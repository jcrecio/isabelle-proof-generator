{"file_name": "/home/qj213/afp-2021-10-22/thys/Safe_OCL/OCL_Normalization.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Safe_OCL", "problem_names": ["lemma any_has_not_element_type:\n  \"element_type \\<tau> \\<sigma> \\<Longrightarrow> \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty \\<Longrightarrow> False\"", "lemma any_has_not_element_type':\n  \"element_type \\<tau> \\<sigma> \\<Longrightarrow> OclVoid[?] \\<le> \\<tau> \\<Longrightarrow> False\"", "lemma\n  normalize_det:\n    \"\\<Gamma> \\<turnstile> expr \\<Rrightarrow> expr\\<^sub>1 \\<Longrightarrow>\n     \\<Gamma> \\<turnstile> expr \\<Rrightarrow> expr\\<^sub>2 \\<Longrightarrow> expr\\<^sub>1 = expr\\<^sub>2\" and\n  normalize_call_det:\n    \"\\<Gamma>_\\<tau> \\<turnstile>\\<^sub>C call \\<Rrightarrow> call\\<^sub>1 \\<Longrightarrow>\n     \\<Gamma>_\\<tau> \\<turnstile>\\<^sub>C call \\<Rrightarrow> call\\<^sub>2 \\<Longrightarrow> call\\<^sub>1 = call\\<^sub>2\" and\n  normalize_expr_list_det:\n    \"\\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys \\<Longrightarrow>\n     \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> zs \\<Longrightarrow> ys = zs\"\n  for \\<Gamma> :: \"('a :: ocl_object_model) type env\"\n  and \\<Gamma>_\\<tau> :: \"('a :: ocl_object_model) type env \\<times> 'a type\"", "lemma nf_typing_det:\n  \"\\<Gamma> \\<turnstile> expr : \\<tau> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile> expr : \\<sigma> \\<Longrightarrow> \\<tau> = \\<sigma>\""], "translations": [["", "lemma any_has_not_element_type:\n  \"element_type \\<tau> \\<sigma> \\<Longrightarrow> \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>element_type \\<tau> \\<sigma>;\n     \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty\\<rbrakk>\n    \\<Longrightarrow> False", "by (erule element_type.cases; auto)"], ["", "lemma any_has_not_element_type':\n  \"element_type \\<tau> \\<sigma> \\<Longrightarrow> OclVoid[?] \\<le> \\<tau> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<tau>\\<rbrakk>\n    \\<Longrightarrow> False", "by (erule element_type.cases; auto)"], ["", "lemma\n  normalize_det:\n    \"\\<Gamma> \\<turnstile> expr \\<Rrightarrow> expr\\<^sub>1 \\<Longrightarrow>\n     \\<Gamma> \\<turnstile> expr \\<Rrightarrow> expr\\<^sub>2 \\<Longrightarrow> expr\\<^sub>1 = expr\\<^sub>2\" and\n  normalize_call_det:\n    \"\\<Gamma>_\\<tau> \\<turnstile>\\<^sub>C call \\<Rrightarrow> call\\<^sub>1 \\<Longrightarrow>\n     \\<Gamma>_\\<tau> \\<turnstile>\\<^sub>C call \\<Rrightarrow> call\\<^sub>2 \\<Longrightarrow> call\\<^sub>1 = call\\<^sub>2\" and\n  normalize_expr_list_det:\n    \"\\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys \\<Longrightarrow>\n     \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> zs \\<Longrightarrow> ys = zs\"\n  for \\<Gamma> :: \"('a :: ocl_object_model) type env\"\n  and \\<Gamma>_\\<tau> :: \"('a :: ocl_object_model) type env \\<times> 'a type\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<Gamma> \\<turnstile> expr \\<Rrightarrow> expr\\<^sub>1;\n      \\<Gamma> \\<turnstile> expr \\<Rrightarrow> expr\\<^sub>2\\<rbrakk>\n     \\<Longrightarrow> expr\\<^sub>1 = expr\\<^sub>2) &&&\n    (\\<lbrakk>\\<Gamma>_\\<tau> \\<turnstile>\\<^sub>C call \\<Rrightarrow>\n              call\\<^sub>1;\n      \\<Gamma>_\\<tau> \\<turnstile>\\<^sub>C call \\<Rrightarrow>\n      call\\<^sub>2\\<rbrakk>\n     \\<Longrightarrow> call\\<^sub>1 = call\\<^sub>2) &&&\n    (\\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n      \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> zs\\<rbrakk>\n     \\<Longrightarrow> ys = zs)", "proof (induct arbitrary: expr\\<^sub>2 and call\\<^sub>2 and zs\n       rule: normalize_normalize_call_normalize_expr_list.inducts)"], ["proof (state)\ngoal (27 subgoals):\n 1. \\<And>\\<Gamma> a expr\\<^sub>2.\n       \\<Gamma> \\<turnstile> Literal a \\<Rrightarrow>\n       expr\\<^sub>2 \\<Longrightarrow>\n       Literal a = expr\\<^sub>2\n 2. \\<And>\\<Gamma> init\\<^sub>1 init\\<^sub>2 v \\<tau> body\\<^sub>1\n       body\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow>\n                init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f\n        \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow> body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f\n           \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> expr.Let v (Some \\<tau>) init\\<^sub>1\n                               body\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.Let v (Some \\<tau>) init\\<^sub>2\n                          body\\<^sub>2 =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> init\\<^sub>1 init\\<^sub>2 \\<tau> v body\\<^sub>1\n       body\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow>\n                init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E init\\<^sub>2 : \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f\n        \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow> body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f\n           \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> expr.Let v None init\\<^sub>1\n                               body\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.Let v (Some \\<tau>) init\\<^sub>2\n                          body\\<^sub>2 =\n                         expr\\<^sub>2\n 4. \\<And>\\<Gamma> v expr\\<^sub>2.\n       \\<Gamma> \\<turnstile> Var v \\<Rrightarrow>\n       expr\\<^sub>2 \\<Longrightarrow>\n       Var v = expr\\<^sub>2\n 5. \\<And>\\<Gamma> a\\<^sub>1 a\\<^sub>2 b\\<^sub>1 b\\<^sub>2 c\\<^sub>1\n       c\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow> a\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           a\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow> b\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           b\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow> c\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           c\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> expr.If a\\<^sub>1 b\\<^sub>1\n                               c\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If a\\<^sub>2 b\\<^sub>2 c\\<^sub>2 =\n                         expr\\<^sub>2\n 6. \\<And>\\<Gamma> \\<tau> op expr\\<^sub>2.\n       \\<Gamma> \\<turnstile> MetaOperationCall \\<tau> op \\<Rrightarrow>\n       expr\\<^sub>2 \\<Longrightarrow>\n       MetaOperationCall \\<tau> op = expr\\<^sub>2\n 7. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        \\<Gamma> \\<turnstile> StaticOperationCall \\<tau> op\n                               params\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> StaticOperationCall \\<tau> op params\\<^sub>2 =\n                         expr\\<^sub>2\n 8. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 DotCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 9. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       src\\<^sub>3 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        OclVoid[?] \\<le> \\<tau>;\n        (\\<Gamma>,\n         to_required_type\n          \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            to_required_type\n             \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n         (to_required_type \\<tau>);\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3 DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2\n 10. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> src\\<^sub>3 \\<sigma>\n        call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n        \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                 src\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            src\\<^sub>2 = expr\\<^sub>2;\n         \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n         \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n         src\\<^sub>3 =\n         OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp)\n          [];\n         \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>;\n         (\\<Gamma>,\n          \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n         call\\<^sub>2;\n         \\<And>call\\<^sub>2'.\n            (\\<Gamma>,\n             \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n            call\\<^sub>2' \\<Longrightarrow>\n            call\\<^sub>2 = call\\<^sub>2';\n         \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                                call\\<^sub>1 \\<Rrightarrow>\n         expr\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                          expr\\<^sub>2\nA total of 27 subgoals...", "case (LiteralN \\<Gamma> a)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile> Literal a \\<Rrightarrow> expr\\<^sub>2\n\ngoal (27 subgoals):\n 1. \\<And>\\<Gamma> a expr\\<^sub>2.\n       \\<Gamma> \\<turnstile> Literal a \\<Rrightarrow>\n       expr\\<^sub>2 \\<Longrightarrow>\n       Literal a = expr\\<^sub>2\n 2. \\<And>\\<Gamma> init\\<^sub>1 init\\<^sub>2 v \\<tau> body\\<^sub>1\n       body\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow>\n                init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f\n        \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow> body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f\n           \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> expr.Let v (Some \\<tau>) init\\<^sub>1\n                               body\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.Let v (Some \\<tau>) init\\<^sub>2\n                          body\\<^sub>2 =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> init\\<^sub>1 init\\<^sub>2 \\<tau> v body\\<^sub>1\n       body\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow>\n                init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E init\\<^sub>2 : \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f\n        \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow> body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f\n           \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> expr.Let v None init\\<^sub>1\n                               body\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.Let v (Some \\<tau>) init\\<^sub>2\n                          body\\<^sub>2 =\n                         expr\\<^sub>2\n 4. \\<And>\\<Gamma> v expr\\<^sub>2.\n       \\<Gamma> \\<turnstile> Var v \\<Rrightarrow>\n       expr\\<^sub>2 \\<Longrightarrow>\n       Var v = expr\\<^sub>2\n 5. \\<And>\\<Gamma> a\\<^sub>1 a\\<^sub>2 b\\<^sub>1 b\\<^sub>2 c\\<^sub>1\n       c\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow> a\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           a\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow> b\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           b\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow> c\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           c\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> expr.If a\\<^sub>1 b\\<^sub>1\n                               c\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If a\\<^sub>2 b\\<^sub>2 c\\<^sub>2 =\n                         expr\\<^sub>2\n 6. \\<And>\\<Gamma> \\<tau> op expr\\<^sub>2.\n       \\<Gamma> \\<turnstile> MetaOperationCall \\<tau> op \\<Rrightarrow>\n       expr\\<^sub>2 \\<Longrightarrow>\n       MetaOperationCall \\<tau> op = expr\\<^sub>2\n 7. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        \\<Gamma> \\<turnstile> StaticOperationCall \\<tau> op\n                               params\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> StaticOperationCall \\<tau> op params\\<^sub>2 =\n                         expr\\<^sub>2\n 8. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 DotCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 9. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       src\\<^sub>3 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        OclVoid[?] \\<le> \\<tau>;\n        (\\<Gamma>,\n         to_required_type\n          \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            to_required_type\n             \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n         (to_required_type \\<tau>);\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3 DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2\n 10. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> src\\<^sub>3 \\<sigma>\n        call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n        \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                 src\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            src\\<^sub>2 = expr\\<^sub>2;\n         \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n         \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n         src\\<^sub>3 =\n         OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp)\n          [];\n         \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>;\n         (\\<Gamma>,\n          \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n         call\\<^sub>2;\n         \\<And>call\\<^sub>2'.\n            (\\<Gamma>,\n             \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n            call\\<^sub>2' \\<Longrightarrow>\n            call\\<^sub>2 = call\\<^sub>2';\n         \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                                call\\<^sub>1 \\<Rrightarrow>\n         expr\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                          expr\\<^sub>2\nA total of 27 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile> Literal a \\<Rrightarrow> expr\\<^sub>2\n\ngoal (1 subgoal):\n 1. Literal a = expr\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  Literal a = expr\\<^sub>2\n\ngoal (26 subgoals):\n 1. \\<And>\\<Gamma> init\\<^sub>1 init\\<^sub>2 v \\<tau> body\\<^sub>1\n       body\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow>\n                init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f\n        \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow> body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f\n           \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> expr.Let v (Some \\<tau>) init\\<^sub>1\n                               body\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.Let v (Some \\<tau>) init\\<^sub>2\n                          body\\<^sub>2 =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> init\\<^sub>1 init\\<^sub>2 \\<tau> v body\\<^sub>1\n       body\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow>\n                init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E init\\<^sub>2 : \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f\n        \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow> body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f\n           \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> expr.Let v None init\\<^sub>1\n                               body\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.Let v (Some \\<tau>) init\\<^sub>2\n                          body\\<^sub>2 =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> v expr\\<^sub>2.\n       \\<Gamma> \\<turnstile> Var v \\<Rrightarrow>\n       expr\\<^sub>2 \\<Longrightarrow>\n       Var v = expr\\<^sub>2\n 4. \\<And>\\<Gamma> a\\<^sub>1 a\\<^sub>2 b\\<^sub>1 b\\<^sub>2 c\\<^sub>1\n       c\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow> a\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           a\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow> b\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           b\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow> c\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           c\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> expr.If a\\<^sub>1 b\\<^sub>1\n                               c\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If a\\<^sub>2 b\\<^sub>2 c\\<^sub>2 =\n                         expr\\<^sub>2\n 5. \\<And>\\<Gamma> \\<tau> op expr\\<^sub>2.\n       \\<Gamma> \\<turnstile> MetaOperationCall \\<tau> op \\<Rrightarrow>\n       expr\\<^sub>2 \\<Longrightarrow>\n       MetaOperationCall \\<tau> op = expr\\<^sub>2\n 6. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        \\<Gamma> \\<turnstile> StaticOperationCall \\<tau> op\n                               params\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> StaticOperationCall \\<tau> op params\\<^sub>2 =\n                         expr\\<^sub>2\n 7. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 DotCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 8. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       src\\<^sub>3 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        OclVoid[?] \\<le> \\<tau>;\n        (\\<Gamma>,\n         to_required_type\n          \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            to_required_type\n             \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n         (to_required_type \\<tau>);\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3 DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2\n 9. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> src\\<^sub>3 \\<sigma>\n       call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        src\\<^sub>3 =\n        OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp) [];\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 10. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu_ call\\<^sub>1\n        call\\<^sub>2 expr\\<^sub>2.\n        \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                 src\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            src\\<^sub>2 = expr\\<^sub>2;\n         \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n         element_type \\<tau> uu_;\n         (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n         call\\<^sub>2;\n         \\<And>call\\<^sub>2'.\n            (\\<Gamma>,\n             \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n            call\\<^sub>2' \\<Longrightarrow>\n            call\\<^sub>2 = call\\<^sub>2';\n         \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                                call\\<^sub>1 \\<Rrightarrow>\n         expr\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                          expr\\<^sub>2\nA total of 26 subgoals...", "next"], ["proof (state)\ngoal (26 subgoals):\n 1. \\<And>\\<Gamma> init\\<^sub>1 init\\<^sub>2 v \\<tau> body\\<^sub>1\n       body\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow>\n                init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f\n        \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow> body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f\n           \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> expr.Let v (Some \\<tau>) init\\<^sub>1\n                               body\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.Let v (Some \\<tau>) init\\<^sub>2\n                          body\\<^sub>2 =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> init\\<^sub>1 init\\<^sub>2 \\<tau> v body\\<^sub>1\n       body\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow>\n                init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E init\\<^sub>2 : \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f\n        \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow> body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f\n           \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> expr.Let v None init\\<^sub>1\n                               body\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.Let v (Some \\<tau>) init\\<^sub>2\n                          body\\<^sub>2 =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> v expr\\<^sub>2.\n       \\<Gamma> \\<turnstile> Var v \\<Rrightarrow>\n       expr\\<^sub>2 \\<Longrightarrow>\n       Var v = expr\\<^sub>2\n 4. \\<And>\\<Gamma> a\\<^sub>1 a\\<^sub>2 b\\<^sub>1 b\\<^sub>2 c\\<^sub>1\n       c\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow> a\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           a\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow> b\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           b\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow> c\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           c\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> expr.If a\\<^sub>1 b\\<^sub>1\n                               c\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If a\\<^sub>2 b\\<^sub>2 c\\<^sub>2 =\n                         expr\\<^sub>2\n 5. \\<And>\\<Gamma> \\<tau> op expr\\<^sub>2.\n       \\<Gamma> \\<turnstile> MetaOperationCall \\<tau> op \\<Rrightarrow>\n       expr\\<^sub>2 \\<Longrightarrow>\n       MetaOperationCall \\<tau> op = expr\\<^sub>2\n 6. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        \\<Gamma> \\<turnstile> StaticOperationCall \\<tau> op\n                               params\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> StaticOperationCall \\<tau> op params\\<^sub>2 =\n                         expr\\<^sub>2\n 7. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 DotCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 8. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       src\\<^sub>3 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        OclVoid[?] \\<le> \\<tau>;\n        (\\<Gamma>,\n         to_required_type\n          \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            to_required_type\n             \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n         (to_required_type \\<tau>);\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3 DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2\n 9. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> src\\<^sub>3 \\<sigma>\n       call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        src\\<^sub>3 =\n        OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp) [];\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 10. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu_ call\\<^sub>1\n        call\\<^sub>2 expr\\<^sub>2.\n        \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                 src\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            src\\<^sub>2 = expr\\<^sub>2;\n         \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n         element_type \\<tau> uu_;\n         (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n         call\\<^sub>2;\n         \\<And>call\\<^sub>2'.\n            (\\<Gamma>,\n             \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n            call\\<^sub>2' \\<Longrightarrow>\n            call\\<^sub>2 = call\\<^sub>2';\n         \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                                call\\<^sub>1 \\<Rrightarrow>\n         expr\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                          expr\\<^sub>2\nA total of 26 subgoals...", "case (ExplicitlyTypedLetN \\<Gamma> init\\<^sub>1 init\\<^sub>2 v \\<tau> body\\<^sub>1 body\\<^sub>2)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow> init\\<^sub>2\n  \\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  init\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma>(v \\<mapsto>\\<^sub>f\n  \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow> body\\<^sub>2\n  \\<Gamma>(v \\<mapsto>\\<^sub>f\n  \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  body\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile> expr.Let v (Some \\<tau>) init\\<^sub>1\n                         body\\<^sub>1 \\<Rrightarrow>\n  expr\\<^sub>2\n\ngoal (26 subgoals):\n 1. \\<And>\\<Gamma> init\\<^sub>1 init\\<^sub>2 v \\<tau> body\\<^sub>1\n       body\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow>\n                init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f\n        \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow> body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f\n           \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> expr.Let v (Some \\<tau>) init\\<^sub>1\n                               body\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.Let v (Some \\<tau>) init\\<^sub>2\n                          body\\<^sub>2 =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> init\\<^sub>1 init\\<^sub>2 \\<tau> v body\\<^sub>1\n       body\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow>\n                init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E init\\<^sub>2 : \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f\n        \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow> body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f\n           \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> expr.Let v None init\\<^sub>1\n                               body\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.Let v (Some \\<tau>) init\\<^sub>2\n                          body\\<^sub>2 =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> v expr\\<^sub>2.\n       \\<Gamma> \\<turnstile> Var v \\<Rrightarrow>\n       expr\\<^sub>2 \\<Longrightarrow>\n       Var v = expr\\<^sub>2\n 4. \\<And>\\<Gamma> a\\<^sub>1 a\\<^sub>2 b\\<^sub>1 b\\<^sub>2 c\\<^sub>1\n       c\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow> a\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           a\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow> b\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           b\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow> c\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           c\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> expr.If a\\<^sub>1 b\\<^sub>1\n                               c\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If a\\<^sub>2 b\\<^sub>2 c\\<^sub>2 =\n                         expr\\<^sub>2\n 5. \\<And>\\<Gamma> \\<tau> op expr\\<^sub>2.\n       \\<Gamma> \\<turnstile> MetaOperationCall \\<tau> op \\<Rrightarrow>\n       expr\\<^sub>2 \\<Longrightarrow>\n       MetaOperationCall \\<tau> op = expr\\<^sub>2\n 6. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        \\<Gamma> \\<turnstile> StaticOperationCall \\<tau> op\n                               params\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> StaticOperationCall \\<tau> op params\\<^sub>2 =\n                         expr\\<^sub>2\n 7. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 DotCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 8. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       src\\<^sub>3 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        OclVoid[?] \\<le> \\<tau>;\n        (\\<Gamma>,\n         to_required_type\n          \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            to_required_type\n             \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n         (to_required_type \\<tau>);\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3 DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2\n 9. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> src\\<^sub>3 \\<sigma>\n       call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        src\\<^sub>3 =\n        OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp) [];\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 10. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu_ call\\<^sub>1\n        call\\<^sub>2 expr\\<^sub>2.\n        \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                 src\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            src\\<^sub>2 = expr\\<^sub>2;\n         \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n         element_type \\<tau> uu_;\n         (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n         call\\<^sub>2;\n         \\<And>call\\<^sub>2'.\n            (\\<Gamma>,\n             \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n            call\\<^sub>2' \\<Longrightarrow>\n            call\\<^sub>2 = call\\<^sub>2';\n         \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                                call\\<^sub>1 \\<Rrightarrow>\n         expr\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                          expr\\<^sub>2\nA total of 26 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow> init\\<^sub>2\n  \\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  init\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma>(v \\<mapsto>\\<^sub>f\n  \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow> body\\<^sub>2\n  \\<Gamma>(v \\<mapsto>\\<^sub>f\n  \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  body\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile> expr.Let v (Some \\<tau>) init\\<^sub>1\n                         body\\<^sub>1 \\<Rrightarrow>\n  expr\\<^sub>2\n\ngoal (1 subgoal):\n 1. expr.Let v (Some \\<tau>) init\\<^sub>2 body\\<^sub>2 = expr\\<^sub>2", "by blast"], ["proof (state)\nthis:\n  expr.Let v (Some \\<tau>) init\\<^sub>2 body\\<^sub>2 = expr\\<^sub>2\n\ngoal (25 subgoals):\n 1. \\<And>\\<Gamma> init\\<^sub>1 init\\<^sub>2 \\<tau> v body\\<^sub>1\n       body\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow>\n                init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E init\\<^sub>2 : \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f\n        \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow> body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f\n           \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> expr.Let v None init\\<^sub>1\n                               body\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.Let v (Some \\<tau>) init\\<^sub>2\n                          body\\<^sub>2 =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> v expr\\<^sub>2.\n       \\<Gamma> \\<turnstile> Var v \\<Rrightarrow>\n       expr\\<^sub>2 \\<Longrightarrow>\n       Var v = expr\\<^sub>2\n 3. \\<And>\\<Gamma> a\\<^sub>1 a\\<^sub>2 b\\<^sub>1 b\\<^sub>2 c\\<^sub>1\n       c\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow> a\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           a\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow> b\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           b\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow> c\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           c\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> expr.If a\\<^sub>1 b\\<^sub>1\n                               c\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If a\\<^sub>2 b\\<^sub>2 c\\<^sub>2 =\n                         expr\\<^sub>2\n 4. \\<And>\\<Gamma> \\<tau> op expr\\<^sub>2.\n       \\<Gamma> \\<turnstile> MetaOperationCall \\<tau> op \\<Rrightarrow>\n       expr\\<^sub>2 \\<Longrightarrow>\n       MetaOperationCall \\<tau> op = expr\\<^sub>2\n 5. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        \\<Gamma> \\<turnstile> StaticOperationCall \\<tau> op\n                               params\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> StaticOperationCall \\<tau> op params\\<^sub>2 =\n                         expr\\<^sub>2\n 6. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 DotCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 7. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       src\\<^sub>3 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        OclVoid[?] \\<le> \\<tau>;\n        (\\<Gamma>,\n         to_required_type\n          \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            to_required_type\n             \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n         (to_required_type \\<tau>);\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3 DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2\n 8. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> src\\<^sub>3 \\<sigma>\n       call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        src\\<^sub>3 =\n        OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp) [];\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 9. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu_ call\\<^sub>1\n       call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 10. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3\n        \\<rho> call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n        \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                 src\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            src\\<^sub>2 = expr\\<^sub>2;\n         \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n         element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n         src\\<^sub>3 =\n         TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n          (to_required_type \\<sigma>);\n         \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>;\n         (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n         call\\<^sub>2;\n         \\<And>call\\<^sub>2'.\n            (\\<Gamma>,\n             \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n            call\\<^sub>2' \\<Longrightarrow>\n            call\\<^sub>2 = call\\<^sub>2';\n         \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                                call\\<^sub>1 \\<Rrightarrow>\n         expr\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                          expr\\<^sub>2\nA total of 25 subgoals...", "next"], ["proof (state)\ngoal (25 subgoals):\n 1. \\<And>\\<Gamma> init\\<^sub>1 init\\<^sub>2 \\<tau> v body\\<^sub>1\n       body\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow>\n                init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E init\\<^sub>2 : \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f\n        \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow> body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f\n           \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> expr.Let v None init\\<^sub>1\n                               body\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.Let v (Some \\<tau>) init\\<^sub>2\n                          body\\<^sub>2 =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> v expr\\<^sub>2.\n       \\<Gamma> \\<turnstile> Var v \\<Rrightarrow>\n       expr\\<^sub>2 \\<Longrightarrow>\n       Var v = expr\\<^sub>2\n 3. \\<And>\\<Gamma> a\\<^sub>1 a\\<^sub>2 b\\<^sub>1 b\\<^sub>2 c\\<^sub>1\n       c\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow> a\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           a\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow> b\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           b\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow> c\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           c\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> expr.If a\\<^sub>1 b\\<^sub>1\n                               c\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If a\\<^sub>2 b\\<^sub>2 c\\<^sub>2 =\n                         expr\\<^sub>2\n 4. \\<And>\\<Gamma> \\<tau> op expr\\<^sub>2.\n       \\<Gamma> \\<turnstile> MetaOperationCall \\<tau> op \\<Rrightarrow>\n       expr\\<^sub>2 \\<Longrightarrow>\n       MetaOperationCall \\<tau> op = expr\\<^sub>2\n 5. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        \\<Gamma> \\<turnstile> StaticOperationCall \\<tau> op\n                               params\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> StaticOperationCall \\<tau> op params\\<^sub>2 =\n                         expr\\<^sub>2\n 6. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 DotCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 7. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       src\\<^sub>3 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        OclVoid[?] \\<le> \\<tau>;\n        (\\<Gamma>,\n         to_required_type\n          \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            to_required_type\n             \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n         (to_required_type \\<tau>);\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3 DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2\n 8. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> src\\<^sub>3 \\<sigma>\n       call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        src\\<^sub>3 =\n        OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp) [];\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 9. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu_ call\\<^sub>1\n       call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 10. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3\n        \\<rho> call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n        \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                 src\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            src\\<^sub>2 = expr\\<^sub>2;\n         \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n         element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n         src\\<^sub>3 =\n         TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n          (to_required_type \\<sigma>);\n         \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>;\n         (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n         call\\<^sub>2;\n         \\<And>call\\<^sub>2'.\n            (\\<Gamma>,\n             \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n            call\\<^sub>2' \\<Longrightarrow>\n            call\\<^sub>2 = call\\<^sub>2';\n         \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                                call\\<^sub>1 \\<Rrightarrow>\n         expr\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                          expr\\<^sub>2\nA total of 25 subgoals...", "case (ImplicitlyTypedLetN \\<Gamma> init\\<^sub>1 init\\<^sub>2 \\<tau> v body\\<^sub>1 body\\<^sub>2)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow> init\\<^sub>2\n  \\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  init\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile>\\<^sub>E init\\<^sub>2 : \\<tau>\n  \\<Gamma>(v \\<mapsto>\\<^sub>f\n  \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow> body\\<^sub>2\n  \\<Gamma>(v \\<mapsto>\\<^sub>f\n  \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  body\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile> expr.Let v None init\\<^sub>1\n                         body\\<^sub>1 \\<Rrightarrow>\n  expr\\<^sub>2\n\ngoal (25 subgoals):\n 1. \\<And>\\<Gamma> init\\<^sub>1 init\\<^sub>2 \\<tau> v body\\<^sub>1\n       body\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow>\n                init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E init\\<^sub>2 : \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f\n        \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow> body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f\n           \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> expr.Let v None init\\<^sub>1\n                               body\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.Let v (Some \\<tau>) init\\<^sub>2\n                          body\\<^sub>2 =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> v expr\\<^sub>2.\n       \\<Gamma> \\<turnstile> Var v \\<Rrightarrow>\n       expr\\<^sub>2 \\<Longrightarrow>\n       Var v = expr\\<^sub>2\n 3. \\<And>\\<Gamma> a\\<^sub>1 a\\<^sub>2 b\\<^sub>1 b\\<^sub>2 c\\<^sub>1\n       c\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow> a\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           a\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow> b\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           b\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow> c\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           c\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> expr.If a\\<^sub>1 b\\<^sub>1\n                               c\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If a\\<^sub>2 b\\<^sub>2 c\\<^sub>2 =\n                         expr\\<^sub>2\n 4. \\<And>\\<Gamma> \\<tau> op expr\\<^sub>2.\n       \\<Gamma> \\<turnstile> MetaOperationCall \\<tau> op \\<Rrightarrow>\n       expr\\<^sub>2 \\<Longrightarrow>\n       MetaOperationCall \\<tau> op = expr\\<^sub>2\n 5. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        \\<Gamma> \\<turnstile> StaticOperationCall \\<tau> op\n                               params\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> StaticOperationCall \\<tau> op params\\<^sub>2 =\n                         expr\\<^sub>2\n 6. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 DotCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 7. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       src\\<^sub>3 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        OclVoid[?] \\<le> \\<tau>;\n        (\\<Gamma>,\n         to_required_type\n          \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            to_required_type\n             \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n         (to_required_type \\<tau>);\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3 DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2\n 8. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> src\\<^sub>3 \\<sigma>\n       call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        src\\<^sub>3 =\n        OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp) [];\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 9. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu_ call\\<^sub>1\n       call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 10. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3\n        \\<rho> call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n        \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                 src\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            src\\<^sub>2 = expr\\<^sub>2;\n         \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n         element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n         src\\<^sub>3 =\n         TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n          (to_required_type \\<sigma>);\n         \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>;\n         (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n         call\\<^sub>2;\n         \\<And>call\\<^sub>2'.\n            (\\<Gamma>,\n             \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n            call\\<^sub>2' \\<Longrightarrow>\n            call\\<^sub>2 = call\\<^sub>2';\n         \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                                call\\<^sub>1 \\<Rrightarrow>\n         expr\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                          expr\\<^sub>2\nA total of 25 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow> init\\<^sub>2\n  \\<Gamma> \\<turnstile> init\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  init\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile>\\<^sub>E init\\<^sub>2 : \\<tau>\n  \\<Gamma>(v \\<mapsto>\\<^sub>f\n  \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow> body\\<^sub>2\n  \\<Gamma>(v \\<mapsto>\\<^sub>f\n  \\<tau>) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  body\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile> expr.Let v None init\\<^sub>1\n                         body\\<^sub>1 \\<Rrightarrow>\n  expr\\<^sub>2\n\ngoal (1 subgoal):\n 1. expr.Let v (Some \\<tau>) init\\<^sub>2 body\\<^sub>2 = expr\\<^sub>2", "by (metis (mono_tags, lifting) LetNE option.distinct(1) typing_det)"], ["proof (state)\nthis:\n  expr.Let v (Some \\<tau>) init\\<^sub>2 body\\<^sub>2 = expr\\<^sub>2\n\ngoal (24 subgoals):\n 1. \\<And>\\<Gamma> v expr\\<^sub>2.\n       \\<Gamma> \\<turnstile> Var v \\<Rrightarrow>\n       expr\\<^sub>2 \\<Longrightarrow>\n       Var v = expr\\<^sub>2\n 2. \\<And>\\<Gamma> a\\<^sub>1 a\\<^sub>2 b\\<^sub>1 b\\<^sub>2 c\\<^sub>1\n       c\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow> a\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           a\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow> b\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           b\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow> c\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           c\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> expr.If a\\<^sub>1 b\\<^sub>1\n                               c\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If a\\<^sub>2 b\\<^sub>2 c\\<^sub>2 =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> \\<tau> op expr\\<^sub>2.\n       \\<Gamma> \\<turnstile> MetaOperationCall \\<tau> op \\<Rrightarrow>\n       expr\\<^sub>2 \\<Longrightarrow>\n       MetaOperationCall \\<tau> op = expr\\<^sub>2\n 4. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        \\<Gamma> \\<turnstile> StaticOperationCall \\<tau> op\n                               params\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> StaticOperationCall \\<tau> op params\\<^sub>2 =\n                         expr\\<^sub>2\n 5. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 DotCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 6. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       src\\<^sub>3 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        OclVoid[?] \\<le> \\<tau>;\n        (\\<Gamma>,\n         to_required_type\n          \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            to_required_type\n             \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n         (to_required_type \\<tau>);\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3 DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2\n 7. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> src\\<^sub>3 \\<sigma>\n       call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        src\\<^sub>3 =\n        OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp) [];\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 8. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu_ call\\<^sub>1\n       call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 9. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3\n       \\<rho> call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n         (to_required_type \\<sigma>);\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 10. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1\n        call\\<^sub>2 it expr\\<^sub>2.\n        \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                 src\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            src\\<^sub>2 = expr\\<^sub>2;\n         \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n         element_type \\<tau> \\<sigma>;\n         (\\<Gamma>,\n          \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n         call\\<^sub>2;\n         \\<And>call\\<^sub>2'.\n            (\\<Gamma>,\n             \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n            call\\<^sub>2' \\<Longrightarrow>\n            call\\<^sub>2 = call\\<^sub>2';\n         it = new_vname \\<Gamma>;\n         \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                                call\\<^sub>1 \\<Rrightarrow>\n         expr\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                           (Some \\<sigma>)\n                           (Call (Var it) DotCall call\\<^sub>2) =\n                          expr\\<^sub>2\nA total of 24 subgoals...", "next"], ["proof (state)\ngoal (24 subgoals):\n 1. \\<And>\\<Gamma> v expr\\<^sub>2.\n       \\<Gamma> \\<turnstile> Var v \\<Rrightarrow>\n       expr\\<^sub>2 \\<Longrightarrow>\n       Var v = expr\\<^sub>2\n 2. \\<And>\\<Gamma> a\\<^sub>1 a\\<^sub>2 b\\<^sub>1 b\\<^sub>2 c\\<^sub>1\n       c\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow> a\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           a\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow> b\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           b\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow> c\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           c\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> expr.If a\\<^sub>1 b\\<^sub>1\n                               c\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If a\\<^sub>2 b\\<^sub>2 c\\<^sub>2 =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> \\<tau> op expr\\<^sub>2.\n       \\<Gamma> \\<turnstile> MetaOperationCall \\<tau> op \\<Rrightarrow>\n       expr\\<^sub>2 \\<Longrightarrow>\n       MetaOperationCall \\<tau> op = expr\\<^sub>2\n 4. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        \\<Gamma> \\<turnstile> StaticOperationCall \\<tau> op\n                               params\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> StaticOperationCall \\<tau> op params\\<^sub>2 =\n                         expr\\<^sub>2\n 5. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 DotCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 6. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       src\\<^sub>3 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        OclVoid[?] \\<le> \\<tau>;\n        (\\<Gamma>,\n         to_required_type\n          \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            to_required_type\n             \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n         (to_required_type \\<tau>);\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3 DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2\n 7. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> src\\<^sub>3 \\<sigma>\n       call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        src\\<^sub>3 =\n        OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp) [];\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 8. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu_ call\\<^sub>1\n       call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 9. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3\n       \\<rho> call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n         (to_required_type \\<sigma>);\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 10. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1\n        call\\<^sub>2 it expr\\<^sub>2.\n        \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                 src\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            src\\<^sub>2 = expr\\<^sub>2;\n         \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n         element_type \\<tau> \\<sigma>;\n         (\\<Gamma>,\n          \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n         call\\<^sub>2;\n         \\<And>call\\<^sub>2'.\n            (\\<Gamma>,\n             \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n            call\\<^sub>2' \\<Longrightarrow>\n            call\\<^sub>2 = call\\<^sub>2';\n         it = new_vname \\<Gamma>;\n         \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                                call\\<^sub>1 \\<Rrightarrow>\n         expr\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                           (Some \\<sigma>)\n                           (Call (Var it) DotCall call\\<^sub>2) =\n                          expr\\<^sub>2\nA total of 24 subgoals...", "case (VarN \\<Gamma> v)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile> Var v \\<Rrightarrow> expr\\<^sub>2\n\ngoal (24 subgoals):\n 1. \\<And>\\<Gamma> v expr\\<^sub>2.\n       \\<Gamma> \\<turnstile> Var v \\<Rrightarrow>\n       expr\\<^sub>2 \\<Longrightarrow>\n       Var v = expr\\<^sub>2\n 2. \\<And>\\<Gamma> a\\<^sub>1 a\\<^sub>2 b\\<^sub>1 b\\<^sub>2 c\\<^sub>1\n       c\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow> a\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           a\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow> b\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           b\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow> c\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           c\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> expr.If a\\<^sub>1 b\\<^sub>1\n                               c\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If a\\<^sub>2 b\\<^sub>2 c\\<^sub>2 =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> \\<tau> op expr\\<^sub>2.\n       \\<Gamma> \\<turnstile> MetaOperationCall \\<tau> op \\<Rrightarrow>\n       expr\\<^sub>2 \\<Longrightarrow>\n       MetaOperationCall \\<tau> op = expr\\<^sub>2\n 4. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        \\<Gamma> \\<turnstile> StaticOperationCall \\<tau> op\n                               params\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> StaticOperationCall \\<tau> op params\\<^sub>2 =\n                         expr\\<^sub>2\n 5. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 DotCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 6. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       src\\<^sub>3 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        OclVoid[?] \\<le> \\<tau>;\n        (\\<Gamma>,\n         to_required_type\n          \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            to_required_type\n             \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n         (to_required_type \\<tau>);\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3 DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2\n 7. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> src\\<^sub>3 \\<sigma>\n       call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        src\\<^sub>3 =\n        OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp) [];\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 8. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu_ call\\<^sub>1\n       call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 9. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3\n       \\<rho> call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n         (to_required_type \\<sigma>);\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 10. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1\n        call\\<^sub>2 it expr\\<^sub>2.\n        \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                 src\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            src\\<^sub>2 = expr\\<^sub>2;\n         \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n         element_type \\<tau> \\<sigma>;\n         (\\<Gamma>,\n          \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n         call\\<^sub>2;\n         \\<And>call\\<^sub>2'.\n            (\\<Gamma>,\n             \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n            call\\<^sub>2' \\<Longrightarrow>\n            call\\<^sub>2 = call\\<^sub>2';\n         it = new_vname \\<Gamma>;\n         \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                                call\\<^sub>1 \\<Rrightarrow>\n         expr\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                           (Some \\<sigma>)\n                           (Call (Var it) DotCall call\\<^sub>2) =\n                          expr\\<^sub>2\nA total of 24 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile> Var v \\<Rrightarrow> expr\\<^sub>2\n\ngoal (1 subgoal):\n 1. Var v = expr\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  Var v = expr\\<^sub>2\n\ngoal (23 subgoals):\n 1. \\<And>\\<Gamma> a\\<^sub>1 a\\<^sub>2 b\\<^sub>1 b\\<^sub>2 c\\<^sub>1\n       c\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow> a\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           a\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow> b\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           b\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow> c\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           c\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> expr.If a\\<^sub>1 b\\<^sub>1\n                               c\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If a\\<^sub>2 b\\<^sub>2 c\\<^sub>2 =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> \\<tau> op expr\\<^sub>2.\n       \\<Gamma> \\<turnstile> MetaOperationCall \\<tau> op \\<Rrightarrow>\n       expr\\<^sub>2 \\<Longrightarrow>\n       MetaOperationCall \\<tau> op = expr\\<^sub>2\n 3. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        \\<Gamma> \\<turnstile> StaticOperationCall \\<tau> op\n                               params\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> StaticOperationCall \\<tau> op params\\<^sub>2 =\n                         expr\\<^sub>2\n 4. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 DotCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 5. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       src\\<^sub>3 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        OclVoid[?] \\<le> \\<tau>;\n        (\\<Gamma>,\n         to_required_type\n          \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            to_required_type\n             \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n         (to_required_type \\<tau>);\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3 DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2\n 6. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> src\\<^sub>3 \\<sigma>\n       call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        src\\<^sub>3 =\n        OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp) [];\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 7. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu_ call\\<^sub>1\n       call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 8. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3\n       \\<rho> call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n         (to_required_type \\<sigma>);\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 9. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1\n       call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 10. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> \\<rho>\n        src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it expr\\<^sub>2.\n        \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                 src\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            src\\<^sub>2 = expr\\<^sub>2;\n         \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n         element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n         \\<rho> = to_required_type \\<sigma>;\n         src\\<^sub>3 =\n         TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp \\<rho>;\n         (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n         call\\<^sub>2;\n         \\<And>call\\<^sub>2'.\n            (\\<Gamma>,\n             \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n            call\\<^sub>2' \\<Longrightarrow>\n            call\\<^sub>2 = call\\<^sub>2';\n         it = new_vname \\<Gamma>;\n         \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                                call\\<^sub>1 \\<Rrightarrow>\n         expr\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> CollectIteratorCall src\\<^sub>3 ArrowCall [it]\n                           (Some \\<rho>)\n                           (Call (Var it) DotCall call\\<^sub>2) =\n                          expr\\<^sub>2\nA total of 23 subgoals...", "next"], ["proof (state)\ngoal (23 subgoals):\n 1. \\<And>\\<Gamma> a\\<^sub>1 a\\<^sub>2 b\\<^sub>1 b\\<^sub>2 c\\<^sub>1\n       c\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow> a\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           a\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow> b\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           b\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow> c\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           c\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> expr.If a\\<^sub>1 b\\<^sub>1\n                               c\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If a\\<^sub>2 b\\<^sub>2 c\\<^sub>2 =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> \\<tau> op expr\\<^sub>2.\n       \\<Gamma> \\<turnstile> MetaOperationCall \\<tau> op \\<Rrightarrow>\n       expr\\<^sub>2 \\<Longrightarrow>\n       MetaOperationCall \\<tau> op = expr\\<^sub>2\n 3. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        \\<Gamma> \\<turnstile> StaticOperationCall \\<tau> op\n                               params\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> StaticOperationCall \\<tau> op params\\<^sub>2 =\n                         expr\\<^sub>2\n 4. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 DotCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 5. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       src\\<^sub>3 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        OclVoid[?] \\<le> \\<tau>;\n        (\\<Gamma>,\n         to_required_type\n          \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            to_required_type\n             \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n         (to_required_type \\<tau>);\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3 DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2\n 6. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> src\\<^sub>3 \\<sigma>\n       call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        src\\<^sub>3 =\n        OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp) [];\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 7. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu_ call\\<^sub>1\n       call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 8. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3\n       \\<rho> call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n         (to_required_type \\<sigma>);\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 9. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1\n       call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 10. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> \\<rho>\n        src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it expr\\<^sub>2.\n        \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                 src\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            src\\<^sub>2 = expr\\<^sub>2;\n         \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n         element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n         \\<rho> = to_required_type \\<sigma>;\n         src\\<^sub>3 =\n         TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp \\<rho>;\n         (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n         call\\<^sub>2;\n         \\<And>call\\<^sub>2'.\n            (\\<Gamma>,\n             \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n            call\\<^sub>2' \\<Longrightarrow>\n            call\\<^sub>2 = call\\<^sub>2';\n         it = new_vname \\<Gamma>;\n         \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                                call\\<^sub>1 \\<Rrightarrow>\n         expr\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> CollectIteratorCall src\\<^sub>3 ArrowCall [it]\n                           (Some \\<rho>)\n                           (Call (Var it) DotCall call\\<^sub>2) =\n                          expr\\<^sub>2\nA total of 23 subgoals...", "case (IfN \\<Gamma> a\\<^sub>1 a\\<^sub>2 b\\<^sub>1 b\\<^sub>2 c\\<^sub>1 c\\<^sub>2)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow> a\\<^sub>2\n  \\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  a\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow> b\\<^sub>2\n  \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  b\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow> c\\<^sub>2\n  \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  c\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile> expr.If a\\<^sub>1 b\\<^sub>1 c\\<^sub>1 \\<Rrightarrow>\n  expr\\<^sub>2\n\ngoal (23 subgoals):\n 1. \\<And>\\<Gamma> a\\<^sub>1 a\\<^sub>2 b\\<^sub>1 b\\<^sub>2 c\\<^sub>1\n       c\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow> a\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           a\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow> b\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           b\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow> c\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           c\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile> expr.If a\\<^sub>1 b\\<^sub>1\n                               c\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If a\\<^sub>2 b\\<^sub>2 c\\<^sub>2 =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> \\<tau> op expr\\<^sub>2.\n       \\<Gamma> \\<turnstile> MetaOperationCall \\<tau> op \\<Rrightarrow>\n       expr\\<^sub>2 \\<Longrightarrow>\n       MetaOperationCall \\<tau> op = expr\\<^sub>2\n 3. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        \\<Gamma> \\<turnstile> StaticOperationCall \\<tau> op\n                               params\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> StaticOperationCall \\<tau> op params\\<^sub>2 =\n                         expr\\<^sub>2\n 4. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 DotCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 5. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       src\\<^sub>3 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        OclVoid[?] \\<le> \\<tau>;\n        (\\<Gamma>,\n         to_required_type\n          \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            to_required_type\n             \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n         (to_required_type \\<tau>);\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3 DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2\n 6. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> src\\<^sub>3 \\<sigma>\n       call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        src\\<^sub>3 =\n        OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp) [];\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 7. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu_ call\\<^sub>1\n       call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 8. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3\n       \\<rho> call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n         (to_required_type \\<sigma>);\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 9. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1\n       call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 10. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> \\<rho>\n        src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it expr\\<^sub>2.\n        \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                 src\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            src\\<^sub>2 = expr\\<^sub>2;\n         \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n         element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n         \\<rho> = to_required_type \\<sigma>;\n         src\\<^sub>3 =\n         TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp \\<rho>;\n         (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n         call\\<^sub>2;\n         \\<And>call\\<^sub>2'.\n            (\\<Gamma>,\n             \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n            call\\<^sub>2' \\<Longrightarrow>\n            call\\<^sub>2 = call\\<^sub>2';\n         it = new_vname \\<Gamma>;\n         \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                                call\\<^sub>1 \\<Rrightarrow>\n         expr\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> CollectIteratorCall src\\<^sub>3 ArrowCall [it]\n                           (Some \\<rho>)\n                           (Call (Var it) DotCall call\\<^sub>2) =\n                          expr\\<^sub>2\nA total of 23 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow> a\\<^sub>2\n  \\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  a\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow> b\\<^sub>2\n  \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  b\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow> c\\<^sub>2\n  \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  c\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile> expr.If a\\<^sub>1 b\\<^sub>1 c\\<^sub>1 \\<Rrightarrow>\n  expr\\<^sub>2\n\ngoal (1 subgoal):\n 1. expr.If a\\<^sub>2 b\\<^sub>2 c\\<^sub>2 = expr\\<^sub>2", "apply (insert IfN.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile> expr.If a\\<^sub>1 b\\<^sub>1\n                           c\\<^sub>1 \\<Rrightarrow>\n    expr\\<^sub>2 \\<Longrightarrow>\n    expr.If a\\<^sub>2 b\\<^sub>2 c\\<^sub>2 = expr\\<^sub>2", "apply (erule IfNE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a\\<^sub>2' b\\<^sub>2' c\\<^sub>2'.\n       \\<lbrakk>expr\\<^sub>2 = expr.If a\\<^sub>2' b\\<^sub>2' c\\<^sub>2';\n        \\<Gamma> \\<turnstile> a\\<^sub>1 \\<Rrightarrow> a\\<^sub>2';\n        \\<Gamma> \\<turnstile> b\\<^sub>1 \\<Rrightarrow> b\\<^sub>2';\n        \\<Gamma> \\<turnstile> c\\<^sub>1 \\<Rrightarrow> c\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> expr.If a\\<^sub>2 b\\<^sub>2 c\\<^sub>2 =\n                         expr\\<^sub>2", "by (simp add: IfN.hyps)"], ["proof (state)\nthis:\n  expr.If a\\<^sub>2 b\\<^sub>2 c\\<^sub>2 = expr\\<^sub>2\n\ngoal (22 subgoals):\n 1. \\<And>\\<Gamma> \\<tau> op expr\\<^sub>2.\n       \\<Gamma> \\<turnstile> MetaOperationCall \\<tau> op \\<Rrightarrow>\n       expr\\<^sub>2 \\<Longrightarrow>\n       MetaOperationCall \\<tau> op = expr\\<^sub>2\n 2. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        \\<Gamma> \\<turnstile> StaticOperationCall \\<tau> op\n                               params\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> StaticOperationCall \\<tau> op params\\<^sub>2 =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 DotCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 4. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       src\\<^sub>3 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        OclVoid[?] \\<le> \\<tau>;\n        (\\<Gamma>,\n         to_required_type\n          \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            to_required_type\n             \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n         (to_required_type \\<tau>);\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3 DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2\n 5. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> src\\<^sub>3 \\<sigma>\n       call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        src\\<^sub>3 =\n        OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp) [];\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 6. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu_ call\\<^sub>1\n       call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 7. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3\n       \\<rho> call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n         (to_required_type \\<sigma>);\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 8. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1\n       call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 9. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> \\<rho>\n       src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        \\<rho> = to_required_type \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>3 ArrowCall [it]\n                          (Some \\<rho>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 10. \\<And>\\<Gamma> \\<tau> op ty call\\<^sub>2.\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n        call\\<^sub>2 \\<Longrightarrow>\n        TypeOperation op ty = call\\<^sub>2\nA total of 22 subgoals...", "next"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>\\<Gamma> \\<tau> op expr\\<^sub>2.\n       \\<Gamma> \\<turnstile> MetaOperationCall \\<tau> op \\<Rrightarrow>\n       expr\\<^sub>2 \\<Longrightarrow>\n       MetaOperationCall \\<tau> op = expr\\<^sub>2\n 2. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        \\<Gamma> \\<turnstile> StaticOperationCall \\<tau> op\n                               params\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> StaticOperationCall \\<tau> op params\\<^sub>2 =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 DotCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 4. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       src\\<^sub>3 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        OclVoid[?] \\<le> \\<tau>;\n        (\\<Gamma>,\n         to_required_type\n          \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            to_required_type\n             \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n         (to_required_type \\<tau>);\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3 DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2\n 5. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> src\\<^sub>3 \\<sigma>\n       call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        src\\<^sub>3 =\n        OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp) [];\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 6. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu_ call\\<^sub>1\n       call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 7. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3\n       \\<rho> call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n         (to_required_type \\<sigma>);\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 8. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1\n       call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 9. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> \\<rho>\n       src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        \\<rho> = to_required_type \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>3 ArrowCall [it]\n                          (Some \\<rho>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 10. \\<And>\\<Gamma> \\<tau> op ty call\\<^sub>2.\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n        call\\<^sub>2 \\<Longrightarrow>\n        TypeOperation op ty = call\\<^sub>2\nA total of 22 subgoals...", "case (MetaOperationCallN \\<Gamma> \\<tau> op)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile> MetaOperationCall \\<tau> op \\<Rrightarrow>\n  expr\\<^sub>2\n\ngoal (22 subgoals):\n 1. \\<And>\\<Gamma> \\<tau> op expr\\<^sub>2.\n       \\<Gamma> \\<turnstile> MetaOperationCall \\<tau> op \\<Rrightarrow>\n       expr\\<^sub>2 \\<Longrightarrow>\n       MetaOperationCall \\<tau> op = expr\\<^sub>2\n 2. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        \\<Gamma> \\<turnstile> StaticOperationCall \\<tau> op\n                               params\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> StaticOperationCall \\<tau> op params\\<^sub>2 =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 DotCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 4. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       src\\<^sub>3 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        OclVoid[?] \\<le> \\<tau>;\n        (\\<Gamma>,\n         to_required_type\n          \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            to_required_type\n             \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n         (to_required_type \\<tau>);\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3 DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2\n 5. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> src\\<^sub>3 \\<sigma>\n       call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        src\\<^sub>3 =\n        OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp) [];\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 6. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu_ call\\<^sub>1\n       call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 7. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3\n       \\<rho> call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n         (to_required_type \\<sigma>);\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 8. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1\n       call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 9. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> \\<rho>\n       src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        \\<rho> = to_required_type \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>3 ArrowCall [it]\n                          (Some \\<rho>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 10. \\<And>\\<Gamma> \\<tau> op ty call\\<^sub>2.\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n        call\\<^sub>2 \\<Longrightarrow>\n        TypeOperation op ty = call\\<^sub>2\nA total of 22 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile> MetaOperationCall \\<tau> op \\<Rrightarrow>\n  expr\\<^sub>2\n\ngoal (1 subgoal):\n 1. MetaOperationCall \\<tau> op = expr\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  MetaOperationCall \\<tau> op = expr\\<^sub>2\n\ngoal (21 subgoals):\n 1. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        \\<Gamma> \\<turnstile> StaticOperationCall \\<tau> op\n                               params\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> StaticOperationCall \\<tau> op params\\<^sub>2 =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 DotCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       src\\<^sub>3 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        OclVoid[?] \\<le> \\<tau>;\n        (\\<Gamma>,\n         to_required_type\n          \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            to_required_type\n             \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n         (to_required_type \\<tau>);\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3 DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2\n 4. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> src\\<^sub>3 \\<sigma>\n       call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        src\\<^sub>3 =\n        OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp) [];\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 5. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu_ call\\<^sub>1\n       call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 6. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3\n       \\<rho> call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n         (to_required_type \\<sigma>);\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 7. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1\n       call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 8. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> \\<rho>\n       src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        \\<rho> = to_required_type \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>3 ArrowCall [it]\n                          (Some \\<rho>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 9. \\<And>\\<Gamma> \\<tau> op ty call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TypeOperation op ty = call\\<^sub>2\n 10. \\<And>\\<Gamma> \\<tau> attr call\\<^sub>2.\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n        call\\<^sub>2 \\<Longrightarrow>\n        Attribute attr = call\\<^sub>2\nA total of 21 subgoals...", "next"], ["proof (state)\ngoal (21 subgoals):\n 1. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        \\<Gamma> \\<turnstile> StaticOperationCall \\<tau> op\n                               params\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> StaticOperationCall \\<tau> op params\\<^sub>2 =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 DotCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       src\\<^sub>3 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        OclVoid[?] \\<le> \\<tau>;\n        (\\<Gamma>,\n         to_required_type\n          \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            to_required_type\n             \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n         (to_required_type \\<tau>);\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3 DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2\n 4. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> src\\<^sub>3 \\<sigma>\n       call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        src\\<^sub>3 =\n        OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp) [];\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 5. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu_ call\\<^sub>1\n       call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 6. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3\n       \\<rho> call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n         (to_required_type \\<sigma>);\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 7. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1\n       call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 8. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> \\<rho>\n       src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        \\<rho> = to_required_type \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>3 ArrowCall [it]\n                          (Some \\<rho>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 9. \\<And>\\<Gamma> \\<tau> op ty call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TypeOperation op ty = call\\<^sub>2\n 10. \\<And>\\<Gamma> \\<tau> attr call\\<^sub>2.\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n        call\\<^sub>2 \\<Longrightarrow>\n        Attribute attr = call\\<^sub>2\nA total of 21 subgoals...", "case (StaticOperationCallN \\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow> params\\<^sub>2\n  \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n  ?zs \\<Longrightarrow>\n  params\\<^sub>2 = ?zs\n  \\<Gamma> \\<turnstile> StaticOperationCall \\<tau> op\n                         params\\<^sub>1 \\<Rrightarrow>\n  expr\\<^sub>2\n\ngoal (21 subgoals):\n 1. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        \\<Gamma> \\<turnstile> StaticOperationCall \\<tau> op\n                               params\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> StaticOperationCall \\<tau> op params\\<^sub>2 =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 DotCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       src\\<^sub>3 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        OclVoid[?] \\<le> \\<tau>;\n        (\\<Gamma>,\n         to_required_type\n          \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            to_required_type\n             \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n         (to_required_type \\<tau>);\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3 DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2\n 4. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> src\\<^sub>3 \\<sigma>\n       call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        src\\<^sub>3 =\n        OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp) [];\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 5. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu_ call\\<^sub>1\n       call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 6. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3\n       \\<rho> call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n         (to_required_type \\<sigma>);\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 7. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1\n       call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 8. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> \\<rho>\n       src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        \\<rho> = to_required_type \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>3 ArrowCall [it]\n                          (Some \\<rho>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 9. \\<And>\\<Gamma> \\<tau> op ty call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TypeOperation op ty = call\\<^sub>2\n 10. \\<And>\\<Gamma> \\<tau> attr call\\<^sub>2.\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n        call\\<^sub>2 \\<Longrightarrow>\n        Attribute attr = call\\<^sub>2\nA total of 21 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow> params\\<^sub>2\n  \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n  ?zs \\<Longrightarrow>\n  params\\<^sub>2 = ?zs\n  \\<Gamma> \\<turnstile> StaticOperationCall \\<tau> op\n                         params\\<^sub>1 \\<Rrightarrow>\n  expr\\<^sub>2\n\ngoal (1 subgoal):\n 1. StaticOperationCall \\<tau> op params\\<^sub>2 = expr\\<^sub>2", "by blast"], ["proof (state)\nthis:\n  StaticOperationCall \\<tau> op params\\<^sub>2 = expr\\<^sub>2\n\ngoal (20 subgoals):\n 1. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 DotCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       src\\<^sub>3 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        OclVoid[?] \\<le> \\<tau>;\n        (\\<Gamma>,\n         to_required_type\n          \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            to_required_type\n             \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n         (to_required_type \\<tau>);\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3 DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> src\\<^sub>3 \\<sigma>\n       call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        src\\<^sub>3 =\n        OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp) [];\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 4. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu_ call\\<^sub>1\n       call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 5. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3\n       \\<rho> call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n         (to_required_type \\<sigma>);\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 6. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1\n       call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 7. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> \\<rho>\n       src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        \\<rho> = to_required_type \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>3 ArrowCall [it]\n                          (Some \\<rho>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 8. \\<And>\\<Gamma> \\<tau> op ty call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TypeOperation op ty = call\\<^sub>2\n 9. \\<And>\\<Gamma> \\<tau> attr call\\<^sub>2.\n       (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       Attribute attr = call\\<^sub>2\n 10. \\<And>\\<Gamma> \\<tau> role from call\\<^sub>2.\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role\n from \\<Rrightarrow>\n        call\\<^sub>2 \\<Longrightarrow>\n        AssociationEnd role from = call\\<^sub>2\nA total of 20 subgoals...", "next"], ["proof (state)\ngoal (20 subgoals):\n 1. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 DotCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       src\\<^sub>3 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        OclVoid[?] \\<le> \\<tau>;\n        (\\<Gamma>,\n         to_required_type\n          \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            to_required_type\n             \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n         (to_required_type \\<tau>);\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3 DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> src\\<^sub>3 \\<sigma>\n       call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        src\\<^sub>3 =\n        OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp) [];\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 4. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu_ call\\<^sub>1\n       call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 5. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3\n       \\<rho> call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n         (to_required_type \\<sigma>);\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 6. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1\n       call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 7. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> \\<rho>\n       src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        \\<rho> = to_required_type \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>3 ArrowCall [it]\n                          (Some \\<rho>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 8. \\<And>\\<Gamma> \\<tau> op ty call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TypeOperation op ty = call\\<^sub>2\n 9. \\<And>\\<Gamma> \\<tau> attr call\\<^sub>2.\n       (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       Attribute attr = call\\<^sub>2\n 10. \\<And>\\<Gamma> \\<tau> role from call\\<^sub>2.\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role\n from \\<Rrightarrow>\n        call\\<^sub>2 \\<Longrightarrow>\n        AssociationEnd role from = call\\<^sub>2\nA total of 20 subgoals...", "case (OclAnyDotCallN \\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  src\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>\n  \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty\n  (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  call\\<^sub>2\n  (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  ?call\\<^sub>2 \\<Longrightarrow>\n  call\\<^sub>2 = ?call\\<^sub>2\n  \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall call\\<^sub>1 \\<Rrightarrow>\n  expr\\<^sub>2\n\ngoal (20 subgoals):\n 1. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 DotCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       src\\<^sub>3 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        OclVoid[?] \\<le> \\<tau>;\n        (\\<Gamma>,\n         to_required_type\n          \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            to_required_type\n             \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n         (to_required_type \\<tau>);\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3 DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> src\\<^sub>3 \\<sigma>\n       call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        src\\<^sub>3 =\n        OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp) [];\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 4. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu_ call\\<^sub>1\n       call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 5. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3\n       \\<rho> call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n         (to_required_type \\<sigma>);\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 6. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1\n       call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 7. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> \\<rho>\n       src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        \\<rho> = to_required_type \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>3 ArrowCall [it]\n                          (Some \\<rho>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 8. \\<And>\\<Gamma> \\<tau> op ty call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TypeOperation op ty = call\\<^sub>2\n 9. \\<And>\\<Gamma> \\<tau> attr call\\<^sub>2.\n       (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       Attribute attr = call\\<^sub>2\n 10. \\<And>\\<Gamma> \\<tau> role from call\\<^sub>2.\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role\n from \\<Rrightarrow>\n        call\\<^sub>2 \\<Longrightarrow>\n        AssociationEnd role from = call\\<^sub>2\nA total of 20 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Call src\\<^sub>2 DotCall call\\<^sub>2 = expr\\<^sub>2", "apply (insert OclAnyDotCallN.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                           call\\<^sub>1 \\<Rrightarrow>\n    expr\\<^sub>2 \\<Longrightarrow>\n    Call src\\<^sub>2 DotCall call\\<^sub>2 = expr\\<^sub>2", "apply (erule DotCallNE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>src\\<^sub>2' \\<tau> call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 = Call src\\<^sub>2' DotCall call\\<^sub>2;\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2';\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2' : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 DotCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 2. \\<And>src\\<^sub>2' \\<tau> \\<sigma> call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 =\n                CollectIteratorCall src\\<^sub>2' ArrowCall\n                 [new_vname \\<Gamma>] (Some \\<sigma>)\n                 (Call (Var (new_vname \\<Gamma>)) DotCall call\\<^sub>2);\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2';\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2' : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 DotCall call\\<^sub>2 =\n                         expr\\<^sub>2", "using OclAnyDotCallN.hyps typing_det"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  src\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>\n  \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty\n  (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  call\\<^sub>2\n  (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  ?call\\<^sub>2 \\<Longrightarrow>\n  call\\<^sub>2 = ?call\\<^sub>2\n  \\<lbrakk>?\\<Gamma> \\<turnstile>\\<^sub>E ?expr : ?\\<tau>;\n   ?\\<Gamma> \\<turnstile>\\<^sub>E ?expr : ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> ?\\<tau> = ?\\<sigma>\n\ngoal (2 subgoals):\n 1. \\<And>src\\<^sub>2' \\<tau> call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 = Call src\\<^sub>2' DotCall call\\<^sub>2;\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2';\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2' : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 DotCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 2. \\<And>src\\<^sub>2' \\<tau> \\<sigma> call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 =\n                CollectIteratorCall src\\<^sub>2' ArrowCall\n                 [new_vname \\<Gamma>] (Some \\<sigma>)\n                 (Call (Var (new_vname \\<Gamma>)) DotCall call\\<^sub>2);\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2';\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2' : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 DotCall call\\<^sub>2 =\n                         expr\\<^sub>2", "apply metis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>src\\<^sub>2' \\<tau> \\<sigma> call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 =\n                CollectIteratorCall src\\<^sub>2' ArrowCall\n                 [new_vname \\<Gamma>] (Some \\<sigma>)\n                 (Call (Var (new_vname \\<Gamma>)) DotCall call\\<^sub>2);\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2';\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2' : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 DotCall call\\<^sub>2 =\n                         expr\\<^sub>2", "using OclAnyDotCallN.hyps any_has_not_element_type typing_det"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  src\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>\n  \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty\n  (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  call\\<^sub>2\n  (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  ?call\\<^sub>2 \\<Longrightarrow>\n  call\\<^sub>2 = ?call\\<^sub>2\n  \\<lbrakk>element_type ?\\<tau> ?\\<sigma>;\n   ?\\<tau> \\<le> OclAny[?] \\<or> ?\\<tau> \\<le> Tuple fmempty\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<lbrakk>?\\<Gamma> \\<turnstile>\\<^sub>E ?expr : ?\\<tau>;\n   ?\\<Gamma> \\<turnstile>\\<^sub>E ?expr : ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> ?\\<tau> = ?\\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>src\\<^sub>2' \\<tau> \\<sigma> call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 =\n                CollectIteratorCall src\\<^sub>2' ArrowCall\n                 [new_vname \\<Gamma>] (Some \\<sigma>)\n                 (Call (Var (new_vname \\<Gamma>)) DotCall call\\<^sub>2);\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2';\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2' : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 DotCall call\\<^sub>2 =\n                         expr\\<^sub>2", "by metis"], ["proof (state)\nthis:\n  Call src\\<^sub>2 DotCall call\\<^sub>2 = expr\\<^sub>2\n\ngoal (19 subgoals):\n 1. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       src\\<^sub>3 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        OclVoid[?] \\<le> \\<tau>;\n        (\\<Gamma>,\n         to_required_type\n          \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            to_required_type\n             \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n         (to_required_type \\<tau>);\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3 DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> src\\<^sub>3 \\<sigma>\n       call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        src\\<^sub>3 =\n        OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp) [];\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu_ call\\<^sub>1\n       call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 4. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3\n       \\<rho> call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n         (to_required_type \\<sigma>);\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 5. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1\n       call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 6. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> \\<rho>\n       src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        \\<rho> = to_required_type \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>3 ArrowCall [it]\n                          (Some \\<rho>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 7. \\<And>\\<Gamma> \\<tau> op ty call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TypeOperation op ty = call\\<^sub>2\n 8. \\<And>\\<Gamma> \\<tau> attr call\\<^sub>2.\n       (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       Attribute attr = call\\<^sub>2\n 9. \\<And>\\<Gamma> \\<tau> role from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role from \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationEnd role from = call\\<^sub>2\n 10. \\<And>\\<Gamma> \\<tau> \\<A> from call\\<^sub>2.\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A>\n from \\<Rrightarrow>\n        call\\<^sub>2 \\<Longrightarrow>\n        AssociationClass \\<A> from = call\\<^sub>2\nA total of 19 subgoals...", "next"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       src\\<^sub>3 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        OclVoid[?] \\<le> \\<tau>;\n        (\\<Gamma>,\n         to_required_type\n          \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            to_required_type\n             \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n         (to_required_type \\<tau>);\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3 DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> src\\<^sub>3 \\<sigma>\n       call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        src\\<^sub>3 =\n        OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp) [];\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu_ call\\<^sub>1\n       call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 4. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3\n       \\<rho> call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n         (to_required_type \\<sigma>);\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 5. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1\n       call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 6. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> \\<rho>\n       src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        \\<rho> = to_required_type \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>3 ArrowCall [it]\n                          (Some \\<rho>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 7. \\<And>\\<Gamma> \\<tau> op ty call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TypeOperation op ty = call\\<^sub>2\n 8. \\<And>\\<Gamma> \\<tau> attr call\\<^sub>2.\n       (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       Attribute attr = call\\<^sub>2\n 9. \\<And>\\<Gamma> \\<tau> role from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role from \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationEnd role from = call\\<^sub>2\n 10. \\<And>\\<Gamma> \\<tau> \\<A> from call\\<^sub>2.\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A>\n from \\<Rrightarrow>\n        call\\<^sub>2 \\<Longrightarrow>\n        AssociationClass \\<A> from = call\\<^sub>2\nA total of 19 subgoals...", "case (OclAnySafeDotCallN \\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  src\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>\n  OclVoid[?] \\<le> \\<tau>\n  (\\<Gamma>,\n   to_required_type \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  call\\<^sub>2\n  (\\<Gamma>,\n   to_required_type \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  ?call\\<^sub>2 \\<Longrightarrow>\n  call\\<^sub>2 = ?call\\<^sub>2\n  src\\<^sub>3_ =\n  TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n   (to_required_type \\<tau>)\n  \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                         call\\<^sub>1 \\<Rrightarrow>\n  expr\\<^sub>2\n\ngoal (19 subgoals):\n 1. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> call\\<^sub>1 call\\<^sub>2\n       src\\<^sub>3 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        OclVoid[?] \\<le> \\<tau>;\n        (\\<Gamma>,\n         to_required_type\n          \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            to_required_type\n             \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n         (to_required_type \\<tau>);\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3 DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> src\\<^sub>3 \\<sigma>\n       call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        src\\<^sub>3 =\n        OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp) [];\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu_ call\\<^sub>1\n       call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 4. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3\n       \\<rho> call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n         (to_required_type \\<sigma>);\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 5. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1\n       call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 6. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> \\<rho>\n       src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        \\<rho> = to_required_type \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>3 ArrowCall [it]\n                          (Some \\<rho>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 7. \\<And>\\<Gamma> \\<tau> op ty call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TypeOperation op ty = call\\<^sub>2\n 8. \\<And>\\<Gamma> \\<tau> attr call\\<^sub>2.\n       (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       Attribute attr = call\\<^sub>2\n 9. \\<And>\\<Gamma> \\<tau> role from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role from \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationEnd role from = call\\<^sub>2\n 10. \\<And>\\<Gamma> \\<tau> \\<A> from call\\<^sub>2.\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A>\n from \\<Rrightarrow>\n        call\\<^sub>2 \\<Longrightarrow>\n        AssociationClass \\<A> from = call\\<^sub>2\nA total of 19 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. expr.If\n     (OperationCall src\\<^sub>2 DotCall\n       ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n       (map Literal [NullLiteral]))\n     (Call src\\<^sub>3_ DotCall call\\<^sub>2) (Literal NullLiteral) =\n    expr\\<^sub>2", "apply (insert OclAnySafeDotCallN.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                           call\\<^sub>1 \\<Rrightarrow>\n    expr\\<^sub>2 \\<Longrightarrow>\n    expr.If\n     (OperationCall src\\<^sub>2 DotCall\n       ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n       (map Literal [NullLiteral]))\n     (Call src\\<^sub>3_ DotCall call\\<^sub>2) (Literal NullLiteral) =\n    expr\\<^sub>2", "apply (erule SafeDotCallNE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>src\\<^sub>2' \\<tau> call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 =\n                expr.If\n                 (OperationCall src\\<^sub>2' DotCall\n                   (Inr (Inl (Inl NotEqualOp))) [Literal NullLiteral])\n                 (Call\n                   (TypeOperationCall src\\<^sub>2' DotCall OclAsTypeOp\n                     (to_required_type \\<tau>))\n                   DotCall call\\<^sub>2)\n                 (Literal NullLiteral);\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2';\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2' : \\<tau>;\n        OclVoid[?] \\<le> \\<tau>;\n        (\\<Gamma>,\n         to_required_type\n          \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3_ DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2\n 2. \\<And>src\\<^sub>2' \\<tau> \\<sigma> call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 =\n                CollectIteratorCall\n                 (TypeOperationCall src\\<^sub>2' ArrowCall SelectByKindOp\n                   (to_required_type \\<sigma>))\n                 ArrowCall [new_vname \\<Gamma>]\n                 (Some (to_required_type \\<sigma>))\n                 (Call (Var (new_vname \\<Gamma>)) DotCall call\\<^sub>2);\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2';\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2' : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        (\\<Gamma>,\n         to_required_type\n          \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3_ DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2", "using OclAnySafeDotCallN.hyps typing_det comp_apply"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  src\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>\n  OclVoid[?] \\<le> \\<tau>\n  (\\<Gamma>,\n   to_required_type \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  call\\<^sub>2\n  (\\<Gamma>,\n   to_required_type \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  ?call\\<^sub>2 \\<Longrightarrow>\n  call\\<^sub>2 = ?call\\<^sub>2\n  src\\<^sub>3_ =\n  TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n   (to_required_type \\<tau>)\n  \\<lbrakk>?\\<Gamma> \\<turnstile>\\<^sub>E ?expr : ?\\<tau>;\n   ?\\<Gamma> \\<turnstile>\\<^sub>E ?expr : ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> ?\\<tau> = ?\\<sigma>\n  (?f \\<circ> ?g) ?x = ?f (?g ?x)\n\ngoal (2 subgoals):\n 1. \\<And>src\\<^sub>2' \\<tau> call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 =\n                expr.If\n                 (OperationCall src\\<^sub>2' DotCall\n                   (Inr (Inl (Inl NotEqualOp))) [Literal NullLiteral])\n                 (Call\n                   (TypeOperationCall src\\<^sub>2' DotCall OclAsTypeOp\n                     (to_required_type \\<tau>))\n                   DotCall call\\<^sub>2)\n                 (Literal NullLiteral);\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2';\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2' : \\<tau>;\n        OclVoid[?] \\<le> \\<tau>;\n        (\\<Gamma>,\n         to_required_type\n          \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3_ DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2\n 2. \\<And>src\\<^sub>2' \\<tau> \\<sigma> call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 =\n                CollectIteratorCall\n                 (TypeOperationCall src\\<^sub>2' ArrowCall SelectByKindOp\n                   (to_required_type \\<sigma>))\n                 ArrowCall [new_vname \\<Gamma>]\n                 (Some (to_required_type \\<sigma>))\n                 (Call (Var (new_vname \\<Gamma>)) DotCall call\\<^sub>2);\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2';\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2' : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        (\\<Gamma>,\n         to_required_type\n          \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3_ DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2", "apply (metis (no_types, lifting) list.simps(8) list.simps(9))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>src\\<^sub>2' \\<tau> \\<sigma> call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 =\n                CollectIteratorCall\n                 (TypeOperationCall src\\<^sub>2' ArrowCall SelectByKindOp\n                   (to_required_type \\<sigma>))\n                 ArrowCall [new_vname \\<Gamma>]\n                 (Some (to_required_type \\<sigma>))\n                 (Call (Var (new_vname \\<Gamma>)) DotCall call\\<^sub>2);\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2';\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2' : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        (\\<Gamma>,\n         to_required_type\n          \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3_ DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2", "using OclAnySafeDotCallN.hyps typing_det any_has_not_element_type'"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  src\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>\n  OclVoid[?] \\<le> \\<tau>\n  (\\<Gamma>,\n   to_required_type \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  call\\<^sub>2\n  (\\<Gamma>,\n   to_required_type \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  ?call\\<^sub>2 \\<Longrightarrow>\n  call\\<^sub>2 = ?call\\<^sub>2\n  src\\<^sub>3_ =\n  TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n   (to_required_type \\<tau>)\n  \\<lbrakk>?\\<Gamma> \\<turnstile>\\<^sub>E ?expr : ?\\<tau>;\n   ?\\<Gamma> \\<turnstile>\\<^sub>E ?expr : ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> ?\\<tau> = ?\\<sigma>\n  \\<lbrakk>element_type ?\\<tau> ?\\<sigma>; OclVoid[?] \\<le> ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>src\\<^sub>2' \\<tau> \\<sigma> call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 =\n                CollectIteratorCall\n                 (TypeOperationCall src\\<^sub>2' ArrowCall SelectByKindOp\n                   (to_required_type \\<sigma>))\n                 ArrowCall [new_vname \\<Gamma>]\n                 (Some (to_required_type \\<sigma>))\n                 (Call (Var (new_vname \\<Gamma>)) DotCall call\\<^sub>2);\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2';\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2' : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        (\\<Gamma>,\n         to_required_type\n          \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> expr.If\n                          (OperationCall src\\<^sub>2 DotCall\n                            ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp)\n                            (map Literal [NullLiteral]))\n                          (Call src\\<^sub>3_ DotCall call\\<^sub>2)\n                          (Literal NullLiteral) =\n                         expr\\<^sub>2", "by metis"], ["proof (state)\nthis:\n  expr.If\n   (OperationCall src\\<^sub>2 DotCall\n     ((Inr \\<circ> Inl \\<circ> Inl) NotEqualOp) (map Literal [NullLiteral]))\n   (Call src\\<^sub>3_ DotCall call\\<^sub>2) (Literal NullLiteral) =\n  expr\\<^sub>2\n\ngoal (18 subgoals):\n 1. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> src\\<^sub>3 \\<sigma>\n       call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        src\\<^sub>3 =\n        OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp) [];\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu_ call\\<^sub>1\n       call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3\n       \\<rho> call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n         (to_required_type \\<sigma>);\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 4. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1\n       call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 5. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> \\<rho>\n       src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        \\<rho> = to_required_type \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>3 ArrowCall [it]\n                          (Some \\<rho>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 6. \\<And>\\<Gamma> \\<tau> op ty call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TypeOperation op ty = call\\<^sub>2\n 7. \\<And>\\<Gamma> \\<tau> attr call\\<^sub>2.\n       (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       Attribute attr = call\\<^sub>2\n 8. \\<And>\\<Gamma> \\<tau> role from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role from \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationEnd role from = call\\<^sub>2\n 9. \\<And>\\<Gamma> \\<tau> \\<A> from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A>\nfrom \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClass \\<A> from = call\\<^sub>2\n 10. \\<And>\\<Gamma> \\<tau> role call\\<^sub>2.\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd\n role \\<Rrightarrow>\n        call\\<^sub>2 \\<Longrightarrow>\n        AssociationClassEnd role = call\\<^sub>2\nA total of 18 subgoals...", "next"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> src\\<^sub>3 \\<sigma>\n       call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        src\\<^sub>3 =\n        OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp) [];\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu_ call\\<^sub>1\n       call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3\n       \\<rho> call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n         (to_required_type \\<sigma>);\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 4. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1\n       call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 5. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> \\<rho>\n       src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        \\<rho> = to_required_type \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>3 ArrowCall [it]\n                          (Some \\<rho>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 6. \\<And>\\<Gamma> \\<tau> op ty call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TypeOperation op ty = call\\<^sub>2\n 7. \\<And>\\<Gamma> \\<tau> attr call\\<^sub>2.\n       (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       Attribute attr = call\\<^sub>2\n 8. \\<And>\\<Gamma> \\<tau> role from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role from \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationEnd role from = call\\<^sub>2\n 9. \\<And>\\<Gamma> \\<tau> \\<A> from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A>\nfrom \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClass \\<A> from = call\\<^sub>2\n 10. \\<And>\\<Gamma> \\<tau> role call\\<^sub>2.\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd\n role \\<Rrightarrow>\n        call\\<^sub>2 \\<Longrightarrow>\n        AssociationClassEnd role = call\\<^sub>2\nA total of 18 subgoals...", "case (OclAnyArrowCallN \\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> src\\<^sub>3 \\<sigma> call\\<^sub>1 call\\<^sub>2)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  src\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>\n  \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty\n  src\\<^sub>3 =\n  OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp) []\n  \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>\n  (\\<Gamma>, \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  call\\<^sub>2\n  (\\<Gamma>, \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  ?call\\<^sub>2 \\<Longrightarrow>\n  call\\<^sub>2 = ?call\\<^sub>2\n  \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                         call\\<^sub>1 \\<Rrightarrow>\n  expr\\<^sub>2\n\ngoal (18 subgoals):\n 1. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> src\\<^sub>3 \\<sigma>\n       call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        src\\<^sub>3 =\n        OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp) [];\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu_ call\\<^sub>1\n       call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3\n       \\<rho> call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n         (to_required_type \\<sigma>);\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 4. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1\n       call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 5. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> \\<rho>\n       src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        \\<rho> = to_required_type \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>3 ArrowCall [it]\n                          (Some \\<rho>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 6. \\<And>\\<Gamma> \\<tau> op ty call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TypeOperation op ty = call\\<^sub>2\n 7. \\<And>\\<Gamma> \\<tau> attr call\\<^sub>2.\n       (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       Attribute attr = call\\<^sub>2\n 8. \\<And>\\<Gamma> \\<tau> role from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role from \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationEnd role from = call\\<^sub>2\n 9. \\<And>\\<Gamma> \\<tau> \\<A> from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A>\nfrom \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClass \\<A> from = call\\<^sub>2\n 10. \\<And>\\<Gamma> \\<tau> role call\\<^sub>2.\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd\n role \\<Rrightarrow>\n        call\\<^sub>2 \\<Longrightarrow>\n        AssociationClassEnd role = call\\<^sub>2\nA total of 18 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Call src\\<^sub>3 ArrowCall call\\<^sub>2 = expr\\<^sub>2", "apply (insert OclAnyArrowCallN.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                           call\\<^sub>1 \\<Rrightarrow>\n    expr\\<^sub>2 \\<Longrightarrow>\n    Call src\\<^sub>3 ArrowCall call\\<^sub>2 = expr\\<^sub>2", "apply (erule ArrowCallNE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 =\n                Call\n                 (OperationCall src\\<^sub>2 DotCall (Inl (Inl OclAsSetOp))\n                   [])\n                 ArrowCall call\\<^sub>2;\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src\\<^sub>2 DotCall (Inl (Inl OclAsSetOp)) [] :\n         \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 2. \\<And>src\\<^sub>2 \\<tau> uu_ call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 = Call src\\<^sub>2 ArrowCall call\\<^sub>2;\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2", "using OclAnyArrowCallN.hyps typing_det comp_apply"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  src\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>\n  \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty\n  src\\<^sub>3 =\n  OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp) []\n  \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>\n  (\\<Gamma>, \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  call\\<^sub>2\n  (\\<Gamma>, \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  ?call\\<^sub>2 \\<Longrightarrow>\n  call\\<^sub>2 = ?call\\<^sub>2\n  \\<lbrakk>?\\<Gamma> \\<turnstile>\\<^sub>E ?expr : ?\\<tau>;\n   ?\\<Gamma> \\<turnstile>\\<^sub>E ?expr : ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> ?\\<tau> = ?\\<sigma>\n  (?f \\<circ> ?g) ?x = ?f (?g ?x)\n\ngoal (2 subgoals):\n 1. \\<And>src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 =\n                Call\n                 (OperationCall src\\<^sub>2 DotCall (Inl (Inl OclAsSetOp))\n                   [])\n                 ArrowCall call\\<^sub>2;\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src\\<^sub>2 DotCall (Inl (Inl OclAsSetOp)) [] :\n         \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 2. \\<And>src\\<^sub>2 \\<tau> uu_ call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 = Call src\\<^sub>2 ArrowCall call\\<^sub>2;\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2", "apply metis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>src\\<^sub>2 \\<tau> uu_ call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 = Call src\\<^sub>2 ArrowCall call\\<^sub>2;\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2", "using OclAnyArrowCallN.hyps typing_det any_has_not_element_type"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  src\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>\n  \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty\n  src\\<^sub>3 =\n  OperationCall src\\<^sub>2 DotCall ((Inl \\<circ> Inl) OclAsSetOp) []\n  \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<sigma>\n  (\\<Gamma>, \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  call\\<^sub>2\n  (\\<Gamma>, \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  ?call\\<^sub>2 \\<Longrightarrow>\n  call\\<^sub>2 = ?call\\<^sub>2\n  \\<lbrakk>?\\<Gamma> \\<turnstile>\\<^sub>E ?expr : ?\\<tau>;\n   ?\\<Gamma> \\<turnstile>\\<^sub>E ?expr : ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> ?\\<tau> = ?\\<sigma>\n  \\<lbrakk>element_type ?\\<tau> ?\\<sigma>;\n   ?\\<tau> \\<le> OclAny[?] \\<or> ?\\<tau> \\<le> Tuple fmempty\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>src\\<^sub>2 \\<tau> uu_ call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 = Call src\\<^sub>2 ArrowCall call\\<^sub>2;\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2", "by metis"], ["proof (state)\nthis:\n  Call src\\<^sub>3 ArrowCall call\\<^sub>2 = expr\\<^sub>2\n\ngoal (17 subgoals):\n 1. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu_ call\\<^sub>1\n       call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3\n       \\<rho> call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n         (to_required_type \\<sigma>);\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1\n       call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 4. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> \\<rho>\n       src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        \\<rho> = to_required_type \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>3 ArrowCall [it]\n                          (Some \\<rho>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 5. \\<And>\\<Gamma> \\<tau> op ty call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TypeOperation op ty = call\\<^sub>2\n 6. \\<And>\\<Gamma> \\<tau> attr call\\<^sub>2.\n       (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       Attribute attr = call\\<^sub>2\n 7. \\<And>\\<Gamma> \\<tau> role from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role from \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationEnd role from = call\\<^sub>2\n 8. \\<And>\\<Gamma> \\<tau> \\<A> from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A>\nfrom \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClass \\<A> from = call\\<^sub>2\n 9. \\<And>\\<Gamma> \\<tau> role call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd role \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClassEnd role = call\\<^sub>2\n 10. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op call\\<^sub>2.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                 params\\<^sub>2;\n         \\<And>zs.\n            \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n            zs \\<Longrightarrow>\n            params\\<^sub>2 = zs;\n         (\\<Gamma>,\n          \\<tau>) \\<turnstile>\\<^sub>C Operation op\n  params\\<^sub>1 \\<Rrightarrow>\n         call\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> Operation op params\\<^sub>2 = call\\<^sub>2\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu_ call\\<^sub>1\n       call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3\n       \\<rho> call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n         (to_required_type \\<sigma>);\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1\n       call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 4. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> \\<rho>\n       src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        \\<rho> = to_required_type \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>3 ArrowCall [it]\n                          (Some \\<rho>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 5. \\<And>\\<Gamma> \\<tau> op ty call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TypeOperation op ty = call\\<^sub>2\n 6. \\<And>\\<Gamma> \\<tau> attr call\\<^sub>2.\n       (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       Attribute attr = call\\<^sub>2\n 7. \\<And>\\<Gamma> \\<tau> role from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role from \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationEnd role from = call\\<^sub>2\n 8. \\<And>\\<Gamma> \\<tau> \\<A> from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A>\nfrom \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClass \\<A> from = call\\<^sub>2\n 9. \\<And>\\<Gamma> \\<tau> role call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd role \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClassEnd role = call\\<^sub>2\n 10. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op call\\<^sub>2.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                 params\\<^sub>2;\n         \\<And>zs.\n            \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n            zs \\<Longrightarrow>\n            params\\<^sub>2 = zs;\n         (\\<Gamma>,\n          \\<tau>) \\<turnstile>\\<^sub>C Operation op\n  params\\<^sub>1 \\<Rrightarrow>\n         call\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> Operation op params\\<^sub>2 = call\\<^sub>2\nA total of 17 subgoals...", "case (CollectionArrowCallN \\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu call\\<^sub>1 call\\<^sub>2)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  src\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>\n  element_type \\<tau> uu\n  (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  call\\<^sub>2\n  (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  ?call\\<^sub>2 \\<Longrightarrow>\n  call\\<^sub>2 = ?call\\<^sub>2\n  \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                         call\\<^sub>1 \\<Rrightarrow>\n  expr\\<^sub>2\n\ngoal (17 subgoals):\n 1. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> uu_ call\\<^sub>1\n       call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3\n       \\<rho> call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n         (to_required_type \\<sigma>);\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1\n       call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 4. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> \\<rho>\n       src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        \\<rho> = to_required_type \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>3 ArrowCall [it]\n                          (Some \\<rho>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 5. \\<And>\\<Gamma> \\<tau> op ty call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TypeOperation op ty = call\\<^sub>2\n 6. \\<And>\\<Gamma> \\<tau> attr call\\<^sub>2.\n       (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       Attribute attr = call\\<^sub>2\n 7. \\<And>\\<Gamma> \\<tau> role from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role from \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationEnd role from = call\\<^sub>2\n 8. \\<And>\\<Gamma> \\<tau> \\<A> from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A>\nfrom \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClass \\<A> from = call\\<^sub>2\n 9. \\<And>\\<Gamma> \\<tau> role call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd role \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClassEnd role = call\\<^sub>2\n 10. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op call\\<^sub>2.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                 params\\<^sub>2;\n         \\<And>zs.\n            \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n            zs \\<Longrightarrow>\n            params\\<^sub>2 = zs;\n         (\\<Gamma>,\n          \\<tau>) \\<turnstile>\\<^sub>C Operation op\n  params\\<^sub>1 \\<Rrightarrow>\n         call\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> Operation op params\\<^sub>2 = call\\<^sub>2\nA total of 17 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Call src\\<^sub>2 ArrowCall call\\<^sub>2 = expr\\<^sub>2", "apply (insert CollectionArrowCallN.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile> Call src\\<^sub>1 ArrowCall\n                           call\\<^sub>1 \\<Rrightarrow>\n    expr\\<^sub>2 \\<Longrightarrow>\n    Call src\\<^sub>2 ArrowCall call\\<^sub>2 = expr\\<^sub>2", "apply (erule ArrowCallNE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>src\\<^sub>2' \\<tau> \\<sigma> call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 =\n                Call\n                 (OperationCall src\\<^sub>2' DotCall (Inl (Inl OclAsSetOp))\n                   [])\n                 ArrowCall call\\<^sub>2;\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2';\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2' : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src\\<^sub>2' DotCall (Inl (Inl OclAsSetOp)) [] :\n         \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 2. \\<And>src\\<^sub>2' \\<tau> uu_ call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 = Call src\\<^sub>2' ArrowCall call\\<^sub>2;\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2';\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2' : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2", "using CollectionArrowCallN.hyps typing_det any_has_not_element_type"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  src\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>\n  element_type \\<tau> uu\n  (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  call\\<^sub>2\n  (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  ?call\\<^sub>2 \\<Longrightarrow>\n  call\\<^sub>2 = ?call\\<^sub>2\n  \\<lbrakk>?\\<Gamma> \\<turnstile>\\<^sub>E ?expr : ?\\<tau>;\n   ?\\<Gamma> \\<turnstile>\\<^sub>E ?expr : ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> ?\\<tau> = ?\\<sigma>\n  \\<lbrakk>element_type ?\\<tau> ?\\<sigma>;\n   ?\\<tau> \\<le> OclAny[?] \\<or> ?\\<tau> \\<le> Tuple fmempty\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. \\<And>src\\<^sub>2' \\<tau> \\<sigma> call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 =\n                Call\n                 (OperationCall src\\<^sub>2' DotCall (Inl (Inl OclAsSetOp))\n                   [])\n                 ArrowCall call\\<^sub>2;\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2';\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2' : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src\\<^sub>2' DotCall (Inl (Inl OclAsSetOp)) [] :\n         \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 2. \\<And>src\\<^sub>2' \\<tau> uu_ call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 = Call src\\<^sub>2' ArrowCall call\\<^sub>2;\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2';\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2' : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2", "apply metis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>src\\<^sub>2' \\<tau> uu_ call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 = Call src\\<^sub>2' ArrowCall call\\<^sub>2;\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2';\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2' : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2", "using CollectionArrowCallN.hyps typing_det"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  src\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>\n  element_type \\<tau> uu\n  (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  call\\<^sub>2\n  (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  ?call\\<^sub>2 \\<Longrightarrow>\n  call\\<^sub>2 = ?call\\<^sub>2\n  \\<lbrakk>?\\<Gamma> \\<turnstile>\\<^sub>E ?expr : ?\\<tau>;\n   ?\\<Gamma> \\<turnstile>\\<^sub>E ?expr : ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> ?\\<tau> = ?\\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>src\\<^sub>2' \\<tau> uu_ call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 = Call src\\<^sub>2' ArrowCall call\\<^sub>2;\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2';\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2' : \\<tau>;\n        element_type \\<tau> uu_;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>2 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2", "by metis"], ["proof (state)\nthis:\n  Call src\\<^sub>2 ArrowCall call\\<^sub>2 = expr\\<^sub>2\n\ngoal (16 subgoals):\n 1. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3\n       \\<rho> call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n         (to_required_type \\<sigma>);\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1\n       call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> \\<rho>\n       src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        \\<rho> = to_required_type \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>3 ArrowCall [it]\n                          (Some \\<rho>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 4. \\<And>\\<Gamma> \\<tau> op ty call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TypeOperation op ty = call\\<^sub>2\n 5. \\<And>\\<Gamma> \\<tau> attr call\\<^sub>2.\n       (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       Attribute attr = call\\<^sub>2\n 6. \\<And>\\<Gamma> \\<tau> role from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role from \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationEnd role from = call\\<^sub>2\n 7. \\<And>\\<Gamma> \\<tau> \\<A> from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A>\nfrom \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClass \\<A> from = call\\<^sub>2\n 8. \\<And>\\<Gamma> \\<tau> role call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd role \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClassEnd role = call\\<^sub>2\n 9. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Operation op\n params\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Operation op params\\<^sub>2 = call\\<^sub>2\n 10. \\<And>\\<Gamma> \\<tau> elem call\\<^sub>2.\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n        call\\<^sub>2 \\<Longrightarrow>\n        TupleElement elem = call\\<^sub>2\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3\n       \\<rho> call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n         (to_required_type \\<sigma>);\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1\n       call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> \\<rho>\n       src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        \\<rho> = to_required_type \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>3 ArrowCall [it]\n                          (Some \\<rho>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 4. \\<And>\\<Gamma> \\<tau> op ty call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TypeOperation op ty = call\\<^sub>2\n 5. \\<And>\\<Gamma> \\<tau> attr call\\<^sub>2.\n       (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       Attribute attr = call\\<^sub>2\n 6. \\<And>\\<Gamma> \\<tau> role from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role from \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationEnd role from = call\\<^sub>2\n 7. \\<And>\\<Gamma> \\<tau> \\<A> from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A>\nfrom \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClass \\<A> from = call\\<^sub>2\n 8. \\<And>\\<Gamma> \\<tau> role call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd role \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClassEnd role = call\\<^sub>2\n 9. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Operation op\n params\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Operation op params\\<^sub>2 = call\\<^sub>2\n 10. \\<And>\\<Gamma> \\<tau> elem call\\<^sub>2.\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n        call\\<^sub>2 \\<Longrightarrow>\n        TupleElement elem = call\\<^sub>2\nA total of 16 subgoals...", "case (CollectionSafeArrowCallN \\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3 \\<rho> call\\<^sub>1 call\\<^sub>2)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  src\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>\n  element_type \\<tau> \\<sigma>\n  OclVoid[?] \\<le> \\<sigma>\n  src\\<^sub>3 =\n  TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n   (to_required_type \\<sigma>)\n  \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>\n  (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  call\\<^sub>2\n  (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  ?call\\<^sub>2 \\<Longrightarrow>\n  call\\<^sub>2 = ?call\\<^sub>2\n  \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                         call\\<^sub>1 \\<Rrightarrow>\n  expr\\<^sub>2\n\ngoal (16 subgoals):\n 1. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3\n       \\<rho> call\\<^sub>1 call\\<^sub>2 expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n         (to_required_type \\<sigma>);\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1\n       call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> \\<rho>\n       src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        \\<rho> = to_required_type \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>3 ArrowCall [it]\n                          (Some \\<rho>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 4. \\<And>\\<Gamma> \\<tau> op ty call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TypeOperation op ty = call\\<^sub>2\n 5. \\<And>\\<Gamma> \\<tau> attr call\\<^sub>2.\n       (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       Attribute attr = call\\<^sub>2\n 6. \\<And>\\<Gamma> \\<tau> role from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role from \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationEnd role from = call\\<^sub>2\n 7. \\<And>\\<Gamma> \\<tau> \\<A> from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A>\nfrom \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClass \\<A> from = call\\<^sub>2\n 8. \\<And>\\<Gamma> \\<tau> role call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd role \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClassEnd role = call\\<^sub>2\n 9. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Operation op\n params\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Operation op params\\<^sub>2 = call\\<^sub>2\n 10. \\<And>\\<Gamma> \\<tau> elem call\\<^sub>2.\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n        call\\<^sub>2 \\<Longrightarrow>\n        TupleElement elem = call\\<^sub>2\nA total of 16 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Call src\\<^sub>3 ArrowCall call\\<^sub>2 = expr\\<^sub>2", "apply (insert CollectionSafeArrowCallN.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeArrowCall\n                           call\\<^sub>1 \\<Rrightarrow>\n    expr\\<^sub>2 \\<Longrightarrow>\n    Call src\\<^sub>3 ArrowCall call\\<^sub>2 = expr\\<^sub>2", "apply (erule SafeArrowCallNE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>src\\<^sub>2 \\<tau> \\<sigma> \\<rho> call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 =\n                Call\n                 (TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n                   (to_required_type \\<sigma>))\n                 ArrowCall call\\<^sub>2;\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n          (to_required_type \\<sigma>) :\n         \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2", "using CollectionSafeArrowCallN.hyps typing_det element_type_det"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  src\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>\n  element_type \\<tau> \\<sigma>\n  OclVoid[?] \\<le> \\<sigma>\n  src\\<^sub>3 =\n  TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n   (to_required_type \\<sigma>)\n  \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>3 : \\<rho>\n  (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  call\\<^sub>2\n  (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  ?call\\<^sub>2 \\<Longrightarrow>\n  call\\<^sub>2 = ?call\\<^sub>2\n  \\<lbrakk>?\\<Gamma> \\<turnstile>\\<^sub>E ?expr : ?\\<tau>;\n   ?\\<Gamma> \\<turnstile>\\<^sub>E ?expr : ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> ?\\<tau> = ?\\<sigma>\n  \\<lbrakk>element_type ?\\<tau> ?\\<sigma>\\<^sub>1;\n   element_type ?\\<tau> ?\\<sigma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?\\<sigma>\\<^sub>1 = ?\\<sigma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>src\\<^sub>2 \\<tau> \\<sigma> \\<rho> call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 =\n                Call\n                 (TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n                   (to_required_type \\<sigma>))\n                 ArrowCall call\\<^sub>2;\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n          (to_required_type \\<sigma>) :\n         \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Call src\\<^sub>3 ArrowCall call\\<^sub>2 =\n                         expr\\<^sub>2", "by metis"], ["proof (state)\nthis:\n  Call src\\<^sub>3 ArrowCall call\\<^sub>2 = expr\\<^sub>2\n\ngoal (15 subgoals):\n 1. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1\n       call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> \\<rho>\n       src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        \\<rho> = to_required_type \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>3 ArrowCall [it]\n                          (Some \\<rho>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> \\<tau> op ty call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TypeOperation op ty = call\\<^sub>2\n 4. \\<And>\\<Gamma> \\<tau> attr call\\<^sub>2.\n       (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       Attribute attr = call\\<^sub>2\n 5. \\<And>\\<Gamma> \\<tau> role from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role from \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationEnd role from = call\\<^sub>2\n 6. \\<And>\\<Gamma> \\<tau> \\<A> from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A>\nfrom \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClass \\<A> from = call\\<^sub>2\n 7. \\<And>\\<Gamma> \\<tau> role call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd role \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClassEnd role = call\\<^sub>2\n 8. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Operation op\n params\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Operation op params\\<^sub>2 = call\\<^sub>2\n 9. \\<And>\\<Gamma> \\<tau> elem call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TupleElement elem = call\\<^sub>2\n 10. \\<And>\\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res\n        res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>\n        call\\<^sub>2.\n        \\<lbrakk>\\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n                 res_init\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            res_init\\<^sub>2 = expr\\<^sub>2;\n         \\<Gamma> ++\\<^sub>f\n         fmap_of_list\n          (map (\\<lambda>it. (it, \\<sigma>))\n            its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                               body\\<^sub>1 \\<Rrightarrow>\n         expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> ++\\<^sub>f\n            fmap_of_list\n             (map (\\<lambda>it. (it, \\<sigma>))\n               its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                  body\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n            expr\\<^sub>2;\n         (\\<Gamma>,\n          \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n  res_t\\<^sub>1 res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n         call\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                           res_init\\<^sub>2 body\\<^sub>2 =\n                          call\\<^sub>2\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1\n       call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> \\<rho>\n       src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        \\<rho> = to_required_type \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>3 ArrowCall [it]\n                          (Some \\<rho>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> \\<tau> op ty call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TypeOperation op ty = call\\<^sub>2\n 4. \\<And>\\<Gamma> \\<tau> attr call\\<^sub>2.\n       (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       Attribute attr = call\\<^sub>2\n 5. \\<And>\\<Gamma> \\<tau> role from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role from \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationEnd role from = call\\<^sub>2\n 6. \\<And>\\<Gamma> \\<tau> \\<A> from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A>\nfrom \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClass \\<A> from = call\\<^sub>2\n 7. \\<And>\\<Gamma> \\<tau> role call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd role \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClassEnd role = call\\<^sub>2\n 8. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Operation op\n params\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Operation op params\\<^sub>2 = call\\<^sub>2\n 9. \\<And>\\<Gamma> \\<tau> elem call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TupleElement elem = call\\<^sub>2\n 10. \\<And>\\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res\n        res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>\n        call\\<^sub>2.\n        \\<lbrakk>\\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n                 res_init\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            res_init\\<^sub>2 = expr\\<^sub>2;\n         \\<Gamma> ++\\<^sub>f\n         fmap_of_list\n          (map (\\<lambda>it. (it, \\<sigma>))\n            its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                               body\\<^sub>1 \\<Rrightarrow>\n         expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> ++\\<^sub>f\n            fmap_of_list\n             (map (\\<lambda>it. (it, \\<sigma>))\n               its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                  body\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n            expr\\<^sub>2;\n         (\\<Gamma>,\n          \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n  res_t\\<^sub>1 res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n         call\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                           res_init\\<^sub>2 body\\<^sub>2 =\n                          call\\<^sub>2\nA total of 15 subgoals...", "case (CollectionDotCallN \\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1 call\\<^sub>2 it)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  src\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>\n  element_type \\<tau> \\<sigma>\n  (\\<Gamma>, \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  call\\<^sub>2\n  (\\<Gamma>, \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  ?call\\<^sub>2 \\<Longrightarrow>\n  call\\<^sub>2 = ?call\\<^sub>2\n  it = new_vname \\<Gamma>\n  \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall call\\<^sub>1 \\<Rrightarrow>\n  expr\\<^sub>2\n\ngoal (15 subgoals):\n 1. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>1\n       call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>;\n        (\\<Gamma>,\n         \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> \\<rho>\n       src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        \\<rho> = to_required_type \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>3 ArrowCall [it]\n                          (Some \\<rho>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 3. \\<And>\\<Gamma> \\<tau> op ty call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TypeOperation op ty = call\\<^sub>2\n 4. \\<And>\\<Gamma> \\<tau> attr call\\<^sub>2.\n       (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       Attribute attr = call\\<^sub>2\n 5. \\<And>\\<Gamma> \\<tau> role from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role from \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationEnd role from = call\\<^sub>2\n 6. \\<And>\\<Gamma> \\<tau> \\<A> from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A>\nfrom \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClass \\<A> from = call\\<^sub>2\n 7. \\<And>\\<Gamma> \\<tau> role call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd role \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClassEnd role = call\\<^sub>2\n 8. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Operation op\n params\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Operation op params\\<^sub>2 = call\\<^sub>2\n 9. \\<And>\\<Gamma> \\<tau> elem call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TupleElement elem = call\\<^sub>2\n 10. \\<And>\\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res\n        res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>\n        call\\<^sub>2.\n        \\<lbrakk>\\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n                 res_init\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            res_init\\<^sub>2 = expr\\<^sub>2;\n         \\<Gamma> ++\\<^sub>f\n         fmap_of_list\n          (map (\\<lambda>it. (it, \\<sigma>))\n            its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                               body\\<^sub>1 \\<Rrightarrow>\n         expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> ++\\<^sub>f\n            fmap_of_list\n             (map (\\<lambda>it. (it, \\<sigma>))\n               its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                  body\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n            expr\\<^sub>2;\n         (\\<Gamma>,\n          \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n  res_t\\<^sub>1 res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n         call\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                           res_init\\<^sub>2 body\\<^sub>2 =\n                          call\\<^sub>2\nA total of 15 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. CollectIteratorCall src\\<^sub>2 ArrowCall [it] (Some \\<sigma>)\n     (Call (Var it) DotCall call\\<^sub>2) =\n    expr\\<^sub>2", "apply (insert CollectionDotCallN.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile> Call src\\<^sub>1 DotCall\n                           call\\<^sub>1 \\<Rrightarrow>\n    expr\\<^sub>2 \\<Longrightarrow>\n    CollectIteratorCall src\\<^sub>2 ArrowCall [it] (Some \\<sigma>)\n     (Call (Var it) DotCall call\\<^sub>2) =\n    expr\\<^sub>2", "apply (erule DotCallNE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>src\\<^sub>2' \\<tau> call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 = Call src\\<^sub>2' DotCall call\\<^sub>2;\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2';\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2' : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 2. \\<And>src\\<^sub>2' \\<tau> \\<sigma>' call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 =\n                CollectIteratorCall src\\<^sub>2' ArrowCall\n                 [new_vname \\<Gamma>] (Some \\<sigma>')\n                 (Call (Var (new_vname \\<Gamma>)) DotCall call\\<^sub>2);\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2';\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2' : \\<tau>;\n        element_type \\<tau> \\<sigma>';\n        (\\<Gamma>,\n         \\<sigma>') \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2", "using CollectionDotCallN.hyps typing_det any_has_not_element_type"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  src\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>\n  element_type \\<tau> \\<sigma>\n  (\\<Gamma>, \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  call\\<^sub>2\n  (\\<Gamma>, \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  ?call\\<^sub>2 \\<Longrightarrow>\n  call\\<^sub>2 = ?call\\<^sub>2\n  it = new_vname \\<Gamma>\n  \\<lbrakk>?\\<Gamma> \\<turnstile>\\<^sub>E ?expr : ?\\<tau>;\n   ?\\<Gamma> \\<turnstile>\\<^sub>E ?expr : ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> ?\\<tau> = ?\\<sigma>\n  \\<lbrakk>element_type ?\\<tau> ?\\<sigma>;\n   ?\\<tau> \\<le> OclAny[?] \\<or> ?\\<tau> \\<le> Tuple fmempty\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. \\<And>src\\<^sub>2' \\<tau> call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 = Call src\\<^sub>2' DotCall call\\<^sub>2;\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2';\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2' : \\<tau>;\n        \\<tau> \\<le> OclAny[?] \\<or> \\<tau> \\<le> Tuple fmempty;\n        (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 2. \\<And>src\\<^sub>2' \\<tau> \\<sigma>' call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 =\n                CollectIteratorCall src\\<^sub>2' ArrowCall\n                 [new_vname \\<Gamma>] (Some \\<sigma>')\n                 (Call (Var (new_vname \\<Gamma>)) DotCall call\\<^sub>2);\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2';\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2' : \\<tau>;\n        element_type \\<tau> \\<sigma>';\n        (\\<Gamma>,\n         \\<sigma>') \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2", "apply metis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>src\\<^sub>2' \\<tau> \\<sigma>' call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 =\n                CollectIteratorCall src\\<^sub>2' ArrowCall\n                 [new_vname \\<Gamma>] (Some \\<sigma>')\n                 (Call (Var (new_vname \\<Gamma>)) DotCall call\\<^sub>2);\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2';\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2' : \\<tau>;\n        element_type \\<tau> \\<sigma>';\n        (\\<Gamma>,\n         \\<sigma>') \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2", "using CollectionDotCallN.hyps typing_det element_type_det"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  src\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>\n  element_type \\<tau> \\<sigma>\n  (\\<Gamma>, \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  call\\<^sub>2\n  (\\<Gamma>, \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n  ?call\\<^sub>2 \\<Longrightarrow>\n  call\\<^sub>2 = ?call\\<^sub>2\n  it = new_vname \\<Gamma>\n  \\<lbrakk>?\\<Gamma> \\<turnstile>\\<^sub>E ?expr : ?\\<tau>;\n   ?\\<Gamma> \\<turnstile>\\<^sub>E ?expr : ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> ?\\<tau> = ?\\<sigma>\n  \\<lbrakk>element_type ?\\<tau> ?\\<sigma>\\<^sub>1;\n   element_type ?\\<tau> ?\\<sigma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?\\<sigma>\\<^sub>1 = ?\\<sigma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>src\\<^sub>2' \\<tau> \\<sigma>' call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 =\n                CollectIteratorCall src\\<^sub>2' ArrowCall\n                 [new_vname \\<Gamma>] (Some \\<sigma>')\n                 (Call (Var (new_vname \\<Gamma>)) DotCall call\\<^sub>2);\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2';\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2' : \\<tau>;\n        element_type \\<tau> \\<sigma>';\n        (\\<Gamma>,\n         \\<sigma>') \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>2 ArrowCall [it]\n                          (Some \\<sigma>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2", "by metis"], ["proof (state)\nthis:\n  CollectIteratorCall src\\<^sub>2 ArrowCall [it] (Some \\<sigma>)\n   (Call (Var it) DotCall call\\<^sub>2) =\n  expr\\<^sub>2\n\ngoal (14 subgoals):\n 1. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> \\<rho>\n       src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        \\<rho> = to_required_type \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>3 ArrowCall [it]\n                          (Some \\<rho>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> \\<tau> op ty call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TypeOperation op ty = call\\<^sub>2\n 3. \\<And>\\<Gamma> \\<tau> attr call\\<^sub>2.\n       (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       Attribute attr = call\\<^sub>2\n 4. \\<And>\\<Gamma> \\<tau> role from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role from \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationEnd role from = call\\<^sub>2\n 5. \\<And>\\<Gamma> \\<tau> \\<A> from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A>\nfrom \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClass \\<A> from = call\\<^sub>2\n 6. \\<And>\\<Gamma> \\<tau> role call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd role \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClassEnd role = call\\<^sub>2\n 7. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Operation op\n params\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Operation op params\\<^sub>2 = call\\<^sub>2\n 8. \\<And>\\<Gamma> \\<tau> elem call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TupleElement elem = call\\<^sub>2\n 9. \\<And>\\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n                res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n res_t\\<^sub>1 res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 10. \\<And>\\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its\n        res res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2\n        call\\<^sub>2.\n        \\<lbrakk>element_type \\<tau> \\<sigma>;\n         \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n         res_init\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            res_init\\<^sub>2 = expr\\<^sub>2;\n         \\<Gamma> ++\\<^sub>f\n         fmap_of_list\n          (map (\\<lambda>it. (it, \\<sigma>))\n            its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                               body\\<^sub>1 \\<Rrightarrow>\n         expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> ++\\<^sub>f\n            fmap_of_list\n             (map (\\<lambda>it. (it, \\<sigma>))\n               its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                  body\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n            expr\\<^sub>2;\n         (\\<Gamma>,\n          \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n  res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n         call\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                           res_init\\<^sub>2 body\\<^sub>2 =\n                          call\\<^sub>2\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> \\<rho>\n       src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        \\<rho> = to_required_type \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>3 ArrowCall [it]\n                          (Some \\<rho>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> \\<tau> op ty call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TypeOperation op ty = call\\<^sub>2\n 3. \\<And>\\<Gamma> \\<tau> attr call\\<^sub>2.\n       (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       Attribute attr = call\\<^sub>2\n 4. \\<And>\\<Gamma> \\<tau> role from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role from \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationEnd role from = call\\<^sub>2\n 5. \\<And>\\<Gamma> \\<tau> \\<A> from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A>\nfrom \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClass \\<A> from = call\\<^sub>2\n 6. \\<And>\\<Gamma> \\<tau> role call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd role \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClassEnd role = call\\<^sub>2\n 7. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Operation op\n params\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Operation op params\\<^sub>2 = call\\<^sub>2\n 8. \\<And>\\<Gamma> \\<tau> elem call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TupleElement elem = call\\<^sub>2\n 9. \\<And>\\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n                res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n res_t\\<^sub>1 res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 10. \\<And>\\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its\n        res res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2\n        call\\<^sub>2.\n        \\<lbrakk>element_type \\<tau> \\<sigma>;\n         \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n         res_init\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            res_init\\<^sub>2 = expr\\<^sub>2;\n         \\<Gamma> ++\\<^sub>f\n         fmap_of_list\n          (map (\\<lambda>it. (it, \\<sigma>))\n            its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                               body\\<^sub>1 \\<Rrightarrow>\n         expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> ++\\<^sub>f\n            fmap_of_list\n             (map (\\<lambda>it. (it, \\<sigma>))\n               its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                  body\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n            expr\\<^sub>2;\n         (\\<Gamma>,\n          \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n  res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n         call\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                           res_init\\<^sub>2 body\\<^sub>2 =\n                          call\\<^sub>2\nA total of 14 subgoals...", "case (CollectionSafeDotCallN \\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  src\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>\n  element_type \\<tau> \\<sigma>\n  OclVoid[?] \\<le> \\<sigma>\n  src\\<^sub>3 = to_required_type \\<sigma>\n  call\\<^sub>1 =\n  TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp src\\<^sub>3\n  (\\<Gamma>, src\\<^sub>3) \\<turnstile>\\<^sub>C call\\<^sub>2 \\<Rrightarrow>\n  it\n  (\\<Gamma>, src\\<^sub>3) \\<turnstile>\\<^sub>C call\\<^sub>2 \\<Rrightarrow>\n  ?call\\<^sub>2 \\<Longrightarrow>\n  it = ?call\\<^sub>2\n  it_ = new_vname \\<Gamma>\n  \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                         call\\<^sub>2 \\<Rrightarrow>\n  expr\\<^sub>2\n\ngoal (14 subgoals):\n 1. \\<And>\\<Gamma> src\\<^sub>1 src\\<^sub>2 \\<tau> \\<sigma> \\<rho>\n       src\\<^sub>3 call\\<^sub>1 call\\<^sub>2 it expr\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n                src\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           src\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        \\<rho> = to_required_type \\<sigma>;\n        src\\<^sub>3 =\n        TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp \\<rho>;\n        (\\<Gamma>, \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2;\n        \\<And>call\\<^sub>2'.\n           (\\<Gamma>,\n            \\<rho>) \\<turnstile>\\<^sub>C call\\<^sub>1 \\<Rrightarrow>\n           call\\<^sub>2' \\<Longrightarrow>\n           call\\<^sub>2 = call\\<^sub>2';\n        it = new_vname \\<Gamma>;\n        \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                               call\\<^sub>1 \\<Rrightarrow>\n        expr\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall src\\<^sub>3 ArrowCall [it]\n                          (Some \\<rho>)\n                          (Call (Var it) DotCall call\\<^sub>2) =\n                         expr\\<^sub>2\n 2. \\<And>\\<Gamma> \\<tau> op ty call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TypeOperation op ty = call\\<^sub>2\n 3. \\<And>\\<Gamma> \\<tau> attr call\\<^sub>2.\n       (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       Attribute attr = call\\<^sub>2\n 4. \\<And>\\<Gamma> \\<tau> role from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role from \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationEnd role from = call\\<^sub>2\n 5. \\<And>\\<Gamma> \\<tau> \\<A> from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A>\nfrom \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClass \\<A> from = call\\<^sub>2\n 6. \\<And>\\<Gamma> \\<tau> role call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd role \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClassEnd role = call\\<^sub>2\n 7. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Operation op\n params\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Operation op params\\<^sub>2 = call\\<^sub>2\n 8. \\<And>\\<Gamma> \\<tau> elem call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TupleElement elem = call\\<^sub>2\n 9. \\<And>\\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n                res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n res_t\\<^sub>1 res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 10. \\<And>\\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its\n        res res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2\n        call\\<^sub>2.\n        \\<lbrakk>element_type \\<tau> \\<sigma>;\n         \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n         res_init\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            res_init\\<^sub>2 = expr\\<^sub>2;\n         \\<Gamma> ++\\<^sub>f\n         fmap_of_list\n          (map (\\<lambda>it. (it, \\<sigma>))\n            its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                               body\\<^sub>1 \\<Rrightarrow>\n         expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> ++\\<^sub>f\n            fmap_of_list\n             (map (\\<lambda>it. (it, \\<sigma>))\n               its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                  body\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n            expr\\<^sub>2;\n         (\\<Gamma>,\n          \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n  res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n         call\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                           res_init\\<^sub>2 body\\<^sub>2 =\n                          call\\<^sub>2\nA total of 14 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. CollectIteratorCall call\\<^sub>1 ArrowCall [it_] (Some src\\<^sub>3)\n     (Call (Var it_) DotCall it) =\n    expr\\<^sub>2", "apply (insert CollectionSafeDotCallN.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile> Call src\\<^sub>1 SafeDotCall\n                           call\\<^sub>2 \\<Rrightarrow>\n    expr\\<^sub>2 \\<Longrightarrow>\n    CollectIteratorCall call\\<^sub>1 ArrowCall [it_] (Some src\\<^sub>3)\n     (Call (Var it_) DotCall it) =\n    expr\\<^sub>2", "apply (erule SafeDotCallNE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>src\\<^sub>2 \\<tau> call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 =\n                expr.If\n                 (OperationCall src\\<^sub>2 DotCall\n                   (Inr (Inl (Inl NotEqualOp))) [Literal NullLiteral])\n                 (Call\n                   (TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n                     (to_required_type \\<tau>))\n                   DotCall call\\<^sub>2)\n                 (Literal NullLiteral);\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        OclVoid[?] \\<le> \\<tau>;\n        (\\<Gamma>,\n         to_required_type\n          \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>2 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall call\\<^sub>1 ArrowCall [it_]\n                          (Some src\\<^sub>3) (Call (Var it_) DotCall it) =\n                         expr\\<^sub>2\n 2. \\<And>src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 =\n                CollectIteratorCall\n                 (TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n                   (to_required_type \\<sigma>))\n                 ArrowCall [new_vname \\<Gamma>]\n                 (Some (to_required_type \\<sigma>))\n                 (Call (Var (new_vname \\<Gamma>)) DotCall call\\<^sub>2);\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        (\\<Gamma>,\n         to_required_type\n          \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>2 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall call\\<^sub>1 ArrowCall [it_]\n                          (Some src\\<^sub>3) (Call (Var it_) DotCall it) =\n                         expr\\<^sub>2", "using CollectionSafeDotCallN.hyps typing_det any_has_not_element_type'"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  src\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>\n  element_type \\<tau> \\<sigma>\n  OclVoid[?] \\<le> \\<sigma>\n  src\\<^sub>3 = to_required_type \\<sigma>\n  call\\<^sub>1 =\n  TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp src\\<^sub>3\n  (\\<Gamma>, src\\<^sub>3) \\<turnstile>\\<^sub>C call\\<^sub>2 \\<Rrightarrow>\n  it\n  (\\<Gamma>, src\\<^sub>3) \\<turnstile>\\<^sub>C call\\<^sub>2 \\<Rrightarrow>\n  ?call\\<^sub>2 \\<Longrightarrow>\n  it = ?call\\<^sub>2\n  it_ = new_vname \\<Gamma>\n  \\<lbrakk>?\\<Gamma> \\<turnstile>\\<^sub>E ?expr : ?\\<tau>;\n   ?\\<Gamma> \\<turnstile>\\<^sub>E ?expr : ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> ?\\<tau> = ?\\<sigma>\n  \\<lbrakk>element_type ?\\<tau> ?\\<sigma>; OclVoid[?] \\<le> ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. \\<And>src\\<^sub>2 \\<tau> call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 =\n                expr.If\n                 (OperationCall src\\<^sub>2 DotCall\n                   (Inr (Inl (Inl NotEqualOp))) [Literal NullLiteral])\n                 (Call\n                   (TypeOperationCall src\\<^sub>2 DotCall OclAsTypeOp\n                     (to_required_type \\<tau>))\n                   DotCall call\\<^sub>2)\n                 (Literal NullLiteral);\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        OclVoid[?] \\<le> \\<tau>;\n        (\\<Gamma>,\n         to_required_type\n          \\<tau>) \\<turnstile>\\<^sub>C call\\<^sub>2 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall call\\<^sub>1 ArrowCall [it_]\n                          (Some src\\<^sub>3) (Call (Var it_) DotCall it) =\n                         expr\\<^sub>2\n 2. \\<And>src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 =\n                CollectIteratorCall\n                 (TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n                   (to_required_type \\<sigma>))\n                 ArrowCall [new_vname \\<Gamma>]\n                 (Some (to_required_type \\<sigma>))\n                 (Call (Var (new_vname \\<Gamma>)) DotCall call\\<^sub>2);\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        (\\<Gamma>,\n         to_required_type\n          \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>2 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall call\\<^sub>1 ArrowCall [it_]\n                          (Some src\\<^sub>3) (Call (Var it_) DotCall it) =\n                         expr\\<^sub>2", "apply metis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 =\n                CollectIteratorCall\n                 (TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n                   (to_required_type \\<sigma>))\n                 ArrowCall [new_vname \\<Gamma>]\n                 (Some (to_required_type \\<sigma>))\n                 (Call (Var (new_vname \\<Gamma>)) DotCall call\\<^sub>2);\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        (\\<Gamma>,\n         to_required_type\n          \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>2 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall call\\<^sub>1 ArrowCall [it_]\n                          (Some src\\<^sub>3) (Call (Var it_) DotCall it) =\n                         expr\\<^sub>2", "using CollectionSafeDotCallN.hyps typing_det element_type_det"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2\n  \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  src\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>\n  element_type \\<tau> \\<sigma>\n  OclVoid[?] \\<le> \\<sigma>\n  src\\<^sub>3 = to_required_type \\<sigma>\n  call\\<^sub>1 =\n  TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp src\\<^sub>3\n  (\\<Gamma>, src\\<^sub>3) \\<turnstile>\\<^sub>C call\\<^sub>2 \\<Rrightarrow>\n  it\n  (\\<Gamma>, src\\<^sub>3) \\<turnstile>\\<^sub>C call\\<^sub>2 \\<Rrightarrow>\n  ?call\\<^sub>2 \\<Longrightarrow>\n  it = ?call\\<^sub>2\n  it_ = new_vname \\<Gamma>\n  \\<lbrakk>?\\<Gamma> \\<turnstile>\\<^sub>E ?expr : ?\\<tau>;\n   ?\\<Gamma> \\<turnstile>\\<^sub>E ?expr : ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> ?\\<tau> = ?\\<sigma>\n  \\<lbrakk>element_type ?\\<tau> ?\\<sigma>\\<^sub>1;\n   element_type ?\\<tau> ?\\<sigma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?\\<sigma>\\<^sub>1 = ?\\<sigma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>src\\<^sub>2 \\<tau> \\<sigma> call\\<^sub>2.\n       \\<lbrakk>expr\\<^sub>2 =\n                CollectIteratorCall\n                 (TypeOperationCall src\\<^sub>2 ArrowCall SelectByKindOp\n                   (to_required_type \\<sigma>))\n                 ArrowCall [new_vname \\<Gamma>]\n                 (Some (to_required_type \\<sigma>))\n                 (Call (Var (new_vname \\<Gamma>)) DotCall call\\<^sub>2);\n        \\<Gamma> \\<turnstile> src\\<^sub>1 \\<Rrightarrow> src\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>E src\\<^sub>2 : \\<tau>;\n        element_type \\<tau> \\<sigma>; OclVoid[?] \\<le> \\<sigma>;\n        (\\<Gamma>,\n         to_required_type\n          \\<sigma>) \\<turnstile>\\<^sub>C call\\<^sub>2 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> CollectIteratorCall call\\<^sub>1 ArrowCall [it_]\n                          (Some src\\<^sub>3) (Call (Var it_) DotCall it) =\n                         expr\\<^sub>2", "by metis"], ["proof (state)\nthis:\n  CollectIteratorCall call\\<^sub>1 ArrowCall [it_] (Some src\\<^sub>3)\n   (Call (Var it_) DotCall it) =\n  expr\\<^sub>2\n\ngoal (13 subgoals):\n 1. \\<And>\\<Gamma> \\<tau> op ty call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TypeOperation op ty = call\\<^sub>2\n 2. \\<And>\\<Gamma> \\<tau> attr call\\<^sub>2.\n       (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       Attribute attr = call\\<^sub>2\n 3. \\<And>\\<Gamma> \\<tau> role from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role from \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationEnd role from = call\\<^sub>2\n 4. \\<And>\\<Gamma> \\<tau> \\<A> from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A>\nfrom \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClass \\<A> from = call\\<^sub>2\n 5. \\<And>\\<Gamma> \\<tau> role call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd role \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClassEnd role = call\\<^sub>2\n 6. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Operation op\n params\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Operation op params\\<^sub>2 = call\\<^sub>2\n 7. \\<And>\\<Gamma> \\<tau> elem call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TupleElement elem = call\\<^sub>2\n 8. \\<And>\\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n                res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n res_t\\<^sub>1 res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 9. \\<And>\\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 10. \\<And>\\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter\n        call\\<^sub>2.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f\n                 fmap_of_list\n                  (map (\\<lambda>it. (it, \\<sigma>))\n                    its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n                 body\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> ++\\<^sub>f\n            fmap_of_list\n             (map (\\<lambda>it. (it, \\<sigma>))\n               its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            body\\<^sub>2 = expr\\<^sub>2;\n         (\\<Gamma>,\n          \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n  body\\<^sub>1 \\<Rrightarrow>\n         call\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                          call\\<^sub>2\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>\\<Gamma> \\<tau> op ty call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TypeOperation op ty = call\\<^sub>2\n 2. \\<And>\\<Gamma> \\<tau> attr call\\<^sub>2.\n       (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       Attribute attr = call\\<^sub>2\n 3. \\<And>\\<Gamma> \\<tau> role from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role from \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationEnd role from = call\\<^sub>2\n 4. \\<And>\\<Gamma> \\<tau> \\<A> from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A>\nfrom \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClass \\<A> from = call\\<^sub>2\n 5. \\<And>\\<Gamma> \\<tau> role call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd role \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClassEnd role = call\\<^sub>2\n 6. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Operation op\n params\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Operation op params\\<^sub>2 = call\\<^sub>2\n 7. \\<And>\\<Gamma> \\<tau> elem call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TupleElement elem = call\\<^sub>2\n 8. \\<And>\\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n                res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n res_t\\<^sub>1 res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 9. \\<And>\\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 10. \\<And>\\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter\n        call\\<^sub>2.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f\n                 fmap_of_list\n                  (map (\\<lambda>it. (it, \\<sigma>))\n                    its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n                 body\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> ++\\<^sub>f\n            fmap_of_list\n             (map (\\<lambda>it. (it, \\<sigma>))\n               its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            body\\<^sub>2 = expr\\<^sub>2;\n         (\\<Gamma>,\n          \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n  body\\<^sub>1 \\<Rrightarrow>\n         call\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                          call\\<^sub>2\nA total of 13 subgoals...", "case (TypeOperationN \\<Gamma> \\<tau> op ty)"], ["proof (state)\nthis:\n  (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n  call\\<^sub>2\n\ngoal (13 subgoals):\n 1. \\<And>\\<Gamma> \\<tau> op ty call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TypeOperation op ty = call\\<^sub>2\n 2. \\<And>\\<Gamma> \\<tau> attr call\\<^sub>2.\n       (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       Attribute attr = call\\<^sub>2\n 3. \\<And>\\<Gamma> \\<tau> role from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role from \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationEnd role from = call\\<^sub>2\n 4. \\<And>\\<Gamma> \\<tau> \\<A> from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A>\nfrom \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClass \\<A> from = call\\<^sub>2\n 5. \\<And>\\<Gamma> \\<tau> role call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd role \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClassEnd role = call\\<^sub>2\n 6. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Operation op\n params\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Operation op params\\<^sub>2 = call\\<^sub>2\n 7. \\<And>\\<Gamma> \\<tau> elem call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TupleElement elem = call\\<^sub>2\n 8. \\<And>\\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n                res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n res_t\\<^sub>1 res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 9. \\<And>\\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 10. \\<And>\\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter\n        call\\<^sub>2.\n        \\<lbrakk>\\<Gamma> ++\\<^sub>f\n                 fmap_of_list\n                  (map (\\<lambda>it. (it, \\<sigma>))\n                    its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n                 body\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> ++\\<^sub>f\n            fmap_of_list\n             (map (\\<lambda>it. (it, \\<sigma>))\n               its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            body\\<^sub>2 = expr\\<^sub>2;\n         (\\<Gamma>,\n          \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n  body\\<^sub>1 \\<Rrightarrow>\n         call\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                          call\\<^sub>2\nA total of 13 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C TypeOperation op ty \\<Rrightarrow>\n  call\\<^sub>2\n\ngoal (1 subgoal):\n 1. TypeOperation op ty = call\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  TypeOperation op ty = call\\<^sub>2\n\ngoal (12 subgoals):\n 1. \\<And>\\<Gamma> \\<tau> attr call\\<^sub>2.\n       (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       Attribute attr = call\\<^sub>2\n 2. \\<And>\\<Gamma> \\<tau> role from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role from \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationEnd role from = call\\<^sub>2\n 3. \\<And>\\<Gamma> \\<tau> \\<A> from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A>\nfrom \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClass \\<A> from = call\\<^sub>2\n 4. \\<And>\\<Gamma> \\<tau> role call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd role \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClassEnd role = call\\<^sub>2\n 5. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Operation op\n params\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Operation op params\\<^sub>2 = call\\<^sub>2\n 6. \\<And>\\<Gamma> \\<tau> elem call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TupleElement elem = call\\<^sub>2\n 7. \\<And>\\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n                res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n res_t\\<^sub>1 res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 8. \\<And>\\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 9. \\<And>\\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> ++\\<^sub>f\n                fmap_of_list\n                 (map (\\<lambda>it. (it, \\<sigma>))\n                   its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n                body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 10. \\<And>\\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter\n        call\\<^sub>2.\n        \\<lbrakk>element_type \\<tau> \\<sigma>;\n         \\<Gamma> ++\\<^sub>f\n         fmap_of_list\n          (map (\\<lambda>it. (it, \\<sigma>))\n            its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n         body\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> ++\\<^sub>f\n            fmap_of_list\n             (map (\\<lambda>it. (it, \\<sigma>))\n               its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            body\\<^sub>2 = expr\\<^sub>2;\n         (\\<Gamma>,\n          \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n  body\\<^sub>1 \\<Rrightarrow>\n         call\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                          call\\<^sub>2\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>\\<Gamma> \\<tau> attr call\\<^sub>2.\n       (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       Attribute attr = call\\<^sub>2\n 2. \\<And>\\<Gamma> \\<tau> role from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role from \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationEnd role from = call\\<^sub>2\n 3. \\<And>\\<Gamma> \\<tau> \\<A> from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A>\nfrom \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClass \\<A> from = call\\<^sub>2\n 4. \\<And>\\<Gamma> \\<tau> role call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd role \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClassEnd role = call\\<^sub>2\n 5. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Operation op\n params\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Operation op params\\<^sub>2 = call\\<^sub>2\n 6. \\<And>\\<Gamma> \\<tau> elem call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TupleElement elem = call\\<^sub>2\n 7. \\<And>\\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n                res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n res_t\\<^sub>1 res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 8. \\<And>\\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 9. \\<And>\\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> ++\\<^sub>f\n                fmap_of_list\n                 (map (\\<lambda>it. (it, \\<sigma>))\n                   its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n                body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 10. \\<And>\\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter\n        call\\<^sub>2.\n        \\<lbrakk>element_type \\<tau> \\<sigma>;\n         \\<Gamma> ++\\<^sub>f\n         fmap_of_list\n          (map (\\<lambda>it. (it, \\<sigma>))\n            its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n         body\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> ++\\<^sub>f\n            fmap_of_list\n             (map (\\<lambda>it. (it, \\<sigma>))\n               its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            body\\<^sub>2 = expr\\<^sub>2;\n         (\\<Gamma>,\n          \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n  body\\<^sub>1 \\<Rrightarrow>\n         call\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                          call\\<^sub>2\nA total of 12 subgoals...", "case (AttributeN \\<Gamma> \\<tau> attr)"], ["proof (state)\nthis:\n  (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n  call\\<^sub>2\n\ngoal (12 subgoals):\n 1. \\<And>\\<Gamma> \\<tau> attr call\\<^sub>2.\n       (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       Attribute attr = call\\<^sub>2\n 2. \\<And>\\<Gamma> \\<tau> role from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role from \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationEnd role from = call\\<^sub>2\n 3. \\<And>\\<Gamma> \\<tau> \\<A> from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A>\nfrom \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClass \\<A> from = call\\<^sub>2\n 4. \\<And>\\<Gamma> \\<tau> role call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd role \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClassEnd role = call\\<^sub>2\n 5. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Operation op\n params\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Operation op params\\<^sub>2 = call\\<^sub>2\n 6. \\<And>\\<Gamma> \\<tau> elem call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TupleElement elem = call\\<^sub>2\n 7. \\<And>\\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n                res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n res_t\\<^sub>1 res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 8. \\<And>\\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 9. \\<And>\\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> ++\\<^sub>f\n                fmap_of_list\n                 (map (\\<lambda>it. (it, \\<sigma>))\n                   its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n                body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 10. \\<And>\\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter\n        call\\<^sub>2.\n        \\<lbrakk>element_type \\<tau> \\<sigma>;\n         \\<Gamma> ++\\<^sub>f\n         fmap_of_list\n          (map (\\<lambda>it. (it, \\<sigma>))\n            its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n         body\\<^sub>2;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> ++\\<^sub>f\n            fmap_of_list\n             (map (\\<lambda>it. (it, \\<sigma>))\n               its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            body\\<^sub>2 = expr\\<^sub>2;\n         (\\<Gamma>,\n          \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n  body\\<^sub>1 \\<Rrightarrow>\n         call\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                          call\\<^sub>2\nA total of 12 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C Attribute attr \\<Rrightarrow>\n  call\\<^sub>2\n\ngoal (1 subgoal):\n 1. Attribute attr = call\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  Attribute attr = call\\<^sub>2\n\ngoal (11 subgoals):\n 1. \\<And>\\<Gamma> \\<tau> role from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role from \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationEnd role from = call\\<^sub>2\n 2. \\<And>\\<Gamma> \\<tau> \\<A> from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A>\nfrom \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClass \\<A> from = call\\<^sub>2\n 3. \\<And>\\<Gamma> \\<tau> role call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd role \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClassEnd role = call\\<^sub>2\n 4. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Operation op\n params\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Operation op params\\<^sub>2 = call\\<^sub>2\n 5. \\<And>\\<Gamma> \\<tau> elem call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TupleElement elem = call\\<^sub>2\n 6. \\<And>\\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n                res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n res_t\\<^sub>1 res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 7. \\<And>\\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 8. \\<And>\\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> ++\\<^sub>f\n                fmap_of_list\n                 (map (\\<lambda>it. (it, \\<sigma>))\n                   its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n                body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 9. \\<And>\\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter\n       call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 10. \\<And>\\<Gamma> zs.\n        \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs \\<Longrightarrow>\n        [] = zs\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>\\<Gamma> \\<tau> role from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role from \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationEnd role from = call\\<^sub>2\n 2. \\<And>\\<Gamma> \\<tau> \\<A> from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A>\nfrom \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClass \\<A> from = call\\<^sub>2\n 3. \\<And>\\<Gamma> \\<tau> role call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd role \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClassEnd role = call\\<^sub>2\n 4. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Operation op\n params\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Operation op params\\<^sub>2 = call\\<^sub>2\n 5. \\<And>\\<Gamma> \\<tau> elem call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TupleElement elem = call\\<^sub>2\n 6. \\<And>\\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n                res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n res_t\\<^sub>1 res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 7. \\<And>\\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 8. \\<And>\\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> ++\\<^sub>f\n                fmap_of_list\n                 (map (\\<lambda>it. (it, \\<sigma>))\n                   its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n                body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 9. \\<And>\\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter\n       call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 10. \\<And>\\<Gamma> zs.\n        \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs \\<Longrightarrow>\n        [] = zs\nA total of 11 subgoals...", "case (AssociationEndN \\<Gamma> \\<tau> role \"from\")"], ["proof (state)\nthis:\n  (\\<Gamma>,\n   \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role from \\<Rrightarrow>\n  call\\<^sub>2\n\ngoal (11 subgoals):\n 1. \\<And>\\<Gamma> \\<tau> role from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role from \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationEnd role from = call\\<^sub>2\n 2. \\<And>\\<Gamma> \\<tau> \\<A> from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A>\nfrom \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClass \\<A> from = call\\<^sub>2\n 3. \\<And>\\<Gamma> \\<tau> role call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd role \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClassEnd role = call\\<^sub>2\n 4. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Operation op\n params\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Operation op params\\<^sub>2 = call\\<^sub>2\n 5. \\<And>\\<Gamma> \\<tau> elem call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TupleElement elem = call\\<^sub>2\n 6. \\<And>\\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n                res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n res_t\\<^sub>1 res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 7. \\<And>\\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 8. \\<And>\\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> ++\\<^sub>f\n                fmap_of_list\n                 (map (\\<lambda>it. (it, \\<sigma>))\n                   its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n                body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 9. \\<And>\\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter\n       call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 10. \\<And>\\<Gamma> zs.\n        \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs \\<Longrightarrow>\n        [] = zs\nA total of 11 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  (\\<Gamma>,\n   \\<tau>) \\<turnstile>\\<^sub>C AssociationEnd role from \\<Rrightarrow>\n  call\\<^sub>2\n\ngoal (1 subgoal):\n 1. AssociationEnd role from = call\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  AssociationEnd role from = call\\<^sub>2\n\ngoal (10 subgoals):\n 1. \\<And>\\<Gamma> \\<tau> \\<A> from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A>\nfrom \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClass \\<A> from = call\\<^sub>2\n 2. \\<And>\\<Gamma> \\<tau> role call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd role \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClassEnd role = call\\<^sub>2\n 3. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Operation op\n params\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Operation op params\\<^sub>2 = call\\<^sub>2\n 4. \\<And>\\<Gamma> \\<tau> elem call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TupleElement elem = call\\<^sub>2\n 5. \\<And>\\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n                res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n res_t\\<^sub>1 res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 6. \\<And>\\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 7. \\<And>\\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> ++\\<^sub>f\n                fmap_of_list\n                 (map (\\<lambda>it. (it, \\<sigma>))\n                   its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n                body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 8. \\<And>\\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter\n       call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 9. \\<And>\\<Gamma> zs.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs \\<Longrightarrow>\n       [] = zs\n 10. \\<And>\\<Gamma> x y xs ys zs.\n        \\<lbrakk>\\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> \\<turnstile> x \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            y = expr\\<^sub>2;\n         \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n         \\<And>zs.\n            \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow>\n            zs \\<Longrightarrow>\n            ys = zs;\n         \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\\<rbrakk>\n        \\<Longrightarrow> y # ys = zs", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>\\<Gamma> \\<tau> \\<A> from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A>\nfrom \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClass \\<A> from = call\\<^sub>2\n 2. \\<And>\\<Gamma> \\<tau> role call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd role \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClassEnd role = call\\<^sub>2\n 3. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Operation op\n params\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Operation op params\\<^sub>2 = call\\<^sub>2\n 4. \\<And>\\<Gamma> \\<tau> elem call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TupleElement elem = call\\<^sub>2\n 5. \\<And>\\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n                res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n res_t\\<^sub>1 res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 6. \\<And>\\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 7. \\<And>\\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> ++\\<^sub>f\n                fmap_of_list\n                 (map (\\<lambda>it. (it, \\<sigma>))\n                   its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n                body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 8. \\<And>\\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter\n       call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 9. \\<And>\\<Gamma> zs.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs \\<Longrightarrow>\n       [] = zs\n 10. \\<And>\\<Gamma> x y xs ys zs.\n        \\<lbrakk>\\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> \\<turnstile> x \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            y = expr\\<^sub>2;\n         \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n         \\<And>zs.\n            \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow>\n            zs \\<Longrightarrow>\n            ys = zs;\n         \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\\<rbrakk>\n        \\<Longrightarrow> y # ys = zs", "case (AssociationClassN \\<Gamma> \\<tau> \\<A> \"from\")"], ["proof (state)\nthis:\n  (\\<Gamma>,\n   \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A> from \\<Rrightarrow>\n  call\\<^sub>2\n\ngoal (10 subgoals):\n 1. \\<And>\\<Gamma> \\<tau> \\<A> from call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A>\nfrom \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClass \\<A> from = call\\<^sub>2\n 2. \\<And>\\<Gamma> \\<tau> role call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd role \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClassEnd role = call\\<^sub>2\n 3. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Operation op\n params\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Operation op params\\<^sub>2 = call\\<^sub>2\n 4. \\<And>\\<Gamma> \\<tau> elem call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TupleElement elem = call\\<^sub>2\n 5. \\<And>\\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n                res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n res_t\\<^sub>1 res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 6. \\<And>\\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 7. \\<And>\\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> ++\\<^sub>f\n                fmap_of_list\n                 (map (\\<lambda>it. (it, \\<sigma>))\n                   its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n                body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 8. \\<And>\\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter\n       call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 9. \\<And>\\<Gamma> zs.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs \\<Longrightarrow>\n       [] = zs\n 10. \\<And>\\<Gamma> x y xs ys zs.\n        \\<lbrakk>\\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n         \\<And>expr\\<^sub>2.\n            \\<Gamma> \\<turnstile> x \\<Rrightarrow>\n            expr\\<^sub>2 \\<Longrightarrow>\n            y = expr\\<^sub>2;\n         \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n         \\<And>zs.\n            \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow>\n            zs \\<Longrightarrow>\n            ys = zs;\n         \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\\<rbrakk>\n        \\<Longrightarrow> y # ys = zs", "thus ?case"], ["proof (prove)\nusing this:\n  (\\<Gamma>,\n   \\<tau>) \\<turnstile>\\<^sub>C AssociationClass \\<A> from \\<Rrightarrow>\n  call\\<^sub>2\n\ngoal (1 subgoal):\n 1. AssociationClass \\<A> from = call\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  AssociationClass \\<A> from = call\\<^sub>2\n\ngoal (9 subgoals):\n 1. \\<And>\\<Gamma> \\<tau> role call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd role \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClassEnd role = call\\<^sub>2\n 2. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Operation op\n params\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Operation op params\\<^sub>2 = call\\<^sub>2\n 3. \\<And>\\<Gamma> \\<tau> elem call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TupleElement elem = call\\<^sub>2\n 4. \\<And>\\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n                res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n res_t\\<^sub>1 res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 5. \\<And>\\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 6. \\<And>\\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> ++\\<^sub>f\n                fmap_of_list\n                 (map (\\<lambda>it. (it, \\<sigma>))\n                   its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n                body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 7. \\<And>\\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter\n       call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 8. \\<And>\\<Gamma> zs.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs \\<Longrightarrow>\n       [] = zs\n 9. \\<And>\\<Gamma> x y xs ys zs.\n       \\<lbrakk>\\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> x \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           y = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           ys = zs;\n        \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\\<rbrakk>\n       \\<Longrightarrow> y # ys = zs", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>\\<Gamma> \\<tau> role call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd role \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClassEnd role = call\\<^sub>2\n 2. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Operation op\n params\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Operation op params\\<^sub>2 = call\\<^sub>2\n 3. \\<And>\\<Gamma> \\<tau> elem call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TupleElement elem = call\\<^sub>2\n 4. \\<And>\\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n                res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n res_t\\<^sub>1 res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 5. \\<And>\\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 6. \\<And>\\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> ++\\<^sub>f\n                fmap_of_list\n                 (map (\\<lambda>it. (it, \\<sigma>))\n                   its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n                body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 7. \\<And>\\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter\n       call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 8. \\<And>\\<Gamma> zs.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs \\<Longrightarrow>\n       [] = zs\n 9. \\<And>\\<Gamma> x y xs ys zs.\n       \\<lbrakk>\\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> x \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           y = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           ys = zs;\n        \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\\<rbrakk>\n       \\<Longrightarrow> y # ys = zs", "case (AssociationClassEndN \\<Gamma> \\<tau> role)"], ["proof (state)\nthis:\n  (\\<Gamma>,\n   \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd role \\<Rrightarrow>\n  call\\<^sub>2\n\ngoal (9 subgoals):\n 1. \\<And>\\<Gamma> \\<tau> role call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd role \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       AssociationClassEnd role = call\\<^sub>2\n 2. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Operation op\n params\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Operation op params\\<^sub>2 = call\\<^sub>2\n 3. \\<And>\\<Gamma> \\<tau> elem call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TupleElement elem = call\\<^sub>2\n 4. \\<And>\\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n                res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n res_t\\<^sub>1 res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 5. \\<And>\\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 6. \\<And>\\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> ++\\<^sub>f\n                fmap_of_list\n                 (map (\\<lambda>it. (it, \\<sigma>))\n                   its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n                body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 7. \\<And>\\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter\n       call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 8. \\<And>\\<Gamma> zs.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs \\<Longrightarrow>\n       [] = zs\n 9. \\<And>\\<Gamma> x y xs ys zs.\n       \\<lbrakk>\\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> x \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           y = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           ys = zs;\n        \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\\<rbrakk>\n       \\<Longrightarrow> y # ys = zs", "thus ?case"], ["proof (prove)\nusing this:\n  (\\<Gamma>,\n   \\<tau>) \\<turnstile>\\<^sub>C AssociationClassEnd role \\<Rrightarrow>\n  call\\<^sub>2\n\ngoal (1 subgoal):\n 1. AssociationClassEnd role = call\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  AssociationClassEnd role = call\\<^sub>2\n\ngoal (8 subgoals):\n 1. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Operation op\n params\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Operation op params\\<^sub>2 = call\\<^sub>2\n 2. \\<And>\\<Gamma> \\<tau> elem call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TupleElement elem = call\\<^sub>2\n 3. \\<And>\\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n                res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n res_t\\<^sub>1 res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 4. \\<And>\\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 5. \\<And>\\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> ++\\<^sub>f\n                fmap_of_list\n                 (map (\\<lambda>it. (it, \\<sigma>))\n                   its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n                body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 6. \\<And>\\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter\n       call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 7. \\<And>\\<Gamma> zs.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs \\<Longrightarrow>\n       [] = zs\n 8. \\<And>\\<Gamma> x y xs ys zs.\n       \\<lbrakk>\\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> x \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           y = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           ys = zs;\n        \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\\<rbrakk>\n       \\<Longrightarrow> y # ys = zs", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Operation op\n params\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Operation op params\\<^sub>2 = call\\<^sub>2\n 2. \\<And>\\<Gamma> \\<tau> elem call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TupleElement elem = call\\<^sub>2\n 3. \\<And>\\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n                res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n res_t\\<^sub>1 res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 4. \\<And>\\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 5. \\<And>\\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> ++\\<^sub>f\n                fmap_of_list\n                 (map (\\<lambda>it. (it, \\<sigma>))\n                   its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n                body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 6. \\<And>\\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter\n       call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 7. \\<And>\\<Gamma> zs.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs \\<Longrightarrow>\n       [] = zs\n 8. \\<And>\\<Gamma> x y xs ys zs.\n       \\<lbrakk>\\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> x \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           y = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           ys = zs;\n        \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\\<rbrakk>\n       \\<Longrightarrow> y # ys = zs", "case (OperationN \\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow> params\\<^sub>2\n  \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n  ?zs \\<Longrightarrow>\n  params\\<^sub>2 = ?zs\n  (\\<Gamma>,\n   \\<tau>) \\<turnstile>\\<^sub>C Operation op params\\<^sub>1 \\<Rrightarrow>\n  call\\<^sub>2\n\ngoal (8 subgoals):\n 1. \\<And>\\<Gamma> params\\<^sub>1 params\\<^sub>2 \\<tau> op call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n                params\\<^sub>2;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           params\\<^sub>2 = zs;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Operation op\n params\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Operation op params\\<^sub>2 = call\\<^sub>2\n 2. \\<And>\\<Gamma> \\<tau> elem call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TupleElement elem = call\\<^sub>2\n 3. \\<And>\\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n                res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n res_t\\<^sub>1 res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 4. \\<And>\\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 5. \\<And>\\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> ++\\<^sub>f\n                fmap_of_list\n                 (map (\\<lambda>it. (it, \\<sigma>))\n                   its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n                body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 6. \\<And>\\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter\n       call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 7. \\<And>\\<Gamma> zs.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs \\<Longrightarrow>\n       [] = zs\n 8. \\<And>\\<Gamma> x y xs ys zs.\n       \\<lbrakk>\\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> x \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           y = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           ys = zs;\n        \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\\<rbrakk>\n       \\<Longrightarrow> y # ys = zs", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow> params\\<^sub>2\n  \\<Gamma> \\<turnstile>\\<^sub>L params\\<^sub>1 \\<Rrightarrow>\n  ?zs \\<Longrightarrow>\n  params\\<^sub>2 = ?zs\n  (\\<Gamma>,\n   \\<tau>) \\<turnstile>\\<^sub>C Operation op params\\<^sub>1 \\<Rrightarrow>\n  call\\<^sub>2\n\ngoal (1 subgoal):\n 1. Operation op params\\<^sub>2 = call\\<^sub>2", "by blast"], ["proof (state)\nthis:\n  Operation op params\\<^sub>2 = call\\<^sub>2\n\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> \\<tau> elem call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TupleElement elem = call\\<^sub>2\n 2. \\<And>\\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n                res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n res_t\\<^sub>1 res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 3. \\<And>\\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 4. \\<And>\\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> ++\\<^sub>f\n                fmap_of_list\n                 (map (\\<lambda>it. (it, \\<sigma>))\n                   its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n                body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 5. \\<And>\\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter\n       call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 6. \\<And>\\<Gamma> zs.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs \\<Longrightarrow>\n       [] = zs\n 7. \\<And>\\<Gamma> x y xs ys zs.\n       \\<lbrakk>\\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> x \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           y = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           ys = zs;\n        \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\\<rbrakk>\n       \\<Longrightarrow> y # ys = zs", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> \\<tau> elem call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TupleElement elem = call\\<^sub>2\n 2. \\<And>\\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n                res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n res_t\\<^sub>1 res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 3. \\<And>\\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 4. \\<And>\\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> ++\\<^sub>f\n                fmap_of_list\n                 (map (\\<lambda>it. (it, \\<sigma>))\n                   its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n                body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 5. \\<And>\\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter\n       call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 6. \\<And>\\<Gamma> zs.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs \\<Longrightarrow>\n       [] = zs\n 7. \\<And>\\<Gamma> x y xs ys zs.\n       \\<lbrakk>\\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> x \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           y = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           ys = zs;\n        \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\\<rbrakk>\n       \\<Longrightarrow> y # ys = zs", "case (TupleElementN \\<Gamma> \\<tau> elem)"], ["proof (state)\nthis:\n  (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n  call\\<^sub>2\n\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> \\<tau> elem call\\<^sub>2.\n       (\\<Gamma>,\n        \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n       call\\<^sub>2 \\<Longrightarrow>\n       TupleElement elem = call\\<^sub>2\n 2. \\<And>\\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n                res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n res_t\\<^sub>1 res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 3. \\<And>\\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 4. \\<And>\\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> ++\\<^sub>f\n                fmap_of_list\n                 (map (\\<lambda>it. (it, \\<sigma>))\n                   its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n                body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 5. \\<And>\\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter\n       call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 6. \\<And>\\<Gamma> zs.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs \\<Longrightarrow>\n       [] = zs\n 7. \\<And>\\<Gamma> x y xs ys zs.\n       \\<lbrakk>\\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> x \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           y = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           ys = zs;\n        \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\\<rbrakk>\n       \\<Longrightarrow> y # ys = zs", "thus ?case"], ["proof (prove)\nusing this:\n  (\\<Gamma>, \\<tau>) \\<turnstile>\\<^sub>C TupleElement elem \\<Rrightarrow>\n  call\\<^sub>2\n\ngoal (1 subgoal):\n 1. TupleElement elem = call\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  TupleElement elem = call\\<^sub>2\n\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n                res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n res_t\\<^sub>1 res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 2. \\<And>\\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 3. \\<And>\\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> ++\\<^sub>f\n                fmap_of_list\n                 (map (\\<lambda>it. (it, \\<sigma>))\n                   its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n                body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 4. \\<And>\\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter\n       call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 5. \\<And>\\<Gamma> zs.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs \\<Longrightarrow>\n       [] = zs\n 6. \\<And>\\<Gamma> x y xs ys zs.\n       \\<lbrakk>\\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> x \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           y = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           ys = zs;\n        \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\\<rbrakk>\n       \\<Longrightarrow> y # ys = zs", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n                res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n res_t\\<^sub>1 res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 2. \\<And>\\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 3. \\<And>\\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> ++\\<^sub>f\n                fmap_of_list\n                 (map (\\<lambda>it. (it, \\<sigma>))\n                   its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n                body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 4. \\<And>\\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter\n       call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 5. \\<And>\\<Gamma> zs.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs \\<Longrightarrow>\n       [] = zs\n 6. \\<And>\\<Gamma> x y xs ys zs.\n       \\<lbrakk>\\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> x \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           y = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           ys = zs;\n        \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\\<rbrakk>\n       \\<Longrightarrow> y # ys = zs", "case (ExplicitlyTypedIterateN\n    \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow> res_init\\<^sub>2\n  \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  res_init\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> ++\\<^sub>f\n  fmap_of_list\n   (map (\\<lambda>it. (it, \\<sigma>))\n     its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                        body\\<^sub>1 \\<Rrightarrow>\n  expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2\n  \\<Gamma> ++\\<^sub>f\n  fmap_of_list\n   (map (\\<lambda>it. (it, \\<sigma>))\n     its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                        body\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 = ?expr\\<^sub>2\n  (\\<Gamma>,\n   \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n                                 res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n  call\\<^sub>2\n\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 \\<sigma> its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 \\<tau>\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n                res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n res_t\\<^sub>1 res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 2. \\<And>\\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 3. \\<And>\\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> ++\\<^sub>f\n                fmap_of_list\n                 (map (\\<lambda>it. (it, \\<sigma>))\n                   its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n                body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 4. \\<And>\\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter\n       call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 5. \\<And>\\<Gamma> zs.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs \\<Longrightarrow>\n       [] = zs\n 6. \\<And>\\<Gamma> x y xs ys zs.\n       \\<lbrakk>\\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> x \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           y = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           ys = zs;\n        \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\\<rbrakk>\n       \\<Longrightarrow> y # ys = zs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Iterate its (Some \\<sigma>) res res_t\\<^sub>2 res_init\\<^sub>2\n     body\\<^sub>2 =\n    call\\<^sub>2", "apply (insert ExplicitlyTypedIterateN.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Gamma>,\n     \\<tau>) \\<turnstile>\\<^sub>C Iterate its (Some \\<sigma>) res\n                                   res_t\\<^sub>1 res_init\\<^sub>1\n                                   body\\<^sub>1 \\<Rrightarrow>\n    call\\<^sub>2 \\<Longrightarrow>\n    Iterate its (Some \\<sigma>) res res_t\\<^sub>2 res_init\\<^sub>2\n     body\\<^sub>2 =\n    call\\<^sub>2", "apply (erule IterateCallNE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>res_init\\<^sub>2' \\<sigma>' res_t\\<^sub>2' body\\<^sub>2'.\n       \\<lbrakk>Some \\<sigma> = Some \\<sigma>';\n        call\\<^sub>2 =\n        Iterate its (Some \\<sigma>') res res_t\\<^sub>2' res_init\\<^sub>2'\n         body\\<^sub>2';\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2';\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>'))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2' res_init\\<^sub>2' body\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 2. \\<And>\\<sigma>' res_init\\<^sub>2' res_t\\<^sub>2' body\\<^sub>2'.\n       \\<lbrakk>Some \\<sigma> = None;\n        call\\<^sub>2 =\n        Iterate its (Some \\<sigma>') res res_t\\<^sub>2' res_init\\<^sub>2'\n         body\\<^sub>2';\n        element_type \\<tau> \\<sigma>';\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2';\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>'))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2' res_init\\<^sub>2' body\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2", "using ExplicitlyTypedIterateN.hyps element_type_det"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow> res_init\\<^sub>2\n  \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  res_init\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> ++\\<^sub>f\n  fmap_of_list\n   (map (\\<lambda>it. (it, \\<sigma>))\n     its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                        body\\<^sub>1 \\<Rrightarrow>\n  expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2\n  \\<Gamma> ++\\<^sub>f\n  fmap_of_list\n   (map (\\<lambda>it. (it, \\<sigma>))\n     its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                        body\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 = ?expr\\<^sub>2\n  \\<lbrakk>element_type ?\\<tau> ?\\<sigma>\\<^sub>1;\n   element_type ?\\<tau> ?\\<sigma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?\\<sigma>\\<^sub>1 = ?\\<sigma>\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>res_init\\<^sub>2' \\<sigma>' res_t\\<^sub>2' body\\<^sub>2'.\n       \\<lbrakk>Some \\<sigma> = Some \\<sigma>';\n        call\\<^sub>2 =\n        Iterate its (Some \\<sigma>') res res_t\\<^sub>2' res_init\\<^sub>2'\n         body\\<^sub>2';\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2';\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>'))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2' res_init\\<^sub>2' body\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 2. \\<And>\\<sigma>' res_init\\<^sub>2' res_t\\<^sub>2' body\\<^sub>2'.\n       \\<lbrakk>Some \\<sigma> = None;\n        call\\<^sub>2 =\n        Iterate its (Some \\<sigma>') res res_t\\<^sub>2' res_init\\<^sub>2'\n         body\\<^sub>2';\n        element_type \\<tau> \\<sigma>';\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2';\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>'))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2' res_init\\<^sub>2' body\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2", "by blast+"], ["proof (state)\nthis:\n  Iterate its (Some \\<sigma>) res res_t\\<^sub>2 res_init\\<^sub>2\n   body\\<^sub>2 =\n  call\\<^sub>2\n\ngoal (5 subgoals):\n 1. \\<And>\\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 2. \\<And>\\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> ++\\<^sub>f\n                fmap_of_list\n                 (map (\\<lambda>it. (it, \\<sigma>))\n                   its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n                body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 3. \\<And>\\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter\n       call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 4. \\<And>\\<Gamma> zs.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs \\<Longrightarrow>\n       [] = zs\n 5. \\<And>\\<Gamma> x y xs ys zs.\n       \\<lbrakk>\\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> x \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           y = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           ys = zs;\n        \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\\<rbrakk>\n       \\<Longrightarrow> y # ys = zs", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 2. \\<And>\\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> ++\\<^sub>f\n                fmap_of_list\n                 (map (\\<lambda>it. (it, \\<sigma>))\n                   its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n                body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 3. \\<And>\\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter\n       call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 4. \\<And>\\<Gamma> zs.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs \\<Longrightarrow>\n       [] = zs\n 5. \\<And>\\<Gamma> x y xs ys zs.\n       \\<lbrakk>\\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> x \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           y = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           ys = zs;\n        \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\\<rbrakk>\n       \\<Longrightarrow> y # ys = zs", "case (ImplicitlyTypedIterateN\n    \\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its res res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2)"], ["proof (state)\nthis:\n  element_type \\<tau> \\<sigma>\n  \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow> res_init\\<^sub>2\n  \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  res_init\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> ++\\<^sub>f\n  fmap_of_list\n   (map (\\<lambda>it. (it, \\<sigma>))\n     its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                        body\\<^sub>1 \\<Rrightarrow>\n  expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2\n  \\<Gamma> ++\\<^sub>f\n  fmap_of_list\n   (map (\\<lambda>it. (it, \\<sigma>))\n     its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                        body\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 = ?expr\\<^sub>2\n  (\\<Gamma>,\n   \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n                                 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n  call\\<^sub>2\n\ngoal (5 subgoals):\n 1. \\<And>\\<tau> \\<sigma> \\<Gamma> res_init\\<^sub>1 res_init\\<^sub>2 its res\n       res_t\\<^sub>1 body\\<^sub>1 res_t\\<^sub>2 body\\<^sub>2 call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           res_init\\<^sub>2 = expr\\<^sub>2;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                                 body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 =\n           expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n res_init\\<^sub>1 body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 2. \\<And>\\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> ++\\<^sub>f\n                fmap_of_list\n                 (map (\\<lambda>it. (it, \\<sigma>))\n                   its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n                body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 3. \\<And>\\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter\n       call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 4. \\<And>\\<Gamma> zs.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs \\<Longrightarrow>\n       [] = zs\n 5. \\<And>\\<Gamma> x y xs ys zs.\n       \\<lbrakk>\\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> x \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           y = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           ys = zs;\n        \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\\<rbrakk>\n       \\<Longrightarrow> y # ys = zs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Iterate its (Some \\<sigma>) res res_t\\<^sub>2 res_init\\<^sub>2\n     body\\<^sub>2 =\n    call\\<^sub>2", "apply (insert ImplicitlyTypedIterateN.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Gamma>,\n     \\<tau>) \\<turnstile>\\<^sub>C Iterate its None res res_t\\<^sub>1\n                                   res_init\\<^sub>1\n                                   body\\<^sub>1 \\<Rrightarrow>\n    call\\<^sub>2 \\<Longrightarrow>\n    Iterate its (Some \\<sigma>) res res_t\\<^sub>2 res_init\\<^sub>2\n     body\\<^sub>2 =\n    call\\<^sub>2", "apply (erule IterateCallNE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>res_init\\<^sub>2' \\<sigma>' res_t\\<^sub>2' body\\<^sub>2'.\n       \\<lbrakk>None = Some \\<sigma>';\n        call\\<^sub>2 =\n        Iterate its (Some \\<sigma>') res res_t\\<^sub>2' res_init\\<^sub>2'\n         body\\<^sub>2';\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2';\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>'))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2' res_init\\<^sub>2' body\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 2. \\<And>\\<sigma>' res_init\\<^sub>2' res_t\\<^sub>2' body\\<^sub>2'.\n       \\<lbrakk>None = None;\n        call\\<^sub>2 =\n        Iterate its (Some \\<sigma>') res res_t\\<^sub>2' res_init\\<^sub>2'\n         body\\<^sub>2';\n        element_type \\<tau> \\<sigma>';\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2';\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>'))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2' res_init\\<^sub>2' body\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2", "using ImplicitlyTypedIterateN.hyps element_type_det"], ["proof (prove)\nusing this:\n  element_type \\<tau> \\<sigma>\n  \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow> res_init\\<^sub>2\n  \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  res_init\\<^sub>2 = ?expr\\<^sub>2\n  \\<Gamma> ++\\<^sub>f\n  fmap_of_list\n   (map (\\<lambda>it. (it, \\<sigma>))\n     its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                        body\\<^sub>1 \\<Rrightarrow>\n  expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2\n  \\<Gamma> ++\\<^sub>f\n  fmap_of_list\n   (map (\\<lambda>it. (it, \\<sigma>))\n     its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                        body\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  expr.Let res res_t\\<^sub>2 res_init\\<^sub>2 body\\<^sub>2 = ?expr\\<^sub>2\n  \\<lbrakk>element_type ?\\<tau> ?\\<sigma>\\<^sub>1;\n   element_type ?\\<tau> ?\\<sigma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?\\<sigma>\\<^sub>1 = ?\\<sigma>\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>res_init\\<^sub>2' \\<sigma>' res_t\\<^sub>2' body\\<^sub>2'.\n       \\<lbrakk>None = Some \\<sigma>';\n        call\\<^sub>2 =\n        Iterate its (Some \\<sigma>') res res_t\\<^sub>2' res_init\\<^sub>2'\n         body\\<^sub>2';\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2';\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>'))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2' res_init\\<^sub>2' body\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2\n 2. \\<And>\\<sigma>' res_init\\<^sub>2' res_t\\<^sub>2' body\\<^sub>2'.\n       \\<lbrakk>None = None;\n        call\\<^sub>2 =\n        Iterate its (Some \\<sigma>') res res_t\\<^sub>2' res_init\\<^sub>2'\n         body\\<^sub>2';\n        element_type \\<tau> \\<sigma>';\n        \\<Gamma> \\<turnstile> res_init\\<^sub>1 \\<Rrightarrow>\n        res_init\\<^sub>2';\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>'))\n           its) \\<turnstile> expr.Let res res_t\\<^sub>1 res_init\\<^sub>1\n                              body\\<^sub>1 \\<Rrightarrow>\n        expr.Let res res_t\\<^sub>2' res_init\\<^sub>2' body\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> Iterate its (Some \\<sigma>) res res_t\\<^sub>2\n                          res_init\\<^sub>2 body\\<^sub>2 =\n                         call\\<^sub>2", "by blast+"], ["proof (state)\nthis:\n  Iterate its (Some \\<sigma>) res res_t\\<^sub>2 res_init\\<^sub>2\n   body\\<^sub>2 =\n  call\\<^sub>2\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> ++\\<^sub>f\n                fmap_of_list\n                 (map (\\<lambda>it. (it, \\<sigma>))\n                   its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n                body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 2. \\<And>\\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter\n       call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 3. \\<And>\\<Gamma> zs.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs \\<Longrightarrow>\n       [] = zs\n 4. \\<And>\\<Gamma> x y xs ys zs.\n       \\<lbrakk>\\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> x \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           y = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           ys = zs;\n        \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\\<rbrakk>\n       \\<Longrightarrow> y # ys = zs", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> ++\\<^sub>f\n                fmap_of_list\n                 (map (\\<lambda>it. (it, \\<sigma>))\n                   its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n                body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 2. \\<And>\\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter\n       call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 3. \\<And>\\<Gamma> zs.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs \\<Longrightarrow>\n       [] = zs\n 4. \\<And>\\<Gamma> x y xs ys zs.\n       \\<lbrakk>\\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> x \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           y = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           ys = zs;\n        \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\\<rbrakk>\n       \\<Longrightarrow> y # ys = zs", "case (ExplicitlyTypedIteratorN \\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter)"], ["proof (state)\nthis:\n  \\<Gamma> ++\\<^sub>f\n  fmap_of_list\n   (map (\\<lambda>it. (it, \\<sigma>))\n     its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n  body\\<^sub>2\n  \\<Gamma> ++\\<^sub>f\n  fmap_of_list\n   (map (\\<lambda>it. (it, \\<sigma>))\n     its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  body\\<^sub>2 = ?expr\\<^sub>2\n  (\\<Gamma>,\n   \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n                                 body\\<^sub>1 \\<Rrightarrow>\n  call\\<^sub>2\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> \\<sigma> its body\\<^sub>1 body\\<^sub>2 \\<tau> iter\n       call\\<^sub>2.\n       \\<lbrakk>\\<Gamma> ++\\<^sub>f\n                fmap_of_list\n                 (map (\\<lambda>it. (it, \\<sigma>))\n                   its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n                body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 2. \\<And>\\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter\n       call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 3. \\<And>\\<Gamma> zs.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs \\<Longrightarrow>\n       [] = zs\n 4. \\<And>\\<Gamma> x y xs ys zs.\n       \\<lbrakk>\\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> x \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           y = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           ys = zs;\n        \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\\<rbrakk>\n       \\<Longrightarrow> y # ys = zs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Iterator iter its (Some \\<sigma>) body\\<^sub>2 = call\\<^sub>2", "apply (insert ExplicitlyTypedIteratorN.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Gamma>,\n     \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its (Some \\<sigma>)\n                                   body\\<^sub>1 \\<Rrightarrow>\n    call\\<^sub>2 \\<Longrightarrow>\n    Iterator iter its (Some \\<sigma>) body\\<^sub>2 = call\\<^sub>2", "apply (erule IteratorCallNE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>' body\\<^sub>2'.\n       \\<lbrakk>Some \\<sigma> = Some \\<sigma>';\n        call\\<^sub>2 = Iterator iter its (Some \\<sigma>') body\\<^sub>2';\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>'))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 2. \\<And>\\<sigma>' body\\<^sub>2'.\n       \\<lbrakk>Some \\<sigma> = None;\n        call\\<^sub>2 = Iterator iter its (Some \\<sigma>') body\\<^sub>2';\n        element_type \\<tau> \\<sigma>';\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>'))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2", "using ExplicitlyTypedIteratorN.hyps element_type_det"], ["proof (prove)\nusing this:\n  \\<Gamma> ++\\<^sub>f\n  fmap_of_list\n   (map (\\<lambda>it. (it, \\<sigma>))\n     its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n  body\\<^sub>2\n  \\<Gamma> ++\\<^sub>f\n  fmap_of_list\n   (map (\\<lambda>it. (it, \\<sigma>))\n     its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  body\\<^sub>2 = ?expr\\<^sub>2\n  \\<lbrakk>element_type ?\\<tau> ?\\<sigma>\\<^sub>1;\n   element_type ?\\<tau> ?\\<sigma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?\\<sigma>\\<^sub>1 = ?\\<sigma>\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>' body\\<^sub>2'.\n       \\<lbrakk>Some \\<sigma> = Some \\<sigma>';\n        call\\<^sub>2 = Iterator iter its (Some \\<sigma>') body\\<^sub>2';\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>'))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 2. \\<And>\\<sigma>' body\\<^sub>2'.\n       \\<lbrakk>Some \\<sigma> = None;\n        call\\<^sub>2 = Iterator iter its (Some \\<sigma>') body\\<^sub>2';\n        element_type \\<tau> \\<sigma>';\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>'))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2", "by blast+"], ["proof (state)\nthis:\n  Iterator iter its (Some \\<sigma>) body\\<^sub>2 = call\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>\\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter\n       call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 2. \\<And>\\<Gamma> zs.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs \\<Longrightarrow>\n       [] = zs\n 3. \\<And>\\<Gamma> x y xs ys zs.\n       \\<lbrakk>\\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> x \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           y = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           ys = zs;\n        \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\\<rbrakk>\n       \\<Longrightarrow> y # ys = zs", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter\n       call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 2. \\<And>\\<Gamma> zs.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs \\<Longrightarrow>\n       [] = zs\n 3. \\<And>\\<Gamma> x y xs ys zs.\n       \\<lbrakk>\\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> x \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           y = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           ys = zs;\n        \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\\<rbrakk>\n       \\<Longrightarrow> y # ys = zs", "case (ImplicitlyTypedIteratorN \\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter)"], ["proof (state)\nthis:\n  element_type \\<tau> \\<sigma>\n  \\<Gamma> ++\\<^sub>f\n  fmap_of_list\n   (map (\\<lambda>it. (it, \\<sigma>))\n     its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n  body\\<^sub>2\n  \\<Gamma> ++\\<^sub>f\n  fmap_of_list\n   (map (\\<lambda>it. (it, \\<sigma>))\n     its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  body\\<^sub>2 = ?expr\\<^sub>2\n  (\\<Gamma>,\n   \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n                                 body\\<^sub>1 \\<Rrightarrow>\n  call\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>\\<tau> \\<sigma> \\<Gamma> its body\\<^sub>1 body\\<^sub>2 iter\n       call\\<^sub>2.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list\n            (map (\\<lambda>it. (it, \\<sigma>))\n              its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           body\\<^sub>2 = expr\\<^sub>2;\n        (\\<Gamma>,\n         \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n body\\<^sub>1 \\<Rrightarrow>\n        call\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 2. \\<And>\\<Gamma> zs.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs \\<Longrightarrow>\n       [] = zs\n 3. \\<And>\\<Gamma> x y xs ys zs.\n       \\<lbrakk>\\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> x \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           y = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           ys = zs;\n        \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\\<rbrakk>\n       \\<Longrightarrow> y # ys = zs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Iterator iter its (Some \\<sigma>) body\\<^sub>2 = call\\<^sub>2", "apply (insert ImplicitlyTypedIteratorN.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Gamma>,\n     \\<tau>) \\<turnstile>\\<^sub>C Iterator iter its None\n                                   body\\<^sub>1 \\<Rrightarrow>\n    call\\<^sub>2 \\<Longrightarrow>\n    Iterator iter its (Some \\<sigma>) body\\<^sub>2 = call\\<^sub>2", "apply (erule IteratorCallNE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>' body\\<^sub>2'.\n       \\<lbrakk>None = Some \\<sigma>';\n        call\\<^sub>2 = Iterator iter its (Some \\<sigma>') body\\<^sub>2';\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>'))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 2. \\<And>\\<sigma>' body\\<^sub>2'.\n       \\<lbrakk>None = None;\n        call\\<^sub>2 = Iterator iter its (Some \\<sigma>') body\\<^sub>2';\n        element_type \\<tau> \\<sigma>';\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>'))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2", "using ImplicitlyTypedIteratorN.hyps element_type_det"], ["proof (prove)\nusing this:\n  element_type \\<tau> \\<sigma>\n  \\<Gamma> ++\\<^sub>f\n  fmap_of_list\n   (map (\\<lambda>it. (it, \\<sigma>))\n     its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n  body\\<^sub>2\n  \\<Gamma> ++\\<^sub>f\n  fmap_of_list\n   (map (\\<lambda>it. (it, \\<sigma>))\n     its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n  ?expr\\<^sub>2 \\<Longrightarrow>\n  body\\<^sub>2 = ?expr\\<^sub>2\n  \\<lbrakk>element_type ?\\<tau> ?\\<sigma>\\<^sub>1;\n   element_type ?\\<tau> ?\\<sigma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?\\<sigma>\\<^sub>1 = ?\\<sigma>\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>' body\\<^sub>2'.\n       \\<lbrakk>None = Some \\<sigma>';\n        call\\<^sub>2 = Iterator iter its (Some \\<sigma>') body\\<^sub>2';\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>'))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2\n 2. \\<And>\\<sigma>' body\\<^sub>2'.\n       \\<lbrakk>None = None;\n        call\\<^sub>2 = Iterator iter its (Some \\<sigma>') body\\<^sub>2';\n        element_type \\<tau> \\<sigma>';\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list\n         (map (\\<lambda>it. (it, \\<sigma>'))\n           its) \\<turnstile> body\\<^sub>1 \\<Rrightarrow>\n        body\\<^sub>2'\\<rbrakk>\n       \\<Longrightarrow> Iterator iter its (Some \\<sigma>) body\\<^sub>2 =\n                         call\\<^sub>2", "by blast+"], ["proof (state)\nthis:\n  Iterator iter its (Some \\<sigma>) body\\<^sub>2 = call\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> zs.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs \\<Longrightarrow>\n       [] = zs\n 2. \\<And>\\<Gamma> x y xs ys zs.\n       \\<lbrakk>\\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> x \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           y = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           ys = zs;\n        \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\\<rbrakk>\n       \\<Longrightarrow> y # ys = zs", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> zs.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs \\<Longrightarrow>\n       [] = zs\n 2. \\<And>\\<Gamma> x y xs ys zs.\n       \\<lbrakk>\\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> x \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           y = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           ys = zs;\n        \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\\<rbrakk>\n       \\<Longrightarrow> y # ys = zs", "case (ExprListNilN \\<Gamma>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> zs.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs \\<Longrightarrow>\n       [] = zs\n 2. \\<And>\\<Gamma> x y xs ys zs.\n       \\<lbrakk>\\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> x \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           y = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           ys = zs;\n        \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\\<rbrakk>\n       \\<Longrightarrow> y # ys = zs", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs\n\ngoal (1 subgoal):\n 1. [] = zs", "using normalize_expr_list.cases"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>L [] \\<Rrightarrow> zs\n  \\<lbrakk>?a1.0 \\<turnstile>\\<^sub>L ?a2.0 \\<Rrightarrow> ?a3.0;\n   \\<And>\\<Gamma>.\n      \\<lbrakk>?a1.0 = \\<Gamma>; ?a2.0 = []; ?a3.0 = []\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>\\<Gamma> x y xs ys.\n      \\<lbrakk>?a1.0 = \\<Gamma>; ?a2.0 = x # xs; ?a3.0 = y # ys;\n       \\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n       \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. [] = zs", "by auto"], ["proof (state)\nthis:\n  [] = zs\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> x y xs ys zs.\n       \\<lbrakk>\\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> x \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           y = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           ys = zs;\n        \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\\<rbrakk>\n       \\<Longrightarrow> y # ys = zs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> x y xs ys zs.\n       \\<lbrakk>\\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> x \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           y = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           ys = zs;\n        \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\\<rbrakk>\n       \\<Longrightarrow> y # ys = zs", "case (ExprListConsN \\<Gamma> x y xs ys)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile> x \\<Rrightarrow> y\n  \\<Gamma> \\<turnstile> x \\<Rrightarrow> ?expr\\<^sub>2 \\<Longrightarrow>\n  y = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys\n  \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ?zs \\<Longrightarrow>\n  ys = ?zs\n  \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> x y xs ys zs.\n       \\<lbrakk>\\<Gamma> \\<turnstile> x \\<Rrightarrow> y;\n        \\<And>expr\\<^sub>2.\n           \\<Gamma> \\<turnstile> x \\<Rrightarrow>\n           expr\\<^sub>2 \\<Longrightarrow>\n           y = expr\\<^sub>2;\n        \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys;\n        \\<And>zs.\n           \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow>\n           zs \\<Longrightarrow>\n           ys = zs;\n        \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\\<rbrakk>\n       \\<Longrightarrow> y # ys = zs", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile> x \\<Rrightarrow> y\n  \\<Gamma> \\<turnstile> x \\<Rrightarrow> ?expr\\<^sub>2 \\<Longrightarrow>\n  y = ?expr\\<^sub>2\n  \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ys\n  \\<Gamma> \\<turnstile>\\<^sub>L xs \\<Rrightarrow> ?zs \\<Longrightarrow>\n  ys = ?zs\n  \\<Gamma> \\<turnstile>\\<^sub>L x # xs \\<Rrightarrow> zs\n\ngoal (1 subgoal):\n 1. y # ys = zs", "by blast"], ["proof (state)\nthis:\n  y # ys = zs\n\ngoal:\nNo subgoals!", "qed"], ["", "(*** Normalized Expressions Typing ******************************************)"], ["", "section \\<open>Normalized Expressions Typing\\<close>"], ["", "text \\<open>\n  Here is the final typing rules.\\<close>"], ["", "inductive nf_typing (\"(1_/ \\<turnstile>/ (_ :/ _))\" [51,51,51] 50) where\n  \"\\<Gamma> \\<turnstile> expr \\<Rrightarrow> expr\\<^sub>N \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E expr\\<^sub>N : \\<tau> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile> expr : \\<tau>\""], ["", "lemma nf_typing_det:\n  \"\\<Gamma> \\<turnstile> expr : \\<tau> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile> expr : \\<sigma> \\<Longrightarrow> \\<tau> = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> \\<turnstile> expr : \\<tau>;\n     \\<Gamma> \\<turnstile> expr : \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> \\<tau> = \\<sigma>", "by (metis nf_typing.cases normalize_det typing_det)"], ["", "(*** Code Setup *************************************************************)"], ["", "section \\<open>Code Setup\\<close>"], ["", "code_pred normalize"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "code_pred nf_typing"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition \"check_type \\<Gamma> expr \\<tau> \\<equiv>\n  Predicate.eval (nf_typing_i_i_i \\<Gamma> expr \\<tau>) ()\""], ["", "definition \"synthesize_type \\<Gamma> expr \\<equiv>\n  Predicate.singleton (\\<lambda>_. OclInvalid)\n    (Predicate.map errorable (nf_typing_i_i_o \\<Gamma> expr))\""], ["", "text \\<open>\n  It is the only usage of the @{text OclInvalid} type.\n  This type is not required to define typing rules.\n  It is only required to make the typing function total.\\<close>"], ["", "end"]]}