{"file_name": "/home/qj213/afp-2021-10-22/thys/Safe_OCL/OCL_Basic_Types.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Safe_OCL", "problem_names": ["lemma basic_subtype_asym:\n  \"\\<tau> \\<sqsubset>\\<^sub>B \\<sigma> \\<Longrightarrow> \\<sigma> \\<sqsubset>\\<^sub>B \\<tau> \\<Longrightarrow> False\"", "lemma type_less_x_OclAny_intro [intro]:\n  \"\\<tau> \\<noteq> OclAny \\<Longrightarrow> \\<tau> < OclAny\"", "lemma type_less_OclVoid_x_intro [intro]:\n  \"\\<tau> \\<noteq> OclVoid \\<Longrightarrow> OclVoid < \\<tau>\"", "lemma type_less_x_Real_intro [intro]:\n  \"\\<tau> = UnlimitedNatural \\<Longrightarrow> \\<tau> < Real\"\n  \"\\<tau> = Integer \\<Longrightarrow> \\<tau> < Real\"", "lemma type_less_x_Integer_intro [intro]:\n  \"\\<tau> = UnlimitedNatural \\<Longrightarrow> \\<tau> < Integer\"", "lemma type_less_x_ObjectType_intro [intro]:\n  \"\\<tau> = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T> \\<Longrightarrow> \\<C> < \\<D> \\<Longrightarrow> \\<tau> < \\<langle>\\<D>\\<rangle>\\<^sub>\\<T>\"", "lemma type_less_x_OclAny [elim!]:\n  \"\\<tau> < OclAny \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = Boolean \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = Integer \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = UnlimitedNatural \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = Real \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = String \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<And>\\<E>. \\<tau> = Enum \\<E> \\<Longrightarrow> P) \\<Longrightarrow> \n   (\\<And>\\<C>. \\<tau> = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T> \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma type_less_x_OclVoid [elim!]:\n  \"\\<tau> < OclVoid \\<Longrightarrow> P\"", "lemma type_less_x_Boolean [elim!]:\n  \"\\<tau> < Boolean \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma type_less_x_Real [elim!]:\n  \"\\<tau> < Real \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = UnlimitedNatural \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = Integer \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma type_less_x_Integer [elim!]:\n  \"\\<tau> < Integer \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = UnlimitedNatural \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma type_less_x_UnlimitedNatural [elim!]:\n  \"\\<tau> < UnlimitedNatural \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma type_less_x_String [elim!]:\n  \"\\<tau> < String \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma type_less_x_ObjectType [elim!]:\n  \"\\<tau> < \\<langle>\\<D>\\<rangle>\\<^sub>\\<T> \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<And>\\<C>. \\<tau> = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T> \\<Longrightarrow> \\<C> < \\<D> \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma type_less_x_Enum [elim!]:\n  \"\\<tau> < Enum \\<E> \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma basic_subtype_irrefl:\n  \"\\<tau> < \\<tau> \\<Longrightarrow> False\"\n  for \\<tau> :: \"'a basic_type\"", "lemma tranclp_less_basic_type:\n  \"(\\<tau>, \\<sigma>) \\<in> {(\\<tau>, \\<sigma>). \\<tau> \\<sqsubset>\\<^sub>B \\<sigma>}\\<^sup>+ \\<longleftrightarrow> \\<tau> < \\<sigma>\"", "lemma basic_subtype_acyclic:\n  \"acyclicP basic_subtype\"", "lemma less_le_not_le_basic_type:\n  \"\\<tau> < \\<sigma> \\<longleftrightarrow> \\<tau> \\<le> \\<sigma> \\<and> \\<not> \\<sigma> \\<le> \\<tau>\"\n  for \\<tau> \\<sigma> :: \"'a basic_type\"", "lemma antisym_basic_type:\n  \"\\<tau> \\<le> \\<sigma> \\<Longrightarrow> \\<sigma> \\<le> \\<tau> \\<Longrightarrow> \\<tau> = \\<sigma>\"\n  for \\<tau> \\<sigma> :: \"'a basic_type\"", "lemma order_refl_basic_type [iff]:\n  \"\\<tau> \\<le> \\<tau>\"\n  for \\<tau> :: \"'a basic_type\"", "lemma type_less_eq_x_OclAny_intro [intro]:\n  \"\\<tau> \\<le> OclAny\"", "lemma type_less_eq_OclVoid_x_intro [intro]:\n  \"OclVoid \\<le> \\<tau>\"", "lemma type_less_eq_x_Real_intro [intro]:\n  \"\\<tau> = UnlimitedNatural \\<Longrightarrow> \\<tau> \\<le> Real\"\n  \"\\<tau> = Integer \\<Longrightarrow> \\<tau> \\<le> Real\"", "lemma type_less_eq_x_Integer_intro [intro]:\n  \"\\<tau> = UnlimitedNatural \\<Longrightarrow> \\<tau> \\<le> Integer\"", "lemma type_less_eq_x_ObjectType_intro [intro]:\n  \"\\<tau> = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T> \\<Longrightarrow> \\<C> \\<le> \\<D> \\<Longrightarrow> \\<tau> \\<le> \\<langle>\\<D>\\<rangle>\\<^sub>\\<T>\"", "lemma type_less_eq_x_OclAny [elim!]:\n  \"\\<tau> \\<le> OclAny \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = OclAny \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = Boolean \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = Integer \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = UnlimitedNatural \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = Real \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = String \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<And>\\<E>. \\<tau> = Enum \\<E> \\<Longrightarrow> P) \\<Longrightarrow> \n   (\\<And>\\<C>. \\<tau> = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T> \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma type_less_eq_x_OclVoid [elim!]:\n  \"\\<tau> \\<le> OclVoid \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma type_less_eq_x_Boolean [elim!]:\n  \"\\<tau> \\<le> Boolean \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = Boolean \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma type_less_eq_x_Real [elim!]:\n  \"\\<tau> \\<le> Real \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = UnlimitedNatural \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = Integer \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = Real \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma type_less_eq_x_Integer [elim!]:\n  \"\\<tau> \\<le> Integer \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = UnlimitedNatural \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = Integer \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma type_less_eq_x_UnlimitedNatural [elim!]:\n  \"\\<tau> \\<le> UnlimitedNatural \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = UnlimitedNatural \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma type_less_eq_x_String [elim!]:\n  \"\\<tau> \\<le> String \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = String \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma type_less_eq_x_ObjectType [elim!]:\n  \"\\<tau> \\<le> \\<langle>\\<D>\\<rangle>\\<^sub>\\<T> \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<And>\\<C>. \\<tau> = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T> \\<Longrightarrow> \\<C> \\<le> \\<D> \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma type_less_eq_x_Enum [elim!]:\n  \"\\<tau> \\<le> Enum \\<E> \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = Enum \\<E> \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma basic_type_less_left_simps [simp]:\n  \"OclAny < \\<sigma> = False\"\n  \"OclVoid < \\<sigma> = (\\<sigma> \\<noteq> OclVoid)\"\n  \"Boolean < \\<sigma> = (\\<sigma> = OclAny)\"\n  \"Real < \\<sigma> = (\\<sigma> = OclAny)\"\n  \"Integer < \\<sigma> = (\\<sigma> = OclAny \\<or> \\<sigma> = Real)\"\n  \"UnlimitedNatural < \\<sigma> = (\\<sigma> = OclAny \\<or> \\<sigma> = Real \\<or> \\<sigma> = Integer)\"\n  \"String < \\<sigma> = (\\<sigma> = OclAny)\"\n  \"ObjectType \\<C> < \\<sigma> = (\\<exists>\\<D>. \\<sigma> = OclAny \\<or> \\<sigma> = ObjectType \\<D> \\<and> \\<C> < \\<D>)\"\n  \"Enum \\<E> < \\<sigma> = (\\<sigma> = OclAny)\"", "lemma basic_type_less_right_simps [simp]:\n  \"\\<tau> < OclAny = (\\<tau> \\<noteq> OclAny)\"\n  \"\\<tau> < OclVoid = False\"\n  \"\\<tau> < Boolean = (\\<tau> = OclVoid)\"\n  \"\\<tau> < Real = (\\<tau> = Integer \\<or> \\<tau> = UnlimitedNatural \\<or> \\<tau> = OclVoid)\"\n  \"\\<tau> < Integer = (\\<tau> = UnlimitedNatural \\<or> \\<tau> = OclVoid)\"\n  \"\\<tau> < UnlimitedNatural = (\\<tau> = OclVoid)\"\n  \"\\<tau> < String = (\\<tau> = OclVoid)\"\n  \"\\<tau> < ObjectType \\<D> = (\\<exists>\\<C>. \\<tau> = ObjectType \\<C> \\<and> \\<C> < \\<D> \\<or> \\<tau> = OclVoid)\"\n  \"\\<tau> < Enum \\<E> = (\\<tau> = OclVoid)\"", "lemma sup_ge1_ObjectType:\n  \"\\<langle>\\<C>\\<rangle>\\<^sub>\\<T> \\<le> \\<langle>\\<C>\\<rangle>\\<^sub>\\<T> \\<squnion> \\<sigma>\"", "lemma sup_ge1_basic_type:\n  \"\\<tau> \\<le> \\<tau> \\<squnion> \\<sigma>\"\n  for \\<tau> \\<sigma> :: \"'a basic_type\"", "lemma sup_commut_basic_type:\n  \"\\<tau> \\<squnion> \\<sigma> = \\<sigma> \\<squnion> \\<tau>\"\n  for \\<tau> \\<sigma> :: \"'a basic_type\"", "lemma sup_least_basic_type:\n  \"\\<tau> \\<le> \\<rho> \\<Longrightarrow> \\<sigma> \\<le> \\<rho> \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> \\<le> \\<rho>\"\n  for \\<tau> \\<sigma> \\<rho> :: \"'a basic_type\"", "lemma less_basic_type_code [code]:\n  \"(<) = basic_subtype_fun\"", "lemma less_eq_basic_type_code [code]:\n  \"(\\<le>) = (\\<lambda>x y. basic_subtype_fun x y \\<or> x = y)\""], "translations": [["", "lemma basic_subtype_asym:\n  \"\\<tau> \\<sqsubset>\\<^sub>B \\<sigma> \\<Longrightarrow> \\<sigma> \\<sqsubset>\\<^sub>B \\<tau> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<sqsubset>\\<^sub>B \\<sigma>;\n     \\<sigma> \\<sqsubset>\\<^sub>B \\<tau>\\<rbrakk>\n    \\<Longrightarrow> False", "by (induct rule: basic_subtype.induct, auto)"], ["", "(*** Partial Order of Basic Types *******************************************)"], ["", "section \\<open>Partial Order of Basic Types\\<close>"], ["", "instantiation basic_type :: (order) order\nbegin"], ["", "definition \"(<) \\<equiv> basic_subtype\\<^sup>+\\<^sup>+\""], ["", "definition \"(\\<le>) \\<equiv> basic_subtype\\<^sup>*\\<^sup>*\""], ["", "(*** Strict Introduction Rules **********************************************)"], ["", "subsection \\<open>Strict Introduction Rules\\<close>"], ["", "lemma type_less_x_OclAny_intro [intro]:\n  \"\\<tau> \\<noteq> OclAny \\<Longrightarrow> \\<tau> < OclAny\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<noteq> OclAny \\<Longrightarrow> \\<tau> < OclAny", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau> \\<noteq> OclAny \\<Longrightarrow> \\<tau> < OclAny", "have \"basic_subtype\\<^sup>+\\<^sup>+ OclVoid OclAny\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ OclVoid OclAny", "by (rule_tac ?b=\"Boolean\" in tranclp.trancl_into_trancl; auto)"], ["proof (state)\nthis:\n  (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ OclVoid OclAny\n\ngoal (1 subgoal):\n 1. \\<tau> \\<noteq> OclAny \\<Longrightarrow> \\<tau> < OclAny", "moreover"], ["proof (state)\nthis:\n  (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ OclVoid OclAny\n\ngoal (1 subgoal):\n 1. \\<tau> \\<noteq> OclAny \\<Longrightarrow> \\<tau> < OclAny", "have \"basic_subtype\\<^sup>+\\<^sup>+ Integer OclAny\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ Integer OclAny", "by (rule_tac ?b=\"Real\" in tranclp.trancl_into_trancl; auto)"], ["proof (state)\nthis:\n  (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ Integer OclAny\n\ngoal (1 subgoal):\n 1. \\<tau> \\<noteq> OclAny \\<Longrightarrow> \\<tau> < OclAny", "moreover"], ["proof (state)\nthis:\n  (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ Integer OclAny\n\ngoal (1 subgoal):\n 1. \\<tau> \\<noteq> OclAny \\<Longrightarrow> \\<tau> < OclAny", "hence \"basic_subtype\\<^sup>+\\<^sup>+ UnlimitedNatural OclAny\""], ["proof (prove)\nusing this:\n  (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ Integer OclAny\n\ngoal (1 subgoal):\n 1. (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ UnlimitedNatural OclAny", "by (rule_tac ?b=\"Integer\" in tranclp_into_tranclp2; auto)"], ["proof (state)\nthis:\n  (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ UnlimitedNatural OclAny\n\ngoal (1 subgoal):\n 1. \\<tau> \\<noteq> OclAny \\<Longrightarrow> \\<tau> < OclAny", "ultimately"], ["proof (chain)\npicking this:\n  (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ OclVoid OclAny\n  (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ Integer OclAny\n  (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ UnlimitedNatural OclAny", "show \"\\<tau> \\<noteq> OclAny \\<Longrightarrow> \\<tau> < OclAny\""], ["proof (prove)\nusing this:\n  (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ OclVoid OclAny\n  (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ Integer OclAny\n  (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ UnlimitedNatural OclAny\n\ngoal (1 subgoal):\n 1. \\<tau> \\<noteq> OclAny \\<Longrightarrow> \\<tau> < OclAny", "unfolding less_basic_type_def"], ["proof (prove)\nusing this:\n  (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ OclVoid OclAny\n  (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ Integer OclAny\n  (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ UnlimitedNatural OclAny\n\ngoal (1 subgoal):\n 1. \\<tau> \\<noteq> OclAny \\<Longrightarrow>\n    (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ \\<tau> OclAny", "by (induct \\<tau>, auto)"], ["proof (state)\nthis:\n  \\<tau> \\<noteq> OclAny \\<Longrightarrow> \\<tau> < OclAny\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma type_less_OclVoid_x_intro [intro]:\n  \"\\<tau> \\<noteq> OclVoid \\<Longrightarrow> OclVoid < \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<noteq> OclVoid \\<Longrightarrow> OclVoid < \\<tau>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau> \\<noteq> OclVoid \\<Longrightarrow> OclVoid < \\<tau>", "have \"basic_subtype\\<^sup>+\\<^sup>+ OclVoid OclAny\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ OclVoid OclAny", "by (rule_tac ?b=\"Boolean\" in tranclp.trancl_into_trancl; auto)"], ["proof (state)\nthis:\n  (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ OclVoid OclAny\n\ngoal (1 subgoal):\n 1. \\<tau> \\<noteq> OclVoid \\<Longrightarrow> OclVoid < \\<tau>", "moreover"], ["proof (state)\nthis:\n  (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ OclVoid OclAny\n\ngoal (1 subgoal):\n 1. \\<tau> \\<noteq> OclVoid \\<Longrightarrow> OclVoid < \\<tau>", "have \"basic_subtype\\<^sup>+\\<^sup>+ OclVoid Integer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ OclVoid Integer", "by (rule_tac ?b=\"UnlimitedNatural\" in tranclp.trancl_into_trancl; auto)"], ["proof (state)\nthis:\n  (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ OclVoid Integer\n\ngoal (1 subgoal):\n 1. \\<tau> \\<noteq> OclVoid \\<Longrightarrow> OclVoid < \\<tau>", "moreover"], ["proof (state)\nthis:\n  (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ OclVoid Integer\n\ngoal (1 subgoal):\n 1. \\<tau> \\<noteq> OclVoid \\<Longrightarrow> OclVoid < \\<tau>", "hence \"basic_subtype\\<^sup>+\\<^sup>+ OclVoid Real\""], ["proof (prove)\nusing this:\n  (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ OclVoid Integer\n\ngoal (1 subgoal):\n 1. (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ OclVoid Real", "by (rule_tac ?b=\"Integer\" in tranclp.trancl_into_trancl; auto)"], ["proof (state)\nthis:\n  (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ OclVoid Real\n\ngoal (1 subgoal):\n 1. \\<tau> \\<noteq> OclVoid \\<Longrightarrow> OclVoid < \\<tau>", "ultimately"], ["proof (chain)\npicking this:\n  (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ OclVoid OclAny\n  (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ OclVoid Integer\n  (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ OclVoid Real", "show \"\\<tau> \\<noteq> OclVoid \\<Longrightarrow> OclVoid < \\<tau>\""], ["proof (prove)\nusing this:\n  (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ OclVoid OclAny\n  (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ OclVoid Integer\n  (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ OclVoid Real\n\ngoal (1 subgoal):\n 1. \\<tau> \\<noteq> OclVoid \\<Longrightarrow> OclVoid < \\<tau>", "unfolding less_basic_type_def"], ["proof (prove)\nusing this:\n  (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ OclVoid OclAny\n  (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ OclVoid Integer\n  (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ OclVoid Real\n\ngoal (1 subgoal):\n 1. \\<tau> \\<noteq> OclVoid \\<Longrightarrow>\n    (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ OclVoid \\<tau>", "by (induct \\<tau>; auto)"], ["proof (state)\nthis:\n  \\<tau> \\<noteq> OclVoid \\<Longrightarrow> OclVoid < \\<tau>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma type_less_x_Real_intro [intro]:\n  \"\\<tau> = UnlimitedNatural \\<Longrightarrow> \\<tau> < Real\"\n  \"\\<tau> = Integer \\<Longrightarrow> \\<tau> < Real\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> = UnlimitedNatural \\<Longrightarrow> \\<tau> < Real) &&&\n    (\\<tau> = Integer \\<Longrightarrow> \\<tau> < Real)", "unfolding less_basic_type_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> = UnlimitedNatural \\<Longrightarrow>\n     (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ \\<tau> Real) &&&\n    (\\<tau> = Integer \\<Longrightarrow>\n     (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ \\<tau> Real)", "by (rule rtranclp_into_tranclp2, auto)"], ["", "lemma type_less_x_Integer_intro [intro]:\n  \"\\<tau> = UnlimitedNatural \\<Longrightarrow> \\<tau> < Integer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> = UnlimitedNatural \\<Longrightarrow> \\<tau> < Integer", "unfolding less_basic_type_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> = UnlimitedNatural \\<Longrightarrow>\n    (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ \\<tau> Integer", "by (rule rtranclp_into_tranclp2, auto)"], ["", "lemma type_less_x_ObjectType_intro [intro]:\n  \"\\<tau> = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T> \\<Longrightarrow> \\<C> < \\<D> \\<Longrightarrow> \\<tau> < \\<langle>\\<D>\\<rangle>\\<^sub>\\<T>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>;\n     \\<C> < \\<D>\\<rbrakk>\n    \\<Longrightarrow> \\<tau> < \\<langle>\\<D>\\<rangle>\\<^sub>\\<T>", "unfolding less_basic_type_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>;\n     \\<C> < \\<D>\\<rbrakk>\n    \\<Longrightarrow> (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ \\<tau>\n                       \\<langle>\\<D>\\<rangle>\\<^sub>\\<T>", "using dual_order.order_iff_strict"], ["proof (prove)\nusing this:\n  (?b \\<le> ?a) = (?b < ?a \\<or> ?a = ?b)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>;\n     \\<C> < \\<D>\\<rbrakk>\n    \\<Longrightarrow> (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ \\<tau>\n                       \\<langle>\\<D>\\<rangle>\\<^sub>\\<T>", "by blast"], ["", "(*** Strict Elimination Rules ***********************************************)"], ["", "subsection \\<open>Strict Elimination Rules\\<close>"], ["", "lemma type_less_x_OclAny [elim!]:\n  \"\\<tau> < OclAny \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = Boolean \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = Integer \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = UnlimitedNatural \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = Real \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = String \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<And>\\<E>. \\<tau> = Enum \\<E> \\<Longrightarrow> P) \\<Longrightarrow> \n   (\\<And>\\<C>. \\<tau> = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T> \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> < OclAny; \\<tau> = OclVoid \\<Longrightarrow> P;\n     \\<tau> = Boolean \\<Longrightarrow> P;\n     \\<tau> = Integer \\<Longrightarrow> P;\n     \\<tau> = UnlimitedNatural \\<Longrightarrow> P;\n     \\<tau> = Real \\<Longrightarrow> P; \\<tau> = String \\<Longrightarrow> P;\n     \\<And>\\<E>. \\<tau> = Enum \\<E> \\<Longrightarrow> P;\n     \\<And>\\<C>.\n        \\<tau> = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T> \\<Longrightarrow>\n        P\\<rbrakk>\n    \\<Longrightarrow> P", "unfolding less_basic_type_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ \\<tau> OclAny;\n     \\<tau> = OclVoid \\<Longrightarrow> P;\n     \\<tau> = Boolean \\<Longrightarrow> P;\n     \\<tau> = Integer \\<Longrightarrow> P;\n     \\<tau> = UnlimitedNatural \\<Longrightarrow> P;\n     \\<tau> = Real \\<Longrightarrow> P; \\<tau> = String \\<Longrightarrow> P;\n     \\<And>\\<E>. \\<tau> = Enum \\<E> \\<Longrightarrow> P;\n     \\<And>\\<C>.\n        \\<tau> = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T> \\<Longrightarrow>\n        P\\<rbrakk>\n    \\<Longrightarrow> P", "by (induct rule: converse_tranclp_induct; auto)"], ["", "lemma type_less_x_OclVoid [elim!]:\n  \"\\<tau> < OclVoid \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> < OclVoid \\<Longrightarrow> P", "unfolding less_basic_type_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ \\<tau> OclVoid \\<Longrightarrow> P", "by (induct rule: converse_tranclp_induct; auto)"], ["", "lemma type_less_x_Boolean [elim!]:\n  \"\\<tau> < Boolean \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> < Boolean; \\<tau> = OclVoid \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "unfolding less_basic_type_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ \\<tau> Boolean;\n     \\<tau> = OclVoid \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (induct rule: converse_tranclp_induct; auto)"], ["", "lemma type_less_x_Real [elim!]:\n  \"\\<tau> < Real \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = UnlimitedNatural \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = Integer \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> < Real; \\<tau> = OclVoid \\<Longrightarrow> P;\n     \\<tau> = UnlimitedNatural \\<Longrightarrow> P;\n     \\<tau> = Integer \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "unfolding less_basic_type_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ \\<tau> Real;\n     \\<tau> = OclVoid \\<Longrightarrow> P;\n     \\<tau> = UnlimitedNatural \\<Longrightarrow> P;\n     \\<tau> = Integer \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (induct rule: converse_tranclp_induct; auto)"], ["", "lemma type_less_x_Integer [elim!]:\n  \"\\<tau> < Integer \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = UnlimitedNatural \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> < Integer; \\<tau> = OclVoid \\<Longrightarrow> P;\n     \\<tau> = UnlimitedNatural \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "unfolding less_basic_type_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ \\<tau> Integer;\n     \\<tau> = OclVoid \\<Longrightarrow> P;\n     \\<tau> = UnlimitedNatural \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (induct rule: converse_tranclp_induct; auto)"], ["", "lemma type_less_x_UnlimitedNatural [elim!]:\n  \"\\<tau> < UnlimitedNatural \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> < UnlimitedNatural;\n     \\<tau> = OclVoid \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "unfolding less_basic_type_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ \\<tau> UnlimitedNatural;\n     \\<tau> = OclVoid \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (induct rule: converse_tranclp_induct; auto)"], ["", "lemma type_less_x_String [elim!]:\n  \"\\<tau> < String \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> < String; \\<tau> = OclVoid \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "unfolding less_basic_type_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ \\<tau> String;\n     \\<tau> = OclVoid \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (induct rule: converse_tranclp_induct; auto)"], ["", "lemma type_less_x_ObjectType [elim!]:\n  \"\\<tau> < \\<langle>\\<D>\\<rangle>\\<^sub>\\<T> \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<And>\\<C>. \\<tau> = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T> \\<Longrightarrow> \\<C> < \\<D> \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> < \\<langle>\\<D>\\<rangle>\\<^sub>\\<T>;\n     \\<tau> = OclVoid \\<Longrightarrow> P;\n     \\<And>\\<C>.\n        \\<lbrakk>\\<tau> = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>;\n         \\<C> < \\<D>\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "unfolding less_basic_type_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ \\<tau>\n              \\<langle>\\<D>\\<rangle>\\<^sub>\\<T>;\n     \\<tau> = OclVoid \\<Longrightarrow> P;\n     \\<And>\\<C>.\n        \\<lbrakk>\\<tau> = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>;\n         \\<C> < \\<D>\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "apply (induct rule: converse_tranclp_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>y \\<sqsubset>\\<^sub>B \\<langle>\\<D>\\<rangle>\\<^sub>\\<T>;\n        y = OclVoid \\<Longrightarrow> P;\n        \\<And>\\<C>.\n           \\<lbrakk>y = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>;\n            \\<C> < \\<D>\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>y z.\n       \\<lbrakk>y \\<sqsubset>\\<^sub>B z;\n        (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ z\n         \\<langle>\\<D>\\<rangle>\\<^sub>\\<T>;\n        \\<lbrakk>z = OclVoid \\<Longrightarrow> P;\n         \\<And>\\<C>.\n            \\<lbrakk>z = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>;\n             \\<C> < \\<D>\\<rbrakk>\n            \\<Longrightarrow> P\\<rbrakk>\n        \\<Longrightarrow> P;\n        y = OclVoid \\<Longrightarrow> P;\n        \\<And>\\<C>.\n           \\<lbrakk>y = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>;\n            \\<C> < \\<D>\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>y \\<sqsubset>\\<^sub>B z;\n        (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ z\n         \\<langle>\\<D>\\<rangle>\\<^sub>\\<T>;\n        \\<lbrakk>z = OclVoid \\<Longrightarrow> P;\n         \\<And>\\<C>.\n            \\<lbrakk>z = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>;\n             \\<C> < \\<D>\\<rbrakk>\n            \\<Longrightarrow> P\\<rbrakk>\n        \\<Longrightarrow> P;\n        y = OclVoid \\<Longrightarrow> P;\n        \\<And>\\<C>.\n           \\<lbrakk>y = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>;\n            \\<C> < \\<D>\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "using less_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x < ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>y \\<sqsubset>\\<^sub>B z;\n        (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ z\n         \\<langle>\\<D>\\<rangle>\\<^sub>\\<T>;\n        \\<lbrakk>z = OclVoid \\<Longrightarrow> P;\n         \\<And>\\<C>.\n            \\<lbrakk>z = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>;\n             \\<C> < \\<D>\\<rbrakk>\n            \\<Longrightarrow> P\\<rbrakk>\n        \\<Longrightarrow> P;\n        y = OclVoid \\<Longrightarrow> P;\n        \\<And>\\<C>.\n           \\<lbrakk>y = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>;\n            \\<C> < \\<D>\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "by auto"], ["", "lemma type_less_x_Enum [elim!]:\n  \"\\<tau> < Enum \\<E> \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> < Enum \\<E>;\n     \\<tau> = OclVoid \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "unfolding less_basic_type_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ \\<tau> (Enum \\<E>);\n     \\<tau> = OclVoid \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (induct rule: converse_tranclp_induct; auto)"], ["", "(*** Properties *************************************************************)"], ["", "subsection \\<open>Properties\\<close>"], ["", "lemma basic_subtype_irrefl:\n  \"\\<tau> < \\<tau> \\<Longrightarrow> False\"\n  for \\<tau> :: \"'a basic_type\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> < \\<tau> \\<Longrightarrow> False", "by (cases \\<tau>; auto)"], ["", "lemma tranclp_less_basic_type:\n  \"(\\<tau>, \\<sigma>) \\<in> {(\\<tau>, \\<sigma>). \\<tau> \\<sqsubset>\\<^sub>B \\<sigma>}\\<^sup>+ \\<longleftrightarrow> \\<tau> < \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<tau>, \\<sigma>)\n     \\<in> {(\\<tau>, \\<sigma>).\n            \\<tau> \\<sqsubset>\\<^sub>B \\<sigma>}\\<^sup>+) =\n    (\\<tau> < \\<sigma>)", "by (simp add: tranclp_unfold less_basic_type_def)"], ["", "lemma basic_subtype_acyclic:\n  \"acyclicP basic_subtype\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclicP (\\<sqsubset>\\<^sub>B)", "apply (rule acyclicI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (x, x) \\<notin> {(x, y). x \\<sqsubset>\\<^sub>B y}\\<^sup>+", "using OCL_Basic_Types.basic_subtype_irrefl\n    OCL_Basic_Types.tranclp_less_basic_type"], ["proof (prove)\nusing this:\n  ?\\<tau> < ?\\<tau> \\<Longrightarrow> False\n  ((?\\<tau>, ?\\<sigma>)\n   \\<in> {(\\<tau>, \\<sigma>).\n          \\<tau> \\<sqsubset>\\<^sub>B \\<sigma>}\\<^sup>+) =\n  (?\\<tau> < ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<forall>x. (x, x) \\<notin> {(x, y). x \\<sqsubset>\\<^sub>B y}\\<^sup>+", "by auto"], ["", "lemma less_le_not_le_basic_type:\n  \"\\<tau> < \\<sigma> \\<longleftrightarrow> \\<tau> \\<le> \\<sigma> \\<and> \\<not> \\<sigma> \\<le> \\<tau>\"\n  for \\<tau> \\<sigma> :: \"'a basic_type\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> < \\<sigma>) =\n    (\\<tau> \\<le> \\<sigma> \\<and> \\<not> \\<sigma> \\<le> \\<tau>)", "unfolding less_basic_type_def less_eq_basic_type_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ \\<tau> \\<sigma> =\n    ((\\<sqsubset>\\<^sub>B)\\<^sup>*\\<^sup>* \\<tau> \\<sigma> \\<and>\n     \\<not> (\\<sqsubset>\\<^sub>B)\\<^sup>*\\<^sup>* \\<sigma> \\<tau>)", "apply (rule iffI; auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ \\<tau> \\<sigma>;\n     (\\<sqsubset>\\<^sub>B)\\<^sup>*\\<^sup>* \\<sigma> \\<tau>\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>(\\<sqsubset>\\<^sub>B)\\<^sup>*\\<^sup>* \\<tau> \\<sigma>;\n     \\<not> (\\<sqsubset>\\<^sub>B)\\<^sup>*\\<^sup>* \\<sigma> \\<tau>\\<rbrakk>\n    \\<Longrightarrow> (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ \\<tau> \\<sigma>", "apply (metis (mono_tags) basic_subtype_irrefl\n      less_basic_type_def tranclp_rtranclp_tranclp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<sqsubset>\\<^sub>B)\\<^sup>*\\<^sup>* \\<tau> \\<sigma>;\n     \\<not> (\\<sqsubset>\\<^sub>B)\\<^sup>*\\<^sup>* \\<sigma> \\<tau>\\<rbrakk>\n    \\<Longrightarrow> (\\<sqsubset>\\<^sub>B)\\<^sup>+\\<^sup>+ \\<tau> \\<sigma>", "by (drule rtranclpD; auto)"], ["", "lemma antisym_basic_type:\n  \"\\<tau> \\<le> \\<sigma> \\<Longrightarrow> \\<sigma> \\<le> \\<tau> \\<Longrightarrow> \\<tau> = \\<sigma>\"\n  for \\<tau> \\<sigma> :: \"'a basic_type\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<le> \\<sigma>; \\<sigma> \\<le> \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<tau> = \\<sigma>", "unfolding less_eq_basic_type_def less_basic_type_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<sqsubset>\\<^sub>B)\\<^sup>*\\<^sup>* \\<tau> \\<sigma>;\n     (\\<sqsubset>\\<^sub>B)\\<^sup>*\\<^sup>* \\<sigma> \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<tau> = \\<sigma>", "by (metis (mono_tags, lifting) less_eq_basic_type_def\n      less_le_not_le_basic_type less_basic_type_def rtranclpD)"], ["", "lemma order_refl_basic_type [iff]:\n  \"\\<tau> \\<le> \\<tau>\"\n  for \\<tau> :: \"'a basic_type\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<le> \\<tau>", "by (simp add: less_eq_basic_type_def)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a basic_type, order_class)", "by standard (auto simp add: less_eq_basic_type_def\n        less_le_not_le_basic_type antisym_basic_type)"], ["", "end"], ["", "(*** Non-Strict Introduction Rules ******************************************)"], ["", "subsection \\<open>Non-Strict Introduction Rules\\<close>"], ["", "lemma type_less_eq_x_OclAny_intro [intro]:\n  \"\\<tau> \\<le> OclAny\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<le> OclAny", "using order.order_iff_strict"], ["proof (prove)\nusing this:\n  (?a \\<le> ?b) = (?a < ?b \\<or> ?a = ?b)\n\ngoal (1 subgoal):\n 1. \\<tau> \\<le> OclAny", "by auto"], ["", "lemma type_less_eq_OclVoid_x_intro [intro]:\n  \"OclVoid \\<le> \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OclVoid \\<le> \\<tau>", "using order.order_iff_strict"], ["proof (prove)\nusing this:\n  (?a \\<le> ?b) = (?a < ?b \\<or> ?a = ?b)\n\ngoal (1 subgoal):\n 1. OclVoid \\<le> \\<tau>", "by auto"], ["", "lemma type_less_eq_x_Real_intro [intro]:\n  \"\\<tau> = UnlimitedNatural \\<Longrightarrow> \\<tau> \\<le> Real\"\n  \"\\<tau> = Integer \\<Longrightarrow> \\<tau> \\<le> Real\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> = UnlimitedNatural \\<Longrightarrow> \\<tau> \\<le> Real) &&&\n    (\\<tau> = Integer \\<Longrightarrow> \\<tau> \\<le> Real)", "using order.order_iff_strict"], ["proof (prove)\nusing this:\n  (?a \\<le> ?b) = (?a < ?b \\<or> ?a = ?b)\n\ngoal (1 subgoal):\n 1. (\\<tau> = UnlimitedNatural \\<Longrightarrow> \\<tau> \\<le> Real) &&&\n    (\\<tau> = Integer \\<Longrightarrow> \\<tau> \\<le> Real)", "by auto"], ["", "lemma type_less_eq_x_Integer_intro [intro]:\n  \"\\<tau> = UnlimitedNatural \\<Longrightarrow> \\<tau> \\<le> Integer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> = UnlimitedNatural \\<Longrightarrow> \\<tau> \\<le> Integer", "using order.order_iff_strict"], ["proof (prove)\nusing this:\n  (?a \\<le> ?b) = (?a < ?b \\<or> ?a = ?b)\n\ngoal (1 subgoal):\n 1. \\<tau> = UnlimitedNatural \\<Longrightarrow> \\<tau> \\<le> Integer", "by auto"], ["", "lemma type_less_eq_x_ObjectType_intro [intro]:\n  \"\\<tau> = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T> \\<Longrightarrow> \\<C> \\<le> \\<D> \\<Longrightarrow> \\<tau> \\<le> \\<langle>\\<D>\\<rangle>\\<^sub>\\<T>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>;\n     \\<C> \\<le> \\<D>\\<rbrakk>\n    \\<Longrightarrow> \\<tau> \\<le> \\<langle>\\<D>\\<rangle>\\<^sub>\\<T>", "using order.order_iff_strict"], ["proof (prove)\nusing this:\n  (?a \\<le> ?b) = (?a < ?b \\<or> ?a = ?b)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>;\n     \\<C> \\<le> \\<D>\\<rbrakk>\n    \\<Longrightarrow> \\<tau> \\<le> \\<langle>\\<D>\\<rangle>\\<^sub>\\<T>", "by fastforce"], ["", "(*** Non-Strict Elimination Rules *******************************************)"], ["", "subsection \\<open>Non-Strict Elimination Rules\\<close>"], ["", "lemma type_less_eq_x_OclAny [elim!]:\n  \"\\<tau> \\<le> OclAny \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = OclAny \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = Boolean \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = Integer \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = UnlimitedNatural \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = Real \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = String \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<And>\\<E>. \\<tau> = Enum \\<E> \\<Longrightarrow> P) \\<Longrightarrow> \n   (\\<And>\\<C>. \\<tau> = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T> \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<le> OclAny; \\<tau> = OclVoid \\<Longrightarrow> P;\n     \\<tau> = OclAny \\<Longrightarrow> P;\n     \\<tau> = Boolean \\<Longrightarrow> P;\n     \\<tau> = Integer \\<Longrightarrow> P;\n     \\<tau> = UnlimitedNatural \\<Longrightarrow> P;\n     \\<tau> = Real \\<Longrightarrow> P; \\<tau> = String \\<Longrightarrow> P;\n     \\<And>\\<E>. \\<tau> = Enum \\<E> \\<Longrightarrow> P;\n     \\<And>\\<C>.\n        \\<tau> = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T> \\<Longrightarrow>\n        P\\<rbrakk>\n    \\<Longrightarrow> P", "by (drule le_imp_less_or_eq; auto)"], ["", "lemma type_less_eq_x_OclVoid [elim!]:\n  \"\\<tau> \\<le> OclVoid \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<le> OclVoid;\n     \\<tau> = OclVoid \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (drule le_imp_less_or_eq; auto)"], ["", "lemma type_less_eq_x_Boolean [elim!]:\n  \"\\<tau> \\<le> Boolean \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = Boolean \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<le> Boolean; \\<tau> = OclVoid \\<Longrightarrow> P;\n     \\<tau> = Boolean \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (drule le_imp_less_or_eq; auto)"], ["", "lemma type_less_eq_x_Real [elim!]:\n  \"\\<tau> \\<le> Real \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = UnlimitedNatural \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = Integer \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = Real \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<le> Real; \\<tau> = OclVoid \\<Longrightarrow> P;\n     \\<tau> = UnlimitedNatural \\<Longrightarrow> P;\n     \\<tau> = Integer \\<Longrightarrow> P;\n     \\<tau> = Real \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (drule le_imp_less_or_eq; auto)"], ["", "lemma type_less_eq_x_Integer [elim!]:\n  \"\\<tau> \\<le> Integer \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = UnlimitedNatural \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = Integer \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<le> Integer; \\<tau> = OclVoid \\<Longrightarrow> P;\n     \\<tau> = UnlimitedNatural \\<Longrightarrow> P;\n     \\<tau> = Integer \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (drule le_imp_less_or_eq; auto)"], ["", "lemma type_less_eq_x_UnlimitedNatural [elim!]:\n  \"\\<tau> \\<le> UnlimitedNatural \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = UnlimitedNatural \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<le> UnlimitedNatural;\n     \\<tau> = OclVoid \\<Longrightarrow> P;\n     \\<tau> = UnlimitedNatural \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (drule le_imp_less_or_eq; auto)"], ["", "lemma type_less_eq_x_String [elim!]:\n  \"\\<tau> \\<le> String \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = String \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<le> String; \\<tau> = OclVoid \\<Longrightarrow> P;\n     \\<tau> = String \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (drule le_imp_less_or_eq; auto)"], ["", "lemma type_less_eq_x_ObjectType [elim!]:\n  \"\\<tau> \\<le> \\<langle>\\<D>\\<rangle>\\<^sub>\\<T> \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<And>\\<C>. \\<tau> = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T> \\<Longrightarrow> \\<C> \\<le> \\<D> \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<le> \\<langle>\\<D>\\<rangle>\\<^sub>\\<T>;\n     \\<tau> = OclVoid \\<Longrightarrow> P;\n     \\<And>\\<C>.\n        \\<lbrakk>\\<tau> = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>;\n         \\<C> \\<le> \\<D>\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (drule le_imp_less_or_eq; auto)"], ["", "lemma type_less_eq_x_Enum [elim!]:\n  \"\\<tau> \\<le> Enum \\<E> \\<Longrightarrow>\n   (\\<tau> = OclVoid \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<tau> = Enum \\<E> \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<le> Enum \\<E>; \\<tau> = OclVoid \\<Longrightarrow> P;\n     \\<tau> = Enum \\<E> \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (drule le_imp_less_or_eq; auto)"], ["", "(*** Simplification Rules ***************************************************)"], ["", "subsection \\<open>Simplification Rules\\<close>"], ["", "lemma basic_type_less_left_simps [simp]:\n  \"OclAny < \\<sigma> = False\"\n  \"OclVoid < \\<sigma> = (\\<sigma> \\<noteq> OclVoid)\"\n  \"Boolean < \\<sigma> = (\\<sigma> = OclAny)\"\n  \"Real < \\<sigma> = (\\<sigma> = OclAny)\"\n  \"Integer < \\<sigma> = (\\<sigma> = OclAny \\<or> \\<sigma> = Real)\"\n  \"UnlimitedNatural < \\<sigma> = (\\<sigma> = OclAny \\<or> \\<sigma> = Real \\<or> \\<sigma> = Integer)\"\n  \"String < \\<sigma> = (\\<sigma> = OclAny)\"\n  \"ObjectType \\<C> < \\<sigma> = (\\<exists>\\<D>. \\<sigma> = OclAny \\<or> \\<sigma> = ObjectType \\<D> \\<and> \\<C> < \\<D>)\"\n  \"Enum \\<E> < \\<sigma> = (\\<sigma> = OclAny)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((OclAny < \\<sigma>) = False &&&\n      (OclVoid < \\<sigma>) = (\\<sigma> \\<noteq> OclVoid)) &&&\n     (Boolean < \\<sigma>) = (\\<sigma> = OclAny) &&&\n     (Real < \\<sigma>) = (\\<sigma> = OclAny)) &&&\n    ((Integer < \\<sigma>) = (\\<sigma> = OclAny \\<or> \\<sigma> = Real) &&&\n     (UnlimitedNatural < \\<sigma>) =\n     (\\<sigma> = OclAny \\<or> \\<sigma> = Real \\<or> \\<sigma> = Integer)) &&&\n    (String < \\<sigma>) = (\\<sigma> = OclAny) &&&\n    (\\<langle>\\<C>\\<rangle>\\<^sub>\\<T> < \\<sigma>) =\n    (\\<exists>\\<D>.\n        \\<sigma> = OclAny \\<or>\n        \\<sigma> = \\<langle>\\<D>\\<rangle>\\<^sub>\\<T> \\<and> \\<C> < \\<D>) &&&\n    (Enum \\<E> < \\<sigma>) = (\\<sigma> = OclAny)", "by (induct \\<sigma>, auto)"], ["", "lemma basic_type_less_right_simps [simp]:\n  \"\\<tau> < OclAny = (\\<tau> \\<noteq> OclAny)\"\n  \"\\<tau> < OclVoid = False\"\n  \"\\<tau> < Boolean = (\\<tau> = OclVoid)\"\n  \"\\<tau> < Real = (\\<tau> = Integer \\<or> \\<tau> = UnlimitedNatural \\<or> \\<tau> = OclVoid)\"\n  \"\\<tau> < Integer = (\\<tau> = UnlimitedNatural \\<or> \\<tau> = OclVoid)\"\n  \"\\<tau> < UnlimitedNatural = (\\<tau> = OclVoid)\"\n  \"\\<tau> < String = (\\<tau> = OclVoid)\"\n  \"\\<tau> < ObjectType \\<D> = (\\<exists>\\<C>. \\<tau> = ObjectType \\<C> \\<and> \\<C> < \\<D> \\<or> \\<tau> = OclVoid)\"\n  \"\\<tau> < Enum \\<E> = (\\<tau> = OclVoid)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((\\<tau> < OclAny) = (\\<tau> \\<noteq> OclAny) &&&\n      (\\<tau> < OclVoid) = False) &&&\n     (\\<tau> < Boolean) = (\\<tau> = OclVoid) &&&\n     (\\<tau> < Real) =\n     (\\<tau> = Integer \\<or>\n      \\<tau> = UnlimitedNatural \\<or> \\<tau> = OclVoid)) &&&\n    ((\\<tau> < Integer) =\n     (\\<tau> = UnlimitedNatural \\<or> \\<tau> = OclVoid) &&&\n     (\\<tau> < UnlimitedNatural) = (\\<tau> = OclVoid)) &&&\n    (\\<tau> < String) = (\\<tau> = OclVoid) &&&\n    (\\<tau> < \\<langle>\\<D>\\<rangle>\\<^sub>\\<T>) =\n    (\\<exists>\\<C>.\n        \\<tau> = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T> \\<and> \\<C> < \\<D> \\<or>\n        \\<tau> = OclVoid) &&&\n    (\\<tau> < Enum \\<E>) = (\\<tau> = OclVoid)", "by auto"], ["", "(*** Upper Semilattice of Basic Types ***************************************)"], ["", "section \\<open>Upper Semilattice of Basic Types\\<close>"], ["", "notation sup (infixl \"\\<squnion>\" 65)"], ["", "instantiation basic_type :: (semilattice_sup) semilattice_sup\nbegin"], ["", "(* We use \"case\"-style because it works faster *)"], ["", "fun sup_basic_type where\n  \"\\<langle>\\<C>\\<rangle>\\<^sub>\\<T> \\<squnion> \\<sigma> = (case \\<sigma> of OclVoid \\<Rightarrow> \\<langle>\\<C>\\<rangle>\\<^sub>\\<T> | \\<langle>\\<D>\\<rangle>\\<^sub>\\<T> \\<Rightarrow> \\<langle>\\<C> \\<squnion> \\<D>\\<rangle>\\<^sub>\\<T> | _ \\<Rightarrow> OclAny)\"\n| \"\\<tau> \\<squnion> \\<sigma> = (if \\<tau> \\<le> \\<sigma> then \\<sigma> else (if \\<sigma> \\<le> \\<tau> then \\<tau> else OclAny))\""], ["", "lemma sup_ge1_ObjectType:\n  \"\\<langle>\\<C>\\<rangle>\\<^sub>\\<T> \\<le> \\<langle>\\<C>\\<rangle>\\<^sub>\\<T> \\<squnion> \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>\n    \\<le> \\<langle>\\<C>\\<rangle>\\<^sub>\\<T> \\<squnion> \\<sigma>", "apply (induct \\<sigma>; simp add: basic_subtype.simps\n        less_eq_basic_type_def r_into_rtranclp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<sqsubset>\\<^sub>B)\\<^sup>*\\<^sup>*\n        \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>\n        \\<langle>\\<C> \\<squnion> x\\<rangle>\\<^sub>\\<T>", "by (metis Nitpick.rtranclp_unfold basic_subtype.intros(8)\n        le_imp_less_or_eq r_into_rtranclp sup_ge1)"], ["", "lemma sup_ge1_basic_type:\n  \"\\<tau> \\<le> \\<tau> \\<squnion> \\<sigma>\"\n  for \\<tau> \\<sigma> :: \"'a basic_type\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<le> \\<tau> \\<squnion> \\<sigma>", "apply (induct \\<tau>, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<langle>x\\<rangle>\\<^sub>\\<T>\n       \\<le> (case \\<sigma> of\n              OclVoid \\<Rightarrow> \\<langle>x\\<rangle>\\<^sub>\\<T>\n              | \\<langle>\\<D>\\<rangle>\\<^sub>\\<T> \\<Rightarrow>\n                  \\<langle>x \\<squnion> \\<D>\\<rangle>\\<^sub>\\<T>\n              | _ \\<Rightarrow> OclAny)", "using sup_ge1_ObjectType"], ["proof (prove)\nusing this:\n  \\<langle>?\\<C>\\<rangle>\\<^sub>\\<T>\n  \\<le> \\<langle>?\\<C>\\<rangle>\\<^sub>\\<T> \\<squnion> ?\\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<langle>x\\<rangle>\\<^sub>\\<T>\n       \\<le> (case \\<sigma> of\n              OclVoid \\<Rightarrow> \\<langle>x\\<rangle>\\<^sub>\\<T>\n              | \\<langle>\\<D>\\<rangle>\\<^sub>\\<T> \\<Rightarrow>\n                  \\<langle>x \\<squnion> \\<D>\\<rangle>\\<^sub>\\<T>\n              | _ \\<Rightarrow> OclAny)", "by auto"], ["", "lemma sup_commut_basic_type:\n  \"\\<tau> \\<squnion> \\<sigma> = \\<sigma> \\<squnion> \\<tau>\"\n  for \\<tau> \\<sigma> :: \"'a basic_type\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<squnion> \\<sigma> = \\<sigma> \\<squnion> \\<tau>", "by (induct \\<tau>; induct \\<sigma>; auto simp add: sup.commute)"], ["", "lemma sup_least_basic_type:\n  \"\\<tau> \\<le> \\<rho> \\<Longrightarrow> \\<sigma> \\<le> \\<rho> \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> \\<le> \\<rho>\"\n  for \\<tau> \\<sigma> \\<rho> :: \"'a basic_type\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<le> \\<rho>; \\<sigma> \\<le> \\<rho>\\<rbrakk>\n    \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> \\<le> \\<rho>", "by (induct \\<rho>; auto)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a basic_type, semilattice_sup_class)", "by standard (auto simp add: sup_ge1_basic_type\n        sup_commut_basic_type sup_least_basic_type)"], ["", "end"], ["", "(*** Code Setup *************************************************************)"], ["", "section \\<open>Code Setup\\<close>"], ["", "code_pred basic_subtype"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "fun basic_subtype_fun :: \"'a::order basic_type \\<Rightarrow> 'a basic_type \\<Rightarrow> bool\" where\n  \"basic_subtype_fun OclAny \\<sigma> = False\"\n| \"basic_subtype_fun OclVoid \\<sigma> = (\\<sigma> \\<noteq> OclVoid)\"\n| \"basic_subtype_fun Boolean \\<sigma> = (\\<sigma> = OclAny)\"\n| \"basic_subtype_fun Real \\<sigma> = (\\<sigma> = OclAny)\"\n| \"basic_subtype_fun Integer \\<sigma> = (\\<sigma> = Real \\<or> \\<sigma> = OclAny)\"\n| \"basic_subtype_fun UnlimitedNatural \\<sigma> = (\\<sigma> = Integer \\<or> \\<sigma> = Real \\<or> \\<sigma> = OclAny)\"\n| \"basic_subtype_fun String \\<sigma> = (\\<sigma> = OclAny)\"\n| \"basic_subtype_fun \\<langle>\\<C>\\<rangle>\\<^sub>\\<T> \\<sigma> = (case \\<sigma>\n    of \\<langle>\\<D>\\<rangle>\\<^sub>\\<T> \\<Rightarrow> \\<C> < \\<D>\n     | OclAny \\<Rightarrow> True\n     | _ \\<Rightarrow> False)\"\n| \"basic_subtype_fun (Enum _) \\<sigma> = (\\<sigma> = OclAny)\""], ["", "lemma less_basic_type_code [code]:\n  \"(<) = basic_subtype_fun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (<) = basic_subtype_fun", "proof (intro ext iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa. x < xa \\<Longrightarrow> basic_subtype_fun x xa\n 2. \\<And>x xa. basic_subtype_fun x xa \\<Longrightarrow> x < xa", "fix \\<tau> \\<sigma> :: \"'a basic_type\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa. x < xa \\<Longrightarrow> basic_subtype_fun x xa\n 2. \\<And>x xa. basic_subtype_fun x xa \\<Longrightarrow> x < xa", "show \"\\<tau> < \\<sigma> \\<Longrightarrow> basic_subtype_fun \\<tau> \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> < \\<sigma> \\<Longrightarrow> basic_subtype_fun \\<tau> \\<sigma>", "apply (cases \\<sigma>; auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<noteq> OclAny; \\<sigma> = OclAny\\<rbrakk>\n    \\<Longrightarrow> basic_subtype_fun \\<tau> OclAny", "using basic_subtype_fun.elims(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> basic_subtype_fun ?x ?xa;\n   \\<And>\\<sigma>.\n      \\<lbrakk>?x = OclAny; ?xa = \\<sigma>\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>\\<sigma>.\n      \\<lbrakk>?x = OclVoid; ?xa = \\<sigma>;\n       \\<not> \\<sigma> \\<noteq> OclVoid\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>\\<sigma>.\n      \\<lbrakk>?x = Boolean; ?xa = \\<sigma>;\n       \\<sigma> \\<noteq> OclAny\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>\\<sigma>.\n      \\<lbrakk>?x = Real; ?xa = \\<sigma>; \\<sigma> \\<noteq> OclAny\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>\\<sigma>.\n      \\<lbrakk>?x = Integer; ?xa = \\<sigma>;\n       \\<not> (\\<sigma> = Real \\<or> \\<sigma> = OclAny)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>\\<sigma>.\n      \\<lbrakk>?x = UnlimitedNatural; ?xa = \\<sigma>;\n       \\<not> (\\<sigma> = Integer \\<or>\n               \\<sigma> = Real \\<or> \\<sigma> = OclAny)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>\\<sigma>.\n      \\<lbrakk>?x = String; ?xa = \\<sigma>;\n       \\<sigma> \\<noteq> OclAny\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>\\<C> \\<sigma>.\n      \\<lbrakk>?x = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>; ?xa = \\<sigma>;\n       \\<not> (case \\<sigma> of OclAny \\<Rightarrow> True\n               | \\<langle>x\\<rangle>\\<^sub>\\<T> \\<Rightarrow> \\<C> < x\n               | _ \\<Rightarrow> False)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>uu_ \\<sigma>.\n      \\<lbrakk>?x = Enum uu_; ?xa = \\<sigma>;\n       \\<sigma> \\<noteq> OclAny\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<noteq> OclAny; \\<sigma> = OclAny\\<rbrakk>\n    \\<Longrightarrow> basic_subtype_fun \\<tau> OclAny", "by fastforce"], ["proof (state)\nthis:\n  \\<tau> < \\<sigma> \\<Longrightarrow> basic_subtype_fun \\<tau> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x xa. basic_subtype_fun x xa \\<Longrightarrow> x < xa", "show \"basic_subtype_fun \\<tau> \\<sigma> \\<Longrightarrow> \\<tau> < \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basic_subtype_fun \\<tau> \\<sigma> \\<Longrightarrow> \\<tau> < \\<sigma>", "apply (erule basic_subtype_fun.elims, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<C>.\n       \\<lbrakk>\\<tau> = \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>;\n        case \\<sigma> of OclAny \\<Rightarrow> True\n        | \\<langle>x\\<rangle>\\<^sub>\\<T> \\<Rightarrow> \\<C> < x\n        | _ \\<Rightarrow> False;\n        \\<forall>\\<D>.\n           \\<sigma> = \\<langle>\\<D>\\<rangle>\\<^sub>\\<T> \\<longrightarrow>\n           \\<not> \\<C> < \\<D>\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = OclAny", "by (cases \\<sigma>, auto)"], ["proof (state)\nthis:\n  basic_subtype_fun \\<tau> \\<sigma> \\<Longrightarrow> \\<tau> < \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma less_eq_basic_type_code [code]:\n  \"(\\<le>) = (\\<lambda>x y. basic_subtype_fun x y \\<or> x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<le>) = (\\<lambda>x y. basic_subtype_fun x y \\<or> x = y)", "unfolding dual_order.order_iff_strict less_basic_type_code"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>b a. basic_subtype_fun b a \\<or> a = b) =\n    (\\<lambda>x y. basic_subtype_fun x y \\<or> x = y)", "by auto"], ["", "end"]]}