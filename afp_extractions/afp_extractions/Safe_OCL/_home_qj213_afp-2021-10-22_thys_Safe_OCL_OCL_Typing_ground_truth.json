{"file_name": "/home/qj213/afp-2021-10-22/thys/Safe_OCL/OCL_Typing.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Safe_OCL", "problem_names": ["lemma typeop_type_det:\n  \"typeop_type op k \\<tau> \\<sigma> \\<rho>\\<^sub>1 \\<Longrightarrow>\n   typeop_type op k \\<tau> \\<sigma> \\<rho>\\<^sub>2 \\<Longrightarrow> \\<rho>\\<^sub>1 = \\<rho>\\<^sub>2\"", "lemma any_unop_type_det:\n  \"any_unop_type op \\<tau> \\<sigma>\\<^sub>1 \\<Longrightarrow>\n   any_unop_type op \\<tau> \\<sigma>\\<^sub>2 \\<Longrightarrow> \\<sigma>\\<^sub>1 = \\<sigma>\\<^sub>2\"", "lemma boolean_unop_type_det:\n  \"boolean_unop_type op \\<tau> \\<sigma>\\<^sub>1 \\<Longrightarrow>\n   boolean_unop_type op \\<tau> \\<sigma>\\<^sub>2 \\<Longrightarrow> \\<sigma>\\<^sub>1 = \\<sigma>\\<^sub>2\"", "lemma numeric_unop_type_det:\n  \"numeric_unop_type op \\<tau> \\<sigma>\\<^sub>1 \\<Longrightarrow>\n   numeric_unop_type op \\<tau> \\<sigma>\\<^sub>2 \\<Longrightarrow> \\<sigma>\\<^sub>1 = \\<sigma>\\<^sub>2\"", "lemma string_unop_type_det:\n  \"string_unop_type op \\<tau> \\<sigma>\\<^sub>1 \\<Longrightarrow>\n   string_unop_type op \\<tau> \\<sigma>\\<^sub>2 \\<Longrightarrow> \\<sigma>\\<^sub>1 = \\<sigma>\\<^sub>2\"", "lemma collection_unop_type_det:\n  \"collection_unop_type op \\<tau> \\<sigma>\\<^sub>1 \\<Longrightarrow>\n   collection_unop_type op \\<tau> \\<sigma>\\<^sub>2 \\<Longrightarrow> \\<sigma>\\<^sub>1 = \\<sigma>\\<^sub>2\"", "lemma unop_type_det:\n  \"unop_type op k \\<tau> \\<sigma>\\<^sub>1 \\<Longrightarrow>\n   unop_type op k \\<tau> \\<sigma>\\<^sub>2 \\<Longrightarrow> \\<sigma>\\<^sub>1 = \\<sigma>\\<^sub>2\"", "lemma super_binop_type_det:\n  \"super_binop_type op \\<tau> \\<sigma> \\<rho>\\<^sub>1 \\<Longrightarrow>\n   super_binop_type op \\<tau> \\<sigma> \\<rho>\\<^sub>2 \\<Longrightarrow> \\<rho>\\<^sub>1 = \\<rho>\\<^sub>2\"", "lemma boolean_binop_type_det:\n  \"boolean_binop_type op \\<tau> \\<sigma> \\<rho>\\<^sub>1 \\<Longrightarrow>\n   boolean_binop_type op \\<tau> \\<sigma> \\<rho>\\<^sub>2 \\<Longrightarrow> \\<rho>\\<^sub>1 = \\<rho>\\<^sub>2\"", "lemma numeric_binop_type_det:\n  \"numeric_binop_type op \\<tau> \\<sigma> \\<rho>\\<^sub>1 \\<Longrightarrow>\n   numeric_binop_type op \\<tau> \\<sigma> \\<rho>\\<^sub>2 \\<Longrightarrow> \\<rho>\\<^sub>1 = \\<rho>\\<^sub>2\"", "lemma string_binop_type_det:\n  \"string_binop_type op \\<tau> \\<sigma> \\<rho>\\<^sub>1 \\<Longrightarrow>\n   string_binop_type op \\<tau> \\<sigma> \\<rho>\\<^sub>2 \\<Longrightarrow> \\<rho>\\<^sub>1 = \\<rho>\\<^sub>2\"", "lemma collection_binop_type_det:\n  \"collection_binop_type op \\<tau> \\<sigma> \\<rho>\\<^sub>1 \\<Longrightarrow>\n   collection_binop_type op \\<tau> \\<sigma> \\<rho>\\<^sub>2 \\<Longrightarrow> \\<rho>\\<^sub>1 = \\<rho>\\<^sub>2\"", "lemma binop_type_det:\n  \"binop_type op k \\<tau> \\<sigma> \\<rho>\\<^sub>1 \\<Longrightarrow>\n   binop_type op k \\<tau> \\<sigma> \\<rho>\\<^sub>2 \\<Longrightarrow> \\<rho>\\<^sub>1 = \\<rho>\\<^sub>2\"", "lemma string_ternop_type_det:\n  \"string_ternop_type op \\<tau> \\<sigma> \\<rho> \\<upsilon>\\<^sub>1 \\<Longrightarrow>\n   string_ternop_type op \\<tau> \\<sigma> \\<rho> \\<upsilon>\\<^sub>2 \\<Longrightarrow> \\<upsilon>\\<^sub>1 = \\<upsilon>\\<^sub>2\"", "lemma collection_ternop_type_det:\n  \"collection_ternop_type op \\<tau> \\<sigma> \\<rho> \\<upsilon>\\<^sub>1 \\<Longrightarrow>\n   collection_ternop_type op \\<tau> \\<sigma> \\<rho> \\<upsilon>\\<^sub>2 \\<Longrightarrow> \\<upsilon>\\<^sub>1 = \\<upsilon>\\<^sub>2\"", "lemma ternop_type_det:\n  \"ternop_type op k \\<tau> \\<sigma> \\<rho> \\<upsilon>\\<^sub>1 \\<Longrightarrow>\n   ternop_type op k \\<tau> \\<sigma> \\<rho> \\<upsilon>\\<^sub>2 \\<Longrightarrow> \\<upsilon>\\<^sub>1 = \\<upsilon>\\<^sub>2\"", "lemma op_type_det:\n  \"op_type op k \\<tau> \\<pi> \\<sigma> \\<Longrightarrow>\n   op_type op k \\<tau> \\<pi> \\<rho> \\<Longrightarrow> \\<sigma> = \\<rho>\"", "lemma\n  typing_det:\n    \"\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau> \\<Longrightarrow>\n     \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow> \\<tau> = \\<sigma>\" and\n  collection_parts_typing_det:\n    \"\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau> \\<Longrightarrow>\n     \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow> \\<tau> = \\<sigma>\" and\n  collection_part_typing_det:\n    \"\\<Gamma> \\<turnstile>\\<^sub>P prt : \\<tau> \\<Longrightarrow>\n     \\<Gamma> \\<turnstile>\\<^sub>P prt : \\<sigma> \\<Longrightarrow> \\<tau> = \\<sigma>\" and\n  iterator_typing_det:\n    \"\\<Gamma> \\<turnstile>\\<^sub>I (src, its, body) : xs \\<Longrightarrow>\n     \\<Gamma> \\<turnstile>\\<^sub>I (src, its, body) : ys \\<Longrightarrow> xs = ys\" and\n  expr_list_typing_det:\n    \"\\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi> \\<Longrightarrow>\n     \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow> \\<pi> = \\<xi>\""], "translations": [["", "lemma typeop_type_det:\n  \"typeop_type op k \\<tau> \\<sigma> \\<rho>\\<^sub>1 \\<Longrightarrow>\n   typeop_type op k \\<tau> \\<sigma> \\<rho>\\<^sub>2 \\<Longrightarrow> \\<rho>\\<^sub>1 = \\<rho>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>typeop_type op k \\<tau> \\<sigma> \\<rho>\\<^sub>1;\n     typeop_type op k \\<tau> \\<sigma> \\<rho>\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> \\<rho>\\<^sub>1 = \\<rho>\\<^sub>2", "by (induct rule: typeop_type.induct;\n      auto simp add: typeop_type.simps update_element_type_det)"], ["", "lemma any_unop_type_det:\n  \"any_unop_type op \\<tau> \\<sigma>\\<^sub>1 \\<Longrightarrow>\n   any_unop_type op \\<tau> \\<sigma>\\<^sub>2 \\<Longrightarrow> \\<sigma>\\<^sub>1 = \\<sigma>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>any_unop_type op \\<tau> \\<sigma>\\<^sub>1;\n     any_unop_type op \\<tau> \\<sigma>\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>1 = \\<sigma>\\<^sub>2", "by (induct rule: any_unop_type.induct; simp add: any_unop_type.simps)"], ["", "lemma boolean_unop_type_det:\n  \"boolean_unop_type op \\<tau> \\<sigma>\\<^sub>1 \\<Longrightarrow>\n   boolean_unop_type op \\<tau> \\<sigma>\\<^sub>2 \\<Longrightarrow> \\<sigma>\\<^sub>1 = \\<sigma>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>boolean_unop_type op \\<tau> \\<sigma>\\<^sub>1;\n     boolean_unop_type op \\<tau> \\<sigma>\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>1 = \\<sigma>\\<^sub>2", "by (induct rule: boolean_unop_type.induct; simp add: boolean_unop_type.simps)"], ["", "lemma numeric_unop_type_det:\n  \"numeric_unop_type op \\<tau> \\<sigma>\\<^sub>1 \\<Longrightarrow>\n   numeric_unop_type op \\<tau> \\<sigma>\\<^sub>2 \\<Longrightarrow> \\<sigma>\\<^sub>1 = \\<sigma>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>numeric_unop_type op \\<tau> \\<sigma>\\<^sub>1;\n     numeric_unop_type op \\<tau> \\<sigma>\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>1 = \\<sigma>\\<^sub>2", "by (induct rule: numeric_unop_type.induct; auto simp add: numeric_unop_type.simps)"], ["", "lemma string_unop_type_det:\n  \"string_unop_type op \\<tau> \\<sigma>\\<^sub>1 \\<Longrightarrow>\n   string_unop_type op \\<tau> \\<sigma>\\<^sub>2 \\<Longrightarrow> \\<sigma>\\<^sub>1 = \\<sigma>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>string_unop_type op \\<tau> \\<sigma>\\<^sub>1;\n     string_unop_type op \\<tau> \\<sigma>\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>1 = \\<sigma>\\<^sub>2", "by (induct rule: string_unop_type.induct; simp add: string_unop_type.simps)"], ["", "lemma collection_unop_type_det:\n  \"collection_unop_type op \\<tau> \\<sigma>\\<^sub>1 \\<Longrightarrow>\n   collection_unop_type op \\<tau> \\<sigma>\\<^sub>2 \\<Longrightarrow> \\<sigma>\\<^sub>1 = \\<sigma>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>collection_unop_type op \\<tau> \\<sigma>\\<^sub>1;\n     collection_unop_type op \\<tau> \\<sigma>\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>1 = \\<sigma>\\<^sub>2", "apply (induct rule: collection_unop_type.induct)"], ["proof (prove)\ngoal (20 subgoals):\n 1. \\<And>\\<tau> uu_.\n       \\<lbrakk>element_type \\<tau> uu_;\n        collection_unop_type CollectionSizeOp \\<tau>\n         \\<sigma>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Integer[1] = \\<sigma>\\<^sub>2\n 2. \\<And>\\<tau> uv_.\n       \\<lbrakk>element_type \\<tau> uv_;\n        collection_unop_type IsEmptyOp \\<tau> \\<sigma>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>\\<^sub>2\n 3. \\<And>\\<tau> uw_.\n       \\<lbrakk>element_type \\<tau> uw_;\n        collection_unop_type NotEmptyOp \\<tau> \\<sigma>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>\\<^sub>2\n 4. \\<And>\\<tau> \\<sigma>.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<sigma> = UnlimitedNatural[1]\\<midarrow>Real[1];\n        collection_unop_type CollectionMaxOp \\<tau>\n         \\<sigma>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>\\<^sub>2\n 5. \\<And>\\<tau> \\<sigma> oper.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        operation \\<sigma> STR ''max'' [\\<sigma>] oper;\n        collection_unop_type CollectionMaxOp \\<tau>\n         \\<sigma>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>\\<^sub>2\n 6. \\<And>\\<tau> \\<sigma>.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<sigma> = UnlimitedNatural[1]\\<midarrow>Real[1];\n        collection_unop_type CollectionMinOp \\<tau>\n         \\<sigma>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>\\<^sub>2\n 7. \\<And>\\<tau> \\<sigma> oper.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        operation \\<sigma> STR ''min'' [\\<sigma>] oper;\n        collection_unop_type CollectionMinOp \\<tau>\n         \\<sigma>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>\\<^sub>2\n 8. \\<And>\\<tau> \\<sigma>.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        \\<sigma> = UnlimitedNatural[1]\\<midarrow>Real[1];\n        collection_unop_type SumOp \\<tau> \\<sigma>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>\\<^sub>2\n 9. \\<And>\\<tau> \\<sigma> oper.\n       \\<lbrakk>element_type \\<tau> \\<sigma>;\n        operation \\<sigma> STR ''+'' [\\<sigma>] oper;\n        collection_unop_type SumOp \\<tau> \\<sigma>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>\\<^sub>2\n 10. \\<And>\\<tau> \\<sigma>.\n        \\<lbrakk>element_type \\<tau> \\<sigma>;\n         collection_unop_type AsSetOp \\<tau> \\<sigma>\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> Set \\<sigma> = \\<sigma>\\<^sub>2\nA total of 20 subgoals...", "by (erule collection_unop_type.cases;\n      auto simp add: element_type_det update_element_type_det)+"], ["", "lemma unop_type_det:\n  \"unop_type op k \\<tau> \\<sigma>\\<^sub>1 \\<Longrightarrow>\n   unop_type op k \\<tau> \\<sigma>\\<^sub>2 \\<Longrightarrow> \\<sigma>\\<^sub>1 = \\<sigma>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>unop_type op k \\<tau> \\<sigma>\\<^sub>1;\n     unop_type op k \\<tau> \\<sigma>\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>1 = \\<sigma>\\<^sub>2", "by (induct rule: unop_type.induct;\n      simp add: unop_type.simps any_unop_type_det\n                boolean_unop_type_det numeric_unop_type_det\n                string_unop_type_det collection_unop_type_det)"], ["", "lemma super_binop_type_det:\n  \"super_binop_type op \\<tau> \\<sigma> \\<rho>\\<^sub>1 \\<Longrightarrow>\n   super_binop_type op \\<tau> \\<sigma> \\<rho>\\<^sub>2 \\<Longrightarrow> \\<rho>\\<^sub>1 = \\<rho>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>super_binop_type op \\<tau> \\<sigma> \\<rho>\\<^sub>1;\n     super_binop_type op \\<tau> \\<sigma> \\<rho>\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> \\<rho>\\<^sub>1 = \\<rho>\\<^sub>2", "by (induct rule: super_binop_type.induct; auto simp add: super_binop_type.simps)"], ["", "lemma boolean_binop_type_det:\n  \"boolean_binop_type op \\<tau> \\<sigma> \\<rho>\\<^sub>1 \\<Longrightarrow>\n   boolean_binop_type op \\<tau> \\<sigma> \\<rho>\\<^sub>2 \\<Longrightarrow> \\<rho>\\<^sub>1 = \\<rho>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>boolean_binop_type op \\<tau> \\<sigma> \\<rho>\\<^sub>1;\n     boolean_binop_type op \\<tau> \\<sigma> \\<rho>\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> \\<rho>\\<^sub>1 = \\<rho>\\<^sub>2", "by (induct rule: boolean_binop_type.induct; simp add: boolean_binop_type.simps)"], ["", "lemma numeric_binop_type_det:\n  \"numeric_binop_type op \\<tau> \\<sigma> \\<rho>\\<^sub>1 \\<Longrightarrow>\n   numeric_binop_type op \\<tau> \\<sigma> \\<rho>\\<^sub>2 \\<Longrightarrow> \\<rho>\\<^sub>1 = \\<rho>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>numeric_binop_type op \\<tau> \\<sigma> \\<rho>\\<^sub>1;\n     numeric_binop_type op \\<tau> \\<sigma> \\<rho>\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> \\<rho>\\<^sub>1 = \\<rho>\\<^sub>2", "by (induct rule: numeric_binop_type.induct;\n      auto simp add: numeric_binop_type.simps split: if_splits)"], ["", "lemma string_binop_type_det:\n  \"string_binop_type op \\<tau> \\<sigma> \\<rho>\\<^sub>1 \\<Longrightarrow>\n   string_binop_type op \\<tau> \\<sigma> \\<rho>\\<^sub>2 \\<Longrightarrow> \\<rho>\\<^sub>1 = \\<rho>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>string_binop_type op \\<tau> \\<sigma> \\<rho>\\<^sub>1;\n     string_binop_type op \\<tau> \\<sigma> \\<rho>\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> \\<rho>\\<^sub>1 = \\<rho>\\<^sub>2", "by (induct rule: string_binop_type.induct; simp add: string_binop_type.simps)"], ["", "lemma collection_binop_type_det:\n  \"collection_binop_type op \\<tau> \\<sigma> \\<rho>\\<^sub>1 \\<Longrightarrow>\n   collection_binop_type op \\<tau> \\<sigma> \\<rho>\\<^sub>2 \\<Longrightarrow> \\<rho>\\<^sub>1 = \\<rho>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>collection_binop_type op \\<tau> \\<sigma> \\<rho>\\<^sub>1;\n     collection_binop_type op \\<tau> \\<sigma> \\<rho>\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> \\<rho>\\<^sub>1 = \\<rho>\\<^sub>2", "apply (induct rule: collection_binop_type.induct; simp add: collection_binop_type.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau> \\<rho> \\<sigma> \\<upsilon>.\n       \\<lbrakk>element_type \\<tau> \\<rho>;\n        element_type \\<sigma> \\<upsilon>;\n        \\<exists>\\<rho> \\<upsilon>.\n           \\<rho>\\<^sub>2 =\n           Set (Tuple\n                 [STR ''second'' \\<mapsto>\\<^sub>f \\<upsilon>,\n                  STR ''first'' \\<mapsto>\\<^sub>f \\<rho>]) \\<and>\n           element_type \\<tau> \\<rho> \\<and>\n           element_type \\<sigma> \\<upsilon>\\<rbrakk>\n       \\<Longrightarrow> Set (Tuple\n                               [STR ''second'' \\<mapsto>\\<^sub>f \\<upsilon>,\n                                STR ''first'' \\<mapsto>\\<^sub>f \\<rho>]) =\n                         \\<rho>\\<^sub>2\n 2. \\<And>\\<tau> \\<rho> \\<sigma> \\<upsilon>.\n       \\<lbrakk>element_type \\<tau> \\<rho>;\n        update_element_type \\<tau> (\\<rho> \\<squnion> \\<sigma>) \\<upsilon>;\n        \\<exists>\\<rho>.\n           element_type \\<tau> \\<rho> \\<and>\n           update_element_type \\<tau> (\\<rho> \\<squnion> \\<sigma>)\n            \\<rho>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<rho>\\<^sub>2", "using element_type_det update_element_type_det"], ["proof (prove)\nusing this:\n  \\<lbrakk>element_type ?\\<tau> ?\\<sigma>\\<^sub>1;\n   element_type ?\\<tau> ?\\<sigma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?\\<sigma>\\<^sub>1 = ?\\<sigma>\\<^sub>2\n  \\<lbrakk>update_element_type ?\\<tau> ?\\<sigma> ?\\<rho>\\<^sub>1;\n   update_element_type ?\\<tau> ?\\<sigma> ?\\<rho>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?\\<rho>\\<^sub>1 = ?\\<rho>\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>\\<tau> \\<rho> \\<sigma> \\<upsilon>.\n       \\<lbrakk>element_type \\<tau> \\<rho>;\n        element_type \\<sigma> \\<upsilon>;\n        \\<exists>\\<rho> \\<upsilon>.\n           \\<rho>\\<^sub>2 =\n           Set (Tuple\n                 [STR ''second'' \\<mapsto>\\<^sub>f \\<upsilon>,\n                  STR ''first'' \\<mapsto>\\<^sub>f \\<rho>]) \\<and>\n           element_type \\<tau> \\<rho> \\<and>\n           element_type \\<sigma> \\<upsilon>\\<rbrakk>\n       \\<Longrightarrow> Set (Tuple\n                               [STR ''second'' \\<mapsto>\\<^sub>f \\<upsilon>,\n                                STR ''first'' \\<mapsto>\\<^sub>f \\<rho>]) =\n                         \\<rho>\\<^sub>2\n 2. \\<And>\\<tau> \\<rho> \\<sigma> \\<upsilon>.\n       \\<lbrakk>element_type \\<tau> \\<rho>;\n        update_element_type \\<tau> (\\<rho> \\<squnion> \\<sigma>) \\<upsilon>;\n        \\<exists>\\<rho>.\n           element_type \\<tau> \\<rho> \\<and>\n           update_element_type \\<tau> (\\<rho> \\<squnion> \\<sigma>)\n            \\<rho>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<rho>\\<^sub>2", "by blast+"], ["", "lemma binop_type_det:\n  \"binop_type op k \\<tau> \\<sigma> \\<rho>\\<^sub>1 \\<Longrightarrow>\n   binop_type op k \\<tau> \\<sigma> \\<rho>\\<^sub>2 \\<Longrightarrow> \\<rho>\\<^sub>1 = \\<rho>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>binop_type op k \\<tau> \\<sigma> \\<rho>\\<^sub>1;\n     binop_type op k \\<tau> \\<sigma> \\<rho>\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> \\<rho>\\<^sub>1 = \\<rho>\\<^sub>2", "by (induct rule: binop_type.induct;\n      simp add: binop_type.simps super_binop_type_det\n                boolean_binop_type_det numeric_binop_type_det\n                string_binop_type_det collection_binop_type_det)"], ["", "lemma string_ternop_type_det:\n  \"string_ternop_type op \\<tau> \\<sigma> \\<rho> \\<upsilon>\\<^sub>1 \\<Longrightarrow>\n   string_ternop_type op \\<tau> \\<sigma> \\<rho> \\<upsilon>\\<^sub>2 \\<Longrightarrow> \\<upsilon>\\<^sub>1 = \\<upsilon>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>string_ternop_type op \\<tau> \\<sigma> \\<rho>\n              \\<upsilon>\\<^sub>1;\n     string_ternop_type op \\<tau> \\<sigma> \\<rho>\n      \\<upsilon>\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> \\<upsilon>\\<^sub>1 = \\<upsilon>\\<^sub>2", "by (induct rule: string_ternop_type.induct; simp add: string_ternop_type.simps)"], ["", "lemma collection_ternop_type_det:\n  \"collection_ternop_type op \\<tau> \\<sigma> \\<rho> \\<upsilon>\\<^sub>1 \\<Longrightarrow>\n   collection_ternop_type op \\<tau> \\<sigma> \\<rho> \\<upsilon>\\<^sub>2 \\<Longrightarrow> \\<upsilon>\\<^sub>1 = \\<upsilon>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>collection_ternop_type op \\<tau> \\<sigma> \\<rho>\n              \\<upsilon>\\<^sub>1;\n     collection_ternop_type op \\<tau> \\<sigma> \\<rho>\n      \\<upsilon>\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> \\<upsilon>\\<^sub>1 = \\<upsilon>\\<^sub>2", "by (induct rule: collection_ternop_type.induct; simp add: collection_ternop_type.simps)"], ["", "lemma ternop_type_det:\n  \"ternop_type op k \\<tau> \\<sigma> \\<rho> \\<upsilon>\\<^sub>1 \\<Longrightarrow>\n   ternop_type op k \\<tau> \\<sigma> \\<rho> \\<upsilon>\\<^sub>2 \\<Longrightarrow> \\<upsilon>\\<^sub>1 = \\<upsilon>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ternop_type op k \\<tau> \\<sigma> \\<rho> \\<upsilon>\\<^sub>1;\n     ternop_type op k \\<tau> \\<sigma> \\<rho> \\<upsilon>\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> \\<upsilon>\\<^sub>1 = \\<upsilon>\\<^sub>2", "by (induct rule: ternop_type.induct;\n      simp add: ternop_type.simps string_ternop_type_det collection_ternop_type_det)"], ["", "lemma op_type_det:\n  \"op_type op k \\<tau> \\<pi> \\<sigma> \\<Longrightarrow>\n   op_type op k \\<tau> \\<pi> \\<rho> \\<Longrightarrow> \\<sigma> = \\<rho>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>op_type op k \\<tau> \\<pi> \\<sigma>;\n     op_type op k \\<tau> \\<pi> \\<rho>\\<rbrakk>\n    \\<Longrightarrow> \\<sigma> = \\<rho>", "apply (induct rule: op_type.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>op k \\<tau> \\<upsilon>.\n       \\<lbrakk>unop_type op k \\<tau> \\<upsilon>;\n        op_type (Inl op) k \\<tau> [] \\<rho>\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<rho>\n 2. \\<And>op k \\<tau> \\<sigma> \\<upsilon>.\n       \\<lbrakk>binop_type op k \\<tau> \\<sigma> \\<upsilon>;\n        op_type (Inr (Inl op)) k \\<tau> [\\<sigma>] \\<rho>\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<rho>\n 3. \\<And>op k \\<tau> \\<sigma> \\<rho>' \\<upsilon>.\n       \\<lbrakk>ternop_type op k \\<tau> \\<sigma> \\<rho>' \\<upsilon>;\n        op_type (Inr (Inr (Inl op))) k \\<tau> [\\<sigma>, \\<rho>']\n         \\<rho>\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<rho>\n 4. \\<And>\\<tau> op \\<pi> oper.\n       \\<lbrakk>operation \\<tau> op \\<pi> oper;\n        op_type (Inr (Inr (Inr op))) DotCall \\<tau> \\<pi> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<rho>", "apply (erule op_type.cases; simp add: unop_type_det)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>op k \\<tau> \\<sigma> \\<upsilon>.\n       \\<lbrakk>binop_type op k \\<tau> \\<sigma> \\<upsilon>;\n        op_type (Inr (Inl op)) k \\<tau> [\\<sigma>] \\<rho>\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<rho>\n 2. \\<And>op k \\<tau> \\<sigma> \\<rho>' \\<upsilon>.\n       \\<lbrakk>ternop_type op k \\<tau> \\<sigma> \\<rho>' \\<upsilon>;\n        op_type (Inr (Inr (Inl op))) k \\<tau> [\\<sigma>, \\<rho>']\n         \\<rho>\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<rho>\n 3. \\<And>\\<tau> op \\<pi> oper.\n       \\<lbrakk>operation \\<tau> op \\<pi> oper;\n        op_type (Inr (Inr (Inr op))) DotCall \\<tau> \\<pi> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<rho>", "apply (erule op_type.cases; simp add: binop_type_det)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>op k \\<tau> \\<sigma> \\<rho>' \\<upsilon>.\n       \\<lbrakk>ternop_type op k \\<tau> \\<sigma> \\<rho>' \\<upsilon>;\n        op_type (Inr (Inr (Inl op))) k \\<tau> [\\<sigma>, \\<rho>']\n         \\<rho>\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<rho>\n 2. \\<And>\\<tau> op \\<pi> oper.\n       \\<lbrakk>operation \\<tau> op \\<pi> oper;\n        op_type (Inr (Inr (Inr op))) DotCall \\<tau> \\<pi> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<rho>", "apply (erule op_type.cases; simp add: ternop_type_det)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> op \\<pi> oper.\n       \\<lbrakk>operation \\<tau> op \\<pi> oper;\n        op_type (Inr (Inr (Inr op))) DotCall \\<tau> \\<pi> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<rho>", "by (erule op_type.cases; simp; metis operation_det)"], ["", "(*** Expressions Typing *****************************************************)"], ["", "section \\<open>Expressions Typing\\<close>"], ["", "text \\<open>\n  The following typing rules are preliminary. The final rules are given at\n  the end of the next chapter.\\<close>"], ["", "inductive typing :: \"('a :: ocl_object_model) type env \\<Rightarrow> 'a expr \\<Rightarrow> 'a type \\<Rightarrow> bool\"\n       (\"(1_/ \\<turnstile>\\<^sub>E/ (_ :/ _))\" [51,51,51] 50)\n    and collection_parts_typing (\"(1_/ \\<turnstile>\\<^sub>C/ (_ :/ _))\" [51,51,51] 50)\n    and collection_part_typing (\"(1_/ \\<turnstile>\\<^sub>P/ (_ :/ _))\" [51,51,51] 50)\n    and iterator_typing (\"(1_/ \\<turnstile>\\<^sub>I/ (_ :/ _))\" [51,51,51] 50)\n    and expr_list_typing (\"(1_/ \\<turnstile>\\<^sub>L/ (_ :/ _))\" [51,51,51] 50) where\n\n\\<comment> \\<open>Primitive Literals\\<close>\n\n NullLiteralT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>E NullLiteral : OclVoid[?]\"\n|BooleanLiteralT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>E BooleanLiteral c : Boolean[1]\"\n|RealLiteralT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>E RealLiteral c : Real[1]\"\n|IntegerLiteralT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>E IntegerLiteral c : Integer[1]\"\n|UnlimitedNaturalLiteralT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>E UnlimitedNaturalLiteral c : UnlimitedNatural[1]\"\n|StringLiteralT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>E StringLiteral c : String[1]\"\n|EnumLiteralT:\n  \"has_literal enum lit \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E EnumLiteral enum lit : (Enum enum)[1]\"\n\n\\<comment> \\<open>Collection Literals\\<close>\n\n|SetLiteralT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E CollectionLiteral SetKind prts : Set \\<tau>\"\n|OrderedSetLiteralT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E CollectionLiteral OrderedSetKind prts : OrderedSet \\<tau>\"\n|BagLiteralT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E CollectionLiteral BagKind prts : Bag \\<tau>\"\n|SequenceLiteralT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E CollectionLiteral SequenceKind prts : Sequence \\<tau>\"\n\n\\<comment> \\<open>We prohibit empty collection literals, because their type is unclear.\n  We could use @{text \"OclVoid[1]\"} element type for empty collections, but\n  the typing rules will give wrong types for nested collections, because,\n  for example, @{text \"OclVoid[1] \\<squnion> Set(Integer[1]) = OclSuper\"}\\<close>\n\n|CollectionPartsSingletonT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<tau>\"\n|CollectionPartsListT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<tau> \\<squnion> \\<sigma>\"\n\n|CollectionPartItemT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<tau>\"\n|CollectionPartRangeT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma> \\<Longrightarrow>\n   \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1] \\<Longrightarrow>\n   \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1] \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>P CollectionRange a b : Integer[1]\"\n\n\\<comment> \\<open>Tuple Literals\\<close>\n\\<comment> \\<open>We do not prohibit empty tuples, because it could be useful.\n  @{text \"Tuple()\"} is a supertype of all other tuple types.\\<close>\n\n|TupleLiteralNilT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>E TupleLiteral [] : Tuple fmempty\"\n|TupleLiteralConsT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>E TupleLiteral elems : Tuple \\<xi> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau> \\<Longrightarrow>\n   tuple_element_type el = Some \\<sigma> \\<Longrightarrow>\n   \\<tau> \\<le> \\<sigma> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E TupleLiteral (el # elems) : Tuple (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f \\<sigma>))\"\n\n\\<comment> \\<open>Misc Expressions\\<close>\n\n|LetT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma> \\<Longrightarrow>\n   \\<sigma> \\<le> \\<tau> \\<Longrightarrow>\n   \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E body : \\<rho> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E Let v (Some \\<tau>) init body : \\<rho>\"\n|VarT:\n  \"fmlookup \\<Gamma> v = Some \\<tau> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<tau>\"\n|IfT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1] \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E If a b c : \\<sigma> \\<squnion> \\<rho>\"\n\n\\<comment> \\<open>Call Expressions\\<close>\n\n|MetaOperationCallT:\n  \"mataop_type \\<tau> op \\<sigma> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E MetaOperationCall \\<tau> op : \\<sigma>\"\n|StaticOperationCallT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi> \\<Longrightarrow>\n   static_operation \\<tau> op \\<pi> oper \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E StaticOperationCall \\<tau> op params : oper_type oper\"\n\n|TypeOperationCallT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau> \\<Longrightarrow>\n   typeop_type k op \\<tau> \\<sigma> \\<rho> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E TypeOperationCall a k op \\<sigma> : \\<rho>\"\n\n|AttributeCallT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>E src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] \\<Longrightarrow>\n   attribute \\<C> prop \\<D> \\<tau> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E AttributeCall src DotCall prop : \\<tau>\"\n|AssociationEndCallT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>E src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] \\<Longrightarrow>\n   association_end \\<C> from role \\<D> end \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E AssociationEndCall src DotCall from role : assoc_end_type end\"\n|AssociationClassCallT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>E src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] \\<Longrightarrow>\n   referred_by_association_class \\<C> from \\<A> \\<D> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E AssociationClassCall src DotCall from \\<A> : class_assoc_type \\<A>\"\n|AssociationClassEndCallT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>E src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] \\<Longrightarrow>\n   association_class_end \\<A> role end \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E AssociationClassEndCall src DotCall role : class_assoc_end_type end\"\n|OperationCallT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi> \\<Longrightarrow>\n   op_type op k \\<tau> \\<pi> \\<sigma> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E OperationCall src k op params : \\<sigma>\"\n\n|TupleElementCallT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi> \\<Longrightarrow>\n   fmlookup \\<pi> elem = Some \\<tau> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E TupleElementCall src DotCall elem : \\<tau>\"\n\n\\<comment> \\<open>Iterator Expressions\\<close>\n\n|IteratorT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau> \\<Longrightarrow>\n   element_type \\<tau> \\<sigma> \\<Longrightarrow>\n   \\<sigma> \\<le> its_ty \\<Longrightarrow>\n   \\<Gamma> ++\\<^sub>f fmap_of_list (map (\\<lambda>it. (it, its_ty)) its) \\<turnstile>\\<^sub>E body : \\<rho> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>I (src, its, (Some its_ty), body) : (\\<tau>, \\<sigma>, \\<rho>)\"\n\n|IterateT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>I (src, its, its_ty, Let res (Some res_t) res_init body) : (\\<tau>, \\<sigma>, \\<rho>) \\<Longrightarrow>\n   \\<rho> \\<le> res_t \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E IterateCall src ArrowCall its its_ty res (Some res_t) res_init body : \\<rho>\"\n\n|AnyIteratorT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>I (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>) \\<Longrightarrow>\n   length its \\<le> 1 \\<Longrightarrow>\n   \\<rho> \\<le> Boolean[?] \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>\"\n|ClosureIteratorT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>I (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>) \\<Longrightarrow>\n   length its \\<le> 1 \\<Longrightarrow>\n   to_single_type \\<rho> \\<le> \\<sigma> \\<Longrightarrow>\n   to_unique_collection \\<tau> \\<upsilon> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E ClosureIteratorCall src ArrowCall its its_ty body : \\<upsilon>\"\n|CollectIteratorT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>I (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>) \\<Longrightarrow>\n   length its \\<le> 1 \\<Longrightarrow>\n   to_nonunique_collection \\<tau> \\<upsilon> \\<Longrightarrow>\n   update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E CollectIteratorCall src ArrowCall its its_ty body : \\<phi>\"\n|CollectNestedIteratorT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>I (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>) \\<Longrightarrow>\n   length its \\<le> 1 \\<Longrightarrow>\n   to_nonunique_collection \\<tau> \\<upsilon> \\<Longrightarrow>\n   update_element_type \\<upsilon> \\<rho> \\<phi> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E CollectNestedIteratorCall src ArrowCall its its_ty body : \\<phi>\"\n|ExistsIteratorT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>I (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>) \\<Longrightarrow>\n   \\<rho> \\<le> Boolean[?] \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E ExistsIteratorCall src ArrowCall its its_ty body : \\<rho>\"\n|ForAllIteratorT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>I (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>) \\<Longrightarrow>\n   \\<rho> \\<le> Boolean[?] \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E ForAllIteratorCall src ArrowCall its its_ty body : \\<rho>\"\n|OneIteratorT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>I (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>) \\<Longrightarrow>\n   length its \\<le> 1 \\<Longrightarrow>\n   \\<rho> \\<le> Boolean[?] \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E OneIteratorCall src ArrowCall its its_ty body : Boolean[1]\"\n|IsUniqueIteratorT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>I (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>) \\<Longrightarrow>\n   length its \\<le> 1 \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E IsUniqueIteratorCall src ArrowCall its its_ty body : Boolean[1]\"\n|SelectIteratorT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>I (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>) \\<Longrightarrow>\n   length its \\<le> 1 \\<Longrightarrow>\n   \\<rho> \\<le> Boolean[?] \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E SelectIteratorCall src ArrowCall its its_ty body : \\<tau>\"\n|RejectIteratorT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>I (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>) \\<Longrightarrow>\n   length its \\<le> 1 \\<Longrightarrow>\n   \\<rho> \\<le> Boolean[?] \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E RejectIteratorCall src ArrowCall its its_ty body : \\<tau>\"\n|SortedByIteratorT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>I (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>) \\<Longrightarrow>\n   length its \\<le> 1 \\<Longrightarrow>\n   to_ordered_collection \\<tau> \\<upsilon> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>E SortedByIteratorCall src ArrowCall its its_ty body : \\<upsilon>\"\n\n\\<comment> \\<open>Expression Lists\\<close>\n\n|ExprListNilT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>L [] : []\"\n|ExprListConsT:\n  \"\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi> \\<Longrightarrow>\n   \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<tau> # \\<pi>\""], ["", "(*** Elimination Rules ******************************************************)"], ["", "section \\<open>Elimination Rules\\<close>"], ["", "inductive_cases NullLiteralTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E NullLiteral : \\<tau>\""], ["", "inductive_cases BooleanLiteralTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E BooleanLiteral c : \\<tau>\""], ["", "inductive_cases RealLiteralTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E RealLiteral c : \\<tau>\""], ["", "inductive_cases IntegerLiteralTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E IntegerLiteral c : \\<tau>\""], ["", "inductive_cases UnlimitedNaturalLiteralTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E UnlimitedNaturalLiteral c : \\<tau>\""], ["", "inductive_cases StringLiteralTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E StringLiteral c : \\<tau>\""], ["", "inductive_cases EnumLiteralTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E EnumLiteral enm lit : \\<tau>\""], ["", "inductive_cases CollectionLiteralTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E CollectionLiteral k prts : \\<tau>\""], ["", "inductive_cases TupleLiteralTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E TupleLiteral elems : \\<tau>\""], ["", "inductive_cases LetTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E Let v \\<tau> init body : \\<sigma>\""], ["", "inductive_cases VarTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<tau>\""], ["", "inductive_cases IfTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E If a b c : \\<tau>\""], ["", "inductive_cases MetaOperationCallTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E MetaOperationCall \\<tau> op : \\<sigma>\""], ["", "inductive_cases StaticOperationCallTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E StaticOperationCall \\<tau> op as : \\<sigma>\""], ["", "inductive_cases TypeOperationCallTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E TypeOperationCall a k op \\<sigma> : \\<tau>\""], ["", "inductive_cases AttributeCallTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E AttributeCall src k prop : \\<tau>\""], ["", "inductive_cases AssociationEndCallTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E AssociationEndCall src k role from : \\<tau>\""], ["", "inductive_cases AssociationClassCallTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E AssociationClassCall src k a from : \\<tau>\""], ["", "inductive_cases AssociationClassEndCallTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E AssociationClassEndCall src k role : \\<tau>\""], ["", "inductive_cases OperationCallTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E OperationCall src k op params : \\<tau>\""], ["", "inductive_cases TupleElementCallTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E TupleElementCall src k elem : \\<tau>\""], ["", "inductive_cases IteratorTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>I (src, its, body) : ys\""], ["", "inductive_cases IterateTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E IterateCall src k its its_ty res res_t res_init body : \\<tau>\""], ["", "inductive_cases AnyIteratorTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E AnyIteratorCall src k its its_ty body : \\<tau>\""], ["", "inductive_cases ClosureIteratorTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E ClosureIteratorCall src k its its_ty body : \\<tau>\""], ["", "inductive_cases CollectIteratorTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E CollectIteratorCall src k its its_ty body : \\<tau>\""], ["", "inductive_cases CollectNestedIteratorTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E CollectNestedIteratorCall src k its its_ty body : \\<tau>\""], ["", "inductive_cases ExistsIteratorTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E ExistsIteratorCall src k its its_ty body : \\<tau>\""], ["", "inductive_cases ForAllIteratorTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E ForAllIteratorCall src k its its_ty body : \\<tau>\""], ["", "inductive_cases OneIteratorTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E OneIteratorCall src k its its_ty body : \\<tau>\""], ["", "inductive_cases IsUniqueIteratorTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E IsUniqueIteratorCall src k its its_ty body : \\<tau>\""], ["", "inductive_cases SelectIteratorTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E SelectIteratorCall src k its its_ty body : \\<tau>\""], ["", "inductive_cases RejectIteratorTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E RejectIteratorCall src k its its_ty body : \\<tau>\""], ["", "inductive_cases SortedByIteratorTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>E SortedByIteratorCall src k its its_ty body : \\<tau>\""], ["", "inductive_cases CollectionPartsNilTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<tau>\""], ["", "inductive_cases CollectionPartsItemTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<tau>\""], ["", "inductive_cases CollectionItemTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<tau>\""], ["", "inductive_cases CollectionRangeTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>P CollectionRange a b : \\<tau>\""], ["", "inductive_cases ExprListTE [elim]: \"\\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>\""], ["", "(*** Simplification Rules ***************************************************)"], ["", "section \\<open>Simplification Rules\\<close>"], ["", "inductive_simps typing_alt_simps: \n\"\\<Gamma> \\<turnstile>\\<^sub>E NullLiteral : \\<tau>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>E BooleanLiteral c : \\<tau>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>E RealLiteral c : \\<tau>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>E UnlimitedNaturalLiteral c : \\<tau>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>E IntegerLiteral c : \\<tau>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>E StringLiteral c : \\<tau>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>E EnumLiteral enm lit : \\<tau>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>E CollectionLiteral k prts : \\<tau>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>E TupleLiteral [] : \\<tau>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>E TupleLiteral (x # xs) : \\<tau>\"\n\n\"\\<Gamma> \\<turnstile>\\<^sub>E Let v \\<tau> init body : \\<sigma>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<tau>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>E If a b c : \\<tau>\"\n\n\"\\<Gamma> \\<turnstile>\\<^sub>E MetaOperationCall \\<tau> op : \\<sigma>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>E StaticOperationCall \\<tau> op as : \\<sigma>\"\n\n\"\\<Gamma> \\<turnstile>\\<^sub>E TypeOperationCall a k op \\<sigma> : \\<tau>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>E AttributeCall src k prop : \\<tau>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>E AssociationEndCall src k role from : \\<tau>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>E AssociationClassCall src k a from : \\<tau>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>E AssociationClassEndCall src k role : \\<tau>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>E OperationCall src k op params : \\<tau>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>E TupleElementCall src k elem : \\<tau>\"\n\n\"\\<Gamma> \\<turnstile>\\<^sub>I (src, its, body) : ys\"\n\"\\<Gamma> \\<turnstile>\\<^sub>E IterateCall src k its its_ty res res_t res_init body : \\<tau>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>E AnyIteratorCall src k its its_ty body : \\<tau>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>E ClosureIteratorCall src k its its_ty body : \\<tau>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>E CollectIteratorCall src k its its_ty body : \\<tau>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>E CollectNestedIteratorCall src k its its_ty body : \\<tau>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>E ExistsIteratorCall src k its its_ty body : \\<tau>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>E ForAllIteratorCall src k its its_ty body : \\<tau>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>E OneIteratorCall src k its its_ty body : \\<tau>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>E IsUniqueIteratorCall src k its its_ty body : \\<tau>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>E SelectIteratorCall src k its its_ty body : \\<tau>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>E RejectIteratorCall src k its its_ty body : \\<tau>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>E SortedByIteratorCall src k its its_ty body : \\<tau>\"\n\n\"\\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<tau>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<tau>\"\n\n\"\\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<tau>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>P CollectionRange a b : \\<tau>\"\n\n\"\\<Gamma> \\<turnstile>\\<^sub>L [] : \\<pi>\"\n\"\\<Gamma> \\<turnstile>\\<^sub>L x # xs : \\<pi>\""], ["", "(*** Determinism ************************************************************)"], ["", "section \\<open>Determinism\\<close>"], ["", "lemma\n  typing_det:\n    \"\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau> \\<Longrightarrow>\n     \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow> \\<tau> = \\<sigma>\" and\n  collection_parts_typing_det:\n    \"\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau> \\<Longrightarrow>\n     \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow> \\<tau> = \\<sigma>\" and\n  collection_part_typing_det:\n    \"\\<Gamma> \\<turnstile>\\<^sub>P prt : \\<tau> \\<Longrightarrow>\n     \\<Gamma> \\<turnstile>\\<^sub>P prt : \\<sigma> \\<Longrightarrow> \\<tau> = \\<sigma>\" and\n  iterator_typing_det:\n    \"\\<Gamma> \\<turnstile>\\<^sub>I (src, its, body) : xs \\<Longrightarrow>\n     \\<Gamma> \\<turnstile>\\<^sub>I (src, its, body) : ys \\<Longrightarrow> xs = ys\" and\n  expr_list_typing_det:\n    \"\\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi> \\<Longrightarrow>\n     \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow> \\<pi> = \\<xi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n       \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma>\\<rbrakk>\n      \\<Longrightarrow> \\<tau> = \\<sigma>) &&&\n     (\\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n       \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma>\\<rbrakk>\n      \\<Longrightarrow> \\<tau> = \\<sigma>)) &&&\n    (\\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P prt : \\<tau>;\n      \\<Gamma> \\<turnstile>\\<^sub>P prt : \\<sigma>\\<rbrakk>\n     \\<Longrightarrow> \\<tau> = \\<sigma>) &&&\n    (\\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I (src, its, body) : xs;\n      \\<Gamma> \\<turnstile>\\<^sub>I (src, its, body) : ys\\<rbrakk>\n     \\<Longrightarrow> xs = ys) &&&\n    (\\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n      \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi>\\<rbrakk>\n     \\<Longrightarrow> \\<pi> = \\<xi>)", "proof (induct arbitrary: \\<sigma> and \\<sigma> and \\<sigma> and ys and \\<xi>\n       rule: typing_collection_parts_typing_collection_part_typing_iterator_typing_expr_list_typing.inducts)"], ["proof (state)\ngoal (44 subgoals):\n 1. \\<And>\\<Gamma> \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal NullLiteral : \\<sigma> \\<Longrightarrow>\n       OclVoid[?] = \\<sigma>\n 2. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (BooleanLiteral c) : \\<sigma> \\<Longrightarrow>\n       Boolean[1] = \\<sigma>\n 3. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (RealLiteral c) : \\<sigma> \\<Longrightarrow>\n       Real[1] = \\<sigma>\n 4. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (IntegerLiteral c) : \\<sigma> \\<Longrightarrow>\n       Integer[1] = \\<sigma>\n 5. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (UnlimitedNaturalLiteral c) : \\<sigma> \\<Longrightarrow>\n       UnlimitedNatural[1] = \\<sigma>\n 6. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (StringLiteral c) : \\<sigma> \\<Longrightarrow>\n       String[1] = \\<sigma>\n 7. \\<And>enum lit \\<Gamma> \\<sigma>.\n       \\<lbrakk>has_literal enum lit;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (EnumLiteral enum lit) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (Enum enum)[1] = \\<sigma>\n 8. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Set \\<tau> = \\<sigma>\n 9. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral OrderedSetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> OrderedSet \\<tau> = \\<sigma>\n 10. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          Literal (CollectionLiteral BagKind prts) : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> Bag \\<tau> = \\<sigma>\nA total of 44 subgoals...", "case (NullLiteralT \\<Gamma>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>E Literal NullLiteral : \\<sigma>\n\ngoal (44 subgoals):\n 1. \\<And>\\<Gamma> \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal NullLiteral : \\<sigma> \\<Longrightarrow>\n       OclVoid[?] = \\<sigma>\n 2. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (BooleanLiteral c) : \\<sigma> \\<Longrightarrow>\n       Boolean[1] = \\<sigma>\n 3. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (RealLiteral c) : \\<sigma> \\<Longrightarrow>\n       Real[1] = \\<sigma>\n 4. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (IntegerLiteral c) : \\<sigma> \\<Longrightarrow>\n       Integer[1] = \\<sigma>\n 5. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (UnlimitedNaturalLiteral c) : \\<sigma> \\<Longrightarrow>\n       UnlimitedNatural[1] = \\<sigma>\n 6. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (StringLiteral c) : \\<sigma> \\<Longrightarrow>\n       String[1] = \\<sigma>\n 7. \\<And>enum lit \\<Gamma> \\<sigma>.\n       \\<lbrakk>has_literal enum lit;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (EnumLiteral enum lit) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (Enum enum)[1] = \\<sigma>\n 8. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Set \\<tau> = \\<sigma>\n 9. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral OrderedSetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> OrderedSet \\<tau> = \\<sigma>\n 10. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          Literal (CollectionLiteral BagKind prts) : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> Bag \\<tau> = \\<sigma>\nA total of 44 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>E Literal NullLiteral : \\<sigma>\n\ngoal (1 subgoal):\n 1. OclVoid[?] = \\<sigma>", "by auto"], ["proof (state)\nthis:\n  OclVoid[?] = \\<sigma>\n\ngoal (43 subgoals):\n 1. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (BooleanLiteral c) : \\<sigma> \\<Longrightarrow>\n       Boolean[1] = \\<sigma>\n 2. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (RealLiteral c) : \\<sigma> \\<Longrightarrow>\n       Real[1] = \\<sigma>\n 3. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (IntegerLiteral c) : \\<sigma> \\<Longrightarrow>\n       Integer[1] = \\<sigma>\n 4. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (UnlimitedNaturalLiteral c) : \\<sigma> \\<Longrightarrow>\n       UnlimitedNatural[1] = \\<sigma>\n 5. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (StringLiteral c) : \\<sigma> \\<Longrightarrow>\n       String[1] = \\<sigma>\n 6. \\<And>enum lit \\<Gamma> \\<sigma>.\n       \\<lbrakk>has_literal enum lit;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (EnumLiteral enum lit) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (Enum enum)[1] = \\<sigma>\n 7. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Set \\<tau> = \\<sigma>\n 8. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral OrderedSetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> OrderedSet \\<tau> = \\<sigma>\n 9. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral BagKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Bag \\<tau> = \\<sigma>\n 10. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> Sequence \\<tau> = \\<sigma>\nA total of 43 subgoals...", "next"], ["proof (state)\ngoal (43 subgoals):\n 1. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (BooleanLiteral c) : \\<sigma> \\<Longrightarrow>\n       Boolean[1] = \\<sigma>\n 2. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (RealLiteral c) : \\<sigma> \\<Longrightarrow>\n       Real[1] = \\<sigma>\n 3. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (IntegerLiteral c) : \\<sigma> \\<Longrightarrow>\n       Integer[1] = \\<sigma>\n 4. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (UnlimitedNaturalLiteral c) : \\<sigma> \\<Longrightarrow>\n       UnlimitedNatural[1] = \\<sigma>\n 5. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (StringLiteral c) : \\<sigma> \\<Longrightarrow>\n       String[1] = \\<sigma>\n 6. \\<And>enum lit \\<Gamma> \\<sigma>.\n       \\<lbrakk>has_literal enum lit;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (EnumLiteral enum lit) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (Enum enum)[1] = \\<sigma>\n 7. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Set \\<tau> = \\<sigma>\n 8. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral OrderedSetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> OrderedSet \\<tau> = \\<sigma>\n 9. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral BagKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Bag \\<tau> = \\<sigma>\n 10. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> Sequence \\<tau> = \\<sigma>\nA total of 43 subgoals...", "case (BooleanLiteralT \\<Gamma> c)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>E Literal (BooleanLiteral c) : \\<sigma>\n\ngoal (43 subgoals):\n 1. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (BooleanLiteral c) : \\<sigma> \\<Longrightarrow>\n       Boolean[1] = \\<sigma>\n 2. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (RealLiteral c) : \\<sigma> \\<Longrightarrow>\n       Real[1] = \\<sigma>\n 3. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (IntegerLiteral c) : \\<sigma> \\<Longrightarrow>\n       Integer[1] = \\<sigma>\n 4. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (UnlimitedNaturalLiteral c) : \\<sigma> \\<Longrightarrow>\n       UnlimitedNatural[1] = \\<sigma>\n 5. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (StringLiteral c) : \\<sigma> \\<Longrightarrow>\n       String[1] = \\<sigma>\n 6. \\<And>enum lit \\<Gamma> \\<sigma>.\n       \\<lbrakk>has_literal enum lit;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (EnumLiteral enum lit) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (Enum enum)[1] = \\<sigma>\n 7. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Set \\<tau> = \\<sigma>\n 8. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral OrderedSetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> OrderedSet \\<tau> = \\<sigma>\n 9. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral BagKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Bag \\<tau> = \\<sigma>\n 10. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> Sequence \\<tau> = \\<sigma>\nA total of 43 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>E Literal (BooleanLiteral c) : \\<sigma>\n\ngoal (1 subgoal):\n 1. Boolean[1] = \\<sigma>", "by auto"], ["proof (state)\nthis:\n  Boolean[1] = \\<sigma>\n\ngoal (42 subgoals):\n 1. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (RealLiteral c) : \\<sigma> \\<Longrightarrow>\n       Real[1] = \\<sigma>\n 2. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (IntegerLiteral c) : \\<sigma> \\<Longrightarrow>\n       Integer[1] = \\<sigma>\n 3. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (UnlimitedNaturalLiteral c) : \\<sigma> \\<Longrightarrow>\n       UnlimitedNatural[1] = \\<sigma>\n 4. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (StringLiteral c) : \\<sigma> \\<Longrightarrow>\n       String[1] = \\<sigma>\n 5. \\<And>enum lit \\<Gamma> \\<sigma>.\n       \\<lbrakk>has_literal enum lit;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (EnumLiteral enum lit) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (Enum enum)[1] = \\<sigma>\n 6. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Set \\<tau> = \\<sigma>\n 7. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral OrderedSetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> OrderedSet \\<tau> = \\<sigma>\n 8. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral BagKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Bag \\<tau> = \\<sigma>\n 9. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Sequence \\<tau> = \\<sigma>\n 10. \\<And>\\<Gamma> x \\<tau> \\<sigma>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> \\<tau> = \\<sigma>\nA total of 42 subgoals...", "next"], ["proof (state)\ngoal (42 subgoals):\n 1. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (RealLiteral c) : \\<sigma> \\<Longrightarrow>\n       Real[1] = \\<sigma>\n 2. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (IntegerLiteral c) : \\<sigma> \\<Longrightarrow>\n       Integer[1] = \\<sigma>\n 3. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (UnlimitedNaturalLiteral c) : \\<sigma> \\<Longrightarrow>\n       UnlimitedNatural[1] = \\<sigma>\n 4. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (StringLiteral c) : \\<sigma> \\<Longrightarrow>\n       String[1] = \\<sigma>\n 5. \\<And>enum lit \\<Gamma> \\<sigma>.\n       \\<lbrakk>has_literal enum lit;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (EnumLiteral enum lit) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (Enum enum)[1] = \\<sigma>\n 6. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Set \\<tau> = \\<sigma>\n 7. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral OrderedSetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> OrderedSet \\<tau> = \\<sigma>\n 8. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral BagKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Bag \\<tau> = \\<sigma>\n 9. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Sequence \\<tau> = \\<sigma>\n 10. \\<And>\\<Gamma> x \\<tau> \\<sigma>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> \\<tau> = \\<sigma>\nA total of 42 subgoals...", "case (RealLiteralT \\<Gamma> c)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>E Literal (RealLiteral c) : \\<sigma>\n\ngoal (42 subgoals):\n 1. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (RealLiteral c) : \\<sigma> \\<Longrightarrow>\n       Real[1] = \\<sigma>\n 2. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (IntegerLiteral c) : \\<sigma> \\<Longrightarrow>\n       Integer[1] = \\<sigma>\n 3. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (UnlimitedNaturalLiteral c) : \\<sigma> \\<Longrightarrow>\n       UnlimitedNatural[1] = \\<sigma>\n 4. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (StringLiteral c) : \\<sigma> \\<Longrightarrow>\n       String[1] = \\<sigma>\n 5. \\<And>enum lit \\<Gamma> \\<sigma>.\n       \\<lbrakk>has_literal enum lit;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (EnumLiteral enum lit) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (Enum enum)[1] = \\<sigma>\n 6. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Set \\<tau> = \\<sigma>\n 7. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral OrderedSetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> OrderedSet \\<tau> = \\<sigma>\n 8. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral BagKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Bag \\<tau> = \\<sigma>\n 9. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Sequence \\<tau> = \\<sigma>\n 10. \\<And>\\<Gamma> x \\<tau> \\<sigma>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> \\<tau> = \\<sigma>\nA total of 42 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>E Literal (RealLiteral c) : \\<sigma>\n\ngoal (1 subgoal):\n 1. Real[1] = \\<sigma>", "by auto"], ["proof (state)\nthis:\n  Real[1] = \\<sigma>\n\ngoal (41 subgoals):\n 1. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (IntegerLiteral c) : \\<sigma> \\<Longrightarrow>\n       Integer[1] = \\<sigma>\n 2. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (UnlimitedNaturalLiteral c) : \\<sigma> \\<Longrightarrow>\n       UnlimitedNatural[1] = \\<sigma>\n 3. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (StringLiteral c) : \\<sigma> \\<Longrightarrow>\n       String[1] = \\<sigma>\n 4. \\<And>enum lit \\<Gamma> \\<sigma>.\n       \\<lbrakk>has_literal enum lit;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (EnumLiteral enum lit) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (Enum enum)[1] = \\<sigma>\n 5. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Set \\<tau> = \\<sigma>\n 6. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral OrderedSetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> OrderedSet \\<tau> = \\<sigma>\n 7. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral BagKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Bag \\<tau> = \\<sigma>\n 8. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Sequence \\<tau> = \\<sigma>\n 9. \\<And>\\<Gamma> x \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 10. \\<And>\\<Gamma> x \\<tau> y xs \\<sigma> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>;\n         \\<And>\\<sigma>'.\n            \\<Gamma> \\<turnstile>\\<^sub>C\n             y # xs : \\<sigma>' \\<Longrightarrow>\n            \\<sigma> = \\<sigma>';\n         \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> = \\<sigma>'\nA total of 41 subgoals...", "next"], ["proof (state)\ngoal (41 subgoals):\n 1. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (IntegerLiteral c) : \\<sigma> \\<Longrightarrow>\n       Integer[1] = \\<sigma>\n 2. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (UnlimitedNaturalLiteral c) : \\<sigma> \\<Longrightarrow>\n       UnlimitedNatural[1] = \\<sigma>\n 3. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (StringLiteral c) : \\<sigma> \\<Longrightarrow>\n       String[1] = \\<sigma>\n 4. \\<And>enum lit \\<Gamma> \\<sigma>.\n       \\<lbrakk>has_literal enum lit;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (EnumLiteral enum lit) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (Enum enum)[1] = \\<sigma>\n 5. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Set \\<tau> = \\<sigma>\n 6. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral OrderedSetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> OrderedSet \\<tau> = \\<sigma>\n 7. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral BagKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Bag \\<tau> = \\<sigma>\n 8. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Sequence \\<tau> = \\<sigma>\n 9. \\<And>\\<Gamma> x \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 10. \\<And>\\<Gamma> x \\<tau> y xs \\<sigma> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>;\n         \\<And>\\<sigma>'.\n            \\<Gamma> \\<turnstile>\\<^sub>C\n             y # xs : \\<sigma>' \\<Longrightarrow>\n            \\<sigma> = \\<sigma>';\n         \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> = \\<sigma>'\nA total of 41 subgoals...", "case (IntegerLiteralT \\<Gamma> c)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>E Literal (IntegerLiteral c) : \\<sigma>\n\ngoal (41 subgoals):\n 1. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (IntegerLiteral c) : \\<sigma> \\<Longrightarrow>\n       Integer[1] = \\<sigma>\n 2. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (UnlimitedNaturalLiteral c) : \\<sigma> \\<Longrightarrow>\n       UnlimitedNatural[1] = \\<sigma>\n 3. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (StringLiteral c) : \\<sigma> \\<Longrightarrow>\n       String[1] = \\<sigma>\n 4. \\<And>enum lit \\<Gamma> \\<sigma>.\n       \\<lbrakk>has_literal enum lit;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (EnumLiteral enum lit) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (Enum enum)[1] = \\<sigma>\n 5. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Set \\<tau> = \\<sigma>\n 6. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral OrderedSetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> OrderedSet \\<tau> = \\<sigma>\n 7. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral BagKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Bag \\<tau> = \\<sigma>\n 8. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Sequence \\<tau> = \\<sigma>\n 9. \\<And>\\<Gamma> x \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 10. \\<And>\\<Gamma> x \\<tau> y xs \\<sigma> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>;\n         \\<And>\\<sigma>'.\n            \\<Gamma> \\<turnstile>\\<^sub>C\n             y # xs : \\<sigma>' \\<Longrightarrow>\n            \\<sigma> = \\<sigma>';\n         \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> = \\<sigma>'\nA total of 41 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>E Literal (IntegerLiteral c) : \\<sigma>\n\ngoal (1 subgoal):\n 1. Integer[1] = \\<sigma>", "by auto"], ["proof (state)\nthis:\n  Integer[1] = \\<sigma>\n\ngoal (40 subgoals):\n 1. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (UnlimitedNaturalLiteral c) : \\<sigma> \\<Longrightarrow>\n       UnlimitedNatural[1] = \\<sigma>\n 2. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (StringLiteral c) : \\<sigma> \\<Longrightarrow>\n       String[1] = \\<sigma>\n 3. \\<And>enum lit \\<Gamma> \\<sigma>.\n       \\<lbrakk>has_literal enum lit;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (EnumLiteral enum lit) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (Enum enum)[1] = \\<sigma>\n 4. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Set \\<tau> = \\<sigma>\n 5. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral OrderedSetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> OrderedSet \\<tau> = \\<sigma>\n 6. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral BagKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Bag \\<tau> = \\<sigma>\n 7. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Sequence \\<tau> = \\<sigma>\n 8. \\<And>\\<Gamma> x \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 9. \\<And>\\<Gamma> x \\<tau> y xs \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>C\n            y # xs : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> = \\<sigma>'\n 10. \\<And>\\<Gamma> a \\<tau> \\<sigma>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> \\<tau> = \\<sigma>\nA total of 40 subgoals...", "next"], ["proof (state)\ngoal (40 subgoals):\n 1. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (UnlimitedNaturalLiteral c) : \\<sigma> \\<Longrightarrow>\n       UnlimitedNatural[1] = \\<sigma>\n 2. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (StringLiteral c) : \\<sigma> \\<Longrightarrow>\n       String[1] = \\<sigma>\n 3. \\<And>enum lit \\<Gamma> \\<sigma>.\n       \\<lbrakk>has_literal enum lit;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (EnumLiteral enum lit) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (Enum enum)[1] = \\<sigma>\n 4. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Set \\<tau> = \\<sigma>\n 5. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral OrderedSetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> OrderedSet \\<tau> = \\<sigma>\n 6. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral BagKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Bag \\<tau> = \\<sigma>\n 7. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Sequence \\<tau> = \\<sigma>\n 8. \\<And>\\<Gamma> x \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 9. \\<And>\\<Gamma> x \\<tau> y xs \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>C\n            y # xs : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> = \\<sigma>'\n 10. \\<And>\\<Gamma> a \\<tau> \\<sigma>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> \\<tau> = \\<sigma>\nA total of 40 subgoals...", "case (UnlimitedNaturalLiteralT \\<Gamma> c)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   Literal (UnlimitedNaturalLiteral c) : \\<sigma>\n\ngoal (40 subgoals):\n 1. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (UnlimitedNaturalLiteral c) : \\<sigma> \\<Longrightarrow>\n       UnlimitedNatural[1] = \\<sigma>\n 2. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (StringLiteral c) : \\<sigma> \\<Longrightarrow>\n       String[1] = \\<sigma>\n 3. \\<And>enum lit \\<Gamma> \\<sigma>.\n       \\<lbrakk>has_literal enum lit;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (EnumLiteral enum lit) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (Enum enum)[1] = \\<sigma>\n 4. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Set \\<tau> = \\<sigma>\n 5. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral OrderedSetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> OrderedSet \\<tau> = \\<sigma>\n 6. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral BagKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Bag \\<tau> = \\<sigma>\n 7. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Sequence \\<tau> = \\<sigma>\n 8. \\<And>\\<Gamma> x \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 9. \\<And>\\<Gamma> x \\<tau> y xs \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>C\n            y # xs : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> = \\<sigma>'\n 10. \\<And>\\<Gamma> a \\<tau> \\<sigma>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> \\<tau> = \\<sigma>\nA total of 40 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   Literal (UnlimitedNaturalLiteral c) : \\<sigma>\n\ngoal (1 subgoal):\n 1. UnlimitedNatural[1] = \\<sigma>", "by auto"], ["proof (state)\nthis:\n  UnlimitedNatural[1] = \\<sigma>\n\ngoal (39 subgoals):\n 1. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (StringLiteral c) : \\<sigma> \\<Longrightarrow>\n       String[1] = \\<sigma>\n 2. \\<And>enum lit \\<Gamma> \\<sigma>.\n       \\<lbrakk>has_literal enum lit;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (EnumLiteral enum lit) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (Enum enum)[1] = \\<sigma>\n 3. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Set \\<tau> = \\<sigma>\n 4. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral OrderedSetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> OrderedSet \\<tau> = \\<sigma>\n 5. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral BagKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Bag \\<tau> = \\<sigma>\n 6. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Sequence \\<tau> = \\<sigma>\n 7. \\<And>\\<Gamma> x \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 8. \\<And>\\<Gamma> x \\<tau> y xs \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>C\n            y # xs : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> = \\<sigma>'\n 9. \\<And>\\<Gamma> a \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 10. \\<And>\\<Gamma> a \\<tau> b \\<sigma> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n         \\<And>\\<sigma>'.\n            \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n            \\<sigma> = \\<sigma>';\n         \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n         \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n         \\<Gamma> \\<turnstile>\\<^sub>P\n          CollectionRange a b : \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> Integer[1] = \\<sigma>'\nA total of 39 subgoals...", "next"], ["proof (state)\ngoal (39 subgoals):\n 1. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (StringLiteral c) : \\<sigma> \\<Longrightarrow>\n       String[1] = \\<sigma>\n 2. \\<And>enum lit \\<Gamma> \\<sigma>.\n       \\<lbrakk>has_literal enum lit;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (EnumLiteral enum lit) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (Enum enum)[1] = \\<sigma>\n 3. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Set \\<tau> = \\<sigma>\n 4. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral OrderedSetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> OrderedSet \\<tau> = \\<sigma>\n 5. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral BagKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Bag \\<tau> = \\<sigma>\n 6. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Sequence \\<tau> = \\<sigma>\n 7. \\<And>\\<Gamma> x \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 8. \\<And>\\<Gamma> x \\<tau> y xs \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>C\n            y # xs : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> = \\<sigma>'\n 9. \\<And>\\<Gamma> a \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 10. \\<And>\\<Gamma> a \\<tau> b \\<sigma> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n         \\<And>\\<sigma>'.\n            \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n            \\<sigma> = \\<sigma>';\n         \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n         \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n         \\<Gamma> \\<turnstile>\\<^sub>P\n          CollectionRange a b : \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> Integer[1] = \\<sigma>'\nA total of 39 subgoals...", "case (StringLiteralT \\<Gamma> c)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>E Literal (StringLiteral c) : \\<sigma>\n\ngoal (39 subgoals):\n 1. \\<And>\\<Gamma> c \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (StringLiteral c) : \\<sigma> \\<Longrightarrow>\n       String[1] = \\<sigma>\n 2. \\<And>enum lit \\<Gamma> \\<sigma>.\n       \\<lbrakk>has_literal enum lit;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (EnumLiteral enum lit) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (Enum enum)[1] = \\<sigma>\n 3. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Set \\<tau> = \\<sigma>\n 4. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral OrderedSetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> OrderedSet \\<tau> = \\<sigma>\n 5. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral BagKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Bag \\<tau> = \\<sigma>\n 6. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Sequence \\<tau> = \\<sigma>\n 7. \\<And>\\<Gamma> x \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 8. \\<And>\\<Gamma> x \\<tau> y xs \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>C\n            y # xs : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> = \\<sigma>'\n 9. \\<And>\\<Gamma> a \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 10. \\<And>\\<Gamma> a \\<tau> b \\<sigma> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n         \\<And>\\<sigma>'.\n            \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n            \\<sigma> = \\<sigma>';\n         \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n         \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n         \\<Gamma> \\<turnstile>\\<^sub>P\n          CollectionRange a b : \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> Integer[1] = \\<sigma>'\nA total of 39 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>E Literal (StringLiteral c) : \\<sigma>\n\ngoal (1 subgoal):\n 1. String[1] = \\<sigma>", "by auto"], ["proof (state)\nthis:\n  String[1] = \\<sigma>\n\ngoal (38 subgoals):\n 1. \\<And>enum lit \\<Gamma> \\<sigma>.\n       \\<lbrakk>has_literal enum lit;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (EnumLiteral enum lit) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (Enum enum)[1] = \\<sigma>\n 2. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Set \\<tau> = \\<sigma>\n 3. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral OrderedSetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> OrderedSet \\<tau> = \\<sigma>\n 4. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral BagKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Bag \\<tau> = \\<sigma>\n 5. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Sequence \\<tau> = \\<sigma>\n 6. \\<And>\\<Gamma> x \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 7. \\<And>\\<Gamma> x \\<tau> y xs \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>C\n            y # xs : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> = \\<sigma>'\n 8. \\<And>\\<Gamma> a \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 9. \\<And>\\<Gamma> a \\<tau> b \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<Gamma> \\<turnstile>\\<^sub>P\n         CollectionRange a b : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Integer[1] = \\<sigma>'\n 10. \\<And>\\<Gamma> \\<sigma>.\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral []) : \\<sigma> \\<Longrightarrow>\n        Tuple fmempty = \\<sigma>\nA total of 38 subgoals...", "next"], ["proof (state)\ngoal (38 subgoals):\n 1. \\<And>enum lit \\<Gamma> \\<sigma>.\n       \\<lbrakk>has_literal enum lit;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (EnumLiteral enum lit) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (Enum enum)[1] = \\<sigma>\n 2. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Set \\<tau> = \\<sigma>\n 3. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral OrderedSetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> OrderedSet \\<tau> = \\<sigma>\n 4. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral BagKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Bag \\<tau> = \\<sigma>\n 5. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Sequence \\<tau> = \\<sigma>\n 6. \\<And>\\<Gamma> x \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 7. \\<And>\\<Gamma> x \\<tau> y xs \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>C\n            y # xs : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> = \\<sigma>'\n 8. \\<And>\\<Gamma> a \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 9. \\<And>\\<Gamma> a \\<tau> b \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<Gamma> \\<turnstile>\\<^sub>P\n         CollectionRange a b : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Integer[1] = \\<sigma>'\n 10. \\<And>\\<Gamma> \\<sigma>.\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral []) : \\<sigma> \\<Longrightarrow>\n        Tuple fmempty = \\<sigma>\nA total of 38 subgoals...", "case (EnumLiteralT \\<Gamma> \\<tau> lit)"], ["proof (state)\nthis:\n  has_literal \\<Gamma> \\<tau>\n  lit \\<turnstile>\\<^sub>E Literal (EnumLiteral \\<Gamma> \\<tau>) : \\<sigma>\n\ngoal (38 subgoals):\n 1. \\<And>enum lit \\<Gamma> \\<sigma>.\n       \\<lbrakk>has_literal enum lit;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (EnumLiteral enum lit) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> (Enum enum)[1] = \\<sigma>\n 2. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Set \\<tau> = \\<sigma>\n 3. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral OrderedSetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> OrderedSet \\<tau> = \\<sigma>\n 4. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral BagKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Bag \\<tau> = \\<sigma>\n 5. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Sequence \\<tau> = \\<sigma>\n 6. \\<And>\\<Gamma> x \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 7. \\<And>\\<Gamma> x \\<tau> y xs \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>C\n            y # xs : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> = \\<sigma>'\n 8. \\<And>\\<Gamma> a \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 9. \\<And>\\<Gamma> a \\<tau> b \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<Gamma> \\<turnstile>\\<^sub>P\n         CollectionRange a b : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Integer[1] = \\<sigma>'\n 10. \\<And>\\<Gamma> \\<sigma>.\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral []) : \\<sigma> \\<Longrightarrow>\n        Tuple fmempty = \\<sigma>\nA total of 38 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  has_literal \\<Gamma> \\<tau>\n  lit \\<turnstile>\\<^sub>E Literal (EnumLiteral \\<Gamma> \\<tau>) : \\<sigma>\n\ngoal (1 subgoal):\n 1. (Enum \\<Gamma>)[1] = \\<sigma>", "by auto"], ["proof (state)\nthis:\n  (Enum \\<Gamma>)[1] = \\<sigma>\n\ngoal (37 subgoals):\n 1. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Set \\<tau> = \\<sigma>\n 2. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral OrderedSetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> OrderedSet \\<tau> = \\<sigma>\n 3. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral BagKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Bag \\<tau> = \\<sigma>\n 4. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Sequence \\<tau> = \\<sigma>\n 5. \\<And>\\<Gamma> x \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 6. \\<And>\\<Gamma> x \\<tau> y xs \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>C\n            y # xs : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> = \\<sigma>'\n 7. \\<And>\\<Gamma> a \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 8. \\<And>\\<Gamma> a \\<tau> b \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<Gamma> \\<turnstile>\\<^sub>P\n         CollectionRange a b : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Integer[1] = \\<sigma>'\n 9. \\<And>\\<Gamma> \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (TupleLiteral []) : \\<sigma> \\<Longrightarrow>\n       Tuple fmempty = \\<sigma>\n 10. \\<And>\\<Gamma> elems \\<xi> el \\<tau> \\<sigma> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                  Literal (TupleLiteral elems) : Tuple \\<xi>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E\n             Literal (TupleLiteral elems) : \\<sigma> \\<Longrightarrow>\n            Tuple \\<xi> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E\n             tuple_element_expr el : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         tuple_element_type el = Some \\<sigma>; \\<tau> \\<le> \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          Literal (TupleLiteral (el # elems)) : \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> Tuple\n                           (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                            \\<sigma>)) =\n                          \\<sigma>'\nA total of 37 subgoals...", "next"], ["proof (state)\ngoal (37 subgoals):\n 1. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Set \\<tau> = \\<sigma>\n 2. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral OrderedSetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> OrderedSet \\<tau> = \\<sigma>\n 3. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral BagKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Bag \\<tau> = \\<sigma>\n 4. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Sequence \\<tau> = \\<sigma>\n 5. \\<And>\\<Gamma> x \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 6. \\<And>\\<Gamma> x \\<tau> y xs \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>C\n            y # xs : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> = \\<sigma>'\n 7. \\<And>\\<Gamma> a \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 8. \\<And>\\<Gamma> a \\<tau> b \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<Gamma> \\<turnstile>\\<^sub>P\n         CollectionRange a b : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Integer[1] = \\<sigma>'\n 9. \\<And>\\<Gamma> \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (TupleLiteral []) : \\<sigma> \\<Longrightarrow>\n       Tuple fmempty = \\<sigma>\n 10. \\<And>\\<Gamma> elems \\<xi> el \\<tau> \\<sigma> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                  Literal (TupleLiteral elems) : Tuple \\<xi>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E\n             Literal (TupleLiteral elems) : \\<sigma> \\<Longrightarrow>\n            Tuple \\<xi> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E\n             tuple_element_expr el : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         tuple_element_type el = Some \\<sigma>; \\<tau> \\<le> \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          Literal (TupleLiteral (el # elems)) : \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> Tuple\n                           (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                            \\<sigma>)) =\n                          \\<sigma>'\nA total of 37 subgoals...", "case (SetLiteralT \\<Gamma> prts \\<tau>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>\n  \\<Gamma> \\<turnstile>\\<^sub>C prts : ?\\<sigma> \\<Longrightarrow>\n  \\<tau> = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   Literal (CollectionLiteral SetKind prts) : \\<sigma>\n\ngoal (37 subgoals):\n 1. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Set \\<tau> = \\<sigma>\n 2. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral OrderedSetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> OrderedSet \\<tau> = \\<sigma>\n 3. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral BagKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Bag \\<tau> = \\<sigma>\n 4. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Sequence \\<tau> = \\<sigma>\n 5. \\<And>\\<Gamma> x \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 6. \\<And>\\<Gamma> x \\<tau> y xs \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>C\n            y # xs : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> = \\<sigma>'\n 7. \\<And>\\<Gamma> a \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 8. \\<And>\\<Gamma> a \\<tau> b \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<Gamma> \\<turnstile>\\<^sub>P\n         CollectionRange a b : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Integer[1] = \\<sigma>'\n 9. \\<And>\\<Gamma> \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (TupleLiteral []) : \\<sigma> \\<Longrightarrow>\n       Tuple fmempty = \\<sigma>\n 10. \\<And>\\<Gamma> elems \\<xi> el \\<tau> \\<sigma> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                  Literal (TupleLiteral elems) : Tuple \\<xi>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E\n             Literal (TupleLiteral elems) : \\<sigma> \\<Longrightarrow>\n            Tuple \\<xi> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E\n             tuple_element_expr el : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         tuple_element_type el = Some \\<sigma>; \\<tau> \\<le> \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          Literal (TupleLiteral (el # elems)) : \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> Tuple\n                           (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                            \\<sigma>)) =\n                          \\<sigma>'\nA total of 37 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>\n  \\<Gamma> \\<turnstile>\\<^sub>C prts : ?\\<sigma> \\<Longrightarrow>\n  \\<tau> = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   Literal (CollectionLiteral SetKind prts) : \\<sigma>\n\ngoal (1 subgoal):\n 1. Set \\<tau> = \\<sigma>", "by blast"], ["proof (state)\nthis:\n  Set \\<tau> = \\<sigma>\n\ngoal (36 subgoals):\n 1. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral OrderedSetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> OrderedSet \\<tau> = \\<sigma>\n 2. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral BagKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Bag \\<tau> = \\<sigma>\n 3. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Sequence \\<tau> = \\<sigma>\n 4. \\<And>\\<Gamma> x \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 5. \\<And>\\<Gamma> x \\<tau> y xs \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>C\n            y # xs : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> = \\<sigma>'\n 6. \\<And>\\<Gamma> a \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 7. \\<And>\\<Gamma> a \\<tau> b \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<Gamma> \\<turnstile>\\<^sub>P\n         CollectionRange a b : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Integer[1] = \\<sigma>'\n 8. \\<And>\\<Gamma> \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (TupleLiteral []) : \\<sigma> \\<Longrightarrow>\n       Tuple fmempty = \\<sigma>\n 9. \\<And>\\<Gamma> elems \\<xi> el \\<tau> \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 Literal (TupleLiteral elems) : Tuple \\<xi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            Literal (TupleLiteral elems) : \\<sigma> \\<Longrightarrow>\n           Tuple \\<xi> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            tuple_element_expr el : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        tuple_element_type el = Some \\<sigma>; \\<tau> \\<le> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral (el # elems)) : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Tuple\n                          (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                           \\<sigma>)) =\n                         \\<sigma>'\n 10. \\<And>\\<Gamma> init \\<sigma> \\<tau> v body \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>;\n         \\<And>\\<sigma>'.\n            \\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>' \\<Longrightarrow>\n            \\<sigma> = \\<sigma>';\n         \\<sigma> \\<le> \\<tau>;\n         \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n          body : \\<rho>;\n         \\<And>\\<sigma>.\n            \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n             body : \\<sigma> \\<Longrightarrow>\n            \\<rho> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          expr.Let v (Some \\<tau>) init body : \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<rho> = \\<sigma>'\nA total of 36 subgoals...", "next"], ["proof (state)\ngoal (36 subgoals):\n 1. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral OrderedSetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> OrderedSet \\<tau> = \\<sigma>\n 2. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral BagKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Bag \\<tau> = \\<sigma>\n 3. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Sequence \\<tau> = \\<sigma>\n 4. \\<And>\\<Gamma> x \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 5. \\<And>\\<Gamma> x \\<tau> y xs \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>C\n            y # xs : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> = \\<sigma>'\n 6. \\<And>\\<Gamma> a \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 7. \\<And>\\<Gamma> a \\<tau> b \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<Gamma> \\<turnstile>\\<^sub>P\n         CollectionRange a b : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Integer[1] = \\<sigma>'\n 8. \\<And>\\<Gamma> \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (TupleLiteral []) : \\<sigma> \\<Longrightarrow>\n       Tuple fmempty = \\<sigma>\n 9. \\<And>\\<Gamma> elems \\<xi> el \\<tau> \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 Literal (TupleLiteral elems) : Tuple \\<xi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            Literal (TupleLiteral elems) : \\<sigma> \\<Longrightarrow>\n           Tuple \\<xi> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            tuple_element_expr el : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        tuple_element_type el = Some \\<sigma>; \\<tau> \\<le> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral (el # elems)) : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Tuple\n                          (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                           \\<sigma>)) =\n                         \\<sigma>'\n 10. \\<And>\\<Gamma> init \\<sigma> \\<tau> v body \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>;\n         \\<And>\\<sigma>'.\n            \\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>' \\<Longrightarrow>\n            \\<sigma> = \\<sigma>';\n         \\<sigma> \\<le> \\<tau>;\n         \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n          body : \\<rho>;\n         \\<And>\\<sigma>.\n            \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n             body : \\<sigma> \\<Longrightarrow>\n            \\<rho> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          expr.Let v (Some \\<tau>) init body : \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<rho> = \\<sigma>'\nA total of 36 subgoals...", "case (OrderedSetLiteralT \\<Gamma> prts \\<tau>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>\n  \\<Gamma> \\<turnstile>\\<^sub>C prts : ?\\<sigma> \\<Longrightarrow>\n  \\<tau> = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   Literal (CollectionLiteral OrderedSetKind prts) : \\<sigma>\n\ngoal (36 subgoals):\n 1. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral OrderedSetKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> OrderedSet \\<tau> = \\<sigma>\n 2. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral BagKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Bag \\<tau> = \\<sigma>\n 3. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Sequence \\<tau> = \\<sigma>\n 4. \\<And>\\<Gamma> x \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 5. \\<And>\\<Gamma> x \\<tau> y xs \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>C\n            y # xs : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> = \\<sigma>'\n 6. \\<And>\\<Gamma> a \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 7. \\<And>\\<Gamma> a \\<tau> b \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<Gamma> \\<turnstile>\\<^sub>P\n         CollectionRange a b : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Integer[1] = \\<sigma>'\n 8. \\<And>\\<Gamma> \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (TupleLiteral []) : \\<sigma> \\<Longrightarrow>\n       Tuple fmempty = \\<sigma>\n 9. \\<And>\\<Gamma> elems \\<xi> el \\<tau> \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 Literal (TupleLiteral elems) : Tuple \\<xi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            Literal (TupleLiteral elems) : \\<sigma> \\<Longrightarrow>\n           Tuple \\<xi> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            tuple_element_expr el : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        tuple_element_type el = Some \\<sigma>; \\<tau> \\<le> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral (el # elems)) : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Tuple\n                          (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                           \\<sigma>)) =\n                         \\<sigma>'\n 10. \\<And>\\<Gamma> init \\<sigma> \\<tau> v body \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>;\n         \\<And>\\<sigma>'.\n            \\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>' \\<Longrightarrow>\n            \\<sigma> = \\<sigma>';\n         \\<sigma> \\<le> \\<tau>;\n         \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n          body : \\<rho>;\n         \\<And>\\<sigma>.\n            \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n             body : \\<sigma> \\<Longrightarrow>\n            \\<rho> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          expr.Let v (Some \\<tau>) init body : \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<rho> = \\<sigma>'\nA total of 36 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>\n  \\<Gamma> \\<turnstile>\\<^sub>C prts : ?\\<sigma> \\<Longrightarrow>\n  \\<tau> = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   Literal (CollectionLiteral OrderedSetKind prts) : \\<sigma>\n\ngoal (1 subgoal):\n 1. OrderedSet \\<tau> = \\<sigma>", "by blast"], ["proof (state)\nthis:\n  OrderedSet \\<tau> = \\<sigma>\n\ngoal (35 subgoals):\n 1. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral BagKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Bag \\<tau> = \\<sigma>\n 2. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Sequence \\<tau> = \\<sigma>\n 3. \\<And>\\<Gamma> x \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 4. \\<And>\\<Gamma> x \\<tau> y xs \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>C\n            y # xs : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> = \\<sigma>'\n 5. \\<And>\\<Gamma> a \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 6. \\<And>\\<Gamma> a \\<tau> b \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<Gamma> \\<turnstile>\\<^sub>P\n         CollectionRange a b : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Integer[1] = \\<sigma>'\n 7. \\<And>\\<Gamma> \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (TupleLiteral []) : \\<sigma> \\<Longrightarrow>\n       Tuple fmempty = \\<sigma>\n 8. \\<And>\\<Gamma> elems \\<xi> el \\<tau> \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 Literal (TupleLiteral elems) : Tuple \\<xi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            Literal (TupleLiteral elems) : \\<sigma> \\<Longrightarrow>\n           Tuple \\<xi> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            tuple_element_expr el : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        tuple_element_type el = Some \\<sigma>; \\<tau> \\<le> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral (el # elems)) : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Tuple\n                          (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                           \\<sigma>)) =\n                         \\<sigma>'\n 9. \\<And>\\<Gamma> init \\<sigma> \\<tau> v body \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<sigma> \\<le> \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n         body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n            body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         expr.Let v (Some \\<tau>) init body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 10. \\<And>\\<Gamma> v \\<tau> \\<sigma>.\n        \\<lbrakk>fmlookup \\<Gamma> v = Some \\<tau>;\n         \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> \\<tau> = \\<sigma>\nA total of 35 subgoals...", "next"], ["proof (state)\ngoal (35 subgoals):\n 1. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral BagKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Bag \\<tau> = \\<sigma>\n 2. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Sequence \\<tau> = \\<sigma>\n 3. \\<And>\\<Gamma> x \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 4. \\<And>\\<Gamma> x \\<tau> y xs \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>C\n            y # xs : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> = \\<sigma>'\n 5. \\<And>\\<Gamma> a \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 6. \\<And>\\<Gamma> a \\<tau> b \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<Gamma> \\<turnstile>\\<^sub>P\n         CollectionRange a b : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Integer[1] = \\<sigma>'\n 7. \\<And>\\<Gamma> \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (TupleLiteral []) : \\<sigma> \\<Longrightarrow>\n       Tuple fmempty = \\<sigma>\n 8. \\<And>\\<Gamma> elems \\<xi> el \\<tau> \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 Literal (TupleLiteral elems) : Tuple \\<xi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            Literal (TupleLiteral elems) : \\<sigma> \\<Longrightarrow>\n           Tuple \\<xi> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            tuple_element_expr el : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        tuple_element_type el = Some \\<sigma>; \\<tau> \\<le> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral (el # elems)) : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Tuple\n                          (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                           \\<sigma>)) =\n                         \\<sigma>'\n 9. \\<And>\\<Gamma> init \\<sigma> \\<tau> v body \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<sigma> \\<le> \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n         body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n            body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         expr.Let v (Some \\<tau>) init body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 10. \\<And>\\<Gamma> v \\<tau> \\<sigma>.\n        \\<lbrakk>fmlookup \\<Gamma> v = Some \\<tau>;\n         \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> \\<tau> = \\<sigma>\nA total of 35 subgoals...", "case (BagLiteralT \\<Gamma> prts \\<tau>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>\n  \\<Gamma> \\<turnstile>\\<^sub>C prts : ?\\<sigma> \\<Longrightarrow>\n  \\<tau> = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   Literal (CollectionLiteral BagKind prts) : \\<sigma>\n\ngoal (35 subgoals):\n 1. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral BagKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Bag \\<tau> = \\<sigma>\n 2. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Sequence \\<tau> = \\<sigma>\n 3. \\<And>\\<Gamma> x \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 4. \\<And>\\<Gamma> x \\<tau> y xs \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>C\n            y # xs : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> = \\<sigma>'\n 5. \\<And>\\<Gamma> a \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 6. \\<And>\\<Gamma> a \\<tau> b \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<Gamma> \\<turnstile>\\<^sub>P\n         CollectionRange a b : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Integer[1] = \\<sigma>'\n 7. \\<And>\\<Gamma> \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (TupleLiteral []) : \\<sigma> \\<Longrightarrow>\n       Tuple fmempty = \\<sigma>\n 8. \\<And>\\<Gamma> elems \\<xi> el \\<tau> \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 Literal (TupleLiteral elems) : Tuple \\<xi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            Literal (TupleLiteral elems) : \\<sigma> \\<Longrightarrow>\n           Tuple \\<xi> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            tuple_element_expr el : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        tuple_element_type el = Some \\<sigma>; \\<tau> \\<le> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral (el # elems)) : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Tuple\n                          (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                           \\<sigma>)) =\n                         \\<sigma>'\n 9. \\<And>\\<Gamma> init \\<sigma> \\<tau> v body \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<sigma> \\<le> \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n         body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n            body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         expr.Let v (Some \\<tau>) init body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 10. \\<And>\\<Gamma> v \\<tau> \\<sigma>.\n        \\<lbrakk>fmlookup \\<Gamma> v = Some \\<tau>;\n         \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> \\<tau> = \\<sigma>\nA total of 35 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>\n  \\<Gamma> \\<turnstile>\\<^sub>C prts : ?\\<sigma> \\<Longrightarrow>\n  \\<tau> = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   Literal (CollectionLiteral BagKind prts) : \\<sigma>\n\ngoal (1 subgoal):\n 1. Bag \\<tau> = \\<sigma>", "by blast"], ["proof (state)\nthis:\n  Bag \\<tau> = \\<sigma>\n\ngoal (34 subgoals):\n 1. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Sequence \\<tau> = \\<sigma>\n 2. \\<And>\\<Gamma> x \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 3. \\<And>\\<Gamma> x \\<tau> y xs \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>C\n            y # xs : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> = \\<sigma>'\n 4. \\<And>\\<Gamma> a \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 5. \\<And>\\<Gamma> a \\<tau> b \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<Gamma> \\<turnstile>\\<^sub>P\n         CollectionRange a b : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Integer[1] = \\<sigma>'\n 6. \\<And>\\<Gamma> \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (TupleLiteral []) : \\<sigma> \\<Longrightarrow>\n       Tuple fmempty = \\<sigma>\n 7. \\<And>\\<Gamma> elems \\<xi> el \\<tau> \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 Literal (TupleLiteral elems) : Tuple \\<xi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            Literal (TupleLiteral elems) : \\<sigma> \\<Longrightarrow>\n           Tuple \\<xi> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            tuple_element_expr el : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        tuple_element_type el = Some \\<sigma>; \\<tau> \\<le> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral (el # elems)) : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Tuple\n                          (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                           \\<sigma>)) =\n                         \\<sigma>'\n 8. \\<And>\\<Gamma> init \\<sigma> \\<tau> v body \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<sigma> \\<le> \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n         body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n            body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         expr.Let v (Some \\<tau>) init body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 9. \\<And>\\<Gamma> v \\<tau> \\<sigma>.\n       \\<lbrakk>fmlookup \\<Gamma> v = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 10. \\<And>\\<Gamma> a b \\<sigma> c \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n            Boolean[1] = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n         \\<And>\\<sigma>'.\n            \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n            \\<sigma> = \\<sigma>';\n         \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E c : \\<sigma> \\<Longrightarrow>\n            \\<rho> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>E expr.If a b c : \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<sigma> \\<squnion> \\<rho> = \\<sigma>'\nA total of 34 subgoals...", "next"], ["proof (state)\ngoal (34 subgoals):\n 1. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Sequence \\<tau> = \\<sigma>\n 2. \\<And>\\<Gamma> x \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 3. \\<And>\\<Gamma> x \\<tau> y xs \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>C\n            y # xs : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> = \\<sigma>'\n 4. \\<And>\\<Gamma> a \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 5. \\<And>\\<Gamma> a \\<tau> b \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<Gamma> \\<turnstile>\\<^sub>P\n         CollectionRange a b : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Integer[1] = \\<sigma>'\n 6. \\<And>\\<Gamma> \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (TupleLiteral []) : \\<sigma> \\<Longrightarrow>\n       Tuple fmempty = \\<sigma>\n 7. \\<And>\\<Gamma> elems \\<xi> el \\<tau> \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 Literal (TupleLiteral elems) : Tuple \\<xi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            Literal (TupleLiteral elems) : \\<sigma> \\<Longrightarrow>\n           Tuple \\<xi> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            tuple_element_expr el : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        tuple_element_type el = Some \\<sigma>; \\<tau> \\<le> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral (el # elems)) : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Tuple\n                          (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                           \\<sigma>)) =\n                         \\<sigma>'\n 8. \\<And>\\<Gamma> init \\<sigma> \\<tau> v body \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<sigma> \\<le> \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n         body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n            body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         expr.Let v (Some \\<tau>) init body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 9. \\<And>\\<Gamma> v \\<tau> \\<sigma>.\n       \\<lbrakk>fmlookup \\<Gamma> v = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 10. \\<And>\\<Gamma> a b \\<sigma> c \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n            Boolean[1] = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n         \\<And>\\<sigma>'.\n            \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n            \\<sigma> = \\<sigma>';\n         \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E c : \\<sigma> \\<Longrightarrow>\n            \\<rho> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>E expr.If a b c : \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<sigma> \\<squnion> \\<rho> = \\<sigma>'\nA total of 34 subgoals...", "case (SequenceLiteralT \\<Gamma> prts \\<tau>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>\n  \\<Gamma> \\<turnstile>\\<^sub>C prts : ?\\<sigma> \\<Longrightarrow>\n  \\<tau> = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\n\ngoal (34 subgoals):\n 1. \\<And>\\<Gamma> prts \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Sequence \\<tau> = \\<sigma>\n 2. \\<And>\\<Gamma> x \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 3. \\<And>\\<Gamma> x \\<tau> y xs \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>C\n            y # xs : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> = \\<sigma>'\n 4. \\<And>\\<Gamma> a \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 5. \\<And>\\<Gamma> a \\<tau> b \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<Gamma> \\<turnstile>\\<^sub>P\n         CollectionRange a b : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Integer[1] = \\<sigma>'\n 6. \\<And>\\<Gamma> \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (TupleLiteral []) : \\<sigma> \\<Longrightarrow>\n       Tuple fmempty = \\<sigma>\n 7. \\<And>\\<Gamma> elems \\<xi> el \\<tau> \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 Literal (TupleLiteral elems) : Tuple \\<xi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            Literal (TupleLiteral elems) : \\<sigma> \\<Longrightarrow>\n           Tuple \\<xi> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            tuple_element_expr el : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        tuple_element_type el = Some \\<sigma>; \\<tau> \\<le> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral (el # elems)) : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Tuple\n                          (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                           \\<sigma>)) =\n                         \\<sigma>'\n 8. \\<And>\\<Gamma> init \\<sigma> \\<tau> v body \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<sigma> \\<le> \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n         body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n            body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         expr.Let v (Some \\<tau>) init body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 9. \\<And>\\<Gamma> v \\<tau> \\<sigma>.\n       \\<lbrakk>fmlookup \\<Gamma> v = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 10. \\<And>\\<Gamma> a b \\<sigma> c \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n            Boolean[1] = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n         \\<And>\\<sigma>'.\n            \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n            \\<sigma> = \\<sigma>';\n         \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E c : \\<sigma> \\<Longrightarrow>\n            \\<rho> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>E expr.If a b c : \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<sigma> \\<squnion> \\<rho> = \\<sigma>'\nA total of 34 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>C prts : \\<tau>\n  \\<Gamma> \\<turnstile>\\<^sub>C prts : ?\\<sigma> \\<Longrightarrow>\n  \\<tau> = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   Literal (CollectionLiteral SequenceKind prts) : \\<sigma>\n\ngoal (1 subgoal):\n 1. Sequence \\<tau> = \\<sigma>", "by blast"], ["proof (state)\nthis:\n  Sequence \\<tau> = \\<sigma>\n\ngoal (33 subgoals):\n 1. \\<And>\\<Gamma> x \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 2. \\<And>\\<Gamma> x \\<tau> y xs \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>C\n            y # xs : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> = \\<sigma>'\n 3. \\<And>\\<Gamma> a \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 4. \\<And>\\<Gamma> a \\<tau> b \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<Gamma> \\<turnstile>\\<^sub>P\n         CollectionRange a b : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Integer[1] = \\<sigma>'\n 5. \\<And>\\<Gamma> \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (TupleLiteral []) : \\<sigma> \\<Longrightarrow>\n       Tuple fmempty = \\<sigma>\n 6. \\<And>\\<Gamma> elems \\<xi> el \\<tau> \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 Literal (TupleLiteral elems) : Tuple \\<xi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            Literal (TupleLiteral elems) : \\<sigma> \\<Longrightarrow>\n           Tuple \\<xi> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            tuple_element_expr el : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        tuple_element_type el = Some \\<sigma>; \\<tau> \\<le> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral (el # elems)) : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Tuple\n                          (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                           \\<sigma>)) =\n                         \\<sigma>'\n 7. \\<And>\\<Gamma> init \\<sigma> \\<tau> v body \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<sigma> \\<le> \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n         body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n            body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         expr.Let v (Some \\<tau>) init body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 8. \\<And>\\<Gamma> v \\<tau> \\<sigma>.\n       \\<lbrakk>fmlookup \\<Gamma> v = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 9. \\<And>\\<Gamma> a b \\<sigma> c \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           Boolean[1] = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E c : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E expr.If a b c : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<squnion> \\<rho> = \\<sigma>'\n 10. \\<And>\\<tau> op \\<sigma> \\<Gamma> \\<sigma>'.\n        \\<lbrakk>mataop_type \\<tau> op \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          MetaOperationCall \\<tau> op : \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<sigma> = \\<sigma>'\nA total of 33 subgoals...", "next"], ["proof (state)\ngoal (33 subgoals):\n 1. \\<And>\\<Gamma> x \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 2. \\<And>\\<Gamma> x \\<tau> y xs \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>C\n            y # xs : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> = \\<sigma>'\n 3. \\<And>\\<Gamma> a \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 4. \\<And>\\<Gamma> a \\<tau> b \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<Gamma> \\<turnstile>\\<^sub>P\n         CollectionRange a b : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Integer[1] = \\<sigma>'\n 5. \\<And>\\<Gamma> \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (TupleLiteral []) : \\<sigma> \\<Longrightarrow>\n       Tuple fmempty = \\<sigma>\n 6. \\<And>\\<Gamma> elems \\<xi> el \\<tau> \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 Literal (TupleLiteral elems) : Tuple \\<xi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            Literal (TupleLiteral elems) : \\<sigma> \\<Longrightarrow>\n           Tuple \\<xi> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            tuple_element_expr el : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        tuple_element_type el = Some \\<sigma>; \\<tau> \\<le> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral (el # elems)) : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Tuple\n                          (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                           \\<sigma>)) =\n                         \\<sigma>'\n 7. \\<And>\\<Gamma> init \\<sigma> \\<tau> v body \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<sigma> \\<le> \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n         body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n            body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         expr.Let v (Some \\<tau>) init body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 8. \\<And>\\<Gamma> v \\<tau> \\<sigma>.\n       \\<lbrakk>fmlookup \\<Gamma> v = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 9. \\<And>\\<Gamma> a b \\<sigma> c \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           Boolean[1] = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E c : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E expr.If a b c : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<squnion> \\<rho> = \\<sigma>'\n 10. \\<And>\\<tau> op \\<sigma> \\<Gamma> \\<sigma>'.\n        \\<lbrakk>mataop_type \\<tau> op \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          MetaOperationCall \\<tau> op : \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<sigma> = \\<sigma>'\nA total of 33 subgoals...", "case (CollectionPartsSingletonT \\<Gamma> x \\<tau>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>\n  \\<Gamma> \\<turnstile>\\<^sub>P x : ?\\<sigma> \\<Longrightarrow>\n  \\<tau> = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\n\ngoal (33 subgoals):\n 1. \\<And>\\<Gamma> x \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 2. \\<And>\\<Gamma> x \\<tau> y xs \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>C\n            y # xs : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> = \\<sigma>'\n 3. \\<And>\\<Gamma> a \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 4. \\<And>\\<Gamma> a \\<tau> b \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<Gamma> \\<turnstile>\\<^sub>P\n         CollectionRange a b : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Integer[1] = \\<sigma>'\n 5. \\<And>\\<Gamma> \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (TupleLiteral []) : \\<sigma> \\<Longrightarrow>\n       Tuple fmempty = \\<sigma>\n 6. \\<And>\\<Gamma> elems \\<xi> el \\<tau> \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 Literal (TupleLiteral elems) : Tuple \\<xi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            Literal (TupleLiteral elems) : \\<sigma> \\<Longrightarrow>\n           Tuple \\<xi> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            tuple_element_expr el : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        tuple_element_type el = Some \\<sigma>; \\<tau> \\<le> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral (el # elems)) : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Tuple\n                          (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                           \\<sigma>)) =\n                         \\<sigma>'\n 7. \\<And>\\<Gamma> init \\<sigma> \\<tau> v body \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<sigma> \\<le> \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n         body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n            body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         expr.Let v (Some \\<tau>) init body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 8. \\<And>\\<Gamma> v \\<tau> \\<sigma>.\n       \\<lbrakk>fmlookup \\<Gamma> v = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 9. \\<And>\\<Gamma> a b \\<sigma> c \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           Boolean[1] = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E c : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E expr.If a b c : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<squnion> \\<rho> = \\<sigma>'\n 10. \\<And>\\<tau> op \\<sigma> \\<Gamma> \\<sigma>'.\n        \\<lbrakk>mataop_type \\<tau> op \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          MetaOperationCall \\<tau> op : \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<sigma> = \\<sigma>'\nA total of 33 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>\n  \\<Gamma> \\<turnstile>\\<^sub>P x : ?\\<sigma> \\<Longrightarrow>\n  \\<tau> = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>C [x] : \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<tau> = \\<sigma>", "by blast"], ["proof (state)\nthis:\n  \\<tau> = \\<sigma>\n\ngoal (32 subgoals):\n 1. \\<And>\\<Gamma> x \\<tau> y xs \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>C\n            y # xs : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> = \\<sigma>'\n 2. \\<And>\\<Gamma> a \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 3. \\<And>\\<Gamma> a \\<tau> b \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<Gamma> \\<turnstile>\\<^sub>P\n         CollectionRange a b : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Integer[1] = \\<sigma>'\n 4. \\<And>\\<Gamma> \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (TupleLiteral []) : \\<sigma> \\<Longrightarrow>\n       Tuple fmempty = \\<sigma>\n 5. \\<And>\\<Gamma> elems \\<xi> el \\<tau> \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 Literal (TupleLiteral elems) : Tuple \\<xi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            Literal (TupleLiteral elems) : \\<sigma> \\<Longrightarrow>\n           Tuple \\<xi> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            tuple_element_expr el : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        tuple_element_type el = Some \\<sigma>; \\<tau> \\<le> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral (el # elems)) : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Tuple\n                          (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                           \\<sigma>)) =\n                         \\<sigma>'\n 6. \\<And>\\<Gamma> init \\<sigma> \\<tau> v body \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<sigma> \\<le> \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n         body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n            body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         expr.Let v (Some \\<tau>) init body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 7. \\<And>\\<Gamma> v \\<tau> \\<sigma>.\n       \\<lbrakk>fmlookup \\<Gamma> v = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 8. \\<And>\\<Gamma> a b \\<sigma> c \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           Boolean[1] = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E c : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E expr.If a b c : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<squnion> \\<rho> = \\<sigma>'\n 9. \\<And>\\<tau> op \\<sigma> \\<Gamma> \\<sigma>'.\n       \\<lbrakk>mataop_type \\<tau> op \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         MetaOperationCall \\<tau> op : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 10. \\<And>\\<Gamma> params \\<pi> \\<tau> op oper \\<sigma>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n         \\<And>\\<xi>.\n            \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n            \\<pi> = \\<xi>;\n         static_operation \\<tau> op \\<pi> oper;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          StaticOperationCall \\<tau> op params : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> oper_type oper = \\<sigma>\nA total of 32 subgoals...", "next"], ["proof (state)\ngoal (32 subgoals):\n 1. \\<And>\\<Gamma> x \\<tau> y xs \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>C\n            y # xs : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> = \\<sigma>'\n 2. \\<And>\\<Gamma> a \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 3. \\<And>\\<Gamma> a \\<tau> b \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<Gamma> \\<turnstile>\\<^sub>P\n         CollectionRange a b : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Integer[1] = \\<sigma>'\n 4. \\<And>\\<Gamma> \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (TupleLiteral []) : \\<sigma> \\<Longrightarrow>\n       Tuple fmempty = \\<sigma>\n 5. \\<And>\\<Gamma> elems \\<xi> el \\<tau> \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 Literal (TupleLiteral elems) : Tuple \\<xi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            Literal (TupleLiteral elems) : \\<sigma> \\<Longrightarrow>\n           Tuple \\<xi> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            tuple_element_expr el : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        tuple_element_type el = Some \\<sigma>; \\<tau> \\<le> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral (el # elems)) : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Tuple\n                          (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                           \\<sigma>)) =\n                         \\<sigma>'\n 6. \\<And>\\<Gamma> init \\<sigma> \\<tau> v body \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<sigma> \\<le> \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n         body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n            body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         expr.Let v (Some \\<tau>) init body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 7. \\<And>\\<Gamma> v \\<tau> \\<sigma>.\n       \\<lbrakk>fmlookup \\<Gamma> v = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 8. \\<And>\\<Gamma> a b \\<sigma> c \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           Boolean[1] = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E c : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E expr.If a b c : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<squnion> \\<rho> = \\<sigma>'\n 9. \\<And>\\<tau> op \\<sigma> \\<Gamma> \\<sigma>'.\n       \\<lbrakk>mataop_type \\<tau> op \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         MetaOperationCall \\<tau> op : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 10. \\<And>\\<Gamma> params \\<pi> \\<tau> op oper \\<sigma>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n         \\<And>\\<xi>.\n            \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n            \\<pi> = \\<xi>;\n         static_operation \\<tau> op \\<pi> oper;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          StaticOperationCall \\<tau> op params : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> oper_type oper = \\<sigma>\nA total of 32 subgoals...", "case (CollectionPartsListT \\<Gamma> x \\<tau> y xs \\<sigma>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>\n  \\<Gamma> \\<turnstile>\\<^sub>P x : ?\\<sigma> \\<Longrightarrow>\n  \\<tau> = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>'__\n  \\<Gamma> \\<turnstile>\\<^sub>C y # xs : ?\\<sigma> \\<Longrightarrow>\n  \\<sigma>'__ = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>\n\ngoal (32 subgoals):\n 1. \\<And>\\<Gamma> x \\<tau> y xs \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>P x : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>C\n            y # xs : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<squnion> \\<sigma> = \\<sigma>'\n 2. \\<And>\\<Gamma> a \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 3. \\<And>\\<Gamma> a \\<tau> b \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<Gamma> \\<turnstile>\\<^sub>P\n         CollectionRange a b : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Integer[1] = \\<sigma>'\n 4. \\<And>\\<Gamma> \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (TupleLiteral []) : \\<sigma> \\<Longrightarrow>\n       Tuple fmempty = \\<sigma>\n 5. \\<And>\\<Gamma> elems \\<xi> el \\<tau> \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 Literal (TupleLiteral elems) : Tuple \\<xi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            Literal (TupleLiteral elems) : \\<sigma> \\<Longrightarrow>\n           Tuple \\<xi> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            tuple_element_expr el : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        tuple_element_type el = Some \\<sigma>; \\<tau> \\<le> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral (el # elems)) : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Tuple\n                          (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                           \\<sigma>)) =\n                         \\<sigma>'\n 6. \\<And>\\<Gamma> init \\<sigma> \\<tau> v body \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<sigma> \\<le> \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n         body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n            body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         expr.Let v (Some \\<tau>) init body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 7. \\<And>\\<Gamma> v \\<tau> \\<sigma>.\n       \\<lbrakk>fmlookup \\<Gamma> v = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 8. \\<And>\\<Gamma> a b \\<sigma> c \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           Boolean[1] = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E c : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E expr.If a b c : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<squnion> \\<rho> = \\<sigma>'\n 9. \\<And>\\<tau> op \\<sigma> \\<Gamma> \\<sigma>'.\n       \\<lbrakk>mataop_type \\<tau> op \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         MetaOperationCall \\<tau> op : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 10. \\<And>\\<Gamma> params \\<pi> \\<tau> op oper \\<sigma>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n         \\<And>\\<xi>.\n            \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n            \\<pi> = \\<xi>;\n         static_operation \\<tau> op \\<pi> oper;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          StaticOperationCall \\<tau> op params : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> oper_type oper = \\<sigma>\nA total of 32 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>P x : \\<tau>\n  \\<Gamma> \\<turnstile>\\<^sub>P x : ?\\<sigma> \\<Longrightarrow>\n  \\<tau> = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>C y # xs : \\<sigma>'__\n  \\<Gamma> \\<turnstile>\\<^sub>C y # xs : ?\\<sigma> \\<Longrightarrow>\n  \\<sigma>'__ = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>C x # y # xs : \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<tau> \\<squnion> \\<sigma>'__ = \\<sigma>", "by blast"], ["proof (state)\nthis:\n  \\<tau> \\<squnion> \\<sigma>'__ = \\<sigma>\n\ngoal (31 subgoals):\n 1. \\<And>\\<Gamma> a \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 2. \\<And>\\<Gamma> a \\<tau> b \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<Gamma> \\<turnstile>\\<^sub>P\n         CollectionRange a b : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Integer[1] = \\<sigma>'\n 3. \\<And>\\<Gamma> \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (TupleLiteral []) : \\<sigma> \\<Longrightarrow>\n       Tuple fmempty = \\<sigma>\n 4. \\<And>\\<Gamma> elems \\<xi> el \\<tau> \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 Literal (TupleLiteral elems) : Tuple \\<xi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            Literal (TupleLiteral elems) : \\<sigma> \\<Longrightarrow>\n           Tuple \\<xi> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            tuple_element_expr el : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        tuple_element_type el = Some \\<sigma>; \\<tau> \\<le> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral (el # elems)) : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Tuple\n                          (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                           \\<sigma>)) =\n                         \\<sigma>'\n 5. \\<And>\\<Gamma> init \\<sigma> \\<tau> v body \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<sigma> \\<le> \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n         body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n            body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         expr.Let v (Some \\<tau>) init body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 6. \\<And>\\<Gamma> v \\<tau> \\<sigma>.\n       \\<lbrakk>fmlookup \\<Gamma> v = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 7. \\<And>\\<Gamma> a b \\<sigma> c \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           Boolean[1] = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E c : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E expr.If a b c : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<squnion> \\<rho> = \\<sigma>'\n 8. \\<And>\\<tau> op \\<sigma> \\<Gamma> \\<sigma>'.\n       \\<lbrakk>mataop_type \\<tau> op \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         MetaOperationCall \\<tau> op : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 9. \\<And>\\<Gamma> params \\<pi> \\<tau> op oper \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        static_operation \\<tau> op \\<pi> oper;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         StaticOperationCall \\<tau> op params : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<sigma>\n 10. \\<And>\\<Gamma> a \\<tau> k op \\<sigma> \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         typeop_type k op \\<tau> \\<sigma> \\<rho>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          TypeOperationCall a k op \\<sigma> : \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<rho> = \\<sigma>'\nA total of 31 subgoals...", "next"], ["proof (state)\ngoal (31 subgoals):\n 1. \\<And>\\<Gamma> a \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 2. \\<And>\\<Gamma> a \\<tau> b \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<Gamma> \\<turnstile>\\<^sub>P\n         CollectionRange a b : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Integer[1] = \\<sigma>'\n 3. \\<And>\\<Gamma> \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (TupleLiteral []) : \\<sigma> \\<Longrightarrow>\n       Tuple fmempty = \\<sigma>\n 4. \\<And>\\<Gamma> elems \\<xi> el \\<tau> \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 Literal (TupleLiteral elems) : Tuple \\<xi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            Literal (TupleLiteral elems) : \\<sigma> \\<Longrightarrow>\n           Tuple \\<xi> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            tuple_element_expr el : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        tuple_element_type el = Some \\<sigma>; \\<tau> \\<le> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral (el # elems)) : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Tuple\n                          (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                           \\<sigma>)) =\n                         \\<sigma>'\n 5. \\<And>\\<Gamma> init \\<sigma> \\<tau> v body \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<sigma> \\<le> \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n         body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n            body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         expr.Let v (Some \\<tau>) init body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 6. \\<And>\\<Gamma> v \\<tau> \\<sigma>.\n       \\<lbrakk>fmlookup \\<Gamma> v = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 7. \\<And>\\<Gamma> a b \\<sigma> c \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           Boolean[1] = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E c : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E expr.If a b c : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<squnion> \\<rho> = \\<sigma>'\n 8. \\<And>\\<tau> op \\<sigma> \\<Gamma> \\<sigma>'.\n       \\<lbrakk>mataop_type \\<tau> op \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         MetaOperationCall \\<tau> op : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 9. \\<And>\\<Gamma> params \\<pi> \\<tau> op oper \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        static_operation \\<tau> op \\<pi> oper;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         StaticOperationCall \\<tau> op params : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<sigma>\n 10. \\<And>\\<Gamma> a \\<tau> k op \\<sigma> \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         typeop_type k op \\<tau> \\<sigma> \\<rho>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          TypeOperationCall a k op \\<sigma> : \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<rho> = \\<sigma>'\nA total of 31 subgoals...", "case (CollectionPartItemT \\<Gamma> a \\<tau>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>\n  \\<Gamma> \\<turnstile>\\<^sub>E a : ?\\<sigma> \\<Longrightarrow>\n  \\<tau> = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\n\ngoal (31 subgoals):\n 1. \\<And>\\<Gamma> a \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 2. \\<And>\\<Gamma> a \\<tau> b \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<Gamma> \\<turnstile>\\<^sub>P\n         CollectionRange a b : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Integer[1] = \\<sigma>'\n 3. \\<And>\\<Gamma> \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (TupleLiteral []) : \\<sigma> \\<Longrightarrow>\n       Tuple fmempty = \\<sigma>\n 4. \\<And>\\<Gamma> elems \\<xi> el \\<tau> \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 Literal (TupleLiteral elems) : Tuple \\<xi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            Literal (TupleLiteral elems) : \\<sigma> \\<Longrightarrow>\n           Tuple \\<xi> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            tuple_element_expr el : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        tuple_element_type el = Some \\<sigma>; \\<tau> \\<le> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral (el # elems)) : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Tuple\n                          (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                           \\<sigma>)) =\n                         \\<sigma>'\n 5. \\<And>\\<Gamma> init \\<sigma> \\<tau> v body \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<sigma> \\<le> \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n         body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n            body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         expr.Let v (Some \\<tau>) init body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 6. \\<And>\\<Gamma> v \\<tau> \\<sigma>.\n       \\<lbrakk>fmlookup \\<Gamma> v = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 7. \\<And>\\<Gamma> a b \\<sigma> c \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           Boolean[1] = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E c : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E expr.If a b c : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<squnion> \\<rho> = \\<sigma>'\n 8. \\<And>\\<tau> op \\<sigma> \\<Gamma> \\<sigma>'.\n       \\<lbrakk>mataop_type \\<tau> op \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         MetaOperationCall \\<tau> op : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 9. \\<And>\\<Gamma> params \\<pi> \\<tau> op oper \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        static_operation \\<tau> op \\<pi> oper;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         StaticOperationCall \\<tau> op params : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<sigma>\n 10. \\<And>\\<Gamma> a \\<tau> k op \\<sigma> \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         typeop_type k op \\<tau> \\<sigma> \\<rho>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          TypeOperationCall a k op \\<sigma> : \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<rho> = \\<sigma>'\nA total of 31 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>\n  \\<Gamma> \\<turnstile>\\<^sub>E a : ?\\<sigma> \\<Longrightarrow>\n  \\<tau> = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>P CollectionItem a : \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<tau> = \\<sigma>", "by blast"], ["proof (state)\nthis:\n  \\<tau> = \\<sigma>\n\ngoal (30 subgoals):\n 1. \\<And>\\<Gamma> a \\<tau> b \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<Gamma> \\<turnstile>\\<^sub>P\n         CollectionRange a b : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Integer[1] = \\<sigma>'\n 2. \\<And>\\<Gamma> \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (TupleLiteral []) : \\<sigma> \\<Longrightarrow>\n       Tuple fmempty = \\<sigma>\n 3. \\<And>\\<Gamma> elems \\<xi> el \\<tau> \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 Literal (TupleLiteral elems) : Tuple \\<xi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            Literal (TupleLiteral elems) : \\<sigma> \\<Longrightarrow>\n           Tuple \\<xi> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            tuple_element_expr el : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        tuple_element_type el = Some \\<sigma>; \\<tau> \\<le> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral (el # elems)) : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Tuple\n                          (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                           \\<sigma>)) =\n                         \\<sigma>'\n 4. \\<And>\\<Gamma> init \\<sigma> \\<tau> v body \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<sigma> \\<le> \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n         body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n            body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         expr.Let v (Some \\<tau>) init body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 5. \\<And>\\<Gamma> v \\<tau> \\<sigma>.\n       \\<lbrakk>fmlookup \\<Gamma> v = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 6. \\<And>\\<Gamma> a b \\<sigma> c \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           Boolean[1] = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E c : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E expr.If a b c : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<squnion> \\<rho> = \\<sigma>'\n 7. \\<And>\\<tau> op \\<sigma> \\<Gamma> \\<sigma>'.\n       \\<lbrakk>mataop_type \\<tau> op \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         MetaOperationCall \\<tau> op : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 8. \\<And>\\<Gamma> params \\<pi> \\<tau> op oper \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        static_operation \\<tau> op \\<pi> oper;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         StaticOperationCall \\<tau> op params : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<sigma>\n 9. \\<And>\\<Gamma> a \\<tau> k op \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        typeop_type k op \\<tau> \\<sigma> \\<rho>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TypeOperationCall a k op \\<sigma> : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 10. \\<And>\\<Gamma> src \\<C> prop \\<D> \\<tau> \\<sigma>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                  src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n            \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n         attribute \\<C> prop \\<D> \\<tau>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          AttributeCall src DotCall prop : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> \\<tau> = \\<sigma>\nA total of 30 subgoals...", "next"], ["proof (state)\ngoal (30 subgoals):\n 1. \\<And>\\<Gamma> a \\<tau> b \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<Gamma> \\<turnstile>\\<^sub>P\n         CollectionRange a b : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Integer[1] = \\<sigma>'\n 2. \\<And>\\<Gamma> \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (TupleLiteral []) : \\<sigma> \\<Longrightarrow>\n       Tuple fmempty = \\<sigma>\n 3. \\<And>\\<Gamma> elems \\<xi> el \\<tau> \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 Literal (TupleLiteral elems) : Tuple \\<xi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            Literal (TupleLiteral elems) : \\<sigma> \\<Longrightarrow>\n           Tuple \\<xi> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            tuple_element_expr el : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        tuple_element_type el = Some \\<sigma>; \\<tau> \\<le> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral (el # elems)) : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Tuple\n                          (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                           \\<sigma>)) =\n                         \\<sigma>'\n 4. \\<And>\\<Gamma> init \\<sigma> \\<tau> v body \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<sigma> \\<le> \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n         body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n            body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         expr.Let v (Some \\<tau>) init body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 5. \\<And>\\<Gamma> v \\<tau> \\<sigma>.\n       \\<lbrakk>fmlookup \\<Gamma> v = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 6. \\<And>\\<Gamma> a b \\<sigma> c \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           Boolean[1] = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E c : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E expr.If a b c : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<squnion> \\<rho> = \\<sigma>'\n 7. \\<And>\\<tau> op \\<sigma> \\<Gamma> \\<sigma>'.\n       \\<lbrakk>mataop_type \\<tau> op \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         MetaOperationCall \\<tau> op : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 8. \\<And>\\<Gamma> params \\<pi> \\<tau> op oper \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        static_operation \\<tau> op \\<pi> oper;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         StaticOperationCall \\<tau> op params : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<sigma>\n 9. \\<And>\\<Gamma> a \\<tau> k op \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        typeop_type k op \\<tau> \\<sigma> \\<rho>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TypeOperationCall a k op \\<sigma> : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 10. \\<And>\\<Gamma> src \\<C> prop \\<D> \\<tau> \\<sigma>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                  src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n            \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n         attribute \\<C> prop \\<D> \\<tau>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          AttributeCall src DotCall prop : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> \\<tau> = \\<sigma>\nA total of 30 subgoals...", "case (CollectionPartRangeT \\<Gamma> a \\<tau> b \\<sigma>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>\n  \\<Gamma> \\<turnstile>\\<^sub>E a : ?\\<sigma> \\<Longrightarrow>\n  \\<tau> = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>'__\n  \\<Gamma> \\<turnstile>\\<^sub>E b : ?\\<sigma> \\<Longrightarrow>\n  \\<sigma>'__ = ?\\<sigma>\n  \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1]\n  \\<sigma>'__ = UnlimitedNatural[1]\\<midarrow>Integer[1]\n  \\<Gamma> \\<turnstile>\\<^sub>P CollectionRange a b : \\<sigma>\n\ngoal (30 subgoals):\n 1. \\<And>\\<Gamma> a \\<tau> b \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<sigma> = UnlimitedNatural[1]\\<midarrow>Integer[1];\n        \\<Gamma> \\<turnstile>\\<^sub>P\n         CollectionRange a b : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Integer[1] = \\<sigma>'\n 2. \\<And>\\<Gamma> \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (TupleLiteral []) : \\<sigma> \\<Longrightarrow>\n       Tuple fmempty = \\<sigma>\n 3. \\<And>\\<Gamma> elems \\<xi> el \\<tau> \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 Literal (TupleLiteral elems) : Tuple \\<xi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            Literal (TupleLiteral elems) : \\<sigma> \\<Longrightarrow>\n           Tuple \\<xi> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            tuple_element_expr el : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        tuple_element_type el = Some \\<sigma>; \\<tau> \\<le> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral (el # elems)) : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Tuple\n                          (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                           \\<sigma>)) =\n                         \\<sigma>'\n 4. \\<And>\\<Gamma> init \\<sigma> \\<tau> v body \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<sigma> \\<le> \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n         body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n            body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         expr.Let v (Some \\<tau>) init body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 5. \\<And>\\<Gamma> v \\<tau> \\<sigma>.\n       \\<lbrakk>fmlookup \\<Gamma> v = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 6. \\<And>\\<Gamma> a b \\<sigma> c \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           Boolean[1] = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E c : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E expr.If a b c : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<squnion> \\<rho> = \\<sigma>'\n 7. \\<And>\\<tau> op \\<sigma> \\<Gamma> \\<sigma>'.\n       \\<lbrakk>mataop_type \\<tau> op \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         MetaOperationCall \\<tau> op : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 8. \\<And>\\<Gamma> params \\<pi> \\<tau> op oper \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        static_operation \\<tau> op \\<pi> oper;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         StaticOperationCall \\<tau> op params : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<sigma>\n 9. \\<And>\\<Gamma> a \\<tau> k op \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        typeop_type k op \\<tau> \\<sigma> \\<rho>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TypeOperationCall a k op \\<sigma> : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 10. \\<And>\\<Gamma> src \\<C> prop \\<D> \\<tau> \\<sigma>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                  src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n            \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n         attribute \\<C> prop \\<D> \\<tau>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          AttributeCall src DotCall prop : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> \\<tau> = \\<sigma>\nA total of 30 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>\n  \\<Gamma> \\<turnstile>\\<^sub>E a : ?\\<sigma> \\<Longrightarrow>\n  \\<tau> = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>'__\n  \\<Gamma> \\<turnstile>\\<^sub>E b : ?\\<sigma> \\<Longrightarrow>\n  \\<sigma>'__ = ?\\<sigma>\n  \\<tau> = UnlimitedNatural[1]\\<midarrow>Integer[1]\n  \\<sigma>'__ = UnlimitedNatural[1]\\<midarrow>Integer[1]\n  \\<Gamma> \\<turnstile>\\<^sub>P CollectionRange a b : \\<sigma>\n\ngoal (1 subgoal):\n 1. Integer[1] = \\<sigma>", "by blast"], ["proof (state)\nthis:\n  Integer[1] = \\<sigma>\n\ngoal (29 subgoals):\n 1. \\<And>\\<Gamma> \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (TupleLiteral []) : \\<sigma> \\<Longrightarrow>\n       Tuple fmempty = \\<sigma>\n 2. \\<And>\\<Gamma> elems \\<xi> el \\<tau> \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 Literal (TupleLiteral elems) : Tuple \\<xi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            Literal (TupleLiteral elems) : \\<sigma> \\<Longrightarrow>\n           Tuple \\<xi> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            tuple_element_expr el : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        tuple_element_type el = Some \\<sigma>; \\<tau> \\<le> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral (el # elems)) : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Tuple\n                          (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                           \\<sigma>)) =\n                         \\<sigma>'\n 3. \\<And>\\<Gamma> init \\<sigma> \\<tau> v body \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<sigma> \\<le> \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n         body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n            body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         expr.Let v (Some \\<tau>) init body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 4. \\<And>\\<Gamma> v \\<tau> \\<sigma>.\n       \\<lbrakk>fmlookup \\<Gamma> v = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 5. \\<And>\\<Gamma> a b \\<sigma> c \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           Boolean[1] = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E c : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E expr.If a b c : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<squnion> \\<rho> = \\<sigma>'\n 6. \\<And>\\<tau> op \\<sigma> \\<Gamma> \\<sigma>'.\n       \\<lbrakk>mataop_type \\<tau> op \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         MetaOperationCall \\<tau> op : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 7. \\<And>\\<Gamma> params \\<pi> \\<tau> op oper \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        static_operation \\<tau> op \\<pi> oper;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         StaticOperationCall \\<tau> op params : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<sigma>\n 8. \\<And>\\<Gamma> a \\<tau> k op \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        typeop_type k op \\<tau> \\<sigma> \\<rho>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TypeOperationCall a k op \\<sigma> : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 9. \\<And>\\<Gamma> src \\<C> prop \\<D> \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        attribute \\<C> prop \\<D> \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AttributeCall src DotCall prop : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 10. \\<And>\\<Gamma> src \\<C> from role \\<D> end \\<sigma>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                  src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n            \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n         association_end \\<C> from role \\<D> end;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          AssociationEndCall src DotCall from role : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> assoc_end_type end = \\<sigma>\nA total of 29 subgoals...", "next"], ["proof (state)\ngoal (29 subgoals):\n 1. \\<And>\\<Gamma> \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (TupleLiteral []) : \\<sigma> \\<Longrightarrow>\n       Tuple fmempty = \\<sigma>\n 2. \\<And>\\<Gamma> elems \\<xi> el \\<tau> \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 Literal (TupleLiteral elems) : Tuple \\<xi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            Literal (TupleLiteral elems) : \\<sigma> \\<Longrightarrow>\n           Tuple \\<xi> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            tuple_element_expr el : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        tuple_element_type el = Some \\<sigma>; \\<tau> \\<le> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral (el # elems)) : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Tuple\n                          (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                           \\<sigma>)) =\n                         \\<sigma>'\n 3. \\<And>\\<Gamma> init \\<sigma> \\<tau> v body \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<sigma> \\<le> \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n         body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n            body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         expr.Let v (Some \\<tau>) init body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 4. \\<And>\\<Gamma> v \\<tau> \\<sigma>.\n       \\<lbrakk>fmlookup \\<Gamma> v = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 5. \\<And>\\<Gamma> a b \\<sigma> c \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           Boolean[1] = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E c : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E expr.If a b c : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<squnion> \\<rho> = \\<sigma>'\n 6. \\<And>\\<tau> op \\<sigma> \\<Gamma> \\<sigma>'.\n       \\<lbrakk>mataop_type \\<tau> op \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         MetaOperationCall \\<tau> op : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 7. \\<And>\\<Gamma> params \\<pi> \\<tau> op oper \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        static_operation \\<tau> op \\<pi> oper;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         StaticOperationCall \\<tau> op params : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<sigma>\n 8. \\<And>\\<Gamma> a \\<tau> k op \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        typeop_type k op \\<tau> \\<sigma> \\<rho>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TypeOperationCall a k op \\<sigma> : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 9. \\<And>\\<Gamma> src \\<C> prop \\<D> \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        attribute \\<C> prop \\<D> \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AttributeCall src DotCall prop : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 10. \\<And>\\<Gamma> src \\<C> from role \\<D> end \\<sigma>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                  src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n            \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n         association_end \\<C> from role \\<D> end;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          AssociationEndCall src DotCall from role : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> assoc_end_type end = \\<sigma>\nA total of 29 subgoals...", "case (TupleLiteralNilT \\<Gamma>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>E Literal (TupleLiteral []) : \\<sigma>\n\ngoal (29 subgoals):\n 1. \\<And>\\<Gamma> \\<sigma>.\n       \\<Gamma> \\<turnstile>\\<^sub>E\n        Literal (TupleLiteral []) : \\<sigma> \\<Longrightarrow>\n       Tuple fmempty = \\<sigma>\n 2. \\<And>\\<Gamma> elems \\<xi> el \\<tau> \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 Literal (TupleLiteral elems) : Tuple \\<xi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            Literal (TupleLiteral elems) : \\<sigma> \\<Longrightarrow>\n           Tuple \\<xi> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            tuple_element_expr el : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        tuple_element_type el = Some \\<sigma>; \\<tau> \\<le> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral (el # elems)) : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Tuple\n                          (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                           \\<sigma>)) =\n                         \\<sigma>'\n 3. \\<And>\\<Gamma> init \\<sigma> \\<tau> v body \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<sigma> \\<le> \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n         body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n            body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         expr.Let v (Some \\<tau>) init body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 4. \\<And>\\<Gamma> v \\<tau> \\<sigma>.\n       \\<lbrakk>fmlookup \\<Gamma> v = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 5. \\<And>\\<Gamma> a b \\<sigma> c \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           Boolean[1] = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E c : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E expr.If a b c : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<squnion> \\<rho> = \\<sigma>'\n 6. \\<And>\\<tau> op \\<sigma> \\<Gamma> \\<sigma>'.\n       \\<lbrakk>mataop_type \\<tau> op \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         MetaOperationCall \\<tau> op : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 7. \\<And>\\<Gamma> params \\<pi> \\<tau> op oper \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        static_operation \\<tau> op \\<pi> oper;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         StaticOperationCall \\<tau> op params : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<sigma>\n 8. \\<And>\\<Gamma> a \\<tau> k op \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        typeop_type k op \\<tau> \\<sigma> \\<rho>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TypeOperationCall a k op \\<sigma> : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 9. \\<And>\\<Gamma> src \\<C> prop \\<D> \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        attribute \\<C> prop \\<D> \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AttributeCall src DotCall prop : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 10. \\<And>\\<Gamma> src \\<C> from role \\<D> end \\<sigma>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                  src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n            \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n         association_end \\<C> from role \\<D> end;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          AssociationEndCall src DotCall from role : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> assoc_end_type end = \\<sigma>\nA total of 29 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>E Literal (TupleLiteral []) : \\<sigma>\n\ngoal (1 subgoal):\n 1. Tuple fmempty = \\<sigma>", "by auto"], ["proof (state)\nthis:\n  Tuple fmempty = \\<sigma>\n\ngoal (28 subgoals):\n 1. \\<And>\\<Gamma> elems \\<xi> el \\<tau> \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 Literal (TupleLiteral elems) : Tuple \\<xi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            Literal (TupleLiteral elems) : \\<sigma> \\<Longrightarrow>\n           Tuple \\<xi> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            tuple_element_expr el : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        tuple_element_type el = Some \\<sigma>; \\<tau> \\<le> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral (el # elems)) : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Tuple\n                          (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                           \\<sigma>)) =\n                         \\<sigma>'\n 2. \\<And>\\<Gamma> init \\<sigma> \\<tau> v body \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<sigma> \\<le> \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n         body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n            body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         expr.Let v (Some \\<tau>) init body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 3. \\<And>\\<Gamma> v \\<tau> \\<sigma>.\n       \\<lbrakk>fmlookup \\<Gamma> v = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 4. \\<And>\\<Gamma> a b \\<sigma> c \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           Boolean[1] = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E c : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E expr.If a b c : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<squnion> \\<rho> = \\<sigma>'\n 5. \\<And>\\<tau> op \\<sigma> \\<Gamma> \\<sigma>'.\n       \\<lbrakk>mataop_type \\<tau> op \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         MetaOperationCall \\<tau> op : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 6. \\<And>\\<Gamma> params \\<pi> \\<tau> op oper \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        static_operation \\<tau> op \\<pi> oper;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         StaticOperationCall \\<tau> op params : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<sigma>\n 7. \\<And>\\<Gamma> a \\<tau> k op \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        typeop_type k op \\<tau> \\<sigma> \\<rho>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TypeOperationCall a k op \\<sigma> : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 8. \\<And>\\<Gamma> src \\<C> prop \\<D> \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        attribute \\<C> prop \\<D> \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AttributeCall src DotCall prop : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 9. \\<And>\\<Gamma> src \\<C> from role \\<D> end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_end \\<C> from role \\<D> end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationEndCall src DotCall from role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> assoc_end_type end = \\<sigma>\n 10. \\<And>\\<Gamma> src \\<C> from \\<A> \\<D> \\<sigma>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                  src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n            \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n         referred_by_association_class \\<C> from \\<A> \\<D>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          AssociationClassCall src DotCall from \\<A> : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> class_assoc_type \\<A> = \\<sigma>\nA total of 28 subgoals...", "next"], ["proof (state)\ngoal (28 subgoals):\n 1. \\<And>\\<Gamma> elems \\<xi> el \\<tau> \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 Literal (TupleLiteral elems) : Tuple \\<xi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            Literal (TupleLiteral elems) : \\<sigma> \\<Longrightarrow>\n           Tuple \\<xi> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            tuple_element_expr el : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        tuple_element_type el = Some \\<sigma>; \\<tau> \\<le> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral (el # elems)) : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Tuple\n                          (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                           \\<sigma>)) =\n                         \\<sigma>'\n 2. \\<And>\\<Gamma> init \\<sigma> \\<tau> v body \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<sigma> \\<le> \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n         body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n            body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         expr.Let v (Some \\<tau>) init body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 3. \\<And>\\<Gamma> v \\<tau> \\<sigma>.\n       \\<lbrakk>fmlookup \\<Gamma> v = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 4. \\<And>\\<Gamma> a b \\<sigma> c \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           Boolean[1] = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E c : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E expr.If a b c : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<squnion> \\<rho> = \\<sigma>'\n 5. \\<And>\\<tau> op \\<sigma> \\<Gamma> \\<sigma>'.\n       \\<lbrakk>mataop_type \\<tau> op \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         MetaOperationCall \\<tau> op : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 6. \\<And>\\<Gamma> params \\<pi> \\<tau> op oper \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        static_operation \\<tau> op \\<pi> oper;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         StaticOperationCall \\<tau> op params : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<sigma>\n 7. \\<And>\\<Gamma> a \\<tau> k op \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        typeop_type k op \\<tau> \\<sigma> \\<rho>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TypeOperationCall a k op \\<sigma> : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 8. \\<And>\\<Gamma> src \\<C> prop \\<D> \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        attribute \\<C> prop \\<D> \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AttributeCall src DotCall prop : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 9. \\<And>\\<Gamma> src \\<C> from role \\<D> end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_end \\<C> from role \\<D> end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationEndCall src DotCall from role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> assoc_end_type end = \\<sigma>\n 10. \\<And>\\<Gamma> src \\<C> from \\<A> \\<D> \\<sigma>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                  src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n            \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n         referred_by_association_class \\<C> from \\<A> \\<D>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          AssociationClassCall src DotCall from \\<A> : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> class_assoc_type \\<A> = \\<sigma>\nA total of 28 subgoals...", "case (TupleLiteralConsT \\<Gamma> elems \\<xi> el \\<tau>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>E Literal (TupleLiteral elems) : Tuple \\<xi>\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   Literal (TupleLiteral elems) : ?\\<sigma> \\<Longrightarrow>\n  Tuple \\<xi> = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   tuple_element_expr el : ?\\<sigma> \\<Longrightarrow>\n  \\<tau> = ?\\<sigma>\n  tuple_element_type el = Some \\<sigma>_\n  \\<tau> \\<le> \\<sigma>_\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   Literal (TupleLiteral (el # elems)) : \\<sigma>\n\ngoal (28 subgoals):\n 1. \\<And>\\<Gamma> elems \\<xi> el \\<tau> \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 Literal (TupleLiteral elems) : Tuple \\<xi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            Literal (TupleLiteral elems) : \\<sigma> \\<Longrightarrow>\n           Tuple \\<xi> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E\n            tuple_element_expr el : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        tuple_element_type el = Some \\<sigma>; \\<tau> \\<le> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral (el # elems)) : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Tuple\n                          (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                           \\<sigma>)) =\n                         \\<sigma>'\n 2. \\<And>\\<Gamma> init \\<sigma> \\<tau> v body \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<sigma> \\<le> \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n         body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n            body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         expr.Let v (Some \\<tau>) init body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 3. \\<And>\\<Gamma> v \\<tau> \\<sigma>.\n       \\<lbrakk>fmlookup \\<Gamma> v = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 4. \\<And>\\<Gamma> a b \\<sigma> c \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           Boolean[1] = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E c : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E expr.If a b c : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<squnion> \\<rho> = \\<sigma>'\n 5. \\<And>\\<tau> op \\<sigma> \\<Gamma> \\<sigma>'.\n       \\<lbrakk>mataop_type \\<tau> op \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         MetaOperationCall \\<tau> op : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 6. \\<And>\\<Gamma> params \\<pi> \\<tau> op oper \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        static_operation \\<tau> op \\<pi> oper;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         StaticOperationCall \\<tau> op params : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<sigma>\n 7. \\<And>\\<Gamma> a \\<tau> k op \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        typeop_type k op \\<tau> \\<sigma> \\<rho>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TypeOperationCall a k op \\<sigma> : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 8. \\<And>\\<Gamma> src \\<C> prop \\<D> \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        attribute \\<C> prop \\<D> \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AttributeCall src DotCall prop : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 9. \\<And>\\<Gamma> src \\<C> from role \\<D> end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_end \\<C> from role \\<D> end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationEndCall src DotCall from role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> assoc_end_type end = \\<sigma>\n 10. \\<And>\\<Gamma> src \\<C> from \\<A> \\<D> \\<sigma>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                  src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n            \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n         referred_by_association_class \\<C> from \\<A> \\<D>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          AssociationClassCall src DotCall from \\<A> : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> class_assoc_type \\<A> = \\<sigma>\nA total of 28 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Tuple (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f \\<sigma>_)) =\n    \\<sigma>", "apply (insert TupleLiteralConsT.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>E\n     Literal (TupleLiteral (el # elems)) : \\<sigma> \\<Longrightarrow>\n    Tuple (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f \\<sigma>_)) =\n    \\<sigma>", "apply (erule TupleLiteralTE, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>elemsa \\<xi> ela \\<tau> \\<sigma>.\n       \\<lbrakk>el # elems = ela # elemsa;\n        \\<sigma> =\n        Tuple (\\<xi>(tuple_element_name ela \\<mapsto>\\<^sub>f \\<sigma>));\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral elemsa) : Tuple \\<xi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr ela : \\<tau>;\n        tuple_element_type ela = Some \\<sigma>;\n        \\<tau> \\<le> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Tuple\n                          (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                           \\<sigma>_)) =\n                         \\<sigma>", "using TupleLiteralConsT.hyps"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>E Literal (TupleLiteral elems) : Tuple \\<xi>\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   Literal (TupleLiteral elems) : ?\\<sigma> \\<Longrightarrow>\n  Tuple \\<xi> = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr el : \\<tau>\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   tuple_element_expr el : ?\\<sigma> \\<Longrightarrow>\n  \\<tau> = ?\\<sigma>\n  tuple_element_type el = Some \\<sigma>_\n  \\<tau> \\<le> \\<sigma>_\n\ngoal (1 subgoal):\n 1. \\<And>elemsa \\<xi> ela \\<tau> \\<sigma>.\n       \\<lbrakk>el # elems = ela # elemsa;\n        \\<sigma> =\n        Tuple (\\<xi>(tuple_element_name ela \\<mapsto>\\<^sub>f \\<sigma>));\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         Literal (TupleLiteral elemsa) : Tuple \\<xi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E tuple_element_expr ela : \\<tau>;\n        tuple_element_type ela = Some \\<sigma>;\n        \\<tau> \\<le> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> Tuple\n                          (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f\n                           \\<sigma>_)) =\n                         \\<sigma>", "by auto"], ["proof (state)\nthis:\n  Tuple (\\<xi>(tuple_element_name el \\<mapsto>\\<^sub>f \\<sigma>_)) =\n  \\<sigma>\n\ngoal (27 subgoals):\n 1. \\<And>\\<Gamma> init \\<sigma> \\<tau> v body \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<sigma> \\<le> \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n         body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n            body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         expr.Let v (Some \\<tau>) init body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 2. \\<And>\\<Gamma> v \\<tau> \\<sigma>.\n       \\<lbrakk>fmlookup \\<Gamma> v = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 3. \\<And>\\<Gamma> a b \\<sigma> c \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           Boolean[1] = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E c : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E expr.If a b c : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<squnion> \\<rho> = \\<sigma>'\n 4. \\<And>\\<tau> op \\<sigma> \\<Gamma> \\<sigma>'.\n       \\<lbrakk>mataop_type \\<tau> op \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         MetaOperationCall \\<tau> op : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 5. \\<And>\\<Gamma> params \\<pi> \\<tau> op oper \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        static_operation \\<tau> op \\<pi> oper;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         StaticOperationCall \\<tau> op params : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<sigma>\n 6. \\<And>\\<Gamma> a \\<tau> k op \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        typeop_type k op \\<tau> \\<sigma> \\<rho>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TypeOperationCall a k op \\<sigma> : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 7. \\<And>\\<Gamma> src \\<C> prop \\<D> \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        attribute \\<C> prop \\<D> \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AttributeCall src DotCall prop : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 8. \\<And>\\<Gamma> src \\<C> from role \\<D> end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_end \\<C> from role \\<D> end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationEndCall src DotCall from role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> assoc_end_type end = \\<sigma>\n 9. \\<And>\\<Gamma> src \\<C> from \\<A> \\<D> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        referred_by_association_class \\<C> from \\<A> \\<D>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassCall src DotCall from \\<A> : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_type \\<A> = \\<sigma>\n 10. \\<And>\\<Gamma> src \\<A> role end \\<sigma>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                  src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1];\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n            \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n         association_class_end \\<A> role end;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          AssociationClassEndCall src DotCall role : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> class_assoc_end_type end = \\<sigma>\nA total of 27 subgoals...", "next"], ["proof (state)\ngoal (27 subgoals):\n 1. \\<And>\\<Gamma> init \\<sigma> \\<tau> v body \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<sigma> \\<le> \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n         body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n            body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         expr.Let v (Some \\<tau>) init body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 2. \\<And>\\<Gamma> v \\<tau> \\<sigma>.\n       \\<lbrakk>fmlookup \\<Gamma> v = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 3. \\<And>\\<Gamma> a b \\<sigma> c \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           Boolean[1] = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E c : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E expr.If a b c : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<squnion> \\<rho> = \\<sigma>'\n 4. \\<And>\\<tau> op \\<sigma> \\<Gamma> \\<sigma>'.\n       \\<lbrakk>mataop_type \\<tau> op \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         MetaOperationCall \\<tau> op : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 5. \\<And>\\<Gamma> params \\<pi> \\<tau> op oper \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        static_operation \\<tau> op \\<pi> oper;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         StaticOperationCall \\<tau> op params : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<sigma>\n 6. \\<And>\\<Gamma> a \\<tau> k op \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        typeop_type k op \\<tau> \\<sigma> \\<rho>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TypeOperationCall a k op \\<sigma> : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 7. \\<And>\\<Gamma> src \\<C> prop \\<D> \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        attribute \\<C> prop \\<D> \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AttributeCall src DotCall prop : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 8. \\<And>\\<Gamma> src \\<C> from role \\<D> end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_end \\<C> from role \\<D> end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationEndCall src DotCall from role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> assoc_end_type end = \\<sigma>\n 9. \\<And>\\<Gamma> src \\<C> from \\<A> \\<D> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        referred_by_association_class \\<C> from \\<A> \\<D>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassCall src DotCall from \\<A> : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_type \\<A> = \\<sigma>\n 10. \\<And>\\<Gamma> src \\<A> role end \\<sigma>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                  src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1];\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n            \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n         association_class_end \\<A> role end;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          AssociationClassEndCall src DotCall role : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> class_assoc_end_type end = \\<sigma>\nA total of 27 subgoals...", "case (LetT \\<Gamma> \\<M> init \\<sigma> \\<tau> v body \\<rho>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>E \\<M> : init\n  \\<Gamma> \\<turnstile>\\<^sub>E \\<M> : ?\\<sigma> \\<Longrightarrow>\n  init = ?\\<sigma>\n  init \\<le> \\<sigma>\n  \\<Gamma>(\\<tau> \\<mapsto>\\<^sub>f \\<sigma>) \\<turnstile>\\<^sub>E v : body\n  \\<Gamma>(\\<tau> \\<mapsto>\\<^sub>f \\<sigma>) \\<turnstile>\\<^sub>E\n   v : ?\\<sigma> \\<Longrightarrow>\n  body = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   expr.Let \\<tau> (Some \\<sigma>) \\<M> v : \\<rho>\n\ngoal (27 subgoals):\n 1. \\<And>\\<Gamma> init \\<sigma> \\<tau> v body \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E init : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<sigma> \\<le> \\<tau>;\n        \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n         body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma>(v \\<mapsto>\\<^sub>f \\<tau>) \\<turnstile>\\<^sub>E\n            body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         expr.Let v (Some \\<tau>) init body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 2. \\<And>\\<Gamma> v \\<tau> \\<sigma>.\n       \\<lbrakk>fmlookup \\<Gamma> v = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 3. \\<And>\\<Gamma> a b \\<sigma> c \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           Boolean[1] = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E c : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E expr.If a b c : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<squnion> \\<rho> = \\<sigma>'\n 4. \\<And>\\<tau> op \\<sigma> \\<Gamma> \\<sigma>'.\n       \\<lbrakk>mataop_type \\<tau> op \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         MetaOperationCall \\<tau> op : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 5. \\<And>\\<Gamma> params \\<pi> \\<tau> op oper \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        static_operation \\<tau> op \\<pi> oper;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         StaticOperationCall \\<tau> op params : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<sigma>\n 6. \\<And>\\<Gamma> a \\<tau> k op \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        typeop_type k op \\<tau> \\<sigma> \\<rho>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TypeOperationCall a k op \\<sigma> : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 7. \\<And>\\<Gamma> src \\<C> prop \\<D> \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        attribute \\<C> prop \\<D> \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AttributeCall src DotCall prop : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 8. \\<And>\\<Gamma> src \\<C> from role \\<D> end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_end \\<C> from role \\<D> end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationEndCall src DotCall from role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> assoc_end_type end = \\<sigma>\n 9. \\<And>\\<Gamma> src \\<C> from \\<A> \\<D> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        referred_by_association_class \\<C> from \\<A> \\<D>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassCall src DotCall from \\<A> : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_type \\<A> = \\<sigma>\n 10. \\<And>\\<Gamma> src \\<A> role end \\<sigma>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                  src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1];\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n            \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n         association_class_end \\<A> role end;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          AssociationClassEndCall src DotCall role : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> class_assoc_end_type end = \\<sigma>\nA total of 27 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>E \\<M> : init\n  \\<Gamma> \\<turnstile>\\<^sub>E \\<M> : ?\\<sigma> \\<Longrightarrow>\n  init = ?\\<sigma>\n  init \\<le> \\<sigma>\n  \\<Gamma>(\\<tau> \\<mapsto>\\<^sub>f \\<sigma>) \\<turnstile>\\<^sub>E v : body\n  \\<Gamma>(\\<tau> \\<mapsto>\\<^sub>f \\<sigma>) \\<turnstile>\\<^sub>E\n   v : ?\\<sigma> \\<Longrightarrow>\n  body = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   expr.Let \\<tau> (Some \\<sigma>) \\<M> v : \\<rho>\n\ngoal (1 subgoal):\n 1. body = \\<rho>", "by blast"], ["proof (state)\nthis:\n  body = \\<rho>\n\ngoal (26 subgoals):\n 1. \\<And>\\<Gamma> v \\<tau> \\<sigma>.\n       \\<lbrakk>fmlookup \\<Gamma> v = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 2. \\<And>\\<Gamma> a b \\<sigma> c \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           Boolean[1] = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E c : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E expr.If a b c : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<squnion> \\<rho> = \\<sigma>'\n 3. \\<And>\\<tau> op \\<sigma> \\<Gamma> \\<sigma>'.\n       \\<lbrakk>mataop_type \\<tau> op \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         MetaOperationCall \\<tau> op : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 4. \\<And>\\<Gamma> params \\<pi> \\<tau> op oper \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        static_operation \\<tau> op \\<pi> oper;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         StaticOperationCall \\<tau> op params : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<sigma>\n 5. \\<And>\\<Gamma> a \\<tau> k op \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        typeop_type k op \\<tau> \\<sigma> \\<rho>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TypeOperationCall a k op \\<sigma> : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 6. \\<And>\\<Gamma> src \\<C> prop \\<D> \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        attribute \\<C> prop \\<D> \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AttributeCall src DotCall prop : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 7. \\<And>\\<Gamma> src \\<C> from role \\<D> end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_end \\<C> from role \\<D> end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationEndCall src DotCall from role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> assoc_end_type end = \\<sigma>\n 8. \\<And>\\<Gamma> src \\<C> from \\<A> \\<D> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        referred_by_association_class \\<C> from \\<A> \\<D>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassCall src DotCall from \\<A> : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_type \\<A> = \\<sigma>\n 9. \\<And>\\<Gamma> src \\<A> role end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_class_end \\<A> role end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassEndCall src DotCall role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_end_type end = \\<sigma>\n 10. \\<And>\\<Gamma> src \\<tau> params \\<pi> op k \\<sigma> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n         \\<And>\\<xi>.\n            \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n            \\<pi> = \\<xi>;\n         op_type op k \\<tau> \\<pi> \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          OperationCall src k op params : \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<sigma> = \\<sigma>'\nA total of 26 subgoals...", "next"], ["proof (state)\ngoal (26 subgoals):\n 1. \\<And>\\<Gamma> v \\<tau> \\<sigma>.\n       \\<lbrakk>fmlookup \\<Gamma> v = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 2. \\<And>\\<Gamma> a b \\<sigma> c \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           Boolean[1] = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E c : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E expr.If a b c : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<squnion> \\<rho> = \\<sigma>'\n 3. \\<And>\\<tau> op \\<sigma> \\<Gamma> \\<sigma>'.\n       \\<lbrakk>mataop_type \\<tau> op \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         MetaOperationCall \\<tau> op : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 4. \\<And>\\<Gamma> params \\<pi> \\<tau> op oper \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        static_operation \\<tau> op \\<pi> oper;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         StaticOperationCall \\<tau> op params : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<sigma>\n 5. \\<And>\\<Gamma> a \\<tau> k op \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        typeop_type k op \\<tau> \\<sigma> \\<rho>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TypeOperationCall a k op \\<sigma> : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 6. \\<And>\\<Gamma> src \\<C> prop \\<D> \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        attribute \\<C> prop \\<D> \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AttributeCall src DotCall prop : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 7. \\<And>\\<Gamma> src \\<C> from role \\<D> end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_end \\<C> from role \\<D> end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationEndCall src DotCall from role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> assoc_end_type end = \\<sigma>\n 8. \\<And>\\<Gamma> src \\<C> from \\<A> \\<D> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        referred_by_association_class \\<C> from \\<A> \\<D>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassCall src DotCall from \\<A> : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_type \\<A> = \\<sigma>\n 9. \\<And>\\<Gamma> src \\<A> role end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_class_end \\<A> role end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassEndCall src DotCall role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_end_type end = \\<sigma>\n 10. \\<And>\\<Gamma> src \\<tau> params \\<pi> op k \\<sigma> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n         \\<And>\\<xi>.\n            \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n            \\<pi> = \\<xi>;\n         op_type op k \\<tau> \\<pi> \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          OperationCall src k op params : \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<sigma> = \\<sigma>'\nA total of 26 subgoals...", "case (VarT \\<Gamma> v \\<tau> \\<M>)"], ["proof (state)\nthis:\n  fmlookup \\<Gamma> v = Some \\<tau>\n  \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<M>\n\ngoal (26 subgoals):\n 1. \\<And>\\<Gamma> v \\<tau> \\<sigma>.\n       \\<lbrakk>fmlookup \\<Gamma> v = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 2. \\<And>\\<Gamma> a b \\<sigma> c \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           Boolean[1] = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E c : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E expr.If a b c : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<squnion> \\<rho> = \\<sigma>'\n 3. \\<And>\\<tau> op \\<sigma> \\<Gamma> \\<sigma>'.\n       \\<lbrakk>mataop_type \\<tau> op \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         MetaOperationCall \\<tau> op : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 4. \\<And>\\<Gamma> params \\<pi> \\<tau> op oper \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        static_operation \\<tau> op \\<pi> oper;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         StaticOperationCall \\<tau> op params : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<sigma>\n 5. \\<And>\\<Gamma> a \\<tau> k op \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        typeop_type k op \\<tau> \\<sigma> \\<rho>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TypeOperationCall a k op \\<sigma> : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 6. \\<And>\\<Gamma> src \\<C> prop \\<D> \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        attribute \\<C> prop \\<D> \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AttributeCall src DotCall prop : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 7. \\<And>\\<Gamma> src \\<C> from role \\<D> end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_end \\<C> from role \\<D> end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationEndCall src DotCall from role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> assoc_end_type end = \\<sigma>\n 8. \\<And>\\<Gamma> src \\<C> from \\<A> \\<D> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        referred_by_association_class \\<C> from \\<A> \\<D>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassCall src DotCall from \\<A> : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_type \\<A> = \\<sigma>\n 9. \\<And>\\<Gamma> src \\<A> role end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_class_end \\<A> role end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassEndCall src DotCall role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_end_type end = \\<sigma>\n 10. \\<And>\\<Gamma> src \\<tau> params \\<pi> op k \\<sigma> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n         \\<And>\\<xi>.\n            \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n            \\<pi> = \\<xi>;\n         op_type op k \\<tau> \\<pi> \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          OperationCall src k op params : \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<sigma> = \\<sigma>'\nA total of 26 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  fmlookup \\<Gamma> v = Some \\<tau>\n  \\<Gamma> \\<turnstile>\\<^sub>E Var v : \\<M>\n\ngoal (1 subgoal):\n 1. \\<tau> = \\<M>", "by auto"], ["proof (state)\nthis:\n  \\<tau> = \\<M>\n\ngoal (25 subgoals):\n 1. \\<And>\\<Gamma> a b \\<sigma> c \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           Boolean[1] = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E c : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E expr.If a b c : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<squnion> \\<rho> = \\<sigma>'\n 2. \\<And>\\<tau> op \\<sigma> \\<Gamma> \\<sigma>'.\n       \\<lbrakk>mataop_type \\<tau> op \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         MetaOperationCall \\<tau> op : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 3. \\<And>\\<Gamma> params \\<pi> \\<tau> op oper \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        static_operation \\<tau> op \\<pi> oper;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         StaticOperationCall \\<tau> op params : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<sigma>\n 4. \\<And>\\<Gamma> a \\<tau> k op \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        typeop_type k op \\<tau> \\<sigma> \\<rho>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TypeOperationCall a k op \\<sigma> : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 5. \\<And>\\<Gamma> src \\<C> prop \\<D> \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        attribute \\<C> prop \\<D> \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AttributeCall src DotCall prop : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 6. \\<And>\\<Gamma> src \\<C> from role \\<D> end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_end \\<C> from role \\<D> end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationEndCall src DotCall from role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> assoc_end_type end = \\<sigma>\n 7. \\<And>\\<Gamma> src \\<C> from \\<A> \\<D> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        referred_by_association_class \\<C> from \\<A> \\<D>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassCall src DotCall from \\<A> : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_type \\<A> = \\<sigma>\n 8. \\<And>\\<Gamma> src \\<A> role end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_class_end \\<A> role end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassEndCall src DotCall role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_end_type end = \\<sigma>\n 9. \\<And>\\<Gamma> src \\<tau> params \\<pi> op k \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        op_type op k \\<tau> \\<pi> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src k op params : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 10. \\<And>\\<Gamma> src \\<pi> elem \\<tau> \\<sigma>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n            Tuple \\<pi> = \\<sigma>;\n         fmlookup \\<pi> elem = Some \\<tau>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          TupleElementCall src DotCall elem : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> \\<tau> = \\<sigma>\nA total of 25 subgoals...", "next"], ["proof (state)\ngoal (25 subgoals):\n 1. \\<And>\\<Gamma> a b \\<sigma> c \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           Boolean[1] = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E c : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E expr.If a b c : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<squnion> \\<rho> = \\<sigma>'\n 2. \\<And>\\<tau> op \\<sigma> \\<Gamma> \\<sigma>'.\n       \\<lbrakk>mataop_type \\<tau> op \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         MetaOperationCall \\<tau> op : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 3. \\<And>\\<Gamma> params \\<pi> \\<tau> op oper \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        static_operation \\<tau> op \\<pi> oper;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         StaticOperationCall \\<tau> op params : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<sigma>\n 4. \\<And>\\<Gamma> a \\<tau> k op \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        typeop_type k op \\<tau> \\<sigma> \\<rho>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TypeOperationCall a k op \\<sigma> : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 5. \\<And>\\<Gamma> src \\<C> prop \\<D> \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        attribute \\<C> prop \\<D> \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AttributeCall src DotCall prop : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 6. \\<And>\\<Gamma> src \\<C> from role \\<D> end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_end \\<C> from role \\<D> end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationEndCall src DotCall from role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> assoc_end_type end = \\<sigma>\n 7. \\<And>\\<Gamma> src \\<C> from \\<A> \\<D> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        referred_by_association_class \\<C> from \\<A> \\<D>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassCall src DotCall from \\<A> : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_type \\<A> = \\<sigma>\n 8. \\<And>\\<Gamma> src \\<A> role end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_class_end \\<A> role end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassEndCall src DotCall role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_end_type end = \\<sigma>\n 9. \\<And>\\<Gamma> src \\<tau> params \\<pi> op k \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        op_type op k \\<tau> \\<pi> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src k op params : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 10. \\<And>\\<Gamma> src \\<pi> elem \\<tau> \\<sigma>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n            Tuple \\<pi> = \\<sigma>;\n         fmlookup \\<pi> elem = Some \\<tau>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          TupleElementCall src DotCall elem : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> \\<tau> = \\<sigma>\nA total of 25 subgoals...", "case (IfT \\<Gamma> a \\<tau> b \\<sigma> c \\<rho>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1]\n  \\<Gamma> \\<turnstile>\\<^sub>E a : ?\\<sigma> \\<Longrightarrow>\n  Boolean[1] = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>E \\<tau> : b\n  \\<Gamma> \\<turnstile>\\<^sub>E \\<tau> : ?\\<sigma> \\<Longrightarrow>\n  b = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>E \\<sigma> : c\n  \\<Gamma> \\<turnstile>\\<^sub>E \\<sigma> : ?\\<sigma> \\<Longrightarrow>\n  c = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>E expr.If a \\<tau> \\<sigma> : \\<rho>\n\ngoal (25 subgoals):\n 1. \\<And>\\<Gamma> a b \\<sigma> c \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           Boolean[1] = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>;\n        \\<And>\\<sigma>'.\n           \\<Gamma> \\<turnstile>\\<^sub>E b : \\<sigma>' \\<Longrightarrow>\n           \\<sigma> = \\<sigma>';\n        \\<Gamma> \\<turnstile>\\<^sub>E c : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E c : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E expr.If a b c : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<squnion> \\<rho> = \\<sigma>'\n 2. \\<And>\\<tau> op \\<sigma> \\<Gamma> \\<sigma>'.\n       \\<lbrakk>mataop_type \\<tau> op \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         MetaOperationCall \\<tau> op : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 3. \\<And>\\<Gamma> params \\<pi> \\<tau> op oper \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        static_operation \\<tau> op \\<pi> oper;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         StaticOperationCall \\<tau> op params : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<sigma>\n 4. \\<And>\\<Gamma> a \\<tau> k op \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        typeop_type k op \\<tau> \\<sigma> \\<rho>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TypeOperationCall a k op \\<sigma> : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 5. \\<And>\\<Gamma> src \\<C> prop \\<D> \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        attribute \\<C> prop \\<D> \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AttributeCall src DotCall prop : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 6. \\<And>\\<Gamma> src \\<C> from role \\<D> end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_end \\<C> from role \\<D> end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationEndCall src DotCall from role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> assoc_end_type end = \\<sigma>\n 7. \\<And>\\<Gamma> src \\<C> from \\<A> \\<D> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        referred_by_association_class \\<C> from \\<A> \\<D>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassCall src DotCall from \\<A> : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_type \\<A> = \\<sigma>\n 8. \\<And>\\<Gamma> src \\<A> role end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_class_end \\<A> role end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassEndCall src DotCall role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_end_type end = \\<sigma>\n 9. \\<And>\\<Gamma> src \\<tau> params \\<pi> op k \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        op_type op k \\<tau> \\<pi> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src k op params : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 10. \\<And>\\<Gamma> src \\<pi> elem \\<tau> \\<sigma>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n            Tuple \\<pi> = \\<sigma>;\n         fmlookup \\<pi> elem = Some \\<tau>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          TupleElementCall src DotCall elem : \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> \\<tau> = \\<sigma>\nA total of 25 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1]\n  \\<Gamma> \\<turnstile>\\<^sub>E a : ?\\<sigma> \\<Longrightarrow>\n  Boolean[1] = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>E \\<tau> : b\n  \\<Gamma> \\<turnstile>\\<^sub>E \\<tau> : ?\\<sigma> \\<Longrightarrow>\n  b = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>E \\<sigma> : c\n  \\<Gamma> \\<turnstile>\\<^sub>E \\<sigma> : ?\\<sigma> \\<Longrightarrow>\n  c = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>E expr.If a \\<tau> \\<sigma> : \\<rho>\n\ngoal (1 subgoal):\n 1. b \\<squnion> c = \\<rho>", "apply (insert IfT.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>E\n     expr.If a \\<tau> \\<sigma> : \\<rho> \\<Longrightarrow>\n    b \\<squnion> c = \\<rho>", "apply (erule IfTE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<rho>'.\n       \\<lbrakk>\\<rho> = \\<sigma> \\<squnion> \\<rho>';\n        \\<Gamma> \\<turnstile>\\<^sub>E a : Boolean[1];\n        \\<Gamma> \\<turnstile>\\<^sub>E \\<tau> : \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E \\<sigma> : \\<rho>'\\<rbrakk>\n       \\<Longrightarrow> b \\<squnion> c = \\<rho>", "by (simp add: IfT.hyps)"], ["proof (state)\nthis:\n  b \\<squnion> c = \\<rho>\n\ngoal (24 subgoals):\n 1. \\<And>\\<tau> op \\<sigma> \\<Gamma> \\<sigma>'.\n       \\<lbrakk>mataop_type \\<tau> op \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         MetaOperationCall \\<tau> op : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 2. \\<And>\\<Gamma> params \\<pi> \\<tau> op oper \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        static_operation \\<tau> op \\<pi> oper;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         StaticOperationCall \\<tau> op params : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<sigma>\n 3. \\<And>\\<Gamma> a \\<tau> k op \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        typeop_type k op \\<tau> \\<sigma> \\<rho>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TypeOperationCall a k op \\<sigma> : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 4. \\<And>\\<Gamma> src \\<C> prop \\<D> \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        attribute \\<C> prop \\<D> \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AttributeCall src DotCall prop : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 5. \\<And>\\<Gamma> src \\<C> from role \\<D> end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_end \\<C> from role \\<D> end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationEndCall src DotCall from role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> assoc_end_type end = \\<sigma>\n 6. \\<And>\\<Gamma> src \\<C> from \\<A> \\<D> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        referred_by_association_class \\<C> from \\<A> \\<D>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassCall src DotCall from \\<A> : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_type \\<A> = \\<sigma>\n 7. \\<And>\\<Gamma> src \\<A> role end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_class_end \\<A> role end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassEndCall src DotCall role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_end_type end = \\<sigma>\n 8. \\<And>\\<Gamma> src \\<tau> params \\<pi> op k \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        op_type op k \\<tau> \\<pi> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src k op params : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 9. \\<And>\\<Gamma> src \\<pi> elem \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           Tuple \\<pi> = \\<sigma>;\n        fmlookup \\<pi> elem = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TupleElementCall src DotCall elem : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 10. \\<And>\\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho> ys.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_ty;\n         \\<Gamma> ++\\<^sub>f\n         fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n          \\<turnstile>\\<^sub>E body : \\<rho>;\n         \\<And>\\<sigma>.\n            \\<Gamma> ++\\<^sub>f\n            fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n             \\<turnstile>\\<^sub>E body : \\<sigma> \\<Longrightarrow>\n            \\<rho> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>I\n          (src, its, Some its_ty, body) : ys\\<rbrakk>\n        \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys\nA total of 24 subgoals...", "next"], ["proof (state)\ngoal (24 subgoals):\n 1. \\<And>\\<tau> op \\<sigma> \\<Gamma> \\<sigma>'.\n       \\<lbrakk>mataop_type \\<tau> op \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         MetaOperationCall \\<tau> op : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 2. \\<And>\\<Gamma> params \\<pi> \\<tau> op oper \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        static_operation \\<tau> op \\<pi> oper;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         StaticOperationCall \\<tau> op params : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<sigma>\n 3. \\<And>\\<Gamma> a \\<tau> k op \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        typeop_type k op \\<tau> \\<sigma> \\<rho>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TypeOperationCall a k op \\<sigma> : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 4. \\<And>\\<Gamma> src \\<C> prop \\<D> \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        attribute \\<C> prop \\<D> \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AttributeCall src DotCall prop : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 5. \\<And>\\<Gamma> src \\<C> from role \\<D> end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_end \\<C> from role \\<D> end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationEndCall src DotCall from role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> assoc_end_type end = \\<sigma>\n 6. \\<And>\\<Gamma> src \\<C> from \\<A> \\<D> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        referred_by_association_class \\<C> from \\<A> \\<D>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassCall src DotCall from \\<A> : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_type \\<A> = \\<sigma>\n 7. \\<And>\\<Gamma> src \\<A> role end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_class_end \\<A> role end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassEndCall src DotCall role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_end_type end = \\<sigma>\n 8. \\<And>\\<Gamma> src \\<tau> params \\<pi> op k \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        op_type op k \\<tau> \\<pi> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src k op params : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 9. \\<And>\\<Gamma> src \\<pi> elem \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           Tuple \\<pi> = \\<sigma>;\n        fmlookup \\<pi> elem = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TupleElementCall src DotCall elem : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 10. \\<And>\\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho> ys.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_ty;\n         \\<Gamma> ++\\<^sub>f\n         fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n          \\<turnstile>\\<^sub>E body : \\<rho>;\n         \\<And>\\<sigma>.\n            \\<Gamma> ++\\<^sub>f\n            fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n             \\<turnstile>\\<^sub>E body : \\<sigma> \\<Longrightarrow>\n            \\<rho> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>I\n          (src, its, Some its_ty, body) : ys\\<rbrakk>\n        \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys\nA total of 24 subgoals...", "case (MetaOperationCallT \\<tau> op \\<sigma> \\<Gamma>)"], ["proof (state)\nthis:\n  mataop_type \\<tau> op \\<sigma>'__\n  \\<Gamma> \\<turnstile>\\<^sub>E MetaOperationCall \\<tau> op : \\<sigma>\n\ngoal (24 subgoals):\n 1. \\<And>\\<tau> op \\<sigma> \\<Gamma> \\<sigma>'.\n       \\<lbrakk>mataop_type \\<tau> op \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         MetaOperationCall \\<tau> op : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 2. \\<And>\\<Gamma> params \\<pi> \\<tau> op oper \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        static_operation \\<tau> op \\<pi> oper;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         StaticOperationCall \\<tau> op params : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<sigma>\n 3. \\<And>\\<Gamma> a \\<tau> k op \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        typeop_type k op \\<tau> \\<sigma> \\<rho>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TypeOperationCall a k op \\<sigma> : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 4. \\<And>\\<Gamma> src \\<C> prop \\<D> \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        attribute \\<C> prop \\<D> \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AttributeCall src DotCall prop : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 5. \\<And>\\<Gamma> src \\<C> from role \\<D> end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_end \\<C> from role \\<D> end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationEndCall src DotCall from role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> assoc_end_type end = \\<sigma>\n 6. \\<And>\\<Gamma> src \\<C> from \\<A> \\<D> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        referred_by_association_class \\<C> from \\<A> \\<D>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassCall src DotCall from \\<A> : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_type \\<A> = \\<sigma>\n 7. \\<And>\\<Gamma> src \\<A> role end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_class_end \\<A> role end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassEndCall src DotCall role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_end_type end = \\<sigma>\n 8. \\<And>\\<Gamma> src \\<tau> params \\<pi> op k \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        op_type op k \\<tau> \\<pi> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src k op params : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 9. \\<And>\\<Gamma> src \\<pi> elem \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           Tuple \\<pi> = \\<sigma>;\n        fmlookup \\<pi> elem = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TupleElementCall src DotCall elem : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 10. \\<And>\\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho> ys.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_ty;\n         \\<Gamma> ++\\<^sub>f\n         fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n          \\<turnstile>\\<^sub>E body : \\<rho>;\n         \\<And>\\<sigma>.\n            \\<Gamma> ++\\<^sub>f\n            fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n             \\<turnstile>\\<^sub>E body : \\<sigma> \\<Longrightarrow>\n            \\<rho> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>I\n          (src, its, Some its_ty, body) : ys\\<rbrakk>\n        \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys\nA total of 24 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  mataop_type \\<tau> op \\<sigma>'__\n  \\<Gamma> \\<turnstile>\\<^sub>E MetaOperationCall \\<tau> op : \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<sigma>'__ = \\<sigma>", "by (metis MetaOperationCallTE mataop_type.cases)"], ["proof (state)\nthis:\n  \\<sigma>'__ = \\<sigma>\n\ngoal (23 subgoals):\n 1. \\<And>\\<Gamma> params \\<pi> \\<tau> op oper \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        static_operation \\<tau> op \\<pi> oper;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         StaticOperationCall \\<tau> op params : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<sigma>\n 2. \\<And>\\<Gamma> a \\<tau> k op \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        typeop_type k op \\<tau> \\<sigma> \\<rho>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TypeOperationCall a k op \\<sigma> : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 3. \\<And>\\<Gamma> src \\<C> prop \\<D> \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        attribute \\<C> prop \\<D> \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AttributeCall src DotCall prop : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 4. \\<And>\\<Gamma> src \\<C> from role \\<D> end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_end \\<C> from role \\<D> end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationEndCall src DotCall from role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> assoc_end_type end = \\<sigma>\n 5. \\<And>\\<Gamma> src \\<C> from \\<A> \\<D> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        referred_by_association_class \\<C> from \\<A> \\<D>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassCall src DotCall from \\<A> : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_type \\<A> = \\<sigma>\n 6. \\<And>\\<Gamma> src \\<A> role end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_class_end \\<A> role end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassEndCall src DotCall role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_end_type end = \\<sigma>\n 7. \\<And>\\<Gamma> src \\<tau> params \\<pi> op k \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        op_type op k \\<tau> \\<pi> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src k op params : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 8. \\<And>\\<Gamma> src \\<pi> elem \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           Tuple \\<pi> = \\<sigma>;\n        fmlookup \\<pi> elem = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TupleElementCall src DotCall elem : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 9. \\<And>\\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho> ys.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_ty;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n         \\<turnstile>\\<^sub>E body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n            \\<turnstile>\\<^sub>E body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, Some its_ty, body) : ys\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys\n 10. \\<And>\\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma>\n        \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty,\n                   expr.Let res (Some res_t) res_init body) :\n                  (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n             ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         \\<rho> \\<le> res_t;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          IterateCall src ArrowCall its its_ty res (Some res_t) res_init\n           body :\n          \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<rho> = \\<sigma>'\nA total of 23 subgoals...", "next"], ["proof (state)\ngoal (23 subgoals):\n 1. \\<And>\\<Gamma> params \\<pi> \\<tau> op oper \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        static_operation \\<tau> op \\<pi> oper;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         StaticOperationCall \\<tau> op params : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<sigma>\n 2. \\<And>\\<Gamma> a \\<tau> k op \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        typeop_type k op \\<tau> \\<sigma> \\<rho>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TypeOperationCall a k op \\<sigma> : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 3. \\<And>\\<Gamma> src \\<C> prop \\<D> \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        attribute \\<C> prop \\<D> \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AttributeCall src DotCall prop : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 4. \\<And>\\<Gamma> src \\<C> from role \\<D> end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_end \\<C> from role \\<D> end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationEndCall src DotCall from role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> assoc_end_type end = \\<sigma>\n 5. \\<And>\\<Gamma> src \\<C> from \\<A> \\<D> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        referred_by_association_class \\<C> from \\<A> \\<D>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassCall src DotCall from \\<A> : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_type \\<A> = \\<sigma>\n 6. \\<And>\\<Gamma> src \\<A> role end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_class_end \\<A> role end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassEndCall src DotCall role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_end_type end = \\<sigma>\n 7. \\<And>\\<Gamma> src \\<tau> params \\<pi> op k \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        op_type op k \\<tau> \\<pi> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src k op params : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 8. \\<And>\\<Gamma> src \\<pi> elem \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           Tuple \\<pi> = \\<sigma>;\n        fmlookup \\<pi> elem = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TupleElementCall src DotCall elem : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 9. \\<And>\\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho> ys.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_ty;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n         \\<turnstile>\\<^sub>E body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n            \\<turnstile>\\<^sub>E body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, Some its_ty, body) : ys\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys\n 10. \\<And>\\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma>\n        \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty,\n                   expr.Let res (Some res_t) res_init body) :\n                  (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n             ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         \\<rho> \\<le> res_t;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          IterateCall src ArrowCall its its_ty res (Some res_t) res_init\n           body :\n          \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<rho> = \\<sigma>'\nA total of 23 subgoals...", "case (StaticOperationCallT \\<tau> op \\<pi> oper \\<Gamma> as)"], ["proof (state)\nthis:\n  \\<tau> \\<turnstile>\\<^sub>L op : \\<pi>\n  \\<tau> \\<turnstile>\\<^sub>L op : ?\\<xi> \\<Longrightarrow> \\<pi> = ?\\<xi>\n  static_operation oper \\<Gamma> \\<pi> as\n  \\<tau> \\<turnstile>\\<^sub>E\n   StaticOperationCall oper \\<Gamma> op : \\<sigma>\n\ngoal (23 subgoals):\n 1. \\<And>\\<Gamma> params \\<pi> \\<tau> op oper \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        static_operation \\<tau> op \\<pi> oper;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         StaticOperationCall \\<tau> op params : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> oper_type oper = \\<sigma>\n 2. \\<And>\\<Gamma> a \\<tau> k op \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        typeop_type k op \\<tau> \\<sigma> \\<rho>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TypeOperationCall a k op \\<sigma> : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 3. \\<And>\\<Gamma> src \\<C> prop \\<D> \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        attribute \\<C> prop \\<D> \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AttributeCall src DotCall prop : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 4. \\<And>\\<Gamma> src \\<C> from role \\<D> end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_end \\<C> from role \\<D> end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationEndCall src DotCall from role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> assoc_end_type end = \\<sigma>\n 5. \\<And>\\<Gamma> src \\<C> from \\<A> \\<D> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        referred_by_association_class \\<C> from \\<A> \\<D>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassCall src DotCall from \\<A> : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_type \\<A> = \\<sigma>\n 6. \\<And>\\<Gamma> src \\<A> role end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_class_end \\<A> role end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassEndCall src DotCall role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_end_type end = \\<sigma>\n 7. \\<And>\\<Gamma> src \\<tau> params \\<pi> op k \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        op_type op k \\<tau> \\<pi> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src k op params : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 8. \\<And>\\<Gamma> src \\<pi> elem \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           Tuple \\<pi> = \\<sigma>;\n        fmlookup \\<pi> elem = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TupleElementCall src DotCall elem : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 9. \\<And>\\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho> ys.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_ty;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n         \\<turnstile>\\<^sub>E body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n            \\<turnstile>\\<^sub>E body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, Some its_ty, body) : ys\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys\n 10. \\<And>\\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma>\n        \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty,\n                   expr.Let res (Some res_t) res_init body) :\n                  (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n             ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         \\<rho> \\<le> res_t;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          IterateCall src ArrowCall its its_ty res (Some res_t) res_init\n           body :\n          \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<rho> = \\<sigma>'\nA total of 23 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<tau> \\<turnstile>\\<^sub>L op : \\<pi>\n  \\<tau> \\<turnstile>\\<^sub>L op : ?\\<xi> \\<Longrightarrow> \\<pi> = ?\\<xi>\n  static_operation oper \\<Gamma> \\<pi> as\n  \\<tau> \\<turnstile>\\<^sub>E\n   StaticOperationCall oper \\<Gamma> op : \\<sigma>\n\ngoal (1 subgoal):\n 1. oper_type as = \\<sigma>", "apply (insert StaticOperationCallT.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<turnstile>\\<^sub>E\n     StaticOperationCall oper \\<Gamma> op : \\<sigma> \\<Longrightarrow>\n    oper_type as = \\<sigma>", "apply (erule StaticOperationCallTE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<pi> opera.\n       \\<lbrakk>\\<sigma> = oper_type opera;\n        \\<tau> \\<turnstile>\\<^sub>L op : \\<pi>;\n        static_operation oper \\<Gamma> \\<pi> opera\\<rbrakk>\n       \\<Longrightarrow> oper_type as = \\<sigma>", "using StaticOperationCallT.hyps static_operation_det"], ["proof (prove)\nusing this:\n  \\<tau> \\<turnstile>\\<^sub>L op : \\<pi>\n  \\<tau> \\<turnstile>\\<^sub>L op : ?\\<xi> \\<Longrightarrow> \\<pi> = ?\\<xi>\n  static_operation oper \\<Gamma> \\<pi> as\n  \\<lbrakk>static_operation ?\\<tau> ?name ?\\<pi> ?oper\\<^sub>1;\n   static_operation ?\\<tau> ?name ?\\<pi> ?oper\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?oper\\<^sub>1 = ?oper\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi> opera.\n       \\<lbrakk>\\<sigma> = oper_type opera;\n        \\<tau> \\<turnstile>\\<^sub>L op : \\<pi>;\n        static_operation oper \\<Gamma> \\<pi> opera\\<rbrakk>\n       \\<Longrightarrow> oper_type as = \\<sigma>", "by blast"], ["proof (state)\nthis:\n  oper_type as = \\<sigma>\n\ngoal (22 subgoals):\n 1. \\<And>\\<Gamma> a \\<tau> k op \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        typeop_type k op \\<tau> \\<sigma> \\<rho>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TypeOperationCall a k op \\<sigma> : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 2. \\<And>\\<Gamma> src \\<C> prop \\<D> \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        attribute \\<C> prop \\<D> \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AttributeCall src DotCall prop : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 3. \\<And>\\<Gamma> src \\<C> from role \\<D> end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_end \\<C> from role \\<D> end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationEndCall src DotCall from role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> assoc_end_type end = \\<sigma>\n 4. \\<And>\\<Gamma> src \\<C> from \\<A> \\<D> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        referred_by_association_class \\<C> from \\<A> \\<D>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassCall src DotCall from \\<A> : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_type \\<A> = \\<sigma>\n 5. \\<And>\\<Gamma> src \\<A> role end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_class_end \\<A> role end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassEndCall src DotCall role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_end_type end = \\<sigma>\n 6. \\<And>\\<Gamma> src \\<tau> params \\<pi> op k \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        op_type op k \\<tau> \\<pi> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src k op params : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 7. \\<And>\\<Gamma> src \\<pi> elem \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           Tuple \\<pi> = \\<sigma>;\n        fmlookup \\<pi> elem = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TupleElementCall src DotCall elem : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 8. \\<And>\\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho> ys.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_ty;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n         \\<turnstile>\\<^sub>E body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n            \\<turnstile>\\<^sub>E body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, Some its_ty, body) : ys\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys\n 9. \\<And>\\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma>\n       \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty,\n                  expr.Let res (Some res_t) res_init body) :\n                 (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n            ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> res_t;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IterateCall src ArrowCall its its_ty res (Some res_t) res_init\n          body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<sigma> = \\<sigma>'\nA total of 22 subgoals...", "next"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>\\<Gamma> a \\<tau> k op \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        typeop_type k op \\<tau> \\<sigma> \\<rho>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TypeOperationCall a k op \\<sigma> : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 2. \\<And>\\<Gamma> src \\<C> prop \\<D> \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        attribute \\<C> prop \\<D> \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AttributeCall src DotCall prop : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 3. \\<And>\\<Gamma> src \\<C> from role \\<D> end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_end \\<C> from role \\<D> end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationEndCall src DotCall from role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> assoc_end_type end = \\<sigma>\n 4. \\<And>\\<Gamma> src \\<C> from \\<A> \\<D> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        referred_by_association_class \\<C> from \\<A> \\<D>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassCall src DotCall from \\<A> : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_type \\<A> = \\<sigma>\n 5. \\<And>\\<Gamma> src \\<A> role end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_class_end \\<A> role end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassEndCall src DotCall role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_end_type end = \\<sigma>\n 6. \\<And>\\<Gamma> src \\<tau> params \\<pi> op k \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        op_type op k \\<tau> \\<pi> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src k op params : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 7. \\<And>\\<Gamma> src \\<pi> elem \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           Tuple \\<pi> = \\<sigma>;\n        fmlookup \\<pi> elem = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TupleElementCall src DotCall elem : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 8. \\<And>\\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho> ys.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_ty;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n         \\<turnstile>\\<^sub>E body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n            \\<turnstile>\\<^sub>E body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, Some its_ty, body) : ys\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys\n 9. \\<And>\\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma>\n       \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty,\n                  expr.Let res (Some res_t) res_init body) :\n                 (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n            ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> res_t;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IterateCall src ArrowCall its its_ty res (Some res_t) res_init\n          body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<sigma> = \\<sigma>'\nA total of 22 subgoals...", "case (TypeOperationCallT \\<Gamma> a \\<tau> op \\<sigma> \\<rho>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>\n  \\<Gamma> \\<turnstile>\\<^sub>E a : ?\\<sigma> \\<Longrightarrow>\n  \\<tau> = ?\\<sigma>\n  typeop_type op \\<sigma>'__ \\<tau> \\<rho> \\<rho>_\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   TypeOperationCall a op \\<sigma>'__ \\<rho> : \\<sigma>\n\ngoal (22 subgoals):\n 1. \\<And>\\<Gamma> a \\<tau> k op \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E a : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        typeop_type k op \\<tau> \\<sigma> \\<rho>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TypeOperationCall a k op \\<sigma> : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 2. \\<And>\\<Gamma> src \\<C> prop \\<D> \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        attribute \\<C> prop \\<D> \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AttributeCall src DotCall prop : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 3. \\<And>\\<Gamma> src \\<C> from role \\<D> end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_end \\<C> from role \\<D> end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationEndCall src DotCall from role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> assoc_end_type end = \\<sigma>\n 4. \\<And>\\<Gamma> src \\<C> from \\<A> \\<D> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        referred_by_association_class \\<C> from \\<A> \\<D>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassCall src DotCall from \\<A> : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_type \\<A> = \\<sigma>\n 5. \\<And>\\<Gamma> src \\<A> role end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_class_end \\<A> role end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassEndCall src DotCall role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_end_type end = \\<sigma>\n 6. \\<And>\\<Gamma> src \\<tau> params \\<pi> op k \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        op_type op k \\<tau> \\<pi> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src k op params : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 7. \\<And>\\<Gamma> src \\<pi> elem \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           Tuple \\<pi> = \\<sigma>;\n        fmlookup \\<pi> elem = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TupleElementCall src DotCall elem : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 8. \\<And>\\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho> ys.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_ty;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n         \\<turnstile>\\<^sub>E body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n            \\<turnstile>\\<^sub>E body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, Some its_ty, body) : ys\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys\n 9. \\<And>\\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma>\n       \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty,\n                  expr.Let res (Some res_t) res_init body) :\n                 (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n            ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> res_t;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IterateCall src ArrowCall its its_ty res (Some res_t) res_init\n          body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<sigma> = \\<sigma>'\nA total of 22 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>E a : \\<tau>\n  \\<Gamma> \\<turnstile>\\<^sub>E a : ?\\<sigma> \\<Longrightarrow>\n  \\<tau> = ?\\<sigma>\n  typeop_type op \\<sigma>'__ \\<tau> \\<rho> \\<rho>_\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   TypeOperationCall a op \\<sigma>'__ \\<rho> : \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<rho>_ = \\<sigma>", "by (metis TypeOperationCallTE typeop_type_det)"], ["proof (state)\nthis:\n  \\<rho>_ = \\<sigma>\n\ngoal (21 subgoals):\n 1. \\<And>\\<Gamma> src \\<C> prop \\<D> \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        attribute \\<C> prop \\<D> \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AttributeCall src DotCall prop : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 2. \\<And>\\<Gamma> src \\<C> from role \\<D> end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_end \\<C> from role \\<D> end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationEndCall src DotCall from role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> assoc_end_type end = \\<sigma>\n 3. \\<And>\\<Gamma> src \\<C> from \\<A> \\<D> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        referred_by_association_class \\<C> from \\<A> \\<D>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassCall src DotCall from \\<A> : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_type \\<A> = \\<sigma>\n 4. \\<And>\\<Gamma> src \\<A> role end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_class_end \\<A> role end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassEndCall src DotCall role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_end_type end = \\<sigma>\n 5. \\<And>\\<Gamma> src \\<tau> params \\<pi> op k \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        op_type op k \\<tau> \\<pi> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src k op params : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 6. \\<And>\\<Gamma> src \\<pi> elem \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           Tuple \\<pi> = \\<sigma>;\n        fmlookup \\<pi> elem = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TupleElementCall src DotCall elem : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 7. \\<And>\\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho> ys.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_ty;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n         \\<turnstile>\\<^sub>E body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n            \\<turnstile>\\<^sub>E body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, Some its_ty, body) : ys\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys\n 8. \\<And>\\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma>\n       \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty,\n                  expr.Let res (Some res_t) res_init body) :\n                 (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n            ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> res_t;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IterateCall src ArrowCall its its_ty res (Some res_t) res_init\n          body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n        \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         length its \\<le> 1; to_single_type \\<rho> \\<le> \\<sigma>;\n         to_unique_collection \\<tau> \\<upsilon>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          ClosureIteratorCall src ArrowCall its its_ty body :\n          \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<upsilon> = \\<sigma>'\nA total of 21 subgoals...", "next"], ["proof (state)\ngoal (21 subgoals):\n 1. \\<And>\\<Gamma> src \\<C> prop \\<D> \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        attribute \\<C> prop \\<D> \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AttributeCall src DotCall prop : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 2. \\<And>\\<Gamma> src \\<C> from role \\<D> end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_end \\<C> from role \\<D> end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationEndCall src DotCall from role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> assoc_end_type end = \\<sigma>\n 3. \\<And>\\<Gamma> src \\<C> from \\<A> \\<D> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        referred_by_association_class \\<C> from \\<A> \\<D>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassCall src DotCall from \\<A> : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_type \\<A> = \\<sigma>\n 4. \\<And>\\<Gamma> src \\<A> role end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_class_end \\<A> role end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassEndCall src DotCall role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_end_type end = \\<sigma>\n 5. \\<And>\\<Gamma> src \\<tau> params \\<pi> op k \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        op_type op k \\<tau> \\<pi> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src k op params : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 6. \\<And>\\<Gamma> src \\<pi> elem \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           Tuple \\<pi> = \\<sigma>;\n        fmlookup \\<pi> elem = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TupleElementCall src DotCall elem : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 7. \\<And>\\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho> ys.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_ty;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n         \\<turnstile>\\<^sub>E body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n            \\<turnstile>\\<^sub>E body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, Some its_ty, body) : ys\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys\n 8. \\<And>\\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma>\n       \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty,\n                  expr.Let res (Some res_t) res_init body) :\n                 (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n            ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> res_t;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IterateCall src ArrowCall its its_ty res (Some res_t) res_init\n          body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n        \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         length its \\<le> 1; to_single_type \\<rho> \\<le> \\<sigma>;\n         to_unique_collection \\<tau> \\<upsilon>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          ClosureIteratorCall src ArrowCall its its_ty body :\n          \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<upsilon> = \\<sigma>'\nA total of 21 subgoals...", "case (AttributeCallT \\<Gamma> src \\<tau> \\<C> \"prop\" \\<D> \\<sigma>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>E src : \\<langle>\\<tau>\\<rangle>\\<^sub>\\<T>[1]\n  \\<Gamma> \\<turnstile>\\<^sub>E src : ?\\<sigma> \\<Longrightarrow>\n  \\<langle>\\<tau>\\<rangle>\\<^sub>\\<T>[1] = ?\\<sigma>\n  attribute \\<tau> \\<C> prop \\<D>\n  \\<Gamma> \\<turnstile>\\<^sub>E AttributeCall src DotCall \\<C> : \\<sigma>\n\ngoal (21 subgoals):\n 1. \\<And>\\<Gamma> src \\<C> prop \\<D> \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        attribute \\<C> prop \\<D> \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AttributeCall src DotCall prop : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 2. \\<And>\\<Gamma> src \\<C> from role \\<D> end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_end \\<C> from role \\<D> end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationEndCall src DotCall from role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> assoc_end_type end = \\<sigma>\n 3. \\<And>\\<Gamma> src \\<C> from \\<A> \\<D> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        referred_by_association_class \\<C> from \\<A> \\<D>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassCall src DotCall from \\<A> : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_type \\<A> = \\<sigma>\n 4. \\<And>\\<Gamma> src \\<A> role end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_class_end \\<A> role end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassEndCall src DotCall role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_end_type end = \\<sigma>\n 5. \\<And>\\<Gamma> src \\<tau> params \\<pi> op k \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        op_type op k \\<tau> \\<pi> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src k op params : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 6. \\<And>\\<Gamma> src \\<pi> elem \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           Tuple \\<pi> = \\<sigma>;\n        fmlookup \\<pi> elem = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TupleElementCall src DotCall elem : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 7. \\<And>\\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho> ys.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_ty;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n         \\<turnstile>\\<^sub>E body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n            \\<turnstile>\\<^sub>E body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, Some its_ty, body) : ys\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys\n 8. \\<And>\\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma>\n       \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty,\n                  expr.Let res (Some res_t) res_init body) :\n                 (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n            ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> res_t;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IterateCall src ArrowCall its its_ty res (Some res_t) res_init\n          body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n        \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         length its \\<le> 1; to_single_type \\<rho> \\<le> \\<sigma>;\n         to_unique_collection \\<tau> \\<upsilon>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          ClosureIteratorCall src ArrowCall its its_ty body :\n          \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<upsilon> = \\<sigma>'\nA total of 21 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<D> = \\<sigma>", "apply (insert AttributeCallT.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>E\n     AttributeCall src DotCall \\<C> : \\<sigma> \\<Longrightarrow>\n    \\<D> = \\<sigma>", "apply (erule AttributeCallTE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<C>' \\<D>'.\n       \\<lbrakk>DotCall = DotCall;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         src : \\<langle>\\<C>'\\<rangle>\\<^sub>\\<T>[1];\n        attribute \\<C>' \\<C> \\<D>' \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<D> = \\<sigma>", "using AttributeCallT.hyps attribute_det"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>E src : \\<langle>\\<tau>\\<rangle>\\<^sub>\\<T>[1]\n  \\<Gamma> \\<turnstile>\\<^sub>E src : ?\\<sigma> \\<Longrightarrow>\n  \\<langle>\\<tau>\\<rangle>\\<^sub>\\<T>[1] = ?\\<sigma>\n  attribute \\<tau> \\<C> prop \\<D>\n  \\<lbrakk>attribute ?\\<C> ?attr ?\\<D>\\<^sub>1 ?\\<tau>\\<^sub>1;\n   attribute ?\\<C> ?attr ?\\<D>\\<^sub>2 ?\\<tau>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?\\<D>\\<^sub>1 = ?\\<D>\\<^sub>2 \\<and>\n                    ?\\<tau>\\<^sub>1 = ?\\<tau>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>\\<C>' \\<D>'.\n       \\<lbrakk>DotCall = DotCall;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         src : \\<langle>\\<C>'\\<rangle>\\<^sub>\\<T>[1];\n        attribute \\<C>' \\<C> \\<D>' \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<D> = \\<sigma>", "by blast"], ["proof (state)\nthis:\n  \\<D> = \\<sigma>\n\ngoal (20 subgoals):\n 1. \\<And>\\<Gamma> src \\<C> from role \\<D> end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_end \\<C> from role \\<D> end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationEndCall src DotCall from role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> assoc_end_type end = \\<sigma>\n 2. \\<And>\\<Gamma> src \\<C> from \\<A> \\<D> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        referred_by_association_class \\<C> from \\<A> \\<D>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassCall src DotCall from \\<A> : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_type \\<A> = \\<sigma>\n 3. \\<And>\\<Gamma> src \\<A> role end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_class_end \\<A> role end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassEndCall src DotCall role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_end_type end = \\<sigma>\n 4. \\<And>\\<Gamma> src \\<tau> params \\<pi> op k \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        op_type op k \\<tau> \\<pi> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src k op params : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 5. \\<And>\\<Gamma> src \\<pi> elem \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           Tuple \\<pi> = \\<sigma>;\n        fmlookup \\<pi> elem = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TupleElementCall src DotCall elem : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 6. \\<And>\\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho> ys.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_ty;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n         \\<turnstile>\\<^sub>E body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n            \\<turnstile>\\<^sub>E body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, Some its_ty, body) : ys\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys\n 7. \\<And>\\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma>\n       \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty,\n                  expr.Let res (Some res_t) res_init body) :\n                 (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n            ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> res_t;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IterateCall src ArrowCall its its_ty res (Some res_t) res_init\n          body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_single_type \\<rho> \\<le> \\<sigma>;\n        to_unique_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ClosureIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n        \\<phi> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n         update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          CollectIteratorCall src ArrowCall its its_ty body :\n          \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<phi> = \\<sigma>'\nA total of 20 subgoals...", "next"], ["proof (state)\ngoal (20 subgoals):\n 1. \\<And>\\<Gamma> src \\<C> from role \\<D> end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_end \\<C> from role \\<D> end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationEndCall src DotCall from role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> assoc_end_type end = \\<sigma>\n 2. \\<And>\\<Gamma> src \\<C> from \\<A> \\<D> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        referred_by_association_class \\<C> from \\<A> \\<D>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassCall src DotCall from \\<A> : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_type \\<A> = \\<sigma>\n 3. \\<And>\\<Gamma> src \\<A> role end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_class_end \\<A> role end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassEndCall src DotCall role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_end_type end = \\<sigma>\n 4. \\<And>\\<Gamma> src \\<tau> params \\<pi> op k \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        op_type op k \\<tau> \\<pi> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src k op params : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 5. \\<And>\\<Gamma> src \\<pi> elem \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           Tuple \\<pi> = \\<sigma>;\n        fmlookup \\<pi> elem = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TupleElementCall src DotCall elem : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 6. \\<And>\\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho> ys.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_ty;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n         \\<turnstile>\\<^sub>E body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n            \\<turnstile>\\<^sub>E body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, Some its_ty, body) : ys\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys\n 7. \\<And>\\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma>\n       \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty,\n                  expr.Let res (Some res_t) res_init body) :\n                 (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n            ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> res_t;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IterateCall src ArrowCall its its_ty res (Some res_t) res_init\n          body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_single_type \\<rho> \\<le> \\<sigma>;\n        to_unique_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ClosureIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n        \\<phi> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n         update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          CollectIteratorCall src ArrowCall its its_ty body :\n          \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<phi> = \\<sigma>'\nA total of 20 subgoals...", "case (AssociationEndCallT \\<Gamma> src \\<C> \"from\" role \\<D> \"end\")"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>E src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1]\n  \\<Gamma> \\<turnstile>\\<^sub>E src : ?\\<sigma> \\<Longrightarrow>\n  \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = ?\\<sigma>\n  association_end \\<C> from role \\<D> end\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   AssociationEndCall src DotCall from role : \\<sigma>\n\ngoal (20 subgoals):\n 1. \\<And>\\<Gamma> src \\<C> from role \\<D> end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_end \\<C> from role \\<D> end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationEndCall src DotCall from role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> assoc_end_type end = \\<sigma>\n 2. \\<And>\\<Gamma> src \\<C> from \\<A> \\<D> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        referred_by_association_class \\<C> from \\<A> \\<D>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassCall src DotCall from \\<A> : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_type \\<A> = \\<sigma>\n 3. \\<And>\\<Gamma> src \\<A> role end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_class_end \\<A> role end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassEndCall src DotCall role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_end_type end = \\<sigma>\n 4. \\<And>\\<Gamma> src \\<tau> params \\<pi> op k \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        op_type op k \\<tau> \\<pi> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src k op params : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 5. \\<And>\\<Gamma> src \\<pi> elem \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           Tuple \\<pi> = \\<sigma>;\n        fmlookup \\<pi> elem = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TupleElementCall src DotCall elem : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 6. \\<And>\\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho> ys.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_ty;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n         \\<turnstile>\\<^sub>E body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n            \\<turnstile>\\<^sub>E body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, Some its_ty, body) : ys\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys\n 7. \\<And>\\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma>\n       \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty,\n                  expr.Let res (Some res_t) res_init body) :\n                 (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n            ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> res_t;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IterateCall src ArrowCall its its_ty res (Some res_t) res_init\n          body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_single_type \\<rho> \\<le> \\<sigma>;\n        to_unique_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ClosureIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n        \\<phi> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n         update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          CollectIteratorCall src ArrowCall its its_ty body :\n          \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<phi> = \\<sigma>'\nA total of 20 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. assoc_end_type end = \\<sigma>", "apply (insert AssociationEndCallT.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>E\n     AssociationEndCall src DotCall from role : \\<sigma> \\<Longrightarrow>\n    assoc_end_type end = \\<sigma>", "apply (erule AssociationEndCallTE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<C> \\<D> enda.\n       \\<lbrakk>DotCall = DotCall; \\<sigma> = assoc_end_type enda;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        association_end \\<C> from role \\<D> enda\\<rbrakk>\n       \\<Longrightarrow> assoc_end_type end = \\<sigma>", "using AssociationEndCallT.hyps association_end_det"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>E src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1]\n  \\<Gamma> \\<turnstile>\\<^sub>E src : ?\\<sigma> \\<Longrightarrow>\n  \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = ?\\<sigma>\n  association_end \\<C> from role \\<D> end\n  \\<lbrakk>association_end ?\\<C> ?from ?role ?\\<D>\\<^sub>1 ?end\\<^sub>1;\n   association_end ?\\<C> ?from ?role ?\\<D>\\<^sub>2 ?end\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?\\<D>\\<^sub>1 = ?\\<D>\\<^sub>2 \\<and>\n                    ?end\\<^sub>1 = ?end\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>\\<C> \\<D> enda.\n       \\<lbrakk>DotCall = DotCall; \\<sigma> = assoc_end_type enda;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        association_end \\<C> from role \\<D> enda\\<rbrakk>\n       \\<Longrightarrow> assoc_end_type end = \\<sigma>", "by blast"], ["proof (state)\nthis:\n  assoc_end_type end = \\<sigma>\n\ngoal (19 subgoals):\n 1. \\<And>\\<Gamma> src \\<C> from \\<A> \\<D> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        referred_by_association_class \\<C> from \\<A> \\<D>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassCall src DotCall from \\<A> : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_type \\<A> = \\<sigma>\n 2. \\<And>\\<Gamma> src \\<A> role end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_class_end \\<A> role end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassEndCall src DotCall role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_end_type end = \\<sigma>\n 3. \\<And>\\<Gamma> src \\<tau> params \\<pi> op k \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        op_type op k \\<tau> \\<pi> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src k op params : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 4. \\<And>\\<Gamma> src \\<pi> elem \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           Tuple \\<pi> = \\<sigma>;\n        fmlookup \\<pi> elem = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TupleElementCall src DotCall elem : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 5. \\<And>\\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho> ys.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_ty;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n         \\<turnstile>\\<^sub>E body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n            \\<turnstile>\\<^sub>E body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, Some its_ty, body) : ys\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys\n 6. \\<And>\\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma>\n       \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty,\n                  expr.Let res (Some res_t) res_init body) :\n                 (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n            ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> res_t;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IterateCall src ArrowCall its its_ty res (Some res_t) res_init\n          body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_single_type \\<rho> \\<le> \\<sigma>;\n        to_unique_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ClosureIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n        \\<phi> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n         update_element_type \\<upsilon> \\<rho> \\<phi>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          CollectNestedIteratorCall src ArrowCall its its_ty body :\n          \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<phi> = \\<sigma>'\nA total of 19 subgoals...", "next"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>\\<Gamma> src \\<C> from \\<A> \\<D> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        referred_by_association_class \\<C> from \\<A> \\<D>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassCall src DotCall from \\<A> : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_type \\<A> = \\<sigma>\n 2. \\<And>\\<Gamma> src \\<A> role end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_class_end \\<A> role end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassEndCall src DotCall role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_end_type end = \\<sigma>\n 3. \\<And>\\<Gamma> src \\<tau> params \\<pi> op k \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        op_type op k \\<tau> \\<pi> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src k op params : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 4. \\<And>\\<Gamma> src \\<pi> elem \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           Tuple \\<pi> = \\<sigma>;\n        fmlookup \\<pi> elem = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TupleElementCall src DotCall elem : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 5. \\<And>\\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho> ys.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_ty;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n         \\<turnstile>\\<^sub>E body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n            \\<turnstile>\\<^sub>E body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, Some its_ty, body) : ys\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys\n 6. \\<And>\\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma>\n       \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty,\n                  expr.Let res (Some res_t) res_init body) :\n                 (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n            ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> res_t;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IterateCall src ArrowCall its its_ty res (Some res_t) res_init\n          body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_single_type \\<rho> \\<le> \\<sigma>;\n        to_unique_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ClosureIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n        \\<phi> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n         update_element_type \\<upsilon> \\<rho> \\<phi>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          CollectNestedIteratorCall src ArrowCall its its_ty body :\n          \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<phi> = \\<sigma>'\nA total of 19 subgoals...", "case (AssociationClassCallT \\<Gamma> src \\<C> \"from\" \\<A>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>E src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1]\n  \\<Gamma> \\<turnstile>\\<^sub>E src : ?\\<sigma> \\<Longrightarrow>\n  \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = ?\\<sigma>\n  referred_by_association_class \\<C> from \\<A> \\<D>_\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   AssociationClassCall src DotCall from \\<A> : \\<sigma>\n\ngoal (19 subgoals):\n 1. \\<And>\\<Gamma> src \\<C> from \\<A> \\<D> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        referred_by_association_class \\<C> from \\<A> \\<D>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassCall src DotCall from \\<A> : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_type \\<A> = \\<sigma>\n 2. \\<And>\\<Gamma> src \\<A> role end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_class_end \\<A> role end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassEndCall src DotCall role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_end_type end = \\<sigma>\n 3. \\<And>\\<Gamma> src \\<tau> params \\<pi> op k \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        op_type op k \\<tau> \\<pi> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src k op params : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 4. \\<And>\\<Gamma> src \\<pi> elem \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           Tuple \\<pi> = \\<sigma>;\n        fmlookup \\<pi> elem = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TupleElementCall src DotCall elem : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 5. \\<And>\\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho> ys.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_ty;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n         \\<turnstile>\\<^sub>E body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n            \\<turnstile>\\<^sub>E body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, Some its_ty, body) : ys\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys\n 6. \\<And>\\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma>\n       \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty,\n                  expr.Let res (Some res_t) res_init body) :\n                 (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n            ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> res_t;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IterateCall src ArrowCall its its_ty res (Some res_t) res_init\n          body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_single_type \\<rho> \\<le> \\<sigma>;\n        to_unique_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ClosureIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n        \\<phi> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n         update_element_type \\<upsilon> \\<rho> \\<phi>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          CollectNestedIteratorCall src ArrowCall its its_ty body :\n          \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<phi> = \\<sigma>'\nA total of 19 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>E src : \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1]\n  \\<Gamma> \\<turnstile>\\<^sub>E src : ?\\<sigma> \\<Longrightarrow>\n  \\<langle>\\<C>\\<rangle>\\<^sub>\\<T>[1] = ?\\<sigma>\n  referred_by_association_class \\<C> from \\<A> \\<D>_\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   AssociationClassCall src DotCall from \\<A> : \\<sigma>\n\ngoal (1 subgoal):\n 1. class_assoc_type \\<A> = \\<sigma>", "by blast"], ["proof (state)\nthis:\n  class_assoc_type \\<A> = \\<sigma>\n\ngoal (18 subgoals):\n 1. \\<And>\\<Gamma> src \\<A> role end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_class_end \\<A> role end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassEndCall src DotCall role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_end_type end = \\<sigma>\n 2. \\<And>\\<Gamma> src \\<tau> params \\<pi> op k \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        op_type op k \\<tau> \\<pi> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src k op params : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 3. \\<And>\\<Gamma> src \\<pi> elem \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           Tuple \\<pi> = \\<sigma>;\n        fmlookup \\<pi> elem = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TupleElementCall src DotCall elem : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 4. \\<And>\\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho> ys.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_ty;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n         \\<turnstile>\\<^sub>E body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n            \\<turnstile>\\<^sub>E body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, Some its_ty, body) : ys\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys\n 5. \\<And>\\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma>\n       \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty,\n                  expr.Let res (Some res_t) res_init body) :\n                 (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n            ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> res_t;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IterateCall src ArrowCall its its_ty res (Some res_t) res_init\n          body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_single_type \\<rho> \\<le> \\<sigma>;\n        to_unique_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ClosureIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> \\<rho> \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectNestedIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         \\<rho> \\<le> Boolean[?];\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          ExistsIteratorCall src ArrowCall its its_ty body :\n          \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<rho> = \\<sigma>'\nA total of 18 subgoals...", "next"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>\\<Gamma> src \\<A> role end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_class_end \\<A> role end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassEndCall src DotCall role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_end_type end = \\<sigma>\n 2. \\<And>\\<Gamma> src \\<tau> params \\<pi> op k \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        op_type op k \\<tau> \\<pi> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src k op params : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 3. \\<And>\\<Gamma> src \\<pi> elem \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           Tuple \\<pi> = \\<sigma>;\n        fmlookup \\<pi> elem = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TupleElementCall src DotCall elem : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 4. \\<And>\\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho> ys.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_ty;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n         \\<turnstile>\\<^sub>E body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n            \\<turnstile>\\<^sub>E body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, Some its_ty, body) : ys\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys\n 5. \\<And>\\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma>\n       \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty,\n                  expr.Let res (Some res_t) res_init body) :\n                 (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n            ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> res_t;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IterateCall src ArrowCall its its_ty res (Some res_t) res_init\n          body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_single_type \\<rho> \\<le> \\<sigma>;\n        to_unique_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ClosureIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> \\<rho> \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectNestedIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         \\<rho> \\<le> Boolean[?];\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          ExistsIteratorCall src ArrowCall its its_ty body :\n          \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<rho> = \\<sigma>'\nA total of 18 subgoals...", "case (AssociationClassEndCallT \\<Gamma> src \\<tau> \\<A> role \"end\")"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>E src : \\<langle>\\<tau>\\<rangle>\\<^sub>\\<T>[1]\n  \\<Gamma> \\<turnstile>\\<^sub>E src : ?\\<sigma> \\<Longrightarrow>\n  \\<langle>\\<tau>\\<rangle>\\<^sub>\\<T>[1] = ?\\<sigma>\n  association_class_end \\<tau> \\<A> role\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   AssociationClassEndCall src DotCall \\<A> : end\n\ngoal (18 subgoals):\n 1. \\<And>\\<Gamma> src \\<A> role end \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E\n                 src : \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1];\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<langle>\\<A>\\<rangle>\\<^sub>\\<T>[1] = \\<sigma>;\n        association_class_end \\<A> role end;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AssociationClassEndCall src DotCall role : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> class_assoc_end_type end = \\<sigma>\n 2. \\<And>\\<Gamma> src \\<tau> params \\<pi> op k \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        op_type op k \\<tau> \\<pi> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src k op params : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 3. \\<And>\\<Gamma> src \\<pi> elem \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           Tuple \\<pi> = \\<sigma>;\n        fmlookup \\<pi> elem = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TupleElementCall src DotCall elem : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 4. \\<And>\\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho> ys.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_ty;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n         \\<turnstile>\\<^sub>E body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n            \\<turnstile>\\<^sub>E body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, Some its_ty, body) : ys\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys\n 5. \\<And>\\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma>\n       \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty,\n                  expr.Let res (Some res_t) res_init body) :\n                 (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n            ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> res_t;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IterateCall src ArrowCall its its_ty res (Some res_t) res_init\n          body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_single_type \\<rho> \\<le> \\<sigma>;\n        to_unique_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ClosureIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> \\<rho> \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectNestedIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         \\<rho> \\<le> Boolean[?];\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          ExistsIteratorCall src ArrowCall its its_ty body :\n          \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<rho> = \\<sigma>'\nA total of 18 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. class_assoc_end_type role = end", "apply (insert AssociationClassEndCallT.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>E\n     AssociationClassEndCall src DotCall \\<A> : end \\<Longrightarrow>\n    class_assoc_end_type role = end", "apply (erule AssociationClassEndCallTE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<A>' enda.\n       \\<lbrakk>DotCall = DotCall; end = class_assoc_end_type enda;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         src : \\<langle>\\<A>'\\<rangle>\\<^sub>\\<T>[1];\n        association_class_end \\<A>' \\<A> enda\\<rbrakk>\n       \\<Longrightarrow> class_assoc_end_type role = end", "using AssociationClassEndCallT.hyps association_class_end_det"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>E src : \\<langle>\\<tau>\\<rangle>\\<^sub>\\<T>[1]\n  \\<Gamma> \\<turnstile>\\<^sub>E src : ?\\<sigma> \\<Longrightarrow>\n  \\<langle>\\<tau>\\<rangle>\\<^sub>\\<T>[1] = ?\\<sigma>\n  association_class_end \\<tau> \\<A> role\n  \\<lbrakk>association_class_end ?\\<A> ?role ?end\\<^sub>1;\n   association_class_end ?\\<A> ?role ?end\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?end\\<^sub>1 = ?end\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>\\<A>' enda.\n       \\<lbrakk>DotCall = DotCall; end = class_assoc_end_type enda;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         src : \\<langle>\\<A>'\\<rangle>\\<^sub>\\<T>[1];\n        association_class_end \\<A>' \\<A> enda\\<rbrakk>\n       \\<Longrightarrow> class_assoc_end_type role = end", "by blast"], ["proof (state)\nthis:\n  class_assoc_end_type role = end\n\ngoal (17 subgoals):\n 1. \\<And>\\<Gamma> src \\<tau> params \\<pi> op k \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        op_type op k \\<tau> \\<pi> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src k op params : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 2. \\<And>\\<Gamma> src \\<pi> elem \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           Tuple \\<pi> = \\<sigma>;\n        fmlookup \\<pi> elem = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TupleElementCall src DotCall elem : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 3. \\<And>\\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho> ys.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_ty;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n         \\<turnstile>\\<^sub>E body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n            \\<turnstile>\\<^sub>E body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, Some its_ty, body) : ys\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys\n 4. \\<And>\\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma>\n       \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty,\n                  expr.Let res (Some res_t) res_init body) :\n                 (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n            ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> res_t;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IterateCall src ArrowCall its its_ty res (Some res_t) res_init\n          body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_single_type \\<rho> \\<le> \\<sigma>;\n        to_unique_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ClosureIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> \\<rho> \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectNestedIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ExistsIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         \\<rho> \\<le> Boolean[?];\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          ForAllIteratorCall src ArrowCall its its_ty body :\n          \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<rho> = \\<sigma>'\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>\\<Gamma> src \\<tau> params \\<pi> op k \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        op_type op k \\<tau> \\<pi> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src k op params : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 2. \\<And>\\<Gamma> src \\<pi> elem \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           Tuple \\<pi> = \\<sigma>;\n        fmlookup \\<pi> elem = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TupleElementCall src DotCall elem : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 3. \\<And>\\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho> ys.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_ty;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n         \\<turnstile>\\<^sub>E body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n            \\<turnstile>\\<^sub>E body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, Some its_ty, body) : ys\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys\n 4. \\<And>\\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma>\n       \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty,\n                  expr.Let res (Some res_t) res_init body) :\n                 (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n            ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> res_t;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IterateCall src ArrowCall its its_ty res (Some res_t) res_init\n          body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_single_type \\<rho> \\<le> \\<sigma>;\n        to_unique_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ClosureIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> \\<rho> \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectNestedIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ExistsIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         \\<rho> \\<le> Boolean[?];\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          ForAllIteratorCall src ArrowCall its its_ty body :\n          \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<rho> = \\<sigma>'\nA total of 17 subgoals...", "case (OperationCallT \\<Gamma> src \\<tau> params \\<pi> op k)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>\n  \\<Gamma> \\<turnstile>\\<^sub>E src : ?\\<sigma> \\<Longrightarrow>\n  \\<tau> = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>\n  \\<Gamma> \\<turnstile>\\<^sub>L params : ?\\<xi> \\<Longrightarrow>\n  \\<pi> = ?\\<xi>\n  op_type op k \\<tau> \\<pi> \\<sigma>_\n  \\<Gamma> \\<turnstile>\\<^sub>E OperationCall src k op params : \\<sigma>\n\ngoal (17 subgoals):\n 1. \\<And>\\<Gamma> src \\<tau> params \\<pi> op k \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L params : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        op_type op k \\<tau> \\<pi> \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OperationCall src k op params : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 2. \\<And>\\<Gamma> src \\<pi> elem \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           Tuple \\<pi> = \\<sigma>;\n        fmlookup \\<pi> elem = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TupleElementCall src DotCall elem : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 3. \\<And>\\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho> ys.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_ty;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n         \\<turnstile>\\<^sub>E body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n            \\<turnstile>\\<^sub>E body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, Some its_ty, body) : ys\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys\n 4. \\<And>\\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma>\n       \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty,\n                  expr.Let res (Some res_t) res_init body) :\n                 (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n            ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> res_t;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IterateCall src ArrowCall its its_ty res (Some res_t) res_init\n          body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_single_type \\<rho> \\<le> \\<sigma>;\n        to_unique_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ClosureIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> \\<rho> \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectNestedIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ExistsIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         \\<rho> \\<le> Boolean[?];\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          ForAllIteratorCall src ArrowCall its its_ty body :\n          \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<rho> = \\<sigma>'\nA total of 17 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>_ = \\<sigma>", "apply (insert OperationCallT.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>E\n     OperationCall src k op params : \\<sigma> \\<Longrightarrow>\n    \\<sigma>_ = \\<sigma>", "apply (erule OperationCallTE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<pi>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        op_type op k \\<tau> \\<pi> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<sigma>_ = \\<sigma>", "using OperationCallT.hyps op_type_det"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>\n  \\<Gamma> \\<turnstile>\\<^sub>E src : ?\\<sigma> \\<Longrightarrow>\n  \\<tau> = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>\n  \\<Gamma> \\<turnstile>\\<^sub>L params : ?\\<xi> \\<Longrightarrow>\n  \\<pi> = ?\\<xi>\n  op_type op k \\<tau> \\<pi> \\<sigma>_\n  \\<lbrakk>op_type ?op ?k ?\\<tau> ?\\<pi> ?\\<sigma>;\n   op_type ?op ?k ?\\<tau> ?\\<pi> ?\\<rho>\\<rbrakk>\n  \\<Longrightarrow> ?\\<sigma> = ?\\<rho>\n\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<pi>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>L params : \\<pi>;\n        op_type op k \\<tau> \\<pi> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<sigma>_ = \\<sigma>", "by blast"], ["proof (state)\nthis:\n  \\<sigma>_ = \\<sigma>\n\ngoal (16 subgoals):\n 1. \\<And>\\<Gamma> src \\<pi> elem \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           Tuple \\<pi> = \\<sigma>;\n        fmlookup \\<pi> elem = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TupleElementCall src DotCall elem : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 2. \\<And>\\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho> ys.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_ty;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n         \\<turnstile>\\<^sub>E body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n            \\<turnstile>\\<^sub>E body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, Some its_ty, body) : ys\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys\n 3. \\<And>\\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma>\n       \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty,\n                  expr.Let res (Some res_t) res_init body) :\n                 (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n            ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> res_t;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IterateCall src ArrowCall its its_ty res (Some res_t) res_init\n          body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_single_type \\<rho> \\<le> \\<sigma>;\n        to_unique_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ClosureIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> \\<rho> \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectNestedIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ExistsIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ForAllIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          OneIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> Boolean[1] = \\<sigma>'\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>\\<Gamma> src \\<pi> elem \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           Tuple \\<pi> = \\<sigma>;\n        fmlookup \\<pi> elem = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TupleElementCall src DotCall elem : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 2. \\<And>\\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho> ys.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_ty;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n         \\<turnstile>\\<^sub>E body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n            \\<turnstile>\\<^sub>E body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, Some its_ty, body) : ys\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys\n 3. \\<And>\\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma>\n       \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty,\n                  expr.Let res (Some res_t) res_init body) :\n                 (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n            ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> res_t;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IterateCall src ArrowCall its its_ty res (Some res_t) res_init\n          body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_single_type \\<rho> \\<le> \\<sigma>;\n        to_unique_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ClosureIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> \\<rho> \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectNestedIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ExistsIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ForAllIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          OneIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> Boolean[1] = \\<sigma>'\nA total of 16 subgoals...", "case (TupleElementCallT \\<Gamma> src \\<pi> elem \\<tau>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>\n  \\<Gamma> \\<turnstile>\\<^sub>E src : ?\\<sigma> \\<Longrightarrow>\n  Tuple \\<pi> = ?\\<sigma>\n  fmlookup \\<pi> elem = Some \\<tau>\n  \\<Gamma> \\<turnstile>\\<^sub>E TupleElementCall src DotCall elem : \\<sigma>\n\ngoal (16 subgoals):\n 1. \\<And>\\<Gamma> src \\<pi> elem \\<tau> \\<sigma>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           Tuple \\<pi> = \\<sigma>;\n        fmlookup \\<pi> elem = Some \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         TupleElementCall src DotCall elem : \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>\n 2. \\<And>\\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho> ys.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_ty;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n         \\<turnstile>\\<^sub>E body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n            \\<turnstile>\\<^sub>E body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, Some its_ty, body) : ys\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys\n 3. \\<And>\\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma>\n       \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty,\n                  expr.Let res (Some res_t) res_init body) :\n                 (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n            ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> res_t;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IterateCall src ArrowCall its its_ty res (Some res_t) res_init\n          body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_single_type \\<rho> \\<le> \\<sigma>;\n        to_unique_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ClosureIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> \\<rho> \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectNestedIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ExistsIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ForAllIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          OneIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> Boolean[1] = \\<sigma>'\nA total of 16 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>\n  \\<Gamma> \\<turnstile>\\<^sub>E src : ?\\<sigma> \\<Longrightarrow>\n  Tuple \\<pi> = ?\\<sigma>\n  fmlookup \\<pi> elem = Some \\<tau>\n  \\<Gamma> \\<turnstile>\\<^sub>E TupleElementCall src DotCall elem : \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<tau> = \\<sigma>", "apply (insert TupleElementCallT.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>E\n     TupleElementCall src DotCall elem : \\<sigma> \\<Longrightarrow>\n    \\<tau> = \\<sigma>", "apply (erule TupleElementCallTE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<lbrakk>DotCall = DotCall;\n        \\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n        fmlookup \\<pi> elem = Some \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>", "using TupleElementCallT.hyps"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>\n  \\<Gamma> \\<turnstile>\\<^sub>E src : ?\\<sigma> \\<Longrightarrow>\n  Tuple \\<pi> = ?\\<sigma>\n  fmlookup \\<pi> elem = Some \\<tau>\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<lbrakk>DotCall = DotCall;\n        \\<Gamma> \\<turnstile>\\<^sub>E src : Tuple \\<pi>;\n        fmlookup \\<pi> elem = Some \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>", "by fastforce"], ["proof (state)\nthis:\n  \\<tau> = \\<sigma>\n\ngoal (15 subgoals):\n 1. \\<And>\\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho> ys.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_ty;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n         \\<turnstile>\\<^sub>E body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n            \\<turnstile>\\<^sub>E body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, Some its_ty, body) : ys\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys\n 2. \\<And>\\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma>\n       \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty,\n                  expr.Let res (Some res_t) res_init body) :\n                 (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n            ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> res_t;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IterateCall src ArrowCall its its_ty res (Some res_t) res_init\n          body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_single_type \\<rho> \\<le> \\<sigma>;\n        to_unique_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ClosureIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> \\<rho> \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectNestedIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ExistsIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ForAllIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OneIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         length its \\<le> 1;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          IsUniqueIteratorCall src ArrowCall its its_ty body :\n          \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> Boolean[1] = \\<sigma>'\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>\\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho> ys.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_ty;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n         \\<turnstile>\\<^sub>E body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n            \\<turnstile>\\<^sub>E body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, Some its_ty, body) : ys\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys\n 2. \\<And>\\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma>\n       \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty,\n                  expr.Let res (Some res_t) res_init body) :\n                 (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n            ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> res_t;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IterateCall src ArrowCall its its_ty res (Some res_t) res_init\n          body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_single_type \\<rho> \\<le> \\<sigma>;\n        to_unique_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ClosureIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> \\<rho> \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectNestedIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ExistsIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ForAllIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OneIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         length its \\<le> 1;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          IsUniqueIteratorCall src ArrowCall its its_ty body :\n          \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> Boolean[1] = \\<sigma>'\nA total of 15 subgoals...", "case (IteratorT \\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>\n  \\<Gamma> \\<turnstile>\\<^sub>E src : ?\\<sigma> \\<Longrightarrow>\n  \\<tau> = ?\\<sigma>\n  element_type \\<tau> \\<sigma>\n  \\<sigma> \\<le> its_ty\n  \\<Gamma> ++\\<^sub>f fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n   \\<turnstile>\\<^sub>E body : \\<rho>\n  \\<Gamma> ++\\<^sub>f fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n   \\<turnstile>\\<^sub>E body : ?\\<sigma> \\<Longrightarrow>\n  \\<rho> = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>I (src, its, Some its_ty, body) : ys\n\ngoal (15 subgoals):\n 1. \\<And>\\<Gamma> src \\<tau> \\<sigma> its_ty its body \\<rho> ys.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E src : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_ty;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n         \\<turnstile>\\<^sub>E body : \\<rho>;\n        \\<And>\\<sigma>.\n           \\<Gamma> ++\\<^sub>f\n           fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n            \\<turnstile>\\<^sub>E body : \\<sigma> \\<Longrightarrow>\n           \\<rho> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, Some its_ty, body) : ys\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys\n 2. \\<And>\\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma>\n       \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty,\n                  expr.Let res (Some res_t) res_init body) :\n                 (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n            ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> res_t;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IterateCall src ArrowCall its its_ty res (Some res_t) res_init\n          body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_single_type \\<rho> \\<le> \\<sigma>;\n        to_unique_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ClosureIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> \\<rho> \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectNestedIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ExistsIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ForAllIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OneIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         length its \\<le> 1;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          IsUniqueIteratorCall src ArrowCall its its_ty body :\n          \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> Boolean[1] = \\<sigma>'\nA total of 15 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau>, \\<sigma>, \\<rho>) = ys", "apply (insert IteratorT.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>I\n     (src, its, Some its_ty, body) : ys \\<Longrightarrow>\n    (\\<tau>, \\<sigma>, \\<rho>) = ys", "apply (erule IteratorTE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<sigma> its_tya body \\<rho>'.\n       \\<lbrakk>(Some its_ty, body) = (Some its_tya, body);\n        ys = (\\<tau>, \\<sigma>, \\<rho>');\n        \\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_tya;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list (map (\\<lambda>it. (it, its_tya)) its)\n         \\<turnstile>\\<^sub>E body : \\<rho>'\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys", "using IteratorT.hyps element_type_det"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>\n  \\<Gamma> \\<turnstile>\\<^sub>E src : ?\\<sigma> \\<Longrightarrow>\n  \\<tau> = ?\\<sigma>\n  element_type \\<tau> \\<sigma>\n  \\<sigma> \\<le> its_ty\n  \\<Gamma> ++\\<^sub>f fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n   \\<turnstile>\\<^sub>E body : \\<rho>\n  \\<Gamma> ++\\<^sub>f fmap_of_list (map (\\<lambda>it. (it, its_ty)) its)\n   \\<turnstile>\\<^sub>E body : ?\\<sigma> \\<Longrightarrow>\n  \\<rho> = ?\\<sigma>\n  \\<lbrakk>element_type ?\\<tau> ?\\<sigma>\\<^sub>1;\n   element_type ?\\<tau> ?\\<sigma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?\\<sigma>\\<^sub>1 = ?\\<sigma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<sigma> its_tya body \\<rho>'.\n       \\<lbrakk>(Some its_ty, body) = (Some its_tya, body);\n        ys = (\\<tau>, \\<sigma>, \\<rho>');\n        \\<Gamma> \\<turnstile>\\<^sub>E src : \\<tau>;\n        element_type \\<tau> \\<sigma>; \\<sigma> \\<le> its_tya;\n        \\<Gamma> ++\\<^sub>f\n        fmap_of_list (map (\\<lambda>it. (it, its_tya)) its)\n         \\<turnstile>\\<^sub>E body : \\<rho>'\\<rbrakk>\n       \\<Longrightarrow> (\\<tau>, \\<sigma>, \\<rho>) = ys", "by blast"], ["proof (state)\nthis:\n  (\\<tau>, \\<sigma>, \\<rho>) = ys\n\ngoal (14 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma>\n       \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty,\n                  expr.Let res (Some res_t) res_init body) :\n                 (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n            ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> res_t;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IterateCall src ArrowCall its its_ty res (Some res_t) res_init\n          body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_single_type \\<rho> \\<le> \\<sigma>;\n        to_unique_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ClosureIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> \\<rho> \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectNestedIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ExistsIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ForAllIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OneIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IsUniqueIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          SelectIteratorCall src ArrowCall its its_ty body :\n          \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<tau> = \\<sigma>'\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma>\n       \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty,\n                  expr.Let res (Some res_t) res_init body) :\n                 (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n            ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> res_t;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IterateCall src ArrowCall its its_ty res (Some res_t) res_init\n          body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_single_type \\<rho> \\<le> \\<sigma>;\n        to_unique_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ClosureIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> \\<rho> \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectNestedIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ExistsIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ForAllIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OneIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IsUniqueIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          SelectIteratorCall src ArrowCall its its_ty body :\n          \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<tau> = \\<sigma>'\nA total of 14 subgoals...", "case (IterateT \\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma> \\<rho>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n   (\\<tau>, \\<sigma>'__, \\<rho>)\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n   ?ys \\<Longrightarrow>\n  (\\<tau>, \\<sigma>'__, \\<rho>) = ?ys\n  \\<rho> \\<le> res_t\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   IterateCall src ArrowCall its its_ty res (Some res_t) res_init body :\n   \\<sigma>\n\ngoal (14 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty res res_t res_init body \\<tau> \\<sigma>\n       \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty,\n                  expr.Let res (Some res_t) res_init body) :\n                 (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n            ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> res_t;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IterateCall src ArrowCall its its_ty res (Some res_t) res_init\n          body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_single_type \\<rho> \\<le> \\<sigma>;\n        to_unique_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ClosureIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> \\<rho> \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectNestedIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ExistsIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ForAllIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OneIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IsUniqueIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          SelectIteratorCall src ArrowCall its its_ty body :\n          \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<tau> = \\<sigma>'\nA total of 14 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<rho> = \\<sigma>", "apply (insert IterateT.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>E\n     IterateCall src ArrowCall its its_ty res (Some res_t) res_init body :\n     \\<sigma> \\<Longrightarrow>\n    \\<rho> = \\<sigma>", "using IterateT.hyps"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n   (\\<tau>, \\<sigma>'__, \\<rho>)\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (src, its, its_ty, expr.Let res (Some res_t) res_init body) :\n   ?ys \\<Longrightarrow>\n  (\\<tau>, \\<sigma>'__, \\<rho>) = ?ys\n  \\<rho> \\<le> res_t\n\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>E\n     IterateCall src ArrowCall its its_ty res (Some res_t) res_init body :\n     \\<sigma> \\<Longrightarrow>\n    \\<rho> = \\<sigma>", "by blast"], ["proof (state)\nthis:\n  \\<rho> = \\<sigma>\n\ngoal (13 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_single_type \\<rho> \\<le> \\<sigma>;\n        to_unique_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ClosureIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> \\<rho> \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectNestedIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ExistsIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ForAllIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OneIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IsUniqueIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SelectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          RejectIteratorCall src ArrowCall its its_ty body :\n          \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<tau> = \\<sigma>'\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_single_type \\<rho> \\<le> \\<sigma>;\n        to_unique_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ClosureIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> \\<rho> \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectNestedIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ExistsIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ForAllIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OneIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IsUniqueIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SelectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          RejectIteratorCall src ArrowCall its its_ty body :\n          \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<tau> = \\<sigma>'\nA total of 13 subgoals...", "case (AnyIteratorT \\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (src, its, its_ty, body) : (\\<tau>, \\<sigma>'__, \\<rho>)\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (src, its, its_ty, body) : ?ys \\<Longrightarrow>\n  (\\<tau>, \\<sigma>'__, \\<rho>) = ?ys\n  length its \\<le> 1\n  \\<rho> \\<le> Boolean[?]\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>\n\ngoal (13 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_single_type \\<rho> \\<le> \\<sigma>;\n        to_unique_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ClosureIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> \\<rho> \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectNestedIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ExistsIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ForAllIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OneIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IsUniqueIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SelectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          RejectIteratorCall src ArrowCall its its_ty body :\n          \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<tau> = \\<sigma>'\nA total of 13 subgoals...", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (src, its, its_ty, body) : (\\<tau>, \\<sigma>'__, \\<rho>)\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (src, its, its_ty, body) : ?ys \\<Longrightarrow>\n  (\\<tau>, \\<sigma>'__, \\<rho>) = ?ys\n  length its \\<le> 1\n  \\<rho> \\<le> Boolean[?]\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   AnyIteratorCall src ArrowCall its its_ty body : \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<sigma>'__ = \\<sigma>", "by (meson AnyIteratorTE Pair_inject)"], ["proof (state)\nthis:\n  \\<sigma>'__ = \\<sigma>\n\ngoal (12 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_single_type \\<rho> \\<le> \\<sigma>;\n        to_unique_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ClosureIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> \\<rho> \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectNestedIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ExistsIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ForAllIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OneIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IsUniqueIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SelectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         RejectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n        \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         length its \\<le> 1; to_ordered_collection \\<tau> \\<upsilon>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          SortedByIteratorCall src ArrowCall its its_ty body :\n          \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<upsilon> = \\<sigma>'\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_single_type \\<rho> \\<le> \\<sigma>;\n        to_unique_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ClosureIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> \\<rho> \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectNestedIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ExistsIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ForAllIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OneIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IsUniqueIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SelectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         RejectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n        \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         length its \\<le> 1; to_ordered_collection \\<tau> \\<upsilon>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          SortedByIteratorCall src ArrowCall its its_ty body :\n          \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<upsilon> = \\<sigma>'\nA total of 12 subgoals...", "case (ClosureIteratorT \\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (src, its, its_ty, body) : (\\<tau>, \\<sigma>'__, \\<rho>)\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (src, its, its_ty, body) : ?ys \\<Longrightarrow>\n  (\\<tau>, \\<sigma>'__, \\<rho>) = ?ys\n  length its \\<le> 1\n  to_single_type \\<rho> \\<le> \\<sigma>'__\n  to_unique_collection \\<tau> \\<upsilon>\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   ClosureIteratorCall src ArrowCall its its_ty body : \\<sigma>\n\ngoal (12 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_single_type \\<rho> \\<le> \\<sigma>;\n        to_unique_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ClosureIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> \\<rho> \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectNestedIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ExistsIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ForAllIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OneIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IsUniqueIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SelectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         RejectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 10. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n        \\<sigma>'.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                  (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n         \\<And>ys.\n            \\<Gamma> \\<turnstile>\\<^sub>I\n             (src, its, its_ty, body) : ys \\<Longrightarrow>\n            (\\<tau>, \\<sigma>, \\<rho>) = ys;\n         length its \\<le> 1; to_ordered_collection \\<tau> \\<upsilon>;\n         \\<Gamma> \\<turnstile>\\<^sub>E\n          SortedByIteratorCall src ArrowCall its its_ty body :\n          \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> \\<upsilon> = \\<sigma>'\nA total of 12 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> = \\<sigma>", "apply (insert ClosureIteratorT.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>E\n     ClosureIteratorCall src ArrowCall its its_ty body :\n     \\<sigma> \\<Longrightarrow>\n    \\<upsilon> = \\<sigma>", "apply (erule ClosureIteratorTE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<sigma> \\<rho>.\n       \\<lbrakk>ArrowCall = ArrowCall;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        length its \\<le> Suc 0; to_single_type \\<rho> \\<le> \\<sigma>;\n        to_unique_collection \\<tau> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>", "using ClosureIteratorT.hyps to_unique_collection_det"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (src, its, its_ty, body) : (\\<tau>, \\<sigma>'__, \\<rho>)\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (src, its, its_ty, body) : ?ys \\<Longrightarrow>\n  (\\<tau>, \\<sigma>'__, \\<rho>) = ?ys\n  length its \\<le> 1\n  to_single_type \\<rho> \\<le> \\<sigma>'__\n  to_unique_collection \\<tau> \\<upsilon>\n  \\<lbrakk>to_unique_collection ?\\<tau> ?\\<sigma>\\<^sub>1;\n   to_unique_collection ?\\<tau> ?\\<sigma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?\\<sigma>\\<^sub>1 = ?\\<sigma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<sigma> \\<rho>.\n       \\<lbrakk>ArrowCall = ArrowCall;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        length its \\<le> Suc 0; to_single_type \\<rho> \\<le> \\<sigma>;\n        to_unique_collection \\<tau> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>", "by blast"], ["proof (state)\nthis:\n  \\<upsilon> = \\<sigma>\n\ngoal (11 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> \\<rho> \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectNestedIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ExistsIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ForAllIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OneIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IsUniqueIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SelectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         RejectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_ordered_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SortedByIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 10. \\<And>\\<Gamma> \\<xi>.\n        \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi> \\<Longrightarrow>\n        [] = \\<xi>\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> \\<rho> \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectNestedIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ExistsIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ForAllIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OneIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IsUniqueIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SelectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         RejectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_ordered_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SortedByIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 10. \\<And>\\<Gamma> \\<xi>.\n        \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi> \\<Longrightarrow>\n        [] = \\<xi>\nA total of 11 subgoals...", "case (CollectIteratorT \\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (src, its, its_ty, body) : (\\<tau>, \\<sigma>'__, \\<rho>)\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (src, its, its_ty, body) : ?ys \\<Longrightarrow>\n  (\\<tau>, \\<sigma>'__, \\<rho>) = ?ys\n  length its \\<le> 1\n  to_nonunique_collection \\<tau> \\<upsilon>\n  update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>_\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   CollectIteratorCall src ArrowCall its its_ty body : \\<sigma>\n\ngoal (11 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> \\<rho> \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectNestedIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ExistsIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ForAllIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OneIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IsUniqueIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SelectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         RejectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 9. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_ordered_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SortedByIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 10. \\<And>\\<Gamma> \\<xi>.\n        \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi> \\<Longrightarrow>\n        [] = \\<xi>\nA total of 11 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>_ = \\<sigma>", "apply (insert CollectIteratorT.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>E\n     CollectIteratorCall src ArrowCall its its_ty body :\n     \\<sigma> \\<Longrightarrow>\n    \\<phi>_ = \\<sigma>", "apply (erule CollectIteratorTE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<sigma> \\<rho> \\<upsilon>.\n       \\<lbrakk>ArrowCall = ArrowCall;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        length its \\<le> Suc 0; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> (to_single_type \\<rho>)\n         \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<phi>_ = \\<sigma>", "using CollectIteratorT.hyps to_nonunique_collection_det\n      update_element_type_det Pair_inject"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (src, its, its_ty, body) : (\\<tau>, \\<sigma>'__, \\<rho>)\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (src, its, its_ty, body) : ?ys \\<Longrightarrow>\n  (\\<tau>, \\<sigma>'__, \\<rho>) = ?ys\n  length its \\<le> 1\n  to_nonunique_collection \\<tau> \\<upsilon>\n  update_element_type \\<upsilon> (to_single_type \\<rho>) \\<phi>_\n  \\<lbrakk>to_nonunique_collection ?\\<tau> ?\\<sigma>\\<^sub>1;\n   to_nonunique_collection ?\\<tau> ?\\<sigma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?\\<sigma>\\<^sub>1 = ?\\<sigma>\\<^sub>2\n  \\<lbrakk>update_element_type ?\\<tau> ?\\<sigma> ?\\<rho>\\<^sub>1;\n   update_element_type ?\\<tau> ?\\<sigma> ?\\<rho>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?\\<rho>\\<^sub>1 = ?\\<rho>\\<^sub>2\n  \\<lbrakk>(?a, ?b) = (?a', ?b');\n   \\<lbrakk>?a = ?a'; ?b = ?b'\\<rbrakk> \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<sigma> \\<rho> \\<upsilon>.\n       \\<lbrakk>ArrowCall = ArrowCall;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        length its \\<le> Suc 0; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> (to_single_type \\<rho>)\n         \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<phi>_ = \\<sigma>", "by metis"], ["proof (state)\nthis:\n  \\<phi>_ = \\<sigma>\n\ngoal (10 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> \\<rho> \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectNestedIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ExistsIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ForAllIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OneIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IsUniqueIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SelectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         RejectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_ordered_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SortedByIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 9. \\<And>\\<Gamma> \\<xi>.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi> \\<Longrightarrow> [] = \\<xi>\n 10. \\<And>\\<Gamma> expr \\<tau> exprs \\<pi> \\<xi>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n         \\<And>\\<xi>.\n            \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow>\n            \\<pi> = \\<xi>;\n         \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\\<rbrakk>\n        \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> \\<rho> \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectNestedIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ExistsIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ForAllIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OneIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IsUniqueIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SelectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         RejectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_ordered_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SortedByIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 9. \\<And>\\<Gamma> \\<xi>.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi> \\<Longrightarrow> [] = \\<xi>\n 10. \\<And>\\<Gamma> expr \\<tau> exprs \\<pi> \\<xi>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n         \\<And>\\<xi>.\n            \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow>\n            \\<pi> = \\<xi>;\n         \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\\<rbrakk>\n        \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "case (CollectNestedIteratorT \\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (src, its, its_ty, body) : (\\<tau>, \\<sigma>'__, \\<rho>)\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (src, its, its_ty, body) : ?ys \\<Longrightarrow>\n  (\\<tau>, \\<sigma>'__, \\<rho>) = ?ys\n  length its \\<le> 1\n  to_nonunique_collection \\<tau> \\<upsilon>\n  update_element_type \\<upsilon> \\<rho> \\<phi>_\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   CollectNestedIteratorCall src ArrowCall its its_ty body : \\<sigma>\n\ngoal (10 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<phi> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> \\<rho> \\<phi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         CollectNestedIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ExistsIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ForAllIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OneIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IsUniqueIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SelectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         RejectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 8. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_ordered_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SortedByIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 9. \\<And>\\<Gamma> \\<xi>.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi> \\<Longrightarrow> [] = \\<xi>\n 10. \\<And>\\<Gamma> expr \\<tau> exprs \\<pi> \\<xi>.\n        \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n         \\<And>\\<sigma>.\n            \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow>\n            \\<tau> = \\<sigma>;\n         \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n         \\<And>\\<xi>.\n            \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow>\n            \\<pi> = \\<xi>;\n         \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\\<rbrakk>\n        \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>_ = \\<sigma>", "apply (insert CollectNestedIteratorT.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>E\n     CollectNestedIteratorCall src ArrowCall its its_ty body :\n     \\<sigma> \\<Longrightarrow>\n    \\<phi>_ = \\<sigma>", "apply (erule CollectNestedIteratorTE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<sigma> \\<rho> \\<upsilon>.\n       \\<lbrakk>ArrowCall = ArrowCall;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        length its \\<le> Suc 0; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> \\<rho> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<phi>_ = \\<sigma>", "using CollectNestedIteratorT.hyps to_nonunique_collection_det\n      update_element_type_det Pair_inject"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (src, its, its_ty, body) : (\\<tau>, \\<sigma>'__, \\<rho>)\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (src, its, its_ty, body) : ?ys \\<Longrightarrow>\n  (\\<tau>, \\<sigma>'__, \\<rho>) = ?ys\n  length its \\<le> 1\n  to_nonunique_collection \\<tau> \\<upsilon>\n  update_element_type \\<upsilon> \\<rho> \\<phi>_\n  \\<lbrakk>to_nonunique_collection ?\\<tau> ?\\<sigma>\\<^sub>1;\n   to_nonunique_collection ?\\<tau> ?\\<sigma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?\\<sigma>\\<^sub>1 = ?\\<sigma>\\<^sub>2\n  \\<lbrakk>update_element_type ?\\<tau> ?\\<sigma> ?\\<rho>\\<^sub>1;\n   update_element_type ?\\<tau> ?\\<sigma> ?\\<rho>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?\\<rho>\\<^sub>1 = ?\\<rho>\\<^sub>2\n  \\<lbrakk>(?a, ?b) = (?a', ?b');\n   \\<lbrakk>?a = ?a'; ?b = ?b'\\<rbrakk> \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<sigma> \\<rho> \\<upsilon>.\n       \\<lbrakk>ArrowCall = ArrowCall;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        length its \\<le> Suc 0; to_nonunique_collection \\<tau> \\<upsilon>;\n        update_element_type \\<upsilon> \\<rho> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<phi>_ = \\<sigma>", "by metis"], ["proof (state)\nthis:\n  \\<phi>_ = \\<sigma>\n\ngoal (9 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ExistsIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ForAllIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OneIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IsUniqueIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SelectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         RejectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_ordered_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SortedByIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 8. \\<And>\\<Gamma> \\<xi>.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi> \\<Longrightarrow> [] = \\<xi>\n 9. \\<And>\\<Gamma> expr \\<tau> exprs \\<pi> \\<xi>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ExistsIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ForAllIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OneIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IsUniqueIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SelectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         RejectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_ordered_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SortedByIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 8. \\<And>\\<Gamma> \\<xi>.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi> \\<Longrightarrow> [] = \\<xi>\n 9. \\<And>\\<Gamma> expr \\<tau> exprs \\<pi> \\<xi>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "case (ExistsIteratorT \\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (src, its, its_ty, body) : (\\<tau>, \\<sigma>'__, \\<rho>)\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (src, its, its_ty, body) : ?ys \\<Longrightarrow>\n  (\\<tau>, \\<sigma>'__, \\<rho>) = ?ys\n  \\<rho> \\<le> Boolean[?]\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   ExistsIteratorCall src ArrowCall its its_ty body : \\<sigma>\n\ngoal (9 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ExistsIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ForAllIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OneIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IsUniqueIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SelectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         RejectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 7. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_ordered_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SortedByIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 8. \\<And>\\<Gamma> \\<xi>.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi> \\<Longrightarrow> [] = \\<xi>\n 9. \\<And>\\<Gamma> expr \\<tau> exprs \\<pi> \\<xi>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<rho> = \\<sigma>", "apply (insert ExistsIteratorT.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>E\n     ExistsIteratorCall src ArrowCall its its_ty body :\n     \\<sigma> \\<Longrightarrow>\n    \\<rho> = \\<sigma>", "apply (erule ExistsIteratorTE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<sigma>.\n       \\<lbrakk>ArrowCall = ArrowCall;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<sigma>);\n        \\<sigma> \\<le> Boolean[?]\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>", "using ExistsIteratorT.hyps Pair_inject"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (src, its, its_ty, body) : (\\<tau>, \\<sigma>'__, \\<rho>)\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (src, its, its_ty, body) : ?ys \\<Longrightarrow>\n  (\\<tau>, \\<sigma>'__, \\<rho>) = ?ys\n  \\<rho> \\<le> Boolean[?]\n  \\<lbrakk>(?a, ?b) = (?a', ?b');\n   \\<lbrakk>?a = ?a'; ?b = ?b'\\<rbrakk> \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<sigma>.\n       \\<lbrakk>ArrowCall = ArrowCall;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<sigma>);\n        \\<sigma> \\<le> Boolean[?]\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>", "by metis"], ["proof (state)\nthis:\n  \\<rho> = \\<sigma>\n\ngoal (8 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ForAllIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OneIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IsUniqueIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SelectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         RejectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_ordered_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SortedByIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 7. \\<And>\\<Gamma> \\<xi>.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi> \\<Longrightarrow> [] = \\<xi>\n 8. \\<And>\\<Gamma> expr \\<tau> exprs \\<pi> \\<xi>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ForAllIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OneIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IsUniqueIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SelectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         RejectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_ordered_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SortedByIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 7. \\<And>\\<Gamma> \\<xi>.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi> \\<Longrightarrow> [] = \\<xi>\n 8. \\<And>\\<Gamma> expr \\<tau> exprs \\<pi> \\<xi>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "case (ForAllIteratorT \\<Gamma> \\<M> src its its_ty body \\<tau> \\<sigma> \\<rho>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (\\<M>, src, its, its_ty) : (body, \\<tau>, \\<sigma>)\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (\\<M>, src, its, its_ty) : ?ys \\<Longrightarrow>\n  (body, \\<tau>, \\<sigma>) = ?ys\n  \\<sigma> \\<le> Boolean[?]\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   ForAllIteratorCall \\<M> ArrowCall src its its_ty : \\<rho>\n\ngoal (8 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         ForAllIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OneIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IsUniqueIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SelectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         RejectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 6. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_ordered_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SortedByIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 7. \\<And>\\<Gamma> \\<xi>.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi> \\<Longrightarrow> [] = \\<xi>\n 8. \\<And>\\<Gamma> expr \\<tau> exprs \\<pi> \\<xi>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> = \\<rho>", "apply (insert ForAllIteratorT.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>E\n     ForAllIteratorCall \\<M> ArrowCall src its its_ty :\n     \\<rho> \\<Longrightarrow>\n    \\<sigma> = \\<rho>", "apply (erule ForAllIteratorTE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<sigma>.\n       \\<lbrakk>ArrowCall = ArrowCall;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (\\<M>, src, its, its_ty) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<rho> \\<le> Boolean[?]\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<rho>", "using ForAllIteratorT.hyps Pair_inject"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (\\<M>, src, its, its_ty) : (body, \\<tau>, \\<sigma>)\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (\\<M>, src, its, its_ty) : ?ys \\<Longrightarrow>\n  (body, \\<tau>, \\<sigma>) = ?ys\n  \\<sigma> \\<le> Boolean[?]\n  \\<lbrakk>(?a, ?b) = (?a', ?b');\n   \\<lbrakk>?a = ?a'; ?b = ?b'\\<rbrakk> \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<sigma>.\n       \\<lbrakk>ArrowCall = ArrowCall;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (\\<M>, src, its, its_ty) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<rho> \\<le> Boolean[?]\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = \\<rho>", "by metis"], ["proof (state)\nthis:\n  \\<sigma> = \\<rho>\n\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OneIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IsUniqueIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SelectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         RejectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_ordered_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SortedByIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 6. \\<And>\\<Gamma> \\<xi>.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi> \\<Longrightarrow> [] = \\<xi>\n 7. \\<And>\\<Gamma> expr \\<tau> exprs \\<pi> \\<xi>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OneIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IsUniqueIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SelectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         RejectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_ordered_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SortedByIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 6. \\<And>\\<Gamma> \\<xi>.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi> \\<Longrightarrow> [] = \\<xi>\n 7. \\<And>\\<Gamma> expr \\<tau> exprs \\<pi> \\<xi>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "case (OneIteratorT \\<Gamma> \\<M> src its its_ty body \\<tau> \\<sigma> \\<rho>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (\\<M>, src, its, its_ty) : (body, \\<tau>, \\<sigma>)\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (\\<M>, src, its, its_ty) : ?ys \\<Longrightarrow>\n  (body, \\<tau>, \\<sigma>) = ?ys\n  length src \\<le> 1\n  \\<sigma> \\<le> Boolean[?]\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   OneIteratorCall \\<M> ArrowCall src its its_ty : \\<rho>\n\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         OneIteratorCall src ArrowCall its its_ty body : \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IsUniqueIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SelectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         RejectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 5. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_ordered_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SortedByIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 6. \\<And>\\<Gamma> \\<xi>.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi> \\<Longrightarrow> [] = \\<xi>\n 7. \\<And>\\<Gamma> expr \\<tau> exprs \\<pi> \\<xi>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Boolean[1] = \\<rho>", "apply (insert OneIteratorT.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>E\n     OneIteratorCall \\<M> ArrowCall src its its_ty :\n     \\<rho> \\<Longrightarrow>\n    Boolean[1] = \\<rho>", "apply (erule OneIteratorTE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<sigma> \\<rho>'.\n       \\<lbrakk>ArrowCall = ArrowCall; \\<rho> = Boolean[1];\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (\\<M>, src, its, its_ty) : (\\<tau>, \\<sigma>, \\<rho>');\n        length src \\<le> Suc 0; \\<rho>' \\<le> Boolean[?]\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<rho>", "by simp"], ["proof (state)\nthis:\n  Boolean[1] = \\<rho>\n\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IsUniqueIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SelectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         RejectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_ordered_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SortedByIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 5. \\<And>\\<Gamma> \\<xi>.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi> \\<Longrightarrow> [] = \\<xi>\n 6. \\<And>\\<Gamma> expr \\<tau> exprs \\<pi> \\<xi>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IsUniqueIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SelectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         RejectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_ordered_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SortedByIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 5. \\<And>\\<Gamma> \\<xi>.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi> \\<Longrightarrow> [] = \\<xi>\n 6. \\<And>\\<Gamma> expr \\<tau> exprs \\<pi> \\<xi>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "case (IsUniqueIteratorT \\<Gamma> \\<M> src its its_ty body \\<tau> \\<sigma> \\<rho>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (\\<M>, src, its, its_ty) : (body, \\<tau>, \\<sigma>)\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (\\<M>, src, its, its_ty) : ?ys \\<Longrightarrow>\n  (body, \\<tau>, \\<sigma>) = ?ys\n  length src \\<le> 1\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   IsUniqueIteratorCall \\<M> ArrowCall src its its_ty : \\<rho>\n\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         IsUniqueIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SelectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         RejectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 4. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_ordered_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SortedByIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 5. \\<And>\\<Gamma> \\<xi>.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi> \\<Longrightarrow> [] = \\<xi>\n 6. \\<And>\\<Gamma> expr \\<tau> exprs \\<pi> \\<xi>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Boolean[1] = \\<rho>", "apply (insert IsUniqueIteratorT.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>E\n     IsUniqueIteratorCall \\<M> ArrowCall src its its_ty :\n     \\<rho> \\<Longrightarrow>\n    Boolean[1] = \\<rho>", "apply (erule IsUniqueIteratorTE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<sigma> \\<rho>'.\n       \\<lbrakk>ArrowCall = ArrowCall; \\<rho> = Boolean[1];\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (\\<M>, src, its, its_ty) : (\\<tau>, \\<sigma>, \\<rho>');\n        length src \\<le> Suc 0\\<rbrakk>\n       \\<Longrightarrow> Boolean[1] = \\<rho>", "by simp"], ["proof (state)\nthis:\n  Boolean[1] = \\<rho>\n\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SelectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         RejectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_ordered_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SortedByIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 4. \\<And>\\<Gamma> \\<xi>.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi> \\<Longrightarrow> [] = \\<xi>\n 5. \\<And>\\<Gamma> expr \\<tau> exprs \\<pi> \\<xi>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SelectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         RejectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_ordered_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SortedByIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 4. \\<And>\\<Gamma> \\<xi>.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi> \\<Longrightarrow> [] = \\<xi>\n 5. \\<And>\\<Gamma> expr \\<tau> exprs \\<pi> \\<xi>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "case (SelectIteratorT \\<Gamma> \\<M> src its its_ty body \\<tau> \\<sigma> \\<rho>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (\\<M>, src, its, its_ty) : (body, \\<tau>, \\<sigma>)\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (\\<M>, src, its, its_ty) : ?ys \\<Longrightarrow>\n  (body, \\<tau>, \\<sigma>) = ?ys\n  length src \\<le> 1\n  \\<sigma> \\<le> Boolean[?]\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   SelectIteratorCall \\<M> ArrowCall src its its_ty : \\<rho>\n\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SelectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         RejectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 3. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_ordered_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SortedByIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 4. \\<And>\\<Gamma> \\<xi>.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi> \\<Longrightarrow> [] = \\<xi>\n 5. \\<And>\\<Gamma> expr \\<tau> exprs \\<pi> \\<xi>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. body = \\<rho>", "apply (insert SelectIteratorT.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>E\n     SelectIteratorCall \\<M> ArrowCall src its its_ty :\n     \\<rho> \\<Longrightarrow>\n    body = \\<rho>", "apply (erule SelectIteratorTE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<rho>'.\n       \\<lbrakk>ArrowCall = ArrowCall;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (\\<M>, src, its, its_ty) : (\\<rho>, \\<sigma>, \\<rho>');\n        length src \\<le> Suc 0; \\<rho>' \\<le> Boolean[?]\\<rbrakk>\n       \\<Longrightarrow> body = \\<rho>", "using SelectIteratorT.hyps"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (\\<M>, src, its, its_ty) : (body, \\<tau>, \\<sigma>)\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (\\<M>, src, its, its_ty) : ?ys \\<Longrightarrow>\n  (body, \\<tau>, \\<sigma>) = ?ys\n  length src \\<le> 1\n  \\<sigma> \\<le> Boolean[?]\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<rho>'.\n       \\<lbrakk>ArrowCall = ArrowCall;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (\\<M>, src, its, its_ty) : (\\<rho>, \\<sigma>, \\<rho>');\n        length src \\<le> Suc 0; \\<rho>' \\<le> Boolean[?]\\<rbrakk>\n       \\<Longrightarrow> body = \\<rho>", "by blast"], ["proof (state)\nthis:\n  body = \\<rho>\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         RejectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_ordered_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SortedByIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 3. \\<And>\\<Gamma> \\<xi>.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi> \\<Longrightarrow> [] = \\<xi>\n 4. \\<And>\\<Gamma> expr \\<tau> exprs \\<pi> \\<xi>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         RejectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_ordered_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SortedByIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 3. \\<And>\\<Gamma> \\<xi>.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi> \\<Longrightarrow> [] = \\<xi>\n 4. \\<And>\\<Gamma> expr \\<tau> exprs \\<pi> \\<xi>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "case (RejectIteratorT \\<Gamma> \\<M> src its its_ty body \\<tau> \\<sigma> \\<rho>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (\\<M>, src, its, its_ty) : (body, \\<tau>, \\<sigma>)\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (\\<M>, src, its, its_ty) : ?ys \\<Longrightarrow>\n  (body, \\<tau>, \\<sigma>) = ?ys\n  length src \\<le> 1\n  \\<sigma> \\<le> Boolean[?]\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   RejectIteratorCall \\<M> ArrowCall src its its_ty : \\<rho>\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; \\<rho> \\<le> Boolean[?];\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         RejectIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<tau> = \\<sigma>'\n 2. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_ordered_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SortedByIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 3. \\<And>\\<Gamma> \\<xi>.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi> \\<Longrightarrow> [] = \\<xi>\n 4. \\<And>\\<Gamma> expr \\<tau> exprs \\<pi> \\<xi>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. body = \\<rho>", "apply (insert RejectIteratorT.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>E\n     RejectIteratorCall \\<M> ArrowCall src its its_ty :\n     \\<rho> \\<Longrightarrow>\n    body = \\<rho>", "apply (erule RejectIteratorTE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<rho>'.\n       \\<lbrakk>ArrowCall = ArrowCall;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (\\<M>, src, its, its_ty) : (\\<rho>, \\<sigma>, \\<rho>');\n        length src \\<le> Suc 0; \\<rho>' \\<le> Boolean[?]\\<rbrakk>\n       \\<Longrightarrow> body = \\<rho>", "using RejectIteratorT.hyps"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (\\<M>, src, its, its_ty) : (body, \\<tau>, \\<sigma>)\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (\\<M>, src, its, its_ty) : ?ys \\<Longrightarrow>\n  (body, \\<tau>, \\<sigma>) = ?ys\n  length src \\<le> 1\n  \\<sigma> \\<le> Boolean[?]\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<rho>'.\n       \\<lbrakk>ArrowCall = ArrowCall;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (\\<M>, src, its, its_ty) : (\\<rho>, \\<sigma>, \\<rho>');\n        length src \\<le> Suc 0; \\<rho>' \\<le> Boolean[?]\\<rbrakk>\n       \\<Longrightarrow> body = \\<rho>", "by blast"], ["proof (state)\nthis:\n  body = \\<rho>\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_ordered_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SortedByIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 2. \\<And>\\<Gamma> \\<xi>.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi> \\<Longrightarrow> [] = \\<xi>\n 3. \\<And>\\<Gamma> expr \\<tau> exprs \\<pi> \\<xi>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_ordered_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SortedByIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 2. \\<And>\\<Gamma> \\<xi>.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi> \\<Longrightarrow> [] = \\<xi>\n 3. \\<And>\\<Gamma> expr \\<tau> exprs \\<pi> \\<xi>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "case (SortedByIteratorT \\<Gamma> \\<M> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (\\<M>, src, its, its_ty) : (body, \\<tau>, \\<sigma>)\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (\\<M>, src, its, its_ty) : ?ys \\<Longrightarrow>\n  (body, \\<tau>, \\<sigma>) = ?ys\n  length src \\<le> 1\n  to_ordered_collection body \\<rho>\n  \\<Gamma> \\<turnstile>\\<^sub>E\n   SortedByIteratorCall \\<M> ArrowCall src its its_ty : \\<upsilon>\n\ngoal (3 subgoals):\n 1. \\<And>\\<Gamma> src its its_ty body \\<tau> \\<sigma> \\<rho> \\<upsilon>\n       \\<sigma>'.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>I\n                 (src, its, its_ty, body) : (\\<tau>, \\<sigma>, \\<rho>);\n        \\<And>ys.\n           \\<Gamma> \\<turnstile>\\<^sub>I\n            (src, its, its_ty, body) : ys \\<Longrightarrow>\n           (\\<tau>, \\<sigma>, \\<rho>) = ys;\n        length its \\<le> 1; to_ordered_collection \\<tau> \\<upsilon>;\n        \\<Gamma> \\<turnstile>\\<^sub>E\n         SortedByIteratorCall src ArrowCall its its_ty body :\n         \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> \\<upsilon> = \\<sigma>'\n 2. \\<And>\\<Gamma> \\<xi>.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi> \\<Longrightarrow> [] = \\<xi>\n 3. \\<And>\\<Gamma> expr \\<tau> exprs \\<pi> \\<xi>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<rho> = \\<upsilon>", "apply (insert SortedByIteratorT.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>E\n     SortedByIteratorCall \\<M> ArrowCall src its its_ty :\n     \\<upsilon> \\<Longrightarrow>\n    \\<rho> = \\<upsilon>", "apply (erule SortedByIteratorTE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<sigma> \\<rho>'.\n       \\<lbrakk>ArrowCall = ArrowCall;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (\\<M>, src, its, its_ty) : (\\<tau>, \\<sigma>, \\<rho>');\n        length src \\<le> Suc 0;\n        to_ordered_collection \\<tau> \\<upsilon>\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<upsilon>", "using SortedByIteratorT.hyps to_ordered_collection_det"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (\\<M>, src, its, its_ty) : (body, \\<tau>, \\<sigma>)\n  \\<Gamma> \\<turnstile>\\<^sub>I\n   (\\<M>, src, its, its_ty) : ?ys \\<Longrightarrow>\n  (body, \\<tau>, \\<sigma>) = ?ys\n  length src \\<le> 1\n  to_ordered_collection body \\<rho>\n  \\<lbrakk>to_ordered_collection ?\\<tau> ?\\<sigma>\\<^sub>1;\n   to_ordered_collection ?\\<tau> ?\\<sigma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?\\<sigma>\\<^sub>1 = ?\\<sigma>\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<sigma> \\<rho>'.\n       \\<lbrakk>ArrowCall = ArrowCall;\n        \\<Gamma> \\<turnstile>\\<^sub>I\n         (\\<M>, src, its, its_ty) : (\\<tau>, \\<sigma>, \\<rho>');\n        length src \\<le> Suc 0;\n        to_ordered_collection \\<tau> \\<upsilon>\\<rbrakk>\n       \\<Longrightarrow> \\<rho> = \\<upsilon>", "by blast"], ["proof (state)\nthis:\n  \\<rho> = \\<upsilon>\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> \\<xi>.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi> \\<Longrightarrow> [] = \\<xi>\n 2. \\<And>\\<Gamma> expr \\<tau> exprs \\<pi> \\<xi>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> \\<xi>.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi> \\<Longrightarrow> [] = \\<xi>\n 2. \\<And>\\<Gamma> expr \\<tau> exprs \\<pi> \\<xi>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "case (ExprListNilT \\<Gamma>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi>\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> \\<xi>.\n       \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi> \\<Longrightarrow> [] = \\<xi>\n 2. \\<And>\\<Gamma> expr \\<tau> exprs \\<pi> \\<xi>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi>\n\ngoal (1 subgoal):\n 1. [] = \\<xi>", "using expr_list_typing.cases"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<turnstile>\\<^sub>L [] : \\<xi>\n  \\<lbrakk>?a1.0 \\<turnstile>\\<^sub>L ?a2.0 : ?a3.0;\n   \\<And>\\<Gamma>.\n      \\<lbrakk>?a1.0 = \\<Gamma>; ?a2.0 = []; ?a3.0 = []\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>\\<Gamma> expr \\<tau> exprs \\<pi>.\n      \\<lbrakk>?a1.0 = \\<Gamma>; ?a2.0 = expr # exprs;\n       ?a3.0 = \\<tau> # \\<pi>; \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n       \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. [] = \\<xi>", "by auto"], ["proof (state)\nthis:\n  [] = \\<xi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> expr \\<tau> exprs \\<pi> \\<xi>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> expr \\<tau> exprs \\<pi> \\<xi>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "case (ExprListConsT \\<Gamma> expr \\<tau> exprs \\<pi>)"], ["proof (state)\nthis:\n  \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>\n  \\<Gamma> \\<turnstile>\\<^sub>E expr : ?\\<sigma> \\<Longrightarrow>\n  \\<tau> = ?\\<sigma>\n  \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>\n  \\<Gamma> \\<turnstile>\\<^sub>L exprs : ?\\<xi> \\<Longrightarrow>\n  \\<pi> = ?\\<xi>\n  \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma> expr \\<tau> exprs \\<pi> \\<xi>.\n       \\<lbrakk>\\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n        \\<And>\\<sigma>.\n           \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<sigma> \\<Longrightarrow>\n           \\<tau> = \\<sigma>;\n        \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>;\n        \\<And>\\<xi>.\n           \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<xi> \\<Longrightarrow>\n           \\<pi> = \\<xi>;\n        \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> # \\<pi> = \\<xi>", "apply (insert ExprListConsT.prems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<turnstile>\\<^sub>L expr # exprs : \\<xi> \\<Longrightarrow>\n    \\<tau> # \\<pi> = \\<xi>", "apply (erule ExprListTE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>expr # exprs = []; \\<xi> = []\\<rbrakk>\n    \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>\n 2. \\<And>expr \\<tau> exprs \\<pi>.\n       \\<lbrakk>expr # exprs = expr # exprs; \\<xi> = \\<tau> # \\<pi>;\n        \\<Gamma> \\<turnstile>\\<^sub>E expr : \\<tau>;\n        \\<Gamma> \\<turnstile>\\<^sub>L exprs : \\<pi>\\<rbrakk>\n       \\<Longrightarrow> \\<tau> # \\<pi> = \\<xi>", "by (simp_all add: ExprListConsT.hyps)"], ["proof (state)\nthis:\n  \\<tau> # \\<pi> = \\<xi>\n\ngoal:\nNo subgoals!", "qed"], ["", "(*** Code Setup *************************************************************)"], ["", "section \\<open>Code Setup\\<close>"], ["", "code_pred op_type"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "code_pred (modes:\n    i \\<Rightarrow> i \\<Rightarrow> i \\<Rightarrow> bool,\n    i \\<Rightarrow> i \\<Rightarrow> o \\<Rightarrow> bool) iterator_typing"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"]]}