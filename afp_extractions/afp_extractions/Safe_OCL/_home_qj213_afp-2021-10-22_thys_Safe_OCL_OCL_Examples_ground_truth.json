{"file_name": "/home/qj213/afp-2021-10-22/thys/Safe_OCL/OCL_Examples.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Safe_OCL", "problem_names": ["lemma less_le_not_le_classes1:\n  \"c < d \\<longleftrightarrow> c \\<le> d \\<and> \\<not> d \\<le> c\"\n  for c d :: classes1", "lemma order_refl_classes1:\n  \"c \\<le> c\"\n  for c :: classes1", "lemma order_trans_classes1:\n  \"c \\<le> d \\<Longrightarrow> d \\<le> e \\<Longrightarrow> c \\<le> e\"\n  for c d e :: classes1", "lemma antisym_classes1:\n  \"c \\<le> d \\<Longrightarrow> d \\<le> c \\<Longrightarrow> c = d\"\n  for c d :: classes1", "lemma sup_ge1_classes1:\n  \"c \\<le> c \\<squnion> d\"\n  for c d :: classes1", "lemma sup_ge2_classes1:\n  \"d \\<le> c \\<squnion> d\"\n  for c d :: classes1", "lemma sup_least_classes1:\n  \"c \\<le> e \\<Longrightarrow> d \\<le> e \\<Longrightarrow> c \\<squnion> d \\<le> e\"\n  for c d e :: classes1", "lemma less_classes1_code [code]:\n  \"(<) = subclass1_fun\"", "lemma less_eq_classes1_code [code]:\n  \"(\\<le>) = (\\<lambda>x y. subclass1_fun x y \\<or> x = y)\"", "lemma assoc_end_min_less_eq_max:\n  \"assoc |\\<in>| fmdom assocs \\<Longrightarrow>\n   fmlookup assocs assoc = Some ends \\<Longrightarrow>\n   role |\\<in>| fmdom ends  \\<Longrightarrow>\n   fmlookup ends role = Some end \\<Longrightarrow>\n   assoc_end_min end \\<le> assoc_end_max end\"", "lemma association_ends_unique:\n  assumes \"association_ends' classes assocs \\<C> from role end\\<^sub>1\"\n      and \"association_ends' classes assocs \\<C> from role end\\<^sub>2\"\n    shows \"end\\<^sub>1 = end\\<^sub>2\"", "lemma ex_alt_simps [simp]:\n  \"\\<exists>a. a\"\n  \"\\<exists>a. \\<not> a\"\n  \"(\\<exists>a. (a \\<longrightarrow> P) \\<and> a) = P\"\n  \"(\\<exists>a. \\<not> a \\<and> (\\<not> a \\<longrightarrow> P)) = P\"", "lemmas basic_type_le_less [simp] = Orderings.order_class.le_less\n  for x y :: \"'a basic_type\"", "lemma attribute_Employee_name [simp]:\n  \"attribute Employee STR ''name'' \\<D> \\<tau> =\n   (\\<D> = Employee \\<and> \\<tau> = String[1])\"", "lemma association_end_Project_members [simp]:\n  \"association_end Project None STR ''members'' \\<D> \\<tau> =\n   (\\<D> = Project \\<and> \\<tau> = (Employee, 1, 20, True, True))\"", "lemma association_end_Employee_projects_simp [simp]:\n  \"association_end Employee None STR ''projects'' \\<D> \\<tau> =\n   (\\<D> = Employee \\<and> \\<tau> = (Project, 0, \\<infinity>, False, True))\"", "lemma static_operation_Project_allProjects [simp]:\n  \"static_operation \\<langle>Project\\<rangle>\\<^sub>\\<T>[1] STR ''allProjects'' [] oper =\n   (oper = (STR ''allProjects'', \\<langle>Project\\<rangle>\\<^sub>\\<T>[1], [], Set \\<langle>Project\\<rangle>\\<^sub>\\<T>[1], True,\n     Some (MetaOperationCall \\<langle>Project\\<rangle>\\<^sub>\\<T>[1] AllInstancesOp)))\"", "lemma \"UnlimitedNatural < (Real :: classes1 basic_type)\"", "lemma \"\\<langle>Employee\\<rangle>\\<^sub>\\<T> < \\<langle>Person\\<rangle>\\<^sub>\\<T>\"", "lemma \"\\<langle>Person\\<rangle>\\<^sub>\\<T> \\<le> OclAny\"", "lemma \"\\<not> String \\<le> (Boolean :: classes1 basic_type)\"", "lemma \"Integer[?] < (OclSuper :: classes1 type)\"", "lemma \"Collection Real[?] < (OclSuper :: classes1 type)\"", "lemma \"Set (Collection Boolean[1]) < (OclSuper :: classes1 type)\"", "lemma \"Set (Bag Boolean[1]) < Set (Collection Boolean[?] :: classes1 type)\"", "lemma \"Tuple (fmap_of_list [(STR ''a'', Boolean[1]), (STR ''b'', Integer[1])]) <\n       Tuple (fmap_of_list [(STR ''a'', Boolean[?] :: classes1 type)])\"", "lemma \"Integer[1] \\<squnion> (Real[?] :: classes1 type) = Real[?]\"", "lemma \"Set Integer[1] \\<squnion> Set (Real[1] :: classes1 type) = Set Real[1]\"", "lemma \"Set Integer[1] \\<squnion> Bag (Boolean[?] :: classes1 type) = Collection OclAny[?]\"", "lemma \"Set Integer[1] \\<squnion> (Real[1] :: classes1 type) = OclSuper\"", "lemma \"\\<not> OrderedSet Boolean[1] < Set (Boolean[1] :: classes1 type)\"", "lemma\n  \"\\<Gamma>\\<^sub>0 \\<turnstile> EnumLiteral STR ''E1'' STR ''A'' : (Enum STR ''E1'')[1]\"", "lemma\n  \"\\<Gamma>\\<^sub>0 \\<turnstile> OperationCall (BooleanLiteral True) DotCall OrOp\n    [BooleanLiteral False] : Boolean[1]\"", "lemma\n  \"\\<Gamma>\\<^sub>0 \\<turnstile> OperationCall (NullLiteral) DotCall AndOp\n    [BooleanLiteral True] : Boolean[?]\"", "lemma\n  \"\\<Gamma>\\<^sub>0 \\<turnstile> Let (STR ''x'') (Some Real[1]) (IntegerLiteral 5)\n    (OperationCall (Var STR ''x'') DotCall PlusOp [IntegerLiteral 7]) : Real[1]\"", "lemma\n  \"\\<Gamma>\\<^sub>0 \\<turnstile> OperationCall (NullLiteral) DotCall OclIsUndefinedOp [] : Boolean[1]\"", "lemma\n  \"\\<Gamma>\\<^sub>0 \\<turnstile> OperationCall (CollectionLiteral SequenceKind\n    [CollectionRange (IntegerLiteral 1) (IntegerLiteral 5),\n     CollectionItem NullLiteral])\n    DotCall OclIsUndefinedOp [] : Sequence Boolean[1]\"", "lemma\n  \"\\<Gamma>\\<^sub>0 \\<turnstile> OperationCall (CollectionLiteral SequenceKind\n    [CollectionRange (IntegerLiteral 1) (IntegerLiteral 5)])\n    ArrowCall ProductOp\n    [CollectionLiteral SetKind\n      [CollectionItem (StringLiteral ''a''),\n       CollectionItem (StringLiteral ''b'')]] :\n    Set (Tuple (fmap_of_list [\n      (STR ''first'', Integer[1]), (STR ''second'', String[1])]))\"", "lemma\n  \"\\<Gamma>\\<^sub>0 \\<turnstile> IterateCall (CollectionLiteral SequenceKind\n    [CollectionRange (IntegerLiteral 1) (IntegerLiteral 5),\n     CollectionItem NullLiteral]) SafeArrowCall\n    [STR ''x''] None\n    (STR ''acc'') (Some Real[1]) (IntegerLiteral 0)\n    (OperationCall (Var STR ''acc'') DotCall PlusOp [Var STR ''x'']) : Real[1]\"", "lemma\n  \"\\<Gamma>\\<^sub>0 \\<turnstile> OperationCall (CollectionLiteral SequenceKind\n    [CollectionRange (IntegerLiteral 1) (IntegerLiteral 5),\n     CollectionItem NullLiteral])\n    SafeArrowCall CollectionMaxOp [] : Integer[1]\"", "lemma\n  \"\\<Gamma>\\<^sub>0 \\<turnstile> Let (STR ''x'') (Some (Sequence String[?]))\n    (CollectionLiteral SequenceKind\n      [CollectionItem (StringLiteral ''abc''),\n       CollectionItem (StringLiteral ''zxc'')])\n    (AnyIteratorCall (Var STR ''x'') ArrowCall\n      [STR ''it''] None\n      (OperationCall (Var STR ''it'') DotCall EqualOp\n        [StringLiteral ''test''])) : String[?]\"", "lemma\n  \"\\<Gamma>\\<^sub>0 \\<turnstile> Let STR ''x'' (Some (Sequence String[?]))\n    (CollectionLiteral SequenceKind\n      [CollectionItem (StringLiteral ''abc''),\n       CollectionItem (StringLiteral ''zxc'')])\n    (ClosureIteratorCall (Var STR ''x'') SafeArrowCall\n      [STR ''it''] None\n      (Var STR ''it'')) : OrderedSet String[1]\"", "lemma\n  \"\\<Gamma>\\<^sub>0(STR ''self'' \\<mapsto>\\<^sub>f Employee[1]) \\<turnstile>\n    AttributeCall (Var STR ''self'') DotCall STR ''name'' : String[1]\"", "lemma\n  \"\\<Gamma>\\<^sub>0(STR ''self'' \\<mapsto>\\<^sub>f Employee[1]) \\<turnstile>\n    AssociationEndCall (Var STR ''self'') DotCall None\n      STR ''projects'' : Set Project[1]\"", "lemma\n  \"\\<Gamma>\\<^sub>0(STR ''self'' \\<mapsto>\\<^sub>f Employee[1]) \\<turnstile>\n    AssociationEndCall (AssociationEndCall (Var STR ''self'')\n        DotCall None STR ''projects'')\n      DotCall None STR ''members'' : Bag Employee[1]\"", "lemma\n  \"\\<Gamma>\\<^sub>0 \\<turnstile> MetaOperationCall Project[?] AllInstancesOp : Set Project[?]\"", "lemma\n  \"\\<Gamma>\\<^sub>0 \\<turnstile> StaticOperationCall Project[1] STR ''allProjects'' [] : Set Project[1]\"", "lemma\n  \"\\<nexists>\\<tau>. \\<Gamma>\\<^sub>0 \\<turnstile> OperationCall (BooleanLiteral True) DotCall EqualOp\n    [NullLiteral] : \\<tau>\"", "lemma\n  \"\\<nexists>\\<tau>. \\<Gamma>\\<^sub>0 \\<turnstile> Let STR ''x'' (Some Boolean[1]) (IntegerLiteral 5)\n    (OperationCall (Var STR ''x'') DotCall AndOp [BooleanLiteral True]) : \\<tau>\"", "lemma\n  \"\\<nexists>\\<tau>. \\<Gamma>\\<^sub>0 \\<turnstile> Let STR ''x'' (Some (Sequence String[?]))\n    (CollectionLiteral SequenceKind\n      [CollectionItem (StringLiteral ''abc''),\n       CollectionItem (StringLiteral ''zxc'')])\n    (ClosureIteratorCall (Var STR ''x'') ArrowCall [STR ''it''] None\n      (IntegerLiteral 1)) : \\<tau>\"", "lemma\n  \"\\<nexists>\\<tau>. \\<Gamma>\\<^sub>0 \\<turnstile> OperationCall (CollectionLiteral SequenceKind\n    [CollectionRange (IntegerLiteral 1) (IntegerLiteral 5),\n     CollectionItem NullLiteral])\n    ArrowCall CollectionMaxOp [] : \\<tau>\""], "translations": [["", "lemma less_le_not_le_classes1:\n  \"c < d \\<longleftrightarrow> c \\<le> d \\<and> \\<not> d \\<le> c\"\n  for c d :: classes1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (c < d) = (c \\<le> d \\<and> \\<not> d \\<le> c)", "unfolding less_classes1_def less_eq_classes1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. subclass1 c d =\n    (subclass1\\<^sup>=\\<^sup>= c d \\<and>\n     \\<not> subclass1\\<^sup>=\\<^sup>= d c)", "using subclass1.simps"], ["proof (prove)\nusing this:\n  subclass1 ?a1.0 ?a2.0 =\n  ((\\<exists>c.\n       ?a1.0 = c \\<and> ?a2.0 = Object \\<and> c \\<noteq> Object) \\<or>\n   ?a1.0 = Employee \\<and> ?a2.0 = Person \\<or>\n   ?a1.0 = Customer \\<and> ?a2.0 = Person)\n\ngoal (1 subgoal):\n 1. subclass1 c d =\n    (subclass1\\<^sup>=\\<^sup>= c d \\<and>\n     \\<not> subclass1\\<^sup>=\\<^sup>= d c)", "by auto"], ["", "lemma order_refl_classes1:\n  \"c \\<le> c\"\n  for c :: classes1"], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<le> c", "unfolding less_eq_classes1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. subclass1\\<^sup>=\\<^sup>= c c", "by simp"], ["", "lemma order_trans_classes1:\n  \"c \\<le> d \\<Longrightarrow> d \\<le> e \\<Longrightarrow> c \\<le> e\"\n  for c d e :: classes1"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<le> d; d \\<le> e\\<rbrakk> \\<Longrightarrow> c \\<le> e", "unfolding less_eq_classes1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>subclass1\\<^sup>=\\<^sup>= c d;\n     subclass1\\<^sup>=\\<^sup>= d e\\<rbrakk>\n    \\<Longrightarrow> subclass1\\<^sup>=\\<^sup>= c e", "using subclass1.simps"], ["proof (prove)\nusing this:\n  subclass1 ?a1.0 ?a2.0 =\n  ((\\<exists>c.\n       ?a1.0 = c \\<and> ?a2.0 = Object \\<and> c \\<noteq> Object) \\<or>\n   ?a1.0 = Employee \\<and> ?a2.0 = Person \\<or>\n   ?a1.0 = Customer \\<and> ?a2.0 = Person)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>subclass1\\<^sup>=\\<^sup>= c d;\n     subclass1\\<^sup>=\\<^sup>= d e\\<rbrakk>\n    \\<Longrightarrow> subclass1\\<^sup>=\\<^sup>= c e", "by auto"], ["", "lemma antisym_classes1:\n  \"c \\<le> d \\<Longrightarrow> d \\<le> c \\<Longrightarrow> c = d\"\n  for c d :: classes1"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<le> d; d \\<le> c\\<rbrakk> \\<Longrightarrow> c = d", "unfolding less_eq_classes1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>subclass1\\<^sup>=\\<^sup>= c d;\n     subclass1\\<^sup>=\\<^sup>= d c\\<rbrakk>\n    \\<Longrightarrow> c = d", "using subclass1.simps"], ["proof (prove)\nusing this:\n  subclass1 ?a1.0 ?a2.0 =\n  ((\\<exists>c.\n       ?a1.0 = c \\<and> ?a2.0 = Object \\<and> c \\<noteq> Object) \\<or>\n   ?a1.0 = Employee \\<and> ?a2.0 = Person \\<or>\n   ?a1.0 = Customer \\<and> ?a2.0 = Person)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>subclass1\\<^sup>=\\<^sup>= c d;\n     subclass1\\<^sup>=\\<^sup>= d c\\<rbrakk>\n    \\<Longrightarrow> c = d", "by auto"], ["", "lemma sup_ge1_classes1:\n  \"c \\<le> c \\<squnion> d\"\n  for c d :: classes1"], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<le> c \\<squnion> d", "by (induct c; auto simp add: less_eq_classes1_def less_classes1_def subclass1.simps)"], ["", "lemma sup_ge2_classes1:\n  \"d \\<le> c \\<squnion> d\"\n  for c d :: classes1"], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<le> c \\<squnion> d", "by (induct c; auto simp add: less_eq_classes1_def less_classes1_def subclass1.simps)"], ["", "lemma sup_least_classes1:\n  \"c \\<le> e \\<Longrightarrow> d \\<le> e \\<Longrightarrow> c \\<squnion> d \\<le> e\"\n  for c d e :: classes1"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<le> e; d \\<le> e\\<rbrakk>\n    \\<Longrightarrow> c \\<squnion> d \\<le> e", "by (induct c; induct d;\n      auto simp add: less_eq_classes1_def less_classes1_def subclass1.simps)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(classes1, semilattice_sup_class)", "apply intro_classes"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<le> x \\<squnion> y\n 6. \\<And>y x. y \\<le> x \\<squnion> y\n 7. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x", "apply (simp add: less_le_not_le_classes1)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<le> x \\<squnion> y\n 5. \\<And>y x. y \\<le> x \\<squnion> y\n 6. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x", "apply (simp add: order_refl_classes1)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<le> x \\<squnion> y\n 4. \\<And>y x. y \\<le> x \\<squnion> y\n 5. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x", "apply (rule order_trans_classes1; auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<le> x \\<squnion> y\n 3. \\<And>y x. y \\<le> x \\<squnion> y\n 4. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x", "apply (simp add: antisym_classes1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y. x \\<le> x \\<squnion> y\n 2. \\<And>y x. y \\<le> x \\<squnion> y\n 3. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x", "apply (simp add: sup_ge1_classes1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y x. y \\<le> x \\<squnion> y\n 2. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x", "apply (simp add: sup_ge2_classes1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x", "by (simp add: sup_least_classes1)"], ["", "end"], ["", "code_pred subclass1"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "fun subclass1_fun where\n  \"subclass1_fun Object \\<C> = False\"\n| \"subclass1_fun Person \\<C> = (\\<C> = Object)\"\n| \"subclass1_fun Employee \\<C> = (\\<C> = Object \\<or> \\<C> = Person)\"\n| \"subclass1_fun Customer \\<C> = (\\<C> = Object \\<or> \\<C> = Person)\"\n| \"subclass1_fun Project \\<C> = (\\<C> = Object)\"\n| \"subclass1_fun Task \\<C> = (\\<C> = Object)\"\n| \"subclass1_fun Sprint \\<C> = (\\<C> = Object)\""], ["", "lemma less_classes1_code [code]:\n  \"(<) = subclass1_fun\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (<) = subclass1_fun", "proof (intro ext iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa. x < xa \\<Longrightarrow> subclass1_fun x xa\n 2. \\<And>x xa. subclass1_fun x xa \\<Longrightarrow> x < xa", "fix \\<C> \\<D> :: \"classes1\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa. x < xa \\<Longrightarrow> subclass1_fun x xa\n 2. \\<And>x xa. subclass1_fun x xa \\<Longrightarrow> x < xa", "show \"\\<C> < \\<D> \\<Longrightarrow> subclass1_fun \\<C> \\<D>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<C> < \\<D> \\<Longrightarrow> subclass1_fun \\<C> \\<D>", "unfolding less_classes1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. subclass1 \\<C> \\<D> \\<Longrightarrow> subclass1_fun \\<C> \\<D>", "apply (erule subclass1.cases, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<D> = Object; \\<C> \\<noteq> Object\\<rbrakk>\n    \\<Longrightarrow> subclass1_fun \\<C> Object", "using subclass1_fun.elims(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> subclass1_fun ?x ?xa;\n   \\<And>\\<C>.\n      \\<lbrakk>?x = Object; ?xa = \\<C>\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>\\<C>.\n      \\<lbrakk>?x = Person; ?xa = \\<C>; \\<C> \\<noteq> Object\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>\\<C>.\n      \\<lbrakk>?x = Employee; ?xa = \\<C>;\n       \\<not> (\\<C> = Object \\<or> \\<C> = Person)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>\\<C>.\n      \\<lbrakk>?x = Customer; ?xa = \\<C>;\n       \\<not> (\\<C> = Object \\<or> \\<C> = Person)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>\\<C>.\n      \\<lbrakk>?x = Project; ?xa = \\<C>; \\<C> \\<noteq> Object\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>\\<C>.\n      \\<lbrakk>?x = Task; ?xa = \\<C>; \\<C> \\<noteq> Object\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>\\<C>.\n      \\<lbrakk>?x = Sprint; ?xa = \\<C>; \\<C> \\<noteq> Object\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<D> = Object; \\<C> \\<noteq> Object\\<rbrakk>\n    \\<Longrightarrow> subclass1_fun \\<C> Object", "by blast"], ["proof (state)\nthis:\n  \\<C> < \\<D> \\<Longrightarrow> subclass1_fun \\<C> \\<D>\n\ngoal (1 subgoal):\n 1. \\<And>x xa. subclass1_fun x xa \\<Longrightarrow> x < xa", "show \"subclass1_fun \\<C> \\<D> \\<Longrightarrow> \\<C> < \\<D>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subclass1_fun \\<C> \\<D> \\<Longrightarrow> \\<C> < \\<D>", "by (erule subclass1_fun.elims, auto simp add: less_classes1_def subclass1.intros)"], ["proof (state)\nthis:\n  subclass1_fun \\<C> \\<D> \\<Longrightarrow> \\<C> < \\<D>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma less_eq_classes1_code [code]:\n  \"(\\<le>) = (\\<lambda>x y. subclass1_fun x y \\<or> x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<le>) = (\\<lambda>x y. subclass1_fun x y \\<or> x = y)", "unfolding dual_order.order_iff_strict less_classes1_code"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>b a. subclass1_fun b a \\<or> a = b) =\n    (\\<lambda>x y. subclass1_fun x y \\<or> x = y)", "by auto"], ["", "(*** Object Model ***********************************************************)"], ["", "section \\<open>Object Model\\<close>"], ["", "abbreviation \"\\<Gamma>\\<^sub>0 \\<equiv> fmempty :: classes1 type env\""], ["", "declare [[coercion \"ObjectType :: classes1 \\<Rightarrow> classes1 basic_type\"]]"], ["", "declare [[coercion \"phantom :: String.literal \\<Rightarrow> classes1 enum\"]]"], ["", "instantiation classes1 :: ocl_object_model\nbegin"], ["", "definition \"classes_classes1 \\<equiv>\n  {|Object, Person, Employee, Customer, Project, Task, Sprint|}\""], ["", "definition \"attributes_classes1 \\<equiv> fmap_of_list [\n  (Person, fmap_of_list [\n    (STR ''name'', String[1] :: classes1 type)]),\n  (Employee, fmap_of_list [\n    (STR ''name'', String[1]),\n    (STR ''position'', String[1])]),\n  (Customer, fmap_of_list [\n    (STR ''vip'', Boolean[1])]),\n  (Project, fmap_of_list [\n    (STR ''name'', String[1]),\n    (STR ''cost'', Real[?])]),\n  (Task, fmap_of_list [\n    (STR ''description'', String[1])])]\""], ["", "abbreviation \"assocs \\<equiv> [\n  STR ''ProjectManager'' \\<mapsto>\\<^sub>f [\n    STR ''projects'' \\<mapsto>\\<^sub>f (Project, 0::nat, \\<infinity>::enat, False, True),\n    STR ''manager'' \\<mapsto>\\<^sub>f (Employee, 1, 1, False, False)],\n  STR ''ProjectMember'' \\<mapsto>\\<^sub>f [\n    STR ''member_of'' \\<mapsto>\\<^sub>f (Project, 0, \\<infinity>, False, False),\n    STR ''members'' \\<mapsto>\\<^sub>f (Employee, 1, 20, True, True)],\n  STR ''ManagerEmployee'' \\<mapsto>\\<^sub>f [\n    STR ''line_manager'' \\<mapsto>\\<^sub>f (Employee, 0, 1, False, False),\n    STR ''project_manager'' \\<mapsto>\\<^sub>f (Employee, 0, \\<infinity>, False, False),\n    STR ''employees'' \\<mapsto>\\<^sub>f (Employee, 3, 7, False, False)],\n  STR ''ProjectCustomer'' \\<mapsto>\\<^sub>f [\n    STR ''projects'' \\<mapsto>\\<^sub>f (Project, 0, \\<infinity>, False, True),\n    STR ''customer'' \\<mapsto>\\<^sub>f (Customer, 1, 1, False, False)],\n  STR ''ProjectTask'' \\<mapsto>\\<^sub>f [\n    STR ''project'' \\<mapsto>\\<^sub>f (Project, 1, 1, False, False),\n    STR ''tasks'' \\<mapsto>\\<^sub>f (Task, 0, \\<infinity>, True, True)],\n  STR ''SprintTaskAssignee'' \\<mapsto>\\<^sub>f [\n    STR ''sprint'' \\<mapsto>\\<^sub>f (Sprint, 0, 10, False, True),\n    STR ''tasks'' \\<mapsto>\\<^sub>f (Task, 0, 5, False, True),\n    STR ''assignee'' \\<mapsto>\\<^sub>f (Employee, 0, 1, False, False)]]\""], ["", "definition \"associations_classes1 \\<equiv> assocs\""], ["", "definition \"association_classes_classes1 \\<equiv> fmempty :: classes1 \\<rightharpoonup>\\<^sub>f assoc\""], ["", "text \\<open>\n\\begin{verbatim}\ncontext Project\ndef: membersCount() : Integer[1] = members->size()\ndef: membersByName(mn : String[1]) : Set(Employee[1]) =\n       members->select(member | member.name = mn)\nstatic def: allProjects() : Set(Project[1]) =\n              Project[1].allInstances()\n\\end{verbatim}\\<close>"], ["", "definition \"operations_classes1 \\<equiv> [\n  (STR ''membersCount'', Project[1], [], Integer[1], False,\n   Some (OperationCall\n    (AssociationEndCall (Var STR ''self'') DotCall None STR ''members'')\n    ArrowCall CollectionSizeOp [])),\n  (STR ''membersByName'', Project[1], [(STR ''mn'', String[1], In)],\n    Set Employee[1], False,\n   Some (SelectIteratorCall\n    (AssociationEndCall (Var STR ''self'') DotCall None STR ''members'')\n    ArrowCall [STR ''member''] None\n    (OperationCall\n      (AttributeCall (Var STR ''member'') DotCall STR ''name'')\n      DotCall EqualOp [Var STR ''mn'']))),\n  (STR ''allProjects'', Project[1], [], Set Project[1], True,\n   Some (MetaOperationCall Project[1] AllInstancesOp))\n  ] :: (classes1 type, classes1 expr) oper_spec list\""], ["", "definition \"literals_classes1 \\<equiv> fmap_of_list [\n  (STR ''E1'' :: classes1 enum, {|STR ''A'', STR ''B''|}),\n  (STR ''E2'', {|STR ''C'', STR ''D'', STR ''E''|})]\""], ["", "lemma assoc_end_min_less_eq_max:\n  \"assoc |\\<in>| fmdom assocs \\<Longrightarrow>\n   fmlookup assocs assoc = Some ends \\<Longrightarrow>\n   role |\\<in>| fmdom ends  \\<Longrightarrow>\n   fmlookup ends role = Some end \\<Longrightarrow>\n   assoc_end_min end \\<le> assoc_end_max end\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>assoc |\\<in>| fmdom assocs; fmlookup assocs assoc = Some ends;\n     role |\\<in>| fmdom ends; fmlookup ends role = Some end\\<rbrakk>\n    \\<Longrightarrow> enat (assoc_end_min end) \\<le> assoc_end_max end", "unfolding assoc_end_min_def assoc_end_max_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>assoc |\\<in>| fmdom assocs; fmlookup assocs assoc = Some ends;\n     role |\\<in>| fmdom ends; fmlookup ends role = Some end\\<rbrakk>\n    \\<Longrightarrow> enat ((fst \\<circ> snd) end)\n                      \\<le> (fst \\<circ> snd \\<circ> snd) end", "using zero_enat_def one_enat_def numeral_eq_enat"], ["proof (prove)\nusing this:\n  0 = enat 0\n  1 = enat 1\n  numeral ?k = enat (numeral ?k)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>assoc |\\<in>| fmdom assocs; fmlookup assocs assoc = Some ends;\n     role |\\<in>| fmdom ends; fmlookup ends role = Some end\\<rbrakk>\n    \\<Longrightarrow> enat ((fst \\<circ> snd) end)\n                      \\<le> (fst \\<circ> snd \\<circ> snd) end", "by auto"], ["", "lemma association_ends_unique:\n  assumes \"association_ends' classes assocs \\<C> from role end\\<^sub>1\"\n      and \"association_ends' classes assocs \\<C> from role end\\<^sub>2\"\n    shows \"end\\<^sub>1 = end\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. end\\<^sub>1 = end\\<^sub>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. end\\<^sub>1 = end\\<^sub>2", "have \"\\<not> association_ends_not_unique' classes assocs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> association_ends_not_unique' classes assocs", "by eval"], ["proof (state)\nthis:\n  \\<not> association_ends_not_unique' classes assocs\n\ngoal (1 subgoal):\n 1. end\\<^sub>1 = end\\<^sub>2", "with assms"], ["proof (chain)\npicking this:\n  association_ends' classes assocs \\<C> from role end\\<^sub>1\n  association_ends' classes assocs \\<C> from role end\\<^sub>2\n  \\<not> association_ends_not_unique' classes assocs", "show ?thesis"], ["proof (prove)\nusing this:\n  association_ends' classes assocs \\<C> from role end\\<^sub>1\n  association_ends' classes assocs \\<C> from role end\\<^sub>2\n  \\<not> association_ends_not_unique' classes assocs\n\ngoal (1 subgoal):\n 1. end\\<^sub>1 = end\\<^sub>2", "using association_ends_not_unique'.simps"], ["proof (prove)\nusing this:\n  association_ends' classes assocs \\<C> from role end\\<^sub>1\n  association_ends' classes assocs \\<C> from role end\\<^sub>2\n  \\<not> association_ends_not_unique' classes assocs\n  association_ends_not_unique' ?a1.0 ?a2.0 =\n  (\\<exists>classes associations \\<C> from role end\\<^sub>1 end\\<^sub>2.\n      ?a1.0 = classes \\<and>\n      ?a2.0 = associations \\<and>\n      association_ends' classes associations \\<C> from role\n       end\\<^sub>1 \\<and>\n      association_ends' classes associations \\<C> from role\n       end\\<^sub>2 \\<and>\n      end\\<^sub>1 \\<noteq> end\\<^sub>2)\n\ngoal (1 subgoal):\n 1. end\\<^sub>1 = end\\<^sub>2", "by blast"], ["proof (state)\nthis:\n  end\\<^sub>1 = end\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(classes1, ocl_object_model_class)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>assoc ends role end.\n       \\<lbrakk>assoc |\\<in>| fmdom associations;\n        fmlookup associations assoc = Some ends; role |\\<in>| fmdom ends;\n        fmlookup ends role = Some end\\<rbrakk>\n       \\<Longrightarrow> enat (assoc_end_min end) \\<le> assoc_end_max end\n 2. \\<And>\\<C> from role end\\<^sub>1 end\\<^sub>2.\n       \\<lbrakk>association_ends' classes associations \\<C> from role\n                 end\\<^sub>1;\n        association_ends' classes associations \\<C> from role\n         end\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> end\\<^sub>1 = end\\<^sub>2", "unfolding associations_classes1_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>assoc ends role end.\n       \\<lbrakk>assoc |\\<in>| fmdom assocs;\n        fmlookup assocs assoc = Some ends; role |\\<in>| fmdom ends;\n        fmlookup ends role = Some end\\<rbrakk>\n       \\<Longrightarrow> enat (assoc_end_min end) \\<le> assoc_end_max end\n 2. \\<And>\\<C> from role end\\<^sub>1 end\\<^sub>2.\n       \\<lbrakk>association_ends' classes assocs \\<C> from role end\\<^sub>1;\n        association_ends' classes assocs \\<C> from role end\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> end\\<^sub>1 = end\\<^sub>2", "using assoc_end_min_less_eq_max"], ["proof (prove)\nusing this:\n  \\<lbrakk>?assoc |\\<in>| fmdom assocs; fmlookup assocs ?assoc = Some ?ends;\n   ?role |\\<in>| fmdom ?ends; fmlookup ?ends ?role = Some ?end\\<rbrakk>\n  \\<Longrightarrow> enat (assoc_end_min ?end) \\<le> assoc_end_max ?end\n\ngoal (2 subgoals):\n 1. \\<And>assoc ends role end.\n       \\<lbrakk>assoc |\\<in>| fmdom assocs;\n        fmlookup assocs assoc = Some ends; role |\\<in>| fmdom ends;\n        fmlookup ends role = Some end\\<rbrakk>\n       \\<Longrightarrow> enat (assoc_end_min end) \\<le> assoc_end_max end\n 2. \\<And>\\<C> from role end\\<^sub>1 end\\<^sub>2.\n       \\<lbrakk>association_ends' classes assocs \\<C> from role end\\<^sub>1;\n        association_ends' classes assocs \\<C> from role end\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> end\\<^sub>1 = end\\<^sub>2", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<C> from role end\\<^sub>1 end\\<^sub>2.\n       \\<lbrakk>association_ends' classes assocs \\<C> from role end\\<^sub>1;\n        association_ends' classes assocs \\<C> from role end\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> end\\<^sub>1 = end\\<^sub>2", "using association_ends_unique"], ["proof (prove)\nusing this:\n  \\<lbrakk>association_ends' classes assocs ?\\<C> ?from ?role ?end\\<^sub>1;\n   association_ends' classes assocs ?\\<C> ?from ?role ?end\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?end\\<^sub>1 = ?end\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>\\<C> from role end\\<^sub>1 end\\<^sub>2.\n       \\<lbrakk>association_ends' classes assocs \\<C> from role end\\<^sub>1;\n        association_ends' classes assocs \\<C> from role end\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> end\\<^sub>1 = end\\<^sub>2", "by blast"], ["", "end"], ["", "(*** Simplification Rules ***************************************************)"], ["", "section \\<open>Simplification Rules\\<close>"], ["", "lemma ex_alt_simps [simp]:\n  \"\\<exists>a. a\"\n  \"\\<exists>a. \\<not> a\"\n  \"(\\<exists>a. (a \\<longrightarrow> P) \\<and> a) = P\"\n  \"(\\<exists>a. \\<not> a \\<and> (\\<not> a \\<longrightarrow> P)) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>a. a &&& \\<exists>a. \\<not> a) &&&\n    (\\<exists>a. (a \\<longrightarrow> P) \\<and> a) = P &&&\n    (\\<exists>a. \\<not> a \\<and> (\\<not> a \\<longrightarrow> P)) = P", "by auto"], ["", "declare numeral_eq_enat [simp]"], ["", "lemmas basic_type_le_less [simp] = Orderings.order_class.le_less\n  for x y :: \"'a basic_type\""], ["", "declare element_type_alt_simps [simp]"], ["", "declare update_element_type.simps [simp]"], ["", "declare to_unique_collection.simps [simp]"], ["", "declare to_nonunique_collection.simps [simp]"], ["", "declare to_ordered_collection.simps [simp]"], ["", "declare assoc_end_class_def [simp]"], ["", "declare assoc_end_min_def [simp]"], ["", "declare assoc_end_max_def [simp]"], ["", "declare assoc_end_ordered_def [simp]"], ["", "declare assoc_end_unique_def [simp]"], ["", "declare oper_name_def [simp]"], ["", "declare oper_context_def [simp]"], ["", "declare oper_params_def [simp]"], ["", "declare oper_result_def [simp]"], ["", "declare oper_static_def [simp]"], ["", "declare oper_body_def [simp]"], ["", "declare oper_in_params_def [simp]"], ["", "declare oper_out_params_def [simp]"], ["", "declare assoc_end_type_def [simp]"], ["", "declare oper_type_def [simp]"], ["", "declare op_type_alt_simps [simp]"], ["", "declare typing_alt_simps [simp]"], ["", "declare normalize_alt_simps [simp]"], ["", "declare nf_typing.simps [simp]"], ["", "declare subclass1.intros [intro]"], ["", "declare less_classes1_def [simp]"], ["", "declare literals_classes1_def [simp]"], ["", "lemma attribute_Employee_name [simp]:\n  \"attribute Employee STR ''name'' \\<D> \\<tau> =\n   (\\<D> = Employee \\<and> \\<tau> = String[1])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. attribute Employee STR ''name'' \\<D> \\<tau> =\n    (\\<D> = Employee \\<and> \\<tau> = String[1])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. attribute Employee STR ''name'' \\<D> \\<tau> =\n    (\\<D> = Employee \\<and> \\<tau> = String[1])", "have \"attribute Employee STR ''name'' Employee String[1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. attribute Employee STR ''name'' Employee String[1]", "by eval"], ["proof (state)\nthis:\n  attribute Employee STR ''name'' Employee String[1]\n\ngoal (1 subgoal):\n 1. attribute Employee STR ''name'' \\<D> \\<tau> =\n    (\\<D> = Employee \\<and> \\<tau> = String[1])", "thus ?thesis"], ["proof (prove)\nusing this:\n  attribute Employee STR ''name'' Employee String[1]\n\ngoal (1 subgoal):\n 1. attribute Employee STR ''name'' \\<D> \\<tau> =\n    (\\<D> = Employee \\<and> \\<tau> = String[1])", "using attribute_det"], ["proof (prove)\nusing this:\n  attribute Employee STR ''name'' Employee String[1]\n  \\<lbrakk>attribute ?\\<C> ?attr ?\\<D>\\<^sub>1 ?\\<tau>\\<^sub>1;\n   attribute ?\\<C> ?attr ?\\<D>\\<^sub>2 ?\\<tau>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?\\<D>\\<^sub>1 = ?\\<D>\\<^sub>2 \\<and>\n                    ?\\<tau>\\<^sub>1 = ?\\<tau>\\<^sub>2\n\ngoal (1 subgoal):\n 1. attribute Employee STR ''name'' \\<D> \\<tau> =\n    (\\<D> = Employee \\<and> \\<tau> = String[1])", "by blast"], ["proof (state)\nthis:\n  attribute Employee STR ''name'' \\<D> \\<tau> =\n  (\\<D> = Employee \\<and> \\<tau> = String[1])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma association_end_Project_members [simp]:\n  \"association_end Project None STR ''members'' \\<D> \\<tau> =\n   (\\<D> = Project \\<and> \\<tau> = (Employee, 1, 20, True, True))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. association_end Project None STR ''members'' \\<D> \\<tau> =\n    (\\<D> = Project \\<and> \\<tau> = (Employee, 1, 20, True, True))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. association_end Project None STR ''members'' \\<D> \\<tau> =\n    (\\<D> = Project \\<and> \\<tau> = (Employee, 1, 20, True, True))", "have \"association_end Project None STR ''members''\n          Project (Employee, 1, 20, True, True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. association_end Project None STR ''members'' Project\n     (Employee, 1, 20, True, True)", "by eval"], ["proof (state)\nthis:\n  association_end Project None STR ''members'' Project\n   (Employee, 1, 20, True, True)\n\ngoal (1 subgoal):\n 1. association_end Project None STR ''members'' \\<D> \\<tau> =\n    (\\<D> = Project \\<and> \\<tau> = (Employee, 1, 20, True, True))", "thus ?thesis"], ["proof (prove)\nusing this:\n  association_end Project None STR ''members'' Project\n   (Employee, 1, 20, True, True)\n\ngoal (1 subgoal):\n 1. association_end Project None STR ''members'' \\<D> \\<tau> =\n    (\\<D> = Project \\<and> \\<tau> = (Employee, 1, 20, True, True))", "using association_end_det"], ["proof (prove)\nusing this:\n  association_end Project None STR ''members'' Project\n   (Employee, 1, 20, True, True)\n  \\<lbrakk>association_end ?\\<C> ?from ?role ?\\<D>\\<^sub>1 ?end\\<^sub>1;\n   association_end ?\\<C> ?from ?role ?\\<D>\\<^sub>2 ?end\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?\\<D>\\<^sub>1 = ?\\<D>\\<^sub>2 \\<and>\n                    ?end\\<^sub>1 = ?end\\<^sub>2\n\ngoal (1 subgoal):\n 1. association_end Project None STR ''members'' \\<D> \\<tau> =\n    (\\<D> = Project \\<and> \\<tau> = (Employee, 1, 20, True, True))", "by blast"], ["proof (state)\nthis:\n  association_end Project None STR ''members'' \\<D> \\<tau> =\n  (\\<D> = Project \\<and> \\<tau> = (Employee, 1, 20, True, True))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma association_end_Employee_projects_simp [simp]:\n  \"association_end Employee None STR ''projects'' \\<D> \\<tau> =\n   (\\<D> = Employee \\<and> \\<tau> = (Project, 0, \\<infinity>, False, True))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. association_end Employee None STR ''projects'' \\<D> \\<tau> =\n    (\\<D> = Employee \\<and> \\<tau> = (Project, 0, \\<infinity>, False, True))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. association_end Employee None STR ''projects'' \\<D> \\<tau> =\n    (\\<D> = Employee \\<and> \\<tau> = (Project, 0, \\<infinity>, False, True))", "have \"association_end Employee None STR ''projects''\n          Employee (Project, 0, \\<infinity>, False, True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. association_end Employee None STR ''projects'' Employee\n     (Project, 0, \\<infinity>, False, True)", "by eval"], ["proof (state)\nthis:\n  association_end Employee None STR ''projects'' Employee\n   (Project, 0, \\<infinity>, False, True)\n\ngoal (1 subgoal):\n 1. association_end Employee None STR ''projects'' \\<D> \\<tau> =\n    (\\<D> = Employee \\<and> \\<tau> = (Project, 0, \\<infinity>, False, True))", "thus ?thesis"], ["proof (prove)\nusing this:\n  association_end Employee None STR ''projects'' Employee\n   (Project, 0, \\<infinity>, False, True)\n\ngoal (1 subgoal):\n 1. association_end Employee None STR ''projects'' \\<D> \\<tau> =\n    (\\<D> = Employee \\<and> \\<tau> = (Project, 0, \\<infinity>, False, True))", "using association_end_det"], ["proof (prove)\nusing this:\n  association_end Employee None STR ''projects'' Employee\n   (Project, 0, \\<infinity>, False, True)\n  \\<lbrakk>association_end ?\\<C> ?from ?role ?\\<D>\\<^sub>1 ?end\\<^sub>1;\n   association_end ?\\<C> ?from ?role ?\\<D>\\<^sub>2 ?end\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?\\<D>\\<^sub>1 = ?\\<D>\\<^sub>2 \\<and>\n                    ?end\\<^sub>1 = ?end\\<^sub>2\n\ngoal (1 subgoal):\n 1. association_end Employee None STR ''projects'' \\<D> \\<tau> =\n    (\\<D> = Employee \\<and> \\<tau> = (Project, 0, \\<infinity>, False, True))", "by blast"], ["proof (state)\nthis:\n  association_end Employee None STR ''projects'' \\<D> \\<tau> =\n  (\\<D> = Employee \\<and> \\<tau> = (Project, 0, \\<infinity>, False, True))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma static_operation_Project_allProjects [simp]:\n  \"static_operation \\<langle>Project\\<rangle>\\<^sub>\\<T>[1] STR ''allProjects'' [] oper =\n   (oper = (STR ''allProjects'', \\<langle>Project\\<rangle>\\<^sub>\\<T>[1], [], Set \\<langle>Project\\<rangle>\\<^sub>\\<T>[1], True,\n     Some (MetaOperationCall \\<langle>Project\\<rangle>\\<^sub>\\<T>[1] AllInstancesOp)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. static_operation \\<langle>Project\\<rangle>\\<^sub>\\<T>[1]\n     STR ''allProjects'' [] oper =\n    (oper =\n     (STR ''allProjects'', \\<langle>Project\\<rangle>\\<^sub>\\<T>[1], [],\n      Set \\<langle>Project\\<rangle>\\<^sub>\\<T>[1], True,\n      Some\n       (MetaOperationCall \\<langle>Project\\<rangle>\\<^sub>\\<T>[1]\n         AllInstancesOp)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. static_operation \\<langle>Project\\<rangle>\\<^sub>\\<T>[1]\n     STR ''allProjects'' [] oper =\n    (oper =\n     (STR ''allProjects'', \\<langle>Project\\<rangle>\\<^sub>\\<T>[1], [],\n      Set \\<langle>Project\\<rangle>\\<^sub>\\<T>[1], True,\n      Some\n       (MetaOperationCall \\<langle>Project\\<rangle>\\<^sub>\\<T>[1]\n         AllInstancesOp)))", "have \"static_operation \\<langle>Project\\<rangle>\\<^sub>\\<T>[1] STR ''allProjects'' []\n    (STR ''allProjects'', \\<langle>Project\\<rangle>\\<^sub>\\<T>[1], [], Set \\<langle>Project\\<rangle>\\<^sub>\\<T>[1], True,\n     Some (MetaOperationCall \\<langle>Project\\<rangle>\\<^sub>\\<T>[1] AllInstancesOp))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. static_operation \\<langle>Project\\<rangle>\\<^sub>\\<T>[1]\n     STR ''allProjects'' []\n     (STR ''allProjects'', \\<langle>Project\\<rangle>\\<^sub>\\<T>[1], [],\n      Set \\<langle>Project\\<rangle>\\<^sub>\\<T>[1], True,\n      Some\n       (MetaOperationCall \\<langle>Project\\<rangle>\\<^sub>\\<T>[1]\n         AllInstancesOp))", "by eval"], ["proof (state)\nthis:\n  static_operation \\<langle>Project\\<rangle>\\<^sub>\\<T>[1]\n   STR ''allProjects'' []\n   (STR ''allProjects'', \\<langle>Project\\<rangle>\\<^sub>\\<T>[1], [],\n    Set \\<langle>Project\\<rangle>\\<^sub>\\<T>[1], True,\n    Some\n     (MetaOperationCall \\<langle>Project\\<rangle>\\<^sub>\\<T>[1]\n       AllInstancesOp))\n\ngoal (1 subgoal):\n 1. static_operation \\<langle>Project\\<rangle>\\<^sub>\\<T>[1]\n     STR ''allProjects'' [] oper =\n    (oper =\n     (STR ''allProjects'', \\<langle>Project\\<rangle>\\<^sub>\\<T>[1], [],\n      Set \\<langle>Project\\<rangle>\\<^sub>\\<T>[1], True,\n      Some\n       (MetaOperationCall \\<langle>Project\\<rangle>\\<^sub>\\<T>[1]\n         AllInstancesOp)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  static_operation \\<langle>Project\\<rangle>\\<^sub>\\<T>[1]\n   STR ''allProjects'' []\n   (STR ''allProjects'', \\<langle>Project\\<rangle>\\<^sub>\\<T>[1], [],\n    Set \\<langle>Project\\<rangle>\\<^sub>\\<T>[1], True,\n    Some\n     (MetaOperationCall \\<langle>Project\\<rangle>\\<^sub>\\<T>[1]\n       AllInstancesOp))\n\ngoal (1 subgoal):\n 1. static_operation \\<langle>Project\\<rangle>\\<^sub>\\<T>[1]\n     STR ''allProjects'' [] oper =\n    (oper =\n     (STR ''allProjects'', \\<langle>Project\\<rangle>\\<^sub>\\<T>[1], [],\n      Set \\<langle>Project\\<rangle>\\<^sub>\\<T>[1], True,\n      Some\n       (MetaOperationCall \\<langle>Project\\<rangle>\\<^sub>\\<T>[1]\n         AllInstancesOp)))", "using static_operation_det"], ["proof (prove)\nusing this:\n  static_operation \\<langle>Project\\<rangle>\\<^sub>\\<T>[1]\n   STR ''allProjects'' []\n   (STR ''allProjects'', \\<langle>Project\\<rangle>\\<^sub>\\<T>[1], [],\n    Set \\<langle>Project\\<rangle>\\<^sub>\\<T>[1], True,\n    Some\n     (MetaOperationCall \\<langle>Project\\<rangle>\\<^sub>\\<T>[1]\n       AllInstancesOp))\n  \\<lbrakk>static_operation ?\\<tau> ?name ?\\<pi> ?oper\\<^sub>1;\n   static_operation ?\\<tau> ?name ?\\<pi> ?oper\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?oper\\<^sub>1 = ?oper\\<^sub>2\n\ngoal (1 subgoal):\n 1. static_operation \\<langle>Project\\<rangle>\\<^sub>\\<T>[1]\n     STR ''allProjects'' [] oper =\n    (oper =\n     (STR ''allProjects'', \\<langle>Project\\<rangle>\\<^sub>\\<T>[1], [],\n      Set \\<langle>Project\\<rangle>\\<^sub>\\<T>[1], True,\n      Some\n       (MetaOperationCall \\<langle>Project\\<rangle>\\<^sub>\\<T>[1]\n         AllInstancesOp)))", "by blast"], ["proof (state)\nthis:\n  static_operation \\<langle>Project\\<rangle>\\<^sub>\\<T>[1]\n   STR ''allProjects'' [] oper =\n  (oper =\n   (STR ''allProjects'', \\<langle>Project\\<rangle>\\<^sub>\\<T>[1], [],\n    Set \\<langle>Project\\<rangle>\\<^sub>\\<T>[1], True,\n    Some\n     (MetaOperationCall \\<langle>Project\\<rangle>\\<^sub>\\<T>[1]\n       AllInstancesOp)))\n\ngoal:\nNo subgoals!", "qed"], ["", "(*** Basic Types ************************************************************)"], ["", "section \\<open>Basic Types\\<close>"], ["", "subsection \\<open>Positive Cases\\<close>"], ["", "lemma \"UnlimitedNatural < (Real :: classes1 basic_type)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UnlimitedNatural < Real", "by simp"], ["", "lemma \"\\<langle>Employee\\<rangle>\\<^sub>\\<T> < \\<langle>Person\\<rangle>\\<^sub>\\<T>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Employee\\<rangle>\\<^sub>\\<T>\n    < \\<langle>Person\\<rangle>\\<^sub>\\<T>", "by auto"], ["", "lemma \"\\<langle>Person\\<rangle>\\<^sub>\\<T> \\<le> OclAny\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Person\\<rangle>\\<^sub>\\<T> \\<le> OclAny", "by simp"], ["", "subsection \\<open>Negative Cases\\<close>"], ["", "lemma \"\\<not> String \\<le> (Boolean :: classes1 basic_type)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> String \\<le> Boolean", "by simp"], ["", "(*** Types ******************************************************************)"], ["", "section \\<open>Types\\<close>"], ["", "subsection \\<open>Positive Cases\\<close>"], ["", "lemma \"Integer[?] < (OclSuper :: classes1 type)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Integer[?] < OclSuper", "by simp"], ["", "lemma \"Collection Real[?] < (OclSuper :: classes1 type)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Collection Real[?] < OclSuper", "by simp"], ["", "lemma \"Set (Collection Boolean[1]) < (OclSuper :: classes1 type)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set (Collection Boolean[1]) < OclSuper", "by simp"], ["", "lemma \"Set (Bag Boolean[1]) < Set (Collection Boolean[?] :: classes1 type)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set (Bag Boolean[1]) < Set (Collection Boolean[?])", "by simp"], ["", "lemma \"Tuple (fmap_of_list [(STR ''a'', Boolean[1]), (STR ''b'', Integer[1])]) <\n       Tuple (fmap_of_list [(STR ''a'', Boolean[?] :: classes1 type)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Tuple (fmap_of_list [(STR ''a'', Boolean[1]), (STR ''b'', Integer[1])])\n    < Tuple (fmap_of_list [(STR ''a'', Boolean[?])])", "by eval"], ["", "lemma \"Integer[1] \\<squnion> (Real[?] :: classes1 type) = Real[?]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Integer[1] \\<squnion> Real[?] = Real[?]", "by simp"], ["", "lemma \"Set Integer[1] \\<squnion> Set (Real[1] :: classes1 type) = Set Real[1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set Integer[1] \\<squnion> Set Real[1] = Set Real[1]", "by simp"], ["", "lemma \"Set Integer[1] \\<squnion> Bag (Boolean[?] :: classes1 type) = Collection OclAny[?]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set Integer[1] \\<squnion> Bag Boolean[?] = Collection OclAny[?]", "by simp"], ["", "lemma \"Set Integer[1] \\<squnion> (Real[1] :: classes1 type) = OclSuper\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set Integer[1] \\<squnion> Real[1] = OclSuper", "by simp"], ["", "subsection \\<open>Negative Cases\\<close>"], ["", "lemma \"\\<not> OrderedSet Boolean[1] < Set (Boolean[1] :: classes1 type)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> OrderedSet Boolean[1] < Set Boolean[1]", "by simp"], ["", "(*** Typing *****************************************************************)"], ["", "section \\<open>Typing\\<close>"], ["", "subsection \\<open>Positive Cases\\<close>"], ["", "text \\<open>\n\\<^verbatim>\\<open>E1::A : E1[1]\\<close>\\<close>"], ["", "lemma\n  \"\\<Gamma>\\<^sub>0 \\<turnstile> EnumLiteral STR ''E1'' STR ''A'' : (Enum STR ''E1'')[1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\\<^sub>0 \\<turnstile>\n     Literal (EnumLiteral (Phantom(classes1) STR ''E1'') STR ''A'') :\n     (Enum (Phantom(classes1) STR ''E1''))[1]", "by simp"], ["", "text \\<open>\n\\<^verbatim>\\<open>true or false : Boolean[1]\\<close>\\<close>"], ["", "lemma\n  \"\\<Gamma>\\<^sub>0 \\<turnstile> OperationCall (BooleanLiteral True) DotCall OrOp\n    [BooleanLiteral False] : Boolean[1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\\<^sub>0 \\<turnstile>\n     OperationCall (Literal (BooleanLiteral True)) DotCall\n      ((Inr \\<circ> Inl \\<circ> Inr \\<circ> Inl) OrOp)\n      (map Literal [BooleanLiteral False]) :\n     Boolean[1]", "by simp"], ["", "text \\<open>\n\\<^verbatim>\\<open>null and true : Boolean[?]\\<close>\\<close>"], ["", "lemma\n  \"\\<Gamma>\\<^sub>0 \\<turnstile> OperationCall (NullLiteral) DotCall AndOp\n    [BooleanLiteral True] : Boolean[?]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\\<^sub>0 \\<turnstile>\n     OperationCall (Literal NullLiteral) DotCall\n      ((Inr \\<circ> Inl \\<circ> Inr \\<circ> Inl) AndOp)\n      (map Literal [BooleanLiteral True]) :\n     Boolean[?]", "by simp"], ["", "text \\<open>\n\\<^verbatim>\\<open>let x : Real[1] = 5 in x + 7 : Real[1]\\<close>\\<close>"], ["", "lemma\n  \"\\<Gamma>\\<^sub>0 \\<turnstile> Let (STR ''x'') (Some Real[1]) (IntegerLiteral 5)\n    (OperationCall (Var STR ''x'') DotCall PlusOp [IntegerLiteral 7]) : Real[1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\\<^sub>0 \\<turnstile>\n     expr.Let STR ''x'' (Some Real[1]) (Literal (IntegerLiteral 5))\n      (OperationCall (Var STR ''x'') DotCall\n        ((Inr \\<circ> Inl \\<circ> Inr \\<circ> Inr \\<circ> Inl) PlusOp)\n        (map Literal [IntegerLiteral 7])) :\n     Real[1]", "by simp"], ["", "text \\<open>\n\\<^verbatim>\\<open>null.oclIsUndefined() : Boolean[1]\\<close>\\<close>"], ["", "lemma\n  \"\\<Gamma>\\<^sub>0 \\<turnstile> OperationCall (NullLiteral) DotCall OclIsUndefinedOp [] : Boolean[1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\\<^sub>0 \\<turnstile>\n     OperationCall (Literal NullLiteral) DotCall\n      ((Inl \\<circ> Inl) OclIsUndefinedOp) [] :\n     Boolean[1]", "by simp"], ["", "text \\<open>\n\\<^verbatim>\\<open>Sequence{1..5, null}.oclIsUndefined() : Sequence(Boolean[1])\\<close>\\<close>"], ["", "lemma\n  \"\\<Gamma>\\<^sub>0 \\<turnstile> OperationCall (CollectionLiteral SequenceKind\n    [CollectionRange (IntegerLiteral 1) (IntegerLiteral 5),\n     CollectionItem NullLiteral])\n    DotCall OclIsUndefinedOp [] : Sequence Boolean[1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\\<^sub>0 \\<turnstile>\n     OperationCall\n      (Literal\n        (CollectionLiteral SequenceKind\n          [CollectionRange (Literal (IntegerLiteral 1))\n            (Literal (IntegerLiteral 5)),\n           CollectionItem (Literal NullLiteral)]))\n      DotCall ((Inl \\<circ> Inl) OclIsUndefinedOp) [] :\n     Sequence Boolean[1]", "by simp"], ["", "text \\<open>\n\\<^verbatim>\\<open>Sequence{1..5}->product(Set{'a', 'b'})\n  : Set(Tuple(first: Integer[1], second: String[1]))\\<close>\\<close>"], ["", "lemma\n  \"\\<Gamma>\\<^sub>0 \\<turnstile> OperationCall (CollectionLiteral SequenceKind\n    [CollectionRange (IntegerLiteral 1) (IntegerLiteral 5)])\n    ArrowCall ProductOp\n    [CollectionLiteral SetKind\n      [CollectionItem (StringLiteral ''a''),\n       CollectionItem (StringLiteral ''b'')]] :\n    Set (Tuple (fmap_of_list [\n      (STR ''first'', Integer[1]), (STR ''second'', String[1])]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\\<^sub>0 \\<turnstile>\n     OperationCall\n      (Literal\n        (CollectionLiteral SequenceKind\n          [CollectionRange (Literal (IntegerLiteral 1))\n            (Literal (IntegerLiteral 5))]))\n      ArrowCall\n      ((Inr \\<circ> Inl \\<circ> Inr \\<circ> Inr \\<circ> Inr \\<circ> Inr)\n        ProductOp)\n      (map Literal\n        [CollectionLiteral SetKind\n          [CollectionItem (Literal (StringLiteral ''a'')),\n           CollectionItem (Literal (StringLiteral ''b''))]]) :\n     Set (Tuple\n           (fmap_of_list\n             [(STR ''first'', Integer[1]), (STR ''second'', String[1])]))", "by simp"], ["", "text \\<open>\n\\<^verbatim>\\<open>Sequence{1..5, null}?->iterate(x, acc : Real[1] = 0 | acc + x)\n  : Real[1]\\<close>\\<close>"], ["", "lemma\n  \"\\<Gamma>\\<^sub>0 \\<turnstile> IterateCall (CollectionLiteral SequenceKind\n    [CollectionRange (IntegerLiteral 1) (IntegerLiteral 5),\n     CollectionItem NullLiteral]) SafeArrowCall\n    [STR ''x''] None\n    (STR ''acc'') (Some Real[1]) (IntegerLiteral 0)\n    (OperationCall (Var STR ''acc'') DotCall PlusOp [Var STR ''x'']) : Real[1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\\<^sub>0 \\<turnstile>\n     IterateCall\n      (Literal\n        (CollectionLiteral SequenceKind\n          [CollectionRange (Literal (IntegerLiteral 1))\n            (Literal (IntegerLiteral 5)),\n           CollectionItem (Literal NullLiteral)]))\n      SafeArrowCall [STR ''x''] None STR ''acc'' (Some Real[1])\n      (Literal (IntegerLiteral 0))\n      (OperationCall (Var STR ''acc'') DotCall\n        ((Inr \\<circ> Inl \\<circ> Inr \\<circ> Inr \\<circ> Inl) PlusOp)\n        [Var STR ''x'']) :\n     Real[1]", "by simp"], ["", "text \\<open>\n\\<^verbatim>\\<open>Sequence{1..5, null}?->max() : Integer[1]\\<close>\\<close>"], ["", "lemma\n  \"\\<Gamma>\\<^sub>0 \\<turnstile> OperationCall (CollectionLiteral SequenceKind\n    [CollectionRange (IntegerLiteral 1) (IntegerLiteral 5),\n     CollectionItem NullLiteral])\n    SafeArrowCall CollectionMaxOp [] : Integer[1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\\<^sub>0 \\<turnstile>\n     OperationCall\n      (Literal\n        (CollectionLiteral SequenceKind\n          [CollectionRange (Literal (IntegerLiteral 1))\n            (Literal (IntegerLiteral 5)),\n           CollectionItem (Literal NullLiteral)]))\n      SafeArrowCall\n      ((Inl \\<circ> Inr \\<circ> Inr \\<circ> Inr \\<circ> Inr)\n        CollectionMaxOp)\n      [] :\n     Integer[1]", "by simp"], ["", "text \\<open>\n\\<^verbatim>\\<open>let x : Sequence(String[?]) = Sequence{'abc', 'zxc'} in\nx->any(it | it = 'test') : String[?]\\<close>\\<close>"], ["", "lemma\n  \"\\<Gamma>\\<^sub>0 \\<turnstile> Let (STR ''x'') (Some (Sequence String[?]))\n    (CollectionLiteral SequenceKind\n      [CollectionItem (StringLiteral ''abc''),\n       CollectionItem (StringLiteral ''zxc'')])\n    (AnyIteratorCall (Var STR ''x'') ArrowCall\n      [STR ''it''] None\n      (OperationCall (Var STR ''it'') DotCall EqualOp\n        [StringLiteral ''test''])) : String[?]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\\<^sub>0 \\<turnstile>\n     expr.Let STR ''x'' (Some (Sequence String[?]))\n      (Literal\n        (CollectionLiteral SequenceKind\n          [CollectionItem (Literal (StringLiteral ''abc'')),\n           CollectionItem (Literal (StringLiteral ''zxc''))]))\n      (AnyIteratorCall (Var STR ''x'') ArrowCall [STR ''it''] None\n        (OperationCall (Var STR ''it'') DotCall\n          ((Inr \\<circ> Inl \\<circ> Inl) EqualOp)\n          (map Literal [StringLiteral ''test'']))) :\n     String[?]", "by simp"], ["", "text \\<open>\n\\<^verbatim>\\<open>let x : Sequence(String[?]) = Sequence{'abc', 'zxc'} in\nx?->closure(it | it) : OrderedSet(String[1])\\<close>\\<close>"], ["", "lemma\n  \"\\<Gamma>\\<^sub>0 \\<turnstile> Let STR ''x'' (Some (Sequence String[?]))\n    (CollectionLiteral SequenceKind\n      [CollectionItem (StringLiteral ''abc''),\n       CollectionItem (StringLiteral ''zxc'')])\n    (ClosureIteratorCall (Var STR ''x'') SafeArrowCall\n      [STR ''it''] None\n      (Var STR ''it'')) : OrderedSet String[1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\\<^sub>0 \\<turnstile>\n     expr.Let STR ''x'' (Some (Sequence String[?]))\n      (Literal\n        (CollectionLiteral SequenceKind\n          [CollectionItem (Literal (StringLiteral ''abc'')),\n           CollectionItem (Literal (StringLiteral ''zxc''))]))\n      (ClosureIteratorCall (Var STR ''x'') SafeArrowCall [STR ''it''] None\n        (Var STR ''it'')) :\n     OrderedSet String[1]", "by simp"], ["", "text \\<open>\n\\<^verbatim>\\<open>context Employee:\nname : String[1]\\<close>\\<close>"], ["", "lemma\n  \"\\<Gamma>\\<^sub>0(STR ''self'' \\<mapsto>\\<^sub>f Employee[1]) \\<turnstile>\n    AttributeCall (Var STR ''self'') DotCall STR ''name'' : String[1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\\<^sub>0(STR ''self'' \\<mapsto>\\<^sub>f\n     \\<langle>Employee\\<rangle>\\<^sub>\\<T>[1]) \\<turnstile>\n     AttributeCall (Var STR ''self'') DotCall STR ''name'' : String[1]", "by simp"], ["", "text \\<open>\n\\<^verbatim>\\<open>context Employee:\nprojects : Set(Project[1])\\<close>\\<close>"], ["", "lemma\n  \"\\<Gamma>\\<^sub>0(STR ''self'' \\<mapsto>\\<^sub>f Employee[1]) \\<turnstile>\n    AssociationEndCall (Var STR ''self'') DotCall None\n      STR ''projects'' : Set Project[1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\\<^sub>0(STR ''self'' \\<mapsto>\\<^sub>f\n     \\<langle>Employee\\<rangle>\\<^sub>\\<T>[1]) \\<turnstile>\n     AssociationEndCall (Var STR ''self'') DotCall None STR ''projects'' :\n     Set \\<langle>Project\\<rangle>\\<^sub>\\<T>[1]", "by simp"], ["", "text \\<open>\n\\<^verbatim>\\<open>context Employee:\nprojects.members : Bag(Employee[1])\\<close>\\<close>"], ["", "lemma\n  \"\\<Gamma>\\<^sub>0(STR ''self'' \\<mapsto>\\<^sub>f Employee[1]) \\<turnstile>\n    AssociationEndCall (AssociationEndCall (Var STR ''self'')\n        DotCall None STR ''projects'')\n      DotCall None STR ''members'' : Bag Employee[1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\\<^sub>0(STR ''self'' \\<mapsto>\\<^sub>f\n     \\<langle>Employee\\<rangle>\\<^sub>\\<T>[1]) \\<turnstile>\n     AssociationEndCall\n      (AssociationEndCall (Var STR ''self'') DotCall None STR ''projects'')\n      DotCall None STR ''members'' :\n     Bag \\<langle>Employee\\<rangle>\\<^sub>\\<T>[1]", "by simp"], ["", "text \\<open>\n\\<^verbatim>\\<open>Project[?].allInstances() : Set(Project[?])\\<close>\\<close>"], ["", "lemma\n  \"\\<Gamma>\\<^sub>0 \\<turnstile> MetaOperationCall Project[?] AllInstancesOp : Set Project[?]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\\<^sub>0 \\<turnstile>\n     MetaOperationCall \\<langle>Project\\<rangle>\\<^sub>\\<T>[?]\n      AllInstancesOp :\n     Set \\<langle>Project\\<rangle>\\<^sub>\\<T>[?]", "by simp"], ["", "text \\<open>\n\\<^verbatim>\\<open>Project[1]::allProjects() : Set(Project[1])\\<close>\\<close>"], ["", "lemma\n  \"\\<Gamma>\\<^sub>0 \\<turnstile> StaticOperationCall Project[1] STR ''allProjects'' [] : Set Project[1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\\<^sub>0 \\<turnstile>\n     StaticOperationCall \\<langle>Project\\<rangle>\\<^sub>\\<T>[1]\n      STR ''allProjects'' [] :\n     Set \\<langle>Project\\<rangle>\\<^sub>\\<T>[1]", "by simp"], ["", "subsection \\<open>Negative Cases\\<close>"], ["", "text \\<open>\n\\<^verbatim>\\<open>true = null\\<close>\\<close>"], ["", "lemma\n  \"\\<nexists>\\<tau>. \\<Gamma>\\<^sub>0 \\<turnstile> OperationCall (BooleanLiteral True) DotCall EqualOp\n    [NullLiteral] : \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>\\<tau>.\n       \\<Gamma>\\<^sub>0 \\<turnstile>\n        OperationCall (Literal (BooleanLiteral True)) DotCall\n         ((Inr \\<circ> Inl \\<circ> Inl) EqualOp)\n         (map Literal [NullLiteral]) :\n        \\<tau>", "by simp"], ["", "text \\<open>\n\\<^verbatim>\\<open>let x : Boolean[1] = 5 in x and true\\<close>\\<close>"], ["", "lemma\n  \"\\<nexists>\\<tau>. \\<Gamma>\\<^sub>0 \\<turnstile> Let STR ''x'' (Some Boolean[1]) (IntegerLiteral 5)\n    (OperationCall (Var STR ''x'') DotCall AndOp [BooleanLiteral True]) : \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>\\<tau>.\n       \\<Gamma>\\<^sub>0 \\<turnstile>\n        expr.Let STR ''x'' (Some Boolean[1]) (Literal (IntegerLiteral 5))\n         (OperationCall (Var STR ''x'') DotCall\n           ((Inr \\<circ> Inl \\<circ> Inr \\<circ> Inl) AndOp)\n           (map Literal [BooleanLiteral True])) :\n        \\<tau>", "by simp"], ["", "text \\<open>\n\\<^verbatim>\\<open>let x : Sequence(String[?]) = Sequence{'abc', 'zxc'} in\nx->closure(it | 1)\\<close>\\<close>"], ["", "lemma\n  \"\\<nexists>\\<tau>. \\<Gamma>\\<^sub>0 \\<turnstile> Let STR ''x'' (Some (Sequence String[?]))\n    (CollectionLiteral SequenceKind\n      [CollectionItem (StringLiteral ''abc''),\n       CollectionItem (StringLiteral ''zxc'')])\n    (ClosureIteratorCall (Var STR ''x'') ArrowCall [STR ''it''] None\n      (IntegerLiteral 1)) : \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>\\<tau>.\n       \\<Gamma>\\<^sub>0 \\<turnstile>\n        expr.Let STR ''x'' (Some (Sequence String[?]))\n         (Literal\n           (CollectionLiteral SequenceKind\n             [CollectionItem (Literal (StringLiteral ''abc'')),\n              CollectionItem (Literal (StringLiteral ''zxc''))]))\n         (ClosureIteratorCall (Var STR ''x'') ArrowCall [STR ''it''] None\n           (Literal (IntegerLiteral 1))) :\n        \\<tau>", "by simp"], ["", "text \\<open>\n\\<^verbatim>\\<open>Sequence{1..5, null}->max()\\<close>\\<close>"], ["", "lemma\n  \"\\<nexists>\\<tau>. \\<Gamma>\\<^sub>0 \\<turnstile> OperationCall (CollectionLiteral SequenceKind\n    [CollectionRange (IntegerLiteral 1) (IntegerLiteral 5),\n     CollectionItem NullLiteral])\n    ArrowCall CollectionMaxOp [] : \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>\\<tau>.\n       \\<Gamma>\\<^sub>0 \\<turnstile>\n        OperationCall\n         (Literal\n           (CollectionLiteral SequenceKind\n             [CollectionRange (Literal (IntegerLiteral 1))\n               (Literal (IntegerLiteral 5)),\n              CollectionItem (Literal NullLiteral)]))\n         ArrowCall\n         ((Inl \\<circ> Inr \\<circ> Inr \\<circ> Inr \\<circ> Inr)\n           CollectionMaxOp)\n         [] :\n        \\<tau>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>\\<tau>.\n       \\<Gamma>\\<^sub>0 \\<turnstile>\n        OperationCall\n         (Literal\n           (CollectionLiteral SequenceKind\n             [CollectionRange (Literal (IntegerLiteral 1))\n               (Literal (IntegerLiteral 5)),\n              CollectionItem (Literal NullLiteral)]))\n         ArrowCall\n         ((Inl \\<circ> Inr \\<circ> Inr \\<circ> Inr \\<circ> Inr)\n           CollectionMaxOp)\n         [] :\n        \\<tau>", "have \"\\<not> operation_defined (Integer[?] :: classes1 type) STR ''max'' [Integer[?]]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> operation_defined Integer[?] STR ''max'' [Integer[?]]", "by eval"], ["proof (state)\nthis:\n  \\<not> operation_defined Integer[?] STR ''max'' [Integer[?]]\n\ngoal (1 subgoal):\n 1. \\<nexists>\\<tau>.\n       \\<Gamma>\\<^sub>0 \\<turnstile>\n        OperationCall\n         (Literal\n           (CollectionLiteral SequenceKind\n             [CollectionRange (Literal (IntegerLiteral 1))\n               (Literal (IntegerLiteral 5)),\n              CollectionItem (Literal NullLiteral)]))\n         ArrowCall\n         ((Inl \\<circ> Inr \\<circ> Inr \\<circ> Inr \\<circ> Inr)\n           CollectionMaxOp)\n         [] :\n        \\<tau>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> operation_defined Integer[?] STR ''max'' [Integer[?]]\n\ngoal (1 subgoal):\n 1. \\<nexists>\\<tau>.\n       \\<Gamma>\\<^sub>0 \\<turnstile>\n        OperationCall\n         (Literal\n           (CollectionLiteral SequenceKind\n             [CollectionRange (Literal (IntegerLiteral 1))\n               (Literal (IntegerLiteral 5)),\n              CollectionItem (Literal NullLiteral)]))\n         ArrowCall\n         ((Inl \\<circ> Inr \\<circ> Inr \\<circ> Inr \\<circ> Inr)\n           CollectionMaxOp)\n         [] :\n        \\<tau>", "by simp"], ["proof (state)\nthis:\n  \\<nexists>\\<tau>.\n     \\<Gamma>\\<^sub>0 \\<turnstile>\n      OperationCall\n       (Literal\n         (CollectionLiteral SequenceKind\n           [CollectionRange (Literal (IntegerLiteral 1))\n             (Literal (IntegerLiteral 5)),\n            CollectionItem (Literal NullLiteral)]))\n       ArrowCall\n       ((Inl \\<circ> Inr \\<circ> Inr \\<circ> Inr \\<circ> Inr)\n         CollectionMaxOp)\n       [] :\n      \\<tau>\n\ngoal:\nNo subgoals!", "qed"], ["", "(*** Code *******************************************************************)"], ["", "section \\<open>Code\\<close>"], ["", "subsection \\<open>Positive Cases\\<close>"], ["", "values \"{(\\<D>, \\<tau>). attribute Employee STR ''name'' \\<D> \\<tau>}\""], ["", "values \"{(\\<D>, end). association_end Employee None STR ''employees'' \\<D> end}\""], ["", "values \"{(\\<D>, end). association_end Employee (Some STR ''project_manager'') STR ''employees'' \\<D> end}\""], ["", "values \"{op. operation Project[1] STR ''membersCount'' [] op}\""], ["", "values \"{op. operation Project[1] STR ''membersByName'' [String[1]] op}\""], ["", "value \"has_literal STR ''E1'' STR ''A''\""], ["", "text \\<open>\n\\<^verbatim>\\<open>context Employee:\nprojects.members : Bag(Employee[1])\\<close>\\<close>"], ["", "values\n  \"{\\<tau>. \\<Gamma>\\<^sub>0(STR ''self'' \\<mapsto>\\<^sub>f Employee[1]) \\<turnstile>\n    AssociationEndCall (AssociationEndCall (Var STR ''self'')\n        DotCall None STR ''projects'')\n      DotCall None STR ''members'' : \\<tau>}\""], ["", "subsection \\<open>Negative Cases\\<close>"], ["", "values \"{(\\<D>, \\<tau>). attribute Employee STR ''name2'' \\<D> \\<tau>}\""], ["", "value \"has_literal STR ''E1'' STR ''C''\""], ["", "text \\<open>\n\\<^verbatim>\\<open>Sequence{1..5, null}->max()\\<close>\\<close>"], ["", "values\n  \"{\\<tau>. \\<Gamma>\\<^sub>0 \\<turnstile> OperationCall (CollectionLiteral SequenceKind\n    [CollectionRange (IntegerLiteral 1) (IntegerLiteral 5),\n      CollectionItem NullLiteral])\n    ArrowCall CollectionMaxOp [] : \\<tau>}\""], ["", "end"]]}