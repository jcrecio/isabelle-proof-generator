{"file_name": "/home/qj213/afp-2021-10-22/thys/Mersenne_Primes/Lucas_Lehmer_Auxiliary.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Mersenne_Primes", "problem_names": ["lemma congD: \"[a = b] (mod n) \\<Longrightarrow> a mod n = b mod n\"", "lemma eval_coprime:\n  \"(b :: 'a :: euclidean_semiring_gcd) \\<noteq> 0 \\<Longrightarrow> coprime a b \\<longleftrightarrow> coprime b (a mod b)\"", "lemma two_power_odd_mod_12:\n  assumes \"odd n\" \"n > 1\"\n  shows   \"[2 ^ n = 8] (mod (12 :: nat))\"", "lemma Legendre_3_right:\n  fixes p :: nat\n  assumes p: \"prime p\" \"p > 3\"\n  shows   \"p mod 12 \\<in> {1, 5, 7, 11}\" and \"Legendre p 3 = (if p mod 12 \\<in> {1, 7} then 1 else -1)\"", "lemma Legendre_3_left:\n  fixes p :: nat\n  assumes p: \"prime p\" \"p > 3\"\n  shows   \"Legendre 3 p = (if p mod 12 \\<in> {1, 11} then 1 else -1)\"", "lemma supplement2_Legendre':\n  assumes \"prime p\" \"p \\<noteq> 2\"\n  shows \"Legendre 2 p = (if p mod 8 = 1 \\<or> p mod 8 = 7 then 1 else -1)\"", "lemma little_Fermat_nat:\n  fixes a :: nat\n  assumes \"prime p\" \"\\<not>p dvd a\"\n  shows   \"[a ^ p = a] (mod p)\"", "lemma little_Fermat_int:\n  fixes a :: int and p :: nat\n  assumes \"prime p\" \"\\<not>p dvd a\"\n  shows   \"[a ^ p = a] (mod p)\"", "lemma prime_dvd_choose:\n  assumes \"0 < k\" \"k < p\" \"prime p\" \n  shows \"p dvd (p choose k)\"", "lemma prime_natD:\n  assumes \"prime (p :: nat)\" \"a dvd p\"\n  shows   \"a = 1 \\<or> a = p\"", "lemma not_prime_imp_ex_prod_nat:\n  assumes \"m > 1\" \"\\<not> prime (m::nat)\"\n  shows   \"\\<exists>n k. m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m\"", "lemma (in group) ord_eqI_prime_factors:\n  assumes \"\\<And>p. p \\<in> prime_factors n \\<Longrightarrow> x [^] (n div p) \\<noteq> \\<one>\" and \"x [^] n = \\<one>\"\n  assumes \"x \\<in> carrier G\" \"n > 0\"\n  shows   \"group.ord G x = n\"", "lemma (in monoid) pow_nat_eq_1_imp_unit:\n  fixes n :: nat\n  assumes \"x [^] n = \\<one>\" and \"n > 0\" and [simp]: \"x \\<in> carrier G\"\n  shows   \"x \\<in> Units G\"", "lemma (in cring) finsum_reindex_bij_betw:\n  assumes \"bij_betw h S T\" \"g \\<in> T \\<rightarrow> carrier R\"\n  shows   \"finsum R (\\<lambda>x. g (h x)) S = finsum R g T\"", "lemma (in cring) finsum_reindex_bij_witness:\n  assumes witness:\n    \"\\<And>a. a \\<in> S \\<Longrightarrow> i (j a) = a\"\n    \"\\<And>a. a \\<in> S \\<Longrightarrow> j a \\<in> T\"\n    \"\\<And>b. b \\<in> T \\<Longrightarrow> j (i b) = b\"\n    \"\\<And>b. b \\<in> T \\<Longrightarrow> i b \\<in> S\"\n    \"\\<And>b. b \\<in> S \\<Longrightarrow> g b \\<in> carrier R\"\n  assumes eq:\n    \"\\<And>a. a \\<in> S \\<Longrightarrow> h (j a) = g a\"\n  shows \"finsum R g S = finsum R h T\"", "lemma (in cring) binomial:\n  fixes n :: nat\n  assumes [simp]: \"x \\<in> carrier R\" \"y \\<in> carrier R\"\n  shows   \"(x \\<oplus> y) [^] n = (\\<Oplus>i\\<in>{..n}. add_pow R (n choose i) (x [^] i \\<otimes> y [^] (n - i)))\"", "lemma (in cring) binomial_finite_char:\n  fixes p :: nat\n  assumes [simp]: \"x \\<in> carrier R\" \"y \\<in> carrier R\" and \"add_pow R p \\<one> = \\<zero>\" \"prime p\"\n  shows   \"(x \\<oplus> y) [^] p = x [^] p \\<oplus> y [^] p\"", "lemma (in ring_hom_cring) hom_add_pow_nat:\n  \"x \\<in> carrier R \\<Longrightarrow> h (add_pow R (n::nat) x) = add_pow S n (h x)\""], "translations": [["", "lemma congD: \"[a = b] (mod n) \\<Longrightarrow> a mod n = b mod n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a = b] (mod n) \\<Longrightarrow> a mod n = b mod n", "by (auto simp: cong_def)"], ["", "lemma eval_coprime:\n  \"(b :: 'a :: euclidean_semiring_gcd) \\<noteq> 0 \\<Longrightarrow> coprime a b \\<longleftrightarrow> coprime b (a mod b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<noteq> (0::'a) \\<Longrightarrow> coprime a b = coprime b (a mod b)", "by (simp add: coprime_commute)"], ["", "lemma two_power_odd_mod_12:\n  assumes \"odd n\" \"n > 1\"\n  shows   \"[2 ^ n = 8] (mod (12 :: nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [2 ^ n = 8] (mod 12)", "using assms"], ["proof (prove)\nusing this:\n  odd n\n  1 < n\n\ngoal (1 subgoal):\n 1. [2 ^ n = 8] (mod 12)", "proof (induction n rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; odd y; 1 < y\\<rbrakk>\n                   \\<Longrightarrow> [2 ^ y = 8] (mod 12);\n        odd x; 1 < x\\<rbrakk>\n       \\<Longrightarrow> [2 ^ x = 8] (mod 12)", "case (less n)"], ["proof (state)\nthis:\n  \\<lbrakk>?y < n; odd ?y; 1 < ?y\\<rbrakk>\n  \\<Longrightarrow> [2 ^ ?y = 8] (mod 12)\n  odd n\n  1 < n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; odd y; 1 < y\\<rbrakk>\n                   \\<Longrightarrow> [2 ^ y = 8] (mod 12);\n        odd x; 1 < x\\<rbrakk>\n       \\<Longrightarrow> [2 ^ x = 8] (mod 12)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [2 ^ n = 8] (mod 12)", "proof (cases \"n = 3\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 3 \\<Longrightarrow> [2 ^ n = 8] (mod 12)\n 2. n \\<noteq> 3 \\<Longrightarrow> [2 ^ n = 8] (mod 12)", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 3\n\ngoal (2 subgoals):\n 1. n = 3 \\<Longrightarrow> [2 ^ n = 8] (mod 12)\n 2. n \\<noteq> 3 \\<Longrightarrow> [2 ^ n = 8] (mod 12)", "with less.prems"], ["proof (chain)\npicking this:\n  odd n\n  1 < n\n  n \\<noteq> 3", "have \"n > 3\""], ["proof (prove)\nusing this:\n  odd n\n  1 < n\n  n \\<noteq> 3\n\ngoal (1 subgoal):\n 1. 3 < n", "by (auto elim!: oddE)"], ["proof (state)\nthis:\n  3 < n\n\ngoal (2 subgoals):\n 1. n = 3 \\<Longrightarrow> [2 ^ n = 8] (mod 12)\n 2. n \\<noteq> 3 \\<Longrightarrow> [2 ^ n = 8] (mod 12)", "hence \"[2 ^ (n - 2 + 2) = (8 * 4 :: nat)] (mod 12)\""], ["proof (prove)\nusing this:\n  3 < n\n\ngoal (1 subgoal):\n 1. [2 ^ (n - 2 + 2) = 8 * 4] (mod 12)", "unfolding power_add"], ["proof (prove)\nusing this:\n  3 < n\n\ngoal (1 subgoal):\n 1. [2 ^ (n - 2) * 2\\<^sup>2 = 8 * 4] (mod 12)", "using less.prems"], ["proof (prove)\nusing this:\n  3 < n\n  odd n\n  1 < n\n\ngoal (1 subgoal):\n 1. [2 ^ (n - 2) * 2\\<^sup>2 = 8 * 4] (mod 12)", "by (intro cong_mult less) auto"], ["proof (state)\nthis:\n  [2 ^ (n - 2 + 2) = 8 * 4] (mod 12)\n\ngoal (2 subgoals):\n 1. n = 3 \\<Longrightarrow> [2 ^ n = 8] (mod 12)\n 2. n \\<noteq> 3 \\<Longrightarrow> [2 ^ n = 8] (mod 12)", "also"], ["proof (state)\nthis:\n  [2 ^ (n - 2 + 2) = 8 * 4] (mod 12)\n\ngoal (2 subgoals):\n 1. n = 3 \\<Longrightarrow> [2 ^ n = 8] (mod 12)\n 2. n \\<noteq> 3 \\<Longrightarrow> [2 ^ n = 8] (mod 12)", "have \"n - 2 + 2 = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n - 2 + 2 = n", "using \\<open>n > 3\\<close>"], ["proof (prove)\nusing this:\n  3 < n\n\ngoal (1 subgoal):\n 1. n - 2 + 2 = n", "by simp"], ["proof (state)\nthis:\n  n - 2 + 2 = n\n\ngoal (2 subgoals):\n 1. n = 3 \\<Longrightarrow> [2 ^ n = 8] (mod 12)\n 2. n \\<noteq> 3 \\<Longrightarrow> [2 ^ n = 8] (mod 12)", "finally"], ["proof (chain)\npicking this:\n  [2 ^ n = 8 * 4] (mod 12)", "show ?thesis"], ["proof (prove)\nusing this:\n  [2 ^ n = 8 * 4] (mod 12)\n\ngoal (1 subgoal):\n 1. [2 ^ n = 8] (mod 12)", "by (simp add: cong_def)"], ["proof (state)\nthis:\n  [2 ^ n = 8] (mod 12)\n\ngoal (1 subgoal):\n 1. n = 3 \\<Longrightarrow> [2 ^ n = 8] (mod 12)", "qed auto"], ["proof (state)\nthis:\n  [2 ^ n = 8] (mod 12)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Legendre_3_right:\n  fixes p :: nat\n  assumes p: \"prime p\" \"p > 3\"\n  shows   \"p mod 12 \\<in> {1, 5, 7, 11}\" and \"Legendre p 3 = (if p mod 12 \\<in> {1, 7} then 1 else -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p mod 12 \\<in> {1, 5, 7, 11} &&&\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. p mod 12 \\<in> {1, 5, 7, 11}\n 2. Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "have \"coprime p 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime p 2", "using p prime_nat_not_dvd[of p 2]"], ["proof (prove)\nusing this:\n  prime p\n  3 < p\n  \\<lbrakk>prime p; 2 < p; 2 \\<noteq> 1\\<rbrakk> \\<Longrightarrow> odd p\n\ngoal (1 subgoal):\n 1. coprime p 2", "by (intro prime_imp_coprime) (auto dest: dvd_imp_le)"], ["proof (state)\nthis:\n  coprime p 2\n\ngoal (2 subgoals):\n 1. p mod 12 \\<in> {1, 5, 7, 11}\n 2. Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "moreover"], ["proof (state)\nthis:\n  coprime p 2\n\ngoal (2 subgoals):\n 1. p mod 12 \\<in> {1, 5, 7, 11}\n 2. Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "have \"coprime p 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime p 3", "using p"], ["proof (prove)\nusing this:\n  prime p\n  3 < p\n\ngoal (1 subgoal):\n 1. coprime p 3", "by (intro prime_imp_coprime) auto"], ["proof (state)\nthis:\n  coprime p 3\n\ngoal (2 subgoals):\n 1. p mod 12 \\<in> {1, 5, 7, 11}\n 2. Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "ultimately"], ["proof (chain)\npicking this:\n  coprime p 2\n  coprime p 3", "have \"coprime p (2 * 2 * 3)\""], ["proof (prove)\nusing this:\n  coprime p 2\n  coprime p 3\n\ngoal (1 subgoal):\n 1. coprime p (2 * 2 * 3)", "unfolding coprime_mult_right_iff"], ["proof (prove)\nusing this:\n  coprime p 2\n  coprime p 3\n\ngoal (1 subgoal):\n 1. (coprime p 2 \\<and> coprime p 2) \\<and> coprime p 3", "by auto"], ["proof (state)\nthis:\n  coprime p (2 * 2 * 3)\n\ngoal (2 subgoals):\n 1. p mod 12 \\<in> {1, 5, 7, 11}\n 2. Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "hence \"coprime 12 p\""], ["proof (prove)\nusing this:\n  coprime p (2 * 2 * 3)\n\ngoal (1 subgoal):\n 1. coprime 12 p", "by (simp add: coprime_commute)"], ["proof (state)\nthis:\n  coprime 12 p\n\ngoal (2 subgoals):\n 1. p mod 12 \\<in> {1, 5, 7, 11}\n 2. Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "hence \"p mod 12 \\<in> {p\\<in>{..11}. coprime 12 p}\""], ["proof (prove)\nusing this:\n  coprime 12 p\n\ngoal (1 subgoal):\n 1. p mod 12 \\<in> {p \\<in> {..11}. coprime 12 p}", "by auto"], ["proof (state)\nthis:\n  p mod 12 \\<in> {p \\<in> {..11}. coprime 12 p}\n\ngoal (2 subgoals):\n 1. p mod 12 \\<in> {1, 5, 7, 11}\n 2. Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "also"], ["proof (state)\nthis:\n  p mod 12 \\<in> {p \\<in> {..11}. coprime 12 p}\n\ngoal (2 subgoals):\n 1. p mod 12 \\<in> {1, 5, 7, 11}\n 2. Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "have \"{p\\<in>{..11}. coprime 12 p} = {1::nat, 5, 7, 11}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {p \\<in> {..11}. coprime 12 p} = {1, 5, 7, 11}", "unfolding atMost_nat_numeral pred_numeral_simps arith_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. {p \\<in> insert 11\n              (insert 10\n                (insert 9\n                  (insert 8\n                    (insert 7\n                      (insert 6\n                        (insert 5\n                          (insert 4\n                            (insert 3\n                              (insert 2 (insert Numeral1 {..0})))))))))).\n     coprime 12 p} =\n    {1, 5, 7, 11}", "by (auto simp del: coprime_imp_gcd_eq_1 simp: eval_coprime)"], ["proof (state)\nthis:\n  {p \\<in> {..11}. coprime 12 p} = {1, 5, 7, 11}\n\ngoal (2 subgoals):\n 1. p mod 12 \\<in> {1, 5, 7, 11}\n 2. Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "finally"], ["proof (chain)\npicking this:\n  p mod 12 \\<in> {1, 5, 7, 11}", "show \"p mod 12 \\<in> {1, 5, 7, 11}\""], ["proof (prove)\nusing this:\n  p mod 12 \\<in> {1, 5, 7, 11}\n\ngoal (1 subgoal):\n 1. p mod 12 \\<in> {1, 5, 7, 11}", "by auto"], ["proof (state)\nthis:\n  p mod 12 \\<in> {1, 5, 7, 11}\n\ngoal (1 subgoal):\n 1. Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "hence \"p mod 12 = 1 \\<or> p mod 12 = 5 \\<or> p mod 12 = 7 \\<or> p mod 12 = 11\""], ["proof (prove)\nusing this:\n  p mod 12 \\<in> {1, 5, 7, 11}\n\ngoal (1 subgoal):\n 1. p mod 12 = 1 \\<or> p mod 12 = 5 \\<or> p mod 12 = 7 \\<or> p mod 12 = 11", "by auto"], ["proof (state)\nthis:\n  p mod 12 = 1 \\<or> p mod 12 = 5 \\<or> p mod 12 = 7 \\<or> p mod 12 = 11\n\ngoal (1 subgoal):\n 1. Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "thus \"Legendre p 3 = (if p mod 12 \\<in> {1, 7} then 1 else -1)\""], ["proof (prove)\nusing this:\n  p mod 12 = 1 \\<or> p mod 12 = 5 \\<or> p mod 12 = 7 \\<or> p mod 12 = 11\n\ngoal (1 subgoal):\n 1. Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "proof safe"], ["proof (state)\ngoal (4 subgoals):\n 1. p mod 12 = 1 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 2. p mod 12 = 5 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 3. p mod 12 = 7 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 4. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "assume \"p mod 12 = 1\""], ["proof (state)\nthis:\n  p mod 12 = 1\n\ngoal (4 subgoals):\n 1. p mod 12 = 1 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 2. p mod 12 = 5 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 3. p mod 12 = 7 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 4. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "have \"Legendre (int p) 3 = Legendre (int p mod 3) 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Legendre (int p) 3 = Legendre (int p mod 3) 3", "by (intro Legendre_mod [symmetric]) auto"], ["proof (state)\nthis:\n  Legendre (int p) 3 = Legendre (int p mod 3) 3\n\ngoal (4 subgoals):\n 1. p mod 12 = 1 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 2. p mod 12 = 5 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 3. p mod 12 = 7 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 4. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "also"], ["proof (state)\nthis:\n  Legendre (int p) 3 = Legendre (int p mod 3) 3\n\ngoal (4 subgoals):\n 1. p mod 12 = 1 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 2. p mod 12 = 5 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 3. p mod 12 = 7 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 4. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "from \\<open>p mod 12 = 1\\<close>"], ["proof (chain)\npicking this:\n  p mod 12 = 1", "have \"p mod 12 mod 3 = 1\""], ["proof (prove)\nusing this:\n  p mod 12 = 1\n\ngoal (1 subgoal):\n 1. p mod 12 mod 3 = 1", "by simp"], ["proof (state)\nthis:\n  p mod 12 mod 3 = 1\n\ngoal (4 subgoals):\n 1. p mod 12 = 1 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 2. p mod 12 = 5 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 3. p mod 12 = 7 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 4. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "hence \"p mod 3 = 1\""], ["proof (prove)\nusing this:\n  p mod 12 mod 3 = 1\n\ngoal (1 subgoal):\n 1. p mod 3 = 1", "by (simp add: mod_mod_cancel)"], ["proof (state)\nthis:\n  p mod 3 = 1\n\ngoal (4 subgoals):\n 1. p mod 12 = 1 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 2. p mod 12 = 5 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 3. p mod 12 = 7 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 4. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "hence \"int p mod 3 = 1\""], ["proof (prove)\nusing this:\n  p mod 3 = 1\n\ngoal (1 subgoal):\n 1. int p mod 3 = 1", "by presburger"], ["proof (state)\nthis:\n  int p mod 3 = 1\n\ngoal (4 subgoals):\n 1. p mod 12 = 1 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 2. p mod 12 = 5 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 3. p mod 12 = 7 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 4. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "finally"], ["proof (chain)\npicking this:\n  Legendre (int p) 3 = Legendre 1 3", "have \"Legendre p 3 = 1\""], ["proof (prove)\nusing this:\n  Legendre (int p) 3 = Legendre 1 3\n\ngoal (1 subgoal):\n 1. Legendre (int p) 3 = 1", "by simp"], ["proof (state)\nthis:\n  Legendre (int p) 3 = 1\n\ngoal (4 subgoals):\n 1. p mod 12 = 1 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 2. p mod 12 = 5 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 3. p mod 12 = 7 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 4. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Legendre (int p) 3 = 1\n\ngoal (1 subgoal):\n 1. Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "using \\<open>p mod 12 = 1\\<close>"], ["proof (prove)\nusing this:\n  Legendre (int p) 3 = 1\n  p mod 12 = 1\n\ngoal (1 subgoal):\n 1. Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "by simp"], ["proof (state)\nthis:\n  Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n\ngoal (3 subgoals):\n 1. p mod 12 = 5 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 2. p mod 12 = 7 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 3. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. p mod 12 = 5 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 2. p mod 12 = 7 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 3. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "assume \"p mod 12 = 5\""], ["proof (state)\nthis:\n  p mod 12 = 5\n\ngoal (3 subgoals):\n 1. p mod 12 = 5 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 2. p mod 12 = 7 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 3. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "have \"Legendre (int p) 3 = Legendre (int p mod 3) 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Legendre (int p) 3 = Legendre (int p mod 3) 3", "by (intro Legendre_mod [symmetric]) auto"], ["proof (state)\nthis:\n  Legendre (int p) 3 = Legendre (int p mod 3) 3\n\ngoal (3 subgoals):\n 1. p mod 12 = 5 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 2. p mod 12 = 7 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 3. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "also"], ["proof (state)\nthis:\n  Legendre (int p) 3 = Legendre (int p mod 3) 3\n\ngoal (3 subgoals):\n 1. p mod 12 = 5 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 2. p mod 12 = 7 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 3. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "from \\<open>p mod 12 = 5\\<close>"], ["proof (chain)\npicking this:\n  p mod 12 = 5", "have \"p mod 12 mod 3 = 2\""], ["proof (prove)\nusing this:\n  p mod 12 = 5\n\ngoal (1 subgoal):\n 1. p mod 12 mod 3 = 2", "by simp"], ["proof (state)\nthis:\n  p mod 12 mod 3 = 2\n\ngoal (3 subgoals):\n 1. p mod 12 = 5 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 2. p mod 12 = 7 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 3. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "hence \"p mod 3 = 2\""], ["proof (prove)\nusing this:\n  p mod 12 mod 3 = 2\n\ngoal (1 subgoal):\n 1. p mod 3 = 2", "by (simp add: mod_mod_cancel)"], ["proof (state)\nthis:\n  p mod 3 = 2\n\ngoal (3 subgoals):\n 1. p mod 12 = 5 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 2. p mod 12 = 7 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 3. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "hence \"int p mod 3 = 2\""], ["proof (prove)\nusing this:\n  p mod 3 = 2\n\ngoal (1 subgoal):\n 1. int p mod 3 = 2", "by presburger"], ["proof (state)\nthis:\n  int p mod 3 = 2\n\ngoal (3 subgoals):\n 1. p mod 12 = 5 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 2. p mod 12 = 7 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 3. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "finally"], ["proof (chain)\npicking this:\n  Legendre (int p) 3 = Legendre 2 3", "have \"Legendre p 3 = -1\""], ["proof (prove)\nusing this:\n  Legendre (int p) 3 = Legendre 2 3\n\ngoal (1 subgoal):\n 1. Legendre (int p) 3 = - 1", "by (simp add: supplement2_Legendre)"], ["proof (state)\nthis:\n  Legendre (int p) 3 = - 1\n\ngoal (3 subgoals):\n 1. p mod 12 = 5 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 2. p mod 12 = 7 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 3. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Legendre (int p) 3 = - 1\n\ngoal (1 subgoal):\n 1. Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "using \\<open>p mod 12 = 5\\<close>"], ["proof (prove)\nusing this:\n  Legendre (int p) 3 = - 1\n  p mod 12 = 5\n\ngoal (1 subgoal):\n 1. Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "by simp"], ["proof (state)\nthis:\n  Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n\ngoal (2 subgoals):\n 1. p mod 12 = 7 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 2. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. p mod 12 = 7 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 2. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "assume \"p mod 12 = 7\""], ["proof (state)\nthis:\n  p mod 12 = 7\n\ngoal (2 subgoals):\n 1. p mod 12 = 7 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 2. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "have \"Legendre (int p) 3 = Legendre (int p mod 3) 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Legendre (int p) 3 = Legendre (int p mod 3) 3", "by (intro Legendre_mod [symmetric]) auto"], ["proof (state)\nthis:\n  Legendre (int p) 3 = Legendre (int p mod 3) 3\n\ngoal (2 subgoals):\n 1. p mod 12 = 7 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 2. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "also"], ["proof (state)\nthis:\n  Legendre (int p) 3 = Legendre (int p mod 3) 3\n\ngoal (2 subgoals):\n 1. p mod 12 = 7 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 2. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "from \\<open>p mod 12 = 7\\<close>"], ["proof (chain)\npicking this:\n  p mod 12 = 7", "have \"p mod 12 mod 3 = 1\""], ["proof (prove)\nusing this:\n  p mod 12 = 7\n\ngoal (1 subgoal):\n 1. p mod 12 mod 3 = 1", "by simp"], ["proof (state)\nthis:\n  p mod 12 mod 3 = 1\n\ngoal (2 subgoals):\n 1. p mod 12 = 7 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 2. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "hence \"p mod 3 = 1\""], ["proof (prove)\nusing this:\n  p mod 12 mod 3 = 1\n\ngoal (1 subgoal):\n 1. p mod 3 = 1", "by (simp add: mod_mod_cancel)"], ["proof (state)\nthis:\n  p mod 3 = 1\n\ngoal (2 subgoals):\n 1. p mod 12 = 7 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 2. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "hence \"int p mod 3 = 1\""], ["proof (prove)\nusing this:\n  p mod 3 = 1\n\ngoal (1 subgoal):\n 1. int p mod 3 = 1", "by presburger"], ["proof (state)\nthis:\n  int p mod 3 = 1\n\ngoal (2 subgoals):\n 1. p mod 12 = 7 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 2. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "finally"], ["proof (chain)\npicking this:\n  Legendre (int p) 3 = Legendre 1 3", "have \"Legendre p 3 = 1\""], ["proof (prove)\nusing this:\n  Legendre (int p) 3 = Legendre 1 3\n\ngoal (1 subgoal):\n 1. Legendre (int p) 3 = 1", "by simp"], ["proof (state)\nthis:\n  Legendre (int p) 3 = 1\n\ngoal (2 subgoals):\n 1. p mod 12 = 7 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n 2. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Legendre (int p) 3 = 1\n\ngoal (1 subgoal):\n 1. Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "using \\<open>p mod 12 = 7\\<close>"], ["proof (prove)\nusing this:\n  Legendre (int p) 3 = 1\n  p mod 12 = 7\n\ngoal (1 subgoal):\n 1. Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "by simp"], ["proof (state)\nthis:\n  Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n\ngoal (1 subgoal):\n 1. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "assume \"p mod 12 = 11\""], ["proof (state)\nthis:\n  p mod 12 = 11\n\ngoal (1 subgoal):\n 1. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "have \"Legendre (int p) 3 = Legendre (int p mod 3) 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Legendre (int p) 3 = Legendre (int p mod 3) 3", "by (intro Legendre_mod [symmetric]) auto"], ["proof (state)\nthis:\n  Legendre (int p) 3 = Legendre (int p mod 3) 3\n\ngoal (1 subgoal):\n 1. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "also"], ["proof (state)\nthis:\n  Legendre (int p) 3 = Legendre (int p mod 3) 3\n\ngoal (1 subgoal):\n 1. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "from \\<open>p mod 12 = 11\\<close>"], ["proof (chain)\npicking this:\n  p mod 12 = 11", "have \"p mod 12 mod 3 = 2\""], ["proof (prove)\nusing this:\n  p mod 12 = 11\n\ngoal (1 subgoal):\n 1. p mod 12 mod 3 = 2", "by simp"], ["proof (state)\nthis:\n  p mod 12 mod 3 = 2\n\ngoal (1 subgoal):\n 1. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "hence \"p mod 3 = 2\""], ["proof (prove)\nusing this:\n  p mod 12 mod 3 = 2\n\ngoal (1 subgoal):\n 1. p mod 3 = 2", "by (simp add: mod_mod_cancel)"], ["proof (state)\nthis:\n  p mod 3 = 2\n\ngoal (1 subgoal):\n 1. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "hence \"int p mod 3 = 2\""], ["proof (prove)\nusing this:\n  p mod 3 = 2\n\ngoal (1 subgoal):\n 1. int p mod 3 = 2", "by presburger"], ["proof (state)\nthis:\n  int p mod 3 = 2\n\ngoal (1 subgoal):\n 1. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "finally"], ["proof (chain)\npicking this:\n  Legendre (int p) 3 = Legendre 2 3", "have \"Legendre p 3 = -1\""], ["proof (prove)\nusing this:\n  Legendre (int p) 3 = Legendre 2 3\n\ngoal (1 subgoal):\n 1. Legendre (int p) 3 = - 1", "by (simp add: supplement2_Legendre)"], ["proof (state)\nthis:\n  Legendre (int p) 3 = - 1\n\ngoal (1 subgoal):\n 1. p mod 12 = 11 \\<Longrightarrow>\n    Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Legendre (int p) 3 = - 1\n\ngoal (1 subgoal):\n 1. Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "using \\<open>p mod 12 = 11\\<close>"], ["proof (prove)\nusing this:\n  Legendre (int p) 3 = - 1\n  p mod 12 = 11\n\ngoal (1 subgoal):\n 1. Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)", "by simp"], ["proof (state)\nthis:\n  Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Legendre (int p) 3 = (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Legendre_3_left:\n  fixes p :: nat\n  assumes p: \"prime p\" \"p > 3\"\n  shows   \"Legendre 3 p = (if p mod 12 \\<in> {1, 11} then 1 else -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Legendre 3 (int p) = (if p mod 12 \\<in> {1, 11} then 1 else - 1)", "proof (cases \"p mod 12 = 1 \\<or> p mod 12 = 5\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p mod 12 = 1 \\<or> p mod 12 = 5 \\<Longrightarrow>\n    Legendre 3 (int p) = (if p mod 12 \\<in> {1, 11} then 1 else - 1)\n 2. \\<not> (p mod 12 = 1 \\<or> p mod 12 = 5) \\<Longrightarrow>\n    Legendre 3 (int p) = (if p mod 12 \\<in> {1, 11} then 1 else - 1)", "case True"], ["proof (state)\nthis:\n  p mod 12 = 1 \\<or> p mod 12 = 5\n\ngoal (2 subgoals):\n 1. p mod 12 = 1 \\<or> p mod 12 = 5 \\<Longrightarrow>\n    Legendre 3 (int p) = (if p mod 12 \\<in> {1, 11} then 1 else - 1)\n 2. \\<not> (p mod 12 = 1 \\<or> p mod 12 = 5) \\<Longrightarrow>\n    Legendre 3 (int p) = (if p mod 12 \\<in> {1, 11} then 1 else - 1)", "hence \"p mod 12 mod 4 = 1\""], ["proof (prove)\nusing this:\n  p mod 12 = 1 \\<or> p mod 12 = 5\n\ngoal (1 subgoal):\n 1. p mod 12 mod 4 = 1", "by auto"], ["proof (state)\nthis:\n  p mod 12 mod 4 = 1\n\ngoal (2 subgoals):\n 1. p mod 12 = 1 \\<or> p mod 12 = 5 \\<Longrightarrow>\n    Legendre 3 (int p) = (if p mod 12 \\<in> {1, 11} then 1 else - 1)\n 2. \\<not> (p mod 12 = 1 \\<or> p mod 12 = 5) \\<Longrightarrow>\n    Legendre 3 (int p) = (if p mod 12 \\<in> {1, 11} then 1 else - 1)", "hence \"even ((p - Suc 0) div 2)\""], ["proof (prove)\nusing this:\n  p mod 12 mod 4 = 1\n\ngoal (1 subgoal):\n 1. even ((p - Suc 0) div 2)", "by (intro even_mod_4_div_2) (auto simp: mod_mod_cancel)"], ["proof (state)\nthis:\n  even ((p - Suc 0) div 2)\n\ngoal (2 subgoals):\n 1. p mod 12 = 1 \\<or> p mod 12 = 5 \\<Longrightarrow>\n    Legendre 3 (int p) = (if p mod 12 \\<in> {1, 11} then 1 else - 1)\n 2. \\<not> (p mod 12 = 1 \\<or> p mod 12 = 5) \\<Longrightarrow>\n    Legendre 3 (int p) = (if p mod 12 \\<in> {1, 11} then 1 else - 1)", "with Quadratic_Reciprocity[of p 3] Legendre_3_right(2)[of p] assms True"], ["proof (chain)\npicking this:\n  \\<lbrakk>prime p; 2 < p; prime 3; 2 < 3; p \\<noteq> 3\\<rbrakk>\n  \\<Longrightarrow> Legendre (int p) (int 3) * Legendre (int 3) (int p) =\n                    (- 1) ^ ((p - 1) div 2 * ((3 - 1) div 2))\n  \\<lbrakk>prime p; 3 < p\\<rbrakk>\n  \\<Longrightarrow> Legendre (int p) 3 =\n                    (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n  prime p\n  3 < p\n  p mod 12 = 1 \\<or> p mod 12 = 5\n  even ((p - Suc 0) div 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>prime p; 2 < p; prime 3; 2 < 3; p \\<noteq> 3\\<rbrakk>\n  \\<Longrightarrow> Legendre (int p) (int 3) * Legendre (int 3) (int p) =\n                    (- 1) ^ ((p - 1) div 2 * ((3 - 1) div 2))\n  \\<lbrakk>prime p; 3 < p\\<rbrakk>\n  \\<Longrightarrow> Legendre (int p) 3 =\n                    (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n  prime p\n  3 < p\n  p mod 12 = 1 \\<or> p mod 12 = 5\n  even ((p - Suc 0) div 2)\n\ngoal (1 subgoal):\n 1. Legendre 3 (int p) = (if p mod 12 \\<in> {1, 11} then 1 else - 1)", "by auto"], ["proof (state)\nthis:\n  Legendre 3 (int p) = (if p mod 12 \\<in> {1, 11} then 1 else - 1)\n\ngoal (1 subgoal):\n 1. \\<not> (p mod 12 = 1 \\<or> p mod 12 = 5) \\<Longrightarrow>\n    Legendre 3 (int p) = (if p mod 12 \\<in> {1, 11} then 1 else - 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (p mod 12 = 1 \\<or> p mod 12 = 5) \\<Longrightarrow>\n    Legendre 3 (int p) = (if p mod 12 \\<in> {1, 11} then 1 else - 1)", "case False"], ["proof (state)\nthis:\n  \\<not> (p mod 12 = 1 \\<or> p mod 12 = 5)\n\ngoal (1 subgoal):\n 1. \\<not> (p mod 12 = 1 \\<or> p mod 12 = 5) \\<Longrightarrow>\n    Legendre 3 (int p) = (if p mod 12 \\<in> {1, 11} then 1 else - 1)", "with Legendre_3_right(1)[OF assms]"], ["proof (chain)\npicking this:\n  p mod 12 \\<in> {1, 5, 7, 11}\n  \\<not> (p mod 12 = 1 \\<or> p mod 12 = 5)", "have *: \"p mod 12 = 7 \\<or> p mod 12 = 11\""], ["proof (prove)\nusing this:\n  p mod 12 \\<in> {1, 5, 7, 11}\n  \\<not> (p mod 12 = 1 \\<or> p mod 12 = 5)\n\ngoal (1 subgoal):\n 1. p mod 12 = 7 \\<or> p mod 12 = 11", "by auto"], ["proof (state)\nthis:\n  p mod 12 = 7 \\<or> p mod 12 = 11\n\ngoal (1 subgoal):\n 1. \\<not> (p mod 12 = 1 \\<or> p mod 12 = 5) \\<Longrightarrow>\n    Legendre 3 (int p) = (if p mod 12 \\<in> {1, 11} then 1 else - 1)", "hence \"p mod 12 mod 4 = 3\""], ["proof (prove)\nusing this:\n  p mod 12 = 7 \\<or> p mod 12 = 11\n\ngoal (1 subgoal):\n 1. p mod 12 mod 4 = 3", "by auto"], ["proof (state)\nthis:\n  p mod 12 mod 4 = 3\n\ngoal (1 subgoal):\n 1. \\<not> (p mod 12 = 1 \\<or> p mod 12 = 5) \\<Longrightarrow>\n    Legendre 3 (int p) = (if p mod 12 \\<in> {1, 11} then 1 else - 1)", "hence \"odd ((p - Suc 0) div 2)\""], ["proof (prove)\nusing this:\n  p mod 12 mod 4 = 3\n\ngoal (1 subgoal):\n 1. odd ((p - Suc 0) div 2)", "by (intro odd_mod_4_div_2) (auto simp: mod_mod_cancel)"], ["proof (state)\nthis:\n  odd ((p - Suc 0) div 2)\n\ngoal (1 subgoal):\n 1. \\<not> (p mod 12 = 1 \\<or> p mod 12 = 5) \\<Longrightarrow>\n    Legendre 3 (int p) = (if p mod 12 \\<in> {1, 11} then 1 else - 1)", "with Quadratic_Reciprocity[of p 3] Legendre_3_right(2)[of p] assms *"], ["proof (chain)\npicking this:\n  \\<lbrakk>prime p; 2 < p; prime 3; 2 < 3; p \\<noteq> 3\\<rbrakk>\n  \\<Longrightarrow> Legendre (int p) (int 3) * Legendre (int 3) (int p) =\n                    (- 1) ^ ((p - 1) div 2 * ((3 - 1) div 2))\n  \\<lbrakk>prime p; 3 < p\\<rbrakk>\n  \\<Longrightarrow> Legendre (int p) 3 =\n                    (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n  prime p\n  3 < p\n  p mod 12 = 7 \\<or> p mod 12 = 11\n  odd ((p - Suc 0) div 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>prime p; 2 < p; prime 3; 2 < 3; p \\<noteq> 3\\<rbrakk>\n  \\<Longrightarrow> Legendre (int p) (int 3) * Legendre (int 3) (int p) =\n                    (- 1) ^ ((p - 1) div 2 * ((3 - 1) div 2))\n  \\<lbrakk>prime p; 3 < p\\<rbrakk>\n  \\<Longrightarrow> Legendre (int p) 3 =\n                    (if p mod 12 \\<in> {1, 7} then 1 else - 1)\n  prime p\n  3 < p\n  p mod 12 = 7 \\<or> p mod 12 = 11\n  odd ((p - Suc 0) div 2)\n\ngoal (1 subgoal):\n 1. Legendre 3 (int p) = (if p mod 12 \\<in> {1, 11} then 1 else - 1)", "by fastforce"], ["proof (state)\nthis:\n  Legendre 3 (int p) = (if p mod 12 \\<in> {1, 11} then 1 else - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma supplement2_Legendre':\n  assumes \"prime p\" \"p \\<noteq> 2\"\n  shows \"Legendre 2 p = (if p mod 8 = 1 \\<or> p mod 8 = 7 then 1 else -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Legendre 2 p = (if p mod 8 = 1 \\<or> p mod 8 = 7 then 1 else - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Legendre 2 p = (if p mod 8 = 1 \\<or> p mod 8 = 7 then 1 else - 1)", "from assms"], ["proof (chain)\npicking this:\n  prime p\n  p \\<noteq> 2", "have \"p > 2\""], ["proof (prove)\nusing this:\n  prime p\n  p \\<noteq> 2\n\ngoal (1 subgoal):\n 1. 2 < p", "using prime_gt_1_int[of p]"], ["proof (prove)\nusing this:\n  prime p\n  p \\<noteq> 2\n  prime p \\<Longrightarrow> 1 < p\n\ngoal (1 subgoal):\n 1. 2 < p", "by auto"], ["proof (state)\nthis:\n  2 < p\n\ngoal (1 subgoal):\n 1. Legendre 2 p = (if p mod 8 = 1 \\<or> p mod 8 = 7 then 1 else - 1)", "moreover"], ["proof (state)\nthis:\n  2 < p\n\ngoal (1 subgoal):\n 1. Legendre 2 p = (if p mod 8 = 1 \\<or> p mod 8 = 7 then 1 else - 1)", "from this and assms"], ["proof (chain)\npicking this:\n  2 < p\n  prime p\n  p \\<noteq> 2", "have \"odd p\""], ["proof (prove)\nusing this:\n  2 < p\n  prime p\n  p \\<noteq> 2\n\ngoal (1 subgoal):\n 1. odd p", "by (auto simp: prime_odd_int)"], ["proof (state)\nthis:\n  odd p\n\ngoal (1 subgoal):\n 1. Legendre 2 p = (if p mod 8 = 1 \\<or> p mod 8 = 7 then 1 else - 1)", "ultimately"], ["proof (chain)\npicking this:\n  2 < p\n  odd p", "show ?thesis"], ["proof (prove)\nusing this:\n  2 < p\n  odd p\n\ngoal (1 subgoal):\n 1. Legendre 2 p = (if p mod 8 = 1 \\<or> p mod 8 = 7 then 1 else - 1)", "using supplement2_Jacobi'[of p] assms prime_odd_int[of p]"], ["proof (prove)\nusing this:\n  2 < p\n  odd p\n  \\<lbrakk>odd p; 1 < p\\<rbrakk>\n  \\<Longrightarrow> Jacobi 2 p =\n                    (if p mod 8 = 1 \\<or> p mod 8 = 7 then 1 else - 1)\n  prime p\n  p \\<noteq> 2\n  \\<lbrakk>prime p; 2 < p\\<rbrakk> \\<Longrightarrow> odd p\n\ngoal (1 subgoal):\n 1. Legendre 2 p = (if p mod 8 = 1 \\<or> p mod 8 = 7 then 1 else - 1)", "by (simp add: prime_p_Jacobi_eq_Legendre)"], ["proof (state)\nthis:\n  Legendre 2 p = (if p mod 8 = 1 \\<or> p mod 8 = 7 then 1 else - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma little_Fermat_nat:\n  fixes a :: nat\n  assumes \"prime p\" \"\\<not>p dvd a\"\n  shows   \"[a ^ p = a] (mod p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a ^ p = a] (mod p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [a ^ p = a] (mod p)", "have \"p = Suc (p - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = Suc (p - 1)", "using prime_gt_0_nat[OF assms(1)]"], ["proof (prove)\nusing this:\n  0 < p\n\ngoal (1 subgoal):\n 1. p = Suc (p - 1)", "by simp"], ["proof (state)\nthis:\n  p = Suc (p - 1)\n\ngoal (1 subgoal):\n 1. [a ^ p = a] (mod p)", "also"], ["proof (state)\nthis:\n  p = Suc (p - 1)\n\ngoal (1 subgoal):\n 1. [a ^ p = a] (mod p)", "have \"p - 1 = totient p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p - 1 = totient p", "using assms"], ["proof (prove)\nusing this:\n  prime p\n  \\<not> p dvd a\n\ngoal (1 subgoal):\n 1. p - 1 = totient p", "by (simp add: totient_prime)"], ["proof (state)\nthis:\n  p - 1 = totient p\n\ngoal (1 subgoal):\n 1. [a ^ p = a] (mod p)", "also"], ["proof (state)\nthis:\n  p - 1 = totient p\n\ngoal (1 subgoal):\n 1. [a ^ p = a] (mod p)", "have \"a ^ (Suc \\<dots>) = a * a ^ totient p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a ^ Suc (totient p) = a * a ^ totient p", "by simp"], ["proof (state)\nthis:\n  a ^ Suc (totient p) = a * a ^ totient p\n\ngoal (1 subgoal):\n 1. [a ^ p = a] (mod p)", "also"], ["proof (state)\nthis:\n  a ^ Suc (totient p) = a * a ^ totient p\n\ngoal (1 subgoal):\n 1. [a ^ p = a] (mod p)", "have \"[\\<dots> = a * 1] (mod p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a * a ^ totient p = a * 1] (mod p)", "using prime_imp_coprime[of p a] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>prime p; \\<not> p dvd a\\<rbrakk> \\<Longrightarrow> coprime p a\n  prime p\n  \\<not> p dvd a\n\ngoal (1 subgoal):\n 1. [a * a ^ totient p = a * 1] (mod p)", "by (intro cong_mult cong_refl euler_theorem) (auto simp: coprime_commute)"], ["proof (state)\nthis:\n  [a * a ^ totient p = a * 1] (mod p)\n\ngoal (1 subgoal):\n 1. [a ^ p = a] (mod p)", "finally"], ["proof (chain)\npicking this:\n  [a ^ p = a * 1] (mod p)", "show ?thesis"], ["proof (prove)\nusing this:\n  [a ^ p = a * 1] (mod p)\n\ngoal (1 subgoal):\n 1. [a ^ p = a] (mod p)", "by simp"], ["proof (state)\nthis:\n  [a ^ p = a] (mod p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma little_Fermat_int:\n  fixes a :: int and p :: nat\n  assumes \"prime p\" \"\\<not>p dvd a\"\n  shows   \"[a ^ p = a] (mod p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a ^ p = a] (mod int p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [a ^ p = a] (mod int p)", "have \"p > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < p", "using prime_gt_1_nat assms"], ["proof (prove)\nusing this:\n  prime ?p \\<Longrightarrow> 1 < ?p\n  prime p\n  \\<not> int p dvd a\n\ngoal (1 subgoal):\n 1. 1 < p", "by simp"], ["proof (state)\nthis:\n  1 < p\n\ngoal (1 subgoal):\n 1. [a ^ p = a] (mod int p)", "have \"\\<not>int p dvd a mod int p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> int p dvd a mod int p", "using assms"], ["proof (prove)\nusing this:\n  prime p\n  \\<not> int p dvd a\n\ngoal (1 subgoal):\n 1. \\<not> int p dvd a mod int p", "by (simp add: dvd_mod_iff)"], ["proof (state)\nthis:\n  \\<not> int p dvd a mod int p\n\ngoal (1 subgoal):\n 1. [a ^ p = a] (mod int p)", "also"], ["proof (state)\nthis:\n  \\<not> int p dvd a mod int p\n\ngoal (1 subgoal):\n 1. [a ^ p = a] (mod int p)", "from \\<open>p > 1\\<close>"], ["proof (chain)\npicking this:\n  1 < p", "have \"a mod int p = int (nat (a mod int p))\""], ["proof (prove)\nusing this:\n  1 < p\n\ngoal (1 subgoal):\n 1. a mod int p = int (nat (a mod int p))", "by simp"], ["proof (state)\nthis:\n  a mod int p = int (nat (a mod int p))\n\ngoal (1 subgoal):\n 1. [a ^ p = a] (mod int p)", "finally"], ["proof (chain)\npicking this:\n  \\<not> int p dvd int (nat (a mod int p))", "have not_dvd: \"\\<not>p dvd nat (a mod int p)\""], ["proof (prove)\nusing this:\n  \\<not> int p dvd int (nat (a mod int p))\n\ngoal (1 subgoal):\n 1. \\<not> p dvd nat (a mod int p)", "by (subst (asm) int_dvd_int_iff)"], ["proof (state)\nthis:\n  \\<not> p dvd nat (a mod int p)\n\ngoal (1 subgoal):\n 1. [a ^ p = a] (mod int p)", "have \"[a ^ p = (a mod p) ^ p] (mod p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a ^ p = (a mod int p) ^ p] (mod int p)", "by (intro cong_pow) (auto simp: cong_def)"], ["proof (state)\nthis:\n  [a ^ p = (a mod int p) ^ p] (mod int p)\n\ngoal (1 subgoal):\n 1. [a ^ p = a] (mod int p)", "also"], ["proof (state)\nthis:\n  [a ^ p = (a mod int p) ^ p] (mod int p)\n\ngoal (1 subgoal):\n 1. [a ^ p = a] (mod int p)", "have \"(a mod p) ^ p = (int (nat (a mod p))) ^ p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a mod int p) ^ p = int (nat (a mod int p)) ^ p", "using \\<open>p > 1\\<close>"], ["proof (prove)\nusing this:\n  1 < p\n\ngoal (1 subgoal):\n 1. (a mod int p) ^ p = int (nat (a mod int p)) ^ p", "by (subst of_nat_nat) auto"], ["proof (state)\nthis:\n  (a mod int p) ^ p = int (nat (a mod int p)) ^ p\n\ngoal (1 subgoal):\n 1. [a ^ p = a] (mod int p)", "also"], ["proof (state)\nthis:\n  (a mod int p) ^ p = int (nat (a mod int p)) ^ p\n\ngoal (1 subgoal):\n 1. [a ^ p = a] (mod int p)", "have \"\\<dots> = int (nat (a mod p) ^ p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (nat (a mod int p)) ^ p = int (nat (a mod int p) ^ p)", "by simp"], ["proof (state)\nthis:\n  int (nat (a mod int p)) ^ p = int (nat (a mod int p) ^ p)\n\ngoal (1 subgoal):\n 1. [a ^ p = a] (mod int p)", "also"], ["proof (state)\nthis:\n  int (nat (a mod int p)) ^ p = int (nat (a mod int p) ^ p)\n\ngoal (1 subgoal):\n 1. [a ^ p = a] (mod int p)", "have \"[\\<dots> = int (nat (a mod p))] (mod p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [int (nat (a mod int p) ^ p) = int (nat (a mod int p))] (mod int p)", "by (subst cong_int_iff, rule little_Fermat_nat) (use assms not_dvd in auto)"], ["proof (state)\nthis:\n  [int (nat (a mod int p) ^ p) = int (nat (a mod int p))] (mod int p)\n\ngoal (1 subgoal):\n 1. [a ^ p = a] (mod int p)", "also"], ["proof (state)\nthis:\n  [int (nat (a mod int p) ^ p) = int (nat (a mod int p))] (mod int p)\n\ngoal (1 subgoal):\n 1. [a ^ p = a] (mod int p)", "have \"int (nat (a mod p)) = a mod p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (nat (a mod int p)) = a mod int p", "using \\<open>p > 1\\<close>"], ["proof (prove)\nusing this:\n  1 < p\n\ngoal (1 subgoal):\n 1. int (nat (a mod int p)) = a mod int p", "by simp"], ["proof (state)\nthis:\n  int (nat (a mod int p)) = a mod int p\n\ngoal (1 subgoal):\n 1. [a ^ p = a] (mod int p)", "also"], ["proof (state)\nthis:\n  int (nat (a mod int p)) = a mod int p\n\ngoal (1 subgoal):\n 1. [a ^ p = a] (mod int p)", "have \"[a mod p = a] (mod p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a mod int p = a] (mod int p)", "by (auto simp: cong_def)"], ["proof (state)\nthis:\n  [a mod int p = a] (mod int p)\n\ngoal (1 subgoal):\n 1. [a ^ p = a] (mod int p)", "finally"], ["proof (chain)\npicking this:\n  [a ^ p = a] (mod int p)", "show ?thesis"], ["proof (prove)\nusing this:\n  [a ^ p = a] (mod int p)\n\ngoal (1 subgoal):\n 1. [a ^ p = a] (mod int p)", "."], ["proof (state)\nthis:\n  [a ^ p = a] (mod int p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prime_dvd_choose:\n  assumes \"0 < k\" \"k < p\" \"prime p\" \n  shows \"p dvd (p choose k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p dvd p choose k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p dvd p choose k", "have \"k \\<le> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> p", "using \\<open>k < p\\<close>"], ["proof (prove)\nusing this:\n  k < p\n\ngoal (1 subgoal):\n 1. k \\<le> p", "by auto"], ["proof (state)\nthis:\n  k \\<le> p\n\ngoal (1 subgoal):\n 1. p dvd p choose k", "have \"p dvd fact p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p dvd fact p", "using assms"], ["proof (prove)\nusing this:\n  0 < k\n  k < p\n  prime p\n\ngoal (1 subgoal):\n 1. p dvd fact p", "by (simp add: prime_dvd_fact_iff)"], ["proof (state)\nthis:\n  p dvd fact p\n\ngoal (1 subgoal):\n 1. p dvd p choose k", "moreover"], ["proof (state)\nthis:\n  p dvd fact p\n\ngoal (1 subgoal):\n 1. p dvd p choose k", "have \"\\<not> p dvd fact k * fact (p - k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> p dvd fact k * fact (p - k)", "unfolding prime_dvd_mult_iff[OF assms(3)] prime_dvd_fact_iff[OF assms(3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (p \\<le> k \\<or> p \\<le> p - k)", "using assms"], ["proof (prove)\nusing this:\n  0 < k\n  k < p\n  prime p\n\ngoal (1 subgoal):\n 1. \\<not> (p \\<le> k \\<or> p \\<le> p - k)", "by simp"], ["proof (state)\nthis:\n  \\<not> p dvd fact k * fact (p - k)\n\ngoal (1 subgoal):\n 1. p dvd p choose k", "ultimately"], ["proof (chain)\npicking this:\n  p dvd fact p\n  \\<not> p dvd fact k * fact (p - k)", "show ?thesis"], ["proof (prove)\nusing this:\n  p dvd fact p\n  \\<not> p dvd fact k * fact (p - k)\n\ngoal (1 subgoal):\n 1. p dvd p choose k", "unfolding binomial_fact_lemma[OF \\<open>k \\<le> p\\<close>, symmetric]"], ["proof (prove)\nusing this:\n  p dvd fact k * fact (p - k) * (p choose k)\n  \\<not> p dvd fact k * fact (p - k)\n\ngoal (1 subgoal):\n 1. p dvd p choose k", "using assms prime_dvd_multD"], ["proof (prove)\nusing this:\n  p dvd fact k * fact (p - k) * (p choose k)\n  \\<not> p dvd fact k * fact (p - k)\n  0 < k\n  k < p\n  prime p\n  \\<lbrakk>prime ?p; ?p dvd ?a * ?b\\<rbrakk>\n  \\<Longrightarrow> ?p dvd ?a \\<or> ?p dvd ?b\n\ngoal (1 subgoal):\n 1. p dvd p choose k", "by blast"], ["proof (state)\nthis:\n  p dvd p choose k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prime_natD:\n  assumes \"prime (p :: nat)\" \"a dvd p\"\n  shows   \"a = 1 \\<or> a = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = 1 \\<or> a = p", "using assms"], ["proof (prove)\nusing this:\n  prime p\n  a dvd p\n\ngoal (1 subgoal):\n 1. a = 1 \\<or> a = p", "by (auto simp: prime_nat_iff)"], ["", "lemma not_prime_imp_ex_prod_nat:\n  assumes \"m > 1\" \"\\<not> prime (m::nat)\"\n  shows   \"\\<exists>n k. m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "from assms"], ["proof (chain)\npicking this:\n  1 < m\n  \\<not> prime m", "have \"\\<not>Factorial_Ring.irreducible m\""], ["proof (prove)\nusing this:\n  1 < m\n  \\<not> prime m\n\ngoal (1 subgoal):\n 1. \\<not> comm_semiring_1_class.irreducible m", "by (simp flip: prime_elem_iff_irreducible)"], ["proof (state)\nthis:\n  \\<not> comm_semiring_1_class.irreducible m\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "with assms"], ["proof (chain)\npicking this:\n  1 < m\n  \\<not> prime m\n  \\<not> comm_semiring_1_class.irreducible m", "obtain n k where nk: \"m = n * k\" \"n \\<noteq> 1\" \"k \\<noteq> 1\""], ["proof (prove)\nusing this:\n  1 < m\n  \\<not> prime m\n  \\<not> comm_semiring_1_class.irreducible m\n\ngoal (1 subgoal):\n 1. (\\<And>n k.\n        \\<lbrakk>m = n * k; n \\<noteq> 1; k \\<noteq> 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Factorial_Ring.irreducible_def)"], ["proof (state)\nthis:\n  m = n * k\n  n \\<noteq> 1\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "moreover"], ["proof (state)\nthis:\n  m = n * k\n  n \\<noteq> 1\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "from this assms"], ["proof (chain)\npicking this:\n  m = n * k\n  n \\<noteq> 1\n  k \\<noteq> 1\n  1 < m\n  \\<not> prime m", "have \"n > 0\" \"k > 0\""], ["proof (prove)\nusing this:\n  m = n * k\n  n \\<noteq> 1\n  k \\<noteq> 1\n  1 < m\n  \\<not> prime m\n\ngoal (1 subgoal):\n 1. 0 < n &&& 0 < k", "by auto"], ["proof (state)\nthis:\n  0 < n\n  0 < k\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "with nk"], ["proof (chain)\npicking this:\n  m = n * k\n  n \\<noteq> 1\n  k \\<noteq> 1\n  0 < n\n  0 < k", "have \"n > 1\" \"k > 1\""], ["proof (prove)\nusing this:\n  m = n * k\n  n \\<noteq> 1\n  k \\<noteq> 1\n  0 < n\n  0 < k\n\ngoal (1 subgoal):\n 1. 1 < n &&& 1 < k", "by auto"], ["proof (state)\nthis:\n  1 < n\n  1 < k\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "moreover"], ["proof (state)\nthis:\n  1 < n\n  1 < k\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "{"], ["proof (state)\nthis:\n  1 < n\n  1 < k\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "from assms nk"], ["proof (chain)\npicking this:\n  1 < m\n  \\<not> prime m\n  m = n * k\n  n \\<noteq> 1\n  k \\<noteq> 1", "have \"n dvd m\" \"k dvd m\""], ["proof (prove)\nusing this:\n  1 < m\n  \\<not> prime m\n  m = n * k\n  n \\<noteq> 1\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. n dvd m &&& k dvd m", "by auto"], ["proof (state)\nthis:\n  n dvd m\n  k dvd m\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "with assms"], ["proof (chain)\npicking this:\n  1 < m\n  \\<not> prime m\n  n dvd m\n  k dvd m", "have \"n \\<le> m\" \"k \\<le> m\""], ["proof (prove)\nusing this:\n  1 < m\n  \\<not> prime m\n  n dvd m\n  k dvd m\n\ngoal (1 subgoal):\n 1. n \\<le> m &&& k \\<le> m", "by (auto intro!: dvd_imp_le)"], ["proof (state)\nthis:\n  n \\<le> m\n  k \\<le> m\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "moreover"], ["proof (state)\nthis:\n  n \\<le> m\n  k \\<le> m\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "from nk \\<open>n > 1\\<close> \\<open>k > 1\\<close>"], ["proof (chain)\npicking this:\n  m = n * k\n  n \\<noteq> 1\n  k \\<noteq> 1\n  1 < n\n  1 < k", "have \"n \\<noteq> m\" \"k \\<noteq> m\""], ["proof (prove)\nusing this:\n  m = n * k\n  n \\<noteq> 1\n  k \\<noteq> 1\n  1 < n\n  1 < k\n\ngoal (1 subgoal):\n 1. n \\<noteq> m &&& k \\<noteq> m", "by auto"], ["proof (state)\nthis:\n  n \\<noteq> m\n  k \\<noteq> m\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "ultimately"], ["proof (chain)\npicking this:\n  n \\<le> m\n  k \\<le> m\n  n \\<noteq> m\n  k \\<noteq> m", "have \"n < m\" \"k < m\""], ["proof (prove)\nusing this:\n  n \\<le> m\n  k \\<le> m\n  n \\<noteq> m\n  k \\<noteq> m\n\ngoal (1 subgoal):\n 1. n < m &&& k < m", "by auto"], ["proof (state)\nthis:\n  n < m\n  k < m\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "}"], ["proof (state)\nthis:\n  n < m\n  k < m\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "ultimately"], ["proof (chain)\npicking this:\n  m = n * k\n  n \\<noteq> 1\n  k \\<noteq> 1\n  1 < n\n  1 < k\n  n < m\n  k < m", "show ?thesis"], ["proof (prove)\nusing this:\n  m = n * k\n  n \\<noteq> 1\n  k \\<noteq> 1\n  1 < n\n  1 < k\n  n < m\n  k < m\n\ngoal (1 subgoal):\n 1. \\<exists>n k.\n       m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m", "by blast"], ["proof (state)\nthis:\n  \\<exists>n k.\n     m = n * k \\<and> 1 < n \\<and> n < m \\<and> 1 < k \\<and> k < m\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Auxiliary algebraic material\\<close>"], ["", "lemma (in group) ord_eqI_prime_factors:\n  assumes \"\\<And>p. p \\<in> prime_factors n \\<Longrightarrow> x [^] (n div p) \\<noteq> \\<one>\" and \"x [^] n = \\<one>\"\n  assumes \"x \\<in> carrier G\" \"n > 0\"\n  shows   \"group.ord G x = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ord x = n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.ord x = n", "have \"group.ord G x dvd n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ord x dvd n", "using assms"], ["proof (prove)\nusing this:\n  ?p \\<in># prime_factorization n \\<Longrightarrow>\n  x [^] (n div ?p) \\<noteq> \\<one>\n  x [^] n = \\<one>\n  x \\<in> carrier G\n  0 < n\n\ngoal (1 subgoal):\n 1. local.ord x dvd n", "by (subst pow_eq_id [symmetric]) auto"], ["proof (state)\nthis:\n  local.ord x dvd n\n\ngoal (1 subgoal):\n 1. local.ord x = n", "then"], ["proof (chain)\npicking this:\n  local.ord x dvd n", "obtain k where k: \"n = group.ord G x * k\""], ["proof (prove)\nusing this:\n  local.ord x dvd n\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        n = local.ord x * k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n = local.ord x * k\n\ngoal (1 subgoal):\n 1. local.ord x = n", "have \"k = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k = 1", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> False", "assume \"k \\<noteq> 1\""], ["proof (state)\nthis:\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  k \\<noteq> 1", "obtain p where p: \"prime p\" \"p dvd k\""], ["proof (prove)\nusing this:\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>prime p; p dvd k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prime_factor_nat"], ["proof (prove)\nusing this:\n  k \\<noteq> 1\n  ?n \\<noteq> 1 \\<Longrightarrow> \\<exists>p. prime p \\<and> p dvd ?n\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>prime p; p dvd k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  prime p\n  p dvd k\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> False", "have \"x [^] (group.ord G x * (k div p)) = \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x [^] (local.ord x * (k div p)) = \\<one>", "by (subst pow_eq_id) (use assms in auto)"], ["proof (state)\nthis:\n  x [^] (local.ord x * (k div p)) = \\<one>\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  x [^] (local.ord x * (k div p)) = \\<one>\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> False", "have \"group.ord G x * (k div p) = n div p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ord x * (k div p) = n div p", "using p"], ["proof (prove)\nusing this:\n  prime p\n  p dvd k\n\ngoal (1 subgoal):\n 1. local.ord x * (k div p) = n div p", "by (auto simp: k)"], ["proof (state)\nthis:\n  local.ord x * (k div p) = n div p\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  x [^] (n div p) = \\<one>", "have \"x [^] (n div p) = \\<one>\""], ["proof (prove)\nusing this:\n  x [^] (n div p) = \\<one>\n\ngoal (1 subgoal):\n 1. x [^] (n div p) = \\<one>", "."], ["proof (state)\nthis:\n  x [^] (n div p) = \\<one>\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  x [^] (n div p) = \\<one>\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> False", "have \"x [^] (n div p) \\<noteq> \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x [^] (n div p) \\<noteq> \\<one>", "using p k assms"], ["proof (prove)\nusing this:\n  prime p\n  p dvd k\n  n = local.ord x * k\n  ?p \\<in># prime_factorization n \\<Longrightarrow>\n  x [^] (n div ?p) \\<noteq> \\<one>\n  x [^] n = \\<one>\n  x \\<in> carrier G\n  0 < n\n\ngoal (1 subgoal):\n 1. x [^] (n div p) \\<noteq> \\<one>", "by (intro assms) (auto simp: in_prime_factors_iff)"], ["proof (state)\nthis:\n  x [^] (n div p) \\<noteq> \\<one>\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  x [^] (n div p) = \\<one>\n  x [^] (n div p) \\<noteq> \\<one>", "show False"], ["proof (prove)\nusing this:\n  x [^] (n div p) = \\<one>\n  x [^] (n div p) \\<noteq> \\<one>\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k = 1\n\ngoal (1 subgoal):\n 1. local.ord x = n", "with k"], ["proof (chain)\npicking this:\n  n = local.ord x * k\n  k = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  n = local.ord x * k\n  k = 1\n\ngoal (1 subgoal):\n 1. local.ord x = n", "by simp"], ["proof (state)\nthis:\n  local.ord x = n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in monoid) pow_nat_eq_1_imp_unit:\n  fixes n :: nat\n  assumes \"x [^] n = \\<one>\" and \"n > 0\" and [simp]: \"x \\<in> carrier G\"\n  shows   \"x \\<in> Units G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Units G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> Units G", "from \\<open>n > 0\\<close>"], ["proof (chain)\npicking this:\n  0 < n", "have \"x [^] (1 :: nat) \\<otimes> x [^] (n - 1) = x [^] n\""], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. x [^] 1 \\<otimes> x [^] (n - 1) = x [^] n", "by (subst nat_pow_mult) auto"], ["proof (state)\nthis:\n  x [^] 1 \\<otimes> x [^] (n - 1) = x [^] n\n\ngoal (1 subgoal):\n 1. x \\<in> Units G", "with assms"], ["proof (chain)\npicking this:\n  x [^] n = \\<one>\n  0 < n\n  x \\<in> carrier G\n  x [^] 1 \\<otimes> x [^] (n - 1) = x [^] n", "have \"x \\<otimes> x [^] (n - 1) = \\<one>\""], ["proof (prove)\nusing this:\n  x [^] n = \\<one>\n  0 < n\n  x \\<in> carrier G\n  x [^] 1 \\<otimes> x [^] (n - 1) = x [^] n\n\ngoal (1 subgoal):\n 1. x \\<otimes> x [^] (n - 1) = \\<one>", "by simp"], ["proof (state)\nthis:\n  x \\<otimes> x [^] (n - 1) = \\<one>\n\ngoal (1 subgoal):\n 1. x \\<in> Units G", "moreover"], ["proof (state)\nthis:\n  x \\<otimes> x [^] (n - 1) = \\<one>\n\ngoal (1 subgoal):\n 1. x \\<in> Units G", "from \\<open>n > 0\\<close>"], ["proof (chain)\npicking this:\n  0 < n", "have \"x [^] (n - 1) \\<otimes> x [^] (1 :: nat) = x [^] n\""], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. x [^] (n - 1) \\<otimes> x [^] 1 = x [^] n", "by (subst nat_pow_mult) auto"], ["proof (state)\nthis:\n  x [^] (n - 1) \\<otimes> x [^] 1 = x [^] n\n\ngoal (1 subgoal):\n 1. x \\<in> Units G", "with assms"], ["proof (chain)\npicking this:\n  x [^] n = \\<one>\n  0 < n\n  x \\<in> carrier G\n  x [^] (n - 1) \\<otimes> x [^] 1 = x [^] n", "have \"x [^] (n - 1) \\<otimes> x = \\<one>\""], ["proof (prove)\nusing this:\n  x [^] n = \\<one>\n  0 < n\n  x \\<in> carrier G\n  x [^] (n - 1) \\<otimes> x [^] 1 = x [^] n\n\ngoal (1 subgoal):\n 1. x [^] (n - 1) \\<otimes> x = \\<one>", "by simp"], ["proof (state)\nthis:\n  x [^] (n - 1) \\<otimes> x = \\<one>\n\ngoal (1 subgoal):\n 1. x \\<in> Units G", "ultimately"], ["proof (chain)\npicking this:\n  x \\<otimes> x [^] (n - 1) = \\<one>\n  x [^] (n - 1) \\<otimes> x = \\<one>", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<otimes> x [^] (n - 1) = \\<one>\n  x [^] (n - 1) \\<otimes> x = \\<one>\n\ngoal (1 subgoal):\n 1. x \\<in> Units G", "by (auto simp: Units_def)"], ["proof (state)\nthis:\n  x \\<in> Units G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in cring) finsum_reindex_bij_betw:\n  assumes \"bij_betw h S T\" \"g \\<in> T \\<rightarrow> carrier R\"\n  shows   \"finsum R (\\<lambda>x. g (h x)) S = finsum R g T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>x\\<in>S. g (h x)) = finsum R g T", "using assms"], ["proof (prove)\nusing this:\n  bij_betw h S T\n  g \\<in> T \\<rightarrow> carrier R\n\ngoal (1 subgoal):\n 1. (\\<Oplus>x\\<in>S. g (h x)) = finsum R g T", "by (auto simp: bij_betw_def finsum_reindex)"], ["", "lemma (in cring) finsum_reindex_bij_witness:\n  assumes witness:\n    \"\\<And>a. a \\<in> S \\<Longrightarrow> i (j a) = a\"\n    \"\\<And>a. a \\<in> S \\<Longrightarrow> j a \\<in> T\"\n    \"\\<And>b. b \\<in> T \\<Longrightarrow> j (i b) = b\"\n    \"\\<And>b. b \\<in> T \\<Longrightarrow> i b \\<in> S\"\n    \"\\<And>b. b \\<in> S \\<Longrightarrow> g b \\<in> carrier R\"\n  assumes eq:\n    \"\\<And>a. a \\<in> S \\<Longrightarrow> h (j a) = g a\"\n  shows \"finsum R g S = finsum R h T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finsum R g S = finsum R h T", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finsum R g S = finsum R h T", "have bij: \"bij_betw j S T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw j S T", "using bij_betw_byWitness[where A=S and f=j and f'=i and A'=T] witness"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>a\\<in>S. i (j a) = a; \\<forall>a'\\<in>T. j (i a') = a';\n   j ` S \\<subseteq> T; i ` T \\<subseteq> S\\<rbrakk>\n  \\<Longrightarrow> bij_betw j S T\n  ?a20 \\<in> S \\<Longrightarrow> i (j ?a20) = ?a20\n  ?a20 \\<in> S \\<Longrightarrow> j ?a20 \\<in> T\n  ?b20 \\<in> T \\<Longrightarrow> j (i ?b20) = ?b20\n  ?b20 \\<in> T \\<Longrightarrow> i ?b20 \\<in> S\n  ?b20 \\<in> S \\<Longrightarrow> g ?b20 \\<in> carrier R\n\ngoal (1 subgoal):\n 1. bij_betw j S T", "by auto"], ["proof (state)\nthis:\n  bij_betw j S T\n\ngoal (1 subgoal):\n 1. finsum R g S = finsum R h T", "hence T_eq: \"T = j ` S\""], ["proof (prove)\nusing this:\n  bij_betw j S T\n\ngoal (1 subgoal):\n 1. T = j ` S", "by (auto simp: bij_betw_def)"], ["proof (state)\nthis:\n  T = j ` S\n\ngoal (1 subgoal):\n 1. finsum R g S = finsum R h T", "from assms"], ["proof (chain)\npicking this:\n  ?a20 \\<in> S \\<Longrightarrow> i (j ?a20) = ?a20\n  ?a20 \\<in> S \\<Longrightarrow> j ?a20 \\<in> T\n  ?b20 \\<in> T \\<Longrightarrow> j (i ?b20) = ?b20\n  ?b20 \\<in> T \\<Longrightarrow> i ?b20 \\<in> S\n  ?b20 \\<in> S \\<Longrightarrow> g ?b20 \\<in> carrier R\n  ?a20 \\<in> S \\<Longrightarrow> h (j ?a20) = g ?a20", "have \"h \\<in> T \\<rightarrow> carrier R\""], ["proof (prove)\nusing this:\n  ?a20 \\<in> S \\<Longrightarrow> i (j ?a20) = ?a20\n  ?a20 \\<in> S \\<Longrightarrow> j ?a20 \\<in> T\n  ?b20 \\<in> T \\<Longrightarrow> j (i ?b20) = ?b20\n  ?b20 \\<in> T \\<Longrightarrow> i ?b20 \\<in> S\n  ?b20 \\<in> S \\<Longrightarrow> g ?b20 \\<in> carrier R\n  ?a20 \\<in> S \\<Longrightarrow> h (j ?a20) = g ?a20\n\ngoal (1 subgoal):\n 1. h \\<in> T \\<rightarrow> carrier R", "by (subst T_eq) auto"], ["proof (state)\nthis:\n  h \\<in> T \\<rightarrow> carrier R\n\ngoal (1 subgoal):\n 1. finsum R g S = finsum R h T", "moreover"], ["proof (state)\nthis:\n  h \\<in> T \\<rightarrow> carrier R\n\ngoal (1 subgoal):\n 1. finsum R g S = finsum R h T", "have \"finsum R g S = finsum R (\\<lambda>x. h (j x)) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finsum R g S = (\\<Oplus>x\\<in>S. h (j x))", "using assms"], ["proof (prove)\nusing this:\n  ?a20 \\<in> S \\<Longrightarrow> i (j ?a20) = ?a20\n  ?a20 \\<in> S \\<Longrightarrow> j ?a20 \\<in> T\n  ?b20 \\<in> T \\<Longrightarrow> j (i ?b20) = ?b20\n  ?b20 \\<in> T \\<Longrightarrow> i ?b20 \\<in> S\n  ?b20 \\<in> S \\<Longrightarrow> g ?b20 \\<in> carrier R\n  ?a20 \\<in> S \\<Longrightarrow> h (j ?a20) = g ?a20\n\ngoal (1 subgoal):\n 1. finsum R g S = (\\<Oplus>x\\<in>S. h (j x))", "by (intro finsum_cong) (auto simp: eq)"], ["proof (state)\nthis:\n  finsum R g S = (\\<Oplus>x\\<in>S. h (j x))\n\ngoal (1 subgoal):\n 1. finsum R g S = finsum R h T", "ultimately"], ["proof (chain)\npicking this:\n  h \\<in> T \\<rightarrow> carrier R\n  finsum R g S = (\\<Oplus>x\\<in>S. h (j x))", "show ?thesis"], ["proof (prove)\nusing this:\n  h \\<in> T \\<rightarrow> carrier R\n  finsum R g S = (\\<Oplus>x\\<in>S. h (j x))\n\ngoal (1 subgoal):\n 1. finsum R g S = finsum R h T", "using assms(5)"], ["proof (prove)\nusing this:\n  h \\<in> T \\<rightarrow> carrier R\n  finsum R g S = (\\<Oplus>x\\<in>S. h (j x))\n  ?b20 \\<in> S \\<Longrightarrow> g ?b20 \\<in> carrier R\n\ngoal (1 subgoal):\n 1. finsum R g S = finsum R h T", "using finsum_reindex_bij_betw[OF bij, of h]"], ["proof (prove)\nusing this:\n  h \\<in> T \\<rightarrow> carrier R\n  finsum R g S = (\\<Oplus>x\\<in>S. h (j x))\n  ?b20 \\<in> S \\<Longrightarrow> g ?b20 \\<in> carrier R\n  h \\<in> T \\<rightarrow> carrier R \\<Longrightarrow>\n  (\\<Oplus>x\\<in>S. h (j x)) = finsum R h T\n\ngoal (1 subgoal):\n 1. finsum R g S = finsum R h T", "by simp"], ["proof (state)\nthis:\n  finsum R g S = finsum R h T\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in cring) binomial:\n  fixes n :: nat\n  assumes [simp]: \"x \\<in> carrier R\" \"y \\<in> carrier R\"\n  shows   \"(x \\<oplus> y) [^] n = (\\<Oplus>i\\<in>{..n}. add_pow R (n choose i) (x [^] i \\<otimes> y [^] (n - i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<oplus> y) [^] n =\n    (\\<Oplus>i\\<in>{..n}. [(n choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (n - i)))", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. (x \\<oplus> y) [^] 0 =\n    (\\<Oplus>i\\<in>{..0}. [(0 choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (0 - i)))\n 2. \\<And>n.\n       (x \\<oplus> y) [^] n =\n       (\\<Oplus>i\\<in>{..n}. [(n choose\n                               i)] \\<cdot> (x [^] i \\<otimes>\n      y [^] (n - i))) \\<Longrightarrow>\n       (x \\<oplus> y) [^] Suc n =\n       (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                                   i)] \\<cdot> (x [^] i \\<otimes>\n          y [^] (Suc n - i)))", "case (Suc n)"], ["proof (state)\nthis:\n  (x \\<oplus> y) [^] n =\n  (\\<Oplus>i\\<in>{..n}. [(n choose\n                          i)] \\<cdot> (x [^] i \\<otimes> y [^] (n - i)))\n\ngoal (2 subgoals):\n 1. (x \\<oplus> y) [^] 0 =\n    (\\<Oplus>i\\<in>{..0}. [(0 choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (0 - i)))\n 2. \\<And>n.\n       (x \\<oplus> y) [^] n =\n       (\\<Oplus>i\\<in>{..n}. [(n choose\n                               i)] \\<cdot> (x [^] i \\<otimes>\n      y [^] (n - i))) \\<Longrightarrow>\n       (x \\<oplus> y) [^] Suc n =\n       (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                                   i)] \\<cdot> (x [^] i \\<otimes>\n          y [^] (Suc n - i)))", "have binomial_Suc: \"Suc n choose i = (n choose (i - 1)) + (n choose i)\" if \"i \\<in> {1..n}\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc n choose i = n choose (i - 1) + (n choose i)", "using that"], ["proof (prove)\nusing this:\n  i \\<in> {1..n}\n\ngoal (1 subgoal):\n 1. Suc n choose i = n choose (i - 1) + (n choose i)", "by (cases i) auto"], ["proof (state)\nthis:\n  ?i20 \\<in> {1..n} \\<Longrightarrow>\n  Suc n choose ?i20 = n choose (?i20 - 1) + (n choose ?i20)\n\ngoal (2 subgoals):\n 1. (x \\<oplus> y) [^] 0 =\n    (\\<Oplus>i\\<in>{..0}. [(0 choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (0 - i)))\n 2. \\<And>n.\n       (x \\<oplus> y) [^] n =\n       (\\<Oplus>i\\<in>{..n}. [(n choose\n                               i)] \\<cdot> (x [^] i \\<otimes>\n      y [^] (n - i))) \\<Longrightarrow>\n       (x \\<oplus> y) [^] Suc n =\n       (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                                   i)] \\<cdot> (x [^] i \\<otimes>\n          y [^] (Suc n - i)))", "have Suc_diff: \"Suc n - i = Suc (n - i)\" if \"i \\<le> n\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc n - i = Suc (n - i)", "using that"], ["proof (prove)\nusing this:\n  i \\<le> n\n\ngoal (1 subgoal):\n 1. Suc n - i = Suc (n - i)", "by linarith"], ["proof (state)\nthis:\n  ?i20 \\<le> n \\<Longrightarrow> Suc n - ?i20 = Suc (n - ?i20)\n\ngoal (2 subgoals):\n 1. (x \\<oplus> y) [^] 0 =\n    (\\<Oplus>i\\<in>{..0}. [(0 choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (0 - i)))\n 2. \\<And>n.\n       (x \\<oplus> y) [^] n =\n       (\\<Oplus>i\\<in>{..n}. [(n choose\n                               i)] \\<cdot> (x [^] i \\<otimes>\n      y [^] (n - i))) \\<Longrightarrow>\n       (x \\<oplus> y) [^] Suc n =\n       (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                                   i)] \\<cdot> (x [^] i \\<otimes>\n          y [^] (Suc n - i)))", "have \"(x \\<oplus> y) [^] Suc n =\n          (\\<Oplus>i\\<in>{..n}. add_pow R (n choose i) (x [^] i \\<otimes> y [^] (n - i))) \\<otimes> x \\<oplus>\n          (\\<Oplus>i\\<in>{..n}. add_pow R (n choose i) (x [^] i \\<otimes> y [^] (n - i))) \\<otimes> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<oplus> y) [^] Suc n =\n    (\\<Oplus>i\\<in>{..n}. [(n choose\n                            i)] \\<cdot> (x [^] i \\<otimes>\n   y [^] (n - i))) \\<otimes>\n    x \\<oplus>\n    (\\<Oplus>i\\<in>{..n}. [(n choose\n                            i)] \\<cdot> (x [^] i \\<otimes>\n   y [^] (n - i))) \\<otimes>\n    y", "by (simp add: semiring_simprules Suc)"], ["proof (state)\nthis:\n  (x \\<oplus> y) [^] Suc n =\n  (\\<Oplus>i\\<in>{..n}. [(n choose\n                          i)] \\<cdot> (x [^] i \\<otimes>\n y [^] (n - i))) \\<otimes>\n  x \\<oplus>\n  (\\<Oplus>i\\<in>{..n}. [(n choose\n                          i)] \\<cdot> (x [^] i \\<otimes>\n y [^] (n - i))) \\<otimes>\n  y\n\ngoal (2 subgoals):\n 1. (x \\<oplus> y) [^] 0 =\n    (\\<Oplus>i\\<in>{..0}. [(0 choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (0 - i)))\n 2. \\<And>n.\n       (x \\<oplus> y) [^] n =\n       (\\<Oplus>i\\<in>{..n}. [(n choose\n                               i)] \\<cdot> (x [^] i \\<otimes>\n      y [^] (n - i))) \\<Longrightarrow>\n       (x \\<oplus> y) [^] Suc n =\n       (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                                   i)] \\<cdot> (x [^] i \\<otimes>\n          y [^] (Suc n - i)))", "also"], ["proof (state)\nthis:\n  (x \\<oplus> y) [^] Suc n =\n  (\\<Oplus>i\\<in>{..n}. [(n choose\n                          i)] \\<cdot> (x [^] i \\<otimes>\n y [^] (n - i))) \\<otimes>\n  x \\<oplus>\n  (\\<Oplus>i\\<in>{..n}. [(n choose\n                          i)] \\<cdot> (x [^] i \\<otimes>\n y [^] (n - i))) \\<otimes>\n  y\n\ngoal (2 subgoals):\n 1. (x \\<oplus> y) [^] 0 =\n    (\\<Oplus>i\\<in>{..0}. [(0 choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (0 - i)))\n 2. \\<And>n.\n       (x \\<oplus> y) [^] n =\n       (\\<Oplus>i\\<in>{..n}. [(n choose\n                               i)] \\<cdot> (x [^] i \\<otimes>\n      y [^] (n - i))) \\<Longrightarrow>\n       (x \\<oplus> y) [^] Suc n =\n       (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                                   i)] \\<cdot> (x [^] i \\<otimes>\n          y [^] (Suc n - i)))", "have \"(\\<Oplus>i\\<in>{..n}. add_pow R (n choose i) (x [^] i \\<otimes> y [^] (n - i))) \\<otimes> x =\n             (\\<Oplus>i\\<in>{..n}. add_pow R (n choose i) (x [^] Suc i \\<otimes> y [^] (n - i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>i\\<in>{..n}. [(n choose\n                            i)] \\<cdot> (x [^] i \\<otimes>\n   y [^] (n - i))) \\<otimes>\n    x =\n    (\\<Oplus>i\\<in>{..n}. [(n choose\n                            i)] \\<cdot> (x [^] Suc i \\<otimes>\n   y [^] (n - i)))", "by (subst finsum_ldistr)\n       (auto simp: cring_simprules Suc add_pow_rdistr intro!: finsum_cong)"], ["proof (state)\nthis:\n  (\\<Oplus>i\\<in>{..n}. [(n choose\n                          i)] \\<cdot> (x [^] i \\<otimes>\n y [^] (n - i))) \\<otimes>\n  x =\n  (\\<Oplus>i\\<in>{..n}. [(n choose\n                          i)] \\<cdot> (x [^] Suc i \\<otimes> y [^] (n - i)))\n\ngoal (2 subgoals):\n 1. (x \\<oplus> y) [^] 0 =\n    (\\<Oplus>i\\<in>{..0}. [(0 choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (0 - i)))\n 2. \\<And>n.\n       (x \\<oplus> y) [^] n =\n       (\\<Oplus>i\\<in>{..n}. [(n choose\n                               i)] \\<cdot> (x [^] i \\<otimes>\n      y [^] (n - i))) \\<Longrightarrow>\n       (x \\<oplus> y) [^] Suc n =\n       (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                                   i)] \\<cdot> (x [^] i \\<otimes>\n          y [^] (Suc n - i)))", "also"], ["proof (state)\nthis:\n  (\\<Oplus>i\\<in>{..n}. [(n choose\n                          i)] \\<cdot> (x [^] i \\<otimes>\n y [^] (n - i))) \\<otimes>\n  x =\n  (\\<Oplus>i\\<in>{..n}. [(n choose\n                          i)] \\<cdot> (x [^] Suc i \\<otimes> y [^] (n - i)))\n\ngoal (2 subgoals):\n 1. (x \\<oplus> y) [^] 0 =\n    (\\<Oplus>i\\<in>{..0}. [(0 choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (0 - i)))\n 2. \\<And>n.\n       (x \\<oplus> y) [^] n =\n       (\\<Oplus>i\\<in>{..n}. [(n choose\n                               i)] \\<cdot> (x [^] i \\<otimes>\n      y [^] (n - i))) \\<Longrightarrow>\n       (x \\<oplus> y) [^] Suc n =\n       (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                                   i)] \\<cdot> (x [^] i \\<otimes>\n          y [^] (Suc n - i)))", "have \"\\<dots> = (\\<Oplus>i\\<in>{1..Suc n}. add_pow R (n choose (i - 1)) (x [^] i \\<otimes> y [^] (Suc n - i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>i\\<in>{..n}. [(n choose\n                            i)] \\<cdot> (x [^] Suc i \\<otimes>\n   y [^] (n - i))) =\n    (\\<Oplus>i\\<in>{1..Suc n}. [(n choose\n                                 (i -\n                                  1))] \\<cdot> (x [^] i \\<otimes>\n          y [^] (Suc n - i)))", "by (intro finsum_reindex_bij_witness[of _ \"\\<lambda>i. i - 1\" Suc]) auto"], ["proof (state)\nthis:\n  (\\<Oplus>i\\<in>{..n}. [(n choose\n                          i)] \\<cdot> (x [^] Suc i \\<otimes>\n y [^] (n - i))) =\n  (\\<Oplus>i\\<in>{1..Suc n}. [(n choose\n                               (i -\n                                1))] \\<cdot> (x [^] i \\<otimes>\n        y [^] (Suc n - i)))\n\ngoal (2 subgoals):\n 1. (x \\<oplus> y) [^] 0 =\n    (\\<Oplus>i\\<in>{..0}. [(0 choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (0 - i)))\n 2. \\<And>n.\n       (x \\<oplus> y) [^] n =\n       (\\<Oplus>i\\<in>{..n}. [(n choose\n                               i)] \\<cdot> (x [^] i \\<otimes>\n      y [^] (n - i))) \\<Longrightarrow>\n       (x \\<oplus> y) [^] Suc n =\n       (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                                   i)] \\<cdot> (x [^] i \\<otimes>\n          y [^] (Suc n - i)))", "also"], ["proof (state)\nthis:\n  (\\<Oplus>i\\<in>{..n}. [(n choose\n                          i)] \\<cdot> (x [^] Suc i \\<otimes>\n y [^] (n - i))) =\n  (\\<Oplus>i\\<in>{1..Suc n}. [(n choose\n                               (i -\n                                1))] \\<cdot> (x [^] i \\<otimes>\n        y [^] (Suc n - i)))\n\ngoal (2 subgoals):\n 1. (x \\<oplus> y) [^] 0 =\n    (\\<Oplus>i\\<in>{..0}. [(0 choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (0 - i)))\n 2. \\<And>n.\n       (x \\<oplus> y) [^] n =\n       (\\<Oplus>i\\<in>{..n}. [(n choose\n                               i)] \\<cdot> (x [^] i \\<otimes>\n      y [^] (n - i))) \\<Longrightarrow>\n       (x \\<oplus> y) [^] Suc n =\n       (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                                   i)] \\<cdot> (x [^] i \\<otimes>\n          y [^] (Suc n - i)))", "have \"{1..Suc n} = insert (Suc n) {1..n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {1..Suc n} = insert (Suc n) {1..n}", "by auto"], ["proof (state)\nthis:\n  {1..Suc n} = insert (Suc n) {1..n}\n\ngoal (2 subgoals):\n 1. (x \\<oplus> y) [^] 0 =\n    (\\<Oplus>i\\<in>{..0}. [(0 choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (0 - i)))\n 2. \\<And>n.\n       (x \\<oplus> y) [^] n =\n       (\\<Oplus>i\\<in>{..n}. [(n choose\n                               i)] \\<cdot> (x [^] i \\<otimes>\n      y [^] (n - i))) \\<Longrightarrow>\n       (x \\<oplus> y) [^] Suc n =\n       (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                                   i)] \\<cdot> (x [^] i \\<otimes>\n          y [^] (Suc n - i)))", "also"], ["proof (state)\nthis:\n  {1..Suc n} = insert (Suc n) {1..n}\n\ngoal (2 subgoals):\n 1. (x \\<oplus> y) [^] 0 =\n    (\\<Oplus>i\\<in>{..0}. [(0 choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (0 - i)))\n 2. \\<And>n.\n       (x \\<oplus> y) [^] n =\n       (\\<Oplus>i\\<in>{..n}. [(n choose\n                               i)] \\<cdot> (x [^] i \\<otimes>\n      y [^] (n - i))) \\<Longrightarrow>\n       (x \\<oplus> y) [^] Suc n =\n       (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                                   i)] \\<cdot> (x [^] i \\<otimes>\n          y [^] (Suc n - i)))", "have \"(\\<Oplus>i\\<in>\\<dots>. add_pow R (n choose (i - 1)) (x [^] i \\<otimes> y [^] (Suc n - i))) =\n             x [^] Suc n \\<oplus> (\\<Oplus>i\\<in>{1..n}. add_pow R (n choose (i - 1)) (x [^] i \\<otimes> y [^] (Suc n - i)))\"\n    (is \"_ = _ \\<oplus> ?S1\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>i\\<in>insert (Suc n)\n                    {1..n}. [(n choose\n                              (i -\n                               1))] \\<cdot> (x [^] i \\<otimes>\n       y [^] (Suc n - i))) =\n    x [^] Suc n \\<oplus>\n    (\\<Oplus>i\\<in>{1..n}. [(n choose\n                             (i -\n                              1))] \\<cdot> (x [^] i \\<otimes>\n      y [^] (Suc n - i)))", "by (subst finsum_insert) auto"], ["proof (state)\nthis:\n  (\\<Oplus>i\\<in>insert (Suc n)\n                  {1..n}. [(n choose\n                            (i -\n                             1))] \\<cdot> (x [^] i \\<otimes>\n     y [^] (Suc n - i))) =\n  x [^] Suc n \\<oplus>\n  (\\<Oplus>i\\<in>{1..n}. [(n choose\n                           (i -\n                            1))] \\<cdot> (x [^] i \\<otimes>\n    y [^] (Suc n - i)))\n\ngoal (2 subgoals):\n 1. (x \\<oplus> y) [^] 0 =\n    (\\<Oplus>i\\<in>{..0}. [(0 choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (0 - i)))\n 2. \\<And>n.\n       (x \\<oplus> y) [^] n =\n       (\\<Oplus>i\\<in>{..n}. [(n choose\n                               i)] \\<cdot> (x [^] i \\<otimes>\n      y [^] (n - i))) \\<Longrightarrow>\n       (x \\<oplus> y) [^] Suc n =\n       (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                                   i)] \\<cdot> (x [^] i \\<otimes>\n          y [^] (Suc n - i)))", "also"], ["proof (state)\nthis:\n  (\\<Oplus>i\\<in>insert (Suc n)\n                  {1..n}. [(n choose\n                            (i -\n                             1))] \\<cdot> (x [^] i \\<otimes>\n     y [^] (Suc n - i))) =\n  x [^] Suc n \\<oplus>\n  (\\<Oplus>i\\<in>{1..n}. [(n choose\n                           (i -\n                            1))] \\<cdot> (x [^] i \\<otimes>\n    y [^] (Suc n - i)))\n\ngoal (2 subgoals):\n 1. (x \\<oplus> y) [^] 0 =\n    (\\<Oplus>i\\<in>{..0}. [(0 choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (0 - i)))\n 2. \\<And>n.\n       (x \\<oplus> y) [^] n =\n       (\\<Oplus>i\\<in>{..n}. [(n choose\n                               i)] \\<cdot> (x [^] i \\<otimes>\n      y [^] (n - i))) \\<Longrightarrow>\n       (x \\<oplus> y) [^] Suc n =\n       (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                                   i)] \\<cdot> (x [^] i \\<otimes>\n          y [^] (Suc n - i)))", "have \"(\\<Oplus>i\\<in>{..n}. add_pow R (n choose i) (x [^] i \\<otimes> y [^] (n - i))) \\<otimes> y =\n             (\\<Oplus>i\\<in>{..n}. add_pow R (n choose i) (x [^] i \\<otimes> y [^] (Suc n - i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>i\\<in>{..n}. [(n choose\n                            i)] \\<cdot> (x [^] i \\<otimes>\n   y [^] (n - i))) \\<otimes>\n    y =\n    (\\<Oplus>i\\<in>{..n}. [(n choose\n                            i)] \\<cdot> (x [^] i \\<otimes>\n   y [^] (Suc n - i)))", "by (subst finsum_ldistr)\n       (auto simp: cring_simprules Suc add_pow_rdistr Suc_diff intro!: finsum_cong)"], ["proof (state)\nthis:\n  (\\<Oplus>i\\<in>{..n}. [(n choose\n                          i)] \\<cdot> (x [^] i \\<otimes>\n y [^] (n - i))) \\<otimes>\n  y =\n  (\\<Oplus>i\\<in>{..n}. [(n choose\n                          i)] \\<cdot> (x [^] i \\<otimes> y [^] (Suc n - i)))\n\ngoal (2 subgoals):\n 1. (x \\<oplus> y) [^] 0 =\n    (\\<Oplus>i\\<in>{..0}. [(0 choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (0 - i)))\n 2. \\<And>n.\n       (x \\<oplus> y) [^] n =\n       (\\<Oplus>i\\<in>{..n}. [(n choose\n                               i)] \\<cdot> (x [^] i \\<otimes>\n      y [^] (n - i))) \\<Longrightarrow>\n       (x \\<oplus> y) [^] Suc n =\n       (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                                   i)] \\<cdot> (x [^] i \\<otimes>\n          y [^] (Suc n - i)))", "also"], ["proof (state)\nthis:\n  (\\<Oplus>i\\<in>{..n}. [(n choose\n                          i)] \\<cdot> (x [^] i \\<otimes>\n y [^] (n - i))) \\<otimes>\n  y =\n  (\\<Oplus>i\\<in>{..n}. [(n choose\n                          i)] \\<cdot> (x [^] i \\<otimes> y [^] (Suc n - i)))\n\ngoal (2 subgoals):\n 1. (x \\<oplus> y) [^] 0 =\n    (\\<Oplus>i\\<in>{..0}. [(0 choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (0 - i)))\n 2. \\<And>n.\n       (x \\<oplus> y) [^] n =\n       (\\<Oplus>i\\<in>{..n}. [(n choose\n                               i)] \\<cdot> (x [^] i \\<otimes>\n      y [^] (n - i))) \\<Longrightarrow>\n       (x \\<oplus> y) [^] Suc n =\n       (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                                   i)] \\<cdot> (x [^] i \\<otimes>\n          y [^] (Suc n - i)))", "have \"{..n} = insert 0 {1..n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..n} = insert 0 {1..n}", "by auto"], ["proof (state)\nthis:\n  {..n} = insert 0 {1..n}\n\ngoal (2 subgoals):\n 1. (x \\<oplus> y) [^] 0 =\n    (\\<Oplus>i\\<in>{..0}. [(0 choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (0 - i)))\n 2. \\<And>n.\n       (x \\<oplus> y) [^] n =\n       (\\<Oplus>i\\<in>{..n}. [(n choose\n                               i)] \\<cdot> (x [^] i \\<otimes>\n      y [^] (n - i))) \\<Longrightarrow>\n       (x \\<oplus> y) [^] Suc n =\n       (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                                   i)] \\<cdot> (x [^] i \\<otimes>\n          y [^] (Suc n - i)))", "also"], ["proof (state)\nthis:\n  {..n} = insert 0 {1..n}\n\ngoal (2 subgoals):\n 1. (x \\<oplus> y) [^] 0 =\n    (\\<Oplus>i\\<in>{..0}. [(0 choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (0 - i)))\n 2. \\<And>n.\n       (x \\<oplus> y) [^] n =\n       (\\<Oplus>i\\<in>{..n}. [(n choose\n                               i)] \\<cdot> (x [^] i \\<otimes>\n      y [^] (n - i))) \\<Longrightarrow>\n       (x \\<oplus> y) [^] Suc n =\n       (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                                   i)] \\<cdot> (x [^] i \\<otimes>\n          y [^] (Suc n - i)))", "have \"(\\<Oplus>i\\<in>\\<dots>. add_pow R (n choose i) (x [^] i \\<otimes> y [^] (Suc n - i))) =\n             y [^] Suc n \\<oplus> (\\<Oplus>i\\<in>{1..n}. add_pow R (n choose i) (x [^] i \\<otimes> y [^] (Suc n - i)))\"\n    (is \"_ = _ \\<oplus> ?S2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>i\\<in>insert 0\n                    {1..n}. [(n choose\n                              i)] \\<cdot> (x [^] i \\<otimes>\n     y [^] (Suc n - i))) =\n    y [^] Suc n \\<oplus>\n    (\\<Oplus>i\\<in>{1..n}. [(n choose\n                             i)] \\<cdot> (x [^] i \\<otimes>\n    y [^] (Suc n - i)))", "by (subst finsum_insert) auto"], ["proof (state)\nthis:\n  (\\<Oplus>i\\<in>insert 0\n                  {1..n}. [(n choose\n                            i)] \\<cdot> (x [^] i \\<otimes>\n   y [^] (Suc n - i))) =\n  y [^] Suc n \\<oplus>\n  (\\<Oplus>i\\<in>{1..n}. [(n choose\n                           i)] \\<cdot> (x [^] i \\<otimes>\n  y [^] (Suc n - i)))\n\ngoal (2 subgoals):\n 1. (x \\<oplus> y) [^] 0 =\n    (\\<Oplus>i\\<in>{..0}. [(0 choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (0 - i)))\n 2. \\<And>n.\n       (x \\<oplus> y) [^] n =\n       (\\<Oplus>i\\<in>{..n}. [(n choose\n                               i)] \\<cdot> (x [^] i \\<otimes>\n      y [^] (n - i))) \\<Longrightarrow>\n       (x \\<oplus> y) [^] Suc n =\n       (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                                   i)] \\<cdot> (x [^] i \\<otimes>\n          y [^] (Suc n - i)))", "also"], ["proof (state)\nthis:\n  (\\<Oplus>i\\<in>insert 0\n                  {1..n}. [(n choose\n                            i)] \\<cdot> (x [^] i \\<otimes>\n   y [^] (Suc n - i))) =\n  y [^] Suc n \\<oplus>\n  (\\<Oplus>i\\<in>{1..n}. [(n choose\n                           i)] \\<cdot> (x [^] i \\<otimes>\n  y [^] (Suc n - i)))\n\ngoal (2 subgoals):\n 1. (x \\<oplus> y) [^] 0 =\n    (\\<Oplus>i\\<in>{..0}. [(0 choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (0 - i)))\n 2. \\<And>n.\n       (x \\<oplus> y) [^] n =\n       (\\<Oplus>i\\<in>{..n}. [(n choose\n                               i)] \\<cdot> (x [^] i \\<otimes>\n      y [^] (n - i))) \\<Longrightarrow>\n       (x \\<oplus> y) [^] Suc n =\n       (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                                   i)] \\<cdot> (x [^] i \\<otimes>\n          y [^] (Suc n - i)))", "have \"(x [^] Suc n \\<oplus> ?S1) \\<oplus> (y [^] Suc n \\<oplus> ?S2) =\n               x [^] Suc n \\<oplus> y [^] Suc n \\<oplus> (?S1 \\<oplus> ?S2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x [^] Suc n \\<oplus>\n    (\\<Oplus>i\\<in>{1..n}. [(n choose\n                             (i -\n                              1))] \\<cdot> (x [^] i \\<otimes>\n      y [^] (Suc n - i))) \\<oplus>\n    (y [^] Suc n \\<oplus>\n     (\\<Oplus>i\\<in>{1..n}. [(n choose\n                              i)] \\<cdot> (x [^] i \\<otimes>\n     y [^] (Suc n - i)))) =\n    x [^] Suc n \\<oplus> y [^] Suc n \\<oplus>\n    ((\\<Oplus>i\\<in>{1..n}. [(n choose\n                              (i -\n                               1))] \\<cdot> (x [^] i \\<otimes>\n       y [^] (Suc n - i))) \\<oplus>\n     (\\<Oplus>i\\<in>{1..n}. [(n choose\n                              i)] \\<cdot> (x [^] i \\<otimes>\n     y [^] (Suc n - i))))", "by (simp add: cring_simprules)"], ["proof (state)\nthis:\n  x [^] Suc n \\<oplus>\n  (\\<Oplus>i\\<in>{1..n}. [(n choose\n                           (i -\n                            1))] \\<cdot> (x [^] i \\<otimes>\n    y [^] (Suc n - i))) \\<oplus>\n  (y [^] Suc n \\<oplus>\n   (\\<Oplus>i\\<in>{1..n}. [(n choose\n                            i)] \\<cdot> (x [^] i \\<otimes>\n   y [^] (Suc n - i)))) =\n  x [^] Suc n \\<oplus> y [^] Suc n \\<oplus>\n  ((\\<Oplus>i\\<in>{1..n}. [(n choose\n                            (i -\n                             1))] \\<cdot> (x [^] i \\<otimes>\n     y [^] (Suc n - i))) \\<oplus>\n   (\\<Oplus>i\\<in>{1..n}. [(n choose\n                            i)] \\<cdot> (x [^] i \\<otimes>\n   y [^] (Suc n - i))))\n\ngoal (2 subgoals):\n 1. (x \\<oplus> y) [^] 0 =\n    (\\<Oplus>i\\<in>{..0}. [(0 choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (0 - i)))\n 2. \\<And>n.\n       (x \\<oplus> y) [^] n =\n       (\\<Oplus>i\\<in>{..n}. [(n choose\n                               i)] \\<cdot> (x [^] i \\<otimes>\n      y [^] (n - i))) \\<Longrightarrow>\n       (x \\<oplus> y) [^] Suc n =\n       (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                                   i)] \\<cdot> (x [^] i \\<otimes>\n          y [^] (Suc n - i)))", "also"], ["proof (state)\nthis:\n  x [^] Suc n \\<oplus>\n  (\\<Oplus>i\\<in>{1..n}. [(n choose\n                           (i -\n                            1))] \\<cdot> (x [^] i \\<otimes>\n    y [^] (Suc n - i))) \\<oplus>\n  (y [^] Suc n \\<oplus>\n   (\\<Oplus>i\\<in>{1..n}. [(n choose\n                            i)] \\<cdot> (x [^] i \\<otimes>\n   y [^] (Suc n - i)))) =\n  x [^] Suc n \\<oplus> y [^] Suc n \\<oplus>\n  ((\\<Oplus>i\\<in>{1..n}. [(n choose\n                            (i -\n                             1))] \\<cdot> (x [^] i \\<otimes>\n     y [^] (Suc n - i))) \\<oplus>\n   (\\<Oplus>i\\<in>{1..n}. [(n choose\n                            i)] \\<cdot> (x [^] i \\<otimes>\n   y [^] (Suc n - i))))\n\ngoal (2 subgoals):\n 1. (x \\<oplus> y) [^] 0 =\n    (\\<Oplus>i\\<in>{..0}. [(0 choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (0 - i)))\n 2. \\<And>n.\n       (x \\<oplus> y) [^] n =\n       (\\<Oplus>i\\<in>{..n}. [(n choose\n                               i)] \\<cdot> (x [^] i \\<otimes>\n      y [^] (n - i))) \\<Longrightarrow>\n       (x \\<oplus> y) [^] Suc n =\n       (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                                   i)] \\<cdot> (x [^] i \\<otimes>\n          y [^] (Suc n - i)))", "have \"?S1 \\<oplus> ?S2 = (\\<Oplus>i\\<in>{1..n}. add_pow R (Suc n choose i) (x [^] i \\<otimes> y [^] (Suc n - i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>i\\<in>{1..n}. [(n choose\n                             (i -\n                              1))] \\<cdot> (x [^] i \\<otimes>\n      y [^] (Suc n - i))) \\<oplus>\n    (\\<Oplus>i\\<in>{1..n}. [(n choose\n                             i)] \\<cdot> (x [^] i \\<otimes>\n    y [^] (Suc n - i))) =\n    (\\<Oplus>i\\<in>{1..n}. [(Suc n choose\n                             i)] \\<cdot> (x [^] i \\<otimes>\n    y [^] (Suc n - i)))", "by (subst finsum_addf [symmetric], simp, simp, rule finsum_cong')\n       (auto intro!: finsum_cong simp: binomial_Suc add.nat_pow_mult)"], ["proof (state)\nthis:\n  (\\<Oplus>i\\<in>{1..n}. [(n choose\n                           (i -\n                            1))] \\<cdot> (x [^] i \\<otimes>\n    y [^] (Suc n - i))) \\<oplus>\n  (\\<Oplus>i\\<in>{1..n}. [(n choose\n                           i)] \\<cdot> (x [^] i \\<otimes>\n  y [^] (Suc n - i))) =\n  (\\<Oplus>i\\<in>{1..n}. [(Suc n choose\n                           i)] \\<cdot> (x [^] i \\<otimes>\n  y [^] (Suc n - i)))\n\ngoal (2 subgoals):\n 1. (x \\<oplus> y) [^] 0 =\n    (\\<Oplus>i\\<in>{..0}. [(0 choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (0 - i)))\n 2. \\<And>n.\n       (x \\<oplus> y) [^] n =\n       (\\<Oplus>i\\<in>{..n}. [(n choose\n                               i)] \\<cdot> (x [^] i \\<otimes>\n      y [^] (n - i))) \\<Longrightarrow>\n       (x \\<oplus> y) [^] Suc n =\n       (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                                   i)] \\<cdot> (x [^] i \\<otimes>\n          y [^] (Suc n - i)))", "also"], ["proof (state)\nthis:\n  (\\<Oplus>i\\<in>{1..n}. [(n choose\n                           (i -\n                            1))] \\<cdot> (x [^] i \\<otimes>\n    y [^] (Suc n - i))) \\<oplus>\n  (\\<Oplus>i\\<in>{1..n}. [(n choose\n                           i)] \\<cdot> (x [^] i \\<otimes>\n  y [^] (Suc n - i))) =\n  (\\<Oplus>i\\<in>{1..n}. [(Suc n choose\n                           i)] \\<cdot> (x [^] i \\<otimes>\n  y [^] (Suc n - i)))\n\ngoal (2 subgoals):\n 1. (x \\<oplus> y) [^] 0 =\n    (\\<Oplus>i\\<in>{..0}. [(0 choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (0 - i)))\n 2. \\<And>n.\n       (x \\<oplus> y) [^] n =\n       (\\<Oplus>i\\<in>{..n}. [(n choose\n                               i)] \\<cdot> (x [^] i \\<otimes>\n      y [^] (n - i))) \\<Longrightarrow>\n       (x \\<oplus> y) [^] Suc n =\n       (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                                   i)] \\<cdot> (x [^] i \\<otimes>\n          y [^] (Suc n - i)))", "have \"x [^] Suc n \\<oplus> y [^] Suc n \\<oplus> \\<dots> =\n               (\\<Oplus>i\\<in>{0, Suc n} \\<union> {1..n}. add_pow R (Suc n choose i) (x [^] i \\<otimes> y [^] (Suc n - i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x [^] Suc n \\<oplus> y [^] Suc n \\<oplus>\n    (\\<Oplus>i\\<in>{1..n}. [(Suc n choose\n                             i)] \\<cdot> (x [^] i \\<otimes>\n    y [^] (Suc n - i))) =\n    (\\<Oplus>i\\<in>{0, Suc n} \\<union>\n                   {1..n}. [(Suc n choose\n                             i)] \\<cdot> (x [^] i \\<otimes>\n    y [^] (Suc n - i)))", "by (subst finsum_Un_disjoint) (auto simp: cring_simprules)"], ["proof (state)\nthis:\n  x [^] Suc n \\<oplus> y [^] Suc n \\<oplus>\n  (\\<Oplus>i\\<in>{1..n}. [(Suc n choose\n                           i)] \\<cdot> (x [^] i \\<otimes>\n  y [^] (Suc n - i))) =\n  (\\<Oplus>i\\<in>{0, Suc n} \\<union>\n                 {1..n}. [(Suc n choose\n                           i)] \\<cdot> (x [^] i \\<otimes>\n  y [^] (Suc n - i)))\n\ngoal (2 subgoals):\n 1. (x \\<oplus> y) [^] 0 =\n    (\\<Oplus>i\\<in>{..0}. [(0 choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (0 - i)))\n 2. \\<And>n.\n       (x \\<oplus> y) [^] n =\n       (\\<Oplus>i\\<in>{..n}. [(n choose\n                               i)] \\<cdot> (x [^] i \\<otimes>\n      y [^] (n - i))) \\<Longrightarrow>\n       (x \\<oplus> y) [^] Suc n =\n       (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                                   i)] \\<cdot> (x [^] i \\<otimes>\n          y [^] (Suc n - i)))", "also"], ["proof (state)\nthis:\n  x [^] Suc n \\<oplus> y [^] Suc n \\<oplus>\n  (\\<Oplus>i\\<in>{1..n}. [(Suc n choose\n                           i)] \\<cdot> (x [^] i \\<otimes>\n  y [^] (Suc n - i))) =\n  (\\<Oplus>i\\<in>{0, Suc n} \\<union>\n                 {1..n}. [(Suc n choose\n                           i)] \\<cdot> (x [^] i \\<otimes>\n  y [^] (Suc n - i)))\n\ngoal (2 subgoals):\n 1. (x \\<oplus> y) [^] 0 =\n    (\\<Oplus>i\\<in>{..0}. [(0 choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (0 - i)))\n 2. \\<And>n.\n       (x \\<oplus> y) [^] n =\n       (\\<Oplus>i\\<in>{..n}. [(n choose\n                               i)] \\<cdot> (x [^] i \\<otimes>\n      y [^] (n - i))) \\<Longrightarrow>\n       (x \\<oplus> y) [^] Suc n =\n       (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                                   i)] \\<cdot> (x [^] i \\<otimes>\n          y [^] (Suc n - i)))", "have \"{0, Suc n} \\<union> {1..n} = {..Suc n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0, Suc n} \\<union> {1..n} = {..Suc n}", "by auto"], ["proof (state)\nthis:\n  {0, Suc n} \\<union> {1..n} = {..Suc n}\n\ngoal (2 subgoals):\n 1. (x \\<oplus> y) [^] 0 =\n    (\\<Oplus>i\\<in>{..0}. [(0 choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (0 - i)))\n 2. \\<And>n.\n       (x \\<oplus> y) [^] n =\n       (\\<Oplus>i\\<in>{..n}. [(n choose\n                               i)] \\<cdot> (x [^] i \\<otimes>\n      y [^] (n - i))) \\<Longrightarrow>\n       (x \\<oplus> y) [^] Suc n =\n       (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                                   i)] \\<cdot> (x [^] i \\<otimes>\n          y [^] (Suc n - i)))", "finally"], ["proof (chain)\npicking this:\n  (x \\<oplus> y) [^] Suc n =\n  (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                              i)] \\<cdot> (x [^] i \\<otimes>\n     y [^] (Suc n - i)))", "show ?case"], ["proof (prove)\nusing this:\n  (x \\<oplus> y) [^] Suc n =\n  (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                              i)] \\<cdot> (x [^] i \\<otimes>\n     y [^] (Suc n - i)))\n\ngoal (1 subgoal):\n 1. (x \\<oplus> y) [^] Suc n =\n    (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                                i)] \\<cdot> (x [^] i \\<otimes>\n       y [^] (Suc n - i)))", "."], ["proof (state)\nthis:\n  (x \\<oplus> y) [^] Suc n =\n  (\\<Oplus>i\\<in>{..Suc n}. [(Suc n choose\n                              i)] \\<cdot> (x [^] i \\<otimes>\n     y [^] (Suc n - i)))\n\ngoal (1 subgoal):\n 1. (x \\<oplus> y) [^] 0 =\n    (\\<Oplus>i\\<in>{..0}. [(0 choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (0 - i)))", "qed auto"], ["", "lemma (in cring) binomial_finite_char:\n  fixes p :: nat\n  assumes [simp]: \"x \\<in> carrier R\" \"y \\<in> carrier R\" and \"add_pow R p \\<one> = \\<zero>\" \"prime p\"\n  shows   \"(x \\<oplus> y) [^] p = x [^] p \\<oplus> y [^] p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<oplus> y) [^] p = x [^] p \\<oplus> y [^] p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x \\<oplus> y) [^] p = x [^] p \\<oplus> y [^] p", "have *: \"add_pow R (p choose i) (x [^] i \\<otimes> y [^] (p - i)) = \\<zero>\" if \"i \\<in> {1..<p}\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. [(p choose i)] \\<cdot> (x [^] i \\<otimes> y [^] (p - i)) = \\<zero>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [(p choose i)] \\<cdot> (x [^] i \\<otimes> y [^] (p - i)) = \\<zero>", "have \"p dvd (p choose i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p dvd p choose i", "by (rule prime_dvd_choose) (use that assms in auto)"], ["proof (state)\nthis:\n  p dvd p choose i\n\ngoal (1 subgoal):\n 1. [(p choose i)] \\<cdot> (x [^] i \\<otimes> y [^] (p - i)) = \\<zero>", "then"], ["proof (chain)\npicking this:\n  p dvd p choose i", "obtain k where [simp]: \"(p choose i) = p * k\""], ["proof (prove)\nusing this:\n  p dvd p choose i\n\ngoal (1 subgoal):\n 1. (\\<And>k. p choose i = p * k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p choose i = p * k\n\ngoal (1 subgoal):\n 1. [(p choose i)] \\<cdot> (x [^] i \\<otimes> y [^] (p - i)) = \\<zero>", "have \"add_pow R (p choose i) (x [^] i \\<otimes> y [^] (p - i)) =\n            add_pow R (p choose i) \\<one> \\<otimes> (x [^] i \\<otimes> y [^] (p - i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(p choose i)] \\<cdot> (x [^] i \\<otimes> y [^] (p - i)) =\n    [(p choose i)] \\<cdot> \\<one> \\<otimes>\n    (x [^] i \\<otimes> y [^] (p - i))", "by (simp add: add_pow_ldistr)"], ["proof (state)\nthis:\n  [(p choose i)] \\<cdot> (x [^] i \\<otimes> y [^] (p - i)) =\n  [(p choose i)] \\<cdot> \\<one> \\<otimes> (x [^] i \\<otimes> y [^] (p - i))\n\ngoal (1 subgoal):\n 1. [(p choose i)] \\<cdot> (x [^] i \\<otimes> y [^] (p - i)) = \\<zero>", "also"], ["proof (state)\nthis:\n  [(p choose i)] \\<cdot> (x [^] i \\<otimes> y [^] (p - i)) =\n  [(p choose i)] \\<cdot> \\<one> \\<otimes> (x [^] i \\<otimes> y [^] (p - i))\n\ngoal (1 subgoal):\n 1. [(p choose i)] \\<cdot> (x [^] i \\<otimes> y [^] (p - i)) = \\<zero>", "have \"add_pow R (p choose i) \\<one> = \\<zero>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(p choose i)] \\<cdot> \\<one> = \\<zero>", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> carrier R\n  y \\<in> carrier R\n  [p] \\<cdot> \\<one> = \\<zero>\n  prime p\n\ngoal (1 subgoal):\n 1. [(p choose i)] \\<cdot> \\<one> = \\<zero>", "by (simp flip: add.nat_pow_pow)"], ["proof (state)\nthis:\n  [(p choose i)] \\<cdot> \\<one> = \\<zero>\n\ngoal (1 subgoal):\n 1. [(p choose i)] \\<cdot> (x [^] i \\<otimes> y [^] (p - i)) = \\<zero>", "finally"], ["proof (chain)\npicking this:\n  [(p choose i)] \\<cdot> (x [^] i \\<otimes> y [^] (p - i)) =\n  \\<zero> \\<otimes> (x [^] i \\<otimes> y [^] (p - i))", "show ?thesis"], ["proof (prove)\nusing this:\n  [(p choose i)] \\<cdot> (x [^] i \\<otimes> y [^] (p - i)) =\n  \\<zero> \\<otimes> (x [^] i \\<otimes> y [^] (p - i))\n\ngoal (1 subgoal):\n 1. [(p choose i)] \\<cdot> (x [^] i \\<otimes> y [^] (p - i)) = \\<zero>", "by simp"], ["proof (state)\nthis:\n  [(p choose i)] \\<cdot> (x [^] i \\<otimes> y [^] (p - i)) = \\<zero>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i20 \\<in> {1..<p} \\<Longrightarrow>\n  [(p choose ?i20)] \\<cdot> (x [^] ?i20 \\<otimes> y [^] (p - ?i20)) =\n  \\<zero>\n\ngoal (1 subgoal):\n 1. (x \\<oplus> y) [^] p = x [^] p \\<oplus> y [^] p", "have \"(x \\<oplus> y) [^] p = (\\<Oplus>i\\<in>{..p}. add_pow R (p choose i) (x [^] i \\<otimes> y [^] (p - i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<oplus> y) [^] p =\n    (\\<Oplus>i\\<in>{..p}. [(p choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (p - i)))", "by (rule binomial) auto"], ["proof (state)\nthis:\n  (x \\<oplus> y) [^] p =\n  (\\<Oplus>i\\<in>{..p}. [(p choose\n                          i)] \\<cdot> (x [^] i \\<otimes> y [^] (p - i)))\n\ngoal (1 subgoal):\n 1. (x \\<oplus> y) [^] p = x [^] p \\<oplus> y [^] p", "also"], ["proof (state)\nthis:\n  (x \\<oplus> y) [^] p =\n  (\\<Oplus>i\\<in>{..p}. [(p choose\n                          i)] \\<cdot> (x [^] i \\<otimes> y [^] (p - i)))\n\ngoal (1 subgoal):\n 1. (x \\<oplus> y) [^] p = x [^] p \\<oplus> y [^] p", "have \"\\<dots> = (\\<Oplus>i\\<in>{0, p}. add_pow R (p choose i) (x [^] i \\<otimes> y [^] (p - i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>i\\<in>{..p}. [(p choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (p - i))) =\n    (\\<Oplus>i\\<in>{0, p}. [(p choose\n                             i)] \\<cdot> (x [^] i \\<otimes> y [^] (p - i)))", "using *"], ["proof (prove)\nusing this:\n  ?i20 \\<in> {1..<p} \\<Longrightarrow>\n  [(p choose ?i20)] \\<cdot> (x [^] ?i20 \\<otimes> y [^] (p - ?i20)) =\n  \\<zero>\n\ngoal (1 subgoal):\n 1. (\\<Oplus>i\\<in>{..p}. [(p choose\n                            i)] \\<cdot> (x [^] i \\<otimes> y [^] (p - i))) =\n    (\\<Oplus>i\\<in>{0, p}. [(p choose\n                             i)] \\<cdot> (x [^] i \\<otimes> y [^] (p - i)))", "by (intro add.finprod_mono_neutral_cong_right) auto"], ["proof (state)\nthis:\n  (\\<Oplus>i\\<in>{..p}. [(p choose\n                          i)] \\<cdot> (x [^] i \\<otimes> y [^] (p - i))) =\n  (\\<Oplus>i\\<in>{0, p}. [(p choose\n                           i)] \\<cdot> (x [^] i \\<otimes> y [^] (p - i)))\n\ngoal (1 subgoal):\n 1. (x \\<oplus> y) [^] p = x [^] p \\<oplus> y [^] p", "also"], ["proof (state)\nthis:\n  (\\<Oplus>i\\<in>{..p}. [(p choose\n                          i)] \\<cdot> (x [^] i \\<otimes> y [^] (p - i))) =\n  (\\<Oplus>i\\<in>{0, p}. [(p choose\n                           i)] \\<cdot> (x [^] i \\<otimes> y [^] (p - i)))\n\ngoal (1 subgoal):\n 1. (x \\<oplus> y) [^] p = x [^] p \\<oplus> y [^] p", "have \"\\<dots> = x [^] p \\<oplus> y [^] p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Oplus>i\\<in>{0, p}. [(p choose\n                             i)] \\<cdot> (x [^] i \\<otimes>\n    y [^] (p - i))) =\n    x [^] p \\<oplus> y [^] p", "using assms prime_gt_0_nat[of p]"], ["proof (prove)\nusing this:\n  x \\<in> carrier R\n  y \\<in> carrier R\n  [p] \\<cdot> \\<one> = \\<zero>\n  prime p\n  prime p \\<Longrightarrow> 0 < p\n\ngoal (1 subgoal):\n 1. (\\<Oplus>i\\<in>{0, p}. [(p choose\n                             i)] \\<cdot> (x [^] i \\<otimes>\n    y [^] (p - i))) =\n    x [^] p \\<oplus> y [^] p", "by (simp add: cring_simprules)"], ["proof (state)\nthis:\n  (\\<Oplus>i\\<in>{0, p}. [(p choose\n                           i)] \\<cdot> (x [^] i \\<otimes> y [^] (p - i))) =\n  x [^] p \\<oplus> y [^] p\n\ngoal (1 subgoal):\n 1. (x \\<oplus> y) [^] p = x [^] p \\<oplus> y [^] p", "finally"], ["proof (chain)\npicking this:\n  (x \\<oplus> y) [^] p = x [^] p \\<oplus> y [^] p", "show ?thesis"], ["proof (prove)\nusing this:\n  (x \\<oplus> y) [^] p = x [^] p \\<oplus> y [^] p\n\ngoal (1 subgoal):\n 1. (x \\<oplus> y) [^] p = x [^] p \\<oplus> y [^] p", "."], ["proof (state)\nthis:\n  (x \\<oplus> y) [^] p = x [^] p \\<oplus> y [^] p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in ring_hom_cring) hom_add_pow_nat:\n  \"x \\<in> carrier R \\<Longrightarrow> h (add_pow R (n::nat) x) = add_pow S n (h x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> carrier R \\<Longrightarrow>\n    h ([n] \\<cdot> x) = [n] \\<cdot>\\<^bsub>S\\<^esub> h x", "by (induction n) auto"], ["", "end"]]}