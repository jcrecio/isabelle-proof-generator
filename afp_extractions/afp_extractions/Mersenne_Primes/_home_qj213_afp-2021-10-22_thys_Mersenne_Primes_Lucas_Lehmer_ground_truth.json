{"file_name": "/home/qj213/afp-2021-10-22/thys/Mersenne_Primes/Lucas_Lehmer.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Mersenne_Primes", "problem_names": ["lemma prime_power_minus_oneD:\n  fixes a n :: nat\n  assumes \"prime (a ^ n - 1)\"\n  shows   \"n = 1 \\<or> a = 2\"", "lemma prime_dvd_mersenneD:\n  fixes p q :: nat\n  assumes \"prime p\" \"p \\<noteq> 2\" \"prime q\" \"q dvd (2 ^ p - 1)\"\n  shows   \"[q = 1] (mod (2 * p))\"", "lemma prime_dvd_mersenneD':\n  fixes p q :: nat\n  assumes \"prime p\" \"p \\<noteq> 2\" \"prime q\" \"q dvd (2 ^ p - 1)\"\n  shows \"\\<exists>k>0. q = 1 + 2 * k * p\"", "lemma M_gt_6: \"M > 6\"", "lemma M_odd: \"odd M\"", "theorem p_prime: \"prime p\"", "lemma p_odd: \"odd p\"", "lemma M_cong_7_mod_12: \"[M = 7] (mod 12)\"", "lemma Legendre_3_M: \"Legendre 3 M = -1\"", "lemma M_cong_7_mod_8: \"[M = 7] (mod 8)\"", "lemma Legendre_2_M: \"Legendre 2 M = 1\"", "lemma M_not_dvd_24: \"\\<not>M dvd 24\"", "lemma gen_lucas_lehmer_sequence_Suc':\n  \"gen_lucas_lehmer_sequence a (Suc n) = gen_lucas_lehmer_sequence (a ^ 2 - 2) n\"", "lemmas gen_lucas_lehmer_code [code] =\n  gen_lucas_lehmer_sequence.simps(1) gen_lucas_lehmer_sequence_Suc'", "lemma gen_lucas_lehmer_sequence_4_closed_form1:\n  \"real_of_int (gen_lucas_lehmer_sequence 4 n) = (2 + sqrt 3) ^ (2 ^ n) + (2 - sqrt 3) ^ (2 ^ n)\"", "lemma gen_lucas_lehmer_sequence_4_closed_form2:\n  \"gen_lucas_lehmer_sequence 4 n = round ((2 + sqrt 3) ^ (2 ^ n))\"", "lemma gen_lucas_lehmer_sequence_4_closed_form3:\n  \"gen_lucas_lehmer_sequence 4 n = \\<lceil>(2 + sqrt 3) ^ (2 ^ n)\\<rceil>\"", "lemma carrier_lucas_lehmer_ring [simp]: \"carrier lucas_lehmer_ring = UNIV\"", "lemma cring_lucas_lehmer_ring [intro]: \"cring (lucas_lehmer_ring)\"", "lemma lucas_lehmer_add_in_carrier: \"m > 0 \\<Longrightarrow> lucas_lehmer_add m x y \\<in> {..<m} \\<times> {..<m}\"", "lemma lucas_lehmer_mult_in_carrier: \"m > 0 \\<Longrightarrow> lucas_lehmer_mult m x y \\<in> {..<m} \\<times> {..<m}\"", "lemma lucas_lehmer_add_cong:\n  \"[fst (lucas_lehmer_add m x y) = fst x + fst y] (mod m)\"\n  \"[snd (lucas_lehmer_add m x y) = snd x + snd y] (mod m)\"", "lemma lucas_lehmer_mult_cong:\n  \"[fst (lucas_lehmer_mult m x y) = fst x * fst y + 3 * snd x * snd y] (mod m)\"\n  \"[snd (lucas_lehmer_mult m x y) = fst x * snd y + snd x * fst y] (mod m)\"", "lemma lucas_lehmer_add_neutral [simp]:\n  assumes \"fst x < m\" \"snd x < m\"\n  shows   \"lucas_lehmer_add m (0, 0) x = x\"\n    and   \"lucas_lehmer_add m x (0, 0) = x\"", "lemma lucas_lehmer_mult_neutral [simp]:\n  assumes \"fst x < m\" \"snd x < m\"\n  shows   \"lucas_lehmer_mult m (Suc 0, 0) x = x\"\n    and   \"lucas_lehmer_mult m x (Suc 0, 0) = x\"", "lemma lucas_lehmer_add_commute: \"lucas_lehmer_add m x y = lucas_lehmer_add m y x\"", "lemma lucas_lehmer_mult_commute: \"lucas_lehmer_mult m x y = lucas_lehmer_mult m y x\"", "lemma lucas_lehmer_add_assoc:\n  assumes m: \"m > 0\"\n  shows   \"lucas_lehmer_add m x (lucas_lehmer_add m y z) =\n           lucas_lehmer_add m (lucas_lehmer_add m x y) z\"", "lemma lucas_lehmer_mult_assoc:\n  assumes m: \"m > 0\"\n  shows   \"lucas_lehmer_mult m x (lucas_lehmer_mult m y z) =\n           lucas_lehmer_mult m (lucas_lehmer_mult m x y) z\"", "lemma lucas_lehmer_distrib_right:\n  assumes m: \"m > 1\"\n  shows \"lucas_lehmer_mult m (lucas_lehmer_add m x y) z =\n         lucas_lehmer_add m (lucas_lehmer_mult m x z) (lucas_lehmer_mult m y z)\"", "lemma lucas_lehmer_distrib_left:\n  assumes \"m > 1\"\n  shows \"lucas_lehmer_mult m z (lucas_lehmer_add m x y) =\n         lucas_lehmer_add m (lucas_lehmer_mult m z x) (lucas_lehmer_mult m z y)\"", "lemma cring_lucas_lehmer_ring_mod [intro]:\n  assumes \"m > 1\"\n  shows   \"cring (lucas_lehmer_ring_mod m)\"", "lemma card_lucas_lehmer_Units:\n  assumes \"m > 1\"\n  shows   \"card (Units (lucas_lehmer_ring_mod m)) < m ^ 2\"", "lemma int_in_Units_lucas_lehmer_ring_mod:\n  assumes \"prime p\"\n  assumes \"x > 0\" \"x < p\"\n  shows   \"(x, 0) \\<in> Units (lucas_lehmer_ring_mod p)\"", "lemma minus_lucas_lehmer_ring: \"\\<ominus>\\<^bsub>lucas_lehmer_ring\\<^esub> x = (case x of (a, b) \\<Rightarrow> (-a, -b))\"", "lemma lucas_lehmer_to_real_simps1:\n      \"lucas_lehmer_to_real (a, b) = of_int a + of_int b * sqrt 3\"\n      \"lucas_lehmer_to_real (x \\<oplus>\\<^bsub>lucas_lehmer_ring\\<^esub> y) =\n       lucas_lehmer_to_real x + lucas_lehmer_to_real y\"\n      \"lucas_lehmer_to_real (x \\<otimes>\\<^bsub>lucas_lehmer_ring\\<^esub> y) =\n       lucas_lehmer_to_real x * lucas_lehmer_to_real y\"\n      \"lucas_lehmer_to_real (\\<ominus>\\<^bsub>lucas_lehmer_ring\\<^esub> x) = -lucas_lehmer_to_real x\"\n      \"lucas_lehmer_to_real (\\<zero>\\<^bsub>lucas_lehmer_ring\\<^esub>) = 0\"\n      \"lucas_lehmer_to_real (\\<one>\\<^bsub>lucas_lehmer_ring\\<^esub>) = 1\"", "lemma lucas_lehmer_to_add_pow_nat:\n  \"lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) = of_nat n * lucas_lehmer_to_real x\"", "lemma lucas_lehmer_to_add_pow_int:\n  \"lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) = of_int n * lucas_lehmer_to_real x\"", "lemma lucas_lehmer_to_real_power:\n  \"lucas_lehmer_to_real (x [^]\\<^bsub>lucas_lehmer_ring\\<^esub> (n :: nat)) = lucas_lehmer_to_real x ^ n\"", "lemmas lucas_lehmer_to_real_simps =\n  lucas_lehmer_to_real_simps1 lucas_lehmer_to_real_power\n  lucas_lehmer_to_add_pow_nat lucas_lehmer_to_add_pow_int", "lemma lucas_lehmer_to_real_inj: \"inj lucas_lehmer_to_real\"", "lemma lucas_lehmer_hom_cong:\n  \"[fst x = fst y] (mod int m) \\<Longrightarrow> [snd x = snd y] (mod int m) \\<Longrightarrow>\n   lucas_lehmer_hom m x = lucas_lehmer_hom m y\"", "lemma lucas_lehmer_hom_cong':\n  \"[a = b] (mod int m) \\<Longrightarrow> [c = d] (mod int m) \\<Longrightarrow>\n   lucas_lehmer_hom m (a, c) = lucas_lehmer_hom m (b, d)\"", "lemma lucas_lehmer_hom_in_carrier: \"lucas_lehmer_hom m x \\<in> {..<m} \\<times> {..<m}\"", "lemma lucas_lehmer_hom_add:\n  \"lucas_lehmer_hom m (lucas_lehmer_add' x y) =\n   lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y)\"", "lemma lucas_lehmer_hom_mult:\n  \"lucas_lehmer_hom m (lucas_lehmer_mult' x y) =\n   lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y)\"", "lemma lucas_lehmer_hom_1 [simp]: \"lucas_lehmer_hom m (1, 0) = (1, 0)\"", "lemma ring_hom_lucas_lehmer_hom:\n  \"lucas_lehmer_hom m \\<in> ring_hom lucas_lehmer_ring (lucas_lehmer_ring_mod m)\"", "theorem lucas_lehmer_sufficient:\n  assumes \"prime p\" \"odd p\"\n  assumes \"(2 ^ p - 1) dvd gen_lucas_lehmer_sequence 4 (p - 2)\"\n  shows   \"prime (2 ^ p - 1 :: nat)\"", "theorem (in mersenne_prime) lucas_lehmer_necessary:\n  \"(2 ^ p - 1) dvd gen_lucas_lehmer_sequence 4 (p - 2)\"", "lemma gen_lucas_lehmer_sequence'_Suc':\n  \"gen_lucas_lehmer_sequence' m a (Suc n) = (gen_lucas_lehmer_sequence' m a n ^ 2 - 2) mod m\"", "lemma gen_lucas_lehmer_sequence'_correct:\n  assumes \"a \\<in> {0..<m}\"\n  shows   \"gen_lucas_lehmer_sequence' m a n = gen_lucas_lehmer_sequence a n mod m\"", "lemma lucas_lehmer_test_code_arithmetic [code]:\n  \"lucas_lehmer_test p = (p > 2 \\<and>\n     gen_lucas_lehmer_sequence' (2 ^ p - 1) 4 (p - 2) = 0)\"", "lemma mersenne_prime_iff: \"mersenne_prime p \\<longleftrightarrow> p > 2 \\<and> prime (2 ^ p - 1 :: nat)\"", "lemma mersenne_prime_code [code]:\n  \"mersenne_prime p \\<longleftrightarrow> prime p \\<and> lucas_lehmer_test p\""], "translations": [["", "lemma prime_power_minus_oneD:\n  fixes a n :: nat\n  assumes \"prime (a ^ n - 1)\"\n  shows   \"n = 1 \\<or> a = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = 1 \\<or> a = 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n = 1 \\<or> a = 2", "from assms"], ["proof (chain)\npicking this:\n  prime (a ^ n - 1)", "have \"n > 0\""], ["proof (prove)\nusing this:\n  prime (a ^ n - 1)\n\ngoal (1 subgoal):\n 1. 0 < n", "by (intro Nat.gr0I) auto"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. n = 1 \\<or> a = 2", "have \"a \\<noteq> 0\" \"a \\<noteq> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> 0 &&& a \\<noteq> 1", "by (rule notI, use \\<open>n > 0\\<close> assms in \\<open>simp add: zero_power\\<close>)+"], ["proof (state)\nthis:\n  a \\<noteq> 0\n  a \\<noteq> 1\n\ngoal (1 subgoal):\n 1. n = 1 \\<or> a = 2", "hence \"a > 1\""], ["proof (prove)\nusing this:\n  a \\<noteq> 0\n  a \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 1 < a", "by auto"], ["proof (state)\nthis:\n  1 < a\n\ngoal (1 subgoal):\n 1. n = 1 \\<or> a = 2", "have \"[a - 1 + 1 = 0 + 1] (mod (a - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [a - 1 + 1 = 0 + 1] (mod a - 1)", "by (rule cong_add) (auto simp: cong_def)"], ["proof (state)\nthis:\n  [a - 1 + 1 = 0 + 1] (mod a - 1)\n\ngoal (1 subgoal):\n 1. n = 1 \\<or> a = 2", "hence \"[a = 1] (mod (a - 1))\""], ["proof (prove)\nusing this:\n  [a - 1 + 1 = 0 + 1] (mod a - 1)\n\ngoal (1 subgoal):\n 1. [a = 1] (mod a - 1)", "using \\<open>a > 1\\<close>"], ["proof (prove)\nusing this:\n  [a - 1 + 1 = 0 + 1] (mod a - 1)\n  1 < a\n\ngoal (1 subgoal):\n 1. [a = 1] (mod a - 1)", "by simp"], ["proof (state)\nthis:\n  [a = 1] (mod a - 1)\n\ngoal (1 subgoal):\n 1. n = 1 \\<or> a = 2", "hence \"[a ^ n - 1 = 1 ^ n - 1] (mod (a - 1))\""], ["proof (prove)\nusing this:\n  [a = 1] (mod a - 1)\n\ngoal (1 subgoal):\n 1. [a ^ n - 1 = 1 ^ n - 1] (mod a - 1)", "using \\<open>a > 1\\<close>"], ["proof (prove)\nusing this:\n  [a = 1] (mod a - 1)\n  1 < a\n\ngoal (1 subgoal):\n 1. [a ^ n - 1 = 1 ^ n - 1] (mod a - 1)", "by (intro cong_pow cong_diff_nat) auto"], ["proof (state)\nthis:\n  [a ^ n - 1 = 1 ^ n - 1] (mod a - 1)\n\ngoal (1 subgoal):\n 1. n = 1 \\<or> a = 2", "hence \"(a - 1) dvd (a ^ n - 1)\""], ["proof (prove)\nusing this:\n  [a ^ n - 1 = 1 ^ n - 1] (mod a - 1)\n\ngoal (1 subgoal):\n 1. a - 1 dvd a ^ n - 1", "by (simp add: cong_0_iff)"], ["proof (state)\nthis:\n  a - 1 dvd a ^ n - 1\n\ngoal (1 subgoal):\n 1. n = 1 \\<or> a = 2", "have \"a - 1 = 1 \\<or> a - 1 = a ^ n - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a - 1 = 1 \\<or> a - 1 = a ^ n - 1", "using \\<open>prime (a ^ n - 1)\\<close> and \\<open>(a - 1) dvd _\\<close>"], ["proof (prove)\nusing this:\n  prime (a ^ n - 1)\n  a - 1 dvd a ^ n - 1\n\ngoal (1 subgoal):\n 1. a - 1 = 1 \\<or> a - 1 = a ^ n - 1", "by (rule prime_natD)"], ["proof (state)\nthis:\n  a - 1 = 1 \\<or> a - 1 = a ^ n - 1\n\ngoal (1 subgoal):\n 1. n = 1 \\<or> a = 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  a - 1 = 1 \\<or> a - 1 = a ^ n - 1\n\ngoal (1 subgoal):\n 1. n = 1 \\<or> a = 2", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. a - 1 = 1 \\<Longrightarrow> n = 1 \\<or> a = 2\n 2. a - 1 = a ^ n - 1 \\<Longrightarrow> n = 1 \\<or> a = 2", "assume \"a - 1 = 1\""], ["proof (state)\nthis:\n  a - 1 = 1\n\ngoal (2 subgoals):\n 1. a - 1 = 1 \\<Longrightarrow> n = 1 \\<or> a = 2\n 2. a - 1 = a ^ n - 1 \\<Longrightarrow> n = 1 \\<or> a = 2", "hence \"a = 2\""], ["proof (prove)\nusing this:\n  a - 1 = 1\n\ngoal (1 subgoal):\n 1. a = 2", "by simp"], ["proof (state)\nthis:\n  a = 2\n\ngoal (2 subgoals):\n 1. a - 1 = 1 \\<Longrightarrow> n = 1 \\<or> a = 2\n 2. a - 1 = a ^ n - 1 \\<Longrightarrow> n = 1 \\<or> a = 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  a = 2\n\ngoal (1 subgoal):\n 1. n = 1 \\<or> a = 2", "by simp"], ["proof (state)\nthis:\n  n = 1 \\<or> a = 2\n\ngoal (1 subgoal):\n 1. a - 1 = a ^ n - 1 \\<Longrightarrow> n = 1 \\<or> a = 2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a - 1 = a ^ n - 1 \\<Longrightarrow> n = 1 \\<or> a = 2", "assume \"a - 1 = a ^ n - 1\""], ["proof (state)\nthis:\n  a - 1 = a ^ n - 1\n\ngoal (1 subgoal):\n 1. a - 1 = a ^ n - 1 \\<Longrightarrow> n = 1 \\<or> a = 2", "hence \"a ^ n = a ^ 1\""], ["proof (prove)\nusing this:\n  a - 1 = a ^ n - 1\n\ngoal (1 subgoal):\n 1. a ^ n = a ^ 1", "using \\<open>a > 1\\<close>"], ["proof (prove)\nusing this:\n  a - 1 = a ^ n - 1\n  1 < a\n\ngoal (1 subgoal):\n 1. a ^ n = a ^ 1", "by (simp add: Nat.eq_diff_iff)"], ["proof (state)\nthis:\n  a ^ n = a ^ 1\n\ngoal (1 subgoal):\n 1. a - 1 = a ^ n - 1 \\<Longrightarrow> n = 1 \\<or> a = 2", "hence \"n = 1\""], ["proof (prove)\nusing this:\n  a ^ n = a ^ 1\n\ngoal (1 subgoal):\n 1. n = 1", "using \\<open>a > 1\\<close>"], ["proof (prove)\nusing this:\n  a ^ n = a ^ 1\n  1 < a\n\ngoal (1 subgoal):\n 1. n = 1", "by (subst (asm) power_inject_exp) auto"], ["proof (state)\nthis:\n  n = 1\n\ngoal (1 subgoal):\n 1. a - 1 = a ^ n - 1 \\<Longrightarrow> n = 1 \\<or> a = 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = 1\n\ngoal (1 subgoal):\n 1. n = 1 \\<or> a = 2", "by simp"], ["proof (state)\nthis:\n  n = 1 \\<or> a = 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n = 1 \\<or> a = 2\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Next, we show that if a prime \\<open>q\\<close> divides a Mersenne number $2^p - 1$ with an odd prime\n  exponent \\<open>p\\<close>, then \\<open>q\\<close> must be of the form $q = 1 + 2kp$ for some $k > 0$.\n\\<close>"], ["", "lemma prime_dvd_mersenneD:\n  fixes p q :: nat\n  assumes \"prime p\" \"p \\<noteq> 2\" \"prime q\" \"q dvd (2 ^ p - 1)\"\n  shows   \"[q = 1] (mod (2 * p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [q = 1] (mod 2 * p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [q = 1] (mod 2 * p)", "from assms"], ["proof (chain)\npicking this:\n  prime p\n  p \\<noteq> 2\n  prime q\n  q dvd 2 ^ p - 1", "have \"odd p\""], ["proof (prove)\nusing this:\n  prime p\n  p \\<noteq> 2\n  prime q\n  q dvd 2 ^ p - 1\n\ngoal (1 subgoal):\n 1. odd p", "using prime_gt_1_nat[of p]"], ["proof (prove)\nusing this:\n  prime p\n  p \\<noteq> 2\n  prime q\n  q dvd 2 ^ p - 1\n  prime p \\<Longrightarrow> 1 < p\n\ngoal (1 subgoal):\n 1. odd p", "by (intro prime_odd_nat) auto"], ["proof (state)\nthis:\n  odd p\n\ngoal (1 subgoal):\n 1. [q = 1] (mod 2 * p)", "have \"q \\<noteq> 0\" \"q \\<noteq> 1\" \"q \\<noteq> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> 0 &&& q \\<noteq> 1 &&& q \\<noteq> 2", "using assms"], ["proof (prove)\nusing this:\n  prime p\n  p \\<noteq> 2\n  prime q\n  q dvd 2 ^ p - 1\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 &&& q \\<noteq> 1 &&& q \\<noteq> 2", "by (auto intro!: Nat.gr0I)"], ["proof (state)\nthis:\n  q \\<noteq> 0\n  q \\<noteq> 1\n  q \\<noteq> 2\n\ngoal (1 subgoal):\n 1. [q = 1] (mod 2 * p)", "hence \"q > 2\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  q \\<noteq> 1\n  q \\<noteq> 2\n\ngoal (1 subgoal):\n 1. 2 < q", "by simp"], ["proof (state)\nthis:\n  2 < q\n\ngoal (1 subgoal):\n 1. [q = 1] (mod 2 * p)", "with \\<open>prime q\\<close>"], ["proof (chain)\npicking this:\n  prime q\n  2 < q", "have \"odd q\""], ["proof (prove)\nusing this:\n  prime q\n  2 < q\n\ngoal (1 subgoal):\n 1. odd q", "by (simp add: prime_odd_nat)"], ["proof (state)\nthis:\n  odd q\n\ngoal (1 subgoal):\n 1. [q = 1] (mod 2 * p)", "have \"ord q 2 = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord q 2 = p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ord q 2 = p", "from assms"], ["proof (chain)\npicking this:\n  prime p\n  p \\<noteq> 2\n  prime q\n  q dvd 2 ^ p - 1", "have \"[2 ^ p - 1 + 1 = 0 + 1] (mod q)\""], ["proof (prove)\nusing this:\n  prime p\n  p \\<noteq> 2\n  prime q\n  q dvd 2 ^ p - 1\n\ngoal (1 subgoal):\n 1. [2 ^ p - 1 + 1 = 0 + 1] (mod q)", "by (intro cong_add cong_refl) (auto simp: cong_0_iff)"], ["proof (state)\nthis:\n  [2 ^ p - 1 + 1 = 0 + 1] (mod q)\n\ngoal (1 subgoal):\n 1. ord q 2 = p", "hence \"[2 ^ p = 1] (mod q)\""], ["proof (prove)\nusing this:\n  [2 ^ p - 1 + 1 = 0 + 1] (mod q)\n\ngoal (1 subgoal):\n 1. [2 ^ p = 1] (mod q)", "by simp"], ["proof (state)\nthis:\n  [2 ^ p = 1] (mod q)\n\ngoal (1 subgoal):\n 1. ord q 2 = p", "hence \"ord q 2 dvd p\""], ["proof (prove)\nusing this:\n  [2 ^ p = 1] (mod q)\n\ngoal (1 subgoal):\n 1. ord q 2 dvd p", "by (subst (asm) ord_divides)"], ["proof (state)\nthis:\n  ord q 2 dvd p\n\ngoal (1 subgoal):\n 1. ord q 2 = p", "hence \"ord q 2 = 1 \\<or> ord q 2 = p\""], ["proof (prove)\nusing this:\n  ord q 2 dvd p\n\ngoal (1 subgoal):\n 1. ord q 2 = 1 \\<or> ord q 2 = p", "using \\<open>prime p\\<close> and prime_natD"], ["proof (prove)\nusing this:\n  ord q 2 dvd p\n  prime p\n  \\<lbrakk>prime ?p; ?a dvd ?p\\<rbrakk>\n  \\<Longrightarrow> ?a = 1 \\<or> ?a = ?p\n\ngoal (1 subgoal):\n 1. ord q 2 = 1 \\<or> ord q 2 = p", "by blast"], ["proof (state)\nthis:\n  ord q 2 = 1 \\<or> ord q 2 = p\n\ngoal (1 subgoal):\n 1. ord q 2 = p", "moreover"], ["proof (state)\nthis:\n  ord q 2 = 1 \\<or> ord q 2 = p\n\ngoal (1 subgoal):\n 1. ord q 2 = p", "have \"ord q 2 \\<noteq> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord q 2 \\<noteq> 1", "using ord_works[of 2 q] and \\<open>prime q\\<close>"], ["proof (prove)\nusing this:\n  [2 ^ ord q 2 = 1] (mod q) \\<and>\n  (\\<forall>m.\n      0 < m \\<and> m < ord q 2 \\<longrightarrow> [2 ^ m \\<noteq> 1] (mod q))\n  prime q\n\ngoal (1 subgoal):\n 1. ord q 2 \\<noteq> 1", "by (auto simp: cong_altdef_nat)"], ["proof (state)\nthis:\n  ord q 2 \\<noteq> 1\n\ngoal (1 subgoal):\n 1. ord q 2 = p", "ultimately"], ["proof (chain)\npicking this:\n  ord q 2 = 1 \\<or> ord q 2 = p\n  ord q 2 \\<noteq> 1", "show \"ord q 2 = p\""], ["proof (prove)\nusing this:\n  ord q 2 = 1 \\<or> ord q 2 = p\n  ord q 2 \\<noteq> 1\n\ngoal (1 subgoal):\n 1. ord q 2 = p", "by blast"], ["proof (state)\nthis:\n  ord q 2 = p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ord q 2 = p\n\ngoal (1 subgoal):\n 1. [q = 1] (mod 2 * p)", "have q_dvd_iff: \"q dvd (2 ^ x - 1) \\<longleftrightarrow> p dvd x\" for x :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. (q dvd 2 ^ x - 1) = (p dvd x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (q dvd 2 ^ x - 1) = (p dvd x)", "have \"q dvd (2 ^ x - 1) \\<longleftrightarrow> [2 ^ x = 1] (mod q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (q dvd 2 ^ x - 1) = [2 ^ x = 1] (mod q)", "by (auto simp: cong_altdef_nat)"], ["proof (state)\nthis:\n  (q dvd 2 ^ x - 1) = [2 ^ x = 1] (mod q)\n\ngoal (1 subgoal):\n 1. (q dvd 2 ^ x - 1) = (p dvd x)", "also"], ["proof (state)\nthis:\n  (q dvd 2 ^ x - 1) = [2 ^ x = 1] (mod q)\n\ngoal (1 subgoal):\n 1. (q dvd 2 ^ x - 1) = (p dvd x)", "have \"\\<dots> \\<longleftrightarrow> ord q 2 dvd x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [2 ^ x = 1] (mod q) = (ord q 2 dvd x)", "by (rule ord_divides)"], ["proof (state)\nthis:\n  [2 ^ x = 1] (mod q) = (ord q 2 dvd x)\n\ngoal (1 subgoal):\n 1. (q dvd 2 ^ x - 1) = (p dvd x)", "also"], ["proof (state)\nthis:\n  [2 ^ x = 1] (mod q) = (ord q 2 dvd x)\n\ngoal (1 subgoal):\n 1. (q dvd 2 ^ x - 1) = (p dvd x)", "note \\<open>ord q 2 = p\\<close>"], ["proof (state)\nthis:\n  ord q 2 = p\n\ngoal (1 subgoal):\n 1. (q dvd 2 ^ x - 1) = (p dvd x)", "finally"], ["proof (chain)\npicking this:\n  (q dvd 2 ^ x - 1) = (p dvd x)", "show ?thesis"], ["proof (prove)\nusing this:\n  (q dvd 2 ^ x - 1) = (p dvd x)\n\ngoal (1 subgoal):\n 1. (q dvd 2 ^ x - 1) = (p dvd x)", "."], ["proof (state)\nthis:\n  (q dvd 2 ^ x - 1) = (p dvd x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (q dvd 2 ^ ?x - 1) = (p dvd ?x)\n\ngoal (1 subgoal):\n 1. [q = 1] (mod 2 * p)", "from \\<open>q > 2\\<close> and assms"], ["proof (chain)\npicking this:\n  2 < q\n  prime p\n  p \\<noteq> 2\n  prime q\n  q dvd 2 ^ p - 1", "have \"\\<not>q dvd 2\""], ["proof (prove)\nusing this:\n  2 < q\n  prime p\n  p \\<noteq> 2\n  prime q\n  q dvd 2 ^ p - 1\n\ngoal (1 subgoal):\n 1. \\<not> q dvd 2", "using primes_dvd_imp_eq two_is_prime_nat"], ["proof (prove)\nusing this:\n  2 < q\n  prime p\n  p \\<noteq> 2\n  prime q\n  q dvd 2 ^ p - 1\n  \\<lbrakk>prime ?p; prime ?q; ?p dvd ?q\\<rbrakk> \\<Longrightarrow> ?p = ?q\n  prime 2\n\ngoal (1 subgoal):\n 1. \\<not> q dvd 2", "by blast"], ["proof (state)\nthis:\n  \\<not> q dvd 2\n\ngoal (1 subgoal):\n 1. [q = 1] (mod 2 * p)", "hence \"[2 ^ (q - 1) - 1 = 1 - 1] (mod q)\""], ["proof (prove)\nusing this:\n  \\<not> q dvd 2\n\ngoal (1 subgoal):\n 1. [2 ^ (q - 1) - 1 = 1 - 1] (mod q)", "using assms"], ["proof (prove)\nusing this:\n  \\<not> q dvd 2\n  prime p\n  p \\<noteq> 2\n  prime q\n  q dvd 2 ^ p - 1\n\ngoal (1 subgoal):\n 1. [2 ^ (q - 1) - 1 = 1 - 1] (mod q)", "by (intro fermat_theorem cong_diff_nat) auto"], ["proof (state)\nthis:\n  [2 ^ (q - 1) - 1 = 1 - 1] (mod q)\n\ngoal (1 subgoal):\n 1. [q = 1] (mod 2 * p)", "hence \"q dvd (2 ^ (q - 1) - 1)\""], ["proof (prove)\nusing this:\n  [2 ^ (q - 1) - 1 = 1 - 1] (mod q)\n\ngoal (1 subgoal):\n 1. q dvd 2 ^ (q - 1) - 1", "by (simp add: cong_0_iff)"], ["proof (state)\nthis:\n  q dvd 2 ^ (q - 1) - 1\n\ngoal (1 subgoal):\n 1. [q = 1] (mod 2 * p)", "hence \"p dvd (q - 1)\""], ["proof (prove)\nusing this:\n  q dvd 2 ^ (q - 1) - 1\n\ngoal (1 subgoal):\n 1. p dvd q - 1", "by (subst (asm) q_dvd_iff)"], ["proof (state)\nthis:\n  p dvd q - 1\n\ngoal (1 subgoal):\n 1. [q = 1] (mod 2 * p)", "hence \"[q = 1] (mod p)\""], ["proof (prove)\nusing this:\n  p dvd q - 1\n\ngoal (1 subgoal):\n 1. [q = 1] (mod p)", "using \\<open>q > 2\\<close>"], ["proof (prove)\nusing this:\n  p dvd q - 1\n  2 < q\n\ngoal (1 subgoal):\n 1. [q = 1] (mod p)", "by (auto simp: cong_altdef_nat prime_gt_1_nat)"], ["proof (state)\nthis:\n  [q = 1] (mod p)\n\ngoal (1 subgoal):\n 1. [q = 1] (mod 2 * p)", "moreover"], ["proof (state)\nthis:\n  [q = 1] (mod p)\n\ngoal (1 subgoal):\n 1. [q = 1] (mod 2 * p)", "have \"[q = 1] (mod 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [q = 1] (mod 2)", "using \\<open>odd q\\<close>"], ["proof (prove)\nusing this:\n  odd q\n\ngoal (1 subgoal):\n 1. [q = 1] (mod 2)", "by (auto simp: cong_def odd_iff_mod_2_eq_one)"], ["proof (state)\nthis:\n  [q = 1] (mod 2)\n\ngoal (1 subgoal):\n 1. [q = 1] (mod 2 * p)", "ultimately"], ["proof (chain)\npicking this:\n  [q = 1] (mod p)\n  [q = 1] (mod 2)", "show \"[q = 1] (mod (2 * p))\""], ["proof (prove)\nusing this:\n  [q = 1] (mod p)\n  [q = 1] (mod 2)\n\ngoal (1 subgoal):\n 1. [q = 1] (mod 2 * p)", "using \\<open>odd p\\<close>"], ["proof (prove)\nusing this:\n  [q = 1] (mod p)\n  [q = 1] (mod 2)\n  odd p\n\ngoal (1 subgoal):\n 1. [q = 1] (mod 2 * p)", "by (intro coprime_cong_mult_nat) auto"], ["proof (state)\nthis:\n  [q = 1] (mod 2 * p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prime_dvd_mersenneD':\n  fixes p q :: nat\n  assumes \"prime p\" \"p \\<noteq> 2\" \"prime q\" \"q dvd (2 ^ p - 1)\"\n  shows \"\\<exists>k>0. q = 1 + 2 * k * p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k>0. q = 1 + 2 * k * p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k>0. q = 1 + 2 * k * p", "have \"q \\<noteq> 0\" \"q \\<noteq> 1\" \"q \\<noteq> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> 0 &&& q \\<noteq> 1 &&& q \\<noteq> 2", "using assms"], ["proof (prove)\nusing this:\n  prime p\n  p \\<noteq> 2\n  prime q\n  q dvd 2 ^ p - 1\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 &&& q \\<noteq> 1 &&& q \\<noteq> 2", "by (auto intro!: Nat.gr0I)"], ["proof (state)\nthis:\n  q \\<noteq> 0\n  q \\<noteq> 1\n  q \\<noteq> 2\n\ngoal (1 subgoal):\n 1. \\<exists>k>0. q = 1 + 2 * k * p", "hence \"q > 2\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  q \\<noteq> 1\n  q \\<noteq> 2\n\ngoal (1 subgoal):\n 1. 2 < q", "by simp"], ["proof (state)\nthis:\n  2 < q\n\ngoal (1 subgoal):\n 1. \\<exists>k>0. q = 1 + 2 * k * p", "have \"[q = 1] (mod (2 * p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [q = 1] (mod 2 * p)", "by (rule prime_dvd_mersenneD) fact+"], ["proof (state)\nthis:\n  [q = 1] (mod 2 * p)\n\ngoal (1 subgoal):\n 1. \\<exists>k>0. q = 1 + 2 * k * p", "hence \"(2 * p) dvd (q - 1)\""], ["proof (prove)\nusing this:\n  [q = 1] (mod 2 * p)\n\ngoal (1 subgoal):\n 1. 2 * p dvd q - 1", "using \\<open>q > 2\\<close>"], ["proof (prove)\nusing this:\n  [q = 1] (mod 2 * p)\n  2 < q\n\ngoal (1 subgoal):\n 1. 2 * p dvd q - 1", "by (auto simp: cong_altdef_nat)"], ["proof (state)\nthis:\n  2 * p dvd q - 1\n\ngoal (1 subgoal):\n 1. \\<exists>k>0. q = 1 + 2 * k * p", "then"], ["proof (chain)\npicking this:\n  2 * p dvd q - 1", "obtain k where k: \"q - 1 = (2 * p) * k\""], ["proof (prove)\nusing this:\n  2 * p dvd q - 1\n\ngoal (1 subgoal):\n 1. (\\<And>k. q - 1 = 2 * p * k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  q - 1 = 2 * p * k\n\ngoal (1 subgoal):\n 1. \\<exists>k>0. q = 1 + 2 * k * p", "hence \"q = 1 + 2 * k * p\""], ["proof (prove)\nusing this:\n  q - 1 = 2 * p * k\n\ngoal (1 subgoal):\n 1. q = 1 + 2 * k * p", "using \\<open>q > 2\\<close>"], ["proof (prove)\nusing this:\n  q - 1 = 2 * p * k\n  2 < q\n\ngoal (1 subgoal):\n 1. q = 1 + 2 * k * p", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  q = 1 + 2 * k * p\n\ngoal (1 subgoal):\n 1. \\<exists>k>0. q = 1 + 2 * k * p", "moreover"], ["proof (state)\nthis:\n  q = 1 + 2 * k * p\n\ngoal (1 subgoal):\n 1. \\<exists>k>0. q = 1 + 2 * k * p", "have \"k > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k", "using \\<open>q > 2\\<close> and k"], ["proof (prove)\nusing this:\n  2 < q\n  q - 1 = 2 * p * k\n\ngoal (1 subgoal):\n 1. 0 < k", "by (intro Nat.gr0I) auto"], ["proof (state)\nthis:\n  0 < k\n\ngoal (1 subgoal):\n 1. \\<exists>k>0. q = 1 + 2 * k * p", "ultimately"], ["proof (chain)\npicking this:\n  q = 1 + 2 * k * p\n  0 < k", "show ?thesis"], ["proof (prove)\nusing this:\n  q = 1 + 2 * k * p\n  0 < k\n\ngoal (1 subgoal):\n 1. \\<exists>k>0. q = 1 + 2 * k * p", "by blast"], ["proof (state)\nthis:\n  \\<exists>k>0. q = 1 + 2 * k * p\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  A Mersenne number is any number of the form $2^p - 1$ for a natural number $p$. To make things\n  a bit more pleasant, we additionally exclude $2^2 - 1$, i.e. we require $p > 2$. It can\n  be shown that $p$ is then always an odd prime.\n\\<close>"], ["", "locale mersenne_prime =\n  fixes p M :: nat\n  defines \"M \\<equiv> 2 ^ p - 1\"\n  assumes p_gt_2: \"p > 2\" and prime: \"prime M\"\nbegin"], ["", "lemma M_gt_6: \"M > 6\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 6 < M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 6 < M", "from p_gt_2"], ["proof (chain)\npicking this:\n  2 < p", "have \"2 ^ p \\<ge> (2 ^ 3 :: nat)\""], ["proof (prove)\nusing this:\n  2 < p\n\ngoal (1 subgoal):\n 1. 2 ^ 3 \\<le> 2 ^ p", "by (intro power_increasing) auto"], ["proof (state)\nthis:\n  2 ^ 3 \\<le> 2 ^ p\n\ngoal (1 subgoal):\n 1. 6 < M", "thus ?thesis"], ["proof (prove)\nusing this:\n  2 ^ 3 \\<le> 2 ^ p\n\ngoal (1 subgoal):\n 1. 6 < M", "by (simp add: M_def)"], ["proof (state)\nthis:\n  6 < M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma M_odd: \"odd M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd M", "using p_gt_2"], ["proof (prove)\nusing this:\n  2 < p\n\ngoal (1 subgoal):\n 1. odd M", "by (auto simp: M_def)"], ["", "theorem p_prime: \"prime p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime p", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> prime p \\<Longrightarrow> False", "assume \"\\<not>prime p\""], ["proof (state)\nthis:\n  \\<not> prime p\n\ngoal (1 subgoal):\n 1. \\<not> prime p \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> prime p", "obtain a b where ab: \"p = a * b\" \"a > 1\" \"b > 1\""], ["proof (prove)\nusing this:\n  \\<not> prime p\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>p = a * b; 1 < a; 1 < b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using p_gt_2 not_prime_imp_ex_prod_nat[of p]"], ["proof (prove)\nusing this:\n  \\<not> prime p\n  2 < p\n  \\<lbrakk>1 < p; \\<not> prime p\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n k.\n                       p = n * k \\<and>\n                       1 < n \\<and> n < p \\<and> 1 < k \\<and> k < p\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>p = a * b; 1 < a; 1 < b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p = a * b\n  1 < a\n  1 < b\n\ngoal (1 subgoal):\n 1. \\<not> prime p \\<Longrightarrow> False", "have geometric_sum_aux: \"(x - (1 :: int)) * (\\<Sum>k<a. x ^ k) = x ^ a - 1\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x - 1) * sum ((^) x) {..<a} = x ^ a - 1", "by (induction a) (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  (?x - 1) * sum ((^) ?x) {..<a} = ?x ^ a - 1\n\ngoal (1 subgoal):\n 1. \\<not> prime p \\<Longrightarrow> False", "have \"(2 ^ b - 1 :: int) * (\\<Sum>k<a. (2 ^ b) ^ k) = (2 ^ b) ^ a - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ b - 1) * sum ((^) (2 ^ b)) {..<a} = (2 ^ b) ^ a - 1", "by (rule geometric_sum_aux)"], ["proof (state)\nthis:\n  (2 ^ b - 1) * sum ((^) (2 ^ b)) {..<a} = (2 ^ b) ^ a - 1\n\ngoal (1 subgoal):\n 1. \\<not> prime p \\<Longrightarrow> False", "hence \"2 ^ (a*b) - 1 = (2 ^ b - 1 :: int) * (\\<Sum>k<a. 2 ^ (k*b))\""], ["proof (prove)\nusing this:\n  (2 ^ b - 1) * sum ((^) (2 ^ b)) {..<a} = (2 ^ b) ^ a - 1\n\ngoal (1 subgoal):\n 1. 2 ^ (a * b) - 1 = (2 ^ b - 1) * (\\<Sum>k<a. 2 ^ (k * b))", "by (simp flip: power_mult add: algebra_simps)"], ["proof (state)\nthis:\n  2 ^ (a * b) - 1 = (2 ^ b - 1) * (\\<Sum>k<a. 2 ^ (k * b))\n\ngoal (1 subgoal):\n 1. \\<not> prime p \\<Longrightarrow> False", "hence \"(2 ^ b - 1) dvd (2 ^ (a*b) - 1 :: int)\""], ["proof (prove)\nusing this:\n  2 ^ (a * b) - 1 = (2 ^ b - 1) * (\\<Sum>k<a. 2 ^ (k * b))\n\ngoal (1 subgoal):\n 1. 2 ^ b - 1 dvd 2 ^ (a * b) - 1", "by simp"], ["proof (state)\nthis:\n  2 ^ b - 1 dvd 2 ^ (a * b) - 1\n\ngoal (1 subgoal):\n 1. \\<not> prime p \\<Longrightarrow> False", "hence \"int (2 ^ b - 1) dvd int (2 ^ (a * b) - 1)\""], ["proof (prove)\nusing this:\n  2 ^ b - 1 dvd 2 ^ (a * b) - 1\n\ngoal (1 subgoal):\n 1. int (2 ^ b - 1) dvd int (2 ^ (a * b) - 1)", "by (subst of_nat_diff) (auto simp: of_nat_diff)"], ["proof (state)\nthis:\n  int (2 ^ b - 1) dvd int (2 ^ (a * b) - 1)\n\ngoal (1 subgoal):\n 1. \\<not> prime p \\<Longrightarrow> False", "hence \"(2 ^ b - 1) dvd (2 ^ (a * b) - 1 :: nat)\""], ["proof (prove)\nusing this:\n  int (2 ^ b - 1) dvd int (2 ^ (a * b) - 1)\n\ngoal (1 subgoal):\n 1. 2 ^ b - 1 dvd 2 ^ (a * b) - 1", "by (subst (asm) int_dvd_int_iff)"], ["proof (state)\nthis:\n  2 ^ b - 1 dvd 2 ^ (a * b) - 1\n\ngoal (1 subgoal):\n 1. \\<not> prime p \\<Longrightarrow> False", "with prime"], ["proof (chain)\npicking this:\n  prime M\n  2 ^ b - 1 dvd 2 ^ (a * b) - 1", "have \"2 ^ b - 1 = (1 :: nat) \\<or> 2 ^ b - 1 = (2 ^ p - 1 :: nat)\""], ["proof (prove)\nusing this:\n  prime M\n  2 ^ b - 1 dvd 2 ^ (a * b) - 1\n\ngoal (1 subgoal):\n 1. 2 ^ b - 1 = 1 \\<or> 2 ^ b - 1 = 2 ^ p - 1", "unfolding ab M_def"], ["proof (prove)\nusing this:\n  prime (2 ^ (a * b) - 1)\n  2 ^ b - 1 dvd 2 ^ (a * b) - 1\n\ngoal (1 subgoal):\n 1. 2 ^ b - 1 = 1 \\<or> 2 ^ b - 1 = 2 ^ (a * b) - 1", "by (intro prime_natD) auto"], ["proof (state)\nthis:\n  2 ^ b - 1 = 1 \\<or> 2 ^ b - 1 = 2 ^ p - 1\n\ngoal (1 subgoal):\n 1. \\<not> prime p \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  2 ^ b - 1 = 1 \\<or> 2 ^ b - 1 = 2 ^ p - 1\n\ngoal (1 subgoal):\n 1. \\<not> prime p \\<Longrightarrow> False", "have \"2 ^ b > (2 ^ 1 :: nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ 1 < 2 ^ b", "using ab"], ["proof (prove)\nusing this:\n  p = a * b\n  1 < a\n  1 < b\n\ngoal (1 subgoal):\n 1. 2 ^ 1 < 2 ^ b", "by (intro power_strict_increasing) auto"], ["proof (state)\nthis:\n  2 ^ 1 < 2 ^ b\n\ngoal (1 subgoal):\n 1. \\<not> prime p \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  2 ^ 1 < 2 ^ b\n\ngoal (1 subgoal):\n 1. \\<not> prime p \\<Longrightarrow> False", "have \"2 ^ b < (2 ^ p :: nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ b < 2 ^ p", "using ab"], ["proof (prove)\nusing this:\n  p = a * b\n  1 < a\n  1 < b\n\ngoal (1 subgoal):\n 1. 2 ^ b < 2 ^ p", "by (intro power_strict_increasing) auto"], ["proof (state)\nthis:\n  2 ^ b < 2 ^ p\n\ngoal (1 subgoal):\n 1. \\<not> prime p \\<Longrightarrow> False", "hence \"2 ^ b - 1 < (2 ^ p - 1 :: nat)\""], ["proof (prove)\nusing this:\n  2 ^ b < 2 ^ p\n\ngoal (1 subgoal):\n 1. 2 ^ b - 1 < 2 ^ p - 1", "by (subst less_diff_iff) auto"], ["proof (state)\nthis:\n  2 ^ b - 1 < 2 ^ p - 1\n\ngoal (1 subgoal):\n 1. \\<not> prime p \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  2 ^ b - 1 = 1 \\<or> 2 ^ b - 1 = 2 ^ p - 1\n  2 ^ 1 < 2 ^ b\n  2 ^ b - 1 < 2 ^ p - 1", "show False"], ["proof (prove)\nusing this:\n  2 ^ b - 1 = 1 \\<or> 2 ^ b - 1 = 2 ^ p - 1\n  2 ^ 1 < 2 ^ b\n  2 ^ b - 1 < 2 ^ p - 1\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma p_odd: \"odd p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odd p", "using p_prime p_gt_2 prime_odd_nat"], ["proof (prove)\nusing this:\n  prime p\n  2 < p\n  \\<lbrakk>prime ?p; 2 < ?p\\<rbrakk> \\<Longrightarrow> odd ?p\n\ngoal (1 subgoal):\n 1. odd p", "by auto"], ["", "text \\<open>\n  We now first show a few more properties of Mersenne primes regarding congruences\n  and the Legendre symbol.\n\\<close>"], ["", "lemma M_cong_7_mod_12: \"[M = 7] (mod 12)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [M = 7] (mod 12)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [M = 7] (mod 12)", "have \"[M = 8 - 1] (mod 12)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [M = 8 - 1] (mod 12)", "using p_gt_2 p_odd"], ["proof (prove)\nusing this:\n  2 < p\n  odd p\n\ngoal (1 subgoal):\n 1. [M = 8 - 1] (mod 12)", "unfolding M_def"], ["proof (prove)\nusing this:\n  2 < p\n  odd p\n\ngoal (1 subgoal):\n 1. [2 ^ p - 1 = 8 - 1] (mod 12)", "by (intro cong_diff_nat two_power_odd_mod_12) auto"], ["proof (state)\nthis:\n  [M = 8 - 1] (mod 12)\n\ngoal (1 subgoal):\n 1. [M = 7] (mod 12)", "thus \"[M = 7] (mod 12)\""], ["proof (prove)\nusing this:\n  [M = 8 - 1] (mod 12)\n\ngoal (1 subgoal):\n 1. [M = 7] (mod 12)", "by simp"], ["proof (state)\nthis:\n  [M = 7] (mod 12)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Legendre_3_M: \"Legendre 3 M = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Legendre 3 (int M) = - 1", "using prime M_cong_7_mod_12"], ["proof (prove)\nusing this:\n  prime M\n  [M = 7] (mod 12)\n\ngoal (1 subgoal):\n 1. Legendre 3 (int M) = - 1", "by (subst Legendre_3_left) (auto simp: cong_def)"], ["", "lemma M_cong_7_mod_8: \"[M = 7] (mod 8)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [M = 7] (mod 8)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [M = 7] (mod 8)", "have \"2 ^ 3 dvd (2 ^ p :: int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ 3 dvd 2 ^ p", "using p_gt_2"], ["proof (prove)\nusing this:\n  2 < p\n\ngoal (1 subgoal):\n 1. 2 ^ 3 dvd 2 ^ p", "by (intro le_imp_power_dvd) auto"], ["proof (state)\nthis:\n  2 ^ 3 dvd 2 ^ p\n\ngoal (1 subgoal):\n 1. [M = 7] (mod 8)", "hence \"[2 ^ p - 1 = 0 - 1] (mod (8 :: int))\""], ["proof (prove)\nusing this:\n  2 ^ 3 dvd 2 ^ p\n\ngoal (1 subgoal):\n 1. [2 ^ p - 1 = 0 - 1] (mod 8)", "by (intro cong_diff) (auto simp: cong_def)"], ["proof (state)\nthis:\n  [2 ^ p - 1 = 0 - 1] (mod 8)\n\ngoal (1 subgoal):\n 1. [M = 7] (mod 8)", "also"], ["proof (state)\nthis:\n  [2 ^ p - 1 = 0 - 1] (mod 8)\n\ngoal (1 subgoal):\n 1. [M = 7] (mod 8)", "have \"2 ^ p - 1 = int M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ p - 1 = int M", "by (simp add: M_def of_nat_diff)"], ["proof (state)\nthis:\n  2 ^ p - 1 = int M\n\ngoal (1 subgoal):\n 1. [M = 7] (mod 8)", "finally"], ["proof (chain)\npicking this:\n  [int M = 0 - 1] (mod 8)", "have \"int M mod int 8 = 7\""], ["proof (prove)\nusing this:\n  [int M = 0 - 1] (mod 8)\n\ngoal (1 subgoal):\n 1. int M mod int 8 = 7", "by (simp add: cong_def)"], ["proof (state)\nthis:\n  int M mod int 8 = 7\n\ngoal (1 subgoal):\n 1. [M = 7] (mod 8)", "thus \"[M = 7] (mod 8)\""], ["proof (prove)\nusing this:\n  int M mod int 8 = 7\n\ngoal (1 subgoal):\n 1. [M = 7] (mod 8)", "by (subst (asm) zmod_int [symmetric]) (auto simp: cong_def)"], ["proof (state)\nthis:\n  [M = 7] (mod 8)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Legendre_2_M: \"Legendre 2 M = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Legendre 2 (int M) = 1", "using prime M_gt_6 M_cong_7_mod_8"], ["proof (prove)\nusing this:\n  prime M\n  6 < M\n  [M = 7] (mod 8)\n\ngoal (1 subgoal):\n 1. Legendre 2 (int M) = 1", "by (subst supplement2_Legendre') (auto simp: cong_def nat_mod_as_int)"], ["", "lemma M_not_dvd_24: \"\\<not>M dvd 24\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> M dvd 24", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. M dvd 24 \\<Longrightarrow> False", "assume \"M dvd 24\""], ["proof (state)\nthis:\n  M dvd 24\n\ngoal (1 subgoal):\n 1. M dvd 24 \\<Longrightarrow> False", "hence \"M dvd 2 * 2 * 2 * 3\""], ["proof (prove)\nusing this:\n  M dvd 24\n\ngoal (1 subgoal):\n 1. M dvd 2 * 2 * 2 * 3", "by simp"], ["proof (state)\nthis:\n  M dvd 2 * 2 * 2 * 3\n\ngoal (1 subgoal):\n 1. M dvd 24 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  M dvd 2 * 2 * 2 * 3\n\ngoal (1 subgoal):\n 1. M dvd 24 \\<Longrightarrow> False", "have \"?this \\<longleftrightarrow> M dvd 2 \\<or> M dvd 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M dvd 2 * 2 * 2 * 3) = (M dvd 2 \\<or> M dvd 3)", "using prime"], ["proof (prove)\nusing this:\n  prime M\n\ngoal (1 subgoal):\n 1. (M dvd 2 * 2 * 2 * 3) = (M dvd 2 \\<or> M dvd 3)", "by (simp only: prime_dvd_mult_iff) auto"], ["proof (state)\nthis:\n  (M dvd 2 * 2 * 2 * 3) = (M dvd 2 \\<or> M dvd 3)\n\ngoal (1 subgoal):\n 1. M dvd 24 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  M dvd 2 \\<or> M dvd 3", "show False"], ["proof (prove)\nusing this:\n  M dvd 2 \\<or> M dvd 3\n\ngoal (1 subgoal):\n 1. False", "using M_gt_6"], ["proof (prove)\nusing this:\n  M dvd 2 \\<or> M dvd 3\n  6 < M\n\ngoal (1 subgoal):\n 1. False", "by (auto dest: dvd_imp_le)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>The Lucas--Lehmer sequence\\<close>"], ["", "text \\<open>\n  We now define the Lucas--Lehmer sequence $a_{n+1} = a_n ^ 2 - 2$. The starting value\n  we will always use is $a_0 = 4$.\n\\<close>"], ["", "primrec gen_lucas_lehmer_sequence :: \"int \\<Rightarrow> nat \\<Rightarrow> int\" where\n  \"gen_lucas_lehmer_sequence a 0 = a\"\n| \"gen_lucas_lehmer_sequence a (Suc n) = gen_lucas_lehmer_sequence a n ^ 2 - 2\""], ["", "lemma gen_lucas_lehmer_sequence_Suc':\n  \"gen_lucas_lehmer_sequence a (Suc n) = gen_lucas_lehmer_sequence (a ^ 2 - 2) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_lucas_lehmer_sequence a (Suc n) =\n    gen_lucas_lehmer_sequence (a\\<^sup>2 - 2) n", "by (induction n arbitrary: a) auto"], ["", "lemmas gen_lucas_lehmer_code [code] =\n  gen_lucas_lehmer_sequence.simps(1) gen_lucas_lehmer_sequence_Suc'"], ["", "text \\<open>\n  For $a_0 = 4$, the recurrence has the closed form $a_{4,n} = \\omega^{2^n} + \\bar\\omega^{2^n}$\n  with $\\omega = 2 + \\sqrt{3}$ and $\\bar\\omega = 2 - \\sqrt{3}$.\n\\<close>"], ["", "lemma gen_lucas_lehmer_sequence_4_closed_form1:\n  \"real_of_int (gen_lucas_lehmer_sequence 4 n) = (2 + sqrt 3) ^ (2 ^ n) + (2 - sqrt 3) ^ (2 ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (gen_lucas_lehmer_sequence 4 n) =\n    (2 + sqrt 3) ^ 2 ^ n + (2 - sqrt 3) ^ 2 ^ n", "by (induction n)\n     (auto simp: algebra_simps power2_eq_square power_mult simp flip: power_mult_distrib)"], ["", "lemma gen_lucas_lehmer_sequence_4_closed_form2:\n  \"gen_lucas_lehmer_sequence 4 n = round ((2 + sqrt 3) ^ (2 ^ n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_lucas_lehmer_sequence 4 n = round ((2 + sqrt 3) ^ 2 ^ n)", "proof (rule sym, rule round_unique')"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>(2 + sqrt 3) ^ 2 ^ n -\n          real_of_int (gen_lucas_lehmer_sequence 4 n)\\<bar>\n    < 1 / 2", "have \"5 / 3 < sqrt (3 :: real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 5 / 3 < sqrt 3", "by (rule real_less_rsqrt) (auto simp: power2_eq_square)"], ["proof (state)\nthis:\n  5 / 3 < sqrt 3\n\ngoal (1 subgoal):\n 1. \\<bar>(2 + sqrt 3) ^ 2 ^ n -\n          real_of_int (gen_lucas_lehmer_sequence 4 n)\\<bar>\n    < 1 / 2", "hence \"(2 - sqrt 3) ^ (2 ^ n) < (1 / 3) ^ (2 ^ n)\""], ["proof (prove)\nusing this:\n  5 / 3 < sqrt 3\n\ngoal (1 subgoal):\n 1. (2 - sqrt 3) ^ 2 ^ n < (1 / 3) ^ 2 ^ n", "by (intro power_strict_mono) (auto simp: real_le_lsqrt)"], ["proof (state)\nthis:\n  (2 - sqrt 3) ^ 2 ^ n < (1 / 3) ^ 2 ^ n\n\ngoal (1 subgoal):\n 1. \\<bar>(2 + sqrt 3) ^ 2 ^ n -\n          real_of_int (gen_lucas_lehmer_sequence 4 n)\\<bar>\n    < 1 / 2", "also"], ["proof (state)\nthis:\n  (2 - sqrt 3) ^ 2 ^ n < (1 / 3) ^ 2 ^ n\n\ngoal (1 subgoal):\n 1. \\<bar>(2 + sqrt 3) ^ 2 ^ n -\n          real_of_int (gen_lucas_lehmer_sequence 4 n)\\<bar>\n    < 1 / 2", "have \"\\<dots> \\<le> (1 / 3) ^ 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 / 3) ^ 2 ^ n \\<le> (1 / 3) ^ 1", "by (intro power_decreasing) auto"], ["proof (state)\nthis:\n  (1 / 3) ^ 2 ^ n \\<le> (1 / 3) ^ 1\n\ngoal (1 subgoal):\n 1. \\<bar>(2 + sqrt 3) ^ 2 ^ n -\n          real_of_int (gen_lucas_lehmer_sequence 4 n)\\<bar>\n    < 1 / 2", "finally"], ["proof (chain)\npicking this:\n  (2 - sqrt 3) ^ 2 ^ n < (1 / 3) ^ 1", "have \"(2 - sqrt 3) ^ (2 ^ n) < 1 / 2\""], ["proof (prove)\nusing this:\n  (2 - sqrt 3) ^ 2 ^ n < (1 / 3) ^ 1\n\ngoal (1 subgoal):\n 1. (2 - sqrt 3) ^ 2 ^ n < 1 / 2", "by simp"], ["proof (state)\nthis:\n  (2 - sqrt 3) ^ 2 ^ n < 1 / 2\n\ngoal (1 subgoal):\n 1. \\<bar>(2 + sqrt 3) ^ 2 ^ n -\n          real_of_int (gen_lucas_lehmer_sequence 4 n)\\<bar>\n    < 1 / 2", "moreover"], ["proof (state)\nthis:\n  (2 - sqrt 3) ^ 2 ^ n < 1 / 2\n\ngoal (1 subgoal):\n 1. \\<bar>(2 + sqrt 3) ^ 2 ^ n -\n          real_of_int (gen_lucas_lehmer_sequence 4 n)\\<bar>\n    < 1 / 2", "have \"(2 - sqrt 3) ^ (2 ^ n) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (2 - sqrt 3) ^ 2 ^ n", "by (intro zero_le_power) (auto simp: real_le_lsqrt)"], ["proof (state)\nthis:\n  0 \\<le> (2 - sqrt 3) ^ 2 ^ n\n\ngoal (1 subgoal):\n 1. \\<bar>(2 + sqrt 3) ^ 2 ^ n -\n          real_of_int (gen_lucas_lehmer_sequence 4 n)\\<bar>\n    < 1 / 2", "ultimately"], ["proof (chain)\npicking this:\n  (2 - sqrt 3) ^ 2 ^ n < 1 / 2\n  0 \\<le> (2 - sqrt 3) ^ 2 ^ n", "show \"\\<bar>(2 + sqrt 3) ^ 2 ^ n - real_of_int (gen_lucas_lehmer_sequence 4 n)\\<bar> < 1 / 2\""], ["proof (prove)\nusing this:\n  (2 - sqrt 3) ^ 2 ^ n < 1 / 2\n  0 \\<le> (2 - sqrt 3) ^ 2 ^ n\n\ngoal (1 subgoal):\n 1. \\<bar>(2 + sqrt 3) ^ 2 ^ n -\n          real_of_int (gen_lucas_lehmer_sequence 4 n)\\<bar>\n    < 1 / 2", "unfolding gen_lucas_lehmer_sequence_4_closed_form1"], ["proof (prove)\nusing this:\n  (2 - sqrt 3) ^ 2 ^ n < 1 / 2\n  0 \\<le> (2 - sqrt 3) ^ 2 ^ n\n\ngoal (1 subgoal):\n 1. \\<bar>(2 + sqrt 3) ^ 2 ^ n -\n          ((2 + sqrt 3) ^ 2 ^ n + (2 - sqrt 3) ^ 2 ^ n)\\<bar>\n    < 1 / 2", "by linarith"], ["proof (state)\nthis:\n  \\<bar>(2 + sqrt 3) ^ 2 ^ n -\n        real_of_int (gen_lucas_lehmer_sequence 4 n)\\<bar>\n  < 1 / 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gen_lucas_lehmer_sequence_4_closed_form3:\n  \"gen_lucas_lehmer_sequence 4 n = \\<lceil>(2 + sqrt 3) ^ (2 ^ n)\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_lucas_lehmer_sequence 4 n = \\<lceil>(2 + sqrt 3) ^ 2 ^ n\\<rceil>", "proof (rule sym, rule ceiling_unique)"], ["proof (state)\ngoal (2 subgoals):\n 1. real_of_int (gen_lucas_lehmer_sequence 4 n) - 1 < (2 + sqrt 3) ^ 2 ^ n\n 2. (2 + sqrt 3) ^ 2 ^ n \\<le> real_of_int (gen_lucas_lehmer_sequence 4 n)", "show \"real_of_int (gen_lucas_lehmer_sequence 4 n) \\<ge> (2 + sqrt 3) ^ 2 ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 + sqrt 3) ^ 2 ^ n \\<le> real_of_int (gen_lucas_lehmer_sequence 4 n)", "unfolding gen_lucas_lehmer_sequence_4_closed_form1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 + sqrt 3) ^ 2 ^ n \\<le> (2 + sqrt 3) ^ 2 ^ n + (2 - sqrt 3) ^ 2 ^ n", "by (auto intro!: zero_le_power real_le_lsqrt)"], ["proof (state)\nthis:\n  (2 + sqrt 3) ^ 2 ^ n \\<le> real_of_int (gen_lucas_lehmer_sequence 4 n)\n\ngoal (1 subgoal):\n 1. real_of_int (gen_lucas_lehmer_sequence 4 n) - 1 < (2 + sqrt 3) ^ 2 ^ n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int (gen_lucas_lehmer_sequence 4 n) - 1 < (2 + sqrt 3) ^ 2 ^ n", "have \"5 / 3 < sqrt (3 :: real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 5 / 3 < sqrt 3", "by (rule real_less_rsqrt) (auto simp: power2_eq_square)"], ["proof (state)\nthis:\n  5 / 3 < sqrt 3\n\ngoal (1 subgoal):\n 1. real_of_int (gen_lucas_lehmer_sequence 4 n) - 1 < (2 + sqrt 3) ^ 2 ^ n", "hence \"(2 - sqrt 3) ^ (2 ^ n) < (1 / 3) ^ (2 ^ n)\""], ["proof (prove)\nusing this:\n  5 / 3 < sqrt 3\n\ngoal (1 subgoal):\n 1. (2 - sqrt 3) ^ 2 ^ n < (1 / 3) ^ 2 ^ n", "by (intro power_strict_mono) (auto simp: real_le_lsqrt)"], ["proof (state)\nthis:\n  (2 - sqrt 3) ^ 2 ^ n < (1 / 3) ^ 2 ^ n\n\ngoal (1 subgoal):\n 1. real_of_int (gen_lucas_lehmer_sequence 4 n) - 1 < (2 + sqrt 3) ^ 2 ^ n", "also"], ["proof (state)\nthis:\n  (2 - sqrt 3) ^ 2 ^ n < (1 / 3) ^ 2 ^ n\n\ngoal (1 subgoal):\n 1. real_of_int (gen_lucas_lehmer_sequence 4 n) - 1 < (2 + sqrt 3) ^ 2 ^ n", "have \"\\<dots> \\<le> (1 / 3) ^ 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 / 3) ^ 2 ^ n \\<le> (1 / 3) ^ 1", "by (intro power_decreasing) auto"], ["proof (state)\nthis:\n  (1 / 3) ^ 2 ^ n \\<le> (1 / 3) ^ 1\n\ngoal (1 subgoal):\n 1. real_of_int (gen_lucas_lehmer_sequence 4 n) - 1 < (2 + sqrt 3) ^ 2 ^ n", "finally"], ["proof (chain)\npicking this:\n  (2 - sqrt 3) ^ 2 ^ n < (1 / 3) ^ 1", "have \"(2 - sqrt 3) ^ (2 ^ n) < 1 / 2\""], ["proof (prove)\nusing this:\n  (2 - sqrt 3) ^ 2 ^ n < (1 / 3) ^ 1\n\ngoal (1 subgoal):\n 1. (2 - sqrt 3) ^ 2 ^ n < 1 / 2", "by simp"], ["proof (state)\nthis:\n  (2 - sqrt 3) ^ 2 ^ n < 1 / 2\n\ngoal (1 subgoal):\n 1. real_of_int (gen_lucas_lehmer_sequence 4 n) - 1 < (2 + sqrt 3) ^ 2 ^ n", "moreover"], ["proof (state)\nthis:\n  (2 - sqrt 3) ^ 2 ^ n < 1 / 2\n\ngoal (1 subgoal):\n 1. real_of_int (gen_lucas_lehmer_sequence 4 n) - 1 < (2 + sqrt 3) ^ 2 ^ n", "have \"(2 - sqrt 3) ^ (2 ^ n) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (2 - sqrt 3) ^ 2 ^ n", "by (intro zero_le_power) (auto simp: real_le_lsqrt)"], ["proof (state)\nthis:\n  0 \\<le> (2 - sqrt 3) ^ 2 ^ n\n\ngoal (1 subgoal):\n 1. real_of_int (gen_lucas_lehmer_sequence 4 n) - 1 < (2 + sqrt 3) ^ 2 ^ n", "ultimately"], ["proof (chain)\npicking this:\n  (2 - sqrt 3) ^ 2 ^ n < 1 / 2\n  0 \\<le> (2 - sqrt 3) ^ 2 ^ n", "show \"real_of_int (gen_lucas_lehmer_sequence 4 n) - 1 < (2 + sqrt 3) ^ 2 ^ n\""], ["proof (prove)\nusing this:\n  (2 - sqrt 3) ^ 2 ^ n < 1 / 2\n  0 \\<le> (2 - sqrt 3) ^ 2 ^ n\n\ngoal (1 subgoal):\n 1. real_of_int (gen_lucas_lehmer_sequence 4 n) - 1 < (2 + sqrt 3) ^ 2 ^ n", "unfolding gen_lucas_lehmer_sequence_4_closed_form1"], ["proof (prove)\nusing this:\n  (2 - sqrt 3) ^ 2 ^ n < 1 / 2\n  0 \\<le> (2 - sqrt 3) ^ 2 ^ n\n\ngoal (1 subgoal):\n 1. (2 + sqrt 3) ^ 2 ^ n + (2 - sqrt 3) ^ 2 ^ n - 1 < (2 + sqrt 3) ^ 2 ^ n", "by linarith"], ["proof (state)\nthis:\n  real_of_int (gen_lucas_lehmer_sequence 4 n) - 1 < (2 + sqrt 3) ^ 2 ^ n\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The ring $\\mathbb{Z}[\\sqrt{3}]$\\<close>"], ["", "text \\<open>\n  To relate this sequence to Mersenne primes, we now first need to define the ring\n  $\\mathbb{Z}[\\sqrt{3}]$, which is a subring of $\\mathbb{R}$. This ring can be seen as the\n  lattice on $\\mathbb{R}$ that is freely generated by $1$ and $\\sqrt{3}$.\n\n  It is, however, more convenient to explicitly describe it as a ring structure over the \n  set $\\mathbb{Z}\\times\\mathbb{Z}$ with a corresponding injective homomorphism\n  $\\mathbb{Z}\\times\\mathbb{Z} \\to \\mathbb{R}$.\n\\<close>"], ["", "definition lucas_lehmer_add' :: \"int \\<times> int \\<Rightarrow> int \\<times> int \\<Rightarrow> int \\<times> int\" where\n  \"lucas_lehmer_add' = (\\<lambda>(a,b) (c,d). (a + c, b + d))\""], ["", "definition lucas_lehmer_mult' :: \"int \\<times> int \\<Rightarrow> int \\<times> int \\<Rightarrow> int \\<times> int\" where\n  \"lucas_lehmer_mult' = (\\<lambda>(a,b) (c,d). (a * c + 3 * b * d, a * d + b * c))\""], ["", "definition lucas_lehmer_ring :: \"(int \\<times> int) ring\" where\n  \"lucas_lehmer_ring =\n     \\<lparr>carrier = UNIV,\n      monoid.mult = lucas_lehmer_mult',\n      one = (1, 0),\n      ring.zero = (0, 0),\n      add = lucas_lehmer_add'\\<rparr>\""], ["", "lemma carrier_lucas_lehmer_ring [simp]: \"carrier lucas_lehmer_ring = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. carrier lucas_lehmer_ring = UNIV", "by (simp add: lucas_lehmer_ring_def)"], ["", "lemma cring_lucas_lehmer_ring [intro]: \"cring (lucas_lehmer_ring)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cring lucas_lehmer_ring", "proof"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier (add_monoid lucas_lehmer_ring);\n        y \\<in> carrier (add_monoid lucas_lehmer_ring)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub>\n                         y\n                         \\<in> carrier (add_monoid lucas_lehmer_ring)\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier (add_monoid lucas_lehmer_ring);\n        y \\<in> carrier (add_monoid lucas_lehmer_ring);\n        z \\<in> carrier (add_monoid lucas_lehmer_ring)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub>\n                         y \\<otimes>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub>\n                         (y \\<otimes>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub>\n                          z)\n 3. \\<one>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub>\n    \\<in> carrier (add_monoid lucas_lehmer_ring)\n 4. \\<And>x.\n       x \\<in> carrier (add_monoid lucas_lehmer_ring) \\<Longrightarrow>\n       \\<one>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub> \\<otimes>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub>\n       x =\n       x\n 5. \\<And>x.\n       x \\<in> carrier (add_monoid lucas_lehmer_ring) \\<Longrightarrow>\n       x \\<otimes>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub>\n       \\<one>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub> =\n       x\n 6. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier (add_monoid lucas_lehmer_ring);\n        y \\<in> carrier (add_monoid lucas_lehmer_ring)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub>\n                         y =\n                         y \\<otimes>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub>\n                         x\n 7. carrier (add_monoid lucas_lehmer_ring)\n    \\<subseteq> Units (add_monoid lucas_lehmer_ring)\n 8. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier lucas_lehmer_ring;\n        y \\<in> carrier lucas_lehmer_ring\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>lucas_lehmer_ring\\<^esub> y\n                         \\<in> carrier lucas_lehmer_ring\n 9. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier lucas_lehmer_ring;\n        y \\<in> carrier lucas_lehmer_ring;\n        z \\<in> carrier lucas_lehmer_ring\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>lucas_lehmer_ring\\<^esub>\n                         y \\<otimes>\\<^bsub>lucas_lehmer_ring\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>lucas_lehmer_ring\\<^esub>\n                         (y \\<otimes>\\<^bsub>lucas_lehmer_ring\\<^esub> z)\n 10. \\<one>\\<^bsub>lucas_lehmer_ring\\<^esub> \\<in> carrier lucas_lehmer_ring\nA total of 15 subgoals...", "have \"\\<exists>aa ba. lucas_lehmer_add' (aa, ba) (a, b) = (0, 0) \\<and>\n                lucas_lehmer_add' (a, b) (aa, ba) = (0, 0)\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>aa ba.\n       lucas_lehmer_add' (aa, ba) (a, b) = (0, 0) \\<and>\n       lucas_lehmer_add' (a, b) (aa, ba) = (0, 0)", "by (rule exI[of _ \"-a\"], rule exI[of _ \"-b\"]) (auto simp: lucas_lehmer_add'_def)"], ["proof (state)\nthis:\n  \\<exists>aa ba.\n     lucas_lehmer_add' (aa, ba) (?a, ?b) = (0, 0) \\<and>\n     lucas_lehmer_add' (?a, ?b) (aa, ba) = (0, 0)\n\ngoal (15 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier (add_monoid lucas_lehmer_ring);\n        y \\<in> carrier (add_monoid lucas_lehmer_ring)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub>\n                         y\n                         \\<in> carrier (add_monoid lucas_lehmer_ring)\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier (add_monoid lucas_lehmer_ring);\n        y \\<in> carrier (add_monoid lucas_lehmer_ring);\n        z \\<in> carrier (add_monoid lucas_lehmer_ring)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub>\n                         y \\<otimes>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub>\n                         (y \\<otimes>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub>\n                          z)\n 3. \\<one>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub>\n    \\<in> carrier (add_monoid lucas_lehmer_ring)\n 4. \\<And>x.\n       x \\<in> carrier (add_monoid lucas_lehmer_ring) \\<Longrightarrow>\n       \\<one>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub> \\<otimes>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub>\n       x =\n       x\n 5. \\<And>x.\n       x \\<in> carrier (add_monoid lucas_lehmer_ring) \\<Longrightarrow>\n       x \\<otimes>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub>\n       \\<one>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub> =\n       x\n 6. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier (add_monoid lucas_lehmer_ring);\n        y \\<in> carrier (add_monoid lucas_lehmer_ring)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub>\n                         y =\n                         y \\<otimes>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub>\n                         x\n 7. carrier (add_monoid lucas_lehmer_ring)\n    \\<subseteq> Units (add_monoid lucas_lehmer_ring)\n 8. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier lucas_lehmer_ring;\n        y \\<in> carrier lucas_lehmer_ring\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>lucas_lehmer_ring\\<^esub> y\n                         \\<in> carrier lucas_lehmer_ring\n 9. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier lucas_lehmer_ring;\n        y \\<in> carrier lucas_lehmer_ring;\n        z \\<in> carrier lucas_lehmer_ring\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>lucas_lehmer_ring\\<^esub>\n                         y \\<otimes>\\<^bsub>lucas_lehmer_ring\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>lucas_lehmer_ring\\<^esub>\n                         (y \\<otimes>\\<^bsub>lucas_lehmer_ring\\<^esub> z)\n 10. \\<one>\\<^bsub>lucas_lehmer_ring\\<^esub> \\<in> carrier lucas_lehmer_ring\nA total of 15 subgoals...", "thus \"carrier (add_monoid lucas_lehmer_ring) \\<subseteq> Units (add_monoid lucas_lehmer_ring)\""], ["proof (prove)\nusing this:\n  \\<exists>aa ba.\n     lucas_lehmer_add' (aa, ba) (?a, ?b) = (0, 0) \\<and>\n     lucas_lehmer_add' (?a, ?b) (aa, ba) = (0, 0)\n\ngoal (1 subgoal):\n 1. carrier (add_monoid lucas_lehmer_ring)\n    \\<subseteq> Units (add_monoid lucas_lehmer_ring)", "by (auto simp: Units_def lucas_lehmer_ring_def)"], ["proof (state)\nthis:\n  carrier (add_monoid lucas_lehmer_ring)\n  \\<subseteq> Units (add_monoid lucas_lehmer_ring)\n\ngoal (14 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier (add_monoid lucas_lehmer_ring);\n        y \\<in> carrier (add_monoid lucas_lehmer_ring)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub>\n                         y\n                         \\<in> carrier (add_monoid lucas_lehmer_ring)\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier (add_monoid lucas_lehmer_ring);\n        y \\<in> carrier (add_monoid lucas_lehmer_ring);\n        z \\<in> carrier (add_monoid lucas_lehmer_ring)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub>\n                         y \\<otimes>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub>\n                         (y \\<otimes>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub>\n                          z)\n 3. \\<one>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub>\n    \\<in> carrier (add_monoid lucas_lehmer_ring)\n 4. \\<And>x.\n       x \\<in> carrier (add_monoid lucas_lehmer_ring) \\<Longrightarrow>\n       \\<one>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub> \\<otimes>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub>\n       x =\n       x\n 5. \\<And>x.\n       x \\<in> carrier (add_monoid lucas_lehmer_ring) \\<Longrightarrow>\n       x \\<otimes>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub>\n       \\<one>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub> =\n       x\n 6. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier (add_monoid lucas_lehmer_ring);\n        y \\<in> carrier (add_monoid lucas_lehmer_ring)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub>\n                         y =\n                         y \\<otimes>\\<^bsub>add_monoid lucas_lehmer_ring\\<^esub>\n                         x\n 7. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier lucas_lehmer_ring;\n        y \\<in> carrier lucas_lehmer_ring\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>lucas_lehmer_ring\\<^esub> y\n                         \\<in> carrier lucas_lehmer_ring\n 8. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier lucas_lehmer_ring;\n        y \\<in> carrier lucas_lehmer_ring;\n        z \\<in> carrier lucas_lehmer_ring\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>lucas_lehmer_ring\\<^esub>\n                         y \\<otimes>\\<^bsub>lucas_lehmer_ring\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>lucas_lehmer_ring\\<^esub>\n                         (y \\<otimes>\\<^bsub>lucas_lehmer_ring\\<^esub> z)\n 9. \\<one>\\<^bsub>lucas_lehmer_ring\\<^esub> \\<in> carrier lucas_lehmer_ring\n 10. \\<And>x.\n        x \\<in> carrier lucas_lehmer_ring \\<Longrightarrow>\n        \\<one>\\<^bsub>lucas_lehmer_ring\\<^esub> \\<otimes>\\<^bsub>lucas_lehmer_ring\\<^esub>\n        x =\n        x\nA total of 14 subgoals...", "qed (auto simp: lucas_lehmer_ring_def lucas_lehmer_add'_def lucas_lehmer_mult'_def algebra_simps)"], ["", "subsection \\<open>The ring $(\\mathbb{Z}/m\\mathbb{Z})[\\sqrt{3}]$\\<close>"], ["", "text \\<open>\n  We shall also need the ring $(\\mathbb{Z}/m\\mathbb{Z})[\\sqrt{3}]$, which is obtained from\n  $\\mathbb{Z}[\\sqrt{3}]$ by reducing each component separately modulo $m$. This essentially\n  identifies any two points that are a multiple of $m$ apart and then all those that are\n  a multiple of $m\\sqrt{3}$ apart.\n\\<close>"], ["", "definition lucas_lehmer_mult :: \"nat \\<Rightarrow> nat \\<times> nat \\<Rightarrow> nat \\<times> nat \\<Rightarrow> nat \\<times> nat\" where\n  \"lucas_lehmer_mult m = (\\<lambda>(a,b) (c,d). ((a * c + 3 * b * d) mod m, (a * d + b * c) mod m))\""], ["", "definition lucas_lehmer_add :: \"nat \\<Rightarrow> nat \\<times> nat \\<Rightarrow> nat \\<times> nat \\<Rightarrow> nat \\<times> nat\" where\n  \"lucas_lehmer_add m = (\\<lambda>(a,b) (c,d). ((a + c) mod m, (b + d) mod m))\""], ["", "definition lucas_lehmer_ring_mod :: \"nat \\<Rightarrow> (nat \\<times> nat) ring\" where\n  \"lucas_lehmer_ring_mod m =\n     \\<lparr>carrier = {..<m} \\<times> {..<m},\n      monoid.mult = lucas_lehmer_mult m,\n      one = (1, 0),\n      ring.zero = (0, 0),\n      add = lucas_lehmer_add m\\<rparr>\""], ["", "lemma lucas_lehmer_add_in_carrier: \"m > 0 \\<Longrightarrow> lucas_lehmer_add m x y \\<in> {..<m} \\<times> {..<m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m \\<Longrightarrow>\n    lucas_lehmer_add m x y \\<in> {..<m} \\<times> {..<m}", "by (auto simp: lucas_lehmer_add_def split: prod.splits)"], ["", "lemma lucas_lehmer_mult_in_carrier: \"m > 0 \\<Longrightarrow> lucas_lehmer_mult m x y \\<in> {..<m} \\<times> {..<m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m \\<Longrightarrow>\n    lucas_lehmer_mult m x y \\<in> {..<m} \\<times> {..<m}", "by (auto simp: lucas_lehmer_mult_def split: prod.splits)"], ["", "lemma lucas_lehmer_add_cong:\n  \"[fst (lucas_lehmer_add m x y) = fst x + fst y] (mod m)\"\n  \"[snd (lucas_lehmer_add m x y) = snd x + snd y] (mod m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [fst (lucas_lehmer_add m x y) = fst x + fst y] (mod m) &&&\n    [snd (lucas_lehmer_add m x y) = snd x + snd y] (mod m)", "by (simp_all add: lucas_lehmer_add_def cong_def case_prod_unfold)"], ["", "lemma lucas_lehmer_mult_cong:\n  \"[fst (lucas_lehmer_mult m x y) = fst x * fst y + 3 * snd x * snd y] (mod m)\"\n  \"[snd (lucas_lehmer_mult m x y) = fst x * snd y + snd x * fst y] (mod m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [fst (lucas_lehmer_mult m x\n           y) = fst x * fst y + 3 * snd x * snd y] (mod m) &&&\n    [snd (lucas_lehmer_mult m x y) = fst x * snd y + snd x * fst y] (mod m)", "by (simp_all add: lucas_lehmer_mult_def cong_def case_prod_unfold)"], ["", "lemma lucas_lehmer_add_neutral [simp]:\n  assumes \"fst x < m\" \"snd x < m\"\n  shows   \"lucas_lehmer_add m (0, 0) x = x\"\n    and   \"lucas_lehmer_add m x (0, 0) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_add m (0, 0) x = x &&& lucas_lehmer_add m x (0, 0) = x", "using assms"], ["proof (prove)\nusing this:\n  fst x < m\n  snd x < m\n\ngoal (1 subgoal):\n 1. lucas_lehmer_add m (0, 0) x = x &&& lucas_lehmer_add m x (0, 0) = x", "by (auto simp: lucas_lehmer_add_def case_prod_unfold)"], ["", "lemma lucas_lehmer_mult_neutral [simp]:\n  assumes \"fst x < m\" \"snd x < m\"\n  shows   \"lucas_lehmer_mult m (Suc 0, 0) x = x\"\n    and   \"lucas_lehmer_mult m x (Suc 0, 0) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_mult m (Suc 0, 0) x = x &&&\n    lucas_lehmer_mult m x (Suc 0, 0) = x", "using assms"], ["proof (prove)\nusing this:\n  fst x < m\n  snd x < m\n\ngoal (1 subgoal):\n 1. lucas_lehmer_mult m (Suc 0, 0) x = x &&&\n    lucas_lehmer_mult m x (Suc 0, 0) = x", "by (auto simp: lucas_lehmer_mult_def case_prod_unfold)"], ["", "lemma lucas_lehmer_add_commute: \"lucas_lehmer_add m x y = lucas_lehmer_add m y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_add m x y = lucas_lehmer_add m y x", "by (simp add: lucas_lehmer_add_def algebra_simps case_prod_unfold)"], ["", "lemma lucas_lehmer_mult_commute: \"lucas_lehmer_mult m x y = lucas_lehmer_mult m y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_mult m x y = lucas_lehmer_mult m y x", "by (simp add: lucas_lehmer_mult_def algebra_simps case_prod_unfold)"], ["", "lemma lucas_lehmer_add_assoc:\n  assumes m: \"m > 0\"\n  shows   \"lucas_lehmer_add m x (lucas_lehmer_add m y z) =\n           lucas_lehmer_add m (lucas_lehmer_add m x y) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_add m x (lucas_lehmer_add m y z) =\n    lucas_lehmer_add m (lucas_lehmer_add m x y) z", "proof (rule prod_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_add m x (lucas_lehmer_add m y z)) =\n    fst (lucas_lehmer_add m (lucas_lehmer_add m x y) z)\n 2. snd (lucas_lehmer_add m x (lucas_lehmer_add m y z)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_add m x y) z)", "let ?add = \"lucas_lehmer_add m\""], ["proof (state)\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_add m x (lucas_lehmer_add m y z)) =\n    fst (lucas_lehmer_add m (lucas_lehmer_add m x y) z)\n 2. snd (lucas_lehmer_add m x (lucas_lehmer_add m y z)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_add m x y) z)", "have \"[fst (?add x (?add y z)) = fst x + (fst y + fst z)] (mod m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [fst (lucas_lehmer_add m x\n           (lucas_lehmer_add m y z)) = fst x + (fst y + fst z)] (mod m)", "by (rule lucas_lehmer_add_cong[THEN cong_trans] cong_add cong_mult cong_refl)+"], ["proof (state)\nthis:\n  [fst (lucas_lehmer_add m x\n         (lucas_lehmer_add m y z)) = fst x + (fst y + fst z)] (mod m)\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_add m x (lucas_lehmer_add m y z)) =\n    fst (lucas_lehmer_add m (lucas_lehmer_add m x y) z)\n 2. snd (lucas_lehmer_add m x (lucas_lehmer_add m y z)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_add m x y) z)", "also"], ["proof (state)\nthis:\n  [fst (lucas_lehmer_add m x\n         (lucas_lehmer_add m y z)) = fst x + (fst y + fst z)] (mod m)\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_add m x (lucas_lehmer_add m y z)) =\n    fst (lucas_lehmer_add m (lucas_lehmer_add m x y) z)\n 2. snd (lucas_lehmer_add m x (lucas_lehmer_add m y z)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_add m x y) z)", "have \"fst x + (fst y + fst z) = (fst x + fst y) + fst z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst x + (fst y + fst z) = fst x + fst y + fst z", "by (simp add: add_ac)"], ["proof (state)\nthis:\n  fst x + (fst y + fst z) = fst x + fst y + fst z\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_add m x (lucas_lehmer_add m y z)) =\n    fst (lucas_lehmer_add m (lucas_lehmer_add m x y) z)\n 2. snd (lucas_lehmer_add m x (lucas_lehmer_add m y z)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_add m x y) z)", "also"], ["proof (state)\nthis:\n  fst x + (fst y + fst z) = fst x + fst y + fst z\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_add m x (lucas_lehmer_add m y z)) =\n    fst (lucas_lehmer_add m (lucas_lehmer_add m x y) z)\n 2. snd (lucas_lehmer_add m x (lucas_lehmer_add m y z)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_add m x y) z)", "have \"[\\<dots> = fst (?add (?add x y) z)] (mod m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [fst x + fst y +\n     fst z = fst (lucas_lehmer_add m (lucas_lehmer_add m x y) z)] (mod m)", "by (rule cong_sym, (rule lucas_lehmer_add_cong[THEN cong_trans] cong_add cong_mult cong_refl)+)"], ["proof (state)\nthis:\n  [fst x + fst y +\n   fst z = fst (lucas_lehmer_add m (lucas_lehmer_add m x y) z)] (mod m)\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_add m x (lucas_lehmer_add m y z)) =\n    fst (lucas_lehmer_add m (lucas_lehmer_add m x y) z)\n 2. snd (lucas_lehmer_add m x (lucas_lehmer_add m y z)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_add m x y) z)", "finally"], ["proof (chain)\npicking this:\n  [fst (lucas_lehmer_add m x\n         (lucas_lehmer_add m y\n           z)) = fst (lucas_lehmer_add m (lucas_lehmer_add m x y)\n                       z)] (mod m)", "show \"fst (?add x (?add y z)) = fst (?add (?add x y) z)\""], ["proof (prove)\nusing this:\n  [fst (lucas_lehmer_add m x\n         (lucas_lehmer_add m y\n           z)) = fst (lucas_lehmer_add m (lucas_lehmer_add m x y)\n                       z)] (mod m)\n\ngoal (1 subgoal):\n 1. fst (lucas_lehmer_add m x (lucas_lehmer_add m y z)) =\n    fst (lucas_lehmer_add m (lucas_lehmer_add m x y) z)", "by (rule cong_less_modulus_unique_nat)\n       (use m in \\<open>auto simp: lucas_lehmer_add_def case_prod_unfold\\<close>)"], ["proof (state)\nthis:\n  fst (lucas_lehmer_add m x (lucas_lehmer_add m y z)) =\n  fst (lucas_lehmer_add m (lucas_lehmer_add m x y) z)\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_add m x (lucas_lehmer_add m y z)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_add m x y) z)", "have \"[snd (?add x (?add y z)) = snd x + (snd y + snd z)] (mod m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [snd (lucas_lehmer_add m x\n           (lucas_lehmer_add m y z)) = snd x + (snd y + snd z)] (mod m)", "by (rule lucas_lehmer_add_cong[THEN cong_trans] cong_add cong_mult cong_refl)+"], ["proof (state)\nthis:\n  [snd (lucas_lehmer_add m x\n         (lucas_lehmer_add m y z)) = snd x + (snd y + snd z)] (mod m)\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_add m x (lucas_lehmer_add m y z)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_add m x y) z)", "also"], ["proof (state)\nthis:\n  [snd (lucas_lehmer_add m x\n         (lucas_lehmer_add m y z)) = snd x + (snd y + snd z)] (mod m)\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_add m x (lucas_lehmer_add m y z)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_add m x y) z)", "have \"snd x + (snd y + snd z) = (snd x + snd y) + snd z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd x + (snd y + snd z) = snd x + snd y + snd z", "by (simp add: add_ac)"], ["proof (state)\nthis:\n  snd x + (snd y + snd z) = snd x + snd y + snd z\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_add m x (lucas_lehmer_add m y z)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_add m x y) z)", "also"], ["proof (state)\nthis:\n  snd x + (snd y + snd z) = snd x + snd y + snd z\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_add m x (lucas_lehmer_add m y z)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_add m x y) z)", "have \"[\\<dots> = snd (?add (?add x y) z)] (mod m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [snd x + snd y +\n     snd z = snd (lucas_lehmer_add m (lucas_lehmer_add m x y) z)] (mod m)", "by (rule cong_sym, (rule lucas_lehmer_add_cong[THEN cong_trans] cong_add cong_mult cong_refl)+)"], ["proof (state)\nthis:\n  [snd x + snd y +\n   snd z = snd (lucas_lehmer_add m (lucas_lehmer_add m x y) z)] (mod m)\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_add m x (lucas_lehmer_add m y z)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_add m x y) z)", "finally"], ["proof (chain)\npicking this:\n  [snd (lucas_lehmer_add m x\n         (lucas_lehmer_add m y\n           z)) = snd (lucas_lehmer_add m (lucas_lehmer_add m x y)\n                       z)] (mod m)", "show \"snd (?add x (?add y z)) = snd (?add (?add x y) z)\""], ["proof (prove)\nusing this:\n  [snd (lucas_lehmer_add m x\n         (lucas_lehmer_add m y\n           z)) = snd (lucas_lehmer_add m (lucas_lehmer_add m x y)\n                       z)] (mod m)\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_add m x (lucas_lehmer_add m y z)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_add m x y) z)", "by (rule cong_less_modulus_unique_nat)\n       (use m in \\<open>auto simp: lucas_lehmer_add_def case_prod_unfold\\<close>)"], ["proof (state)\nthis:\n  snd (lucas_lehmer_add m x (lucas_lehmer_add m y z)) =\n  snd (lucas_lehmer_add m (lucas_lehmer_add m x y) z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lucas_lehmer_mult_assoc:\n  assumes m: \"m > 0\"\n  shows   \"lucas_lehmer_mult m x (lucas_lehmer_mult m y z) =\n           lucas_lehmer_mult m (lucas_lehmer_mult m x y) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_mult m x (lucas_lehmer_mult m y z) =\n    lucas_lehmer_mult m (lucas_lehmer_mult m x y) z", "proof (rule prod_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_mult m x (lucas_lehmer_mult m y z)) =\n    fst (lucas_lehmer_mult m (lucas_lehmer_mult m x y) z)\n 2. snd (lucas_lehmer_mult m x (lucas_lehmer_mult m y z)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_mult m x y) z)", "let ?mul = \"lucas_lehmer_mult m\""], ["proof (state)\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_mult m x (lucas_lehmer_mult m y z)) =\n    fst (lucas_lehmer_mult m (lucas_lehmer_mult m x y) z)\n 2. snd (lucas_lehmer_mult m x (lucas_lehmer_mult m y z)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_mult m x y) z)", "have \"[fst (?mul x (?mul y z)) = fst x * (fst y * fst z + 3 * snd y * snd z) +\n           3 * snd x * (fst y * snd z + snd y * fst z)] (mod m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [fst (lucas_lehmer_mult m x\n           (lucas_lehmer_mult m y\n             z)) = fst x * (fst y * fst z + 3 * snd y * snd z) +\n                   3 * snd x * (fst y * snd z + snd y * fst z)] (mod m)", "by (rule lucas_lehmer_mult_cong[THEN cong_trans] cong_add cong_mult cong_refl)+"], ["proof (state)\nthis:\n  [fst (lucas_lehmer_mult m x\n         (lucas_lehmer_mult m y\n           z)) = fst x * (fst y * fst z + 3 * snd y * snd z) +\n                 3 * snd x * (fst y * snd z + snd y * fst z)] (mod m)\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_mult m x (lucas_lehmer_mult m y z)) =\n    fst (lucas_lehmer_mult m (lucas_lehmer_mult m x y) z)\n 2. snd (lucas_lehmer_mult m x (lucas_lehmer_mult m y z)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_mult m x y) z)", "also"], ["proof (state)\nthis:\n  [fst (lucas_lehmer_mult m x\n         (lucas_lehmer_mult m y\n           z)) = fst x * (fst y * fst z + 3 * snd y * snd z) +\n                 3 * snd x * (fst y * snd z + snd y * fst z)] (mod m)\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_mult m x (lucas_lehmer_mult m y z)) =\n    fst (lucas_lehmer_mult m (lucas_lehmer_mult m x y) z)\n 2. snd (lucas_lehmer_mult m x (lucas_lehmer_mult m y z)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_mult m x y) z)", "have \"fst x * (fst y * fst z + 3 * snd y * snd z) +\n               3 * snd x * (fst y * snd z + snd y * fst z) =\n             (fst x * fst y + 3 * snd x * snd y) * fst z +\n               3 * (fst x * snd y + snd x * fst y) * snd z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst x * (fst y * fst z + 3 * snd y * snd z) +\n    3 * snd x * (fst y * snd z + snd y * fst z) =\n    (fst x * fst y + 3 * snd x * snd y) * fst z +\n    3 * (fst x * snd y + snd x * fst y) * snd z", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  fst x * (fst y * fst z + 3 * snd y * snd z) +\n  3 * snd x * (fst y * snd z + snd y * fst z) =\n  (fst x * fst y + 3 * snd x * snd y) * fst z +\n  3 * (fst x * snd y + snd x * fst y) * snd z\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_mult m x (lucas_lehmer_mult m y z)) =\n    fst (lucas_lehmer_mult m (lucas_lehmer_mult m x y) z)\n 2. snd (lucas_lehmer_mult m x (lucas_lehmer_mult m y z)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_mult m x y) z)", "also"], ["proof (state)\nthis:\n  fst x * (fst y * fst z + 3 * snd y * snd z) +\n  3 * snd x * (fst y * snd z + snd y * fst z) =\n  (fst x * fst y + 3 * snd x * snd y) * fst z +\n  3 * (fst x * snd y + snd x * fst y) * snd z\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_mult m x (lucas_lehmer_mult m y z)) =\n    fst (lucas_lehmer_mult m (lucas_lehmer_mult m x y) z)\n 2. snd (lucas_lehmer_mult m x (lucas_lehmer_mult m y z)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_mult m x y) z)", "have \"[\\<dots> = fst (?mul (?mul x y) z)] (mod m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(fst x * fst y + 3 * snd x * snd y) * fst z +\n     3 * (fst x * snd y + snd x * fst y) *\n     snd z = fst (lucas_lehmer_mult m (lucas_lehmer_mult m x y) z)] (mod m)", "by (rule cong_sym, (rule lucas_lehmer_mult_cong[THEN cong_trans] cong_add cong_mult cong_refl)+)"], ["proof (state)\nthis:\n  [(fst x * fst y + 3 * snd x * snd y) * fst z +\n   3 * (fst x * snd y + snd x * fst y) *\n   snd z = fst (lucas_lehmer_mult m (lucas_lehmer_mult m x y) z)] (mod m)\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_mult m x (lucas_lehmer_mult m y z)) =\n    fst (lucas_lehmer_mult m (lucas_lehmer_mult m x y) z)\n 2. snd (lucas_lehmer_mult m x (lucas_lehmer_mult m y z)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_mult m x y) z)", "finally"], ["proof (chain)\npicking this:\n  [fst (lucas_lehmer_mult m x\n         (lucas_lehmer_mult m y\n           z)) = fst (lucas_lehmer_mult m (lucas_lehmer_mult m x y)\n                       z)] (mod m)", "show \"fst (?mul x (?mul y z)) = fst (?mul (?mul x y) z)\""], ["proof (prove)\nusing this:\n  [fst (lucas_lehmer_mult m x\n         (lucas_lehmer_mult m y\n           z)) = fst (lucas_lehmer_mult m (lucas_lehmer_mult m x y)\n                       z)] (mod m)\n\ngoal (1 subgoal):\n 1. fst (lucas_lehmer_mult m x (lucas_lehmer_mult m y z)) =\n    fst (lucas_lehmer_mult m (lucas_lehmer_mult m x y) z)", "by (rule cong_less_modulus_unique_nat)\n       (use m in \\<open>auto simp: lucas_lehmer_mult_def case_prod_unfold\\<close>)"], ["proof (state)\nthis:\n  fst (lucas_lehmer_mult m x (lucas_lehmer_mult m y z)) =\n  fst (lucas_lehmer_mult m (lucas_lehmer_mult m x y) z)\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_mult m x (lucas_lehmer_mult m y z)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_mult m x y) z)", "have \"[snd (?mul x (?mul y z)) = fst x * (fst y * snd z + snd y * fst z) +\n     snd x * (fst y * fst z + 3 * snd y * snd z)] (mod m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [snd (lucas_lehmer_mult m x\n           (lucas_lehmer_mult m y\n             z)) = fst x * (fst y * snd z + snd y * fst z) +\n                   snd x * (fst y * fst z + 3 * snd y * snd z)] (mod m)", "by (rule lucas_lehmer_mult_cong[THEN cong_trans] cong_add cong_mult cong_refl)+"], ["proof (state)\nthis:\n  [snd (lucas_lehmer_mult m x\n         (lucas_lehmer_mult m y\n           z)) = fst x * (fst y * snd z + snd y * fst z) +\n                 snd x * (fst y * fst z + 3 * snd y * snd z)] (mod m)\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_mult m x (lucas_lehmer_mult m y z)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_mult m x y) z)", "also"], ["proof (state)\nthis:\n  [snd (lucas_lehmer_mult m x\n         (lucas_lehmer_mult m y\n           z)) = fst x * (fst y * snd z + snd y * fst z) +\n                 snd x * (fst y * fst z + 3 * snd y * snd z)] (mod m)\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_mult m x (lucas_lehmer_mult m y z)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_mult m x y) z)", "have \"fst x * (fst y * snd z + snd y * fst z) + snd x * (fst y * fst z + 3 * snd y * snd z) =\n             (fst x * fst y + 3 * snd x * snd y) * snd z + (fst x * snd y + snd x * fst y) * fst z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst x * (fst y * snd z + snd y * fst z) +\n    snd x * (fst y * fst z + 3 * snd y * snd z) =\n    (fst x * fst y + 3 * snd x * snd y) * snd z +\n    (fst x * snd y + snd x * fst y) * fst z", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  fst x * (fst y * snd z + snd y * fst z) +\n  snd x * (fst y * fst z + 3 * snd y * snd z) =\n  (fst x * fst y + 3 * snd x * snd y) * snd z +\n  (fst x * snd y + snd x * fst y) * fst z\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_mult m x (lucas_lehmer_mult m y z)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_mult m x y) z)", "also"], ["proof (state)\nthis:\n  fst x * (fst y * snd z + snd y * fst z) +\n  snd x * (fst y * fst z + 3 * snd y * snd z) =\n  (fst x * fst y + 3 * snd x * snd y) * snd z +\n  (fst x * snd y + snd x * fst y) * fst z\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_mult m x (lucas_lehmer_mult m y z)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_mult m x y) z)", "have \"[\\<dots> = snd (?mul (?mul x y) z)] (mod m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(fst x * fst y + 3 * snd x * snd y) * snd z +\n     (fst x * snd y + snd x * fst y) *\n     fst z = snd (lucas_lehmer_mult m (lucas_lehmer_mult m x y) z)] (mod m)", "by (rule cong_sym, (rule lucas_lehmer_mult_cong[THEN cong_trans] cong_add cong_mult cong_refl)+)"], ["proof (state)\nthis:\n  [(fst x * fst y + 3 * snd x * snd y) * snd z +\n   (fst x * snd y + snd x * fst y) *\n   fst z = snd (lucas_lehmer_mult m (lucas_lehmer_mult m x y) z)] (mod m)\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_mult m x (lucas_lehmer_mult m y z)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_mult m x y) z)", "finally"], ["proof (chain)\npicking this:\n  [snd (lucas_lehmer_mult m x\n         (lucas_lehmer_mult m y\n           z)) = snd (lucas_lehmer_mult m (lucas_lehmer_mult m x y)\n                       z)] (mod m)", "show \"snd (?mul x (?mul y z)) = snd (?mul (?mul x y) z)\""], ["proof (prove)\nusing this:\n  [snd (lucas_lehmer_mult m x\n         (lucas_lehmer_mult m y\n           z)) = snd (lucas_lehmer_mult m (lucas_lehmer_mult m x y)\n                       z)] (mod m)\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_mult m x (lucas_lehmer_mult m y z)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_mult m x y) z)", "by (rule cong_less_modulus_unique_nat)\n       (use m in \\<open>auto simp: lucas_lehmer_mult_def case_prod_unfold\\<close>)"], ["proof (state)\nthis:\n  snd (lucas_lehmer_mult m x (lucas_lehmer_mult m y z)) =\n  snd (lucas_lehmer_mult m (lucas_lehmer_mult m x y) z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lucas_lehmer_distrib_right:\n  assumes m: \"m > 1\"\n  shows \"lucas_lehmer_mult m (lucas_lehmer_add m x y) z =\n         lucas_lehmer_add m (lucas_lehmer_mult m x z) (lucas_lehmer_mult m y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_mult m (lucas_lehmer_add m x y) z =\n    lucas_lehmer_add m (lucas_lehmer_mult m x z) (lucas_lehmer_mult m y z)", "proof (rule prod_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_mult m (lucas_lehmer_add m x y) z) =\n    fst (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n          (lucas_lehmer_mult m y z))\n 2. snd (lucas_lehmer_mult m (lucas_lehmer_add m x y) z) =\n    snd (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n          (lucas_lehmer_mult m y z))", "let ?mul = \"lucas_lehmer_mult m\" and ?add = \"lucas_lehmer_add m\""], ["proof (state)\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_mult m (lucas_lehmer_add m x y) z) =\n    fst (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n          (lucas_lehmer_mult m y z))\n 2. snd (lucas_lehmer_mult m (lucas_lehmer_add m x y) z) =\n    snd (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n          (lucas_lehmer_mult m y z))", "have \"[fst (?mul (?add x y) z) = (fst x + fst y) * fst z + 3 * (snd x + snd y) * snd z] (mod m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [fst (lucas_lehmer_mult m (lucas_lehmer_add m x y)\n           z) = (fst x + fst y) * fst z +\n                3 * (snd x + snd y) * snd z] (mod m)", "by (rule lucas_lehmer_mult_cong[THEN cong_trans] lucas_lehmer_add_cong[THEN cong_trans]\n             cong_add cong_mult cong_refl)+"], ["proof (state)\nthis:\n  [fst (lucas_lehmer_mult m (lucas_lehmer_add m x y)\n         z) = (fst x + fst y) * fst z + 3 * (snd x + snd y) * snd z] (mod m)\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_mult m (lucas_lehmer_add m x y) z) =\n    fst (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n          (lucas_lehmer_mult m y z))\n 2. snd (lucas_lehmer_mult m (lucas_lehmer_add m x y) z) =\n    snd (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n          (lucas_lehmer_mult m y z))", "also"], ["proof (state)\nthis:\n  [fst (lucas_lehmer_mult m (lucas_lehmer_add m x y)\n         z) = (fst x + fst y) * fst z + 3 * (snd x + snd y) * snd z] (mod m)\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_mult m (lucas_lehmer_add m x y) z) =\n    fst (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n          (lucas_lehmer_mult m y z))\n 2. snd (lucas_lehmer_mult m (lucas_lehmer_add m x y) z) =\n    snd (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n          (lucas_lehmer_mult m y z))", "have \"(fst x + fst y) * fst z + 3 * (snd x + snd y) * snd z =\n               (fst x * fst z + 3 * snd x * snd z) + (fst y * fst z + 3 * snd y * snd z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst x + fst y) * fst z + 3 * (snd x + snd y) * snd z =\n    fst x * fst z + 3 * snd x * snd z + (fst y * fst z + 3 * snd y * snd z)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (fst x + fst y) * fst z + 3 * (snd x + snd y) * snd z =\n  fst x * fst z + 3 * snd x * snd z + (fst y * fst z + 3 * snd y * snd z)\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_mult m (lucas_lehmer_add m x y) z) =\n    fst (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n          (lucas_lehmer_mult m y z))\n 2. snd (lucas_lehmer_mult m (lucas_lehmer_add m x y) z) =\n    snd (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n          (lucas_lehmer_mult m y z))", "also"], ["proof (state)\nthis:\n  (fst x + fst y) * fst z + 3 * (snd x + snd y) * snd z =\n  fst x * fst z + 3 * snd x * snd z + (fst y * fst z + 3 * snd y * snd z)\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_mult m (lucas_lehmer_add m x y) z) =\n    fst (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n          (lucas_lehmer_mult m y z))\n 2. snd (lucas_lehmer_mult m (lucas_lehmer_add m x y) z) =\n    snd (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n          (lucas_lehmer_mult m y z))", "have \"[\\<dots> = fst (?add (?mul x z) (?mul y z))] (mod m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [fst x * fst z + 3 * snd x * snd z +\n     (fst y * fst z +\n      3 * snd y *\n      snd z) = fst (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n                     (lucas_lehmer_mult m y z))] (mod m)", "by (rule cong_sym, (rule lucas_lehmer_mult_cong[THEN cong_trans]\n          lucas_lehmer_add_cong[THEN cong_trans] cong_add cong_mult cong_refl)+)"], ["proof (state)\nthis:\n  [fst x * fst z + 3 * snd x * snd z +\n   (fst y * fst z +\n    3 * snd y *\n    snd z) = fst (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n                   (lucas_lehmer_mult m y z))] (mod m)\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_mult m (lucas_lehmer_add m x y) z) =\n    fst (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n          (lucas_lehmer_mult m y z))\n 2. snd (lucas_lehmer_mult m (lucas_lehmer_add m x y) z) =\n    snd (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n          (lucas_lehmer_mult m y z))", "finally"], ["proof (chain)\npicking this:\n  [fst (lucas_lehmer_mult m (lucas_lehmer_add m x y)\n         z) = fst (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n                    (lucas_lehmer_mult m y z))] (mod m)", "show \"fst (?mul (?add x y) z) = fst (?add (?mul x z) (?mul y z))\""], ["proof (prove)\nusing this:\n  [fst (lucas_lehmer_mult m (lucas_lehmer_add m x y)\n         z) = fst (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n                    (lucas_lehmer_mult m y z))] (mod m)\n\ngoal (1 subgoal):\n 1. fst (lucas_lehmer_mult m (lucas_lehmer_add m x y) z) =\n    fst (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n          (lucas_lehmer_mult m y z))", "by (rule cong_less_modulus_unique_nat)\n       (use m in \\<open>auto simp: lucas_lehmer_add_def lucas_lehmer_mult_def case_prod_unfold\\<close>)"], ["proof (state)\nthis:\n  fst (lucas_lehmer_mult m (lucas_lehmer_add m x y) z) =\n  fst (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n        (lucas_lehmer_mult m y z))\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_mult m (lucas_lehmer_add m x y) z) =\n    snd (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n          (lucas_lehmer_mult m y z))", "have \"[snd (?mul (?add x y) z) = (fst x + fst y) * snd z + (snd x + snd y) * fst z] (mod m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [snd (lucas_lehmer_mult m (lucas_lehmer_add m x y)\n           z) = (fst x + fst y) * snd z + (snd x + snd y) * fst z] (mod m)", "by (rule lucas_lehmer_mult_cong[THEN cong_trans] lucas_lehmer_add_cong[THEN cong_trans]\n             cong_add cong_mult cong_refl)+"], ["proof (state)\nthis:\n  [snd (lucas_lehmer_mult m (lucas_lehmer_add m x y)\n         z) = (fst x + fst y) * snd z + (snd x + snd y) * fst z] (mod m)\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_mult m (lucas_lehmer_add m x y) z) =\n    snd (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n          (lucas_lehmer_mult m y z))", "also"], ["proof (state)\nthis:\n  [snd (lucas_lehmer_mult m (lucas_lehmer_add m x y)\n         z) = (fst x + fst y) * snd z + (snd x + snd y) * fst z] (mod m)\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_mult m (lucas_lehmer_add m x y) z) =\n    snd (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n          (lucas_lehmer_mult m y z))", "have \"(fst x + fst y) * snd z + (snd x + snd y) * fst z =\n               (fst x * snd z + snd x * fst z) + (fst y * snd z + snd y * fst z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst x + fst y) * snd z + (snd x + snd y) * fst z =\n    fst x * snd z + snd x * fst z + (fst y * snd z + snd y * fst z)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (fst x + fst y) * snd z + (snd x + snd y) * fst z =\n  fst x * snd z + snd x * fst z + (fst y * snd z + snd y * fst z)\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_mult m (lucas_lehmer_add m x y) z) =\n    snd (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n          (lucas_lehmer_mult m y z))", "also"], ["proof (state)\nthis:\n  (fst x + fst y) * snd z + (snd x + snd y) * fst z =\n  fst x * snd z + snd x * fst z + (fst y * snd z + snd y * fst z)\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_mult m (lucas_lehmer_add m x y) z) =\n    snd (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n          (lucas_lehmer_mult m y z))", "have \"[\\<dots> = snd (?add (?mul x z) (?mul y z))] (mod m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [fst x * snd z + snd x * fst z +\n     (fst y * snd z +\n      snd y *\n      fst z) = snd (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n                     (lucas_lehmer_mult m y z))] (mod m)", "by (rule cong_sym, (rule lucas_lehmer_mult_cong[THEN cong_trans]\n          lucas_lehmer_add_cong[THEN cong_trans] cong_add cong_mult cong_refl)+)"], ["proof (state)\nthis:\n  [fst x * snd z + snd x * fst z +\n   (fst y * snd z +\n    snd y *\n    fst z) = snd (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n                   (lucas_lehmer_mult m y z))] (mod m)\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_mult m (lucas_lehmer_add m x y) z) =\n    snd (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n          (lucas_lehmer_mult m y z))", "finally"], ["proof (chain)\npicking this:\n  [snd (lucas_lehmer_mult m (lucas_lehmer_add m x y)\n         z) = snd (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n                    (lucas_lehmer_mult m y z))] (mod m)", "show \"snd (?mul (?add x y) z) = snd (?add (?mul x z) (?mul y z))\""], ["proof (prove)\nusing this:\n  [snd (lucas_lehmer_mult m (lucas_lehmer_add m x y)\n         z) = snd (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n                    (lucas_lehmer_mult m y z))] (mod m)\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_mult m (lucas_lehmer_add m x y) z) =\n    snd (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n          (lucas_lehmer_mult m y z))", "by (rule cong_less_modulus_unique_nat)\n       (use m in \\<open>auto simp: lucas_lehmer_add_def lucas_lehmer_mult_def case_prod_unfold\\<close>)"], ["proof (state)\nthis:\n  snd (lucas_lehmer_mult m (lucas_lehmer_add m x y) z) =\n  snd (lucas_lehmer_add m (lucas_lehmer_mult m x z)\n        (lucas_lehmer_mult m y z))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lucas_lehmer_distrib_left:\n  assumes \"m > 1\"\n  shows \"lucas_lehmer_mult m z (lucas_lehmer_add m x y) =\n         lucas_lehmer_add m (lucas_lehmer_mult m z x) (lucas_lehmer_mult m z y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_mult m z (lucas_lehmer_add m x y) =\n    lucas_lehmer_add m (lucas_lehmer_mult m z x) (lucas_lehmer_mult m z y)", "using lucas_lehmer_distrib_right[of m x y z] assms"], ["proof (prove)\nusing this:\n  1 < m \\<Longrightarrow>\n  lucas_lehmer_mult m (lucas_lehmer_add m x y) z =\n  lucas_lehmer_add m (lucas_lehmer_mult m x z) (lucas_lehmer_mult m y z)\n  1 < m\n\ngoal (1 subgoal):\n 1. lucas_lehmer_mult m z (lucas_lehmer_add m x y) =\n    lucas_lehmer_add m (lucas_lehmer_mult m z x) (lucas_lehmer_mult m z y)", "by (simp add: lucas_lehmer_mult_commute)"], ["", "lemma cring_lucas_lehmer_ring_mod [intro]:\n  assumes \"m > 1\"\n  shows   \"cring (lucas_lehmer_ring_mod m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cring (lucas_lehmer_ring_mod m)", "proof unfold_locales"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m));\n        y \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m))\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n                         y\n                         \\<in> carrier\n                                (add_monoid (lucas_lehmer_ring_mod m))\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m));\n        y \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m));\n        z \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m))\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n                         y \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n                         (y \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n                          z)\n 3. \\<one>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n    \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m))\n 4. \\<And>x.\n       x \\<in> carrier\n                (add_monoid (lucas_lehmer_ring_mod m)) \\<Longrightarrow>\n       \\<one>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub> \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n       x =\n       x\n 5. \\<And>x.\n       x \\<in> carrier\n                (add_monoid (lucas_lehmer_ring_mod m)) \\<Longrightarrow>\n       x \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n       \\<one>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub> =\n       x\n 6. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m));\n        y \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m))\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n                         y =\n                         y \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n                         x\n 7. carrier (add_monoid (lucas_lehmer_ring_mod m))\n    \\<subseteq> Units (add_monoid (lucas_lehmer_ring_mod m))\n 8. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier (lucas_lehmer_ring_mod m);\n        y \\<in> carrier (lucas_lehmer_ring_mod m)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n                         y\n                         \\<in> carrier (lucas_lehmer_ring_mod m)\n 9. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier (lucas_lehmer_ring_mod m);\n        y \\<in> carrier (lucas_lehmer_ring_mod m);\n        z \\<in> carrier (lucas_lehmer_ring_mod m)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n                         y \\<otimes>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n                         (y \\<otimes>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n                          z)\n 10. \\<one>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n     \\<in> carrier (lucas_lehmer_ring_mod m)\nA total of 15 subgoals...", "let ?neg = \"\\<lambda>x. if x = 0 then 0 else m - x\""], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m));\n        y \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m))\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n                         y\n                         \\<in> carrier\n                                (add_monoid (lucas_lehmer_ring_mod m))\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m));\n        y \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m));\n        z \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m))\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n                         y \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n                         (y \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n                          z)\n 3. \\<one>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n    \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m))\n 4. \\<And>x.\n       x \\<in> carrier\n                (add_monoid (lucas_lehmer_ring_mod m)) \\<Longrightarrow>\n       \\<one>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub> \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n       x =\n       x\n 5. \\<And>x.\n       x \\<in> carrier\n                (add_monoid (lucas_lehmer_ring_mod m)) \\<Longrightarrow>\n       x \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n       \\<one>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub> =\n       x\n 6. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m));\n        y \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m))\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n                         y =\n                         y \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n                         x\n 7. carrier (add_monoid (lucas_lehmer_ring_mod m))\n    \\<subseteq> Units (add_monoid (lucas_lehmer_ring_mod m))\n 8. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier (lucas_lehmer_ring_mod m);\n        y \\<in> carrier (lucas_lehmer_ring_mod m)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n                         y\n                         \\<in> carrier (lucas_lehmer_ring_mod m)\n 9. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier (lucas_lehmer_ring_mod m);\n        y \\<in> carrier (lucas_lehmer_ring_mod m);\n        z \\<in> carrier (lucas_lehmer_ring_mod m)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n                         y \\<otimes>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n                         (y \\<otimes>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n                          z)\n 10. \\<one>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n     \\<in> carrier (lucas_lehmer_ring_mod m)\nA total of 15 subgoals...", "have \"\\<exists>x\\<in>carrier (lucas_lehmer_ring_mod m).\n           x \\<oplus>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub> (a, b) = \\<zero>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub> \\<and>\n           (a, b) \\<oplus>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub> x = \\<zero>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\"\n    if \"(a, b) \\<in> carrier (lucas_lehmer_ring_mod m)\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>carrier (lucas_lehmer_ring_mod m).\n       x \\<oplus>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub> (a, b) =\n       \\<zero>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub> \\<and>\n       (a, b) \\<oplus>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub> x =\n       \\<zero>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>", "using that assms"], ["proof (prove)\nusing this:\n  (a, b) \\<in> carrier (lucas_lehmer_ring_mod m)\n  1 < m\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>carrier (lucas_lehmer_ring_mod m).\n       x \\<oplus>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub> (a, b) =\n       \\<zero>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub> \\<and>\n       (a, b) \\<oplus>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub> x =\n       \\<zero>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>", "by (intro bexI[of _ \"(?neg a, ?neg b)\"])\n       (auto simp: lucas_lehmer_ring_mod_def lucas_lehmer_add_def)"], ["proof (state)\nthis:\n  (?a, ?b) \\<in> carrier (lucas_lehmer_ring_mod m) \\<Longrightarrow>\n  \\<exists>x\\<in>carrier (lucas_lehmer_ring_mod m).\n     x \\<oplus>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub> (?a, ?b) =\n     \\<zero>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub> \\<and>\n     (?a, ?b) \\<oplus>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub> x =\n     \\<zero>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n\ngoal (15 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m));\n        y \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m))\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n                         y\n                         \\<in> carrier\n                                (add_monoid (lucas_lehmer_ring_mod m))\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m));\n        y \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m));\n        z \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m))\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n                         y \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n                         (y \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n                          z)\n 3. \\<one>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n    \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m))\n 4. \\<And>x.\n       x \\<in> carrier\n                (add_monoid (lucas_lehmer_ring_mod m)) \\<Longrightarrow>\n       \\<one>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub> \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n       x =\n       x\n 5. \\<And>x.\n       x \\<in> carrier\n                (add_monoid (lucas_lehmer_ring_mod m)) \\<Longrightarrow>\n       x \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n       \\<one>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub> =\n       x\n 6. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m));\n        y \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m))\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n                         y =\n                         y \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n                         x\n 7. carrier (add_monoid (lucas_lehmer_ring_mod m))\n    \\<subseteq> Units (add_monoid (lucas_lehmer_ring_mod m))\n 8. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier (lucas_lehmer_ring_mod m);\n        y \\<in> carrier (lucas_lehmer_ring_mod m)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n                         y\n                         \\<in> carrier (lucas_lehmer_ring_mod m)\n 9. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier (lucas_lehmer_ring_mod m);\n        y \\<in> carrier (lucas_lehmer_ring_mod m);\n        z \\<in> carrier (lucas_lehmer_ring_mod m)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n                         y \\<otimes>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n                         (y \\<otimes>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n                          z)\n 10. \\<one>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n     \\<in> carrier (lucas_lehmer_ring_mod m)\nA total of 15 subgoals...", "thus \"carrier (add_monoid (lucas_lehmer_ring_mod m)) \\<subseteq> Units (add_monoid (lucas_lehmer_ring_mod m))\""], ["proof (prove)\nusing this:\n  (?a, ?b) \\<in> carrier (lucas_lehmer_ring_mod m) \\<Longrightarrow>\n  \\<exists>x\\<in>carrier (lucas_lehmer_ring_mod m).\n     x \\<oplus>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub> (?a, ?b) =\n     \\<zero>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub> \\<and>\n     (?a, ?b) \\<oplus>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub> x =\n     \\<zero>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n\ngoal (1 subgoal):\n 1. carrier (add_monoid (lucas_lehmer_ring_mod m))\n    \\<subseteq> Units (add_monoid (lucas_lehmer_ring_mod m))", "by (auto simp: Units_def)"], ["proof (state)\nthis:\n  carrier (add_monoid (lucas_lehmer_ring_mod m))\n  \\<subseteq> Units (add_monoid (lucas_lehmer_ring_mod m))\n\ngoal (14 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m));\n        y \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m))\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n                         y\n                         \\<in> carrier\n                                (add_monoid (lucas_lehmer_ring_mod m))\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m));\n        y \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m));\n        z \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m))\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n                         y \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n                         (y \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n                          z)\n 3. \\<one>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n    \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m))\n 4. \\<And>x.\n       x \\<in> carrier\n                (add_monoid (lucas_lehmer_ring_mod m)) \\<Longrightarrow>\n       \\<one>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub> \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n       x =\n       x\n 5. \\<And>x.\n       x \\<in> carrier\n                (add_monoid (lucas_lehmer_ring_mod m)) \\<Longrightarrow>\n       x \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n       \\<one>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub> =\n       x\n 6. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m));\n        y \\<in> carrier (add_monoid (lucas_lehmer_ring_mod m))\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n                         y =\n                         y \\<otimes>\\<^bsub>add_monoid (lucas_lehmer_ring_mod m)\\<^esub>\n                         x\n 7. \\<And>x y.\n       \\<lbrakk>x \\<in> carrier (lucas_lehmer_ring_mod m);\n        y \\<in> carrier (lucas_lehmer_ring_mod m)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n                         y\n                         \\<in> carrier (lucas_lehmer_ring_mod m)\n 8. \\<And>x y z.\n       \\<lbrakk>x \\<in> carrier (lucas_lehmer_ring_mod m);\n        y \\<in> carrier (lucas_lehmer_ring_mod m);\n        z \\<in> carrier (lucas_lehmer_ring_mod m)\\<rbrakk>\n       \\<Longrightarrow> x \\<otimes>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n                         y \\<otimes>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n                         z =\n                         x \\<otimes>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n                         (y \\<otimes>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n                          z)\n 9. \\<one>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n    \\<in> carrier (lucas_lehmer_ring_mod m)\n 10. \\<And>x.\n        x \\<in> carrier (lucas_lehmer_ring_mod m) \\<Longrightarrow>\n        \\<one>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub> \\<otimes>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n        x =\n        x\nA total of 14 subgoals...", "qed (insert assms,\n     auto simp: lucas_lehmer_ring_mod_def algebra_simps lucas_lehmer_mult_assoc\n                lucas_lehmer_add_assoc lucas_lehmer_distrib_right lucas_lehmer_distrib_left\n          intro: lucas_lehmer_mult_in_carrier lucas_lehmer_add_in_carrier\n                 lucas_lehmer_add_commute lucas_lehmer_mult_commute)"], ["", "text \\<open>\n  Since $0$ is clearly not a unit in the ring and its carrier has size $m ^ 2$, the \n  number of units is strictly less than $m ^ 2$.\n\\<close>"], ["", "lemma card_lucas_lehmer_Units:\n  assumes \"m > 1\"\n  shows   \"card (Units (lucas_lehmer_ring_mod m)) < m ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (Units (lucas_lehmer_ring_mod m)) < m\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card (Units (lucas_lehmer_ring_mod m)) < m\\<^sup>2", "interpret cring \"lucas_lehmer_ring_mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cring (lucas_lehmer_ring_mod m)", "using assms"], ["proof (prove)\nusing this:\n  1 < m\n\ngoal (1 subgoal):\n 1. cring (lucas_lehmer_ring_mod m)", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. card (Units (lucas_lehmer_ring_mod m)) < m\\<^sup>2", "have \"m ^ 2 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < m\\<^sup>2", "using assms"], ["proof (prove)\nusing this:\n  1 < m\n\ngoal (1 subgoal):\n 1. 0 < m\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  0 < m\\<^sup>2\n\ngoal (1 subgoal):\n 1. card (Units (lucas_lehmer_ring_mod m)) < m\\<^sup>2", "from assms"], ["proof (chain)\npicking this:\n  1 < m", "have \"card (Units (lucas_lehmer_ring_mod m)) \\<le> card ({..<m} \\<times> {..<m} - {(0, 0)})\""], ["proof (prove)\nusing this:\n  1 < m\n\ngoal (1 subgoal):\n 1. card (Units (lucas_lehmer_ring_mod m))\n    \\<le> card ({..<m} \\<times> {..<m} - {(0, 0)})", "by (intro card_mono) (auto simp: Units_def lucas_lehmer_ring_mod_def lucas_lehmer_mult_def)"], ["proof (state)\nthis:\n  card (Units (lucas_lehmer_ring_mod m))\n  \\<le> card ({..<m} \\<times> {..<m} - {(0, 0)})\n\ngoal (1 subgoal):\n 1. card (Units (lucas_lehmer_ring_mod m)) < m\\<^sup>2", "also"], ["proof (state)\nthis:\n  card (Units (lucas_lehmer_ring_mod m))\n  \\<le> card ({..<m} \\<times> {..<m} - {(0, 0)})\n\ngoal (1 subgoal):\n 1. card (Units (lucas_lehmer_ring_mod m)) < m\\<^sup>2", "have \"\\<dots> = m ^ 2 - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ({..<m} \\<times> {..<m} - {(0, 0)}) = m\\<^sup>2 - 1", "using assms"], ["proof (prove)\nusing this:\n  1 < m\n\ngoal (1 subgoal):\n 1. card ({..<m} \\<times> {..<m} - {(0, 0)}) = m\\<^sup>2 - 1", "by (subst card_Diff_subset) (auto simp: power2_eq_square)"], ["proof (state)\nthis:\n  card ({..<m} \\<times> {..<m} - {(0, 0)}) = m\\<^sup>2 - 1\n\ngoal (1 subgoal):\n 1. card (Units (lucas_lehmer_ring_mod m)) < m\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  card (Units (lucas_lehmer_ring_mod m)) \\<le> m\\<^sup>2 - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  card (Units (lucas_lehmer_ring_mod m)) \\<le> m\\<^sup>2 - 1\n\ngoal (1 subgoal):\n 1. card (Units (lucas_lehmer_ring_mod m)) < m\\<^sup>2", "using \\<open>m ^ 2 > 0\\<close>"], ["proof (prove)\nusing this:\n  card (Units (lucas_lehmer_ring_mod m)) \\<le> m\\<^sup>2 - 1\n  0 < m\\<^sup>2\n\ngoal (1 subgoal):\n 1. card (Units (lucas_lehmer_ring_mod m)) < m\\<^sup>2", "by linarith"], ["proof (state)\nthis:\n  card (Units (lucas_lehmer_ring_mod m)) < m\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Consider now the case of a prime modulus $m$: Since $\\mathbb{Z}/m\\mathbb{Z} = \\text{GF}(m)$\n  is a field, any element of $\\mathbb{Z}/m\\mathbb{Z}$ is a unit in\n  $(\\mathbb{Z}/m\\mathbb{Z})[\\sqrt{3}]$.\n\\<close>"], ["", "lemma int_in_Units_lucas_lehmer_ring_mod:\n  assumes \"prime p\"\n  assumes \"x > 0\" \"x < p\"\n  shows   \"(x, 0) \\<in> Units (lucas_lehmer_ring_mod p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, 0) \\<in> Units (lucas_lehmer_ring_mod p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x, 0) \\<in> Units (lucas_lehmer_ring_mod p)", "define R where \"R = lucas_lehmer_ring_mod p\""], ["proof (state)\nthis:\n  R = lucas_lehmer_ring_mod p\n\ngoal (1 subgoal):\n 1. (x, 0) \\<in> Units (lucas_lehmer_ring_mod p)", "have \"[x * (x ^ (p - 2) mod p) = x * x ^ (p - 2)] (mod p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x * (x ^ (p - 2) mod p) = x * x ^ (p - 2)] (mod p)", "by (intro cong_mult) (auto simp: cong_def)"], ["proof (state)\nthis:\n  [x * (x ^ (p - 2) mod p) = x * x ^ (p - 2)] (mod p)\n\ngoal (1 subgoal):\n 1. (x, 0) \\<in> Units (lucas_lehmer_ring_mod p)", "also"], ["proof (state)\nthis:\n  [x * (x ^ (p - 2) mod p) = x * x ^ (p - 2)] (mod p)\n\ngoal (1 subgoal):\n 1. (x, 0) \\<in> Units (lucas_lehmer_ring_mod p)", "have \"x * x ^ (p - 2) = x ^ (Suc (p - 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * x ^ (p - 2) = x ^ Suc (p - 2)", "by (simp add: mult_ac)"], ["proof (state)\nthis:\n  x * x ^ (p - 2) = x ^ Suc (p - 2)\n\ngoal (1 subgoal):\n 1. (x, 0) \\<in> Units (lucas_lehmer_ring_mod p)", "also"], ["proof (state)\nthis:\n  x * x ^ (p - 2) = x ^ Suc (p - 2)\n\ngoal (1 subgoal):\n 1. (x, 0) \\<in> Units (lucas_lehmer_ring_mod p)", "have \"Suc (p - 2) = p - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (p - 2) = p - 1", "using prime_gt_1_nat[of p] assms"], ["proof (prove)\nusing this:\n  prime p \\<Longrightarrow> 1 < p\n  prime p\n  0 < x\n  x < p\n\ngoal (1 subgoal):\n 1. Suc (p - 2) = p - 1", "by simp"], ["proof (state)\nthis:\n  Suc (p - 2) = p - 1\n\ngoal (1 subgoal):\n 1. (x, 0) \\<in> Units (lucas_lehmer_ring_mod p)", "also"], ["proof (state)\nthis:\n  Suc (p - 2) = p - 1\n\ngoal (1 subgoal):\n 1. (x, 0) \\<in> Units (lucas_lehmer_ring_mod p)", "have \"[x ^ (p - 1) = 1] (mod p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x ^ (p - 1) = 1] (mod p)", "using assms"], ["proof (prove)\nusing this:\n  prime p\n  0 < x\n  x < p\n\ngoal (1 subgoal):\n 1. [x ^ (p - 1) = 1] (mod p)", "by (intro fermat_theorem) (auto dest: dvd_imp_le)"], ["proof (state)\nthis:\n  [x ^ (p - 1) = 1] (mod p)\n\ngoal (1 subgoal):\n 1. (x, 0) \\<in> Units (lucas_lehmer_ring_mod p)", "finally"], ["proof (chain)\npicking this:\n  [x * (x ^ (p - 2) mod p) = 1] (mod p)", "have \"(x, 0) \\<otimes>\\<^bsub>R\\<^esub> (x ^ (p - 2) mod p, 0) = \\<one>\\<^bsub>R\\<^esub>\"\n               \"(x ^ (p - 2) mod p, 0) \\<otimes>\\<^bsub>R\\<^esub> (x, 0) = \\<one>\\<^bsub>R\\<^esub>\"\n               \"(x ^ (p - 2) mod p, 0) \\<in> carrier R\""], ["proof (prove)\nusing this:\n  [x * (x ^ (p - 2) mod p) = 1] (mod p)\n\ngoal (1 subgoal):\n 1. (x, 0) \\<otimes>\\<^bsub>R\\<^esub> (x ^ (p - 2) mod p, 0) =\n    \\<one>\\<^bsub>R\\<^esub> &&&\n    (x ^ (p - 2) mod p, 0) \\<otimes>\\<^bsub>R\\<^esub> (x, 0) =\n    \\<one>\\<^bsub>R\\<^esub> &&&\n    (x ^ (p - 2) mod p, 0) \\<in> carrier R", "using prime_gt_1_nat[of p] assms"], ["proof (prove)\nusing this:\n  [x * (x ^ (p - 2) mod p) = 1] (mod p)\n  prime p \\<Longrightarrow> 1 < p\n  prime p\n  0 < x\n  x < p\n\ngoal (1 subgoal):\n 1. (x, 0) \\<otimes>\\<^bsub>R\\<^esub> (x ^ (p - 2) mod p, 0) =\n    \\<one>\\<^bsub>R\\<^esub> &&&\n    (x ^ (p - 2) mod p, 0) \\<otimes>\\<^bsub>R\\<^esub> (x, 0) =\n    \\<one>\\<^bsub>R\\<^esub> &&&\n    (x ^ (p - 2) mod p, 0) \\<in> carrier R", "by (auto simp: lucas_lehmer_mult_def cong_def lucas_lehmer_ring_mod_def mult_ac R_def)"], ["proof (state)\nthis:\n  (x, 0) \\<otimes>\\<^bsub>R\\<^esub> (x ^ (p - 2) mod p, 0) =\n  \\<one>\\<^bsub>R\\<^esub>\n  (x ^ (p - 2) mod p, 0) \\<otimes>\\<^bsub>R\\<^esub> (x, 0) =\n  \\<one>\\<^bsub>R\\<^esub>\n  (x ^ (p - 2) mod p, 0) \\<in> carrier R\n\ngoal (1 subgoal):\n 1. (x, 0) \\<in> Units (lucas_lehmer_ring_mod p)", "moreover"], ["proof (state)\nthis:\n  (x, 0) \\<otimes>\\<^bsub>R\\<^esub> (x ^ (p - 2) mod p, 0) =\n  \\<one>\\<^bsub>R\\<^esub>\n  (x ^ (p - 2) mod p, 0) \\<otimes>\\<^bsub>R\\<^esub> (x, 0) =\n  \\<one>\\<^bsub>R\\<^esub>\n  (x ^ (p - 2) mod p, 0) \\<in> carrier R\n\ngoal (1 subgoal):\n 1. (x, 0) \\<in> Units (lucas_lehmer_ring_mod p)", "from assms"], ["proof (chain)\npicking this:\n  prime p\n  0 < x\n  x < p", "have \"(x, 0) \\<in> carrier R\""], ["proof (prove)\nusing this:\n  prime p\n  0 < x\n  x < p\n\ngoal (1 subgoal):\n 1. (x, 0) \\<in> carrier R", "by (auto simp: R_def lucas_lehmer_ring_mod_def)"], ["proof (state)\nthis:\n  (x, 0) \\<in> carrier R\n\ngoal (1 subgoal):\n 1. (x, 0) \\<in> Units (lucas_lehmer_ring_mod p)", "ultimately"], ["proof (chain)\npicking this:\n  (x, 0) \\<otimes>\\<^bsub>R\\<^esub> (x ^ (p - 2) mod p, 0) =\n  \\<one>\\<^bsub>R\\<^esub>\n  (x ^ (p - 2) mod p, 0) \\<otimes>\\<^bsub>R\\<^esub> (x, 0) =\n  \\<one>\\<^bsub>R\\<^esub>\n  (x ^ (p - 2) mod p, 0) \\<in> carrier R\n  (x, 0) \\<in> carrier R", "show ?thesis"], ["proof (prove)\nusing this:\n  (x, 0) \\<otimes>\\<^bsub>R\\<^esub> (x ^ (p - 2) mod p, 0) =\n  \\<one>\\<^bsub>R\\<^esub>\n  (x ^ (p - 2) mod p, 0) \\<otimes>\\<^bsub>R\\<^esub> (x, 0) =\n  \\<one>\\<^bsub>R\\<^esub>\n  (x ^ (p - 2) mod p, 0) \\<in> carrier R\n  (x, 0) \\<in> carrier R\n\ngoal (1 subgoal):\n 1. (x, 0) \\<in> Units (lucas_lehmer_ring_mod p)", "using assms"], ["proof (prove)\nusing this:\n  (x, 0) \\<otimes>\\<^bsub>R\\<^esub> (x ^ (p - 2) mod p, 0) =\n  \\<one>\\<^bsub>R\\<^esub>\n  (x ^ (p - 2) mod p, 0) \\<otimes>\\<^bsub>R\\<^esub> (x, 0) =\n  \\<one>\\<^bsub>R\\<^esub>\n  (x ^ (p - 2) mod p, 0) \\<in> carrier R\n  (x, 0) \\<in> carrier R\n  prime p\n  0 < x\n  x < p\n\ngoal (1 subgoal):\n 1. (x, 0) \\<in> Units (lucas_lehmer_ring_mod p)", "by (auto simp: Units_def R_def)"], ["proof (state)\nthis:\n  (x, 0) \\<in> Units (lucas_lehmer_ring_mod p)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>$\\mathbb{Z}[\\sqrt{3}]$ as a subring of $\\mathbb{R}$\\<close>"], ["", "text \\<open>\n  We now define the homomorphism from $\\mathbb{Z}[\\sqrt{3}]$ into the reals:\n\\<close>"], ["", "definition lucas_lehmer_to_real :: \"int \\<times> int \\<Rightarrow> real\" where\n  \"lucas_lehmer_to_real = (\\<lambda>(a,b). real_of_int a + real_of_int b * sqrt 3)\""], ["", "context\nbegin"], ["", "interpretation cring lucas_lehmer_ring"], ["proof (prove)\ngoal (1 subgoal):\n 1. cring lucas_lehmer_ring", ".."], ["", "lemma minus_lucas_lehmer_ring: \"\\<ominus>\\<^bsub>lucas_lehmer_ring\\<^esub> x = (case x of (a, b) \\<Rightarrow> (-a, -b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<ominus>\\<^bsub>lucas_lehmer_ring\\<^esub> x =\n    (case x of (a, b) \\<Rightarrow> (- a, - b))", "by (rule sym, rule sum_zero_eq_neg)\n     (auto simp: case_prod_unfold lucas_lehmer_ring_def lucas_lehmer_add'_def)"], ["", "lemma lucas_lehmer_to_real_simps1:\n      \"lucas_lehmer_to_real (a, b) = of_int a + of_int b * sqrt 3\"\n      \"lucas_lehmer_to_real (x \\<oplus>\\<^bsub>lucas_lehmer_ring\\<^esub> y) =\n       lucas_lehmer_to_real x + lucas_lehmer_to_real y\"\n      \"lucas_lehmer_to_real (x \\<otimes>\\<^bsub>lucas_lehmer_ring\\<^esub> y) =\n       lucas_lehmer_to_real x * lucas_lehmer_to_real y\"\n      \"lucas_lehmer_to_real (\\<ominus>\\<^bsub>lucas_lehmer_ring\\<^esub> x) = -lucas_lehmer_to_real x\"\n      \"lucas_lehmer_to_real (\\<zero>\\<^bsub>lucas_lehmer_ring\\<^esub>) = 0\"\n      \"lucas_lehmer_to_real (\\<one>\\<^bsub>lucas_lehmer_ring\\<^esub>) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lucas_lehmer_to_real (a, b) =\n     real_of_int a + real_of_int b * sqrt 3 &&&\n     lucas_lehmer_to_real (x \\<oplus>\\<^bsub>lucas_lehmer_ring\\<^esub> y) =\n     lucas_lehmer_to_real x + lucas_lehmer_to_real y &&&\n     lucas_lehmer_to_real (x \\<otimes>\\<^bsub>lucas_lehmer_ring\\<^esub> y) =\n     lucas_lehmer_to_real x * lucas_lehmer_to_real y) &&&\n    lucas_lehmer_to_real (\\<ominus>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    - lucas_lehmer_to_real x &&&\n    lucas_lehmer_to_real \\<zero>\\<^bsub>lucas_lehmer_ring\\<^esub> = 0 &&&\n    lucas_lehmer_to_real \\<one>\\<^bsub>lucas_lehmer_ring\\<^esub> = 1", "using minus_lucas_lehmer_ring"], ["proof (prove)\nusing this:\n  \\<ominus>\\<^bsub>lucas_lehmer_ring\\<^esub> ?x =\n  (case ?x of (a, b) \\<Rightarrow> (- a, - b))\n\ngoal (1 subgoal):\n 1. (lucas_lehmer_to_real (a, b) =\n     real_of_int a + real_of_int b * sqrt 3 &&&\n     lucas_lehmer_to_real (x \\<oplus>\\<^bsub>lucas_lehmer_ring\\<^esub> y) =\n     lucas_lehmer_to_real x + lucas_lehmer_to_real y &&&\n     lucas_lehmer_to_real (x \\<otimes>\\<^bsub>lucas_lehmer_ring\\<^esub> y) =\n     lucas_lehmer_to_real x * lucas_lehmer_to_real y) &&&\n    lucas_lehmer_to_real (\\<ominus>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    - lucas_lehmer_to_real x &&&\n    lucas_lehmer_to_real \\<zero>\\<^bsub>lucas_lehmer_ring\\<^esub> = 0 &&&\n    lucas_lehmer_to_real \\<one>\\<^bsub>lucas_lehmer_ring\\<^esub> = 1", "by (simp_all add: lucas_lehmer_to_real_def lucas_lehmer_add'_def lucas_lehmer_mult'_def\n                    case_prod_unfold algebra_simps lucas_lehmer_ring_def)"], ["", "lemma lucas_lehmer_to_add_pow_nat:\n  \"lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) = of_nat n * lucas_lehmer_to_real x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    real n * lucas_lehmer_to_real x", "by (induction n) (auto simp: lucas_lehmer_to_real_simps1 algebra_simps)"], ["", "lemma lucas_lehmer_to_add_pow_int:\n  \"lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) = of_int n * lucas_lehmer_to_real x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    real_of_int n * lucas_lehmer_to_real x", "proof (cases \"n \\<ge> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow>\n    lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    real_of_int n * lucas_lehmer_to_real x\n 2. \\<not> 0 \\<le> n \\<Longrightarrow>\n    lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    real_of_int n * lucas_lehmer_to_real x", "case True"], ["proof (state)\nthis:\n  0 \\<le> n\n\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow>\n    lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    real_of_int n * lucas_lehmer_to_real x\n 2. \\<not> 0 \\<le> n \\<Longrightarrow>\n    lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    real_of_int n * lucas_lehmer_to_real x", "hence \"lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n         lucas_lehmer_to_real ([int (nat n)] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x)\""], ["proof (prove)\nusing this:\n  0 \\<le> n\n\ngoal (1 subgoal):\n 1. lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    lucas_lehmer_to_real\n     ([int (nat n)] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x)", "by simp"], ["proof (state)\nthis:\n  lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n  lucas_lehmer_to_real\n   ([int (nat n)] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x)\n\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow>\n    lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    real_of_int n * lucas_lehmer_to_real x\n 2. \\<not> 0 \\<le> n \\<Longrightarrow>\n    lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    real_of_int n * lucas_lehmer_to_real x", "also"], ["proof (state)\nthis:\n  lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n  lucas_lehmer_to_real\n   ([int (nat n)] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x)\n\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow>\n    lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    real_of_int n * lucas_lehmer_to_real x\n 2. \\<not> 0 \\<le> n \\<Longrightarrow>\n    lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    real_of_int n * lucas_lehmer_to_real x", "have \"\\<dots> = lucas_lehmer_to_real ([nat n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_to_real\n     ([int (nat n)] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    lucas_lehmer_to_real\n     ([nat n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x)", "by (simp add: add_pow_int_ge)"], ["proof (state)\nthis:\n  lucas_lehmer_to_real\n   ([int (nat n)] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n  lucas_lehmer_to_real ([nat n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x)\n\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow>\n    lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    real_of_int n * lucas_lehmer_to_real x\n 2. \\<not> 0 \\<le> n \\<Longrightarrow>\n    lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    real_of_int n * lucas_lehmer_to_real x", "also"], ["proof (state)\nthis:\n  lucas_lehmer_to_real\n   ([int (nat n)] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n  lucas_lehmer_to_real ([nat n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x)\n\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow>\n    lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    real_of_int n * lucas_lehmer_to_real x\n 2. \\<not> 0 \\<le> n \\<Longrightarrow>\n    lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    real_of_int n * lucas_lehmer_to_real x", "have \"\\<dots> = of_int n * lucas_lehmer_to_real x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_to_real\n     ([nat n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    real_of_int n * lucas_lehmer_to_real x", "using True"], ["proof (prove)\nusing this:\n  0 \\<le> n\n\ngoal (1 subgoal):\n 1. lucas_lehmer_to_real\n     ([nat n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    real_of_int n * lucas_lehmer_to_real x", "by (simp add: lucas_lehmer_to_add_pow_nat algebra_simps)"], ["proof (state)\nthis:\n  lucas_lehmer_to_real\n   ([nat n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n  real_of_int n * lucas_lehmer_to_real x\n\ngoal (2 subgoals):\n 1. 0 \\<le> n \\<Longrightarrow>\n    lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    real_of_int n * lucas_lehmer_to_real x\n 2. \\<not> 0 \\<le> n \\<Longrightarrow>\n    lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    real_of_int n * lucas_lehmer_to_real x", "finally"], ["proof (chain)\npicking this:\n  lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n  real_of_int n * lucas_lehmer_to_real x", "show ?thesis"], ["proof (prove)\nusing this:\n  lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n  real_of_int n * lucas_lehmer_to_real x\n\ngoal (1 subgoal):\n 1. lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    real_of_int n * lucas_lehmer_to_real x", "."], ["proof (state)\nthis:\n  lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n  real_of_int n * lucas_lehmer_to_real x\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> n \\<Longrightarrow>\n    lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    real_of_int n * lucas_lehmer_to_real x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> n \\<Longrightarrow>\n    lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    real_of_int n * lucas_lehmer_to_real x", "case False"], ["proof (state)\nthis:\n  \\<not> 0 \\<le> n\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> n \\<Longrightarrow>\n    lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    real_of_int n * lucas_lehmer_to_real x", "hence \"lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n         lucas_lehmer_to_real (add_pow lucas_lehmer_ring (-int (nat (-n))) x)\""], ["proof (prove)\nusing this:\n  \\<not> 0 \\<le> n\n\ngoal (1 subgoal):\n 1. lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    lucas_lehmer_to_real\n     ([(- int (nat (- n)))] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x)", "by simp"], ["proof (state)\nthis:\n  lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n  lucas_lehmer_to_real\n   ([(- int (nat (- n)))] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x)\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> n \\<Longrightarrow>\n    lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    real_of_int n * lucas_lehmer_to_real x", "also"], ["proof (state)\nthis:\n  lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n  lucas_lehmer_to_real\n   ([(- int (nat (- n)))] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x)\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> n \\<Longrightarrow>\n    lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    real_of_int n * lucas_lehmer_to_real x", "have \"add_pow lucas_lehmer_ring (-int (nat (-n))) x =\n              \\<ominus>\\<^bsub>lucas_lehmer_ring\\<^esub> (add_pow lucas_lehmer_ring (nat (-n)) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(- int (nat (- n)))] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x =\n    \\<ominus>\\<^bsub>lucas_lehmer_ring\\<^esub> ([nat\n            (- n)] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x)", "using False"], ["proof (prove)\nusing this:\n  \\<not> 0 \\<le> n\n\ngoal (1 subgoal):\n 1. [(- int (nat (- n)))] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x =\n    \\<ominus>\\<^bsub>lucas_lehmer_ring\\<^esub> ([nat\n            (- n)] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x)", "by (subst add.int_pow_neg_int) (auto simp: lucas_lehmer_ring_def)"], ["proof (state)\nthis:\n  [(- int (nat (- n)))] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x =\n  \\<ominus>\\<^bsub>lucas_lehmer_ring\\<^esub> ([nat\n          (- n)] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x)\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> n \\<Longrightarrow>\n    lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    real_of_int n * lucas_lehmer_to_real x", "also"], ["proof (state)\nthis:\n  [(- int (nat (- n)))] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x =\n  \\<ominus>\\<^bsub>lucas_lehmer_ring\\<^esub> ([nat\n          (- n)] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x)\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> n \\<Longrightarrow>\n    lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    real_of_int n * lucas_lehmer_to_real x", "have \"lucas_lehmer_to_real \\<dots> = of_int n * lucas_lehmer_to_real x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_to_real\n     (\\<ominus>\\<^bsub>lucas_lehmer_ring\\<^esub> ([nat\n              (- n)] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x)) =\n    real_of_int n * lucas_lehmer_to_real x", "using False"], ["proof (prove)\nusing this:\n  \\<not> 0 \\<le> n\n\ngoal (1 subgoal):\n 1. lucas_lehmer_to_real\n     (\\<ominus>\\<^bsub>lucas_lehmer_ring\\<^esub> ([nat\n              (- n)] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x)) =\n    real_of_int n * lucas_lehmer_to_real x", "by (simp add: lucas_lehmer_to_add_pow_nat lucas_lehmer_to_real_simps1 algebra_simps)"], ["proof (state)\nthis:\n  lucas_lehmer_to_real\n   (\\<ominus>\\<^bsub>lucas_lehmer_ring\\<^esub> ([nat\n            (- n)] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x)) =\n  real_of_int n * lucas_lehmer_to_real x\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> n \\<Longrightarrow>\n    lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    real_of_int n * lucas_lehmer_to_real x", "finally"], ["proof (chain)\npicking this:\n  lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n  real_of_int n * lucas_lehmer_to_real x", "show ?thesis"], ["proof (prove)\nusing this:\n  lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n  real_of_int n * lucas_lehmer_to_real x\n\ngoal (1 subgoal):\n 1. lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n    real_of_int n * lucas_lehmer_to_real x", "."], ["proof (state)\nthis:\n  lucas_lehmer_to_real ([n] \\<cdot>\\<^bsub>lucas_lehmer_ring\\<^esub> x) =\n  real_of_int n * lucas_lehmer_to_real x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lucas_lehmer_to_real_power:\n  \"lucas_lehmer_to_real (x [^]\\<^bsub>lucas_lehmer_ring\\<^esub> (n :: nat)) = lucas_lehmer_to_real x ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_to_real (x [^]\\<^bsub>lucas_lehmer_ring\\<^esub> n) =\n    lucas_lehmer_to_real x ^ n", "by (induction n) (auto simp: lucas_lehmer_to_real_simps1)"], ["", "lemmas lucas_lehmer_to_real_simps =\n  lucas_lehmer_to_real_simps1 lucas_lehmer_to_real_power\n  lucas_lehmer_to_add_pow_nat lucas_lehmer_to_add_pow_int"], ["", "end"], ["", "lemma lucas_lehmer_to_real_inj: \"inj lucas_lehmer_to_real\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj lucas_lehmer_to_real", "proof (rule injI, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       lucas_lehmer_to_real (a, b) =\n       lucas_lehmer_to_real (aa, ba) \\<Longrightarrow>\n       a = aa \\<and> b = ba", "fix a b c d :: int"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       lucas_lehmer_to_real (a, b) =\n       lucas_lehmer_to_real (aa, ba) \\<Longrightarrow>\n       a = aa \\<and> b = ba", "assume eq: \"lucas_lehmer_to_real (a, b) = lucas_lehmer_to_real (c, d)\""], ["proof (state)\nthis:\n  lucas_lehmer_to_real (a, b) = lucas_lehmer_to_real (c, d)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       lucas_lehmer_to_real (a, b) =\n       lucas_lehmer_to_real (aa, ba) \\<Longrightarrow>\n       a = aa \\<and> b = ba", "have \"b = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = d", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<noteq> d \\<Longrightarrow> False", "assume \"b \\<noteq> d\""], ["proof (state)\nthis:\n  b \\<noteq> d\n\ngoal (1 subgoal):\n 1. b \\<noteq> d \\<Longrightarrow> False", "hence \"sqrt 3 = (c - a) / (b - d)\""], ["proof (prove)\nusing this:\n  b \\<noteq> d\n\ngoal (1 subgoal):\n 1. sqrt 3 = real_of_int (c - a) / real_of_int (b - d)", "using eq"], ["proof (prove)\nusing this:\n  b \\<noteq> d\n  lucas_lehmer_to_real (a, b) = lucas_lehmer_to_real (c, d)\n\ngoal (1 subgoal):\n 1. sqrt 3 = real_of_int (c - a) / real_of_int (b - d)", "by (simp add: lucas_lehmer_to_real_def field_simps)"], ["proof (state)\nthis:\n  sqrt 3 = real_of_int (c - a) / real_of_int (b - d)\n\ngoal (1 subgoal):\n 1. b \\<noteq> d \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  sqrt 3 = real_of_int (c - a) / real_of_int (b - d)\n\ngoal (1 subgoal):\n 1. b \\<noteq> d \\<Longrightarrow> False", "have \"\\<dots> \\<in> \\<rat>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (c - a) / real_of_int (b - d) \\<in> \\<rat>", "by auto"], ["proof (state)\nthis:\n  real_of_int (c - a) / real_of_int (b - d) \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. b \\<noteq> d \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  sqrt 3 \\<in> \\<rat>", "have \"sqrt 3 \\<in> \\<rat>\""], ["proof (prove)\nusing this:\n  sqrt 3 \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. sqrt 3 \\<in> \\<rat>", "."], ["proof (state)\nthis:\n  sqrt 3 \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. b \\<noteq> d \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  sqrt 3 \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. b \\<noteq> d \\<Longrightarrow> False", "have \"sqrt 3 \\<notin> \\<rat>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt 3 \\<notin> \\<rat>", "using is_nth_power_prime_power_nat_iff[of 3 2 1] irrat_sqrt_nonsquare[of 3]"], ["proof (prove)\nusing this:\n  prime 3 \\<Longrightarrow> is_square (3 ^ 1) = is_unit 2\n  \\<not> is_square 3 \\<Longrightarrow> sqrt (real 3) \\<notin> \\<rat>\n\ngoal (1 subgoal):\n 1. sqrt 3 \\<notin> \\<rat>", "by auto"], ["proof (state)\nthis:\n  sqrt 3 \\<notin> \\<rat>\n\ngoal (1 subgoal):\n 1. b \\<noteq> d \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  sqrt 3 \\<in> \\<rat>\n  sqrt 3 \\<notin> \\<rat>", "show False"], ["proof (prove)\nusing this:\n  sqrt 3 \\<in> \\<rat>\n  sqrt 3 \\<notin> \\<rat>\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b = d\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       lucas_lehmer_to_real (a, b) =\n       lucas_lehmer_to_real (aa, ba) \\<Longrightarrow>\n       a = aa \\<and> b = ba", "moreover"], ["proof (state)\nthis:\n  b = d\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       lucas_lehmer_to_real (a, b) =\n       lucas_lehmer_to_real (aa, ba) \\<Longrightarrow>\n       a = aa \\<and> b = ba", "from this and eq"], ["proof (chain)\npicking this:\n  b = d\n  lucas_lehmer_to_real (a, b) = lucas_lehmer_to_real (c, d)", "have \"a = c\""], ["proof (prove)\nusing this:\n  b = d\n  lucas_lehmer_to_real (a, b) = lucas_lehmer_to_real (c, d)\n\ngoal (1 subgoal):\n 1. a = c", "by (auto simp: lucas_lehmer_to_real_def)"], ["proof (state)\nthis:\n  a = c\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       lucas_lehmer_to_real (a, b) =\n       lucas_lehmer_to_real (aa, ba) \\<Longrightarrow>\n       a = aa \\<and> b = ba", "ultimately"], ["proof (chain)\npicking this:\n  b = d\n  a = c", "show \"a = c \\<and> b = d\""], ["proof (prove)\nusing this:\n  b = d\n  a = c\n\ngoal (1 subgoal):\n 1. a = c \\<and> b = d", "by blast"], ["proof (state)\nthis:\n  a = c \\<and> b = d\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The canonical homomorphism $\\mathbb{Z}[\\sqrt 3] \\to (\\mathbb{Z}/m\\mathbb{Z})[\\sqrt 3]$\\<close>"], ["", "text \\<open>\n  Next, we show that reduction modulo $m$ is indeed a homomorphism.\n\\<close>"], ["", "definition lucas_lehmer_hom :: \"nat \\<Rightarrow> (int \\<times> int) \\<Rightarrow> (nat \\<times> nat)\" where\n  \"lucas_lehmer_hom m = (\\<lambda>(x,y). (nat (x mod m), nat (y mod m)))\""], ["", "lemma lucas_lehmer_hom_cong:\n  \"[fst x = fst y] (mod int m) \\<Longrightarrow> [snd x = snd y] (mod int m) \\<Longrightarrow>\n   lucas_lehmer_hom m x = lucas_lehmer_hom m y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>[fst x = fst y] (mod int m);\n     [snd x = snd y] (mod int m)\\<rbrakk>\n    \\<Longrightarrow> lucas_lehmer_hom m x = lucas_lehmer_hom m y", "by (auto simp: lucas_lehmer_hom_def cong_def case_prod_unfold)"], ["", "lemma lucas_lehmer_hom_cong':\n  \"[a = b] (mod int m) \\<Longrightarrow> [c = d] (mod int m) \\<Longrightarrow>\n   lucas_lehmer_hom m (a, c) = lucas_lehmer_hom m (b, d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>[a = b] (mod int m); [c = d] (mod int m)\\<rbrakk>\n    \\<Longrightarrow> lucas_lehmer_hom m (a, c) = lucas_lehmer_hom m (b, d)", "by (auto simp: lucas_lehmer_hom_def cong_def)"], ["", "context\n  fixes m :: nat\n  assumes m: \"m > 1\"\nbegin"], ["", "lemma lucas_lehmer_hom_in_carrier: \"lucas_lehmer_hom m x \\<in> {..<m} \\<times> {..<m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_hom m x \\<in> {..<m} \\<times> {..<m}", "using m nat_less_iff"], ["proof (prove)\nusing this:\n  1 < m\n  0 \\<le> ?w \\<Longrightarrow> (nat ?w < ?m) = (?w < int ?m)\n\ngoal (1 subgoal):\n 1. lucas_lehmer_hom m x \\<in> {..<m} \\<times> {..<m}", "by (auto simp: lucas_lehmer_hom_def case_prod_unfold)"], ["", "lemma lucas_lehmer_hom_add:\n  \"lucas_lehmer_hom m (lucas_lehmer_add' x y) =\n   lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_hom m (lucas_lehmer_add' x y) =\n    lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y)", "proof (rule prod_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    fst (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n 2. snd (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "let ?add1 = \"lucas_lehmer_add'\" and ?add2 = \"lucas_lehmer_add m\""], ["proof (state)\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    fst (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n 2. snd (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "let ?\\<phi> = \"lucas_lehmer_hom m\""], ["proof (state)\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    fst (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n 2. snd (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "have \"fst (?\\<phi> (?add1 x y)) = nat ((fst x + fst y) mod int m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    nat ((fst x + fst y) mod int m)", "by (simp add: lucas_lehmer_hom_def lucas_lehmer_add'_def case_prod_unfold)"], ["proof (state)\nthis:\n  fst (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n  nat ((fst x + fst y) mod int m)\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    fst (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n 2. snd (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "also"], ["proof (state)\nthis:\n  fst (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n  nat ((fst x + fst y) mod int m)\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    fst (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n 2. snd (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "have \"(fst x + fst y) mod int m = ((fst x mod m) + (fst y mod m)) mod int m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst x + fst y) mod int m =\n    (fst x mod int m + fst y mod int m) mod int m", "by (simp add: mod_add_eq)"], ["proof (state)\nthis:\n  (fst x + fst y) mod int m = (fst x mod int m + fst y mod int m) mod int m\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    fst (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n 2. snd (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "also"], ["proof (state)\nthis:\n  (fst x + fst y) mod int m = (fst x mod int m + fst y mod int m) mod int m\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    fst (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n 2. snd (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "have \"nat \\<dots> = (nat (fst x mod int m) + nat (fst y mod int m)) mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat ((fst x mod int m + fst y mod int m) mod int m) =\n    (nat (fst x mod int m) + nat (fst y mod int m)) mod m", "using m nat_add_distrib nat_mod_distrib"], ["proof (prove)\nusing this:\n  1 < m\n  \\<lbrakk>0 \\<le> ?z; 0 \\<le> ?z'\\<rbrakk>\n  \\<Longrightarrow> nat (?z + ?z') = nat ?z + nat ?z'\n  \\<lbrakk>0 \\<le> ?x; 0 \\<le> ?y\\<rbrakk>\n  \\<Longrightarrow> nat (?x mod ?y) = nat ?x mod nat ?y\n\ngoal (1 subgoal):\n 1. nat ((fst x mod int m + fst y mod int m) mod int m) =\n    (nat (fst x mod int m) + nat (fst y mod int m)) mod m", "by auto"], ["proof (state)\nthis:\n  nat ((fst x mod int m + fst y mod int m) mod int m) =\n  (nat (fst x mod int m) + nat (fst y mod int m)) mod m\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    fst (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n 2. snd (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "also"], ["proof (state)\nthis:\n  nat ((fst x mod int m + fst y mod int m) mod int m) =\n  (nat (fst x mod int m) + nat (fst y mod int m)) mod m\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    fst (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n 2. snd (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "have \"\\<dots> = fst (?add2 (?\\<phi> x) (?\\<phi> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nat (fst x mod int m) + nat (fst y mod int m)) mod m =\n    fst (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "by (auto simp: lucas_lehmer_hom_def lucas_lehmer_add_def case_prod_unfold)"], ["proof (state)\nthis:\n  (nat (fst x mod int m) + nat (fst y mod int m)) mod m =\n  fst (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    fst (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n 2. snd (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "finally"], ["proof (chain)\npicking this:\n  fst (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n  fst (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "show \"fst (?\\<phi> (?add1 x y)) = fst (?add2 (?\\<phi> x) (?\\<phi> y))\""], ["proof (prove)\nusing this:\n  fst (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n  fst (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n\ngoal (1 subgoal):\n 1. fst (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    fst (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "."], ["proof (state)\nthis:\n  fst (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n  fst (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "have \"snd (?\\<phi> (?add1 x y)) = nat ((snd x + snd y) mod int m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    nat ((snd x + snd y) mod int m)", "by (simp add: lucas_lehmer_hom_def lucas_lehmer_add'_def case_prod_unfold)"], ["proof (state)\nthis:\n  snd (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n  nat ((snd x + snd y) mod int m)\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "also"], ["proof (state)\nthis:\n  snd (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n  nat ((snd x + snd y) mod int m)\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "have \"(snd x + snd y) mod int m = ((snd x mod m) + (snd y mod m)) mod int m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (snd x + snd y) mod int m =\n    (snd x mod int m + snd y mod int m) mod int m", "by (simp add: mod_add_eq)"], ["proof (state)\nthis:\n  (snd x + snd y) mod int m = (snd x mod int m + snd y mod int m) mod int m\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "also"], ["proof (state)\nthis:\n  (snd x + snd y) mod int m = (snd x mod int m + snd y mod int m) mod int m\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "have \"nat \\<dots> = (nat (snd x mod int m) + nat (snd y mod int m)) mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat ((snd x mod int m + snd y mod int m) mod int m) =\n    (nat (snd x mod int m) + nat (snd y mod int m)) mod m", "using m nat_add_distrib nat_mod_distrib"], ["proof (prove)\nusing this:\n  1 < m\n  \\<lbrakk>0 \\<le> ?z; 0 \\<le> ?z'\\<rbrakk>\n  \\<Longrightarrow> nat (?z + ?z') = nat ?z + nat ?z'\n  \\<lbrakk>0 \\<le> ?x; 0 \\<le> ?y\\<rbrakk>\n  \\<Longrightarrow> nat (?x mod ?y) = nat ?x mod nat ?y\n\ngoal (1 subgoal):\n 1. nat ((snd x mod int m + snd y mod int m) mod int m) =\n    (nat (snd x mod int m) + nat (snd y mod int m)) mod m", "by auto"], ["proof (state)\nthis:\n  nat ((snd x mod int m + snd y mod int m) mod int m) =\n  (nat (snd x mod int m) + nat (snd y mod int m)) mod m\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "also"], ["proof (state)\nthis:\n  nat ((snd x mod int m + snd y mod int m) mod int m) =\n  (nat (snd x mod int m) + nat (snd y mod int m)) mod m\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "have \"\\<dots> = snd (?add2 (?\\<phi> x) (?\\<phi> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nat (snd x mod int m) + nat (snd y mod int m)) mod m =\n    snd (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "by (auto simp: lucas_lehmer_hom_def lucas_lehmer_add_def case_prod_unfold)"], ["proof (state)\nthis:\n  (nat (snd x mod int m) + nat (snd y mod int m)) mod m =\n  snd (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "finally"], ["proof (chain)\npicking this:\n  snd (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n  snd (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "show \"snd (?\\<phi> (?add1 x y)) = snd (?add2 (?\\<phi> x) (?\\<phi> y))\""], ["proof (prove)\nusing this:\n  snd (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n  snd (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n    snd (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "."], ["proof (state)\nthis:\n  snd (lucas_lehmer_hom m (lucas_lehmer_add' x y)) =\n  snd (lucas_lehmer_add m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lucas_lehmer_hom_mult:\n  \"lucas_lehmer_hom m (lucas_lehmer_mult' x y) =\n   lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_hom m (lucas_lehmer_mult' x y) =\n    lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y)", "proof (rule prod_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    fst (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n 2. snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "let ?mul1 = \"lucas_lehmer_mult'\" and ?mul2 = \"lucas_lehmer_mult m\""], ["proof (state)\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    fst (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n 2. snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "let ?\\<phi> = \"lucas_lehmer_hom m\""], ["proof (state)\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    fst (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n 2. snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "have \"fst (?\\<phi> (?mul1 x y)) = nat ((fst x * fst y + 3 * snd x * snd y) mod int m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    nat ((fst x * fst y + 3 * snd x * snd y) mod int m)", "by (simp add: lucas_lehmer_hom_def lucas_lehmer_mult'_def case_prod_unfold)"], ["proof (state)\nthis:\n  fst (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n  nat ((fst x * fst y + 3 * snd x * snd y) mod int m)\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    fst (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n 2. snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "also"], ["proof (state)\nthis:\n  fst (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n  nat ((fst x * fst y + 3 * snd x * snd y) mod int m)\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    fst (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n 2. snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "have \"(fst x * fst y + 3 * snd x * snd y) mod int m =\n               ((fst x mod int m) * (fst y mod int m) +\n                3 * (snd x mod int m) * (snd y mod int m)) mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst x * fst y + 3 * snd x * snd y) mod int m =\n    (fst x mod int m * (fst y mod int m) +\n     3 * (snd x mod int m) * (snd y mod int m)) mod\n    int m", "by (intro congD cong_mult cong_add cong_refl) (auto simp: cong_def)"], ["proof (state)\nthis:\n  (fst x * fst y + 3 * snd x * snd y) mod int m =\n  (fst x mod int m * (fst y mod int m) +\n   3 * (snd x mod int m) * (snd y mod int m)) mod\n  int m\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    fst (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n 2. snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "also"], ["proof (state)\nthis:\n  (fst x * fst y + 3 * snd x * snd y) mod int m =\n  (fst x mod int m * (fst y mod int m) +\n   3 * (snd x mod int m) * (snd y mod int m)) mod\n  int m\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    fst (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n 2. snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "have \"\\<dots> = int (nat (((fst x mod int m) * (fst y mod int m) +\n                3 * (snd x mod int m) * (snd y mod int m)) mod m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst x mod int m * (fst y mod int m) +\n     3 * (snd x mod int m) * (snd y mod int m)) mod\n    int m =\n    int (nat ((fst x mod int m * (fst y mod int m) +\n               3 * (snd x mod int m) * (snd y mod int m)) mod\n              int m))", "using m"], ["proof (prove)\nusing this:\n  1 < m\n\ngoal (1 subgoal):\n 1. (fst x mod int m * (fst y mod int m) +\n     3 * (snd x mod int m) * (snd y mod int m)) mod\n    int m =\n    int (nat ((fst x mod int m * (fst y mod int m) +\n               3 * (snd x mod int m) * (snd y mod int m)) mod\n              int m))", "by (subst of_nat_nat) auto"], ["proof (state)\nthis:\n  (fst x mod int m * (fst y mod int m) +\n   3 * (snd x mod int m) * (snd y mod int m)) mod\n  int m =\n  int (nat ((fst x mod int m * (fst y mod int m) +\n             3 * (snd x mod int m) * (snd y mod int m)) mod\n            int m))\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    fst (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n 2. snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "also"], ["proof (state)\nthis:\n  (fst x mod int m * (fst y mod int m) +\n   3 * (snd x mod int m) * (snd y mod int m)) mod\n  int m =\n  int (nat ((fst x mod int m * (fst y mod int m) +\n             3 * (snd x mod int m) * (snd y mod int m)) mod\n            int m))\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    fst (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n 2. snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "have \"\\<dots> = int (nat (fst x mod int m) * nat (fst y mod int m) +\n                3 * (nat (snd x mod int m)) * nat (snd y mod int m)) mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (nat ((fst x mod int m * (fst y mod int m) +\n               3 * (snd x mod int m) * (snd y mod int m)) mod\n              int m)) =\n    int (nat (fst x mod int m) * nat (fst y mod int m) +\n         3 * nat (snd x mod int m) * nat (snd y mod int m)) mod\n    int m", "using m"], ["proof (prove)\nusing this:\n  1 < m\n\ngoal (1 subgoal):\n 1. int (nat ((fst x mod int m * (fst y mod int m) +\n               3 * (snd x mod int m) * (snd y mod int m)) mod\n              int m)) =\n    int (nat (fst x mod int m) * nat (fst y mod int m) +\n         3 * nat (snd x mod int m) * nat (snd y mod int m)) mod\n    int m", "by simp"], ["proof (state)\nthis:\n  int (nat ((fst x mod int m * (fst y mod int m) +\n             3 * (snd x mod int m) * (snd y mod int m)) mod\n            int m)) =\n  int (nat (fst x mod int m) * nat (fst y mod int m) +\n       3 * nat (snd x mod int m) * nat (snd y mod int m)) mod\n  int m\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    fst (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n 2. snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "also"], ["proof (state)\nthis:\n  int (nat ((fst x mod int m * (fst y mod int m) +\n             3 * (snd x mod int m) * (snd y mod int m)) mod\n            int m)) =\n  int (nat (fst x mod int m) * nat (fst y mod int m) +\n       3 * nat (snd x mod int m) * nat (snd y mod int m)) mod\n  int m\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    fst (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n 2. snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "have \"nat \\<dots> = (nat (fst x mod int m) * nat (fst y mod int m) +\n           3 * nat (snd x mod int m) * nat (snd y mod int m)) mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat (int (nat (fst x mod int m) * nat (fst y mod int m) +\n              3 * nat (snd x mod int m) * nat (snd y mod int m)) mod\n         int m) =\n    (nat (fst x mod int m) * nat (fst y mod int m) +\n     3 * nat (snd x mod int m) * nat (snd y mod int m)) mod\n    m", "using m"], ["proof (prove)\nusing this:\n  1 < m\n\ngoal (1 subgoal):\n 1. nat (int (nat (fst x mod int m) * nat (fst y mod int m) +\n              3 * nat (snd x mod int m) * nat (snd y mod int m)) mod\n         int m) =\n    (nat (fst x mod int m) * nat (fst y mod int m) +\n     3 * nat (snd x mod int m) * nat (snd y mod int m)) mod\n    m", "by (metis nat_int zmod_int)"], ["proof (state)\nthis:\n  nat (int (nat (fst x mod int m) * nat (fst y mod int m) +\n            3 * nat (snd x mod int m) * nat (snd y mod int m)) mod\n       int m) =\n  (nat (fst x mod int m) * nat (fst y mod int m) +\n   3 * nat (snd x mod int m) * nat (snd y mod int m)) mod\n  m\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    fst (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n 2. snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "also"], ["proof (state)\nthis:\n  nat (int (nat (fst x mod int m) * nat (fst y mod int m) +\n            3 * nat (snd x mod int m) * nat (snd y mod int m)) mod\n       int m) =\n  (nat (fst x mod int m) * nat (fst y mod int m) +\n   3 * nat (snd x mod int m) * nat (snd y mod int m)) mod\n  m\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    fst (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n 2. snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "have \"\\<dots> = fst (?mul2 (?\\<phi> x) (?\\<phi> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nat (fst x mod int m) * nat (fst y mod int m) +\n     3 * nat (snd x mod int m) * nat (snd y mod int m)) mod\n    m =\n    fst (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "by (simp add: lucas_lehmer_hom_def lucas_lehmer_mult_def case_prod_unfold)"], ["proof (state)\nthis:\n  (nat (fst x mod int m) * nat (fst y mod int m) +\n   3 * nat (snd x mod int m) * nat (snd y mod int m)) mod\n  m =\n  fst (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n\ngoal (2 subgoals):\n 1. fst (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    fst (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n 2. snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "finally"], ["proof (chain)\npicking this:\n  fst (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n  fst (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "show \"fst (?\\<phi> (?mul1 x y)) = fst (?mul2 (?\\<phi> x) (?\\<phi> y))\""], ["proof (prove)\nusing this:\n  fst (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n  fst (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n\ngoal (1 subgoal):\n 1. fst (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    fst (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "."], ["proof (state)\nthis:\n  fst (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n  fst (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "have \"snd (?\\<phi> (?mul1 x y)) = nat ((fst x * snd y + snd x * fst y) mod int m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    nat ((fst x * snd y + snd x * fst y) mod int m)", "by (simp add: lucas_lehmer_hom_def lucas_lehmer_mult'_def case_prod_unfold)"], ["proof (state)\nthis:\n  snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n  nat ((fst x * snd y + snd x * fst y) mod int m)\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "also"], ["proof (state)\nthis:\n  snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n  nat ((fst x * snd y + snd x * fst y) mod int m)\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "have \"(fst x * snd y + snd x * fst y) mod int m =\n               ((fst x mod int m) * (snd y mod int m) +\n                (snd x mod int m) * (fst y mod int m)) mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst x * snd y + snd x * fst y) mod int m =\n    (fst x mod int m * (snd y mod int m) +\n     snd x mod int m * (fst y mod int m)) mod\n    int m", "by (intro congD cong_mult cong_add cong_refl) (auto simp: cong_def)"], ["proof (state)\nthis:\n  (fst x * snd y + snd x * fst y) mod int m =\n  (fst x mod int m * (snd y mod int m) +\n   snd x mod int m * (fst y mod int m)) mod\n  int m\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "also"], ["proof (state)\nthis:\n  (fst x * snd y + snd x * fst y) mod int m =\n  (fst x mod int m * (snd y mod int m) +\n   snd x mod int m * (fst y mod int m)) mod\n  int m\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "have \"\\<dots> = int (nat (((fst x mod int m) * (snd y mod int m) +\n                (snd x mod int m) * (fst y mod int m)) mod m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst x mod int m * (snd y mod int m) +\n     snd x mod int m * (fst y mod int m)) mod\n    int m =\n    int (nat ((fst x mod int m * (snd y mod int m) +\n               snd x mod int m * (fst y mod int m)) mod\n              int m))", "using m"], ["proof (prove)\nusing this:\n  1 < m\n\ngoal (1 subgoal):\n 1. (fst x mod int m * (snd y mod int m) +\n     snd x mod int m * (fst y mod int m)) mod\n    int m =\n    int (nat ((fst x mod int m * (snd y mod int m) +\n               snd x mod int m * (fst y mod int m)) mod\n              int m))", "by (subst of_nat_nat) auto"], ["proof (state)\nthis:\n  (fst x mod int m * (snd y mod int m) +\n   snd x mod int m * (fst y mod int m)) mod\n  int m =\n  int (nat ((fst x mod int m * (snd y mod int m) +\n             snd x mod int m * (fst y mod int m)) mod\n            int m))\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "also"], ["proof (state)\nthis:\n  (fst x mod int m * (snd y mod int m) +\n   snd x mod int m * (fst y mod int m)) mod\n  int m =\n  int (nat ((fst x mod int m * (snd y mod int m) +\n             snd x mod int m * (fst y mod int m)) mod\n            int m))\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "have \"\\<dots> = int (nat (fst x mod int m) * nat (snd y mod int m) +\n                    (nat (snd x mod int m)) * nat (fst y mod int m)) mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (nat ((fst x mod int m * (snd y mod int m) +\n               snd x mod int m * (fst y mod int m)) mod\n              int m)) =\n    int (nat (fst x mod int m) * nat (snd y mod int m) +\n         nat (snd x mod int m) * nat (fst y mod int m)) mod\n    int m", "using m"], ["proof (prove)\nusing this:\n  1 < m\n\ngoal (1 subgoal):\n 1. int (nat ((fst x mod int m * (snd y mod int m) +\n               snd x mod int m * (fst y mod int m)) mod\n              int m)) =\n    int (nat (fst x mod int m) * nat (snd y mod int m) +\n         nat (snd x mod int m) * nat (fst y mod int m)) mod\n    int m", "by simp"], ["proof (state)\nthis:\n  int (nat ((fst x mod int m * (snd y mod int m) +\n             snd x mod int m * (fst y mod int m)) mod\n            int m)) =\n  int (nat (fst x mod int m) * nat (snd y mod int m) +\n       nat (snd x mod int m) * nat (fst y mod int m)) mod\n  int m\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "also"], ["proof (state)\nthis:\n  int (nat ((fst x mod int m * (snd y mod int m) +\n             snd x mod int m * (fst y mod int m)) mod\n            int m)) =\n  int (nat (fst x mod int m) * nat (snd y mod int m) +\n       nat (snd x mod int m) * nat (fst y mod int m)) mod\n  int m\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "have \"nat \\<dots> = (nat (fst x mod int m) * nat (snd y mod int m) +\n               nat (snd x mod int m) * nat (fst y mod int m)) mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat (int (nat (fst x mod int m) * nat (snd y mod int m) +\n              nat (snd x mod int m) * nat (fst y mod int m)) mod\n         int m) =\n    (nat (fst x mod int m) * nat (snd y mod int m) +\n     nat (snd x mod int m) * nat (fst y mod int m)) mod\n    m", "using m"], ["proof (prove)\nusing this:\n  1 < m\n\ngoal (1 subgoal):\n 1. nat (int (nat (fst x mod int m) * nat (snd y mod int m) +\n              nat (snd x mod int m) * nat (fst y mod int m)) mod\n         int m) =\n    (nat (fst x mod int m) * nat (snd y mod int m) +\n     nat (snd x mod int m) * nat (fst y mod int m)) mod\n    m", "by (metis nat_int zmod_int)"], ["proof (state)\nthis:\n  nat (int (nat (fst x mod int m) * nat (snd y mod int m) +\n            nat (snd x mod int m) * nat (fst y mod int m)) mod\n       int m) =\n  (nat (fst x mod int m) * nat (snd y mod int m) +\n   nat (snd x mod int m) * nat (fst y mod int m)) mod\n  m\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "also"], ["proof (state)\nthis:\n  nat (int (nat (fst x mod int m) * nat (snd y mod int m) +\n            nat (snd x mod int m) * nat (fst y mod int m)) mod\n       int m) =\n  (nat (fst x mod int m) * nat (snd y mod int m) +\n   nat (snd x mod int m) * nat (fst y mod int m)) mod\n  m\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "have \"\\<dots> = snd (?mul2 (?\\<phi> x) (?\\<phi> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nat (fst x mod int m) * nat (snd y mod int m) +\n     nat (snd x mod int m) * nat (fst y mod int m)) mod\n    m =\n    snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "by (simp add: lucas_lehmer_hom_def lucas_lehmer_mult_def case_prod_unfold)"], ["proof (state)\nthis:\n  (nat (fst x mod int m) * nat (snd y mod int m) +\n   nat (snd x mod int m) * nat (fst y mod int m)) mod\n  m =\n  snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "finally"], ["proof (chain)\npicking this:\n  snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n  snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "show \"snd (?\\<phi> (?mul1 x y)) = snd (?mul2 (?\\<phi> x) (?\\<phi> y))\""], ["proof (prove)\nusing this:\n  snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n  snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n\ngoal (1 subgoal):\n 1. snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n    snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))", "."], ["proof (state)\nthis:\n  snd (lucas_lehmer_hom m (lucas_lehmer_mult' x y)) =\n  snd (lucas_lehmer_mult m (lucas_lehmer_hom m x) (lucas_lehmer_hom m y))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lucas_lehmer_hom_1 [simp]: \"lucas_lehmer_hom m (1, 0) = (1, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_hom m (1, 0) = (1, 0)", "using m"], ["proof (prove)\nusing this:\n  1 < m\n\ngoal (1 subgoal):\n 1. lucas_lehmer_hom m (1, 0) = (1, 0)", "by (simp add: lucas_lehmer_hom_def)"], ["", "lemma ring_hom_lucas_lehmer_hom:\n  \"lucas_lehmer_hom m \\<in> ring_hom lucas_lehmer_ring (lucas_lehmer_ring_mod m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_hom m\n    \\<in> ring_hom lucas_lehmer_ring (lucas_lehmer_ring_mod m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lucas_lehmer_hom m\n    \\<in> ring_hom lucas_lehmer_ring (lucas_lehmer_ring_mod m)", "interpret R: cring lucas_lehmer_ring"], ["proof (prove)\ngoal (1 subgoal):\n 1. cring lucas_lehmer_ring", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. lucas_lehmer_hom m\n    \\<in> ring_hom lucas_lehmer_ring (lucas_lehmer_ring_mod m)", "from m"], ["proof (chain)\npicking this:\n  1 < m", "interpret S: cring \"lucas_lehmer_ring_mod m\""], ["proof (prove)\nusing this:\n  1 < m\n\ngoal (1 subgoal):\n 1. cring (lucas_lehmer_ring_mod m)", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. lucas_lehmer_hom m\n    \\<in> ring_hom lucas_lehmer_ring (lucas_lehmer_ring_mod m)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_hom m\n    \\<in> ring_hom lucas_lehmer_ring (lucas_lehmer_ring_mod m)", "unfolding ring_hom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_hom m\n    \\<in> {h \\<in> carrier lucas_lehmer_ring \\<rightarrow>\n                   carrier (lucas_lehmer_ring_mod m).\n           (\\<forall>x y.\n               x \\<in> carrier lucas_lehmer_ring \\<and>\n               y \\<in> carrier lucas_lehmer_ring \\<longrightarrow>\n               h (x \\<otimes>\\<^bsub>lucas_lehmer_ring\\<^esub> y) =\n               h x \\<otimes>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n               h y \\<and>\n               h (x \\<oplus>\\<^bsub>lucas_lehmer_ring\\<^esub> y) =\n               h x \\<oplus>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n               h y) \\<and>\n           h \\<one>\\<^bsub>lucas_lehmer_ring\\<^esub> =\n           \\<one>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>}", "using lucas_lehmer_hom_in_carrier m"], ["proof (prove)\nusing this:\n  lucas_lehmer_hom m ?x \\<in> {..<m} \\<times> {..<m}\n  1 < m\n\ngoal (1 subgoal):\n 1. lucas_lehmer_hom m\n    \\<in> {h \\<in> carrier lucas_lehmer_ring \\<rightarrow>\n                   carrier (lucas_lehmer_ring_mod m).\n           (\\<forall>x y.\n               x \\<in> carrier lucas_lehmer_ring \\<and>\n               y \\<in> carrier lucas_lehmer_ring \\<longrightarrow>\n               h (x \\<otimes>\\<^bsub>lucas_lehmer_ring\\<^esub> y) =\n               h x \\<otimes>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n               h y \\<and>\n               h (x \\<oplus>\\<^bsub>lucas_lehmer_ring\\<^esub> y) =\n               h x \\<oplus>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>\n               h y) \\<and>\n           h \\<one>\\<^bsub>lucas_lehmer_ring\\<^esub> =\n           \\<one>\\<^bsub>lucas_lehmer_ring_mod m\\<^esub>}", "by (auto simp: lucas_lehmer_ring_mod_def lucas_lehmer_hom_add\n                   lucas_lehmer_ring_def lucas_lehmer_hom_mult)"], ["proof (state)\nthis:\n  lucas_lehmer_hom m\n  \\<in> ring_hom lucas_lehmer_ring (lucas_lehmer_ring_mod m)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Correctness of the Lucas--Lehmer test\\<close>"], ["", "text \\<open>\n  In this section, we will prove that the Lucas--Lehmer test is both a necessary and sufficient\n  condition for the primality of a Mersenne number of the form $2^p - 1$ for an odd prime $p$.\n  The proof that shall be given here is rather explicit and heavily draws from the Wikipedia\n  article on the Lucas--Lehmer test~\\cite{wiki:lucas_lehmer}.\n\n  A shorter and more high-level proof of a more general statement can be obtained using more\n  theory on finite fields (in particular the field $\\text{GF}(q^2)$ (cf.\\ e.\\,g.\\ \n  R?dseth~\\cite{roedseth94}).\n\\<close>"], ["", "definition lucas_lehmer_test where\n  \"lucas_lehmer_test p = (p > 2 \\<and>\n     (2 ^ p - 1) dvd gen_lucas_lehmer_sequence 4 (p - 2))\""], ["", "text \\<open>\n  We can now prove that any Mersenne number $2^p - 1$ for $p$ prime that passes the \n  Lucas--Lehmer test is prime. We follow the simple argument given by Bruce~\\cite{bruce93},\n  which is also given on Wikipedia~\\cite{wiki:lucas_lehmer}.\n\\<close>"], ["", "theorem lucas_lehmer_sufficient:\n  assumes \"prime p\" \"odd p\"\n  assumes \"(2 ^ p - 1) dvd gen_lucas_lehmer_sequence 4 (p - 2)\"\n  shows   \"prime (2 ^ p - 1 :: nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime (2 ^ p - 1)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "assume not_prime: \"\\<not>prime (2 ^ p - 1 :: nat)\""], ["proof (state)\nthis:\n  \\<not> prime (2 ^ p - 1)\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "from assms"], ["proof (chain)\npicking this:\n  prime p\n  odd p\n  2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "obtain k :: int where k: \"gen_lucas_lehmer_sequence 4 (p - 2) = k * (2 ^ p - 1)\""], ["proof (prove)\nusing this:\n  prime p\n  odd p\n  2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        gen_lucas_lehmer_sequence 4 (p - 2) =\n        k * (2 ^ p - 1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (elim dvdE) (auto simp: mult_ac)"], ["proof (state)\nthis:\n  gen_lucas_lehmer_sequence 4 (p - 2) = k * (2 ^ p - 1)\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "from assms"], ["proof (chain)\npicking this:\n  prime p\n  odd p\n  2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "have \"p > 2\""], ["proof (prove)\nusing this:\n  prime p\n  odd p\n  2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)\n\ngoal (1 subgoal):\n 1. 2 < p", "using odd_prime_gt_2_nat"], ["proof (prove)\nusing this:\n  prime p\n  odd p\n  2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)\n  \\<lbrakk>odd ?p; prime ?p\\<rbrakk> \\<Longrightarrow> 2 < ?p\n\ngoal (1 subgoal):\n 1. 2 < p", "by blast"], ["proof (state)\nthis:\n  2 < p\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "from \\<open>p > 2\\<close>"], ["proof (chain)\npicking this:\n  2 < p", "have \"2 ^ p \\<ge> (2 ^ 3 :: nat)\""], ["proof (prove)\nusing this:\n  2 < p\n\ngoal (1 subgoal):\n 1. 2 ^ 3 \\<le> 2 ^ p", "by (intro power_increasing) auto"], ["proof (state)\nthis:\n  2 ^ 3 \\<le> 2 ^ p\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "hence \"2 ^ p \\<ge> (8 :: nat)\""], ["proof (prove)\nusing this:\n  2 ^ 3 \\<le> 2 ^ p\n\ngoal (1 subgoal):\n 1. 8 \\<le> 2 ^ p", "by simp"], ["proof (state)\nthis:\n  8 \\<le> 2 ^ p\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "define q :: nat where \"q = Min (prime_factors (2 ^ p - 1))\""], ["proof (state)\nthis:\n  q = Min_mset (prime_factorization (2 ^ p - 1))\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "have \"q \\<in> prime_factors (2 ^ p - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in># prime_factorization (2 ^ p - 1)", "using \\<open>2 ^ p \\<ge> 8\\<close>"], ["proof (prove)\nusing this:\n  8 \\<le> 2 ^ p\n\ngoal (1 subgoal):\n 1. q \\<in># prime_factorization (2 ^ p - 1)", "unfolding q_def"], ["proof (prove)\nusing this:\n  8 \\<le> 2 ^ p\n\ngoal (1 subgoal):\n 1. Min_mset (prime_factorization (2 ^ p - 1))\n    \\<in># prime_factorization (2 ^ p - 1)", "by (intro Min_in) (auto simp: prime_factorization_empty_iff)"], ["proof (state)\nthis:\n  q \\<in># prime_factorization (2 ^ p - 1)\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "hence q: \"prime q\" \"q dvd (2 ^ p - 1 :: nat)\""], ["proof (prove)\nusing this:\n  q \\<in># prime_factorization (2 ^ p - 1)\n\ngoal (1 subgoal):\n 1. prime q &&& q dvd 2 ^ p - 1", "by (auto simp: in_prime_factors_iff)"], ["proof (state)\nthis:\n  prime q\n  q dvd 2 ^ p - 1\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "have q_minimal: \"q \\<le> q'\" if \"q' \\<in> prime_factors (2 ^ p - 1)\" for q'"], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<le> q'", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Min_mset (prime_factorization (2 ^ p - 1)) \\<le> q'", "by (rule Min_le) (use that in auto)"], ["proof (state)\nthis:\n  ?q' \\<in># prime_factorization (2 ^ p - 1) \\<Longrightarrow> q \\<le> ?q'\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "have \"2 ^ p - 1 \\<ge> q ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q\\<^sup>2 \\<le> 2 ^ p - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. q\\<^sup>2 \\<le> 2 ^ p - 1", "from q"], ["proof (chain)\npicking this:\n  prime q\n  q dvd 2 ^ p - 1", "obtain k where k: \"2 ^ p - 1 = q * k\""], ["proof (prove)\nusing this:\n  prime q\n  q dvd 2 ^ p - 1\n\ngoal (1 subgoal):\n 1. (\\<And>k. 2 ^ p - 1 = q * k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  2 ^ p - 1 = q * k\n\ngoal (1 subgoal):\n 1. q\\<^sup>2 \\<le> 2 ^ p - 1", "have \"prime_factorization (2 ^ p - 1 :: nat) \\<noteq> {#q#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factorization (2 ^ p - 1) \\<noteq> {#q#}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. prime_factorization (2 ^ p - 1) = {#q#} \\<Longrightarrow> False", "assume *: \"prime_factorization (2 ^ p - 1 :: nat) = {#q#}\""], ["proof (state)\nthis:\n  prime_factorization (2 ^ p - 1) = {#q#}\n\ngoal (1 subgoal):\n 1. prime_factorization (2 ^ p - 1) = {#q#} \\<Longrightarrow> False", "have \"2 ^ p - 1 = prod_mset (prime_factorization (2 ^ p - 1 :: nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ p - 1 = \\<Prod>\\<^sub># (prime_factorization (2 ^ p - 1))", "using \\<open>2 ^ p \\<ge> 8\\<close>"], ["proof (prove)\nusing this:\n  8 \\<le> 2 ^ p\n\ngoal (1 subgoal):\n 1. 2 ^ p - 1 = \\<Prod>\\<^sub># (prime_factorization (2 ^ p - 1))", "by (subst prod_mset_prime_factorization_nat) auto"], ["proof (state)\nthis:\n  2 ^ p - 1 = \\<Prod>\\<^sub># (prime_factorization (2 ^ p - 1))\n\ngoal (1 subgoal):\n 1. prime_factorization (2 ^ p - 1) = {#q#} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  2 ^ p - 1 = \\<Prod>\\<^sub># (prime_factorization (2 ^ p - 1))\n\ngoal (1 subgoal):\n 1. prime_factorization (2 ^ p - 1) = {#q#} \\<Longrightarrow> False", "have \"\\<dots> = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Prod>\\<^sub># (prime_factorization (2 ^ p - 1)) = q", "by (subst *) auto"], ["proof (state)\nthis:\n  \\<Prod>\\<^sub># (prime_factorization (2 ^ p - 1)) = q\n\ngoal (1 subgoal):\n 1. prime_factorization (2 ^ p - 1) = {#q#} \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  2 ^ p - 1 = q", "show False"], ["proof (prove)\nusing this:\n  2 ^ p - 1 = q\n\ngoal (1 subgoal):\n 1. False", "using not_prime q"], ["proof (prove)\nusing this:\n  2 ^ p - 1 = q\n  \\<not> prime (2 ^ p - 1)\n  prime q\n  q dvd 2 ^ p - 1\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prime_factorization (2 ^ p - 1) \\<noteq> {#q#}\n\ngoal (1 subgoal):\n 1. q\\<^sup>2 \\<le> 2 ^ p - 1", "hence \"prime_factorization k \\<noteq> {#}\""], ["proof (prove)\nusing this:\n  prime_factorization (2 ^ p - 1) \\<noteq> {#q#}\n\ngoal (1 subgoal):\n 1. prime_factorization k \\<noteq> {#}", "using q k \\<open>2 ^ p \\<ge> 8\\<close>"], ["proof (prove)\nusing this:\n  prime_factorization (2 ^ p - 1) \\<noteq> {#q#}\n  prime q\n  q dvd 2 ^ p - 1\n  2 ^ p - 1 = q * k\n  8 \\<le> 2 ^ p\n\ngoal (1 subgoal):\n 1. prime_factorization k \\<noteq> {#}", "by (subst (asm) k, subst (asm) prime_factorization_mult)\n         (auto intro!: Nat.gr0I simp: prime_factorization_prime)"], ["proof (state)\nthis:\n  prime_factorization k \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. q\\<^sup>2 \\<le> 2 ^ p - 1", "hence \"k \\<noteq> 1\""], ["proof (prove)\nusing this:\n  prime_factorization k \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. k \\<noteq> 1", "by (auto simp: prime_factorization_empty_iff)"], ["proof (state)\nthis:\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. q\\<^sup>2 \\<le> 2 ^ p - 1", "then"], ["proof (chain)\npicking this:\n  k \\<noteq> 1", "obtain q' where q': \"prime q'\" \"q' dvd k\""], ["proof (prove)\nusing this:\n  k \\<noteq> 1\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>prime q'; q' dvd k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prime_factor_nat"], ["proof (prove)\nusing this:\n  k \\<noteq> 1\n  ?n \\<noteq> 1 \\<Longrightarrow> \\<exists>p. prime p \\<and> p dvd ?n\n\ngoal (1 subgoal):\n 1. (\\<And>q'.\n        \\<lbrakk>prime q'; q' dvd k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  prime q'\n  q' dvd k\n\ngoal (1 subgoal):\n 1. q\\<^sup>2 \\<le> 2 ^ p - 1", "from q' k \\<open>2 ^ p \\<ge> 8\\<close>"], ["proof (chain)\npicking this:\n  prime q'\n  q' dvd k\n  2 ^ p - 1 = q * k\n  8 \\<le> 2 ^ p", "have \"q \\<le> q'\""], ["proof (prove)\nusing this:\n  prime q'\n  q' dvd k\n  2 ^ p - 1 = q * k\n  8 \\<le> 2 ^ p\n\ngoal (1 subgoal):\n 1. q \\<le> q'", "by (intro q_minimal) (auto simp: in_prime_factors_iff intro!: Nat.gr0I)"], ["proof (state)\nthis:\n  q \\<le> q'\n\ngoal (1 subgoal):\n 1. q\\<^sup>2 \\<le> 2 ^ p - 1", "hence \"q ^ 2 \\<le> q * q'\""], ["proof (prove)\nusing this:\n  q \\<le> q'\n\ngoal (1 subgoal):\n 1. q\\<^sup>2 \\<le> q * q'", "unfolding power2_eq_square"], ["proof (prove)\nusing this:\n  q \\<le> q'\n\ngoal (1 subgoal):\n 1. q * q \\<le> q * q'", "by (intro mult_mono) auto"], ["proof (state)\nthis:\n  q\\<^sup>2 \\<le> q * q'\n\ngoal (1 subgoal):\n 1. q\\<^sup>2 \\<le> 2 ^ p - 1", "also"], ["proof (state)\nthis:\n  q\\<^sup>2 \\<le> q * q'\n\ngoal (1 subgoal):\n 1. q\\<^sup>2 \\<le> 2 ^ p - 1", "have \"q * q' \\<le> 2 ^ p - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q * q' \\<le> 2 ^ p - 1", "using q q' k \\<open>2 ^ p \\<ge> 8\\<close>"], ["proof (prove)\nusing this:\n  prime q\n  q dvd 2 ^ p - 1\n  prime q'\n  q' dvd k\n  2 ^ p - 1 = q * k\n  8 \\<le> 2 ^ p\n\ngoal (1 subgoal):\n 1. q * q' \\<le> 2 ^ p - 1", "by (intro dvd_imp_le) (auto intro!: Nat.gr0I)"], ["proof (state)\nthis:\n  q * q' \\<le> 2 ^ p - 1\n\ngoal (1 subgoal):\n 1. q\\<^sup>2 \\<le> 2 ^ p - 1", "finally"], ["proof (chain)\npicking this:\n  q\\<^sup>2 \\<le> 2 ^ p - 1", "show \"2 ^ p - 1 \\<ge> q ^ 2\""], ["proof (prove)\nusing this:\n  q\\<^sup>2 \\<le> 2 ^ p - 1\n\ngoal (1 subgoal):\n 1. q\\<^sup>2 \\<le> 2 ^ p - 1", "."], ["proof (state)\nthis:\n  q\\<^sup>2 \\<le> 2 ^ p - 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q\\<^sup>2 \\<le> 2 ^ p - 1\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "have \"q \\<noteq> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> 2", "using q \\<open>p > 2\\<close>"], ["proof (prove)\nusing this:\n  prime q\n  q dvd 2 ^ p - 1\n  2 < p\n\ngoal (1 subgoal):\n 1. q \\<noteq> 2", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 2\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  q \\<noteq> 2\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "from q"], ["proof (chain)\npicking this:\n  prime q\n  q dvd 2 ^ p - 1", "have \"q \\<noteq> 0\" \"q \\<noteq> 1\""], ["proof (prove)\nusing this:\n  prime q\n  q dvd 2 ^ p - 1\n\ngoal (1 subgoal):\n 1. q \\<noteq> 0 &&& q \\<noteq> 1", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> 0\n  q \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  q \\<noteq> 2\n  q \\<noteq> 0\n  q \\<noteq> 1", "have \"q > 2\""], ["proof (prove)\nusing this:\n  q \\<noteq> 2\n  q \\<noteq> 0\n  q \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 2 < q", "by auto"], ["proof (state)\nthis:\n  2 < q\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "write lucas_lehmer_ring (\"R\")"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "define S where \"S = lucas_lehmer_ring_mod q\""], ["proof (state)\nthis:\n  S = lucas_lehmer_ring_mod q\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "define S' where \"S' = units_of S\""], ["proof (state)\nthis:\n  S' = units_of S\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "define \\<phi> where \"\\<phi> = lucas_lehmer_hom q\""], ["proof (state)\nthis:\n  \\<phi> = lucas_lehmer_hom q\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "interpret R: cring R"], ["proof (prove)\ngoal (1 subgoal):\n 1. cring R", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "interpret S: cring S"], ["proof (prove)\ngoal (1 subgoal):\n 1. cring S", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cring (lucas_lehmer_ring_mod q)", "by (rule cring_lucas_lehmer_ring_mod) (use \\<open>q > 2\\<close> in auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "interpret S': comm_group S'"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_group S'", "unfolding S'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_group (units_of S)", "by (rule S.units_comm_group)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "have \"\\<phi> \\<in> ring_hom R S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> \\<in> ring_hom R S", "unfolding \\<phi>_def S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_hom q \\<in> ring_hom R (lucas_lehmer_ring_mod q)", "by (rule ring_hom_lucas_lehmer_hom) (use \\<open>q > 2\\<close> in auto)"], ["proof (state)\nthis:\n  \\<phi> \\<in> ring_hom R S\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "interpret \\<phi>: ring_hom_cring R S \\<phi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_hom_cring R S \\<phi>", "by standard fact"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "have \"(2 + sqrt 3) ^ (2 ^ (p - 2)) + (2 - sqrt 3) ^ (2 ^ (p - 2)) =\n          real_of_int (gen_lucas_lehmer_sequence 4 (p - 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 + sqrt 3) ^ 2 ^ (p - 2) + (2 - sqrt 3) ^ 2 ^ (p - 2) =\n    real_of_int (gen_lucas_lehmer_sequence 4 (p - 2))", "unfolding gen_lucas_lehmer_sequence_4_closed_form1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 + sqrt 3) ^ 2 ^ (p - 2) + (2 - sqrt 3) ^ 2 ^ (p - 2) =\n    (2 + sqrt 3) ^ 2 ^ (p - 2) + (2 - sqrt 3) ^ 2 ^ (p - 2)", ".."], ["proof (state)\nthis:\n  (2 + sqrt 3) ^ 2 ^ (p - 2) + (2 - sqrt 3) ^ 2 ^ (p - 2) =\n  real_of_int (gen_lucas_lehmer_sequence 4 (p - 2))\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (2 + sqrt 3) ^ 2 ^ (p - 2) + (2 - sqrt 3) ^ 2 ^ (p - 2) =\n  real_of_int (gen_lucas_lehmer_sequence 4 (p - 2))\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "have \"\\<dots> = real_of_int k * (2 ^ p - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (gen_lucas_lehmer_sequence 4 (p - 2)) =\n    real_of_int k * (2 ^ p - 1)", "by (simp add: k)"], ["proof (state)\nthis:\n  real_of_int (gen_lucas_lehmer_sequence 4 (p - 2)) =\n  real_of_int k * (2 ^ p - 1)\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  (2 + sqrt 3) ^ 2 ^ (p - 2) + (2 - sqrt 3) ^ 2 ^ (p - 2) =\n  real_of_int k * (2 ^ p - 1)", "have *: \"(2 + sqrt 3) ^ (2 ^ (p - 2)) =\n                     real_of_int k * (2 ^ p - 1) - (2 - sqrt 3) ^ (2 ^ (p - 2))\""], ["proof (prove)\nusing this:\n  (2 + sqrt 3) ^ 2 ^ (p - 2) + (2 - sqrt 3) ^ 2 ^ (p - 2) =\n  real_of_int k * (2 ^ p - 1)\n\ngoal (1 subgoal):\n 1. (2 + sqrt 3) ^ 2 ^ (p - 2) =\n    real_of_int k * (2 ^ p - 1) - (2 - sqrt 3) ^ 2 ^ (p - 2)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (2 + sqrt 3) ^ 2 ^ (p - 2) =\n  real_of_int k * (2 ^ p - 1) - (2 - sqrt 3) ^ 2 ^ (p - 2)\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "have \"((2 + sqrt 3) ^ (2 ^ (p - 2))) ^ 2 =\n             real_of_int k * (2 ^ p - 1) * (2 + sqrt 3) ^ (2 ^ (p - 2)) -\n             (2 - sqrt 3) ^ (2 ^ (p - 2)) * (2 + sqrt 3) ^ (2 ^ (p - 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((2 + sqrt 3) ^ 2 ^ (p - 2))\\<^sup>2 =\n    real_of_int k * (2 ^ p - 1) * (2 + sqrt 3) ^ 2 ^ (p - 2) -\n    (2 - sqrt 3) ^ 2 ^ (p - 2) * (2 + sqrt 3) ^ 2 ^ (p - 2)", "unfolding power2_eq_square"], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 + sqrt 3) ^ 2 ^ (p - 2) * (2 + sqrt 3) ^ 2 ^ (p - 2) =\n    real_of_int k * (2 ^ p - 1) * (2 + sqrt 3) ^ 2 ^ (p - 2) -\n    (2 - sqrt 3) ^ 2 ^ (p - 2) * (2 + sqrt 3) ^ 2 ^ (p - 2)", "by (subst *) (simp add: algebra_simps)"], ["proof (state)\nthis:\n  ((2 + sqrt 3) ^ 2 ^ (p - 2))\\<^sup>2 =\n  real_of_int k * (2 ^ p - 1) * (2 + sqrt 3) ^ 2 ^ (p - 2) -\n  (2 - sqrt 3) ^ 2 ^ (p - 2) * (2 + sqrt 3) ^ 2 ^ (p - 2)\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  ((2 + sqrt 3) ^ 2 ^ (p - 2))\\<^sup>2 =\n  real_of_int k * (2 ^ p - 1) * (2 + sqrt 3) ^ 2 ^ (p - 2) -\n  (2 - sqrt 3) ^ 2 ^ (p - 2) * (2 + sqrt 3) ^ 2 ^ (p - 2)\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "have \"((2 + sqrt 3) ^ (2 ^ (p - 2))) ^ 2 = (2 + sqrt 3) ^ (2 * 2 ^ (p - 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((2 + sqrt 3) ^ 2 ^ (p - 2))\\<^sup>2 = (2 + sqrt 3) ^ (2 * 2 ^ (p - 2))", "by (simp flip: power_mult add: mult_ac)"], ["proof (state)\nthis:\n  ((2 + sqrt 3) ^ 2 ^ (p - 2))\\<^sup>2 = (2 + sqrt 3) ^ (2 * 2 ^ (p - 2))\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  ((2 + sqrt 3) ^ 2 ^ (p - 2))\\<^sup>2 = (2 + sqrt 3) ^ (2 * 2 ^ (p - 2))\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "have \"2 * 2 ^ (p - 2) = 2 ^ (Suc (p - 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2::'a) * (2::'a) ^ (p - 2) = (2::'a) ^ Suc (p - 2)", "by simp"], ["proof (state)\nthis:\n  (2::?'a2) * (2::?'a2) ^ (p - 2) = (2::?'a2) ^ Suc (p - 2)\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (2::?'a2) * (2::?'a2) ^ (p - 2) = (2::?'a2) ^ Suc (p - 2)\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "from \\<open>p > 2\\<close>"], ["proof (chain)\npicking this:\n  2 < p", "have \"Suc (p - 2) = p - 1\""], ["proof (prove)\nusing this:\n  2 < p\n\ngoal (1 subgoal):\n 1. Suc (p - 2) = p - 1", "by linarith"], ["proof (state)\nthis:\n  Suc (p - 2) = p - 1\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  Suc (p - 2) = p - 1\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "have \"(2 - sqrt 3) ^ (2 ^ (p - 2)) * (2 + sqrt 3) ^ (2 ^ (p - 2)) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 - sqrt 3) ^ 2 ^ (p - 2) * (2 + sqrt 3) ^ 2 ^ (p - 2) = 1", "by (subst power_mult_distrib [symmetric]) (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  (2 - sqrt 3) ^ 2 ^ (p - 2) * (2 + sqrt 3) ^ 2 ^ (p - 2) = 1\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  (2 + sqrt 3) ^ 2 ^ (p - 1) =\n  real_of_int k * (2 ^ p - 1) * (2 + sqrt 3) ^ 2 ^ (p - 2) - 1", "have \"(2 + sqrt 3) ^ (2 ^ (p - 1)) =\n                  real_of_int k * (2 ^ p - 1) * (2 + sqrt 3) ^ (2 ^ (p - 2)) - 1\""], ["proof (prove)\nusing this:\n  (2 + sqrt 3) ^ 2 ^ (p - 1) =\n  real_of_int k * (2 ^ p - 1) * (2 + sqrt 3) ^ 2 ^ (p - 2) - 1\n\ngoal (1 subgoal):\n 1. (2 + sqrt 3) ^ 2 ^ (p - 1) =\n    real_of_int k * (2 ^ p - 1) * (2 + sqrt 3) ^ 2 ^ (p - 2) - 1", "."], ["proof (state)\nthis:\n  (2 + sqrt 3) ^ 2 ^ (p - 1) =\n  real_of_int k * (2 ^ p - 1) * (2 + sqrt 3) ^ 2 ^ (p - 2) - 1\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (2 + sqrt 3) ^ 2 ^ (p - 1) =\n  real_of_int k * (2 ^ p - 1) * (2 + sqrt 3) ^ 2 ^ (p - 2) - 1\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "have \"(2 + sqrt 3) ^ (2 ^ (p - 1)) =\n               lucas_lehmer_to_real ((2, 1) [^]\\<^bsub>R\\<^esub> (2 ^ (p - 1) :: nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 + sqrt 3) ^ 2 ^ (p - 1) =\n    lucas_lehmer_to_real ((2, 1) [^]\\<^bsub>R\\<^esub> 2 ^ (p - 1))", "by (simp add: lucas_lehmer_to_real_simps)"], ["proof (state)\nthis:\n  (2 + sqrt 3) ^ 2 ^ (p - 1) =\n  lucas_lehmer_to_real ((2, 1) [^]\\<^bsub>R\\<^esub> 2 ^ (p - 1))\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (2 + sqrt 3) ^ 2 ^ (p - 1) =\n  lucas_lehmer_to_real ((2, 1) [^]\\<^bsub>R\\<^esub> 2 ^ (p - 1))\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "have \"real_of_int k * (2 ^ p - 1) * (2 + sqrt 3) ^ (2 ^ (p - 2)) - 1 =\n               lucas_lehmer_to_real ((k * (2 ^ p - 1), 0) \\<otimes>\\<^bsub>R\\<^esub>\n                 (2, 1) [^]\\<^bsub>R\\<^esub> (2 ^ (p - 2) :: nat) \\<oplus>\\<^bsub>R\\<^esub> \\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int k * (2 ^ p - 1) * (2 + sqrt 3) ^ 2 ^ (p - 2) - 1 =\n    lucas_lehmer_to_real\n     ((k * (2 ^ p - 1), 0) \\<otimes>\\<^bsub>R\\<^esub>\n      (2, 1) [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n      \\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>)", "by (simp add: lucas_lehmer_to_real_simps)"], ["proof (state)\nthis:\n  real_of_int k * (2 ^ p - 1) * (2 + sqrt 3) ^ 2 ^ (p - 2) - 1 =\n  lucas_lehmer_to_real\n   ((k * (2 ^ p - 1), 0) \\<otimes>\\<^bsub>R\\<^esub>\n    (2, 1) [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n    \\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  lucas_lehmer_to_real ((2, 1) [^]\\<^bsub>R\\<^esub> 2 ^ (p - 1)) =\n  lucas_lehmer_to_real\n   ((k * (2 ^ p - 1), 0) \\<otimes>\\<^bsub>R\\<^esub>\n    (2, 1) [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n    \\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>)", "have \"((2, 1) [^]\\<^bsub>R\\<^esub> (2 ^ (p - 1) :: nat)) =\n                ((k * (2 ^ p - 1), 0) \\<otimes>\\<^bsub>R\\<^esub> (2, 1) [^]\\<^bsub>R\\<^esub> (2 ^ (p - 2) :: nat) \\<oplus>\\<^bsub>R\\<^esub> \\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>)\""], ["proof (prove)\nusing this:\n  lucas_lehmer_to_real ((2, 1) [^]\\<^bsub>R\\<^esub> 2 ^ (p - 1)) =\n  lucas_lehmer_to_real\n   ((k * (2 ^ p - 1), 0) \\<otimes>\\<^bsub>R\\<^esub>\n    (2, 1) [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n    \\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>)\n\ngoal (1 subgoal):\n 1. (2, 1) [^]\\<^bsub>R\\<^esub> 2 ^ (p - 1) =\n    (k * (2 ^ p - 1), 0) \\<otimes>\\<^bsub>R\\<^esub>\n    (2, 1) [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n    \\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>", "by (rule injD[OF lucas_lehmer_to_real_inj])"], ["proof (state)\nthis:\n  (2, 1) [^]\\<^bsub>R\\<^esub> 2 ^ (p - 1) =\n  (k * (2 ^ p - 1), 0) \\<otimes>\\<^bsub>R\\<^esub>\n  (2, 1) [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n  \\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "hence \"\\<phi> ((2, 1) [^]\\<^bsub>R\\<^esub> (2 ^ (p - 1) :: nat)) =\n           \\<phi> ((k * (2 ^ p - 1), 0) \\<otimes>\\<^bsub>R\\<^esub> (2, 1) [^]\\<^bsub>R\\<^esub> (2 ^ (p - 2) :: nat) \\<oplus>\\<^bsub>R\\<^esub> \\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>)\""], ["proof (prove)\nusing this:\n  (2, 1) [^]\\<^bsub>R\\<^esub> 2 ^ (p - 1) =\n  (k * (2 ^ p - 1), 0) \\<otimes>\\<^bsub>R\\<^esub>\n  (2, 1) [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n  \\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<phi> ((2, 1) [^]\\<^bsub>R\\<^esub> 2 ^ (p - 1)) =\n    \\<phi>\n     ((k * (2 ^ p - 1), 0) \\<otimes>\\<^bsub>R\\<^esub>\n      (2, 1) [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n      \\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>)", "by (simp only:)"], ["proof (state)\nthis:\n  \\<phi> ((2, 1) [^]\\<^bsub>R\\<^esub> 2 ^ (p - 1)) =\n  \\<phi>\n   ((k * (2 ^ p - 1), 0) \\<otimes>\\<^bsub>R\\<^esub>\n    (2, 1) [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n    \\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  \\<phi> ((2, 1) [^]\\<^bsub>R\\<^esub> 2 ^ (p - 1)) =\n  \\<phi>\n   ((k * (2 ^ p - 1), 0) \\<otimes>\\<^bsub>R\\<^esub>\n    (2, 1) [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n    \\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "have \"\\<phi> ((2, 1) [^]\\<^bsub>R\\<^esub> (2 ^ (p - 1) :: nat)) = \\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> (2 ^ (p - 1) :: nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> ((2, 1) [^]\\<^bsub>R\\<^esub> 2 ^ (p - 1)) =\n    \\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> 2 ^ (p - 1)", "by simp"], ["proof (state)\nthis:\n  \\<phi> ((2, 1) [^]\\<^bsub>R\\<^esub> 2 ^ (p - 1)) =\n  \\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> 2 ^ (p - 1)\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  \\<phi> ((2, 1) [^]\\<^bsub>R\\<^esub> 2 ^ (p - 1)) =\n  \\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> 2 ^ (p - 1)\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  \\<phi> ((2, 1) [^]\\<^bsub>R\\<^esub> 2 ^ (p - 1)) =\n  \\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> 2 ^ (p - 1)\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "have \"int q dvd int (2 ^ p - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int q dvd int (2 ^ p - 1)", "by (subst int_dvd_int_iff) (use q in auto)"], ["proof (state)\nthis:\n  int q dvd int (2 ^ p - 1)\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  int q dvd int (2 ^ p - 1)\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "have \"int (2 ^ p - 1) = 2 ^ p - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (2 ^ p - 1) = 2 ^ p - 1", "by (simp add: of_nat_diff)"], ["proof (state)\nthis:\n  int (2 ^ p - 1) = 2 ^ p - 1\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  int q dvd 2 ^ p - 1", "have \"\\<phi> (k * (2 ^ p - 1), 0) = \\<zero>\\<^bsub>S\\<^esub>\""], ["proof (prove)\nusing this:\n  int q dvd 2 ^ p - 1\n\ngoal (1 subgoal):\n 1. \\<phi> (k * (2 ^ p - 1), 0) = \\<zero>\\<^bsub>S\\<^esub>", "by (simp add: \\<phi>_def lucas_lehmer_hom_def S_def lucas_lehmer_ring_mod_def)"], ["proof (state)\nthis:\n  \\<phi> (k * (2 ^ p - 1), 0) = \\<zero>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  \\<phi> (k * (2 ^ p - 1), 0) = \\<zero>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "hence \"\\<phi> ((k * (2 ^ p - 1), 0) \\<otimes>\\<^bsub>R\\<^esub> (2, 1) [^]\\<^bsub>R\\<^esub> (2 ^ (p - 2) :: nat) \\<oplus>\\<^bsub>R\\<^esub> \\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) = \n           \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<phi> (k * (2 ^ p - 1), 0) = \\<zero>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<phi>\n     ((k * (2 ^ p - 1), 0) \\<otimes>\\<^bsub>R\\<^esub>\n      (2, 1) [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n      \\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "by simp"], ["proof (state)\nthis:\n  \\<phi>\n   ((k * (2 ^ p - 1), 0) \\<otimes>\\<^bsub>R\\<^esub>\n    (2, 1) [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n    \\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) =\n  \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  \\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> 2 ^ (p - 1) =\n  \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "have eq: \"\\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> (2 ^ (p - 1) :: nat) = \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> 2 ^ (p - 1) =\n  \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> 2 ^ (p - 1) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "."], ["proof (state)\nthis:\n  \\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> 2 ^ (p - 1) =\n  \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "have \"\\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> (2 ^ p :: nat) = \\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> (2 ^ (p - 1) * 2 :: nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> 2 ^ p =\n    \\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> (2 ^ (p - 1) * 2)", "using \\<open>p > 2\\<close>"], ["proof (prove)\nusing this:\n  2 < p\n\ngoal (1 subgoal):\n 1. \\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> 2 ^ p =\n    \\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> (2 ^ (p - 1) * 2)", "by (cases p) (auto simp: mult_ac)"], ["proof (state)\nthis:\n  \\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> 2 ^ p =\n  \\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> (2 ^ (p - 1) * 2)\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  \\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> 2 ^ p =\n  \\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> (2 ^ (p - 1) * 2)\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "have \"\\<dots> = (\\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> (2 ^ (p - 1) :: nat)) [^]\\<^bsub>S\\<^esub> (2 :: nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> (2 ^ (p - 1) * 2) =\n    (\\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> 2 ^ (p - 1)) [^]\\<^bsub>S\\<^esub> 2", "by (subst S.nat_pow_pow) auto"], ["proof (state)\nthis:\n  \\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> (2 ^ (p - 1) * 2) =\n  (\\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> 2 ^ (p - 1)) [^]\\<^bsub>S\\<^esub> 2\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  \\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> (2 ^ (p - 1) * 2) =\n  (\\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> 2 ^ (p - 1)) [^]\\<^bsub>S\\<^esub> 2\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "have \"\\<dots> = \\<one>\\<^bsub>S\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> 2 ^ (p - 1)) [^]\\<^bsub>S\\<^esub>\n    2 =\n    \\<one>\\<^bsub>S\\<^esub>", "by (subst eq) (auto simp: numeral_2_eq_2 S.l_minus)"], ["proof (state)\nthis:\n  (\\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> 2 ^ (p - 1)) [^]\\<^bsub>S\\<^esub> 2 =\n  \\<one>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  \\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> 2 ^ p = \\<one>\\<^bsub>S\\<^esub>", "have eq': \"\\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> (2 ^ p :: nat) = \\<one>\\<^bsub>S\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> 2 ^ p = \\<one>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> 2 ^ p = \\<one>\\<^bsub>S\\<^esub>", "."], ["proof (state)\nthis:\n  \\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> 2 ^ p = \\<one>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "from eq'"], ["proof (chain)\npicking this:\n  \\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> 2 ^ p = \\<one>\\<^bsub>S\\<^esub>", "have unit: \"\\<phi> (2, 1) \\<in> Units S\""], ["proof (prove)\nusing this:\n  \\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> 2 ^ p = \\<one>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<phi> (2, 1) \\<in> Units S", "by (rule S.pow_nat_eq_1_imp_unit) auto"], ["proof (state)\nthis:\n  \\<phi> (2, 1) \\<in> Units S\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "have neg_one_not_one: \"\\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub> \\<noteq> \\<one>\\<^bsub>S\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub> \\<noteq>\n    \\<one>\\<^bsub>S\\<^esub>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub> =\n    \\<one>\\<^bsub>S\\<^esub> \\<Longrightarrow>\n    False", "assume *: \"\\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub> = \\<one>\\<^bsub>S\\<^esub>\""], ["proof (state)\nthis:\n  \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub> =\n  \\<one>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub> =\n    \\<one>\\<^bsub>S\\<^esub> \\<Longrightarrow>\n    False", "have \"(\\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>) \\<oplus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub> = \\<zero>\\<^bsub>S\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub> \\<oplus>\\<^bsub>S\\<^esub>\n    \\<one>\\<^bsub>S\\<^esub> =\n    \\<zero>\\<^bsub>S\\<^esub>", "by (rule S.l_neg) auto"], ["proof (state)\nthis:\n  \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub> \\<oplus>\\<^bsub>S\\<^esub>\n  \\<one>\\<^bsub>S\\<^esub> =\n  \\<zero>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub> =\n    \\<one>\\<^bsub>S\\<^esub> \\<Longrightarrow>\n    False", "hence \"\\<one>\\<^bsub>S\\<^esub> \\<oplus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub> = \\<zero>\\<^bsub>S\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub> \\<oplus>\\<^bsub>S\\<^esub>\n  \\<one>\\<^bsub>S\\<^esub> =\n  \\<zero>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<one>\\<^bsub>S\\<^esub> \\<oplus>\\<^bsub>S\\<^esub>\n    \\<one>\\<^bsub>S\\<^esub> =\n    \\<zero>\\<^bsub>S\\<^esub>", "by (simp only: *)"], ["proof (state)\nthis:\n  \\<one>\\<^bsub>S\\<^esub> \\<oplus>\\<^bsub>S\\<^esub>\n  \\<one>\\<^bsub>S\\<^esub> =\n  \\<zero>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub> =\n    \\<one>\\<^bsub>S\\<^esub> \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  \\<one>\\<^bsub>S\\<^esub> \\<oplus>\\<^bsub>S\\<^esub>\n  \\<one>\\<^bsub>S\\<^esub> =\n  \\<zero>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. False", "using \\<open>q > 2\\<close>"], ["proof (prove)\nusing this:\n  \\<one>\\<^bsub>S\\<^esub> \\<oplus>\\<^bsub>S\\<^esub>\n  \\<one>\\<^bsub>S\\<^esub> =\n  \\<zero>\\<^bsub>S\\<^esub>\n  2 < q\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: S_def lucas_lehmer_ring_mod_def lucas_lehmer_add_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub> \\<noteq>\n  \\<one>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "have fin: \"finite (Units S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Units S)", "by (rule finite_subset[of _ \"carrier S\"]) (auto simp: Units_def S_def lucas_lehmer_ring_mod_def)"], ["proof (state)\nthis:\n  finite (Units S)\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "have \"group.ord S' (\\<phi> (2, 1)) = 2 ^ p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S'.ord (\\<phi> (2, 1)) = 2 ^ p", "using \\<open>p > 2\\<close> eq eq' unit neg_one_not_one"], ["proof (prove)\nusing this:\n  2 < p\n  \\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> 2 ^ (p - 1) =\n  \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>\n  \\<phi> (2, 1) [^]\\<^bsub>S\\<^esub> 2 ^ p = \\<one>\\<^bsub>S\\<^esub>\n  \\<phi> (2, 1) \\<in> Units S\n  \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub> \\<noteq>\n  \\<one>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. S'.ord (\\<phi> (2, 1)) = 2 ^ p", "by (intro S'.ord_eqI_prime_factors)\n       (auto simp: prime_factors_power prime_factorization_prime\n                   S'_def S.units_of_pow units_of_carrier units_of_one power_diff)"], ["proof (state)\nthis:\n  S'.ord (\\<phi> (2, 1)) = 2 ^ p\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "hence \"2 ^ p = group.ord S' (\\<phi> (2, 1))\""], ["proof (prove)\nusing this:\n  S'.ord (\\<phi> (2, 1)) = 2 ^ p\n\ngoal (1 subgoal):\n 1. 2 ^ p = S'.ord (\\<phi> (2, 1))", "by simp"], ["proof (state)\nthis:\n  2 ^ p = S'.ord (\\<phi> (2, 1))\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  2 ^ p = S'.ord (\\<phi> (2, 1))\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "have \"\\<dots> = card (generate S' {\\<phi> (2, 1)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S'.ord (\\<phi> (2, 1)) = card (generate S' {\\<phi> (2, 1)})", "using unit fin"], ["proof (prove)\nusing this:\n  \\<phi> (2, 1) \\<in> Units S\n  finite (Units S)\n\ngoal (1 subgoal):\n 1. S'.ord (\\<phi> (2, 1)) = card (generate S' {\\<phi> (2, 1)})", "by (intro S'.generate_pow_card) (auto simp: S'_def units_of_carrier)"], ["proof (state)\nthis:\n  S'.ord (\\<phi> (2, 1)) = card (generate S' {\\<phi> (2, 1)})\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  S'.ord (\\<phi> (2, 1)) = card (generate S' {\\<phi> (2, 1)})\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "have \"\\<dots> \\<le> card (carrier S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (generate S' {\\<phi> (2, 1)}) \\<le> card (carrier S')", "using fin unit"], ["proof (prove)\nusing this:\n  finite (Units S)\n  \\<phi> (2, 1) \\<in> Units S\n\ngoal (1 subgoal):\n 1. card (generate S' {\\<phi> (2, 1)}) \\<le> card (carrier S')", "by (intro card_mono S'.generate_incl) (auto simp: S'_def units_of_carrier)"], ["proof (state)\nthis:\n  card (generate S' {\\<phi> (2, 1)}) \\<le> card (carrier S')\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  card (generate S' {\\<phi> (2, 1)}) \\<le> card (carrier S')\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "have \"\\<dots> < q ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (carrier S') < q\\<^sup>2", "unfolding S'_def S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (carrier (units_of (lucas_lehmer_ring_mod q))) < q\\<^sup>2", "using card_lucas_lehmer_Units[of q] \\<open>q > 2\\<close>"], ["proof (prove)\nusing this:\n  1 < q \\<Longrightarrow> card (Units (lucas_lehmer_ring_mod q)) < q\\<^sup>2\n  2 < q\n\ngoal (1 subgoal):\n 1. card (carrier (units_of (lucas_lehmer_ring_mod q))) < q\\<^sup>2", "by (auto simp: units_of_carrier)"], ["proof (state)\nthis:\n  card (carrier S') < q\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  card (carrier S') < q\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "note \\<open>q ^ 2 \\<le> 2 ^ p - 1\\<close>"], ["proof (state)\nthis:\n  q\\<^sup>2 \\<le> 2 ^ p - 1\n\ngoal (1 subgoal):\n 1. \\<not> prime (2 ^ p - 1) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  2 ^ p < 2 ^ p - 1", "show False"], ["proof (prove)\nusing this:\n  2 ^ p < 2 ^ p - 1\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Next, we show that any Mersenne prime passes the Lucas--Lehmer test. We again follow the\n  rather explicit proof outlined on Wikipedia~\\cite{wiki:lucas_lehmer}, which is a simplified\n  (but less general and less abstract) version of the proof by R?dseth~\\cite{roedseth94}.\n\\<close>"], ["", "theorem (in mersenne_prime) lucas_lehmer_necessary:\n  \"(2 ^ p - 1) dvd gen_lucas_lehmer_sequence 4 (p - 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "write lucas_lehmer_ring (\"R\")"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "define S where \"S = lucas_lehmer_ring_mod M\""], ["proof (state)\nthis:\n  S = lucas_lehmer_ring_mod M\n\ngoal (1 subgoal):\n 1. 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "define S' where \"S' = units_of S\""], ["proof (state)\nthis:\n  S' = units_of S\n\ngoal (1 subgoal):\n 1. 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "define \\<phi> where \"\\<phi> = lucas_lehmer_hom M\""], ["proof (state)\nthis:\n  \\<phi> = lucas_lehmer_hom M\n\ngoal (1 subgoal):\n 1. 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "interpret R: cring R"], ["proof (prove)\ngoal (1 subgoal):\n 1. cring R", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "interpret S: cring S"], ["proof (prove)\ngoal (1 subgoal):\n 1. cring S", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cring (lucas_lehmer_ring_mod M)", "by (rule cring_lucas_lehmer_ring_mod) (use M_gt_6 in auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "interpret S': comm_group S'"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_group S'", "unfolding S'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_group (units_of S)", "by (rule S.units_comm_group)"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "have \"\\<phi> \\<in> ring_hom R S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> \\<in> ring_hom R S", "unfolding \\<phi>_def S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_hom M \\<in> ring_hom R (lucas_lehmer_ring_mod M)", "by (rule ring_hom_lucas_lehmer_hom) (use M_gt_6 in auto)"], ["proof (state)\nthis:\n  \\<phi> \\<in> ring_hom R S\n\ngoal (1 subgoal):\n 1. 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "interpret \\<phi>: ring_hom_cring R S \\<phi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_hom_cring R S \\<phi>", "by standard fact"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "have R_pow_int: \"(n, 0) [^]\\<^bsub>R\\<^esub> m = (n ^ m, 0)\" for n :: int and m :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. (n, 0) [^]\\<^bsub>R\\<^esub> m = (n ^ m, 0)", "by (induction m; simp; simp add: lucas_lehmer_ring_def lucas_lehmer_mult'_def)"], ["proof (state)\nthis:\n  (?n1, 0) [^]\\<^bsub>R\\<^esub> ?m1 = (?n1 ^ ?m1, 0)\n\ngoal (1 subgoal):\n 1. 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "have \"add_pow R n \\<one>\\<^bsub>R\\<^esub> = (int n, 0)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. [n] \\<cdot>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub> = (int n, 0)", "by (induction n; simp; simp add: lucas_lehmer_ring_def lucas_lehmer_add'_def)"], ["proof (state)\nthis:\n  [?n1] \\<cdot>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub> = (int ?n1, 0)\n\ngoal (1 subgoal):\n 1. 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "hence \"add_pow R M \\<one>\\<^bsub>R\\<^esub> = (int M, 0)\""], ["proof (prove)\nusing this:\n  [?n1] \\<cdot>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub> = (int ?n1, 0)\n\ngoal (1 subgoal):\n 1. [M] \\<cdot>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub> = (int M, 0)", "by simp"], ["proof (state)\nthis:\n  [M] \\<cdot>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub> = (int M, 0)\n\ngoal (1 subgoal):\n 1. 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "also"], ["proof (state)\nthis:\n  [M] \\<cdot>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub> = (int M, 0)\n\ngoal (1 subgoal):\n 1. 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "have \"\\<phi> \\<dots> = \\<zero>\\<^bsub>S\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (int M, 0) = \\<zero>\\<^bsub>S\\<^esub>", "by (simp add: \\<phi>_def S_def lucas_lehmer_ring_mod_def lucas_lehmer_hom_def)"], ["proof (state)\nthis:\n  \\<phi> (int M, 0) = \\<zero>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "finally"], ["proof (chain)\npicking this:\n  \\<phi> ([M] \\<cdot>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) =\n  \\<zero>\\<^bsub>S\\<^esub>", "have \"add_pow S M \\<one>\\<^bsub>S\\<^esub> = \\<zero>\\<^bsub>S\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<phi> ([M] \\<cdot>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) =\n  \\<zero>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. [M] \\<cdot>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub> =\n    \\<zero>\\<^bsub>S\\<^esub>", "by (simp add: \\<phi>.hom_add_pow_nat)"], ["proof (state)\nthis:\n  [M] \\<cdot>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub> =\n  \\<zero>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "define \\<sigma> :: \"int \\<times> int\" where \"\\<sigma> = (0, 2)\""], ["proof (state)\nthis:\n  \\<sigma> = (0, 2)\n\ngoal (1 subgoal):\n 1. 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "have eq1: \"\\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, -2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "have \"(6, 2) = (6, 0) \\<oplus>\\<^bsub>R\\<^esub> \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (6, 2) = (6, 0) \\<oplus>\\<^bsub>R\\<^esub> \\<sigma>", "by (simp add: lucas_lehmer_ring_def \\<sigma>_def lucas_lehmer_add'_def)"], ["proof (state)\nthis:\n  (6, 2) = (6, 0) \\<oplus>\\<^bsub>R\\<^esub> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "also"], ["proof (state)\nthis:\n  (6, 2) = (6, 0) \\<oplus>\\<^bsub>R\\<^esub> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "have \"\\<phi> (\\<dots> [^]\\<^bsub>R\\<^esub> M) = \\<phi> ((6, 0) [^]\\<^bsub>R\\<^esub> M) \\<oplus>\\<^bsub>S\\<^esub> \\<phi> (\\<sigma> [^]\\<^bsub>R\\<^esub> M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\n     (((6, 0) \\<oplus>\\<^bsub>R\\<^esub> \\<sigma>) [^]\\<^bsub>R\\<^esub> M) =\n    \\<phi> ((6, 0) [^]\\<^bsub>R\\<^esub> M) \\<oplus>\\<^bsub>S\\<^esub>\n    \\<phi> (\\<sigma> [^]\\<^bsub>R\\<^esub> M)", "using prime and \\<open>add_pow S M \\<one>\\<^bsub>S\\<^esub> = \\<zero>\\<^bsub>S\\<^esub>\\<close>"], ["proof (prove)\nusing this:\n  prime M\n  [M] \\<cdot>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub> =\n  \\<zero>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<phi>\n     (((6, 0) \\<oplus>\\<^bsub>R\\<^esub> \\<sigma>) [^]\\<^bsub>R\\<^esub> M) =\n    \\<phi> ((6, 0) [^]\\<^bsub>R\\<^esub> M) \\<oplus>\\<^bsub>S\\<^esub>\n    \\<phi> (\\<sigma> [^]\\<^bsub>R\\<^esub> M)", "by (simp add: S.binomial_finite_char)"], ["proof (state)\nthis:\n  \\<phi>\n   (((6, 0) \\<oplus>\\<^bsub>R\\<^esub> \\<sigma>) [^]\\<^bsub>R\\<^esub> M) =\n  \\<phi> ((6, 0) [^]\\<^bsub>R\\<^esub> M) \\<oplus>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<sigma> [^]\\<^bsub>R\\<^esub> M)\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "also"], ["proof (state)\nthis:\n  \\<phi>\n   (((6, 0) \\<oplus>\\<^bsub>R\\<^esub> \\<sigma>) [^]\\<^bsub>R\\<^esub> M) =\n  \\<phi> ((6, 0) [^]\\<^bsub>R\\<^esub> M) \\<oplus>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<sigma> [^]\\<^bsub>R\\<^esub> M)\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "have \"(6, 0) [^]\\<^bsub>R\\<^esub> M = (6 ^ M, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (6, 0) [^]\\<^bsub>R\\<^esub> M = (6 ^ M, 0)", "by (simp add: R_pow_int)"], ["proof (state)\nthis:\n  (6, 0) [^]\\<^bsub>R\\<^esub> M = (6 ^ M, 0)\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "also"], ["proof (state)\nthis:\n  (6, 0) [^]\\<^bsub>R\\<^esub> M = (6 ^ M, 0)\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "have \"[6 ^ M = 6] (mod (int M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [6 ^ M = 6] (mod int M)", "using M_gt_6"], ["proof (prove)\nusing this:\n  6 < M\n\ngoal (1 subgoal):\n 1. [6 ^ M = 6] (mod int M)", "by (intro little_Fermat_int) (use prime in \\<open>auto simp flip: dvd_nat_abs_iff\\<close>)"], ["proof (state)\nthis:\n  [6 ^ M = 6] (mod int M)\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "hence \"\\<phi> (6 ^ M, 0) = \\<phi> (6, 0)\""], ["proof (prove)\nusing this:\n  [6 ^ M = 6] (mod int M)\n\ngoal (1 subgoal):\n 1. \\<phi> (6 ^ M, 0) = \\<phi> (6, 0)", "unfolding \\<phi>_def"], ["proof (prove)\nusing this:\n  [6 ^ M = 6] (mod int M)\n\ngoal (1 subgoal):\n 1. lucas_lehmer_hom M (6 ^ M, 0) = lucas_lehmer_hom M (6, 0)", "by (intro lucas_lehmer_hom_cong) auto"], ["proof (state)\nthis:\n  \\<phi> (6 ^ M, 0) = \\<phi> (6, 0)\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "also"], ["proof (state)\nthis:\n  \\<phi> (6 ^ M, 0) = \\<phi> (6, 0)\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "have \"\\<sigma> = (2, 0) \\<otimes>\\<^bsub>R\\<^esub> (0, 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> = (2, 0) \\<otimes>\\<^bsub>R\\<^esub> (0, 1)", "by (simp add: \\<sigma>_def lucas_lehmer_ring_def lucas_lehmer_mult'_def)"], ["proof (state)\nthis:\n  \\<sigma> = (2, 0) \\<otimes>\\<^bsub>R\\<^esub> (0, 1)\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "hence \"\\<phi> (\\<sigma> [^]\\<^bsub>R\\<^esub> M) = \\<phi> ((2, 0) [^]\\<^bsub>R\\<^esub> M \\<otimes>\\<^bsub>R\\<^esub> (0, 1) [^]\\<^bsub>R\\<^esub> M)\""], ["proof (prove)\nusing this:\n  \\<sigma> = (2, 0) \\<otimes>\\<^bsub>R\\<^esub> (0, 1)\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<sigma> [^]\\<^bsub>R\\<^esub> M) =\n    \\<phi>\n     ((2, 0) [^]\\<^bsub>R\\<^esub> M \\<otimes>\\<^bsub>R\\<^esub>\n      (0, 1) [^]\\<^bsub>R\\<^esub> M)", "by (subst R.nat_pow_distrib [symmetric]) auto"], ["proof (state)\nthis:\n  \\<phi> (\\<sigma> [^]\\<^bsub>R\\<^esub> M) =\n  \\<phi>\n   ((2, 0) [^]\\<^bsub>R\\<^esub> M \\<otimes>\\<^bsub>R\\<^esub>\n    (0, 1) [^]\\<^bsub>R\\<^esub> M)\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "also"], ["proof (state)\nthis:\n  \\<phi> (\\<sigma> [^]\\<^bsub>R\\<^esub> M) =\n  \\<phi>\n   ((2, 0) [^]\\<^bsub>R\\<^esub> M \\<otimes>\\<^bsub>R\\<^esub>\n    (0, 1) [^]\\<^bsub>R\\<^esub> M)\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "have \"\\<dots> = \\<phi> ((2, 0) [^]\\<^bsub>R\\<^esub> M) \\<otimes>\\<^bsub>S\\<^esub> \\<phi> ((0, 1) [^]\\<^bsub>R\\<^esub> M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\n     ((2, 0) [^]\\<^bsub>R\\<^esub> M \\<otimes>\\<^bsub>R\\<^esub>\n      (0, 1) [^]\\<^bsub>R\\<^esub> M) =\n    \\<phi> ((2, 0) [^]\\<^bsub>R\\<^esub> M) \\<otimes>\\<^bsub>S\\<^esub>\n    \\<phi> ((0, 1) [^]\\<^bsub>R\\<^esub> M)", "by simp"], ["proof (state)\nthis:\n  \\<phi>\n   ((2, 0) [^]\\<^bsub>R\\<^esub> M \\<otimes>\\<^bsub>R\\<^esub>\n    (0, 1) [^]\\<^bsub>R\\<^esub> M) =\n  \\<phi> ((2, 0) [^]\\<^bsub>R\\<^esub> M) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> ((0, 1) [^]\\<^bsub>R\\<^esub> M)\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "also"], ["proof (state)\nthis:\n  \\<phi>\n   ((2, 0) [^]\\<^bsub>R\\<^esub> M \\<otimes>\\<^bsub>R\\<^esub>\n    (0, 1) [^]\\<^bsub>R\\<^esub> M) =\n  \\<phi> ((2, 0) [^]\\<^bsub>R\\<^esub> M) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> ((0, 1) [^]\\<^bsub>R\\<^esub> M)\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "have \"(2, 0) [^]\\<^bsub>R\\<^esub> M = (2 ^ M, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2, 0) [^]\\<^bsub>R\\<^esub> M = (2 ^ M, 0)", "by (simp add: R_pow_int)"], ["proof (state)\nthis:\n  (2, 0) [^]\\<^bsub>R\\<^esub> M = (2 ^ M, 0)\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "also"], ["proof (state)\nthis:\n  (2, 0) [^]\\<^bsub>R\\<^esub> M = (2 ^ M, 0)\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "have \"[2 ^ M = 2] (mod int M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [2 ^ M = 2] (mod int M)", "using M_gt_6 prime"], ["proof (prove)\nusing this:\n  6 < M\n  prime M\n\ngoal (1 subgoal):\n 1. [2 ^ M = 2] (mod int M)", "by (intro little_Fermat_int) (auto simp flip: dvd_nat_abs_iff dest: dvd_imp_le)"], ["proof (state)\nthis:\n  [2 ^ M = 2] (mod int M)\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "hence \"\\<phi> (2 ^ M, 0) = \\<phi> (2, 0)\""], ["proof (prove)\nusing this:\n  [2 ^ M = 2] (mod int M)\n\ngoal (1 subgoal):\n 1. \\<phi> (2 ^ M, 0) = \\<phi> (2, 0)", "unfolding \\<phi>_def"], ["proof (prove)\nusing this:\n  [2 ^ M = 2] (mod int M)\n\ngoal (1 subgoal):\n 1. lucas_lehmer_hom M (2 ^ M, 0) = lucas_lehmer_hom M (2, 0)", "by (intro lucas_lehmer_hom_cong) auto"], ["proof (state)\nthis:\n  \\<phi> (2 ^ M, 0) = \\<phi> (2, 0)\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "also"], ["proof (state)\nthis:\n  \\<phi> (2 ^ M, 0) = \\<phi> (2, 0)\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "have M_eq: \"M = Suc (2 * ((M - 1) div 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M = Suc (2 * ((M - 1) div 2))", "using M_odd"], ["proof (prove)\nusing this:\n  odd M\n\ngoal (1 subgoal):\n 1. M = Suc (2 * ((M - 1) div 2))", "by auto"], ["proof (state)\nthis:\n  M = Suc (2 * ((M - 1) div 2))\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "have \"(0, 1) [^]\\<^bsub>R\\<^esub> M = (0, 1) \\<otimes>\\<^bsub>R\\<^esub> ((0, 1) [^]\\<^bsub>R\\<^esub> (2::nat)) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0, 1) [^]\\<^bsub>R\\<^esub> M =\n    (0, 1) \\<otimes>\\<^bsub>R\\<^esub>\n    ((0, 1) [^]\\<^bsub>R\\<^esub> 2) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)", "by (subst M_eq) (auto simp: R.nat_pow_mult R.nat_pow_pow R.cring_simprules)"], ["proof (state)\nthis:\n  (0, 1) [^]\\<^bsub>R\\<^esub> M =\n  (0, 1) \\<otimes>\\<^bsub>R\\<^esub>\n  ((0, 1) [^]\\<^bsub>R\\<^esub> 2) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "also"], ["proof (state)\nthis:\n  (0, 1) [^]\\<^bsub>R\\<^esub> M =\n  (0, 1) \\<otimes>\\<^bsub>R\\<^esub>\n  ((0, 1) [^]\\<^bsub>R\\<^esub> 2) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "have \"(0, 1) [^]\\<^bsub>R\\<^esub> (2::nat) = (3, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0, 1) [^]\\<^bsub>R\\<^esub> 2 = (3, 0)", "by (simp add: eval_nat_numeral) (simp add: lucas_lehmer_ring_def lucas_lehmer_mult'_def)"], ["proof (state)\nthis:\n  (0, 1) [^]\\<^bsub>R\\<^esub> 2 = (3, 0)\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "also"], ["proof (state)\nthis:\n  (0, 1) [^]\\<^bsub>R\\<^esub> 2 = (3, 0)\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "have \"\\<phi> ((0, 1) \\<otimes>\\<^bsub>R\\<^esub> (3, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) = \n                 \\<phi> ((3, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) \\<otimes>\\<^bsub>S\\<^esub> \\<phi> (0, 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\n     ((0, 1) \\<otimes>\\<^bsub>R\\<^esub>\n      (3, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n    \\<phi>\n     ((3, 0) [^]\\<^bsub>R\\<^esub>\n      ((M - 1) div 2)) \\<otimes>\\<^bsub>S\\<^esub>\n    \\<phi> (0, 1)", "by (simp add: S.cring_simprules)"], ["proof (state)\nthis:\n  \\<phi>\n   ((0, 1) \\<otimes>\\<^bsub>R\\<^esub>\n    (3, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n  \\<phi>\n   ((3, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (0, 1)\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "also"], ["proof (state)\nthis:\n  \\<phi>\n   ((0, 1) \\<otimes>\\<^bsub>R\\<^esub>\n    (3, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n  \\<phi>\n   ((3, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (0, 1)\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "have \"(3, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2) = (3 ^ ((M - 1) div 2), 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (3, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2) = (3 ^ ((M - 1) div 2), 0)", "by (simp add: R_pow_int)"], ["proof (state)\nthis:\n  (3, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2) = (3 ^ ((M - 1) div 2), 0)\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "also"], ["proof (state)\nthis:\n  (3, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2) = (3 ^ ((M - 1) div 2), 0)\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "have \"\\<phi> (3 ^ ((M - 1) div 2), 0) = \\<phi> (-1, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (3 ^ ((M - 1) div 2), 0) = \\<phi> (- 1, 0)", "unfolding \\<phi>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_hom M (3 ^ ((M - 1) div 2), 0) =\n    lucas_lehmer_hom M (- 1, 0)", "proof (intro lucas_lehmer_hom_cong')"], ["proof (state)\ngoal (2 subgoals):\n 1. [3 ^ ((M - 1) div 2) = - 1] (mod int M)\n 2. [0 = 0] (mod int M)", "have \"[3 ^ ((M - 1) div 2) = Legendre 3 M] (mod int M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [3 ^ ((M - 1) div 2) = Legendre 3 (int M)] (mod int M)", "by (rule cong_sym, rule euler_criterion) (use prime M_gt_6 in auto)"], ["proof (state)\nthis:\n  [3 ^ ((M - 1) div 2) = Legendre 3 (int M)] (mod int M)\n\ngoal (2 subgoals):\n 1. [3 ^ ((M - 1) div 2) = - 1] (mod int M)\n 2. [0 = 0] (mod int M)", "thus \"[3 ^ ((M - 1) div 2) = -1] (mod int M)\""], ["proof (prove)\nusing this:\n  [3 ^ ((M - 1) div 2) = Legendre 3 (int M)] (mod int M)\n\ngoal (1 subgoal):\n 1. [3 ^ ((M - 1) div 2) = - 1] (mod int M)", "by (simp add: Legendre_3_M)"], ["proof (state)\nthis:\n  [3 ^ ((M - 1) div 2) = - 1] (mod int M)\n\ngoal (1 subgoal):\n 1. [0 = 0] (mod int M)", "qed auto"], ["proof (state)\nthis:\n  \\<phi> (3 ^ ((M - 1) div 2), 0) = \\<phi> (- 1, 0)\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "also"], ["proof (state)\nthis:\n  \\<phi> (3 ^ ((M - 1) div 2), 0) = \\<phi> (- 1, 0)\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "have \"\\<phi> (2, 0) \\<otimes>\\<^bsub>S\\<^esub> (\\<phi> (- 1, 0) \\<otimes>\\<^bsub>S\\<^esub> \\<phi> (0, 1)) = \\<phi> ((2, 0) \\<otimes>\\<^bsub>R\\<^esub> (-1, 0) \\<otimes>\\<^bsub>R\\<^esub> (0, 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (2, 0) \\<otimes>\\<^bsub>S\\<^esub>\n    (\\<phi> (- 1, 0) \\<otimes>\\<^bsub>S\\<^esub> \\<phi> (0, 1)) =\n    \\<phi>\n     ((2, 0) \\<otimes>\\<^bsub>R\\<^esub> (- 1, 0) \\<otimes>\\<^bsub>R\\<^esub>\n      (0, 1))", "by (simp add: R.cring_simprules S.cring_simprules)"], ["proof (state)\nthis:\n  \\<phi> (2, 0) \\<otimes>\\<^bsub>S\\<^esub>\n  (\\<phi> (- 1, 0) \\<otimes>\\<^bsub>S\\<^esub> \\<phi> (0, 1)) =\n  \\<phi>\n   ((2, 0) \\<otimes>\\<^bsub>R\\<^esub> (- 1, 0) \\<otimes>\\<^bsub>R\\<^esub>\n    (0, 1))\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "also"], ["proof (state)\nthis:\n  \\<phi> (2, 0) \\<otimes>\\<^bsub>S\\<^esub>\n  (\\<phi> (- 1, 0) \\<otimes>\\<^bsub>S\\<^esub> \\<phi> (0, 1)) =\n  \\<phi>\n   ((2, 0) \\<otimes>\\<^bsub>R\\<^esub> (- 1, 0) \\<otimes>\\<^bsub>R\\<^esub>\n    (0, 1))\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "have \"\\<phi> (6, 0) \\<oplus>\\<^bsub>S\\<^esub> \\<phi> ((2, 0) \\<otimes>\\<^bsub>R\\<^esub> (- 1, 0) \\<otimes>\\<^bsub>R\\<^esub> (0, 1)) =\n                 \\<phi> ((6, 0) \\<oplus>\\<^bsub>R\\<^esub> (2, 0) \\<otimes>\\<^bsub>R\\<^esub> (- 1, 0) \\<otimes>\\<^bsub>R\\<^esub> (0, 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (6, 0) \\<oplus>\\<^bsub>S\\<^esub>\n    \\<phi>\n     ((2, 0) \\<otimes>\\<^bsub>R\\<^esub> (- 1, 0) \\<otimes>\\<^bsub>R\\<^esub>\n      (0, 1)) =\n    \\<phi>\n     ((6, 0) \\<oplus>\\<^bsub>R\\<^esub>\n      (2, 0) \\<otimes>\\<^bsub>R\\<^esub> (- 1, 0) \\<otimes>\\<^bsub>R\\<^esub>\n      (0, 1))", "by simp"], ["proof (state)\nthis:\n  \\<phi> (6, 0) \\<oplus>\\<^bsub>S\\<^esub>\n  \\<phi>\n   ((2, 0) \\<otimes>\\<^bsub>R\\<^esub> (- 1, 0) \\<otimes>\\<^bsub>R\\<^esub>\n    (0, 1)) =\n  \\<phi>\n   ((6, 0) \\<oplus>\\<^bsub>R\\<^esub>\n    (2, 0) \\<otimes>\\<^bsub>R\\<^esub> (- 1, 0) \\<otimes>\\<^bsub>R\\<^esub>\n    (0, 1))\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "also"], ["proof (state)\nthis:\n  \\<phi> (6, 0) \\<oplus>\\<^bsub>S\\<^esub>\n  \\<phi>\n   ((2, 0) \\<otimes>\\<^bsub>R\\<^esub> (- 1, 0) \\<otimes>\\<^bsub>R\\<^esub>\n    (0, 1)) =\n  \\<phi>\n   ((6, 0) \\<oplus>\\<^bsub>R\\<^esub>\n    (2, 0) \\<otimes>\\<^bsub>R\\<^esub> (- 1, 0) \\<otimes>\\<^bsub>R\\<^esub>\n    (0, 1))\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "have \"\\<dots> = \\<phi> (6, -2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\n     ((6, 0) \\<oplus>\\<^bsub>R\\<^esub>\n      (2, 0) \\<otimes>\\<^bsub>R\\<^esub> (- 1, 0) \\<otimes>\\<^bsub>R\\<^esub>\n      (0, 1)) =\n    \\<phi> (6, - 2)", "unfolding \\<phi>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_hom M\n     ((6, 0) \\<oplus>\\<^bsub>R\\<^esub>\n      (2, 0) \\<otimes>\\<^bsub>R\\<^esub> (- 1, 0) \\<otimes>\\<^bsub>R\\<^esub>\n      (0, 1)) =\n    lucas_lehmer_hom M (6, - 2)", "by (intro lucas_lehmer_hom_cong)\n         (auto simp: lucas_lehmer_ring_def lucas_lehmer_mult'_def lucas_lehmer_add'_def)"], ["proof (state)\nthis:\n  \\<phi>\n   ((6, 0) \\<oplus>\\<^bsub>R\\<^esub>\n    (2, 0) \\<otimes>\\<^bsub>R\\<^esub> (- 1, 0) \\<otimes>\\<^bsub>R\\<^esub>\n    (0, 1)) =\n  \\<phi> (6, - 2)\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "finally"], ["proof (chain)\npicking this:\n  \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "show \"\\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, -2)\""], ["proof (prove)\nusing this:\n  \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)\n\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "by (simp add: R.cring_simprules S.cring_simprules)"], ["proof (state)\nthis:\n  \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)\n\ngoal (1 subgoal):\n 1. 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "have eq2: \"\\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) = \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "have \"(24, 0) = (2, 0) [^]\\<^bsub>R\\<^esub> (3::nat) \\<otimes>\\<^bsub>R\\<^esub> (3, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (24, 0) =\n    (2, 0) [^]\\<^bsub>R\\<^esub> 3 \\<otimes>\\<^bsub>R\\<^esub> (3, 0)", "by (simp add: eval_nat_numeral) (auto simp: lucas_lehmer_ring_def lucas_lehmer_mult'_def)"], ["proof (state)\nthis:\n  (24, 0) = (2, 0) [^]\\<^bsub>R\\<^esub> 3 \\<otimes>\\<^bsub>R\\<^esub> (3, 0)\n\ngoal (1 subgoal):\n 1. \\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "also"], ["proof (state)\nthis:\n  (24, 0) = (2, 0) [^]\\<^bsub>R\\<^esub> 3 \\<otimes>\\<^bsub>R\\<^esub> (3, 0)\n\ngoal (1 subgoal):\n 1. \\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "have \"\\<dots> [^]\\<^bsub>R\\<^esub> ((M - 1) div 2) =\n                 ((2, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) [^]\\<^bsub>R\\<^esub> (3::nat) \\<otimes>\\<^bsub>R\\<^esub> (3, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((2, 0) [^]\\<^bsub>R\\<^esub> 3 \\<otimes>\\<^bsub>R\\<^esub>\n     (3, 0)) [^]\\<^bsub>R\\<^esub>\n    ((M - 1) div 2) =\n    ((2, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) [^]\\<^bsub>R\\<^esub>\n    3 \\<otimes>\\<^bsub>R\\<^esub>\n    (3, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)", "by (simp add: R.cring_simprules R.nat_pow_distrib R.nat_pow_pow mult_ac)"], ["proof (state)\nthis:\n  ((2, 0) [^]\\<^bsub>R\\<^esub> 3 \\<otimes>\\<^bsub>R\\<^esub>\n   (3, 0)) [^]\\<^bsub>R\\<^esub>\n  ((M - 1) div 2) =\n  ((2, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) [^]\\<^bsub>R\\<^esub>\n  3 \\<otimes>\\<^bsub>R\\<^esub>\n  (3, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)\n\ngoal (1 subgoal):\n 1. \\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "also"], ["proof (state)\nthis:\n  ((2, 0) [^]\\<^bsub>R\\<^esub> 3 \\<otimes>\\<^bsub>R\\<^esub>\n   (3, 0)) [^]\\<^bsub>R\\<^esub>\n  ((M - 1) div 2) =\n  ((2, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) [^]\\<^bsub>R\\<^esub>\n  3 \\<otimes>\\<^bsub>R\\<^esub>\n  (3, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)\n\ngoal (1 subgoal):\n 1. \\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "have \"\\<phi> \\<dots> = (\\<phi> ((2, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2))) [^]\\<^bsub>S\\<^esub> (3::nat) \\<otimes>\\<^bsub>S\\<^esub> \n                      \\<phi> ((3, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\n     (((2, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) [^]\\<^bsub>R\\<^esub>\n      3 \\<otimes>\\<^bsub>R\\<^esub>\n      (3, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n    \\<phi>\n     ((2, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) [^]\\<^bsub>S\\<^esub>\n    3 \\<otimes>\\<^bsub>S\\<^esub>\n    \\<phi> ((3, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2))", "by simp"], ["proof (state)\nthis:\n  \\<phi>\n   (((2, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) [^]\\<^bsub>R\\<^esub>\n    3 \\<otimes>\\<^bsub>R\\<^esub>\n    (3, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n  \\<phi> ((2, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) [^]\\<^bsub>S\\<^esub>\n  3 \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> ((3, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2))\n\ngoal (1 subgoal):\n 1. \\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "also"], ["proof (state)\nthis:\n  \\<phi>\n   (((2, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) [^]\\<^bsub>R\\<^esub>\n    3 \\<otimes>\\<^bsub>R\\<^esub>\n    (3, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n  \\<phi> ((2, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) [^]\\<^bsub>S\\<^esub>\n  3 \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> ((3, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2))\n\ngoal (1 subgoal):\n 1. \\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "have \"(2, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2) = (2 ^ ((M - 1) div 2), 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2) = (2 ^ ((M - 1) div 2), 0)", "by (simp add: R_pow_int)"], ["proof (state)\nthis:\n  (2, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2) = (2 ^ ((M - 1) div 2), 0)\n\ngoal (1 subgoal):\n 1. \\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "also"], ["proof (state)\nthis:\n  (2, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2) = (2 ^ ((M - 1) div 2), 0)\n\ngoal (1 subgoal):\n 1. \\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "have \"\\<phi> \\<dots> = \\<phi> (1, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (2 ^ ((M - 1) div 2), 0) = \\<phi> (1, 0)", "unfolding \\<phi>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_hom M (2 ^ ((M - 1) div 2), 0) = lucas_lehmer_hom M (1, 0)", "proof (intro lucas_lehmer_hom_cong')"], ["proof (state)\ngoal (2 subgoals):\n 1. [2 ^ ((M - 1) div 2) = 1] (mod int M)\n 2. [0 = 0] (mod int M)", "have \"[2 ^ ((M - 1) div 2) = Legendre 2 M] (mod int M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [2 ^ ((M - 1) div 2) = Legendre 2 (int M)] (mod int M)", "by (rule cong_sym, rule euler_criterion) (use prime M_gt_6 in auto)"], ["proof (state)\nthis:\n  [2 ^ ((M - 1) div 2) = Legendre 2 (int M)] (mod int M)\n\ngoal (2 subgoals):\n 1. [2 ^ ((M - 1) div 2) = 1] (mod int M)\n 2. [0 = 0] (mod int M)", "thus \"[2 ^ ((M - 1) div 2) = 1] (mod int M)\""], ["proof (prove)\nusing this:\n  [2 ^ ((M - 1) div 2) = Legendre 2 (int M)] (mod int M)\n\ngoal (1 subgoal):\n 1. [2 ^ ((M - 1) div 2) = 1] (mod int M)", "using Legendre_2_M"], ["proof (prove)\nusing this:\n  [2 ^ ((M - 1) div 2) = Legendre 2 (int M)] (mod int M)\n  Legendre 2 (int M) = 1\n\ngoal (1 subgoal):\n 1. [2 ^ ((M - 1) div 2) = 1] (mod int M)", "by simp"], ["proof (state)\nthis:\n  [2 ^ ((M - 1) div 2) = 1] (mod int M)\n\ngoal (1 subgoal):\n 1. [0 = 0] (mod int M)", "qed auto"], ["proof (state)\nthis:\n  \\<phi> (2 ^ ((M - 1) div 2), 0) = \\<phi> (1, 0)\n\ngoal (1 subgoal):\n 1. \\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "also"], ["proof (state)\nthis:\n  \\<phi> (2 ^ ((M - 1) div 2), 0) = \\<phi> (1, 0)\n\ngoal (1 subgoal):\n 1. \\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "have \"(1, 0) = \\<one>\\<^bsub>R\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1, 0) = \\<one>\\<^bsub>R\\<^esub>", "by (simp add: lucas_lehmer_ring_def)"], ["proof (state)\nthis:\n  (1, 0) = \\<one>\\<^bsub>R\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "also"], ["proof (state)\nthis:\n  (1, 0) = \\<one>\\<^bsub>R\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "have \"(3, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2) = (3 ^ ((M - 1) div 2), 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (3, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2) = (3 ^ ((M - 1) div 2), 0)", "by (simp add: R_pow_int)"], ["proof (state)\nthis:\n  (3, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2) = (3 ^ ((M - 1) div 2), 0)\n\ngoal (1 subgoal):\n 1. \\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "also"], ["proof (state)\nthis:\n  (3, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2) = (3 ^ ((M - 1) div 2), 0)\n\ngoal (1 subgoal):\n 1. \\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "have \"\\<phi> \\<dots> = \\<phi> (-1, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (3 ^ ((M - 1) div 2), 0) = \\<phi> (- 1, 0)", "unfolding \\<phi>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_hom M (3 ^ ((M - 1) div 2), 0) =\n    lucas_lehmer_hom M (- 1, 0)", "proof  (intro lucas_lehmer_hom_cong')"], ["proof (state)\ngoal (2 subgoals):\n 1. [3 ^ ((M - 1) div 2) = - 1] (mod int M)\n 2. [0 = 0] (mod int M)", "have \"[3 ^ ((M - 1) div 2) = Legendre 3 M] (mod int M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [3 ^ ((M - 1) div 2) = Legendre 3 (int M)] (mod int M)", "by (rule cong_sym, rule euler_criterion) (use prime M_gt_6 in auto)"], ["proof (state)\nthis:\n  [3 ^ ((M - 1) div 2) = Legendre 3 (int M)] (mod int M)\n\ngoal (2 subgoals):\n 1. [3 ^ ((M - 1) div 2) = - 1] (mod int M)\n 2. [0 = 0] (mod int M)", "thus \"[3 ^ ((M - 1) div 2) = -1] (mod int M)\""], ["proof (prove)\nusing this:\n  [3 ^ ((M - 1) div 2) = Legendre 3 (int M)] (mod int M)\n\ngoal (1 subgoal):\n 1. [3 ^ ((M - 1) div 2) = - 1] (mod int M)", "using Legendre_3_M"], ["proof (prove)\nusing this:\n  [3 ^ ((M - 1) div 2) = Legendre 3 (int M)] (mod int M)\n  Legendre 3 (int M) = - 1\n\ngoal (1 subgoal):\n 1. [3 ^ ((M - 1) div 2) = - 1] (mod int M)", "by simp"], ["proof (state)\nthis:\n  [3 ^ ((M - 1) div 2) = - 1] (mod int M)\n\ngoal (1 subgoal):\n 1. [0 = 0] (mod int M)", "qed auto"], ["proof (state)\nthis:\n  \\<phi> (3 ^ ((M - 1) div 2), 0) = \\<phi> (- 1, 0)\n\ngoal (1 subgoal):\n 1. \\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "also"], ["proof (state)\nthis:\n  \\<phi> (3 ^ ((M - 1) div 2), 0) = \\<phi> (- 1, 0)\n\ngoal (1 subgoal):\n 1. \\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "have \"(-1, 0) = \\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1, 0) = \\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>", "using minus_lucas_lehmer_ring"], ["proof (prove)\nusing this:\n  \\<ominus>\\<^bsub>R\\<^esub> ?x =\n  (case ?x of (a, b) \\<Rightarrow> (- a, - b))\n\ngoal (1 subgoal):\n 1. (- 1, 0) = \\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>", "by (simp add: lucas_lehmer_ring_def)"], ["proof (state)\nthis:\n  (- 1, 0) = \\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "finally"], ["proof (chain)\npicking this:\n  \\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n  \\<phi> \\<one>\\<^bsub>R\\<^esub> [^]\\<^bsub>S\\<^esub>\n  3 \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>)", "show \"\\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) = \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n  \\<phi> \\<one>\\<^bsub>R\\<^esub> [^]\\<^bsub>S\\<^esub>\n  3 \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "by simp"], ["proof (state)\nthis:\n  \\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n  \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n  \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "define \\<omega> \\<omega>' :: \"int \\<times> int\" where \"\\<omega> = (2, 1)\" and \"\\<omega>' = (2, -1)\""], ["proof (state)\nthis:\n  \\<omega> = (2, 1)\n  \\<omega>' = (2, - 1)\n\ngoal (1 subgoal):\n 1. 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "have eq3: \"\\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) = \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "have \"(M + 1) div 2 = Suc ((M - 1) div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M + 1) div 2 = Suc ((M - 1) div 2)", "using M_odd M_gt_6"], ["proof (prove)\nusing this:\n  odd M\n  6 < M\n\ngoal (1 subgoal):\n 1. (M + 1) div 2 = Suc ((M - 1) div 2)", "by (auto elim!: oddE)"], ["proof (state)\nthis:\n  (M + 1) div 2 = Suc ((M - 1) div 2)\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "have *: \"\\<phi> ((24, 0) \\<otimes>\\<^bsub>R\\<^esub> \\<omega>) = \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> (2 :: nat))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> ((24, 0) \\<otimes>\\<^bsub>R\\<^esub> \\<omega>) =\n    \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> 2)", "unfolding \\<phi>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_hom M ((24, 0) \\<otimes>\\<^bsub>R\\<^esub> \\<omega>) =\n    lucas_lehmer_hom M ((6, 2) [^]\\<^bsub>R\\<^esub> 2)", "by (intro lucas_lehmer_hom_cong)\n         (simp_all add: eval_nat_numeral,\n          auto simp: lucas_lehmer_ring_def lucas_lehmer_mult'_def \\<omega>_def)"], ["proof (state)\nthis:\n  \\<phi> ((24, 0) \\<otimes>\\<^bsub>R\\<^esub> \\<omega>) =\n  \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> 2)\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "have \"\\<phi> (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub> \\<phi> ((24, 0) \\<otimes>\\<^bsub>R\\<^esub> \\<omega>) [^]\\<^bsub>S\\<^esub> ((M + 1) div 2) =\n            \\<phi> (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub> \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> (2 :: nat)) [^]\\<^bsub>S\\<^esub> ((M + 1) div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\n     (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub>\n    \\<phi>\n     ((24, 0) \\<otimes>\\<^bsub>R\\<^esub> \\<omega>) [^]\\<^bsub>S\\<^esub>\n    ((M + 1) div 2) =\n    \\<phi>\n     (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub>\n    \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> 2) [^]\\<^bsub>S\\<^esub>\n    ((M + 1) div 2)", "by (subst *) auto"], ["proof (state)\nthis:\n  \\<phi>\n   (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> ((24, 0) \\<otimes>\\<^bsub>R\\<^esub> \\<omega>) [^]\\<^bsub>S\\<^esub>\n  ((M + 1) div 2) =\n  \\<phi>\n   (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> 2) [^]\\<^bsub>S\\<^esub>\n  ((M + 1) div 2)\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "hence \"\\<phi> (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub> \\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) \\<otimes>\\<^bsub>S\\<^esub> \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n            \\<phi> (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub> \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> (2 * ((M + 1) div 2)))\""], ["proof (prove)\nusing this:\n  \\<phi>\n   (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> ((24, 0) \\<otimes>\\<^bsub>R\\<^esub> \\<omega>) [^]\\<^bsub>S\\<^esub>\n  ((M + 1) div 2) =\n  \\<phi>\n   (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> 2) [^]\\<^bsub>S\\<^esub>\n  ((M + 1) div 2)\n\ngoal (1 subgoal):\n 1. \\<phi>\n     (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub>\n    \\<phi>\n     ((24, 0) [^]\\<^bsub>R\\<^esub>\n      ((M + 1) div 2)) \\<otimes>\\<^bsub>S\\<^esub>\n    \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n    \\<phi>\n     (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub>\n    \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> (2 * ((M + 1) div 2)))", "by (simp add: R.nat_pow_distrib S.nat_pow_distrib R.nat_pow_pow\n                    S.nat_pow_pow R.cring_simprules S.cring_simprules)"], ["proof (state)\nthis:\n  \\<phi>\n   (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi>\n   ((24, 0) [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n  \\<phi>\n   (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> (2 * ((M + 1) div 2)))\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "also"], ["proof (state)\nthis:\n  \\<phi>\n   (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi>\n   ((24, 0) [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n  \\<phi>\n   (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> (2 * ((M + 1) div 2)))\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "have \"2 * ((M + 1) div 2) = M + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * ((M + 1) div 2) = M + 1", "using M_odd"], ["proof (prove)\nusing this:\n  odd M\n\ngoal (1 subgoal):\n 1. 2 * ((M + 1) div 2) = M + 1", "by auto"], ["proof (state)\nthis:\n  2 * ((M + 1) div 2) = M + 1\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "finally"], ["proof (chain)\npicking this:\n  \\<phi>\n   (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi>\n   ((24, 0) [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n  \\<phi>\n   (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> (M + 1))", "have \"\\<phi> (24, 0) \\<otimes>\\<^bsub>S\\<^esub> (\\<phi> (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub> \\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2))) \\<otimes>\\<^bsub>S\\<^esub> \n                    \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n                  \\<phi> (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub> (\\<phi> (6, 2) \\<otimes>\\<^bsub>S\\<^esub> \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M))\""], ["proof (prove)\nusing this:\n  \\<phi>\n   (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi>\n   ((24, 0) [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n  \\<phi>\n   (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> (M + 1))\n\ngoal (1 subgoal):\n 1. \\<phi> (24, 0) \\<otimes>\\<^bsub>S\\<^esub>\n    (\\<phi>\n      (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub>\n     \\<phi>\n      ((24, 0) [^]\\<^bsub>R\\<^esub>\n       ((M - 1) div 2))) \\<otimes>\\<^bsub>S\\<^esub>\n    \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n    \\<phi>\n     (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub>\n    (\\<phi> (6, 2) \\<otimes>\\<^bsub>S\\<^esub>\n     \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M))", "by (subst (asm) \\<open>(M + 1) div 2 = _\\<close>) (simp add: S.cring_simprules R.cring_simprules)"], ["proof (state)\nthis:\n  \\<phi> (24, 0) \\<otimes>\\<^bsub>S\\<^esub>\n  (\\<phi>\n    (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub>\n   \\<phi>\n    ((24, 0) [^]\\<^bsub>R\\<^esub>\n     ((M - 1) div 2))) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n  \\<phi>\n   (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub>\n  (\\<phi> (6, 2) \\<otimes>\\<^bsub>S\\<^esub>\n   \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M))\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "also"], ["proof (state)\nthis:\n  \\<phi> (24, 0) \\<otimes>\\<^bsub>S\\<^esub>\n  (\\<phi>\n    (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub>\n   \\<phi>\n    ((24, 0) [^]\\<^bsub>R\\<^esub>\n     ((M - 1) div 2))) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n  \\<phi>\n   (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub>\n  (\\<phi> (6, 2) \\<otimes>\\<^bsub>S\\<^esub>\n   \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M))\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "have \"\\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) = \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "by (subst eq2) auto"], ["proof (state)\nthis:\n  \\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n  \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "also"], ["proof (state)\nthis:\n  \\<phi> ((24, 0) [^]\\<^bsub>R\\<^esub> ((M - 1) div 2)) =\n  \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "have \"(\\<phi> (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub> \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>) = \\<one>\\<^bsub>S\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\n     (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub>\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub> =\n    \\<one>\\<^bsub>S\\<^esub>", "by (simp add: S.cring_simprules)"], ["proof (state)\nthis:\n  \\<phi>\n   (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub> =\n  \\<one>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "also"], ["proof (state)\nthis:\n  \\<phi>\n   (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub> =\n  \\<one>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "have \"\\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, -2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)", "by (subst eq1) auto"], ["proof (state)\nthis:\n  \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "also"], ["proof (state)\nthis:\n  \\<phi> ((6, 2) [^]\\<^bsub>R\\<^esub> M) = \\<phi> (6, - 2)\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "have \"\\<phi> (6, 2) \\<otimes>\\<^bsub>S\\<^esub> \\<phi> (6, -2) = \\<phi> ((6, 2) \\<otimes>\\<^bsub>R\\<^esub> (6, -2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (6, 2) \\<otimes>\\<^bsub>S\\<^esub> \\<phi> (6, - 2) =\n    \\<phi> ((6, 2) \\<otimes>\\<^bsub>R\\<^esub> (6, - 2))", "by simp"], ["proof (state)\nthis:\n  \\<phi> (6, 2) \\<otimes>\\<^bsub>S\\<^esub> \\<phi> (6, - 2) =\n  \\<phi> ((6, 2) \\<otimes>\\<^bsub>R\\<^esub> (6, - 2))\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "also"], ["proof (state)\nthis:\n  \\<phi> (6, 2) \\<otimes>\\<^bsub>S\\<^esub> \\<phi> (6, - 2) =\n  \\<phi> ((6, 2) \\<otimes>\\<^bsub>R\\<^esub> (6, - 2))\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "have \"\\<dots> = \\<phi> (24, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> ((6, 2) \\<otimes>\\<^bsub>R\\<^esub> (6, - 2)) = \\<phi> (24, 0)", "unfolding \\<phi>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_hom M ((6, 2) \\<otimes>\\<^bsub>R\\<^esub> (6, - 2)) =\n    lucas_lehmer_hom M (24, 0)", "by (intro lucas_lehmer_hom_cong) (auto simp: lucas_lehmer_ring_def lucas_lehmer_mult'_def)"], ["proof (state)\nthis:\n  \\<phi> ((6, 2) \\<otimes>\\<^bsub>R\\<^esub> (6, - 2)) = \\<phi> (24, 0)\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "finally"], ["proof (chain)\npicking this:\n  \\<phi> (24, 0) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<one>\\<^bsub>S\\<^esub> \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n  \\<phi>\n   (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (24, 0)", "have \"\\<phi> (24, 0) \\<otimes>\\<^bsub>S\\<^esub> (\\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2))) =\n                  \\<phi> (24, 0) \\<otimes>\\<^bsub>S\\<^esub> \\<phi> (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>)\""], ["proof (prove)\nusing this:\n  \\<phi> (24, 0) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<one>\\<^bsub>S\\<^esub> \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n  \\<phi>\n   (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (24, 0)\n\ngoal (1 subgoal):\n 1. \\<phi> (24, 0) \\<otimes>\\<^bsub>S\\<^esub>\n    \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n    \\<phi> (24, 0) \\<otimes>\\<^bsub>S\\<^esub>\n    \\<phi> (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>)", "by (simp add: S.cring_simprules)"], ["proof (state)\nthis:\n  \\<phi> (24, 0) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n  \\<phi> (24, 0) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "also"], ["proof (state)\nthis:\n  \\<phi> (24, 0) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n  \\<phi> (24, 0) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "have \"\\<phi> (24, 0) = (24 mod M, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (24, 0) = (24 mod M, 0)", "by (simp add: \\<phi>_def lucas_lehmer_hom_def nat_mod_as_int)"], ["proof (state)\nthis:\n  \\<phi> (24, 0) = (24 mod M, 0)\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "finally"], ["proof (chain)\npicking this:\n  (24 mod M, 0) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n  (24 mod M, 0) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>)", "have \"(24 mod M, 0) \\<otimes>\\<^bsub>S\\<^esub> (\\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2))) =\n                  (24 mod M, 0) \\<otimes>\\<^bsub>S\\<^esub> \\<phi> (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>)\""], ["proof (prove)\nusing this:\n  (24 mod M, 0) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n  (24 mod M, 0) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>)\n\ngoal (1 subgoal):\n 1. (24 mod M, 0) \\<otimes>\\<^bsub>S\\<^esub>\n    \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n    (24 mod M, 0) \\<otimes>\\<^bsub>S\\<^esub>\n    \\<phi> (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>)", "."], ["proof (state)\nthis:\n  (24 mod M, 0) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n  (24 mod M, 0) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "moreover"], ["proof (state)\nthis:\n  (24 mod M, 0) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n  (24 mod M, 0) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "have \"(24 mod M, 0) \\<in> Units S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (24 mod M, 0) \\<in> Units S", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (24 mod M, 0) \\<in> Units (lucas_lehmer_ring_mod M)", "using M_gt_6 prime M_not_dvd_24"], ["proof (prove)\nusing this:\n  6 < M\n  prime M\n  \\<not> M dvd 24\n\ngoal (1 subgoal):\n 1. (24 mod M, 0) \\<in> Units (lucas_lehmer_ring_mod M)", "by (intro int_in_Units_lucas_lehmer_ring_mod) (auto simp: dvd_mod_iff intro!: Nat.gr0I)"], ["proof (state)\nthis:\n  (24 mod M, 0) \\<in> Units S\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "ultimately"], ["proof (chain)\npicking this:\n  (24 mod M, 0) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n  (24 mod M, 0) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>)\n  (24 mod M, 0) \\<in> Units S", "show \"\\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) = \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>\""], ["proof (prove)\nusing this:\n  (24 mod M, 0) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n  (24 mod M, 0) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<ominus>\\<^bsub>R\\<^esub> \\<one>\\<^bsub>R\\<^esub>)\n  (24 mod M, 0) \\<in> Units S\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n    \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>", "by (subst (asm) S.Units_l_cancel) auto"], ["proof (state)\nthis:\n  \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n  \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) =\n  \\<ominus>\\<^bsub>S\\<^esub> \\<one>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "have eq4: \"\\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> (2 ^ (p - 2) :: nat) \\<oplus>\\<^bsub>R\\<^esub> \\<omega>' [^]\\<^bsub>R\\<^esub> (2 ^ (p - 2) :: nat)) = \\<zero>\\<^bsub>S\\<^esub>\"\n    (is \"\\<phi> ?lhs = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\n     (\\<omega> [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n      \\<omega>' [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2)) =\n    \\<zero>\\<^bsub>S\\<^esub>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi>\n     (\\<omega> [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n      \\<omega>' [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2)) =\n    \\<zero>\\<^bsub>S\\<^esub>", "have \"\\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 2)) \\<otimes>\\<^bsub>S\\<^esub> \\<phi> (\\<omega>' [^]\\<^bsub>R\\<^esub> ((M + 1) div 4)) \\<oplus>\\<^bsub>S\\<^esub>\n            \\<phi> (\\<omega>' [^]\\<^bsub>R\\<^esub> ((M + 1) div 4)) = \\<zero>\\<^bsub>S\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\n     (\\<omega> [^]\\<^bsub>R\\<^esub>\n      ((M + 1) div 2)) \\<otimes>\\<^bsub>S\\<^esub>\n    \\<phi>\n     (\\<omega>' [^]\\<^bsub>R\\<^esub>\n      ((M + 1) div 4)) \\<oplus>\\<^bsub>S\\<^esub>\n    \\<phi> (\\<omega>' [^]\\<^bsub>R\\<^esub> ((M + 1) div 4)) =\n    \\<zero>\\<^bsub>S\\<^esub>", "by (subst eq3) (auto simp: S.cring_simprules)"], ["proof (state)\nthis:\n  \\<phi>\n   (\\<omega> [^]\\<^bsub>R\\<^esub>\n    ((M + 1) div 2)) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi>\n   (\\<omega>' [^]\\<^bsub>R\\<^esub>\n    ((M + 1) div 4)) \\<oplus>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<omega>' [^]\\<^bsub>R\\<^esub> ((M + 1) div 4)) =\n  \\<zero>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<phi>\n     (\\<omega> [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n      \\<omega>' [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2)) =\n    \\<zero>\\<^bsub>S\\<^esub>", "also"], ["proof (state)\nthis:\n  \\<phi>\n   (\\<omega> [^]\\<^bsub>R\\<^esub>\n    ((M + 1) div 2)) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi>\n   (\\<omega>' [^]\\<^bsub>R\\<^esub>\n    ((M + 1) div 4)) \\<oplus>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<omega>' [^]\\<^bsub>R\\<^esub> ((M + 1) div 4)) =\n  \\<zero>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<phi>\n     (\\<omega> [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n      \\<omega>' [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2)) =\n    \\<zero>\\<^bsub>S\\<^esub>", "have \"2 ^ 2 dvd (2 ^ p :: nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2\\<^sup>2 dvd 2 ^ p", "by (intro le_imp_power_dvd) (use p_gt_2 in auto)"], ["proof (state)\nthis:\n  2\\<^sup>2 dvd 2 ^ p\n\ngoal (1 subgoal):\n 1. \\<phi>\n     (\\<omega> [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n      \\<omega>' [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2)) =\n    \\<zero>\\<^bsub>S\\<^esub>", "hence \"4 dvd (M + 1)\""], ["proof (prove)\nusing this:\n  2\\<^sup>2 dvd 2 ^ p\n\ngoal (1 subgoal):\n 1. 4 dvd M + 1", "by (auto simp: M_def)"], ["proof (state)\nthis:\n  4 dvd M + 1\n\ngoal (1 subgoal):\n 1. \\<phi>\n     (\\<omega> [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n      \\<omega>' [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2)) =\n    \\<zero>\\<^bsub>S\\<^esub>", "hence \"(M + 1) div 2 = (M + 1) div 4 + (M + 1) div 4\""], ["proof (prove)\nusing this:\n  4 dvd M + 1\n\ngoal (1 subgoal):\n 1. (M + 1) div 2 = (M + 1) div 4 + (M + 1) div 4", "by presburger"], ["proof (state)\nthis:\n  (M + 1) div 2 = (M + 1) div 4 + (M + 1) div 4\n\ngoal (1 subgoal):\n 1. \\<phi>\n     (\\<omega> [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n      \\<omega>' [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2)) =\n    \\<zero>\\<^bsub>S\\<^esub>", "also"], ["proof (state)\nthis:\n  (M + 1) div 2 = (M + 1) div 4 + (M + 1) div 4\n\ngoal (1 subgoal):\n 1. \\<phi>\n     (\\<omega> [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n      \\<omega>' [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2)) =\n    \\<zero>\\<^bsub>S\\<^esub>", "have \"\\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> \\<dots>) \\<otimes>\\<^bsub>S\\<^esub> \\<phi> (\\<omega>' [^]\\<^bsub>R\\<^esub> ((M + 1) div 4)) =\n               \\<phi> (\\<omega> \\<otimes>\\<^bsub>R\\<^esub> \\<omega>') [^]\\<^bsub>S\\<^esub> ((M + 1) div 4) \\<otimes>\\<^bsub>S\\<^esub> \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 4))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\n     (\\<omega> [^]\\<^bsub>R\\<^esub>\n      ((M + 1) div 4 + (M + 1) div 4)) \\<otimes>\\<^bsub>S\\<^esub>\n    \\<phi> (\\<omega>' [^]\\<^bsub>R\\<^esub> ((M + 1) div 4)) =\n    \\<phi>\n     (\\<omega> \\<otimes>\\<^bsub>R\\<^esub> \\<omega>') [^]\\<^bsub>S\\<^esub>\n    ((M + 1) div 4) \\<otimes>\\<^bsub>S\\<^esub>\n    \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 4))", "by (simp add: S.cring_simprules S.nat_pow_distrib flip: S.nat_pow_mult)"], ["proof (state)\nthis:\n  \\<phi>\n   (\\<omega> [^]\\<^bsub>R\\<^esub>\n    ((M + 1) div 4 + (M + 1) div 4)) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<omega>' [^]\\<^bsub>R\\<^esub> ((M + 1) div 4)) =\n  \\<phi>\n   (\\<omega> \\<otimes>\\<^bsub>R\\<^esub> \\<omega>') [^]\\<^bsub>S\\<^esub>\n  ((M + 1) div 4) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 4))\n\ngoal (1 subgoal):\n 1. \\<phi>\n     (\\<omega> [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n      \\<omega>' [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2)) =\n    \\<zero>\\<^bsub>S\\<^esub>", "also"], ["proof (state)\nthis:\n  \\<phi>\n   (\\<omega> [^]\\<^bsub>R\\<^esub>\n    ((M + 1) div 4 + (M + 1) div 4)) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<omega>' [^]\\<^bsub>R\\<^esub> ((M + 1) div 4)) =\n  \\<phi>\n   (\\<omega> \\<otimes>\\<^bsub>R\\<^esub> \\<omega>') [^]\\<^bsub>S\\<^esub>\n  ((M + 1) div 4) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> ((M + 1) div 4))\n\ngoal (1 subgoal):\n 1. \\<phi>\n     (\\<omega> [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n      \\<omega>' [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2)) =\n    \\<zero>\\<^bsub>S\\<^esub>", "have \"\\<phi> (\\<omega> \\<otimes>\\<^bsub>R\\<^esub> \\<omega>') = \\<phi> \\<one>\\<^bsub>R\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (\\<omega> \\<otimes>\\<^bsub>R\\<^esub> \\<omega>') =\n    \\<phi> \\<one>\\<^bsub>R\\<^esub>", "unfolding \\<phi>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_hom M (\\<omega> \\<otimes>\\<^bsub>R\\<^esub> \\<omega>') =\n    lucas_lehmer_hom M \\<one>\\<^bsub>R\\<^esub>", "by (intro lucas_lehmer_hom_cong)\n         (auto simp: \\<omega>_def \\<omega>'_def lucas_lehmer_ring_def lucas_lehmer_mult'_def)"], ["proof (state)\nthis:\n  \\<phi> (\\<omega> \\<otimes>\\<^bsub>R\\<^esub> \\<omega>') =\n  \\<phi> \\<one>\\<^bsub>R\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<phi>\n     (\\<omega> [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n      \\<omega>' [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2)) =\n    \\<zero>\\<^bsub>S\\<^esub>", "also"], ["proof (state)\nthis:\n  \\<phi> (\\<omega> \\<otimes>\\<^bsub>R\\<^esub> \\<omega>') =\n  \\<phi> \\<one>\\<^bsub>R\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<phi>\n     (\\<omega> [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n      \\<omega>' [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2)) =\n    \\<zero>\\<^bsub>S\\<^esub>", "have \"(M + 1) div 4 = 2 ^ (p - 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M + 1) div 4 = 2 ^ (p - 2)", "using p_gt_2"], ["proof (prove)\nusing this:\n  2 < p\n\ngoal (1 subgoal):\n 1. (M + 1) div 4 = 2 ^ (p - 2)", "by (auto simp: M_def power_diff)"], ["proof (state)\nthis:\n  (M + 1) div 4 = 2 ^ (p - 2)\n\ngoal (1 subgoal):\n 1. \\<phi>\n     (\\<omega> [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n      \\<omega>' [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2)) =\n    \\<zero>\\<^bsub>S\\<^esub>", "finally"], ["proof (chain)\npicking this:\n  \\<phi> \\<one>\\<^bsub>R\\<^esub> [^]\\<^bsub>S\\<^esub>\n  2 ^ (p - 2) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi>\n   (\\<omega> [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2)) \\<oplus>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<omega>' [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2)) =\n  \\<zero>\\<^bsub>S\\<^esub>", "show eq4: \"\\<phi> (\\<omega> [^]\\<^bsub>R\\<^esub> (2 ^ (p - 2) :: nat) \\<oplus>\\<^bsub>R\\<^esub> \\<omega>' [^]\\<^bsub>R\\<^esub> (2 ^ (p - 2) :: nat)) = \\<zero>\\<^bsub>S\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<phi> \\<one>\\<^bsub>R\\<^esub> [^]\\<^bsub>S\\<^esub>\n  2 ^ (p - 2) \\<otimes>\\<^bsub>S\\<^esub>\n  \\<phi>\n   (\\<omega> [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2)) \\<oplus>\\<^bsub>S\\<^esub>\n  \\<phi> (\\<omega>' [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2)) =\n  \\<zero>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<phi>\n     (\\<omega> [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n      \\<omega>' [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2)) =\n    \\<zero>\\<^bsub>S\\<^esub>", "by simp"], ["proof (state)\nthis:\n  \\<phi>\n   (\\<omega> [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n    \\<omega>' [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2)) =\n  \\<zero>\\<^bsub>S\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<phi>\n   (\\<omega> [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n    \\<omega>' [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2)) =\n  \\<zero>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "have \"\\<phi> ?lhs = \\<zero>\\<^bsub>S\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\n     (\\<omega> [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n      \\<omega>' [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2)) =\n    \\<zero>\\<^bsub>S\\<^esub>", "by (rule eq4)"], ["proof (state)\nthis:\n  \\<phi>\n   (\\<omega> [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n    \\<omega>' [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2)) =\n  \\<zero>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "also"], ["proof (state)\nthis:\n  \\<phi>\n   (\\<omega> [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n    \\<omega>' [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2)) =\n  \\<zero>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "have \"lucas_lehmer_to_real ?lhs =\n             lucas_lehmer_to_real (gen_lucas_lehmer_sequence 4 (p - 2), 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_to_real\n     (\\<omega> [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n      \\<omega>' [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2)) =\n    lucas_lehmer_to_real (gen_lucas_lehmer_sequence 4 (p - 2), 0)", "by (simp add: \\<omega>_def \\<omega>'_def lucas_lehmer_to_real_simps gen_lucas_lehmer_sequence_4_closed_form1)"], ["proof (state)\nthis:\n  lucas_lehmer_to_real\n   (\\<omega> [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n    \\<omega>' [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2)) =\n  lucas_lehmer_to_real (gen_lucas_lehmer_sequence 4 (p - 2), 0)\n\ngoal (1 subgoal):\n 1. 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "hence \"?lhs = (gen_lucas_lehmer_sequence 4 (p - 2), 0)\""], ["proof (prove)\nusing this:\n  lucas_lehmer_to_real\n   (\\<omega> [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n    \\<omega>' [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2)) =\n  lucas_lehmer_to_real (gen_lucas_lehmer_sequence 4 (p - 2), 0)\n\ngoal (1 subgoal):\n 1. \\<omega> [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n    \\<omega>' [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) =\n    (gen_lucas_lehmer_sequence 4 (p - 2), 0)", "by (rule injD[OF lucas_lehmer_to_real_inj])"], ["proof (state)\nthis:\n  \\<omega> [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) \\<oplus>\\<^bsub>R\\<^esub>\n  \\<omega>' [^]\\<^bsub>R\\<^esub> 2 ^ (p - 2) =\n  (gen_lucas_lehmer_sequence 4 (p - 2), 0)\n\ngoal (1 subgoal):\n 1. 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "finally"], ["proof (chain)\npicking this:\n  \\<phi> (gen_lucas_lehmer_sequence 4 (p - 2), 0) = \\<zero>\\<^bsub>S\\<^esub>", "have \"gen_lucas_lehmer_sequence 4 (p - 2) mod M = 0\""], ["proof (prove)\nusing this:\n  \\<phi> (gen_lucas_lehmer_sequence 4 (p - 2), 0) = \\<zero>\\<^bsub>S\\<^esub>\n\ngoal (1 subgoal):\n 1. gen_lucas_lehmer_sequence 4 (p - 2) mod int M = 0", "using M_gt_6"], ["proof (prove)\nusing this:\n  \\<phi> (gen_lucas_lehmer_sequence 4 (p - 2), 0) = \\<zero>\\<^bsub>S\\<^esub>\n  6 < M\n\ngoal (1 subgoal):\n 1. gen_lucas_lehmer_sequence 4 (p - 2) mod int M = 0", "by (auto simp: \\<phi>_def lucas_lehmer_hom_def S_def lucas_lehmer_ring_mod_def)"], ["proof (state)\nthis:\n  gen_lucas_lehmer_sequence 4 (p - 2) mod int M = 0\n\ngoal (1 subgoal):\n 1. 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "thus \"(2 ^ p - 1) dvd gen_lucas_lehmer_sequence 4 (p - 2)\""], ["proof (prove)\nusing this:\n  gen_lucas_lehmer_sequence 4 (p - 2) mod int M = 0\n\ngoal (1 subgoal):\n 1. 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "by (simp add: M_def mod_eq_0_iff_dvd of_nat_diff)"], ["proof (state)\nthis:\n  2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary lucas_lehmer_correct:\n  \"prime (2 ^ p - 1 :: nat) \\<longleftrightarrow>\n     prime p \\<and> (p = 2 \\<or> (2 ^ p - 1) dvd gen_lucas_lehmer_sequence 4 (p - 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime (2 ^ p - 1) =\n    (prime p \\<and>\n     (p = 2 \\<or> 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)))", "proof (intro iffI; (elim conjE)?)"], ["proof (state)\ngoal (2 subgoals):\n 1. prime (2 ^ p - 1) \\<Longrightarrow>\n    prime p \\<and>\n    (p = 2 \\<or> 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2))\n 2. \\<lbrakk>prime p;\n     p = 2 \\<or> 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)\\<rbrakk>\n    \\<Longrightarrow> prime (2 ^ p - 1)", "assume prime: \"prime (2 ^ p - 1 :: nat)\""], ["proof (state)\nthis:\n  prime (2 ^ p - 1)\n\ngoal (2 subgoals):\n 1. prime (2 ^ p - 1) \\<Longrightarrow>\n    prime p \\<and>\n    (p = 2 \\<or> 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2))\n 2. \\<lbrakk>prime p;\n     p = 2 \\<or> 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)\\<rbrakk>\n    \\<Longrightarrow> prime (2 ^ p - 1)", "from prime"], ["proof (chain)\npicking this:\n  prime (2 ^ p - 1)", "have \"p \\<noteq> 0\" \"p \\<noteq> 1\""], ["proof (prove)\nusing this:\n  prime (2 ^ p - 1)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 &&& p \\<noteq> 1", "by (auto intro!: Nat.gr0I)"], ["proof (state)\nthis:\n  p \\<noteq> 0\n  p \\<noteq> 1\n\ngoal (2 subgoals):\n 1. prime (2 ^ p - 1) \\<Longrightarrow>\n    prime p \\<and>\n    (p = 2 \\<or> 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2))\n 2. \\<lbrakk>prime p;\n     p = 2 \\<or> 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)\\<rbrakk>\n    \\<Longrightarrow> prime (2 ^ p - 1)", "hence \"p = 2 \\<or> p > 2\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  p \\<noteq> 1\n\ngoal (1 subgoal):\n 1. p = 2 \\<or> 2 < p", "by auto"], ["proof (state)\nthis:\n  p = 2 \\<or> 2 < p\n\ngoal (2 subgoals):\n 1. prime (2 ^ p - 1) \\<Longrightarrow>\n    prime p \\<and>\n    (p = 2 \\<or> 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2))\n 2. \\<lbrakk>prime p;\n     p = 2 \\<or> 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)\\<rbrakk>\n    \\<Longrightarrow> prime (2 ^ p - 1)", "thus \"prime p \\<and> (p = 2 \\<or> (2 ^ p - 1) dvd gen_lucas_lehmer_sequence 4 (p - 2))\""], ["proof (prove)\nusing this:\n  p = 2 \\<or> 2 < p\n\ngoal (1 subgoal):\n 1. prime p \\<and>\n    (p = 2 \\<or> 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2))", "proof (elim disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 2 \\<Longrightarrow>\n    prime p \\<and>\n    (p = 2 \\<or> 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2))\n 2. 2 < p \\<Longrightarrow>\n    prime p \\<and>\n    (p = 2 \\<or> 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2))", "assume \"p > 2\""], ["proof (state)\nthis:\n  2 < p\n\ngoal (2 subgoals):\n 1. p = 2 \\<Longrightarrow>\n    prime p \\<and>\n    (p = 2 \\<or> 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2))\n 2. 2 < p \\<Longrightarrow>\n    prime p \\<and>\n    (p = 2 \\<or> 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2))", "with prime"], ["proof (chain)\npicking this:\n  prime (2 ^ p - 1)\n  2 < p", "interpret mersenne_prime p \"2 ^ p - 1\""], ["proof (prove)\nusing this:\n  prime (2 ^ p - 1)\n  2 < p\n\ngoal (1 subgoal):\n 1. mersenne_prime p &&& 2 ^ p - 1 \\<equiv> 2 ^ p - 1", "by unfold_locales"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 2 \\<Longrightarrow>\n    prime p \\<and>\n    (p = 2 \\<or> 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2))\n 2. 2 < p \\<Longrightarrow>\n    prime p \\<and>\n    (p = 2 \\<or> 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2))", "from lucas_lehmer_necessary p_prime"], ["proof (chain)\npicking this:\n  2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)\n  prime p", "show ?thesis"], ["proof (prove)\nusing this:\n  2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)\n  prime p\n\ngoal (1 subgoal):\n 1. prime p \\<and>\n    (p = 2 \\<or> 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2))", "by auto"], ["proof (state)\nthis:\n  prime p \\<and>\n  (p = 2 \\<or> 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2))\n\ngoal (1 subgoal):\n 1. p = 2 \\<Longrightarrow>\n    prime p \\<and>\n    (p = 2 \\<or> 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2))", "qed auto"], ["proof (state)\nthis:\n  prime p \\<and>\n  (p = 2 \\<or> 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p;\n     p = 2 \\<or> 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)\\<rbrakk>\n    \\<Longrightarrow> prime (2 ^ p - 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p;\n     p = 2 \\<or> 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)\\<rbrakk>\n    \\<Longrightarrow> prime (2 ^ p - 1)", "assume prime: \"prime p\" and *: \"p = 2 \\<or> (2 ^ p - 1) dvd gen_lucas_lehmer_sequence 4 (p - 2)\""], ["proof (state)\nthis:\n  prime p\n  p = 2 \\<or> 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p;\n     p = 2 \\<or> 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)\\<rbrakk>\n    \\<Longrightarrow> prime (2 ^ p - 1)", "from *"], ["proof (chain)\npicking this:\n  p = 2 \\<or> 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)", "consider \"p = 2\" | \"p \\<noteq> 2\" \"(2 ^ p - 1) dvd gen_lucas_lehmer_sequence 4 (p - 2)\""], ["proof (prove)\nusing this:\n  p = 2 \\<or> 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p = 2 \\<Longrightarrow> thesis;\n     \\<lbrakk>p \\<noteq> 2;\n      2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>p = 2 \\<Longrightarrow> ?thesis;\n   \\<lbrakk>p \\<noteq> 2;\n    2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p;\n     p = 2 \\<or> 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)\\<rbrakk>\n    \\<Longrightarrow> prime (2 ^ p - 1)", "thus \"prime (2 ^ p - 1 :: nat)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>p = 2 \\<Longrightarrow> ?thesis;\n   \\<lbrakk>p \\<noteq> 2;\n    2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. prime (2 ^ p - 1)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 2 \\<Longrightarrow> prime (2 ^ p - 1)\n 2. \\<lbrakk>p \\<noteq> 2;\n     2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)\\<rbrakk>\n    \\<Longrightarrow> prime (2 ^ p - 1)", "assume \"p \\<noteq> 2\" and dvd: \"(2 ^ p - 1) dvd gen_lucas_lehmer_sequence 4 (p - 2)\""], ["proof (state)\nthis:\n  p \\<noteq> 2\n  2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)\n\ngoal (2 subgoals):\n 1. p = 2 \\<Longrightarrow> prime (2 ^ p - 1)\n 2. \\<lbrakk>p \\<noteq> 2;\n     2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)\\<rbrakk>\n    \\<Longrightarrow> prime (2 ^ p - 1)", "from \\<open>prime p\\<close> and \\<open>p \\<noteq> 2\\<close>"], ["proof (chain)\npicking this:\n  prime p\n  p \\<noteq> 2", "have \"p > 2\""], ["proof (prove)\nusing this:\n  prime p\n  p \\<noteq> 2\n\ngoal (1 subgoal):\n 1. 2 < p", "using prime_gt_1_nat[of p]"], ["proof (prove)\nusing this:\n  prime p\n  p \\<noteq> 2\n  prime p \\<Longrightarrow> 1 < p\n\ngoal (1 subgoal):\n 1. 2 < p", "by auto"], ["proof (state)\nthis:\n  2 < p\n\ngoal (2 subgoals):\n 1. p = 2 \\<Longrightarrow> prime (2 ^ p - 1)\n 2. \\<lbrakk>p \\<noteq> 2;\n     2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)\\<rbrakk>\n    \\<Longrightarrow> prime (2 ^ p - 1)", "with prime"], ["proof (chain)\npicking this:\n  prime p\n  2 < p", "have \"odd p\""], ["proof (prove)\nusing this:\n  prime p\n  2 < p\n\ngoal (1 subgoal):\n 1. odd p", "by (auto simp: prime_odd_nat)"], ["proof (state)\nthis:\n  odd p\n\ngoal (2 subgoals):\n 1. p = 2 \\<Longrightarrow> prime (2 ^ p - 1)\n 2. \\<lbrakk>p \\<noteq> 2;\n     2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)\\<rbrakk>\n    \\<Longrightarrow> prime (2 ^ p - 1)", "with prime dvd"], ["proof (chain)\npicking this:\n  prime p\n  2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)\n  odd p", "show ?thesis"], ["proof (prove)\nusing this:\n  prime p\n  2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)\n  odd p\n\ngoal (1 subgoal):\n 1. prime (2 ^ p - 1)", "by (intro lucas_lehmer_sufficient)"], ["proof (state)\nthis:\n  prime (2 ^ p - 1)\n\ngoal (1 subgoal):\n 1. p = 2 \\<Longrightarrow> prime (2 ^ p - 1)", "qed auto"], ["proof (state)\nthis:\n  prime (2 ^ p - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary lucas_lehmer_correct':\n  \"prime (2 ^ p - 1 :: nat) \\<longleftrightarrow> prime p \\<and> (p = 2 \\<or> lucas_lehmer_test p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime (2 ^ p - 1) = (prime p \\<and> (p = 2 \\<or> lucas_lehmer_test p))", "using lucas_lehmer_correct[of p] prime_gt_1_nat[of p]"], ["proof (prove)\nusing this:\n  prime (2 ^ p - 1) =\n  (prime p \\<and>\n   (p = 2 \\<or> 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)))\n  prime p \\<Longrightarrow> 1 < p\n\ngoal (1 subgoal):\n 1. prime (2 ^ p - 1) = (prime p \\<and> (p = 2 \\<or> lucas_lehmer_test p))", "by (auto simp: lucas_lehmer_test_def)"], ["", "subsection \\<open>A first executable version Lucas--Lehmer test\\<close>"], ["", "text \\<open>\n  The following is an implementation of the Lucas--Lehmer test using modular\n  arithmetic on the integers. This is not the most efficient implementation --\n  the modular arithmetic can be replaced by much cheaper bitwise operations,\n  and we will do that in the next section.\n\\<close>"], ["", "primrec gen_lucas_lehmer_sequence' :: \"int \\<Rightarrow> int \\<Rightarrow> nat \\<Rightarrow> int\" where\n  \"gen_lucas_lehmer_sequence' m a 0 = a\"\n| \"gen_lucas_lehmer_sequence' m a (Suc n) = gen_lucas_lehmer_sequence' m ((a ^ 2 - 2) mod m) n\""], ["", "lemma gen_lucas_lehmer_sequence'_Suc':\n  \"gen_lucas_lehmer_sequence' m a (Suc n) = (gen_lucas_lehmer_sequence' m a n ^ 2 - 2) mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_lucas_lehmer_sequence' m a (Suc n) =\n    ((gen_lucas_lehmer_sequence' m a n)\\<^sup>2 - 2) mod m", "by (induction n arbitrary: a) auto"], ["", "lemma gen_lucas_lehmer_sequence'_correct:\n  assumes \"a \\<in> {0..<m}\"\n  shows   \"gen_lucas_lehmer_sequence' m a n = gen_lucas_lehmer_sequence a n mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_lucas_lehmer_sequence' m a n = gen_lucas_lehmer_sequence a n mod m", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> {0..<m}\n\ngoal (1 subgoal):\n 1. gen_lucas_lehmer_sequence' m a n = gen_lucas_lehmer_sequence a n mod m", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in> {0..<m} \\<Longrightarrow>\n    gen_lucas_lehmer_sequence' m a 0 = gen_lucas_lehmer_sequence a 0 mod m\n 2. \\<And>n.\n       \\<lbrakk>a \\<in> {0..<m} \\<Longrightarrow>\n                gen_lucas_lehmer_sequence' m a n =\n                gen_lucas_lehmer_sequence a n mod m;\n        a \\<in> {0..<m}\\<rbrakk>\n       \\<Longrightarrow> gen_lucas_lehmer_sequence' m a (Suc n) =\n                         gen_lucas_lehmer_sequence a (Suc n) mod m", "case (Suc n)"], ["proof (state)\nthis:\n  a \\<in> {0..<m} \\<Longrightarrow>\n  gen_lucas_lehmer_sequence' m a n = gen_lucas_lehmer_sequence a n mod m\n  a \\<in> {0..<m}\n\ngoal (2 subgoals):\n 1. a \\<in> {0..<m} \\<Longrightarrow>\n    gen_lucas_lehmer_sequence' m a 0 = gen_lucas_lehmer_sequence a 0 mod m\n 2. \\<And>n.\n       \\<lbrakk>a \\<in> {0..<m} \\<Longrightarrow>\n                gen_lucas_lehmer_sequence' m a n =\n                gen_lucas_lehmer_sequence a n mod m;\n        a \\<in> {0..<m}\\<rbrakk>\n       \\<Longrightarrow> gen_lucas_lehmer_sequence' m a (Suc n) =\n                         gen_lucas_lehmer_sequence a (Suc n) mod m", "have \"gen_lucas_lehmer_sequence' m a (Suc n) =\n          ((gen_lucas_lehmer_sequence a n mod m)\\<^sup>2 - 2) mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_lucas_lehmer_sequence' m a (Suc n) =\n    ((gen_lucas_lehmer_sequence a n mod m)\\<^sup>2 - 2) mod m", "using Suc"], ["proof (prove)\nusing this:\n  a \\<in> {0..<m} \\<Longrightarrow>\n  gen_lucas_lehmer_sequence' m a n = gen_lucas_lehmer_sequence a n mod m\n  a \\<in> {0..<m}\n\ngoal (1 subgoal):\n 1. gen_lucas_lehmer_sequence' m a (Suc n) =\n    ((gen_lucas_lehmer_sequence a n mod m)\\<^sup>2 - 2) mod m", "unfolding gen_lucas_lehmer_sequence'_Suc'"], ["proof (prove)\nusing this:\n  a \\<in> {0..<m} \\<Longrightarrow>\n  gen_lucas_lehmer_sequence' m a n = gen_lucas_lehmer_sequence a n mod m\n  a \\<in> {0..<m}\n\ngoal (1 subgoal):\n 1. ((gen_lucas_lehmer_sequence' m a n)\\<^sup>2 - 2) mod m =\n    ((gen_lucas_lehmer_sequence a n mod m)\\<^sup>2 - 2) mod m", "by simp"], ["proof (state)\nthis:\n  gen_lucas_lehmer_sequence' m a (Suc n) =\n  ((gen_lucas_lehmer_sequence a n mod m)\\<^sup>2 - 2) mod m\n\ngoal (2 subgoals):\n 1. a \\<in> {0..<m} \\<Longrightarrow>\n    gen_lucas_lehmer_sequence' m a 0 = gen_lucas_lehmer_sequence a 0 mod m\n 2. \\<And>n.\n       \\<lbrakk>a \\<in> {0..<m} \\<Longrightarrow>\n                gen_lucas_lehmer_sequence' m a n =\n                gen_lucas_lehmer_sequence a n mod m;\n        a \\<in> {0..<m}\\<rbrakk>\n       \\<Longrightarrow> gen_lucas_lehmer_sequence' m a (Suc n) =\n                         gen_lucas_lehmer_sequence a (Suc n) mod m", "also"], ["proof (state)\nthis:\n  gen_lucas_lehmer_sequence' m a (Suc n) =\n  ((gen_lucas_lehmer_sequence a n mod m)\\<^sup>2 - 2) mod m\n\ngoal (2 subgoals):\n 1. a \\<in> {0..<m} \\<Longrightarrow>\n    gen_lucas_lehmer_sequence' m a 0 = gen_lucas_lehmer_sequence a 0 mod m\n 2. \\<And>n.\n       \\<lbrakk>a \\<in> {0..<m} \\<Longrightarrow>\n                gen_lucas_lehmer_sequence' m a n =\n                gen_lucas_lehmer_sequence a n mod m;\n        a \\<in> {0..<m}\\<rbrakk>\n       \\<Longrightarrow> gen_lucas_lehmer_sequence' m a (Suc n) =\n                         gen_lucas_lehmer_sequence a (Suc n) mod m", "have \"\\<dots> = ((gen_lucas_lehmer_sequence a n)\\<^sup>2 - 2) mod m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((gen_lucas_lehmer_sequence a n mod m)\\<^sup>2 - 2) mod m =\n    ((gen_lucas_lehmer_sequence a n)\\<^sup>2 - 2) mod m", "by (intro congD cong_diff cong_pow cong_refl) (auto simp: cong_def)"], ["proof (state)\nthis:\n  ((gen_lucas_lehmer_sequence a n mod m)\\<^sup>2 - 2) mod m =\n  ((gen_lucas_lehmer_sequence a n)\\<^sup>2 - 2) mod m\n\ngoal (2 subgoals):\n 1. a \\<in> {0..<m} \\<Longrightarrow>\n    gen_lucas_lehmer_sequence' m a 0 = gen_lucas_lehmer_sequence a 0 mod m\n 2. \\<And>n.\n       \\<lbrakk>a \\<in> {0..<m} \\<Longrightarrow>\n                gen_lucas_lehmer_sequence' m a n =\n                gen_lucas_lehmer_sequence a n mod m;\n        a \\<in> {0..<m}\\<rbrakk>\n       \\<Longrightarrow> gen_lucas_lehmer_sequence' m a (Suc n) =\n                         gen_lucas_lehmer_sequence a (Suc n) mod m", "finally"], ["proof (chain)\npicking this:\n  gen_lucas_lehmer_sequence' m a (Suc n) =\n  ((gen_lucas_lehmer_sequence a n)\\<^sup>2 - 2) mod m", "show ?case"], ["proof (prove)\nusing this:\n  gen_lucas_lehmer_sequence' m a (Suc n) =\n  ((gen_lucas_lehmer_sequence a n)\\<^sup>2 - 2) mod m\n\ngoal (1 subgoal):\n 1. gen_lucas_lehmer_sequence' m a (Suc n) =\n    gen_lucas_lehmer_sequence a (Suc n) mod m", "by simp"], ["proof (state)\nthis:\n  gen_lucas_lehmer_sequence' m a (Suc n) =\n  gen_lucas_lehmer_sequence a (Suc n) mod m\n\ngoal (1 subgoal):\n 1. a \\<in> {0..<m} \\<Longrightarrow>\n    gen_lucas_lehmer_sequence' m a 0 = gen_lucas_lehmer_sequence a 0 mod m", "qed auto"], ["", "lemma lucas_lehmer_test_code_arithmetic [code]:\n  \"lucas_lehmer_test p = (p > 2 \\<and>\n     gen_lucas_lehmer_sequence' (2 ^ p - 1) 4 (p - 2) = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lucas_lehmer_test p =\n    (2 < p \\<and> gen_lucas_lehmer_sequence' (2 ^ p - 1) 4 (p - 2) = 0)", "unfolding lucas_lehmer_test_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 < p \\<and> 2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)) =\n    (2 < p \\<and> gen_lucas_lehmer_sequence' (2 ^ p - 1) 4 (p - 2) = 0)", "proof (intro conj_cong refl)"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 < p \\<Longrightarrow>\n    (2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)) =\n    (gen_lucas_lehmer_sequence' (2 ^ p - 1) 4 (p - 2) = 0)", "assume p: \"p > 2\""], ["proof (state)\nthis:\n  2 < p\n\ngoal (1 subgoal):\n 1. 2 < p \\<Longrightarrow>\n    (2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)) =\n    (gen_lucas_lehmer_sequence' (2 ^ p - 1) 4 (p - 2) = 0)", "from p"], ["proof (chain)\npicking this:\n  2 < p", "have \"2 ^ p \\<ge> (2 ^ 3 :: int)\""], ["proof (prove)\nusing this:\n  2 < p\n\ngoal (1 subgoal):\n 1. 2 ^ 3 \\<le> 2 ^ p", "by (intro power_increasing) auto"], ["proof (state)\nthis:\n  2 ^ 3 \\<le> 2 ^ p\n\ngoal (1 subgoal):\n 1. 2 < p \\<Longrightarrow>\n    (2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)) =\n    (gen_lucas_lehmer_sequence' (2 ^ p - 1) 4 (p - 2) = 0)", "have \"(2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)) \\<longleftrightarrow>\n          gen_lucas_lehmer_sequence 4 (p - 2) mod (2 ^ p - 1) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)) =\n    (gen_lucas_lehmer_sequence 4 (p - 2) mod (2 ^ p - 1) = 0)", "by auto"], ["proof (state)\nthis:\n  (2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)) =\n  (gen_lucas_lehmer_sequence 4 (p - 2) mod (2 ^ p - 1) = 0)\n\ngoal (1 subgoal):\n 1. 2 < p \\<Longrightarrow>\n    (2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)) =\n    (gen_lucas_lehmer_sequence' (2 ^ p - 1) 4 (p - 2) = 0)", "also"], ["proof (state)\nthis:\n  (2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)) =\n  (gen_lucas_lehmer_sequence 4 (p - 2) mod (2 ^ p - 1) = 0)\n\ngoal (1 subgoal):\n 1. 2 < p \\<Longrightarrow>\n    (2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)) =\n    (gen_lucas_lehmer_sequence' (2 ^ p - 1) 4 (p - 2) = 0)", "have \"gen_lucas_lehmer_sequence 4 (p - 2) mod (2 ^ p - 1) =\n             gen_lucas_lehmer_sequence' (2 ^ p - 1) 4 (p - 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_lucas_lehmer_sequence 4 (p - 2) mod (2 ^ p - 1) =\n    gen_lucas_lehmer_sequence' (2 ^ p - 1) 4 (p - 2)", "using \\<open>2 ^ p \\<ge> 2 ^ 3\\<close>"], ["proof (prove)\nusing this:\n  2 ^ 3 \\<le> 2 ^ p\n\ngoal (1 subgoal):\n 1. gen_lucas_lehmer_sequence 4 (p - 2) mod (2 ^ p - 1) =\n    gen_lucas_lehmer_sequence' (2 ^ p - 1) 4 (p - 2)", "by (intro gen_lucas_lehmer_sequence'_correct [symmetric]) auto"], ["proof (state)\nthis:\n  gen_lucas_lehmer_sequence 4 (p - 2) mod (2 ^ p - 1) =\n  gen_lucas_lehmer_sequence' (2 ^ p - 1) 4 (p - 2)\n\ngoal (1 subgoal):\n 1. 2 < p \\<Longrightarrow>\n    (2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)) =\n    (gen_lucas_lehmer_sequence' (2 ^ p - 1) 4 (p - 2) = 0)", "finally"], ["proof (chain)\npicking this:\n  (2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)) =\n  (gen_lucas_lehmer_sequence' (2 ^ p - 1) 4 (p - 2) = 0)", "show \"(2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)) =\n                (gen_lucas_lehmer_sequence' (2 ^ p - 1) 4 (p - 2) = 0)\""], ["proof (prove)\nusing this:\n  (2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)) =\n  (gen_lucas_lehmer_sequence' (2 ^ p - 1) 4 (p - 2) = 0)\n\ngoal (1 subgoal):\n 1. (2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)) =\n    (gen_lucas_lehmer_sequence' (2 ^ p - 1) 4 (p - 2) = 0)", "."], ["proof (state)\nthis:\n  (2 ^ p - 1 dvd gen_lucas_lehmer_sequence 4 (p - 2)) =\n  (gen_lucas_lehmer_sequence' (2 ^ p - 1) 4 (p - 2) = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mersenne_prime_iff: \"mersenne_prime p \\<longleftrightarrow> p > 2 \\<and> prime (2 ^ p - 1 :: nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mersenne_prime p = (2 < p \\<and> prime (2 ^ p - 1))", "by (simp add: mersenne_prime_def)"], ["", "lemma mersenne_prime_code [code]:\n  \"mersenne_prime p \\<longleftrightarrow> prime p \\<and> lucas_lehmer_test p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mersenne_prime p = (prime p \\<and> lucas_lehmer_test p)", "unfolding mersenne_prime_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 < p \\<and> prime (2 ^ p - 1)) = (prime p \\<and> lucas_lehmer_test p)", "using lucas_lehmer_correct'[of p]"], ["proof (prove)\nusing this:\n  prime (2 ^ p - 1) = (prime p \\<and> (p = 2 \\<or> lucas_lehmer_test p))\n\ngoal (1 subgoal):\n 1. (2 < p \\<and> prime (2 ^ p - 1)) = (prime p \\<and> lucas_lehmer_test p)", "by (auto simp: lucas_lehmer_test_def)"], ["", "end"]]}