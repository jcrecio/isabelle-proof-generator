{"file_name": "/home/qj213/afp-2021-10-22/thys/Certification_Monads/Parser_Monad.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Certification_Monads", "problem_names": ["lemma trim:\n  \"\\<exists>w. s = w @ trim s\"", "lemma bind_cong [fundef_cong]:\n  fixes m1 :: \"('t, 'a) gen_parser\"\n  assumes \"m1 ts2 = m2 ts2\"\n    and \"\\<And> y ts. m2 ts2 = Inr (y, ts) \\<Longrightarrow> f1 y ts = f2 y ts\"\n    and \"ts1 = ts2\"\n  shows \"((m1 \\<bind> f1) ts1) = ((m2 \\<bind> f2) ts2)\"", "lemma is_parserI [intro]:\n  assumes \"\\<And>s r x. p s = Inr (x, r) \\<Longrightarrow> length s \\<ge> length r\"\n  shows \"is_parser p\"", "lemma is_parserE [elim]:\n  assumes \"is_parser p\"\n    and \"(\\<And>s r x. p s = Inr (x, r) \\<Longrightarrow> length s \\<ge> length r) \\<Longrightarrow> P\"\n  shows \"P\"", "lemma is_parser_length:\n  assumes \"is_parser p\" and \"p s = Inr (x, r)\"\n  shows \"length s \\<ge> length r\"", "lemma is_cparserI [intro]:\n  assumes \"\\<And>s r x. p s = Inr (x, r) \\<Longrightarrow> length s > length r\"\n  shows \"is_cparser p\"", "lemma is_cparserE [elim]:\n  assumes \"is_cparser p\"\n    and \"(\\<And>s r x. p s = Inr (x, r) \\<Longrightarrow> length s > length r) \\<Longrightarrow> P\"\n  shows \"P\"", "lemma is_cparser_length:\n  assumes \"is_cparser p\" and \"p s = Inr (x, r)\"\n  shows \"length s > length r\"", "lemma is_parser_bind [intro, simp]:\n  assumes p: \"is_parser p\" and q: \"\\<And> x. is_parser (q x)\" \n  shows \"is_parser (p \\<bind> q)\"", "lemma oneof_result:\n  assumes \"oneof xs s = Inr (y, r)\" \n  shows \"\\<exists> w. s = y @ w @ r \\<and> y \\<in> set xs\"", "lemma exactly_result:\n  assumes \"exactly x s = Inr (y, r)\"\n  shows \"\\<exists> w. s = x @ w @ r \\<and> y = x\"", "lemma oneof_length: \n  assumes \"oneof xs s = Inr (y, r)\"\n  shows \"length s \\<ge> length y + length r \\<and> y \\<in> set xs\"", "lemma is_parser_oneof [intro]:\n  \"is_parser (oneof ts)\"", "lemma is_cparser_oneof [intro, simp]:\n  assumes \"\\<forall>x\\<in>set ts. length x \\<ge> 1\"\n  shows \"is_cparser (oneof ts)\"", "lemma exactly_length: \n  assumes \"exactly x s = Inr (y, r)\"\n  shows \"length s \\<ge> length x + length r\"", "lemma is_parser_exactly [intro]:\n  \"is_parser (exactly xs)\"", "lemma is_cparser_exactly [intro]:\n  assumes \"length xs \\<ge> 1\"\n  shows \"is_cparser (exactly xs)\"", "lemma is_parser_many [intro]:\n  \"is_parser (many P)\"", "lemma is_parser_manyof [intro]:\n  \"is_parser (manyof cs)\"", "lemma is_parser_return [intro]:\n  \"is_parser (return x)\"", "lemma is_parser_error [intro]:\n  \"is_parser (error x)\"", "lemma is_parser_If [intro!]:\n  assumes \"is_parser p\" and \"is_parser q\"\n  shows \"is_parser (if b then p else q)\"", "lemma is_parser_Let [intro!]:\n  assumes \"is_parser (f y)\"\n  shows \"is_parser (let x = y in f x)\"", "lemma is_parser_spaces [intro]:\n  \"is_parser spaces\"", "lemma scan_upto_length: \n  assumes \"scan_upto end s = Inr (y, r)\"\n  shows \"length s \\<ge> length end + length r\"", "lemma is_parser_scan_upto [intro]:\n  \"is_parser (scan_upto end)\"", "lemma is_cparser_scan_upto [intro]:\n  \"is_cparser (scan_upto (e # end))\""], "translations": [["", "lemma trim:\n  \"\\<exists>w. s = w @ trim s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w. s = w @ trim s", "by (unfold trim_def) (metis takeWhile_dropWhile_id)"], ["", "text \\<open>\n  A parser takes a list of tokes and returns either an error message or\n  a result together with the remaining tokens.\n\\<close>"], ["", "type_synonym\n  ('t, 'a) gen_parser = \"'t list \\<Rightarrow> string + ('a \\<times> 't list)\""], ["", "type_synonym\n  'a parser = \"(char, 'a) gen_parser\""], ["", "subsection \\<open>Monad-Setup for Parsers\\<close>"], ["", "definition return :: \"'a \\<Rightarrow> ('t, 'a) gen_parser\"\nwhere\n  \"return x = (\\<lambda>ts. Error_Monad.return (x, ts))\""], ["", "definition error :: \"string \\<Rightarrow> ('t, 'a) gen_parser\"\nwhere\n  \"error e = (\\<lambda>_. Error_Monad.error e)\""], ["", "definition bind :: \"('t, 'a) gen_parser \\<Rightarrow> ('a \\<Rightarrow> ('t, 'b) gen_parser) \\<Rightarrow> ('t, 'b) gen_parser\"\nwhere\n  \"bind m f ts = do {\n    (x, ts') \\<leftarrow> m ts;\n    f x ts'\n  }\""], ["", "adhoc_overloading\n  Monad_Syntax.bind bind"], ["", "lemma bind_cong [fundef_cong]:\n  fixes m1 :: \"('t, 'a) gen_parser\"\n  assumes \"m1 ts2 = m2 ts2\"\n    and \"\\<And> y ts. m2 ts2 = Inr (y, ts) \\<Longrightarrow> f1 y ts = f2 y ts\"\n    and \"ts1 = ts2\"\n  shows \"((m1 \\<bind> f1) ts1) = ((m2 \\<bind> f2) ts2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m1 \\<bind> f1) ts1 = (m2 \\<bind> f2) ts2", "using assms"], ["proof (prove)\nusing this:\n  m1 ts2 = m2 ts2\n  m2 ts2 = Inr (?y, ?ts) \\<Longrightarrow> f1 ?y ?ts = f2 ?y ?ts\n  ts1 = ts2\n\ngoal (1 subgoal):\n 1. (m1 \\<bind> f1) ts1 = (m2 \\<bind> f2) ts2", "unfolding bind_def"], ["proof (prove)\nusing this:\n  m1 ts2 = m2 ts2\n  m2 ts2 = Inr (?y, ?ts) \\<Longrightarrow> f1 ?y ?ts = f2 ?y ?ts\n  ts1 = ts2\n\ngoal (1 subgoal):\n 1. m1 ts1 \\<bind> (\\<lambda>(x, y). f1 x y) =\n    m2 ts2 \\<bind> (\\<lambda>(x, y). f2 x y)", "by (cases \"m1 ts1\") auto"], ["", "definition update_tokens :: \"('t list \\<Rightarrow> 't list) \\<Rightarrow> ('t, 't list) gen_parser\"\nwhere\n  \"update_tokens f ts = Error_Monad.return (ts, f ts)\""], ["", "definition get_tokens :: \"('t, 't list) gen_parser\"\nwhere\n  \"get_tokens = update_tokens (\\<lambda>x. x)\""], ["", "definition set_tokens :: \"'t list \\<Rightarrow> ('t, unit) gen_parser\"\nwhere\n  [code_unfold]: \"set_tokens ts = update_tokens (\\<lambda>_. ts) \\<then> return ()\""], ["", "definition err_expecting :: \"string \\<Rightarrow> ('t::show, 'a) gen_parser\"\nwhere\n  \"err_expecting msg ts = Error_Monad.error\n    (''expecting '' @ msg @ '', but found: '' @ shows_quote (shows (take 30 ts)) [])\""], ["", "fun eoi :: \"('t :: show, unit) gen_parser\"\nwhere\n  \"eoi [] = Error_Monad.return ((), [])\" |\n  \"eoi ts = err_expecting ''end of input'' ts\""], ["", "fun exactly_aux :: \"string \\<Rightarrow> string \\<Rightarrow> string \\<Rightarrow> string parser\"\nwhere\n  \"exactly_aux s i (x # xs) (y # ys) =\n    (if x = y then exactly_aux s i xs ys\n    else err_expecting (''\\\"'' @ s @ ''\\\"'') i)\" |\n  \"exactly_aux s i [] xs = Error_Monad.return (s, trim xs)\" |\n  \"exactly_aux s i (x # xs) [] = err_expecting (''\\\"'' @ s @ ''\\\"'') i\""], ["", "fun oneof_aux :: \"string list \\<Rightarrow> string list \\<Rightarrow> string parser\"\nwhere\n  \"oneof_aux allowed (x # xs) ts =\n    (if map snd (zip x ts) = x then Error_Monad.return (x, trim (List.drop (length x) ts))\n    else oneof_aux allowed xs ts)\" |\n  \"oneof_aux allowed [] ts = err_expecting (''one of '' @ shows_list allowed []) ts\""], ["", "definition is_parser :: \"'a parser \\<Rightarrow> bool\" where\n  \"is_parser p \\<longleftrightarrow> (\\<forall>s r x. p s = Inr (x, r) \\<longrightarrow> length s \\<ge> length r)\""], ["", "lemma is_parserI [intro]:\n  assumes \"\\<And>s r x. p s = Inr (x, r) \\<Longrightarrow> length s \\<ge> length r\"\n  shows \"is_parser p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_parser p", "using assms"], ["proof (prove)\nusing this:\n  p ?s = Inr (?x, ?r) \\<Longrightarrow> length ?r \\<le> length ?s\n\ngoal (1 subgoal):\n 1. is_parser p", "unfolding is_parser_def"], ["proof (prove)\nusing this:\n  p ?s = Inr (?x, ?r) \\<Longrightarrow> length ?r \\<le> length ?s\n\ngoal (1 subgoal):\n 1. \\<forall>s r x.\n       p s = Inr (x, r) \\<longrightarrow> length r \\<le> length s", "by blast"], ["", "lemma is_parserE [elim]:\n  assumes \"is_parser p\"\n    and \"(\\<And>s r x. p s = Inr (x, r) \\<Longrightarrow> length s \\<ge> length r) \\<Longrightarrow> P\"\n  shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using assms"], ["proof (prove)\nusing this:\n  is_parser p\n  (\\<And>s r x.\n      p s = Inr (x, r) \\<Longrightarrow>\n      length r \\<le> length s) \\<Longrightarrow>\n  P\n\ngoal (1 subgoal):\n 1. P", "by (auto simp: is_parser_def)"], ["", "lemma is_parser_length:\n  assumes \"is_parser p\" and \"p s = Inr (x, r)\"\n  shows \"length s \\<ge> length r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length r \\<le> length s", "using assms"], ["proof (prove)\nusing this:\n  is_parser p\n  p s = Inr (x, r)\n\ngoal (1 subgoal):\n 1. length r \\<le> length s", "by blast"], ["", "text \\<open>A \\emph{consuming parser} (cparser for short) consumes at least one token of input.\\<close>"], ["", "definition is_cparser :: \"'a parser \\<Rightarrow> bool\"\nwhere\n  \"is_cparser p \\<longleftrightarrow> (\\<forall>s r x. p s = Inr (x, r) \\<longrightarrow> length s > length r)\""], ["", "lemma is_cparserI [intro]:\n  assumes \"\\<And>s r x. p s = Inr (x, r) \\<Longrightarrow> length s > length r\"\n  shows \"is_cparser p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cparser p", "using assms"], ["proof (prove)\nusing this:\n  p ?s = Inr (?x, ?r) \\<Longrightarrow> length ?r < length ?s\n\ngoal (1 subgoal):\n 1. is_cparser p", "unfolding is_cparser_def"], ["proof (prove)\nusing this:\n  p ?s = Inr (?x, ?r) \\<Longrightarrow> length ?r < length ?s\n\ngoal (1 subgoal):\n 1. \\<forall>s r x. p s = Inr (x, r) \\<longrightarrow> length r < length s", "by blast"], ["", "lemma is_cparserE [elim]:\n  assumes \"is_cparser p\"\n    and \"(\\<And>s r x. p s = Inr (x, r) \\<Longrightarrow> length s > length r) \\<Longrightarrow> P\"\n  shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using assms"], ["proof (prove)\nusing this:\n  is_cparser p\n  (\\<And>s r x.\n      p s = Inr (x, r) \\<Longrightarrow>\n      length r < length s) \\<Longrightarrow>\n  P\n\ngoal (1 subgoal):\n 1. P", "by (auto simp: is_cparser_def)"], ["", "lemma is_cparser_length:\n  assumes \"is_cparser p\" and \"p s = Inr (x, r)\"\n  shows \"length s > length r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length r < length s", "using assms"], ["proof (prove)\nusing this:\n  is_cparser p\n  p s = Inr (x, r)\n\ngoal (1 subgoal):\n 1. length r < length s", "by blast"], ["", "lemma is_parser_bind [intro, simp]:\n  assumes p: \"is_parser p\" and q: \"\\<And> x. is_parser (q x)\" \n  shows \"is_parser (p \\<bind> q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_parser (p \\<bind> q)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       (p \\<bind> q) s = Inr (x, r) \\<Longrightarrow>\n       length r \\<le> length s", "fix s r x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       (p \\<bind> q) s = Inr (x, r) \\<Longrightarrow>\n       length r \\<le> length s", "assume \"(p \\<bind> q) s = Inr (x, r)\""], ["proof (state)\nthis:\n  (p \\<bind> q) s = Inr (x, r)\n\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       (p \\<bind> q) s = Inr (x, r) \\<Longrightarrow>\n       length r \\<le> length s", "then"], ["proof (chain)\npicking this:\n  (p \\<bind> q) s = Inr (x, r)", "obtain y t\n    where P: \"p s = Inr (y, t)\" and Q: \"q y t = Inr (x, r)\""], ["proof (prove)\nusing this:\n  (p \\<bind> q) s = Inr (x, r)\n\ngoal (1 subgoal):\n 1. (\\<And>y t.\n        \\<lbrakk>p s = Inr (y, t); q y t = Inr (x, r)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding bind_def"], ["proof (prove)\nusing this:\n  p s \\<bind> (\\<lambda>(x, y). q x y) = Inr (x, r)\n\ngoal (1 subgoal):\n 1. (\\<And>y t.\n        \\<lbrakk>p s = Inr (y, t); q y t = Inr (x, r)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"p s\") auto"], ["proof (state)\nthis:\n  p s = Inr (y, t)\n  q y t = Inr (x, r)\n\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       (p \\<bind> q) s = Inr (x, r) \\<Longrightarrow>\n       length r \\<le> length s", "have \"length r \\<le> length t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length r \\<le> length t", "using q and Q"], ["proof (prove)\nusing this:\n  is_parser (q ?x)\n  q y t = Inr (x, r)\n\ngoal (1 subgoal):\n 1. length r \\<le> length t", "by (auto simp: is_parser_def)"], ["proof (state)\nthis:\n  length r \\<le> length t\n\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       (p \\<bind> q) s = Inr (x, r) \\<Longrightarrow>\n       length r \\<le> length s", "also"], ["proof (state)\nthis:\n  length r \\<le> length t\n\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       (p \\<bind> q) s = Inr (x, r) \\<Longrightarrow>\n       length r \\<le> length s", "have \"\\<dots> \\<le> length s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length t \\<le> length s", "using p and P"], ["proof (prove)\nusing this:\n  is_parser p\n  p s = Inr (y, t)\n\ngoal (1 subgoal):\n 1. length t \\<le> length s", "by (auto simp: is_parser_def)"], ["proof (state)\nthis:\n  length t \\<le> length s\n\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       (p \\<bind> q) s = Inr (x, r) \\<Longrightarrow>\n       length r \\<le> length s", "finally"], ["proof (chain)\npicking this:\n  length r \\<le> length s", "show \"length r \\<le> length s\""], ["proof (prove)\nusing this:\n  length r \\<le> length s\n\ngoal (1 subgoal):\n 1. length r \\<le> length s", "."], ["proof (state)\nthis:\n  length r \\<le> length s\n\ngoal:\nNo subgoals!", "qed"], ["", "definition oneof :: \"string list \\<Rightarrow> string parser\"\nwhere\n  \"oneof xs = oneof_aux xs xs\""], ["", "lemma oneof_result:\n  assumes \"oneof xs s = Inr (y, r)\" \n  shows \"\\<exists> w. s = y @ w @ r \\<and> y \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w. s = y @ w @ r \\<and> y \\<in> set xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>w. s = y @ w @ r \\<and> y \\<in> set xs", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>w. s = y @ w @ r \\<and> y \\<in> set xs", "fix ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>w. s = y @ w @ r \\<and> y \\<in> set xs", "assume \"oneof_aux ys xs s = Inr (y,r)\""], ["proof (state)\nthis:\n  oneof_aux ys xs s = Inr (y, r)\n\ngoal (1 subgoal):\n 1. \\<exists>w. s = y @ w @ r \\<and> y \\<in> set xs", "hence \"\\<exists> w. s = y @ w @ r \\<and> y \\<in> set xs\""], ["proof (prove)\nusing this:\n  oneof_aux ys xs s = Inr (y, r)\n\ngoal (1 subgoal):\n 1. \\<exists>w. s = y @ w @ r \\<and> y \\<in> set xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. oneof_aux ys [] s = Inr (y, r) \\<Longrightarrow>\n    \\<exists>w. s = y @ w @ r \\<and> y \\<in> set []\n 2. \\<And>a xs.\n       \\<lbrakk>oneof_aux ys xs s = Inr (y, r) \\<Longrightarrow>\n                \\<exists>w. s = y @ w @ r \\<and> y \\<in> set xs;\n        oneof_aux ys (a # xs) s = Inr (y, r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w.\n                            s = y @ w @ r \\<and> y \\<in> set (a # xs)", "case Nil"], ["proof (state)\nthis:\n  oneof_aux ys [] s = Inr (y, r)\n\ngoal (2 subgoals):\n 1. oneof_aux ys [] s = Inr (y, r) \\<Longrightarrow>\n    \\<exists>w. s = y @ w @ r \\<and> y \\<in> set []\n 2. \\<And>a xs.\n       \\<lbrakk>oneof_aux ys xs s = Inr (y, r) \\<Longrightarrow>\n                \\<exists>w. s = y @ w @ r \\<and> y \\<in> set xs;\n        oneof_aux ys (a # xs) s = Inr (y, r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w.\n                            s = y @ w @ r \\<and> y \\<in> set (a # xs)", "thus ?case"], ["proof (prove)\nusing this:\n  oneof_aux ys [] s = Inr (y, r)\n\ngoal (1 subgoal):\n 1. \\<exists>w. s = y @ w @ r \\<and> y \\<in> set []", "by (simp add: err_expecting_def)"], ["proof (state)\nthis:\n  \\<exists>w. s = y @ w @ r \\<and> y \\<in> set []\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>oneof_aux ys xs s = Inr (y, r) \\<Longrightarrow>\n                \\<exists>w. s = y @ w @ r \\<and> y \\<in> set xs;\n        oneof_aux ys (a # xs) s = Inr (y, r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w.\n                            s = y @ w @ r \\<and> y \\<in> set (a # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>oneof_aux ys xs s = Inr (y, r) \\<Longrightarrow>\n                \\<exists>w. s = y @ w @ r \\<and> y \\<in> set xs;\n        oneof_aux ys (a # xs) s = Inr (y, r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w.\n                            s = y @ w @ r \\<and> y \\<in> set (a # xs)", "case (Cons z zs)"], ["proof (state)\nthis:\n  oneof_aux ys zs s = Inr (y, r) \\<Longrightarrow>\n  \\<exists>w. s = y @ w @ r \\<and> y \\<in> set zs\n  oneof_aux ys (z # zs) s = Inr (y, r)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>oneof_aux ys xs s = Inr (y, r) \\<Longrightarrow>\n                \\<exists>w. s = y @ w @ r \\<and> y \\<in> set xs;\n        oneof_aux ys (a # xs) s = Inr (y, r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w.\n                            s = y @ w @ r \\<and> y \\<in> set (a # xs)", "thus ?case"], ["proof (prove)\nusing this:\n  oneof_aux ys zs s = Inr (y, r) \\<Longrightarrow>\n  \\<exists>w. s = y @ w @ r \\<and> y \\<in> set zs\n  oneof_aux ys (z # zs) s = Inr (y, r)\n\ngoal (1 subgoal):\n 1. \\<exists>w. s = y @ w @ r \\<and> y \\<in> set (z # zs)", "proof (cases \"map snd (zip z s) = z\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>oneof_aux ys zs s = Inr (y, r) \\<Longrightarrow>\n             \\<exists>w. s = y @ w @ r \\<and> y \\<in> set zs;\n     oneof_aux ys (z # zs) s = Inr (y, r); map snd (zip z s) = z\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w. s = y @ w @ r \\<and> y \\<in> set (z # zs)\n 2. \\<lbrakk>oneof_aux ys zs s = Inr (y, r) \\<Longrightarrow>\n             \\<exists>w. s = y @ w @ r \\<and> y \\<in> set zs;\n     oneof_aux ys (z # zs) s = Inr (y, r);\n     map snd (zip z s) \\<noteq> z\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w. s = y @ w @ r \\<and> y \\<in> set (z # zs)", "case False"], ["proof (state)\nthis:\n  map snd (zip z s) \\<noteq> z\n\ngoal (2 subgoals):\n 1. \\<lbrakk>oneof_aux ys zs s = Inr (y, r) \\<Longrightarrow>\n             \\<exists>w. s = y @ w @ r \\<and> y \\<in> set zs;\n     oneof_aux ys (z # zs) s = Inr (y, r); map snd (zip z s) = z\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w. s = y @ w @ r \\<and> y \\<in> set (z # zs)\n 2. \\<lbrakk>oneof_aux ys zs s = Inr (y, r) \\<Longrightarrow>\n             \\<exists>w. s = y @ w @ r \\<and> y \\<in> set zs;\n     oneof_aux ys (z # zs) s = Inr (y, r);\n     map snd (zip z s) \\<noteq> z\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w. s = y @ w @ r \\<and> y \\<in> set (z # zs)", "with Cons"], ["proof (chain)\npicking this:\n  oneof_aux ys zs s = Inr (y, r) \\<Longrightarrow>\n  \\<exists>w. s = y @ w @ r \\<and> y \\<in> set zs\n  oneof_aux ys (z # zs) s = Inr (y, r)\n  map snd (zip z s) \\<noteq> z", "show ?thesis"], ["proof (prove)\nusing this:\n  oneof_aux ys zs s = Inr (y, r) \\<Longrightarrow>\n  \\<exists>w. s = y @ w @ r \\<and> y \\<in> set zs\n  oneof_aux ys (z # zs) s = Inr (y, r)\n  map snd (zip z s) \\<noteq> z\n\ngoal (1 subgoal):\n 1. \\<exists>w. s = y @ w @ r \\<and> y \\<in> set (z # zs)", "by simp"], ["proof (state)\nthis:\n  \\<exists>w. s = y @ w @ r \\<and> y \\<in> set (z # zs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>oneof_aux ys zs s = Inr (y, r) \\<Longrightarrow>\n             \\<exists>w. s = y @ w @ r \\<and> y \\<in> set zs;\n     oneof_aux ys (z # zs) s = Inr (y, r); map snd (zip z s) = z\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w. s = y @ w @ r \\<and> y \\<in> set (z # zs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>oneof_aux ys zs s = Inr (y, r) \\<Longrightarrow>\n             \\<exists>w. s = y @ w @ r \\<and> y \\<in> set zs;\n     oneof_aux ys (z # zs) s = Inr (y, r); map snd (zip z s) = z\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w. s = y @ w @ r \\<and> y \\<in> set (z # zs)", "case True"], ["proof (state)\nthis:\n  map snd (zip z s) = z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>oneof_aux ys zs s = Inr (y, r) \\<Longrightarrow>\n             \\<exists>w. s = y @ w @ r \\<and> y \\<in> set zs;\n     oneof_aux ys (z # zs) s = Inr (y, r); map snd (zip z s) = z\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w. s = y @ w @ r \\<and> y \\<in> set (z # zs)", "hence s: \"s = z @ drop (length z) s\""], ["proof (prove)\nusing this:\n  map snd (zip z s) = z\n\ngoal (1 subgoal):\n 1. s = z @ drop (length z) s", "proof (induct z arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       map snd (zip [] s) = [] \\<Longrightarrow> s = [] @ drop (length []) s\n 2. \\<And>a z s.\n       \\<lbrakk>\\<And>s.\n                   map snd (zip z s) = z \\<Longrightarrow>\n                   s = z @ drop (length z) s;\n        map snd (zip (a # z) s) = a # z\\<rbrakk>\n       \\<Longrightarrow> s = (a # z) @ drop (length (a # z)) s", "case (Cons a zz)"], ["proof (state)\nthis:\n  map snd (zip zz ?s) = zz \\<Longrightarrow> ?s = zz @ drop (length zz) ?s\n  map snd (zip (a # zz) s) = a # zz\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       map snd (zip [] s) = [] \\<Longrightarrow> s = [] @ drop (length []) s\n 2. \\<And>a z s.\n       \\<lbrakk>\\<And>s.\n                   map snd (zip z s) = z \\<Longrightarrow>\n                   s = z @ drop (length z) s;\n        map snd (zip (a # z) s) = a # z\\<rbrakk>\n       \\<Longrightarrow> s = (a # z) @ drop (length (a # z)) s", "thus ?case"], ["proof (prove)\nusing this:\n  map snd (zip zz ?s) = zz \\<Longrightarrow> ?s = zz @ drop (length zz) ?s\n  map snd (zip (a # zz) s) = a # zz\n\ngoal (1 subgoal):\n 1. s = (a # zz) @ drop (length (a # zz)) s", "by (cases s, auto)"], ["proof (state)\nthis:\n  s = (a # zz) @ drop (length (a # zz)) s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       map snd (zip [] s) = [] \\<Longrightarrow> s = [] @ drop (length []) s", "qed simp"], ["proof (state)\nthis:\n  s = z @ drop (length z) s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>oneof_aux ys zs s = Inr (y, r) \\<Longrightarrow>\n             \\<exists>w. s = y @ w @ r \\<and> y \\<in> set zs;\n     oneof_aux ys (z # zs) s = Inr (y, r); map snd (zip z s) = z\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w. s = y @ w @ r \\<and> y \\<in> set (z # zs)", "from trim[of \"drop (length z) s\"]"], ["proof (chain)\npicking this:\n  \\<exists>w. drop (length z) s = w @ trim (drop (length z) s)", "obtain w where \"drop (length z) s = w @ trim (drop (length z) s)\""], ["proof (prove)\nusing this:\n  \\<exists>w. drop (length z) s = w @ trim (drop (length z) s)\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        drop (length z) s = w @ trim (drop (length z) s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  drop (length z) s = w @ trim (drop (length z) s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>oneof_aux ys zs s = Inr (y, r) \\<Longrightarrow>\n             \\<exists>w. s = y @ w @ r \\<and> y \\<in> set zs;\n     oneof_aux ys (z # zs) s = Inr (y, r); map snd (zip z s) = z\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w. s = y @ w @ r \\<and> y \\<in> set (z # zs)", "with s"], ["proof (chain)\npicking this:\n  s = z @ drop (length z) s\n  drop (length z) s = w @ trim (drop (length z) s)", "have s: \"s = z @ w @ trim (drop (length z) s)\""], ["proof (prove)\nusing this:\n  s = z @ drop (length z) s\n  drop (length z) s = w @ trim (drop (length z) s)\n\ngoal (1 subgoal):\n 1. s = z @ w @ trim (drop (length z) s)", "by auto"], ["proof (state)\nthis:\n  s = z @ w @ trim (drop (length z) s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>oneof_aux ys zs s = Inr (y, r) \\<Longrightarrow>\n             \\<exists>w. s = y @ w @ r \\<and> y \\<in> set zs;\n     oneof_aux ys (z # zs) s = Inr (y, r); map snd (zip z s) = z\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w. s = y @ w @ r \\<and> y \\<in> set (z # zs)", "from True Cons(2)"], ["proof (chain)\npicking this:\n  map snd (zip z s) = z\n  oneof_aux ys (z # zs) s = Inr (y, r)", "have yz: \"y = z\" and r: \"r = trim (drop (length y) s)\""], ["proof (prove)\nusing this:\n  map snd (zip z s) = z\n  oneof_aux ys (z # zs) s = Inr (y, r)\n\ngoal (1 subgoal):\n 1. y = z &&& r = trim (drop (length y) s)", "by auto"], ["proof (state)\nthis:\n  y = z\n  r = trim (drop (length y) s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>oneof_aux ys zs s = Inr (y, r) \\<Longrightarrow>\n             \\<exists>w. s = y @ w @ r \\<and> y \\<in> set zs;\n     oneof_aux ys (z # zs) s = Inr (y, r); map snd (zip z s) = z\\<rbrakk>\n    \\<Longrightarrow> \\<exists>w. s = y @ w @ r \\<and> y \\<in> set (z # zs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w. s = y @ w @ r \\<and> y \\<in> set (z # zs)", "by (simp add: yz r, rule exI, rule s)"], ["proof (state)\nthis:\n  \\<exists>w. s = y @ w @ r \\<and> y \\<in> set (z # zs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>w. s = y @ w @ r \\<and> y \\<in> set (z # zs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>w. s = y @ w @ r \\<and> y \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<exists>w. s = y @ w @ r \\<and> y \\<in> set xs", "}"], ["proof (state)\nthis:\n  oneof_aux ?ys2 xs s = Inr (y, r) \\<Longrightarrow>\n  \\<exists>w. s = y @ w @ r \\<and> y \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<exists>w. s = y @ w @ r \\<and> y \\<in> set xs", "from this [OF assms [unfolded oneof_def]]"], ["proof (chain)\npicking this:\n  \\<exists>w. s = y @ w @ r \\<and> y \\<in> set xs", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>w. s = y @ w @ r \\<and> y \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<exists>w. s = y @ w @ r \\<and> y \\<in> set xs", "."], ["proof (state)\nthis:\n  \\<exists>w. s = y @ w @ r \\<and> y \\<in> set xs\n\ngoal:\nNo subgoals!", "qed"], ["", "definition exactly :: \"string \\<Rightarrow> string parser\"\nwhere \n  \"exactly s x = exactly_aux s x s x\""], ["", "lemma exactly_result:\n  assumes \"exactly x s = Inr (y, r)\"\n  shows \"\\<exists> w. s = x @ w @ r \\<and> y = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w. s = x @ w @ r \\<and> y = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>w. s = x @ w @ r \\<and> y = x", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>w. s = x @ w @ r \\<and> y = x", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>w. s = x @ w @ r \\<and> y = x", "assume \"exactly_aux a b x s = Inr (y,r)\""], ["proof (state)\nthis:\n  exactly_aux a b x s = Inr (y, r)\n\ngoal (1 subgoal):\n 1. \\<exists>w. s = x @ w @ r \\<and> y = x", "hence \"\\<exists> w. s = x @ w @ r \\<and> y = a\""], ["proof (prove)\nusing this:\n  exactly_aux a b x s = Inr (y, r)\n\ngoal (1 subgoal):\n 1. \\<exists>w. s = x @ w @ r \\<and> y = a", "proof (induct x arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       exactly_aux a b [] s = Inr (y, r) \\<Longrightarrow>\n       \\<exists>w. s = [] @ w @ r \\<and> y = a\n 2. \\<And>aa x s.\n       \\<lbrakk>\\<And>s.\n                   exactly_aux a b x s = Inr (y, r) \\<Longrightarrow>\n                   \\<exists>w. s = x @ w @ r \\<and> y = a;\n        exactly_aux a b (aa # x) s = Inr (y, r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w. s = (aa # x) @ w @ r \\<and> y = a", "case Nil"], ["proof (state)\nthis:\n  exactly_aux a b [] s = Inr (y, r)\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       exactly_aux a b [] s = Inr (y, r) \\<Longrightarrow>\n       \\<exists>w. s = [] @ w @ r \\<and> y = a\n 2. \\<And>aa x s.\n       \\<lbrakk>\\<And>s.\n                   exactly_aux a b x s = Inr (y, r) \\<Longrightarrow>\n                   \\<exists>w. s = x @ w @ r \\<and> y = a;\n        exactly_aux a b (aa # x) s = Inr (y, r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w. s = (aa # x) @ w @ r \\<and> y = a", "thus ?case"], ["proof (prove)\nusing this:\n  exactly_aux a b [] s = Inr (y, r)\n\ngoal (1 subgoal):\n 1. \\<exists>w. s = [] @ w @ r \\<and> y = a", "using trim[of s]"], ["proof (prove)\nusing this:\n  exactly_aux a b [] s = Inr (y, r)\n  \\<exists>w. s = w @ trim s\n\ngoal (1 subgoal):\n 1. \\<exists>w. s = [] @ w @ r \\<and> y = a", "by auto"], ["proof (state)\nthis:\n  \\<exists>w. s = [] @ w @ r \\<and> y = a\n\ngoal (1 subgoal):\n 1. \\<And>aa x s.\n       \\<lbrakk>\\<And>s.\n                   exactly_aux a b x s = Inr (y, r) \\<Longrightarrow>\n                   \\<exists>w. s = x @ w @ r \\<and> y = a;\n        exactly_aux a b (aa # x) s = Inr (y, r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w. s = (aa # x) @ w @ r \\<and> y = a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa x s.\n       \\<lbrakk>\\<And>s.\n                   exactly_aux a b x s = Inr (y, r) \\<Longrightarrow>\n                   \\<exists>w. s = x @ w @ r \\<and> y = a;\n        exactly_aux a b (aa # x) s = Inr (y, r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w. s = (aa # x) @ w @ r \\<and> y = a", "case (Cons c xs)"], ["proof (state)\nthis:\n  exactly_aux a b xs ?s = Inr (y, r) \\<Longrightarrow>\n  \\<exists>w. ?s = xs @ w @ r \\<and> y = a\n  exactly_aux a b (c # xs) s = Inr (y, r)\n\ngoal (1 subgoal):\n 1. \\<And>aa x s.\n       \\<lbrakk>\\<And>s.\n                   exactly_aux a b x s = Inr (y, r) \\<Longrightarrow>\n                   \\<exists>w. s = x @ w @ r \\<and> y = a;\n        exactly_aux a b (aa # x) s = Inr (y, r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w. s = (aa # x) @ w @ r \\<and> y = a", "note xs = this"], ["proof (state)\nthis:\n  exactly_aux a b xs ?s = Inr (y, r) \\<Longrightarrow>\n  \\<exists>w. ?s = xs @ w @ r \\<and> y = a\n  exactly_aux a b (c # xs) s = Inr (y, r)\n\ngoal (1 subgoal):\n 1. \\<And>aa x s.\n       \\<lbrakk>\\<And>s.\n                   exactly_aux a b x s = Inr (y, r) \\<Longrightarrow>\n                   \\<exists>w. s = x @ w @ r \\<and> y = a;\n        exactly_aux a b (aa # x) s = Inr (y, r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w. s = (aa # x) @ w @ r \\<and> y = a", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w. s = (c # xs) @ w @ r \\<and> y = a", "proof (cases s)"], ["proof (state)\ngoal (2 subgoals):\n 1. s = [] \\<Longrightarrow> \\<exists>w. s = (c # xs) @ w @ r \\<and> y = a\n 2. \\<And>aa list.\n       s = aa # list \\<Longrightarrow>\n       \\<exists>w. s = (c # xs) @ w @ r \\<and> y = a", "case Nil"], ["proof (state)\nthis:\n  s = []\n\ngoal (2 subgoals):\n 1. s = [] \\<Longrightarrow> \\<exists>w. s = (c # xs) @ w @ r \\<and> y = a\n 2. \\<And>aa list.\n       s = aa # list \\<Longrightarrow>\n       \\<exists>w. s = (c # xs) @ w @ r \\<and> y = a", "with xs"], ["proof (chain)\npicking this:\n  exactly_aux a b xs ?s = Inr (y, r) \\<Longrightarrow>\n  \\<exists>w. ?s = xs @ w @ r \\<and> y = a\n  exactly_aux a b (c # xs) s = Inr (y, r)\n  s = []", "show ?thesis"], ["proof (prove)\nusing this:\n  exactly_aux a b xs ?s = Inr (y, r) \\<Longrightarrow>\n  \\<exists>w. ?s = xs @ w @ r \\<and> y = a\n  exactly_aux a b (c # xs) s = Inr (y, r)\n  s = []\n\ngoal (1 subgoal):\n 1. \\<exists>w. s = (c # xs) @ w @ r \\<and> y = a", "by (auto simp: err_expecting_def)"], ["proof (state)\nthis:\n  \\<exists>w. s = (c # xs) @ w @ r \\<and> y = a\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       s = aa # list \\<Longrightarrow>\n       \\<exists>w. s = (c # xs) @ w @ r \\<and> y = a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       s = aa # list \\<Longrightarrow>\n       \\<exists>w. s = (c # xs) @ w @ r \\<and> y = a", "case (Cons d ss)"], ["proof (state)\nthis:\n  s = d # ss\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       s = aa # list \\<Longrightarrow>\n       \\<exists>w. s = (c # xs) @ w @ r \\<and> y = a", "note xs = xs[unfolded Cons]"], ["proof (state)\nthis:\n  exactly_aux a b xs ?s = Inr (y, r) \\<Longrightarrow>\n  \\<exists>w. ?s = xs @ w @ r \\<and> y = a\n  exactly_aux a b (c # xs) (d # ss) = Inr (y, r)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       s = aa # list \\<Longrightarrow>\n       \\<exists>w. s = (c # xs) @ w @ r \\<and> y = a", "from xs(2)"], ["proof (chain)\npicking this:\n  exactly_aux a b (c # xs) (d # ss) = Inr (y, r)", "have \"exactly_aux a b xs ss = Inr (y, r) \\<and> c = d\""], ["proof (prove)\nusing this:\n  exactly_aux a b (c # xs) (d # ss) = Inr (y, r)\n\ngoal (1 subgoal):\n 1. exactly_aux a b xs ss = Inr (y, r) \\<and> c = d", "by (cases \"c = d\") (auto simp: err_expecting_def)"], ["proof (state)\nthis:\n  exactly_aux a b xs ss = Inr (y, r) \\<and> c = d\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       s = aa # list \\<Longrightarrow>\n       \\<exists>w. s = (c # xs) @ w @ r \\<and> y = a", "hence res: \"exactly_aux a b xs ss = Inr (y, r)\" and c: \"c = d\""], ["proof (prove)\nusing this:\n  exactly_aux a b xs ss = Inr (y, r) \\<and> c = d\n\ngoal (1 subgoal):\n 1. exactly_aux a b xs ss = Inr (y, r) &&& c = d", "by auto"], ["proof (state)\nthis:\n  exactly_aux a b xs ss = Inr (y, r)\n  c = d\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       s = aa # list \\<Longrightarrow>\n       \\<exists>w. s = (c # xs) @ w @ r \\<and> y = a", "from xs(1)[OF res]"], ["proof (chain)\npicking this:\n  \\<exists>w. ss = xs @ w @ r \\<and> y = a", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>w. ss = xs @ w @ r \\<and> y = a\n\ngoal (1 subgoal):\n 1. \\<exists>w. s = (c # xs) @ w @ r \\<and> y = a", "unfolding Cons c"], ["proof (prove)\nusing this:\n  \\<exists>w. ss = xs @ w @ r \\<and> y = a\n\ngoal (1 subgoal):\n 1. \\<exists>w. d # ss = (d # xs) @ w @ r \\<and> y = a", "by auto"], ["proof (state)\nthis:\n  \\<exists>w. s = (c # xs) @ w @ r \\<and> y = a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>w. s = (c # xs) @ w @ r \\<and> y = a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>w. s = x @ w @ r \\<and> y = a\n\ngoal (1 subgoal):\n 1. \\<exists>w. s = x @ w @ r \\<and> y = x", "}"], ["proof (state)\nthis:\n  exactly_aux ?a2 ?b2 x s = Inr (y, r) \\<Longrightarrow>\n  \\<exists>w. s = x @ w @ r \\<and> y = ?a2\n\ngoal (1 subgoal):\n 1. \\<exists>w. s = x @ w @ r \\<and> y = x", "from this[OF assms [unfolded exactly_def]]"], ["proof (chain)\npicking this:\n  \\<exists>w. s = x @ w @ r \\<and> y = x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>w. s = x @ w @ r \\<and> y = x\n\ngoal (1 subgoal):\n 1. \\<exists>w. s = x @ w @ r \\<and> y = x", "."], ["proof (state)\nthis:\n  \\<exists>w. s = x @ w @ r \\<and> y = x\n\ngoal:\nNo subgoals!", "qed"], ["", "hide_const oneof_aux exactly_aux"], ["", "lemma oneof_length: \n  assumes \"oneof xs s = Inr (y, r)\"\n  shows \"length s \\<ge> length y + length r \\<and> y \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length y + length r \\<le> length s \\<and> y \\<in> set xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length y + length r \\<le> length s \\<and> y \\<in> set xs", "from oneof_result [OF assms]"], ["proof (chain)\npicking this:\n  \\<exists>w. s = y @ w @ r \\<and> y \\<in> set xs", "obtain w where \"s = y @ w @ r \\<and> y \\<in> set xs\""], ["proof (prove)\nusing this:\n  \\<exists>w. s = y @ w @ r \\<and> y \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        s = y @ w @ r \\<and> y \\<in> set xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  s = y @ w @ r \\<and> y \\<in> set xs\n\ngoal (1 subgoal):\n 1. length y + length r \\<le> length s \\<and> y \\<in> set xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  s = y @ w @ r \\<and> y \\<in> set xs\n\ngoal (1 subgoal):\n 1. length y + length r \\<le> length s \\<and> y \\<in> set xs", "by auto"], ["proof (state)\nthis:\n  length y + length r \\<le> length s \\<and> y \\<in> set xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_parser_oneof [intro]:\n  \"is_parser (oneof ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_parser (oneof ts)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       oneof ts s = Inr (x, r) \\<Longrightarrow> length r \\<le> length s", "fix s r x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       oneof ts s = Inr (x, r) \\<Longrightarrow> length r \\<le> length s", "assume \"oneof ts s = Inr (x ,r)\""], ["proof (state)\nthis:\n  oneof ts s = Inr (x, r)\n\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       oneof ts s = Inr (x, r) \\<Longrightarrow> length r \\<le> length s", "from oneof_length [OF this]"], ["proof (chain)\npicking this:\n  length x + length r \\<le> length s \\<and> x \\<in> set ts", "show \" length s \\<ge> length r\""], ["proof (prove)\nusing this:\n  length x + length r \\<le> length s \\<and> x \\<in> set ts\n\ngoal (1 subgoal):\n 1. length r \\<le> length s", "by auto"], ["proof (state)\nthis:\n  length r \\<le> length s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_cparser_oneof [intro, simp]:\n  assumes \"\\<forall>x\\<in>set ts. length x \\<ge> 1\"\n  shows \"is_cparser (oneof ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cparser (oneof ts)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       oneof ts s = Inr (x, r) \\<Longrightarrow> length r < length s", "fix s r x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       oneof ts s = Inr (x, r) \\<Longrightarrow> length r < length s", "assume \"oneof ts s = Inr (x ,r)\""], ["proof (state)\nthis:\n  oneof ts s = Inr (x, r)\n\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       oneof ts s = Inr (x, r) \\<Longrightarrow> length r < length s", "from oneof_length [OF this] assms"], ["proof (chain)\npicking this:\n  length x + length r \\<le> length s \\<and> x \\<in> set ts\n  \\<forall>x\\<in>set ts. 1 \\<le> length x", "show \" length s > length r\""], ["proof (prove)\nusing this:\n  length x + length r \\<le> length s \\<and> x \\<in> set ts\n  \\<forall>x\\<in>set ts. 1 \\<le> length x\n\ngoal (1 subgoal):\n 1. length r < length s", "by auto"], ["proof (state)\nthis:\n  length r < length s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exactly_length: \n  assumes \"exactly x s = Inr (y, r)\"\n  shows \"length s \\<ge> length x + length r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length x + length r \\<le> length s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length x + length r \\<le> length s", "from exactly_result [OF assms]"], ["proof (chain)\npicking this:\n  \\<exists>w. s = x @ w @ r \\<and> y = x", "obtain w where \"s = x @ w @ r\""], ["proof (prove)\nusing this:\n  \\<exists>w. s = x @ w @ r \\<and> y = x\n\ngoal (1 subgoal):\n 1. (\\<And>w. s = x @ w @ r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s = x @ w @ r\n\ngoal (1 subgoal):\n 1. length x + length r \\<le> length s", "thus ?thesis"], ["proof (prove)\nusing this:\n  s = x @ w @ r\n\ngoal (1 subgoal):\n 1. length x + length r \\<le> length s", "by auto"], ["proof (state)\nthis:\n  length x + length r \\<le> length s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_parser_exactly [intro]:\n  \"is_parser (exactly xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_parser (exactly xs)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       exactly xs s = Inr (x, r) \\<Longrightarrow> length r \\<le> length s", "fix s r x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       exactly xs s = Inr (x, r) \\<Longrightarrow> length r \\<le> length s", "assume \"exactly xs s = Inr (x ,r)\""], ["proof (state)\nthis:\n  exactly xs s = Inr (x, r)\n\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       exactly xs s = Inr (x, r) \\<Longrightarrow> length r \\<le> length s", "from exactly_length [OF this]"], ["proof (chain)\npicking this:\n  length xs + length r \\<le> length s", "show \"length s \\<ge> length r\""], ["proof (prove)\nusing this:\n  length xs + length r \\<le> length s\n\ngoal (1 subgoal):\n 1. length r \\<le> length s", "by auto"], ["proof (state)\nthis:\n  length r \\<le> length s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_cparser_exactly [intro]:\n  assumes \"length xs \\<ge> 1\"\n  shows \"is_cparser (exactly xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cparser (exactly xs)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       exactly xs s = Inr (x, r) \\<Longrightarrow> length r < length s", "fix s r x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       exactly xs s = Inr (x, r) \\<Longrightarrow> length r < length s", "assume \"exactly xs s = Inr (x, r)\""], ["proof (state)\nthis:\n  exactly xs s = Inr (x, r)\n\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       exactly xs s = Inr (x, r) \\<Longrightarrow> length r < length s", "from exactly_length [OF this]"], ["proof (chain)\npicking this:\n  length xs + length r \\<le> length s", "show \"length s > length r\""], ["proof (prove)\nusing this:\n  length xs + length r \\<le> length s\n\ngoal (1 subgoal):\n 1. length r < length s", "using assms"], ["proof (prove)\nusing this:\n  length xs + length r \\<le> length s\n  1 \\<le> length xs\n\ngoal (1 subgoal):\n 1. length r < length s", "by auto"], ["proof (state)\nthis:\n  length r < length s\n\ngoal:\nNo subgoals!", "qed"], ["", "fun many :: \"(char \\<Rightarrow> bool) \\<Rightarrow> (char list) parser\"\nwhere\n  \"many P (t # ts) =\n    (if P t then do {\n      (rs, ts') \\<leftarrow> many P ts;\n      Error_Monad.return (t # rs, ts')\n    } else Error_Monad.return ([], t # ts))\" |\n  \"many P [] = Error_Monad.return ([], [])\""], ["", "lemma is_parser_many [intro]:\n  \"is_parser (many P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_parser (many P)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       many P s = Inr (x, r) \\<Longrightarrow> length r \\<le> length s", "fix s r x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       many P s = Inr (x, r) \\<Longrightarrow> length r \\<le> length s", "assume \"many P s = Inr (x, r)\""], ["proof (state)\nthis:\n  many P s = Inr (x, r)\n\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       many P s = Inr (x, r) \\<Longrightarrow> length r \\<le> length s", "thus \"length r \\<le> length s\""], ["proof (prove)\nusing this:\n  many P s = Inr (x, r)\n\ngoal (1 subgoal):\n 1. length r \\<le> length s", "proof (induct s arbitrary: x r)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x r.\n       many P [] = Inr (x, r) \\<Longrightarrow> length r \\<le> length []\n 2. \\<And>a s x r.\n       \\<lbrakk>\\<And>x r.\n                   many P s = Inr (x, r) \\<Longrightarrow>\n                   length r \\<le> length s;\n        many P (a # s) = Inr (x, r)\\<rbrakk>\n       \\<Longrightarrow> length r \\<le> length (a # s)", "case (Cons t ts)"], ["proof (state)\nthis:\n  many P ts = Inr (?x, ?r) \\<Longrightarrow> length ?r \\<le> length ts\n  many P (t # ts) = Inr (x, r)\n\ngoal (2 subgoals):\n 1. \\<And>x r.\n       many P [] = Inr (x, r) \\<Longrightarrow> length r \\<le> length []\n 2. \\<And>a s x r.\n       \\<lbrakk>\\<And>x r.\n                   many P s = Inr (x, r) \\<Longrightarrow>\n                   length r \\<le> length s;\n        many P (a # s) = Inr (x, r)\\<rbrakk>\n       \\<Longrightarrow> length r \\<le> length (a # s)", "thus ?case"], ["proof (prove)\nusing this:\n  many P ts = Inr (?x, ?r) \\<Longrightarrow> length ?r \\<le> length ts\n  many P (t # ts) = Inr (x, r)\n\ngoal (1 subgoal):\n 1. length r \\<le> length (t # ts)", "by (cases \"P t\", cases \"many P ts\") force+"], ["proof (state)\nthis:\n  length r \\<le> length (t # ts)\n\ngoal (1 subgoal):\n 1. \\<And>x r.\n       many P [] = Inr (x, r) \\<Longrightarrow> length r \\<le> length []", "qed simp"], ["proof (state)\nthis:\n  length r \\<le> length s\n\ngoal:\nNo subgoals!", "qed"], ["", "definition manyof :: \"char list \\<Rightarrow> (char list) parser\"\nwhere\n  [code_unfold]: \"manyof cs = many (\\<lambda>c. c \\<in> set cs)\""], ["", "lemma is_parser_manyof [intro]:\n  \"is_parser (manyof cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_parser (manyof cs)", "unfolding manyof_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_parser (many (\\<lambda>c. c \\<in> set cs))", "by blast"], ["", "definition spaces :: \"unit parser\"\nwhere\n  [code_unfold]: \"spaces = manyof wspace \\<then> return ()\""], ["", "lemma is_parser_return [intro]:\n  \"is_parser (return x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_parser (Parser_Monad.return x)", "by (auto simp: is_parser_def return_def)"], ["", "lemma is_parser_error [intro]:\n  \"is_parser (error x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_parser (Parser_Monad.error x)", "by (auto simp: is_parser_def error_def)"], ["", "lemma is_parser_If [intro!]:\n  assumes \"is_parser p\" and \"is_parser q\"\n  shows \"is_parser (if b then p else q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_parser (if b then p else q)", "using assms"], ["proof (prove)\nusing this:\n  is_parser p\n  is_parser q\n\ngoal (1 subgoal):\n 1. is_parser (if b then p else q)", "by (cases b) auto"], ["", "lemma is_parser_Let [intro!]:\n  assumes \"is_parser (f y)\"\n  shows \"is_parser (let x = y in f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_parser (Let y f)", "using assms"], ["proof (prove)\nusing this:\n  is_parser (f y)\n\ngoal (1 subgoal):\n 1. is_parser (Let y f)", "by auto"], ["", "lemma is_parser_spaces [intro]:\n  \"is_parser spaces\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_parser spaces", "unfolding spaces_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_parser\n     (manyof [CHR '' '', CHR ''\\<newline>'', CHR 0x09, CHR 0x0D] \\<bind>\n      (\\<lambda>_. Parser_Monad.return ()))", "by blast"], ["", "fun scan_upto :: \"string \\<Rightarrow> string parser\"\nwhere\n  \"scan_upto end (t # ts) =\n    (if map snd (zip end (t # ts)) = end then do {\n       Error_Monad.return (end, List.drop (length end) (t # ts))\n    } else do {\n      (res, ts') \\<leftarrow> scan_upto end ts;\n      Error_Monad.return (t # res, ts')\n    })\" |\n  \"scan_upto end [] = Error_Monad.error (''did not find end-marker '' @ shows_quote (shows end) [])\""], ["", "lemma scan_upto_length: \n  assumes \"scan_upto end s = Inr (y, r)\"\n  shows \"length s \\<ge> length end + length r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length end + length r \\<le> length s", "using assms"], ["proof (prove)\nusing this:\n  scan_upto end s = Inr (y, r)\n\ngoal (1 subgoal):\n 1. length end + length r \\<le> length s", "proof (induct s arbitrary: y r)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y r.\n       scan_upto end [] = Inr (y, r) \\<Longrightarrow>\n       length end + length r \\<le> length []\n 2. \\<And>a s y r.\n       \\<lbrakk>\\<And>y r.\n                   scan_upto end s = Inr (y, r) \\<Longrightarrow>\n                   length end + length r \\<le> length s;\n        scan_upto end (a # s) = Inr (y, r)\\<rbrakk>\n       \\<Longrightarrow> length end + length r \\<le> length (a # s)", "case (Cons t ts)"], ["proof (state)\nthis:\n  scan_upto end ts = Inr (?y, ?r) \\<Longrightarrow>\n  length end + length ?r \\<le> length ts\n  scan_upto end (t # ts) = Inr (y, r)\n\ngoal (2 subgoals):\n 1. \\<And>y r.\n       scan_upto end [] = Inr (y, r) \\<Longrightarrow>\n       length end + length r \\<le> length []\n 2. \\<And>a s y r.\n       \\<lbrakk>\\<And>y r.\n                   scan_upto end s = Inr (y, r) \\<Longrightarrow>\n                   length end + length r \\<le> length s;\n        scan_upto end (a # s) = Inr (y, r)\\<rbrakk>\n       \\<Longrightarrow> length end + length r \\<le> length (a # s)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. length end + length r \\<le> length (t # ts)", "proof (cases \"map snd (zip end (t # ts)) = end\")"], ["proof (state)\ngoal (2 subgoals):\n 1. map snd (zip end (t # ts)) = end \\<Longrightarrow>\n    length end + length r \\<le> length (t # ts)\n 2. map snd (zip end (t # ts)) \\<noteq> end \\<Longrightarrow>\n    length end + length r \\<le> length (t # ts)", "case True"], ["proof (state)\nthis:\n  map snd (zip end (t # ts)) = end\n\ngoal (2 subgoals):\n 1. map snd (zip end (t # ts)) = end \\<Longrightarrow>\n    length end + length r \\<le> length (t # ts)\n 2. map snd (zip end (t # ts)) \\<noteq> end \\<Longrightarrow>\n    length end + length r \\<le> length (t # ts)", "then"], ["proof (chain)\npicking this:\n  map snd (zip end (t # ts)) = end", "obtain tss where tss: \"tss = t # ts\" and map: \"map snd (zip end tss) = end\""], ["proof (prove)\nusing this:\n  map snd (zip end (t # ts)) = end\n\ngoal (1 subgoal):\n 1. (\\<And>tss.\n        \\<lbrakk>tss = t # ts; map snd (zip end tss) = end\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  tss = t # ts\n  map snd (zip end tss) = end\n\ngoal (2 subgoals):\n 1. map snd (zip end (t # ts)) = end \\<Longrightarrow>\n    length end + length r \\<le> length (t # ts)\n 2. map snd (zip end (t # ts)) \\<noteq> end \\<Longrightarrow>\n    length end + length r \\<le> length (t # ts)", "from map"], ["proof (chain)\npicking this:\n  map snd (zip end tss) = end", "have len: \"length tss \\<ge> length end\""], ["proof (prove)\nusing this:\n  map snd (zip end tss) = end\n\ngoal (1 subgoal):\n 1. length end \\<le> length tss", "proof (induct \"end\" arbitrary: tss)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>tss.\n       map snd (zip [] tss) = [] \\<Longrightarrow>\n       length [] \\<le> length tss\n 2. \\<And>a end tss.\n       \\<lbrakk>\\<And>tss.\n                   map snd (zip end tss) = end \\<Longrightarrow>\n                   length end \\<le> length tss;\n        map snd (zip (a # end) tss) = a # end\\<rbrakk>\n       \\<Longrightarrow> length (a # end) \\<le> length tss", "case (Cons e en)"], ["proof (state)\nthis:\n  map snd (zip en ?tss) = en \\<Longrightarrow> length en \\<le> length ?tss\n  map snd (zip (e # en) tss) = e # en\n\ngoal (2 subgoals):\n 1. \\<And>tss.\n       map snd (zip [] tss) = [] \\<Longrightarrow>\n       length [] \\<le> length tss\n 2. \\<And>a end tss.\n       \\<lbrakk>\\<And>tss.\n                   map snd (zip end tss) = end \\<Longrightarrow>\n                   length end \\<le> length tss;\n        map snd (zip (a # end) tss) = a # end\\<rbrakk>\n       \\<Longrightarrow> length (a # end) \\<le> length tss", "thus ?case"], ["proof (prove)\nusing this:\n  map snd (zip en ?tss) = en \\<Longrightarrow> length en \\<le> length ?tss\n  map snd (zip (e # en) tss) = e # en\n\ngoal (1 subgoal):\n 1. length (e # en) \\<le> length tss", "by (cases tss, auto)"], ["proof (state)\nthis:\n  length (e # en) \\<le> length tss\n\ngoal (1 subgoal):\n 1. \\<And>tss.\n       map snd (zip [] tss) = [] \\<Longrightarrow>\n       length [] \\<le> length tss", "qed simp"], ["proof (state)\nthis:\n  length end \\<le> length tss\n\ngoal (2 subgoals):\n 1. map snd (zip end (t # ts)) = end \\<Longrightarrow>\n    length end + length r \\<le> length (t # ts)\n 2. map snd (zip end (t # ts)) \\<noteq> end \\<Longrightarrow>\n    length end + length r \\<le> length (t # ts)", "from True tss Cons(2)"], ["proof (chain)\npicking this:\n  map snd (zip end (t # ts)) = end\n  tss = t # ts\n  scan_upto end (t # ts) = Inr (y, r)", "have y: \"y = end\" and r: \"r = List.drop (length end) tss\""], ["proof (prove)\nusing this:\n  map snd (zip end (t # ts)) = end\n  tss = t # ts\n  scan_upto end (t # ts) = Inr (y, r)\n\ngoal (1 subgoal):\n 1. y = end &&& r = drop (length end) tss", "by auto"], ["proof (state)\nthis:\n  y = end\n  r = drop (length end) tss\n\ngoal (2 subgoals):\n 1. map snd (zip end (t # ts)) = end \\<Longrightarrow>\n    length end + length r \\<le> length (t # ts)\n 2. map snd (zip end (t # ts)) \\<noteq> end \\<Longrightarrow>\n    length end + length r \\<le> length (t # ts)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length end + length r \\<le> length (t # ts)", "by (simp only: tss[symmetric], simp add: y r, auto simp: len)"], ["proof (state)\nthis:\n  length end + length r \\<le> length (t # ts)\n\ngoal (1 subgoal):\n 1. map snd (zip end (t # ts)) \\<noteq> end \\<Longrightarrow>\n    length end + length r \\<le> length (t # ts)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. map snd (zip end (t # ts)) \\<noteq> end \\<Longrightarrow>\n    length end + length r \\<le> length (t # ts)", "case False"], ["proof (state)\nthis:\n  map snd (zip end (t # ts)) \\<noteq> end\n\ngoal (1 subgoal):\n 1. map snd (zip end (t # ts)) \\<noteq> end \\<Longrightarrow>\n    length end + length r \\<le> length (t # ts)", "with Cons"], ["proof (chain)\npicking this:\n  scan_upto end ts = Inr (?y, ?r) \\<Longrightarrow>\n  length end + length ?r \\<le> length ts\n  scan_upto end (t # ts) = Inr (y, r)\n  map snd (zip end (t # ts)) \\<noteq> end", "obtain res ts'\n      where \"scan_upto end ts = Inr (res,ts')\""], ["proof (prove)\nusing this:\n  scan_upto end ts = Inr (?y, ?r) \\<Longrightarrow>\n  length end + length ?r \\<le> length ts\n  scan_upto end (t # ts) = Inr (y, r)\n  map snd (zip end (t # ts)) \\<noteq> end\n\ngoal (1 subgoal):\n 1. (\\<And>res ts'.\n        scan_upto end ts = Inr (res, ts') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"scan_upto end ts\") (auto)"], ["proof (state)\nthis:\n  scan_upto end ts = Inr (res, ts')\n\ngoal (1 subgoal):\n 1. map snd (zip end (t # ts)) \\<noteq> end \\<Longrightarrow>\n    length end + length r \\<le> length (t # ts)", "from Cons(1)[OF this] Cons(2) False this"], ["proof (chain)\npicking this:\n  length end + length ts' \\<le> length ts\n  scan_upto end (t # ts) = Inr (y, r)\n  map snd (zip end (t # ts)) \\<noteq> end\n  scan_upto end ts = Inr (res, ts')", "show ?thesis"], ["proof (prove)\nusing this:\n  length end + length ts' \\<le> length ts\n  scan_upto end (t # ts) = Inr (y, r)\n  map snd (zip end (t # ts)) \\<noteq> end\n  scan_upto end ts = Inr (res, ts')\n\ngoal (1 subgoal):\n 1. length end + length r \\<le> length (t # ts)", "by auto"], ["proof (state)\nthis:\n  length end + length r \\<le> length (t # ts)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length end + length r \\<le> length (t # ts)\n\ngoal (1 subgoal):\n 1. \\<And>y r.\n       scan_upto end [] = Inr (y, r) \\<Longrightarrow>\n       length end + length r \\<le> length []", "qed simp"], ["", "lemma is_parser_scan_upto [intro]:\n  \"is_parser (scan_upto end)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_parser (scan_upto end)", "unfolding is_parser_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s r x.\n       scan_upto end s = Inr (x, r) \\<longrightarrow>\n       length r \\<le> length s", "using scan_upto_length [of \"end\"]"], ["proof (prove)\nusing this:\n  scan_upto end ?s = Inr (?y, ?r) \\<Longrightarrow>\n  length end + length ?r \\<le> length ?s\n\ngoal (1 subgoal):\n 1. \\<forall>s r x.\n       scan_upto end s = Inr (x, r) \\<longrightarrow>\n       length r \\<le> length s", "by force"], ["", "lemma is_cparser_scan_upto [intro]:\n  \"is_cparser (scan_upto (e # end))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cparser (scan_upto (e # end))", "unfolding is_cparser_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s r x.\n       scan_upto (e # end) s = Inr (x, r) \\<longrightarrow>\n       length r < length s", "using scan_upto_length [of \"e # end\"]"], ["proof (prove)\nusing this:\n  scan_upto (e # end) ?s = Inr (?y, ?r) \\<Longrightarrow>\n  length (e # end) + length ?r \\<le> length ?s\n\ngoal (1 subgoal):\n 1. \\<forall>s r x.\n       scan_upto (e # end) s = Inr (x, r) \\<longrightarrow>\n       length r < length s", "by force"], ["", "end"]]}