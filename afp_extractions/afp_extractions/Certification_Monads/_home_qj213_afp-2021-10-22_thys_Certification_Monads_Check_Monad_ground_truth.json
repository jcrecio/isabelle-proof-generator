{"file_name": "/home/qj213/afp-2021-10-22/thys/Certification_Monads/Check_Monad.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Certification_Monads", "problem_names": ["lemma isOK_check [simp]:\n  \"isOK (check b e) = b\"", "lemma isOK_check_catch [simp]:\n  \"isOK (try check b e catch f) \\<longleftrightarrow> b \\<or> isOK (f e)\"", "lemma check_return [simp]:\n  \"check_return chk res = return res' \\<longleftrightarrow> isOK chk \\<and> res' = res\"", "lemma [code_unfold]:\n  \"check_return chk res = (case chk of Inr _ \\<Rightarrow> Inr res | Inl e \\<Rightarrow> Inl e)\"", "lemma isOK_check_allm:\n  \"isOK (check_allm f xs) \\<longleftrightarrow> (\\<forall>x \\<in> set xs. isOK (f x))\"", "lemma isOK_check_all_index [simp]:\n  \"isOK (check_all_index f xs) \\<longleftrightarrow> (\\<forall>i < length xs. f (xs ! i) i)\"", "lemma foldl_error:\n  \"snd (foldl (\\<lambda>(i, m) x . (g x i, m \\<then> f x i)) (n, error e) xs) = error e\"", "lemma isOK_check_allm_gen_index [simp]:\n  assumes \"isOK (check_allm_gen_index g f n xs)\"\n  shows \"\\<forall>x\\<in>set xs. \\<exists>i. isOK (f x i)\"", "lemma check_allm_gen_index [fundef_cong]:\n  fixes f :: \"'a \\<Rightarrow> nat \\<Rightarrow> 'e check\"\n  assumes \"\\<And>x n. x \\<in> set xs \\<Longrightarrow> g x n = g' x n\"\n    and \"\\<And>x n. x \\<in> set xs \\<Longrightarrow> f x n = f' x n\"\n  shows \"check_allm_gen_index g f n xs = check_allm_gen_index g' f' n xs\"", "lemma isOK_check_subseteq [simp]:\n  \"isOK (check_subseteq xs ys) \\<longleftrightarrow> set xs \\<subseteq> set ys\"", "lemma isOK_check_same_set [simp]:\n  \"isOK (check_same_set xs ys) \\<longleftrightarrow> set xs = set ys\"", "lemma isOK_check_disjoint [simp]:\n  \"isOK (check_disjoint xs ys) \\<longleftrightarrow> set xs \\<inter> set ys = {}\"", "lemma isOK_check_all_combinations [simp]:\n  \"isOK (check_all_combinations c xs) \\<longleftrightarrow> (\\<forall>x \\<in> set xs. \\<forall>y \\<in> set xs. isOK (c x y))\"", "lemma pairwise_aux:\n  \"(\\<forall>j<length (x # xs). \\<forall>i<j. P ((x # xs) ! i) ((x # xs) ! j))\n     = ((\\<forall>j<length xs. P x (xs ! j)) \\<and> (\\<forall>j<length xs. \\<forall>i<j. P (xs ! i) (xs ! j)))\"\n  (is \"?C = (?A \\<and> ?B)\")", "lemma isOK_check_pairwise [simp]:\n  \"isOK (check_pairwise c xs) \\<longleftrightarrow> (\\<forall>j<length xs. \\<forall>i<j. isOK (c (xs ! i) (xs ! j)))\"", "lemma isOK_choice [simp]:\n  \"isOK (choice []) \\<longleftrightarrow> False\"\n  \"isOK (choice (x # xs)) \\<longleftrightarrow> isOK x \\<or> isOK (choice xs)\"", "lemma or_is_or: \"isOK (or_ok a b) = isOK a \\<or> isOK b\""], "translations": [["", "lemma isOK_check [simp]:\n  \"isOK (check b e) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK (check b e) = b", "by (simp add: check_def)"], ["", "lemma isOK_check_catch [simp]:\n  \"isOK (try check b e catch f) \\<longleftrightarrow> b \\<or> isOK (f e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK (try check b e catch f) = (b \\<or> isOK (f e))", "by (auto simp add: catch_def check_def)"], ["", "definition check_return :: \"'a check \\<Rightarrow> 'b \\<Rightarrow> 'a + 'b\"\nwhere\n  \"check_return chk res = (chk \\<then> return res)\""], ["", "lemma check_return [simp]:\n  \"check_return chk res = return res' \\<longleftrightarrow> isOK chk \\<and> res' = res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (check_return chk res = Inr res') = (isOK chk \\<and> res' = res)", "unfolding check_return_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (chk \\<bind> (\\<lambda>_. Inr res) = Inr res') =\n    (isOK chk \\<and> res' = res)", "by (cases chk) auto"], ["", "lemma [code_unfold]:\n  \"check_return chk res = (case chk of Inr _ \\<Rightarrow> Inr res | Inl e \\<Rightarrow> Inl e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_return chk res =\n    (case chk of Inl e \\<Rightarrow> Inl e | Inr x \\<Rightarrow> Inr res)", "unfolding check_return_def bind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case chk of Inl x \\<Rightarrow> Inl x\n     | Inr uu_ \\<Rightarrow> Inr res) =\n    (case chk of Inl e \\<Rightarrow> Inl e | Inr x \\<Rightarrow> Inr res)", ".."], ["", "abbreviation check_allm :: \"('a \\<Rightarrow> 'e check) \\<Rightarrow> 'a list \\<Rightarrow> 'e check\"\nwhere\n  \"check_allm f xs \\<equiv> forallM f xs <+? snd\""], ["", "abbreviation check_exm :: \"('a \\<Rightarrow> 'e check) \\<Rightarrow> 'a list \\<Rightarrow> ('e list \\<Rightarrow> 'e) \\<Rightarrow> 'e check\"\nwhere\n  \"check_exm f xs fld \\<equiv> existsM f xs <+? fld\""], ["", "lemma isOK_check_allm:\n  \"isOK (check_allm f xs) \\<longleftrightarrow> (\\<forall>x \\<in> set xs. isOK (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK (try forallM f xs catch (\\<lambda>x. Inl (snd x))) =\n    (\\<forall>x\\<in>set xs. isOK (f x))", "by simp"], ["", "abbreviation check_allm_index :: \"('a \\<Rightarrow> nat \\<Rightarrow> 'e check) \\<Rightarrow> 'a list \\<Rightarrow> 'e check\"\nwhere\n  \"check_allm_index f xs \\<equiv> forallM_index f xs <+? snd\""], ["", "abbreviation check_all :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> 'a check\"\nwhere\n  \"check_all f xs \\<equiv> check_allm (\\<lambda>x. if f x then succeed else error x) xs\""], ["", "abbreviation check_all_index :: \"('a \\<Rightarrow> nat \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> ('a \\<times> nat) check\"\nwhere\n  \"check_all_index f xs \\<equiv> check_allm_index (\\<lambda>x i. if f x i then succeed else error (x, i)) xs\""], ["", "lemma isOK_check_all_index [simp]:\n  \"isOK (check_all_index f xs) \\<longleftrightarrow> (\\<forall>i < length xs. f (xs ! i) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK\n     (try forallM_index (\\<lambda>x i. if f x i then Inr () else Inl (x, i))\n           xs\n      catch (\\<lambda>x. Inl (snd x))) =\n    (\\<forall>i<length xs. f (xs ! i) i)", "by auto"], ["", "text \\<open>The following version allows to modify the index during the check.\\<close>"], ["", "definition\n  check_allm_gen_index ::\n    \"('a \\<Rightarrow> nat \\<Rightarrow> nat) \\<Rightarrow> ('a \\<Rightarrow> nat \\<Rightarrow> 'e check) \\<Rightarrow> nat \\<Rightarrow> 'a list \\<Rightarrow> 'e check\"\nwhere\n  \"check_allm_gen_index g f n xs = snd (foldl (\\<lambda>(i, m) x. (g x i, m \\<then> f x i)) (n, succeed) xs)\""], ["", "lemma foldl_error:\n  \"snd (foldl (\\<lambda>(i, m) x . (g x i, m \\<then> f x i)) (n, error e) xs) = error e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (foldl (\\<lambda>(i, m) x. (g x i, m \\<bind> (\\<lambda>_. f x i)))\n          (n, Inl e) xs) =\n    Inl e", "by (induct xs arbitrary: n) auto"], ["", "lemma isOK_check_allm_gen_index [simp]:\n  assumes \"isOK (check_allm_gen_index g f n xs)\"\n  shows \"\\<forall>x\\<in>set xs. \\<exists>i. isOK (f x i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. \\<exists>i. isOK (f x i)", "using assms"], ["proof (prove)\nusing this:\n  isOK (check_allm_gen_index g f n xs)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. \\<exists>i. isOK (f x i)", "proof (induct xs arbitrary: n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       isOK (check_allm_gen_index g f n []) \\<Longrightarrow>\n       \\<forall>x\\<in>set []. \\<exists>i. isOK (f x i)\n 2. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   isOK (check_allm_gen_index g f n xs) \\<Longrightarrow>\n                   \\<forall>x\\<in>set xs. \\<exists>i. isOK (f x i);\n        isOK (check_allm_gen_index g f n (a # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set (a # xs).\n                            \\<exists>i. isOK (f x i)", "case (Cons x xs)"], ["proof (state)\nthis:\n  isOK (check_allm_gen_index g f ?n xs) \\<Longrightarrow>\n  \\<forall>x\\<in>set xs. \\<exists>i. isOK (f x i)\n  isOK (check_allm_gen_index g f n (x # xs))\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       isOK (check_allm_gen_index g f n []) \\<Longrightarrow>\n       \\<forall>x\\<in>set []. \\<exists>i. isOK (f x i)\n 2. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   isOK (check_allm_gen_index g f n xs) \\<Longrightarrow>\n                   \\<forall>x\\<in>set xs. \\<exists>i. isOK (f x i);\n        isOK (check_allm_gen_index g f n (a # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set (a # xs).\n                            \\<exists>i. isOK (f x i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (x # xs). \\<exists>i. isOK (f x i)", "proof (cases \"isOK (f x n)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. isOK (f x n) \\<Longrightarrow>\n    \\<forall>x\\<in>set (x # xs). \\<exists>i. isOK (f x i)\n 2. \\<not> isOK (f x n) \\<Longrightarrow>\n    \\<forall>x\\<in>set (x # xs). \\<exists>i. isOK (f x i)", "case True"], ["proof (state)\nthis:\n  isOK (f x n)\n\ngoal (2 subgoals):\n 1. isOK (f x n) \\<Longrightarrow>\n    \\<forall>x\\<in>set (x # xs). \\<exists>i. isOK (f x i)\n 2. \\<not> isOK (f x n) \\<Longrightarrow>\n    \\<forall>x\\<in>set (x # xs). \\<exists>i. isOK (f x i)", "then"], ["proof (chain)\npicking this:\n  isOK (f x n)", "have \"\\<exists>i. isOK (f x i)\""], ["proof (prove)\nusing this:\n  isOK (f x n)\n\ngoal (1 subgoal):\n 1. \\<exists>i. isOK (f x i)", "by auto"], ["proof (state)\nthis:\n  \\<exists>i. isOK (f x i)\n\ngoal (2 subgoals):\n 1. isOK (f x n) \\<Longrightarrow>\n    \\<forall>x\\<in>set (x # xs). \\<exists>i. isOK (f x i)\n 2. \\<not> isOK (f x n) \\<Longrightarrow>\n    \\<forall>x\\<in>set (x # xs). \\<exists>i. isOK (f x i)", "with True Cons"], ["proof (chain)\npicking this:\n  isOK (f x n)\n  isOK (check_allm_gen_index g f ?n xs) \\<Longrightarrow>\n  \\<forall>x\\<in>set xs. \\<exists>i. isOK (f x i)\n  isOK (check_allm_gen_index g f n (x # xs))\n  \\<exists>i. isOK (f x i)", "show ?thesis"], ["proof (prove)\nusing this:\n  isOK (f x n)\n  isOK (check_allm_gen_index g f ?n xs) \\<Longrightarrow>\n  \\<forall>x\\<in>set xs. \\<exists>i. isOK (f x i)\n  isOK (check_allm_gen_index g f n (x # xs))\n  \\<exists>i. isOK (f x i)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (x # xs). \\<exists>i. isOK (f x i)", "unfolding check_allm_gen_index_def"], ["proof (prove)\nusing this:\n  isOK (f x n)\n  isOK\n   (snd (foldl (\\<lambda>(i, m) x. (g x i, m \\<bind> (\\<lambda>_. f x i)))\n          (?n, Inr ()) xs)) \\<Longrightarrow>\n  \\<forall>x\\<in>set xs. \\<exists>i. isOK (f x i)\n  isOK\n   (snd (foldl (\\<lambda>(i, m) x. (g x i, m \\<bind> (\\<lambda>_. f x i)))\n          (n, Inr ()) (x # xs)))\n  \\<exists>i. isOK (f x i)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (x # xs). \\<exists>i. isOK (f x i)", "by (force simp: isOK_iff)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (x # xs). \\<exists>i. isOK (f x i)\n\ngoal (1 subgoal):\n 1. \\<not> isOK (f x n) \\<Longrightarrow>\n    \\<forall>x\\<in>set (x # xs). \\<exists>i. isOK (f x i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> isOK (f x n) \\<Longrightarrow>\n    \\<forall>x\\<in>set (x # xs). \\<exists>i. isOK (f x i)", "case False"], ["proof (state)\nthis:\n  \\<not> isOK (f x n)\n\ngoal (1 subgoal):\n 1. \\<not> isOK (f x n) \\<Longrightarrow>\n    \\<forall>x\\<in>set (x # xs). \\<exists>i. isOK (f x i)", "then"], ["proof (chain)\npicking this:\n  \\<not> isOK (f x n)", "obtain e where \"f x n = error e\""], ["proof (prove)\nusing this:\n  \\<not> isOK (f x n)\n\ngoal (1 subgoal):\n 1. (\\<And>e. f x n = Inl e \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"f x n\") auto"], ["proof (state)\nthis:\n  f x n = Inl e\n\ngoal (1 subgoal):\n 1. \\<not> isOK (f x n) \\<Longrightarrow>\n    \\<forall>x\\<in>set (x # xs). \\<exists>i. isOK (f x i)", "with foldl_error [of g f _ e] and Cons"], ["proof (chain)\npicking this:\n  snd (foldl (\\<lambda>(i, m) x. (g x i, m \\<bind> (\\<lambda>_. f x i)))\n        (?n, Inl e) ?xs) =\n  Inl e\n  isOK (check_allm_gen_index g f ?n xs) \\<Longrightarrow>\n  \\<forall>x\\<in>set xs. \\<exists>i. isOK (f x i)\n  isOK (check_allm_gen_index g f n (x # xs))\n  f x n = Inl e", "show ?thesis"], ["proof (prove)\nusing this:\n  snd (foldl (\\<lambda>(i, m) x. (g x i, m \\<bind> (\\<lambda>_. f x i)))\n        (?n, Inl e) ?xs) =\n  Inl e\n  isOK (check_allm_gen_index g f ?n xs) \\<Longrightarrow>\n  \\<forall>x\\<in>set xs. \\<exists>i. isOK (f x i)\n  isOK (check_allm_gen_index g f n (x # xs))\n  f x n = Inl e\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (x # xs). \\<exists>i. isOK (f x i)", "unfolding check_allm_gen_index_def"], ["proof (prove)\nusing this:\n  snd (foldl (\\<lambda>(i, m) x. (g x i, m \\<bind> (\\<lambda>_. f x i)))\n        (?n, Inl e) ?xs) =\n  Inl e\n  isOK\n   (snd (foldl (\\<lambda>(i, m) x. (g x i, m \\<bind> (\\<lambda>_. f x i)))\n          (?n, Inr ()) xs)) \\<Longrightarrow>\n  \\<forall>x\\<in>set xs. \\<exists>i. isOK (f x i)\n  isOK\n   (snd (foldl (\\<lambda>(i, m) x. (g x i, m \\<bind> (\\<lambda>_. f x i)))\n          (n, Inr ()) (x # xs)))\n  f x n = Inl e\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (x # xs). \\<exists>i. isOK (f x i)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (x # xs). \\<exists>i. isOK (f x i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (x # xs). \\<exists>i. isOK (f x i)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       isOK (check_allm_gen_index g f n []) \\<Longrightarrow>\n       \\<forall>x\\<in>set []. \\<exists>i. isOK (f x i)", "qed simp"], ["", "lemma check_allm_gen_index [fundef_cong]:\n  fixes f :: \"'a \\<Rightarrow> nat \\<Rightarrow> 'e check\"\n  assumes \"\\<And>x n. x \\<in> set xs \\<Longrightarrow> g x n = g' x n\"\n    and \"\\<And>x n. x \\<in> set xs \\<Longrightarrow> f x n = f' x n\"\n  shows \"check_allm_gen_index g f n xs = check_allm_gen_index g' f' n xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_allm_gen_index g f n xs = check_allm_gen_index g' f' n xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. check_allm_gen_index g f n xs = check_allm_gen_index g' f' n xs", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. check_allm_gen_index g f n xs = check_allm_gen_index g' f' n xs", "fix n m"], ["proof (state)\ngoal (1 subgoal):\n 1. check_allm_gen_index g f n xs = check_allm_gen_index g' f' n xs", "have \"foldl (\\<lambda>(i, m) x. (g x i, m \\<then> f x i)) (n, m) xs =\n      foldl (\\<lambda>(i, m) x. (g' x i, m \\<then> f' x i)) (n, m) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (\\<lambda>(i, m) x. (g x i, m \\<bind> (\\<lambda>_. f x i))) (n, m)\n     xs =\n    foldl (\\<lambda>(i, m) x. (g' x i, m \\<bind> (\\<lambda>_. f' x i)))\n     (n, m) xs", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> set xs \\<Longrightarrow> g ?x ?n = g' ?x ?n\n  ?x \\<in> set xs \\<Longrightarrow> f ?x ?n = f' ?x ?n\n\ngoal (1 subgoal):\n 1. foldl (\\<lambda>(i, m) x. (g x i, m \\<bind> (\\<lambda>_. f x i))) (n, m)\n     xs =\n    foldl (\\<lambda>(i, m) x. (g' x i, m \\<bind> (\\<lambda>_. f' x i)))\n     (n, m) xs", "by (induct xs arbitrary: n m) auto"], ["proof (state)\nthis:\n  foldl (\\<lambda>(i, m) x. (g x i, m \\<bind> (\\<lambda>_. f x i))) (n, m)\n   xs =\n  foldl (\\<lambda>(i, m) x. (g' x i, m \\<bind> (\\<lambda>_. f' x i))) (n, m)\n   xs\n\ngoal (1 subgoal):\n 1. check_allm_gen_index g f n xs = check_allm_gen_index g' f' n xs", "}"], ["proof (state)\nthis:\n  foldl (\\<lambda>(i, m) x. (g x i, m \\<bind> (\\<lambda>_. f x i)))\n   (?na2, ?m2) xs =\n  foldl (\\<lambda>(i, m) x. (g' x i, m \\<bind> (\\<lambda>_. f' x i)))\n   (?na2, ?m2) xs\n\ngoal (1 subgoal):\n 1. check_allm_gen_index g f n xs = check_allm_gen_index g' f' n xs", "then"], ["proof (chain)\npicking this:\n  foldl (\\<lambda>(i, m) x. (g x i, m \\<bind> (\\<lambda>_. f x i)))\n   (?na2, ?m2) xs =\n  foldl (\\<lambda>(i, m) x. (g' x i, m \\<bind> (\\<lambda>_. f' x i)))\n   (?na2, ?m2) xs", "show ?thesis"], ["proof (prove)\nusing this:\n  foldl (\\<lambda>(i, m) x. (g x i, m \\<bind> (\\<lambda>_. f x i)))\n   (?na2, ?m2) xs =\n  foldl (\\<lambda>(i, m) x. (g' x i, m \\<bind> (\\<lambda>_. f' x i)))\n   (?na2, ?m2) xs\n\ngoal (1 subgoal):\n 1. check_allm_gen_index g f n xs = check_allm_gen_index g' f' n xs", "unfolding check_allm_gen_index_def"], ["proof (prove)\nusing this:\n  foldl (\\<lambda>(i, m) x. (g x i, m \\<bind> (\\<lambda>_. f x i)))\n   (?na2, ?m2) xs =\n  foldl (\\<lambda>(i, m) x. (g' x i, m \\<bind> (\\<lambda>_. f' x i)))\n   (?na2, ?m2) xs\n\ngoal (1 subgoal):\n 1. snd (foldl (\\<lambda>(i, m) x. (g x i, m \\<bind> (\\<lambda>_. f x i)))\n          (n, Inr ()) xs) =\n    snd (foldl (\\<lambda>(i, m) x. (g' x i, m \\<bind> (\\<lambda>_. f' x i)))\n          (n, Inr ()) xs)", "by simp"], ["proof (state)\nthis:\n  check_allm_gen_index g f n xs = check_allm_gen_index g' f' n xs\n\ngoal:\nNo subgoals!", "qed"], ["", "definition check_subseteq :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a check\"\nwhere\n  \"check_subseteq xs ys = check_all (\\<lambda>x. x \\<in> set ys) xs\""], ["", "lemma isOK_check_subseteq [simp]:\n  \"isOK (check_subseteq xs ys) \\<longleftrightarrow> set xs \\<subseteq> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK (check_subseteq xs ys) = (set xs \\<subseteq> set ys)", "by (auto simp: check_subseteq_def)"], ["", "definition check_same_set :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a check\"\nwhere\n  \"check_same_set xs ys = (check_subseteq xs ys \\<then> check_subseteq ys xs)\""], ["", "lemma isOK_check_same_set [simp]:\n  \"isOK (check_same_set xs ys) \\<longleftrightarrow> set xs = set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK (check_same_set xs ys) = (set xs = set ys)", "unfolding check_same_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK (check_subseteq xs ys \\<bind> (\\<lambda>_. check_subseteq ys xs)) =\n    (set xs = set ys)", "by auto"], ["", "definition check_disjoint :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a check\"\nwhere\n  \"check_disjoint xs ys = check_all (\\<lambda>x. x \\<notin> set ys) xs\""], ["", "lemma isOK_check_disjoint [simp]:\n  \"isOK (check_disjoint xs ys) \\<longleftrightarrow> set xs \\<inter> set ys = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK (check_disjoint xs ys) = (set xs \\<inter> set ys = {})", "unfolding check_disjoint_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK\n     (try forallM (\\<lambda>x. if x \\<notin> set ys then Inr () else Inl x)\n           xs\n      catch (\\<lambda>x. Inl (snd x))) =\n    (set xs \\<inter> set ys = {})", "by (auto)"], ["", "definition check_all_combinations :: \"('a \\<Rightarrow> 'a \\<Rightarrow> 'b check) \\<Rightarrow> 'a list \\<Rightarrow> 'b check\"\nwhere\n  \"check_all_combinations c xs = check_allm (\\<lambda>x. check_allm (c x) xs) xs\""], ["", "lemma isOK_check_all_combinations [simp]:\n  \"isOK (check_all_combinations c xs) \\<longleftrightarrow> (\\<forall>x \\<in> set xs. \\<forall>y \\<in> set xs. isOK (c x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK (check_all_combinations c xs) =\n    (\\<forall>x\\<in>set xs. \\<forall>y\\<in>set xs. isOK (c x y))", "unfolding check_all_combinations_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK\n     (try forallM\n           (\\<lambda>x.\n               try forallM (c x) xs catch (\\<lambda>x. Inl (snd x)))\n           xs\n      catch (\\<lambda>x. Inl (snd x))) =\n    (\\<forall>x\\<in>set xs. \\<forall>y\\<in>set xs. isOK (c x y))", "by simp"], ["", "fun check_pairwise :: \"('a \\<Rightarrow> 'a \\<Rightarrow> 'b check) \\<Rightarrow> 'a list \\<Rightarrow> 'b check\"\nwhere\n  \"check_pairwise c [] = succeed\" |\n  \"check_pairwise c (x # xs) = (check_allm (c x) xs \\<then> check_pairwise c xs)\""], ["", "lemma pairwise_aux:\n  \"(\\<forall>j<length (x # xs). \\<forall>i<j. P ((x # xs) ! i) ((x # xs) ! j))\n     = ((\\<forall>j<length xs. P x (xs ! j)) \\<and> (\\<forall>j<length xs. \\<forall>i<j. P (xs ! i) (xs ! j)))\"\n  (is \"?C = (?A \\<and> ?B)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>j<length (x # xs).\n        \\<forall>i<j. P ((x # xs) ! i) ((x # xs) ! j)) =\n    ((\\<forall>j<length xs. P x (xs ! j)) \\<and>\n     (\\<forall>j<length xs. \\<forall>i<j. P (xs ! i) (xs ! j)))", "proof (intro iffI conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>j<length (x # xs).\n       \\<forall>i<j. P ((x # xs) ! i) ((x # xs) ! j) \\<Longrightarrow>\n    \\<forall>j<length xs. P x (xs ! j)\n 2. \\<forall>j<length (x # xs).\n       \\<forall>i<j. P ((x # xs) ! i) ((x # xs) ! j) \\<Longrightarrow>\n    \\<forall>j<length xs. \\<forall>i<j. P (xs ! i) (xs ! j)\n 3. (\\<forall>j<length xs. P x (xs ! j)) \\<and>\n    (\\<forall>j<length xs.\n        \\<forall>i<j. P (xs ! i) (xs ! j)) \\<Longrightarrow>\n    \\<forall>j<length (x # xs).\n       \\<forall>i<j. P ((x # xs) ! i) ((x # xs) ! j)", "assume *: \"?A \\<and> ?B\""], ["proof (state)\nthis:\n  (\\<forall>j<length xs. P x (xs ! j)) \\<and>\n  (\\<forall>j<length xs. \\<forall>i<j. P (xs ! i) (xs ! j))\n\ngoal (3 subgoals):\n 1. \\<forall>j<length (x # xs).\n       \\<forall>i<j. P ((x # xs) ! i) ((x # xs) ! j) \\<Longrightarrow>\n    \\<forall>j<length xs. P x (xs ! j)\n 2. \\<forall>j<length (x # xs).\n       \\<forall>i<j. P ((x # xs) ! i) ((x # xs) ! j) \\<Longrightarrow>\n    \\<forall>j<length xs. \\<forall>i<j. P (xs ! i) (xs ! j)\n 3. (\\<forall>j<length xs. P x (xs ! j)) \\<and>\n    (\\<forall>j<length xs.\n        \\<forall>i<j. P (xs ! i) (xs ! j)) \\<Longrightarrow>\n    \\<forall>j<length (x # xs).\n       \\<forall>i<j. P ((x # xs) ! i) ((x # xs) ! j)", "show \"?C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j<length (x # xs).\n       \\<forall>i<j. P ((x # xs) ! i) ((x # xs) ! j)", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j i.\n       \\<lbrakk>j < length (x # xs); i < j\\<rbrakk>\n       \\<Longrightarrow> P ((x # xs) ! i) ((x # xs) ! j)", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j i.\n       \\<lbrakk>j < length (x # xs); i < j\\<rbrakk>\n       \\<Longrightarrow> P ((x # xs) ! i) ((x # xs) ! j)", "assume \"j < length (x # xs)\" and \"i < j\""], ["proof (state)\nthis:\n  j < length (x # xs)\n  i < j\n\ngoal (1 subgoal):\n 1. \\<And>j i.\n       \\<lbrakk>j < length (x # xs); i < j\\<rbrakk>\n       \\<Longrightarrow> P ((x # xs) ! i) ((x # xs) ! j)", "then"], ["proof (chain)\npicking this:\n  j < length (x # xs)\n  i < j", "show \"P ((x # xs) ! i) ((x # xs) ! j)\""], ["proof (prove)\nusing this:\n  j < length (x # xs)\n  i < j\n\ngoal (1 subgoal):\n 1. P ((x # xs) ! i) ((x # xs) ! j)", "proof (induct j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < length (x # xs); i < 0\\<rbrakk>\n    \\<Longrightarrow> P ((x # xs) ! i) ((x # xs) ! 0)\n 2. \\<And>j.\n       \\<lbrakk>\\<lbrakk>j < length (x # xs); i < j\\<rbrakk>\n                \\<Longrightarrow> P ((x # xs) ! i) ((x # xs) ! j);\n        Suc j < length (x # xs); i < Suc j\\<rbrakk>\n       \\<Longrightarrow> P ((x # xs) ! i) ((x # xs) ! Suc j)", "case (Suc j)"], ["proof (state)\nthis:\n  \\<lbrakk>j < length (x # xs); i < j\\<rbrakk>\n  \\<Longrightarrow> P ((x # xs) ! i) ((x # xs) ! j)\n  Suc j < length (x # xs)\n  i < Suc j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < length (x # xs); i < 0\\<rbrakk>\n    \\<Longrightarrow> P ((x # xs) ! i) ((x # xs) ! 0)\n 2. \\<And>j.\n       \\<lbrakk>\\<lbrakk>j < length (x # xs); i < j\\<rbrakk>\n                \\<Longrightarrow> P ((x # xs) ! i) ((x # xs) ! j);\n        Suc j < length (x # xs); i < Suc j\\<rbrakk>\n       \\<Longrightarrow> P ((x # xs) ! i) ((x # xs) ! Suc j)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>j < length (x # xs); i < j\\<rbrakk>\n  \\<Longrightarrow> P ((x # xs) ! i) ((x # xs) ! j)\n  Suc j < length (x # xs)\n  i < Suc j", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>j < length (x # xs); i < j\\<rbrakk>\n  \\<Longrightarrow> P ((x # xs) ! i) ((x # xs) ! j)\n  Suc j < length (x # xs)\n  i < Suc j\n\ngoal (1 subgoal):\n 1. P ((x # xs) ! i) ((x # xs) ! Suc j)", "using *"], ["proof (prove)\nusing this:\n  \\<lbrakk>j < length (x # xs); i < j\\<rbrakk>\n  \\<Longrightarrow> P ((x # xs) ! i) ((x # xs) ! j)\n  Suc j < length (x # xs)\n  i < Suc j\n  (\\<forall>j<length xs. P x (xs ! j)) \\<and>\n  (\\<forall>j<length xs. \\<forall>i<j. P (xs ! i) (xs ! j))\n\ngoal (1 subgoal):\n 1. P ((x # xs) ! i) ((x # xs) ! Suc j)", "by (induct i) simp_all"], ["proof (state)\nthis:\n  P ((x # xs) ! i) ((x # xs) ! Suc j)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < length (x # xs); i < 0\\<rbrakk>\n    \\<Longrightarrow> P ((x # xs) ! i) ((x # xs) ! 0)", "qed simp"], ["proof (state)\nthis:\n  P ((x # xs) ! i) ((x # xs) ! j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>j<length (x # xs). \\<forall>i<j. P ((x # xs) ! i) ((x # xs) ! j)\n\ngoal (2 subgoals):\n 1. \\<forall>j<length (x # xs).\n       \\<forall>i<j. P ((x # xs) ! i) ((x # xs) ! j) \\<Longrightarrow>\n    \\<forall>j<length xs. P x (xs ! j)\n 2. \\<forall>j<length (x # xs).\n       \\<forall>i<j. P ((x # xs) ! i) ((x # xs) ! j) \\<Longrightarrow>\n    \\<forall>j<length xs. \\<forall>i<j. P (xs ! i) (xs ! j)", "qed force+"], ["", "lemma isOK_check_pairwise [simp]:\n  \"isOK (check_pairwise c xs) \\<longleftrightarrow> (\\<forall>j<length xs. \\<forall>i<j. isOK (c (xs ! i) (xs ! j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK (check_pairwise c xs) =\n    (\\<forall>j<length xs. \\<forall>i<j. isOK (c (xs ! i) (xs ! j)))", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. isOK (check_pairwise c []) =\n    (\\<forall>j<length []. \\<forall>i<j. isOK (c ([] ! i) ([] ! j)))\n 2. \\<And>a xs.\n       isOK (check_pairwise c xs) =\n       (\\<forall>j<length xs.\n           \\<forall>i<j. isOK (c (xs ! i) (xs ! j))) \\<Longrightarrow>\n       isOK (check_pairwise c (a # xs)) =\n       (\\<forall>j<length (a # xs).\n           \\<forall>i<j. isOK (c ((a # xs) ! i) ((a # xs) ! j)))", "case (Cons x xs)"], ["proof (state)\nthis:\n  isOK (check_pairwise c xs) =\n  (\\<forall>j<length xs. \\<forall>i<j. isOK (c (xs ! i) (xs ! j)))\n\ngoal (2 subgoals):\n 1. isOK (check_pairwise c []) =\n    (\\<forall>j<length []. \\<forall>i<j. isOK (c ([] ! i) ([] ! j)))\n 2. \\<And>a xs.\n       isOK (check_pairwise c xs) =\n       (\\<forall>j<length xs.\n           \\<forall>i<j. isOK (c (xs ! i) (xs ! j))) \\<Longrightarrow>\n       isOK (check_pairwise c (a # xs)) =\n       (\\<forall>j<length (a # xs).\n           \\<forall>i<j. isOK (c ((a # xs) ! i) ((a # xs) ! j)))", "have \"isOK (check_allm (c x) xs) = (\\<forall>j<length xs. isOK (c x (xs ! j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK (try forallM (c x) xs catch (\\<lambda>x. Inl (snd x))) =\n    (\\<forall>j<length xs. isOK (c x (xs ! j)))", "using all_set_conv_all_nth [of xs \"\\<lambda>y. isOK (c x y)\"]"], ["proof (prove)\nusing this:\n  (\\<forall>xa\\<in>set xs. isOK (c x xa)) =\n  (\\<forall>i<length xs. isOK (c x (xs ! i)))\n\ngoal (1 subgoal):\n 1. isOK (try forallM (c x) xs catch (\\<lambda>x. Inl (snd x))) =\n    (\\<forall>j<length xs. isOK (c x (xs ! j)))", "by simp"], ["proof (state)\nthis:\n  isOK (try forallM (c x) xs catch (\\<lambda>x. Inl (snd x))) =\n  (\\<forall>j<length xs. isOK (c x (xs ! j)))\n\ngoal (2 subgoals):\n 1. isOK (check_pairwise c []) =\n    (\\<forall>j<length []. \\<forall>i<j. isOK (c ([] ! i) ([] ! j)))\n 2. \\<And>a xs.\n       isOK (check_pairwise c xs) =\n       (\\<forall>j<length xs.\n           \\<forall>i<j. isOK (c (xs ! i) (xs ! j))) \\<Longrightarrow>\n       isOK (check_pairwise c (a # xs)) =\n       (\\<forall>j<length (a # xs).\n           \\<forall>i<j. isOK (c ((a # xs) ! i) ((a # xs) ! j)))", "then"], ["proof (chain)\npicking this:\n  isOK (try forallM (c x) xs catch (\\<lambda>x. Inl (snd x))) =\n  (\\<forall>j<length xs. isOK (c x (xs ! j)))", "have \"isOK (check_pairwise c (x # xs)) =\n    ((\\<forall>j<length xs. isOK (c x (xs ! j))) \\<and> (\\<forall>j<length xs. \\<forall>i<j. isOK (c (xs ! i) (xs ! j))))\""], ["proof (prove)\nusing this:\n  isOK (try forallM (c x) xs catch (\\<lambda>x. Inl (snd x))) =\n  (\\<forall>j<length xs. isOK (c x (xs ! j)))\n\ngoal (1 subgoal):\n 1. isOK (check_pairwise c (x # xs)) =\n    ((\\<forall>j<length xs. isOK (c x (xs ! j))) \\<and>\n     (\\<forall>j<length xs. \\<forall>i<j. isOK (c (xs ! i) (xs ! j))))", "by (simp add: Cons)"], ["proof (state)\nthis:\n  isOK (check_pairwise c (x # xs)) =\n  ((\\<forall>j<length xs. isOK (c x (xs ! j))) \\<and>\n   (\\<forall>j<length xs. \\<forall>i<j. isOK (c (xs ! i) (xs ! j))))\n\ngoal (2 subgoals):\n 1. isOK (check_pairwise c []) =\n    (\\<forall>j<length []. \\<forall>i<j. isOK (c ([] ! i) ([] ! j)))\n 2. \\<And>a xs.\n       isOK (check_pairwise c xs) =\n       (\\<forall>j<length xs.\n           \\<forall>i<j. isOK (c (xs ! i) (xs ! j))) \\<Longrightarrow>\n       isOK (check_pairwise c (a # xs)) =\n       (\\<forall>j<length (a # xs).\n           \\<forall>i<j. isOK (c ((a # xs) ! i) ((a # xs) ! j)))", "then"], ["proof (chain)\npicking this:\n  isOK (check_pairwise c (x # xs)) =\n  ((\\<forall>j<length xs. isOK (c x (xs ! j))) \\<and>\n   (\\<forall>j<length xs. \\<forall>i<j. isOK (c (xs ! i) (xs ! j))))", "show ?case"], ["proof (prove)\nusing this:\n  isOK (check_pairwise c (x # xs)) =\n  ((\\<forall>j<length xs. isOK (c x (xs ! j))) \\<and>\n   (\\<forall>j<length xs. \\<forall>i<j. isOK (c (xs ! i) (xs ! j))))\n\ngoal (1 subgoal):\n 1. isOK (check_pairwise c (x # xs)) =\n    (\\<forall>j<length (x # xs).\n        \\<forall>i<j. isOK (c ((x # xs) ! i) ((x # xs) ! j)))", "using pairwise_aux [of x xs \"\\<lambda>x y. isOK (c x y)\"]"], ["proof (prove)\nusing this:\n  isOK (check_pairwise c (x # xs)) =\n  ((\\<forall>j<length xs. isOK (c x (xs ! j))) \\<and>\n   (\\<forall>j<length xs. \\<forall>i<j. isOK (c (xs ! i) (xs ! j))))\n  (\\<forall>j<length (x # xs).\n      \\<forall>i<j. isOK (c ((x # xs) ! i) ((x # xs) ! j))) =\n  ((\\<forall>j<length xs. isOK (c x (xs ! j))) \\<and>\n   (\\<forall>j<length xs. \\<forall>i<j. isOK (c (xs ! i) (xs ! j))))\n\ngoal (1 subgoal):\n 1. isOK (check_pairwise c (x # xs)) =\n    (\\<forall>j<length (x # xs).\n        \\<forall>i<j. isOK (c ((x # xs) ! i) ((x # xs) ! j)))", "by simp"], ["proof (state)\nthis:\n  isOK (check_pairwise c (x # xs)) =\n  (\\<forall>j<length (x # xs).\n      \\<forall>i<j. isOK (c ((x # xs) ! i) ((x # xs) ! j)))\n\ngoal (1 subgoal):\n 1. isOK (check_pairwise c []) =\n    (\\<forall>j<length []. \\<forall>i<j. isOK (c ([] ! i) ([] ! j)))", "qed auto"], ["", "abbreviation check_exists :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> ('a list) check\"\nwhere\n  \"check_exists f xs \\<equiv> check_exm (\\<lambda>x. if f x then succeed else error [x]) xs concat\""], ["", "lemma isOK_choice [simp]:\n  \"isOK (choice []) \\<longleftrightarrow> False\"\n  \"isOK (choice (x # xs)) \\<longleftrightarrow> isOK x \\<or> isOK (choice xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK (choice []) = False &&&\n    isOK (choice (x # xs)) = (isOK x \\<or> isOK (choice xs))", "by (auto simp: choice.simps isOK_def split: sum.splits)"], ["", "fun or_ok :: \"'a check \\<Rightarrow> 'a check \\<Rightarrow> 'a check\" where\n  \"or_ok (Inl a) b = b\" |\n  \"or_ok (Inr a) b = Inr a\""], ["", "lemma or_is_or: \"isOK (or_ok a b) = isOK a \\<or> isOK b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK (or_ok a b) = isOK a \\<or> isOK b", "using or_ok.elims"], ["proof (prove)\nusing this:\n  \\<lbrakk>or_ok ?x ?xa = ?y;\n   \\<And>a b.\n      \\<lbrakk>?x = Inl a; ?xa = b; ?y = b\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>a b.\n      \\<lbrakk>?x = Inr a; ?xa = b; ?y = Inr a\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. isOK (or_ok a b) = isOK a \\<or> isOK b", "by blast"], ["", "end"]]}