{"file_name": "/home/qj213/afp-2021-10-22/thys/Certification_Monads/Error_Monad.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Certification_Monads", "problem_names": ["lemma return_bind [simp]:\n  \"(return x \\<bind> f) = f x\"", "lemma bind_return [simp]:\n  \"(m \\<bind> return) = m\"", "lemma error_bind [simp]:\n  \"(error e \\<bind> f) = error e\"", "lemma bind_assoc [simp]:\n  fixes m :: \"'a + 'b\"\n  shows \"((m \\<bind> f) \\<bind> g) = (m \\<bind> (\\<lambda>x. f x \\<bind> g))\"", "lemma bind_cong [fundef_cong]:\n  fixes m1 m2 :: \"'e + 'a\"\n    and f1 f2 :: \"'a \\<Rightarrow> 'e + 'b\"\n  assumes \"m1 = m2\"\n    and \"\\<And>y. m2 = Inr y \\<Longrightarrow> f1 y = f2 y\"\n  shows \"(m1 \\<bind> f1) = (m2 \\<bind> f2)\"", "lemma catch_splits:\n  \"P (try m catch f) \\<longleftrightarrow> (\\<forall>e. m = Inl e \\<longrightarrow> P (f e)) \\<and> (\\<forall>x. m = Inr x \\<longrightarrow> P (Inr x))\"\n  \"P (try m catch f) \\<longleftrightarrow> (\\<not> ((\\<exists>e. m = Inl e \\<and> \\<not> P (f e)) \\<or> (\\<exists>x. m = Inr x \\<and> \\<not> P (Inr x))))\"", "lemma catch_return [simp]:\n  \"(try return x catch f) = return x\"", "lemma catch_error [simp]:\n  \"(try error e catch f) = f e\"", "lemma update_error_return [simp]:\n  \"(m <+? c = return x) \\<longleftrightarrow> (m = return x)\"", "lemma isOK_E [elim]:\n  assumes \"isOK m\"\n  obtains x where \"m = return x\"", "lemma isOK_I [simp, intro]:\n  \"m = return x \\<Longrightarrow> isOK m\"", "lemma isOK_iff:\n  \"isOK m \\<longleftrightarrow> (\\<exists>x. m = return x)\"", "lemma isOK_error [simp]:\n  \"isOK (error x) = False\"", "lemma isOK_bind [simp]:\n  \"isOK (m \\<bind> f) \\<longleftrightarrow> isOK m \\<and> isOK (f (run m))\"", "lemma isOK_update_error [simp]:\n  \"isOK (m <+? f) \\<longleftrightarrow> isOK m\"", "lemma isOK_case_prod [simp]:\n  \"isOK (case lr of (l, r) \\<Rightarrow> P l r) = (case lr of (l, r) \\<Rightarrow> isOK (P l r))\"", "lemma isOK_case_option [simp]:\n  \"isOK (case x of None \\<Rightarrow> P | Some v \\<Rightarrow> Q v) = (case x of None \\<Rightarrow> isOK P | Some v \\<Rightarrow> isOK (Q v))\"", "lemma isOK_Let [simp]:\n  \"isOK (Let s f) = isOK (f s)\"", "lemma run_bind [simp]:\n  \"isOK m \\<Longrightarrow> run (m \\<bind> f) = run (f (run m))\"", "lemma run_catch [simp]:\n  \"isOK m \\<Longrightarrow> run (try m catch f) = run m\"", "lemma isOK_forallM_index_aux [simp]:\n  \"isOK (forallM_index_aux P n xs) = (\\<forall>i < length xs. isOK (P (xs ! i) (i + n)))\"", "lemma isOK_forallM_index [simp]:\n  \"isOK (forallM_index P xs) \\<longleftrightarrow> (\\<forall>i < length xs. isOK (P (xs ! i) i))\"", "lemma forallM_index [fundef_cong]:\n  fixes c :: \"'a \\<Rightarrow> nat \\<Rightarrow> 'e + unit\"\n  assumes \"\\<And>x i. x \\<in> set xs \\<Longrightarrow> c x i = d x i\"\n  shows \"forallM_index c xs = forallM_index d xs\"", "lemma isOK_forallM [simp]:\n  \"isOK (forallM f xs) \\<longleftrightarrow> (\\<forall>x \\<in> set xs. isOK (f x))\"", "lemma isOK_existsM [simp]:\n  \"isOK (existsM f xs) \\<longleftrightarrow> (\\<exists>x\\<in>set xs. isOK (f x))\"", "lemma is_OK_if_return [simp]:\n  \"isOK (if b then return x else m) \\<longleftrightarrow> b \\<or> isOK m\"\n  \"isOK (if b then m else return x) \\<longleftrightarrow> \\<not> b \\<or> isOK m\"", "lemma isOK_if_error [simp]:\n  \"isOK (if b then error e else m) \\<longleftrightarrow> \\<not> b \\<and> isOK m\"\n  \"isOK (if b then m else error e) \\<longleftrightarrow> b \\<and> isOK m\"", "lemma isOK_if:\n  \"isOK (if b then x else y) \\<longleftrightarrow> b \\<and> isOK x \\<or> \\<not> b \\<and> isOK y\"", "lemma mapM_error:\n  \"(\\<exists>e. mapM f xs = error e) \\<longleftrightarrow> (\\<exists>x\\<in>set xs. \\<exists>e. f x = error e)\"", "lemma mapM_return:\n  assumes \"mapM f xs = return ys\"\n  shows \"ys = map (run \\<circ> f) xs \\<and> (\\<forall>x\\<in>set xs. \\<forall>e. f x \\<noteq> error e)\"", "lemma mapM_return_idx:\n  assumes *: \"mapM f xs = Inr ys\" and \"i < length xs\" \n  shows \"\\<exists>y. f (xs ! i) = Inr y \\<and> ys ! i = y\"", "lemma mapM_cong [fundef_cong]:\n  assumes \"xs = ys\" and \"\\<And>x. x \\<in> set ys \\<Longrightarrow> f x = g x\"\n  shows \"mapM f xs = mapM g ys\"", "lemma bindE [elim]:\n  assumes \"(p \\<bind> f) = return x\"\n  obtains y where \"p = return y\" and \"f y = return x\"", "lemma then_return_eq [simp]:\n  \"(p \\<then> q) = return f \\<longleftrightarrow> isOK p \\<and> q = return f\"", "lemma isOK_mapM:\n  assumes \"isOK (mapM f xs)\"\n  shows \"(\\<forall>x. x \\<in> set xs \\<longrightarrow> isOK (f x)) \\<and> run (mapM f xs) = map (\\<lambda>x. run (f x)) xs\"", "lemma firstM:\n  \"isOK (firstM f xs) \\<longleftrightarrow> (\\<exists>x\\<in>set xs. isOK (f x))\"", "lemma firstM_return:\n  assumes \"firstM f xs = return y\"\n  shows \"isOK (f y) \\<and> y \\<in> set xs\""], "translations": [["", "lemma return_bind [simp]:\n  \"(return x \\<bind> f) = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inr x \\<bind> f = f x", "by (simp add: bind_def)"], ["", "lemma bind_return [simp]:\n  \"(m \\<bind> return) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> Inr = m", "by (cases m) (simp_all add: bind_def)"], ["", "lemma error_bind [simp]:\n  \"(error e \\<bind> f) = error e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inl e \\<bind> f = Inl e", "by (simp add: bind_def)"], ["", "lemma bind_assoc [simp]:\n  fixes m :: \"'a + 'b\"\n  shows \"((m \\<bind> f) \\<bind> g) = (m \\<bind> (\\<lambda>x. f x \\<bind> g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> f \\<bind> g = m \\<bind> (\\<lambda>x. f x \\<bind> g)", "by (cases m) (simp_all add: bind_def)"], ["", "lemma bind_cong [fundef_cong]:\n  fixes m1 m2 :: \"'e + 'a\"\n    and f1 f2 :: \"'a \\<Rightarrow> 'e + 'b\"\n  assumes \"m1 = m2\"\n    and \"\\<And>y. m2 = Inr y \\<Longrightarrow> f1 y = f2 y\"\n  shows \"(m1 \\<bind> f1) = (m2 \\<bind> f2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 \\<bind> f1 = m2 \\<bind> f2", "using assms"], ["proof (prove)\nusing this:\n  m1 = m2\n  m2 = Inr ?y \\<Longrightarrow> f1 ?y = f2 ?y\n\ngoal (1 subgoal):\n 1. m1 \\<bind> f1 = m2 \\<bind> f2", "by (cases \"m1\") (auto simp: bind_def)"], ["", "definition catch_error :: \"'e + 'a \\<Rightarrow> ('e \\<Rightarrow> 'f + 'a) \\<Rightarrow> 'f + 'a\"\nwhere\n  catch_def: \"catch_error m f = (case m of Inl e \\<Rightarrow> f e | Inr x \\<Rightarrow> Inr x)\""], ["", "adhoc_overloading\n  Error_Syntax.catch catch_error"], ["", "lemma catch_splits:\n  \"P (try m catch f) \\<longleftrightarrow> (\\<forall>e. m = Inl e \\<longrightarrow> P (f e)) \\<and> (\\<forall>x. m = Inr x \\<longrightarrow> P (Inr x))\"\n  \"P (try m catch f) \\<longleftrightarrow> (\\<not> ((\\<exists>e. m = Inl e \\<and> \\<not> P (f e)) \\<or> (\\<exists>x. m = Inr x \\<and> \\<not> P (Inr x))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (try m catch f) =\n    ((\\<forall>e. m = Inl e \\<longrightarrow> P (f e)) \\<and>\n     (\\<forall>x. m = Inr x \\<longrightarrow> P (Inr x))) &&&\n    P (try m catch f) =\n    (\\<not> ((\\<exists>e. m = Inl e \\<and> \\<not> P (f e)) \\<or>\n             (\\<exists>x. m = Inr x \\<and> \\<not> P (Inr x))))", "by (case_tac [!] m) (simp_all add: catch_def)"], ["", "abbreviation update_error :: \"'e + 'a \\<Rightarrow> ('e \\<Rightarrow> 'f) \\<Rightarrow> 'f + 'a\"\nwhere\n  \"update_error m f \\<equiv> try m catch (\\<lambda>x. error (f x))\""], ["", "adhoc_overloading\n  Error_Syntax.update_error update_error"], ["", "lemma catch_return [simp]:\n  \"(try return x catch f) = return x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (try Inr x catch f) = Inr x", "by (simp add: catch_def)"], ["", "lemma catch_error [simp]:\n  \"(try error e catch f) = f e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (try Inl e catch f) = f e", "by (simp add: catch_def)"], ["", "lemma update_error_return [simp]:\n  \"(m <+? c = return x) \\<longleftrightarrow> (m = return x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((try m catch (\\<lambda>x. Inl (c x))) = Inr x) = (m = Inr x)", "by (cases m) simp_all"], ["", "definition \"isOK m \\<longleftrightarrow> (case m of Inl e \\<Rightarrow> False | Inr x \\<Rightarrow> True)\""], ["", "lemma isOK_E [elim]:\n  assumes \"isOK m\"\n  obtains x where \"m = return x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. m = Inr x \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  isOK m\n\ngoal (1 subgoal):\n 1. (\\<And>x. m = Inr x \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases m) (simp_all add: isOK_def)"], ["", "lemma isOK_I [simp, intro]:\n  \"m = return x \\<Longrightarrow> isOK m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = Inr x \\<Longrightarrow> isOK m", "by (cases m) (simp_all add: isOK_def)"], ["", "lemma isOK_iff:\n  \"isOK m \\<longleftrightarrow> (\\<exists>x. m = return x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK m = (\\<exists>x. m = Inr x)", "by blast"], ["", "lemma isOK_error [simp]:\n  \"isOK (error x) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK (Inl x) = False", "by blast"], ["", "lemma isOK_bind [simp]:\n  \"isOK (m \\<bind> f) \\<longleftrightarrow> isOK m \\<and> isOK (f (run m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK (m \\<bind> f) = (isOK m \\<and> isOK (f (projr m)))", "by (cases m) simp_all"], ["", "lemma isOK_update_error [simp]:\n  \"isOK (m <+? f) \\<longleftrightarrow> isOK m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK (try m catch (\\<lambda>x. Inl (f x))) = isOK m", "by (cases m) simp_all"], ["", "lemma isOK_case_prod [simp]:\n  \"isOK (case lr of (l, r) \\<Rightarrow> P l r) = (case lr of (l, r) \\<Rightarrow> isOK (P l r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK (case lr of (l, r) \\<Rightarrow> P l r) =\n    (case lr of (l, r) \\<Rightarrow> isOK (P l r))", "by (rule prod.case_distrib)"], ["", "lemma isOK_case_option [simp]:\n  \"isOK (case x of None \\<Rightarrow> P | Some v \\<Rightarrow> Q v) = (case x of None \\<Rightarrow> isOK P | Some v \\<Rightarrow> isOK (Q v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK (case x of None \\<Rightarrow> P | Some v \\<Rightarrow> Q v) =\n    (case x of None \\<Rightarrow> isOK P | Some v \\<Rightarrow> isOK (Q v))", "by (cases x) (auto)"], ["", "lemma isOK_Let [simp]:\n  \"isOK (Let s f) = isOK (f s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK (Let s f) = isOK (f s)", "by (simp add: Let_def)"], ["", "lemma run_bind [simp]:\n  \"isOK m \\<Longrightarrow> run (m \\<bind> f) = run (f (run m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK m \\<Longrightarrow> projr (m \\<bind> f) = projr (f (projr m))", "by auto"], ["", "lemma run_catch [simp]:\n  \"isOK m \\<Longrightarrow> run (try m catch f) = run m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK m \\<Longrightarrow> projr (try m catch f) = projr m", "by auto"], ["", "fun foldM :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'e + 'a) \\<Rightarrow> 'a \\<Rightarrow> 'b list \\<Rightarrow> 'e + 'a\"\nwhere \n  \"foldM f d [] = return d\" |\n  \"foldM f d (x # xs) = do { y \\<leftarrow> f d x; foldM f y xs }\""], ["", "fun forallM_index_aux :: \"('a \\<Rightarrow> nat \\<Rightarrow> 'e + unit) \\<Rightarrow> nat \\<Rightarrow> 'a list \\<Rightarrow> (('a \\<times> nat) \\<times> 'e) + unit\"\nwhere\n  \"forallM_index_aux P i [] = return ()\" |\n  \"forallM_index_aux P i (x # xs) = do {\n    P x i <+? Pair (x, i);\n    forallM_index_aux P (Suc i) xs\n  }\""], ["", "lemma isOK_forallM_index_aux [simp]:\n  \"isOK (forallM_index_aux P n xs) = (\\<forall>i < length xs. isOK (P (xs ! i) (i + n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK (forallM_index_aux P n xs) =\n    (\\<forall>i<length xs. isOK (P (xs ! i) (i + n)))", "proof (induct xs arbitrary: n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       isOK (forallM_index_aux P n []) =\n       (\\<forall>i<length []. isOK (P ([] ! i) (i + n)))\n 2. \\<And>a xs n.\n       (\\<And>n.\n           isOK (forallM_index_aux P n xs) =\n           (\\<forall>i<length xs.\n               isOK (P (xs ! i) (i + n)))) \\<Longrightarrow>\n       isOK (forallM_index_aux P n (a # xs)) =\n       (\\<forall>i<length (a # xs). isOK (P ((a # xs) ! i) (i + n)))", "case (Cons x xs)"], ["proof (state)\nthis:\n  isOK (forallM_index_aux P ?n xs) =\n  (\\<forall>i<length xs. isOK (P (xs ! i) (i + ?n)))\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       isOK (forallM_index_aux P n []) =\n       (\\<forall>i<length []. isOK (P ([] ! i) (i + n)))\n 2. \\<And>a xs n.\n       (\\<And>n.\n           isOK (forallM_index_aux P n xs) =\n           (\\<forall>i<length xs.\n               isOK (P (xs ! i) (i + n)))) \\<Longrightarrow>\n       isOK (forallM_index_aux P n (a # xs)) =\n       (\\<forall>i<length (a # xs). isOK (P ((a # xs) ! i) (i + n)))", "have \"(\\<forall>i < length (x # xs). isOK (P ((x # xs) ! i) (i + n))) \\<longleftrightarrow>\n    (isOK (P x n) \\<and> (\\<forall>i < length xs. isOK (P (xs ! i) (i + Suc n))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i<length (x # xs). isOK (P ((x # xs) ! i) (i + n))) =\n    (isOK (P x n) \\<and>\n     (\\<forall>i<length xs. isOK (P (xs ! i) (i + Suc n))))", "by (auto, case_tac i) (simp_all)"], ["proof (state)\nthis:\n  (\\<forall>i<length (x # xs). isOK (P ((x # xs) ! i) (i + n))) =\n  (isOK (P x n) \\<and>\n   (\\<forall>i<length xs. isOK (P (xs ! i) (i + Suc n))))\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       isOK (forallM_index_aux P n []) =\n       (\\<forall>i<length []. isOK (P ([] ! i) (i + n)))\n 2. \\<And>a xs n.\n       (\\<And>n.\n           isOK (forallM_index_aux P n xs) =\n           (\\<forall>i<length xs.\n               isOK (P (xs ! i) (i + n)))) \\<Longrightarrow>\n       isOK (forallM_index_aux P n (a # xs)) =\n       (\\<forall>i<length (a # xs). isOK (P ((a # xs) ! i) (i + n)))", "then"], ["proof (chain)\npicking this:\n  (\\<forall>i<length (x # xs). isOK (P ((x # xs) ! i) (i + n))) =\n  (isOK (P x n) \\<and>\n   (\\<forall>i<length xs. isOK (P (xs ! i) (i + Suc n))))", "show ?case"], ["proof (prove)\nusing this:\n  (\\<forall>i<length (x # xs). isOK (P ((x # xs) ! i) (i + n))) =\n  (isOK (P x n) \\<and>\n   (\\<forall>i<length xs. isOK (P (xs ! i) (i + Suc n))))\n\ngoal (1 subgoal):\n 1. isOK (forallM_index_aux P n (x # xs)) =\n    (\\<forall>i<length (x # xs). isOK (P ((x # xs) ! i) (i + n)))", "unfolding Cons [of \"Suc n\", symmetric]"], ["proof (prove)\nusing this:\n  (\\<forall>i<length (x # xs). isOK (P ((x # xs) ! i) (i + n))) =\n  (isOK (P x n) \\<and> isOK (forallM_index_aux P (Suc n) xs))\n\ngoal (1 subgoal):\n 1. isOK (forallM_index_aux P n (x # xs)) =\n    (\\<forall>i<length (x # xs). isOK (P ((x # xs) ! i) (i + n)))", "by simp"], ["proof (state)\nthis:\n  isOK (forallM_index_aux P n (x # xs)) =\n  (\\<forall>i<length (x # xs). isOK (P ((x # xs) ! i) (i + n)))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       isOK (forallM_index_aux P n []) =\n       (\\<forall>i<length []. isOK (P ([] ! i) (i + n)))", "qed auto"], ["", "definition forallM_index :: \"('a \\<Rightarrow> nat \\<Rightarrow> 'e + unit) \\<Rightarrow> 'a list \\<Rightarrow> (('a \\<times> nat) \\<times> 'e) + unit\"\nwhere\n  \"forallM_index P xs = forallM_index_aux P 0 xs\""], ["", "lemma isOK_forallM_index [simp]:\n  \"isOK (forallM_index P xs) \\<longleftrightarrow> (\\<forall>i < length xs. isOK (P (xs ! i) i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK (forallM_index P xs) = (\\<forall>i<length xs. isOK (P (xs ! i) i))", "unfolding forallM_index_def isOK_forallM_index_aux"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i<length xs. isOK (P (xs ! i) (i + 0))) =\n    (\\<forall>i<length xs. isOK (P (xs ! i) i))", "by simp"], ["", "lemma forallM_index [fundef_cong]:\n  fixes c :: \"'a \\<Rightarrow> nat \\<Rightarrow> 'e + unit\"\n  assumes \"\\<And>x i. x \\<in> set xs \\<Longrightarrow> c x i = d x i\"\n  shows \"forallM_index c xs = forallM_index d xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. forallM_index c xs = forallM_index d xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. forallM_index c xs = forallM_index d xs", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. forallM_index c xs = forallM_index d xs", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. forallM_index c xs = forallM_index d xs", "have \"forallM_index_aux c n xs = forallM_index_aux d n xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. forallM_index_aux c n xs = forallM_index_aux d n xs", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> set xs \\<Longrightarrow> c ?x ?i = d ?x ?i\n\ngoal (1 subgoal):\n 1. forallM_index_aux c n xs = forallM_index_aux d n xs", "by (induct xs arbitrary: n) simp_all"], ["proof (state)\nthis:\n  forallM_index_aux c n xs = forallM_index_aux d n xs\n\ngoal (1 subgoal):\n 1. forallM_index c xs = forallM_index d xs", "}"], ["proof (state)\nthis:\n  forallM_index_aux c ?n2 xs = forallM_index_aux d ?n2 xs\n\ngoal (1 subgoal):\n 1. forallM_index c xs = forallM_index d xs", "then"], ["proof (chain)\npicking this:\n  forallM_index_aux c ?n2 xs = forallM_index_aux d ?n2 xs", "show ?thesis"], ["proof (prove)\nusing this:\n  forallM_index_aux c ?n2 xs = forallM_index_aux d ?n2 xs\n\ngoal (1 subgoal):\n 1. forallM_index c xs = forallM_index d xs", "by (simp add: forallM_index_def)"], ["proof (state)\nthis:\n  forallM_index c xs = forallM_index d xs\n\ngoal:\nNo subgoals!", "qed"], ["", "hide_const forallM_index_aux"], ["", "text \\<open>\n  Check whether @{term f} succeeds for all elements of a given list. In case it doesn't,\n  return the first offending element together with the produced error.\n\\<close>"], ["", "fun forallM :: \"('a \\<Rightarrow> 'e + unit) \\<Rightarrow> 'a list \\<Rightarrow> ('a * 'e) + unit\"\nwhere\n  \"forallM f [] = return ()\" |\n  \"forallM f (x # xs) = f x <+? Pair x \\<then> forallM f xs\""], ["", "lemma isOK_forallM [simp]:\n  \"isOK (forallM f xs) \\<longleftrightarrow> (\\<forall>x \\<in> set xs. isOK (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK (forallM f xs) = (\\<forall>x\\<in>set xs. isOK (f x))", "by (induct xs) (simp_all)"], ["", "text \\<open>\n  Check whether @{term f} succeeds for at least one element of a given list.\n  In case it doesn't, return the list of produced errors.\n\\<close>"], ["", "fun existsM :: \"('a \\<Rightarrow> 'e + unit) \\<Rightarrow> 'a list \\<Rightarrow> 'e list + unit\"\nwhere\n  \"existsM f [] = error []\" |\n  \"existsM f (x # xs) = (try f x catch (\\<lambda>e. existsM f xs <+? Cons e))\""], ["", "lemma isOK_existsM [simp]:\n  \"isOK (existsM f xs) \\<longleftrightarrow> (\\<exists>x\\<in>set xs. isOK (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK (existsM f xs) = (\\<exists>x\\<in>set xs. isOK (f x))", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. isOK (existsM f []) = (\\<exists>x\\<in>set []. isOK (f x))\n 2. \\<And>a xs.\n       isOK (existsM f xs) =\n       (\\<exists>x\\<in>set xs. isOK (f x)) \\<Longrightarrow>\n       isOK (existsM f (a # xs)) = (\\<exists>x\\<in>set (a # xs). isOK (f x))", "case (Cons x xs)"], ["proof (state)\nthis:\n  isOK (existsM f xs) = (\\<exists>x\\<in>set xs. isOK (f x))\n\ngoal (2 subgoals):\n 1. isOK (existsM f []) = (\\<exists>x\\<in>set []. isOK (f x))\n 2. \\<And>a xs.\n       isOK (existsM f xs) =\n       (\\<exists>x\\<in>set xs. isOK (f x)) \\<Longrightarrow>\n       isOK (existsM f (a # xs)) = (\\<exists>x\\<in>set (a # xs). isOK (f x))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK (existsM f (x # xs)) = (\\<exists>x\\<in>set (x # xs). isOK (f x))", "proof (cases \"f x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       f x = Inl a \\<Longrightarrow>\n       isOK (existsM f (x # xs)) = (\\<exists>x\\<in>set (x # xs). isOK (f x))\n 2. \\<And>b.\n       f x = Inr b \\<Longrightarrow>\n       isOK (existsM f (x # xs)) = (\\<exists>x\\<in>set (x # xs). isOK (f x))", "case (Inl e)"], ["proof (state)\nthis:\n  f x = Inl e\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       f x = Inl a \\<Longrightarrow>\n       isOK (existsM f (x # xs)) = (\\<exists>x\\<in>set (x # xs). isOK (f x))\n 2. \\<And>b.\n       f x = Inr b \\<Longrightarrow>\n       isOK (existsM f (x # xs)) = (\\<exists>x\\<in>set (x # xs). isOK (f x))", "with Cons"], ["proof (chain)\npicking this:\n  isOK (existsM f xs) = (\\<exists>x\\<in>set xs. isOK (f x))\n  f x = Inl e", "show ?thesis"], ["proof (prove)\nusing this:\n  isOK (existsM f xs) = (\\<exists>x\\<in>set xs. isOK (f x))\n  f x = Inl e\n\ngoal (1 subgoal):\n 1. isOK (existsM f (x # xs)) = (\\<exists>x\\<in>set (x # xs). isOK (f x))", "by simp"], ["proof (state)\nthis:\n  isOK (existsM f (x # xs)) = (\\<exists>x\\<in>set (x # xs). isOK (f x))\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       f x = Inr b \\<Longrightarrow>\n       isOK (existsM f (x # xs)) = (\\<exists>x\\<in>set (x # xs). isOK (f x))", "qed (auto simp add: catch_def)"], ["proof (state)\nthis:\n  isOK (existsM f (x # xs)) = (\\<exists>x\\<in>set (x # xs). isOK (f x))\n\ngoal (1 subgoal):\n 1. isOK (existsM f []) = (\\<exists>x\\<in>set []. isOK (f x))", "qed simp"], ["", "lemma is_OK_if_return [simp]:\n  \"isOK (if b then return x else m) \\<longleftrightarrow> b \\<or> isOK m\"\n  \"isOK (if b then m else return x) \\<longleftrightarrow> \\<not> b \\<or> isOK m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK (if b then Inr x else m) = (b \\<or> isOK m) &&&\n    isOK (if b then m else Inr x) = (\\<not> b \\<or> isOK m)", "by simp_all"], ["", "lemma isOK_if_error [simp]:\n  \"isOK (if b then error e else m) \\<longleftrightarrow> \\<not> b \\<and> isOK m\"\n  \"isOK (if b then m else error e) \\<longleftrightarrow> b \\<and> isOK m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK (if b then Inl e else m) = (\\<not> b \\<and> isOK m) &&&\n    isOK (if b then m else Inl e) = (b \\<and> isOK m)", "by simp_all"], ["", "lemma isOK_if:\n  \"isOK (if b then x else y) \\<longleftrightarrow> b \\<and> isOK x \\<or> \\<not> b \\<and> isOK y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK (if b then x else y) =\n    (b \\<and> isOK x \\<or> \\<not> b \\<and> isOK y)", "by simp"], ["", "fun sequence :: \"('e + 'a) list \\<Rightarrow> 'e + 'a list\"\nwhere\n  \"sequence [] = Inr []\" |\n  \"sequence (m # ms) = do {\n    x \\<leftarrow> m;\n    xs \\<leftarrow> sequence ms;\n    return (x # xs)\n  }\""], ["", "subsection \\<open>Monadic Map for Error Monad\\<close>"], ["", "fun mapM :: \"('a \\<Rightarrow> 'e + 'b) \\<Rightarrow> 'a list \\<Rightarrow> 'e + 'b list\"\nwhere\n  \"mapM f [] = return []\" |\n  \"mapM f (x#xs) = do {\n    y \\<leftarrow> f x;\n    ys \\<leftarrow> mapM f xs;\n    Inr (y # ys)\n  }\""], ["", "lemma mapM_error:\n  \"(\\<exists>e. mapM f xs = error e) \\<longleftrightarrow> (\\<exists>x\\<in>set xs. \\<exists>e. f x = error e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>e. mapM f xs = Inl e) =\n    (\\<exists>x\\<in>set xs. \\<exists>e. f x = Inl e)", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<exists>e. mapM f [] = Inl e) =\n    (\\<exists>x\\<in>set []. \\<exists>e. f x = Inl e)\n 2. \\<And>a xs.\n       (\\<exists>e. mapM f xs = Inl e) =\n       (\\<exists>x\\<in>set xs. \\<exists>e. f x = Inl e) \\<Longrightarrow>\n       (\\<exists>e. mapM f (a # xs) = Inl e) =\n       (\\<exists>x\\<in>set (a # xs). \\<exists>e. f x = Inl e)", "case (Cons x xs)"], ["proof (state)\nthis:\n  (\\<exists>e. mapM f xs = Inl e) =\n  (\\<exists>x\\<in>set xs. \\<exists>e. f x = Inl e)\n\ngoal (2 subgoals):\n 1. (\\<exists>e. mapM f [] = Inl e) =\n    (\\<exists>x\\<in>set []. \\<exists>e. f x = Inl e)\n 2. \\<And>a xs.\n       (\\<exists>e. mapM f xs = Inl e) =\n       (\\<exists>x\\<in>set xs. \\<exists>e. f x = Inl e) \\<Longrightarrow>\n       (\\<exists>e. mapM f (a # xs) = Inl e) =\n       (\\<exists>x\\<in>set (a # xs). \\<exists>e. f x = Inl e)", "then"], ["proof (chain)\npicking this:\n  (\\<exists>e. mapM f xs = Inl e) =\n  (\\<exists>x\\<in>set xs. \\<exists>e. f x = Inl e)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<exists>e. mapM f xs = Inl e) =\n  (\\<exists>x\\<in>set xs. \\<exists>e. f x = Inl e)\n\ngoal (1 subgoal):\n 1. (\\<exists>e. mapM f (x # xs) = Inl e) =\n    (\\<exists>x\\<in>set (x # xs). \\<exists>e. f x = Inl e)", "by (cases \"f x\", simp_all, cases \"mapM f xs\", simp_all)"], ["proof (state)\nthis:\n  (\\<exists>e. mapM f (x # xs) = Inl e) =\n  (\\<exists>x\\<in>set (x # xs). \\<exists>e. f x = Inl e)\n\ngoal (1 subgoal):\n 1. (\\<exists>e. mapM f [] = Inl e) =\n    (\\<exists>x\\<in>set []. \\<exists>e. f x = Inl e)", "qed simp"], ["", "lemma mapM_return:\n  assumes \"mapM f xs = return ys\"\n  shows \"ys = map (run \\<circ> f) xs \\<and> (\\<forall>x\\<in>set xs. \\<forall>e. f x \\<noteq> error e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys = map (projr \\<circ> f) xs \\<and>\n    (\\<forall>x\\<in>set xs. \\<forall>e. f x \\<noteq> Inl e)", "using assms"], ["proof (prove)\nusing this:\n  mapM f xs = Inr ys\n\ngoal (1 subgoal):\n 1. ys = map (projr \\<circ> f) xs \\<and>\n    (\\<forall>x\\<in>set xs. \\<forall>e. f x \\<noteq> Inl e)", "proof (induct xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       mapM f [] = Inr ys \\<Longrightarrow>\n       ys = map (projr \\<circ> f) [] \\<and>\n       (\\<forall>x\\<in>set []. \\<forall>e. f x \\<noteq> Inl e)\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   mapM f xs = Inr ys \\<Longrightarrow>\n                   ys = map (projr \\<circ> f) xs \\<and>\n                   (\\<forall>x\\<in>set xs. \\<forall>e. f x \\<noteq> Inl e);\n        mapM f (a # xs) = Inr ys\\<rbrakk>\n       \\<Longrightarrow> ys = map (projr \\<circ> f) (a # xs) \\<and>\n                         (\\<forall>x\\<in>set (a # xs).\n                             \\<forall>e. f x \\<noteq> Inl e)", "case (Cons x xs ys)"], ["proof (state)\nthis:\n  mapM f xs = Inr ?ys \\<Longrightarrow>\n  ?ys = map (projr \\<circ> f) xs \\<and>\n  (\\<forall>x\\<in>set xs. \\<forall>e. f x \\<noteq> Inl e)\n  mapM f (x # xs) = Inr ys\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       mapM f [] = Inr ys \\<Longrightarrow>\n       ys = map (projr \\<circ> f) [] \\<and>\n       (\\<forall>x\\<in>set []. \\<forall>e. f x \\<noteq> Inl e)\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   mapM f xs = Inr ys \\<Longrightarrow>\n                   ys = map (projr \\<circ> f) xs \\<and>\n                   (\\<forall>x\\<in>set xs. \\<forall>e. f x \\<noteq> Inl e);\n        mapM f (a # xs) = Inr ys\\<rbrakk>\n       \\<Longrightarrow> ys = map (projr \\<circ> f) (a # xs) \\<and>\n                         (\\<forall>x\\<in>set (a # xs).\n                             \\<forall>e. f x \\<noteq> Inl e)", "then"], ["proof (chain)\npicking this:\n  mapM f xs = Inr ?ys \\<Longrightarrow>\n  ?ys = map (projr \\<circ> f) xs \\<and>\n  (\\<forall>x\\<in>set xs. \\<forall>e. f x \\<noteq> Inl e)\n  mapM f (x # xs) = Inr ys", "show ?case"], ["proof (prove)\nusing this:\n  mapM f xs = Inr ?ys \\<Longrightarrow>\n  ?ys = map (projr \\<circ> f) xs \\<and>\n  (\\<forall>x\\<in>set xs. \\<forall>e. f x \\<noteq> Inl e)\n  mapM f (x # xs) = Inr ys\n\ngoal (1 subgoal):\n 1. ys = map (projr \\<circ> f) (x # xs) \\<and>\n    (\\<forall>x\\<in>set (x # xs). \\<forall>e. f x \\<noteq> Inl e)", "by (cases \"f x\", simp, cases \"mapM f xs\", simp_all)"], ["proof (state)\nthis:\n  ys = map (projr \\<circ> f) (x # xs) \\<and>\n  (\\<forall>x\\<in>set (x # xs). \\<forall>e. f x \\<noteq> Inl e)\n\ngoal (1 subgoal):\n 1. \\<And>ys.\n       mapM f [] = Inr ys \\<Longrightarrow>\n       ys = map (projr \\<circ> f) [] \\<and>\n       (\\<forall>x\\<in>set []. \\<forall>e. f x \\<noteq> Inl e)", "qed simp"], ["", "lemma mapM_return_idx:\n  assumes *: \"mapM f xs = Inr ys\" and \"i < length xs\" \n  shows \"\\<exists>y. f (xs ! i) = Inr y \\<and> ys ! i = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. f (xs ! i) = Inr y \\<and> ys ! i = y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>y. f (xs ! i) = Inr y \\<and> ys ! i = y", "note ** = mapM_return [OF *, unfolded set_conv_nth]"], ["proof (state)\nthis:\n  ys = map (projr \\<circ> f) xs \\<and>\n  (\\<forall>x\\<in>{xs ! i |i. i < length xs}.\n      \\<forall>e. f x \\<noteq> Inl e)\n\ngoal (1 subgoal):\n 1. \\<exists>y. f (xs ! i) = Inr y \\<and> ys ! i = y", "with assms"], ["proof (chain)\npicking this:\n  mapM f xs = Inr ys\n  i < length xs\n  ys = map (projr \\<circ> f) xs \\<and>\n  (\\<forall>x\\<in>{xs ! i |i. i < length xs}.\n      \\<forall>e. f x \\<noteq> Inl e)", "have \"\\<And>e. f (xs ! i) \\<noteq> Inl e\""], ["proof (prove)\nusing this:\n  mapM f xs = Inr ys\n  i < length xs\n  ys = map (projr \\<circ> f) xs \\<and>\n  (\\<forall>x\\<in>{xs ! i |i. i < length xs}.\n      \\<forall>e. f x \\<noteq> Inl e)\n\ngoal (1 subgoal):\n 1. \\<And>e. f (xs ! i) \\<noteq> Inl e", "by auto"], ["proof (state)\nthis:\n  f (xs ! i) \\<noteq> Inl ?e\n\ngoal (1 subgoal):\n 1. \\<exists>y. f (xs ! i) = Inr y \\<and> ys ! i = y", "then"], ["proof (chain)\npicking this:\n  f (xs ! i) \\<noteq> Inl ?e", "obtain y where \"f (xs ! i) = Inr y\""], ["proof (prove)\nusing this:\n  f (xs ! i) \\<noteq> Inl ?e\n\ngoal (1 subgoal):\n 1. (\\<And>y. f (xs ! i) = Inr y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"f (xs ! i)\") auto"], ["proof (state)\nthis:\n  f (xs ! i) = Inr y\n\ngoal (1 subgoal):\n 1. \\<exists>y. f (xs ! i) = Inr y \\<and> ys ! i = y", "then"], ["proof (chain)\npicking this:\n  f (xs ! i) = Inr y", "have \"f (xs ! i) = Inr y \\<and> ys ! i = y\""], ["proof (prove)\nusing this:\n  f (xs ! i) = Inr y\n\ngoal (1 subgoal):\n 1. f (xs ! i) = Inr y \\<and> ys ! i = y", "unfolding ** [THEN conjunct1]"], ["proof (prove)\nusing this:\n  f (xs ! i) = Inr y\n\ngoal (1 subgoal):\n 1. f (xs ! i) = Inr y \\<and> map (projr \\<circ> f) xs ! i = y", "using assms"], ["proof (prove)\nusing this:\n  f (xs ! i) = Inr y\n  mapM f xs = Inr ys\n  i < length xs\n\ngoal (1 subgoal):\n 1. f (xs ! i) = Inr y \\<and> map (projr \\<circ> f) xs ! i = y", "by auto"], ["proof (state)\nthis:\n  f (xs ! i) = Inr y \\<and> ys ! i = y\n\ngoal (1 subgoal):\n 1. \\<exists>y. f (xs ! i) = Inr y \\<and> ys ! i = y", "then"], ["proof (chain)\npicking this:\n  f (xs ! i) = Inr y \\<and> ys ! i = y", "show ?thesis"], ["proof (prove)\nusing this:\n  f (xs ! i) = Inr y \\<and> ys ! i = y\n\ngoal (1 subgoal):\n 1. \\<exists>y. f (xs ! i) = Inr y \\<and> ys ! i = y", ".."], ["proof (state)\nthis:\n  \\<exists>y. f (xs ! i) = Inr y \\<and> ys ! i = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mapM_cong [fundef_cong]:\n  assumes \"xs = ys\" and \"\\<And>x. x \\<in> set ys \\<Longrightarrow> f x = g x\"\n  shows \"mapM f xs = mapM g ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mapM f xs = mapM g ys", "unfolding assms(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mapM f ys = mapM g ys", "using assms(2)"], ["proof (prove)\nusing this:\n  ?x \\<in> set ys \\<Longrightarrow> f ?x = g ?x\n\ngoal (1 subgoal):\n 1. mapM f ys = mapM g ys", "by (induct ys) auto"], ["", "lemma bindE [elim]:\n  assumes \"(p \\<bind> f) = return x\"\n  obtains y where \"p = return y\" and \"f y = return x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>p = Inr y; f y = Inr x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  p \\<bind> f = Inr x\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>p = Inr y; f y = Inr x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p) simp_all"], ["", "lemma then_return_eq [simp]:\n  \"(p \\<then> q) = return f \\<longleftrightarrow> isOK p \\<and> q = return f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<bind> (\\<lambda>_. q) = Inr f) = (isOK p \\<and> q = Inr f)", "by (cases p) simp_all"], ["", "fun choice :: \"('e + 'a) list \\<Rightarrow> 'e list + 'a\"\nwhere\n  \"choice [] = error []\" |\n  \"choice (x # xs) = (try x catch (\\<lambda>e. choice xs <+? Cons e))\""], ["", "declare choice.simps [simp del]"], ["", "lemma isOK_mapM:\n  assumes \"isOK (mapM f xs)\"\n  shows \"(\\<forall>x. x \\<in> set xs \\<longrightarrow> isOK (f x)) \\<and> run (mapM f xs) = map (\\<lambda>x. run (f x)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. x \\<in> set xs \\<longrightarrow> isOK (f x)) \\<and>\n    projr (mapM f xs) = map (\\<lambda>x. projr (f x)) xs", "using assms mapM_return[of f xs]"], ["proof (prove)\nusing this:\n  isOK (mapM f xs)\n  mapM f xs = Inr ?ys \\<Longrightarrow>\n  ?ys = map (projr \\<circ> f) xs \\<and>\n  (\\<forall>x\\<in>set xs. \\<forall>e. f x \\<noteq> Inl e)\n\ngoal (1 subgoal):\n 1. (\\<forall>x. x \\<in> set xs \\<longrightarrow> isOK (f x)) \\<and>\n    projr (mapM f xs) = map (\\<lambda>x. projr (f x)) xs", "by (force simp: isOK_def split: sum.splits)+"], ["", "fun firstM\n  where\n    \"firstM f [] = error []\"\n  | \"firstM f (x # xs) = (try f x \\<then> return x catch (\\<lambda>e. firstM f xs <+? Cons e))\""], ["", "lemma firstM:\n  \"isOK (firstM f xs) \\<longleftrightarrow> (\\<exists>x\\<in>set xs. isOK (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK (firstM f xs) = (\\<exists>x\\<in>set xs. isOK (f x))", "by (induct xs) (auto simp: catch_def split: sum.splits)"], ["", "lemma firstM_return:\n  assumes \"firstM f xs = return y\"\n  shows \"isOK (f y) \\<and> y \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isOK (f y) \\<and> y \\<in> set xs", "using assms"], ["proof (prove)\nusing this:\n  firstM f xs = Inr y\n\ngoal (1 subgoal):\n 1. isOK (f y) \\<and> y \\<in> set xs", "by (induct xs) (auto simp: catch_def split: sum.splits)"], ["", "end"]]}