{"file_name": "/home/qj213/afp-2021-10-22/thys/Key_Agreement_Strong_Adversaries/Implem.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Key_Agreement_Strong_Adversaries", "problem_names": ["lemma validI:\n  \"M \\<in> payload \\<Longrightarrow> implem (Chan x A B M) \\<in> valid\"", "lemma validE:\n  \"X \\<in> valid \\<Longrightarrow> (\\<And> x A B M. X = implem (Chan x A B M) \\<Longrightarrow> M \\<in> payload \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma valid_cases:\nfixes X P\nassumes \"X \\<in> valid\"\n        \"(\\<And>A B M. X = implInsec A B M \\<Longrightarrow> M \\<in> payload \\<Longrightarrow> P)\"\n        \"(\\<And>A B M. X = implConfid A B M \\<Longrightarrow> M \\<in> payload \\<Longrightarrow> P)\"\n        \"(\\<And>A B M. X = implAuth A B M \\<Longrightarrow> M \\<in> payload \\<Longrightarrow> P)\"\n        \"(\\<And>A B M. X = implSecure A B M \\<Longrightarrow> M \\<in> payload \\<Longrightarrow> P)\"\nshows \"P\"", "lemmas parts_implE [elim] = parts_impl_inj [rotated 1]", "lemma composed_arg_cong: \"X = Y \\<Longrightarrow> composed X \\<longleftrightarrow> composed Y\"", "lemma implem_Tags_aux: \"implem (Chan x A B M) \\<notin> Tags\"", "lemma implem_Tags [simp]: \"implem x \\<notin> Tags\"", "lemma implem_LtK_aux: \"implem (Chan x A B M) \\<noteq> LtK K\"", "lemma implem_LtK [simp]: \"implem x \\<noteq> LtK K\"", "lemma implem_LtK2 [simp]: \"implem x \\<notin> range LtK\"", "lemma LtK_parts_impl_insert:\n  \"LtK K \\<in> parts (insert (implem (Chan x A B M)) S) \\<Longrightarrow> M \\<in> payload \\<Longrightarrow> LtK K \\<in> parts S\"", "lemma valid_composed [simp,dest]: \"M \\<in> valid \\<Longrightarrow> composed M\"", "lemma valid_payload [dest]: \"\\<lbrakk> X \\<in> valid; X \\<in> payload \\<rbrakk> \\<Longrightarrow> P\"", "lemma valid_isLtKey [dest]: \"\\<lbrakk> X \\<in> valid; X \\<in> range LtK \\<rbrakk> \\<Longrightarrow> P\"", "lemma analz_valid:\n  \"H \\<subseteq> payload \\<union> valid \\<union> range LtK \\<union> Tags \\<Longrightarrow>\n   implem (Chan x A B M) \\<in> analz H \\<Longrightarrow>\n   implem (Chan x A B M) \\<in> H\"", "lemma parts_valid_LtKeys_disjoint:\n  \"I \\<subseteq> valid \\<Longrightarrow> parts I \\<inter> range LtK = {}\"", "lemma analz_LtKeys:\n  \"H \\<subseteq> payload \\<union> valid \\<union> range LtK \\<union> Tags \\<Longrightarrow>\n   analz H \\<inter> range LtK \\<subseteq> H\""], "translations": [["", "lemma validI:\n  \"M \\<in> payload \\<Longrightarrow> implem (Chan x A B M) \\<in> valid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<in> payload \\<Longrightarrow> implem (Chan x A B M) \\<in> valid", "by (auto simp add: valid_def)"], ["", "lemma validE:\n  \"X \\<in> valid \\<Longrightarrow> (\\<And> x A B M. X = implem (Chan x A B M) \\<Longrightarrow> M \\<in> payload \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<in> valid;\n     \\<And>x A B M.\n        \\<lbrakk>X = implem (Chan x A B M); M \\<in> payload\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (auto simp add: valid_def)"], ["", "lemma valid_cases:\nfixes X P\nassumes \"X \\<in> valid\"\n        \"(\\<And>A B M. X = implInsec A B M \\<Longrightarrow> M \\<in> payload \\<Longrightarrow> P)\"\n        \"(\\<And>A B M. X = implConfid A B M \\<Longrightarrow> M \\<in> payload \\<Longrightarrow> P)\"\n        \"(\\<And>A B M. X = implAuth A B M \\<Longrightarrow> M \\<in> payload \\<Longrightarrow> P)\"\n        \"(\\<And>A B M. X = implSecure A B M \\<Longrightarrow> M \\<in> payload \\<Longrightarrow> P)\"\nshows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P", "from assms"], ["proof (chain)\npicking this:\n  X \\<in> valid\n  \\<lbrakk>X = implInsec ?A ?B ?M; ?M \\<in> payload\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>X = implConfid ?A ?B ?M; ?M \\<in> payload\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>X = implAuth ?A ?B ?M; ?M \\<in> payload\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>X = implSecure ?A ?B ?M; ?M \\<in> payload\\<rbrakk>\n  \\<Longrightarrow> P", "have \"(\\<And> x A B M. X = implem (Chan x A B M) \\<Longrightarrow> M \\<in> payload \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\nusing this:\n  X \\<in> valid\n  \\<lbrakk>X = implInsec ?A ?B ?M; ?M \\<in> payload\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>X = implConfid ?A ?B ?M; ?M \\<in> payload\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>X = implAuth ?A ?B ?M; ?M \\<in> payload\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>X = implSecure ?A ?B ?M; ?M \\<in> payload\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. (\\<And>x A B M.\n        \\<lbrakk>X = implem (Chan x A B M); M \\<in> payload\\<rbrakk>\n        \\<Longrightarrow> P) \\<Longrightarrow>\n    P", "by (auto elim: validE)"], ["proof (state)\nthis:\n  (\\<And>x A B M.\n      \\<lbrakk>X = implem (Chan x A B M); M \\<in> payload\\<rbrakk>\n      \\<Longrightarrow> P) \\<Longrightarrow>\n  P\n\ngoal (1 subgoal):\n 1. P", "moreover"], ["proof (state)\nthis:\n  (\\<And>x A B M.\n      \\<lbrakk>X = implem (Chan x A B M); M \\<in> payload\\<rbrakk>\n      \\<Longrightarrow> P) \\<Longrightarrow>\n  P\n\ngoal (1 subgoal):\n 1. P", "from assms"], ["proof (chain)\npicking this:\n  X \\<in> valid\n  \\<lbrakk>X = implInsec ?A ?B ?M; ?M \\<in> payload\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>X = implConfid ?A ?B ?M; ?M \\<in> payload\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>X = implAuth ?A ?B ?M; ?M \\<in> payload\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>X = implSecure ?A ?B ?M; ?M \\<in> payload\\<rbrakk>\n  \\<Longrightarrow> P", "have \"\\<And> x A B M. X = implem (Chan x A B M) \\<Longrightarrow> M \\<in> payload \\<Longrightarrow> P\""], ["proof (prove)\nusing this:\n  X \\<in> valid\n  \\<lbrakk>X = implInsec ?A ?B ?M; ?M \\<in> payload\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>X = implConfid ?A ?B ?M; ?M \\<in> payload\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>X = implAuth ?A ?B ?M; ?M \\<in> payload\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>X = implSecure ?A ?B ?M; ?M \\<in> payload\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<And>x A B M.\n       \\<lbrakk>X = implem (Chan x A B M); M \\<in> payload\\<rbrakk>\n       \\<Longrightarrow> P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x A B M.\n       \\<lbrakk>X = implem (Chan x A B M); M \\<in> payload; X \\<in> valid;\n        \\<And>A B M.\n           \\<lbrakk>X = implInsec A B M; M \\<in> payload\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>A B M.\n           \\<lbrakk>X = implConfid A B M; M \\<in> payload\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>A B M.\n           \\<lbrakk>X = implAuth A B M; M \\<in> payload\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>A B M.\n           \\<lbrakk>X = implSecure A B M; M \\<in> payload\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "fix x A B M"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x A B M.\n       \\<lbrakk>X = implem (Chan x A B M); M \\<in> payload; X \\<in> valid;\n        \\<And>A B M.\n           \\<lbrakk>X = implInsec A B M; M \\<in> payload\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>A B M.\n           \\<lbrakk>X = implConfid A B M; M \\<in> payload\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>A B M.\n           \\<lbrakk>X = implAuth A B M; M \\<in> payload\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>A B M.\n           \\<lbrakk>X = implSecure A B M; M \\<in> payload\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "assume \"X = implem (Chan x A B M)\" \"M \\<in> payload\""], ["proof (state)\nthis:\n  X = implem (Chan x A B M)\n  M \\<in> payload\n\ngoal (1 subgoal):\n 1. \\<And>x A B M.\n       \\<lbrakk>X = implem (Chan x A B M); M \\<in> payload; X \\<in> valid;\n        \\<And>A B M.\n           \\<lbrakk>X = implInsec A B M; M \\<in> payload\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>A B M.\n           \\<lbrakk>X = implConfid A B M; M \\<in> payload\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>A B M.\n           \\<lbrakk>X = implAuth A B M; M \\<in> payload\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>A B M.\n           \\<lbrakk>X = implSecure A B M; M \\<in> payload\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "with assms"], ["proof (chain)\npicking this:\n  X \\<in> valid\n  \\<lbrakk>X = implInsec ?A ?B ?M; ?M \\<in> payload\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>X = implConfid ?A ?B ?M; ?M \\<in> payload\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>X = implAuth ?A ?B ?M; ?M \\<in> payload\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>X = implSecure ?A ?B ?M; ?M \\<in> payload\\<rbrakk>\n  \\<Longrightarrow> P\n  X = implem (Chan x A B M)\n  M \\<in> payload", "show \"P\""], ["proof (prove)\nusing this:\n  X \\<in> valid\n  \\<lbrakk>X = implInsec ?A ?B ?M; ?M \\<in> payload\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>X = implConfid ?A ?B ?M; ?M \\<in> payload\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>X = implAuth ?A ?B ?M; ?M \\<in> payload\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>X = implSecure ?A ?B ?M; ?M \\<in> payload\\<rbrakk>\n  \\<Longrightarrow> P\n  X = implem (Chan x A B M)\n  M \\<in> payload\n\ngoal (1 subgoal):\n 1. P", "by (cases x, auto)"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>X = implem (Chan ?x ?A ?B ?M); ?M \\<in> payload\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "ultimately"], ["proof (chain)\npicking this:\n  (\\<And>x A B M.\n      \\<lbrakk>X = implem (Chan x A B M); M \\<in> payload\\<rbrakk>\n      \\<Longrightarrow> P) \\<Longrightarrow>\n  P\n  \\<lbrakk>X = implem (Chan ?x ?A ?B ?M); ?M \\<in> payload\\<rbrakk>\n  \\<Longrightarrow> P", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x A B M.\n      \\<lbrakk>X = implem (Chan x A B M); M \\<in> payload\\<rbrakk>\n      \\<Longrightarrow> P) \\<Longrightarrow>\n  P\n  \\<lbrakk>X = implem (Chan ?x ?A ?B ?M); ?M \\<in> payload\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "."], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Second step: basic and analyze assumptions\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>This locale contains most of the assumptions on implem, i.e.:\n\\begin{itemize}\n\\item \\<open>impl_inj\\<close>: injectivity\n\\item \\<open>parts_impl_inj\\<close>: injectivity through parts\n\\item \\<open>Enc_parts_valid_impl\\<close>: if Enc X Y appears in parts of an implem, then it is \n  in parts of the payload, or the key is either long term or payload\n\\item \\<open>impl_composed\\<close>: the implementations are composed (not nonces, agents, tags etc.)\n\\item \\<open>analz_Un_implXXXSet\\<close>: move the impl*Set out of the analz (only keep the payloads)\n\\item \\<open>impl_Impl\\<close>: implementations contain implementation material\n\\item \\<open>LtK_parts_impl\\<close>: no exposed long term keys in the implementations \n  (i.e., they are only used as keys, or under hashes)\n\\end{itemize}\n\\<close>"], ["", "locale semivalid_implem = basic_implem +\n\\<comment> \\<open>injectivity\\<close>\nassumes impl_inj:\n  \"implem (Chan x A B M) = implem (Chan x' A' B' M') \n   \\<longleftrightarrow> x = x' \\<and> A = A' \\<and> B = B' \\<and> M = M'\"\n\\<comment> \\<open>implementations and parts\\<close>\nand parts_impl_inj:\n  \"M' \\<in> payload \\<Longrightarrow>\n   implem (Chan x A B M) \\<in> parts {implem (Chan x' A' B' M')} \\<Longrightarrow> \n   x = x' \\<and> A = A' \\<and> B = B' \\<and> M = M'\"\nand Enc_keys_clean_valid: \"I \\<subseteq> valid \\<Longrightarrow> Enc_keys_clean I\"\nand impl_composed: \"composed (implem Z)\"\nand impl_Impl: \"implem (Chan x A B M) \\<notin> payload\"\n\\<comment> \\<open>no ltk in the parts of an implementation\\<close>\nand LtK_parts_impl: \"X \\<in> valid \\<Longrightarrow> LtK K \\<notin> parts {X}\"\n\n\\<comment> \\<open>analyze assumptions:\\<close>\nand analz_Un_implInsecSet:\n  \"\\<lbrakk> G \\<subseteq> payload; Enc_keys_clean H \\<rbrakk> \n \\<Longrightarrow> analz (implInsecSet G \\<union> H) \\<subseteq> synth (analz (G \\<union> H)) \\<union> -payload\"\nand analz_Un_implConfidSet:\n  \"\\<lbrakk> G \\<subseteq> payload; Enc_keys_clean H \\<rbrakk> \n \\<Longrightarrow> analz (implConfidSet Ag G \\<union> H) \\<subseteq> synth (analz (G \\<union> H)) \\<union> -payload\"\nand analz_Un_implConfidSet_2:\n  \"\\<lbrakk> G \\<subseteq> payload; Enc_keys_clean H; Ag \\<inter> broken (parts H \\<inter> range LtK) = {} \\<rbrakk>\n \\<Longrightarrow> analz (implConfidSet Ag G \\<union> H) \\<subseteq> synth (analz H) \\<union> -payload\"\nand analz_Un_implAuthSet:\n  \"\\<lbrakk> G \\<subseteq> payload; Enc_keys_clean H \\<rbrakk>\n \\<Longrightarrow> analz (implAuthSet G \\<union> H) \\<subseteq> synth (analz (G \\<union> H)) \\<union> -payload\"\nand analz_Un_implSecureSet:\n  \"\\<lbrakk> G \\<subseteq> payload; Enc_keys_clean H \\<rbrakk>\n \\<Longrightarrow> analz (implSecureSet Ag G \\<union> H) \\<subseteq> synth (analz (G \\<union> H)) \\<union> -payload\"\nand analz_Un_implSecureSet_2:\n  \"\\<lbrakk> G \\<subseteq> payload; Enc_keys_clean H; Ag \\<inter> broken (parts H \\<inter> range LtK) = {} \\<rbrakk>\n \\<Longrightarrow> analz (implSecureSet Ag G \\<union> H) \\<subseteq> synth (analz H) \\<union> -payload\"\n\nbegin\n\\<comment> \\<open>declare some attributes and abbreviations for the hypotheses\\<close>\n\\<comment> \\<open>and prove some simple consequences of the hypotheses\\<close>"], ["", "declare impl_inj [simp]"], ["", "lemmas parts_implE [elim] = parts_impl_inj [rotated 1]"], ["", "declare impl_composed [simp, intro]"], ["", "lemma composed_arg_cong: \"X = Y \\<Longrightarrow> composed X \\<longleftrightarrow> composed Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X = Y \\<Longrightarrow> composed X = composed Y", "by (rule arg_cong)"], ["", "lemma implem_Tags_aux: \"implem (Chan x A B M) \\<notin> Tags\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implem (Chan x A B M) \\<notin> Tags", "by (cases x, auto dest: composed_arg_cong)"], ["", "lemma implem_Tags [simp]: \"implem x \\<notin> Tags\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implem x \\<notin> Tags", "by (cases x, auto simp add: implem_Tags_aux)"], ["", "lemma implem_LtK_aux: \"implem (Chan x A B M) \\<noteq> LtK K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implem (Chan x A B M) \\<noteq> LtK K", "by (cases x, auto dest: composed_arg_cong)"], ["", "lemma implem_LtK [simp]: \"implem x \\<noteq> LtK K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implem x \\<noteq> LtK K", "by (cases x, auto simp add: implem_LtK_aux)"], ["", "lemma implem_LtK2 [simp]: \"implem x \\<notin> range LtK\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implem x \\<notin> range LtK", "by (cases x, auto simp add: implem_LtK_aux)"], ["", "declare impl_Impl [simp]"], ["", "lemma LtK_parts_impl_insert:\n  \"LtK K \\<in> parts (insert (implem (Chan x A B M)) S) \\<Longrightarrow> M \\<in> payload \\<Longrightarrow> LtK K \\<in> parts S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>LtK K \\<in> parts (insert (implem (Chan x A B M)) S);\n     M \\<in> payload\\<rbrakk>\n    \\<Longrightarrow> LtK K \\<in> parts S", "apply (simp add: parts_insert [of _ S], clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M \\<in> payload;\n     LtK K \\<in> parts {implem (Chan x A B M)}\\<rbrakk>\n    \\<Longrightarrow> LtK K \\<in> parts S", "apply (auto dest: validI LtK_parts_impl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare LtK_parts_impl_insert [dest]"], ["", "declare Enc_keys_clean_valid [simp, intro]"], ["", "lemma valid_composed [simp,dest]: \"M \\<in> valid \\<Longrightarrow> composed M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<in> valid \\<Longrightarrow> composed M", "by (auto elim: validE)\n\n\\<comment> \\<open>lemmas: valid/payload are mutually exclusive\\<close>"], ["", "lemma valid_payload [dest]: \"\\<lbrakk> X \\<in> valid; X \\<in> payload \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<in> valid; X \\<in> payload\\<rbrakk> \\<Longrightarrow> P", "by (auto elim!: validE)\n    \n\\<comment> \\<open>valid/LtK are mutually exclusive\\<close>"], ["", "lemma valid_isLtKey [dest]: \"\\<lbrakk> X \\<in> valid; X \\<in> range LtK \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<in> valid; X \\<in> range LtK\\<rbrakk> \\<Longrightarrow> P", "by (auto)"], ["", "lemma analz_valid:\n  \"H \\<subseteq> payload \\<union> valid \\<union> range LtK \\<union> Tags \\<Longrightarrow>\n   implem (Chan x A B M) \\<in> analz H \\<Longrightarrow>\n   implem (Chan x A B M) \\<in> H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H \\<subseteq> payload \\<union> valid \\<union>\n                           range LtK \\<union>\n                           Tags;\n     implem (Chan x A B M) \\<in> analz H\\<rbrakk>\n    \\<Longrightarrow> implem (Chan x A B M) \\<in> H", "apply (drule analz_into_parts, \n       drule parts_monotone [of _ H \"payload \\<union> H \\<inter> valid \\<union> range LtK \\<union> Tags\"], auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>H \\<subseteq> payload \\<union> valid \\<union>\n                           range LtK \\<union>\n                           Tags;\n     implem (Chan x A B M) \\<in> parts (H \\<inter> valid)\\<rbrakk>\n    \\<Longrightarrow> implem (Chan x A B M) \\<in> H", "apply (drule parts_singleton, auto elim!:validE dest: parts_impl_inj)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma parts_valid_LtKeys_disjoint:\n  \"I \\<subseteq> valid \\<Longrightarrow> parts I \\<inter> range LtK = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<subseteq> valid \\<Longrightarrow> parts I \\<inter> range LtK = {}", "apply (safe, drule parts_singleton, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa Y.\n       \\<lbrakk>I \\<subseteq> valid; Y \\<in> I;\n        LtK xa \\<in> parts {Y}\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto dest: subsetD LtK_parts_impl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma analz_LtKeys:\n  \"H \\<subseteq> payload \\<union> valid \\<union> range LtK \\<union> Tags \\<Longrightarrow>\n   analz H \\<inter> range LtK \\<subseteq> H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<subseteq> payload \\<union> valid \\<union> range LtK \\<union>\n                  Tags \\<Longrightarrow>\n    analz H \\<inter> range LtK \\<subseteq> H", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>H \\<subseteq> payload \\<union> valid \\<union>\n                              range LtK \\<union>\n                              Tags;\n        LtK xa \\<in> analz H\\<rbrakk>\n       \\<Longrightarrow> LtK xa \\<in> H", "apply (drule analz_into_parts, drule parts_monotone [of _ H \"payload \\<union> valid \\<union> H \\<inter> range LtK \\<union> Tags\"], auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>H \\<subseteq> payload \\<union> valid \\<union>\n                              range LtK \\<union>\n                              Tags;\n        LtK xa \\<in> parts valid\\<rbrakk>\n       \\<Longrightarrow> LtK xa \\<in> H", "apply (drule parts_singleton, auto elim!:validE dest: parts_impl_inj)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsection \\<open>Third step: \\<open>valid_implem\\<close>\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>This extends @{locale \"semivalid_implem\"} with four new assumptions, which under certain \n  conditions give information on $A$, $B$, $M$ when @{term \"implXXX A B M \\<in> synth (analz Z)\"}.\n  These assumptions are separated because interpretations are more easily proved, if the \n  conclusions that follow from the @{locale \"semivalid_implem\"} assumptions are already \n  available.\n\\<close>"], ["", "locale valid_implem = semivalid_implem +\n\n\\<comment> \\<open>Synthesize assumptions: conditions on payloads $M$ implied by derivable\\<close>\n\\<comment> \\<open>channel messages with payload $M$.\\<close>\nassumes implInsec_synth_analz:\n  \"H \\<subseteq> payload \\<union> valid \\<union> range LtK \\<union> Tags \\<Longrightarrow>\n   implInsec A B M \\<in> synth (analz H) \\<Longrightarrow>\n   implInsec A B M \\<in> H \\<or> M \\<in> synth (analz H)\"\nand implConfid_synth_analz:\n  \"H \\<subseteq> payload \\<union> valid \\<union> range LtK \\<union> Tags \\<Longrightarrow>\n   implConfid A B M \\<in> synth (analz H) \\<Longrightarrow>\n   implConfid A B M \\<in> H \\<or> M \\<in> synth (analz H)\"\nand implAuth_synth_analz:\n  \"H \\<subseteq> payload \\<union> valid \\<union> range LtK \\<union> Tags \\<Longrightarrow>\n   implAuth A B M \\<in> synth (analz H) \\<Longrightarrow>\n   implAuth A B M \\<in> H \\<or> (M \\<in> synth (analz H) \\<and> (A, B) \\<in> broken H)\"\nand implSecure_synth_analz:\n  \"H \\<subseteq> payload \\<union> valid \\<union> range LtK \\<union> Tags \\<Longrightarrow>\n   implSecure A B M \\<in> synth (analz H) \\<Longrightarrow>\n   implSecure A B M \\<in> H \\<or> (M \\<in> synth (analz H) \\<and> (A, B) \\<in> broken H)\""], ["", "end"]]}