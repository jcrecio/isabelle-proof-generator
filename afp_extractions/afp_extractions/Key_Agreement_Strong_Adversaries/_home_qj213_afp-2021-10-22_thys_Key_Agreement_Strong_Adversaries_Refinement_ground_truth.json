{"file_name": "/home/qj213/afp-2021-10-22/thys/Key_Agreement_Strong_Adversaries/Refinement.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Key_Agreement_Strong_Adversaries", "problem_names": ["lemma beh_immediate_prefix_closed:\n  \"s # b \\<in> beh T \\<Longrightarrow> b \\<in> beh T\"", "lemma beh_prefix_closed:\n  \"c @ b \\<in> beh T \\<Longrightarrow> b \\<in> beh T\"", "lemma beh_in_reach [rule_format]:\n  \"b \\<in> beh T \\<Longrightarrow> (\\<forall>s \\<in> set b. s \\<in> reach T)\"", "lemma reach_in_beh:\n  assumes \"s \\<in> reach T\" shows \"\\<exists>b \\<in> beh T. s \\<in> set b\"", "lemma reach_equiv_beh_states: \"reach T = \\<Union> (set`(beh T))\"", "lemma beh_obs_upd [simp]: \"beh (S(| obs := x |)) = beh S\"", "lemma reach_obs_upd [simp]: \"reach (S(| obs := x |)) = reach S\"", "lemma oreach_equiv_obeh_states:\n  \"oreach S = \\<Union> (set`(obeh S))\"", "lemma obeh_pi_translation:\n  \"(map pi)`(obeh S) = obeh (S(| obs := pi o (obs S) |))\"", "lemma oreach_pi_translation:\n  \"pi`(oreach S) = oreach (S(| obs := pi o (obs S) |))\"", "lemma observableE [elim]:\n  \"\\<lbrakk>observable ob P; ob s = ob s'; s' \\<in> P\\<rbrakk> \\<Longrightarrow> s \\<in> P\"", "lemma observable2_equiv_observable: \"observable2 ob P = observable ob P\"", "lemma observable3_equiv_observable2: \"observable3 ob P = observable2 ob P\"", "lemma observable_id [simp]: \"observable id P\"", "lemma image_vimage_adjoints: \"(ob`P \\<subseteq> Q) = (P \\<subseteq> ob-`Q)\"", "lemma image_r_vimage_l: \"\\<lbrakk> Q \\<subseteq> ob`P; observable ob P \\<rbrakk> \\<Longrightarrow> ob-`Q \\<subseteq> P\"", "lemma vimage_l_image_r: \"\\<lbrakk> ob-`Q \\<subseteq> P; Q \\<subseteq> range ob \\<rbrakk> \\<Longrightarrow> Q \\<subseteq> ob`P\"", "lemma external_from_internal_invariant: \n  \"\\<lbrakk> reach S \\<subseteq> P; (obs S)`P \\<subseteq> Q \\<rbrakk>  \n  \\<Longrightarrow> oreach S \\<subseteq> Q\"", "lemma external_from_internal_invariant_vimage: \n  \"\\<lbrakk> reach S \\<subseteq> P; P \\<subseteq> (obs S)-`Q \\<rbrakk>\n  \\<Longrightarrow> oreach S \\<subseteq> Q\"", "lemma external_to_internal_invariant_vimage: \n  \"\\<lbrakk> oreach S \\<subseteq> Q; (obs S)-`Q \\<subseteq> P \\<rbrakk>\n  \\<Longrightarrow> reach S \\<subseteq> P\"", "lemma external_to_internal_invariant:\n  \"\\<lbrakk> oreach S \\<subseteq> Q; Q \\<subseteq> (obs S)`P; observable (obs S) P \\<rbrakk> \n  \\<Longrightarrow> reach S \\<subseteq> P\"", "lemma external_equiv_internal_invariant_vimage: \n  \"\\<lbrakk> P = (obs S)-`Q \\<rbrakk> \n  \\<Longrightarrow> (oreach S \\<subseteq> Q) = (reach S \\<subseteq> P)\"", "lemma external_equiv_internal_invariant: \n  \"\\<lbrakk> (obs S)`P = Q; observable (obs S) P \\<rbrakk> \n  \\<Longrightarrow> (oreach S \\<subseteq> Q) = (reach S \\<subseteq> P)\"", "lemma implements_refl: \"implements id S S\"", "lemma implements_trans:\n  \"\\<lbrakk> implements pi1 S1 S2; implements pi2 S2 S3 \\<rbrakk> \n  \\<Longrightarrow> implements (pi1 o pi2) S1 S3\"", "lemma implements_oreach:\n  \"implements pi Sa Sc \\<Longrightarrow> pi`(oreach Sc) \\<subseteq> oreach Sa\"", "lemma external_invariant_preservation:\n  \"\\<lbrakk> oreach Sa \\<subseteq> Q; implements pi Sa Sc \\<rbrakk>\n  \\<Longrightarrow> pi`(oreach Sc) \\<subseteq> Q\"", "lemma external_invariant_translation:\n  \"\\<lbrakk> oreach Sa \\<subseteq> Q; pi-`Q \\<subseteq> P; implements pi Sa Sc \\<rbrakk>\n  \\<Longrightarrow> oreach Sc \\<subseteq> P\"", "lemma internal_invariant_translation:\n  \"\\<lbrakk> reach Sa \\<subseteq> Pa; Pa \\<subseteq> obs Sa -` Qa; pi -` Qa \\<subseteq> Q; obs S -` Q \\<subseteq> P;\n     implements pi Sa S \\<rbrakk>\n  \\<Longrightarrow> reach S \\<subseteq> P\"", "lemmas PO_hoare_defs = PO_hoare_def Image_def", "lemma \"{P} R {> Q} = (\\<forall>s t. s \\<in> P \\<longrightarrow> (s, t) \\<in> R \\<longrightarrow> t \\<in> Q)\"", "lemma hoare_conseq_left [intro]:\n  \"\\<lbrakk> {P'} R {> Q}; P \\<subseteq> P' \\<rbrakk>\n  \\<Longrightarrow> {P} R {> Q}\"", "lemma hoare_conseq_right:\n  \"\\<lbrakk> {P} R {> Q'}; Q' \\<subseteq> Q \\<rbrakk>\n  \\<Longrightarrow> {P} R {> Q}\"", "lemma hoare_false_left [simp]:\n  \"{{}} R {> Q}\"", "lemma hoare_true_right [simp]:\n  \"{P} R {> UNIV}\"", "lemma hoare_conj_right [intro!]:\n  \"\\<lbrakk> {P} R {> Q1}; {P} R {> Q2} \\<rbrakk>\n  \\<Longrightarrow> {P} R {> Q1 \\<inter> Q2}\"", "lemma hoare_stop [simp, intro!]:\n  \"{P} {} {> Q}\"", "lemma hoare_skip [simp, intro!]: \n  \"P \\<subseteq> Q \\<Longrightarrow> {P} Id {> Q}\"", "lemma hoare_trans_Un [iff]:\n  \"{P} R1 \\<union> R2 {> Q} = ({P} R1 {> Q} \\<and> {P} R2 {> Q})\"", "lemma hoare_trans_UN [iff]:\n  \"{P} \\<Union> x. R x {> Q} = (\\<forall>x. {P} R x {> Q})\"", "lemma hoare_apply:\n  \"{P} R {>Q} \\<Longrightarrow> x \\<in> P \\<Longrightarrow> (x, y) \\<in> R \\<Longrightarrow> y \\<in> Q\"", "lemma reach_init: \"reach T \\<subseteq> I \\<Longrightarrow> init T \\<subseteq> I\"", "lemma reach_trans: \"reach T \\<subseteq> I \\<Longrightarrow> {reach T} trans T {> I}\"", "lemma inv_rule_basic:\n  \"\\<lbrakk> init T \\<subseteq> P; {P} (trans T) {> P} \\<rbrakk>\n  \\<Longrightarrow> reach T \\<subseteq> P\"", "lemma inv_rule:\n  \"\\<lbrakk> init T \\<subseteq> I; I \\<subseteq> P; {I} (trans T) {> I} \\<rbrakk>\n  \\<Longrightarrow> reach T \\<subseteq> P\"", "lemma INV_rule:\n  \"\\<lbrakk> init T \\<subseteq> I; {I \\<inter> reach T} (trans T) {> I} \\<rbrakk>\n  \\<Longrightarrow> reach T \\<subseteq> I\"", "lemma inv_rule_from_INV_rule:\n  \"\\<lbrakk> init T \\<subseteq> I; I \\<subseteq> P; {I} (trans T) {> I} \\<rbrakk>\n  \\<Longrightarrow> reach T \\<subseteq> P\"", "lemma INV_rule_from_inv_rule:\n  \"\\<lbrakk> init T \\<subseteq> I; {I \\<inter> reach T} (trans T) {> I} \\<rbrakk>\n  \\<Longrightarrow> reach T \\<subseteq> I\"", "lemma inv_rule_incr:\n  \"\\<lbrakk> init T \\<subseteq> I; {I \\<inter> J} (trans T) {> I}; reach T \\<subseteq> J \\<rbrakk>    \n  \\<Longrightarrow> reach T \\<subseteq> I\"", "lemmas PO_rhoare_defs = PO_rhoare_def relcomp_unfold", "lemma relhoare_conseq_left [intro]:\n  \"\\<lbrakk> {pre'} Ra, Rc {> post}; pre \\<subseteq> pre' \\<rbrakk> \n  \\<Longrightarrow> {pre} Ra, Rc {> post}\"", "lemma relhoare_conseq_right:                    \\<comment> \\<open>do NOT declare [intro]\\<close>\n  \"\\<lbrakk> {pre} Ra, Rc {> post'}; post' \\<subseteq> post \\<rbrakk> \n  \\<Longrightarrow> {pre} Ra, Rc {> post}\"", "lemma relhoare_false_left [simp]:               \\<comment> \\<open>do NOT declare [intro]\\<close>\n  \"{ {} } Ra, Rc {> post}\"", "lemma relhoare_true_right [simp]:                \\<comment> \\<open>not true in general\\<close>\n  \"{pre} Ra, Rc {> UNIV} = (Domain (pre O Rc) \\<subseteq> Domain Ra)\"", "lemma Domain_rel_comp [intro]:\n  \"Domain pre \\<subseteq> R \\<Longrightarrow> Domain (pre O Rc) \\<subseteq> R\"", "lemma rel_hoare_skip [iff]: \"{R} Id, Id {> R}\"", "lemma relhoare_refl [simp]: \"{Id} R, R {> Id}\"", "lemma rhoare_trans:\n  \"\\<lbrakk> {R1} T1, T2 {> R1}; {R2} T2, T3 {> R2} \\<rbrakk>\n  \\<Longrightarrow> {R1 O R2} T1, T3 {> R1 O R2}\"", "lemma relhoare_conj_right_det:                 \n  \"\\<lbrakk> {pre} Ra, Rc {> post1}; {pre} Ra, Rc {> post2};\n     single_valued Ra \\<rbrakk>                           \\<comment> \\<open>only for deterministic \\<open>Ra\\<close>!\\<close>\n  \\<Longrightarrow> {pre} Ra, Rc {> post1 \\<inter> post2}\"", "lemma relhoare_conj_right_cartesian [intro]:\n  \"\\<lbrakk> {Domain pre} Ra {> I}; {Range pre} Rc {> J};\n     {pre} Ra, Rc {> post} \\<rbrakk> \n  \\<Longrightarrow> {pre} Ra, Rc {> post \\<inter> I \\<times> J}\"", "lemma relhoare_concrete_Un [simp]:\n  \"{pre} Ra, Rc1 \\<union> Rc2 {> post} \n   = ({pre} Ra, Rc1 {> post} \\<and> {pre} Ra, Rc2 {> post})\"", "lemma relhoare_concrete_UN [simp]:\n  \"{pre} Ra, \\<Union>x. Rc x {> post} = (\\<forall>x. {pre} Ra, Rc x {> post})\"", "lemma relhoare_abstract_Un_left [intro]:\n  \"\\<lbrakk> {pre} Ra1, Rc {> post} \\<rbrakk>\n  \\<Longrightarrow> {pre} Ra1 \\<union> Ra2, Rc {> post}\"", "lemma relhoare_abstract_Un_right [intro]:\n  \"\\<lbrakk> {pre} Ra2, Rc {> post} \\<rbrakk>\n  \\<Longrightarrow> {pre} Ra1 \\<union> Ra2, Rc {> post}\"", "lemma relhoare_abstract_UN [intro]:   \\<comment> \\<open>! might be too aggressive? INDEED.\\<close>\n  \"\\<lbrakk> {pre} Ra x, Rc {> post} \\<rbrakk>\n  \\<Longrightarrow> {pre} \\<Union>x. Ra x, Rc {> post}\"", "lemma relhoare_abstract_trans_weak [intro]:\n  \"\\<lbrakk> {pre} Ra', Rc {> post}; Ra' \\<subseteq> Ra \\<rbrakk> \n \\<Longrightarrow> {pre} Ra, Rc {> post}\"", "lemma PO_refinesI:\n  \"\\<lbrakk> init Tc \\<subseteq> R``(init Ta); {R} (trans Ta), (trans Tc) {> R} \\<rbrakk> \\<Longrightarrow> PO_refines R Ta Tc\"", "lemma PO_refinesE [elim]:\n  \"\\<lbrakk> PO_refines R Ta Tc; \\<lbrakk> init Tc \\<subseteq> R``(init Ta); {R} (trans Ta), (trans Tc) {> R} \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \n \\<Longrightarrow> P\"", "lemma refine_basic:\n  \"\\<lbrakk> init Tc \\<subseteq> R``(init Ta); {R} (trans Ta), (trans Tc) {> R} \\<rbrakk>\n  \\<Longrightarrow> PO_refines R Ta Tc\"", "lemma refine_init_using_invariants:\n  \"\\<lbrakk> init Tc \\<subseteq> R``(init Ta); init Ta \\<subseteq> I; init Tc \\<subseteq> J \\<rbrakk>\n  \\<Longrightarrow> init Tc \\<subseteq> (R \\<inter> I \\<times> J)``(init Ta)\"", "lemma refine_trans_using_invariants:\n  \"\\<lbrakk> {R \\<inter> I \\<times> J} (trans Ta), (trans Tc) {> R};\n     {I \\<inter> Domain (R \\<inter> UNIV \\<times> J)} (trans Ta) {> I}; \n     {J \\<inter> Range (R \\<inter> I \\<times> UNIV)} (trans Tc) {> J} \\<rbrakk>\n  \\<Longrightarrow> {R \\<inter> I \\<times> J} (trans Ta), (trans Tc) {> R  \\<inter> I \\<times> J}\"", "lemma refine_using_invariants:\n  \"\\<lbrakk> {R \\<inter> I \\<times> J} (trans Ta), (trans Tc) {> R};\n     {I \\<inter> Domain (R \\<inter> UNIV \\<times> J)} (trans Ta) {> I}; \n     {J \\<inter> Range (R \\<inter> I \\<times> UNIV)} (trans Tc) {> J}; \n     init Tc \\<subseteq> R``(init Ta); \n     init Ta \\<subseteq> I; init Tc \\<subseteq> J \\<rbrakk>\n  \\<Longrightarrow> PO_refines (R \\<inter> I \\<times> J) Ta Tc\"", "lemma PO_refines_implies_Range_init:\n  \"PO_refines R Ta Tc \\<Longrightarrow> init Tc \\<subseteq> Range R\"", "lemma PO_refines_implies_Range_trans:\n  \"PO_refines R Ta Tc \\<Longrightarrow> {Range R} trans Tc {> Range R}\"", "lemma PO_refines_implies_Range_invariant:\n  \"PO_refines R Ta Tc \\<Longrightarrow> reach Tc \\<subseteq> Range R\"", "lemma behaviour_refinement:\n  \"\\<lbrakk> PO_refines R Ta Tc; bc \\<in> beh Tc\\<rbrakk> \n  \\<Longrightarrow> \\<exists>ba \\<in> beh Ta. (ba, bc) \\<in> seq_lift R\"", "lemma obs_consistent_refl [iff]: \"obs_consistent Id id S S\"", "lemma obs_consistent_trans [intro]: \n  \"\\<lbrakk> obs_consistent R1 pi1 S1 S2; obs_consistent R2 pi2 S2 S3 \\<rbrakk>\n  \\<Longrightarrow> obs_consistent (R1 O R2) (pi1 o pi2) S1 S3\"", "lemma obs_consistent_empty: \"obs_consistent {} pi Sa Sc\"", "lemma obs_consistent_conj1 [intro]: \n  \"obs_consistent R pi Sa Sc \\<Longrightarrow> obs_consistent (R \\<inter> R') pi Sa Sc\"", "lemma obs_consistent_conj2 [intro]: \n  \"obs_consistent R pi Sa Sc \\<Longrightarrow> obs_consistent (R' \\<inter> R) pi Sa Sc\"", "lemma obs_consistent_behaviours:\n  \"\\<lbrakk> obs_consistent R pi Sa Sc; bc \\<in> beh Sc; ba \\<in> beh Sa; (ba, bc) \\<in> seq_lift R\\<rbrakk>\n  \\<Longrightarrow> map pi (map (obs Sc) bc) = map (obs Sa) ba\"", "lemmas refines_defs = \n  refines_def PO_refines_def", "lemma refinesI: \n  \"\\<lbrakk> PO_refines R Sa Sc; obs_consistent R pi Sa Sc \\<rbrakk>\n  \\<Longrightarrow> refines R pi Sa Sc\"", "lemma refinesE [elim]: \n  \"\\<lbrakk> refines R pi Sa Sc; \\<lbrakk> PO_refines R Sa Sc; obs_consistent R pi Sa Sc \\<rbrakk> \\<Longrightarrow> P \\<rbrakk>\n  \\<Longrightarrow> P\"", "lemma refinement_reflexive: \"refines Id id S S\"", "lemma refinement_transitive: \n  \"\\<lbrakk> refines R1 pi1 S1 S2; refines R2 pi2 S2 S3 \\<rbrakk> \n  \\<Longrightarrow> refines (R1 O R2) (pi1 o pi2) S1 S3\"", "lemma observable_behaviour_refinement:\n  \"\\<lbrakk> refines R pi Sa Sc; bc \\<in> obeh Sc \\<rbrakk> \\<Longrightarrow> map pi bc \\<in> obeh Sa\"", "theorem refinement_soundness: \n  \"refines R pi Sa Sc \\<Longrightarrow> implements pi Sa Sc\"", "lemmas Refinement_basic = refine_basic [THEN refinesI]", "lemmas Refinement_using_invariants = refine_using_invariants [THEN refinesI]", "lemma refines_reachable_strengthening:\n  \"refines R pi Sa Sc \\<Longrightarrow> refines (R \\<inter> reach Sa \\<times> reach Sc) pi Sa Sc\"", "lemma INV_init_from_Refinement:\n  \"\\<lbrakk>refines R pi Sa Sc; Range R \\<subseteq> I\\<rbrakk> \\<Longrightarrow> init Sc \\<subseteq> I\"", "lemma INV_trans_from_Refinement:\n  \" \\<lbrakk>refines R pi Sa Sc; K \\<subseteq> Range R; Range R \\<subseteq> I\\<rbrakk> \\<Longrightarrow> {K} TS.trans Sc {> I}\"", "lemma INV_from_Refinement_basic: \n  \"\\<lbrakk> refines R pi Sa Sc; Range R \\<subseteq> I \\<rbrakk> \\<Longrightarrow> reach Sc \\<subseteq> I\"", "lemma INV_from_Refinement_using_invariants: \n  assumes \"refines R pi Sa Sc\" \"Range (R \\<inter> I \\<times> J) \\<subseteq> K\" \n          \"reach Sa \\<subseteq> I\" \"reach Sc \\<subseteq> J\" \n  shows \"reach Sc \\<subseteq> K\""], "translations": [["", "lemma beh_immediate_prefix_closed:\n  \"s # b \\<in> beh T \\<Longrightarrow> b \\<in> beh T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s # b \\<in> beh T \\<Longrightarrow> b \\<in> beh T", "by (erule beh_non_empty, auto)"], ["", "lemma beh_prefix_closed:\n  \"c @ b \\<in> beh T \\<Longrightarrow> b \\<in> beh T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c @ b \\<in> beh T \\<Longrightarrow> b \\<in> beh T", "by (induct c, auto dest!: beh_immediate_prefix_closed)"], ["", "text \\<open>States in behaviours are exactly reachable.\\<close>"], ["", "lemma beh_in_reach [rule_format]:\n  \"b \\<in> beh T \\<Longrightarrow> (\\<forall>s \\<in> set b. s \\<in> reach T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> beh T \\<Longrightarrow> \\<forall>s\\<in>set b. s \\<in> reach T", "by (erule beh.induct) (auto)"], ["", "lemma reach_in_beh:\n  assumes \"s \\<in> reach T\" shows \"\\<exists>b \\<in> beh T. s \\<in> set b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b\\<in>beh T. s \\<in> set b", "using assms"], ["proof (prove)\nusing this:\n  s \\<in> reach T\n\ngoal (1 subgoal):\n 1. \\<exists>b\\<in>beh T. s \\<in> set b", "proof (induction s rule: reach.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       s \\<in> init T \\<Longrightarrow> \\<exists>b\\<in>beh T. s \\<in> set b\n 2. \\<And>s t.\n       \\<lbrakk>(s, t) \\<in> TS.trans T; s \\<in> reach T;\n        \\<exists>b\\<in>beh T. s \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b\\<in>beh T. t \\<in> set b", "case (r_init s)"], ["proof (state)\nthis:\n  s \\<in> init T\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       s \\<in> init T \\<Longrightarrow> \\<exists>b\\<in>beh T. s \\<in> set b\n 2. \\<And>s t.\n       \\<lbrakk>(s, t) \\<in> TS.trans T; s \\<in> reach T;\n        \\<exists>b\\<in>beh T. s \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b\\<in>beh T. t \\<in> set b", "hence \"s \\<in> set [s]\" and \"[s] \\<in> beh T\""], ["proof (prove)\nusing this:\n  s \\<in> init T\n\ngoal (1 subgoal):\n 1. s \\<in> set [s] &&& [s] \\<in> beh T", "by auto"], ["proof (state)\nthis:\n  s \\<in> set [s]\n  [s] \\<in> beh T\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       s \\<in> init T \\<Longrightarrow> \\<exists>b\\<in>beh T. s \\<in> set b\n 2. \\<And>s t.\n       \\<lbrakk>(s, t) \\<in> TS.trans T; s \\<in> reach T;\n        \\<exists>b\\<in>beh T. s \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b\\<in>beh T. t \\<in> set b", "thus ?case"], ["proof (prove)\nusing this:\n  s \\<in> set [s]\n  [s] \\<in> beh T\n\ngoal (1 subgoal):\n 1. \\<exists>b\\<in>beh T. s \\<in> set b", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>b\\<in>beh T. s \\<in> set b\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>(s, t) \\<in> TS.trans T; s \\<in> reach T;\n        \\<exists>b\\<in>beh T. s \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b\\<in>beh T. t \\<in> set b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>(s, t) \\<in> TS.trans T; s \\<in> reach T;\n        \\<exists>b\\<in>beh T. s \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b\\<in>beh T. t \\<in> set b", "case (r_trans s t)"], ["proof (state)\nthis:\n  (s, t) \\<in> TS.trans T\n  s \\<in> reach T\n  \\<exists>b\\<in>beh T. s \\<in> set b\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>(s, t) \\<in> TS.trans T; s \\<in> reach T;\n        \\<exists>b\\<in>beh T. s \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b\\<in>beh T. t \\<in> set b", "then"], ["proof (chain)\npicking this:\n  (s, t) \\<in> TS.trans T\n  s \\<in> reach T\n  \\<exists>b\\<in>beh T. s \\<in> set b", "obtain b where \"b \\<in> beh T\" and \"s \\<in> set b\""], ["proof (prove)\nusing this:\n  (s, t) \\<in> TS.trans T\n  s \\<in> reach T\n  \\<exists>b\\<in>beh T. s \\<in> set b\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b \\<in> beh T; s \\<in> set b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  b \\<in> beh T\n  s \\<in> set b\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>(s, t) \\<in> TS.trans T; s \\<in> reach T;\n        \\<exists>b\\<in>beh T. s \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b\\<in>beh T. t \\<in> set b", "from \\<open>s \\<in> set b\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> set b", "obtain b1 b2 where \"b = b2 @ s # b1\""], ["proof (prove)\nusing this:\n  s \\<in> set b\n\ngoal (1 subgoal):\n 1. (\\<And>b2 b1.\n        b = b2 @ s # b1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: split_list)"], ["proof (state)\nthis:\n  b = b2 @ s # b1\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>(s, t) \\<in> TS.trans T; s \\<in> reach T;\n        \\<exists>b\\<in>beh T. s \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b\\<in>beh T. t \\<in> set b", "with \\<open>b \\<in> beh T\\<close>"], ["proof (chain)\npicking this:\n  b \\<in> beh T\n  b = b2 @ s # b1", "have \"s # b1 \\<in> beh T\""], ["proof (prove)\nusing this:\n  b \\<in> beh T\n  b = b2 @ s # b1\n\ngoal (1 subgoal):\n 1. s # b1 \\<in> beh T", "by (blast intro: beh_prefix_closed)"], ["proof (state)\nthis:\n  s # b1 \\<in> beh T\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>(s, t) \\<in> TS.trans T; s \\<in> reach T;\n        \\<exists>b\\<in>beh T. s \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b\\<in>beh T. t \\<in> set b", "with \\<open>(s, t) \\<in> trans T\\<close>"], ["proof (chain)\npicking this:\n  (s, t) \\<in> TS.trans T\n  s # b1 \\<in> beh T", "have \"t # s # b1 \\<in> beh T\""], ["proof (prove)\nusing this:\n  (s, t) \\<in> TS.trans T\n  s # b1 \\<in> beh T\n\ngoal (1 subgoal):\n 1. t # s # b1 \\<in> beh T", "by blast"], ["proof (state)\nthis:\n  t # s # b1 \\<in> beh T\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>(s, t) \\<in> TS.trans T; s \\<in> reach T;\n        \\<exists>b\\<in>beh T. s \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b\\<in>beh T. t \\<in> set b", "thus ?case"], ["proof (prove)\nusing this:\n  t # s # b1 \\<in> beh T\n\ngoal (1 subgoal):\n 1. \\<exists>b\\<in>beh T. t \\<in> set b", "by force"], ["proof (state)\nthis:\n  \\<exists>b\\<in>beh T. t \\<in> set b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reach_equiv_beh_states: \"reach T = \\<Union> (set`(beh T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach T = \\<Union> (set ` beh T)", "by (auto intro!: reach_in_beh beh_in_reach)"], ["", "subsubsection \\<open>Specifications, observability, and implementation\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Specifications add an observer function to transition systems.\\<close>"], ["", "record ('s, 'o) spec = \"'s TS\" +\n  obs :: \"'s \\<Rightarrow> 'o\""], ["", "lemma beh_obs_upd [simp]: \"beh (S(| obs := x |)) = beh S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. beh (S\\<lparr>obs := x\\<rparr>) = beh S", "by (safe) (erule beh.induct, auto)+"], ["", "lemma reach_obs_upd [simp]: \"reach (S(| obs := x |)) = reach S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach (S\\<lparr>obs := x\\<rparr>) = reach S", "by (safe) (erule reach.induct, auto)+"], ["", "text \\<open>Observable behaviour and reachability.\\<close>"], ["", "definition \n  obeh :: \"('s, 'o) spec \\<Rightarrow> ('o list) set\" where\n  \"obeh S \\<equiv> (map (obs S))`(beh S)\""], ["", "definition \n  oreach :: \"('s, 'o) spec \\<Rightarrow> 'o set\" where \n  \"oreach S \\<equiv> (obs S)`(reach S)\""], ["", "lemma oreach_equiv_obeh_states:\n  \"oreach S = \\<Union> (set`(obeh S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oreach S = \\<Union> (set ` obeh S)", "by (auto simp add: reach_equiv_beh_states oreach_def obeh_def)"], ["", "lemma obeh_pi_translation:\n  \"(map pi)`(obeh S) = obeh (S(| obs := pi o (obs S) |))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map pi ` obeh S = obeh (S\\<lparr>obs := pi \\<circ> obs S\\<rparr>)", "by (auto simp add: obeh_def image_comp)"], ["", "lemma oreach_pi_translation:\n  \"pi`(oreach S) = oreach (S(| obs := pi o (obs S) |))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pi ` oreach S = oreach (S\\<lparr>obs := pi \\<circ> obs S\\<rparr>)", "by (auto simp add: oreach_def)"], ["", "text \\<open>A predicate $P$ on the states of a specification is \\emph{observable} \nif it cannot distinguish between states yielding the same observation. \nEquivalently, $P$ is observable if it is the inverse image under the \nobservation function of a predicate on observations.\\<close>"], ["", "definition \n  observable :: \"['s \\<Rightarrow> 'o, 's set] \\<Rightarrow> bool\"\nwhere\n  \"observable ob P \\<equiv> \\<forall>s s'. ob s = ob s' \\<longrightarrow> s' \\<in> P \\<longrightarrow> s \\<in> P\""], ["", "definition \n  observable2 :: \"['s \\<Rightarrow> 'o, 's set] \\<Rightarrow> bool\"\nwhere\n  \"observable2 ob P \\<equiv> \\<exists>Q. P = ob-`Q\""], ["", "definition \n  observable3 :: \"['s \\<Rightarrow> 'o, 's set] \\<Rightarrow> bool\"\nwhere\n  \"observable3 ob P \\<equiv> ob-`ob`P \\<subseteq> P\"    \\<comment> \\<open>other direction holds trivially\\<close>"], ["", "lemma observableE [elim]:\n  \"\\<lbrakk>observable ob P; ob s = ob s'; s' \\<in> P\\<rbrakk> \\<Longrightarrow> s \\<in> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>observable ob P; ob s = ob s'; s' \\<in> P\\<rbrakk>\n    \\<Longrightarrow> s \\<in> P", "by (unfold observable_def) (fast)"], ["", "lemma observable2_equiv_observable: \"observable2 ob P = observable ob P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. observable2 ob P = observable ob P", "by (unfold observable_def observable2_def) (auto)"], ["", "lemma observable3_equiv_observable2: \"observable3 ob P = observable2 ob P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. observable3 ob P = observable2 ob P", "by (unfold observable3_def observable2_def) (auto)"], ["", "lemma observable_id [simp]: \"observable id P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. observable id P", "by (simp add: observable_def)"], ["", "text \\<open>The set extension of a function @{term \"ob\"} is the left adjoint of \na Galois connection on the powerset lattices over domain and range of @{term \"ob\"} \nwhere the right adjoint is the inverse image function.\\<close>"], ["", "lemma image_vimage_adjoints: \"(ob`P \\<subseteq> Q) = (P \\<subseteq> ob-`Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ob ` P \\<subseteq> Q) = (P \\<subseteq> ob -` Q)", "by auto"], ["", "declare image_vimage_subset [simp, intro]"], ["", "declare vimage_image_subset [simp, intro]"], ["", "text \\<open>Similar but \"reversed\" (wrt to adjointness) relationships only hold under\nadditional conditions.\\<close>"], ["", "lemma image_r_vimage_l: \"\\<lbrakk> Q \\<subseteq> ob`P; observable ob P \\<rbrakk> \\<Longrightarrow> ob-`Q \\<subseteq> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q \\<subseteq> ob ` P; observable ob P\\<rbrakk>\n    \\<Longrightarrow> ob -` Q \\<subseteq> P", "by (auto)"], ["", "lemma vimage_l_image_r: \"\\<lbrakk> ob-`Q \\<subseteq> P; Q \\<subseteq> range ob \\<rbrakk> \\<Longrightarrow> Q \\<subseteq> ob`P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ob -` Q \\<subseteq> P; Q \\<subseteq> range ob\\<rbrakk>\n    \\<Longrightarrow> Q \\<subseteq> ob ` P", "by (drule image_mono [where f=ob], auto)"], ["", "text \\<open>Internal and external invariants\\<close>"], ["", "lemma external_from_internal_invariant: \n  \"\\<lbrakk> reach S \\<subseteq> P; (obs S)`P \\<subseteq> Q \\<rbrakk>  \n  \\<Longrightarrow> oreach S \\<subseteq> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reach S \\<subseteq> P; obs S ` P \\<subseteq> Q\\<rbrakk>\n    \\<Longrightarrow> oreach S \\<subseteq> Q", "by (auto simp add: oreach_def)"], ["", "lemma external_from_internal_invariant_vimage: \n  \"\\<lbrakk> reach S \\<subseteq> P; P \\<subseteq> (obs S)-`Q \\<rbrakk>\n  \\<Longrightarrow> oreach S \\<subseteq> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reach S \\<subseteq> P; P \\<subseteq> obs S -` Q\\<rbrakk>\n    \\<Longrightarrow> oreach S \\<subseteq> Q", "by (erule external_from_internal_invariant) (auto)"], ["", "lemma external_to_internal_invariant_vimage: \n  \"\\<lbrakk> oreach S \\<subseteq> Q; (obs S)-`Q \\<subseteq> P \\<rbrakk>\n  \\<Longrightarrow> reach S \\<subseteq> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>oreach S \\<subseteq> Q; obs S -` Q \\<subseteq> P\\<rbrakk>\n    \\<Longrightarrow> reach S \\<subseteq> P", "by (auto simp add: oreach_def)"], ["", "lemma external_to_internal_invariant:\n  \"\\<lbrakk> oreach S \\<subseteq> Q; Q \\<subseteq> (obs S)`P; observable (obs S) P \\<rbrakk> \n  \\<Longrightarrow> reach S \\<subseteq> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>oreach S \\<subseteq> Q; Q \\<subseteq> obs S ` P;\n     observable (obs S) P\\<rbrakk>\n    \\<Longrightarrow> reach S \\<subseteq> P", "by (erule external_to_internal_invariant_vimage) (auto)"], ["", "lemma external_equiv_internal_invariant_vimage: \n  \"\\<lbrakk> P = (obs S)-`Q \\<rbrakk> \n  \\<Longrightarrow> (oreach S \\<subseteq> Q) = (reach S \\<subseteq> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = obs S -` Q \\<Longrightarrow>\n    (oreach S \\<subseteq> Q) = (reach S \\<subseteq> P)", "by (fast intro: external_from_internal_invariant_vimage\n                external_to_internal_invariant_vimage \n         del: subsetI)"], ["", "lemma external_equiv_internal_invariant: \n  \"\\<lbrakk> (obs S)`P = Q; observable (obs S) P \\<rbrakk> \n  \\<Longrightarrow> (oreach S \\<subseteq> Q) = (reach S \\<subseteq> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>obs S ` P = Q; observable (obs S) P\\<rbrakk>\n    \\<Longrightarrow> (oreach S \\<subseteq> Q) = (reach S \\<subseteq> P)", "by (rule external_equiv_internal_invariant_vimage) (auto)"], ["", "text \\<open>Our notion of implementation is inclusion of observable behaviours.\\<close>"], ["", "definition \n  implements :: \"['p \\<Rightarrow> 'o, ('s, 'o) spec, ('t, 'p) spec] \\<Rightarrow> bool\" where\n  \"implements pi Sa Sc \\<equiv> (map pi)`(obeh Sc) \\<subseteq> obeh Sa\""], ["", "text \\<open>Reflexivity and transitivity\\<close>"], ["", "lemma implements_refl: \"implements id S S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements id S S", "by (auto simp add: implements_def)"], ["", "lemma implements_trans:\n  \"\\<lbrakk> implements pi1 S1 S2; implements pi2 S2 S3 \\<rbrakk> \n  \\<Longrightarrow> implements (pi1 o pi2) S1 S3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>implements pi1 S1 S2; implements pi2 S2 S3\\<rbrakk>\n    \\<Longrightarrow> implements (pi1 \\<circ> pi2) S1 S3", "by (fastforce simp add: implements_def image_subset_iff)"], ["", "text \\<open>Preservation of external invariants\\<close>"], ["", "lemma implements_oreach:\n  \"implements pi Sa Sc \\<Longrightarrow> pi`(oreach Sc) \\<subseteq> oreach Sa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements pi Sa Sc \\<Longrightarrow>\n    pi ` oreach Sc \\<subseteq> oreach Sa", "by (auto simp add: implements_def oreach_equiv_obeh_states dest!: subsetD)"], ["", "lemma external_invariant_preservation:\n  \"\\<lbrakk> oreach Sa \\<subseteq> Q; implements pi Sa Sc \\<rbrakk>\n  \\<Longrightarrow> pi`(oreach Sc) \\<subseteq> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>oreach Sa \\<subseteq> Q; implements pi Sa Sc\\<rbrakk>\n    \\<Longrightarrow> pi ` oreach Sc \\<subseteq> Q", "by (rule subset_trans [OF implements_oreach]) (auto)"], ["", "lemma external_invariant_translation:\n  \"\\<lbrakk> oreach Sa \\<subseteq> Q; pi-`Q \\<subseteq> P; implements pi Sa Sc \\<rbrakk>\n  \\<Longrightarrow> oreach Sc \\<subseteq> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>oreach Sa \\<subseteq> Q; pi -` Q \\<subseteq> P;\n     implements pi Sa Sc\\<rbrakk>\n    \\<Longrightarrow> oreach Sc \\<subseteq> P", "apply (rule subset_trans [OF vimage_image_subset, of pi])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>oreach Sa \\<subseteq> Q; pi -` Q \\<subseteq> P;\n     implements pi Sa Sc\\<rbrakk>\n    \\<Longrightarrow> pi -` pi ` oreach Sc \\<subseteq> P", "apply (rule subset_trans [where B=\"pi-`Q\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>oreach Sa \\<subseteq> Q; pi -` Q \\<subseteq> P;\n     implements pi Sa Sc\\<rbrakk>\n    \\<Longrightarrow> pi -` pi ` oreach Sc \\<subseteq> pi -` Q\n 2. \\<lbrakk>oreach Sa \\<subseteq> Q; pi -` Q \\<subseteq> P;\n     implements pi Sa Sc\\<rbrakk>\n    \\<Longrightarrow> pi -` Q \\<subseteq> P", "apply (intro vimage_mono external_invariant_preservation, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Preservation of internal invariants\\<close>"], ["", "lemma internal_invariant_translation:\n  \"\\<lbrakk> reach Sa \\<subseteq> Pa; Pa \\<subseteq> obs Sa -` Qa; pi -` Qa \\<subseteq> Q; obs S -` Q \\<subseteq> P;\n     implements pi Sa S \\<rbrakk>\n  \\<Longrightarrow> reach S \\<subseteq> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reach Sa \\<subseteq> Pa; Pa \\<subseteq> obs Sa -` Qa;\n     pi -` Qa \\<subseteq> Q; obs S -` Q \\<subseteq> P;\n     implements pi Sa S\\<rbrakk>\n    \\<Longrightarrow> reach S \\<subseteq> P", "by (rule external_from_internal_invariant_vimage [\n      THEN external_invariant_translation, \n      THEN external_to_internal_invariant_vimage])"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Invariants\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>First we define Hoare triples over transition relations and then\nwe derive proof rules to establish invariants.\\<close>"], ["", "subsubsection \\<open>Hoare triples\\<close>"], ["", "(******************************************************************************)"], ["", "definition \n  PO_hoare :: \"['s set, ('s \\<times> 's) set, 's set] \\<Rightarrow> bool\"\n     (\"(3{_} _ {> _})\" [0, 0, 0] 90)\nwhere\n  \"{pre} R {> post} \\<equiv> R``pre \\<subseteq> post\""], ["", "lemmas PO_hoare_defs = PO_hoare_def Image_def"], ["", "lemma \"{P} R {> Q} = (\\<forall>s t. s \\<in> P \\<longrightarrow> (s, t) \\<in> R \\<longrightarrow> t \\<in> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {P} R {> Q} =\n    (\\<forall>s t.\n        s \\<in> P \\<longrightarrow>\n        (s, t) \\<in> R \\<longrightarrow> t \\<in> Q)", "by (auto simp add: PO_hoare_defs)"], ["", "text \\<open>Some essential facts about Hoare triples.\\<close>"], ["", "lemma hoare_conseq_left [intro]:\n  \"\\<lbrakk> {P'} R {> Q}; P \\<subseteq> P' \\<rbrakk>\n  \\<Longrightarrow> {P} R {> Q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{P'} R {> Q}; P \\<subseteq> P'\\<rbrakk>\n    \\<Longrightarrow> {P} R {> Q}", "by (auto simp add: PO_hoare_defs)"], ["", "lemma hoare_conseq_right:\n  \"\\<lbrakk> {P} R {> Q'}; Q' \\<subseteq> Q \\<rbrakk>\n  \\<Longrightarrow> {P} R {> Q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{P} R {> Q'}; Q' \\<subseteq> Q\\<rbrakk>\n    \\<Longrightarrow> {P} R {> Q}", "by (auto simp add: PO_hoare_defs)"], ["", "lemma hoare_false_left [simp]:\n  \"{{}} R {> Q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {{}} R {> Q}", "by (auto simp add: PO_hoare_defs)"], ["", "lemma hoare_true_right [simp]:\n  \"{P} R {> UNIV}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {P} R {> UNIV}", "by (auto simp add: PO_hoare_defs)"], ["", "lemma hoare_conj_right [intro!]:\n  \"\\<lbrakk> {P} R {> Q1}; {P} R {> Q2} \\<rbrakk>\n  \\<Longrightarrow> {P} R {> Q1 \\<inter> Q2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{P} R {> Q1}; {P} R {> Q2}\\<rbrakk>\n    \\<Longrightarrow> {P} R {> Q1 \\<inter> Q2}", "by (auto simp add: PO_hoare_defs)"], ["", "text \\<open>Special transition relations.\\<close>"], ["", "lemma hoare_stop [simp, intro!]:\n  \"{P} {} {> Q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {P} {} {> Q}", "by (auto simp add: PO_hoare_defs)"], ["", "lemma hoare_skip [simp, intro!]: \n  \"P \\<subseteq> Q \\<Longrightarrow> {P} Id {> Q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<subseteq> Q \\<Longrightarrow> {P} Id {> Q}", "by (auto simp add: PO_hoare_defs)"], ["", "lemma hoare_trans_Un [iff]:\n  \"{P} R1 \\<union> R2 {> Q} = ({P} R1 {> Q} \\<and> {P} R2 {> Q})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {P} R1 \\<union> R2 {> Q} = ({P} R1 {> Q} \\<and> {P} R2 {> Q})", "by (auto simp add: PO_hoare_defs)"], ["", "lemma hoare_trans_UN [iff]:\n  \"{P} \\<Union> x. R x {> Q} = (\\<forall>x. {P} R x {> Q})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {P} \\<Union> (range R) {> Q} = (\\<forall>x. {P} R x {> Q})", "by (auto simp add: PO_hoare_defs)"], ["", "lemma hoare_apply:\n  \"{P} R {>Q} \\<Longrightarrow> x \\<in> P \\<Longrightarrow> (x, y) \\<in> R \\<Longrightarrow> y \\<in> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{P} R {> Q}; x \\<in> P; (x, y) \\<in> R\\<rbrakk>\n    \\<Longrightarrow> y \\<in> Q", "by (auto simp add: PO_hoare_defs)"], ["", "subsubsection \\<open>Characterization of reachability\\<close>"], ["", "(******************************************************************************)"], ["", "lemma reach_init: \"reach T \\<subseteq> I \\<Longrightarrow> init T \\<subseteq> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach T \\<subseteq> I \\<Longrightarrow> init T \\<subseteq> I", "by (auto dest: subsetD)"], ["", "lemma reach_trans: \"reach T \\<subseteq> I \\<Longrightarrow> {reach T} trans T {> I}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach T \\<subseteq> I \\<Longrightarrow> {reach T} TS.trans T {> I}", "by (auto simp add: PO_hoare_defs)"], ["", "text \\<open>Useful consequences.\\<close>"], ["", "corollary init_reach [iff]: \"init T \\<subseteq> reach T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init T \\<subseteq> reach T", "by (rule reach_init, simp)"], ["", "corollary trans_reach [iff]: \"{reach T} trans T {> reach T}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {reach T} TS.trans T {> reach T}", "by (rule reach_trans, simp)"], ["", "subsubsection \\<open>Invariant proof rules\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Basic proof rule for invariants.\\<close>"], ["", "lemma inv_rule_basic:\n  \"\\<lbrakk> init T \\<subseteq> P; {P} (trans T) {> P} \\<rbrakk>\n  \\<Longrightarrow> reach T \\<subseteq> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>init T \\<subseteq> P; {P} TS.trans T {> P}\\<rbrakk>\n    \\<Longrightarrow> reach T \\<subseteq> P", "by (safe, erule reach.induct, auto simp add: PO_hoare_def)"], ["", "text \\<open>General invariant proof rule. This rule is complete (set \n@{term \"I = reach T\"}).\\<close>"], ["", "lemma inv_rule:\n  \"\\<lbrakk> init T \\<subseteq> I; I \\<subseteq> P; {I} (trans T) {> I} \\<rbrakk>\n  \\<Longrightarrow> reach T \\<subseteq> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>init T \\<subseteq> I; I \\<subseteq> P;\n     {I} TS.trans T {> I}\\<rbrakk>\n    \\<Longrightarrow> reach T \\<subseteq> P", "apply (rule subset_trans, auto)              \\<comment> \\<open>strengthen goal\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>init T \\<subseteq> I; I \\<subseteq> P; {I} TS.trans T {> I};\n        x \\<in> reach T\\<rbrakk>\n       \\<Longrightarrow> x \\<in> I", "apply (erule reach.induct, auto simp add: PO_hoare_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>The following rule is equivalent to the previous one.\\<close>"], ["", "lemma INV_rule:\n  \"\\<lbrakk> init T \\<subseteq> I; {I \\<inter> reach T} (trans T) {> I} \\<rbrakk>\n  \\<Longrightarrow> reach T \\<subseteq> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>init T \\<subseteq> I;\n     {I \\<inter> reach T} TS.trans T {> I}\\<rbrakk>\n    \\<Longrightarrow> reach T \\<subseteq> I", "by (safe, erule reach.induct, auto simp add: PO_hoare_defs)"], ["", "text \\<open>Proof of equivalence.\\<close>"], ["", "lemma inv_rule_from_INV_rule:\n  \"\\<lbrakk> init T \\<subseteq> I; I \\<subseteq> P; {I} (trans T) {> I} \\<rbrakk>\n  \\<Longrightarrow> reach T \\<subseteq> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>init T \\<subseteq> I; I \\<subseteq> P;\n     {I} TS.trans T {> I}\\<rbrakk>\n    \\<Longrightarrow> reach T \\<subseteq> P", "apply (rule subset_trans, auto del: subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>init T \\<subseteq> I; I \\<subseteq> P;\n     {I} TS.trans T {> I}\\<rbrakk>\n    \\<Longrightarrow> reach T \\<subseteq> I", "apply (rule INV_rule, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma INV_rule_from_inv_rule:\n  \"\\<lbrakk> init T \\<subseteq> I; {I \\<inter> reach T} (trans T) {> I} \\<rbrakk>\n  \\<Longrightarrow> reach T \\<subseteq> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>init T \\<subseteq> I;\n     {I \\<inter> reach T} TS.trans T {> I}\\<rbrakk>\n    \\<Longrightarrow> reach T \\<subseteq> I", "by (rule_tac I=\"I \\<inter> reach T\" in inv_rule, auto)"], ["", "text \\<open>Incremental proof rule for invariants using auxiliary invariant(s). \nThis rule might have become obsolete by addition of $INV\\_rule$.\\<close>"], ["", "lemma inv_rule_incr:\n  \"\\<lbrakk> init T \\<subseteq> I; {I \\<inter> J} (trans T) {> I}; reach T \\<subseteq> J \\<rbrakk>    \n  \\<Longrightarrow> reach T \\<subseteq> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>init T \\<subseteq> I; {I \\<inter> J} TS.trans T {> I};\n     reach T \\<subseteq> J\\<rbrakk>\n    \\<Longrightarrow> reach T \\<subseteq> I", "by (rule INV_rule, auto)"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Refinement\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Our notion of refinement is simulation. We first define a general\nnotion of relational Hoare tuple, which we then use to define the refinement\nproof obligation.  Finally, we show that observation-consistent refinement \nof specifications implies the implementation relation between them.\\<close>"], ["", "subsubsection \\<open>Relational Hoare tuples\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Relational Hoare tuples formalize the following generalized simulation \ndiagram:\n\n\\begin{verbatim}\n                           o -- Ra --> o\n                           |           |\n                          pre         post\n                           |           |\n                           v           V\n                           o -- Rc --> o\n\\end{verbatim}\n\nHere, $Ra$ and $Rc$ are the abstract and concrete transition relations, \nand $pre$ and $post$ are the pre- and post-relations.\n(In the definiton below, the operator @{term \"(O)\"} stands for relational \ncomposition, which is defined as follows: @{thm relcomp_def [no_vars]}.)\\<close>"], ["", "definition\n  PO_rhoare :: \n    \"[('s \\<times> 't) set, ('s \\<times> 's) set, ('t \\<times> 't) set, ('s \\<times> 't) set] \\<Rightarrow> bool\"\n     (\"(4{_} _, _ {> _})\" [0, 0, 0] 90)\nwhere\n  \"{pre} Ra, Rc {> post} \\<equiv> pre O Rc \\<subseteq> Ra O post\""], ["", "lemmas PO_rhoare_defs = PO_rhoare_def relcomp_unfold"], ["", "text \\<open>Facts about relational Hoare tuples.\\<close>"], ["", "lemma relhoare_conseq_left [intro]:\n  \"\\<lbrakk> {pre'} Ra, Rc {> post}; pre \\<subseteq> pre' \\<rbrakk> \n  \\<Longrightarrow> {pre} Ra, Rc {> post}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{pre'} Ra, Rc {> post}; pre \\<subseteq> pre'\\<rbrakk>\n    \\<Longrightarrow> {pre} Ra, Rc {> post}", "by (auto simp add: PO_rhoare_defs dest!: subsetD)"], ["", "lemma relhoare_conseq_right:                    \\<comment> \\<open>do NOT declare [intro]\\<close>\n  \"\\<lbrakk> {pre} Ra, Rc {> post'}; post' \\<subseteq> post \\<rbrakk> \n  \\<Longrightarrow> {pre} Ra, Rc {> post}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{pre} Ra, Rc {> post'}; post' \\<subseteq> post\\<rbrakk>\n    \\<Longrightarrow> {pre} Ra, Rc {> post}", "by (auto simp add: PO_rhoare_defs)"], ["", "lemma relhoare_false_left [simp]:               \\<comment> \\<open>do NOT declare [intro]\\<close>\n  \"{ {} } Ra, Rc {> post}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {{}} Ra, Rc {> post}", "by (auto simp add: PO_rhoare_defs)"], ["", "lemma relhoare_true_right [simp]:                \\<comment> \\<open>not true in general\\<close>\n  \"{pre} Ra, Rc {> UNIV} = (Domain (pre O Rc) \\<subseteq> Domain Ra)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {pre} Ra, Rc {> UNIV} = (Domain (pre O Rc) \\<subseteq> Domain Ra)", "by (auto simp add: PO_rhoare_defs)"], ["", "lemma Domain_rel_comp [intro]:\n  \"Domain pre \\<subseteq> R \\<Longrightarrow> Domain (pre O Rc) \\<subseteq> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domain pre \\<subseteq> R \\<Longrightarrow>\n    Domain (pre O Rc) \\<subseteq> R", "by (auto simp add: Domain_def)"], ["", "lemma rel_hoare_skip [iff]: \"{R} Id, Id {> R}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R} Id, Id {> R}", "by (auto simp add: PO_rhoare_def)"], ["", "text \\<open>Reflexivity and transitivity.\\<close>"], ["", "lemma relhoare_refl [simp]: \"{Id} R, R {> Id}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Id} R, R {> Id}", "by (auto simp add: PO_rhoare_defs)"], ["", "lemma rhoare_trans:\n  \"\\<lbrakk> {R1} T1, T2 {> R1}; {R2} T2, T3 {> R2} \\<rbrakk>\n  \\<Longrightarrow> {R1 O R2} T1, T3 {> R1 O R2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{R1} T1, T2 {> R1}; {R2} T2, T3 {> R2}\\<rbrakk>\n    \\<Longrightarrow> {R1 O R2} T1, T3 {> R1 O R2}", "apply (auto simp add: PO_rhoare_def del: subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R1 O T2 \\<subseteq> T1 O R1;\n     R2 O T3 \\<subseteq> T2 O R2\\<rbrakk>\n    \\<Longrightarrow> (R1 O R2) O T3 \\<subseteq> T1 O R1 O R2", "apply (drule subset_refl [THEN relcomp_mono, where r=R1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R1 O T2 \\<subseteq> T1 O R1;\n     R1 O R2 O T3 \\<subseteq> R1 O T2 O R2\\<rbrakk>\n    \\<Longrightarrow> (R1 O R2) O T3 \\<subseteq> T1 O R1 O R2", "apply (drule subset_refl [THEN [2] relcomp_mono, where s=R2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R1 O R2 O T3 \\<subseteq> R1 O T2 O R2;\n     (R1 O T2) O R2 \\<subseteq> (T1 O R1) O R2\\<rbrakk>\n    \\<Longrightarrow> (R1 O R2) O T3 \\<subseteq> T1 O R1 O R2", "apply (auto simp add: O_assoc del: subsetI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Conjunction in the post-relation cannot be split in general.  However, \nhere are two useful special cases.  In the first case the abstract transtition \nrelation is deterministic and in the second case one conjunct is a cartesian \nproduct of two state predicates.\\<close>"], ["", "lemma relhoare_conj_right_det:                 \n  \"\\<lbrakk> {pre} Ra, Rc {> post1}; {pre} Ra, Rc {> post2};\n     single_valued Ra \\<rbrakk>                           \\<comment> \\<open>only for deterministic \\<open>Ra\\<close>!\\<close>\n  \\<Longrightarrow> {pre} Ra, Rc {> post1 \\<inter> post2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{pre} Ra, Rc {> post1}; {pre} Ra, Rc {> post2};\n     single_valued Ra\\<rbrakk>\n    \\<Longrightarrow> {pre} Ra, Rc {> post1 \\<inter> post2}", "by (auto simp add: PO_rhoare_defs dest: single_valuedD dest!: subsetD)"], ["", "lemma relhoare_conj_right_cartesian [intro]:\n  \"\\<lbrakk> {Domain pre} Ra {> I}; {Range pre} Rc {> J};\n     {pre} Ra, Rc {> post} \\<rbrakk> \n  \\<Longrightarrow> {pre} Ra, Rc {> post \\<inter> I \\<times> J}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{Domain pre} Ra {> I}; {Range pre} Rc {> J};\n     {pre} Ra, Rc {> post}\\<rbrakk>\n    \\<Longrightarrow> {pre} Ra, Rc {> post \\<inter> I \\<times> J}", "by (force simp add: PO_rhoare_defs PO_hoare_defs Domain_def Range_def)"], ["", "text \\<open>Separate rule for cartesian products.\\<close>"], ["", "corollary relhoare_cartesian:\n  \"\\<lbrakk> {Domain pre} Ra {> I}; {Range pre} Rc {> J};\n     {pre} Ra, Rc {> post} \\<rbrakk>                      \\<comment> \\<open>any \\<open>post\\<close>, including \\<open>UNIV\\<close>!\\<close>\n  \\<Longrightarrow> {pre} Ra, Rc {> I \\<times> J}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{Domain pre} Ra {> I}; {Range pre} Rc {> J};\n     {pre} Ra, Rc {> post}\\<rbrakk>\n    \\<Longrightarrow> {pre} Ra, Rc {> I \\<times> J}", "by (auto intro: relhoare_conseq_right)"], ["", "text \\<open>Unions of transition relations.\\<close>"], ["", "lemma relhoare_concrete_Un [simp]:\n  \"{pre} Ra, Rc1 \\<union> Rc2 {> post} \n   = ({pre} Ra, Rc1 {> post} \\<and> {pre} Ra, Rc2 {> post})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {pre} Ra, Rc1 \\<union> Rc2 {> post} =\n    ({pre} Ra, Rc1 {> post} \\<and> {pre} Ra, Rc2 {> post})", "apply (auto simp add: PO_rhoare_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>{(x, z).\n                 \\<exists>y. (x, y) \\<in> pre \\<and> (y, z) \\<in> Rc1}\n                \\<subseteq> {(x, z).\n                             \\<exists>y.\n                                (x, y) \\<in> Ra \\<and> (y, z) \\<in> post};\n        {(x, z). \\<exists>y. (x, y) \\<in> pre \\<and> (y, z) \\<in> Rc2}\n        \\<subseteq> {(x, z).\n                     \\<exists>y. (x, y) \\<in> Ra \\<and> (y, z) \\<in> post};\n        (a, y) \\<in> pre; (y, b) \\<in> Rc2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (a, y) \\<in> Ra \\<and> (y, b) \\<in> post", "apply (auto dest!: subsetD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma relhoare_concrete_UN [simp]:\n  \"{pre} Ra, \\<Union>x. Rc x {> post} = (\\<forall>x. {pre} Ra, Rc x {> post})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {pre} Ra, \\<Union> (range Rc) {> post} =\n    (\\<forall>x. {pre} Ra, Rc x {> post})", "apply (auto simp add: PO_rhoare_defs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a b y.\n       \\<lbrakk>{(x, z).\n                 \\<exists>y.\n                    (x, y) \\<in> pre \\<and> (\\<exists>x. (y, z) \\<in> Rc x)}\n                \\<subseteq> {(x, z).\n                             \\<exists>y.\n                                (x, y) \\<in> Ra \\<and> (y, z) \\<in> post};\n        (a, y) \\<in> pre; (y, b) \\<in> Rc x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (a, y) \\<in> Ra \\<and> (y, b) \\<in> post\n 2. \\<And>a b y x.\n       \\<lbrakk>\\<forall>x.\n                   {(xa, z).\n                    \\<exists>y. (xa, y) \\<in> pre \\<and> (y, z) \\<in> Rc x}\n                   \\<subseteq> {(x, z).\n                                \\<exists>y.\n                                   (x, y) \\<in> Ra \\<and>\n                                   (y, z) \\<in> post};\n        (a, y) \\<in> pre; (y, b) \\<in> Rc x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (a, y) \\<in> Ra \\<and> (y, b) \\<in> post", "apply (auto dest!: subsetD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma relhoare_abstract_Un_left [intro]:\n  \"\\<lbrakk> {pre} Ra1, Rc {> post} \\<rbrakk>\n  \\<Longrightarrow> {pre} Ra1 \\<union> Ra2, Rc {> post}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {pre} Ra1, Rc {> post} \\<Longrightarrow>\n    {pre} Ra1 \\<union> Ra2, Rc {> post}", "by (auto simp add: PO_rhoare_defs)"], ["", "lemma relhoare_abstract_Un_right [intro]:\n  \"\\<lbrakk> {pre} Ra2, Rc {> post} \\<rbrakk>\n  \\<Longrightarrow> {pre} Ra1 \\<union> Ra2, Rc {> post}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {pre} Ra2, Rc {> post} \\<Longrightarrow>\n    {pre} Ra1 \\<union> Ra2, Rc {> post}", "by (auto simp add: PO_rhoare_defs)"], ["", "lemma relhoare_abstract_UN [intro]:   \\<comment> \\<open>! might be too aggressive? INDEED.\\<close>\n  \"\\<lbrakk> {pre} Ra x, Rc {> post} \\<rbrakk>\n  \\<Longrightarrow> {pre} \\<Union>x. Ra x, Rc {> post}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {pre} Ra x, Rc {> post} \\<Longrightarrow>\n    {pre} \\<Union> (range Ra), Rc {> post}", "apply (auto simp add: PO_rhoare_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>{(x, z).\n                 \\<exists>y. (x, y) \\<in> pre \\<and> (y, z) \\<in> Rc}\n                \\<subseteq> {(xa, z).\n                             \\<exists>y.\n                                (xa, y) \\<in> Ra x \\<and>\n                                (y, z) \\<in> post};\n        (a, y) \\<in> pre; (y, b) \\<in> Rc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x. (a, y) \\<in> Ra x) \\<and>\n                            (y, b) \\<in> post", "apply (auto dest!: subsetD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Inclusion of abstract transition relations.\\<close>"], ["", "lemma relhoare_abstract_trans_weak [intro]:\n  \"\\<lbrakk> {pre} Ra', Rc {> post}; Ra' \\<subseteq> Ra \\<rbrakk> \n \\<Longrightarrow> {pre} Ra, Rc {> post}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{pre} Ra', Rc {> post}; Ra' \\<subseteq> Ra\\<rbrakk>\n    \\<Longrightarrow> {pre} Ra, Rc {> post}", "by (auto simp add:PO_rhoare_defs)"], ["", "subsubsection \\<open>Refinement proof obligations\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>A transition system refines another one if the initial states and the\ntransitions are refined. \nInitial state refinement means that for each concrete initial state there is \na related abstract one. Transition refinement means that the simulation \nrelation is preserved (as expressed by a relational Hoare tuple). \n\\<close>"], ["", "definition \n  PO_refines :: \n    \"[('s \\<times> 't) set, ('s, 'a) TS_scheme, ('t, 'b) TS_scheme] \\<Rightarrow> bool\" \nwhere\n  \"PO_refines R Ta Tc \\<equiv> (\n       init Tc \\<subseteq> R``(init Ta)\n     \\<and> {R} (trans Ta), (trans Tc) {> R} \n  )\""], ["", "lemma PO_refinesI:\n  \"\\<lbrakk> init Tc \\<subseteq> R``(init Ta); {R} (trans Ta), (trans Tc) {> R} \\<rbrakk> \\<Longrightarrow> PO_refines R Ta Tc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>init Tc \\<subseteq> R `` init Ta;\n     {R} TS.trans Ta, TS.trans Tc {> R}\\<rbrakk>\n    \\<Longrightarrow> PO_refines R Ta Tc", "by (simp add: PO_refines_def)"], ["", "lemma PO_refinesE [elim]:\n  \"\\<lbrakk> PO_refines R Ta Tc; \\<lbrakk> init Tc \\<subseteq> R``(init Ta); {R} (trans Ta), (trans Tc) {> R} \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \n \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PO_refines R Ta Tc;\n     \\<lbrakk>init Tc \\<subseteq> R `` init Ta;\n      {R} TS.trans Ta, TS.trans Tc {> R}\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (simp add: PO_refines_def)"], ["", "text \\<open>Basic refinement rule. This is just an introduction rule for the\ndefinition.\\<close>"], ["", "lemma refine_basic:\n  \"\\<lbrakk> init Tc \\<subseteq> R``(init Ta); {R} (trans Ta), (trans Tc) {> R} \\<rbrakk>\n  \\<Longrightarrow> PO_refines R Ta Tc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>init Tc \\<subseteq> R `` init Ta;\n     {R} TS.trans Ta, TS.trans Tc {> R}\\<rbrakk>\n    \\<Longrightarrow> PO_refines R Ta Tc", "by (simp add: PO_refines_def)"], ["", "text \\<open>The following proof rule uses individual invariants @{term \"I\"} \nand @{term \"J\"} of the concrete and abstract systems to strengthen the \nsimulation relation $R$. \n\nThe hypotheses state that these state predicates are indeed invariants.\nNote that the pre-condition of the invariant preservation hypotheses for \n@{term \"I\"} and @{term \"J\"} are strengthened by adding the predicates \n@{term \"Domain (R \\<inter> UNIV \\<times> J)\"} and @{term \"Range (R \\<inter> I \\<times> UNIV)\"}, \nrespectively.  In particular, the latter predicate may be essential, if a \nconcrete invariant depends on the simulation relation and an abstract invariant, \ni.e. to \"transport\" abstract invariants to the concrete system.\\<close>"], ["", "lemma refine_init_using_invariants:\n  \"\\<lbrakk> init Tc \\<subseteq> R``(init Ta); init Ta \\<subseteq> I; init Tc \\<subseteq> J \\<rbrakk>\n  \\<Longrightarrow> init Tc \\<subseteq> (R \\<inter> I \\<times> J)``(init Ta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>init Tc \\<subseteq> R `` init Ta; init Ta \\<subseteq> I;\n     init Tc \\<subseteq> J\\<rbrakk>\n    \\<Longrightarrow> init Tc\n                      \\<subseteq> (R \\<inter> I \\<times> J) `` init Ta", "by (auto simp add: Image_def dest!: bspec subsetD)"], ["", "lemma refine_trans_using_invariants:\n  \"\\<lbrakk> {R \\<inter> I \\<times> J} (trans Ta), (trans Tc) {> R};\n     {I \\<inter> Domain (R \\<inter> UNIV \\<times> J)} (trans Ta) {> I}; \n     {J \\<inter> Range (R \\<inter> I \\<times> UNIV)} (trans Tc) {> J} \\<rbrakk>\n  \\<Longrightarrow> {R \\<inter> I \\<times> J} (trans Ta), (trans Tc) {> R  \\<inter> I \\<times> J}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{R \\<inter> I \\<times> J} TS.trans Ta, TS.trans Tc {> R};\n     {I \\<inter> Domain (R \\<inter> UNIV \\<times> J)} TS.trans Ta {> I};\n     {J \\<inter>\n      Range (R \\<inter> I \\<times> UNIV)} TS.trans Tc {> J}\\<rbrakk>\n    \\<Longrightarrow> {R \\<inter>\n                       I \\<times>\n                       J} TS.trans\n                           Ta, TS.trans Tc {> R \\<inter> I \\<times> J}", "by (rule relhoare_conj_right_cartesian) (auto)"], ["", "text \\<open>This is our main rule for refinements.\\<close>"], ["", "lemma refine_using_invariants:\n  \"\\<lbrakk> {R \\<inter> I \\<times> J} (trans Ta), (trans Tc) {> R};\n     {I \\<inter> Domain (R \\<inter> UNIV \\<times> J)} (trans Ta) {> I}; \n     {J \\<inter> Range (R \\<inter> I \\<times> UNIV)} (trans Tc) {> J}; \n     init Tc \\<subseteq> R``(init Ta); \n     init Ta \\<subseteq> I; init Tc \\<subseteq> J \\<rbrakk>\n  \\<Longrightarrow> PO_refines (R \\<inter> I \\<times> J) Ta Tc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{R \\<inter> I \\<times> J} TS.trans Ta, TS.trans Tc {> R};\n     {I \\<inter> Domain (R \\<inter> UNIV \\<times> J)} TS.trans Ta {> I};\n     {J \\<inter> Range (R \\<inter> I \\<times> UNIV)} TS.trans Tc {> J};\n     init Tc \\<subseteq> R `` init Ta; init Ta \\<subseteq> I;\n     init Tc \\<subseteq> J\\<rbrakk>\n    \\<Longrightarrow> PO_refines (R \\<inter> I \\<times> J) Ta Tc", "by (unfold PO_refines_def)\n   (intro refine_init_using_invariants refine_trans_using_invariants conjI)"], ["", "subsubsection \\<open>Deriving invariants from refinements\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Some invariants can only be proved after the simulation has been \nestablished, because they depend on the simulation relation and some abstract\ninvariants.  Here is a rule to derive invariant theorems from the refinement.\\<close>"], ["", "lemma PO_refines_implies_Range_init:\n  \"PO_refines R Ta Tc \\<Longrightarrow> init Tc \\<subseteq> Range R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PO_refines R Ta Tc \\<Longrightarrow> init Tc \\<subseteq> Range R", "by (auto simp add: PO_refines_def)"], ["", "lemma PO_refines_implies_Range_trans:\n  \"PO_refines R Ta Tc \\<Longrightarrow> {Range R} trans Tc {> Range R}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PO_refines R Ta Tc \\<Longrightarrow> {Range R} TS.trans Tc {> Range R}", "by (auto simp add: PO_refines_def PO_rhoare_def PO_hoare_def)"], ["", "lemma PO_refines_implies_Range_invariant:\n  \"PO_refines R Ta Tc \\<Longrightarrow> reach Tc \\<subseteq> Range R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PO_refines R Ta Tc \\<Longrightarrow> reach Tc \\<subseteq> Range R", "by (rule INV_rule)\n   (auto intro!: PO_refines_implies_Range_init \n                 PO_refines_implies_Range_trans)"], ["", "text \\<open>The following rules are more useful in proofs.\\<close>"], ["", "corollary INV_init_from_refinement: \n  \"\\<lbrakk> PO_refines R Ta Tc; Range R \\<subseteq> I \\<rbrakk>\n  \\<Longrightarrow> init Tc \\<subseteq> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PO_refines R Ta Tc; Range R \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> init Tc \\<subseteq> I", "by (drule PO_refines_implies_Range_init, auto)"], ["", "corollary INV_trans_from_refinement: \n  \"\\<lbrakk> PO_refines R Ta Tc; K \\<subseteq> Range R; Range R \\<subseteq> I \\<rbrakk>\n  \\<Longrightarrow> {K} trans Tc {> I}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PO_refines R Ta Tc; K \\<subseteq> Range R;\n     Range R \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> {K} TS.trans Tc {> I}", "apply (drule PO_refines_implies_Range_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>K \\<subseteq> Range R; Range R \\<subseteq> I;\n     {Range R} TS.trans Tc {> Range R}\\<rbrakk>\n    \\<Longrightarrow> {K} TS.trans Tc {> I}", "apply (auto intro: hoare_conseq_right)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary INV_from_refinement: \n  \"\\<lbrakk> PO_refines R Ta Tc; Range R \\<subseteq> I \\<rbrakk>\n  \\<Longrightarrow> reach Tc \\<subseteq> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PO_refines R Ta Tc; Range R \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> reach Tc \\<subseteq> I", "by (drule PO_refines_implies_Range_invariant, fast)"], ["", "subsubsection \\<open>Refinement of specifications\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Lift relation membership to finite sequences\\<close>"], ["", "inductive_set \n  seq_lift :: \"('s \\<times> 't) set \\<Rightarrow> ('s list \\<times> 't list) set\" \n  for R :: \"('s \\<times> 't) set\"\nwhere\n  sl_nil [iff]: \"([], []) \\<in> seq_lift R\"\n| sl_cons [intro]: \n    \"\\<lbrakk> (xs, ys) \\<in> seq_lift R; (x, y) \\<in> R \\<rbrakk> \\<Longrightarrow> (x#xs, y#ys) \\<in> seq_lift R\""], ["", "inductive_cases sl_cons_right_invert: \"(ba', t # bc) \\<in> seq_lift R\""], ["", "text \\<open>For each concrete behaviour there is a related abstract one.\\<close>"], ["", "lemma behaviour_refinement:\n  \"\\<lbrakk> PO_refines R Ta Tc; bc \\<in> beh Tc\\<rbrakk> \n  \\<Longrightarrow> \\<exists>ba \\<in> beh Ta. (ba, bc) \\<in> seq_lift R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PO_refines R Ta Tc; bc \\<in> beh Tc\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ba\\<in>beh Ta. (ba, bc) \\<in> seq_lift R", "apply (erule beh.induct, auto)\n  \\<comment> \\<open>case: singleton\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>PO_refines R Ta Tc; s \\<in> init Tc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba\\<in>beh Ta. (ba, [s]) \\<in> seq_lift R\n 2. \\<And>s b t ba.\n       \\<lbrakk>PO_refines R Ta Tc; s # b \\<in> beh Tc;\n        (s, t) \\<in> TS.trans Tc; ba \\<in> beh Ta;\n        (ba, s # b) \\<in> seq_lift R\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba\\<in>beh Ta.\n                            (ba, t # s # b) \\<in> seq_lift R", "apply (clarsimp simp add: PO_refines_def Image_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> init Tc;\n        init Tc \\<subseteq> {y. \\<exists>x\\<in>init Ta. (x, y) \\<in> R};\n        {R} TS.trans Ta, TS.trans Tc {> R}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba\\<in>beh Ta. (ba, [s]) \\<in> seq_lift R\n 2. \\<And>s b t ba.\n       \\<lbrakk>PO_refines R Ta Tc; s # b \\<in> beh Tc;\n        (s, t) \\<in> TS.trans Tc; ba \\<in> beh Ta;\n        (ba, s # b) \\<in> seq_lift R\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba\\<in>beh Ta.\n                            (ba, t # s # b) \\<in> seq_lift R", "apply (drule subsetD, auto)\n\n  \\<comment> \\<open>case: cons; first construct related abstract state\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s b t ba.\n       \\<lbrakk>PO_refines R Ta Tc; s # b \\<in> beh Tc;\n        (s, t) \\<in> TS.trans Tc; ba \\<in> beh Ta;\n        (ba, s # b) \\<in> seq_lift R\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba\\<in>beh Ta.\n                            (ba, t # s # b) \\<in> seq_lift R", "apply (erule sl_cons_right_invert, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s b t xs x.\n       \\<lbrakk>PO_refines R Ta Tc; s # b \\<in> beh Tc;\n        (s, t) \\<in> TS.trans Tc; x # xs \\<in> beh Ta;\n        (xs, b) \\<in> seq_lift R; (x, s) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba\\<in>beh Ta.\n                            (ba, t # s # b) \\<in> seq_lift R", "apply (rename_tac s bc s' ba t)\n  \\<comment> \\<open>now construct abstract transition\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s bc s' ba t.\n       \\<lbrakk>PO_refines R Ta Tc; s # bc \\<in> beh Tc;\n        (s, s') \\<in> TS.trans Tc; t # ba \\<in> beh Ta;\n        (ba, bc) \\<in> seq_lift R; (t, s) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba\\<in>beh Ta.\n                            (ba, s' # s # bc) \\<in> seq_lift R", "apply (auto simp add: PO_refines_def PO_rhoare_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s bc s' ba t.\n       \\<lbrakk>s # bc \\<in> beh Tc; (s, s') \\<in> TS.trans Tc;\n        t # ba \\<in> beh Ta; (ba, bc) \\<in> seq_lift R; (t, s) \\<in> R;\n        init Tc \\<subseteq> R `` init Ta;\n        R O TS.trans Tc \\<subseteq> TS.trans Ta O R\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba\\<in>beh Ta.\n                            (ba, s' # s # bc) \\<in> seq_lift R", "apply (thin_tac \"X \\<subseteq> Y\" for X Y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s bc s' ba t.\n       \\<lbrakk>s # bc \\<in> beh Tc; (s, s') \\<in> TS.trans Tc;\n        t # ba \\<in> beh Ta; (ba, bc) \\<in> seq_lift R; (t, s) \\<in> R;\n        R O TS.trans Tc \\<subseteq> TS.trans Ta O R\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba\\<in>beh Ta.\n                            (ba, s' # s # bc) \\<in> seq_lift R", "apply (drule subsetD, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Observation consistency of a relation is defined using a mediator \nfunction @{term \"pi\"} to abstract the concrete observation.  This allows us \nto also refine the observables as we move down a refinement branch.\n\\<close>"], ["", "definition \n  obs_consistent :: \n    \"[('s \\<times> 't) set, 'p \\<Rightarrow> 'o, ('s, 'o) spec, ('t, 'p) spec] \\<Rightarrow> bool\"\nwhere\n  \"obs_consistent R pi Sa Sc \\<equiv> (\\<forall>s t. (s, t) \\<in> R \\<longrightarrow> pi (obs Sc t) = obs Sa s)\""], ["", "lemma obs_consistent_refl [iff]: \"obs_consistent Id id S S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent Id id S S", "by (simp add: obs_consistent_def)"], ["", "lemma obs_consistent_trans [intro]: \n  \"\\<lbrakk> obs_consistent R1 pi1 S1 S2; obs_consistent R2 pi2 S2 S3 \\<rbrakk>\n  \\<Longrightarrow> obs_consistent (R1 O R2) (pi1 o pi2) S1 S3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>obs_consistent R1 pi1 S1 S2;\n     obs_consistent R2 pi2 S2 S3\\<rbrakk>\n    \\<Longrightarrow> obs_consistent (R1 O R2) (pi1 \\<circ> pi2) S1 S3", "by (auto simp add: obs_consistent_def)"], ["", "lemma obs_consistent_empty: \"obs_consistent {} pi Sa Sc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent {} pi Sa Sc", "by (auto simp add: obs_consistent_def)"], ["", "lemma obs_consistent_conj1 [intro]: \n  \"obs_consistent R pi Sa Sc \\<Longrightarrow> obs_consistent (R \\<inter> R') pi Sa Sc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent R pi Sa Sc \\<Longrightarrow>\n    obs_consistent (R \\<inter> R') pi Sa Sc", "by (auto simp add: obs_consistent_def)"], ["", "lemma obs_consistent_conj2 [intro]: \n  \"obs_consistent R pi Sa Sc \\<Longrightarrow> obs_consistent (R' \\<inter> R) pi Sa Sc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent R pi Sa Sc \\<Longrightarrow>\n    obs_consistent (R' \\<inter> R) pi Sa Sc", "by (auto simp add: obs_consistent_def)"], ["", "lemma obs_consistent_behaviours:\n  \"\\<lbrakk> obs_consistent R pi Sa Sc; bc \\<in> beh Sc; ba \\<in> beh Sa; (ba, bc) \\<in> seq_lift R\\<rbrakk>\n  \\<Longrightarrow> map pi (map (obs Sc) bc) = map (obs Sa) ba\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>obs_consistent R pi Sa Sc; bc \\<in> beh Sc; ba \\<in> beh Sa;\n     (ba, bc) \\<in> seq_lift R\\<rbrakk>\n    \\<Longrightarrow> map pi (map (obs Sc) bc) = map (obs Sa) ba", "by (erule seq_lift.induct) (auto simp add: obs_consistent_def)"], ["", "text \\<open>Definition of refinement proof obligations.\\<close>"], ["", "definition \n  refines :: \n    \"[('s \\<times> 't) set, 'p \\<Rightarrow> 'o, ('s, 'o) spec, ('t, 'p) spec] \\<Rightarrow> bool\" \nwhere\n  \"refines R pi Sa Sc \\<equiv> obs_consistent R pi Sa Sc \\<and> PO_refines R Sa Sc\""], ["", "lemmas refines_defs = \n  refines_def PO_refines_def"], ["", "lemma refinesI: \n  \"\\<lbrakk> PO_refines R Sa Sc; obs_consistent R pi Sa Sc \\<rbrakk>\n  \\<Longrightarrow> refines R pi Sa Sc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PO_refines R Sa Sc; obs_consistent R pi Sa Sc\\<rbrakk>\n    \\<Longrightarrow> refines R pi Sa Sc", "by (simp add: refines_def)"], ["", "lemma refinesE [elim]: \n  \"\\<lbrakk> refines R pi Sa Sc; \\<lbrakk> PO_refines R Sa Sc; obs_consistent R pi Sa Sc \\<rbrakk> \\<Longrightarrow> P \\<rbrakk>\n  \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>refines R pi Sa Sc;\n     \\<lbrakk>PO_refines R Sa Sc; obs_consistent R pi Sa Sc\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (simp add: refines_def)"], ["", "text \\<open>Reflexivity and transitivity of refinement.\\<close>"], ["", "lemma refinement_reflexive: \"refines Id id S S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines Id id S S", "by (auto simp add: refines_defs)"], ["", "lemma refinement_transitive: \n  \"\\<lbrakk> refines R1 pi1 S1 S2; refines R2 pi2 S2 S3 \\<rbrakk> \n  \\<Longrightarrow> refines (R1 O R2) (pi1 o pi2) S1 S3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>refines R1 pi1 S1 S2; refines R2 pi2 S2 S3\\<rbrakk>\n    \\<Longrightarrow> refines (R1 O R2) (pi1 \\<circ> pi2) S1 S3", "apply (auto simp add: refines_defs del: subsetI\n            intro: rhoare_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>obs_consistent R1 pi1 S1 S2; obs_consistent R2 pi2 S2 S3;\n     init S2 \\<subseteq> R1 `` init S1;\n     {R1} TS.trans S1, TS.trans S2 {> R1};\n     init S3 \\<subseteq> R2 `` init S2;\n     {R2} TS.trans S2, TS.trans S3 {> R2}\\<rbrakk>\n    \\<Longrightarrow> init S3 \\<subseteq> R2 `` R1 `` init S1", "apply (fastforce dest: Image_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Soundness of refinement for proving implementation\\<close>"], ["", "lemma observable_behaviour_refinement:\n  \"\\<lbrakk> refines R pi Sa Sc; bc \\<in> obeh Sc \\<rbrakk> \\<Longrightarrow> map pi bc \\<in> obeh Sa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>refines R pi Sa Sc; bc \\<in> obeh Sc\\<rbrakk>\n    \\<Longrightarrow> map pi bc \\<in> obeh Sa", "by (auto simp add: refines_def obeh_def image_def\n         dest!: behaviour_refinement obs_consistent_behaviours)"], ["", "theorem refinement_soundness: \n  \"refines R pi Sa Sc \\<Longrightarrow> implements pi Sa Sc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines R pi Sa Sc \\<Longrightarrow> implements pi Sa Sc", "by (auto simp add: implements_def \n         elim!: observable_behaviour_refinement)"], ["", "text \\<open>Extended versions of refinement proof rules including observations\\<close>"], ["", "lemmas Refinement_basic = refine_basic [THEN refinesI]"], ["", "lemmas Refinement_using_invariants = refine_using_invariants [THEN refinesI]"], ["", "lemma refines_reachable_strengthening:\n  \"refines R pi Sa Sc \\<Longrightarrow> refines (R \\<inter> reach Sa \\<times> reach Sc) pi Sa Sc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines R pi Sa Sc \\<Longrightarrow>\n    refines (R \\<inter> reach Sa \\<times> reach Sc) pi Sa Sc", "by (auto intro!: Refinement_using_invariants)"], ["", "text \\<open>Inhertitance of internal invariants through refinements\\<close>"], ["", "lemma INV_init_from_Refinement:\n  \"\\<lbrakk>refines R pi Sa Sc; Range R \\<subseteq> I\\<rbrakk> \\<Longrightarrow> init Sc \\<subseteq> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>refines R pi Sa Sc; Range R \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> init Sc \\<subseteq> I", "by (blast intro: INV_init_from_refinement)"], ["", "lemma INV_trans_from_Refinement:\n  \" \\<lbrakk>refines R pi Sa Sc; K \\<subseteq> Range R; Range R \\<subseteq> I\\<rbrakk> \\<Longrightarrow> {K} TS.trans Sc {> I}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>refines R pi Sa Sc; K \\<subseteq> Range R;\n     Range R \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> {K} TS.trans Sc {> I}", "by (blast intro: INV_trans_from_refinement)"], ["", "lemma INV_from_Refinement_basic: \n  \"\\<lbrakk> refines R pi Sa Sc; Range R \\<subseteq> I \\<rbrakk> \\<Longrightarrow> reach Sc \\<subseteq> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>refines R pi Sa Sc; Range R \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> reach Sc \\<subseteq> I", "by (rule INV_from_refinement) blast"], ["", "lemma INV_from_Refinement_using_invariants: \n  assumes \"refines R pi Sa Sc\" \"Range (R \\<inter> I \\<times> J) \\<subseteq> K\" \n          \"reach Sa \\<subseteq> I\" \"reach Sc \\<subseteq> J\" \n  shows \"reach Sc \\<subseteq> K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach Sc \\<subseteq> K", "proof (rule INV_from_Refinement_basic)"], ["proof (state)\ngoal (2 subgoals):\n 1. refines ?R ?pi ?Sa Sc\n 2. Range ?R \\<subseteq> K", "show \"refines (R \\<inter> reach Sa \\<times> reach Sc) pi Sa Sc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines (R \\<inter> reach Sa \\<times> reach Sc) pi Sa Sc", "using assms(1)"], ["proof (prove)\nusing this:\n  refines R pi Sa Sc\n\ngoal (1 subgoal):\n 1. refines (R \\<inter> reach Sa \\<times> reach Sc) pi Sa Sc", "by (rule refines_reachable_strengthening)"], ["proof (state)\nthis:\n  refines (R \\<inter> reach Sa \\<times> reach Sc) pi Sa Sc\n\ngoal (1 subgoal):\n 1. Range (R \\<inter> reach Sa \\<times> reach Sc) \\<subseteq> K", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Range (R \\<inter> reach Sa \\<times> reach Sc) \\<subseteq> K", "show \"Range (R \\<inter> reach Sa \\<times> reach Sc) \\<subseteq> K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Range (R \\<inter> reach Sa \\<times> reach Sc) \\<subseteq> K", "using assms(2-4)"], ["proof (prove)\nusing this:\n  Range (R \\<inter> I \\<times> J) \\<subseteq> K\n  reach Sa \\<subseteq> I\n  reach Sc \\<subseteq> J\n\ngoal (1 subgoal):\n 1. Range (R \\<inter> reach Sa \\<times> reach Sc) \\<subseteq> K", "by blast"], ["proof (state)\nthis:\n  Range (R \\<inter> reach Sa \\<times> reach Sc) \\<subseteq> K\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}