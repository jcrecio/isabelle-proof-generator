{"file_name": "/home/qj213/afp-2021-10-22/thys/Key_Agreement_Strong_Adversaries/dhlvl1.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Key_Agreement_Strong_Adversaries", "problem_names": ["lemma run_ended_not_None [elim]:\n  \"run_ended R \\<Longrightarrow> R = None \\<Longrightarrow> False\"", "lemmas l1_defs = \n  l1_def l1_init_def l1_trans_def\n  l1_learn_def\n  l1_step1_def l1_step2_def l1_step3_def l1_step4_def", "lemmas l1_nostep_defs =\n  l1_def l1_init_def l1_trans_def", "lemma l1_obs_id [simp]: \"obs l1 = id\"", "lemma run_ended_trans:\n  \"run_ended (progress s R) \\<Longrightarrow>\n   (s, s') \\<in> trans l1 \\<Longrightarrow>\n   run_ended (progress s' R)\"", "lemma can_signal_trans:\n  \"can_signal s' A B \\<Longrightarrow>\n  (s, s') \\<in> trans l1 \\<Longrightarrow>\n  can_signal s A B\"", "lemma l1_learn_refines_learn:\n  \"{R01s} s0_learn m, l1_learn m {>R01s}\"", "lemma l1_step1_refines_skip:\n  \"{R01s} Id, l1_step1 Ra A B {>R01s}\"", "lemma l1_step2_refines_skip:\n  \"{R01s} Id, l1_step2 Rb A B gnx {>R01s}\"", "lemma l1_step3_refines_add_secret_skip:\n  \"{R01s} s0_add_secret (Exp gny (NonceF (Ra$nx))) \\<union> Id, l1_step3 Ra A B gny {>R01s}\"", "lemma l1_step4_refines_add_secret_skip:\n  \"{R01s} s0_add_secret (Exp gnx (NonceF (Rb$ny))) \\<union> Id, l1_step4 Rb A B gnx {>R01s}\"", "lemmas l1_trans_refines_s0_trans = \n  l1_learn_refines_learn\n  l1_step1_refines_skip l1_step2_refines_skip \n  l1_step3_refines_add_secret_skip l1_step4_refines_add_secret_skip", "lemma l1_refines_init_s0 [iff]:\n  \"init l1 \\<subseteq> R01s `` (init s0)\"", "lemma l1_refines_trans_s0 [iff]:\n  \"{R01s} trans s0, trans l1 {> R01s}\"", "lemma obs_consistent_med01x [iff]: \n  \"obs_consistent R01s med01s s0 l1\"", "lemma l1s_refines_s0 [iff]: \n  \"refines \n     R01s\n     med01s s0 l1\"", "lemma  l1_implements_s0 [iff]: \"implements med01s s0 l1\"", "lemma l1_obs_secrecy [iff]: \"oreach l1 \\<subseteq> l1_secrecy\"", "lemma l1_secrecy [iff]: \"reach l1 \\<subseteq> l1_secrecy\"", "lemmas l1_inv1I = l1_inv1_def [THEN setc_def_to_intro, rule_format]", "lemmas l1_inv1E [elim] = l1_inv1_def [THEN setc_def_to_elim, rule_format]", "lemmas l1_inv1D = l1_inv1_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]", "lemma l1_inv1_init [iff]:\n  \"init l1 \\<subseteq> l1_inv1\"", "lemma l1_inv1_trans [iff]:\n  \"{l1_inv1} trans l1 {> l1_inv1}\"", "lemma PO_l1_inv1 [iff]: \"reach l1 \\<subseteq> l1_inv1\"", "lemmas l1_inv2I = l1_inv2_def [THEN setc_def_to_intro, rule_format]", "lemmas l1_inv2E [elim] = l1_inv2_def [THEN setc_def_to_elim, rule_format]", "lemmas l1_inv2D = l1_inv2_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]", "lemma l1_inv2_init [iff]:\n  \"init l1 \\<subseteq> l1_inv2\"", "lemma l1_inv2_trans [iff]:\n  \"{l1_inv2} trans l1 {> l1_inv2}\"", "lemma PO_l1_inv2 [iff]: \"reach l1 \\<subseteq> l1_inv2\"", "lemmas l1_inv3I = l1_inv3_def [THEN setc_def_to_intro, rule_format]", "lemmas l1_inv3E [elim] = l1_inv3_def [THEN setc_def_to_elim, rule_format]", "lemmas l1_inv3D = l1_inv3_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]", "lemma l1_inv3_derived: \"l1_inv1 \\<inter> l1_inv2 \\<subseteq> l1_inv3\"", "lemmas l1_inv4I = l1_inv4_def [THEN setc_def_to_intro, rule_format]", "lemmas l1_inv4E [elim] = l1_inv4_def [THEN setc_def_to_elim, rule_format]", "lemmas l1_inv4D = l1_inv4_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]", "lemma l1_inv4_init [iff]:\n  \"init l1 \\<subseteq> l1_inv4\"", "lemma l1_inv4_trans [iff]:\n  \"{l1_inv4} trans l1 {> l1_inv4}\"", "lemma PO_l1_inv4 [iff]: \"reach l1 \\<subseteq> l1_inv4\"", "lemmas l1_inv5I = l1_inv5_def [THEN setc_def_to_intro, rule_format]", "lemmas l1_inv5E [elim] = l1_inv5_def [THEN setc_def_to_elim, rule_format]", "lemmas l1_inv5D = l1_inv5_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]", "lemma l1_inv5_init [iff]:\n  \"init l1 \\<subseteq> l1_inv5\"", "lemma l1_inv5_trans [iff]:\n  \"{l1_inv5} trans l1 {> l1_inv5}\"", "lemma PO_l1_inv5 [iff]: \"reach l1 \\<subseteq> l1_inv5\"", "lemmas l1_inv6I = l1_inv6_def [THEN setc_def_to_intro, rule_format]", "lemmas l1_inv6E [elim] = l1_inv6_def [THEN setc_def_to_elim, rule_format]", "lemmas l1_inv6D = l1_inv6_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]", "lemma l1_inv6_derived:\n  \"l1_inv4 \\<inter> l1_inv5 \\<subseteq> l1_inv6\"", "lemma l1_learn_refines_a0_ia_skip_i:\n  \"{R01iai} Id, l1_learn m {>R01iai}\"", "lemma l1_step1_refines_a0i_skip_i:\n  \"{R01iai} Id, l1_step1 Ra A B {>R01iai}\"", "lemma l1_step2_refines_a0i_running_skip_i:\n  \"{R01iai} a0i_running A B (Exp gnx (NonceF (Rb$ny))) \\<union> Id, l1_step2 Rb A B gnx {>R01iai}\"", "lemma l1_step3_refines_a0i_commit_skip_i:\n  \"{R01iai \\<inter> (UNIV \\<times> l1_inv3)} \n     a0i_commit A B (Exp gny (NonceF (Ra$nx))) \\<union> Id, \n     l1_step3 Ra A B gny \n   {>R01iai}\"", "lemma l1_step4_refines_a0i_skip_i:\n  \"{R01iai} Id, l1_step4 Rb A B gnx {>R01iai}\"", "lemmas l1_trans_refines_a0i_trans_i = \n  l1_learn_refines_a0_ia_skip_i\n  l1_step1_refines_a0i_skip_i l1_step2_refines_a0i_running_skip_i\n  l1_step3_refines_a0i_commit_skip_i l1_step4_refines_a0i_skip_i", "lemma l1_refines_init_a0i_i [iff]:\n  \"init l1 \\<subseteq> R01iai `` (init a0i)\"", "lemma l1_refines_trans_a0i_i [iff]:\n  \"{R01iai \\<inter> (UNIV \\<times> (l1_inv1 \\<inter> l1_inv2))} trans a0i, trans l1 {> R01iai}\"", "lemma obs_consistent_med01iai [iff]: \n  \"obs_consistent R01iai med01iai a0i l1\"", "lemma l1_refines_a0i_i [iff]: \n  \"refines \n     (R01iai \\<inter> (reach a0i \\<times> (l1_inv1 \\<inter> l1_inv2)))\n     med01iai a0i l1\"", "lemma  l1_implements_a0i_i [iff]: \"implements med01iai a0i l1\"", "lemmas l1_iagreement_InitI = l1_iagreement_Init_def [THEN setc_def_to_intro, rule_format]", "lemmas l1_iagreement_InitE [elim] = l1_iagreement_Init_def [THEN setc_def_to_elim, rule_format]", "lemma l1_obs_iagreement_Init [iff]: \"oreach l1 \\<subseteq> l1_iagreement_Init\"", "lemma l1_iagreement_Init [iff]: \"reach l1 \\<subseteq> l1_iagreement_Init\"", "lemma l1_learn_refines_a0_ia_skip_r:\n  \"{R01iar} Id, l1_learn m {>R01iar}\"", "lemma l1_step1_refines_a0i_skip_r:\n  \"{R01iar} Id, l1_step1 Ra A B {>R01iar}\"", "lemma l1_step2_refines_a0i_skip_r:\n  \"{R01iar} Id, l1_step2 Rb A B gnx {>R01iar}\"", "lemma l1_step3_refines_a0i_running_skip_r:\n  \"{R01iar} a0i_running A B (Exp gny (NonceF (Ra$nx))) \\<union> Id, l1_step3 Ra A B gny {>R01iar}\"", "lemma l1_step4_refines_a0i_commit_skip_r:\n  \"{R01iar \\<inter> UNIV\\<times>l1_inv6} \n     a0i_commit A B (Exp gnx (NonceF (Rb$ny))) \\<union> Id, \n     l1_step4 Rb A B gnx \n   {>R01iar}\"", "lemmas l1_trans_refines_a0i_trans_r = \n  l1_learn_refines_a0_ia_skip_r\n  l1_step1_refines_a0i_skip_r l1_step2_refines_a0i_skip_r\n  l1_step3_refines_a0i_running_skip_r l1_step4_refines_a0i_commit_skip_r", "lemma l1_refines_init_a0i_r [iff]:\n  \"init l1 \\<subseteq> R01iar `` (init a0i)\"", "lemma l1_refines_trans_a0i_r [iff]:\n  \"{R01iar \\<inter> (UNIV \\<times> (l1_inv4 \\<inter> l1_inv5))} trans a0i, trans l1 {> R01iar}\"", "lemma obs_consistent_med01iar [iff]: \n  \"obs_consistent R01iar med01iar a0i l1\"", "lemma l1_refines_a0i_r [iff]: \n  \"refines \n     (R01iar \\<inter> (reach a0i \\<times> (l1_inv4 \\<inter> l1_inv5)))\n     med01iar a0i l1\"", "lemma  l1_implements_a0i_r [iff]: \"implements med01iar a0i l1\"", "lemmas l1_iagreement_RespI = l1_iagreement_Resp_def [THEN setc_def_to_intro, rule_format]", "lemmas l1_iagreement_RespE [elim] = l1_iagreement_Resp_def [THEN setc_def_to_elim, rule_format]", "lemma l1_obs_iagreement_Resp [iff]: \"oreach l1 \\<subseteq> l1_iagreement_Resp\"", "lemma l1_iagreement_Resp [iff]: \"reach l1 \\<subseteq> l1_iagreement_Resp\""], "translations": [["", "lemma run_ended_not_None [elim]:\n  \"run_ended R \\<Longrightarrow> R = None \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>run_ended R; R = None\\<rbrakk> \\<Longrightarrow> False", "by (fast dest: in_progress_Some)"], ["", "text \\<open>@{term \"test_ended s\"} $\\longleftrightarrow$ the test run has ended in @{term \"s\"}.\\<close>"], ["", "abbreviation\n  test_ended :: \"'a l1_state_scheme \\<Rightarrow> bool\"\nwhere\n  \"test_ended s \\<equiv> run_ended (progress s test)\""], ["", "text \\<open>A run can emit signals if it involves the same agents as the test run, and if the test run \n  has not ended yet.\\<close>"], ["", "definition\n  can_signal :: \"'a l1_state_scheme \\<Rightarrow> agent \\<Rightarrow> agent \\<Rightarrow> bool\"\nwhere\n  \"can_signal s A B \\<equiv>\n  ((A = test_owner \\<and> B = test_partner) \\<or> (B = test_owner \\<and> A = test_partner)) \\<and>\n  \\<not> test_ended s\""], ["", "text \\<open>Events.\\<close>"], ["", "definition\n  l1_learn :: \"msg \\<Rightarrow> ('a l1_state_scheme * 'a l1_state_scheme) set\"\nwhere\n  \"l1_learn m \\<equiv> {(s,s').\n    \\<comment> \\<open>guard\\<close>\n    synth (analz (insert m (ik s))) \\<inter> (secret s) = {}  \\<and>\n    \\<comment> \\<open>action\\<close>\n    s' = s \\<lparr>ik := ik s \\<union> {m}\\<rparr>\n  }\""], ["", "text \\<open>Potocol events.\\<close>"], ["", "text \\<open>\n\\begin{itemize}\n\\item step 1: create @{term \"Ra\"}, @{term \"A\"} generates @{term \"nx\"},\n  computes $@{term \"g\"}^@{term \"nx\"}$\n\\item step 2: create @{term \"Rb\"}, @{term \"B\"} reads $@{term \"g\"}^@{term \"nx\"}$ insecurely,\n  generates @{term \"ny\"}, computes $@{term \"g\"}^@{term \"ny\"}$,\n  computes $@{term \"g\"}^@{term \"nx*ny\"}$,\n  emits a running signal for @{term \"Init\"}, $@{term \"g\"}^@{term \"nx*ny\"}$\n\\item step 3: @{term \"A\"} reads $@{term \"g\"}^@{term \"ny\"}$ and $@{term \"g\"}^@{term \"nx\"}$\n  authentically,\n  computes $@{term \"g\"}^@{term \"ny*nx\"}$, emits a commit signal for @{term \"Init\"},\n  $@{term \"g\"}^@{term \"ny*nx\"}$, a running signal for @{term \"Resp\"}, $@{term \"g\"}^@{term \"ny*nx\"}$,\n  declares the secret $@{term \"g\"}^@{term \"ny*nx\"}$\n\\item step 4: @{term \"B\"} reads $@{term \"g\"}^@{term \"nx\"}$ and $@{term \"g\"}^@{term \"ny\"}$\n  authentically,\n  emits a commit signal for @{term \"Resp\"}, $@{term \"g\"}^@{term \"nx*ny\"}$,\n  declares the secret $@{term \"g\"}^@{term \"nx*ny\"}$\n\\end{itemize}\n\\<close>"], ["", "definition\n  l1_step1 :: \"rid_t \\<Rightarrow> agent \\<Rightarrow> agent \\<Rightarrow> ('a l1_state_scheme * 'a l1_state_scheme) set\"\nwhere\n  \"l1_step1 Ra A B \\<equiv> {(s, s').\n    \\<comment> \\<open>guards:\\<close>\n    Ra \\<notin> dom (progress s) \\<and>\n    guessed_runs Ra = \\<lparr>role=Init, owner=A, partner=B\\<rparr> \\<and>\n    \\<comment> \\<open>actions:\\<close>\n    s' = s\\<lparr>\n      progress := (progress s)(Ra \\<mapsto> {xnx, xgnx})\n      \\<rparr>\n  }\""], ["", "definition\n  l1_step2 :: \"rid_t \\<Rightarrow> agent \\<Rightarrow> agent \\<Rightarrow> msg \\<Rightarrow> ('a l1_state_scheme * 'a l1_state_scheme) set\"\nwhere\n  \"l1_step2 Rb A B gnx \\<equiv> {(s, s').\n    \\<comment> \\<open>guards:\\<close>\n    guessed_runs Rb = \\<lparr>role=Resp, owner=B, partner=A\\<rparr> \\<and>\n    Rb \\<notin> dom (progress s) \\<and>\n    guessed_frame Rb xgnx = Some gnx \\<and>\n    guessed_frame Rb xsk = Some (Exp gnx (NonceF (Rb$ny))) \\<and>\n    \\<comment> \\<open>actions:\\<close>\n    s' = s\\<lparr> progress := (progress s)(Rb \\<mapsto> {xny, xgny, xgnx, xsk}),\n            signalsInit := if can_signal s A B then\n                          addSignal (signalsInit s) (Running A B (Exp gnx (NonceF (Rb$ny))))\n                       else\n                          signalsInit s\n          \\<rparr>\n  }\""], ["", "definition\n  l1_step3 :: \"rid_t \\<Rightarrow> agent \\<Rightarrow> agent \\<Rightarrow> msg \\<Rightarrow> ('a l1_state_scheme * 'a l1_state_scheme) set\"\nwhere\n  \"l1_step3 Ra A B gny \\<equiv> {(s, s').\n    \\<comment> \\<open>guards:\\<close>\n    guessed_runs Ra = \\<lparr>role=Init, owner=A, partner=B\\<rparr> \\<and>\n    progress s Ra = Some {xnx, xgnx} \\<and>\n    guessed_frame Ra xgny = Some gny \\<and>\n    guessed_frame Ra xsk = Some (Exp gny (NonceF (Ra$nx))) \\<and>\n    (can_signal s A B \\<longrightarrow> \\<comment> \\<open>authentication guard\\<close>\n      (\\<exists> Rb. guessed_runs Rb = \\<lparr>role=Resp, owner=B, partner=A\\<rparr> \\<and>\n             in_progressS (progress s Rb) {xny, xgnx, xgny, xsk} \\<and>\n             guessed_frame Rb xgny = Some gny \\<and>\n             guessed_frame Rb xgnx = Some (Exp Gen (NonceF (Ra$nx))))) \\<and>\n    (Ra = test \\<longrightarrow> Exp gny (NonceF (Ra$nx)) \\<notin> synth (analz (ik s))) \\<and>\n\n    \\<comment> \\<open>actions:\\<close>\n    s' = s\\<lparr> progress := (progress s)(Ra \\<mapsto> {xnx, xgnx, xgny, xsk, xEnd}),\n            secret := {x. x = Exp gny (NonceF (Ra$nx)) \\<and> Ra = test} \\<union> secret s,\n            signalsInit := if can_signal s A B then\n                         addSignal (signalsInit s) (Commit A B (Exp gny (NonceF (Ra$nx))))\n                       else\n                         signalsInit s,\n            signalsResp := if can_signal s A B then\n                         addSignal (signalsResp s) (Running A B (Exp gny (NonceF (Ra$nx))))\n                       else\n                         signalsResp s\n\n          \\<rparr>\n  }\""], ["", "definition\n  l1_step4 :: \"rid_t \\<Rightarrow> agent \\<Rightarrow> agent \\<Rightarrow> msg \\<Rightarrow> ('a l1_state_scheme * 'a l1_state_scheme) set\"\nwhere\n  \"l1_step4 Rb A B gnx \\<equiv> {(s, s').\n    \\<comment> \\<open>guards:\\<close>\n    guessed_runs Rb = \\<lparr>role=Resp, owner=B, partner=A\\<rparr> \\<and>\n    progress s Rb = Some {xny, xgnx, xgny, xsk} \\<and>\n    guessed_frame Rb xgnx = Some gnx \\<and>\n    (can_signal s A B \\<longrightarrow> \\<comment> \\<open>authentication guard\\<close>\n      (\\<exists> Ra. guessed_runs Ra = \\<lparr>role=Init, owner=A, partner=B\\<rparr> \\<and>\n             in_progressS (progress s Ra) {xnx, xgnx, xgny, xsk, xEnd} \\<and>\n             guessed_frame Ra xgnx = Some gnx \\<and>\n             guessed_frame Ra xgny = Some (Exp Gen (NonceF (Rb$ny))))) \\<and>\n    (Rb = test \\<longrightarrow> Exp gnx (NonceF (Rb$ny)) \\<notin> synth (analz (ik s))) \\<and>\n\n    \\<comment> \\<open>actions:\\<close>\n    s' = s\\<lparr> progress := (progress s)(Rb \\<mapsto> {xny, xgnx, xgny, xsk, xEnd}),\n            secret := {x. x = Exp gnx (NonceF (Rb$ny)) \\<and> Rb = test} \\<union> secret s,\n            signalsResp := if can_signal s A B then\n                             addSignal (signalsResp s) (Commit A B (Exp gnx (NonceF (Rb$ny))))\n                           else\n                             signalsResp s\n          \\<rparr>\n  }\""], ["", "text \\<open>Specification.\\<close>"], ["", "definition \n  l1_init :: \"l1_state set\"\nwhere\n  \"l1_init \\<equiv> { \\<lparr>\n    ik = {},\n    secret = {},\n    progress = Map.empty,\n    signalsInit = \\<lambda>x. 0,\n    signalsResp = \\<lambda>x. 0\n    \\<rparr> }\""], ["", "definition \n  l1_trans :: \"('a l1_state_scheme * 'a l1_state_scheme) set\" where\n  \"l1_trans \\<equiv> (\\<Union>m Ra Rb A B x.\n     l1_step1 Ra A B \\<union>\n     l1_step2 Rb A B x \\<union>\n     l1_step3 Ra A B x \\<union>\n     l1_step4 Rb A B x \\<union>\n     l1_learn m \\<union>\n     Id\n  )\""], ["", "definition \n  l1 :: \"(l1_state, l1_obs) spec\" where\n  \"l1 \\<equiv> \\<lparr>\n    init = l1_init,\n    trans = l1_trans,\n    obs = id\n  \\<rparr>\""], ["", "lemmas l1_defs = \n  l1_def l1_init_def l1_trans_def\n  l1_learn_def\n  l1_step1_def l1_step2_def l1_step3_def l1_step4_def"], ["", "lemmas l1_nostep_defs =\n  l1_def l1_init_def l1_trans_def"], ["", "lemma l1_obs_id [simp]: \"obs l1 = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs l1 = id", "by (simp add: l1_def)"], ["", "lemma run_ended_trans:\n  \"run_ended (progress s R) \\<Longrightarrow>\n   (s, s') \\<in> trans l1 \\<Longrightarrow>\n   run_ended (progress s' R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>run_ended (progress s R); (s, s') \\<in> TS.trans l1\\<rbrakk>\n    \\<Longrightarrow> run_ended (progress s' R)", "apply (auto simp add: l1_nostep_defs)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xb xc.\n       \\<lbrakk>run_ended (progress s R);\n        (s, s') \\<in> l1_step1 x xb xc\\<rbrakk>\n       \\<Longrightarrow> run_ended (progress s' R)\n 2. \\<And>xa xb xc xd.\n       \\<lbrakk>run_ended (progress s R);\n        (s, s') \\<in> l1_step2 xa xb xc xd\\<rbrakk>\n       \\<Longrightarrow> run_ended (progress s' R)\n 3. \\<And>x xb xc xd.\n       \\<lbrakk>run_ended (progress s R);\n        (s, s') \\<in> l1_step3 x xb xc xd\\<rbrakk>\n       \\<Longrightarrow> run_ended (progress s' R)\n 4. \\<And>xa xb xc xd.\n       \\<lbrakk>run_ended (progress s R);\n        (s, s') \\<in> l1_step4 xa xb xc xd\\<rbrakk>\n       \\<Longrightarrow> run_ended (progress s' R)\n 5. \\<And>x.\n       \\<lbrakk>run_ended (progress s R); (s, s') \\<in> l1_learn x\\<rbrakk>\n       \\<Longrightarrow> run_ended (progress s' R)", "apply (auto simp add: l1_defs ik_dy_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma can_signal_trans:\n  \"can_signal s' A B \\<Longrightarrow>\n  (s, s') \\<in> trans l1 \\<Longrightarrow>\n  can_signal s A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>can_signal s' A B; (s, s') \\<in> TS.trans l1\\<rbrakk>\n    \\<Longrightarrow> can_signal s A B", "by (auto simp add: can_signal_def run_ended_trans)"], ["", "(**************************************************************************************************)"], ["", "subsection \\<open>Refinement: secrecy\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>Mediator function.\\<close>"], ["", "definition \n  med01s :: \"l1_obs \\<Rightarrow> s0_obs\"\nwhere\n  \"med01s t \\<equiv> \\<lparr> ik = ik t, secret = secret t \\<rparr>\""], ["", "text \\<open>Relation between states.\\<close>"], ["", "definition\n  R01s :: \"(s0_state * l1_state) set\"\nwhere\n  \"R01s \\<equiv> {(s,s').\n    s = \\<lparr>ik = ik s', secret = secret s'\\<rparr>\n    }\""], ["", "text \\<open>Protocol independent events.\\<close>"], ["", "lemma l1_learn_refines_learn:\n  \"{R01s} s0_learn m, l1_learn m {>R01s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01s} s0_learn m, l1_learn m {> R01s}", "apply (simp add: PO_rhoare_defs R01s_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, z).\n     \\<exists>y.\n        x = \\<lparr>ik = ik y, secret = secret y\\<rparr> \\<and>\n        (y, z) \\<in> l1_learn m}\n    \\<subseteq> {(x, z).\n                 (x, \\<lparr>ik = ik z, secret = secret z\\<rparr>)\n                 \\<in> s0_learn m}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b y.\n       (y, b) \\<in> l1_learn m \\<Longrightarrow>\n       (\\<lparr>ik = ik y, secret = secret y\\<rparr>,\n        \\<lparr>ik = ik b, secret = secret b\\<rparr>)\n       \\<in> s0_learn m", "apply (simp add: l1_defs s0_defs s0_secrecy_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Protocol events.\\<close>"], ["", "lemma l1_step1_refines_skip:\n  \"{R01s} Id, l1_step1 Ra A B {>R01s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01s} Id, l1_step1 Ra A B {> R01s}", "by (auto simp add: PO_rhoare_defs R01s_def l1_step1_def)"], ["", "lemma l1_step2_refines_skip:\n  \"{R01s} Id, l1_step2 Rb A B gnx {>R01s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01s} Id, l1_step2 Rb A B gnx {> R01s}", "apply (auto simp add: PO_rhoare_defs R01s_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l1_step2 Rb A B gnx; x \\<in> ik y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ik b\n 2. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l1_step2 Rb A B gnx; x \\<in> ik b\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ik y\n 3. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l1_step2 Rb A B gnx; x \\<in> secret y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> secret b\n 4. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l1_step2 Rb A B gnx; x \\<in> secret b\\<rbrakk>\n       \\<Longrightarrow> x \\<in> secret y", "apply (auto simp add: l1_step2_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma l1_step3_refines_add_secret_skip:\n  \"{R01s} s0_add_secret (Exp gny (NonceF (Ra$nx))) \\<union> Id, l1_step3 Ra A B gny {>R01s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01s} (s0_add_secret\n             (Exp gny\n               (NonceF (Ra $ nx))))\\<^sup>=, l1_step3 Ra A B gny {> R01s}", "apply (auto simp add: PO_rhoare_defs R01s_def s0_add_secret_def)"], ["proof (prove)\ngoal (24 subgoals):\n 1. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l1_step3 Ra A B gny;\n        Exp gny (NonceF (Ra $ nx)) \\<in> synth (analz (ik y));\n        x \\<in> ik y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ik b\n 2. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l1_step3 Ra A B gny;\n        Exp gny (NonceF (Ra $ nx)) \\<in> synth (analz (ik y));\n        x \\<in> ik b\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ik y\n 3. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l1_step3 Ra A B gny;\n        Exp gny (NonceF (Ra $ nx)) \\<in> synth (analz (ik y));\n        x \\<in> secret y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> secret b\n 4. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l1_step3 Ra A B gny;\n        Exp gny (NonceF (Ra $ nx)) \\<in> synth (analz (ik y));\n        x \\<in> secret b\\<rbrakk>\n       \\<Longrightarrow> x \\<in> secret y\n 5. \\<And>b y x xa.\n       \\<lbrakk>(y, b) \\<in> l1_step3 Ra A B gny; x \\<in> ik y;\n        x \\<notin> ik b; xa \\<in> ik b\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> ik y\n 6. \\<And>b y x xa.\n       \\<lbrakk>(y, b) \\<in> l1_step3 Ra A B gny; x \\<in> ik y;\n        x \\<notin> ik b; xa \\<in> ik y\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> ik b\n 7. \\<And>b y x xa.\n       \\<lbrakk>(y, b) \\<in> l1_step3 Ra A B gny; x \\<in> ik y;\n        x \\<notin> ik b; xa \\<in> secret b; xa \\<notin> secret y\\<rbrakk>\n       \\<Longrightarrow> xa = Exp gny (NonceF (Ra $ nx))\n 8. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l1_step3 Ra A B gny; x \\<in> ik y;\n        x \\<notin> ik b\\<rbrakk>\n       \\<Longrightarrow> Exp gny (NonceF (Ra $ nx)) \\<in> secret b\n 9. \\<And>b y x xa.\n       \\<lbrakk>(y, b) \\<in> l1_step3 Ra A B gny; x \\<in> ik y;\n        x \\<notin> ik b; xa \\<in> secret y\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> secret b\n 10. \\<And>b y x xa.\n        \\<lbrakk>(y, b) \\<in> l1_step3 Ra A B gny; x \\<in> ik b;\n         x \\<notin> ik y; xa \\<in> ik b\\<rbrakk>\n        \\<Longrightarrow> xa \\<in> ik y\nA total of 24 subgoals...", "apply (auto simp add: l1_step3_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma l1_step4_refines_add_secret_skip:\n  \"{R01s} s0_add_secret (Exp gnx (NonceF (Rb$ny))) \\<union> Id, l1_step4 Rb A B gnx {>R01s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01s} (s0_add_secret\n             (Exp gnx\n               (NonceF (Rb $ ny))))\\<^sup>=, l1_step4 Rb A B gnx {> R01s}", "apply (auto simp add: PO_rhoare_defs R01s_def s0_add_secret_def)"], ["proof (prove)\ngoal (24 subgoals):\n 1. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l1_step4 Rb A B gnx;\n        Exp gnx (NonceF (Rb $ ny)) \\<in> synth (analz (ik y));\n        x \\<in> ik y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ik b\n 2. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l1_step4 Rb A B gnx;\n        Exp gnx (NonceF (Rb $ ny)) \\<in> synth (analz (ik y));\n        x \\<in> ik b\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ik y\n 3. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l1_step4 Rb A B gnx;\n        Exp gnx (NonceF (Rb $ ny)) \\<in> synth (analz (ik y));\n        x \\<in> secret y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> secret b\n 4. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l1_step4 Rb A B gnx;\n        Exp gnx (NonceF (Rb $ ny)) \\<in> synth (analz (ik y));\n        x \\<in> secret b\\<rbrakk>\n       \\<Longrightarrow> x \\<in> secret y\n 5. \\<And>b y x xa.\n       \\<lbrakk>(y, b) \\<in> l1_step4 Rb A B gnx; x \\<in> ik y;\n        x \\<notin> ik b; xa \\<in> ik b\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> ik y\n 6. \\<And>b y x xa.\n       \\<lbrakk>(y, b) \\<in> l1_step4 Rb A B gnx; x \\<in> ik y;\n        x \\<notin> ik b; xa \\<in> ik y\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> ik b\n 7. \\<And>b y x xa.\n       \\<lbrakk>(y, b) \\<in> l1_step4 Rb A B gnx; x \\<in> ik y;\n        x \\<notin> ik b; xa \\<in> secret b; xa \\<notin> secret y\\<rbrakk>\n       \\<Longrightarrow> xa = Exp gnx (NonceF (Rb $ ny))\n 8. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l1_step4 Rb A B gnx; x \\<in> ik y;\n        x \\<notin> ik b\\<rbrakk>\n       \\<Longrightarrow> Exp gnx (NonceF (Rb $ ny)) \\<in> secret b\n 9. \\<And>b y x xa.\n       \\<lbrakk>(y, b) \\<in> l1_step4 Rb A B gnx; x \\<in> ik y;\n        x \\<notin> ik b; xa \\<in> secret y\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> secret b\n 10. \\<And>b y x xa.\n        \\<lbrakk>(y, b) \\<in> l1_step4 Rb A B gnx; x \\<in> ik b;\n         x \\<notin> ik y; xa \\<in> ik b\\<rbrakk>\n        \\<Longrightarrow> xa \\<in> ik y\nA total of 24 subgoals...", "apply (auto simp add: l1_step4_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Refinement proof.\\<close>"], ["", "lemmas l1_trans_refines_s0_trans = \n  l1_learn_refines_learn\n  l1_step1_refines_skip l1_step2_refines_skip \n  l1_step3_refines_add_secret_skip l1_step4_refines_add_secret_skip"], ["", "lemma l1_refines_init_s0 [iff]:\n  \"init l1 \\<subseteq> R01s `` (init s0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init l1 \\<subseteq> R01s `` init s0", "by (auto simp add: R01s_def s0_defs l1_defs s0_secrecy_def)"], ["", "lemma l1_refines_trans_s0 [iff]:\n  \"{R01s} trans s0, trans l1 {> R01s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01s} TS.trans s0, TS.trans l1 {> R01s}", "by (auto simp add: s0_def l1_def s0_trans_def l1_trans_def \n         intro: l1_trans_refines_s0_trans)"], ["", "lemma obs_consistent_med01x [iff]: \n  \"obs_consistent R01s med01s s0 l1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent R01s med01s s0 l1", "by (auto simp add: obs_consistent_def R01s_def med01s_def)"], ["", "text \\<open>Refinement result.\\<close>"], ["", "lemma l1s_refines_s0 [iff]: \n  \"refines \n     R01s\n     med01s s0 l1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines R01s med01s s0 l1", "by (auto simp add:refines_def PO_refines_def)"], ["", "lemma  l1_implements_s0 [iff]: \"implements med01s s0 l1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements med01s s0 l1", "by (rule refinement_soundness) (fast)"], ["", "(**************************************************************************************************)"], ["", "subsection \\<open>Derived invariants: secrecy\\<close>"], ["", "(**************************************************************************************************)"], ["", "abbreviation \"l1_secrecy \\<equiv> s0_secrecy\""], ["", "lemma l1_obs_secrecy [iff]: \"oreach l1 \\<subseteq> l1_secrecy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oreach l1 \\<subseteq> l1_secrecy", "apply (rule external_invariant_translation \n         [OF s0_obs_secrecy _ l1_implements_s0])"], ["proof (prove)\ngoal (1 subgoal):\n 1. med01s -` l1_secrecy \\<subseteq> l1_secrecy", "apply (auto simp add: med01s_def s0_secrecy_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma l1_secrecy [iff]: \"reach l1 \\<subseteq> l1_secrecy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l1 \\<subseteq> l1_secrecy", "by (rule external_to_internal_invariant [OF l1_obs_secrecy], auto)"], ["", "(**************************************************************************************************)"], ["", "subsection \\<open>Invariants: @{term \"Init\"} authenticates @{term \"Resp\"}\\<close>"], ["", "(**************************************************************************************************)"], ["", "subsubsection \\<open>inv1\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>If an initiator commit signal exists for $(@{term \"g\"}^@{term \"ny\"})^@{term \"Ra$nx\"}$\n  then @{term \"Ra\"} is\n  @{term \"Init\"}, has passed step 3, and has \\<open>(g^ny)^(Ra$nx)\\<close> as the key in its frame.\\<close>"], ["", "definition\n  l1_inv1 :: \"l1_state set\"\nwhere\n  \"l1_inv1 \\<equiv> {s. \\<forall> Ra A B gny.\n    signalsInit s (Commit A B (Exp gny (NonceF (Ra$nx)))) > 0 \\<longrightarrow>\n      guessed_runs Ra = \\<lparr>role=Init, owner=A, partner=B\\<rparr> \\<and>\n      progress s Ra = Some {xnx, xgnx, xgny, xsk, xEnd} \\<and>\n      guessed_frame Ra xsk = Some (Exp gny (NonceF (Ra$nx)))\n   }\""], ["", "lemmas l1_inv1I = l1_inv1_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas l1_inv1E [elim] = l1_inv1_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas l1_inv1D = l1_inv1_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]"], ["", "lemma l1_inv1_init [iff]:\n  \"init l1 \\<subseteq> l1_inv1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init l1 \\<subseteq> l1_inv1", "by (auto simp add: l1_def l1_init_def l1_inv1_def)"], ["", "lemma l1_inv1_trans [iff]:\n  \"{l1_inv1} trans l1 {> l1_inv1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l1_inv1} TS.trans l1 {> l1_inv1}", "apply (auto simp add: PO_hoare_defs l1_nostep_defs intro!: l1_inv1I)"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>x Ra A B gny xa xb xd xe.\n       \\<lbrakk>0 < signalsInit x (Commit A B (Exp gny (NonceF (Ra $ nx))));\n        xa \\<in> l1_inv1; (xa, x) \\<in> l1_step1 xb xd xe\\<rbrakk>\n       \\<Longrightarrow> guessed_runs Ra =\n                         \\<lparr>role = Init, owner = A, partner = B\\<rparr>\n 2. \\<And>x Ra A B gny xa xb xd xe.\n       \\<lbrakk>0 < signalsInit x (Commit A B (Exp gny (NonceF (Ra $ nx))));\n        xa \\<in> l1_inv1; (xa, x) \\<in> l1_step1 xb xd xe\\<rbrakk>\n       \\<Longrightarrow> progress x Ra = Some {xnx, xgnx, xgny, xsk, xEnd}\n 3. \\<And>x Ra A B gny xa xb xd xe.\n       \\<lbrakk>0 < signalsInit x (Commit A B (Exp gny (NonceF (Ra $ nx))));\n        xa \\<in> l1_inv1; (xa, x) \\<in> l1_step1 xb xd xe\\<rbrakk>\n       \\<Longrightarrow> guessed_frame Ra xsk =\n                         Some (Exp gny (NonceF (Ra $ nx)))\n 4. \\<And>x Ra A B gny xa xc xd xe xf.\n       \\<lbrakk>0 < signalsInit x (Commit A B (Exp gny (NonceF (Ra $ nx))));\n        xa \\<in> l1_inv1; (xa, x) \\<in> l1_step2 xc xd xe xf\\<rbrakk>\n       \\<Longrightarrow> guessed_runs Ra =\n                         \\<lparr>role = Init, owner = A, partner = B\\<rparr>\n 5. \\<And>x Ra A B gny xa xc xd xe xf.\n       \\<lbrakk>0 < signalsInit x (Commit A B (Exp gny (NonceF (Ra $ nx))));\n        xa \\<in> l1_inv1; (xa, x) \\<in> l1_step2 xc xd xe xf\\<rbrakk>\n       \\<Longrightarrow> progress x Ra = Some {xnx, xgnx, xgny, xsk, xEnd}\n 6. \\<And>x Ra A B gny xa xc xd xe xf.\n       \\<lbrakk>0 < signalsInit x (Commit A B (Exp gny (NonceF (Ra $ nx))));\n        xa \\<in> l1_inv1; (xa, x) \\<in> l1_step2 xc xd xe xf\\<rbrakk>\n       \\<Longrightarrow> guessed_frame Ra xsk =\n                         Some (Exp gny (NonceF (Ra $ nx)))\n 7. \\<And>x Ra A B gny xa xb xd xe xf.\n       \\<lbrakk>0 < signalsInit x (Commit A B (Exp gny (NonceF (Ra $ nx))));\n        xa \\<in> l1_inv1; (xa, x) \\<in> l1_step3 xb xd xe xf\\<rbrakk>\n       \\<Longrightarrow> guessed_runs Ra =\n                         \\<lparr>role = Init, owner = A, partner = B\\<rparr>\n 8. \\<And>x Ra A B gny xa xb xd xe xf.\n       \\<lbrakk>0 < signalsInit x (Commit A B (Exp gny (NonceF (Ra $ nx))));\n        xa \\<in> l1_inv1; (xa, x) \\<in> l1_step3 xb xd xe xf\\<rbrakk>\n       \\<Longrightarrow> progress x Ra = Some {xnx, xgnx, xgny, xsk, xEnd}\n 9. \\<And>x Ra A B gny xa xb xd xe xf.\n       \\<lbrakk>0 < signalsInit x (Commit A B (Exp gny (NonceF (Ra $ nx))));\n        xa \\<in> l1_inv1; (xa, x) \\<in> l1_step3 xb xd xe xf\\<rbrakk>\n       \\<Longrightarrow> guessed_frame Ra xsk =\n                         Some (Exp gny (NonceF (Ra $ nx)))\n 10. \\<And>x Ra A B gny xa xc xd xe xf.\n        \\<lbrakk>0 < signalsInit x\n                      (Commit A B (Exp gny (NonceF (Ra $ nx))));\n         xa \\<in> l1_inv1; (xa, x) \\<in> l1_step4 xc xd xe xf\\<rbrakk>\n        \\<Longrightarrow> guessed_runs Ra =\n                          \\<lparr>role = Init, owner = A,\n                             partner = B\\<rparr>\nA total of 15 subgoals...", "apply (auto simp add: l1_defs ik_dy_def l1_inv1_def dest: Exp_Exp_Gen_inj2 [OF sym])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_l1_inv1 [iff]: \"reach l1 \\<subseteq> l1_inv1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l1 \\<subseteq> l1_inv1", "by (rule inv_rule_basic) (auto)"], ["", "subsubsection \\<open>inv2\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>If a @{term \"Resp\"} run @{term \"Rb\"} has passed step 2 then\n      (if possible) an initiator running signal has been emitted.\\<close>"], ["", "definition\n  l1_inv2 :: \"l1_state set\"\nwhere\n  \"l1_inv2 \\<equiv> {s. \\<forall> gnx A B Rb.\n    guessed_runs Rb = \\<lparr>role=Resp, owner=B, partner=A\\<rparr> \\<longrightarrow>\n    in_progressS (progress s Rb) {xny, xgnx, xgny, xsk} \\<longrightarrow>\n    guessed_frame Rb xgnx = Some gnx \\<longrightarrow>\n    can_signal s A B \\<longrightarrow>\n      signalsInit s (Running A B (Exp gnx (NonceF (Rb$ny)))) > 0\n  }\""], ["", "lemmas l1_inv2I = l1_inv2_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas l1_inv2E [elim] = l1_inv2_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas l1_inv2D = l1_inv2_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]"], ["", "lemma l1_inv2_init [iff]:\n  \"init l1 \\<subseteq> l1_inv2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init l1 \\<subseteq> l1_inv2", "by (auto simp add: l1_def l1_init_def l1_inv2_def)"], ["", "lemma l1_inv2_trans [iff]:\n  \"{l1_inv2} trans l1 {> l1_inv2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l1_inv2} TS.trans l1 {> l1_inv2}", "apply (auto simp add: PO_hoare_defs intro!: l1_inv2I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x gnx A B Rb xa.\n       \\<lbrakk>guessed_runs Rb =\n                \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        in_progressS (progress x Rb) {xny, xgnx, xgny, xsk};\n        guessed_frame Rb xgnx = Some gnx; can_signal x A B;\n        xa \\<in> l1_inv2; (xa, x) \\<in> TS.trans l1\\<rbrakk>\n       \\<Longrightarrow> 0 < signalsInit x\n                              (Running A B (Exp gnx (NonceF (Rb $ ny))))", "apply (drule can_signal_trans, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x gnx A B Rb xa.\n       \\<lbrakk>guessed_runs Rb =\n                \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        in_progressS (progress x Rb) {xny, xgnx, xgny, xsk};\n        guessed_frame Rb xgnx = Some gnx; xa \\<in> l1_inv2;\n        (xa, x) \\<in> TS.trans l1; can_signal xa A B\\<rbrakk>\n       \\<Longrightarrow> 0 < signalsInit x\n                              (Running A B (Exp gnx (NonceF (Rb $ ny))))", "apply (auto simp add: l1_nostep_defs)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x gnx A B Rb xa xb xd xe.\n       \\<lbrakk>guessed_runs Rb =\n                \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        in_progressS (progress x Rb) {xny, xgnx, xgny, xsk};\n        guessed_frame Rb xgnx = Some gnx; xa \\<in> l1_inv2;\n        can_signal xa A B; (xa, x) \\<in> l1_step1 xb xd xe\\<rbrakk>\n       \\<Longrightarrow> 0 < signalsInit x\n                              (Running A B (Exp gnx (NonceF (Rb $ ny))))\n 2. \\<And>x gnx A B Rb xa xc xd xe xf.\n       \\<lbrakk>guessed_runs Rb =\n                \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        in_progressS (progress x Rb) {xny, xgnx, xgny, xsk};\n        guessed_frame Rb xgnx = Some gnx; xa \\<in> l1_inv2;\n        can_signal xa A B; (xa, x) \\<in> l1_step2 xc xd xe xf\\<rbrakk>\n       \\<Longrightarrow> 0 < signalsInit x\n                              (Running A B (Exp gnx (NonceF (Rb $ ny))))\n 3. \\<And>x gnx A B Rb xa xb xd xe xf.\n       \\<lbrakk>guessed_runs Rb =\n                \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        in_progressS (progress x Rb) {xny, xgnx, xgny, xsk};\n        guessed_frame Rb xgnx = Some gnx; xa \\<in> l1_inv2;\n        can_signal xa A B; (xa, x) \\<in> l1_step3 xb xd xe xf\\<rbrakk>\n       \\<Longrightarrow> 0 < signalsInit x\n                              (Running A B (Exp gnx (NonceF (Rb $ ny))))\n 4. \\<And>x gnx A B Rb xa xc xd xe xf.\n       \\<lbrakk>guessed_runs Rb =\n                \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        in_progressS (progress x Rb) {xny, xgnx, xgny, xsk};\n        guessed_frame Rb xgnx = Some gnx; xa \\<in> l1_inv2;\n        can_signal xa A B; (xa, x) \\<in> l1_step4 xc xd xe xf\\<rbrakk>\n       \\<Longrightarrow> 0 < signalsInit x\n                              (Running A B (Exp gnx (NonceF (Rb $ ny))))\n 5. \\<And>x gnx A B Rb xa xb.\n       \\<lbrakk>guessed_runs Rb =\n                \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        in_progressS (progress x Rb) {xny, xgnx, xgny, xsk};\n        guessed_frame Rb xgnx = Some gnx; xa \\<in> l1_inv2;\n        can_signal xa A B; (xa, x) \\<in> l1_learn xb\\<rbrakk>\n       \\<Longrightarrow> 0 < signalsInit x\n                              (Running A B (Exp gnx (NonceF (Rb $ ny))))", "apply (auto simp add: l1_defs ik_dy_def l1_inv2_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_l1_inv2 [iff]: \"reach l1 \\<subseteq> l1_inv2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l1 \\<subseteq> l1_inv2", "by (rule inv_rule_basic) (auto)"], ["", "subsubsection \\<open>inv3 (derived)\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>\nIf an @{term \"Init\"} run before step 3 and a @{term \"Resp\"} run after step 2 both know the same\nhalf-keys (more or less), then the number of @{term \"Init\"} running signals for the key is strictly\ngreater than the number of @{term \"Init\"} commit signals.\n(actually, there are 0 commit and 1 running).\n\\<close>"], ["", "definition\n  l1_inv3 :: \"l1_state set\"\nwhere\n  \"l1_inv3 \\<equiv> {s. \\<forall> A B Rb Ra gny.\n    guessed_runs Rb = \\<lparr>role=Resp, owner=B, partner=A\\<rparr> \\<longrightarrow>\n    in_progressS (progress s Rb) {xny, xgnx, xgny, xsk} \\<longrightarrow>\n    guessed_frame Rb xgny = Some gny \\<longrightarrow>\n    guessed_frame Rb xgnx = Some (Exp Gen (NonceF (Ra$nx))) \\<longrightarrow>\n    guessed_runs Ra = \\<lparr>role=Init, owner=A, partner=B\\<rparr> \\<longrightarrow>\n    progress s Ra = Some {xnx, xgnx} \\<longrightarrow>\n    can_signal s A B \\<longrightarrow>\n      signalsInit s (Commit A B (Exp gny (NonceF (Ra$nx)))) \n    < signalsInit s (Running A B (Exp gny (NonceF (Ra$nx)))) \n  }\""], ["", "lemmas l1_inv3I = l1_inv3_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas l1_inv3E [elim] = l1_inv3_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas l1_inv3D = l1_inv3_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]"], ["", "lemma l1_inv3_derived: \"l1_inv1 \\<inter> l1_inv2 \\<subseteq> l1_inv3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l1_inv1 \\<inter> l1_inv2 \\<subseteq> l1_inv3", "apply (auto intro!: l1_inv3I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Ra.\n       \\<lbrakk>guessed_runs Rb =\n                \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        in_progressS (progress x Rb) {xny, xgnx, xgny, xsk};\n        guessed_frame Rb xgnx = Some (Exp Gen (NonceF (Ra $ nx)));\n        guessed_runs Ra =\n        \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        progress x Ra = Some {xnx, xgnx}; can_signal x A B; x \\<in> l1_inv1;\n        x \\<in> l1_inv2\\<rbrakk>\n       \\<Longrightarrow> signalsInit x\n                          (Commit A B\n                            (Exp (Exp Gen (NonceF (Rb $ ny)))\n                              (NonceF (Ra $ nx))))\n                         < signalsInit x\n                            (Running A B\n                              (Exp (Exp Gen (NonceF (Rb $ ny)))\n                                (NonceF (Ra $ nx))))", "apply (auto dest!: l1_inv2D)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Ra.\n       \\<lbrakk>in_progressS (progress x Rb) {xny, xgnx, xgny, xsk};\n        guessed_frame Rb xgnx = Some (Exp Gen (NonceF (Ra $ nx)));\n        guessed_runs Ra =\n        \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        progress x Ra = Some {xnx, xgnx}; can_signal x A B; x \\<in> l1_inv1;\n        x \\<in> l1_inv2;\n        0 < signalsInit x\n             (Running A B\n               (Exp (Exp Gen (NonceF (Rb $ ny)))\n                 (NonceF (Ra $ nx))))\\<rbrakk>\n       \\<Longrightarrow> signalsInit x\n                          (Commit A B\n                            (Exp (Exp Gen (NonceF (Rb $ ny)))\n                              (NonceF (Ra $ nx))))\n                         < signalsInit x\n                            (Running A B\n                              (Exp (Exp Gen (NonceF (Rb $ ny)))\n                                (NonceF (Ra $ nx))))", "apply (rename_tac x A B Rb Ra)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Ra.\n       \\<lbrakk>in_progressS (progress x Rb) {xny, xgnx, xgny, xsk};\n        guessed_frame Rb xgnx = Some (Exp Gen (NonceF (Ra $ nx)));\n        guessed_runs Ra =\n        \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        progress x Ra = Some {xnx, xgnx}; can_signal x A B; x \\<in> l1_inv1;\n        x \\<in> l1_inv2;\n        0 < signalsInit x\n             (Running A B\n               (Exp (Exp Gen (NonceF (Rb $ ny)))\n                 (NonceF (Ra $ nx))))\\<rbrakk>\n       \\<Longrightarrow> signalsInit x\n                          (Commit A B\n                            (Exp (Exp Gen (NonceF (Rb $ ny)))\n                              (NonceF (Ra $ nx))))\n                         < signalsInit x\n                            (Running A B\n                              (Exp (Exp Gen (NonceF (Rb $ ny)))\n                                (NonceF (Ra $ nx))))", "apply (case_tac \n  \"signalsInit x (Commit A B (Exp (Exp Gen (NonceF (Rb $ ny))) (NonceF (Ra $ nx)))) > 0\", auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Ra.\n       \\<lbrakk>in_progressS (progress x Rb) {xny, xgnx, xgny, xsk};\n        guessed_frame Rb xgnx = Some (Exp Gen (NonceF (Ra $ nx)));\n        guessed_runs Ra =\n        \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        progress x Ra = Some {xnx, xgnx}; can_signal x A B; x \\<in> l1_inv1;\n        x \\<in> l1_inv2;\n        0 < signalsInit x\n             (Running A B\n               (Exp (Exp Gen (NonceF (Rb $ ny))) (NonceF (Ra $ nx))));\n        0 < signalsInit x\n             (Commit A B\n               (Exp (Exp Gen (NonceF (Rb $ ny)))\n                 (NonceF (Ra $ nx))))\\<rbrakk>\n       \\<Longrightarrow> signalsInit x\n                          (Commit A B\n                            (Exp (Exp Gen (NonceF (Rb $ ny)))\n                              (NonceF (Ra $ nx))))\n                         < signalsInit x\n                            (Running A B\n                              (Exp (Exp Gen (NonceF (Rb $ ny)))\n                                (NonceF (Ra $ nx))))", "apply (fastforce dest: l1_inv1D elim: equalityE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Invariants: @{term \"Resp\"} authenticates @{term \"Init\"}\\<close>"], ["", "(**************************************************************************************************)"], ["", "subsubsection \\<open>inv4\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>If a @{term \"Resp\"} commit signal exists for $(@{term \"g\"}^@{term \"nx\"})^@{term \"Rb$ny\"}$\n  then @{term \"Rb\"} is @{term \"Resp\"}, has finished its run, and\n  has $(@{term \"g\"}^@{term \"nx\"})^@{term \"Rb$ny\"}$ as the key in its frame.\\<close>"], ["", "definition\n  l1_inv4 :: \"l1_state set\"\nwhere\n  \"l1_inv4 \\<equiv> {s. \\<forall> Rb A B gnx.\n    signalsResp s (Commit A B (Exp gnx (NonceF (Rb$ny)))) > 0 \\<longrightarrow>\n      guessed_runs Rb = \\<lparr>role=Resp, owner=B, partner=A\\<rparr> \\<and>\n      progress s Rb = Some {xny, xgnx, xgny, xsk, xEnd} \\<and>\n      guessed_frame Rb xgnx = Some gnx\n   }\""], ["", "lemmas l1_inv4I = l1_inv4_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas l1_inv4E [elim] = l1_inv4_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas l1_inv4D = l1_inv4_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]"], ["", "lemma l1_inv4_init [iff]:\n  \"init l1 \\<subseteq> l1_inv4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init l1 \\<subseteq> l1_inv4", "by (auto simp add: l1_def l1_init_def l1_inv4_def)"], ["", "declare domIff [iff]"], ["", "lemma l1_inv4_trans [iff]:\n  \"{l1_inv4} trans l1 {> l1_inv4}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l1_inv4} TS.trans l1 {> l1_inv4}", "apply (auto simp add: PO_hoare_defs l1_nostep_defs intro!: l1_inv4I)"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>x Rb A B gnx xa xb xd xe.\n       \\<lbrakk>0 < signalsResp x (Commit A B (Exp gnx (NonceF (Rb $ ny))));\n        xa \\<in> l1_inv4; (xa, x) \\<in> l1_step1 xb xd xe\\<rbrakk>\n       \\<Longrightarrow> guessed_runs Rb =\n                         \\<lparr>role = Resp, owner = B, partner = A\\<rparr>\n 2. \\<And>x Rb A B gnx xa xb xd xe.\n       \\<lbrakk>0 < signalsResp x (Commit A B (Exp gnx (NonceF (Rb $ ny))));\n        xa \\<in> l1_inv4; (xa, x) \\<in> l1_step1 xb xd xe\\<rbrakk>\n       \\<Longrightarrow> progress x Rb = Some {xny, xgnx, xgny, xsk, xEnd}\n 3. \\<And>x Rb A B gnx xa xb xd xe.\n       \\<lbrakk>0 < signalsResp x (Commit A B (Exp gnx (NonceF (Rb $ ny))));\n        xa \\<in> l1_inv4; (xa, x) \\<in> l1_step1 xb xd xe\\<rbrakk>\n       \\<Longrightarrow> guessed_frame Rb xgnx = Some gnx\n 4. \\<And>x Rb A B gnx xa xc xd xe xf.\n       \\<lbrakk>0 < signalsResp x (Commit A B (Exp gnx (NonceF (Rb $ ny))));\n        xa \\<in> l1_inv4; (xa, x) \\<in> l1_step2 xc xd xe xf\\<rbrakk>\n       \\<Longrightarrow> guessed_runs Rb =\n                         \\<lparr>role = Resp, owner = B, partner = A\\<rparr>\n 5. \\<And>x Rb A B gnx xa xc xd xe xf.\n       \\<lbrakk>0 < signalsResp x (Commit A B (Exp gnx (NonceF (Rb $ ny))));\n        xa \\<in> l1_inv4; (xa, x) \\<in> l1_step2 xc xd xe xf\\<rbrakk>\n       \\<Longrightarrow> progress x Rb = Some {xny, xgnx, xgny, xsk, xEnd}\n 6. \\<And>x Rb A B gnx xa xc xd xe xf.\n       \\<lbrakk>0 < signalsResp x (Commit A B (Exp gnx (NonceF (Rb $ ny))));\n        xa \\<in> l1_inv4; (xa, x) \\<in> l1_step2 xc xd xe xf\\<rbrakk>\n       \\<Longrightarrow> guessed_frame Rb xgnx = Some gnx\n 7. \\<And>x Rb A B gnx xa xb xd xe xf.\n       \\<lbrakk>0 < signalsResp x (Commit A B (Exp gnx (NonceF (Rb $ ny))));\n        xa \\<in> l1_inv4; (xa, x) \\<in> l1_step3 xb xd xe xf\\<rbrakk>\n       \\<Longrightarrow> guessed_runs Rb =\n                         \\<lparr>role = Resp, owner = B, partner = A\\<rparr>\n 8. \\<And>x Rb A B gnx xa xb xd xe xf.\n       \\<lbrakk>0 < signalsResp x (Commit A B (Exp gnx (NonceF (Rb $ ny))));\n        xa \\<in> l1_inv4; (xa, x) \\<in> l1_step3 xb xd xe xf\\<rbrakk>\n       \\<Longrightarrow> progress x Rb = Some {xny, xgnx, xgny, xsk, xEnd}\n 9. \\<And>x Rb A B gnx xa xb xd xe xf.\n       \\<lbrakk>0 < signalsResp x (Commit A B (Exp gnx (NonceF (Rb $ ny))));\n        xa \\<in> l1_inv4; (xa, x) \\<in> l1_step3 xb xd xe xf\\<rbrakk>\n       \\<Longrightarrow> guessed_frame Rb xgnx = Some gnx\n 10. \\<And>x Rb A B gnx xa xc xd xe xf.\n        \\<lbrakk>0 < signalsResp x\n                      (Commit A B (Exp gnx (NonceF (Rb $ ny))));\n         xa \\<in> l1_inv4; (xa, x) \\<in> l1_step4 xc xd xe xf\\<rbrakk>\n        \\<Longrightarrow> guessed_runs Rb =\n                          \\<lparr>role = Resp, owner = B,\n                             partner = A\\<rparr>\nA total of 15 subgoals...", "apply (auto simp add: l1_inv4_def  l1_defs ik_dy_def dest: Exp_Exp_Gen_inj2 [OF sym])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare domIff [iff del]"], ["", "lemma PO_l1_inv4 [iff]: \"reach l1 \\<subseteq> l1_inv4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l1 \\<subseteq> l1_inv4", "by (rule inv_rule_basic) (auto)"], ["", "subsubsection \\<open>inv5\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>If an @{term \"Init\"} run @{term \"Ra\"} has passed step3 then (if possible) a\n       @{term \"Resp\"} running signal has been emitted.\\<close>"], ["", "definition\n  l1_inv5 :: \"l1_state set\"\nwhere\n  \"l1_inv5 \\<equiv> {s. \\<forall> gny A B Ra.\n    guessed_runs Ra = \\<lparr>role=Init, owner=A, partner=B\\<rparr> \\<longrightarrow>\n    in_progressS (progress s Ra) {xnx, xgnx, xgny, xsk, xEnd} \\<longrightarrow>\n    guessed_frame Ra xgny = Some gny \\<longrightarrow>\n    can_signal s A B \\<longrightarrow>\n      signalsResp s (Running A B (Exp gny (NonceF (Ra$nx)))) > 0\n  }\""], ["", "lemmas l1_inv5I = l1_inv5_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas l1_inv5E [elim] = l1_inv5_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas l1_inv5D = l1_inv5_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]"], ["", "lemma l1_inv5_init [iff]:\n  \"init l1 \\<subseteq> l1_inv5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init l1 \\<subseteq> l1_inv5", "by (auto simp add: l1_def l1_init_def l1_inv5_def)"], ["", "lemma l1_inv5_trans [iff]:\n  \"{l1_inv5} trans l1 {> l1_inv5}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l1_inv5} TS.trans l1 {> l1_inv5}", "apply (auto simp add: PO_hoare_defs intro!: l1_inv5I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x gny A B Ra xa.\n       \\<lbrakk>guessed_runs Ra =\n                \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        in_progressS (progress x Ra) {xnx, xgnx, xgny, xsk, xEnd};\n        guessed_frame Ra xgny = Some gny; can_signal x A B;\n        xa \\<in> l1_inv5; (xa, x) \\<in> TS.trans l1\\<rbrakk>\n       \\<Longrightarrow> 0 < signalsResp x\n                              (Running A B (Exp gny (NonceF (Ra $ nx))))", "apply (drule can_signal_trans, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x gny A B Ra xa.\n       \\<lbrakk>guessed_runs Ra =\n                \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        in_progressS (progress x Ra) {xnx, xgnx, xgny, xsk, xEnd};\n        guessed_frame Ra xgny = Some gny; xa \\<in> l1_inv5;\n        (xa, x) \\<in> TS.trans l1; can_signal xa A B\\<rbrakk>\n       \\<Longrightarrow> 0 < signalsResp x\n                              (Running A B (Exp gny (NonceF (Ra $ nx))))", "apply (auto simp add: l1_nostep_defs)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x gny A B Ra xa xb xd xe.\n       \\<lbrakk>guessed_runs Ra =\n                \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        in_progressS (progress x Ra) {xnx, xgnx, xgny, xsk, xEnd};\n        guessed_frame Ra xgny = Some gny; xa \\<in> l1_inv5;\n        can_signal xa A B; (xa, x) \\<in> l1_step1 xb xd xe\\<rbrakk>\n       \\<Longrightarrow> 0 < signalsResp x\n                              (Running A B (Exp gny (NonceF (Ra $ nx))))\n 2. \\<And>x gny A B Ra xa xc xd xe xf.\n       \\<lbrakk>guessed_runs Ra =\n                \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        in_progressS (progress x Ra) {xnx, xgnx, xgny, xsk, xEnd};\n        guessed_frame Ra xgny = Some gny; xa \\<in> l1_inv5;\n        can_signal xa A B; (xa, x) \\<in> l1_step2 xc xd xe xf\\<rbrakk>\n       \\<Longrightarrow> 0 < signalsResp x\n                              (Running A B (Exp gny (NonceF (Ra $ nx))))\n 3. \\<And>x gny A B Ra xa xb xd xe xf.\n       \\<lbrakk>guessed_runs Ra =\n                \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        in_progressS (progress x Ra) {xnx, xgnx, xgny, xsk, xEnd};\n        guessed_frame Ra xgny = Some gny; xa \\<in> l1_inv5;\n        can_signal xa A B; (xa, x) \\<in> l1_step3 xb xd xe xf\\<rbrakk>\n       \\<Longrightarrow> 0 < signalsResp x\n                              (Running A B (Exp gny (NonceF (Ra $ nx))))\n 4. \\<And>x gny A B Ra xa xc xd xe xf.\n       \\<lbrakk>guessed_runs Ra =\n                \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        in_progressS (progress x Ra) {xnx, xgnx, xgny, xsk, xEnd};\n        guessed_frame Ra xgny = Some gny; xa \\<in> l1_inv5;\n        can_signal xa A B; (xa, x) \\<in> l1_step4 xc xd xe xf\\<rbrakk>\n       \\<Longrightarrow> 0 < signalsResp x\n                              (Running A B (Exp gny (NonceF (Ra $ nx))))\n 5. \\<And>x gny A B Ra xa xb.\n       \\<lbrakk>guessed_runs Ra =\n                \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        in_progressS (progress x Ra) {xnx, xgnx, xgny, xsk, xEnd};\n        guessed_frame Ra xgny = Some gny; xa \\<in> l1_inv5;\n        can_signal xa A B; (xa, x) \\<in> l1_learn xb\\<rbrakk>\n       \\<Longrightarrow> 0 < signalsResp x\n                              (Running A B (Exp gny (NonceF (Ra $ nx))))", "apply (auto simp add: l1_defs ik_dy_def l1_inv5_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_l1_inv5 [iff]: \"reach l1 \\<subseteq> l1_inv5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l1 \\<subseteq> l1_inv5", "by (rule inv_rule_basic) (auto)"], ["", "subsubsection \\<open>inv6 (derived)\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>If a @{term \"Resp\"} run before step 4 and an @{term \"Init\"} run after step 3 both know\n  the same half-keys (more or less), then the number of @{term \"Resp\"} running signals\n  for the key is strictly greater than the number of @{term \"Resp\"} commit signals.\n  (actually, there are 0 commit and 1 running).\n\\<close>"], ["", "definition\n  l1_inv6 :: \"l1_state set\"\nwhere\n  \"l1_inv6 \\<equiv> {s. \\<forall> A B Rb Ra gnx.\n    guessed_runs Ra = \\<lparr>role=Init, owner=A, partner=B\\<rparr> \\<longrightarrow>\n    in_progressS (progress s Ra) {xnx, xgnx, xgny, xsk, xEnd} \\<longrightarrow>\n    guessed_frame Ra xgnx = Some gnx \\<longrightarrow>\n    guessed_frame Ra xgny = Some (Exp Gen (NonceF (Rb$ny))) \\<longrightarrow>\n    guessed_runs Rb = \\<lparr>role=Resp, owner=B, partner=A\\<rparr> \\<longrightarrow>\n    progress s Rb = Some {xny, xgnx, xgny, xsk} \\<longrightarrow>\n    can_signal s A B \\<longrightarrow>\n      signalsResp s (Commit A B (Exp gnx (NonceF (Rb$ny)))) \n    < signalsResp s (Running A B (Exp gnx (NonceF (Rb$ny)))) \n  }\""], ["", "lemmas l1_inv6I = l1_inv6_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas l1_inv6E [elim] = l1_inv6_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas l1_inv6D = l1_inv6_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]"], ["", "lemma l1_inv6_derived:\n  \"l1_inv4 \\<inter> l1_inv5 \\<subseteq> l1_inv6\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l1_inv4 \\<inter> l1_inv5 \\<subseteq> l1_inv6", "proof (auto intro!: l1_inv6I)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Ra.\n       \\<lbrakk>guessed_runs Ra =\n                \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        in_progressS (progress x Ra) {xnx, xgnx, xgny, xsk, xEnd};\n        guessed_frame Ra xgny = Some (Exp Gen (NonceF (Rb $ ny)));\n        guessed_runs Rb =\n        \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        progress x Rb = Some {xny, xgnx, xgny, xsk}; can_signal x A B;\n        x \\<in> l1_inv4; x \\<in> l1_inv5\\<rbrakk>\n       \\<Longrightarrow> signalsResp x\n                          (Commit A B\n                            (Exp (Exp Gen (NonceF (Rb $ ny)))\n                              (NonceF (Ra $ nx))))\n                         < signalsResp x\n                            (Running A B\n                              (Exp (Exp Gen (NonceF (Rb $ ny)))\n                                (NonceF (Ra $ nx))))", "fix s::l1_state"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Ra.\n       \\<lbrakk>guessed_runs Ra =\n                \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        in_progressS (progress x Ra) {xnx, xgnx, xgny, xsk, xEnd};\n        guessed_frame Ra xgny = Some (Exp Gen (NonceF (Rb $ ny)));\n        guessed_runs Rb =\n        \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        progress x Rb = Some {xny, xgnx, xgny, xsk}; can_signal x A B;\n        x \\<in> l1_inv4; x \\<in> l1_inv5\\<rbrakk>\n       \\<Longrightarrow> signalsResp x\n                          (Commit A B\n                            (Exp (Exp Gen (NonceF (Rb $ ny)))\n                              (NonceF (Ra $ nx))))\n                         < signalsResp x\n                            (Running A B\n                              (Exp (Exp Gen (NonceF (Rb $ ny)))\n                                (NonceF (Ra $ nx))))", "fix A B Rb Ra"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Ra.\n       \\<lbrakk>guessed_runs Ra =\n                \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        in_progressS (progress x Ra) {xnx, xgnx, xgny, xsk, xEnd};\n        guessed_frame Ra xgny = Some (Exp Gen (NonceF (Rb $ ny)));\n        guessed_runs Rb =\n        \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        progress x Rb = Some {xny, xgnx, xgny, xsk}; can_signal x A B;\n        x \\<in> l1_inv4; x \\<in> l1_inv5\\<rbrakk>\n       \\<Longrightarrow> signalsResp x\n                          (Commit A B\n                            (Exp (Exp Gen (NonceF (Rb $ ny)))\n                              (NonceF (Ra $ nx))))\n                         < signalsResp x\n                            (Running A B\n                              (Exp (Exp Gen (NonceF (Rb $ ny)))\n                                (NonceF (Ra $ nx))))", "assume HRun:\"guessed_runs Ra = \\<lparr>role = Init, owner = A, partner = B\\<rparr>\"\n              \"in_progressS (progress s Ra) {xnx, xgnx, xgny, xsk, xEnd}\"\n              \"guessed_frame Ra xgny = Some (Exp Gen (NonceF (Rb $ ny)))\"\n              \"can_signal s A B\""], ["proof (state)\nthis:\n  guessed_runs Ra = \\<lparr>role = Init, owner = A, partner = B\\<rparr>\n  in_progressS (progress s Ra) {xnx, xgnx, xgny, xsk, xEnd}\n  guessed_frame Ra xgny = Some (Exp Gen (NonceF (Rb $ ny)))\n  can_signal s A B\n\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Ra.\n       \\<lbrakk>guessed_runs Ra =\n                \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        in_progressS (progress x Ra) {xnx, xgnx, xgny, xsk, xEnd};\n        guessed_frame Ra xgny = Some (Exp Gen (NonceF (Rb $ ny)));\n        guessed_runs Rb =\n        \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        progress x Rb = Some {xny, xgnx, xgny, xsk}; can_signal x A B;\n        x \\<in> l1_inv4; x \\<in> l1_inv5\\<rbrakk>\n       \\<Longrightarrow> signalsResp x\n                          (Commit A B\n                            (Exp (Exp Gen (NonceF (Rb $ ny)))\n                              (NonceF (Ra $ nx))))\n                         < signalsResp x\n                            (Running A B\n                              (Exp (Exp Gen (NonceF (Rb $ ny)))\n                                (NonceF (Ra $ nx))))", "assume HRb: \"progress s Rb = Some {xny, xgnx, xgny, xsk}\""], ["proof (state)\nthis:\n  progress s Rb = Some {xny, xgnx, xgny, xsk}\n\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Ra.\n       \\<lbrakk>guessed_runs Ra =\n                \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        in_progressS (progress x Ra) {xnx, xgnx, xgny, xsk, xEnd};\n        guessed_frame Ra xgny = Some (Exp Gen (NonceF (Rb $ ny)));\n        guessed_runs Rb =\n        \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        progress x Rb = Some {xny, xgnx, xgny, xsk}; can_signal x A B;\n        x \\<in> l1_inv4; x \\<in> l1_inv5\\<rbrakk>\n       \\<Longrightarrow> signalsResp x\n                          (Commit A B\n                            (Exp (Exp Gen (NonceF (Rb $ ny)))\n                              (NonceF (Ra $ nx))))\n                         < signalsResp x\n                            (Running A B\n                              (Exp (Exp Gen (NonceF (Rb $ ny)))\n                                (NonceF (Ra $ nx))))", "assume I4:\"s \\<in> l1_inv4\""], ["proof (state)\nthis:\n  s \\<in> l1_inv4\n\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Ra.\n       \\<lbrakk>guessed_runs Ra =\n                \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        in_progressS (progress x Ra) {xnx, xgnx, xgny, xsk, xEnd};\n        guessed_frame Ra xgny = Some (Exp Gen (NonceF (Rb $ ny)));\n        guessed_runs Rb =\n        \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        progress x Rb = Some {xny, xgnx, xgny, xsk}; can_signal x A B;\n        x \\<in> l1_inv4; x \\<in> l1_inv5\\<rbrakk>\n       \\<Longrightarrow> signalsResp x\n                          (Commit A B\n                            (Exp (Exp Gen (NonceF (Rb $ ny)))\n                              (NonceF (Ra $ nx))))\n                         < signalsResp x\n                            (Running A B\n                              (Exp (Exp Gen (NonceF (Rb $ ny)))\n                                (NonceF (Ra $ nx))))", "assume I5:\"s \\<in> l1_inv5\""], ["proof (state)\nthis:\n  s \\<in> l1_inv5\n\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Ra.\n       \\<lbrakk>guessed_runs Ra =\n                \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        in_progressS (progress x Ra) {xnx, xgnx, xgny, xsk, xEnd};\n        guessed_frame Ra xgny = Some (Exp Gen (NonceF (Rb $ ny)));\n        guessed_runs Rb =\n        \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        progress x Rb = Some {xny, xgnx, xgny, xsk}; can_signal x A B;\n        x \\<in> l1_inv4; x \\<in> l1_inv5\\<rbrakk>\n       \\<Longrightarrow> signalsResp x\n                          (Commit A B\n                            (Exp (Exp Gen (NonceF (Rb $ ny)))\n                              (NonceF (Ra $ nx))))\n                         < signalsResp x\n                            (Running A B\n                              (Exp (Exp Gen (NonceF (Rb $ ny)))\n                                (NonceF (Ra $ nx))))", "from I4 HRb"], ["proof (chain)\npicking this:\n  s \\<in> l1_inv4\n  progress s Rb = Some {xny, xgnx, xgny, xsk}", "have \"signalsResp s (Commit A B (Exp (Exp Gen (NonceF (Rb $ ny))) (NonceF (Ra $ nx)))) > 0 \n       \\<Longrightarrow> False\""], ["proof (prove)\nusing this:\n  s \\<in> l1_inv4\n  progress s Rb = Some {xny, xgnx, xgny, xsk}\n\ngoal (1 subgoal):\n 1. 0 < signalsResp s\n         (Commit A B\n           (Exp (Exp Gen (NonceF (Rb $ ny)))\n             (NonceF (Ra $ nx)))) \\<Longrightarrow>\n    False", "proof (auto dest!: l1_inv4D)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> l1_inv4;\n     {xny, xgnx, xgny, xsk, xEnd} = {xny, xgnx, xgny, xsk};\n     guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n     progress s Rb = Some {xny, xgnx, xgny, xsk};\n     guessed_frame Rb xgnx = Some (Exp Gen (NonceF (Ra $ nx)))\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"{xny, xgnx, xgny, xsk, xEnd} = {xny, xgnx, xgny, xsk}\""], ["proof (state)\nthis:\n  {xny, xgnx, xgny, xsk, xEnd} = {xny, xgnx, xgny, xsk}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> l1_inv4;\n     {xny, xgnx, xgny, xsk, xEnd} = {xny, xgnx, xgny, xsk};\n     guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n     progress s Rb = Some {xny, xgnx, xgny, xsk};\n     guessed_frame Rb xgnx = Some (Exp Gen (NonceF (Ra $ nx)))\\<rbrakk>\n    \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  {xny, xgnx, xgny, xsk, xEnd} = {xny, xgnx, xgny, xsk}\n\ngoal (1 subgoal):\n 1. False", "by force"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < signalsResp s\n       (Commit A B\n         (Exp (Exp Gen (NonceF (Rb $ ny)))\n           (NonceF (Ra $ nx)))) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Ra.\n       \\<lbrakk>guessed_runs Ra =\n                \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        in_progressS (progress x Ra) {xnx, xgnx, xgny, xsk, xEnd};\n        guessed_frame Ra xgny = Some (Exp Gen (NonceF (Rb $ ny)));\n        guessed_runs Rb =\n        \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        progress x Rb = Some {xny, xgnx, xgny, xsk}; can_signal x A B;\n        x \\<in> l1_inv4; x \\<in> l1_inv5\\<rbrakk>\n       \\<Longrightarrow> signalsResp x\n                          (Commit A B\n                            (Exp (Exp Gen (NonceF (Rb $ ny)))\n                              (NonceF (Ra $ nx))))\n                         < signalsResp x\n                            (Running A B\n                              (Exp (Exp Gen (NonceF (Rb $ ny)))\n                                (NonceF (Ra $ nx))))", "then"], ["proof (chain)\npicking this:\n  0 < signalsResp s\n       (Commit A B\n         (Exp (Exp Gen (NonceF (Rb $ ny)))\n           (NonceF (Ra $ nx)))) \\<Longrightarrow>\n  False", "have \n    HC: \"signalsResp s (Commit A B (Exp (Exp Gen (NonceF (Rb $ ny))) (NonceF (Ra $ nx)))) = 0\""], ["proof (prove)\nusing this:\n  0 < signalsResp s\n       (Commit A B\n         (Exp (Exp Gen (NonceF (Rb $ ny)))\n           (NonceF (Ra $ nx)))) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. signalsResp s\n     (Commit A B (Exp (Exp Gen (NonceF (Rb $ ny))) (NonceF (Ra $ nx)))) =\n    0", "by auto"], ["proof (state)\nthis:\n  signalsResp s\n   (Commit A B (Exp (Exp Gen (NonceF (Rb $ ny))) (NonceF (Ra $ nx)))) =\n  0\n\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Ra.\n       \\<lbrakk>guessed_runs Ra =\n                \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        in_progressS (progress x Ra) {xnx, xgnx, xgny, xsk, xEnd};\n        guessed_frame Ra xgny = Some (Exp Gen (NonceF (Rb $ ny)));\n        guessed_runs Rb =\n        \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        progress x Rb = Some {xny, xgnx, xgny, xsk}; can_signal x A B;\n        x \\<in> l1_inv4; x \\<in> l1_inv5\\<rbrakk>\n       \\<Longrightarrow> signalsResp x\n                          (Commit A B\n                            (Exp (Exp Gen (NonceF (Rb $ ny)))\n                              (NonceF (Ra $ nx))))\n                         < signalsResp x\n                            (Running A B\n                              (Exp (Exp Gen (NonceF (Rb $ ny)))\n                                (NonceF (Ra $ nx))))", "from I5 HRun"], ["proof (chain)\npicking this:\n  s \\<in> l1_inv5\n  guessed_runs Ra = \\<lparr>role = Init, owner = A, partner = B\\<rparr>\n  in_progressS (progress s Ra) {xnx, xgnx, xgny, xsk, xEnd}\n  guessed_frame Ra xgny = Some (Exp Gen (NonceF (Rb $ ny)))\n  can_signal s A B", "have \"signalsResp s (Running A B (Exp (Exp Gen (NonceF (Rb $ ny))) (NonceF (Ra $ nx)))) > 0\""], ["proof (prove)\nusing this:\n  s \\<in> l1_inv5\n  guessed_runs Ra = \\<lparr>role = Init, owner = A, partner = B\\<rparr>\n  in_progressS (progress s Ra) {xnx, xgnx, xgny, xsk, xEnd}\n  guessed_frame Ra xgny = Some (Exp Gen (NonceF (Rb $ ny)))\n  can_signal s A B\n\ngoal (1 subgoal):\n 1. 0 < signalsResp s\n         (Running A B (Exp (Exp Gen (NonceF (Rb $ ny))) (NonceF (Ra $ nx))))", "by (auto dest!: l1_inv5D)"], ["proof (state)\nthis:\n  0 < signalsResp s\n       (Running A B (Exp (Exp Gen (NonceF (Rb $ ny))) (NonceF (Ra $ nx))))\n\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Ra.\n       \\<lbrakk>guessed_runs Ra =\n                \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        in_progressS (progress x Ra) {xnx, xgnx, xgny, xsk, xEnd};\n        guessed_frame Ra xgny = Some (Exp Gen (NonceF (Rb $ ny)));\n        guessed_runs Rb =\n        \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        progress x Rb = Some {xny, xgnx, xgny, xsk}; can_signal x A B;\n        x \\<in> l1_inv4; x \\<in> l1_inv5\\<rbrakk>\n       \\<Longrightarrow> signalsResp x\n                          (Commit A B\n                            (Exp (Exp Gen (NonceF (Rb $ ny)))\n                              (NonceF (Ra $ nx))))\n                         < signalsResp x\n                            (Running A B\n                              (Exp (Exp Gen (NonceF (Rb $ ny)))\n                                (NonceF (Ra $ nx))))", "with HC"], ["proof (chain)\npicking this:\n  signalsResp s\n   (Commit A B (Exp (Exp Gen (NonceF (Rb $ ny))) (NonceF (Ra $ nx)))) =\n  0\n  0 < signalsResp s\n       (Running A B (Exp (Exp Gen (NonceF (Rb $ ny))) (NonceF (Ra $ nx))))", "show \n     \"signalsResp s (Commit A B (Exp (Exp Gen (NonceF (Rb $ ny))) (NonceF (Ra $ nx))))\n    < signalsResp s (Running A B (Exp (Exp Gen (NonceF (Rb $ ny))) (NonceF (Ra $ nx))))\""], ["proof (prove)\nusing this:\n  signalsResp s\n   (Commit A B (Exp (Exp Gen (NonceF (Rb $ ny))) (NonceF (Ra $ nx)))) =\n  0\n  0 < signalsResp s\n       (Running A B (Exp (Exp Gen (NonceF (Rb $ ny))) (NonceF (Ra $ nx))))\n\ngoal (1 subgoal):\n 1. signalsResp s\n     (Commit A B (Exp (Exp Gen (NonceF (Rb $ ny))) (NonceF (Ra $ nx))))\n    < signalsResp s\n       (Running A B (Exp (Exp Gen (NonceF (Rb $ ny))) (NonceF (Ra $ nx))))", "by auto"], ["proof (state)\nthis:\n  signalsResp s\n   (Commit A B (Exp (Exp Gen (NonceF (Rb $ ny))) (NonceF (Ra $ nx))))\n  < signalsResp s\n     (Running A B (Exp (Exp Gen (NonceF (Rb $ ny))) (NonceF (Ra $ nx))))\n\ngoal:\nNo subgoals!", "qed"], ["", "(**************************************************************************************************)"], ["", "subsection \\<open>Refinement: injective agreement  (@{term \"Init\"} authenticates @{term \"Resp\"})\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>Mediator function.\\<close>"], ["", "definition \n  med01iai :: \"l1_obs \\<Rightarrow> a0i_obs\"\nwhere\n  \"med01iai t \\<equiv> \\<lparr>a0n_state.signals = signalsInit t\\<rparr>\""], ["", "text \\<open>Relation between states.\\<close>"], ["", "definition\n  R01iai :: \"(a0i_state * l1_state) set\"\nwhere\n  \"R01iai \\<equiv> {(s,s').\n    a0n_state.signals s = signalsInit s'\n    }\""], ["", "text \\<open>Protocol-independent events.\\<close>"], ["", "lemma l1_learn_refines_a0_ia_skip_i:\n  \"{R01iai} Id, l1_learn m {>R01iai}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01iai} Id, l1_learn m {> R01iai}", "apply (auto simp add: PO_rhoare_defs R01iai_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>signals a = signalsInit y; (y, b) \\<in> l1_learn m\\<rbrakk>\n       \\<Longrightarrow> signalsInit y = signalsInit b", "apply (simp add: l1_learn_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Protocol events.\\<close>"], ["", "lemma l1_step1_refines_a0i_skip_i:\n  \"{R01iai} Id, l1_step1 Ra A B {>R01iai}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01iai} Id, l1_step1 Ra A B {> R01iai}", "by (auto simp add: PO_rhoare_defs R01iai_def l1_step1_def)"], ["", "lemma l1_step2_refines_a0i_running_skip_i:\n  \"{R01iai} a0i_running A B (Exp gnx (NonceF (Rb$ny))) \\<union> Id, l1_step2 Rb A B gnx {>R01iai}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01iai} (a0i_running A B\n               (Exp gnx\n                 (NonceF\n                   (Rb $ ny))))\\<^sup>=, l1_step2 Rb A B gnx {> R01iai}", "by (auto simp add: PO_rhoare_defs R01iai_def, simp_all add: l1_step2_def a0i_running_def, auto)"], ["", "lemma l1_step3_refines_a0i_commit_skip_i:\n  \"{R01iai \\<inter> (UNIV \\<times> l1_inv3)} \n     a0i_commit A B (Exp gny (NonceF (Ra$nx))) \\<union> Id, \n     l1_step3 Ra A B gny \n   {>R01iai}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01iai \\<inter>\n     UNIV \\<times>\n     l1_inv3} (a0i_commit A B\n                (Exp gny\n                  (NonceF\n                    (Ra $ nx))))\\<^sup>=, l1_step3 Ra A B gny {> R01iai}", "apply (auto simp add: PO_rhoare_defs R01iai_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>signals a = signalsInit y; y \\<in> l1_inv3;\n        (y, b) \\<in> l1_step3 Ra A B gny\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            ((a, y)\n                             \\<in> a0i_commit A B\n                                    (Exp gny (NonceF (Ra $ nx))) \\<or>\n                             a = y) \\<and>\n                            signals y = signalsInit b", "apply (auto simp add: l1_step3_def a0i_commit_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a y Rb.\n       \\<lbrakk>signals a = signalsInit y; y \\<in> l1_inv3;\n        guessed_runs Ra =\n        \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        progress y Ra = Some {xnx, xgnx};\n        guessed_frame Ra xgny = Some (Exp Gen (NonceF (Rb $ ny)));\n        guessed_frame Ra xsk =\n        Some (Exp (Exp Gen (NonceF (Rb $ ny))) (NonceF (Ra $ nx)));\n        guessed_runs Rb =\n        \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        in_progressS (progress y Rb) {xny, xgnx, xgny, xsk};\n        guessed_frame Rb xgnx = Some (Exp Gen (NonceF (Ra $ nx)));\n        Ra \\<noteq> test; can_signal y A B;\n        gny = Exp Gen (NonceF (Rb $ ny))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            (signalsInit y\n                              (Commit A B\n                                (Exp (Exp Gen (NonceF (Rb $ ny)))\n                                  (NonceF (Ra $ nx))))\n                             < signalsInit y\n                                (Running A B\n                                  (Exp (Exp Gen (NonceF (Rb $ ny)))\n                                    (NonceF (Ra $ nx)))) \\<and>\n                             ya = a\n                             \\<lparr>signals := (signalsInit y)\n (Commit A B (Exp (Exp Gen (NonceF (Rb $ ny))) (NonceF (Ra $ nx))) :=\n    Suc (signalsInit y\n          (Commit A B\n            (Exp (Exp Gen (NonceF (Rb $ ny)))\n              (NonceF (Ra $ nx))))))\\<rparr> \\<or>\n                             a = ya) \\<and>\n                            signals ya = (signalsInit y)\n                            (Commit A B\n                              (Exp (Exp Gen (NonceF (Rb $ ny)))\n                                (NonceF (Ra $ nx))) :=\n                               Suc (signalsInit y\n                                     (Commit A B\n (Exp (Exp Gen (NonceF (Rb $ ny))) (NonceF (Ra $ nx))))))\n 2. \\<And>a y Rb.\n       \\<lbrakk>signals a = signalsInit y; y \\<in> l1_inv3;\n        guessed_runs Ra =\n        \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        progress y Ra = Some {xnx, xgnx};\n        guessed_frame Ra xgny = Some (Exp Gen (NonceF (Rb $ ny)));\n        guessed_frame Ra xsk =\n        Some (Exp (Exp Gen (NonceF (Rb $ ny))) (NonceF (Ra $ nx)));\n        guessed_runs Rb =\n        \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        in_progressS (progress y Rb) {xny, xgnx, xgny, xsk};\n        guessed_frame Rb xgnx = Some (Exp Gen (NonceF (Ra $ nx)));\n        Exp (Exp Gen (NonceF (Rb $ ny))) (NonceF (test $ nx))\n        \\<notin> synth (analz (ik y));\n        can_signal y A B; gny = Exp Gen (NonceF (Rb $ ny))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            (signalsInit y\n                              (Commit A B\n                                (Exp (Exp Gen (NonceF (Rb $ ny)))\n                                  (NonceF (Ra $ nx))))\n                             < signalsInit y\n                                (Running A B\n                                  (Exp (Exp Gen (NonceF (Rb $ ny)))\n                                    (NonceF (Ra $ nx)))) \\<and>\n                             ya = a\n                             \\<lparr>signals := (signalsInit y)\n (Commit A B (Exp (Exp Gen (NonceF (Rb $ ny))) (NonceF (Ra $ nx))) :=\n    Suc (signalsInit y\n          (Commit A B\n            (Exp (Exp Gen (NonceF (Rb $ ny)))\n              (NonceF (Ra $ nx))))))\\<rparr> \\<or>\n                             a = ya) \\<and>\n                            signals ya = (signalsInit y)\n                            (Commit A B\n                              (Exp (Exp Gen (NonceF (Rb $ ny)))\n                                (NonceF (Ra $ nx))) :=\n                               Suc (signalsInit y\n                                     (Commit A B\n (Exp (Exp Gen (NonceF (Rb $ ny))) (NonceF (Ra $ nx))))))", "apply (force elim!: l1_inv3E)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma l1_step4_refines_a0i_skip_i:\n  \"{R01iai} Id, l1_step4 Rb A B gnx {>R01iai}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01iai} Id, l1_step4 Rb A B gnx {> R01iai}", "by (auto simp add: PO_rhoare_defs R01iai_def, auto simp add: l1_step4_def)"], ["", "text \\<open>Refinement proof.\\<close>"], ["", "lemmas l1_trans_refines_a0i_trans_i = \n  l1_learn_refines_a0_ia_skip_i\n  l1_step1_refines_a0i_skip_i l1_step2_refines_a0i_running_skip_i\n  l1_step3_refines_a0i_commit_skip_i l1_step4_refines_a0i_skip_i"], ["", "lemma l1_refines_init_a0i_i [iff]:\n  \"init l1 \\<subseteq> R01iai `` (init a0i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init l1 \\<subseteq> R01iai `` init a0i", "by (auto simp add: R01iai_def a0i_defs l1_defs)"], ["", "lemma l1_refines_trans_a0i_i [iff]:\n  \"{R01iai \\<inter> (UNIV \\<times> (l1_inv1 \\<inter> l1_inv2))} trans a0i, trans l1 {> R01iai}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01iai \\<inter>\n     UNIV \\<times>\n     (l1_inv1 \\<inter> l1_inv2)} TS.trans a0i, TS.trans l1 {> R01iai}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {R01iai \\<inter>\n     UNIV \\<times>\n     (l1_inv1 \\<inter> l1_inv2)} TS.trans a0i, TS.trans l1 {> R01iai}", "let ?pre' = \"R01iai \\<inter> (UNIV \\<times> l1_inv3)\""], ["proof (state)\ngoal (1 subgoal):\n 1. {R01iai \\<inter>\n     UNIV \\<times>\n     (l1_inv1 \\<inter> l1_inv2)} TS.trans a0i, TS.trans l1 {> R01iai}", "show ?thesis (is \"{?pre} ?t1, ?t2 {>?post}\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01iai \\<inter>\n     UNIV \\<times>\n     (l1_inv1 \\<inter> l1_inv2)} TS.trans a0i, TS.trans l1 {> R01iai}", "proof (rule relhoare_conseq_left)"], ["proof (state)\ngoal (2 subgoals):\n 1. {?pre'} TS.trans a0i, TS.trans l1 {> R01iai}\n 2. R01iai \\<inter> UNIV \\<times> (l1_inv1 \\<inter> l1_inv2)\n    \\<subseteq> ?pre'", "show \"?pre \\<subseteq> ?pre'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R01iai \\<inter> UNIV \\<times> (l1_inv1 \\<inter> l1_inv2)\n    \\<subseteq> R01iai \\<inter> UNIV \\<times> l1_inv3", "using l1_inv3_derived"], ["proof (prove)\nusing this:\n  l1_inv1 \\<inter> l1_inv2 \\<subseteq> l1_inv3\n\ngoal (1 subgoal):\n 1. R01iai \\<inter> UNIV \\<times> (l1_inv1 \\<inter> l1_inv2)\n    \\<subseteq> R01iai \\<inter> UNIV \\<times> l1_inv3", "by blast"], ["proof (state)\nthis:\n  R01iai \\<inter> UNIV \\<times> (l1_inv1 \\<inter> l1_inv2)\n  \\<subseteq> R01iai \\<inter> UNIV \\<times> l1_inv3\n\ngoal (1 subgoal):\n 1. {R01iai \\<inter>\n     UNIV \\<times> l1_inv3} TS.trans a0i, TS.trans l1 {> R01iai}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {R01iai \\<inter>\n     UNIV \\<times> l1_inv3} TS.trans a0i, TS.trans l1 {> R01iai}", "show \"{?pre'} ?t1, ?t2 {> ?post}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01iai \\<inter>\n     UNIV \\<times> l1_inv3} TS.trans a0i, TS.trans l1 {> R01iai}", "apply (auto simp add: a0i_def l1_def a0i_trans_def l1_trans_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xb xc.\n       {R01iai \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step1 x xb xc {> R01iai}\n 2. \\<And>xa xb xc xd.\n       {R01iai \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step2 xa xb xc xd {> R01iai}\n 3. \\<And>x xb xc xd.\n       {R01iai \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step3 x xb xc xd {> R01iai}\n 4. \\<And>xa xb xc xd.\n       {R01iai \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step4 xa xb xc xd {> R01iai}\n 5. \\<And>x.\n       {R01iai \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x xa))))\\<^sup>=, l1_learn x {> R01iai}", "prefer 2"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>xa xb xc xd.\n       {R01iai \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step2 xa xb xc xd {> R01iai}\n 2. \\<And>x xb xc.\n       {R01iai \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step1 x xb xc {> R01iai}\n 3. \\<And>x xb xc xd.\n       {R01iai \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step3 x xb xc xd {> R01iai}\n 4. \\<And>xa xb xc xd.\n       {R01iai \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step4 xa xb xc xd {> R01iai}\n 5. \\<And>x.\n       {R01iai \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x xa))))\\<^sup>=, l1_learn x {> R01iai}", "using l1_step2_refines_a0i_running_skip_i"], ["proof (prove)\nusing this:\n  {R01iai} (a0i_running ?A ?B\n             (Exp ?gnx\n               (NonceF\n                 (?Rb $ ny))))\\<^sup>=, l1_step2 ?Rb ?A ?B ?gnx {> R01iai}\n\ngoal (5 subgoals):\n 1. \\<And>xa xb xc xd.\n       {R01iai \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step2 xa xb xc xd {> R01iai}\n 2. \\<And>x xb xc.\n       {R01iai \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step1 x xb xc {> R01iai}\n 3. \\<And>x xb xc xd.\n       {R01iai \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step3 x xb xc xd {> R01iai}\n 4. \\<And>xa xb xc xd.\n       {R01iai \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step4 xa xb xc xd {> R01iai}\n 5. \\<And>x.\n       {R01iai \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x xa))))\\<^sup>=, l1_learn x {> R01iai}", "apply (simp add: PO_rhoare_defs, blast)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xb xc.\n       {R01iai \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step1 x xb xc {> R01iai}\n 2. \\<And>x xb xc xd.\n       {R01iai \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step3 x xb xc xd {> R01iai}\n 3. \\<And>xa xb xc xd.\n       {R01iai \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step4 xa xb xc xd {> R01iai}\n 4. \\<And>x.\n       {R01iai \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x xa))))\\<^sup>=, l1_learn x {> R01iai}", "prefer 2"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xb xc xd.\n       {R01iai \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step3 x xb xc xd {> R01iai}\n 2. \\<And>x xb xc.\n       {R01iai \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step1 x xb xc {> R01iai}\n 3. \\<And>xa xb xc xd.\n       {R01iai \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step4 xa xb xc xd {> R01iai}\n 4. \\<And>x.\n       {R01iai \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x xa))))\\<^sup>=, l1_learn x {> R01iai}", "using l1_step3_refines_a0i_commit_skip_i"], ["proof (prove)\nusing this:\n  {R01iai \\<inter>\n   UNIV \\<times>\n   l1_inv3} (a0i_commit ?A ?B\n              (Exp ?gny\n                (NonceF\n                  (?Ra $ nx))))\\<^sup>=, l1_step3 ?Ra ?A ?B ?gny {> R01iai}\n\ngoal (4 subgoals):\n 1. \\<And>x xb xc xd.\n       {R01iai \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step3 x xb xc xd {> R01iai}\n 2. \\<And>x xb xc.\n       {R01iai \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step1 x xb xc {> R01iai}\n 3. \\<And>xa xb xc xd.\n       {R01iai \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step4 xa xb xc xd {> R01iai}\n 4. \\<And>x.\n       {R01iai \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x xa))))\\<^sup>=, l1_learn x {> R01iai}", "apply (simp add: PO_rhoare_defs, blast)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xb xc.\n       {R01iai \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step1 x xb xc {> R01iai}\n 2. \\<And>xa xb xc xd.\n       {R01iai \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step4 xa xb xc xd {> R01iai}\n 3. \\<And>x.\n       {R01iai \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x xa))))\\<^sup>=, l1_learn x {> R01iai}", "apply (blast intro!:l1_trans_refines_a0i_trans_i)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {R01iai \\<inter>\n   UNIV \\<times> l1_inv3} TS.trans a0i, TS.trans l1 {> R01iai}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {R01iai \\<inter>\n   UNIV \\<times>\n   (l1_inv1 \\<inter> l1_inv2)} TS.trans a0i, TS.trans l1 {> R01iai}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma obs_consistent_med01iai [iff]: \n  \"obs_consistent R01iai med01iai a0i l1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent R01iai med01iai a0i l1", "by (auto simp add: obs_consistent_def R01iai_def med01iai_def)"], ["", "text \\<open>Refinement result.\\<close>"], ["", "lemma l1_refines_a0i_i [iff]: \n  \"refines \n     (R01iai \\<inter> (reach a0i \\<times> (l1_inv1 \\<inter> l1_inv2)))\n     med01iai a0i l1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines (R01iai \\<inter> reach a0i \\<times> (l1_inv1 \\<inter> l1_inv2))\n     med01iai a0i l1", "by (rule Refinement_using_invariants, auto)"], ["", "lemma  l1_implements_a0i_i [iff]: \"implements med01iai a0i l1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements med01iai a0i l1", "by (rule refinement_soundness) (fast)"], ["", "(**************************************************************************************************)"], ["", "subsection \\<open>Derived invariants: injective agreement (@{term \"Init\"} authenticates @{term \"Resp\"})\\<close>"], ["", "(**************************************************************************************************)"], ["", "definition \n  l1_iagreement_Init :: \"('a l1_state_scheme) set\"\nwhere\n  \"l1_iagreement_Init \\<equiv> {s. \\<forall> A B N. \n     signalsInit s (Commit A B N) \\<le> signalsInit s (Running A B N)\n  }\""], ["", "lemmas l1_iagreement_InitI = l1_iagreement_Init_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas l1_iagreement_InitE [elim] = l1_iagreement_Init_def [THEN setc_def_to_elim, rule_format]"], ["", "lemma l1_obs_iagreement_Init [iff]: \"oreach l1 \\<subseteq> l1_iagreement_Init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oreach l1 \\<subseteq> l1_iagreement_Init", "apply (rule external_invariant_translation \n         [OF PO_a0i_obs_agreement _ l1_implements_a0i_i])"], ["proof (prove)\ngoal (1 subgoal):\n 1. med01iai -` a0i_agreement \\<subseteq> l1_iagreement_Init", "apply (auto simp add: med01iai_def l1_iagreement_Init_def a0i_agreement_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma l1_iagreement_Init [iff]: \"reach l1 \\<subseteq> l1_iagreement_Init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l1 \\<subseteq> l1_iagreement_Init", "by (rule external_to_internal_invariant [OF l1_obs_iagreement_Init], auto)"], ["", "(**************************************************************************************************)"], ["", "subsection \\<open>Refinement: injective agreement  (@{term \"Resp\"} authenticates @{term \"Init\"})\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>Mediator function.\\<close>"], ["", "definition \n  med01iar :: \"l1_obs \\<Rightarrow> a0i_obs\"\nwhere\n  \"med01iar t \\<equiv> \\<lparr>a0n_state.signals = signalsResp t\\<rparr>\""], ["", "text \\<open>Relation between states.\\<close>"], ["", "definition\n  R01iar :: \"(a0i_state * l1_state) set\"\nwhere\n  \"R01iar \\<equiv> {(s,s').\n    a0n_state.signals s = signalsResp s'\n    }\""], ["", "text \\<open>Protocol-independent events.\\<close>"], ["", "lemma l1_learn_refines_a0_ia_skip_r:\n  \"{R01iar} Id, l1_learn m {>R01iar}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01iar} Id, l1_learn m {> R01iar}", "apply (auto simp add: PO_rhoare_defs R01iar_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>signals a = signalsResp y; (y, b) \\<in> l1_learn m\\<rbrakk>\n       \\<Longrightarrow> signalsResp y = signalsResp b", "apply (simp add: l1_learn_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Protocol events.\\<close>"], ["", "lemma l1_step1_refines_a0i_skip_r:\n  \"{R01iar} Id, l1_step1 Ra A B {>R01iar}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01iar} Id, l1_step1 Ra A B {> R01iar}", "by (auto simp add: PO_rhoare_defs R01iar_def l1_step1_def)"], ["", "lemma l1_step2_refines_a0i_skip_r:\n  \"{R01iar} Id, l1_step2 Rb A B gnx {>R01iar}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01iar} Id, l1_step2 Rb A B gnx {> R01iar}", "by (auto simp add: PO_rhoare_defs R01iar_def, auto simp add:l1_step2_def)"], ["", "lemma l1_step3_refines_a0i_running_skip_r:\n  \"{R01iar} a0i_running A B (Exp gny (NonceF (Ra$nx))) \\<union> Id, l1_step3 Ra A B gny {>R01iar}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01iar} (a0i_running A B\n               (Exp gny\n                 (NonceF\n                   (Ra $ nx))))\\<^sup>=, l1_step3 Ra A B gny {> R01iar}", "by (auto simp add: PO_rhoare_defs R01iar_def, simp_all add: l1_step3_def a0i_running_def, auto)"], ["", "lemma l1_step4_refines_a0i_commit_skip_r:\n  \"{R01iar \\<inter> UNIV\\<times>l1_inv6} \n     a0i_commit A B (Exp gnx (NonceF (Rb$ny))) \\<union> Id, \n     l1_step4 Rb A B gnx \n   {>R01iar}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01iar \\<inter>\n     UNIV \\<times>\n     l1_inv6} (a0i_commit A B\n                (Exp gnx\n                  (NonceF\n                    (Rb $ ny))))\\<^sup>=, l1_step4 Rb A B gnx {> R01iar}", "apply (auto simp add: PO_rhoare_defs R01iar_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>signals a = signalsResp y; y \\<in> l1_inv6;\n        (y, b) \\<in> l1_step4 Rb A B gnx\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            ((a, y)\n                             \\<in> a0i_commit A B\n                                    (Exp gnx (NonceF (Rb $ ny))) \\<or>\n                             a = y) \\<and>\n                            signals y = signalsResp b", "apply (auto simp add: l1_step4_def a0i_commit_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a y Ra.\n       \\<lbrakk>signals a = signalsResp y; y \\<in> l1_inv6;\n        guessed_runs Rb =\n        \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        progress y Rb = Some {xny, xgnx, xgny, xsk};\n        guessed_frame Rb xgnx = Some (Exp Gen (NonceF (Ra $ nx)));\n        guessed_runs Ra =\n        \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        in_progressS (progress y Ra) {xnx, xgnx, xgny, xsk, xEnd};\n        guessed_frame Ra xgny = Some (Exp Gen (NonceF (Rb $ ny)));\n        Rb \\<noteq> test; can_signal y A B;\n        gnx = Exp Gen (NonceF (Ra $ nx))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            (signalsResp y\n                              (Commit A B\n                                (Exp (Exp Gen (NonceF (Ra $ nx)))\n                                  (NonceF (Rb $ ny))))\n                             < signalsResp y\n                                (Running A B\n                                  (Exp (Exp Gen (NonceF (Ra $ nx)))\n                                    (NonceF (Rb $ ny)))) \\<and>\n                             ya = a\n                             \\<lparr>signals := (signalsResp y)\n (Commit A B (Exp (Exp Gen (NonceF (Ra $ nx))) (NonceF (Rb $ ny))) :=\n    Suc (signalsResp y\n          (Commit A B\n            (Exp (Exp Gen (NonceF (Ra $ nx)))\n              (NonceF (Rb $ ny))))))\\<rparr> \\<or>\n                             a = ya) \\<and>\n                            signals ya = (signalsResp y)\n                            (Commit A B\n                              (Exp (Exp Gen (NonceF (Ra $ nx)))\n                                (NonceF (Rb $ ny))) :=\n                               Suc (signalsResp y\n                                     (Commit A B\n (Exp (Exp Gen (NonceF (Ra $ nx))) (NonceF (Rb $ ny))))))\n 2. \\<And>a y Ra.\n       \\<lbrakk>signals a = signalsResp y; y \\<in> l1_inv6;\n        guessed_runs Rb =\n        \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        progress y Rb = Some {xny, xgnx, xgny, xsk};\n        guessed_frame Rb xgnx = Some (Exp Gen (NonceF (Ra $ nx)));\n        guessed_runs Ra =\n        \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        in_progressS (progress y Ra) {xnx, xgnx, xgny, xsk, xEnd};\n        guessed_frame Ra xgny = Some (Exp Gen (NonceF (Rb $ ny)));\n        Exp (Exp Gen (NonceF (Ra $ nx))) (NonceF (test $ ny))\n        \\<notin> synth (analz (ik y));\n        can_signal y A B; gnx = Exp Gen (NonceF (Ra $ nx))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            (signalsResp y\n                              (Commit A B\n                                (Exp (Exp Gen (NonceF (Ra $ nx)))\n                                  (NonceF (Rb $ ny))))\n                             < signalsResp y\n                                (Running A B\n                                  (Exp (Exp Gen (NonceF (Ra $ nx)))\n                                    (NonceF (Rb $ ny)))) \\<and>\n                             ya = a\n                             \\<lparr>signals := (signalsResp y)\n (Commit A B (Exp (Exp Gen (NonceF (Ra $ nx))) (NonceF (Rb $ ny))) :=\n    Suc (signalsResp y\n          (Commit A B\n            (Exp (Exp Gen (NonceF (Ra $ nx)))\n              (NonceF (Rb $ ny))))))\\<rparr> \\<or>\n                             a = ya) \\<and>\n                            signals ya = (signalsResp y)\n                            (Commit A B\n                              (Exp (Exp Gen (NonceF (Ra $ nx)))\n                                (NonceF (Rb $ ny))) :=\n                               Suc (signalsResp y\n                                     (Commit A B\n (Exp (Exp Gen (NonceF (Ra $ nx))) (NonceF (Rb $ ny))))))", "apply (auto dest!: l1_inv6D [rotated 1])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Refinement proofs.\\<close>"], ["", "lemmas l1_trans_refines_a0i_trans_r = \n  l1_learn_refines_a0_ia_skip_r\n  l1_step1_refines_a0i_skip_r l1_step2_refines_a0i_skip_r\n  l1_step3_refines_a0i_running_skip_r l1_step4_refines_a0i_commit_skip_r"], ["", "lemma l1_refines_init_a0i_r [iff]:\n  \"init l1 \\<subseteq> R01iar `` (init a0i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init l1 \\<subseteq> R01iar `` init a0i", "by (auto simp add: R01iar_def a0i_defs l1_defs)"], ["", "lemma l1_refines_trans_a0i_r [iff]:\n  \"{R01iar \\<inter> (UNIV \\<times> (l1_inv4 \\<inter> l1_inv5))} trans a0i, trans l1 {> R01iar}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01iar \\<inter>\n     UNIV \\<times>\n     (l1_inv4 \\<inter> l1_inv5)} TS.trans a0i, TS.trans l1 {> R01iar}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {R01iar \\<inter>\n     UNIV \\<times>\n     (l1_inv4 \\<inter> l1_inv5)} TS.trans a0i, TS.trans l1 {> R01iar}", "let ?pre' = \"R01iar \\<inter> (UNIV \\<times> l1_inv6)\""], ["proof (state)\ngoal (1 subgoal):\n 1. {R01iar \\<inter>\n     UNIV \\<times>\n     (l1_inv4 \\<inter> l1_inv5)} TS.trans a0i, TS.trans l1 {> R01iar}", "show ?thesis (is \"{?pre} ?t1, ?t2 {>?post}\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01iar \\<inter>\n     UNIV \\<times>\n     (l1_inv4 \\<inter> l1_inv5)} TS.trans a0i, TS.trans l1 {> R01iar}", "proof (rule relhoare_conseq_left)"], ["proof (state)\ngoal (2 subgoals):\n 1. {?pre'} TS.trans a0i, TS.trans l1 {> R01iar}\n 2. R01iar \\<inter> UNIV \\<times> (l1_inv4 \\<inter> l1_inv5)\n    \\<subseteq> ?pre'", "show \"?pre \\<subseteq> ?pre'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R01iar \\<inter> UNIV \\<times> (l1_inv4 \\<inter> l1_inv5)\n    \\<subseteq> R01iar \\<inter> UNIV \\<times> l1_inv6", "using l1_inv6_derived"], ["proof (prove)\nusing this:\n  l1_inv4 \\<inter> l1_inv5 \\<subseteq> l1_inv6\n\ngoal (1 subgoal):\n 1. R01iar \\<inter> UNIV \\<times> (l1_inv4 \\<inter> l1_inv5)\n    \\<subseteq> R01iar \\<inter> UNIV \\<times> l1_inv6", "by blast"], ["proof (state)\nthis:\n  R01iar \\<inter> UNIV \\<times> (l1_inv4 \\<inter> l1_inv5)\n  \\<subseteq> R01iar \\<inter> UNIV \\<times> l1_inv6\n\ngoal (1 subgoal):\n 1. {R01iar \\<inter>\n     UNIV \\<times> l1_inv6} TS.trans a0i, TS.trans l1 {> R01iar}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {R01iar \\<inter>\n     UNIV \\<times> l1_inv6} TS.trans a0i, TS.trans l1 {> R01iar}", "show \"{?pre'} ?t1, ?t2 {> ?post}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01iar \\<inter>\n     UNIV \\<times> l1_inv6} TS.trans a0i, TS.trans l1 {> R01iar}", "apply (auto simp add: a0i_def l1_def a0i_trans_def l1_trans_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xb xc.\n       {R01iar \\<inter>\n        UNIV \\<times>\n        l1_inv6} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step1 x xb xc {> R01iar}\n 2. \\<And>xa xb xc xd.\n       {R01iar \\<inter>\n        UNIV \\<times>\n        l1_inv6} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step2 xa xb xc xd {> R01iar}\n 3. \\<And>x xb xc xd.\n       {R01iar \\<inter>\n        UNIV \\<times>\n        l1_inv6} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step3 x xb xc xd {> R01iar}\n 4. \\<And>xa xb xc xd.\n       {R01iar \\<inter>\n        UNIV \\<times>\n        l1_inv6} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step4 xa xb xc xd {> R01iar}\n 5. \\<And>x.\n       {R01iar \\<inter>\n        UNIV \\<times>\n        l1_inv6} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x xa))))\\<^sup>=, l1_learn x {> R01iar}", "prefer 3"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x xb xc xd.\n       {R01iar \\<inter>\n        UNIV \\<times>\n        l1_inv6} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step3 x xb xc xd {> R01iar}\n 2. \\<And>x xb xc.\n       {R01iar \\<inter>\n        UNIV \\<times>\n        l1_inv6} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step1 x xb xc {> R01iar}\n 3. \\<And>xa xb xc xd.\n       {R01iar \\<inter>\n        UNIV \\<times>\n        l1_inv6} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step2 xa xb xc xd {> R01iar}\n 4. \\<And>xa xb xc xd.\n       {R01iar \\<inter>\n        UNIV \\<times>\n        l1_inv6} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step4 xa xb xc xd {> R01iar}\n 5. \\<And>x.\n       {R01iar \\<inter>\n        UNIV \\<times>\n        l1_inv6} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x xa))))\\<^sup>=, l1_learn x {> R01iar}", "using l1_step3_refines_a0i_running_skip_r"], ["proof (prove)\nusing this:\n  {R01iar} (a0i_running ?A ?B\n             (Exp ?gny\n               (NonceF\n                 (?Ra $ nx))))\\<^sup>=, l1_step3 ?Ra ?A ?B ?gny {> R01iar}\n\ngoal (5 subgoals):\n 1. \\<And>x xb xc xd.\n       {R01iar \\<inter>\n        UNIV \\<times>\n        l1_inv6} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step3 x xb xc xd {> R01iar}\n 2. \\<And>x xb xc.\n       {R01iar \\<inter>\n        UNIV \\<times>\n        l1_inv6} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step1 x xb xc {> R01iar}\n 3. \\<And>xa xb xc xd.\n       {R01iar \\<inter>\n        UNIV \\<times>\n        l1_inv6} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step2 xa xb xc xd {> R01iar}\n 4. \\<And>xa xb xc xd.\n       {R01iar \\<inter>\n        UNIV \\<times>\n        l1_inv6} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step4 xa xb xc xd {> R01iar}\n 5. \\<And>x.\n       {R01iar \\<inter>\n        UNIV \\<times>\n        l1_inv6} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x xa))))\\<^sup>=, l1_learn x {> R01iar}", "apply (simp add: PO_rhoare_defs, blast)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xb xc.\n       {R01iar \\<inter>\n        UNIV \\<times>\n        l1_inv6} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step1 x xb xc {> R01iar}\n 2. \\<And>xa xb xc xd.\n       {R01iar \\<inter>\n        UNIV \\<times>\n        l1_inv6} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step2 xa xb xc xd {> R01iar}\n 3. \\<And>xa xb xc xd.\n       {R01iar \\<inter>\n        UNIV \\<times>\n        l1_inv6} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step4 xa xb xc xd {> R01iar}\n 4. \\<And>x.\n       {R01iar \\<inter>\n        UNIV \\<times>\n        l1_inv6} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x xa))))\\<^sup>=, l1_learn x {> R01iar}", "prefer 3"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa xb xc xd.\n       {R01iar \\<inter>\n        UNIV \\<times>\n        l1_inv6} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step4 xa xb xc xd {> R01iar}\n 2. \\<And>x xb xc.\n       {R01iar \\<inter>\n        UNIV \\<times>\n        l1_inv6} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step1 x xb xc {> R01iar}\n 3. \\<And>xa xb xc xd.\n       {R01iar \\<inter>\n        UNIV \\<times>\n        l1_inv6} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step2 xa xb xc xd {> R01iar}\n 4. \\<And>x.\n       {R01iar \\<inter>\n        UNIV \\<times>\n        l1_inv6} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x xa))))\\<^sup>=, l1_learn x {> R01iar}", "using l1_step4_refines_a0i_commit_skip_r"], ["proof (prove)\nusing this:\n  {R01iar \\<inter>\n   UNIV \\<times>\n   l1_inv6} (a0i_commit ?A ?B\n              (Exp ?gnx\n                (NonceF\n                  (?Rb $ ny))))\\<^sup>=, l1_step4 ?Rb ?A ?B ?gnx {> R01iar}\n\ngoal (4 subgoals):\n 1. \\<And>xa xb xc xd.\n       {R01iar \\<inter>\n        UNIV \\<times>\n        l1_inv6} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step4 xa xb xc xd {> R01iar}\n 2. \\<And>x xb xc.\n       {R01iar \\<inter>\n        UNIV \\<times>\n        l1_inv6} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step1 x xb xc {> R01iar}\n 3. \\<And>xa xb xc xd.\n       {R01iar \\<inter>\n        UNIV \\<times>\n        l1_inv6} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step2 xa xb xc xd {> R01iar}\n 4. \\<And>x.\n       {R01iar \\<inter>\n        UNIV \\<times>\n        l1_inv6} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x xa))))\\<^sup>=, l1_learn x {> R01iar}", "apply (simp add: PO_rhoare_defs, blast)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xb xc.\n       {R01iar \\<inter>\n        UNIV \\<times>\n        l1_inv6} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step1 x xb xc {> R01iar}\n 2. \\<And>xa xb xc xd.\n       {R01iar \\<inter>\n        UNIV \\<times>\n        l1_inv6} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step2 xa xb xc xd {> R01iar}\n 3. \\<And>x.\n       {R01iar \\<inter>\n        UNIV \\<times>\n        l1_inv6} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x xa))))\\<^sup>=, l1_learn x {> R01iar}", "apply (blast intro!:l1_trans_refines_a0i_trans_r)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {R01iar \\<inter>\n   UNIV \\<times> l1_inv6} TS.trans a0i, TS.trans l1 {> R01iar}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {R01iar \\<inter>\n   UNIV \\<times>\n   (l1_inv4 \\<inter> l1_inv5)} TS.trans a0i, TS.trans l1 {> R01iar}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma obs_consistent_med01iar [iff]: \n  \"obs_consistent R01iar med01iar a0i l1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent R01iar med01iar a0i l1", "by (auto simp add: obs_consistent_def R01iar_def med01iar_def)"], ["", "text \\<open>Refinement result.\\<close>"], ["", "lemma l1_refines_a0i_r [iff]: \n  \"refines \n     (R01iar \\<inter> (reach a0i \\<times> (l1_inv4 \\<inter> l1_inv5)))\n     med01iar a0i l1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines (R01iar \\<inter> reach a0i \\<times> (l1_inv4 \\<inter> l1_inv5))\n     med01iar a0i l1", "by (rule Refinement_using_invariants, auto)"], ["", "lemma  l1_implements_a0i_r [iff]: \"implements med01iar a0i l1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements med01iar a0i l1", "by (rule refinement_soundness) (fast)"], ["", "(**************************************************************************************************)"], ["", "subsection \\<open>Derived invariants: injective agreement (@{term \"Resp\"} authenticates @{term \"Init\"})\\<close>"], ["", "(**************************************************************************************************)"], ["", "definition \n  l1_iagreement_Resp :: \"('a l1_state_scheme) set\"\nwhere\n  \"l1_iagreement_Resp \\<equiv> {s. \\<forall> A B N. \n     signalsResp s (Commit A B N) \\<le> signalsResp s (Running A B N)\n  }\""], ["", "lemmas l1_iagreement_RespI = l1_iagreement_Resp_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas l1_iagreement_RespE [elim] = l1_iagreement_Resp_def [THEN setc_def_to_elim, rule_format]"], ["", "lemma l1_obs_iagreement_Resp [iff]: \"oreach l1 \\<subseteq> l1_iagreement_Resp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oreach l1 \\<subseteq> l1_iagreement_Resp", "apply (rule external_invariant_translation \n         [OF PO_a0i_obs_agreement _ l1_implements_a0i_r])"], ["proof (prove)\ngoal (1 subgoal):\n 1. med01iar -` a0i_agreement \\<subseteq> l1_iagreement_Resp", "apply (auto simp add: med01iar_def l1_iagreement_Resp_def a0i_agreement_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma l1_iagreement_Resp [iff]: \"reach l1 \\<subseteq> l1_iagreement_Resp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l1 \\<subseteq> l1_iagreement_Resp", "by (rule external_to_internal_invariant [OF l1_obs_iagreement_Resp], auto)"], ["", "end"]]}