{"file_name": "/home/qj213/afp-2021-10-22/thys/Key_Agreement_Strong_Adversaries/pfslvl3.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Key_Agreement_Strong_Adversaries", "problem_names": ["lemma parts_ik_init [simp]: \"parts ik_init = ik_init\"", "lemma analz_ik_init [simp]: \"analz ik_init = ik_init\"", "lemma abs_ik_init [iff]: \"abs ik_init = {}\"", "lemma payloadSet_ik_init [iff]: \"ik_init \\<inter> payload = {}\"", "lemma validSet_ik_init [iff]: \"ik_init \\<inter> valid = {}\"", "lemmas l3_init_defs = l3_init_def ik_init_def", "lemmas l3_loc_defs = \n  l3_step1_def l3_step2_def l3_step3_def\n  l3_def l3_init_defs l3_trans_def\n  l3_dy_def\n  l3_lkr_others_def l3_lkr_after_def l3_skr_def", "lemmas l3_defs = l3_loc_defs ik_dy_def", "lemmas l3_nostep_defs = l3_def l3_init_def l3_trans_def", "lemma l3_obs_id [simp]: \"obs l3 = id\"", "lemmas l3_inv1I = l3_inv1_def [THEN setc_def_to_intro, rule_format]", "lemmas l3_inv1E [elim] = l3_inv1_def [THEN setc_def_to_elim, rule_format]", "lemmas l3_inv1D = l3_inv1_def [THEN setc_def_to_dest, rule_format]", "lemma l3_inv1D' [dest]: \"\\<lbrakk> LtK K \\<in> parts (ik s); s \\<in> l3_inv1\\<rbrakk> \\<Longrightarrow> LtK K \\<in> ik s\"", "lemma l3_inv1_init [iff]:\n  \"init l3 \\<subseteq> l3_inv1\"", "lemma l3_inv1_trans [iff]:\n  \"{l3_inv1} trans l3 {> l3_inv1}\"", "lemma PO_l3_inv1 [iff]:\n  \"reach l3 \\<subseteq> l3_inv1\"", "lemmas l3_inv2I = l3_inv2_def [THEN setc_def_to_intro, rule_format]", "lemmas l3_inv2E [elim] = l3_inv2_def [THEN setc_def_to_elim, rule_format]", "lemmas l3_inv2D = l3_inv2_def [THEN setc_def_to_dest, rule_format]", "lemma l3_inv2_init [simp,intro!]:\n  \"init l3 \\<subseteq> l3_inv2\"", "lemma l3_inv2_trans [simp,intro!]:\n  \"{l3_inv2 \\<inter> l3_inv1} trans l3 {> l3_inv2}\"", "lemma PO_l3_inv2 [iff]: \"reach l3 \\<subseteq> l3_inv2\"", "lemmas l3_inv3I = l3_inv3_def [THEN setc_def_to_intro, rule_format]", "lemmas l3_inv3E = l3_inv3_def [THEN setc_def_to_elim, rule_format]", "lemmas l3_inv3D = l3_inv3_def [THEN setc_def_to_dest, rule_format]", "lemma l3_inv3_init [iff]:\n  \"init l3 \\<subseteq> l3_inv3\"", "lemma l3_inv3_trans [simp,intro!]:\n  \"{l3_inv3} trans l3 {> l3_inv3}\"", "lemma PO_l3_inv3 [iff]: \"reach l3 \\<subseteq> l3_inv3\"", "lemmas l3_inv4I = l3_inv4_def [THEN setc_def_to_intro, rule_format]", "lemmas l3_inv4E [elim] = l3_inv4_def [THEN setc_def_to_elim, rule_format]", "lemmas l3_inv4D = l3_inv4_def [THEN setc_def_to_dest, rule_format]", "lemma l3_inv4_init [simp,intro!]:\n  \"init l3 \\<subseteq> l3_inv4\"", "lemma l3_inv4_trans [simp,intro!]:\n  \"{l3_inv4} trans l3 {> l3_inv4}\"", "lemma PO_l3_inv4 [simp,intro!]: \"reach l3 \\<subseteq> l3_inv4\"", "lemmas l3_inv5I = l3_inv5_def [THEN setc_def_to_intro, rule_format]", "lemmas l3_inv5E = l3_inv5_def [THEN setc_def_to_elim, rule_format]", "lemmas l3_inv5D = l3_inv5_def [THEN setc_def_to_dest, rule_format]", "lemma l3_inv5_derived: \"l3_inv2 \\<inter> l3_inv3 \\<subseteq> l3_inv5\"", "lemma PO_l3_inv5 [simp,intro!]: \"reach l3 \\<subseteq> l3_inv5\"", "lemmas l3_inv6I = l3_inv6_def [THEN setc_def_to_intro, rule_format]", "lemmas l3_inv6E = l3_inv6_def [THEN setc_def_to_elim, rule_format]", "lemmas l3_inv6D = l3_inv6_def [THEN setc_def_to_dest, rule_format]", "lemma l3_inv6_derived [simp,intro!]:\n  \"l3_inv3 \\<inter> l3_inv4 \\<subseteq> l3_inv6\"", "lemma PO_l3_inv6 [simp,intro!]: \"reach l3 \\<subseteq> l3_inv6\"", "lemmas l3_inv7I = l3_inv7_def [THEN setc_def_to_intro, rule_format]", "lemmas l3_inv7E = l3_inv7_def [THEN setc_def_to_elim, rule_format]", "lemmas l3_inv7D = l3_inv7_def [THEN setc_def_to_dest, rule_format]", "lemma l3_inv7_derived [simp,intro!]:\n  \"l3_inv3 \\<inter> l3_inv4 \\<subseteq> l3_inv7\"", "lemma PO_l3_inv7 [simp,intro!]: \"reach l3 \\<subseteq> l3_inv7\"", "lemmas l3_inv8I = l3_inv8_def [THEN setc_def_to_intro, rule_format]", "lemmas l3_inv8E = l3_inv8_def [THEN setc_def_to_elim, rule_format]", "lemmas l3_inv8D = l3_inv8_def [THEN setc_def_to_dest, rule_format]", "lemma l3_inv8_derived [iff]:\n  \"l3_inv2 \\<inter> l3_inv3 \\<inter> l3_inv4 \\<subseteq> l3_inv8\"", "lemma PO_l3_inv8 [iff]: \"reach l3 \\<subseteq> l3_inv8\"", "lemmas l3_inv9I = l3_inv9_def [THEN setc_def_to_intro, rule_format]", "lemmas l3_inv9E = l3_inv9_def [THEN setc_def_to_elim, rule_format]", "lemmas l3_inv9D = l3_inv9_def [THEN setc_def_to_dest, rule_format]", "lemma l3_inv9_derived [iff]:\n  \"l3_inv2 \\<inter> l3_inv3 \\<inter> l3_inv4 \\<subseteq> l3_inv9\"", "lemma PO_l3_inv9 [iff]: \"reach l3 \\<subseteq> l3_inv9\"", "lemmas R23s_defs = R23s_def med23s_def", "lemma R23sI: \n  \"\\<lbrakk> ik s = ik t \\<inter> payload; secret s = secret t; progress s = progress t; signals s = signals t;\n     chan s = abs (ik t); l2_state.bad s = bad t \\<rbrakk> \n \\<Longrightarrow> (s, t) \\<in> R23s\"", "lemma R23sD: \n  \"(s, t) \\<in> R23s \\<Longrightarrow>\n    ik s = ik t \\<inter> payload \\<and> secret s = secret t \\<and> progress s = progress t \\<and> signals s = signals t \\<and>\n    chan s = abs (ik t) \\<and> l2_state.bad s = bad t\"", "lemma R23sE [elim]: \n  \"\\<lbrakk> (s, t) \\<in> R23s;\n     \\<lbrakk> ik s = ik t \\<inter> payload; secret s = secret t; progress s = progress t; signals s = signals t;\n     chan s = abs (ik t); l2_state.bad s = bad t \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \n \\<Longrightarrow> P\"", "lemma can_signal_R23 [simp]:\n  \"(s2, s3) \\<in> R23s \\<Longrightarrow>\n   can_signal s2 A B \\<longleftrightarrow> can_signal s3 A B\"", "lemma l3_step1_refines_step1:\n  \"{R23s} l2_step1 Ra A B, l3_step1 Ra A B {>R23s}\"", "lemma l3_step2_refines_step2:\n  \"{R23s} l2_step2 Rb A B KE, l3_step2 Rb A B KE{>R23s}\"", "lemma l3_step3_refines_step3:\n  \"{R23s} l2_step3 Ra A B K, l3_step3 Ra A B K {>R23s}\"", "lemma l3_dy_payload_refines_dy_fake_msg:\n  \"M \\<in> payload \\<Longrightarrow>\n   {R23s \\<inter> UNIV \\<times> l3_inv5} l2_dy_fake_msg M, l3_dy M {>R23s}\"", "lemma l3_dy_valid_refines_dy_fake_chan:\n  \"\\<lbrakk> M \\<in> valid; M' \\<in> abs {M} \\<rbrakk> \\<Longrightarrow>\n   {R23s \\<inter> UNIV \\<times> (l3_inv5 \\<inter> l3_inv6 \\<inter> l3_inv7 \\<inter> l3_inv8 \\<inter> l3_inv9)} \n      l2_dy_fake_chan M', l3_dy M \n   {>R23s}\"", "lemma l3_dy_valid_refines_dy_fake_chan_Un:\n  \"M \\<in> valid \\<Longrightarrow>\n   {R23s \\<inter> UNIV \\<times> (l3_inv5 \\<inter> l3_inv6 \\<inter> l3_inv7 \\<inter> l3_inv8 \\<inter> l3_inv9)} \n      \\<Union>M'. l2_dy_fake_chan M', l3_dy M \n   {>R23s}\"", "lemma l3_dy_isLtKey_refines_skip:\n  \"{R23s} Id, l3_dy (LtK ltk) {>R23s}\"", "lemma l3_dy_others_refines_skip:\n  \"\\<lbrakk> M \\<notin> range LtK; M \\<notin> valid; M \\<notin> payload \\<rbrakk> \\<Longrightarrow> \n   {R23s} Id, l3_dy M {>R23s}\"", "lemma l3_dy_refines_dy_fake_msg_dy_fake_chan_skip:\n   \"{R23s \\<inter> UNIV \\<times> (l3_inv5 \\<inter> l3_inv6 \\<inter> l3_inv7 \\<inter> l3_inv8 \\<inter> l3_inv9)} \n      l2_dy_fake_msg M \\<union> (\\<Union>M'. l2_dy_fake_chan M') \\<union> Id, l3_dy M \n    {>R23s}\"", "lemma l3_lkr_others_refines_lkr_others:\n  \"{R23s} l2_lkr_others A, l3_lkr_others A {>R23s}\"", "lemma l3_lkr_after_refines_lkr_after:\n  \"{R23s} l2_lkr_after A, l3_lkr_after A {>R23s}\"", "lemma l3_skr_refines_skr:\n  \"{R23s} l2_skr R K, l3_skr R K {>R23s}\"", "lemmas l3_trans_refines_l2_trans = \n  l3_step1_refines_step1 l3_step2_refines_step2 l3_step3_refines_step3\n  l3_dy_refines_dy_fake_msg_dy_fake_chan_skip\n  l3_lkr_others_refines_lkr_others l3_lkr_after_refines_lkr_after l3_skr_refines_skr", "lemma l3_refines_init_l2 [iff]:\n  \"init l3 \\<subseteq> R23s `` (init l2)\"", "lemma l3_refines_trans_l2 [iff]:\n  \"{R23s \\<inter> (UNIV \\<times> (l3_inv1 \\<inter> l3_inv2 \\<inter> l3_inv3 \\<inter> l3_inv4))} trans l2, trans l3 {> R23s}\"", "lemma PO_obs_consistent_R23s [iff]: \n  \"obs_consistent R23s med23s l2 l3\"", "lemma l3_refines_l2 [iff]:\n  \"refines \n     (R23s \\<inter> \n      (reach l2 \\<times> (l3_inv1 \\<inter> l3_inv2 \\<inter> l3_inv3 \\<inter> l3_inv4)))\n     med23s l2 l3\"", "lemma l3_implements_l2 [iff]:\n  \"implements med23s l2 l3\"", "lemmas l3_inv10I = l3_inv10_def [THEN setc_def_to_intro, rule_format]", "lemmas l3_inv10E = l3_inv10_def [THEN setc_def_to_elim, rule_format]", "lemmas l3_inv10D = l3_inv10_def [THEN setc_def_to_dest, rule_format]", "lemma l3_inv10_init [iff]: \n  \"init l3 \\<subseteq> l3_inv10\"", "lemma l3_inv10_trans [iff]:\n  \"{l3_inv10} trans l3 {> l3_inv10}\"", "lemma PO_l3_inv10 [iff]: \"reach l3 \\<subseteq> l3_inv10\"", "lemma l3_obs_inv10 [iff]: \"oreach l3 \\<subseteq> l3_inv10\"", "lemma l3_obs_partial_secrecy [iff]: \"oreach l3 \\<subseteq> l3_partial_secrecy\"", "lemma l3_obs_inv5: \"oreach l3 \\<subseteq> l3_inv5\"", "lemma l3_obs_secrecy [iff]: \"oreach l3 \\<subseteq> l3_secrecy\"", "lemma l3_secrecy [iff]: \"reach l3 \\<subseteq> l3_secrecy\"", "lemma l3_obs_iagreement [iff]: \"oreach l3 \\<subseteq> l3_iagreement\"", "lemma l3_iagreement [iff]: \"reach l3 \\<subseteq> l3_iagreement\""], "translations": [["", "lemma parts_ik_init [simp]: \"parts ik_init = ik_init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts ik_init = ik_init", "by (auto elim!: parts.induct, auto simp add: ik_init_def)"], ["", "lemma analz_ik_init [simp]: \"analz ik_init = ik_init\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz ik_init = ik_init", "by (auto dest: analz_into_parts)"], ["", "lemma abs_ik_init [iff]: \"abs ik_init = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.abs ik_init = {}", "apply (auto elim!: absE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa A B M.\n       \\<lbrakk>M \\<in> payload;\n        implem (Chan xa A B M) \\<in> ik_init\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto simp add: ik_init_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma payloadSet_ik_init [iff]: \"ik_init \\<inter> payload = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ik_init \\<inter> payload = {}", "by (auto simp add: ik_init_def)"], ["", "lemma validSet_ik_init [iff]: \"ik_init \\<inter> valid = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ik_init \\<inter> valid = {}", "by (auto simp add: ik_init_def)"], ["", "definition \n  l3_init :: \"l3_state set\"\nwhere\n  \"l3_init \\<equiv> { \\<lparr>\n    ik = ik_init,\n    secret = {},\n    progress = Map.empty,\n    signals = \\<lambda>x. 0,\n    bad = bad_init\n    \\<rparr>}\""], ["", "lemmas l3_init_defs = l3_init_def ik_init_def"], ["", "definition \nl3_trans :: \"l3_trans\"\nwhere\n  \"l3_trans \\<equiv> (\\<Union>m M KE Rb Ra A B K.\n     l3_step1 Ra A B \\<union>\n     l3_step2 Rb A B KE \\<union>\n     l3_step3 Ra A B m \\<union>\n     l3_dy M \\<union>\n     l3_lkr_others A \\<union>\n     l3_lkr_after A \\<union>\n     l3_skr Ra K \\<union>\n     Id\n  )\""], ["", "definition \n  l3 :: \"(l3_state, l3_obs) spec\" where\n  \"l3 \\<equiv> \\<lparr>\n    init = l3_init,\n    trans = l3_trans,\n    obs = id\n  \\<rparr>\""], ["", "lemmas l3_loc_defs = \n  l3_step1_def l3_step2_def l3_step3_def\n  l3_def l3_init_defs l3_trans_def\n  l3_dy_def\n  l3_lkr_others_def l3_lkr_after_def l3_skr_def"], ["", "lemmas l3_defs = l3_loc_defs ik_dy_def"], ["", "lemmas l3_nostep_defs = l3_def l3_init_def l3_trans_def"], ["", "lemma l3_obs_id [simp]: \"obs l3 = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs l3 = id", "by (simp add: l3_def)"], ["", "(**************************************************************************************************)"], ["", "subsection \\<open>Invariants\\<close>"], ["", "(**************************************************************************************************)"], ["", "subsubsection \\<open>inv1: No long-term keys as message parts\\<close>"], ["", "(**************************************************************************************************)"], ["", "definition\n  l3_inv1 :: \"l3_state set\"\nwhere\n  \"l3_inv1 \\<equiv> {s.\n     parts (ik s) \\<inter> range LtK \\<subseteq> ik s\n  }\""], ["", "lemmas l3_inv1I = l3_inv1_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas l3_inv1E [elim] = l3_inv1_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas l3_inv1D = l3_inv1_def [THEN setc_def_to_dest, rule_format]"], ["", "lemma l3_inv1D' [dest]: \"\\<lbrakk> LtK K \\<in> parts (ik s); s \\<in> l3_inv1\\<rbrakk> \\<Longrightarrow> LtK K \\<in> ik s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>LtK K \\<in> parts (ik s); s \\<in> l3_inv1\\<rbrakk>\n    \\<Longrightarrow> LtK K \\<in> ik s", "by (auto simp add: l3_inv1_def)"], ["", "lemma l3_inv1_init [iff]:\n  \"init l3 \\<subseteq> l3_inv1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init l3 \\<subseteq> l3_inv1", "by (auto simp add: l3_def l3_init_def intro!:l3_inv1I)"], ["", "lemma l3_inv1_trans [iff]:\n  \"{l3_inv1} trans l3 {> l3_inv1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l3_inv1} TS.trans l3 {> l3_inv1}", "apply (auto simp add: PO_hoare_defs l3_nostep_defs intro!: l3_inv1I)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x xb xc xh xi xj.\n       \\<lbrakk>LtK xb \\<in> parts (ik x); xc \\<in> l3_inv1;\n        (xc, x) \\<in> l3_step1 xh xi xj\\<rbrakk>\n       \\<Longrightarrow> LtK xb \\<in> ik x\n 2. \\<And>x xb xc xf xg xi xj.\n       \\<lbrakk>LtK xb \\<in> parts (ik x); xc \\<in> l3_inv1;\n        (xc, x) \\<in> l3_step2 xg xi xj xf\\<rbrakk>\n       \\<Longrightarrow> LtK xb \\<in> ik x\n 3. \\<And>x xb xc xd xh xi xj.\n       \\<lbrakk>LtK xb \\<in> parts (ik x); xc \\<in> l3_inv1;\n        (xc, x) \\<in> l3_step3 xh xi xj xd\\<rbrakk>\n       \\<Longrightarrow> LtK xb \\<in> ik x\n 4. \\<And>x xb xc xe.\n       \\<lbrakk>LtK xb \\<in> parts (ik x); xc \\<in> l3_inv1;\n        (xc, x) \\<in> l3_dy xe\\<rbrakk>\n       \\<Longrightarrow> LtK xb \\<in> ik x\n 5. \\<And>x xb xc xi.\n       \\<lbrakk>LtK xb \\<in> parts (ik x); xc \\<in> l3_inv1;\n        (xc, x) \\<in> l3_lkr_others xi\\<rbrakk>\n       \\<Longrightarrow> LtK xb \\<in> ik x\n 6. \\<And>x xb xc xi.\n       \\<lbrakk>LtK xb \\<in> parts (ik x); xc \\<in> l3_inv1;\n        (xc, x) \\<in> l3_lkr_after xi\\<rbrakk>\n       \\<Longrightarrow> LtK xb \\<in> ik x\n 7. \\<And>x xb xc xh xi.\n       \\<lbrakk>LtK xb \\<in> parts (ik x); xc \\<in> l3_inv1;\n        (xc, x) \\<in> l3_skr xh xi\\<rbrakk>\n       \\<Longrightarrow> LtK xb \\<in> ik x", "apply (auto simp add: l3_defs dy_fake_msg_def dy_fake_chan_def\n        parts_insert [where H=\"ik _\"] parts_insert [where H=\"insert _ (ik _)\"]\n        dest!: Fake_parts_insert)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xb xc xe.\n       \\<lbrakk>xc \\<in> l3_inv1;\n        parts {xe} \\<subseteq> synth (analz (ik xc)) \\<union> parts (ik xc);\n        LtK xb \\<notin> ik xc; LtK xb \\<in> parts {xe}\\<rbrakk>\n       \\<Longrightarrow> LtK xb = xe", "apply (auto dest:analz_into_parts)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_l3_inv1 [iff]:\n  \"reach l3 \\<subseteq> l3_inv1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l3 \\<subseteq> l3_inv1", "by (rule inv_rule_basic) (auto)"], ["", "subsubsection \\<open>inv2: @{term \"bad s\"} indeed contains \"bad\" keys\\<close>"], ["", "(**************************************************************************************************)"], ["", "definition\n  l3_inv2 :: \"l3_state set\"\nwhere\n  \"l3_inv2 \\<equiv> {s.\n    Keys_bad (ik s) (bad s)\n  }\""], ["", "lemmas l3_inv2I = l3_inv2_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas l3_inv2E [elim] = l3_inv2_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas l3_inv2D = l3_inv2_def [THEN setc_def_to_dest, rule_format]"], ["", "lemma l3_inv2_init [simp,intro!]:\n  \"init l3 \\<subseteq> l3_inv2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init l3 \\<subseteq> l3_inv2", "by (auto simp add: l3_def l3_init_defs intro!:l3_inv2I Keys_badI)"], ["", "lemma l3_inv2_trans [simp,intro!]:\n  \"{l3_inv2 \\<inter> l3_inv1} trans l3 {> l3_inv2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l3_inv2 \\<inter> l3_inv1} TS.trans l3 {> l3_inv2}", "apply (auto simp add: PO_hoare_defs l3_nostep_defs intro!: l3_inv2I)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x xa xf xg xh.\n       \\<lbrakk>xa \\<in> l3_inv2; xa \\<in> l3_inv1;\n        (xa, x) \\<in> l3_step1 xf xg xh\\<rbrakk>\n       \\<Longrightarrow> Keys_bad (ik x) (l3_state.bad x)\n 2. \\<And>x xa xd xe xg xh.\n       \\<lbrakk>xa \\<in> l3_inv2; xa \\<in> l3_inv1;\n        (xa, x) \\<in> l3_step2 xe xg xh xd\\<rbrakk>\n       \\<Longrightarrow> Keys_bad (ik x) (l3_state.bad x)\n 3. \\<And>x xa xb xf xg xh.\n       \\<lbrakk>xa \\<in> l3_inv2; xa \\<in> l3_inv1;\n        (xa, x) \\<in> l3_step3 xf xg xh xb\\<rbrakk>\n       \\<Longrightarrow> Keys_bad (ik x) (l3_state.bad x)\n 4. \\<And>x xa xc.\n       \\<lbrakk>xa \\<in> l3_inv2; xa \\<in> l3_inv1;\n        (xa, x) \\<in> l3_dy xc\\<rbrakk>\n       \\<Longrightarrow> Keys_bad (ik x) (l3_state.bad x)\n 5. \\<And>x xa xg.\n       \\<lbrakk>xa \\<in> l3_inv2; xa \\<in> l3_inv1;\n        (xa, x) \\<in> l3_lkr_others xg\\<rbrakk>\n       \\<Longrightarrow> Keys_bad (ik x) (l3_state.bad x)\n 6. \\<And>x xa xg.\n       \\<lbrakk>xa \\<in> l3_inv2; xa \\<in> l3_inv1;\n        (xa, x) \\<in> l3_lkr_after xg\\<rbrakk>\n       \\<Longrightarrow> Keys_bad (ik x) (l3_state.bad x)\n 7. \\<And>x xa xf xg.\n       \\<lbrakk>xa \\<in> l3_inv2; xa \\<in> l3_inv1;\n        (xa, x) \\<in> l3_skr xf xg\\<rbrakk>\n       \\<Longrightarrow> Keys_bad (ik x) (l3_state.bad x)", "apply (auto simp add: l3_defs dy_fake_msg_def dy_fake_chan_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa xc.\n       \\<lbrakk>xa \\<in> l3_inv2; xa \\<in> l3_inv1;\n        xc \\<in> synth (analz (ik xa))\\<rbrakk>\n       \\<Longrightarrow> Keys_bad (insert xc (ik xa)) (l3_state.bad xa)\n 2. \\<And>xa xg.\n       \\<lbrakk>xa \\<in> l3_inv2; xa \\<in> l3_inv1; xg \\<noteq> test_owner;\n        xg \\<noteq> test_partner\\<rbrakk>\n       \\<Longrightarrow> Keys_bad (keys_of xg \\<union> ik xa)\n                          (insert xg (l3_state.bad xa))\n 3. \\<And>xa xg.\n       \\<lbrakk>xa \\<in> l3_inv2; xa \\<in> l3_inv1; test_ended xa\\<rbrakk>\n       \\<Longrightarrow> Keys_bad (keys_of xg \\<union> ik xa)\n                          (insert xg (l3_state.bad xa))\n 4. \\<And>xa xf xg.\n       \\<lbrakk>xa \\<in> l3_inv2; xa \\<in> l3_inv1; xf \\<noteq> test;\n        xf \\<notin> partners; run_ended (progress xa xf);\n        guessed_frame xf xsk = Some xg\\<rbrakk>\n       \\<Longrightarrow> Keys_bad (insert xg (ik xa)) (l3_state.bad xa)", "text \\<open>4 subgoals: dy, lkr*, skr\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa xc.\n       \\<lbrakk>xa \\<in> l3_inv2; xa \\<in> l3_inv1;\n        xc \\<in> synth (analz (ik xa))\\<rbrakk>\n       \\<Longrightarrow> Keys_bad (insert xc (ik xa)) (l3_state.bad xa)\n 2. \\<And>xa xg.\n       \\<lbrakk>xa \\<in> l3_inv2; xa \\<in> l3_inv1; xg \\<noteq> test_owner;\n        xg \\<noteq> test_partner\\<rbrakk>\n       \\<Longrightarrow> Keys_bad (keys_of xg \\<union> ik xa)\n                          (insert xg (l3_state.bad xa))\n 3. \\<And>xa xg.\n       \\<lbrakk>xa \\<in> l3_inv2; xa \\<in> l3_inv1; test_ended xa\\<rbrakk>\n       \\<Longrightarrow> Keys_bad (keys_of xg \\<union> ik xa)\n                          (insert xg (l3_state.bad xa))\n 4. \\<And>xa xf xg.\n       \\<lbrakk>xa \\<in> l3_inv2; xa \\<in> l3_inv1; xf \\<noteq> test;\n        xf \\<notin> partners; run_ended (progress xa xf);\n        guessed_frame xf xsk = Some xg\\<rbrakk>\n       \\<Longrightarrow> Keys_bad (insert xg (ik xa)) (l3_state.bad xa)", "apply (auto intro: Keys_bad_insert_Fake Keys_bad_insert_keys_of)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xf xg.\n       \\<lbrakk>xa \\<in> l3_inv2; xa \\<in> l3_inv1; xf \\<noteq> test;\n        xf \\<notin> partners; run_ended (progress xa xf);\n        guessed_frame xf xsk = Some xg\\<rbrakk>\n       \\<Longrightarrow> Keys_bad (insert xg (ik xa)) (l3_state.bad xa)", "apply (auto intro!: Keys_bad_insert_payload)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_l3_inv2 [iff]: \"reach l3 \\<subseteq> l3_inv2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l3 \\<subseteq> l3_inv2", "by (rule_tac J=\"l3_inv1\" in inv_rule_incr) (auto)"], ["", "subsubsection \\<open>inv3\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>If a message can be analyzed from the intruder knowledge then it can\nbe derived (using synth/analz) from the sets of implementation, non-implementation, and\nlong-term key messages and the tags. That is, intermediate messages are not needed.\n\\<close>"], ["", "definition\n  l3_inv3 :: \"l3_state set\"      \nwhere\n  \"l3_inv3 \\<equiv> {s.\n    analz (ik s) \\<subseteq> \n    synth (analz ((ik s \\<inter> payload) \\<union> ((ik s) \\<inter> valid) \\<union> (ik s \\<inter> range LtK) \\<union> Tags))\n  }\""], ["", "lemmas l3_inv3I = l3_inv3_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas l3_inv3E = l3_inv3_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas l3_inv3D = l3_inv3_def [THEN setc_def_to_dest, rule_format]"], ["", "lemma l3_inv3_init [iff]:\n  \"init l3 \\<subseteq> l3_inv3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init l3 \\<subseteq> l3_inv3", "apply (auto simp add: l3_def l3_init_def intro!: l3_inv3I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> ik_init \\<Longrightarrow>\n       x \\<in> synth (analz (ik_init \\<inter> range LtK \\<union> Tags))", "apply (auto simp add: ik_init_def intro!: synth_increasing [THEN [2] rev_subsetD])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare domIff [iff del]"], ["", "text \\<open>Most of the cases in this proof are simple and very similar.\nThe proof could probably be shortened.\\<close>"], ["", "lemma l3_inv3_trans [simp,intro!]:\n  \"{l3_inv3} trans l3 {> l3_inv3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l3_inv3} TS.trans l3 {> l3_inv3}", "proof (simp add: l3_nostep_defs, safe)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x xa xb xc xd xe xf. {l3_inv3} l3_step1 xd xe xf {> l3_inv3}\n 2. \\<And>x xa xb xc xd xe xf. {l3_inv3} l3_step2 xc xe xf xb {> l3_inv3}\n 3. \\<And>x xa xb xc xd xe xf. {l3_inv3} l3_step3 xd xe xf x {> l3_inv3}\n 4. \\<And>x xa xb xc xd xe. {l3_inv3} l3_dy xa {> l3_inv3}\n 5. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_others xe {> l3_inv3}\n 6. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_after xe {> l3_inv3}\n 7. \\<And>x xa xb xc xd xe. {l3_inv3} l3_skr xd xe {> l3_inv3}", "fix Ra A B"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x xa xb xc xd xe xf. {l3_inv3} l3_step1 xd xe xf {> l3_inv3}\n 2. \\<And>x xa xb xc xd xe xf. {l3_inv3} l3_step2 xc xe xf xb {> l3_inv3}\n 3. \\<And>x xa xb xc xd xe xf. {l3_inv3} l3_step3 xd xe xf x {> l3_inv3}\n 4. \\<And>x xa xb xc xd xe. {l3_inv3} l3_dy xa {> l3_inv3}\n 5. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_others xe {> l3_inv3}\n 6. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_after xe {> l3_inv3}\n 7. \\<And>x xa xb xc xd xe. {l3_inv3} l3_skr xd xe {> l3_inv3}", "show \"{l3_inv3} l3_step1 Ra A B {> l3_inv3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l3_inv3} l3_step1 Ra A B {> l3_inv3}", "apply (auto simp add: PO_hoare_def l3_defs intro!: l3_inv3I dest!: l3_inv3D)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa s.\n       \\<lbrakk>xa \\<in> analz\n                          (insert\n                            (implAuth A B\n                              \\<langle>Number 0, epubKF (Ra $ kE)\\<rangle>)\n                            (ik s));\n        analz (ik s)\n        \\<subseteq> synth\n                     (analz\n                       (ik s \\<inter> payload \\<union>\n                        ik s \\<inter> valid \\<union>\n                        ik s \\<inter> range LtK \\<union>\n                        Tags));\n        Ra \\<notin> dom (progress s);\n        guessed_runs Ra =\n        \\<lparr>role = Init, owner = A, partner = B\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> synth\n                                   (analz\n                                     (ik s \\<inter> payload \\<union>\ninsert (implAuth A B \\<langle>Number 0, epubKF (Ra $ kE)\\<rangle>)\n (ik s) \\<inter>\nvalid \\<union>\nik s \\<inter> range LtK \\<union>\nTags))", "apply (auto intro!: validI dest!: analz_insert_partition [THEN [2] rev_subsetD])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {l3_inv3} l3_step1 Ra A B {> l3_inv3}\n\ngoal (6 subgoals):\n 1. \\<And>x xa xb xc xd xe xf. {l3_inv3} l3_step2 xc xe xf xb {> l3_inv3}\n 2. \\<And>x xa xb xc xd xe xf. {l3_inv3} l3_step3 xd xe xf x {> l3_inv3}\n 3. \\<And>x xa xb xc xd xe. {l3_inv3} l3_dy xa {> l3_inv3}\n 4. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_others xe {> l3_inv3}\n 5. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_after xe {> l3_inv3}\n 6. \\<And>x xa xb xc xd xe. {l3_inv3} l3_skr xd xe {> l3_inv3}", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x xa xb xc xd xe xf. {l3_inv3} l3_step2 xc xe xf xb {> l3_inv3}\n 2. \\<And>x xa xb xc xd xe xf. {l3_inv3} l3_step3 xd xe xf x {> l3_inv3}\n 3. \\<And>x xa xb xc xd xe. {l3_inv3} l3_dy xa {> l3_inv3}\n 4. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_others xe {> l3_inv3}\n 5. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_after xe {> l3_inv3}\n 6. \\<And>x xa xb xc xd xe. {l3_inv3} l3_skr xd xe {> l3_inv3}", "fix Rb A B KE"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x xa xb xc xd xe xf. {l3_inv3} l3_step2 xc xe xf xb {> l3_inv3}\n 2. \\<And>x xa xb xc xd xe xf. {l3_inv3} l3_step3 xd xe xf x {> l3_inv3}\n 3. \\<And>x xa xb xc xd xe. {l3_inv3} l3_dy xa {> l3_inv3}\n 4. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_others xe {> l3_inv3}\n 5. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_after xe {> l3_inv3}\n 6. \\<And>x xa xb xc xd xe. {l3_inv3} l3_skr xd xe {> l3_inv3}", "show \"{l3_inv3} l3_step2 Rb A B KE {> l3_inv3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l3_inv3} l3_step2 Rb A B KE {> l3_inv3}", "apply (auto simp add: PO_hoare_def l3_defs intro!: l3_inv3I dest!: l3_inv3D)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb.\n       \\<lbrakk>analz (ik xa)\n                \\<subseteq> synth\n                             (analz\n                               (ik xa \\<inter> payload \\<union>\n                                ik xa \\<inter> valid \\<union>\n                                ik xa \\<inter> range LtK \\<union>\n                                Tags));\n        xb \\<in> analz\n                  (insert (implAuth B A (Aenc (NonceF (Rb $ sk)) KE))\n                    (ik xa));\n        guessed_runs Rb =\n        \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        Rb \\<notin> dom (progress xa); guessed_frame Rb xpkE = Some KE;\n        implAuth A B \\<langle>Number 0, KE\\<rangle> \\<in> ik xa\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> synth\n                                   (analz\n                                     (ik xa \\<inter> payload \\<union>\ninsert (implAuth B A (Aenc (NonceF (Rb $ sk)) KE)) (ik xa) \\<inter>\nvalid \\<union>\nik xa \\<inter> range LtK \\<union>\nTags))", "apply (auto intro!: validI dest!: analz_insert_partition [THEN [2] rev_subsetD])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {l3_inv3} l3_step2 Rb A B KE {> l3_inv3}\n\ngoal (5 subgoals):\n 1. \\<And>x xa xb xc xd xe xf. {l3_inv3} l3_step3 xd xe xf x {> l3_inv3}\n 2. \\<And>x xa xb xc xd xe. {l3_inv3} l3_dy xa {> l3_inv3}\n 3. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_others xe {> l3_inv3}\n 4. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_after xe {> l3_inv3}\n 5. \\<And>x xa xb xc xd xe. {l3_inv3} l3_skr xd xe {> l3_inv3}", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x xa xb xc xd xe xf. {l3_inv3} l3_step3 xd xe xf x {> l3_inv3}\n 2. \\<And>x xa xb xc xd xe. {l3_inv3} l3_dy xa {> l3_inv3}\n 3. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_others xe {> l3_inv3}\n 4. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_after xe {> l3_inv3}\n 5. \\<And>x xa xb xc xd xe. {l3_inv3} l3_skr xd xe {> l3_inv3}", "fix Ra A B K"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x xa xb xc xd xe xf. {l3_inv3} l3_step3 xd xe xf x {> l3_inv3}\n 2. \\<And>x xa xb xc xd xe. {l3_inv3} l3_dy xa {> l3_inv3}\n 3. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_others xe {> l3_inv3}\n 4. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_after xe {> l3_inv3}\n 5. \\<And>x xa xb xc xd xe. {l3_inv3} l3_skr xd xe {> l3_inv3}", "show \"{l3_inv3} l3_step3 Ra A B K {> l3_inv3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l3_inv3} l3_step3 Ra A B K {> l3_inv3}", "apply (auto simp add: PO_hoare_def l3_defs intro!: l3_inv3I dest!: l3_inv3D)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {l3_inv3} l3_step3 Ra A B K {> l3_inv3}\n\ngoal (4 subgoals):\n 1. \\<And>x xa xb xc xd xe. {l3_inv3} l3_dy xa {> l3_inv3}\n 2. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_others xe {> l3_inv3}\n 3. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_after xe {> l3_inv3}\n 4. \\<And>x xa xb xc xd xe. {l3_inv3} l3_skr xd xe {> l3_inv3}", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x xa xb xc xd xe. {l3_inv3} l3_dy xa {> l3_inv3}\n 2. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_others xe {> l3_inv3}\n 3. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_after xe {> l3_inv3}\n 4. \\<And>x xa xb xc xd xe. {l3_inv3} l3_skr xd xe {> l3_inv3}", "fix m"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x xa xb xc xd xe. {l3_inv3} l3_dy xa {> l3_inv3}\n 2. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_others xe {> l3_inv3}\n 3. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_after xe {> l3_inv3}\n 4. \\<And>x xa xb xc xd xe. {l3_inv3} l3_skr xd xe {> l3_inv3}", "show \"{l3_inv3} l3_dy m {> l3_inv3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l3_inv3} l3_dy m {> l3_inv3}", "apply (auto simp add: PO_hoare_def l3_defs dy_fake_chan_def dy_fake_msg_def\n                intro!: l3_inv3I dest!: l3_inv3D)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa s.\n       \\<lbrakk>xa \\<in> analz (insert m (ik s));\n        analz (ik s)\n        \\<subseteq> synth\n                     (analz\n                       (ik s \\<inter> payload \\<union>\n                        ik s \\<inter> valid \\<union>\n                        ik s \\<inter> range LtK \\<union>\n                        Tags));\n        m \\<in> synth (analz (ik s))\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> synth\n                                   (analz\n                                     (insert m (ik s) \\<inter>\npayload \\<union>\ninsert m (ik s) \\<inter> valid \\<union>\ninsert m (ik s) \\<inter> range LtK \\<union>\nTags))", "apply (drule synth_analz_insert)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa s.\n       \\<lbrakk>xa \\<in> analz (insert m (ik s));\n        analz (ik s)\n        \\<subseteq> synth\n                     (analz\n                       (ik s \\<inter> payload \\<union>\n                        ik s \\<inter> valid \\<union>\n                        ik s \\<inter> range LtK \\<union>\n                        Tags));\n        synth (analz (insert m (ik s))) = synth (analz (ik s))\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> synth\n                                   (analz\n                                     (insert m (ik s) \\<inter>\npayload \\<union>\ninsert m (ik s) \\<inter> valid \\<union>\ninsert m (ik s) \\<inter> range LtK \\<union>\nTags))", "apply (blast intro: synth_analz_monotone dest: synth_monotone)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {l3_inv3} l3_dy m {> l3_inv3}\n\ngoal (3 subgoals):\n 1. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_others xe {> l3_inv3}\n 2. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_after xe {> l3_inv3}\n 3. \\<And>x xa xb xc xd xe. {l3_inv3} l3_skr xd xe {> l3_inv3}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_others xe {> l3_inv3}\n 2. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_after xe {> l3_inv3}\n 3. \\<And>x xa xb xc xd xe. {l3_inv3} l3_skr xd xe {> l3_inv3}", "fix A"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_others xe {> l3_inv3}\n 2. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_after xe {> l3_inv3}\n 3. \\<And>x xa xb xc xd xe. {l3_inv3} l3_skr xd xe {> l3_inv3}", "show \"{l3_inv3} l3_lkr_others A {> l3_inv3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l3_inv3} l3_lkr_others A {> l3_inv3}", "apply (auto simp add: PO_hoare_def l3_defs intro!: l3_inv3I dest!: l3_inv3D)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb.\n       \\<lbrakk>analz (ik xa)\n                \\<subseteq> synth\n                             (analz\n                               (ik xa \\<inter> payload \\<union>\n                                ik xa \\<inter> valid \\<union>\n                                ik xa \\<inter> range LtK \\<union>\n                                Tags));\n        xb \\<in> analz (keys_of A \\<union> ik xa); A \\<noteq> test_owner;\n        A \\<noteq> test_partner\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> synth\n                                   (analz\n                                     ((keys_of A \\<union> ik xa) \\<inter>\npayload \\<union>\n(keys_of A \\<union> ik xa) \\<inter> valid \\<union>\n(keys_of A \\<union> ik xa) \\<inter> range LtK \\<union>\nTags))", "apply (drule analz_Un_partition [of _ \"keys_of A\"], auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {l3_inv3} l3_lkr_others A {> l3_inv3}\n\ngoal (2 subgoals):\n 1. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_after xe {> l3_inv3}\n 2. \\<And>x xa xb xc xd xe. {l3_inv3} l3_skr xd xe {> l3_inv3}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_after xe {> l3_inv3}\n 2. \\<And>x xa xb xc xd xe. {l3_inv3} l3_skr xd xe {> l3_inv3}", "fix A"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa xb xc xd xe. {l3_inv3} l3_lkr_after xe {> l3_inv3}\n 2. \\<And>x xa xb xc xd xe. {l3_inv3} l3_skr xd xe {> l3_inv3}", "show \"{l3_inv3} l3_lkr_after A {> l3_inv3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l3_inv3} l3_lkr_after A {> l3_inv3}", "apply (auto simp add: PO_hoare_def l3_defs intro!: l3_inv3I dest!: l3_inv3D)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa s.\n       \\<lbrakk>xa \\<in> analz (keys_of A \\<union> ik s);\n        analz (ik s)\n        \\<subseteq> synth\n                     (analz\n                       (ik s \\<inter> payload \\<union>\n                        ik s \\<inter> valid \\<union>\n                        ik s \\<inter> range LtK \\<union>\n                        Tags));\n        test_ended s\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> synth\n                                   (analz\n                                     ((keys_of A \\<union> ik s) \\<inter>\npayload \\<union>\n(keys_of A \\<union> ik s) \\<inter> valid \\<union>\n(keys_of A \\<union> ik s) \\<inter> range LtK \\<union>\nTags))", "apply (drule analz_Un_partition [of _ \"keys_of A\"], auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {l3_inv3} l3_lkr_after A {> l3_inv3}\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb xc xd xe. {l3_inv3} l3_skr xd xe {> l3_inv3}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb xc xd xe. {l3_inv3} l3_skr xd xe {> l3_inv3}", "fix R K"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb xc xd xe. {l3_inv3} l3_skr xd xe {> l3_inv3}", "show \"{l3_inv3} l3_skr R K {> l3_inv3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l3_inv3} l3_skr R K {> l3_inv3}", "apply (auto simp add: PO_hoare_def l3_defs intro!: l3_inv3I dest!: l3_inv3D)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb.\n       \\<lbrakk>analz (ik xa)\n                \\<subseteq> synth\n                             (analz\n                               (ik xa \\<inter> payload \\<union>\n                                ik xa \\<inter> valid \\<union>\n                                ik xa \\<inter> range LtK \\<union>\n                                Tags));\n        xb \\<in> analz (insert K (ik xa)); R \\<noteq> test;\n        R \\<notin> partners; run_ended (progress xa R);\n        guessed_frame R xsk = Some K\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> synth\n                                   (analz\n                                     (insert K\n (ik xa \\<inter> payload \\<union> insert K (ik xa) \\<inter> valid \\<union>\n  insert K (ik xa) \\<inter> range LtK \\<union>\n  Tags)))", "apply (auto dest!: analz_insert_partition [THEN [2] rev_subsetD])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {l3_inv3} l3_skr R K {> l3_inv3}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma PO_l3_inv3 [iff]: \"reach l3 \\<subseteq> l3_inv3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l3 \\<subseteq> l3_inv3", "by (rule inv_rule_basic) (auto)"], ["", "subsubsection \\<open>inv4: the intruder knows the tags\\<close>"], ["", "(**************************************************************************************************)"], ["", "definition\n  l3_inv4 :: \"l3_state set\"\nwhere\n  \"l3_inv4 \\<equiv> {s.\n    Tags \\<subseteq> ik s\n  }\""], ["", "lemmas l3_inv4I = l3_inv4_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas l3_inv4E [elim] = l3_inv4_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas l3_inv4D = l3_inv4_def [THEN setc_def_to_dest, rule_format]"], ["", "lemma l3_inv4_init [simp,intro!]:\n  \"init l3 \\<subseteq> l3_inv4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init l3 \\<subseteq> l3_inv4", "by (auto simp add: l3_def l3_init_def ik_init_def intro!:l3_inv4I)"], ["", "lemma l3_inv4_trans [simp,intro!]:\n  \"{l3_inv4} trans l3 {> l3_inv4}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l3_inv4} TS.trans l3 {> l3_inv4}", "apply (auto simp add: PO_hoare_defs l3_nostep_defs intro!: l3_inv4I)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x xb xc xh xi xj.\n       \\<lbrakk>xc \\<in> l3_inv4; (xc, x) \\<in> l3_step1 xh xi xj\\<rbrakk>\n       \\<Longrightarrow> Tag xb \\<in> ik x\n 2. \\<And>x xb xc xf xg xi xj.\n       \\<lbrakk>xc \\<in> l3_inv4;\n        (xc, x) \\<in> l3_step2 xg xi xj xf\\<rbrakk>\n       \\<Longrightarrow> Tag xb \\<in> ik x\n 3. \\<And>x xb xc xd xh xi xj.\n       \\<lbrakk>xc \\<in> l3_inv4;\n        (xc, x) \\<in> l3_step3 xh xi xj xd\\<rbrakk>\n       \\<Longrightarrow> Tag xb \\<in> ik x\n 4. \\<And>x xb xc xe.\n       \\<lbrakk>xc \\<in> l3_inv4; (xc, x) \\<in> l3_dy xe\\<rbrakk>\n       \\<Longrightarrow> Tag xb \\<in> ik x\n 5. \\<And>x xb xc xi.\n       \\<lbrakk>xc \\<in> l3_inv4; (xc, x) \\<in> l3_lkr_others xi\\<rbrakk>\n       \\<Longrightarrow> Tag xb \\<in> ik x\n 6. \\<And>x xb xc xi.\n       \\<lbrakk>xc \\<in> l3_inv4; (xc, x) \\<in> l3_lkr_after xi\\<rbrakk>\n       \\<Longrightarrow> Tag xb \\<in> ik x\n 7. \\<And>x xb xc xh xi.\n       \\<lbrakk>xc \\<in> l3_inv4; (xc, x) \\<in> l3_skr xh xi\\<rbrakk>\n       \\<Longrightarrow> Tag xb \\<in> ik x", "apply (auto simp add: l3_defs dy_fake_chan_def dy_fake_msg_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_l3_inv4 [simp,intro!]: \"reach l3 \\<subseteq> l3_inv4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l3 \\<subseteq> l3_inv4", "by (rule inv_rule_basic) (auto)"], ["", "text \\<open>The remaining invariants are derived from the others.\nThey are not protocol dependent provided the previous invariants hold.\\<close>"], ["", "subsubsection \\<open>inv5\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>The messages that the L3 DY intruder can derive from the intruder knowledge \n(using @{term \"synth\"}/@{term \"analz\"}), are either implementations or intermediate messages or\ncan also be derived by the L2 intruder from the set \n@{term \"extr (bad s) ((ik s) \\<inter> payload) (abs (ik s))\"}, that is, given the \nnon-implementation messages and the abstractions of (implementation) messages\nin the intruder knowledge. \n\\<close>"], ["", "definition\n  l3_inv5 :: \"l3_state set\"\nwhere\n  \"l3_inv5 \\<equiv> {s.\n    synth (analz (ik s)) \\<subseteq> \n    dy_fake_msg (bad s) (ik s \\<inter> payload) (abs (ik s)) \\<union> -payload\n  }\""], ["", "lemmas l3_inv5I = l3_inv5_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas l3_inv5E = l3_inv5_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas l3_inv5D = l3_inv5_def [THEN setc_def_to_dest, rule_format]"], ["", "lemma l3_inv5_derived: \"l3_inv2 \\<inter> l3_inv3 \\<subseteq> l3_inv5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l3_inv2 \\<inter> l3_inv3 \\<subseteq> l3_inv5", "by (auto simp add: abs_validSet dy_fake_msg_def intro!: l3_inv5I\n            dest!: l3_inv3D [THEN synth_mono, THEN [2] rev_subsetD]\n            dest!: synth_analz_NI_I_K_synth_analz_NI_E [THEN [2] rev_subsetD])"], ["", "lemma PO_l3_inv5 [simp,intro!]: \"reach l3 \\<subseteq> l3_inv5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l3 \\<subseteq> l3_inv5", "using l3_inv5_derived PO_l3_inv2 PO_l3_inv3"], ["proof (prove)\nusing this:\n  l3_inv2 \\<inter> l3_inv3 \\<subseteq> l3_inv5\n  reach l3 \\<subseteq> l3_inv2\n  reach l3 \\<subseteq> l3_inv3\n\ngoal (1 subgoal):\n 1. reach l3 \\<subseteq> l3_inv5", "by blast"], ["", "subsubsection \\<open>inv6\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>If the level 3 intruder can deduce a message implementing an insecure channel message, then:\n\\begin{itemize}\n  \\item either the message is already in the intruder knowledge;\n  \\item or the message is constructed, and the payload can also be deduced by the intruder.\n\\end{itemize}\n\\<close>"], ["", "definition\n  l3_inv6 :: \"l3_state set\"\nwhere\n  \"l3_inv6 \\<equiv> {s. \\<forall> A B M. \n     (implInsec A B M \\<in> synth (analz (ik s)) \\<and> M \\<in> payload) \\<longrightarrow> \n     (implInsec A B M \\<in> ik s \\<or> M \\<in> synth (analz (ik s)))\n  }\""], ["", "lemmas l3_inv6I = l3_inv6_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas l3_inv6E = l3_inv6_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas l3_inv6D = l3_inv6_def [THEN setc_def_to_dest, rule_format]"], ["", "lemma l3_inv6_derived [simp,intro!]:\n  \"l3_inv3 \\<inter> l3_inv4 \\<subseteq> l3_inv6\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l3_inv3 \\<inter> l3_inv4 \\<subseteq> l3_inv6", "apply (auto intro!: l3_inv6I dest!: l3_inv3D)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B M.\n       \\<lbrakk>x \\<in> l3_inv4;\n        analz (ik x)\n        \\<subseteq> synth\n                     (analz\n                       (ik x \\<inter> payload \\<union>\n                        ik x \\<inter> valid \\<union>\n                        ik x \\<inter> range LtK \\<union>\n                        Tags));\n        implInsec A B M \\<in> synth (analz (ik x)); M \\<in> payload;\n        M \\<notin> synth (analz (ik x))\\<rbrakk>\n       \\<Longrightarrow> implInsec A B M \\<in> ik x", "text \\<open>1 subgoal\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B M.\n       \\<lbrakk>x \\<in> l3_inv4;\n        analz (ik x)\n        \\<subseteq> synth\n                     (analz\n                       (ik x \\<inter> payload \\<union>\n                        ik x \\<inter> valid \\<union>\n                        ik x \\<inter> range LtK \\<union>\n                        Tags));\n        implInsec A B M \\<in> synth (analz (ik x)); M \\<in> payload;\n        M \\<notin> synth (analz (ik x))\\<rbrakk>\n       \\<Longrightarrow> implInsec A B M \\<in> ik x", "apply (drule synth_mono, simp, drule subsetD, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B M.\n       \\<lbrakk>x \\<in> l3_inv4; implInsec A B M \\<in> synth (analz (ik x));\n        M \\<in> payload; M \\<notin> synth (analz (ik x));\n        implInsec A B M\n        \\<in> synth\n               (analz\n                 (ik x \\<inter> payload \\<union>\n                  ik x \\<inter> valid \\<union>\n                  ik x \\<inter> range LtK \\<union>\n                  Tags))\\<rbrakk>\n       \\<Longrightarrow> implInsec A B M \\<in> ik x", "apply (auto dest!: implInsec_synth_analz [rotated 1, where H=\"_ \\<union> _\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B M.\n       \\<lbrakk>x \\<in> l3_inv4; implInsec A B M \\<in> synth (analz (ik x));\n        M \\<in> payload; M \\<notin> synth (analz (ik x));\n        M \\<in> synth\n                 (analz\n                   (ik x \\<inter> payload \\<union>\n                    ik x \\<inter> valid \\<union>\n                    ik x \\<inter> range LtK \\<union>\n                    Tags))\\<rbrakk>\n       \\<Longrightarrow> implInsec A B M \\<in> ik x", "apply (auto dest!: synth_analz_monotone [of _ \"_ \\<union> _\" \"ik _\"])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_l3_inv6 [simp,intro!]: \"reach l3 \\<subseteq> l3_inv6\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l3 \\<subseteq> l3_inv6", "using l3_inv6_derived PO_l3_inv3 PO_l3_inv4"], ["proof (prove)\nusing this:\n  l3_inv3 \\<inter> l3_inv4 \\<subseteq> l3_inv6\n  reach l3 \\<subseteq> l3_inv3\n  reach l3 \\<subseteq> l3_inv4\n\ngoal (1 subgoal):\n 1. reach l3 \\<subseteq> l3_inv6", "by (blast)"], ["", "subsubsection \\<open>inv7\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>If the level 3 intruder can deduce a message implementing a confidential channel message,\nthen:\n\\begin{itemize}\n \\item either the message is already in the intruder knowledge;\n \\item or the message is constructed, and the payload can also be deduced by the intruder.\n\\end{itemize}\n\\<close>"], ["", "definition\n  l3_inv7 :: \"l3_state set\"\nwhere\n  \"l3_inv7 \\<equiv> {s. \\<forall> A B M. \n     (implConfid A B M \\<in> synth (analz (ik s)) \\<and> M \\<in> payload) \\<longrightarrow> \n     (implConfid A B M \\<in> ik s \\<or> M \\<in> synth (analz (ik s)))\n  }\""], ["", "lemmas l3_inv7I = l3_inv7_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas l3_inv7E = l3_inv7_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas l3_inv7D = l3_inv7_def [THEN setc_def_to_dest, rule_format]"], ["", "lemma l3_inv7_derived [simp,intro!]:\n  \"l3_inv3 \\<inter> l3_inv4 \\<subseteq> l3_inv7\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l3_inv3 \\<inter> l3_inv4 \\<subseteq> l3_inv7", "apply (auto intro!: l3_inv7I dest!: l3_inv3D)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B M.\n       \\<lbrakk>x \\<in> l3_inv4;\n        analz (ik x)\n        \\<subseteq> synth\n                     (analz\n                       (ik x \\<inter> payload \\<union>\n                        ik x \\<inter> valid \\<union>\n                        ik x \\<inter> range LtK \\<union>\n                        Tags));\n        implConfid A B M \\<in> synth (analz (ik x)); M \\<in> payload;\n        M \\<notin> synth (analz (ik x))\\<rbrakk>\n       \\<Longrightarrow> implConfid A B M \\<in> ik x", "text \\<open>1 subgoal\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B M.\n       \\<lbrakk>x \\<in> l3_inv4;\n        analz (ik x)\n        \\<subseteq> synth\n                     (analz\n                       (ik x \\<inter> payload \\<union>\n                        ik x \\<inter> valid \\<union>\n                        ik x \\<inter> range LtK \\<union>\n                        Tags));\n        implConfid A B M \\<in> synth (analz (ik x)); M \\<in> payload;\n        M \\<notin> synth (analz (ik x))\\<rbrakk>\n       \\<Longrightarrow> implConfid A B M \\<in> ik x", "apply (drule synth_mono, simp, drule subsetD, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B M.\n       \\<lbrakk>x \\<in> l3_inv4;\n        implConfid A B M \\<in> synth (analz (ik x)); M \\<in> payload;\n        M \\<notin> synth (analz (ik x));\n        implConfid A B M\n        \\<in> synth\n               (analz\n                 (ik x \\<inter> payload \\<union>\n                  ik x \\<inter> valid \\<union>\n                  ik x \\<inter> range LtK \\<union>\n                  Tags))\\<rbrakk>\n       \\<Longrightarrow> implConfid A B M \\<in> ik x", "apply (auto dest!: implConfid_synth_analz [rotated 1, where H=\"_ \\<union> _\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B M.\n       \\<lbrakk>x \\<in> l3_inv4;\n        implConfid A B M \\<in> synth (analz (ik x)); M \\<in> payload;\n        M \\<notin> synth (analz (ik x));\n        M \\<in> synth\n                 (analz\n                   (ik x \\<inter> payload \\<union>\n                    ik x \\<inter> valid \\<union>\n                    ik x \\<inter> range LtK \\<union>\n                    Tags))\\<rbrakk>\n       \\<Longrightarrow> implConfid A B M \\<in> ik x", "apply (auto dest!: synth_analz_monotone [of _ \"_ \\<union> _\" \"ik _\"])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_l3_inv7 [simp,intro!]: \"reach l3 \\<subseteq> l3_inv7\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l3 \\<subseteq> l3_inv7", "using l3_inv7_derived PO_l3_inv3 PO_l3_inv4"], ["proof (prove)\nusing this:\n  l3_inv3 \\<inter> l3_inv4 \\<subseteq> l3_inv7\n  reach l3 \\<subseteq> l3_inv3\n  reach l3 \\<subseteq> l3_inv4\n\ngoal (1 subgoal):\n 1. reach l3 \\<subseteq> l3_inv7", "by (blast)"], ["", "subsubsection \\<open>inv8\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>If the level 3 intruder can deduce a message implementing an authentic channel message then:\n\\begin{itemize}\n  \\item either the message is already in the intruder knowledge;\n  \\item or the message is constructed, and in this case the payload can also be deduced\n     by the intruder, and one of the agents is bad.\n\\end{itemize}\n\\<close>"], ["", "definition\n  l3_inv8 :: \"l3_state set\"\nwhere\n  \"l3_inv8 \\<equiv> {s. \\<forall> A B M. \n     (implAuth A B M \\<in> synth (analz (ik s)) \\<and> M \\<in> payload) \\<longrightarrow> \n     (implAuth A B M \\<in> ik s \\<or> (M \\<in> synth (analz (ik s)) \\<and> (A \\<in> bad s \\<or> B \\<in> bad s)))\n  }\""], ["", "lemmas l3_inv8I = l3_inv8_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas l3_inv8E = l3_inv8_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas l3_inv8D = l3_inv8_def [THEN setc_def_to_dest, rule_format]"], ["", "lemma l3_inv8_derived [iff]:\n  \"l3_inv2 \\<inter> l3_inv3 \\<inter> l3_inv4 \\<subseteq> l3_inv8\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l3_inv2 \\<inter> l3_inv3 \\<inter> l3_inv4 \\<subseteq> l3_inv8", "apply (auto intro!: l3_inv8I dest!: l3_inv3D l3_inv2D)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x A B M.\n       \\<lbrakk>x \\<in> l3_inv4; Keys_bad (ik x) (l3_state.bad x);\n        analz (ik x)\n        \\<subseteq> synth\n                     (analz\n                       (ik x \\<inter> payload \\<union>\n                        ik x \\<inter> valid \\<union>\n                        ik x \\<inter> range LtK \\<union>\n                        Tags));\n        implAuth A B M \\<in> synth (analz (ik x)); M \\<in> payload;\n        implAuth A B M \\<notin> ik x\\<rbrakk>\n       \\<Longrightarrow> M \\<in> synth (analz (ik x))\n 2. \\<And>x A B M.\n       \\<lbrakk>x \\<in> l3_inv4; Keys_bad (ik x) (l3_state.bad x);\n        analz (ik x)\n        \\<subseteq> synth\n                     (analz\n                       (ik x \\<inter> payload \\<union>\n                        ik x \\<inter> valid \\<union>\n                        ik x \\<inter> range LtK \\<union>\n                        Tags));\n        implAuth A B M \\<in> synth (analz (ik x)); M \\<in> payload;\n        implAuth A B M \\<notin> ik x; B \\<notin> l3_state.bad x\\<rbrakk>\n       \\<Longrightarrow> A \\<in> l3_state.bad x", "text \\<open>2 subgoals: M is deducible and the agents are bad\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x A B M.\n       \\<lbrakk>x \\<in> l3_inv4; Keys_bad (ik x) (l3_state.bad x);\n        analz (ik x)\n        \\<subseteq> synth\n                     (analz\n                       (ik x \\<inter> payload \\<union>\n                        ik x \\<inter> valid \\<union>\n                        ik x \\<inter> range LtK \\<union>\n                        Tags));\n        implAuth A B M \\<in> synth (analz (ik x)); M \\<in> payload;\n        implAuth A B M \\<notin> ik x\\<rbrakk>\n       \\<Longrightarrow> M \\<in> synth (analz (ik x))\n 2. \\<And>x A B M.\n       \\<lbrakk>x \\<in> l3_inv4; Keys_bad (ik x) (l3_state.bad x);\n        analz (ik x)\n        \\<subseteq> synth\n                     (analz\n                       (ik x \\<inter> payload \\<union>\n                        ik x \\<inter> valid \\<union>\n                        ik x \\<inter> range LtK \\<union>\n                        Tags));\n        implAuth A B M \\<in> synth (analz (ik x)); M \\<in> payload;\n        implAuth A B M \\<notin> ik x; B \\<notin> l3_state.bad x\\<rbrakk>\n       \\<Longrightarrow> A \\<in> l3_state.bad x", "apply (drule synth_mono, simp, drule subsetD, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x A B M.\n       \\<lbrakk>x \\<in> l3_inv4; Keys_bad (ik x) (l3_state.bad x);\n        implAuth A B M \\<in> synth (analz (ik x)); M \\<in> payload;\n        implAuth A B M \\<notin> ik x;\n        implAuth A B M\n        \\<in> synth\n               (analz\n                 (ik x \\<inter> payload \\<union>\n                  ik x \\<inter> valid \\<union>\n                  ik x \\<inter> range LtK \\<union>\n                  Tags))\\<rbrakk>\n       \\<Longrightarrow> M \\<in> synth (analz (ik x))\n 2. \\<And>x A B M.\n       \\<lbrakk>x \\<in> l3_inv4; Keys_bad (ik x) (l3_state.bad x);\n        analz (ik x)\n        \\<subseteq> synth\n                     (analz\n                       (ik x \\<inter> payload \\<union>\n                        ik x \\<inter> valid \\<union>\n                        ik x \\<inter> range LtK \\<union>\n                        Tags));\n        implAuth A B M \\<in> synth (analz (ik x)); M \\<in> payload;\n        implAuth A B M \\<notin> ik x; B \\<notin> l3_state.bad x\\<rbrakk>\n       \\<Longrightarrow> A \\<in> l3_state.bad x", "apply (auto dest!: implAuth_synth_analz [rotated 1, where H=\"_ \\<union> _\"] elim!: synth_analz_monotone)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B M.\n       \\<lbrakk>x \\<in> l3_inv4; Keys_bad (ik x) (l3_state.bad x);\n        analz (ik x)\n        \\<subseteq> synth\n                     (analz\n                       (ik x \\<inter> payload \\<union>\n                        ik x \\<inter> valid \\<union>\n                        ik x \\<inter> range LtK \\<union>\n                        Tags));\n        implAuth A B M \\<in> synth (analz (ik x)); M \\<in> payload;\n        implAuth A B M \\<notin> ik x; B \\<notin> l3_state.bad x\\<rbrakk>\n       \\<Longrightarrow> A \\<in> l3_state.bad x", "apply (drule synth_mono, simp, drule subsetD, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B M.\n       \\<lbrakk>x \\<in> l3_inv4; Keys_bad (ik x) (l3_state.bad x);\n        implAuth A B M \\<in> synth (analz (ik x)); M \\<in> payload;\n        implAuth A B M \\<notin> ik x; B \\<notin> l3_state.bad x;\n        implAuth A B M\n        \\<in> synth\n               (analz\n                 (ik x \\<inter> payload \\<union>\n                  ik x \\<inter> valid \\<union>\n                  ik x \\<inter> range LtK \\<union>\n                  Tags))\\<rbrakk>\n       \\<Longrightarrow> A \\<in> l3_state.bad x", "apply (auto dest!: implAuth_synth_analz [rotated 1, where H=\"_ \\<union> _\"])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_l3_inv8 [iff]: \"reach l3 \\<subseteq> l3_inv8\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l3 \\<subseteq> l3_inv8", "using l3_inv8_derived\n  PO_l3_inv3 PO_l3_inv2 PO_l3_inv4"], ["proof (prove)\nusing this:\n  l3_inv2 \\<inter> l3_inv3 \\<inter> l3_inv4 \\<subseteq> l3_inv8\n  reach l3 \\<subseteq> l3_inv3\n  reach l3 \\<subseteq> l3_inv2\n  reach l3 \\<subseteq> l3_inv4\n\ngoal (1 subgoal):\n 1. reach l3 \\<subseteq> l3_inv8", "by blast"], ["", "subsubsection \\<open>inv9\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>If the level 3 intruder can deduce a message implementing a secure channel message then:\n\\begin{itemize}\n  \\item either the message is already in the intruder knowledge;\n  \\item or the message is constructed, and in this case the payload can also be deduced \n by the intruder, and one of the agents is bad.\n\\end{itemize}\n\\<close>"], ["", "definition\n  l3_inv9 :: \"l3_state set\"\nwhere\n  \"l3_inv9 \\<equiv> {s. \\<forall> A B M. \n     (implSecure A B M \\<in> synth (analz (ik s)) \\<and> M \\<in> payload) \\<longrightarrow> \n     (implSecure A B M \\<in> ik s \\<or> (M \\<in> synth (analz (ik s)) \\<and> (A \\<in> bad s \\<or> B \\<in> bad s)))\n  }\""], ["", "lemmas l3_inv9I = l3_inv9_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas l3_inv9E = l3_inv9_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas l3_inv9D = l3_inv9_def [THEN setc_def_to_dest, rule_format]"], ["", "lemma l3_inv9_derived [iff]:\n  \"l3_inv2 \\<inter> l3_inv3 \\<inter> l3_inv4 \\<subseteq> l3_inv9\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l3_inv2 \\<inter> l3_inv3 \\<inter> l3_inv4 \\<subseteq> l3_inv9", "apply (auto intro!: l3_inv9I dest!:l3_inv3D l3_inv2D)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x A B M.\n       \\<lbrakk>x \\<in> l3_inv4; Keys_bad (ik x) (l3_state.bad x);\n        analz (ik x)\n        \\<subseteq> synth\n                     (analz\n                       (ik x \\<inter> payload \\<union>\n                        ik x \\<inter> valid \\<union>\n                        ik x \\<inter> range LtK \\<union>\n                        Tags));\n        implSecure A B M \\<in> synth (analz (ik x)); M \\<in> payload;\n        implSecure A B M \\<notin> ik x\\<rbrakk>\n       \\<Longrightarrow> M \\<in> synth (analz (ik x))\n 2. \\<And>x A B M.\n       \\<lbrakk>x \\<in> l3_inv4; Keys_bad (ik x) (l3_state.bad x);\n        analz (ik x)\n        \\<subseteq> synth\n                     (analz\n                       (ik x \\<inter> payload \\<union>\n                        ik x \\<inter> valid \\<union>\n                        ik x \\<inter> range LtK \\<union>\n                        Tags));\n        implSecure A B M \\<in> synth (analz (ik x)); M \\<in> payload;\n        implSecure A B M \\<notin> ik x; B \\<notin> l3_state.bad x\\<rbrakk>\n       \\<Longrightarrow> A \\<in> l3_state.bad x", "text \\<open>2 subgoals: M is deducible and the agents are bad\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x A B M.\n       \\<lbrakk>x \\<in> l3_inv4; Keys_bad (ik x) (l3_state.bad x);\n        analz (ik x)\n        \\<subseteq> synth\n                     (analz\n                       (ik x \\<inter> payload \\<union>\n                        ik x \\<inter> valid \\<union>\n                        ik x \\<inter> range LtK \\<union>\n                        Tags));\n        implSecure A B M \\<in> synth (analz (ik x)); M \\<in> payload;\n        implSecure A B M \\<notin> ik x\\<rbrakk>\n       \\<Longrightarrow> M \\<in> synth (analz (ik x))\n 2. \\<And>x A B M.\n       \\<lbrakk>x \\<in> l3_inv4; Keys_bad (ik x) (l3_state.bad x);\n        analz (ik x)\n        \\<subseteq> synth\n                     (analz\n                       (ik x \\<inter> payload \\<union>\n                        ik x \\<inter> valid \\<union>\n                        ik x \\<inter> range LtK \\<union>\n                        Tags));\n        implSecure A B M \\<in> synth (analz (ik x)); M \\<in> payload;\n        implSecure A B M \\<notin> ik x; B \\<notin> l3_state.bad x\\<rbrakk>\n       \\<Longrightarrow> A \\<in> l3_state.bad x", "apply (drule synth_mono, simp, drule subsetD, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x A B M.\n       \\<lbrakk>x \\<in> l3_inv4; Keys_bad (ik x) (l3_state.bad x);\n        implSecure A B M \\<in> synth (analz (ik x)); M \\<in> payload;\n        implSecure A B M \\<notin> ik x;\n        implSecure A B M\n        \\<in> synth\n               (analz\n                 (ik x \\<inter> payload \\<union>\n                  ik x \\<inter> valid \\<union>\n                  ik x \\<inter> range LtK \\<union>\n                  Tags))\\<rbrakk>\n       \\<Longrightarrow> M \\<in> synth (analz (ik x))\n 2. \\<And>x A B M.\n       \\<lbrakk>x \\<in> l3_inv4; Keys_bad (ik x) (l3_state.bad x);\n        analz (ik x)\n        \\<subseteq> synth\n                     (analz\n                       (ik x \\<inter> payload \\<union>\n                        ik x \\<inter> valid \\<union>\n                        ik x \\<inter> range LtK \\<union>\n                        Tags));\n        implSecure A B M \\<in> synth (analz (ik x)); M \\<in> payload;\n        implSecure A B M \\<notin> ik x; B \\<notin> l3_state.bad x\\<rbrakk>\n       \\<Longrightarrow> A \\<in> l3_state.bad x", "apply (auto dest!: implSecure_synth_analz [rotated 1, where H=\"_ \\<union> _\"] elim!: synth_analz_monotone)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B M.\n       \\<lbrakk>x \\<in> l3_inv4; Keys_bad (ik x) (l3_state.bad x);\n        analz (ik x)\n        \\<subseteq> synth\n                     (analz\n                       (ik x \\<inter> payload \\<union>\n                        ik x \\<inter> valid \\<union>\n                        ik x \\<inter> range LtK \\<union>\n                        Tags));\n        implSecure A B M \\<in> synth (analz (ik x)); M \\<in> payload;\n        implSecure A B M \\<notin> ik x; B \\<notin> l3_state.bad x\\<rbrakk>\n       \\<Longrightarrow> A \\<in> l3_state.bad x", "apply (drule synth_mono, simp, drule subsetD, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B M.\n       \\<lbrakk>x \\<in> l3_inv4; Keys_bad (ik x) (l3_state.bad x);\n        implSecure A B M \\<in> synth (analz (ik x)); M \\<in> payload;\n        implSecure A B M \\<notin> ik x; B \\<notin> l3_state.bad x;\n        implSecure A B M\n        \\<in> synth\n               (analz\n                 (ik x \\<inter> payload \\<union>\n                  ik x \\<inter> valid \\<union>\n                  ik x \\<inter> range LtK \\<union>\n                  Tags))\\<rbrakk>\n       \\<Longrightarrow> A \\<in> l3_state.bad x", "apply (auto dest!: implSecure_synth_analz [rotated 1, where H=\"_ \\<union> _\"])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_l3_inv9 [iff]: \"reach l3 \\<subseteq> l3_inv9\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l3 \\<subseteq> l3_inv9", "using l3_inv9_derived\n  PO_l3_inv3 PO_l3_inv2 PO_l3_inv4"], ["proof (prove)\nusing this:\n  l3_inv2 \\<inter> l3_inv3 \\<inter> l3_inv4 \\<subseteq> l3_inv9\n  reach l3 \\<subseteq> l3_inv3\n  reach l3 \\<subseteq> l3_inv2\n  reach l3 \\<subseteq> l3_inv4\n\ngoal (1 subgoal):\n 1. reach l3 \\<subseteq> l3_inv9", "by blast"], ["", "(**************************************************************************************************)"], ["", "subsection \\<open>Refinement\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>mediator function\\<close>"], ["", "definition \n  med23s :: \"l3_obs \\<Rightarrow> l2_obs\"\nwhere\n  \"med23s t \\<equiv> \\<lparr>\n    ik = ik t \\<inter> payload,\n    secret = secret t,\n    progress = progress t,\n    signals = signals t,\n    chan = abs (ik t),\n    bad = bad t\n    \\<rparr>\""], ["", "text \\<open>relation between states\\<close>"], ["", "definition\n  R23s :: \"(l2_state * l3_state) set\"\nwhere\n  \"R23s \\<equiv> {(s, s').\n    s = med23s s'\n    }\""], ["", "lemmas R23s_defs = R23s_def med23s_def"], ["", "lemma R23sI: \n  \"\\<lbrakk> ik s = ik t \\<inter> payload; secret s = secret t; progress s = progress t; signals s = signals t;\n     chan s = abs (ik t); l2_state.bad s = bad t \\<rbrakk> \n \\<Longrightarrow> (s, t) \\<in> R23s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ik s = ik t \\<inter> payload; secret s = secret t;\n     progress s = progress t; l1_state.signals s = l1_state.signals t;\n     chan s = local.abs (ik t); l2_state.bad s = l3_state.bad t\\<rbrakk>\n    \\<Longrightarrow> (s, t) \\<in> R23s", "by (auto simp add: R23s_def med23s_def)"], ["", "lemma R23sD: \n  \"(s, t) \\<in> R23s \\<Longrightarrow>\n    ik s = ik t \\<inter> payload \\<and> secret s = secret t \\<and> progress s = progress t \\<and> signals s = signals t \\<and>\n    chan s = abs (ik t) \\<and> l2_state.bad s = bad t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, t) \\<in> R23s \\<Longrightarrow>\n    ik s = ik t \\<inter> payload \\<and>\n    secret s = secret t \\<and>\n    progress s = progress t \\<and>\n    l1_state.signals s = l1_state.signals t \\<and>\n    chan s = local.abs (ik t) \\<and> l2_state.bad s = l3_state.bad t", "by (auto simp add: R23s_def med23s_def)"], ["", "lemma R23sE [elim]: \n  \"\\<lbrakk> (s, t) \\<in> R23s;\n     \\<lbrakk> ik s = ik t \\<inter> payload; secret s = secret t; progress s = progress t; signals s = signals t;\n     chan s = abs (ik t); l2_state.bad s = bad t \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \n \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, t) \\<in> R23s;\n     \\<lbrakk>ik s = ik t \\<inter> payload; secret s = secret t;\n      progress s = progress t; l1_state.signals s = l1_state.signals t;\n      chan s = local.abs (ik t); l2_state.bad s = l3_state.bad t\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (auto simp add: R23s_def med23s_def)"], ["", "lemma can_signal_R23 [simp]:\n  \"(s2, s3) \\<in> R23s \\<Longrightarrow>\n   can_signal s2 A B \\<longleftrightarrow> can_signal s3 A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s2, s3) \\<in> R23s \\<Longrightarrow>\n    can_signal s2 A B = can_signal s3 A B", "by (auto simp add: can_signal_def)"], ["", "subsubsection \\<open>Protocol events\\<close>"], ["", "(**************************************************************************************************)"], ["", "lemma l3_step1_refines_step1:\n  \"{R23s} l2_step1 Ra A B, l3_step1 Ra A B {>R23s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R23s} l2_step1 Ra A B, l3_step1 Ra A B {> R23s}", "apply (auto simp add: PO_rhoare_defs R23s_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b y.\n       (y, b) \\<in> l3_step1 Ra A B \\<Longrightarrow>\n       (\\<lparr>ik = ik y \\<inter> payload, secret = secret y,\n           progress = progress y, signals = l1_state.signals y,\n           chan = local.abs (ik y), bad = l3_state.bad y\\<rparr>,\n        \\<lparr>ik = ik b \\<inter> payload, secret = secret b,\n           progress = progress b, signals = l1_state.signals b,\n           chan = local.abs (ik b), bad = l3_state.bad b\\<rparr>)\n       \\<in> l2_step1 Ra A B", "apply (auto simp add: l3_defs l2_step1_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma l3_step2_refines_step2:\n  \"{R23s} l2_step2 Rb A B KE, l3_step2 Rb A B KE{>R23s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R23s} l2_step2 Rb A B KE, l3_step2 Rb A B KE {> R23s}", "apply (auto simp add: PO_rhoare_defs R23s_defs l2_step2_def)"], ["proof (prove)\ngoal (30 subgoals):\n 1. \\<And>b y.\n       (y, b) \\<in> l3_step2 Rb A B KE \\<Longrightarrow>\n       guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>\n 2. \\<And>b y.\n       \\<lbrakk>(y, b) \\<in> l3_step2 Rb A B KE;\n        Rb \\<in> dom (progress y)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>b y.\n       (y, b) \\<in> l3_step2 Rb A B KE \\<Longrightarrow>\n       guessed_frame Rb xpkE = Some KE\n 4. \\<And>b y.\n       (y, b) \\<in> l3_step2 Rb A B KE \\<Longrightarrow>\n       Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> local.abs (ik y)\n 5. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l3_step2 Rb A B KE; can_signal y A B;\n        x \\<in> ik y; x \\<in> payload\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ik b\n 6. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l3_step2 Rb A B KE; can_signal y A B;\n        x \\<in> ik b; x \\<in> payload\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ik y\n 7. \\<And>b y.\n       \\<lbrakk>(y, b) \\<in> l3_step2 test A B KE; can_signal y A B;\n        Rb = test\\<rbrakk>\n       \\<Longrightarrow> NonceF (test $ sk) \\<in> secret b\n 8. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l3_step2 Rb A B KE; can_signal y A B;\n        x \\<in> secret y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> secret b\n 9. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l3_step2 Rb A B KE; can_signal y A B;\n        x \\<in> secret b; x \\<notin> secret y\\<rbrakk>\n       \\<Longrightarrow> x = NonceF (Rb $ sk)\n 10. \\<And>b y x.\n        \\<lbrakk>(y, b) \\<in> l3_step2 Rb A B KE; can_signal y A B;\n         x \\<in> secret b; x \\<notin> secret y\\<rbrakk>\n        \\<Longrightarrow> Rb = test\nA total of 30 subgoals...", "apply (auto simp add: l3_step2_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma l3_step3_refines_step3:\n  \"{R23s} l2_step3 Ra A B K, l3_step3 Ra A B K {>R23s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R23s} l2_step3 Ra A B K, l3_step3 Ra A B K {> R23s}", "apply (auto simp add: PO_rhoare_defs R23s_defs l2_step3_def)"], ["proof (prove)\ngoal (28 subgoals):\n 1. \\<And>b y.\n       (y, b) \\<in> l3_step3 Ra A B K \\<Longrightarrow>\n       guessed_runs Ra = \\<lparr>role = Init, owner = A, partner = B\\<rparr>\n 2. \\<And>b y.\n       (y, b) \\<in> l3_step3 Ra A B K \\<Longrightarrow>\n       progress y Ra = Some {xpkE, xskE}\n 3. \\<And>b y.\n       (y, b) \\<in> l3_step3 Ra A B K \\<Longrightarrow>\n       guessed_frame Ra xsk = Some K\n 4. \\<And>b y.\n       (y, b) \\<in> l3_step3 Ra A B K \\<Longrightarrow>\n       Auth B A (Aenc K (epubKF (Ra $ kE))) \\<in> local.abs (ik y)\n 5. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l3_step3 Ra A B K; can_signal y A B;\n        x \\<in> ik y; x \\<in> payload\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ik b\n 6. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l3_step3 Ra A B K; can_signal y A B;\n        x \\<in> ik b; x \\<in> payload\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ik y\n 7. \\<And>b y.\n       \\<lbrakk>(y, b) \\<in> l3_step3 test A B K; can_signal y A B;\n        Ra = test\\<rbrakk>\n       \\<Longrightarrow> K \\<in> secret b\n 8. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l3_step3 Ra A B K; can_signal y A B;\n        x \\<in> secret y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> secret b\n 9. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l3_step3 Ra A B K; can_signal y A B;\n        x \\<in> secret b; x \\<notin> secret y\\<rbrakk>\n       \\<Longrightarrow> x = K\n 10. \\<And>b y x.\n        \\<lbrakk>(y, b) \\<in> l3_step3 Ra A B K; can_signal y A B;\n         x \\<in> secret b; x \\<notin> secret y\\<rbrakk>\n        \\<Longrightarrow> Ra = test\nA total of 28 subgoals...", "apply (auto simp add: l3_step3_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Intruder events\\<close>"], ["", "(**************************************************************************************************)"], ["", "lemma l3_dy_payload_refines_dy_fake_msg:\n  \"M \\<in> payload \\<Longrightarrow>\n   {R23s \\<inter> UNIV \\<times> l3_inv5} l2_dy_fake_msg M, l3_dy M {>R23s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<in> payload \\<Longrightarrow>\n    {R23s \\<inter> UNIV \\<times> l3_inv5} l2_dy_fake_msg M, l3_dy M {> R23s}", "apply (auto simp add: PO_rhoare_defs R23s_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b y.\n       \\<lbrakk>M \\<in> payload; y \\<in> l3_inv5;\n        (y, b) \\<in> l3_dy M\\<rbrakk>\n       \\<Longrightarrow> (\\<lparr>ik = ik y \\<inter> payload,\n                             secret = secret y, progress = progress y,\n                             signals = l1_state.signals y,\n                             chan = local.abs (ik y),\n                             bad = l3_state.bad y\\<rparr>,\n                          \\<lparr>ik = ik b \\<inter> payload,\n                             secret = secret b, progress = progress b,\n                             signals = l1_state.signals b,\n                             chan = local.abs (ik b),\n                             bad = l3_state.bad b\\<rparr>)\n                         \\<in> l2_dy_fake_msg M", "apply (auto simp add: l3_defs l2_dy_fake_msg_def dest: l3_inv5D)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma l3_dy_valid_refines_dy_fake_chan:\n  \"\\<lbrakk> M \\<in> valid; M' \\<in> abs {M} \\<rbrakk> \\<Longrightarrow>\n   {R23s \\<inter> UNIV \\<times> (l3_inv5 \\<inter> l3_inv6 \\<inter> l3_inv7 \\<inter> l3_inv8 \\<inter> l3_inv9)} \n      l2_dy_fake_chan M', l3_dy M \n   {>R23s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M \\<in> valid; M' \\<in> local.abs {M}\\<rbrakk>\n    \\<Longrightarrow> {R23s \\<inter>\n                       UNIV \\<times>\n                       (l3_inv5 \\<inter> l3_inv6 \\<inter> l3_inv7 \\<inter>\n                        l3_inv8 \\<inter>\n                        l3_inv9)} l2_dy_fake_chan M', l3_dy M {> R23s}", "apply (auto simp add: PO_rhoare_defs R23s_defs, simp add: l2_dy_fake_chan_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b y.\n       \\<lbrakk>M \\<in> valid; M' \\<in> local.abs {M}; y \\<in> l3_inv5;\n        y \\<in> l3_inv6; y \\<in> l3_inv7; y \\<in> l3_inv8; y \\<in> l3_inv9;\n        (y, b) \\<in> l3_dy M\\<rbrakk>\n       \\<Longrightarrow> M' \\<in> dy_fake_chan (l3_state.bad y)\n                                   (ik y \\<inter> payload)\n                                   (local.abs (ik y)) \\<and>\n                         ik b \\<inter> payload =\n                         ik y \\<inter> payload \\<and>\n                         secret b = secret y \\<and>\n                         progress b = progress y \\<and>\n                         l1_state.signals b = l1_state.signals y \\<and>\n                         local.abs (ik b) =\n                         insert M' (local.abs (ik y)) \\<and>\n                         l3_state.bad b = l3_state.bad y", "apply (auto simp add: l3_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>M \\<in> valid; M' \\<in> local.abs {M}; y \\<in> l3_inv5;\n        y \\<in> l3_inv6; y \\<in> l3_inv7; y \\<in> l3_inv8; y \\<in> l3_inv9;\n        M \\<in> synth (analz (ik y))\\<rbrakk>\n       \\<Longrightarrow> M' \\<in> dy_fake_chan (l3_state.bad y)\n                                   (ik y \\<inter> payload)\n                                   (local.abs (ik y))", "text \\<open>1 subgoal\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>M \\<in> valid; M' \\<in> local.abs {M}; y \\<in> l3_inv5;\n        y \\<in> l3_inv6; y \\<in> l3_inv7; y \\<in> l3_inv8; y \\<in> l3_inv9;\n        M \\<in> synth (analz (ik y))\\<rbrakk>\n       \\<Longrightarrow> M' \\<in> dy_fake_chan (l3_state.bad y)\n                                   (ik y \\<inter> payload)\n                                   (local.abs (ik y))", "apply (erule valid_cases, simp_all add: dy_fake_chan_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>y A B Ma.\n       \\<lbrakk>M' = Insec A B Ma; y \\<in> l3_inv5; y \\<in> l3_inv6;\n        y \\<in> l3_inv7; y \\<in> l3_inv8; y \\<in> l3_inv9;\n        implInsec A B Ma \\<in> synth (analz (ik y)); M = implInsec A B Ma;\n        Ma \\<in> payload\\<rbrakk>\n       \\<Longrightarrow> Insec A B Ma\n                         \\<in> fake (l3_state.bad y)\n                                (dy_fake_msg (l3_state.bad y)\n                                  (ik y \\<inter> payload)\n                                  (local.abs (ik y)))\n                                (local.abs (ik y))\n 2. \\<And>y A B Ma.\n       \\<lbrakk>M' = Confid A B Ma; y \\<in> l3_inv5; y \\<in> l3_inv6;\n        y \\<in> l3_inv7; y \\<in> l3_inv8; y \\<in> l3_inv9;\n        implConfid A B Ma \\<in> synth (analz (ik y)); M = implConfid A B Ma;\n        Ma \\<in> payload\\<rbrakk>\n       \\<Longrightarrow> Confid A B Ma\n                         \\<in> fake (l3_state.bad y)\n                                (dy_fake_msg (l3_state.bad y)\n                                  (ik y \\<inter> payload)\n                                  (local.abs (ik y)))\n                                (local.abs (ik y))\n 3. \\<And>y A B Ma.\n       \\<lbrakk>M' = Auth A B Ma; y \\<in> l3_inv5; y \\<in> l3_inv6;\n        y \\<in> l3_inv7; y \\<in> l3_inv8; y \\<in> l3_inv9;\n        implAuth A B Ma \\<in> synth (analz (ik y)); M = implAuth A B Ma;\n        Ma \\<in> payload\\<rbrakk>\n       \\<Longrightarrow> Auth A B Ma\n                         \\<in> fake (l3_state.bad y)\n                                (dy_fake_msg (l3_state.bad y)\n                                  (ik y \\<inter> payload)\n                                  (local.abs (ik y)))\n                                (local.abs (ik y))\n 4. \\<And>y A B Ma.\n       \\<lbrakk>M' = Secure A B Ma; y \\<in> l3_inv5; y \\<in> l3_inv6;\n        y \\<in> l3_inv7; y \\<in> l3_inv8; y \\<in> l3_inv9;\n        implSecure A B Ma \\<in> synth (analz (ik y)); M = implSecure A B Ma;\n        Ma \\<in> payload\\<rbrakk>\n       \\<Longrightarrow> Secure A B Ma\n                         \\<in> fake (l3_state.bad y)\n                                (dy_fake_msg (l3_state.bad y)\n                                  (ik y \\<inter> payload)\n                                  (local.abs (ik y)))\n                                (local.abs (ik y))", "text \\<open>Insec\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>y A B Ma.\n       \\<lbrakk>M' = Insec A B Ma; y \\<in> l3_inv5; y \\<in> l3_inv6;\n        y \\<in> l3_inv7; y \\<in> l3_inv8; y \\<in> l3_inv9;\n        implInsec A B Ma \\<in> synth (analz (ik y)); M = implInsec A B Ma;\n        Ma \\<in> payload\\<rbrakk>\n       \\<Longrightarrow> Insec A B Ma\n                         \\<in> fake (l3_state.bad y)\n                                (dy_fake_msg (l3_state.bad y)\n                                  (ik y \\<inter> payload)\n                                  (local.abs (ik y)))\n                                (local.abs (ik y))\n 2. \\<And>y A B Ma.\n       \\<lbrakk>M' = Confid A B Ma; y \\<in> l3_inv5; y \\<in> l3_inv6;\n        y \\<in> l3_inv7; y \\<in> l3_inv8; y \\<in> l3_inv9;\n        implConfid A B Ma \\<in> synth (analz (ik y)); M = implConfid A B Ma;\n        Ma \\<in> payload\\<rbrakk>\n       \\<Longrightarrow> Confid A B Ma\n                         \\<in> fake (l3_state.bad y)\n                                (dy_fake_msg (l3_state.bad y)\n                                  (ik y \\<inter> payload)\n                                  (local.abs (ik y)))\n                                (local.abs (ik y))\n 3. \\<And>y A B Ma.\n       \\<lbrakk>M' = Auth A B Ma; y \\<in> l3_inv5; y \\<in> l3_inv6;\n        y \\<in> l3_inv7; y \\<in> l3_inv8; y \\<in> l3_inv9;\n        implAuth A B Ma \\<in> synth (analz (ik y)); M = implAuth A B Ma;\n        Ma \\<in> payload\\<rbrakk>\n       \\<Longrightarrow> Auth A B Ma\n                         \\<in> fake (l3_state.bad y)\n                                (dy_fake_msg (l3_state.bad y)\n                                  (ik y \\<inter> payload)\n                                  (local.abs (ik y)))\n                                (local.abs (ik y))\n 4. \\<And>y A B Ma.\n       \\<lbrakk>M' = Secure A B Ma; y \\<in> l3_inv5; y \\<in> l3_inv6;\n        y \\<in> l3_inv7; y \\<in> l3_inv8; y \\<in> l3_inv9;\n        implSecure A B Ma \\<in> synth (analz (ik y)); M = implSecure A B Ma;\n        Ma \\<in> payload\\<rbrakk>\n       \\<Longrightarrow> Secure A B Ma\n                         \\<in> fake (l3_state.bad y)\n                                (dy_fake_msg (l3_state.bad y)\n                                  (ik y \\<inter> payload)\n                                  (local.abs (ik y)))\n                                (local.abs (ik y))", "apply (blast dest: l3_inv6D l3_inv5D)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y A B Ma.\n       \\<lbrakk>M' = Confid A B Ma; y \\<in> l3_inv5; y \\<in> l3_inv6;\n        y \\<in> l3_inv7; y \\<in> l3_inv8; y \\<in> l3_inv9;\n        implConfid A B Ma \\<in> synth (analz (ik y)); M = implConfid A B Ma;\n        Ma \\<in> payload\\<rbrakk>\n       \\<Longrightarrow> Confid A B Ma\n                         \\<in> fake (l3_state.bad y)\n                                (dy_fake_msg (l3_state.bad y)\n                                  (ik y \\<inter> payload)\n                                  (local.abs (ik y)))\n                                (local.abs (ik y))\n 2. \\<And>y A B Ma.\n       \\<lbrakk>M' = Auth A B Ma; y \\<in> l3_inv5; y \\<in> l3_inv6;\n        y \\<in> l3_inv7; y \\<in> l3_inv8; y \\<in> l3_inv9;\n        implAuth A B Ma \\<in> synth (analz (ik y)); M = implAuth A B Ma;\n        Ma \\<in> payload\\<rbrakk>\n       \\<Longrightarrow> Auth A B Ma\n                         \\<in> fake (l3_state.bad y)\n                                (dy_fake_msg (l3_state.bad y)\n                                  (ik y \\<inter> payload)\n                                  (local.abs (ik y)))\n                                (local.abs (ik y))\n 3. \\<And>y A B Ma.\n       \\<lbrakk>M' = Secure A B Ma; y \\<in> l3_inv5; y \\<in> l3_inv6;\n        y \\<in> l3_inv7; y \\<in> l3_inv8; y \\<in> l3_inv9;\n        implSecure A B Ma \\<in> synth (analz (ik y)); M = implSecure A B Ma;\n        Ma \\<in> payload\\<rbrakk>\n       \\<Longrightarrow> Secure A B Ma\n                         \\<in> fake (l3_state.bad y)\n                                (dy_fake_msg (l3_state.bad y)\n                                  (ik y \\<inter> payload)\n                                  (local.abs (ik y)))\n                                (local.abs (ik y))", "text \\<open>Confid\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y A B Ma.\n       \\<lbrakk>M' = Confid A B Ma; y \\<in> l3_inv5; y \\<in> l3_inv6;\n        y \\<in> l3_inv7; y \\<in> l3_inv8; y \\<in> l3_inv9;\n        implConfid A B Ma \\<in> synth (analz (ik y)); M = implConfid A B Ma;\n        Ma \\<in> payload\\<rbrakk>\n       \\<Longrightarrow> Confid A B Ma\n                         \\<in> fake (l3_state.bad y)\n                                (dy_fake_msg (l3_state.bad y)\n                                  (ik y \\<inter> payload)\n                                  (local.abs (ik y)))\n                                (local.abs (ik y))\n 2. \\<And>y A B Ma.\n       \\<lbrakk>M' = Auth A B Ma; y \\<in> l3_inv5; y \\<in> l3_inv6;\n        y \\<in> l3_inv7; y \\<in> l3_inv8; y \\<in> l3_inv9;\n        implAuth A B Ma \\<in> synth (analz (ik y)); M = implAuth A B Ma;\n        Ma \\<in> payload\\<rbrakk>\n       \\<Longrightarrow> Auth A B Ma\n                         \\<in> fake (l3_state.bad y)\n                                (dy_fake_msg (l3_state.bad y)\n                                  (ik y \\<inter> payload)\n                                  (local.abs (ik y)))\n                                (local.abs (ik y))\n 3. \\<And>y A B Ma.\n       \\<lbrakk>M' = Secure A B Ma; y \\<in> l3_inv5; y \\<in> l3_inv6;\n        y \\<in> l3_inv7; y \\<in> l3_inv8; y \\<in> l3_inv9;\n        implSecure A B Ma \\<in> synth (analz (ik y)); M = implSecure A B Ma;\n        Ma \\<in> payload\\<rbrakk>\n       \\<Longrightarrow> Secure A B Ma\n                         \\<in> fake (l3_state.bad y)\n                                (dy_fake_msg (l3_state.bad y)\n                                  (ik y \\<inter> payload)\n                                  (local.abs (ik y)))\n                                (local.abs (ik y))", "apply (blast dest: l3_inv7D l3_inv5D)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y A B Ma.\n       \\<lbrakk>M' = Auth A B Ma; y \\<in> l3_inv5; y \\<in> l3_inv6;\n        y \\<in> l3_inv7; y \\<in> l3_inv8; y \\<in> l3_inv9;\n        implAuth A B Ma \\<in> synth (analz (ik y)); M = implAuth A B Ma;\n        Ma \\<in> payload\\<rbrakk>\n       \\<Longrightarrow> Auth A B Ma\n                         \\<in> fake (l3_state.bad y)\n                                (dy_fake_msg (l3_state.bad y)\n                                  (ik y \\<inter> payload)\n                                  (local.abs (ik y)))\n                                (local.abs (ik y))\n 2. \\<And>y A B Ma.\n       \\<lbrakk>M' = Secure A B Ma; y \\<in> l3_inv5; y \\<in> l3_inv6;\n        y \\<in> l3_inv7; y \\<in> l3_inv8; y \\<in> l3_inv9;\n        implSecure A B Ma \\<in> synth (analz (ik y)); M = implSecure A B Ma;\n        Ma \\<in> payload\\<rbrakk>\n       \\<Longrightarrow> Secure A B Ma\n                         \\<in> fake (l3_state.bad y)\n                                (dy_fake_msg (l3_state.bad y)\n                                  (ik y \\<inter> payload)\n                                  (local.abs (ik y)))\n                                (local.abs (ik y))", "text \\<open>Auth\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y A B Ma.\n       \\<lbrakk>M' = Auth A B Ma; y \\<in> l3_inv5; y \\<in> l3_inv6;\n        y \\<in> l3_inv7; y \\<in> l3_inv8; y \\<in> l3_inv9;\n        implAuth A B Ma \\<in> synth (analz (ik y)); M = implAuth A B Ma;\n        Ma \\<in> payload\\<rbrakk>\n       \\<Longrightarrow> Auth A B Ma\n                         \\<in> fake (l3_state.bad y)\n                                (dy_fake_msg (l3_state.bad y)\n                                  (ik y \\<inter> payload)\n                                  (local.abs (ik y)))\n                                (local.abs (ik y))\n 2. \\<And>y A B Ma.\n       \\<lbrakk>M' = Secure A B Ma; y \\<in> l3_inv5; y \\<in> l3_inv6;\n        y \\<in> l3_inv7; y \\<in> l3_inv8; y \\<in> l3_inv9;\n        implSecure A B Ma \\<in> synth (analz (ik y)); M = implSecure A B Ma;\n        Ma \\<in> payload\\<rbrakk>\n       \\<Longrightarrow> Secure A B Ma\n                         \\<in> fake (l3_state.bad y)\n                                (dy_fake_msg (l3_state.bad y)\n                                  (ik y \\<inter> payload)\n                                  (local.abs (ik y)))\n                                (local.abs (ik y))", "apply (blast dest: l3_inv8D l3_inv5D)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y A B Ma.\n       \\<lbrakk>M' = Secure A B Ma; y \\<in> l3_inv5; y \\<in> l3_inv6;\n        y \\<in> l3_inv7; y \\<in> l3_inv8; y \\<in> l3_inv9;\n        implSecure A B Ma \\<in> synth (analz (ik y)); M = implSecure A B Ma;\n        Ma \\<in> payload\\<rbrakk>\n       \\<Longrightarrow> Secure A B Ma\n                         \\<in> fake (l3_state.bad y)\n                                (dy_fake_msg (l3_state.bad y)\n                                  (ik y \\<inter> payload)\n                                  (local.abs (ik y)))\n                                (local.abs (ik y))", "text \\<open>Secure\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y A B Ma.\n       \\<lbrakk>M' = Secure A B Ma; y \\<in> l3_inv5; y \\<in> l3_inv6;\n        y \\<in> l3_inv7; y \\<in> l3_inv8; y \\<in> l3_inv9;\n        implSecure A B Ma \\<in> synth (analz (ik y)); M = implSecure A B Ma;\n        Ma \\<in> payload\\<rbrakk>\n       \\<Longrightarrow> Secure A B Ma\n                         \\<in> fake (l3_state.bad y)\n                                (dy_fake_msg (l3_state.bad y)\n                                  (ik y \\<inter> payload)\n                                  (local.abs (ik y)))\n                                (local.abs (ik y))", "apply (blast dest: l3_inv9D l3_inv5D)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma l3_dy_valid_refines_dy_fake_chan_Un:\n  \"M \\<in> valid \\<Longrightarrow>\n   {R23s \\<inter> UNIV \\<times> (l3_inv5 \\<inter> l3_inv6 \\<inter> l3_inv7 \\<inter> l3_inv8 \\<inter> l3_inv9)} \n      \\<Union>M'. l2_dy_fake_chan M', l3_dy M \n   {>R23s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<in> valid \\<Longrightarrow>\n    {R23s \\<inter>\n     UNIV \\<times>\n     (l3_inv5 \\<inter> l3_inv6 \\<inter> l3_inv7 \\<inter> l3_inv8 \\<inter>\n      l3_inv9)} \\<Union> (range l2_dy_fake_chan), l3_dy M {> R23s}", "by (auto dest: valid_abs intro: l3_dy_valid_refines_dy_fake_chan)"], ["", "lemma l3_dy_isLtKey_refines_skip:\n  \"{R23s} Id, l3_dy (LtK ltk) {>R23s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R23s} Id, l3_dy (LtK ltk) {> R23s}", "apply (auto simp add: PO_rhoare_defs R23s_defs l3_defs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y x.\n       \\<lbrakk>LtK ltk \\<in> analz (ik y);\n        x \\<in> local.abs (ik y)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> local.abs (insert (LtK ltk) (ik y))\n 2. \\<And>y x.\n       \\<lbrakk>LtK ltk \\<in> analz (ik y);\n        x \\<in> local.abs (insert (LtK ltk) (ik y))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> local.abs (ik y)", "apply (auto elim!: absE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma l3_dy_others_refines_skip:\n  \"\\<lbrakk> M \\<notin> range LtK; M \\<notin> valid; M \\<notin> payload \\<rbrakk> \\<Longrightarrow> \n   {R23s} Id, l3_dy M {>R23s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M \\<notin> range LtK; M \\<notin> valid;\n     M \\<notin> payload\\<rbrakk>\n    \\<Longrightarrow> {R23s} Id, l3_dy M {> R23s}", "apply (auto simp add: PO_rhoare_defs R23s_defs)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>b y x.\n       \\<lbrakk>M \\<notin> range LtK; M \\<notin> valid; M \\<notin> payload;\n        (y, b) \\<in> l3_dy M; x \\<in> ik y; x \\<in> payload\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ik b\n 2. \\<And>b y x.\n       \\<lbrakk>M \\<notin> range LtK; M \\<notin> valid; M \\<notin> payload;\n        (y, b) \\<in> l3_dy M; x \\<in> ik b; x \\<in> payload\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ik y\n 3. \\<And>b y x.\n       \\<lbrakk>M \\<notin> range LtK; M \\<notin> valid; M \\<notin> payload;\n        (y, b) \\<in> l3_dy M; x \\<in> secret y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> secret b\n 4. \\<And>b y x.\n       \\<lbrakk>M \\<notin> range LtK; M \\<notin> valid; M \\<notin> payload;\n        (y, b) \\<in> l3_dy M; x \\<in> secret b\\<rbrakk>\n       \\<Longrightarrow> x \\<in> secret y\n 5. \\<And>b y.\n       \\<lbrakk>M \\<notin> range LtK; M \\<notin> valid; M \\<notin> payload;\n        (y, b) \\<in> l3_dy M\\<rbrakk>\n       \\<Longrightarrow> progress y = progress b\n 6. \\<And>b y.\n       \\<lbrakk>M \\<notin> range LtK; M \\<notin> valid; M \\<notin> payload;\n        (y, b) \\<in> l3_dy M\\<rbrakk>\n       \\<Longrightarrow> l1_state.signals y = l1_state.signals b\n 7. \\<And>b y x.\n       \\<lbrakk>M \\<notin> range LtK; M \\<notin> valid; M \\<notin> payload;\n        (y, b) \\<in> l3_dy M; x \\<in> local.abs (ik y)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> local.abs (ik b)\n 8. \\<And>b y x.\n       \\<lbrakk>M \\<notin> range LtK; M \\<notin> valid; M \\<notin> payload;\n        (y, b) \\<in> l3_dy M; x \\<in> local.abs (ik b)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> local.abs (ik y)\n 9. \\<And>b y x.\n       \\<lbrakk>M \\<notin> range LtK; M \\<notin> valid; M \\<notin> payload;\n        (y, b) \\<in> l3_dy M; x \\<in> l3_state.bad y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> l3_state.bad b\n 10. \\<And>b y x.\n        \\<lbrakk>M \\<notin> range LtK; M \\<notin> valid; M \\<notin> payload;\n         (y, b) \\<in> l3_dy M; x \\<in> l3_state.bad b\\<rbrakk>\n        \\<Longrightarrow> x \\<in> l3_state.bad y", "(* auto SLOW *)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>b y x.\n       \\<lbrakk>M \\<notin> range LtK; M \\<notin> valid; M \\<notin> payload;\n        (y, b) \\<in> l3_dy M; x \\<in> ik y; x \\<in> payload\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ik b\n 2. \\<And>b y x.\n       \\<lbrakk>M \\<notin> range LtK; M \\<notin> valid; M \\<notin> payload;\n        (y, b) \\<in> l3_dy M; x \\<in> ik b; x \\<in> payload\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ik y\n 3. \\<And>b y x.\n       \\<lbrakk>M \\<notin> range LtK; M \\<notin> valid; M \\<notin> payload;\n        (y, b) \\<in> l3_dy M; x \\<in> secret y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> secret b\n 4. \\<And>b y x.\n       \\<lbrakk>M \\<notin> range LtK; M \\<notin> valid; M \\<notin> payload;\n        (y, b) \\<in> l3_dy M; x \\<in> secret b\\<rbrakk>\n       \\<Longrightarrow> x \\<in> secret y\n 5. \\<And>b y.\n       \\<lbrakk>M \\<notin> range LtK; M \\<notin> valid; M \\<notin> payload;\n        (y, b) \\<in> l3_dy M\\<rbrakk>\n       \\<Longrightarrow> progress y = progress b\n 6. \\<And>b y.\n       \\<lbrakk>M \\<notin> range LtK; M \\<notin> valid; M \\<notin> payload;\n        (y, b) \\<in> l3_dy M\\<rbrakk>\n       \\<Longrightarrow> l1_state.signals y = l1_state.signals b\n 7. \\<And>b y x.\n       \\<lbrakk>M \\<notin> range LtK; M \\<notin> valid; M \\<notin> payload;\n        (y, b) \\<in> l3_dy M; x \\<in> local.abs (ik y)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> local.abs (ik b)\n 8. \\<And>b y x.\n       \\<lbrakk>M \\<notin> range LtK; M \\<notin> valid; M \\<notin> payload;\n        (y, b) \\<in> l3_dy M; x \\<in> local.abs (ik b)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> local.abs (ik y)\n 9. \\<And>b y x.\n       \\<lbrakk>M \\<notin> range LtK; M \\<notin> valid; M \\<notin> payload;\n        (y, b) \\<in> l3_dy M; x \\<in> l3_state.bad y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> l3_state.bad b\n 10. \\<And>b y x.\n        \\<lbrakk>M \\<notin> range LtK; M \\<notin> valid; M \\<notin> payload;\n         (y, b) \\<in> l3_dy M; x \\<in> l3_state.bad b\\<rbrakk>\n        \\<Longrightarrow> x \\<in> l3_state.bad y", "apply (auto simp add: l3_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x.\n       \\<lbrakk>M \\<notin> range LtK; M \\<notin> valid; M \\<notin> payload;\n        M \\<in> synth (analz (ik y));\n        x \\<in> local.abs (insert M (ik y))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> local.abs (ik y)", "apply (auto elim!: absE intro: validI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma l3_dy_refines_dy_fake_msg_dy_fake_chan_skip:\n   \"{R23s \\<inter> UNIV \\<times> (l3_inv5 \\<inter> l3_inv6 \\<inter> l3_inv7 \\<inter> l3_inv8 \\<inter> l3_inv9)} \n      l2_dy_fake_msg M \\<union> (\\<Union>M'. l2_dy_fake_chan M') \\<union> Id, l3_dy M \n    {>R23s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R23s \\<inter>\n     UNIV \\<times>\n     (l3_inv5 \\<inter> l3_inv6 \\<inter> l3_inv7 \\<inter> l3_inv8 \\<inter>\n      l3_inv9)} (l2_dy_fake_msg M \\<union>\n                 \\<Union> (range l2_dy_fake_chan))\\<^sup>=, l3_dy M {> R23s}", "by (cases \"M \\<in> payload \\<union> valid \\<union> range LtK\")\n   (auto dest: l3_dy_payload_refines_dy_fake_msg l3_dy_valid_refines_dy_fake_chan_Un \n         intro: l3_dy_isLtKey_refines_skip dest!: l3_dy_others_refines_skip)"], ["", "subsubsection \\<open>Compromise events\\<close>"], ["", "(**************************************************************************************************)"], ["", "lemma l3_lkr_others_refines_lkr_others:\n  \"{R23s} l2_lkr_others A, l3_lkr_others A {>R23s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R23s} l2_lkr_others A, l3_lkr_others A {> R23s}", "apply (auto simp add: PO_rhoare_defs R23s_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b y.\n       (y, b) \\<in> l3_lkr_others A \\<Longrightarrow>\n       (\\<lparr>ik = ik y \\<inter> payload, secret = secret y,\n           progress = progress y, signals = l1_state.signals y,\n           chan = local.abs (ik y), bad = l3_state.bad y\\<rparr>,\n        \\<lparr>ik = ik b \\<inter> payload, secret = secret b,\n           progress = progress b, signals = l1_state.signals b,\n           chan = local.abs (ik b), bad = l3_state.bad b\\<rparr>)\n       \\<in> l2_lkr_others A", "apply (auto simp add: l3_defs l2_lkr_others_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma l3_lkr_after_refines_lkr_after:\n  \"{R23s} l2_lkr_after A, l3_lkr_after A {>R23s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R23s} l2_lkr_after A, l3_lkr_after A {> R23s}", "apply (auto simp add: PO_rhoare_defs R23s_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b y.\n       (y, b) \\<in> l3_lkr_after A \\<Longrightarrow>\n       (\\<lparr>ik = ik y \\<inter> payload, secret = secret y,\n           progress = progress y, signals = l1_state.signals y,\n           chan = local.abs (ik y), bad = l3_state.bad y\\<rparr>,\n        \\<lparr>ik = ik b \\<inter> payload, secret = secret b,\n           progress = progress b, signals = l1_state.signals b,\n           chan = local.abs (ik b), bad = l3_state.bad b\\<rparr>)\n       \\<in> l2_lkr_after A", "apply (auto simp add: l3_defs l2_lkr_after_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma l3_skr_refines_skr:\n  \"{R23s} l2_skr R K, l3_skr R K {>R23s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R23s} l2_skr R K, l3_skr R K {> R23s}", "apply (auto simp add: PO_rhoare_defs R23s_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b y.\n       (y, b) \\<in> l3_skr R K \\<Longrightarrow>\n       (\\<lparr>ik = ik y \\<inter> payload, secret = secret y,\n           progress = progress y, signals = l1_state.signals y,\n           chan = local.abs (ik y), bad = l3_state.bad y\\<rparr>,\n        \\<lparr>ik = ik b \\<inter> payload, secret = secret b,\n           progress = progress b, signals = l1_state.signals b,\n           chan = local.abs (ik b), bad = l3_state.bad b\\<rparr>)\n       \\<in> l2_skr R K", "apply (auto simp add: l3_defs l2_skr_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas l3_trans_refines_l2_trans = \n  l3_step1_refines_step1 l3_step2_refines_step2 l3_step3_refines_step3\n  l3_dy_refines_dy_fake_msg_dy_fake_chan_skip\n  l3_lkr_others_refines_lkr_others l3_lkr_after_refines_lkr_after l3_skr_refines_skr"], ["", "lemma l3_refines_init_l2 [iff]:\n  \"init l3 \\<subseteq> R23s `` (init l2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init l3 \\<subseteq> R23s `` init l2", "by (auto simp add: R23s_defs l2_defs l3_def l3_init_def)"], ["", "lemma l3_refines_trans_l2 [iff]:\n  \"{R23s \\<inter> (UNIV \\<times> (l3_inv1 \\<inter> l3_inv2 \\<inter> l3_inv3 \\<inter> l3_inv4))} trans l2, trans l3 {> R23s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R23s \\<inter>\n     UNIV \\<times>\n     (l3_inv1 \\<inter> l3_inv2 \\<inter> l3_inv3 \\<inter>\n      l3_inv4)} TS.trans l2, TS.trans l3 {> R23s}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {R23s \\<inter>\n     UNIV \\<times>\n     (l3_inv1 \\<inter> l3_inv2 \\<inter> l3_inv3 \\<inter>\n      l3_inv4)} TS.trans l2, TS.trans l3 {> R23s}", "let ?pre' = \"R23s \\<inter> (UNIV \\<times> (l3_inv5 \\<inter> l3_inv6 \\<inter> l3_inv7 \\<inter> l3_inv8 \\<inter> l3_inv9))\""], ["proof (state)\ngoal (1 subgoal):\n 1. {R23s \\<inter>\n     UNIV \\<times>\n     (l3_inv1 \\<inter> l3_inv2 \\<inter> l3_inv3 \\<inter>\n      l3_inv4)} TS.trans l2, TS.trans l3 {> R23s}", "show ?thesis (is \"{?pre} ?t1, ?t2 {>?post}\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {R23s \\<inter>\n     UNIV \\<times>\n     (l3_inv1 \\<inter> l3_inv2 \\<inter> l3_inv3 \\<inter>\n      l3_inv4)} TS.trans l2, TS.trans l3 {> R23s}", "proof (rule relhoare_conseq_left)"], ["proof (state)\ngoal (2 subgoals):\n 1. {?pre'} TS.trans l2, TS.trans l3 {> R23s}\n 2. R23s \\<inter>\n    UNIV \\<times>\n    (l3_inv1 \\<inter> l3_inv2 \\<inter> l3_inv3 \\<inter> l3_inv4)\n    \\<subseteq> ?pre'", "show \"?pre \\<subseteq> ?pre'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R23s \\<inter>\n    UNIV \\<times>\n    (l3_inv1 \\<inter> l3_inv2 \\<inter> l3_inv3 \\<inter> l3_inv4)\n    \\<subseteq> R23s \\<inter>\n                UNIV \\<times>\n                (l3_inv5 \\<inter> l3_inv6 \\<inter> l3_inv7 \\<inter>\n                 l3_inv8 \\<inter>\n                 l3_inv9)", "using l3_inv5_derived l3_inv6_derived l3_inv7_derived l3_inv8_derived l3_inv9_derived"], ["proof (prove)\nusing this:\n  l3_inv2 \\<inter> l3_inv3 \\<subseteq> l3_inv5\n  l3_inv3 \\<inter> l3_inv4 \\<subseteq> l3_inv6\n  l3_inv3 \\<inter> l3_inv4 \\<subseteq> l3_inv7\n  l3_inv2 \\<inter> l3_inv3 \\<inter> l3_inv4 \\<subseteq> l3_inv8\n  l3_inv2 \\<inter> l3_inv3 \\<inter> l3_inv4 \\<subseteq> l3_inv9\n\ngoal (1 subgoal):\n 1. R23s \\<inter>\n    UNIV \\<times>\n    (l3_inv1 \\<inter> l3_inv2 \\<inter> l3_inv3 \\<inter> l3_inv4)\n    \\<subseteq> R23s \\<inter>\n                UNIV \\<times>\n                (l3_inv5 \\<inter> l3_inv6 \\<inter> l3_inv7 \\<inter>\n                 l3_inv8 \\<inter>\n                 l3_inv9)", "by blast"], ["proof (state)\nthis:\n  R23s \\<inter>\n  UNIV \\<times> (l3_inv1 \\<inter> l3_inv2 \\<inter> l3_inv3 \\<inter> l3_inv4)\n  \\<subseteq> R23s \\<inter>\n              UNIV \\<times>\n              (l3_inv5 \\<inter> l3_inv6 \\<inter> l3_inv7 \\<inter>\n               l3_inv8 \\<inter>\n               l3_inv9)\n\ngoal (1 subgoal):\n 1. {R23s \\<inter>\n     UNIV \\<times>\n     (l3_inv5 \\<inter> l3_inv6 \\<inter> l3_inv7 \\<inter> l3_inv8 \\<inter>\n      l3_inv9)} TS.trans l2, TS.trans l3 {> R23s}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {R23s \\<inter>\n     UNIV \\<times>\n     (l3_inv5 \\<inter> l3_inv6 \\<inter> l3_inv7 \\<inter> l3_inv8 \\<inter>\n      l3_inv9)} TS.trans l2, TS.trans l3 {> R23s}", "show \"{?pre'} ?t1, ?t2 {> ?post}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R23s \\<inter>\n     UNIV \\<times>\n     (l3_inv5 \\<inter> l3_inv6 \\<inter> l3_inv7 \\<inter> l3_inv8 \\<inter>\n      l3_inv9)} TS.trans l2, TS.trans l3 {> R23s}", "by (auto simp add: l2_def l3_def l2_trans_def l3_trans_def\n               intro!: l3_trans_refines_l2_trans)"], ["proof (state)\nthis:\n  {R23s \\<inter>\n   UNIV \\<times>\n   (l3_inv5 \\<inter> l3_inv6 \\<inter> l3_inv7 \\<inter> l3_inv8 \\<inter>\n    l3_inv9)} TS.trans l2, TS.trans l3 {> R23s}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {R23s \\<inter>\n   UNIV \\<times>\n   (l3_inv1 \\<inter> l3_inv2 \\<inter> l3_inv3 \\<inter>\n    l3_inv4)} TS.trans l2, TS.trans l3 {> R23s}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma PO_obs_consistent_R23s [iff]: \n  \"obs_consistent R23s med23s l2 l3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent R23s med23s l2 l3", "by (auto simp add: obs_consistent_def R23s_def med23s_def l2_defs)"], ["", "lemma l3_refines_l2 [iff]:\n  \"refines \n     (R23s \\<inter> \n      (reach l2 \\<times> (l3_inv1 \\<inter> l3_inv2 \\<inter> l3_inv3 \\<inter> l3_inv4)))\n     med23s l2 l3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines\n     (R23s \\<inter>\n      reach l2 \\<times>\n      (l3_inv1 \\<inter> l3_inv2 \\<inter> l3_inv3 \\<inter> l3_inv4))\n     med23s l2 l3", "by (rule Refinement_using_invariants, auto)"], ["", "lemma l3_implements_l2 [iff]:\n  \"implements med23s l2 l3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements med23s l2 l3", "by (rule refinement_soundness) (auto)"], ["", "(**************************************************************************************************)"], ["", "subsection \\<open>Derived invariants\\<close>"], ["", "(**************************************************************************************************)"], ["", "subsubsection \\<open>inv10: secrets contain no implementation material\\<close>"], ["", "(**************************************************************************************************)"], ["", "definition\n  l3_inv10 :: \"l3_state set\"\nwhere\n  \"l3_inv10 \\<equiv> {s.\n    secret s \\<subseteq> payload\n  }\""], ["", "lemmas l3_inv10I = l3_inv10_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas l3_inv10E = l3_inv10_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas l3_inv10D = l3_inv10_def [THEN setc_def_to_dest, rule_format]"], ["", "lemma l3_inv10_init [iff]: \n  \"init l3 \\<subseteq> l3_inv10\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init l3 \\<subseteq> l3_inv10", "by (auto simp add: l3_def l3_init_def ik_init_def intro!:l3_inv10I)"], ["", "lemma l3_inv10_trans [iff]:\n  \"{l3_inv10} trans l3 {> l3_inv10}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l3_inv10} TS.trans l3 {> l3_inv10}", "apply (auto simp add: PO_hoare_defs l3_nostep_defs)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x xa xf xg xh.\n       \\<lbrakk>xa \\<in> l3_inv10; (xa, x) \\<in> l3_step1 xf xg xh\\<rbrakk>\n       \\<Longrightarrow> x \\<in> l3_inv10\n 2. \\<And>x xa xd xe xg xh.\n       \\<lbrakk>xa \\<in> l3_inv10;\n        (xa, x) \\<in> l3_step2 xe xg xh xd\\<rbrakk>\n       \\<Longrightarrow> x \\<in> l3_inv10\n 3. \\<And>x xa xb xf xg xh.\n       \\<lbrakk>xa \\<in> l3_inv10;\n        (xa, x) \\<in> l3_step3 xf xg xh xb\\<rbrakk>\n       \\<Longrightarrow> x \\<in> l3_inv10\n 4. \\<And>x xa xc.\n       \\<lbrakk>xa \\<in> l3_inv10; (xa, x) \\<in> l3_dy xc\\<rbrakk>\n       \\<Longrightarrow> x \\<in> l3_inv10\n 5. \\<And>x xa xg.\n       \\<lbrakk>xa \\<in> l3_inv10; (xa, x) \\<in> l3_lkr_others xg\\<rbrakk>\n       \\<Longrightarrow> x \\<in> l3_inv10\n 6. \\<And>x xa xg.\n       \\<lbrakk>xa \\<in> l3_inv10; (xa, x) \\<in> l3_lkr_after xg\\<rbrakk>\n       \\<Longrightarrow> x \\<in> l3_inv10\n 7. \\<And>x xa xf xg.\n       \\<lbrakk>xa \\<in> l3_inv10; (xa, x) \\<in> l3_skr xf xg\\<rbrakk>\n       \\<Longrightarrow> x \\<in> l3_inv10", "apply (auto simp add: l3_defs l3_inv10_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_l3_inv10 [iff]: \"reach l3 \\<subseteq> l3_inv10\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l3 \\<subseteq> l3_inv10", "by (rule inv_rule_basic) (auto)"], ["", "lemma l3_obs_inv10 [iff]: \"oreach l3 \\<subseteq> l3_inv10\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oreach l3 \\<subseteq> l3_inv10", "by (auto simp add: oreach_def)"], ["", "subsubsection \\<open>Partial secrecy\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>We want to prove @{term \"l3_secrecy\"}, ie\n  @{term \"synth (analz (ik s)) \\<inter> secret s = {}\"},\n  but by refinement we only get @{term \"l3_partial_secrecy\"}: \n    @{term \"dy_fake_msg (bad s) (payloadSet (ik s)) (abs (ik s)) \\<inter> secret s = {}\"}.\n  This is fine if secrets contain no implementation material.\n  Then, by @{term \"inv5\"}, a message in @{term \"synth (analz (ik s))\"} is in\n    @{term \"dy_fake_msg (bad s) (payloadSet (ik s)) (abs (ik s)) \\<union> -payload\"},\n  and @{term \"l3_partial_secrecy\"} proves it is not a secret.\n\\<close>"], ["", "definition\n  l3_partial_secrecy :: \"('a l3_state_scheme) set\"\nwhere\n  \"l3_partial_secrecy \\<equiv> {s. \n    dy_fake_msg (bad s) (ik s \\<inter> payload) (abs (ik s)) \\<inter> secret s = {}\n  }\""], ["", "lemma l3_obs_partial_secrecy [iff]: \"oreach l3 \\<subseteq> l3_partial_secrecy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oreach l3 \\<subseteq> l3_partial_secrecy", "apply (rule external_invariant_translation [OF l2_obs_secrecy _ l3_implements_l2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. med23s -` l2_secrecy \\<subseteq> l3_partial_secrecy", "apply (auto simp add: med23s_def l2_secrecy_def l3_partial_secrecy_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Secrecy\\<close>"], ["", "(**************************************************************************************************)"], ["", "definition \n  l3_secrecy :: \"('a l3_state_scheme) set\"\nwhere\n  \"l3_secrecy \\<equiv> l1_secrecy\""], ["", "lemma l3_obs_inv5: \"oreach l3 \\<subseteq> l3_inv5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oreach l3 \\<subseteq> l3_inv5", "by (auto simp add: oreach_def)"], ["", "lemma l3_obs_secrecy [iff]: \"oreach l3 \\<subseteq> l3_secrecy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oreach l3 \\<subseteq> l3_secrecy", "apply (rule, frule l3_obs_inv5 [THEN [2] rev_subsetD], frule l3_obs_inv10 [THEN [2] rev_subsetD])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> oreach l3; x \\<in> l3_inv5;\n        x \\<in> l3_inv10\\<rbrakk>\n       \\<Longrightarrow> x \\<in> l3_secrecy", "apply (auto simp add: med23s_def l2_secrecy_def l3_secrecy_def s0_secrecy_def l3_inv10_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> oreach l3; x \\<in> l3_inv5;\n        secret x \\<subseteq> payload; xa \\<in> synth (analz (ik x));\n        xa \\<in> secret x\\<rbrakk>\n       \\<Longrightarrow> False", "using l3_partial_secrecy_def"], ["proof (prove)\nusing this:\n  l3_partial_secrecy \\<equiv>\n  {s. dy_fake_msg (l3_state.bad s) (ik s \\<inter> payload)\n       (local.abs (ik s)) \\<inter>\n      secret s =\n      {}}\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> oreach l3; x \\<in> l3_inv5;\n        secret x \\<subseteq> payload; xa \\<in> synth (analz (ik x));\n        xa \\<in> secret x\\<rbrakk>\n       \\<Longrightarrow> False", "apply (blast dest!: l3_inv5D subsetD [OF l3_obs_partial_secrecy])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma l3_secrecy [iff]: \"reach l3 \\<subseteq> l3_secrecy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l3 \\<subseteq> l3_secrecy", "by (rule external_to_internal_invariant [OF l3_obs_secrecy], auto)"], ["", "subsubsection \\<open>Injective agreement\\<close>"], ["", "(**************************************************************************************************)"], ["", "abbreviation \"l3_iagreement \\<equiv> l1_iagreement\""], ["", "lemma l3_obs_iagreement [iff]: \"oreach l3 \\<subseteq> l3_iagreement\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oreach l3 \\<subseteq> l2_iagreement", "apply (rule external_invariant_translation [OF l2_obs_iagreement _ l3_implements_l2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. med23s -` l2_iagreement \\<subseteq> l2_iagreement", "apply (auto simp add: med23s_def l1_iagreement_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma l3_iagreement [iff]: \"reach l3 \\<subseteq> l3_iagreement\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l3 \\<subseteq> l2_iagreement", "by (rule external_to_internal_invariant [OF l3_obs_iagreement], auto)"], ["", "end"], ["", "end"]]}