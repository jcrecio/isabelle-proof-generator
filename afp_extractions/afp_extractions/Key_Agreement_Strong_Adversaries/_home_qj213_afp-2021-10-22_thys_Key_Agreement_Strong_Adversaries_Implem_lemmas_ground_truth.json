{"file_name": "/home/qj213/afp-2021-10-22/thys/Key_Agreement_Strong_Adversaries/Implem_lemmas.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Key_Agreement_Strong_Adversaries", "problem_names": ["lemma absE [elim]: \n  \"\\<lbrakk> X \\<in> abs H;\n     \\<And> x A B M. X = Chan x A B M \\<Longrightarrow> M \\<in> payload \\<Longrightarrow> implem X \\<in> H \\<Longrightarrow> P \\<rbrakk>\n  \\<Longrightarrow> P\"", "lemma absI [intro]: \"M \\<in> payload \\<Longrightarrow> implem (Chan x A B M) \\<in> H \\<Longrightarrow> Chan x A B M \\<in> abs H\"", "lemma abs_mono: \"G \\<subseteq> H \\<Longrightarrow> abs G \\<subseteq> abs H\"", "lemmas abs_monotone [simp] = abs_mono [THEN [2] rev_subsetD]", "lemma abs_empty [simp]: \"abs {} = {}\"", "lemma abs_Un_eq: \"abs (G \\<union> H) = abs G \\<union> abs H\"", "lemma abs_insert_payload [simp]: \"M \\<in> payload \\<Longrightarrow> abs (insert M S) = abs S\"", "lemma abs_insert_impl [simp]:\n  \"M \\<in> payload \\<Longrightarrow> abs (insert (implem (Chan x A B M)) S) = insert (Chan x A B M) (abs S)\"", "lemma extr_payload [simp, intro]:\n  \"\\<lbrakk> X \\<in> extr Bad NI (abs I); NI \\<subseteq> payload \\<rbrakk> \\<Longrightarrow> X \\<in> payload\"", "lemma abs_Un_LtK:\n  \"K \\<subseteq> range LtK \\<Longrightarrow> abs (K \\<union> S) = abs S\"", "lemma abs_Un_keys_of [simp]:\n  \"abs (keys_of A \\<union> S) = abs S\"", "lemma abs_validSet: \"abs (S \\<inter> valid) = abs S\"", "lemma valid_abs: \"M \\<in> valid \\<Longrightarrow> \\<exists> M'. M' \\<in> abs {M}\"", "lemma extractable_red: \"extractable K I \\<subseteq> I\"", "lemma extractableI:\n  \"implem (Chan x A B M) \\<in> I \\<Longrightarrow>\n   x = insec \\<or> x = auth \\<or> ((x = confid \\<or> x = secure) \\<and> (A, B) \\<in> broken K) \\<Longrightarrow>   \n   implem (Chan x A B M) \\<in> extractable K I\"", "lemma extractableE:\n  \"X \\<in> extractable K I \\<Longrightarrow>\n   (\\<And>A B M. X = implInsec A B M \\<Longrightarrow> X \\<in> I \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<And>A B M. X = implAuth A B M \\<Longrightarrow> X \\<in> I \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<And>A B M. X = implConfid A B M \\<Longrightarrow> X \\<in> I \\<Longrightarrow> (A, B) \\<in> broken K \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<And>A B M. X = implSecure A B M \\<Longrightarrow> X \\<in> I \\<Longrightarrow> (A, B) \\<in> broken K \\<Longrightarrow> P) \\<Longrightarrow>\n  P\"", "lemma implem_extractable [simp]:\n  \"\\<lbrakk> Keys_bad K Bad; implem (Chan x A B M) \\<in> extractable K I; M \\<in> payload \\<rbrakk> \n \\<Longrightarrow> M \\<in> extr Bad NI (abs I)\"", "lemma valid_extractable [simp]: \"I \\<subseteq> valid \\<Longrightarrow> extractable K I \\<subseteq> valid\"", "lemma LtKeys_parts_extractable:\n  \"I \\<subseteq> valid \\<Longrightarrow> parts (extractable K I) \\<inter> range LtK = {}\"", "lemma LtKeys_parts_extractable_elt [simp]:  \n  \"I \\<subseteq> valid \\<Longrightarrow> LtK ltk \\<notin> parts (extractable K I)\"", "lemma LtKeys_parts_implSecureSet:   (* FIX: possibly problematic: not in normal form *)\n  \"parts (implSecureSet Ag payload) \\<inter> range LtK = {}\"", "lemma LtKeys_parts_implSecureSet_elt: \n  \"LtK K \\<notin> parts (implSecureSet Ag payload)\"", "lemmas LtKeys_parts = LtKeys_parts_payload parts_valid_LtKeys_disjoint\n                      LtKeys_parts_extractable LtKeys_parts_implSecureSet \n                      LtKeys_parts_implSecureSet_elt", "lemma impl_partition:\n  \"\\<lbrakk> NI \\<subseteq> payload; I \\<subseteq> valid \\<rbrakk> \\<Longrightarrow>\n  I \\<subseteq> extractable K I \\<union>\n      implConfidSet (UNIV - broken K) payload \\<union>\n      implSecureSet (UNIV - broken K) payload\"", "lemma extractable_partition:\n  \"\\<lbrakk>Keys_bad K Bad; NI \\<subseteq> payload; I \\<subseteq> valid\\<rbrakk> \\<Longrightarrow>\n  extractable K I \\<subseteq> \n  implInsecSet (extr Bad NI (abs I)) \\<union>\n  implConfidSet UNIV (extr Bad NI (abs I)) \\<union>\n  implAuthSet (extr Bad NI (abs I)) \\<union>\n  implSecureSet UNIV (extr Bad NI (abs I))\"", "lemma analz_NI_I_K_analz_NI_EI:\nassumes HNI: \"NI \\<subseteq> payload\"\n    and HK: \"K \\<subseteq> range LtK\"\n    and HI: \"I \\<subseteq> valid\"\nshows \"analz (NI \\<union> I \\<union> K \\<union> Tags) \\<subseteq>\n       synth (analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)) \\<union> -payload\"", "lemma analz_NI_EI_K_synth_analz_NI_E_K:\nassumes HNI: \"NI \\<subseteq> payload\"\n    and HK: \"K \\<subseteq> range LtK\"\n    and HI: \"I \\<subseteq> valid\"\n    and Hbad: \"Keys_bad K Bad\"\nshows \"analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)\n    \\<subseteq> synth (analz (extr Bad NI (abs I) \\<union> K \\<union> Tags)) \\<union> -payload\"", "lemma analz_LtKeys_Tag:\nassumes \"NI \\<subseteq> payload\" and \"K \\<subseteq> range LtK\"\nshows \"analz (NI \\<union> K \\<union> Tags) \\<subseteq> analz NI \\<union> K \\<union> Tags\"", "lemma analz_NI_E_K_analz_NI_E:\n  \"\\<lbrakk> NI \\<subseteq> payload; K \\<subseteq> range LtK; I \\<subseteq> valid \\<rbrakk> \n \\<Longrightarrow> analz (extr Bad NI (abs I) \\<union> K \\<union> Tags) \\<subseteq> analz (extr Bad NI (abs I)) \\<union> K \\<union> Tags\"", "lemma analz_NI_I_K_synth_analz_NI_E:\nassumes\n  Hbad: \"Keys_bad K Bad\" and \n  HNI: \"NI \\<subseteq> payload\" and \n  HK:  \"K \\<subseteq> range LtK\" and \n  HI: \"I \\<subseteq> valid\"\nshows \n  \"analz (NI \\<union> I \\<union> K \\<union> Tags) \\<subseteq> synth (analz (extr Bad NI (abs I))) \\<union> -payload\"", "lemma synth_analz_NI_I_K_synth_analz_NI_E:\n  \"\\<lbrakk> Keys_bad K Bad; NI \\<subseteq> payload; K \\<subseteq> range LtK; I \\<subseteq> valid\\<rbrakk>\n \\<Longrightarrow> synth (analz (NI \\<union> I \\<union> K \\<union> Tags)) \n   \\<subseteq> synth (analz (extr Bad NI (abs I))) \\<union> -payload\"", "lemma analz_Un_partition:\n  \"analz S \\<subseteq> synth (analz ((S \\<inter> payload) \\<union> (S \\<inter> valid) \\<union> (S \\<inter> range LtK) \\<union> Tags)) \\<Longrightarrow>\n  H \\<subseteq> payload \\<union> valid \\<union> range LtK \\<Longrightarrow>\n  analz (H \\<union> S) \\<subseteq>\n    synth (analz (((H \\<union> S) \\<inter> payload) \\<union> ((H \\<union> S) \\<inter> valid) \\<union> ((H \\<union> S) \\<inter> range LtK) \\<union> Tags))\"", "lemma analz_insert_partition:\n  \"analz S \\<subseteq> synth (analz ((S \\<inter> payload) \\<union> (S \\<inter> valid) \\<union> (S \\<inter> range LtK) \\<union> Tags)) \\<Longrightarrow>\n  x \\<in> payload \\<union> valid \\<union> range LtK \\<Longrightarrow>\n  analz (insert x S) \\<subseteq>\n    synth (analz (((insert x S) \\<inter> payload) \\<union> ((insert x S) \\<inter> valid) \\<union> \n                  ((insert x S) \\<inter> range LtK) \\<union> Tags))\""], "translations": [["", "lemma absE [elim]: \n  \"\\<lbrakk> X \\<in> abs H;\n     \\<And> x A B M. X = Chan x A B M \\<Longrightarrow> M \\<in> payload \\<Longrightarrow> implem X \\<in> H \\<Longrightarrow> P \\<rbrakk>\n  \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<in> local.abs H;\n     \\<And>x A B M.\n        \\<lbrakk>X = Chan x A B M; M \\<in> payload;\n         implem X \\<in> H\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (auto simp add: abs_def)"], ["", "lemma absI [intro]: \"M \\<in> payload \\<Longrightarrow> implem (Chan x A B M) \\<in> H \\<Longrightarrow> Chan x A B M \\<in> abs H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M \\<in> payload; implem (Chan x A B M) \\<in> H\\<rbrakk>\n    \\<Longrightarrow> Chan x A B M \\<in> local.abs H", "by (auto simp add: abs_def)"], ["", "lemma abs_mono: \"G \\<subseteq> H \\<Longrightarrow> abs G \\<subseteq> abs H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> H \\<Longrightarrow> local.abs G \\<subseteq> local.abs H", "by (auto simp add: abs_def)"], ["", "lemmas abs_monotone [simp] = abs_mono [THEN [2] rev_subsetD]"], ["", "lemma abs_empty [simp]: \"abs {} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.abs {} = {}", "by (auto simp add: abs_def)"], ["", "lemma abs_Un_eq: \"abs (G \\<union> H) = abs G \\<union> abs H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.abs (G \\<union> H) = local.abs G \\<union> local.abs H", "by (auto simp add: abs_def)"], ["", "text \\<open>General lemmas about implementations and @{term abs}.\\<close>"], ["", "lemma abs_insert_payload [simp]: \"M \\<in> payload \\<Longrightarrow> abs (insert M S) = abs S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<in> payload \\<Longrightarrow> local.abs (insert M S) = local.abs S", "by (auto simp add: abs_def)"], ["", "lemma abs_insert_impl [simp]:\n  \"M \\<in> payload \\<Longrightarrow> abs (insert (implem (Chan x A B M)) S) = insert (Chan x A B M) (abs S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<in> payload \\<Longrightarrow>\n    local.abs (insert (implem (Chan x A B M)) S) =\n    insert (Chan x A B M) (local.abs S)", "by (auto simp add: abs_def)"], ["", "lemma extr_payload [simp, intro]:\n  \"\\<lbrakk> X \\<in> extr Bad NI (abs I); NI \\<subseteq> payload \\<rbrakk> \\<Longrightarrow> X \\<in> payload\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<in> extr Bad NI (local.abs I);\n     NI \\<subseteq> payload\\<rbrakk>\n    \\<Longrightarrow> X \\<in> payload", "by (erule extr.induct, blast, auto)"], ["", "lemma abs_Un_LtK:\n  \"K \\<subseteq> range LtK \\<Longrightarrow> abs (K \\<union> S) = abs S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K \\<subseteq> range LtK \\<Longrightarrow>\n    local.abs (K \\<union> S) = local.abs S", "by (auto simp add: abs_Un_eq)"], ["", "lemma abs_Un_keys_of [simp]:\n  \"abs (keys_of A \\<union> S) = abs S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.abs (keys_of A \\<union> S) = local.abs S", "by (auto intro!: abs_Un_LtK)"], ["", "text \\<open>Lemmas about @{term valid} and @{term abs}\\<close>"], ["", "lemma abs_validSet: \"abs (S \\<inter> valid) = abs S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.abs (S \\<inter> valid) = local.abs S", "by (auto elim: absE intro: validI)"], ["", "lemma valid_abs: \"M \\<in> valid \\<Longrightarrow> \\<exists> M'. M' \\<in> abs {M}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<in> valid \\<Longrightarrow> \\<exists>M'. M' \\<in> local.abs {M}", "by (auto elim: validE)"], ["", "(**************************************************************************************************)"], ["", "subsection \\<open>Extractable messages\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>\\<open>extractable K I\\<close>: subset of messages in $I$ which are implementations \n(not necessarily valid since we do not require that they are payload) and can be extracted \nusing the keys in K. It corresponds to L2 @{term extr}.\\<close>"], ["", "definition\n  extractable :: \"msg set \\<Rightarrow> msg set \\<Rightarrow> msg set\"\nwhere\n  \"extractable K I \\<equiv>\n    {implInsec A B M | A B M. implInsec A B M \\<in> I} \\<union>\n    {implAuth A B M | A B M. implAuth A B M \\<in> I} \\<union>\n    {implConfid A B M | A B M. implConfid A B M \\<in> I \\<and> (A, B) \\<in> broken K} \\<union>\n    {implSecure A B M | A B M. implSecure A B M \\<in> I \\<and> (A, B) \\<in> broken K}\""], ["", "lemma extractable_red: \"extractable K I \\<subseteq> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extractable K I \\<subseteq> I", "by (auto simp add: extractable_def)"], ["", "lemma extractableI:\n  \"implem (Chan x A B M) \\<in> I \\<Longrightarrow>\n   x = insec \\<or> x = auth \\<or> ((x = confid \\<or> x = secure) \\<and> (A, B) \\<in> broken K) \\<Longrightarrow>   \n   implem (Chan x A B M) \\<in> extractable K I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>implem (Chan x A B M) \\<in> I;\n     x = insec \\<or>\n     x = auth \\<or>\n     (x = confid \\<or> x = secure) \\<and> (A, B) \\<in> broken K\\<rbrakk>\n    \\<Longrightarrow> implem (Chan x A B M) \\<in> extractable K I", "by (auto simp add: extractable_def)"], ["", "lemma extractableE:\n  \"X \\<in> extractable K I \\<Longrightarrow>\n   (\\<And>A B M. X = implInsec A B M \\<Longrightarrow> X \\<in> I \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<And>A B M. X = implAuth A B M \\<Longrightarrow> X \\<in> I \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<And>A B M. X = implConfid A B M \\<Longrightarrow> X \\<in> I \\<Longrightarrow> (A, B) \\<in> broken K \\<Longrightarrow> P) \\<Longrightarrow>\n   (\\<And>A B M. X = implSecure A B M \\<Longrightarrow> X \\<in> I \\<Longrightarrow> (A, B) \\<in> broken K \\<Longrightarrow> P) \\<Longrightarrow>\n  P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<in> extractable K I;\n     \\<And>A B M.\n        \\<lbrakk>X = implInsec A B M; X \\<in> I\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>A B M.\n        \\<lbrakk>X = implAuth A B M; X \\<in> I\\<rbrakk> \\<Longrightarrow> P;\n     \\<And>A B M.\n        \\<lbrakk>X = implConfid A B M; X \\<in> I;\n         (A, B) \\<in> broken K\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>A B M.\n        \\<lbrakk>X = implSecure A B M; X \\<in> I;\n         (A, B) \\<in> broken K\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (auto simp add: extractable_def brokenI)"], ["", "text \\<open>General lemmas about implementations and extractable.\\<close>"], ["", "lemma implem_extractable [simp]:\n  \"\\<lbrakk> Keys_bad K Bad; implem (Chan x A B M) \\<in> extractable K I; M \\<in> payload \\<rbrakk> \n \\<Longrightarrow> M \\<in> extr Bad NI (abs I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Keys_bad K Bad; implem (Chan x A B M) \\<in> extractable K I;\n     M \\<in> payload\\<rbrakk>\n    \\<Longrightarrow> M \\<in> extr Bad NI (local.abs I)", "by (erule extractableE, auto)"], ["", "text \\<open>Auxiliary lemmas about extractable messages: they are implementations.\\<close>"], ["", "lemma valid_extractable [simp]: \"I \\<subseteq> valid \\<Longrightarrow> extractable K I \\<subseteq> valid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<subseteq> valid \\<Longrightarrow> extractable K I \\<subseteq> valid", "by (auto intro: subset_trans extractable_red del: subsetI)"], ["", "lemma LtKeys_parts_extractable:\n  \"I \\<subseteq> valid \\<Longrightarrow> parts (extractable K I) \\<inter> range LtK = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<subseteq> valid \\<Longrightarrow>\n    parts (extractable K I) \\<inter> range LtK = {}", "by (auto dest: valid_extractable intro!: parts_valid_LtKeys_disjoint)"], ["", "lemma LtKeys_parts_extractable_elt [simp]:  \n  \"I \\<subseteq> valid \\<Longrightarrow> LtK ltk \\<notin> parts (extractable K I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<subseteq> valid \\<Longrightarrow>\n    LtK ltk \\<notin> parts (extractable K I)", "by (blast dest: LtKeys_parts_extractable)"], ["", "lemma LtKeys_parts_implSecureSet:   (* FIX: possibly problematic: not in normal form *)\n  \"parts (implSecureSet Ag payload) \\<inter> range LtK = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts\n     {implSecure A B M |A B M.\n      (A, B) \\<in> Ag \\<and> M \\<in> payload} \\<inter>\n    range LtK =\n    {}", "by (auto intro!: parts_valid_LtKeys_disjoint intro: validI)"], ["", "lemma LtKeys_parts_implSecureSet_elt: \n  \"LtK K \\<notin> parts (implSecureSet Ag payload)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LtK K\n    \\<notin> parts\n              {implSecure A B M |A B M.\n               (A, B) \\<in> Ag \\<and> M \\<in> payload}", "using LtKeys_parts_implSecureSet"], ["proof (prove)\nusing this:\n  parts\n   {implSecure A B M |A B M.\n    (A, B) \\<in> ?Ag \\<and> M \\<in> payload} \\<inter>\n  range LtK =\n  {}\n\ngoal (1 subgoal):\n 1. LtK K\n    \\<notin> parts\n              {implSecure A B M |A B M.\n               (A, B) \\<in> Ag \\<and> M \\<in> payload}", "by auto"], ["", "lemmas LtKeys_parts = LtKeys_parts_payload parts_valid_LtKeys_disjoint\n                      LtKeys_parts_extractable LtKeys_parts_implSecureSet \n                      LtKeys_parts_implSecureSet_elt"], ["", "subsubsection\\<open>Partition $I$ to keep only the extractable messages\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>Partition the implementation set.\\<close>"], ["", "lemma impl_partition:\n  \"\\<lbrakk> NI \\<subseteq> payload; I \\<subseteq> valid \\<rbrakk> \\<Longrightarrow>\n  I \\<subseteq> extractable K I \\<union>\n      implConfidSet (UNIV - broken K) payload \\<union>\n      implSecureSet (UNIV - broken K) payload\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>NI \\<subseteq> payload; I \\<subseteq> valid\\<rbrakk>\n    \\<Longrightarrow> I \\<subseteq> extractable K I \\<union>\n                                    {implConfid A B M |A B M.\n                                     (A, B) \\<in> UNIV - broken K \\<and>\n                                     M \\<in> payload} \\<union>\n                                    {implSecure A B M |A B M.\n                                     (A, B) \\<in> UNIV - broken K \\<and>\n                                     M \\<in> payload}", "by (auto dest!: subsetD [where A=I] elim!: valid_cases intro:  extractableI)"], ["", "subsubsection \\<open>Partition of @{term \"extractable\"}\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>We partition the @{term \"extractable\"} set into insecure, confidential, authentic \nimplementations.\\<close>"], ["", "lemma extractable_partition:\n  \"\\<lbrakk>Keys_bad K Bad; NI \\<subseteq> payload; I \\<subseteq> valid\\<rbrakk> \\<Longrightarrow>\n  extractable K I \\<subseteq> \n  implInsecSet (extr Bad NI (abs I)) \\<union>\n  implConfidSet UNIV (extr Bad NI (abs I)) \\<union>\n  implAuthSet (extr Bad NI (abs I)) \\<union>\n  implSecureSet UNIV (extr Bad NI (abs I))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Keys_bad K Bad; NI \\<subseteq> payload;\n     I \\<subseteq> valid\\<rbrakk>\n    \\<Longrightarrow> extractable K I\n                      \\<subseteq> {implInsec A B M |A B M.\n                                   M \\<in> extr Bad NI\n      (local.abs I)} \\<union>\n                                  {implConfid A B M |A B M.\n                                   (A, B) \\<in> UNIV \\<and>\n                                   M \\<in> extr Bad NI\n      (local.abs I)} \\<union>\n                                  {implAuth A B M |A B M.\n                                   M \\<in> extr Bad NI\n      (local.abs I)} \\<union>\n                                  {implSecure A B M |A B M.\n                                   (A, B) \\<in> UNIV \\<and>\n                                   M \\<in> extr Bad NI (local.abs I)}", "apply (rule, frule valid_extractable, drule subsetD [where A=\"extractable K I\"], fast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Keys_bad K Bad; NI \\<subseteq> payload; I \\<subseteq> valid;\n        x \\<in> extractable K I; x \\<in> valid\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {implInsec A B M |A B M.\n                                  M \\<in> extr Bad NI\n     (local.abs I)} \\<union>\n                                 {implConfid A B M |A B M.\n                                  (A, B) \\<in> UNIV \\<and>\n                                  M \\<in> extr Bad NI\n     (local.abs I)} \\<union>\n                                 {implAuth A B M |A B M.\n                                  M \\<in> extr Bad NI\n     (local.abs I)} \\<union>\n                                 {implSecure A B M |A B M.\n                                  (A, B) \\<in> UNIV \\<and>\n                                  M \\<in> extr Bad NI (local.abs I)}", "apply (erule valid_cases, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(**************************************************************************************************)"], ["", "subsection \\<open>Lemmas for proving intruder refinement (L2-L3)\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>Chain of lemmas used to prove the refinement for \\<open>l3_dy\\<close>. \nThe ultimate goal is to show @{prop [display] \n  \"synth (analz (NI \\<union> I \\<union> K \\<union> Tags)) \\<subseteq> synth (analz (extr Bad NI (abs I))) \\<union> -payload\"\n}\\<close>"], ["", "subsubsection \\<open>First: we only keep the extractable messages\\<close>\n\n\\<comment> \\<open>the \\<open>synth\\<close> is probably not needed\\<close>"], ["", "lemma analz_NI_I_K_analz_NI_EI:\nassumes HNI: \"NI \\<subseteq> payload\"\n    and HK: \"K \\<subseteq> range LtK\"\n    and HI: \"I \\<subseteq> valid\"\nshows \"analz (NI \\<union> I \\<union> K \\<union> Tags) \\<subseteq>\n       synth (analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)) \\<union> -payload\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (NI \\<union> I \\<union> K \\<union> Tags)\n    \\<subseteq> synth\n                 (analz\n                   (NI \\<union> extractable K I \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. analz (NI \\<union> I \\<union> K \\<union> Tags)\n    \\<subseteq> synth\n                 (analz\n                   (NI \\<union> extractable K I \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "from HNI HI"], ["proof (chain)\npicking this:\n  NI \\<subseteq> payload\n  I \\<subseteq> valid", "have \"analz (NI \\<union> I \\<union> K \\<union> Tags) \\<subseteq> \n        analz (NI \\<union> (extractable K I \\<union>\n                     implConfidSet (UNIV - broken K) payload \\<union>\n                     implSecureSet (UNIV - broken K) payload)\n                \\<union> K \\<union> Tags)\""], ["proof (prove)\nusing this:\n  NI \\<subseteq> payload\n  I \\<subseteq> valid\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> I \\<union> K \\<union> Tags)\n    \\<subseteq> analz\n                 (NI \\<union>\n                  (extractable K I \\<union>\n                   {implConfid A B M |A B M.\n                    (A, B) \\<in> UNIV - broken K \\<and>\n                    M \\<in> payload} \\<union>\n                   {implSecure A B M |A B M.\n                    (A, B) \\<in> UNIV - broken K \\<and>\n                    M \\<in> payload}) \\<union>\n                  K \\<union>\n                  Tags)", "by (intro analz_mono Un_mono impl_partition, simp_all)"], ["proof (state)\nthis:\n  analz (NI \\<union> I \\<union> K \\<union> Tags)\n  \\<subseteq> analz\n               (NI \\<union>\n                (extractable K I \\<union>\n                 {implConfid A B M |A B M.\n                  (A, B) \\<in> UNIV - broken K \\<and>\n                  M \\<in> payload} \\<union>\n                 {implSecure A B M |A B M.\n                  (A, B) \\<in> UNIV - broken K \\<and>\n                  M \\<in> payload}) \\<union>\n                K \\<union>\n                Tags)\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> I \\<union> K \\<union> Tags)\n    \\<subseteq> synth\n                 (analz\n                   (NI \\<union> extractable K I \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "also"], ["proof (state)\nthis:\n  analz (NI \\<union> I \\<union> K \\<union> Tags)\n  \\<subseteq> analz\n               (NI \\<union>\n                (extractable K I \\<union>\n                 {implConfid A B M |A B M.\n                  (A, B) \\<in> UNIV - broken K \\<and>\n                  M \\<in> payload} \\<union>\n                 {implSecure A B M |A B M.\n                  (A, B) \\<in> UNIV - broken K \\<and>\n                  M \\<in> payload}) \\<union>\n                K \\<union>\n                Tags)\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> I \\<union> K \\<union> Tags)\n    \\<subseteq> synth\n                 (analz\n                   (NI \\<union> extractable K I \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "have \"... \\<subseteq> analz (implConfidSet (UNIV - broken K) payload \\<union>\n                    (implSecureSet (UNIV - broken K) payload \\<union>\n                    (extractable K I \\<union> NI \\<union> K \\<union> Tags)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz\n     (NI \\<union>\n      (extractable K I \\<union>\n       {implConfid A B M |A B M.\n        (A, B) \\<in> UNIV - broken K \\<and> M \\<in> payload} \\<union>\n       {implSecure A B M |A B M.\n        (A, B) \\<in> UNIV - broken K \\<and> M \\<in> payload}) \\<union>\n      K \\<union>\n      Tags)\n    \\<subseteq> analz\n                 ({implConfid A B M |A B M.\n                   (A, B) \\<in> UNIV - broken K \\<and>\n                   M \\<in> payload} \\<union>\n                  ({implSecure A B M |A B M.\n                    (A, B) \\<in> UNIV - broken K \\<and>\n                    M \\<in> payload} \\<union>\n                   (extractable K I \\<union> NI \\<union> K \\<union> Tags)))", "by (auto)"], ["proof (state)\nthis:\n  analz\n   (NI \\<union>\n    (extractable K I \\<union>\n     {implConfid A B M |A B M.\n      (A, B) \\<in> UNIV - broken K \\<and> M \\<in> payload} \\<union>\n     {implSecure A B M |A B M.\n      (A, B) \\<in> UNIV - broken K \\<and> M \\<in> payload}) \\<union>\n    K \\<union>\n    Tags)\n  \\<subseteq> analz\n               ({implConfid A B M |A B M.\n                 (A, B) \\<in> UNIV - broken K \\<and>\n                 M \\<in> payload} \\<union>\n                ({implSecure A B M |A B M.\n                  (A, B) \\<in> UNIV - broken K \\<and>\n                  M \\<in> payload} \\<union>\n                 (extractable K I \\<union> NI \\<union> K \\<union> Tags)))\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> I \\<union> K \\<union> Tags)\n    \\<subseteq> synth\n                 (analz\n                   (NI \\<union> extractable K I \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "also"], ["proof (state)\nthis:\n  analz\n   (NI \\<union>\n    (extractable K I \\<union>\n     {implConfid A B M |A B M.\n      (A, B) \\<in> UNIV - broken K \\<and> M \\<in> payload} \\<union>\n     {implSecure A B M |A B M.\n      (A, B) \\<in> UNIV - broken K \\<and> M \\<in> payload}) \\<union>\n    K \\<union>\n    Tags)\n  \\<subseteq> analz\n               ({implConfid A B M |A B M.\n                 (A, B) \\<in> UNIV - broken K \\<and>\n                 M \\<in> payload} \\<union>\n                ({implSecure A B M |A B M.\n                  (A, B) \\<in> UNIV - broken K \\<and>\n                  M \\<in> payload} \\<union>\n                 (extractable K I \\<union> NI \\<union> K \\<union> Tags)))\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> I \\<union> K \\<union> Tags)\n    \\<subseteq> synth\n                 (analz\n                   (NI \\<union> extractable K I \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "have \"... \\<subseteq> synth (analz (implSecureSet (UNIV - broken K) payload \\<union>\n                  (extractable K I \\<union> NI \\<union> K \\<union> Tags))) \\<union> -payload\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz\n     ({implConfid A B M |A B M.\n       (A, B) \\<in> UNIV - broken K \\<and> M \\<in> payload} \\<union>\n      ({implSecure A B M |A B M.\n        (A, B) \\<in> UNIV - broken K \\<and> M \\<in> payload} \\<union>\n       (extractable K I \\<union> NI \\<union> K \\<union> Tags)))\n    \\<subseteq> synth\n                 (analz\n                   ({implSecure A B M |A B M.\n                     (A, B) \\<in> UNIV - broken K \\<and>\n                     M \\<in> payload} \\<union>\n                    (extractable K I \\<union> NI \\<union> K \\<union>\n                     Tags))) \\<union>\n                - payload", "proof (rule analz_Un_implConfidSet_2)"], ["proof (state)\ngoal (3 subgoals):\n 1. payload \\<subseteq> payload\n 2. Enc_keys_clean\n     ({implSecure A B M |A B M.\n       (A, B) \\<in> UNIV - broken K \\<and> M \\<in> payload} \\<union>\n      (extractable K I \\<union> NI \\<union> K \\<union> Tags))\n 3. (UNIV - broken K) \\<inter>\n    broken\n     (parts\n       ({implSecure A B M |A B M.\n         (A, B) \\<in> UNIV - broken K \\<and> M \\<in> payload} \\<union>\n        (extractable K I \\<union> NI \\<union> K \\<union> Tags)) \\<inter>\n      range LtK) =\n    {}", "show \"Enc_keys_clean (implSecureSet (UNIV - broken K) payload \n                              \\<union> (extractable K I \\<union> NI \\<union> K \\<union> Tags))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Enc_keys_clean\n     ({implSecure A B M |A B M.\n       (A, B) \\<in> UNIV - broken K \\<and> M \\<in> payload} \\<union>\n      (extractable K I \\<union> NI \\<union> K \\<union> Tags))", "by (auto simp add: HNI HI HK intro: validI)"], ["proof (state)\nthis:\n  Enc_keys_clean\n   ({implSecure A B M |A B M.\n     (A, B) \\<in> UNIV - broken K \\<and> M \\<in> payload} \\<union>\n    (extractable K I \\<union> NI \\<union> K \\<union> Tags))\n\ngoal (2 subgoals):\n 1. payload \\<subseteq> payload\n 2. (UNIV - broken K) \\<inter>\n    broken\n     (parts\n       ({implSecure A B M |A B M.\n         (A, B) \\<in> UNIV - broken K \\<and> M \\<in> payload} \\<union>\n        (extractable K I \\<union> NI \\<union> K \\<union> Tags)) \\<inter>\n      range LtK) =\n    {}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. payload \\<subseteq> payload\n 2. (UNIV - broken K) \\<inter>\n    broken\n     (parts\n       ({implSecure A B M |A B M.\n         (A, B) \\<in> UNIV - broken K \\<and> M \\<in> payload} \\<union>\n        (extractable K I \\<union> NI \\<union> K \\<union> Tags)) \\<inter>\n      range LtK) =\n    {}", "from HK HI HNI"], ["proof (chain)\npicking this:\n  K \\<subseteq> range LtK\n  I \\<subseteq> valid\n  NI \\<subseteq> payload", "show \"(UNIV - broken K) \\<inter> \n            broken (parts (\n              implSecureSet (UNIV - broken K) payload \\<union>\n              (extractable K I \\<union> NI \\<union> K \\<union> Tags)) \\<inter> range LtK)  = {}\""], ["proof (prove)\nusing this:\n  K \\<subseteq> range LtK\n  I \\<subseteq> valid\n  NI \\<subseteq> payload\n\ngoal (1 subgoal):\n 1. (UNIV - broken K) \\<inter>\n    broken\n     (parts\n       ({implSecure A B M |A B M.\n         (A, B) \\<in> UNIV - broken K \\<and> M \\<in> payload} \\<union>\n        (extractable K I \\<union> NI \\<union> K \\<union> Tags)) \\<inter>\n      range LtK) =\n    {}", "by (auto simp add: LtKeys_parts \n               LtKeys_parts_implSecureSet_elt [where Ag=\"- broken K\", simplified])"], ["proof (state)\nthis:\n  (UNIV - broken K) \\<inter>\n  broken\n   (parts\n     ({implSecure A B M |A B M.\n       (A, B) \\<in> UNIV - broken K \\<and> M \\<in> payload} \\<union>\n      (extractable K I \\<union> NI \\<union> K \\<union> Tags)) \\<inter>\n    range LtK) =\n  {}\n\ngoal (1 subgoal):\n 1. payload \\<subseteq> payload", "qed (auto)"], ["proof (state)\nthis:\n  analz\n   ({implConfid A B M |A B M.\n     (A, B) \\<in> UNIV - broken K \\<and> M \\<in> payload} \\<union>\n    ({implSecure A B M |A B M.\n      (A, B) \\<in> UNIV - broken K \\<and> M \\<in> payload} \\<union>\n     (extractable K I \\<union> NI \\<union> K \\<union> Tags)))\n  \\<subseteq> synth\n               (analz\n                 ({implSecure A B M |A B M.\n                   (A, B) \\<in> UNIV - broken K \\<and>\n                   M \\<in> payload} \\<union>\n                  (extractable K I \\<union> NI \\<union> K \\<union>\n                   Tags))) \\<union>\n              - payload\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> I \\<union> K \\<union> Tags)\n    \\<subseteq> synth\n                 (analz\n                   (NI \\<union> extractable K I \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "also"], ["proof (state)\nthis:\n  analz\n   ({implConfid A B M |A B M.\n     (A, B) \\<in> UNIV - broken K \\<and> M \\<in> payload} \\<union>\n    ({implSecure A B M |A B M.\n      (A, B) \\<in> UNIV - broken K \\<and> M \\<in> payload} \\<union>\n     (extractable K I \\<union> NI \\<union> K \\<union> Tags)))\n  \\<subseteq> synth\n               (analz\n                 ({implSecure A B M |A B M.\n                   (A, B) \\<in> UNIV - broken K \\<and>\n                   M \\<in> payload} \\<union>\n                  (extractable K I \\<union> NI \\<union> K \\<union>\n                   Tags))) \\<union>\n              - payload\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> I \\<union> K \\<union> Tags)\n    \\<subseteq> synth\n                 (analz\n                   (NI \\<union> extractable K I \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "have \"... \\<subseteq> synth (analz (extractable K I \\<union> NI \\<union> K \\<union> Tags)) \\<union> -payload\""], ["proof (prove)\ngoal (1 subgoal):\n 1. synth\n     (analz\n       ({implSecure A B M |A B M.\n         (A, B) \\<in> UNIV - broken K \\<and> M \\<in> payload} \\<union>\n        (extractable K I \\<union> NI \\<union> K \\<union> Tags))) \\<union>\n    - payload\n    \\<subseteq> synth\n                 (analz\n                   (extractable K I \\<union> NI \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "proof (rule Un_least, rule synth_idem_payload)"], ["proof (state)\ngoal (2 subgoals):\n 1. analz\n     ({implSecure A B M |A B M.\n       (A, B) \\<in> UNIV - broken K \\<and> M \\<in> payload} \\<union>\n      (extractable K I \\<union> NI \\<union> K \\<union> Tags))\n    \\<subseteq> synth\n                 (analz\n                   (extractable K I \\<union> NI \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload\n 2. - payload\n    \\<subseteq> synth\n                 (analz\n                   (extractable K I \\<union> NI \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "show \"analz (implSecureSet (UNIV - broken K) payload \\<union> \n                   (extractable K I \\<union> NI \\<union> K \\<union> Tags))\n            \\<subseteq> synth (analz (extractable K I \\<union> NI \\<union> K \\<union> Tags)) \\<union> -payload\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz\n     ({implSecure A B M |A B M.\n       (A, B) \\<in> UNIV - broken K \\<and> M \\<in> payload} \\<union>\n      (extractable K I \\<union> NI \\<union> K \\<union> Tags))\n    \\<subseteq> synth\n                 (analz\n                   (extractable K I \\<union> NI \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "proof (rule analz_Un_implSecureSet_2)"], ["proof (state)\ngoal (3 subgoals):\n 1. payload \\<subseteq> payload\n 2. Enc_keys_clean (extractable K I \\<union> NI \\<union> K \\<union> Tags)\n 3. (UNIV - broken K) \\<inter>\n    broken\n     (parts (extractable K I \\<union> NI \\<union> K \\<union> Tags) \\<inter>\n      range LtK) =\n    {}", "show \"Enc_keys_clean (extractable K I \\<union> NI \\<union> K \\<union> Tags)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Enc_keys_clean (extractable K I \\<union> NI \\<union> K \\<union> Tags)", "using HNI HK HI"], ["proof (prove)\nusing this:\n  NI \\<subseteq> payload\n  K \\<subseteq> range LtK\n  I \\<subseteq> valid\n\ngoal (1 subgoal):\n 1. Enc_keys_clean (extractable K I \\<union> NI \\<union> K \\<union> Tags)", "by auto"], ["proof (state)\nthis:\n  Enc_keys_clean (extractable K I \\<union> NI \\<union> K \\<union> Tags)\n\ngoal (2 subgoals):\n 1. payload \\<subseteq> payload\n 2. (UNIV - broken K) \\<inter>\n    broken\n     (parts (extractable K I \\<union> NI \\<union> K \\<union> Tags) \\<inter>\n      range LtK) =\n    {}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. payload \\<subseteq> payload\n 2. (UNIV - broken K) \\<inter>\n    broken\n     (parts (extractable K I \\<union> NI \\<union> K \\<union> Tags) \\<inter>\n      range LtK) =\n    {}", "from HI HK HNI"], ["proof (chain)\npicking this:\n  I \\<subseteq> valid\n  K \\<subseteq> range LtK\n  NI \\<subseteq> payload", "show \"(UNIV - broken K) \\<inter> \n                broken (parts (extractable K I \\<union> NI \\<union> K \\<union> Tags) \\<inter> range LtK) = {}\""], ["proof (prove)\nusing this:\n  I \\<subseteq> valid\n  K \\<subseteq> range LtK\n  NI \\<subseteq> payload\n\ngoal (1 subgoal):\n 1. (UNIV - broken K) \\<inter>\n    broken\n     (parts (extractable K I \\<union> NI \\<union> K \\<union> Tags) \\<inter>\n      range LtK) =\n    {}", "by (auto simp add: LtKeys_parts)"], ["proof (state)\nthis:\n  (UNIV - broken K) \\<inter>\n  broken\n   (parts (extractable K I \\<union> NI \\<union> K \\<union> Tags) \\<inter>\n    range LtK) =\n  {}\n\ngoal (1 subgoal):\n 1. payload \\<subseteq> payload", "qed (auto)"], ["proof (state)\nthis:\n  analz\n   ({implSecure A B M |A B M.\n     (A, B) \\<in> UNIV - broken K \\<and> M \\<in> payload} \\<union>\n    (extractable K I \\<union> NI \\<union> K \\<union> Tags))\n  \\<subseteq> synth\n               (analz\n                 (extractable K I \\<union> NI \\<union> K \\<union>\n                  Tags)) \\<union>\n              - payload\n\ngoal (1 subgoal):\n 1. - payload\n    \\<subseteq> synth\n                 (analz\n                   (extractable K I \\<union> NI \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. - payload\n    \\<subseteq> synth\n                 (analz\n                   (extractable K I \\<union> NI \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "show \"-payload \\<subseteq> synth (analz (extractable K I \\<union> NI \\<union> K \\<union> Tags)) \\<union> -payload\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - payload\n    \\<subseteq> synth\n                 (analz\n                   (extractable K I \\<union> NI \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "by auto"], ["proof (state)\nthis:\n  - payload\n  \\<subseteq> synth\n               (analz\n                 (extractable K I \\<union> NI \\<union> K \\<union>\n                  Tags)) \\<union>\n              - payload\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  synth\n   (analz\n     ({implSecure A B M |A B M.\n       (A, B) \\<in> UNIV - broken K \\<and> M \\<in> payload} \\<union>\n      (extractable K I \\<union> NI \\<union> K \\<union> Tags))) \\<union>\n  - payload\n  \\<subseteq> synth\n               (analz\n                 (extractable K I \\<union> NI \\<union> K \\<union>\n                  Tags)) \\<union>\n              - payload\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> I \\<union> K \\<union> Tags)\n    \\<subseteq> synth\n                 (analz\n                   (NI \\<union> extractable K I \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "also"], ["proof (state)\nthis:\n  synth\n   (analz\n     ({implSecure A B M |A B M.\n       (A, B) \\<in> UNIV - broken K \\<and> M \\<in> payload} \\<union>\n      (extractable K I \\<union> NI \\<union> K \\<union> Tags))) \\<union>\n  - payload\n  \\<subseteq> synth\n               (analz\n                 (extractable K I \\<union> NI \\<union> K \\<union>\n                  Tags)) \\<union>\n              - payload\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> I \\<union> K \\<union> Tags)\n    \\<subseteq> synth\n                 (analz\n                   (NI \\<union> extractable K I \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "have \"... \\<subseteq> synth (analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)) \\<union> -payload\""], ["proof (prove)\ngoal (1 subgoal):\n 1. synth\n     (analz (extractable K I \\<union> NI \\<union> K \\<union> Tags)) \\<union>\n    - payload\n    \\<subseteq> synth\n                 (analz\n                   (NI \\<union> extractable K I \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "by (simp add: sup.left_commute sup_commute)"], ["proof (state)\nthis:\n  synth\n   (analz (extractable K I \\<union> NI \\<union> K \\<union> Tags)) \\<union>\n  - payload\n  \\<subseteq> synth\n               (analz\n                 (NI \\<union> extractable K I \\<union> K \\<union>\n                  Tags)) \\<union>\n              - payload\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> I \\<union> K \\<union> Tags)\n    \\<subseteq> synth\n                 (analz\n                   (NI \\<union> extractable K I \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "finally"], ["proof (chain)\npicking this:\n  analz (NI \\<union> I \\<union> K \\<union> Tags)\n  \\<subseteq> synth\n               (analz\n                 (NI \\<union> extractable K I \\<union> K \\<union>\n                  Tags)) \\<union>\n              - payload", "show ?thesis"], ["proof (prove)\nusing this:\n  analz (NI \\<union> I \\<union> K \\<union> Tags)\n  \\<subseteq> synth\n               (analz\n                 (NI \\<union> extractable K I \\<union> K \\<union>\n                  Tags)) \\<union>\n              - payload\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> I \\<union> K \\<union> Tags)\n    \\<subseteq> synth\n                 (analz\n                   (NI \\<union> extractable K I \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "."], ["proof (state)\nthis:\n  analz (NI \\<union> I \\<union> K \\<union> Tags)\n  \\<subseteq> synth\n               (analz\n                 (NI \\<union> extractable K I \\<union> K \\<union>\n                  Tags)) \\<union>\n              - payload\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Only keep the extracted messages (instead of extractable)\\<close>"], ["", "(**************************************************************************************************)"], ["", "lemma analz_NI_EI_K_synth_analz_NI_E_K:\nassumes HNI: \"NI \\<subseteq> payload\"\n    and HK: \"K \\<subseteq> range LtK\"\n    and HI: \"I \\<subseteq> valid\"\n    and Hbad: \"Keys_bad K Bad\"\nshows \"analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)\n    \\<subseteq> synth (analz (extr Bad NI (abs I) \\<union> K \\<union> Tags)) \\<union> -payload\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "from HNI HI Hbad"], ["proof (chain)\npicking this:\n  NI \\<subseteq> payload\n  I \\<subseteq> valid\n  Keys_bad K Bad", "have \"analz (NI \\<union> extractable K I \\<union> K \\<union> Tags) \\<subseteq> \n        analz (NI \\<union> (implInsecSet (extr Bad NI (abs I)) \\<union>\n                     implConfidSet UNIV (extr Bad NI (abs I)) \\<union>\n                     implAuthSet (extr Bad NI (abs I)) \\<union>\n                     implSecureSet UNIV (extr Bad NI (abs I))) \\<union>\n                    K \\<union> Tags)\""], ["proof (prove)\nusing this:\n  NI \\<subseteq> payload\n  I \\<subseteq> valid\n  Keys_bad K Bad\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)\n    \\<subseteq> analz\n                 (NI \\<union>\n                  ({implInsec A B M |A B M.\n                    M \\<in> extr Bad NI (local.abs I)} \\<union>\n                   {implConfid A B M |A B M.\n                    (A, B) \\<in> UNIV \\<and>\n                    M \\<in> extr Bad NI (local.abs I)} \\<union>\n                   {implAuth A B M |A B M.\n                    M \\<in> extr Bad NI (local.abs I)} \\<union>\n                   {implSecure A B M |A B M.\n                    (A, B) \\<in> UNIV \\<and>\n                    M \\<in> extr Bad NI (local.abs I)}) \\<union>\n                  K \\<union>\n                  Tags)", "by (intro analz_mono Un_mono extractable_partition) (auto)"], ["proof (state)\nthis:\n  analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)\n  \\<subseteq> analz\n               (NI \\<union>\n                ({implInsec A B M |A B M.\n                  M \\<in> extr Bad NI (local.abs I)} \\<union>\n                 {implConfid A B M |A B M.\n                  (A, B) \\<in> UNIV \\<and>\n                  M \\<in> extr Bad NI (local.abs I)} \\<union>\n                 {implAuth A B M |A B M.\n                  M \\<in> extr Bad NI (local.abs I)} \\<union>\n                 {implSecure A B M |A B M.\n                  (A, B) \\<in> UNIV \\<and>\n                  M \\<in> extr Bad NI (local.abs I)}) \\<union>\n                K \\<union>\n                Tags)\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "also"], ["proof (state)\nthis:\n  analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)\n  \\<subseteq> analz\n               (NI \\<union>\n                ({implInsec A B M |A B M.\n                  M \\<in> extr Bad NI (local.abs I)} \\<union>\n                 {implConfid A B M |A B M.\n                  (A, B) \\<in> UNIV \\<and>\n                  M \\<in> extr Bad NI (local.abs I)} \\<union>\n                 {implAuth A B M |A B M.\n                  M \\<in> extr Bad NI (local.abs I)} \\<union>\n                 {implSecure A B M |A B M.\n                  (A, B) \\<in> UNIV \\<and>\n                  M \\<in> extr Bad NI (local.abs I)}) \\<union>\n                K \\<union>\n                Tags)\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "have \"... \\<subseteq> analz (implInsecSet (extr Bad NI (abs I)) \\<union>\n                     (implConfidSet UNIV (extr Bad NI (abs I)) \\<union>\n                     (implAuthSet (extr Bad NI (abs I)) \\<union>\n                     (implSecureSet UNIV (extr Bad NI (abs I)) \\<union>\n                     (NI \\<union> K \\<union> Tags)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz\n     (NI \\<union>\n      ({implInsec A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n       {implConfid A B M |A B M.\n        (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n       {implAuth A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n       {implSecure A B M |A B M.\n        (A, B) \\<in> UNIV \\<and>\n        M \\<in> extr Bad NI (local.abs I)}) \\<union>\n      K \\<union>\n      Tags)\n    \\<subseteq> analz\n                 ({implInsec A B M |A B M.\n                   M \\<in> extr Bad NI (local.abs I)} \\<union>\n                  ({implConfid A B M |A B M.\n                    (A, B) \\<in> UNIV \\<and>\n                    M \\<in> extr Bad NI (local.abs I)} \\<union>\n                   ({implAuth A B M |A B M.\n                     M \\<in> extr Bad NI (local.abs I)} \\<union>\n                    ({implSecure A B M |A B M.\n                      (A, B) \\<in> UNIV \\<and>\n                      M \\<in> extr Bad NI (local.abs I)} \\<union>\n                     (NI \\<union> K \\<union> Tags)))))", "by (auto)"], ["proof (state)\nthis:\n  analz\n   (NI \\<union>\n    ({implInsec A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n     {implConfid A B M |A B M.\n      (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n     {implAuth A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n     {implSecure A B M |A B M.\n      (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)}) \\<union>\n    K \\<union>\n    Tags)\n  \\<subseteq> analz\n               ({implInsec A B M |A B M.\n                 M \\<in> extr Bad NI (local.abs I)} \\<union>\n                ({implConfid A B M |A B M.\n                  (A, B) \\<in> UNIV \\<and>\n                  M \\<in> extr Bad NI (local.abs I)} \\<union>\n                 ({implAuth A B M |A B M.\n                   M \\<in> extr Bad NI (local.abs I)} \\<union>\n                  ({implSecure A B M |A B M.\n                    (A, B) \\<in> UNIV \\<and>\n                    M \\<in> extr Bad NI (local.abs I)} \\<union>\n                   (NI \\<union> K \\<union> Tags)))))\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "also"], ["proof (state)\nthis:\n  analz\n   (NI \\<union>\n    ({implInsec A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n     {implConfid A B M |A B M.\n      (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n     {implAuth A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n     {implSecure A B M |A B M.\n      (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)}) \\<union>\n    K \\<union>\n    Tags)\n  \\<subseteq> analz\n               ({implInsec A B M |A B M.\n                 M \\<in> extr Bad NI (local.abs I)} \\<union>\n                ({implConfid A B M |A B M.\n                  (A, B) \\<in> UNIV \\<and>\n                  M \\<in> extr Bad NI (local.abs I)} \\<union>\n                 ({implAuth A B M |A B M.\n                   M \\<in> extr Bad NI (local.abs I)} \\<union>\n                  ({implSecure A B M |A B M.\n                    (A, B) \\<in> UNIV \\<and>\n                    M \\<in> extr Bad NI (local.abs I)} \\<union>\n                   (NI \\<union> K \\<union> Tags)))))\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "have \"... \\<subseteq> synth (analz (extr Bad NI (abs I) \\<union>\n                   (implConfidSet UNIV (extr Bad NI (abs I)) \\<union>\n                   (implAuthSet (extr Bad NI (abs I)) \\<union>\n                   (implSecureSet UNIV (extr Bad NI (abs I)) \\<union> (NI \\<union> K \\<union> Tags)))))) \n                 \\<union> -payload\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz\n     ({implInsec A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n      ({implConfid A B M |A B M.\n        (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n       ({implAuth A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n        ({implSecure A B M |A B M.\n          (A, B) \\<in> UNIV \\<and>\n          M \\<in> extr Bad NI (local.abs I)} \\<union>\n         (NI \\<union> K \\<union> Tags)))))\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    ({implConfid A B M |A B M.\n                      (A, B) \\<in> UNIV \\<and>\n                      M \\<in> extr Bad NI (local.abs I)} \\<union>\n                     ({implAuth A B M |A B M.\n                       M \\<in> extr Bad NI (local.abs I)} \\<union>\n                      ({implSecure A B M |A B M.\n                        (A, B) \\<in> UNIV \\<and>\n                        M \\<in> extr Bad NI (local.abs I)} \\<union>\n                       (NI \\<union> K \\<union> Tags)))))) \\<union>\n                - payload", "by (rule analz_Un_implInsecSet)\n       (auto simp only: Un_commute [of \"extr _ _ _\" _] Un_assoc Un_absorb, \n        auto simp add: HNI HK HI intro!: validI)"], ["proof (state)\nthis:\n  analz\n   ({implInsec A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n    ({implConfid A B M |A B M.\n      (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n     ({implAuth A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n      ({implSecure A B M |A B M.\n        (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n       (NI \\<union> K \\<union> Tags)))))\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union>\n                  ({implConfid A B M |A B M.\n                    (A, B) \\<in> UNIV \\<and>\n                    M \\<in> extr Bad NI (local.abs I)} \\<union>\n                   ({implAuth A B M |A B M.\n                     M \\<in> extr Bad NI (local.abs I)} \\<union>\n                    ({implSecure A B M |A B M.\n                      (A, B) \\<in> UNIV \\<and>\n                      M \\<in> extr Bad NI (local.abs I)} \\<union>\n                     (NI \\<union> K \\<union> Tags)))))) \\<union>\n              - payload\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "also"], ["proof (state)\nthis:\n  analz\n   ({implInsec A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n    ({implConfid A B M |A B M.\n      (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n     ({implAuth A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n      ({implSecure A B M |A B M.\n        (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n       (NI \\<union> K \\<union> Tags)))))\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union>\n                  ({implConfid A B M |A B M.\n                    (A, B) \\<in> UNIV \\<and>\n                    M \\<in> extr Bad NI (local.abs I)} \\<union>\n                   ({implAuth A B M |A B M.\n                     M \\<in> extr Bad NI (local.abs I)} \\<union>\n                    ({implSecure A B M |A B M.\n                      (A, B) \\<in> UNIV \\<and>\n                      M \\<in> extr Bad NI (local.abs I)} \\<union>\n                     (NI \\<union> K \\<union> Tags)))))) \\<union>\n              - payload\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "have \"... \\<subseteq> synth (analz (extr Bad NI (abs I) \\<union>\n                   (implAuthSet (extr Bad NI (abs I)) \\<union>\n                   (implSecureSet UNIV (extr Bad NI (abs I)) \\<union> (NI \\<union> K \\<union> Tags))))) \n                 \\<union> -payload\""], ["proof (prove)\ngoal (1 subgoal):\n 1. synth\n     (analz\n       (extr Bad NI (local.abs I) \\<union>\n        ({implConfid A B M |A B M.\n          (A, B) \\<in> UNIV \\<and>\n          M \\<in> extr Bad NI (local.abs I)} \\<union>\n         ({implAuth A B M |A B M.\n           M \\<in> extr Bad NI (local.abs I)} \\<union>\n          ({implSecure A B M |A B M.\n            (A, B) \\<in> UNIV \\<and>\n            M \\<in> extr Bad NI (local.abs I)} \\<union>\n           (NI \\<union> K \\<union> Tags)))))) \\<union>\n    - payload\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    ({implAuth A B M |A B M.\n                      M \\<in> extr Bad NI (local.abs I)} \\<union>\n                     ({implSecure A B M |A B M.\n                       (A, B) \\<in> UNIV \\<and>\n                       M \\<in> extr Bad NI (local.abs I)} \\<union>\n                      (NI \\<union> K \\<union> Tags))))) \\<union>\n                - payload", "proof (rule Un_least, rule synth_idem_payload)"], ["proof (state)\ngoal (2 subgoals):\n 1. analz\n     (extr Bad NI (local.abs I) \\<union>\n      ({implConfid A B M |A B M.\n        (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n       ({implAuth A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n        ({implSecure A B M |A B M.\n          (A, B) \\<in> UNIV \\<and>\n          M \\<in> extr Bad NI (local.abs I)} \\<union>\n         (NI \\<union> K \\<union> Tags)))))\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    ({implAuth A B M |A B M.\n                      M \\<in> extr Bad NI (local.abs I)} \\<union>\n                     ({implSecure A B M |A B M.\n                       (A, B) \\<in> UNIV \\<and>\n                       M \\<in> extr Bad NI (local.abs I)} \\<union>\n                      (NI \\<union> K \\<union> Tags))))) \\<union>\n                - payload\n 2. - payload\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    ({implAuth A B M |A B M.\n                      M \\<in> extr Bad NI (local.abs I)} \\<union>\n                     ({implSecure A B M |A B M.\n                       (A, B) \\<in> UNIV \\<and>\n                       M \\<in> extr Bad NI (local.abs I)} \\<union>\n                      (NI \\<union> K \\<union> Tags))))) \\<union>\n                - payload", "have \"analz (implConfidSet UNIV (extr Bad NI (abs I)) \\<union>\n                   (implAuthSet (extr Bad NI (abs I)) \\<union>\n                   (implSecureSet UNIV (extr Bad NI (abs I)) \\<union> \n                   (NI \\<union> (K \\<union> extr Bad NI (abs I) \\<union> Tags)))))\n            \\<subseteq> synth (analz (extr Bad NI (abs I) \\<union>\n                           (implAuthSet (extr Bad NI (abs I)) \\<union>\n                           (implSecureSet UNIV (extr Bad NI (abs I)) \\<union> \n                           (NI \\<union> (K \\<union> extr Bad NI (abs I) \\<union> Tags)))))) \n              \\<union> -payload\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz\n     ({implConfid A B M |A B M.\n       (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n      ({implAuth A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n       ({implSecure A B M |A B M.\n         (A, B) \\<in> UNIV \\<and>\n         M \\<in> extr Bad NI (local.abs I)} \\<union>\n        (NI \\<union>\n         (K \\<union> extr Bad NI (local.abs I) \\<union> Tags)))))\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    ({implAuth A B M |A B M.\n                      M \\<in> extr Bad NI (local.abs I)} \\<union>\n                     ({implSecure A B M |A B M.\n                       (A, B) \\<in> UNIV \\<and>\n                       M \\<in> extr Bad NI (local.abs I)} \\<union>\n                      (NI \\<union>\n                       (K \\<union> extr Bad NI (local.abs I) \\<union>\n                        Tags)))))) \\<union>\n                - payload", "by (rule analz_Un_implConfidSet)\n           (auto simp only: Un_commute [of \"extr _ _ _\" _] Un_assoc Un_absorb,\n            auto simp add: HK HI HNI  intro!: validI)"], ["proof (state)\nthis:\n  analz\n   ({implConfid A B M |A B M.\n     (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n    ({implAuth A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n     ({implSecure A B M |A B M.\n       (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n      (NI \\<union> (K \\<union> extr Bad NI (local.abs I) \\<union> Tags)))))\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union>\n                  ({implAuth A B M |A B M.\n                    M \\<in> extr Bad NI (local.abs I)} \\<union>\n                   ({implSecure A B M |A B M.\n                     (A, B) \\<in> UNIV \\<and>\n                     M \\<in> extr Bad NI (local.abs I)} \\<union>\n                    (NI \\<union>\n                     (K \\<union> extr Bad NI (local.abs I) \\<union>\n                      Tags)))))) \\<union>\n              - payload\n\ngoal (2 subgoals):\n 1. analz\n     (extr Bad NI (local.abs I) \\<union>\n      ({implConfid A B M |A B M.\n        (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n       ({implAuth A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n        ({implSecure A B M |A B M.\n          (A, B) \\<in> UNIV \\<and>\n          M \\<in> extr Bad NI (local.abs I)} \\<union>\n         (NI \\<union> K \\<union> Tags)))))\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    ({implAuth A B M |A B M.\n                      M \\<in> extr Bad NI (local.abs I)} \\<union>\n                     ({implSecure A B M |A B M.\n                       (A, B) \\<in> UNIV \\<and>\n                       M \\<in> extr Bad NI (local.abs I)} \\<union>\n                      (NI \\<union> K \\<union> Tags))))) \\<union>\n                - payload\n 2. - payload\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    ({implAuth A B M |A B M.\n                      M \\<in> extr Bad NI (local.abs I)} \\<union>\n                     ({implSecure A B M |A B M.\n                       (A, B) \\<in> UNIV \\<and>\n                       M \\<in> extr Bad NI (local.abs I)} \\<union>\n                      (NI \\<union> K \\<union> Tags))))) \\<union>\n                - payload", "then"], ["proof (chain)\npicking this:\n  analz\n   ({implConfid A B M |A B M.\n     (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n    ({implAuth A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n     ({implSecure A B M |A B M.\n       (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n      (NI \\<union> (K \\<union> extr Bad NI (local.abs I) \\<union> Tags)))))\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union>\n                  ({implAuth A B M |A B M.\n                    M \\<in> extr Bad NI (local.abs I)} \\<union>\n                   ({implSecure A B M |A B M.\n                     (A, B) \\<in> UNIV \\<and>\n                     M \\<in> extr Bad NI (local.abs I)} \\<union>\n                    (NI \\<union>\n                     (K \\<union> extr Bad NI (local.abs I) \\<union>\n                      Tags)))))) \\<union>\n              - payload", "show \"analz (extr Bad NI (abs I) \\<union>\n                        (implConfidSet UNIV (extr Bad NI (abs I)) \\<union>\n                        (implAuthSet (extr Bad NI (abs I)) \\<union>\n                        (implSecureSet UNIV (extr Bad NI (abs I)) \\<union> (NI \\<union> K \\<union> Tags)))))\n                 \\<subseteq> synth (analz (extr Bad NI (abs I) \\<union>\n                         (implAuthSet (extr Bad NI (abs I)) \\<union>\n                         (implSecureSet UNIV (extr Bad NI (abs I)) \\<union> \n                         (NI \\<union> K \\<union> Tags))))) \n                   \\<union> -payload\""], ["proof (prove)\nusing this:\n  analz\n   ({implConfid A B M |A B M.\n     (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n    ({implAuth A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n     ({implSecure A B M |A B M.\n       (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n      (NI \\<union> (K \\<union> extr Bad NI (local.abs I) \\<union> Tags)))))\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union>\n                  ({implAuth A B M |A B M.\n                    M \\<in> extr Bad NI (local.abs I)} \\<union>\n                   ({implSecure A B M |A B M.\n                     (A, B) \\<in> UNIV \\<and>\n                     M \\<in> extr Bad NI (local.abs I)} \\<union>\n                    (NI \\<union>\n                     (K \\<union> extr Bad NI (local.abs I) \\<union>\n                      Tags)))))) \\<union>\n              - payload\n\ngoal (1 subgoal):\n 1. analz\n     (extr Bad NI (local.abs I) \\<union>\n      ({implConfid A B M |A B M.\n        (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n       ({implAuth A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n        ({implSecure A B M |A B M.\n          (A, B) \\<in> UNIV \\<and>\n          M \\<in> extr Bad NI (local.abs I)} \\<union>\n         (NI \\<union> K \\<union> Tags)))))\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    ({implAuth A B M |A B M.\n                      M \\<in> extr Bad NI (local.abs I)} \\<union>\n                     ({implSecure A B M |A B M.\n                       (A, B) \\<in> UNIV \\<and>\n                       M \\<in> extr Bad NI (local.abs I)} \\<union>\n                      (NI \\<union> K \\<union> Tags))))) \\<union>\n                - payload", "by (simp add: inf_sup_aci(6) inf_sup_aci(7))"], ["proof (state)\nthis:\n  analz\n   (extr Bad NI (local.abs I) \\<union>\n    ({implConfid A B M |A B M.\n      (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n     ({implAuth A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n      ({implSecure A B M |A B M.\n        (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n       (NI \\<union> K \\<union> Tags)))))\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union>\n                  ({implAuth A B M |A B M.\n                    M \\<in> extr Bad NI (local.abs I)} \\<union>\n                   ({implSecure A B M |A B M.\n                     (A, B) \\<in> UNIV \\<and>\n                     M \\<in> extr Bad NI (local.abs I)} \\<union>\n                    (NI \\<union> K \\<union> Tags))))) \\<union>\n              - payload\n\ngoal (1 subgoal):\n 1. - payload\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    ({implAuth A B M |A B M.\n                      M \\<in> extr Bad NI (local.abs I)} \\<union>\n                     ({implSecure A B M |A B M.\n                       (A, B) \\<in> UNIV \\<and>\n                       M \\<in> extr Bad NI (local.abs I)} \\<union>\n                      (NI \\<union> K \\<union> Tags))))) \\<union>\n                - payload", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. - payload\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    ({implAuth A B M |A B M.\n                      M \\<in> extr Bad NI (local.abs I)} \\<union>\n                     ({implSecure A B M |A B M.\n                       (A, B) \\<in> UNIV \\<and>\n                       M \\<in> extr Bad NI (local.abs I)} \\<union>\n                      (NI \\<union> K \\<union> Tags))))) \\<union>\n                - payload", "show \"-payload\n            \\<subseteq> synth (analz (extr Bad NI (abs I) \\<union>\n                           (implAuthSet (extr Bad NI (abs I)) \\<union>\n                           (implSecureSet UNIV (extr Bad NI (abs I)) \\<union> (NI \\<union> K \\<union> Tags))))) \n              \\<union> -payload\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - payload\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    ({implAuth A B M |A B M.\n                      M \\<in> extr Bad NI (local.abs I)} \\<union>\n                     ({implSecure A B M |A B M.\n                       (A, B) \\<in> UNIV \\<and>\n                       M \\<in> extr Bad NI (local.abs I)} \\<union>\n                      (NI \\<union> K \\<union> Tags))))) \\<union>\n                - payload", "by blast"], ["proof (state)\nthis:\n  - payload\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union>\n                  ({implAuth A B M |A B M.\n                    M \\<in> extr Bad NI (local.abs I)} \\<union>\n                   ({implSecure A B M |A B M.\n                     (A, B) \\<in> UNIV \\<and>\n                     M \\<in> extr Bad NI (local.abs I)} \\<union>\n                    (NI \\<union> K \\<union> Tags))))) \\<union>\n              - payload\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  synth\n   (analz\n     (extr Bad NI (local.abs I) \\<union>\n      ({implConfid A B M |A B M.\n        (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n       ({implAuth A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n        ({implSecure A B M |A B M.\n          (A, B) \\<in> UNIV \\<and>\n          M \\<in> extr Bad NI (local.abs I)} \\<union>\n         (NI \\<union> K \\<union> Tags)))))) \\<union>\n  - payload\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union>\n                  ({implAuth A B M |A B M.\n                    M \\<in> extr Bad NI (local.abs I)} \\<union>\n                   ({implSecure A B M |A B M.\n                     (A, B) \\<in> UNIV \\<and>\n                     M \\<in> extr Bad NI (local.abs I)} \\<union>\n                    (NI \\<union> K \\<union> Tags))))) \\<union>\n              - payload\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "also"], ["proof (state)\nthis:\n  synth\n   (analz\n     (extr Bad NI (local.abs I) \\<union>\n      ({implConfid A B M |A B M.\n        (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n       ({implAuth A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n        ({implSecure A B M |A B M.\n          (A, B) \\<in> UNIV \\<and>\n          M \\<in> extr Bad NI (local.abs I)} \\<union>\n         (NI \\<union> K \\<union> Tags)))))) \\<union>\n  - payload\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union>\n                  ({implAuth A B M |A B M.\n                    M \\<in> extr Bad NI (local.abs I)} \\<union>\n                   ({implSecure A B M |A B M.\n                     (A, B) \\<in> UNIV \\<and>\n                     M \\<in> extr Bad NI (local.abs I)} \\<union>\n                    (NI \\<union> K \\<union> Tags))))) \\<union>\n              - payload\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "have \"... \\<subseteq> synth (analz (extr Bad NI (abs I) \\<union>\n                   (implSecureSet UNIV (extr Bad NI (abs I)) \\<union> (NI \\<union> K \\<union> Tags)))) \n                 \\<union> -payload\""], ["proof (prove)\ngoal (1 subgoal):\n 1. synth\n     (analz\n       (extr Bad NI (local.abs I) \\<union>\n        ({implAuth A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n         ({implSecure A B M |A B M.\n           (A, B) \\<in> UNIV \\<and>\n           M \\<in> extr Bad NI (local.abs I)} \\<union>\n          (NI \\<union> K \\<union> Tags))))) \\<union>\n    - payload\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    ({implSecure A B M |A B M.\n                      (A, B) \\<in> UNIV \\<and>\n                      M \\<in> extr Bad NI (local.abs I)} \\<union>\n                     (NI \\<union> K \\<union> Tags)))) \\<union>\n                - payload", "proof (rule Un_least, rule synth_idem_payload)"], ["proof (state)\ngoal (2 subgoals):\n 1. analz\n     (extr Bad NI (local.abs I) \\<union>\n      ({implAuth A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n       ({implSecure A B M |A B M.\n         (A, B) \\<in> UNIV \\<and>\n         M \\<in> extr Bad NI (local.abs I)} \\<union>\n        (NI \\<union> K \\<union> Tags))))\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    ({implSecure A B M |A B M.\n                      (A, B) \\<in> UNIV \\<and>\n                      M \\<in> extr Bad NI (local.abs I)} \\<union>\n                     (NI \\<union> K \\<union> Tags)))) \\<union>\n                - payload\n 2. - payload\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    ({implSecure A B M |A B M.\n                      (A, B) \\<in> UNIV \\<and>\n                      M \\<in> extr Bad NI (local.abs I)} \\<union>\n                     (NI \\<union> K \\<union> Tags)))) \\<union>\n                - payload", "have \"analz (implAuthSet (extr Bad NI (abs I)) \\<union>\n                   (implSecureSet UNIV (extr Bad NI (abs I)) \\<union> \n                   (NI \\<union> (K \\<union> (extr Bad NI (abs I) \\<union> Tags)))))\n            \\<subseteq> synth (analz (extr Bad NI (abs I) \\<union>\n                           (implSecureSet UNIV (extr Bad NI (abs I)) \\<union> \n                           (NI \\<union> (K \\<union> (extr Bad NI (abs I) \\<union> Tags)))))) \n              \\<union> -payload\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz\n     ({implAuth A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n      ({implSecure A B M |A B M.\n        (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n       (NI \\<union>\n        (K \\<union> (extr Bad NI (local.abs I) \\<union> Tags)))))\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    ({implSecure A B M |A B M.\n                      (A, B) \\<in> UNIV \\<and>\n                      M \\<in> extr Bad NI (local.abs I)} \\<union>\n                     (NI \\<union>\n                      (K \\<union>\n                       (extr Bad NI (local.abs I) \\<union>\n                        Tags)))))) \\<union>\n                - payload", "by (rule analz_Un_implAuthSet)\n           (auto simp only: Un_commute [of \"extr _ _ _\" _] Un_assoc Un_absorb,\n            auto simp add: HI HNI HK intro!: validI)"], ["proof (state)\nthis:\n  analz\n   ({implAuth A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n    ({implSecure A B M |A B M.\n      (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n     (NI \\<union> (K \\<union> (extr Bad NI (local.abs I) \\<union> Tags)))))\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union>\n                  ({implSecure A B M |A B M.\n                    (A, B) \\<in> UNIV \\<and>\n                    M \\<in> extr Bad NI (local.abs I)} \\<union>\n                   (NI \\<union>\n                    (K \\<union>\n                     (extr Bad NI (local.abs I) \\<union> Tags)))))) \\<union>\n              - payload\n\ngoal (2 subgoals):\n 1. analz\n     (extr Bad NI (local.abs I) \\<union>\n      ({implAuth A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n       ({implSecure A B M |A B M.\n         (A, B) \\<in> UNIV \\<and>\n         M \\<in> extr Bad NI (local.abs I)} \\<union>\n        (NI \\<union> K \\<union> Tags))))\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    ({implSecure A B M |A B M.\n                      (A, B) \\<in> UNIV \\<and>\n                      M \\<in> extr Bad NI (local.abs I)} \\<union>\n                     (NI \\<union> K \\<union> Tags)))) \\<union>\n                - payload\n 2. - payload\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    ({implSecure A B M |A B M.\n                      (A, B) \\<in> UNIV \\<and>\n                      M \\<in> extr Bad NI (local.abs I)} \\<union>\n                     (NI \\<union> K \\<union> Tags)))) \\<union>\n                - payload", "then"], ["proof (chain)\npicking this:\n  analz\n   ({implAuth A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n    ({implSecure A B M |A B M.\n      (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n     (NI \\<union> (K \\<union> (extr Bad NI (local.abs I) \\<union> Tags)))))\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union>\n                  ({implSecure A B M |A B M.\n                    (A, B) \\<in> UNIV \\<and>\n                    M \\<in> extr Bad NI (local.abs I)} \\<union>\n                   (NI \\<union>\n                    (K \\<union>\n                     (extr Bad NI (local.abs I) \\<union> Tags)))))) \\<union>\n              - payload", "show \"analz (extr Bad NI (abs I) \\<union>\n                        (implAuthSet (extr Bad NI (abs I)) \\<union>\n                        (implSecureSet UNIV (extr Bad NI (abs I)) \\<union> (NI \\<union> K \\<union> Tags))))\n                 \\<subseteq> synth (analz (extr Bad NI (abs I) \\<union>\n                         (implSecureSet UNIV (extr Bad NI (abs I)) \\<union> \n                         (NI \\<union> K \\<union> Tags)))) \n                   \\<union> -payload\""], ["proof (prove)\nusing this:\n  analz\n   ({implAuth A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n    ({implSecure A B M |A B M.\n      (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n     (NI \\<union> (K \\<union> (extr Bad NI (local.abs I) \\<union> Tags)))))\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union>\n                  ({implSecure A B M |A B M.\n                    (A, B) \\<in> UNIV \\<and>\n                    M \\<in> extr Bad NI (local.abs I)} \\<union>\n                   (NI \\<union>\n                    (K \\<union>\n                     (extr Bad NI (local.abs I) \\<union> Tags)))))) \\<union>\n              - payload\n\ngoal (1 subgoal):\n 1. analz\n     (extr Bad NI (local.abs I) \\<union>\n      ({implAuth A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n       ({implSecure A B M |A B M.\n         (A, B) \\<in> UNIV \\<and>\n         M \\<in> extr Bad NI (local.abs I)} \\<union>\n        (NI \\<union> K \\<union> Tags))))\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    ({implSecure A B M |A B M.\n                      (A, B) \\<in> UNIV \\<and>\n                      M \\<in> extr Bad NI (local.abs I)} \\<union>\n                     (NI \\<union> K \\<union> Tags)))) \\<union>\n                - payload", "by (simp add: inf_sup_aci(6) inf_sup_aci(7))"], ["proof (state)\nthis:\n  analz\n   (extr Bad NI (local.abs I) \\<union>\n    ({implAuth A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n     ({implSecure A B M |A B M.\n       (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n      (NI \\<union> K \\<union> Tags))))\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union>\n                  ({implSecure A B M |A B M.\n                    (A, B) \\<in> UNIV \\<and>\n                    M \\<in> extr Bad NI (local.abs I)} \\<union>\n                   (NI \\<union> K \\<union> Tags)))) \\<union>\n              - payload\n\ngoal (1 subgoal):\n 1. - payload\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    ({implSecure A B M |A B M.\n                      (A, B) \\<in> UNIV \\<and>\n                      M \\<in> extr Bad NI (local.abs I)} \\<union>\n                     (NI \\<union> K \\<union> Tags)))) \\<union>\n                - payload", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. - payload\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    ({implSecure A B M |A B M.\n                      (A, B) \\<in> UNIV \\<and>\n                      M \\<in> extr Bad NI (local.abs I)} \\<union>\n                     (NI \\<union> K \\<union> Tags)))) \\<union>\n                - payload", "show \"-payload\n            \\<subseteq> synth (analz (extr Bad NI (abs I) \\<union>\n                           (implSecureSet UNIV (extr Bad NI (abs I)) \n                            \\<union> (NI \\<union> K \\<union> Tags))))  \n              \\<union> -payload\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - payload\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    ({implSecure A B M |A B M.\n                      (A, B) \\<in> UNIV \\<and>\n                      M \\<in> extr Bad NI (local.abs I)} \\<union>\n                     (NI \\<union> K \\<union> Tags)))) \\<union>\n                - payload", "by blast"], ["proof (state)\nthis:\n  - payload\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union>\n                  ({implSecure A B M |A B M.\n                    (A, B) \\<in> UNIV \\<and>\n                    M \\<in> extr Bad NI (local.abs I)} \\<union>\n                   (NI \\<union> K \\<union> Tags)))) \\<union>\n              - payload\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  synth\n   (analz\n     (extr Bad NI (local.abs I) \\<union>\n      ({implAuth A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n       ({implSecure A B M |A B M.\n         (A, B) \\<in> UNIV \\<and>\n         M \\<in> extr Bad NI (local.abs I)} \\<union>\n        (NI \\<union> K \\<union> Tags))))) \\<union>\n  - payload\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union>\n                  ({implSecure A B M |A B M.\n                    (A, B) \\<in> UNIV \\<and>\n                    M \\<in> extr Bad NI (local.abs I)} \\<union>\n                   (NI \\<union> K \\<union> Tags)))) \\<union>\n              - payload\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "also"], ["proof (state)\nthis:\n  synth\n   (analz\n     (extr Bad NI (local.abs I) \\<union>\n      ({implAuth A B M |A B M. M \\<in> extr Bad NI (local.abs I)} \\<union>\n       ({implSecure A B M |A B M.\n         (A, B) \\<in> UNIV \\<and>\n         M \\<in> extr Bad NI (local.abs I)} \\<union>\n        (NI \\<union> K \\<union> Tags))))) \\<union>\n  - payload\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union>\n                  ({implSecure A B M |A B M.\n                    (A, B) \\<in> UNIV \\<and>\n                    M \\<in> extr Bad NI (local.abs I)} \\<union>\n                   (NI \\<union> K \\<union> Tags)))) \\<union>\n              - payload\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "have \"... \\<subseteq> synth (analz (extr Bad NI (abs I) \\<union> (NI \\<union> K \\<union> Tags))) \n                 \\<union> -payload\""], ["proof (prove)\ngoal (1 subgoal):\n 1. synth\n     (analz\n       (extr Bad NI (local.abs I) \\<union>\n        ({implSecure A B M |A B M.\n          (A, B) \\<in> UNIV \\<and>\n          M \\<in> extr Bad NI (local.abs I)} \\<union>\n         (NI \\<union> K \\<union> Tags)))) \\<union>\n    - payload\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    (NI \\<union> K \\<union> Tags))) \\<union>\n                - payload", "proof (rule Un_least, rule synth_idem_payload)"], ["proof (state)\ngoal (2 subgoals):\n 1. analz\n     (extr Bad NI (local.abs I) \\<union>\n      ({implSecure A B M |A B M.\n        (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n       (NI \\<union> K \\<union> Tags)))\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    (NI \\<union> K \\<union> Tags))) \\<union>\n                - payload\n 2. - payload\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    (NI \\<union> K \\<union> Tags))) \\<union>\n                - payload", "have \"analz (implSecureSet UNIV (extr Bad NI (abs I)) \\<union> \n                   (NI \\<union> (K \\<union> (extr Bad NI (abs I) \\<union> Tags))))\n            \\<subseteq> synth (analz (extr Bad NI (abs I) \\<union>\n                           (NI \\<union> (K \\<union> (extr Bad NI (abs I) \\<union> Tags))))) \n               \\<union> -payload\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz\n     ({implSecure A B M |A B M.\n       (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n      (NI \\<union> (K \\<union> (extr Bad NI (local.abs I) \\<union> Tags))))\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    (NI \\<union>\n                     (K \\<union>\n                      (extr Bad NI (local.abs I) \\<union> Tags))))) \\<union>\n                - payload", "by (rule analz_Un_implSecureSet)\n           (auto simp only: Un_commute [of \"extr _ _ _\" _] Un_assoc Un_absorb,\n            auto simp add: HI HNI HK intro!: validI)"], ["proof (state)\nthis:\n  analz\n   ({implSecure A B M |A B M.\n     (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n    (NI \\<union> (K \\<union> (extr Bad NI (local.abs I) \\<union> Tags))))\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union>\n                  (NI \\<union>\n                   (K \\<union>\n                    (extr Bad NI (local.abs I) \\<union> Tags))))) \\<union>\n              - payload\n\ngoal (2 subgoals):\n 1. analz\n     (extr Bad NI (local.abs I) \\<union>\n      ({implSecure A B M |A B M.\n        (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n       (NI \\<union> K \\<union> Tags)))\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    (NI \\<union> K \\<union> Tags))) \\<union>\n                - payload\n 2. - payload\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    (NI \\<union> K \\<union> Tags))) \\<union>\n                - payload", "then"], ["proof (chain)\npicking this:\n  analz\n   ({implSecure A B M |A B M.\n     (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n    (NI \\<union> (K \\<union> (extr Bad NI (local.abs I) \\<union> Tags))))\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union>\n                  (NI \\<union>\n                   (K \\<union>\n                    (extr Bad NI (local.abs I) \\<union> Tags))))) \\<union>\n              - payload", "show \"analz (extr Bad NI (abs I) \\<union>\n                        (implSecureSet UNIV (extr Bad NI (abs I)) \\<union> (NI \\<union> K \\<union> Tags)))\n                 \\<subseteq> synth (analz (extr Bad NI (abs I) \\<union> (NI \\<union> K \\<union> Tags))) \n                   \\<union> -payload\""], ["proof (prove)\nusing this:\n  analz\n   ({implSecure A B M |A B M.\n     (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n    (NI \\<union> (K \\<union> (extr Bad NI (local.abs I) \\<union> Tags))))\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union>\n                  (NI \\<union>\n                   (K \\<union>\n                    (extr Bad NI (local.abs I) \\<union> Tags))))) \\<union>\n              - payload\n\ngoal (1 subgoal):\n 1. analz\n     (extr Bad NI (local.abs I) \\<union>\n      ({implSecure A B M |A B M.\n        (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n       (NI \\<union> K \\<union> Tags)))\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    (NI \\<union> K \\<union> Tags))) \\<union>\n                - payload", "by (simp add: inf_sup_aci(6) inf_sup_aci(7))"], ["proof (state)\nthis:\n  analz\n   (extr Bad NI (local.abs I) \\<union>\n    ({implSecure A B M |A B M.\n      (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n     (NI \\<union> K \\<union> Tags)))\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union>\n                  (NI \\<union> K \\<union> Tags))) \\<union>\n              - payload\n\ngoal (1 subgoal):\n 1. - payload\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    (NI \\<union> K \\<union> Tags))) \\<union>\n                - payload", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. - payload\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    (NI \\<union> K \\<union> Tags))) \\<union>\n                - payload", "show \"-payload\n            \\<subseteq> synth (analz (extr Bad NI (abs I)\\<union> (NI \\<union> K \\<union> Tags))) \n              \\<union> -payload\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - payload\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union>\n                    (NI \\<union> K \\<union> Tags))) \\<union>\n                - payload", "by blast"], ["proof (state)\nthis:\n  - payload\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union>\n                  (NI \\<union> K \\<union> Tags))) \\<union>\n              - payload\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  synth\n   (analz\n     (extr Bad NI (local.abs I) \\<union>\n      ({implSecure A B M |A B M.\n        (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n       (NI \\<union> K \\<union> Tags)))) \\<union>\n  - payload\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union>\n                  (NI \\<union> K \\<union> Tags))) \\<union>\n              - payload\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "also"], ["proof (state)\nthis:\n  synth\n   (analz\n     (extr Bad NI (local.abs I) \\<union>\n      ({implSecure A B M |A B M.\n        (A, B) \\<in> UNIV \\<and> M \\<in> extr Bad NI (local.abs I)} \\<union>\n       (NI \\<union> K \\<union> Tags)))) \\<union>\n  - payload\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union>\n                  (NI \\<union> K \\<union> Tags))) \\<union>\n              - payload\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "have \"... \\<subseteq> synth (analz (extr Bad NI (abs I) \\<union> K \\<union> Tags)) \\<union> -payload\""], ["proof (prove)\ngoal (1 subgoal):\n 1. synth\n     (analz\n       (extr Bad NI (local.abs I) \\<union>\n        (NI \\<union> K \\<union> Tags))) \\<union>\n    - payload\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "by (metis IK_subset_extr inf_sup_aci(6) set_eq_subset sup.absorb1)"], ["proof (state)\nthis:\n  synth\n   (analz\n     (extr Bad NI (local.abs I) \\<union>\n      (NI \\<union> K \\<union> Tags))) \\<union>\n  - payload\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union> K \\<union>\n                  Tags)) \\<union>\n              - payload\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "finally"], ["proof (chain)\npicking this:\n  analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union> K \\<union>\n                  Tags)) \\<union>\n              - payload", "show ?thesis"], ["proof (prove)\nusing this:\n  analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union> K \\<union>\n                  Tags)) \\<union>\n              - payload\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "."], ["proof (state)\nthis:\n  analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union> K \\<union>\n                  Tags)) \\<union>\n              - payload\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Keys and Tags can be moved out of the @{term \"analz\"}\\<close>"], ["", "lemma analz_LtKeys_Tag:\nassumes \"NI \\<subseteq> payload\" and \"K \\<subseteq> range LtK\"\nshows \"analz (NI \\<union> K \\<union> Tags) \\<subseteq> analz NI \\<union> K \\<union> Tags\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (NI \\<union> K \\<union> Tags)\n    \\<subseteq> analz NI \\<union> K \\<union> Tags", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> analz (NI \\<union> K \\<union> Tags) \\<Longrightarrow>\n       x \\<in> analz NI \\<union> K \\<union> Tags", "fix X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> analz (NI \\<union> K \\<union> Tags) \\<Longrightarrow>\n       x \\<in> analz NI \\<union> K \\<union> Tags", "assume H: \"X \\<in> analz (NI \\<union> K \\<union> Tags) \""], ["proof (state)\nthis:\n  X \\<in> analz (NI \\<union> K \\<union> Tags)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> analz (NI \\<union> K \\<union> Tags) \\<Longrightarrow>\n       x \\<in> analz NI \\<union> K \\<union> Tags", "thus \"X \\<in> analz NI \\<union> K \\<union> Tags\""], ["proof (prove)\nusing this:\n  X \\<in> analz (NI \\<union> K \\<union> Tags)\n\ngoal (1 subgoal):\n 1. X \\<in> analz NI \\<union> K \\<union> Tags", "proof (induction X rule: analz.induct)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>X.\n       X \\<in> NI \\<union> K \\<union> Tags \\<Longrightarrow>\n       X \\<in> analz NI \\<union> K \\<union> Tags\n 2. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 3. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> analz NI \\<union> K \\<union> Tags\n 4. \\<And>X Y.\n       \\<lbrakk>Enc X Y \\<in> analz (NI \\<union> K \\<union> Tags);\n        Enc X Y \\<in> analz NI \\<union> K \\<union> Tags;\n        Y \\<in> synth\n                 (analz (NI \\<union> K \\<union> Tags) \\<inter>\n                  {a. a \\<in> analz NI \\<union> K \\<union> Tags})\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 5. \\<And>X Y.\n       \\<lbrakk>Aenc X (pubK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Aenc X (pubK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        priK Y \\<in> analz (NI \\<union> K \\<union> Tags);\n        priK Y \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 6. \\<And>X Y.\n       \\<lbrakk>Aenc X (epubK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Aenc X (epubK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        epriK Y\n        \\<in> synth\n               (analz (NI \\<union> K \\<union> Tags) \\<inter>\n                {a. a \\<in> analz NI \\<union> K \\<union> Tags})\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 7. \\<And>X Y.\n       \\<lbrakk>Sign X (priK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Sign X (priK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        pubK Y \\<in> analz (NI \\<union> K \\<union> Tags);\n        pubK Y \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags", "case (Dec X Y)"], ["proof (state)\nthis:\n  Enc X Y \\<in> analz (NI \\<union> K \\<union> Tags)\n  Enc X Y \\<in> analz NI \\<union> K \\<union> Tags\n  Y \\<in> synth\n           (analz (NI \\<union> K \\<union> Tags) \\<inter>\n            {a. a \\<in> analz NI \\<union> K \\<union> Tags})\n\ngoal (7 subgoals):\n 1. \\<And>X.\n       X \\<in> NI \\<union> K \\<union> Tags \\<Longrightarrow>\n       X \\<in> analz NI \\<union> K \\<union> Tags\n 2. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 3. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> analz NI \\<union> K \\<union> Tags\n 4. \\<And>X Y.\n       \\<lbrakk>Enc X Y \\<in> analz (NI \\<union> K \\<union> Tags);\n        Enc X Y \\<in> analz NI \\<union> K \\<union> Tags;\n        Y \\<in> synth\n                 (analz (NI \\<union> K \\<union> Tags) \\<inter>\n                  {a. a \\<in> analz NI \\<union> K \\<union> Tags})\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 5. \\<And>X Y.\n       \\<lbrakk>Aenc X (pubK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Aenc X (pubK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        priK Y \\<in> analz (NI \\<union> K \\<union> Tags);\n        priK Y \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 6. \\<And>X Y.\n       \\<lbrakk>Aenc X (epubK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Aenc X (epubK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        epriK Y\n        \\<in> synth\n               (analz (NI \\<union> K \\<union> Tags) \\<inter>\n                {a. a \\<in> analz NI \\<union> K \\<union> Tags})\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 7. \\<And>X Y.\n       \\<lbrakk>Sign X (priK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Sign X (priK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        pubK Y \\<in> analz (NI \\<union> K \\<union> Tags);\n        pubK Y \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags", "hence \"Enc X Y \\<in> payload\""], ["proof (prove)\nusing this:\n  Enc X Y \\<in> analz (NI \\<union> K \\<union> Tags)\n  Enc X Y \\<in> analz NI \\<union> K \\<union> Tags\n  Y \\<in> synth\n           (analz (NI \\<union> K \\<union> Tags) \\<inter>\n            {a. a \\<in> analz NI \\<union> K \\<union> Tags})\n\ngoal (1 subgoal):\n 1. Enc X Y \\<in> payload", "using assms"], ["proof (prove)\nusing this:\n  Enc X Y \\<in> analz (NI \\<union> K \\<union> Tags)\n  Enc X Y \\<in> analz NI \\<union> K \\<union> Tags\n  Y \\<in> synth\n           (analz (NI \\<union> K \\<union> Tags) \\<inter>\n            {a. a \\<in> analz NI \\<union> K \\<union> Tags})\n  NI \\<subseteq> payload\n  K \\<subseteq> range LtK\n\ngoal (1 subgoal):\n 1. Enc X Y \\<in> payload", "by auto"], ["proof (state)\nthis:\n  Enc X Y \\<in> payload\n\ngoal (7 subgoals):\n 1. \\<And>X.\n       X \\<in> NI \\<union> K \\<union> Tags \\<Longrightarrow>\n       X \\<in> analz NI \\<union> K \\<union> Tags\n 2. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 3. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> analz NI \\<union> K \\<union> Tags\n 4. \\<And>X Y.\n       \\<lbrakk>Enc X Y \\<in> analz (NI \\<union> K \\<union> Tags);\n        Enc X Y \\<in> analz NI \\<union> K \\<union> Tags;\n        Y \\<in> synth\n                 (analz (NI \\<union> K \\<union> Tags) \\<inter>\n                  {a. a \\<in> analz NI \\<union> K \\<union> Tags})\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 5. \\<And>X Y.\n       \\<lbrakk>Aenc X (pubK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Aenc X (pubK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        priK Y \\<in> analz (NI \\<union> K \\<union> Tags);\n        priK Y \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 6. \\<And>X Y.\n       \\<lbrakk>Aenc X (epubK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Aenc X (epubK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        epriK Y\n        \\<in> synth\n               (analz (NI \\<union> K \\<union> Tags) \\<inter>\n                {a. a \\<in> analz NI \\<union> K \\<union> Tags})\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 7. \\<And>X Y.\n       \\<lbrakk>Sign X (priK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Sign X (priK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        pubK Y \\<in> analz (NI \\<union> K \\<union> Tags);\n        pubK Y \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags", "moreover"], ["proof (state)\nthis:\n  Enc X Y \\<in> payload\n\ngoal (7 subgoals):\n 1. \\<And>X.\n       X \\<in> NI \\<union> K \\<union> Tags \\<Longrightarrow>\n       X \\<in> analz NI \\<union> K \\<union> Tags\n 2. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 3. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> analz NI \\<union> K \\<union> Tags\n 4. \\<And>X Y.\n       \\<lbrakk>Enc X Y \\<in> analz (NI \\<union> K \\<union> Tags);\n        Enc X Y \\<in> analz NI \\<union> K \\<union> Tags;\n        Y \\<in> synth\n                 (analz (NI \\<union> K \\<union> Tags) \\<inter>\n                  {a. a \\<in> analz NI \\<union> K \\<union> Tags})\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 5. \\<And>X Y.\n       \\<lbrakk>Aenc X (pubK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Aenc X (pubK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        priK Y \\<in> analz (NI \\<union> K \\<union> Tags);\n        priK Y \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 6. \\<And>X Y.\n       \\<lbrakk>Aenc X (epubK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Aenc X (epubK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        epriK Y\n        \\<in> synth\n               (analz (NI \\<union> K \\<union> Tags) \\<inter>\n                {a. a \\<in> analz NI \\<union> K \\<union> Tags})\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 7. \\<And>X Y.\n       \\<lbrakk>Sign X (priK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Sign X (priK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        pubK Y \\<in> analz (NI \\<union> K \\<union> Tags);\n        pubK Y \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags", "from Dec.IH(2)"], ["proof (chain)\npicking this:\n  Y \\<in> synth\n           (analz (NI \\<union> K \\<union> Tags) \\<inter>\n            {a. a \\<in> analz NI \\<union> K \\<union> Tags})", "have \"Y \\<in> synth (analz NI \\<union> (K \\<union> Tags))\""], ["proof (prove)\nusing this:\n  Y \\<in> synth\n           (analz (NI \\<union> K \\<union> Tags) \\<inter>\n            {a. a \\<in> analz NI \\<union> K \\<union> Tags})\n\ngoal (1 subgoal):\n 1. Y \\<in> synth (analz NI \\<union> (K \\<union> Tags))", "by (auto simp add: Collect_disj_eq dest!: synth_Int2 )"], ["proof (state)\nthis:\n  Y \\<in> synth (analz NI \\<union> (K \\<union> Tags))\n\ngoal (7 subgoals):\n 1. \\<And>X.\n       X \\<in> NI \\<union> K \\<union> Tags \\<Longrightarrow>\n       X \\<in> analz NI \\<union> K \\<union> Tags\n 2. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 3. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> analz NI \\<union> K \\<union> Tags\n 4. \\<And>X Y.\n       \\<lbrakk>Enc X Y \\<in> analz (NI \\<union> K \\<union> Tags);\n        Enc X Y \\<in> analz NI \\<union> K \\<union> Tags;\n        Y \\<in> synth\n                 (analz (NI \\<union> K \\<union> Tags) \\<inter>\n                  {a. a \\<in> analz NI \\<union> K \\<union> Tags})\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 5. \\<And>X Y.\n       \\<lbrakk>Aenc X (pubK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Aenc X (pubK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        priK Y \\<in> analz (NI \\<union> K \\<union> Tags);\n        priK Y \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 6. \\<And>X Y.\n       \\<lbrakk>Aenc X (epubK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Aenc X (epubK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        epriK Y\n        \\<in> synth\n               (analz (NI \\<union> K \\<union> Tags) \\<inter>\n                {a. a \\<in> analz NI \\<union> K \\<union> Tags})\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 7. \\<And>X Y.\n       \\<lbrakk>Sign X (priK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Sign X (priK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        pubK Y \\<in> analz (NI \\<union> K \\<union> Tags);\n        pubK Y \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags", "ultimately"], ["proof (chain)\npicking this:\n  Enc X Y \\<in> payload\n  Y \\<in> synth (analz NI \\<union> (K \\<union> Tags))", "show ?case"], ["proof (prove)\nusing this:\n  Enc X Y \\<in> payload\n  Y \\<in> synth (analz NI \\<union> (K \\<union> Tags))\n\ngoal (1 subgoal):\n 1. X \\<in> analz NI \\<union> K \\<union> Tags", "using Dec.IH(1) assms(2)"], ["proof (prove)\nusing this:\n  Enc X Y \\<in> payload\n  Y \\<in> synth (analz NI \\<union> (K \\<union> Tags))\n  Enc X Y \\<in> analz NI \\<union> K \\<union> Tags\n  K \\<subseteq> range LtK\n\ngoal (1 subgoal):\n 1. X \\<in> analz NI \\<union> K \\<union> Tags", "by (auto dest!: synth_payload [THEN [2] rev_subsetD])"], ["proof (state)\nthis:\n  X \\<in> analz NI \\<union> K \\<union> Tags\n\ngoal (6 subgoals):\n 1. \\<And>X.\n       X \\<in> NI \\<union> K \\<union> Tags \\<Longrightarrow>\n       X \\<in> analz NI \\<union> K \\<union> Tags\n 2. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 3. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> analz NI \\<union> K \\<union> Tags\n 4. \\<And>X Y.\n       \\<lbrakk>Aenc X (pubK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Aenc X (pubK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        priK Y \\<in> analz (NI \\<union> K \\<union> Tags);\n        priK Y \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 5. \\<And>X Y.\n       \\<lbrakk>Aenc X (epubK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Aenc X (epubK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        epriK Y\n        \\<in> synth\n               (analz (NI \\<union> K \\<union> Tags) \\<inter>\n                {a. a \\<in> analz NI \\<union> K \\<union> Tags})\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 6. \\<And>X Y.\n       \\<lbrakk>Sign X (priK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Sign X (priK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        pubK Y \\<in> analz (NI \\<union> K \\<union> Tags);\n        pubK Y \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>X.\n       X \\<in> NI \\<union> K \\<union> Tags \\<Longrightarrow>\n       X \\<in> analz NI \\<union> K \\<union> Tags\n 2. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 3. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> analz NI \\<union> K \\<union> Tags\n 4. \\<And>X Y.\n       \\<lbrakk>Aenc X (pubK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Aenc X (pubK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        priK Y \\<in> analz (NI \\<union> K \\<union> Tags);\n        priK Y \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 5. \\<And>X Y.\n       \\<lbrakk>Aenc X (epubK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Aenc X (epubK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        epriK Y\n        \\<in> synth\n               (analz (NI \\<union> K \\<union> Tags) \\<inter>\n                {a. a \\<in> analz NI \\<union> K \\<union> Tags})\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 6. \\<And>X Y.\n       \\<lbrakk>Sign X (priK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Sign X (priK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        pubK Y \\<in> analz (NI \\<union> K \\<union> Tags);\n        pubK Y \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags", "case (Adec_lt X Y)"], ["proof (state)\nthis:\n  Aenc X (pubK Y) \\<in> analz (NI \\<union> K \\<union> Tags)\n  priK Y \\<in> analz (NI \\<union> K \\<union> Tags)\n  Aenc X (pubK Y) \\<in> analz NI \\<union> K \\<union> Tags\n  priK Y \\<in> analz NI \\<union> K \\<union> Tags\n\ngoal (6 subgoals):\n 1. \\<And>X.\n       X \\<in> NI \\<union> K \\<union> Tags \\<Longrightarrow>\n       X \\<in> analz NI \\<union> K \\<union> Tags\n 2. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 3. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> analz NI \\<union> K \\<union> Tags\n 4. \\<And>X Y.\n       \\<lbrakk>Aenc X (pubK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Aenc X (pubK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        priK Y \\<in> analz (NI \\<union> K \\<union> Tags);\n        priK Y \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 5. \\<And>X Y.\n       \\<lbrakk>Aenc X (epubK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Aenc X (epubK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        epriK Y\n        \\<in> synth\n               (analz (NI \\<union> K \\<union> Tags) \\<inter>\n                {a. a \\<in> analz NI \\<union> K \\<union> Tags})\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 6. \\<And>X Y.\n       \\<lbrakk>Sign X (priK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Sign X (priK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        pubK Y \\<in> analz (NI \\<union> K \\<union> Tags);\n        pubK Y \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags", "hence \"Aenc X (pubK Y) \\<in> payload \\<union> range LtK \\<union> Tags\""], ["proof (prove)\nusing this:\n  Aenc X (pubK Y) \\<in> analz (NI \\<union> K \\<union> Tags)\n  priK Y \\<in> analz (NI \\<union> K \\<union> Tags)\n  Aenc X (pubK Y) \\<in> analz NI \\<union> K \\<union> Tags\n  priK Y \\<in> analz NI \\<union> K \\<union> Tags\n\ngoal (1 subgoal):\n 1. Aenc X (pubK Y) \\<in> payload \\<union> range LtK \\<union> Tags", "using assms"], ["proof (prove)\nusing this:\n  Aenc X (pubK Y) \\<in> analz (NI \\<union> K \\<union> Tags)\n  priK Y \\<in> analz (NI \\<union> K \\<union> Tags)\n  Aenc X (pubK Y) \\<in> analz NI \\<union> K \\<union> Tags\n  priK Y \\<in> analz NI \\<union> K \\<union> Tags\n  NI \\<subseteq> payload\n  K \\<subseteq> range LtK\n\ngoal (1 subgoal):\n 1. Aenc X (pubK Y) \\<in> payload \\<union> range LtK \\<union> Tags", "by auto"], ["proof (state)\nthis:\n  Aenc X (pubK Y) \\<in> payload \\<union> range LtK \\<union> Tags\n\ngoal (6 subgoals):\n 1. \\<And>X.\n       X \\<in> NI \\<union> K \\<union> Tags \\<Longrightarrow>\n       X \\<in> analz NI \\<union> K \\<union> Tags\n 2. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 3. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> analz NI \\<union> K \\<union> Tags\n 4. \\<And>X Y.\n       \\<lbrakk>Aenc X (pubK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Aenc X (pubK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        priK Y \\<in> analz (NI \\<union> K \\<union> Tags);\n        priK Y \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 5. \\<And>X Y.\n       \\<lbrakk>Aenc X (epubK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Aenc X (epubK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        epriK Y\n        \\<in> synth\n               (analz (NI \\<union> K \\<union> Tags) \\<inter>\n                {a. a \\<in> analz NI \\<union> K \\<union> Tags})\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 6. \\<And>X Y.\n       \\<lbrakk>Sign X (priK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Sign X (priK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        pubK Y \\<in> analz (NI \\<union> K \\<union> Tags);\n        pubK Y \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags", "then"], ["proof (chain)\npicking this:\n  Aenc X (pubK Y) \\<in> payload \\<union> range LtK \\<union> Tags", "show ?case"], ["proof (prove)\nusing this:\n  Aenc X (pubK Y) \\<in> payload \\<union> range LtK \\<union> Tags\n\ngoal (1 subgoal):\n 1. X \\<in> analz NI \\<union> K \\<union> Tags", "by auto"], ["proof (state)\nthis:\n  X \\<in> analz NI \\<union> K \\<union> Tags\n\ngoal (5 subgoals):\n 1. \\<And>X.\n       X \\<in> NI \\<union> K \\<union> Tags \\<Longrightarrow>\n       X \\<in> analz NI \\<union> K \\<union> Tags\n 2. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 3. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> analz NI \\<union> K \\<union> Tags\n 4. \\<And>X Y.\n       \\<lbrakk>Aenc X (epubK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Aenc X (epubK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        epriK Y\n        \\<in> synth\n               (analz (NI \\<union> K \\<union> Tags) \\<inter>\n                {a. a \\<in> analz NI \\<union> K \\<union> Tags})\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 5. \\<And>X Y.\n       \\<lbrakk>Sign X (priK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Sign X (priK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        pubK Y \\<in> analz (NI \\<union> K \\<union> Tags);\n        pubK Y \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>X.\n       X \\<in> NI \\<union> K \\<union> Tags \\<Longrightarrow>\n       X \\<in> analz NI \\<union> K \\<union> Tags\n 2. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 3. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> analz NI \\<union> K \\<union> Tags\n 4. \\<And>X Y.\n       \\<lbrakk>Aenc X (epubK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Aenc X (epubK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        epriK Y\n        \\<in> synth\n               (analz (NI \\<union> K \\<union> Tags) \\<inter>\n                {a. a \\<in> analz NI \\<union> K \\<union> Tags})\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 5. \\<And>X Y.\n       \\<lbrakk>Sign X (priK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Sign X (priK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        pubK Y \\<in> analz (NI \\<union> K \\<union> Tags);\n        pubK Y \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags", "case (Sign_getmsg X Y)"], ["proof (state)\nthis:\n  Sign X (priK Y) \\<in> analz (NI \\<union> K \\<union> Tags)\n  pubK Y \\<in> analz (NI \\<union> K \\<union> Tags)\n  Sign X (priK Y) \\<in> analz NI \\<union> K \\<union> Tags\n  pubK Y \\<in> analz NI \\<union> K \\<union> Tags\n\ngoal (5 subgoals):\n 1. \\<And>X.\n       X \\<in> NI \\<union> K \\<union> Tags \\<Longrightarrow>\n       X \\<in> analz NI \\<union> K \\<union> Tags\n 2. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 3. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> analz NI \\<union> K \\<union> Tags\n 4. \\<And>X Y.\n       \\<lbrakk>Aenc X (epubK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Aenc X (epubK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        epriK Y\n        \\<in> synth\n               (analz (NI \\<union> K \\<union> Tags) \\<inter>\n                {a. a \\<in> analz NI \\<union> K \\<union> Tags})\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 5. \\<And>X Y.\n       \\<lbrakk>Sign X (priK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Sign X (priK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        pubK Y \\<in> analz (NI \\<union> K \\<union> Tags);\n        pubK Y \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags", "hence \"Sign X (priK Y) \\<in> payload \\<union> range LtK \\<union> Tags\""], ["proof (prove)\nusing this:\n  Sign X (priK Y) \\<in> analz (NI \\<union> K \\<union> Tags)\n  pubK Y \\<in> analz (NI \\<union> K \\<union> Tags)\n  Sign X (priK Y) \\<in> analz NI \\<union> K \\<union> Tags\n  pubK Y \\<in> analz NI \\<union> K \\<union> Tags\n\ngoal (1 subgoal):\n 1. Sign X (priK Y) \\<in> payload \\<union> range LtK \\<union> Tags", "using assms"], ["proof (prove)\nusing this:\n  Sign X (priK Y) \\<in> analz (NI \\<union> K \\<union> Tags)\n  pubK Y \\<in> analz (NI \\<union> K \\<union> Tags)\n  Sign X (priK Y) \\<in> analz NI \\<union> K \\<union> Tags\n  pubK Y \\<in> analz NI \\<union> K \\<union> Tags\n  NI \\<subseteq> payload\n  K \\<subseteq> range LtK\n\ngoal (1 subgoal):\n 1. Sign X (priK Y) \\<in> payload \\<union> range LtK \\<union> Tags", "by auto"], ["proof (state)\nthis:\n  Sign X (priK Y) \\<in> payload \\<union> range LtK \\<union> Tags\n\ngoal (5 subgoals):\n 1. \\<And>X.\n       X \\<in> NI \\<union> K \\<union> Tags \\<Longrightarrow>\n       X \\<in> analz NI \\<union> K \\<union> Tags\n 2. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 3. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> analz NI \\<union> K \\<union> Tags\n 4. \\<And>X Y.\n       \\<lbrakk>Aenc X (epubK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Aenc X (epubK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        epriK Y\n        \\<in> synth\n               (analz (NI \\<union> K \\<union> Tags) \\<inter>\n                {a. a \\<in> analz NI \\<union> K \\<union> Tags})\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 5. \\<And>X Y.\n       \\<lbrakk>Sign X (priK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Sign X (priK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        pubK Y \\<in> analz (NI \\<union> K \\<union> Tags);\n        pubK Y \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags", "then"], ["proof (chain)\npicking this:\n  Sign X (priK Y) \\<in> payload \\<union> range LtK \\<union> Tags", "show ?case"], ["proof (prove)\nusing this:\n  Sign X (priK Y) \\<in> payload \\<union> range LtK \\<union> Tags\n\ngoal (1 subgoal):\n 1. X \\<in> analz NI \\<union> K \\<union> Tags", "by auto"], ["proof (state)\nthis:\n  X \\<in> analz NI \\<union> K \\<union> Tags\n\ngoal (4 subgoals):\n 1. \\<And>X.\n       X \\<in> NI \\<union> K \\<union> Tags \\<Longrightarrow>\n       X \\<in> analz NI \\<union> K \\<union> Tags\n 2. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 3. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> analz NI \\<union> K \\<union> Tags\n 4. \\<And>X Y.\n       \\<lbrakk>Aenc X (epubK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Aenc X (epubK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        epriK Y\n        \\<in> synth\n               (analz (NI \\<union> K \\<union> Tags) \\<inter>\n                {a. a \\<in> analz NI \\<union> K \\<union> Tags})\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>X.\n       X \\<in> NI \\<union> K \\<union> Tags \\<Longrightarrow>\n       X \\<in> analz NI \\<union> K \\<union> Tags\n 2. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 3. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> analz NI \\<union> K \\<union> Tags\n 4. \\<And>X Y.\n       \\<lbrakk>Aenc X (epubK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Aenc X (epubK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        epriK Y\n        \\<in> synth\n               (analz (NI \\<union> K \\<union> Tags) \\<inter>\n                {a. a \\<in> analz NI \\<union> K \\<union> Tags})\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags", "case (Adec_eph X Y)"], ["proof (state)\nthis:\n  Aenc X (epubK Y) \\<in> analz (NI \\<union> K \\<union> Tags)\n  Aenc X (epubK Y) \\<in> analz NI \\<union> K \\<union> Tags\n  epriK Y\n  \\<in> synth\n         (analz (NI \\<union> K \\<union> Tags) \\<inter>\n          {a. a \\<in> analz NI \\<union> K \\<union> Tags})\n\ngoal (4 subgoals):\n 1. \\<And>X.\n       X \\<in> NI \\<union> K \\<union> Tags \\<Longrightarrow>\n       X \\<in> analz NI \\<union> K \\<union> Tags\n 2. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 3. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> analz NI \\<union> K \\<union> Tags\n 4. \\<And>X Y.\n       \\<lbrakk>Aenc X (epubK Y) \\<in> analz (NI \\<union> K \\<union> Tags);\n        Aenc X (epubK Y) \\<in> analz NI \\<union> K \\<union> Tags;\n        epriK Y\n        \\<in> synth\n               (analz (NI \\<union> K \\<union> Tags) \\<inter>\n                {a. a \\<in> analz NI \\<union> K \\<union> Tags})\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags", "then"], ["proof (chain)\npicking this:\n  Aenc X (epubK Y) \\<in> analz (NI \\<union> K \\<union> Tags)\n  Aenc X (epubK Y) \\<in> analz NI \\<union> K \\<union> Tags\n  epriK Y\n  \\<in> synth\n         (analz (NI \\<union> K \\<union> Tags) \\<inter>\n          {a. a \\<in> analz NI \\<union> K \\<union> Tags})", "show ?case"], ["proof (prove)\nusing this:\n  Aenc X (epubK Y) \\<in> analz (NI \\<union> K \\<union> Tags)\n  Aenc X (epubK Y) \\<in> analz NI \\<union> K \\<union> Tags\n  epriK Y\n  \\<in> synth\n         (analz (NI \\<union> K \\<union> Tags) \\<inter>\n          {a. a \\<in> analz NI \\<union> K \\<union> Tags})\n\ngoal (1 subgoal):\n 1. X \\<in> analz NI \\<union> K \\<union> Tags", "using assms"], ["proof (prove)\nusing this:\n  Aenc X (epubK Y) \\<in> analz (NI \\<union> K \\<union> Tags)\n  Aenc X (epubK Y) \\<in> analz NI \\<union> K \\<union> Tags\n  epriK Y\n  \\<in> synth\n         (analz (NI \\<union> K \\<union> Tags) \\<inter>\n          {a. a \\<in> analz NI \\<union> K \\<union> Tags})\n  NI \\<subseteq> payload\n  K \\<subseteq> range LtK\n\ngoal (1 subgoal):\n 1. X \\<in> analz NI \\<union> K \\<union> Tags", "by (auto dest!: EpriK_synth)"], ["proof (state)\nthis:\n  X \\<in> analz NI \\<union> K \\<union> Tags\n\ngoal (3 subgoals):\n 1. \\<And>X.\n       X \\<in> NI \\<union> K \\<union> Tags \\<Longrightarrow>\n       X \\<in> analz NI \\<union> K \\<union> Tags\n 2. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> X \\<in> analz NI \\<union> K \\<union> Tags\n 3. \\<And>X Y.\n       \\<lbrakk>\\<langle>X, Y\\<rangle>\n                \\<in> analz (NI \\<union> K \\<union> Tags);\n        \\<langle>X, Y\\<rangle>\n        \\<in> analz NI \\<union> K \\<union> Tags\\<rbrakk>\n       \\<Longrightarrow> Y \\<in> analz NI \\<union> K \\<union> Tags", "qed (insert assms, auto)"], ["proof (state)\nthis:\n  X \\<in> analz NI \\<union> K \\<union> Tags\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma analz_NI_E_K_analz_NI_E:\n  \"\\<lbrakk> NI \\<subseteq> payload; K \\<subseteq> range LtK; I \\<subseteq> valid \\<rbrakk> \n \\<Longrightarrow> analz (extr Bad NI (abs I) \\<union> K \\<union> Tags) \\<subseteq> analz (extr Bad NI (abs I)) \\<union> K \\<union> Tags\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>NI \\<subseteq> payload; K \\<subseteq> range LtK;\n     I \\<subseteq> valid\\<rbrakk>\n    \\<Longrightarrow> analz\n                       (extr Bad NI (local.abs I) \\<union> K \\<union> Tags)\n                      \\<subseteq> analz (extr Bad NI (local.abs I)) \\<union>\n                                  K \\<union>\n                                  Tags", "by (rule analz_LtKeys_Tag) auto"], ["", "subsubsection \\<open>Final lemmas, using all the previous ones\\<close>"], ["", "(**************************************************************************************************)"], ["", "lemma analz_NI_I_K_synth_analz_NI_E:\nassumes\n  Hbad: \"Keys_bad K Bad\" and \n  HNI: \"NI \\<subseteq> payload\" and \n  HK:  \"K \\<subseteq> range LtK\" and \n  HI: \"I \\<subseteq> valid\"\nshows \n  \"analz (NI \\<union> I \\<union> K \\<union> Tags) \\<subseteq> synth (analz (extr Bad NI (abs I))) \\<union> -payload\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (NI \\<union> I \\<union> K \\<union> Tags)\n    \\<subseteq> synth (analz (extr Bad NI (local.abs I))) \\<union> - payload", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. analz (NI \\<union> I \\<union> K \\<union> Tags)\n    \\<subseteq> synth (analz (extr Bad NI (local.abs I))) \\<union> - payload", "from HNI HK HI"], ["proof (chain)\npicking this:\n  NI \\<subseteq> payload\n  K \\<subseteq> range LtK\n  I \\<subseteq> valid", "have \"analz (NI \\<union> I \\<union> K \\<union> Tags) \\<subseteq>\n        synth (analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)) \\<union> -payload\""], ["proof (prove)\nusing this:\n  NI \\<subseteq> payload\n  K \\<subseteq> range LtK\n  I \\<subseteq> valid\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> I \\<union> K \\<union> Tags)\n    \\<subseteq> synth\n                 (analz\n                   (NI \\<union> extractable K I \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "by (rule analz_NI_I_K_analz_NI_EI)"], ["proof (state)\nthis:\n  analz (NI \\<union> I \\<union> K \\<union> Tags)\n  \\<subseteq> synth\n               (analz\n                 (NI \\<union> extractable K I \\<union> K \\<union>\n                  Tags)) \\<union>\n              - payload\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> I \\<union> K \\<union> Tags)\n    \\<subseteq> synth (analz (extr Bad NI (local.abs I))) \\<union> - payload", "also"], ["proof (state)\nthis:\n  analz (NI \\<union> I \\<union> K \\<union> Tags)\n  \\<subseteq> synth\n               (analz\n                 (NI \\<union> extractable K I \\<union> K \\<union>\n                  Tags)) \\<union>\n              - payload\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> I \\<union> K \\<union> Tags)\n    \\<subseteq> synth (analz (extr Bad NI (local.abs I))) \\<union> - payload", "have \"... \\<subseteq> synth (analz (extr Bad NI (abs I) \\<union> K \\<union> Tags)) \\<union> -payload\""], ["proof (prove)\ngoal (1 subgoal):\n 1. synth\n     (analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)) \\<union>\n    - payload\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "proof (rule Un_least, simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. synth (analz (NI \\<union> extractable K I \\<union> K \\<union> Tags))\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "from Hbad HNI HK HI"], ["proof (chain)\npicking this:\n  Keys_bad K Bad\n  NI \\<subseteq> payload\n  K \\<subseteq> range LtK\n  I \\<subseteq> valid", "have \"analz (NI \\<union> extractable K I \\<union> K \\<union> Tags) \\<subseteq>\n            synth (analz (extr Bad NI (abs I) \\<union> K \\<union> Tags)) \\<union> -payload\""], ["proof (prove)\nusing this:\n  Keys_bad K Bad\n  NI \\<subseteq> payload\n  K \\<subseteq> range LtK\n  I \\<subseteq> valid\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "by (intro analz_NI_EI_K_synth_analz_NI_E_K)"], ["proof (state)\nthis:\n  analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union> K \\<union>\n                  Tags)) \\<union>\n              - payload\n\ngoal (1 subgoal):\n 1. synth (analz (NI \\<union> extractable K I \\<union> K \\<union> Tags))\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "then"], ["proof (chain)\npicking this:\n  analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union> K \\<union>\n                  Tags)) \\<union>\n              - payload", "show \"synth (analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)) \\<subseteq>\n                 synth (analz (extr Bad NI (abs I) \\<union> K \\<union> Tags)) \\<union> -payload\""], ["proof (prove)\nusing this:\n  analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union> K \\<union>\n                  Tags)) \\<union>\n              - payload\n\ngoal (1 subgoal):\n 1. synth (analz (NI \\<union> extractable K I \\<union> K \\<union> Tags))\n    \\<subseteq> synth\n                 (analz\n                   (extr Bad NI (local.abs I) \\<union> K \\<union>\n                    Tags)) \\<union>\n                - payload", "by (rule synth_idem_payload)"], ["proof (state)\nthis:\n  synth (analz (NI \\<union> extractable K I \\<union> K \\<union> Tags))\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union> K \\<union>\n                  Tags)) \\<union>\n              - payload\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  synth\n   (analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)) \\<union>\n  - payload\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union> K \\<union>\n                  Tags)) \\<union>\n              - payload\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> I \\<union> K \\<union> Tags)\n    \\<subseteq> synth (analz (extr Bad NI (local.abs I))) \\<union> - payload", "also"], ["proof (state)\nthis:\n  synth\n   (analz (NI \\<union> extractable K I \\<union> K \\<union> Tags)) \\<union>\n  - payload\n  \\<subseteq> synth\n               (analz\n                 (extr Bad NI (local.abs I) \\<union> K \\<union>\n                  Tags)) \\<union>\n              - payload\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> I \\<union> K \\<union> Tags)\n    \\<subseteq> synth (analz (extr Bad NI (local.abs I))) \\<union> - payload", "have \"... \\<subseteq> synth (analz (extr Bad NI (abs I))) \\<union> -payload\""], ["proof (prove)\ngoal (1 subgoal):\n 1. synth\n     (analz (extr Bad NI (local.abs I) \\<union> K \\<union> Tags)) \\<union>\n    - payload\n    \\<subseteq> synth (analz (extr Bad NI (local.abs I))) \\<union> - payload", "proof (rule Un_least, simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. synth (analz (extr Bad NI (local.abs I) \\<union> K \\<union> Tags))\n    \\<subseteq> synth (analz (extr Bad NI (local.abs I))) \\<union> - payload", "from HNI HK HI"], ["proof (chain)\npicking this:\n  NI \\<subseteq> payload\n  K \\<subseteq> range LtK\n  I \\<subseteq> valid", "have \"analz (extr Bad NI (abs I) \\<union> K \\<union> Tags) \\<subseteq>\n                           analz (extr Bad NI (abs I)) \\<union> K \\<union> Tags\""], ["proof (prove)\nusing this:\n  NI \\<subseteq> payload\n  K \\<subseteq> range LtK\n  I \\<subseteq> valid\n\ngoal (1 subgoal):\n 1. analz (extr Bad NI (local.abs I) \\<union> K \\<union> Tags)\n    \\<subseteq> analz (extr Bad NI (local.abs I)) \\<union> K \\<union> Tags", "by (rule analz_NI_E_K_analz_NI_E)"], ["proof (state)\nthis:\n  analz (extr Bad NI (local.abs I) \\<union> K \\<union> Tags)\n  \\<subseteq> analz (extr Bad NI (local.abs I)) \\<union> K \\<union> Tags\n\ngoal (1 subgoal):\n 1. synth (analz (extr Bad NI (local.abs I) \\<union> K \\<union> Tags))\n    \\<subseteq> synth (analz (extr Bad NI (local.abs I))) \\<union> - payload", "also"], ["proof (state)\nthis:\n  analz (extr Bad NI (local.abs I) \\<union> K \\<union> Tags)\n  \\<subseteq> analz (extr Bad NI (local.abs I)) \\<union> K \\<union> Tags\n\ngoal (1 subgoal):\n 1. synth (analz (extr Bad NI (local.abs I) \\<union> K \\<union> Tags))\n    \\<subseteq> synth (analz (extr Bad NI (local.abs I))) \\<union> - payload", "from HK"], ["proof (chain)\npicking this:\n  K \\<subseteq> range LtK", "have \"... \\<subseteq> analz (extr Bad NI (abs I)) \\<union> -payload\""], ["proof (prove)\nusing this:\n  K \\<subseteq> range LtK\n\ngoal (1 subgoal):\n 1. analz (extr Bad NI (local.abs I)) \\<union> K \\<union> Tags\n    \\<subseteq> analz (extr Bad NI (local.abs I)) \\<union> - payload", "by auto"], ["proof (state)\nthis:\n  analz (extr Bad NI (local.abs I)) \\<union> K \\<union> Tags\n  \\<subseteq> analz (extr Bad NI (local.abs I)) \\<union> - payload\n\ngoal (1 subgoal):\n 1. synth (analz (extr Bad NI (local.abs I) \\<union> K \\<union> Tags))\n    \\<subseteq> synth (analz (extr Bad NI (local.abs I))) \\<union> - payload", "also"], ["proof (state)\nthis:\n  analz (extr Bad NI (local.abs I)) \\<union> K \\<union> Tags\n  \\<subseteq> analz (extr Bad NI (local.abs I)) \\<union> - payload\n\ngoal (1 subgoal):\n 1. synth (analz (extr Bad NI (local.abs I) \\<union> K \\<union> Tags))\n    \\<subseteq> synth (analz (extr Bad NI (local.abs I))) \\<union> - payload", "have \"... \\<subseteq> synth (analz (extr Bad NI (abs I))) \\<union> -payload\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz (extr Bad NI (local.abs I)) \\<union> - payload\n    \\<subseteq> synth (analz (extr Bad NI (local.abs I))) \\<union> - payload", "by auto"], ["proof (state)\nthis:\n  analz (extr Bad NI (local.abs I)) \\<union> - payload\n  \\<subseteq> synth (analz (extr Bad NI (local.abs I))) \\<union> - payload\n\ngoal (1 subgoal):\n 1. synth (analz (extr Bad NI (local.abs I) \\<union> K \\<union> Tags))\n    \\<subseteq> synth (analz (extr Bad NI (local.abs I))) \\<union> - payload", "finally"], ["proof (chain)\npicking this:\n  analz (extr Bad NI (local.abs I) \\<union> K \\<union> Tags)\n  \\<subseteq> synth (analz (extr Bad NI (local.abs I))) \\<union> - payload", "show \"synth (analz (extr Bad NI (abs I) \\<union> K \\<union> Tags)) \\<subseteq>\n                  synth (analz (extr Bad NI (abs I))) \\<union> -payload\""], ["proof (prove)\nusing this:\n  analz (extr Bad NI (local.abs I) \\<union> K \\<union> Tags)\n  \\<subseteq> synth (analz (extr Bad NI (local.abs I))) \\<union> - payload\n\ngoal (1 subgoal):\n 1. synth (analz (extr Bad NI (local.abs I) \\<union> K \\<union> Tags))\n    \\<subseteq> synth (analz (extr Bad NI (local.abs I))) \\<union> - payload", "by (rule synth_idem_payload)"], ["proof (state)\nthis:\n  synth (analz (extr Bad NI (local.abs I) \\<union> K \\<union> Tags))\n  \\<subseteq> synth (analz (extr Bad NI (local.abs I))) \\<union> - payload\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  synth\n   (analz (extr Bad NI (local.abs I) \\<union> K \\<union> Tags)) \\<union>\n  - payload\n  \\<subseteq> synth (analz (extr Bad NI (local.abs I))) \\<union> - payload\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> I \\<union> K \\<union> Tags)\n    \\<subseteq> synth (analz (extr Bad NI (local.abs I))) \\<union> - payload", "finally"], ["proof (chain)\npicking this:\n  analz (NI \\<union> I \\<union> K \\<union> Tags)\n  \\<subseteq> synth (analz (extr Bad NI (local.abs I))) \\<union> - payload", "show ?thesis"], ["proof (prove)\nusing this:\n  analz (NI \\<union> I \\<union> K \\<union> Tags)\n  \\<subseteq> synth (analz (extr Bad NI (local.abs I))) \\<union> - payload\n\ngoal (1 subgoal):\n 1. analz (NI \\<union> I \\<union> K \\<union> Tags)\n    \\<subseteq> synth (analz (extr Bad NI (local.abs I))) \\<union> - payload", "."], ["proof (state)\nthis:\n  analz (NI \\<union> I \\<union> K \\<union> Tags)\n  \\<subseteq> synth (analz (extr Bad NI (local.abs I))) \\<union> - payload\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Lemma actually used to prove the refinement.\\<close>"], ["", "lemma synth_analz_NI_I_K_synth_analz_NI_E:\n  \"\\<lbrakk> Keys_bad K Bad; NI \\<subseteq> payload; K \\<subseteq> range LtK; I \\<subseteq> valid\\<rbrakk>\n \\<Longrightarrow> synth (analz (NI \\<union> I \\<union> K \\<union> Tags)) \n   \\<subseteq> synth (analz (extr Bad NI (abs I))) \\<union> -payload\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Keys_bad K Bad; NI \\<subseteq> payload;\n     K \\<subseteq> range LtK; I \\<subseteq> valid\\<rbrakk>\n    \\<Longrightarrow> synth (analz (NI \\<union> I \\<union> K \\<union> Tags))\n                      \\<subseteq> synth\n                                   (analz\n                                     (extr Bad NI (local.abs I))) \\<union>\n                                  - payload", "by (intro synth_idem_payload analz_NI_I_K_synth_analz_NI_E) (assumption+)"], ["", "subsubsection \\<open>Partitioning @{term \"analz (ik)\"}\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>Two lemmas useful for proving the invariant\n  @{term [display] \"analz ik \\<subseteq> synth (analz (ik \\<inter> payload \\<union> ik \\<inter> valid \\<union> ik \\<inter> range LtK \\<union> Tags))\"}\n\\<close>"], ["", "lemma analz_Un_partition:\n  \"analz S \\<subseteq> synth (analz ((S \\<inter> payload) \\<union> (S \\<inter> valid) \\<union> (S \\<inter> range LtK) \\<union> Tags)) \\<Longrightarrow>\n  H \\<subseteq> payload \\<union> valid \\<union> range LtK \\<Longrightarrow>\n  analz (H \\<union> S) \\<subseteq>\n    synth (analz (((H \\<union> S) \\<inter> payload) \\<union> ((H \\<union> S) \\<inter> valid) \\<union> ((H \\<union> S) \\<inter> range LtK) \\<union> Tags))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>analz S\n             \\<subseteq> synth\n                          (analz\n                            (S \\<inter> payload \\<union>\n                             S \\<inter> valid \\<union>\n                             S \\<inter> range LtK \\<union>\n                             Tags));\n     H \\<subseteq> payload \\<union> valid \\<union> range LtK\\<rbrakk>\n    \\<Longrightarrow> analz (H \\<union> S)\n                      \\<subseteq> synth\n                                   (analz\n                                     ((H \\<union> S) \\<inter>\npayload \\<union>\n(H \\<union> S) \\<inter> valid \\<union>\n(H \\<union> S) \\<inter> range LtK \\<union>\nTags))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>analz S\n             \\<subseteq> synth\n                          (analz\n                            (S \\<inter> payload \\<union>\n                             S \\<inter> valid \\<union>\n                             S \\<inter> range LtK \\<union>\n                             Tags));\n     H \\<subseteq> payload \\<union> valid \\<union> range LtK\\<rbrakk>\n    \\<Longrightarrow> analz (H \\<union> S)\n                      \\<subseteq> synth\n                                   (analz\n                                     ((H \\<union> S) \\<inter>\npayload \\<union>\n(H \\<union> S) \\<inter> valid \\<union>\n(H \\<union> S) \\<inter> range LtK \\<union>\nTags))", "assume \"H \\<subseteq> payload \\<union> valid \\<union> range LtK\""], ["proof (state)\nthis:\n  H \\<subseteq> payload \\<union> valid \\<union> range LtK\n\ngoal (1 subgoal):\n 1. \\<lbrakk>analz S\n             \\<subseteq> synth\n                          (analz\n                            (S \\<inter> payload \\<union>\n                             S \\<inter> valid \\<union>\n                             S \\<inter> range LtK \\<union>\n                             Tags));\n     H \\<subseteq> payload \\<union> valid \\<union> range LtK\\<rbrakk>\n    \\<Longrightarrow> analz (H \\<union> S)\n                      \\<subseteq> synth\n                                   (analz\n                                     ((H \\<union> S) \\<inter>\npayload \\<union>\n(H \\<union> S) \\<inter> valid \\<union>\n(H \\<union> S) \\<inter> range LtK \\<union>\nTags))", "then"], ["proof (chain)\npicking this:\n  H \\<subseteq> payload \\<union> valid \\<union> range LtK", "have HH:\"H = (H \\<inter> payload) \\<union> (H \\<inter> valid) \\<union> (H \\<inter> range LtK)\""], ["proof (prove)\nusing this:\n  H \\<subseteq> payload \\<union> valid \\<union> range LtK\n\ngoal (1 subgoal):\n 1. H =\n    H \\<inter> payload \\<union> H \\<inter> valid \\<union>\n    H \\<inter> range LtK", "by auto"], ["proof (state)\nthis:\n  H =\n  H \\<inter> payload \\<union> H \\<inter> valid \\<union> H \\<inter> range LtK\n\ngoal (1 subgoal):\n 1. \\<lbrakk>analz S\n             \\<subseteq> synth\n                          (analz\n                            (S \\<inter> payload \\<union>\n                             S \\<inter> valid \\<union>\n                             S \\<inter> range LtK \\<union>\n                             Tags));\n     H \\<subseteq> payload \\<union> valid \\<union> range LtK\\<rbrakk>\n    \\<Longrightarrow> analz (H \\<union> S)\n                      \\<subseteq> synth\n                                   (analz\n                                     ((H \\<union> S) \\<inter>\npayload \\<union>\n(H \\<union> S) \\<inter> valid \\<union>\n(H \\<union> S) \\<inter> range LtK \\<union>\nTags))", "assume HA:\n    \"analz S \\<subseteq> synth (analz ((S \\<inter> payload) \\<union> (S \\<inter> valid) \\<union> (S \\<inter> range LtK) \\<union> Tags))\""], ["proof (state)\nthis:\n  analz S\n  \\<subseteq> synth\n               (analz\n                 (S \\<inter> payload \\<union> S \\<inter> valid \\<union>\n                  S \\<inter> range LtK \\<union>\n                  Tags))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>analz S\n             \\<subseteq> synth\n                          (analz\n                            (S \\<inter> payload \\<union>\n                             S \\<inter> valid \\<union>\n                             S \\<inter> range LtK \\<union>\n                             Tags));\n     H \\<subseteq> payload \\<union> valid \\<union> range LtK\\<rbrakk>\n    \\<Longrightarrow> analz (H \\<union> S)\n                      \\<subseteq> synth\n                                   (analz\n                                     ((H \\<union> S) \\<inter>\npayload \\<union>\n(H \\<union> S) \\<inter> valid \\<union>\n(H \\<union> S) \\<inter> range LtK \\<union>\nTags))", "then"], ["proof (chain)\npicking this:\n  analz S\n  \\<subseteq> synth\n               (analz\n                 (S \\<inter> payload \\<union> S \\<inter> valid \\<union>\n                  S \\<inter> range LtK \\<union>\n                  Tags))", "have \n   \"analz (H \\<union> S) \\<subseteq> \n    synth (analz (H \\<union> ((S \\<inter> payload) \\<union> (S \\<inter> valid) \\<union> (S \\<inter> range LtK) \\<union> Tags)))\""], ["proof (prove)\nusing this:\n  analz S\n  \\<subseteq> synth\n               (analz\n                 (S \\<inter> payload \\<union> S \\<inter> valid \\<union>\n                  S \\<inter> range LtK \\<union>\n                  Tags))\n\ngoal (1 subgoal):\n 1. analz (H \\<union> S)\n    \\<subseteq> synth\n                 (analz\n                   (H \\<union>\n                    (S \\<inter> payload \\<union> S \\<inter> valid \\<union>\n                     S \\<inter> range LtK \\<union>\n                     Tags)))", "by (rule analz_synth_subset_Un2)"], ["proof (state)\nthis:\n  analz (H \\<union> S)\n  \\<subseteq> synth\n               (analz\n                 (H \\<union>\n                  (S \\<inter> payload \\<union> S \\<inter> valid \\<union>\n                   S \\<inter> range LtK \\<union>\n                   Tags)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>analz S\n             \\<subseteq> synth\n                          (analz\n                            (S \\<inter> payload \\<union>\n                             S \\<inter> valid \\<union>\n                             S \\<inter> range LtK \\<union>\n                             Tags));\n     H \\<subseteq> payload \\<union> valid \\<union> range LtK\\<rbrakk>\n    \\<Longrightarrow> analz (H \\<union> S)\n                      \\<subseteq> synth\n                                   (analz\n                                     ((H \\<union> S) \\<inter>\npayload \\<union>\n(H \\<union> S) \\<inter> valid \\<union>\n(H \\<union> S) \\<inter> range LtK \\<union>\nTags))", "also"], ["proof (state)\nthis:\n  analz (H \\<union> S)\n  \\<subseteq> synth\n               (analz\n                 (H \\<union>\n                  (S \\<inter> payload \\<union> S \\<inter> valid \\<union>\n                   S \\<inter> range LtK \\<union>\n                   Tags)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>analz S\n             \\<subseteq> synth\n                          (analz\n                            (S \\<inter> payload \\<union>\n                             S \\<inter> valid \\<union>\n                             S \\<inter> range LtK \\<union>\n                             Tags));\n     H \\<subseteq> payload \\<union> valid \\<union> range LtK\\<rbrakk>\n    \\<Longrightarrow> analz (H \\<union> S)\n                      \\<subseteq> synth\n                                   (analz\n                                     ((H \\<union> S) \\<inter>\npayload \\<union>\n(H \\<union> S) \\<inter> valid \\<union>\n(H \\<union> S) \\<inter> range LtK \\<union>\nTags))", "with HH"], ["proof (chain)\npicking this:\n  H =\n  H \\<inter> payload \\<union> H \\<inter> valid \\<union> H \\<inter> range LtK\n  analz (H \\<union> S)\n  \\<subseteq> synth\n               (analz\n                 (H \\<union>\n                  (S \\<inter> payload \\<union> S \\<inter> valid \\<union>\n                   S \\<inter> range LtK \\<union>\n                   Tags)))", "have \n    \"... \\<subseteq> synth (analz (((H \\<inter> payload) \\<union> (H \\<inter> valid) \\<union> (H \\<inter> range LtK)) \\<union> \n                         ((S \\<inter> payload) \\<union> (S \\<inter> valid) \\<union> (S \\<inter> range LtK) \\<union> Tags)))\""], ["proof (prove)\nusing this:\n  H =\n  H \\<inter> payload \\<union> H \\<inter> valid \\<union> H \\<inter> range LtK\n  analz (H \\<union> S)\n  \\<subseteq> synth\n               (analz\n                 (H \\<union>\n                  (S \\<inter> payload \\<union> S \\<inter> valid \\<union>\n                   S \\<inter> range LtK \\<union>\n                   Tags)))\n\ngoal (1 subgoal):\n 1. synth\n     (analz\n       (H \\<union>\n        (S \\<inter> payload \\<union> S \\<inter> valid \\<union>\n         S \\<inter> range LtK \\<union>\n         Tags)))\n    \\<subseteq> synth\n                 (analz\n                   (H \\<inter> payload \\<union> H \\<inter> valid \\<union>\n                    H \\<inter> range LtK \\<union>\n                    (S \\<inter> payload \\<union> S \\<inter> valid \\<union>\n                     S \\<inter> range LtK \\<union>\n                     Tags)))", "by auto"], ["proof (state)\nthis:\n  synth\n   (analz\n     (H \\<union>\n      (S \\<inter> payload \\<union> S \\<inter> valid \\<union>\n       S \\<inter> range LtK \\<union>\n       Tags)))\n  \\<subseteq> synth\n               (analz\n                 (H \\<inter> payload \\<union> H \\<inter> valid \\<union>\n                  H \\<inter> range LtK \\<union>\n                  (S \\<inter> payload \\<union> S \\<inter> valid \\<union>\n                   S \\<inter> range LtK \\<union>\n                   Tags)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>analz S\n             \\<subseteq> synth\n                          (analz\n                            (S \\<inter> payload \\<union>\n                             S \\<inter> valid \\<union>\n                             S \\<inter> range LtK \\<union>\n                             Tags));\n     H \\<subseteq> payload \\<union> valid \\<union> range LtK\\<rbrakk>\n    \\<Longrightarrow> analz (H \\<union> S)\n                      \\<subseteq> synth\n                                   (analz\n                                     ((H \\<union> S) \\<inter>\npayload \\<union>\n(H \\<union> S) \\<inter> valid \\<union>\n(H \\<union> S) \\<inter> range LtK \\<union>\nTags))", "also"], ["proof (state)\nthis:\n  synth\n   (analz\n     (H \\<union>\n      (S \\<inter> payload \\<union> S \\<inter> valid \\<union>\n       S \\<inter> range LtK \\<union>\n       Tags)))\n  \\<subseteq> synth\n               (analz\n                 (H \\<inter> payload \\<union> H \\<inter> valid \\<union>\n                  H \\<inter> range LtK \\<union>\n                  (S \\<inter> payload \\<union> S \\<inter> valid \\<union>\n                   S \\<inter> range LtK \\<union>\n                   Tags)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>analz S\n             \\<subseteq> synth\n                          (analz\n                            (S \\<inter> payload \\<union>\n                             S \\<inter> valid \\<union>\n                             S \\<inter> range LtK \\<union>\n                             Tags));\n     H \\<subseteq> payload \\<union> valid \\<union> range LtK\\<rbrakk>\n    \\<Longrightarrow> analz (H \\<union> S)\n                      \\<subseteq> synth\n                                   (analz\n                                     ((H \\<union> S) \\<inter>\npayload \\<union>\n(H \\<union> S) \\<inter> valid \\<union>\n(H \\<union> S) \\<inter> range LtK \\<union>\nTags))", "have \"... = synth (analz (((H \\<union> S) \\<inter> payload) \\<union> ((H \\<union> S) \\<inter> valid) \\<union> \n                                 ((H \\<union> S) \\<inter> range LtK) \\<union> Tags))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. synth\n     (analz\n       (H \\<inter> payload \\<union> H \\<inter> valid \\<union>\n        H \\<inter> range LtK \\<union>\n        (S \\<inter> payload \\<union> S \\<inter> valid \\<union>\n         S \\<inter> range LtK \\<union>\n         Tags))) =\n    synth\n     (analz\n       ((H \\<union> S) \\<inter> payload \\<union>\n        (H \\<union> S) \\<inter> valid \\<union>\n        (H \\<union> S) \\<inter> range LtK \\<union>\n        Tags))", "by (simp add: Un_left_commute sup.commute Int_Un_distrib2)"], ["proof (state)\nthis:\n  synth\n   (analz\n     (H \\<inter> payload \\<union> H \\<inter> valid \\<union>\n      H \\<inter> range LtK \\<union>\n      (S \\<inter> payload \\<union> S \\<inter> valid \\<union>\n       S \\<inter> range LtK \\<union>\n       Tags))) =\n  synth\n   (analz\n     ((H \\<union> S) \\<inter> payload \\<union>\n      (H \\<union> S) \\<inter> valid \\<union>\n      (H \\<union> S) \\<inter> range LtK \\<union>\n      Tags))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>analz S\n             \\<subseteq> synth\n                          (analz\n                            (S \\<inter> payload \\<union>\n                             S \\<inter> valid \\<union>\n                             S \\<inter> range LtK \\<union>\n                             Tags));\n     H \\<subseteq> payload \\<union> valid \\<union> range LtK\\<rbrakk>\n    \\<Longrightarrow> analz (H \\<union> S)\n                      \\<subseteq> synth\n                                   (analz\n                                     ((H \\<union> S) \\<inter>\npayload \\<union>\n(H \\<union> S) \\<inter> valid \\<union>\n(H \\<union> S) \\<inter> range LtK \\<union>\nTags))", "finally"], ["proof (chain)\npicking this:\n  analz (H \\<union> S)\n  \\<subseteq> synth\n               (analz\n                 ((H \\<union> S) \\<inter> payload \\<union>\n                  (H \\<union> S) \\<inter> valid \\<union>\n                  (H \\<union> S) \\<inter> range LtK \\<union>\n                  Tags))", "show ?thesis"], ["proof (prove)\nusing this:\n  analz (H \\<union> S)\n  \\<subseteq> synth\n               (analz\n                 ((H \\<union> S) \\<inter> payload \\<union>\n                  (H \\<union> S) \\<inter> valid \\<union>\n                  (H \\<union> S) \\<inter> range LtK \\<union>\n                  Tags))\n\ngoal (1 subgoal):\n 1. analz (H \\<union> S)\n    \\<subseteq> synth\n                 (analz\n                   ((H \\<union> S) \\<inter> payload \\<union>\n                    (H \\<union> S) \\<inter> valid \\<union>\n                    (H \\<union> S) \\<inter> range LtK \\<union>\n                    Tags))", "."], ["proof (state)\nthis:\n  analz (H \\<union> S)\n  \\<subseteq> synth\n               (analz\n                 ((H \\<union> S) \\<inter> payload \\<union>\n                  (H \\<union> S) \\<inter> valid \\<union>\n                  (H \\<union> S) \\<inter> range LtK \\<union>\n                  Tags))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma analz_insert_partition:\n  \"analz S \\<subseteq> synth (analz ((S \\<inter> payload) \\<union> (S \\<inter> valid) \\<union> (S \\<inter> range LtK) \\<union> Tags)) \\<Longrightarrow>\n  x \\<in> payload \\<union> valid \\<union> range LtK \\<Longrightarrow>\n  analz (insert x S) \\<subseteq>\n    synth (analz (((insert x S) \\<inter> payload) \\<union> ((insert x S) \\<inter> valid) \\<union> \n                  ((insert x S) \\<inter> range LtK) \\<union> Tags))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>analz S\n             \\<subseteq> synth\n                          (analz\n                            (S \\<inter> payload \\<union>\n                             S \\<inter> valid \\<union>\n                             S \\<inter> range LtK \\<union>\n                             Tags));\n     x \\<in> payload \\<union> valid \\<union> range LtK\\<rbrakk>\n    \\<Longrightarrow> analz (insert x S)\n                      \\<subseteq> synth\n                                   (analz\n                                     (insert x S \\<inter> payload \\<union>\ninsert x S \\<inter> valid \\<union>\ninsert x S \\<inter> range LtK \\<union>\nTags))", "by (simp only: insert_is_Un [of x S], erule analz_Un_partition, auto)"], ["", "end"], ["", "end"]]}