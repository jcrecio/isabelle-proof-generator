{"file_name": "/home/qj213/afp-2021-10-22/thys/Key_Agreement_Strong_Adversaries/Channels.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Key_Agreement_Strong_Adversaries", "problem_names": ["lemma extr_empty_chan [simp]: \"extr bad IK {} = IK\"", "lemma IK_subset_extr: \"IK \\<subseteq> extr bad IK chan\"", "lemma extr_mono_chan [dest]: \"G \\<subseteq> H \\<Longrightarrow> extr bad IK G \\<subseteq> extr bad IK H\"", "lemma extr_mono_IK [dest]: \"IK1 \\<subseteq> IK2 \\<Longrightarrow> extr bad IK1 H \\<subseteq> extr bad IK2 H\"", "lemma extr_mono_bad [dest]: \"bad \\<subseteq> bad' \\<Longrightarrow> extr bad IK H \\<subseteq> extr bad' IK H\"", "lemmas extr_monotone_chan [elim] = extr_mono_chan [THEN [2] rev_subsetD]", "lemmas extr_monotone_IK [elim] = extr_mono_IK [THEN [2] rev_subsetD]", "lemmas extr_monotone_bad [elim] = extr_mono_bad [THEN [2] rev_subsetD]", "lemma extr_mono [intro]: \"\\<lbrakk> b \\<subseteq> b'; I \\<subseteq> I'; C \\<subseteq> C' \\<rbrakk> \\<Longrightarrow> extr b I C \\<subseteq> extr b' I' C'\"", "lemmas extr_monotone [elim] = extr_mono [THEN [2] rev_subsetD]", "lemma extr_insert [intro]: \"M \\<in> extr bad IK H \\<Longrightarrow> M \\<in> extr bad IK (insert C H)\"", "lemma extr_insert_Chan [simp]: \n  \"extr bad IK (insert (Chan c A B M) H) \n   = (if c = insec \\<or> c = auth \\<or> A \\<in> bad \\<or> B \\<in> bad \n      then insert M (extr bad IK H) else extr bad IK H)\"", "lemma extr_insert_chan_eq: \"extr bad IK (insert X CH) = extr bad IK {X} \\<union> extr bad IK CH\"", "lemma extr_insert_IK_eq [simp]: \"extr bad (insert X IK) CH = insert X (extr bad IK CH)\"", "lemma extr_insert_bad:\n  \"extr (insert A bad) IK CH \\<subseteq>\n   extr bad IK CH \\<union> {M. \\<exists> B. Confid A B M \\<in> CH \\<or> Confid B A M \\<in> CH \\<or>\n                             Secure A B M \\<in> CH \\<or> Secure B A M \\<in> CH}\"", "lemma extr_insert_Confid [simp]:\n  \"A \\<notin> bad \\<Longrightarrow>\n   B \\<notin> bad \\<Longrightarrow> \n   extr bad IK (insert (Confid A B X) CH) = extr bad IK CH\"", "lemmas fake_intros = fake_Inj fake_New", "lemma fake_mono_bad [intro]: \n  \"bad \\<subseteq> bad' \\<Longrightarrow> fake bad IK chan \\<subseteq> fake bad' IK chan\"", "lemma fake_mono_ik [intro]: \n  \"IK \\<subseteq> IK' \\<Longrightarrow> fake bad IK chan \\<subseteq> fake bad IK' chan\"", "lemma fake_mono_chan [intro]: \n  \"chan \\<subseteq> chan' \\<Longrightarrow> fake bad IK chan \\<subseteq> fake bad IK chan'\"", "lemma fake_mono [intro]: \n  \"\\<lbrakk> bad \\<subseteq> bad'; IK \\<subseteq> IK'; chan \\<subseteq> chan'\\<rbrakk> \\<Longrightarrow> fake bad IK chan \\<subseteq> fake bad' IK' chan'\"", "lemmas fake_monotone_bad [elim] = fake_mono_bad [THEN [2] rev_subsetD]", "lemmas fake_monotone_ik [elim] = fake_mono_ik [THEN [2] rev_subsetD]", "lemmas fake_monotone_chan [elim] = fake_mono_chan [THEN [2] rev_subsetD]", "lemmas fake_monotone [elim] = fake_mono [THEN [2] rev_subsetD]", "lemma chan_subset_fake: \"chan \\<subseteq> fake bad IK chan\"", "lemma extr_fake:\n  \"X \\<in> fake bad IK chan \\<Longrightarrow> extr bad IK' {X} \\<subseteq> IK \\<union> extr bad IK' chan\"", "lemmas extr_fake_2 [elim] = extr_fake [THEN [2] rev_subsetD]", "lemma fake_parts_extr_singleton:  \n  \"X \\<in> fake bad IK chan \\<Longrightarrow> parts (extr bad IK' {X}) \\<subseteq> parts IK \\<union> parts (extr bad IK' chan)\"", "lemmas fake_parts_extr_singleton_2 [elim] = fake_parts_extr_singleton [THEN [2] rev_subsetD]", "lemma fake_parts_extr_insert: \nassumes \"X \\<in> fake bad IK CH\"\nshows \"parts (extr bad IK' (insert X CH)) \\<subseteq> parts (extr bad IK' CH) \\<union> parts IK\"", "lemma fake_synth_analz_extr: \nassumes  \"X \\<in> fake bad (synth (analz (extr bad IK CH))) CH\"\nshows \"synth (analz (extr bad IK (insert X CH))) = synth (analz (extr bad IK CH))\"", "lemma dy_fake_msg_empty [simp]: \"dy_fake_msg bad {} {} = synth {}\"", "lemma dy_fake_msg_mono_bad [dest]: \"bad \\<subseteq> bad' \\<Longrightarrow> dy_fake_msg bad I C \\<subseteq> dy_fake_msg bad' I C\"", "lemma dy_fake_msg_mono_ik [dest]: \"G \\<subseteq> H \\<Longrightarrow> dy_fake_msg bad G C \\<subseteq> dy_fake_msg bad H C\"", "lemma dy_fake_msg_mono_chan [dest]: \"G \\<subseteq> H \\<Longrightarrow> dy_fake_msg bad I G \\<subseteq> dy_fake_msg bad I H\"", "lemmas dy_fake_msg_monotone_bad [elim] = dy_fake_msg_mono_bad [THEN [2] rev_subsetD]", "lemmas dy_fake_msg_monotone_ik [elim] = dy_fake_msg_mono_ik [THEN [2] rev_subsetD]", "lemmas dy_fake_msg_monotone_chan [elim] = dy_fake_msg_mono_chan [THEN [2] rev_subsetD]", "lemma dy_fake_msg_insert [intro]: \n  \"M \\<in> dy_fake_msg bad I C \\<Longrightarrow> M \\<in> dy_fake_msg bad I (insert X C)\"", "lemma dy_fake_msg_mono [intro]: \n  \"\\<lbrakk> b \\<subseteq> b'; I \\<subseteq> I'; C \\<subseteq> C' \\<rbrakk> \\<Longrightarrow> dy_fake_msg b I C \\<subseteq> dy_fake_msg b' I' C'\"", "lemmas dy_fake_msg_monotone [elim] = dy_fake_msg_mono [THEN [2] rev_subsetD]", "lemma dy_fake_msg_insert_chan:\n  \"x = insec \\<or> x = auth \\<Longrightarrow>\n   M \\<in> dy_fake_msg bad IK (insert (Chan x A B M) CH)\"", "lemma dy_fake_chan_mono_bad [intro]: \n  \"bad \\<subseteq> bad' \\<Longrightarrow> dy_fake_chan bad I C \\<subseteq> dy_fake_chan bad' I C\"", "lemma dy_fake_chan_mono_ik [intro]: \n  \"T \\<subseteq> T' \\<Longrightarrow> dy_fake_chan bad T C \\<subseteq> dy_fake_chan bad T' C\"", "lemma dy_fake_chan_mono_chan [intro]: \n  \"C \\<subseteq> C' \\<Longrightarrow> dy_fake_chan bad T C \\<subseteq> dy_fake_chan bad T C'\"", "lemmas dy_fake_chan_monotone_bad [elim] = dy_fake_chan_mono_bad [THEN [2] rev_subsetD]", "lemmas dy_fake_chan_monotone_ik [elim] = dy_fake_chan_mono_ik [THEN [2] rev_subsetD]", "lemmas dy_fake_chan_monotone_chan [elim] = dy_fake_chan_mono_chan [THEN [2] rev_subsetD]", "lemma dy_fake_chan_mono [intro]: \n  assumes \"b \\<subseteq> b'\" and \"I \\<subseteq> I'\" and \"C \\<subseteq> C'\"\n  shows \"dy_fake_chan b I C \\<subseteq> dy_fake_chan b' I' C'\"", "lemmas dy_fake_chan_monotone [elim] = dy_fake_chan_mono [THEN [2] rev_subsetD]", "lemma dy_fake_msg_subset_synth_analz: \n  \"\\<lbrakk>extr bad IK chan \\<subseteq> T \\<rbrakk> \\<Longrightarrow> dy_fake_msg bad IK chan \\<subseteq> synth (analz T)\"", "lemma dy_fake_chan_mono2:\n  \"\\<lbrakk> extr bad IK chan \\<subseteq> synth (analz y); chan \\<subseteq> fake bad (synth (analz y)) z \\<rbrakk>\n \\<Longrightarrow> dy_fake_chan bad IK chan \\<subseteq> fake bad (synth (analz y)) z\"", "lemma extr_subset_dy_fake_msg: \"extr bad IK chan \\<subseteq> dy_fake_msg bad IK chan\"", "lemma dy_fake_chan_extr_insert: \n  \"M \\<in> dy_fake_chan bad IK CH \\<Longrightarrow> extr bad IK (insert M CH) \\<subseteq> dy_fake_msg bad IK CH\"", "lemma dy_fake_chan_extr_insert_parts:\n  \"M \\<in> dy_fake_chan bad IK CH \\<Longrightarrow>\n   parts (extr bad IK (insert M CH)) \\<subseteq> parts (extr bad IK CH) \\<union> dy_fake_msg bad IK CH\"", "lemma dy_fake_msg_extr: \n  \"extr bad ik chan \\<subseteq> synth (analz X) \\<Longrightarrow> dy_fake_msg bad ik chan \\<subseteq> synth (analz X)\"", "lemma extr_insert_dy_fake_msg:\n  \"M \\<in> dy_fake_msg bad IK CH \\<Longrightarrow> extr bad (insert M IK) CH \\<subseteq> dy_fake_msg bad IK CH\"", "lemma dy_fake_msg_insert_dy_fake_msg:\n  \"M \\<in> dy_fake_msg bad IK CH \\<Longrightarrow> dy_fake_msg bad (insert M IK) CH \\<subseteq> dy_fake_msg bad IK CH\"", "lemma synth_analz_insert_dy_fake_msg:\n  \"M \\<in> dy_fake_msg bad IK CH \\<Longrightarrow> synth (analz (insert M IK)) \\<subseteq> dy_fake_msg bad IK CH\"", "lemma Fake_insert_dy_fake_msg:\n  \"M \\<in> dy_fake_msg bad IK CH \\<Longrightarrow>\n   extr bad IK CH \\<subseteq> synth (analz X) \\<Longrightarrow>\n   synth (analz (insert M IK)) \\<subseteq> synth (analz X)\"", "lemma dy_fake_chan_insert_chan:\n  \"x = insec \\<or> x = auth \\<Longrightarrow>\n   Chan x A B M \\<in> dy_fake_chan bad IK (insert (Chan x A B M) CH)\"", "lemma dy_fake_chan_subset:\n  \"CH \\<subseteq> fake bad (dy_fake_msg bad IK CH) CH' \\<Longrightarrow>\n   dy_fake_chan bad IK CH \\<subseteq> fake bad (dy_fake_msg bad IK CH) CH'\""], "translations": [["", "lemma extr_empty_chan [simp]: \"extr bad IK {} = IK\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extr bad IK {} = IK", "by (auto)"], ["", "lemma IK_subset_extr: \"IK \\<subseteq> extr bad IK chan\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IK \\<subseteq> extr bad IK chan", "by (auto)"], ["", "lemma extr_mono_chan [dest]: \"G \\<subseteq> H \\<Longrightarrow> extr bad IK G \\<subseteq> extr bad IK H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> H \\<Longrightarrow>\n    extr bad IK G \\<subseteq> extr bad IK H", "by (safe, erule extr.induct, auto)"], ["", "lemma extr_mono_IK [dest]: \"IK1 \\<subseteq> IK2 \\<Longrightarrow> extr bad IK1 H \\<subseteq> extr bad IK2 H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IK1 \\<subseteq> IK2 \\<Longrightarrow>\n    extr bad IK1 H \\<subseteq> extr bad IK2 H", "by (safe) (erule extr.induct, auto)"], ["", "lemma extr_mono_bad [dest]: \"bad \\<subseteq> bad' \\<Longrightarrow> extr bad IK H \\<subseteq> extr bad' IK H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bad \\<subseteq> bad' \\<Longrightarrow>\n    extr bad IK H \\<subseteq> extr bad' IK H", "by (safe, erule extr.induct, auto)"], ["", "lemmas extr_monotone_chan [elim] = extr_mono_chan [THEN [2] rev_subsetD]"], ["", "lemmas extr_monotone_IK [elim] = extr_mono_IK [THEN [2] rev_subsetD]"], ["", "lemmas extr_monotone_bad [elim] = extr_mono_bad [THEN [2] rev_subsetD]"], ["", "lemma extr_mono [intro]: \"\\<lbrakk> b \\<subseteq> b'; I \\<subseteq> I'; C \\<subseteq> C' \\<rbrakk> \\<Longrightarrow> extr b I C \\<subseteq> extr b' I' C'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<subseteq> b'; I \\<subseteq> I'; C \\<subseteq> C'\\<rbrakk>\n    \\<Longrightarrow> extr b I C \\<subseteq> extr b' I' C'", "by (force)"], ["", "lemmas extr_monotone [elim] = extr_mono [THEN [2] rev_subsetD]"], ["", "lemma extr_insert [intro]: \"M \\<in> extr bad IK H \\<Longrightarrow> M \\<in> extr bad IK (insert C H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<in> extr bad IK H \\<Longrightarrow> M \\<in> extr bad IK (insert C H)", "by (auto)"], ["", "lemma extr_insert_Chan [simp]: \n  \"extr bad IK (insert (Chan c A B M) H) \n   = (if c = insec \\<or> c = auth \\<or> A \\<in> bad \\<or> B \\<in> bad \n      then insert M (extr bad IK H) else extr bad IK H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extr bad IK (insert (Chan c A B M) H) =\n    (if c = insec \\<or> c = auth \\<or> A \\<in> bad \\<or> B \\<in> bad\n     then insert M (extr bad IK H) else extr bad IK H)", "by auto"], ["", "(* do not declare [simp]! *)"], ["", "lemma extr_insert_chan_eq: \"extr bad IK (insert X CH) = extr bad IK {X} \\<union> extr bad IK CH\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extr bad IK (insert X CH) = extr bad IK {X} \\<union> extr bad IK CH", "by (auto)"], ["", "lemma extr_insert_IK_eq [simp]: \"extr bad (insert X IK) CH = insert X (extr bad IK CH)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extr bad (insert X IK) CH = insert X (extr bad IK CH)", "by (auto)"], ["", "lemma extr_insert_bad:\n  \"extr (insert A bad) IK CH \\<subseteq>\n   extr bad IK CH \\<union> {M. \\<exists> B. Confid A B M \\<in> CH \\<or> Confid B A M \\<in> CH \\<or>\n                             Secure A B M \\<in> CH \\<or> Secure B A M \\<in> CH}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extr (insert A bad) IK CH\n    \\<subseteq> extr bad IK CH \\<union>\n                {M. \\<exists>B.\n                       Confid A B M \\<in> CH \\<or>\n                       Confid B A M \\<in> CH \\<or>\n                       Secure A B M \\<in> CH \\<or> Secure B A M \\<in> CH}", "by (rule, erule extr.induct, auto intro: tag.exhaust)"], ["", "lemma extr_insert_Confid [simp]:\n  \"A \\<notin> bad \\<Longrightarrow>\n   B \\<notin> bad \\<Longrightarrow> \n   extr bad IK (insert (Confid A B X) CH) = extr bad IK CH\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<notin> bad; B \\<notin> bad\\<rbrakk>\n    \\<Longrightarrow> extr bad IK (insert (Confid A B X) CH) =\n                      extr bad IK CH", "by auto"], ["", "(**************************************************************************************************)"], ["", "subsection \\<open>Fake\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>The set of channel messages that an attacker can fake given a set of compromised\nagents, a set of crypto messages and a set of channel messages. The second rule states\nthat an attacker can fake an insecure or confidential messages or a channel message\nwith a compromised endpoint using a payload that he knows.\\<close>"], ["", "inductive_set \n  fake :: \"agent set \\<Rightarrow> msg set \\<Rightarrow> chan set \\<Rightarrow> chan set\"\n  for bad :: \"agent set\"\n  and IK :: \"msg set\"\n  and chan :: \"chan set\"\nwhere \n  fake_Inj: \"M \\<in> chan \\<Longrightarrow> M \\<in> fake bad IK chan\"\n| fake_New: \n    \"\\<lbrakk> M \\<in> IK; c = insec \\<or> c = confid \\<or> A \\<in> bad \\<or> B \\<in> bad  \\<rbrakk> \n   \\<Longrightarrow> Chan c A B M \\<in> fake bad IK chan\""], ["", "declare fake.cases [elim]"], ["", "declare fake.intros [intro]"], ["", "lemmas fake_intros = fake_Inj fake_New"], ["", "lemma fake_mono_bad [intro]: \n  \"bad \\<subseteq> bad' \\<Longrightarrow> fake bad IK chan \\<subseteq> fake bad' IK chan\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bad \\<subseteq> bad' \\<Longrightarrow>\n    fake bad IK chan \\<subseteq> fake bad' IK chan", "by (auto)"], ["", "lemma fake_mono_ik [intro]: \n  \"IK \\<subseteq> IK' \\<Longrightarrow> fake bad IK chan \\<subseteq> fake bad IK' chan\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IK \\<subseteq> IK' \\<Longrightarrow>\n    fake bad IK chan \\<subseteq> fake bad IK' chan", "by (auto)"], ["", "lemma fake_mono_chan [intro]: \n  \"chan \\<subseteq> chan' \\<Longrightarrow> fake bad IK chan \\<subseteq> fake bad IK chan'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chan \\<subseteq> chan' \\<Longrightarrow>\n    fake bad IK chan \\<subseteq> fake bad IK chan'", "by (auto)"], ["", "lemma fake_mono [intro]: \n  \"\\<lbrakk> bad \\<subseteq> bad'; IK \\<subseteq> IK'; chan \\<subseteq> chan'\\<rbrakk> \\<Longrightarrow> fake bad IK chan \\<subseteq> fake bad' IK' chan'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bad \\<subseteq> bad'; IK \\<subseteq> IK';\n     chan \\<subseteq> chan'\\<rbrakk>\n    \\<Longrightarrow> fake bad IK chan \\<subseteq> fake bad' IK' chan'", "by (auto, erule fake.cases, auto)"], ["", "lemmas fake_monotone_bad [elim] = fake_mono_bad [THEN [2] rev_subsetD]"], ["", "lemmas fake_monotone_ik [elim] = fake_mono_ik [THEN [2] rev_subsetD]"], ["", "lemmas fake_monotone_chan [elim] = fake_mono_chan [THEN [2] rev_subsetD]"], ["", "lemmas fake_monotone [elim] = fake_mono [THEN [2] rev_subsetD]"], ["", "lemma chan_subset_fake: \"chan \\<subseteq> fake bad IK chan\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chan \\<subseteq> fake bad IK chan", "by auto"], ["", "lemma extr_fake:\n  \"X \\<in> fake bad IK chan \\<Longrightarrow> extr bad IK' {X} \\<subseteq> IK \\<union> extr bad IK' chan\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> fake bad IK chan \\<Longrightarrow>\n    extr bad IK' {X} \\<subseteq> IK \\<union> extr bad IK' chan", "by auto"], ["", "lemmas extr_fake_2 [elim] = extr_fake [THEN [2] rev_subsetD]"], ["", "lemma fake_parts_extr_singleton:  \n  \"X \\<in> fake bad IK chan \\<Longrightarrow> parts (extr bad IK' {X}) \\<subseteq> parts IK \\<union> parts (extr bad IK' chan)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> fake bad IK chan \\<Longrightarrow>\n    parts (extr bad IK' {X})\n    \\<subseteq> parts IK \\<union> parts (extr bad IK' chan)", "by (rule extr_fake [THEN parts_mono, simplified])"], ["", "lemmas fake_parts_extr_singleton_2 [elim] = fake_parts_extr_singleton [THEN [2] rev_subsetD]"], ["", "lemma fake_parts_extr_insert: \nassumes \"X \\<in> fake bad IK CH\"\nshows \"parts (extr bad IK' (insert X CH)) \\<subseteq> parts (extr bad IK' CH) \\<union> parts IK\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (extr bad IK' (insert X CH))\n    \\<subseteq> parts (extr bad IK' CH) \\<union> parts IK", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. parts (extr bad IK' (insert X CH))\n    \\<subseteq> parts (extr bad IK' CH) \\<union> parts IK", "have \"parts (extr bad IK' (insert X CH)) \\<subseteq> parts (extr bad IK' {X}) \\<union> parts (extr bad IK' CH)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (extr bad IK' (insert X CH))\n    \\<subseteq> parts (extr bad IK' {X}) \\<union> parts (extr bad IK' CH)", "by (auto simp: extr_insert_chan_eq [where CH=CH])"], ["proof (state)\nthis:\n  parts (extr bad IK' (insert X CH))\n  \\<subseteq> parts (extr bad IK' {X}) \\<union> parts (extr bad IK' CH)\n\ngoal (1 subgoal):\n 1. parts (extr bad IK' (insert X CH))\n    \\<subseteq> parts (extr bad IK' CH) \\<union> parts IK", "also"], ["proof (state)\nthis:\n  parts (extr bad IK' (insert X CH))\n  \\<subseteq> parts (extr bad IK' {X}) \\<union> parts (extr bad IK' CH)\n\ngoal (1 subgoal):\n 1. parts (extr bad IK' (insert X CH))\n    \\<subseteq> parts (extr bad IK' CH) \\<union> parts IK", "have \"... \\<subseteq> parts (extr bad IK' CH) \\<union> parts IK\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parts (extr bad IK' {X}) \\<union> parts (extr bad IK' CH)\n    \\<subseteq> parts (extr bad IK' CH) \\<union> parts IK", "using assms"], ["proof (prove)\nusing this:\n  X \\<in> fake bad IK CH\n\ngoal (1 subgoal):\n 1. parts (extr bad IK' {X}) \\<union> parts (extr bad IK' CH)\n    \\<subseteq> parts (extr bad IK' CH) \\<union> parts IK", "by (auto dest!: fake_parts_extr_singleton)"], ["proof (state)\nthis:\n  parts (extr bad IK' {X}) \\<union> parts (extr bad IK' CH)\n  \\<subseteq> parts (extr bad IK' CH) \\<union> parts IK\n\ngoal (1 subgoal):\n 1. parts (extr bad IK' (insert X CH))\n    \\<subseteq> parts (extr bad IK' CH) \\<union> parts IK", "finally"], ["proof (chain)\npicking this:\n  parts (extr bad IK' (insert X CH))\n  \\<subseteq> parts (extr bad IK' CH) \\<union> parts IK", "show ?thesis"], ["proof (prove)\nusing this:\n  parts (extr bad IK' (insert X CH))\n  \\<subseteq> parts (extr bad IK' CH) \\<union> parts IK\n\ngoal (1 subgoal):\n 1. parts (extr bad IK' (insert X CH))\n    \\<subseteq> parts (extr bad IK' CH) \\<union> parts IK", "."], ["proof (state)\nthis:\n  parts (extr bad IK' (insert X CH))\n  \\<subseteq> parts (extr bad IK' CH) \\<union> parts IK\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fake_synth_analz_extr: \nassumes  \"X \\<in> fake bad (synth (analz (extr bad IK CH))) CH\"\nshows \"synth (analz (extr bad IK (insert X CH))) = synth (analz (extr bad IK CH))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. synth (analz (extr bad IK (insert X CH))) =\n    synth (analz (extr bad IK CH))", "using assms"], ["proof (prove)\nusing this:\n  X \\<in> fake bad (synth (analz (extr bad IK CH))) CH\n\ngoal (1 subgoal):\n 1. synth (analz (extr bad IK (insert X CH))) =\n    synth (analz (extr bad IK CH))", "proof (intro equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. X \\<in> fake bad (synth (analz (extr bad IK CH))) CH \\<Longrightarrow>\n    synth (analz (extr bad IK (insert X CH)))\n    \\<subseteq> synth (analz (extr bad IK CH))\n 2. X \\<in> fake bad (synth (analz (extr bad IK CH))) CH \\<Longrightarrow>\n    synth (analz (extr bad IK CH))\n    \\<subseteq> synth (analz (extr bad IK (insert X CH)))", "have \"synth (analz (extr bad IK (insert X CH))) \n     \\<subseteq> synth (analz (extr bad IK {X} \\<union> extr bad IK CH))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. synth (analz (extr bad IK (insert X CH)))\n    \\<subseteq> synth (analz (extr bad IK {X} \\<union> extr bad IK CH))", "by - (rule synth_analz_mono, auto)"], ["proof (state)\nthis:\n  synth (analz (extr bad IK (insert X CH)))\n  \\<subseteq> synth (analz (extr bad IK {X} \\<union> extr bad IK CH))\n\ngoal (2 subgoals):\n 1. X \\<in> fake bad (synth (analz (extr bad IK CH))) CH \\<Longrightarrow>\n    synth (analz (extr bad IK (insert X CH)))\n    \\<subseteq> synth (analz (extr bad IK CH))\n 2. X \\<in> fake bad (synth (analz (extr bad IK CH))) CH \\<Longrightarrow>\n    synth (analz (extr bad IK CH))\n    \\<subseteq> synth (analz (extr bad IK (insert X CH)))", "also"], ["proof (state)\nthis:\n  synth (analz (extr bad IK (insert X CH)))\n  \\<subseteq> synth (analz (extr bad IK {X} \\<union> extr bad IK CH))\n\ngoal (2 subgoals):\n 1. X \\<in> fake bad (synth (analz (extr bad IK CH))) CH \\<Longrightarrow>\n    synth (analz (extr bad IK (insert X CH)))\n    \\<subseteq> synth (analz (extr bad IK CH))\n 2. X \\<in> fake bad (synth (analz (extr bad IK CH))) CH \\<Longrightarrow>\n    synth (analz (extr bad IK CH))\n    \\<subseteq> synth (analz (extr bad IK (insert X CH)))", "have \"... \\<subseteq> synth (analz (synth (analz (extr bad IK CH)) \\<union> extr bad IK CH))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. synth (analz (extr bad IK {X} \\<union> extr bad IK CH))\n    \\<subseteq> synth\n                 (analz\n                   (synth (analz (extr bad IK CH)) \\<union> extr bad IK CH))", "using assms"], ["proof (prove)\nusing this:\n  X \\<in> fake bad (synth (analz (extr bad IK CH))) CH\n\ngoal (1 subgoal):\n 1. synth (analz (extr bad IK {X} \\<union> extr bad IK CH))\n    \\<subseteq> synth\n                 (analz\n                   (synth (analz (extr bad IK CH)) \\<union> extr bad IK CH))", "by - (rule synth_analz_mono, auto)"], ["proof (state)\nthis:\n  synth (analz (extr bad IK {X} \\<union> extr bad IK CH))\n  \\<subseteq> synth\n               (analz\n                 (synth (analz (extr bad IK CH)) \\<union> extr bad IK CH))\n\ngoal (2 subgoals):\n 1. X \\<in> fake bad (synth (analz (extr bad IK CH))) CH \\<Longrightarrow>\n    synth (analz (extr bad IK (insert X CH)))\n    \\<subseteq> synth (analz (extr bad IK CH))\n 2. X \\<in> fake bad (synth (analz (extr bad IK CH))) CH \\<Longrightarrow>\n    synth (analz (extr bad IK CH))\n    \\<subseteq> synth (analz (extr bad IK (insert X CH)))", "also"], ["proof (state)\nthis:\n  synth (analz (extr bad IK {X} \\<union> extr bad IK CH))\n  \\<subseteq> synth\n               (analz\n                 (synth (analz (extr bad IK CH)) \\<union> extr bad IK CH))\n\ngoal (2 subgoals):\n 1. X \\<in> fake bad (synth (analz (extr bad IK CH))) CH \\<Longrightarrow>\n    synth (analz (extr bad IK (insert X CH)))\n    \\<subseteq> synth (analz (extr bad IK CH))\n 2. X \\<in> fake bad (synth (analz (extr bad IK CH))) CH \\<Longrightarrow>\n    synth (analz (extr bad IK CH))\n    \\<subseteq> synth (analz (extr bad IK (insert X CH)))", "have \"... \\<subseteq> synth (analz (synth (analz (extr bad IK CH))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. synth (analz (synth (analz (extr bad IK CH)) \\<union> extr bad IK CH))\n    \\<subseteq> synth (analz (synth (analz (extr bad IK CH))))", "by - (rule synth_analz_mono, auto)"], ["proof (state)\nthis:\n  synth (analz (synth (analz (extr bad IK CH)) \\<union> extr bad IK CH))\n  \\<subseteq> synth (analz (synth (analz (extr bad IK CH))))\n\ngoal (2 subgoals):\n 1. X \\<in> fake bad (synth (analz (extr bad IK CH))) CH \\<Longrightarrow>\n    synth (analz (extr bad IK (insert X CH)))\n    \\<subseteq> synth (analz (extr bad IK CH))\n 2. X \\<in> fake bad (synth (analz (extr bad IK CH))) CH \\<Longrightarrow>\n    synth (analz (extr bad IK CH))\n    \\<subseteq> synth (analz (extr bad IK (insert X CH)))", "also"], ["proof (state)\nthis:\n  synth (analz (synth (analz (extr bad IK CH)) \\<union> extr bad IK CH))\n  \\<subseteq> synth (analz (synth (analz (extr bad IK CH))))\n\ngoal (2 subgoals):\n 1. X \\<in> fake bad (synth (analz (extr bad IK CH))) CH \\<Longrightarrow>\n    synth (analz (extr bad IK (insert X CH)))\n    \\<subseteq> synth (analz (extr bad IK CH))\n 2. X \\<in> fake bad (synth (analz (extr bad IK CH))) CH \\<Longrightarrow>\n    synth (analz (extr bad IK CH))\n    \\<subseteq> synth (analz (extr bad IK (insert X CH)))", "have \"... \\<subseteq> synth (analz (extr bad IK CH))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. synth (analz (synth (analz (extr bad IK CH))))\n    \\<subseteq> synth (analz (extr bad IK CH))", "by simp"], ["proof (state)\nthis:\n  synth (analz (synth (analz (extr bad IK CH))))\n  \\<subseteq> synth (analz (extr bad IK CH))\n\ngoal (2 subgoals):\n 1. X \\<in> fake bad (synth (analz (extr bad IK CH))) CH \\<Longrightarrow>\n    synth (analz (extr bad IK (insert X CH)))\n    \\<subseteq> synth (analz (extr bad IK CH))\n 2. X \\<in> fake bad (synth (analz (extr bad IK CH))) CH \\<Longrightarrow>\n    synth (analz (extr bad IK CH))\n    \\<subseteq> synth (analz (extr bad IK (insert X CH)))", "finally"], ["proof (chain)\npicking this:\n  synth (analz (extr bad IK (insert X CH)))\n  \\<subseteq> synth (analz (extr bad IK CH))", "show \"synth (analz (extr bad IK (insert X CH))) \\<subseteq> synth (analz (extr bad IK CH))\""], ["proof (prove)\nusing this:\n  synth (analz (extr bad IK (insert X CH)))\n  \\<subseteq> synth (analz (extr bad IK CH))\n\ngoal (1 subgoal):\n 1. synth (analz (extr bad IK (insert X CH)))\n    \\<subseteq> synth (analz (extr bad IK CH))", "."], ["proof (state)\nthis:\n  synth (analz (extr bad IK (insert X CH)))\n  \\<subseteq> synth (analz (extr bad IK CH))\n\ngoal (1 subgoal):\n 1. X \\<in> fake bad (synth (analz (extr bad IK CH))) CH \\<Longrightarrow>\n    synth (analz (extr bad IK CH))\n    \\<subseteq> synth (analz (extr bad IK (insert X CH)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. X \\<in> fake bad (synth (analz (extr bad IK CH))) CH \\<Longrightarrow>\n    synth (analz (extr bad IK CH))\n    \\<subseteq> synth (analz (extr bad IK (insert X CH)))", "have \"extr bad IK CH \\<subseteq> extr bad IK (insert X CH)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extr bad IK CH \\<subseteq> extr bad IK (insert X CH)", "by auto"], ["proof (state)\nthis:\n  extr bad IK CH \\<subseteq> extr bad IK (insert X CH)\n\ngoal (1 subgoal):\n 1. X \\<in> fake bad (synth (analz (extr bad IK CH))) CH \\<Longrightarrow>\n    synth (analz (extr bad IK CH))\n    \\<subseteq> synth (analz (extr bad IK (insert X CH)))", "then"], ["proof (chain)\npicking this:\n  extr bad IK CH \\<subseteq> extr bad IK (insert X CH)", "show \"synth (analz (extr bad IK CH)) \\<subseteq> synth (analz (extr bad IK (insert X CH)))\""], ["proof (prove)\nusing this:\n  extr bad IK CH \\<subseteq> extr bad IK (insert X CH)\n\ngoal (1 subgoal):\n 1. synth (analz (extr bad IK CH))\n    \\<subseteq> synth (analz (extr bad IK (insert X CH)))", "by - (rule synth_analz_mono, auto)"], ["proof (state)\nthis:\n  synth (analz (extr bad IK CH))\n  \\<subseteq> synth (analz (extr bad IK (insert X CH)))\n\ngoal:\nNo subgoals!", "qed"], ["", "(**************************************************************************************************)"], ["", "subsection \\<open>Closure of Dolev-Yao, extract and fake\\<close>"], ["", "(**************************************************************************************************)"], ["", "subsubsection \\<open>\\<open>dy_fake_msg\\<close>: returns messages, closure of DY and extr is sufficient\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>Close @{term extr} under Dolev-Yao closure using @{term synth} and @{term analz}. \nThis will be used in Level 2 attacker events to fake crypto messages.\\<close>"], ["", "definition \n  dy_fake_msg :: \"agent set \\<Rightarrow> msg set \\<Rightarrow> chan set \\<Rightarrow> msg set\"\nwhere\n  \"dy_fake_msg b i c = synth (analz (extr b i c))\""], ["", "lemma dy_fake_msg_empty [simp]: \"dy_fake_msg bad {} {} = synth {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dy_fake_msg bad {} {} = synth {}", "by (auto simp add: dy_fake_msg_def)"], ["", "lemma dy_fake_msg_mono_bad [dest]: \"bad \\<subseteq> bad' \\<Longrightarrow> dy_fake_msg bad I C \\<subseteq> dy_fake_msg bad' I C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bad \\<subseteq> bad' \\<Longrightarrow>\n    dy_fake_msg bad I C \\<subseteq> dy_fake_msg bad' I C", "by (auto simp add: dy_fake_msg_def intro!: synth_analz_mono)"], ["", "lemma dy_fake_msg_mono_ik [dest]: \"G \\<subseteq> H \\<Longrightarrow> dy_fake_msg bad G C \\<subseteq> dy_fake_msg bad H C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> H \\<Longrightarrow>\n    dy_fake_msg bad G C \\<subseteq> dy_fake_msg bad H C", "by (auto simp add: dy_fake_msg_def intro!: synth_analz_mono)"], ["", "lemma dy_fake_msg_mono_chan [dest]: \"G \\<subseteq> H \\<Longrightarrow> dy_fake_msg bad I G \\<subseteq> dy_fake_msg bad I H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> H \\<Longrightarrow>\n    dy_fake_msg bad I G \\<subseteq> dy_fake_msg bad I H", "by (auto simp add: dy_fake_msg_def intro!: synth_analz_mono)"], ["", "lemmas dy_fake_msg_monotone_bad [elim] = dy_fake_msg_mono_bad [THEN [2] rev_subsetD]"], ["", "lemmas dy_fake_msg_monotone_ik [elim] = dy_fake_msg_mono_ik [THEN [2] rev_subsetD]"], ["", "lemmas dy_fake_msg_monotone_chan [elim] = dy_fake_msg_mono_chan [THEN [2] rev_subsetD]"], ["", "lemma dy_fake_msg_insert [intro]: \n  \"M \\<in> dy_fake_msg bad I C \\<Longrightarrow> M \\<in> dy_fake_msg bad I (insert X C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<in> dy_fake_msg bad I C \\<Longrightarrow>\n    M \\<in> dy_fake_msg bad I (insert X C)", "by (auto)"], ["", "lemma dy_fake_msg_mono [intro]: \n  \"\\<lbrakk> b \\<subseteq> b'; I \\<subseteq> I'; C \\<subseteq> C' \\<rbrakk> \\<Longrightarrow> dy_fake_msg b I C \\<subseteq> dy_fake_msg b' I' C'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<subseteq> b'; I \\<subseteq> I'; C \\<subseteq> C'\\<rbrakk>\n    \\<Longrightarrow> dy_fake_msg b I C \\<subseteq> dy_fake_msg b' I' C'", "by (force simp add: dy_fake_msg_def intro!: synth_analz_mono)"], ["", "lemmas dy_fake_msg_monotone [elim] = dy_fake_msg_mono [THEN [2] rev_subsetD]"], ["", "lemma dy_fake_msg_insert_chan:\n  \"x = insec \\<or> x = auth \\<Longrightarrow>\n   M \\<in> dy_fake_msg bad IK (insert (Chan x A B M) CH)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = insec \\<or> x = auth \\<Longrightarrow>\n    M \\<in> dy_fake_msg bad IK (insert (Chan x A B M) CH)", "by (auto simp add: dy_fake_msg_def)"], ["", "subsubsection \\<open>\\<open>dy_fake_chan\\<close>: returns channel messages\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>The set of all channel messages that an attacker can fake is obtained using\n@{term fake} with the sets of possible payload messages derived with @{term dy_fake_msg}\ndefined above. This will be used in Level 2 attacker events to fake channel messages.\\<close>"], ["", "definition\n  dy_fake_chan :: \"agent set \\<Rightarrow> msg set \\<Rightarrow> chan set \\<Rightarrow> chan set\"\nwhere\n  \"dy_fake_chan b i c = fake b (dy_fake_msg b i c) c\""], ["", "lemma dy_fake_chan_mono_bad [intro]: \n  \"bad \\<subseteq> bad' \\<Longrightarrow> dy_fake_chan bad I C \\<subseteq> dy_fake_chan bad' I C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bad \\<subseteq> bad' \\<Longrightarrow>\n    dy_fake_chan bad I C \\<subseteq> dy_fake_chan bad' I C", "by (auto simp add: dy_fake_chan_def)"], ["", "lemma dy_fake_chan_mono_ik [intro]: \n  \"T \\<subseteq> T' \\<Longrightarrow> dy_fake_chan bad T C \\<subseteq> dy_fake_chan bad T' C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T \\<subseteq> T' \\<Longrightarrow>\n    dy_fake_chan bad T C \\<subseteq> dy_fake_chan bad T' C", "by (auto simp add: dy_fake_chan_def)"], ["", "lemma dy_fake_chan_mono_chan [intro]: \n  \"C \\<subseteq> C' \\<Longrightarrow> dy_fake_chan bad T C \\<subseteq> dy_fake_chan bad T C'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<subseteq> C' \\<Longrightarrow>\n    dy_fake_chan bad T C \\<subseteq> dy_fake_chan bad T C'", "by (auto simp add: dy_fake_chan_def)"], ["", "lemmas dy_fake_chan_monotone_bad [elim] = dy_fake_chan_mono_bad [THEN [2] rev_subsetD]"], ["", "lemmas dy_fake_chan_monotone_ik [elim] = dy_fake_chan_mono_ik [THEN [2] rev_subsetD]"], ["", "lemmas dy_fake_chan_monotone_chan [elim] = dy_fake_chan_mono_chan [THEN [2] rev_subsetD]"], ["", "lemma dy_fake_chan_mono [intro]: \n  assumes \"b \\<subseteq> b'\" and \"I \\<subseteq> I'\" and \"C \\<subseteq> C'\"\n  shows \"dy_fake_chan b I C \\<subseteq> dy_fake_chan b' I' C'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dy_fake_chan b I C \\<subseteq> dy_fake_chan b' I' C'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dy_fake_chan b I C \\<subseteq> dy_fake_chan b' I' C'", "have \"dy_fake_chan b I C \\<subseteq> dy_fake_chan b' I C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dy_fake_chan b I C \\<subseteq> dy_fake_chan b' I C", "using \\<open>b \\<subseteq> b'\\<close>"], ["proof (prove)\nusing this:\n  b \\<subseteq> b'\n\ngoal (1 subgoal):\n 1. dy_fake_chan b I C \\<subseteq> dy_fake_chan b' I C", "by auto"], ["proof (state)\nthis:\n  dy_fake_chan b I C \\<subseteq> dy_fake_chan b' I C\n\ngoal (1 subgoal):\n 1. dy_fake_chan b I C \\<subseteq> dy_fake_chan b' I' C'", "also"], ["proof (state)\nthis:\n  dy_fake_chan b I C \\<subseteq> dy_fake_chan b' I C\n\ngoal (1 subgoal):\n 1. dy_fake_chan b I C \\<subseteq> dy_fake_chan b' I' C'", "have \"... \\<subseteq> dy_fake_chan b' I' C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dy_fake_chan b' I C \\<subseteq> dy_fake_chan b' I' C", "using \\<open>I \\<subseteq> I'\\<close>"], ["proof (prove)\nusing this:\n  I \\<subseteq> I'\n\ngoal (1 subgoal):\n 1. dy_fake_chan b' I C \\<subseteq> dy_fake_chan b' I' C", "by auto"], ["proof (state)\nthis:\n  dy_fake_chan b' I C \\<subseteq> dy_fake_chan b' I' C\n\ngoal (1 subgoal):\n 1. dy_fake_chan b I C \\<subseteq> dy_fake_chan b' I' C'", "also"], ["proof (state)\nthis:\n  dy_fake_chan b' I C \\<subseteq> dy_fake_chan b' I' C\n\ngoal (1 subgoal):\n 1. dy_fake_chan b I C \\<subseteq> dy_fake_chan b' I' C'", "have \"... \\<subseteq> dy_fake_chan b' I' C'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dy_fake_chan b' I' C \\<subseteq> dy_fake_chan b' I' C'", "using \\<open>C \\<subseteq> C'\\<close>"], ["proof (prove)\nusing this:\n  C \\<subseteq> C'\n\ngoal (1 subgoal):\n 1. dy_fake_chan b' I' C \\<subseteq> dy_fake_chan b' I' C'", "by auto"], ["proof (state)\nthis:\n  dy_fake_chan b' I' C \\<subseteq> dy_fake_chan b' I' C'\n\ngoal (1 subgoal):\n 1. dy_fake_chan b I C \\<subseteq> dy_fake_chan b' I' C'", "finally"], ["proof (chain)\npicking this:\n  dy_fake_chan b I C \\<subseteq> dy_fake_chan b' I' C'", "show ?thesis"], ["proof (prove)\nusing this:\n  dy_fake_chan b I C \\<subseteq> dy_fake_chan b' I' C'\n\ngoal (1 subgoal):\n 1. dy_fake_chan b I C \\<subseteq> dy_fake_chan b' I' C'", "."], ["proof (state)\nthis:\n  dy_fake_chan b I C \\<subseteq> dy_fake_chan b' I' C'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas dy_fake_chan_monotone [elim] = dy_fake_chan_mono [THEN [2] rev_subsetD]"], ["", "lemma dy_fake_msg_subset_synth_analz: \n  \"\\<lbrakk>extr bad IK chan \\<subseteq> T \\<rbrakk> \\<Longrightarrow> dy_fake_msg bad IK chan \\<subseteq> synth (analz T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extr bad IK chan \\<subseteq> T \\<Longrightarrow>\n    dy_fake_msg bad IK chan \\<subseteq> synth (analz T)", "by (auto simp add: dy_fake_msg_def synth_analz_mono)"], ["", "lemma dy_fake_chan_mono2:\n  \"\\<lbrakk> extr bad IK chan \\<subseteq> synth (analz y); chan \\<subseteq> fake bad (synth (analz y)) z \\<rbrakk>\n \\<Longrightarrow> dy_fake_chan bad IK chan \\<subseteq> fake bad (synth (analz y)) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>extr bad IK chan \\<subseteq> synth (analz y);\n     chan \\<subseteq> fake bad (synth (analz y)) z\\<rbrakk>\n    \\<Longrightarrow> dy_fake_chan bad IK chan\n                      \\<subseteq> fake bad (synth (analz y)) z", "apply (auto simp add: dy_fake_chan_def, erule fake.cases, auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>M A B.\n       \\<lbrakk>extr bad IK chan \\<subseteq> synth (analz y);\n        chan \\<subseteq> fake bad (synth (analz y)) z;\n        M \\<in> dy_fake_msg bad IK chan\\<rbrakk>\n       \\<Longrightarrow> Insec A B M \\<in> fake bad (synth (analz y)) z\n 2. \\<And>M A B.\n       \\<lbrakk>extr bad IK chan \\<subseteq> synth (analz y);\n        chan \\<subseteq> fake bad (synth (analz y)) z;\n        M \\<in> dy_fake_msg bad IK chan\\<rbrakk>\n       \\<Longrightarrow> Confid A B M \\<in> fake bad (synth (analz y)) z\n 3. \\<And>M c A B.\n       \\<lbrakk>extr bad IK chan \\<subseteq> synth (analz y);\n        chan \\<subseteq> fake bad (synth (analz y)) z;\n        M \\<in> dy_fake_msg bad IK chan; A \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> Chan c A B M \\<in> fake bad (synth (analz y)) z\n 4. \\<And>M c A B.\n       \\<lbrakk>extr bad IK chan \\<subseteq> synth (analz y);\n        chan \\<subseteq> fake bad (synth (analz y)) z;\n        M \\<in> dy_fake_msg bad IK chan; B \\<in> bad\\<rbrakk>\n       \\<Longrightarrow> Chan c A B M \\<in> fake bad (synth (analz y)) z", "apply (auto intro!: fake_New dest!: dy_fake_msg_subset_synth_analz)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma extr_subset_dy_fake_msg: \"extr bad IK chan \\<subseteq> dy_fake_msg bad IK chan\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extr bad IK chan \\<subseteq> dy_fake_msg bad IK chan", "by (auto simp add: dy_fake_msg_def)"], ["", "lemma dy_fake_chan_extr_insert: \n  \"M \\<in> dy_fake_chan bad IK CH \\<Longrightarrow> extr bad IK (insert M CH) \\<subseteq> dy_fake_msg bad IK CH\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<in> dy_fake_chan bad IK CH \\<Longrightarrow>\n    extr bad IK (insert M CH) \\<subseteq> dy_fake_msg bad IK CH", "by (auto simp add: dy_fake_chan_def dy_fake_msg_def dest: fake_synth_analz_extr)"], ["", "lemma dy_fake_chan_extr_insert_parts:\n  \"M \\<in> dy_fake_chan bad IK CH \\<Longrightarrow>\n   parts (extr bad IK (insert M CH)) \\<subseteq> parts (extr bad IK CH) \\<union> dy_fake_msg bad IK CH\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<in> dy_fake_chan bad IK CH \\<Longrightarrow>\n    parts (extr bad IK (insert M CH))\n    \\<subseteq> parts (extr bad IK CH) \\<union> dy_fake_msg bad IK CH", "by (drule dy_fake_chan_extr_insert [THEN parts_mono], auto simp add: dy_fake_msg_def)"], ["", "lemma dy_fake_msg_extr: \n  \"extr bad ik chan \\<subseteq> synth (analz X) \\<Longrightarrow> dy_fake_msg bad ik chan \\<subseteq> synth (analz X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extr bad ik chan \\<subseteq> synth (analz X) \\<Longrightarrow>\n    dy_fake_msg bad ik chan \\<subseteq> synth (analz X)", "by (drule synth_analz_mono) (auto simp add: dy_fake_msg_def)"], ["", "lemma extr_insert_dy_fake_msg:\n  \"M \\<in> dy_fake_msg bad IK CH \\<Longrightarrow> extr bad (insert M IK) CH \\<subseteq> dy_fake_msg bad IK CH\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<in> dy_fake_msg bad IK CH \\<Longrightarrow>\n    extr bad (insert M IK) CH \\<subseteq> dy_fake_msg bad IK CH", "by (auto simp add: dy_fake_msg_def)"], ["", "lemma dy_fake_msg_insert_dy_fake_msg:\n  \"M \\<in> dy_fake_msg bad IK CH \\<Longrightarrow> dy_fake_msg bad (insert M IK) CH \\<subseteq> dy_fake_msg bad IK CH\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<in> dy_fake_msg bad IK CH \\<Longrightarrow>\n    dy_fake_msg bad (insert M IK) CH \\<subseteq> dy_fake_msg bad IK CH", "by (drule synth_analz_mono [OF extr_insert_dy_fake_msg], auto simp add: dy_fake_msg_def)"], ["", "lemma synth_analz_insert_dy_fake_msg:\n  \"M \\<in> dy_fake_msg bad IK CH \\<Longrightarrow> synth (analz (insert M IK)) \\<subseteq> dy_fake_msg bad IK CH\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<in> dy_fake_msg bad IK CH \\<Longrightarrow>\n    synth (analz (insert M IK)) \\<subseteq> dy_fake_msg bad IK CH", "by (auto dest!: dy_fake_msg_insert_dy_fake_msg, erule subsetD, \n    auto simp add: dy_fake_msg_def elim: synth_analz_monotone)"], ["", "lemma Fake_insert_dy_fake_msg:\n  \"M \\<in> dy_fake_msg bad IK CH \\<Longrightarrow>\n   extr bad IK CH \\<subseteq> synth (analz X) \\<Longrightarrow>\n   synth (analz (insert M IK)) \\<subseteq> synth (analz X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M \\<in> dy_fake_msg bad IK CH;\n     extr bad IK CH \\<subseteq> synth (analz X)\\<rbrakk>\n    \\<Longrightarrow> synth (analz (insert M IK))\n                      \\<subseteq> synth (analz X)", "by (auto dest!: synth_analz_insert_dy_fake_msg dy_fake_msg_extr)"], ["", "lemma dy_fake_chan_insert_chan:\n  \"x = insec \\<or> x = auth \\<Longrightarrow>\n   Chan x A B M \\<in> dy_fake_chan bad IK (insert (Chan x A B M) CH)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = insec \\<or> x = auth \\<Longrightarrow>\n    Chan x A B M \\<in> dy_fake_chan bad IK (insert (Chan x A B M) CH)", "by (auto simp add: dy_fake_chan_def)"], ["", "lemma dy_fake_chan_subset:\n  \"CH \\<subseteq> fake bad (dy_fake_msg bad IK CH) CH' \\<Longrightarrow>\n   dy_fake_chan bad IK CH \\<subseteq> fake bad (dy_fake_msg bad IK CH) CH'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CH \\<subseteq> fake bad (dy_fake_msg bad IK CH) CH' \\<Longrightarrow>\n    dy_fake_chan bad IK CH \\<subseteq> fake bad (dy_fake_msg bad IK CH) CH'", "by (auto simp add: dy_fake_chan_def)"], ["", "end"]]}