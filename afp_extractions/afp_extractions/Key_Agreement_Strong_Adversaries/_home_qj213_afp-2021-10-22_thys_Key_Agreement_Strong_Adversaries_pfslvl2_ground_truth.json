{"file_name": "/home/qj213/afp-2021-10-22/thys/Key_Agreement_Strong_Adversaries/pfslvl2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Key_Agreement_Strong_Adversaries", "problem_names": ["lemma role_comp_inv [simp]:\n  \"role_comp (role_comp x) = x\"", "lemma role_comp_inv_eq:\n  \"y = role_comp x \\<longleftrightarrow> x = role_comp y\"", "lemma test_not_partner [simp]:\n  \"test \\<notin> partners\"", "lemma matching_symmetric:\n  \"matching sigma sigma' \\<Longrightarrow> matching sigma' sigma\"", "lemma partner_symmetric:\n  \"partner_runs R R' \\<Longrightarrow> partner_runs R' R\"", "lemma partner_unique:\n  \"partner_runs R R'' \\<Longrightarrow> partner_runs R R' \\<Longrightarrow> R' = R''\"", "lemma partner_test:\n  \"R \\<in> partners \\<Longrightarrow> partner_runs R R' \\<Longrightarrow> R' = test\"", "lemmas l2_loc_defs = \n  l2_step1_def l2_step2_def l2_step3_def\n  l2_def l2_init_def l2_trans_def\n  l2_dy_fake_chan_def l2_dy_fake_msg_def\n  l2_lkr_after_def l2_lkr_others_def l2_skr_def", "lemmas l2_defs = l2_loc_defs ik_dy_def", "lemmas l2_nostep_defs = l2_def l2_init_def l2_trans_def", "lemma l2_obs_id [simp]: \"obs l2 = id\"", "lemma l2_run_ended_trans:\n  \"run_ended (progress s R) \\<Longrightarrow>\n   (s, s') \\<in> trans l2 \\<Longrightarrow>\n   run_ended (progress s' R)\"", "lemma l2_can_signal_trans:\n  \"can_signal s' A B \\<Longrightarrow>\n  (s, s') \\<in> trans l2 \\<Longrightarrow>\n  can_signal s A B\"", "lemmas l2_inv1I = l2_inv1_def [THEN setc_def_to_intro, rule_format]", "lemmas l2_inv1E [elim] = l2_inv1_def [THEN setc_def_to_elim, rule_format]", "lemmas l2_inv1D = l2_inv1_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]", "lemma l2_inv1_init [iff]:\n  \"init l2 \\<subseteq> l2_inv1\"", "lemma l2_inv1_trans [iff]:\n  \"{l2_inv1} trans l2 {> l2_inv1}\"", "lemma PO_l2_inv1 [iff]: \"reach l2 \\<subseteq> l2_inv1\"", "lemmas l2_inv2I = l2_inv2_def [THEN setc_def_to_intro, rule_format]", "lemmas l2_inv2E [elim] = l2_inv2_def [THEN setc_def_to_elim, rule_format]", "lemmas l2_inv2D = l2_inv2_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]", "lemma l2_inv2_init [iff]:\n  \"init l2 \\<subseteq> l2_inv2\"", "lemma l2_inv2_trans [iff]:\n  \"{l2_inv2} trans l2 {> l2_inv2}\"", "lemma PO_l2_inv2 [iff]: \"reach l2 \\<subseteq> l2_inv2\"", "lemmas l2_inv3I = l2_inv3_def [THEN setc_def_to_intro, rule_format]", "lemmas l2_inv3E [elim] = l2_inv3_def [THEN setc_def_to_elim, rule_format]", "lemmas l2_inv3D = l2_inv3_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]", "lemma l2_inv3_init [iff]:\n  \"init l2 \\<subseteq> l2_inv3\"", "lemma l2_inv3_trans [iff]:\n  \"{l2_inv3} trans l2 {> l2_inv3}\"", "lemma PO_l2_inv3 [iff]: \"reach l2 \\<subseteq> l2_inv3\"", "lemmas l2_inv4I = l2_inv4_def [THEN setc_def_to_intro, rule_format]", "lemmas l2_inv4E [elim] = l2_inv4_def [THEN setc_def_to_elim, rule_format]", "lemmas l2_inv4D = l2_inv4_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]", "lemma l2_inv4_init [iff]:\n  \"init l2 \\<subseteq> l2_inv4\"", "lemma l2_inv4_trans [iff]:\n  \"{l2_inv4 \\<inter> l2_inv3 \\<inter> l2_inv1} trans l2 {> l2_inv4}\"", "lemma PO_l2_inv4 [iff]: \"reach l2 \\<subseteq> l2_inv4\"", "lemmas l2_inv5I = l2_inv5_def [THEN setc_def_to_intro, rule_format]", "lemmas l2_inv5E [elim] = l2_inv5_def [THEN setc_def_to_elim, rule_format]", "lemmas l2_inv5D = l2_inv5_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]", "lemma l2_inv5_init [iff]:\n  \"init l2 \\<subseteq> l2_inv5\"", "lemma l2_inv5_trans [iff]:\n  \"{l2_inv5} trans l2 {> l2_inv5}\"", "lemma PO_l2_inv5 [iff]: \"reach l2 \\<subseteq> l2_inv5\"", "lemmas l2_inv6I = l2_inv6_def [THEN setc_def_to_intro, rule_format]", "lemmas l2_inv6E [elim] = l2_inv6_def [THEN setc_def_to_elim, rule_format]", "lemmas l2_inv6D = l2_inv6_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]", "lemma l2_inv6_init [iff]:\n  \"init l2 \\<subseteq> l2_inv6\"", "lemma l2_inv6_trans [iff]:\n  \"{l2_inv6} trans l2 {> l2_inv6}\"", "lemma PO_l2_inv6 [iff]: \"reach l2 \\<subseteq> l2_inv6\"", "lemma analz_generators: \"analz generators = generators\"", "lemmas l2_inv7I = l2_inv7_def [THEN setc_def_to_intro, rule_format]", "lemmas l2_inv7E [elim] = l2_inv7_def [THEN setc_def_to_elim, rule_format]", "lemmas l2_inv7D = l2_inv7_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]", "lemma l2_inv7_init [iff]:\n  \"init l2 \\<subseteq> l2_inv7\"", "lemma l2_inv7_step1:\n  \"{l2_inv7} l2_step1 Ra A B {> l2_inv7}\"", "lemma l2_inv7_step2:\n  \"{l2_inv1 \\<inter> l2_inv2 \\<inter> l2_inv4 \\<inter> l2_inv7} l2_step2 Rb A B KE {> l2_inv7}\"", "lemma l2_inv7_step3:\n  \"{l2_inv7} l2_step3 Rb A B K {> l2_inv7}\"", "lemma l2_inv7_dy_fake_msg:\n  \"{l2_inv7} l2_dy_fake_msg M {> l2_inv7}\"", "lemma l2_inv7_dy_fake_chan:\n  \"{l2_inv7} l2_dy_fake_chan M {> l2_inv7}\"", "lemma l2_inv7_lkr_others:\n  \"{l2_inv7 \\<inter> l2_inv5} l2_lkr_others A {> l2_inv7}\"", "lemma l2_inv7_lkr_after:\n  \"{l2_inv7 \\<inter> l2_inv5} l2_lkr_after A {> l2_inv7}\"", "lemma l2_inv7_skr:\n  \"{l2_inv7 \\<inter> l2_inv6} l2_skr R K {> l2_inv7}\"", "lemmas l2_inv7_trans_aux =\n  l2_inv7_step1 l2_inv7_step2 l2_inv7_step3\n  l2_inv7_dy_fake_msg l2_inv7_dy_fake_chan\n  l2_inv7_lkr_others l2_inv7_lkr_after l2_inv7_skr", "lemma l2_inv7_trans [iff]:\n  \"{l2_inv7 \\<inter> l2_inv1 \\<inter> l2_inv2 \\<inter> l2_inv4 \\<inter> l2_inv5 \\<inter> l2_inv6} trans l2 {> l2_inv7}\"", "lemma PO_l2_inv7 [iff]: \"reach l2 \\<subseteq> l2_inv7\"", "lemma l2_inv7_aux:\n  \"NonceF (R$sk) \\<in> analz (ik s) \\<Longrightarrow> s \\<in> l2_inv7 \\<Longrightarrow> R \\<noteq> test \\<and> R \\<notin> partners\"", "lemmas l2_inv8I = l2_inv8_def [THEN setc_def_to_intro, rule_format]", "lemmas l2_inv8E [elim] = l2_inv8_def [THEN setc_def_to_elim, rule_format]", "lemmas l2_inv8D = l2_inv8_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]", "lemma l2_inv8_init [iff]:\n  \"init l2 \\<subseteq> l2_inv8\"", "lemma l2_inv8_trans [iff]:\n  \"{l2_inv8 \\<inter> l2_inv1 \\<inter> l2_inv3} trans l2 {> l2_inv8}\"", "lemma PO_l2_inv8 [iff]: \"reach l2 \\<subseteq> l2_inv8\"", "lemmas R12s_defs = R12s_def med12s_def", "lemma can_signal_R12 [simp]:\n  \"(s1, s2) \\<in> R12s \\<Longrightarrow>\n   can_signal s1 A B \\<longleftrightarrow> can_signal s2 A B\"", "lemma l2_step1_refines_step1:\n  \"{R12s} l1_step1 Ra A B, l2_step1 Ra A B {>R12s}\"", "lemma l2_step2_refines_step2:\n  \"{R12s \\<inter> UNIV \\<times> (l2_inv1 \\<inter> l2_inv2 \\<inter> l2_inv7)} \n     l1_step2 Rb A B KE, l2_step2 Rb A B KE \n   {>R12s}\"", "lemma l2_step3_partners:\n  \"guessed_runs test = \\<lparr>role = Init, owner = A, partner = B\\<rparr> \\<Longrightarrow>\n   guessed_frame test xsk = Some (NonceF (Rb$sk)) \\<Longrightarrow>\n   guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr> \\<Longrightarrow>\n   guessed_frame Rb xpkE = Some (epubKF (test $ kE)) \\<Longrightarrow>\n   Rb \\<in> partners\"", "lemma l2_step3_refines_step3:\n  \"{R12s \\<inter> UNIV \\<times> (l2_inv1 \\<inter> l2_inv3 \\<inter> l2_inv7)} \n      l1_step3 Ra A B K, l2_step3 Ra A B K \n   {>R12s}\"", "lemma l2_dy_fake_chan_refines_skip:\n  \"{R12s} Id, l2_dy_fake_chan M {>R12s}\"", "lemma l2_dy_fake_msg_refines_learn:\n  \"{R12s \\<inter> UNIV \\<times> l2_inv7 \\<inter> UNIV \\<times> l2_inv8} l1_learn m, l2_dy_fake_msg m {>R12s}\"", "lemma l2_lkr_others_refines_skip:\n  \"{R12s} Id, l2_lkr_others A {>R12s}\"", "lemma l2_lkr_after_refines_skip:\n  \"{R12s} Id, l2_lkr_after A {>R12s}\"", "lemma l2_skr_refines_learn:\n  \"{R12s \\<inter> UNIV \\<times> l2_inv7 \\<inter> UNIV \\<times> l2_inv6 \\<inter> UNIV \\<times> l2_inv8} l1_learn K, l2_skr R K {>R12s}\"", "lemmas l2_trans_refines_l1_trans = \n  l2_dy_fake_msg_refines_learn l2_dy_fake_chan_refines_skip\n  l2_lkr_others_refines_skip l2_lkr_after_refines_skip l2_skr_refines_learn\n  l2_step1_refines_step1 l2_step2_refines_step2 l2_step3_refines_step3", "lemma l2_refines_init_l1 [iff]:\n  \"init l2 \\<subseteq> R12s `` (init l1)\"", "lemma l2_refines_trans_l1 [iff]:\n  \"{R12s \\<inter> (UNIV \\<times> (l2_inv1 \\<inter> l2_inv2 \\<inter> l2_inv3 \\<inter> l2_inv6 \\<inter> l2_inv7 \\<inter> l2_inv8))} trans l1, trans l2 {> R12s}\"", "lemma PO_obs_consistent_R12s [iff]: \n  \"obs_consistent R12s med12s l1 l2\"", "lemma l2_refines_l1 [iff]:\n  \"refines \n     (R12s \\<inter> \n      (reach l1 \\<times> (l2_inv1 \\<inter> l2_inv2 \\<inter> l2_inv3 \\<inter> l2_inv4 \\<inter> l2_inv5 \\<inter> l2_inv6 \\<inter> l2_inv7 \\<inter> l2_inv8)))\n     med12s l1 l2\"", "lemma l2_implements_l1 [iff]:\n  \"implements med12s l1 l2\"", "lemma l2_obs_partial_secrecy [iff]: \"oreach l2 \\<subseteq> l2_partial_secrecy\"", "lemma l2_oreach_dy_fake_msg:\n  \"s \\<in> oreach l2 \\<Longrightarrow> x \\<in> dy_fake_msg (bad s) (ik s) (chan s) \\<Longrightarrow> s \\<lparr>ik := insert x (ik s)\\<rparr> \\<in> oreach l2\"", "lemma l2_obs_secrecy [iff]: \"oreach l2 \\<subseteq> l2_secrecy\"", "lemma l2_secrecy [iff]: \"reach l2 \\<subseteq> l2_secrecy\"", "lemma l2_obs_iagreement [iff]: \"oreach l2 \\<subseteq> l2_iagreement\"", "lemma l2_iagreement [iff]: \"reach l2 \\<subseteq> l2_iagreement\""], "translations": [["", "lemma role_comp_inv [simp]:\n  \"role_comp (role_comp x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. role_comp (role_comp x) = x", "by (cases x, auto)"], ["", "lemma role_comp_inv_eq:\n  \"y = role_comp x \\<longleftrightarrow> x = role_comp y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y = role_comp x) = (x = role_comp y)", "by (auto elim!: role_comp.elims [OF sym])"], ["", "definition\n  partners :: \"rid_t set\"\nwhere\n  \"partners \\<equiv> {R. partner_runs test R}\""], ["", "lemma test_not_partner [simp]:\n  \"test \\<notin> partners\""], ["proof (prove)\ngoal (1 subgoal):\n 1. test \\<notin> partners", "by (auto simp add: partners_def partner_runs_def, cases \"role (guessed_runs test)\", auto)"], ["", "lemma matching_symmetric:\n  \"matching sigma sigma' \\<Longrightarrow> matching sigma' sigma\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matching sigma sigma' \\<Longrightarrow> matching sigma' sigma", "by (auto simp add: matching_def)"], ["", "lemma partner_symmetric:\n  \"partner_runs R R' \\<Longrightarrow> partner_runs R' R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partner_runs R R' \\<Longrightarrow> partner_runs R' R", "by (auto simp add: partner_runs_def matching_symmetric)"], ["", "lemma partner_unique:\n  \"partner_runs R R'' \\<Longrightarrow> partner_runs R R' \\<Longrightarrow> R' = R''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>partner_runs R R''; partner_runs R R'\\<rbrakk>\n    \\<Longrightarrow> R' = R''", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>partner_runs R R''; partner_runs R R'\\<rbrakk>\n    \\<Longrightarrow> R' = R''", "assume H':\"partner_runs R R'\""], ["proof (state)\nthis:\n  partner_runs R R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>partner_runs R R''; partner_runs R R'\\<rbrakk>\n    \\<Longrightarrow> R' = R''", "then"], ["proof (chain)\npicking this:\n  partner_runs R R'", "have Hm': \"matching (guessed_frame R) (guessed_frame R')\""], ["proof (prove)\nusing this:\n  partner_runs R R'\n\ngoal (1 subgoal):\n 1. matching (guessed_frame R) (guessed_frame R')", "by (auto simp add: partner_runs_def)"], ["proof (state)\nthis:\n  matching (guessed_frame R) (guessed_frame R')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>partner_runs R R''; partner_runs R R'\\<rbrakk>\n    \\<Longrightarrow> R' = R''", "assume H'':\"partner_runs R R''\""], ["proof (state)\nthis:\n  partner_runs R R''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>partner_runs R R''; partner_runs R R'\\<rbrakk>\n    \\<Longrightarrow> R' = R''", "then"], ["proof (chain)\npicking this:\n  partner_runs R R''", "have Hm'': \"matching (guessed_frame R) (guessed_frame R'')\""], ["proof (prove)\nusing this:\n  partner_runs R R''\n\ngoal (1 subgoal):\n 1. matching (guessed_frame R) (guessed_frame R'')", "by (auto simp add: partner_runs_def)"], ["proof (state)\nthis:\n  matching (guessed_frame R) (guessed_frame R'')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>partner_runs R R''; partner_runs R R'\\<rbrakk>\n    \\<Longrightarrow> R' = R''", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. R' = R''", "proof (cases \"role (guessed_runs R')\")"], ["proof (state)\ngoal (2 subgoals):\n 1. role (guessed_runs R') = Init \\<Longrightarrow> R' = R''\n 2. role (guessed_runs R') = Resp \\<Longrightarrow> R' = R''", "case Init"], ["proof (state)\nthis:\n  role (guessed_runs R') = Init\n\ngoal (2 subgoals):\n 1. role (guessed_runs R') = Init \\<Longrightarrow> R' = R''\n 2. role (guessed_runs R') = Resp \\<Longrightarrow> R' = R''", "with H' partner_symmetric [OF H'']"], ["proof (chain)\npicking this:\n  partner_runs R R'\n  partner_runs R'' R\n  role (guessed_runs R') = Init", "have Hrole:\"role (guessed_runs R) = Resp\"\n                                                    \"role (guessed_runs R'') = Init\""], ["proof (prove)\nusing this:\n  partner_runs R R'\n  partner_runs R'' R\n  role (guessed_runs R') = Init\n\ngoal (1 subgoal):\n 1. role (guessed_runs R) = Resp &&& role (guessed_runs R'') = Init", "by (auto simp add: partner_runs_def)"], ["proof (state)\nthis:\n  role (guessed_runs R) = Resp\n  role (guessed_runs R'') = Init\n\ngoal (2 subgoals):\n 1. role (guessed_runs R') = Init \\<Longrightarrow> R' = R''\n 2. role (guessed_runs R') = Resp \\<Longrightarrow> R' = R''", "with Init Hm'"], ["proof (chain)\npicking this:\n  role (guessed_runs R') = Init\n  matching (guessed_frame R) (guessed_frame R')\n  role (guessed_runs R) = Resp\n  role (guessed_runs R'') = Init", "have \"guessed_frame R xpkE = Some (epubKF (R'$kE))\""], ["proof (prove)\nusing this:\n  role (guessed_runs R') = Init\n  matching (guessed_frame R) (guessed_frame R')\n  role (guessed_runs R) = Resp\n  role (guessed_runs R'') = Init\n\ngoal (1 subgoal):\n 1. guessed_frame R xpkE = Some (epubKF (R' $ kE))", "by (simp add: matching_def)"], ["proof (state)\nthis:\n  guessed_frame R xpkE = Some (epubKF (R' $ kE))\n\ngoal (2 subgoals):\n 1. role (guessed_runs R') = Init \\<Longrightarrow> R' = R''\n 2. role (guessed_runs R') = Resp \\<Longrightarrow> R' = R''", "moreover"], ["proof (state)\nthis:\n  guessed_frame R xpkE = Some (epubKF (R' $ kE))\n\ngoal (2 subgoals):\n 1. role (guessed_runs R') = Init \\<Longrightarrow> R' = R''\n 2. role (guessed_runs R') = Resp \\<Longrightarrow> R' = R''", "from Hrole Hm''"], ["proof (chain)\npicking this:\n  role (guessed_runs R) = Resp\n  role (guessed_runs R'') = Init\n  matching (guessed_frame R) (guessed_frame R'')", "have \"guessed_frame R xpkE = Some (epubKF (R''$kE))\""], ["proof (prove)\nusing this:\n  role (guessed_runs R) = Resp\n  role (guessed_runs R'') = Init\n  matching (guessed_frame R) (guessed_frame R'')\n\ngoal (1 subgoal):\n 1. guessed_frame R xpkE = Some (epubKF (R'' $ kE))", "by (simp add: matching_def)"], ["proof (state)\nthis:\n  guessed_frame R xpkE = Some (epubKF (R'' $ kE))\n\ngoal (2 subgoals):\n 1. role (guessed_runs R') = Init \\<Longrightarrow> R' = R''\n 2. role (guessed_runs R') = Resp \\<Longrightarrow> R' = R''", "ultimately"], ["proof (chain)\npicking this:\n  guessed_frame R xpkE = Some (epubKF (R' $ kE))\n  guessed_frame R xpkE = Some (epubKF (R'' $ kE))", "show ?thesis"], ["proof (prove)\nusing this:\n  guessed_frame R xpkE = Some (epubKF (R' $ kE))\n  guessed_frame R xpkE = Some (epubKF (R'' $ kE))\n\ngoal (1 subgoal):\n 1. R' = R''", "by simp"], ["proof (state)\nthis:\n  R' = R''\n\ngoal (1 subgoal):\n 1. role (guessed_runs R') = Resp \\<Longrightarrow> R' = R''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. role (guessed_runs R') = Resp \\<Longrightarrow> R' = R''", "case Resp"], ["proof (state)\nthis:\n  role (guessed_runs R') = Resp\n\ngoal (1 subgoal):\n 1. role (guessed_runs R') = Resp \\<Longrightarrow> R' = R''", "with H' partner_symmetric [OF H'']"], ["proof (chain)\npicking this:\n  partner_runs R R'\n  partner_runs R'' R\n  role (guessed_runs R') = Resp", "have Hrole:\"role (guessed_runs R) = Init\"\n                                                    \"role (guessed_runs R'') = Resp\""], ["proof (prove)\nusing this:\n  partner_runs R R'\n  partner_runs R'' R\n  role (guessed_runs R') = Resp\n\ngoal (1 subgoal):\n 1. role (guessed_runs R) = Init &&& role (guessed_runs R'') = Resp", "by (auto simp add: partner_runs_def)"], ["proof (state)\nthis:\n  role (guessed_runs R) = Init\n  role (guessed_runs R'') = Resp\n\ngoal (1 subgoal):\n 1. role (guessed_runs R') = Resp \\<Longrightarrow> R' = R''", "with Resp Hm'"], ["proof (chain)\npicking this:\n  role (guessed_runs R') = Resp\n  matching (guessed_frame R) (guessed_frame R')\n  role (guessed_runs R) = Init\n  role (guessed_runs R'') = Resp", "have \"guessed_frame R xsk = Some (NonceF (R'$sk))\""], ["proof (prove)\nusing this:\n  role (guessed_runs R') = Resp\n  matching (guessed_frame R) (guessed_frame R')\n  role (guessed_runs R) = Init\n  role (guessed_runs R'') = Resp\n\ngoal (1 subgoal):\n 1. guessed_frame R xsk = Some (NonceF (R' $ sk))", "by (simp add: matching_def)"], ["proof (state)\nthis:\n  guessed_frame R xsk = Some (NonceF (R' $ sk))\n\ngoal (1 subgoal):\n 1. role (guessed_runs R') = Resp \\<Longrightarrow> R' = R''", "moreover"], ["proof (state)\nthis:\n  guessed_frame R xsk = Some (NonceF (R' $ sk))\n\ngoal (1 subgoal):\n 1. role (guessed_runs R') = Resp \\<Longrightarrow> R' = R''", "from Hrole Hm''"], ["proof (chain)\npicking this:\n  role (guessed_runs R) = Init\n  role (guessed_runs R'') = Resp\n  matching (guessed_frame R) (guessed_frame R'')", "have \"guessed_frame R xsk = Some (NonceF (R''$sk))\""], ["proof (prove)\nusing this:\n  role (guessed_runs R) = Init\n  role (guessed_runs R'') = Resp\n  matching (guessed_frame R) (guessed_frame R'')\n\ngoal (1 subgoal):\n 1. guessed_frame R xsk = Some (NonceF (R'' $ sk))", "by (simp add: matching_def)"], ["proof (state)\nthis:\n  guessed_frame R xsk = Some (NonceF (R'' $ sk))\n\ngoal (1 subgoal):\n 1. role (guessed_runs R') = Resp \\<Longrightarrow> R' = R''", "ultimately"], ["proof (chain)\npicking this:\n  guessed_frame R xsk = Some (NonceF (R' $ sk))\n  guessed_frame R xsk = Some (NonceF (R'' $ sk))", "show ?thesis"], ["proof (prove)\nusing this:\n  guessed_frame R xsk = Some (NonceF (R' $ sk))\n  guessed_frame R xsk = Some (NonceF (R'' $ sk))\n\ngoal (1 subgoal):\n 1. R' = R''", "by simp"], ["proof (state)\nthis:\n  R' = R''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R' = R''\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma partner_test:\n  \"R \\<in> partners \\<Longrightarrow> partner_runs R R' \\<Longrightarrow> R' = test\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R \\<in> partners; partner_runs R R'\\<rbrakk>\n    \\<Longrightarrow> R' = test", "by (auto intro!:partner_unique simp add:partners_def partner_symmetric)"], ["", "text \\<open>compromising events\\<close>"], ["", "definition\n  l2_lkr_others :: \"agent \\<Rightarrow> l2_trans\"\nwhere\n  \"l2_lkr_others A \\<equiv> {(s,s').\n    \\<comment> \\<open>guards\\<close>\n    A \\<noteq> test_owner \\<and>\n    A \\<noteq> test_partner \\<and>\n    \\<comment> \\<open>actions\\<close>\n    s' = s\\<lparr>bad := {A} \\<union> bad s\\<rparr>\n  }\""], ["", "definition\n  l2_lkr_actor :: \"agent \\<Rightarrow> l2_trans\"\nwhere\n  \"l2_lkr_actor A \\<equiv> {(s,s').\n    \\<comment> \\<open>guards\\<close>\n    A = test_owner \\<and>\n    A \\<noteq> test_partner \\<and>\n    \\<comment> \\<open>actions\\<close>\n    s' = s\\<lparr>bad := {A} \\<union> bad s\\<rparr>\n  }\""], ["", "definition\n  l2_lkr_after :: \"agent \\<Rightarrow> l2_trans\"\nwhere\n  \"l2_lkr_after A \\<equiv> {(s,s').\n    \\<comment> \\<open>guards\\<close>\n    test_ended s \\<and>\n    \\<comment> \\<open>actions\\<close>\n    s' = s\\<lparr>bad := {A} \\<union> bad s\\<rparr>\n  }\""], ["", "definition\n  l2_skr :: \"rid_t \\<Rightarrow> msg \\<Rightarrow> l2_trans\"\nwhere\n  \"l2_skr R K \\<equiv> {(s,s').\n    \\<comment> \\<open>guards\\<close>\n    R \\<noteq> test \\<and> R \\<notin> partners \\<and>\n    in_progress (progress s R) xsk \\<and>\n    guessed_frame R xsk = Some K \\<and>\n    \\<comment> \\<open>actions\\<close>\n    s' = s\\<lparr>ik := {K} \\<union> ik s\\<rparr>\n  }\""], ["", "text \\<open>protocol events\\<close>"], ["", "definition\n    l2_step1 :: \"rid_t \\<Rightarrow> agent \\<Rightarrow> agent \\<Rightarrow> l2_trans\"\nwhere\n  \"l2_step1 Ra A B \\<equiv> {(s, s').\n    \\<comment> \\<open>guards:\\<close>\n    Ra \\<notin> dom (progress s) \\<and>\n    guessed_runs Ra = \\<lparr>role=Init, owner=A, partner=B\\<rparr> \\<and>\n    \\<comment> \\<open>actions:\\<close>\n    s' = s\\<lparr>\n      progress := (progress s)(Ra \\<mapsto> {xpkE, xskE}),\n      chan := {Auth A B (\\<langle>Number 0, epubKF (Ra$kE)\\<rangle>)} \\<union> (chan s)\n      \\<rparr>\n  }\""], ["", "definition\n  l2_step2 :: \"rid_t \\<Rightarrow> agent \\<Rightarrow> agent \\<Rightarrow> msg \\<Rightarrow> l2_trans\"\nwhere\n  \"l2_step2 Rb A B KE \\<equiv> {(s, s').\n    \\<comment> \\<open>guards:\\<close>\n    guessed_runs Rb = \\<lparr>role=Resp, owner=B, partner=A\\<rparr> \\<and>\n    Rb \\<notin> dom (progress s) \\<and>\n    guessed_frame Rb xpkE = Some KE \\<and>\n    Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s \\<and>\n    \\<comment> \\<open>actions:\\<close>\n    s' = s\\<lparr>\n      progress := (progress s)(Rb \\<mapsto> {xpkE, xsk}),\n      chan := {Auth B A (Aenc (NonceF (Rb$sk)) KE)} \\<union> (chan s),\n      signals := if can_signal s A B then\n                   addSignal (signals s) (Running A B \\<langle>KE, NonceF (Rb$sk)\\<rangle>)\n                 else\n                   signals s,\n      secret := {x. x = NonceF (Rb$sk) \\<and> Rb = test} \\<union> secret s\n         \\<rparr>\n  }\""], ["", "definition\n  l2_step3 :: \"rid_t \\<Rightarrow> agent \\<Rightarrow> agent \\<Rightarrow> msg \\<Rightarrow> l2_trans\"\nwhere\n  \"l2_step3 Ra A B K \\<equiv> {(s, s').\n    \\<comment> \\<open>guards:\\<close>\n    guessed_runs Ra = \\<lparr>role=Init, owner=A, partner=B\\<rparr> \\<and>\n    progress s Ra = Some {xpkE, xskE} \\<and>\n    guessed_frame Ra xsk = Some K \\<and>\n    Auth B A (Aenc K (epubKF (Ra$kE))) \\<in> chan s \\<and>\n    \\<comment> \\<open>actions:\\<close>\n    s' = s\\<lparr> progress := (progress s)(Ra \\<mapsto> {xpkE, xskE, xsk}),\n            signals := if can_signal s A B then\n                         addSignal (signals s) (Commit A B \\<langle>epubKF (Ra$kE),K\\<rangle>)\n                       else\n                         signals s,\n            secret := {x. x = K \\<and> Ra = test} \\<union> secret s\n          \\<rparr>\n  }\""], ["", "text \\<open>specification\\<close>"], ["", "definition \n  l2_init :: \"l2_state set\"\nwhere\n  \"l2_init \\<equiv> { \\<lparr>\n    ik = {},\n    secret = {},\n    progress = Map.empty,\n    signals = \\<lambda>x. 0,\n    chan = {},\n    bad = bad_init\n    \\<rparr>}\""], ["", "definition \n  l2_trans :: \"l2_trans\" where\n  \"l2_trans \\<equiv> (\\<Union>m M KE Rb Ra A B K.\n     l2_step1 Ra A B \\<union>\n     l2_step2 Rb A B KE \\<union>\n     l2_step3 Ra A B m \\<union>\n     l2_dy_fake_chan M \\<union>\n     l2_dy_fake_msg m \\<union>\n     l2_lkr_others A \\<union>\n     l2_lkr_after A \\<union>\n     l2_skr Ra K \\<union>\n     Id\n  )\""], ["", "definition \n  l2 :: \"(l2_state, l2_obs) spec\" where\n  \"l2 \\<equiv> \\<lparr>\n    init = l2_init,\n    trans = l2_trans,\n    obs = id\n  \\<rparr>\""], ["", "lemmas l2_loc_defs = \n  l2_step1_def l2_step2_def l2_step3_def\n  l2_def l2_init_def l2_trans_def\n  l2_dy_fake_chan_def l2_dy_fake_msg_def\n  l2_lkr_after_def l2_lkr_others_def l2_skr_def"], ["", "lemmas l2_defs = l2_loc_defs ik_dy_def"], ["", "lemmas l2_nostep_defs = l2_def l2_init_def l2_trans_def"], ["", "lemma l2_obs_id [simp]: \"obs l2 = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs l2 = id", "by (simp add: l2_def)"], ["", "text \\<open>Once a run is finished, it stays finished, therefore if the test is not finished at some\npoint then it was not finished before either\\<close>"], ["", "declare domIff [iff]"], ["", "lemma l2_run_ended_trans:\n  \"run_ended (progress s R) \\<Longrightarrow>\n   (s, s') \\<in> trans l2 \\<Longrightarrow>\n   run_ended (progress s' R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>run_ended (progress s R); (s, s') \\<in> TS.trans l2\\<rbrakk>\n    \\<Longrightarrow> run_ended (progress s' R)", "apply (auto simp add: l2_nostep_defs)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>xd xe xf.\n       \\<lbrakk>run_ended (progress s R);\n        (s, s') \\<in> l2_step1 xd xe xf\\<rbrakk>\n       \\<Longrightarrow> run_ended (progress s' R)\n 2. \\<And>xb xc xe xf.\n       \\<lbrakk>run_ended (progress s R);\n        (s, s') \\<in> l2_step2 xc xe xf xb\\<rbrakk>\n       \\<Longrightarrow> run_ended (progress s' R)\n 3. \\<And>x xd xe xf.\n       \\<lbrakk>run_ended (progress s R);\n        (s, s') \\<in> l2_step3 xd xe xf x\\<rbrakk>\n       \\<Longrightarrow> run_ended (progress s' R)\n 4. \\<And>xa.\n       \\<lbrakk>run_ended (progress s R);\n        (s, s') \\<in> l2_dy_fake_chan xa\\<rbrakk>\n       \\<Longrightarrow> run_ended (progress s' R)\n 5. \\<And>x.\n       \\<lbrakk>run_ended (progress s R);\n        (s, s') \\<in> l2_dy_fake_msg x\\<rbrakk>\n       \\<Longrightarrow> run_ended (progress s' R)\n 6. \\<And>xe.\n       \\<lbrakk>run_ended (progress s R);\n        (s, s') \\<in> l2_lkr_others xe\\<rbrakk>\n       \\<Longrightarrow> run_ended (progress s' R)\n 7. \\<And>xe.\n       \\<lbrakk>run_ended (progress s R);\n        (s, s') \\<in> l2_lkr_after xe\\<rbrakk>\n       \\<Longrightarrow> run_ended (progress s' R)\n 8. \\<And>xd xe.\n       \\<lbrakk>run_ended (progress s R);\n        (s, s') \\<in> l2_skr xd xe\\<rbrakk>\n       \\<Longrightarrow> run_ended (progress s' R)", "apply (simp add: l2_defs, fast ?)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare domIff [iff del]"], ["", "lemma l2_can_signal_trans:\n  \"can_signal s' A B \\<Longrightarrow>\n  (s, s') \\<in> trans l2 \\<Longrightarrow>\n  can_signal s A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>can_signal s' A B; (s, s') \\<in> TS.trans l2\\<rbrakk>\n    \\<Longrightarrow> can_signal s A B", "by (auto simp add: can_signal_def l2_run_ended_trans)"], ["", "(**************************************************************************************************)"], ["", "subsection \\<open>Invariants\\<close>"], ["", "(**************************************************************************************************)"], ["", "subsubsection \\<open>inv1\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>If @{term \"can_signal s A B\"} (i.e., @{term \"A\"}, @{term \"B\"} are the test session \nagents and the test is not finished), then @{term \"A\"}, @{term \"B\"} are honest.\\<close>"], ["", "definition\n  l2_inv1 :: \"l2_state set\"\nwhere\n  \"l2_inv1 \\<equiv> {s. \\<forall>A B.\n    can_signal s A B \\<longrightarrow>\n    A \\<notin> bad s \\<and> B \\<notin> bad s\n  }\""], ["", "lemmas l2_inv1I = l2_inv1_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas l2_inv1E [elim] = l2_inv1_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas l2_inv1D = l2_inv1_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]"], ["", "lemma l2_inv1_init [iff]:\n  \"init l2 \\<subseteq> l2_inv1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init l2 \\<subseteq> l2_inv1", "by (auto simp add: l2_def l2_init_def l2_inv1_def can_signal_def bad_init_spec)"], ["", "lemma l2_inv1_trans [iff]:\n  \"{l2_inv1} trans l2 {> l2_inv1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l2_inv1} TS.trans l2 {> l2_inv1}", "proof (auto simp add: PO_hoare_defs intro!: l2_inv1I  del: conjI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x A B xa.\n       \\<lbrakk>can_signal x A B; xa \\<in> l2_inv1;\n        (xa, x) \\<in> TS.trans l2\\<rbrakk>\n       \\<Longrightarrow> A \\<notin> bad x \\<and> B \\<notin> bad x", "fix s' s :: l2_state"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x A B xa.\n       \\<lbrakk>can_signal x A B; xa \\<in> l2_inv1;\n        (xa, x) \\<in> TS.trans l2\\<rbrakk>\n       \\<Longrightarrow> A \\<notin> bad x \\<and> B \\<notin> bad x", "fix A B"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x A B xa.\n       \\<lbrakk>can_signal x A B; xa \\<in> l2_inv1;\n        (xa, x) \\<in> TS.trans l2\\<rbrakk>\n       \\<Longrightarrow> A \\<notin> bad x \\<and> B \\<notin> bad x", "assume HI:\"s \\<in> l2_inv1\""], ["proof (state)\nthis:\n  s \\<in> l2_inv1\n\ngoal (1 subgoal):\n 1. \\<And>x A B xa.\n       \\<lbrakk>can_signal x A B; xa \\<in> l2_inv1;\n        (xa, x) \\<in> TS.trans l2\\<rbrakk>\n       \\<Longrightarrow> A \\<notin> bad x \\<and> B \\<notin> bad x", "assume HT:\"(s, s') \\<in> trans l2\""], ["proof (state)\nthis:\n  (s, s') \\<in> TS.trans l2\n\ngoal (1 subgoal):\n 1. \\<And>x A B xa.\n       \\<lbrakk>can_signal x A B; xa \\<in> l2_inv1;\n        (xa, x) \\<in> TS.trans l2\\<rbrakk>\n       \\<Longrightarrow> A \\<notin> bad x \\<and> B \\<notin> bad x", "assume \"can_signal s' A B\""], ["proof (state)\nthis:\n  can_signal s' A B\n\ngoal (1 subgoal):\n 1. \\<And>x A B xa.\n       \\<lbrakk>can_signal x A B; xa \\<in> l2_inv1;\n        (xa, x) \\<in> TS.trans l2\\<rbrakk>\n       \\<Longrightarrow> A \\<notin> bad x \\<and> B \\<notin> bad x", "with HT"], ["proof (chain)\npicking this:\n  (s, s') \\<in> TS.trans l2\n  can_signal s' A B", "have HS:\"can_signal s A B\""], ["proof (prove)\nusing this:\n  (s, s') \\<in> TS.trans l2\n  can_signal s' A B\n\ngoal (1 subgoal):\n 1. can_signal s A B", "by (auto simp add: l2_can_signal_trans)"], ["proof (state)\nthis:\n  can_signal s A B\n\ngoal (1 subgoal):\n 1. \\<And>x A B xa.\n       \\<lbrakk>can_signal x A B; xa \\<in> l2_inv1;\n        (xa, x) \\<in> TS.trans l2\\<rbrakk>\n       \\<Longrightarrow> A \\<notin> bad x \\<and> B \\<notin> bad x", "with HI"], ["proof (chain)\npicking this:\n  s \\<in> l2_inv1\n  can_signal s A B", "have \"A \\<notin> bad s \\<and> B \\<notin> bad s\""], ["proof (prove)\nusing this:\n  s \\<in> l2_inv1\n  can_signal s A B\n\ngoal (1 subgoal):\n 1. A \\<notin> bad s \\<and> B \\<notin> bad s", "by fast"], ["proof (state)\nthis:\n  A \\<notin> bad s \\<and> B \\<notin> bad s\n\ngoal (1 subgoal):\n 1. \\<And>x A B xa.\n       \\<lbrakk>can_signal x A B; xa \\<in> l2_inv1;\n        (xa, x) \\<in> TS.trans l2\\<rbrakk>\n       \\<Longrightarrow> A \\<notin> bad x \\<and> B \\<notin> bad x", "with HS HT"], ["proof (chain)\npicking this:\n  can_signal s A B\n  (s, s') \\<in> TS.trans l2\n  A \\<notin> bad s \\<and> B \\<notin> bad s", "show \"A \\<notin> bad s' \\<and> B \\<notin> bad s'\""], ["proof (prove)\nusing this:\n  can_signal s A B\n  (s, s') \\<in> TS.trans l2\n  A \\<notin> bad s \\<and> B \\<notin> bad s\n\ngoal (1 subgoal):\n 1. A \\<notin> bad s' \\<and> B \\<notin> bad s'", "by (auto simp add: l2_nostep_defs can_signal_def)\n       (simp_all add: l2_defs)"], ["proof (state)\nthis:\n  A \\<notin> bad s' \\<and> B \\<notin> bad s'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma PO_l2_inv1 [iff]: \"reach l2 \\<subseteq> l2_inv1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l2 \\<subseteq> l2_inv1", "by (rule inv_rule_basic) (auto)"], ["", "subsubsection \\<open>inv2 (authentication guard)\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>\n  If @{term \"Auth A B (\\<langle>Number 0, KE\\<rangle>) \\<in> chan s\"} and @{term \"A\"}, @{term \"B\"} are honest\n  then the message has indeed been sent by an initiator run (with the right agents etc.)\\<close>"], ["", "definition\n  l2_inv2 :: \"l2_state set\"\nwhere\n  \"l2_inv2 \\<equiv> {s. \\<forall> A B KE.\n    Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s \\<longrightarrow>\n    A \\<notin> bad s \\<and> B \\<notin> bad s \\<longrightarrow>\n    (\\<exists> Ra.\n      guessed_runs Ra = \\<lparr>role=Init, owner=A, partner=B\\<rparr> \\<and>\n      in_progress (progress s Ra) xpkE \\<and>\n      KE = epubKF (Ra$kE))\n  }\""], ["", "lemmas l2_inv2I = l2_inv2_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas l2_inv2E [elim] = l2_inv2_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas l2_inv2D = l2_inv2_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]"], ["", "lemma l2_inv2_init [iff]:\n  \"init l2 \\<subseteq> l2_inv2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init l2 \\<subseteq> l2_inv2", "by (auto simp add: l2_def l2_init_def l2_inv2_def)"], ["", "lemma l2_inv2_trans [iff]:\n  \"{l2_inv2} trans l2 {> l2_inv2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l2_inv2} TS.trans l2 {> l2_inv2}", "apply (auto simp add: PO_hoare_defs l2_nostep_defs intro!: l2_inv2I)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x A B KE xa xf xg xh.\n       \\<lbrakk>Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan x;\n        xa \\<in> l2_inv2; A \\<notin> bad x; B \\<notin> bad x;\n        (xa, x) \\<in> l2_step1 xf xg xh\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra.\n                            guessed_runs Ra =\n                            \\<lparr>role = Init, owner = A,\n                               partner = B\\<rparr> \\<and>\n                            in_progress (progress x Ra) xpkE \\<and>\n                            KE = epubKF (Ra $ kE)\n 2. \\<And>x A B KE xa xd xe xg xh.\n       \\<lbrakk>Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan x;\n        xa \\<in> l2_inv2; A \\<notin> bad x; B \\<notin> bad x;\n        (xa, x) \\<in> l2_step2 xe xg xh xd\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra.\n                            guessed_runs Ra =\n                            \\<lparr>role = Init, owner = A,\n                               partner = B\\<rparr> \\<and>\n                            in_progress (progress x Ra) xpkE \\<and>\n                            KE = epubKF (Ra $ kE)\n 3. \\<And>x A B KE xa xb xf xg xh.\n       \\<lbrakk>Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan x;\n        xa \\<in> l2_inv2; A \\<notin> bad x; B \\<notin> bad x;\n        (xa, x) \\<in> l2_step3 xf xg xh xb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra.\n                            guessed_runs Ra =\n                            \\<lparr>role = Init, owner = A,\n                               partner = B\\<rparr> \\<and>\n                            in_progress (progress x Ra) xpkE \\<and>\n                            KE = epubKF (Ra $ kE)\n 4. \\<And>x A B KE xa xc.\n       \\<lbrakk>Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan x;\n        xa \\<in> l2_inv2; A \\<notin> bad x; B \\<notin> bad x;\n        (xa, x) \\<in> l2_dy_fake_chan xc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra.\n                            guessed_runs Ra =\n                            \\<lparr>role = Init, owner = A,\n                               partner = B\\<rparr> \\<and>\n                            in_progress (progress x Ra) xpkE \\<and>\n                            KE = epubKF (Ra $ kE)\n 5. \\<And>x A B KE xa xb.\n       \\<lbrakk>Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan x;\n        xa \\<in> l2_inv2; A \\<notin> bad x; B \\<notin> bad x;\n        (xa, x) \\<in> l2_dy_fake_msg xb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra.\n                            guessed_runs Ra =\n                            \\<lparr>role = Init, owner = A,\n                               partner = B\\<rparr> \\<and>\n                            in_progress (progress x Ra) xpkE \\<and>\n                            KE = epubKF (Ra $ kE)\n 6. \\<And>x A B KE xa xg.\n       \\<lbrakk>Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan x;\n        xa \\<in> l2_inv2; A \\<notin> bad x; B \\<notin> bad x;\n        (xa, x) \\<in> l2_lkr_others xg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra.\n                            guessed_runs Ra =\n                            \\<lparr>role = Init, owner = A,\n                               partner = B\\<rparr> \\<and>\n                            in_progress (progress x Ra) xpkE \\<and>\n                            KE = epubKF (Ra $ kE)\n 7. \\<And>x A B KE xa xg.\n       \\<lbrakk>Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan x;\n        xa \\<in> l2_inv2; A \\<notin> bad x; B \\<notin> bad x;\n        (xa, x) \\<in> l2_lkr_after xg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra.\n                            guessed_runs Ra =\n                            \\<lparr>role = Init, owner = A,\n                               partner = B\\<rparr> \\<and>\n                            in_progress (progress x Ra) xpkE \\<and>\n                            KE = epubKF (Ra $ kE)\n 8. \\<And>x A B KE xa xf xg.\n       \\<lbrakk>Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan x;\n        xa \\<in> l2_inv2; A \\<notin> bad x; B \\<notin> bad x;\n        (xa, x) \\<in> l2_skr xf xg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra.\n                            guessed_runs Ra =\n                            \\<lparr>role = Init, owner = A,\n                               partner = B\\<rparr> \\<and>\n                            in_progress (progress x Ra) xpkE \\<and>\n                            KE = epubKF (Ra $ kE)", "apply (auto simp add: l2_defs dy_fake_chan_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>A B KE xa xf xg xh.\n       \\<lbrakk>xa \\<in> l2_inv2; A \\<notin> bad xa; B \\<notin> bad xa;\n        xf \\<notin> dom (progress xa);\n        guessed_runs xf =\n        \\<lparr>role = Init, owner = xg, partner = xh\\<rparr>;\n        Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra.\n                            (Ra = xf \\<longrightarrow>\n                             xg = A \\<and>\n                             xh = B \\<and> KE = epubKF (xf $ kE)) \\<and>\n                            (Ra \\<noteq> xf \\<longrightarrow>\n                             guessed_runs Ra =\n                             \\<lparr>role = Init, owner = A,\n                                partner = B\\<rparr> \\<and>\n                             in_progress (progress xa Ra) xpkE \\<and>\n                             KE = epubKF (Ra $ kE))\n 2. \\<And>A B KE xa xd xe xg xh.\n       \\<lbrakk>Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan xa;\n        xa \\<in> l2_inv2; A \\<notin> bad xa; B \\<notin> bad xa;\n        guessed_runs xe =\n        \\<lparr>role = Resp, owner = xh, partner = xg\\<rparr>;\n        xe \\<notin> dom (progress xa); guessed_frame xe xpkE = Some xd;\n        Auth xg xh \\<langle>Number 0, xd\\<rangle> \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra.\n                            Ra \\<noteq> xe \\<and>\n                            (Ra \\<noteq> xe \\<longrightarrow>\n                             guessed_runs Ra =\n                             \\<lparr>role = Init, owner = A,\n                                partner = B\\<rparr> \\<and>\n                             in_progress (progress xa Ra) xpkE \\<and>\n                             KE = epubKF (Ra $ kE))\n 3. \\<And>A B KE xa xb xf xg xh.\n       \\<lbrakk>Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan xa;\n        xa \\<in> l2_inv2; A \\<notin> bad xa; B \\<notin> bad xa;\n        guessed_runs xf =\n        \\<lparr>role = Init, owner = xg, partner = xh\\<rparr>;\n        progress xa xf = Some {xpkE, xskE}; guessed_frame xf xsk = Some xb;\n        Auth xh xg (Aenc xb (epubKF (xf $ kE))) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra.\n                            (Ra = xf \\<longrightarrow>\n                             xg = A \\<and>\n                             xh = B \\<and> KE = epubKF (xf $ kE)) \\<and>\n                            (Ra \\<noteq> xf \\<longrightarrow>\n                             guessed_runs Ra =\n                             \\<lparr>role = Init, owner = A,\n                                partner = B\\<rparr> \\<and>\n                             in_progress (progress xa Ra) xpkE \\<and>\n                             KE = epubKF (Ra $ kE))\n 4. \\<And>A B KE xa.\n       \\<lbrakk>xa \\<in> l2_inv2; A \\<notin> bad xa; B \\<notin> bad xa;\n        Auth A B \\<langle>Number 0, KE\\<rangle>\n        \\<in> fake (bad xa) (dy_fake_msg (bad xa) (ik xa) (chan xa))\n               (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra.\n                            guessed_runs Ra =\n                            \\<lparr>role = Init, owner = A,\n                               partner = B\\<rparr> \\<and>\n                            in_progress (progress xa Ra) xpkE \\<and>\n                            KE = epubKF (Ra $ kE)", "apply force+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_l2_inv2 [iff]: \"reach l2 \\<subseteq> l2_inv2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l2 \\<subseteq> l2_inv2", "by (rule inv_rule_basic) (auto)"], ["", "subsubsection \\<open>inv3 (authentication guard)\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>If @{term \"Auth B A (Aenc K (epubKF (Ra $ kE))) \\<in> chan s\"}\n and @{term \"A\"}, @{term \"B\"} are honest then the message has indeed been sent by a\n responder run (etc).\\<close>"], ["", "definition\n  l2_inv3 :: \"l2_state set\"\nwhere\n  \"l2_inv3 \\<equiv> {s. \\<forall> Ra A B K.\n     Auth B A (Aenc K (epubKF (Ra $ kE))) \\<in> chan s \\<longrightarrow>\n     A \\<notin> bad s \\<and> B \\<notin> bad s \\<longrightarrow>\n     (\\<exists> Rb.\n       guessed_runs Rb = \\<lparr>role=Resp, owner=B, partner=A\\<rparr> \\<and>\n       progress s Rb = Some {xpkE, xsk} \\<and>\n       guessed_frame Rb xpkE = Some (epubKF (Ra$kE))\\<and>\n       K = NonceF (Rb$sk)\n     )\n    }\""], ["", "lemmas l2_inv3I = l2_inv3_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas l2_inv3E [elim] = l2_inv3_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas l2_inv3D = l2_inv3_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]"], ["", "lemma l2_inv3_init [iff]:\n  \"init l2 \\<subseteq> l2_inv3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init l2 \\<subseteq> l2_inv3", "by (auto simp add: l2_def l2_init_def l2_inv3_def)"], ["", "lemma l2_inv3_trans [iff]:\n  \"{l2_inv3} trans l2 {> l2_inv3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l2_inv3} TS.trans l2 {> l2_inv3}", "apply (auto simp add: PO_hoare_defs l2_nostep_defs intro!: l2_inv3I)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x Ra A B K xa xf xg xh.\n       \\<lbrakk>Auth B A (Aenc K (epubKF (Ra $ kE))) \\<in> chan x;\n        xa \\<in> l2_inv3; A \\<notin> bad x; B \\<notin> bad x;\n        (xa, x) \\<in> l2_step1 xf xg xh\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            guessed_runs Rb =\n                            \\<lparr>role = Resp, owner = B,\n                               partner = A\\<rparr> \\<and>\n                            progress x Rb = Some {xpkE, xsk} \\<and>\n                            guessed_frame Rb xpkE =\n                            Some (epubKF (Ra $ kE)) \\<and>\n                            K = NonceF (Rb $ sk)\n 2. \\<And>x Ra A B K xa xd xe xg xh.\n       \\<lbrakk>Auth B A (Aenc K (epubKF (Ra $ kE))) \\<in> chan x;\n        xa \\<in> l2_inv3; A \\<notin> bad x; B \\<notin> bad x;\n        (xa, x) \\<in> l2_step2 xe xg xh xd\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            guessed_runs Rb =\n                            \\<lparr>role = Resp, owner = B,\n                               partner = A\\<rparr> \\<and>\n                            progress x Rb = Some {xpkE, xsk} \\<and>\n                            guessed_frame Rb xpkE =\n                            Some (epubKF (Ra $ kE)) \\<and>\n                            K = NonceF (Rb $ sk)\n 3. \\<And>x Ra A B K xa xb xf xg xh.\n       \\<lbrakk>Auth B A (Aenc K (epubKF (Ra $ kE))) \\<in> chan x;\n        xa \\<in> l2_inv3; A \\<notin> bad x; B \\<notin> bad x;\n        (xa, x) \\<in> l2_step3 xf xg xh xb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            guessed_runs Rb =\n                            \\<lparr>role = Resp, owner = B,\n                               partner = A\\<rparr> \\<and>\n                            progress x Rb = Some {xpkE, xsk} \\<and>\n                            guessed_frame Rb xpkE =\n                            Some (epubKF (Ra $ kE)) \\<and>\n                            K = NonceF (Rb $ sk)\n 4. \\<And>x Ra A B K xa xc.\n       \\<lbrakk>Auth B A (Aenc K (epubKF (Ra $ kE))) \\<in> chan x;\n        xa \\<in> l2_inv3; A \\<notin> bad x; B \\<notin> bad x;\n        (xa, x) \\<in> l2_dy_fake_chan xc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            guessed_runs Rb =\n                            \\<lparr>role = Resp, owner = B,\n                               partner = A\\<rparr> \\<and>\n                            progress x Rb = Some {xpkE, xsk} \\<and>\n                            guessed_frame Rb xpkE =\n                            Some (epubKF (Ra $ kE)) \\<and>\n                            K = NonceF (Rb $ sk)\n 5. \\<And>x Ra A B K xa xb.\n       \\<lbrakk>Auth B A (Aenc K (epubKF (Ra $ kE))) \\<in> chan x;\n        xa \\<in> l2_inv3; A \\<notin> bad x; B \\<notin> bad x;\n        (xa, x) \\<in> l2_dy_fake_msg xb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            guessed_runs Rb =\n                            \\<lparr>role = Resp, owner = B,\n                               partner = A\\<rparr> \\<and>\n                            progress x Rb = Some {xpkE, xsk} \\<and>\n                            guessed_frame Rb xpkE =\n                            Some (epubKF (Ra $ kE)) \\<and>\n                            K = NonceF (Rb $ sk)\n 6. \\<And>x Ra A B K xa xg.\n       \\<lbrakk>Auth B A (Aenc K (epubKF (Ra $ kE))) \\<in> chan x;\n        xa \\<in> l2_inv3; A \\<notin> bad x; B \\<notin> bad x;\n        (xa, x) \\<in> l2_lkr_others xg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            guessed_runs Rb =\n                            \\<lparr>role = Resp, owner = B,\n                               partner = A\\<rparr> \\<and>\n                            progress x Rb = Some {xpkE, xsk} \\<and>\n                            guessed_frame Rb xpkE =\n                            Some (epubKF (Ra $ kE)) \\<and>\n                            K = NonceF (Rb $ sk)\n 7. \\<And>x Ra A B K xa xg.\n       \\<lbrakk>Auth B A (Aenc K (epubKF (Ra $ kE))) \\<in> chan x;\n        xa \\<in> l2_inv3; A \\<notin> bad x; B \\<notin> bad x;\n        (xa, x) \\<in> l2_lkr_after xg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            guessed_runs Rb =\n                            \\<lparr>role = Resp, owner = B,\n                               partner = A\\<rparr> \\<and>\n                            progress x Rb = Some {xpkE, xsk} \\<and>\n                            guessed_frame Rb xpkE =\n                            Some (epubKF (Ra $ kE)) \\<and>\n                            K = NonceF (Rb $ sk)\n 8. \\<And>x Ra A B K xa xf xg.\n       \\<lbrakk>Auth B A (Aenc K (epubKF (Ra $ kE))) \\<in> chan x;\n        xa \\<in> l2_inv3; A \\<notin> bad x; B \\<notin> bad x;\n        (xa, x) \\<in> l2_skr xf xg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            guessed_runs Rb =\n                            \\<lparr>role = Resp, owner = B,\n                               partner = A\\<rparr> \\<and>\n                            progress x Rb = Some {xpkE, xsk} \\<and>\n                            guessed_frame Rb xpkE =\n                            Some (epubKF (Ra $ kE)) \\<and>\n                            K = NonceF (Rb $ sk)", "apply (auto simp add: l2_defs dy_fake_chan_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Ra A B K xa xf xg xh.\n       \\<lbrakk>Auth B A (Aenc K (epubKF (Ra $ kE))) \\<in> chan xa;\n        xa \\<in> l2_inv3; A \\<notin> bad xa; B \\<notin> bad xa;\n        xf \\<notin> dom (progress xa);\n        guessed_runs xf =\n        \\<lparr>role = Init, owner = xg, partner = xh\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            Rb \\<noteq> xf \\<and>\n                            (Rb \\<noteq> xf \\<longrightarrow>\n                             guessed_runs Rb =\n                             \\<lparr>role = Resp, owner = B,\n                                partner = A\\<rparr> \\<and>\n                             progress xa Rb = Some {xpkE, xsk} \\<and>\n                             guessed_frame Rb xpkE =\n                             Some (epubKF (Ra $ kE)) \\<and>\n                             K = NonceF (Rb $ sk))\n 2. \\<And>Ra A B K xa xd xe xg xh.\n       \\<lbrakk>xa \\<in> l2_inv3; A \\<notin> bad xa; B \\<notin> bad xa;\n        guessed_runs xe =\n        \\<lparr>role = Resp, owner = xh, partner = xg\\<rparr>;\n        xe \\<notin> dom (progress xa); guessed_frame xe xpkE = Some xd;\n        Auth xg xh \\<langle>Number 0, xd\\<rangle> \\<in> chan xa;\n        Auth B A (Aenc K (epubKF (Ra $ kE))) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            (Rb = xe \\<longrightarrow>\n                             xh = B \\<and>\n                             xg = A \\<and>\n                             xd = epubKF (Ra $ kE) \\<and>\n                             K = NonceF (xe $ sk)) \\<and>\n                            (Rb \\<noteq> xe \\<longrightarrow>\n                             guessed_runs Rb =\n                             \\<lparr>role = Resp, owner = B,\n                                partner = A\\<rparr> \\<and>\n                             progress xa Rb = Some {xpkE, xsk} \\<and>\n                             guessed_frame Rb xpkE =\n                             Some (epubKF (Ra $ kE)) \\<and>\n                             K = NonceF (Rb $ sk))\n 3. \\<And>Ra A B K xa xb xf xg xh.\n       \\<lbrakk>Auth B A (Aenc K (epubKF (Ra $ kE))) \\<in> chan xa;\n        xa \\<in> l2_inv3; A \\<notin> bad xa; B \\<notin> bad xa;\n        guessed_runs xf =\n        \\<lparr>role = Init, owner = xg, partner = xh\\<rparr>;\n        progress xa xf = Some {xpkE, xskE}; guessed_frame xf xsk = Some xb;\n        Auth xh xg (Aenc xb (epubKF (xf $ kE))) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            Rb \\<noteq> xf \\<and>\n                            (Rb \\<noteq> xf \\<longrightarrow>\n                             guessed_runs Rb =\n                             \\<lparr>role = Resp, owner = B,\n                                partner = A\\<rparr> \\<and>\n                             progress xa Rb = Some {xpkE, xsk} \\<and>\n                             guessed_frame Rb xpkE =\n                             Some (epubKF (Ra $ kE)) \\<and>\n                             K = NonceF (Rb $ sk))\n 4. \\<And>Ra A B K xa.\n       \\<lbrakk>xa \\<in> l2_inv3; A \\<notin> bad xa; B \\<notin> bad xa;\n        Auth B A (Aenc K (epubKF (Ra $ kE)))\n        \\<in> fake (bad xa) (dy_fake_msg (bad xa) (ik xa) (chan xa))\n               (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            guessed_runs Rb =\n                            \\<lparr>role = Resp, owner = B,\n                               partner = A\\<rparr> \\<and>\n                            progress xa Rb = Some {xpkE, xsk} \\<and>\n                            guessed_frame Rb xpkE =\n                            Some (epubKF (Ra $ kE)) \\<and>\n                            K = NonceF (Rb $ sk)", "apply (simp_all add: domIff)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Ra A B K xa xf xg xh.\n       \\<lbrakk>Auth B A (Aenc K (epubKF (Ra $ kE))) \\<in> chan xa;\n        xa \\<in> l2_inv3; A \\<notin> bad xa; B \\<notin> bad xa;\n        progress xa xf = None;\n        guessed_runs xf =\n        \\<lparr>role = Init, owner = xg, partner = xh\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            Rb \\<noteq> xf \\<and>\n                            (Rb \\<noteq> xf \\<longrightarrow>\n                             guessed_runs Rb =\n                             \\<lparr>role = Resp, owner = B,\n                                partner = A\\<rparr> \\<and>\n                             progress xa Rb = Some {xpkE, xsk} \\<and>\n                             guessed_frame Rb xpkE =\n                             Some (epubKF (Ra $ kE)) \\<and>\n                             K = NonceF (Rb $ sk))\n 2. \\<And>Ra A B K xa xd xe xg xh.\n       \\<lbrakk>xa \\<in> l2_inv3; A \\<notin> bad xa; B \\<notin> bad xa;\n        guessed_runs xe =\n        \\<lparr>role = Resp, owner = xh, partner = xg\\<rparr>;\n        progress xa xe = None; guessed_frame xe xpkE = Some xd;\n        Auth xg xh \\<langle>Number 0, xd\\<rangle> \\<in> chan xa;\n        Auth B A (Aenc K (epubKF (Ra $ kE))) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            (Rb = xe \\<longrightarrow>\n                             xh = B \\<and>\n                             xg = A \\<and>\n                             xd = epubKF (Ra $ kE) \\<and>\n                             K = NonceF (xe $ sk)) \\<and>\n                            (Rb \\<noteq> xe \\<longrightarrow>\n                             guessed_runs Rb =\n                             \\<lparr>role = Resp, owner = B,\n                                partner = A\\<rparr> \\<and>\n                             progress xa Rb = Some {xpkE, xsk} \\<and>\n                             guessed_frame Rb xpkE =\n                             Some (epubKF (Ra $ kE)) \\<and>\n                             K = NonceF (Rb $ sk))\n 3. \\<And>Ra A B K xa xb xf xg xh.\n       \\<lbrakk>Auth B A (Aenc K (epubKF (Ra $ kE))) \\<in> chan xa;\n        xa \\<in> l2_inv3; A \\<notin> bad xa; B \\<notin> bad xa;\n        guessed_runs xf =\n        \\<lparr>role = Init, owner = xg, partner = xh\\<rparr>;\n        progress xa xf = Some {xpkE, xskE}; guessed_frame xf xsk = Some xb;\n        Auth xh xg (Aenc xb (epubKF (xf $ kE))) \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            Rb \\<noteq> xf \\<and>\n                            (Rb \\<noteq> xf \\<longrightarrow>\n                             guessed_runs Rb =\n                             \\<lparr>role = Resp, owner = B,\n                                partner = A\\<rparr> \\<and>\n                             progress xa Rb = Some {xpkE, xsk} \\<and>\n                             guessed_frame Rb xpkE =\n                             Some (epubKF (Ra $ kE)) \\<and>\n                             K = NonceF (Rb $ sk))\n 4. \\<And>Ra A B K xa.\n       \\<lbrakk>xa \\<in> l2_inv3; A \\<notin> bad xa; B \\<notin> bad xa;\n        Auth B A (Aenc K (epubKF (Ra $ kE)))\n        \\<in> fake (bad xa) (dy_fake_msg (bad xa) (ik xa) (chan xa))\n               (chan xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            guessed_runs Rb =\n                            \\<lparr>role = Resp, owner = B,\n                               partner = A\\<rparr> \\<and>\n                            progress xa Rb = Some {xpkE, xsk} \\<and>\n                            guessed_frame Rb xpkE =\n                            Some (epubKF (Ra $ kE)) \\<and>\n                            K = NonceF (Rb $ sk)", "apply force+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_l2_inv3 [iff]: \"reach l2 \\<subseteq> l2_inv3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l2 \\<subseteq> l2_inv3", "by (rule inv_rule_basic) (auto)"], ["", "subsubsection \\<open>inv4\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>If the test run is finished and has the session key generated by a run,\n  then this run is also finished.\\<close>"], ["", "definition\n  l2_inv4 :: \"l2_state set\"\nwhere\n  \"l2_inv4 \\<equiv> {s. \\<forall>Rb.\n    in_progress (progress s test) xsk \\<longrightarrow>\n    guessed_frame test xsk = Some (NonceF (Rb$sk)) \\<longrightarrow>\n    progress s Rb = Some {xpkE, xsk}\n  }\""], ["", "lemmas l2_inv4I = l2_inv4_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas l2_inv4E [elim] = l2_inv4_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas l2_inv4D = l2_inv4_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]"], ["", "lemma l2_inv4_init [iff]:\n  \"init l2 \\<subseteq> l2_inv4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init l2 \\<subseteq> l2_inv4", "by (auto simp add: l2_def l2_init_def l2_inv4_def)"], ["", "lemma l2_inv4_trans [iff]:\n  \"{l2_inv4 \\<inter> l2_inv3 \\<inter> l2_inv1} trans l2 {> l2_inv4}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l2_inv4 \\<inter> l2_inv3 \\<inter> l2_inv1} TS.trans l2 {> l2_inv4}", "apply (auto simp add: PO_hoare_defs l2_nostep_defs intro!: l2_inv4I)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x Rb xa xf xg xh.\n       \\<lbrakk>test_ended x;\n        guessed_frame test xsk = Some (NonceF (Rb $ sk)); xa \\<in> l2_inv1;\n        xa \\<in> l2_inv4; xa \\<in> l2_inv3;\n        (xa, x) \\<in> l2_step1 xf xg xh\\<rbrakk>\n       \\<Longrightarrow> progress x Rb = Some {xpkE, xsk}\n 2. \\<And>x Rb xa xd xe xg xh.\n       \\<lbrakk>test_ended x;\n        guessed_frame test xsk = Some (NonceF (Rb $ sk)); xa \\<in> l2_inv1;\n        xa \\<in> l2_inv4; xa \\<in> l2_inv3;\n        (xa, x) \\<in> l2_step2 xe xg xh xd\\<rbrakk>\n       \\<Longrightarrow> progress x Rb = Some {xpkE, xsk}\n 3. \\<And>x Rb xa xb xf xg xh.\n       \\<lbrakk>test_ended x;\n        guessed_frame test xsk = Some (NonceF (Rb $ sk)); xa \\<in> l2_inv1;\n        xa \\<in> l2_inv4; xa \\<in> l2_inv3;\n        (xa, x) \\<in> l2_step3 xf xg xh xb\\<rbrakk>\n       \\<Longrightarrow> progress x Rb = Some {xpkE, xsk}\n 4. \\<And>x Rb xa xc.\n       \\<lbrakk>test_ended x;\n        guessed_frame test xsk = Some (NonceF (Rb $ sk)); xa \\<in> l2_inv1;\n        xa \\<in> l2_inv4; xa \\<in> l2_inv3;\n        (xa, x) \\<in> l2_dy_fake_chan xc\\<rbrakk>\n       \\<Longrightarrow> progress x Rb = Some {xpkE, xsk}\n 5. \\<And>x Rb xa xb.\n       \\<lbrakk>test_ended x;\n        guessed_frame test xsk = Some (NonceF (Rb $ sk)); xa \\<in> l2_inv1;\n        xa \\<in> l2_inv4; xa \\<in> l2_inv3;\n        (xa, x) \\<in> l2_dy_fake_msg xb\\<rbrakk>\n       \\<Longrightarrow> progress x Rb = Some {xpkE, xsk}\n 6. \\<And>x Rb xa xg.\n       \\<lbrakk>test_ended x;\n        guessed_frame test xsk = Some (NonceF (Rb $ sk)); xa \\<in> l2_inv1;\n        xa \\<in> l2_inv4; xa \\<in> l2_inv3;\n        (xa, x) \\<in> l2_lkr_others xg\\<rbrakk>\n       \\<Longrightarrow> progress x Rb = Some {xpkE, xsk}\n 7. \\<And>x Rb xa xg.\n       \\<lbrakk>test_ended x;\n        guessed_frame test xsk = Some (NonceF (Rb $ sk)); xa \\<in> l2_inv1;\n        xa \\<in> l2_inv4; xa \\<in> l2_inv3;\n        (xa, x) \\<in> l2_lkr_after xg\\<rbrakk>\n       \\<Longrightarrow> progress x Rb = Some {xpkE, xsk}\n 8. \\<And>x Rb xa xf xg.\n       \\<lbrakk>test_ended x;\n        guessed_frame test xsk = Some (NonceF (Rb $ sk)); xa \\<in> l2_inv1;\n        xa \\<in> l2_inv4; xa \\<in> l2_inv3;\n        (xa, x) \\<in> l2_skr xf xg\\<rbrakk>\n       \\<Longrightarrow> progress x Rb = Some {xpkE, xsk}", "apply (auto simp add: l2_defs dy_fake_chan_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>xa xf xg xh.\n       \\<lbrakk>guessed_frame test xsk = Some (NonceF (xf $ sk));\n        xa \\<in> l2_inv1; xa \\<in> l2_inv4; xa \\<in> l2_inv3;\n        test \\<noteq> xf; xf \\<notin> dom (progress xa);\n        guessed_runs xf =\n        \\<lparr>role = Init, owner = xg, partner = xh\\<rparr>;\n        test_ended xa\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>xa xf xg xh.\n       \\<lbrakk>guessed_frame test xsk = Some (NonceF (xf $ sk));\n        xa \\<in> l2_inv1; xa \\<in> l2_inv4; xa \\<in> l2_inv3;\n        test \\<noteq> xf; xf \\<notin> dom (progress xa);\n        guessed_runs xf =\n        \\<lparr>role = Init, owner = xg, partner = xh\\<rparr>;\n        test_ended xa\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>xa xg xh.\n       \\<lbrakk>guessed_frame test xsk = Some (NonceF (test $ sk));\n        xa \\<in> l2_inv1; xa \\<in> l2_inv4; xa \\<in> l2_inv3;\n        guessed_runs test =\n        \\<lparr>role = Init, owner = xg, partner = xh\\<rparr>;\n        progress xa test = Some {xpkE, xskE};\n        Auth xh xg (Aenc (NonceF (test $ sk)) (epubKF (test $ kE)))\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>Rb xa xg xh.\n       \\<lbrakk>guessed_frame test xsk = Some (NonceF (Rb $ sk));\n        xa \\<in> l2_inv1; xa \\<in> l2_inv4; xa \\<in> l2_inv3;\n        guessed_runs test =\n        \\<lparr>role = Init, owner = xg, partner = xh\\<rparr>;\n        progress xa test = Some {xpkE, xskE};\n        Auth xh xg (Aenc (NonceF (Rb $ sk)) (epubKF (test $ kE)))\n        \\<in> chan xa;\n        Rb \\<noteq> test\\<rbrakk>\n       \\<Longrightarrow> progress xa Rb = Some {xpkE, xsk}\n 5. \\<And>xa xb xf xg xh.\n       \\<lbrakk>guessed_frame test xsk = Some (NonceF (xf $ sk));\n        xa \\<in> l2_inv1; xa \\<in> l2_inv4; xa \\<in> l2_inv3;\n        test \\<noteq> xf;\n        guessed_runs xf =\n        \\<lparr>role = Init, owner = xg, partner = xh\\<rparr>;\n        progress xa xf = Some {xpkE, xskE}; guessed_frame xf xsk = Some xb;\n        Auth xh xg (Aenc xb (epubKF (xf $ kE))) \\<in> chan xa;\n        test_ended xa\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto dest!: l2_inv4D simp add: domIff can_signal_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa xg xh.\n       \\<lbrakk>guessed_frame test xsk = Some (NonceF (test $ sk));\n        xa \\<in> l2_inv1; xa \\<in> l2_inv4; xa \\<in> l2_inv3;\n        guessed_runs test =\n        \\<lparr>role = Init, owner = xg, partner = xh\\<rparr>;\n        progress xa test = Some {xpkE, xskE};\n        Auth xh xg (Aenc (NonceF (test $ sk)) (epubKF (test $ kE)))\n        \\<in> chan xa\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Rb xa xg xh.\n       \\<lbrakk>guessed_frame test xsk = Some (NonceF (Rb $ sk));\n        xa \\<in> l2_inv1; xa \\<in> l2_inv4; xa \\<in> l2_inv3;\n        guessed_runs test =\n        \\<lparr>role = Init, owner = xg, partner = xh\\<rparr>;\n        progress xa test = Some {xpkE, xskE};\n        Auth xh xg (Aenc (NonceF (Rb $ sk)) (epubKF (test $ kE)))\n        \\<in> chan xa;\n        Rb \\<noteq> test\\<rbrakk>\n       \\<Longrightarrow> progress xa Rb = Some {xpkE, xsk}\n 3. \\<And>xa xb xf xg xh.\n       \\<lbrakk>guessed_frame test xsk = Some (NonceF (xf $ sk));\n        xa \\<in> l2_inv1; xa \\<in> l2_inv4; xa \\<in> l2_inv3;\n        test \\<noteq> xf;\n        guessed_runs xf =\n        \\<lparr>role = Init, owner = xg, partner = xh\\<rparr>;\n        {xpkE, xsk} = {xpkE, xskE}; guessed_frame xf xsk = Some xb;\n        Auth xh xg (Aenc xb (epubKF (xf $ kE))) \\<in> chan xa;\n        progress xa xf = Some {xpkE, xskE}\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto dest!: l2_inv3D intro!:l2_inv1D simp add: can_signal_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_l2_inv4 [iff]: \"reach l2 \\<subseteq> l2_inv4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l2 \\<subseteq> l2_inv4", "by (rule_tac J=\"l2_inv3 \\<inter> l2_inv1\" in inv_rule_incr) (auto)"], ["", "subsubsection \\<open>inv5\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>The only confidential or secure messages on the channel have been put there\n  by the attacker.\\<close>"], ["", "definition\n  l2_inv5 :: \"l2_state set\"\nwhere\n  \"l2_inv5 \\<equiv> {s. \\<forall>A B M.\n    (Confid A B M \\<in> chan s \\<or> Secure A B M \\<in> chan s) \\<longrightarrow> \n    M \\<in> dy_fake_msg (bad s) (ik s) (chan s)\n  }\""], ["", "lemmas l2_inv5I = l2_inv5_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas l2_inv5E [elim] = l2_inv5_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas l2_inv5D = l2_inv5_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]"], ["", "lemma l2_inv5_init [iff]:\n  \"init l2 \\<subseteq> l2_inv5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init l2 \\<subseteq> l2_inv5", "by (auto simp add: l2_def l2_init_def l2_inv5_def)"], ["", "lemma l2_inv5_trans [iff]:\n  \"{l2_inv5} trans l2 {> l2_inv5}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l2_inv5} TS.trans l2 {> l2_inv5}", "apply (auto simp add: PO_hoare_defs l2_nostep_defs intro!: l2_inv5I)"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>x A B M xa xf xg xh.\n       \\<lbrakk>xa \\<in> l2_inv5; Confid A B M \\<in> chan x;\n        (xa, x) \\<in> l2_step1 xf xg xh\\<rbrakk>\n       \\<Longrightarrow> M \\<in> dy_fake_msg (bad x) (ik x) (chan x)\n 2. \\<And>x A B M xa xd xe xg xh.\n       \\<lbrakk>xa \\<in> l2_inv5; Confid A B M \\<in> chan x;\n        (xa, x) \\<in> l2_step2 xe xg xh xd\\<rbrakk>\n       \\<Longrightarrow> M \\<in> dy_fake_msg (bad x) (ik x) (chan x)\n 3. \\<And>x A B M xa xb xf xg xh.\n       \\<lbrakk>xa \\<in> l2_inv5; Confid A B M \\<in> chan x;\n        (xa, x) \\<in> l2_step3 xf xg xh xb\\<rbrakk>\n       \\<Longrightarrow> M \\<in> dy_fake_msg (bad x) (ik x) (chan x)\n 4. \\<And>x A B M xa xc.\n       \\<lbrakk>xa \\<in> l2_inv5; Confid A B M \\<in> chan x;\n        (xa, x) \\<in> l2_dy_fake_chan xc\\<rbrakk>\n       \\<Longrightarrow> M \\<in> dy_fake_msg (bad x) (ik x) (chan x)\n 5. \\<And>x A B M xa xb.\n       \\<lbrakk>xa \\<in> l2_inv5; Confid A B M \\<in> chan x;\n        (xa, x) \\<in> l2_dy_fake_msg xb\\<rbrakk>\n       \\<Longrightarrow> M \\<in> dy_fake_msg (bad x) (ik x) (chan x)\n 6. \\<And>x A B M xa xg.\n       \\<lbrakk>xa \\<in> l2_inv5; Confid A B M \\<in> chan x;\n        (xa, x) \\<in> l2_lkr_others xg\\<rbrakk>\n       \\<Longrightarrow> M \\<in> dy_fake_msg (bad x) (ik x) (chan x)\n 7. \\<And>x A B M xa xg.\n       \\<lbrakk>xa \\<in> l2_inv5; Confid A B M \\<in> chan x;\n        (xa, x) \\<in> l2_lkr_after xg\\<rbrakk>\n       \\<Longrightarrow> M \\<in> dy_fake_msg (bad x) (ik x) (chan x)\n 8. \\<And>x A B M xa xf xg.\n       \\<lbrakk>xa \\<in> l2_inv5; Confid A B M \\<in> chan x;\n        (xa, x) \\<in> l2_skr xf xg\\<rbrakk>\n       \\<Longrightarrow> M \\<in> dy_fake_msg (bad x) (ik x) (chan x)\n 9. \\<And>x A B M xa xf xg xh.\n       \\<lbrakk>xa \\<in> l2_inv5; Secure A B M \\<in> chan x;\n        (xa, x) \\<in> l2_step1 xf xg xh\\<rbrakk>\n       \\<Longrightarrow> M \\<in> dy_fake_msg (bad x) (ik x) (chan x)\n 10. \\<And>x A B M xa xd xe xg xh.\n        \\<lbrakk>xa \\<in> l2_inv5; Secure A B M \\<in> chan x;\n         (xa, x) \\<in> l2_step2 xe xg xh xd\\<rbrakk>\n        \\<Longrightarrow> M \\<in> dy_fake_msg (bad x) (ik x) (chan x)\nA total of 16 subgoals...", "apply (auto simp add: l2_defs dy_fake_chan_def intro: l2_inv5D dy_fake_msg_monotone)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_l2_inv5 [iff]: \"reach l2 \\<subseteq> l2_inv5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l2 \\<subseteq> l2_inv5", "by (rule inv_rule_basic) (auto)"], ["", "subsubsection \\<open>inv6\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>If an initiator @{term \"Ra\"} knows a session key @{term \"K\"}, then the attacker\n  knows @{term \"Aenc K (epubKF (Ra$kE))\"}.\\<close>"], ["", "definition\n  l2_inv6 :: \"l2_state set\"\nwhere\n  \"l2_inv6 \\<equiv> {s. \\<forall>Ra K.\n    role (guessed_runs Ra) = Init \\<longrightarrow>\n    in_progress (progress s Ra) xsk \\<longrightarrow>\n    guessed_frame Ra xsk = Some K \\<longrightarrow>\n    Aenc K (epubKF (Ra$kE)) \\<in> extr (bad s) (ik s) (chan s)\n  }\""], ["", "lemmas l2_inv6I = l2_inv6_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas l2_inv6E [elim] = l2_inv6_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas l2_inv6D = l2_inv6_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]"], ["", "lemma l2_inv6_init [iff]:\n  \"init l2 \\<subseteq> l2_inv6\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init l2 \\<subseteq> l2_inv6", "by (auto simp add: l2_def l2_init_def l2_inv6_def)"], ["", "lemma l2_inv6_trans [iff]:\n  \"{l2_inv6} trans l2 {> l2_inv6}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l2_inv6} TS.trans l2 {> l2_inv6}", "apply (auto simp add: PO_hoare_defs l2_nostep_defs intro!: l2_inv6I)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x Ra K xa xf xg xh.\n       \\<lbrakk>role (guessed_runs Ra) = Init; run_ended (progress x Ra);\n        guessed_frame Ra xsk = Some K; xa \\<in> l2_inv6;\n        (xa, x) \\<in> l2_step1 xf xg xh\\<rbrakk>\n       \\<Longrightarrow> Aenc K (epubKF (Ra $ kE))\n                         \\<in> extr (bad x) (ik x) (chan x)\n 2. \\<And>x Ra K xa xd xe xg xh.\n       \\<lbrakk>role (guessed_runs Ra) = Init; run_ended (progress x Ra);\n        guessed_frame Ra xsk = Some K; xa \\<in> l2_inv6;\n        (xa, x) \\<in> l2_step2 xe xg xh xd\\<rbrakk>\n       \\<Longrightarrow> Aenc K (epubKF (Ra $ kE))\n                         \\<in> extr (bad x) (ik x) (chan x)\n 3. \\<And>x Ra K xa xb xf xg xh.\n       \\<lbrakk>role (guessed_runs Ra) = Init; run_ended (progress x Ra);\n        guessed_frame Ra xsk = Some K; xa \\<in> l2_inv6;\n        (xa, x) \\<in> l2_step3 xf xg xh xb\\<rbrakk>\n       \\<Longrightarrow> Aenc K (epubKF (Ra $ kE))\n                         \\<in> extr (bad x) (ik x) (chan x)\n 4. \\<And>x Ra K xa xc.\n       \\<lbrakk>role (guessed_runs Ra) = Init; run_ended (progress x Ra);\n        guessed_frame Ra xsk = Some K; xa \\<in> l2_inv6;\n        (xa, x) \\<in> l2_dy_fake_chan xc\\<rbrakk>\n       \\<Longrightarrow> Aenc K (epubKF (Ra $ kE))\n                         \\<in> extr (bad x) (ik x) (chan x)\n 5. \\<And>x Ra K xa xb.\n       \\<lbrakk>role (guessed_runs Ra) = Init; run_ended (progress x Ra);\n        guessed_frame Ra xsk = Some K; xa \\<in> l2_inv6;\n        (xa, x) \\<in> l2_dy_fake_msg xb\\<rbrakk>\n       \\<Longrightarrow> Aenc K (epubKF (Ra $ kE))\n                         \\<in> extr (bad x) (ik x) (chan x)\n 6. \\<And>x Ra K xa xg.\n       \\<lbrakk>role (guessed_runs Ra) = Init; run_ended (progress x Ra);\n        guessed_frame Ra xsk = Some K; xa \\<in> l2_inv6;\n        (xa, x) \\<in> l2_lkr_others xg\\<rbrakk>\n       \\<Longrightarrow> Aenc K (epubKF (Ra $ kE))\n                         \\<in> extr (bad x) (ik x) (chan x)\n 7. \\<And>x Ra K xa xg.\n       \\<lbrakk>role (guessed_runs Ra) = Init; run_ended (progress x Ra);\n        guessed_frame Ra xsk = Some K; xa \\<in> l2_inv6;\n        (xa, x) \\<in> l2_lkr_after xg\\<rbrakk>\n       \\<Longrightarrow> Aenc K (epubKF (Ra $ kE))\n                         \\<in> extr (bad x) (ik x) (chan x)\n 8. \\<And>x Ra K xa xf xg.\n       \\<lbrakk>role (guessed_runs Ra) = Init; run_ended (progress x Ra);\n        guessed_frame Ra xsk = Some K; xa \\<in> l2_inv6;\n        (xa, x) \\<in> l2_skr xf xg\\<rbrakk>\n       \\<Longrightarrow> Aenc K (epubKF (Ra $ kE))\n                         \\<in> extr (bad x) (ik x) (chan x)", "apply (auto simp add: l2_defs dy_fake_chan_def dest: l2_inv6D)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_l2_inv6 [iff]: \"reach l2 \\<subseteq> l2_inv6\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l2 \\<subseteq> l2_inv6", "by (rule inv_rule_basic) (auto)"], ["", "subsubsection \\<open>inv7\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>Form of the messages in @{term \"extr (bad s) (ik s) (chan s)\"} =\n  @{term \"synth (analz (generators))\"}.\\<close>"], ["", "abbreviation\n  \"generators \\<equiv> range epubK \\<union>\n         {Aenc (NonceF (Rb $ sk)) (epubKF (Ra$kE)) |Ra Rb. \\<exists> A B.\n            guessed_runs Ra = \\<lparr>role=Init, owner=A, partner=B\\<rparr> \\<and>\n            guessed_runs Rb = \\<lparr>role=Resp, owner=B, partner=A\\<rparr> \\<and>\n            guessed_frame Rb xpkE = Some (epubKF (Ra$kE))} \\<union>\n         {NonceF (R $ sk) |R. R \\<noteq> test \\<and> R \\<notin> partners}\""], ["", "lemma analz_generators: \"analz generators = generators\""], ["proof (prove)\ngoal (1 subgoal):\n 1. analz generators = generators", "by (rule, rule, erule analz.induct, auto)"], ["", "definition\n  l2_inv7 :: \"l2_state set\"\nwhere\n  \"l2_inv7 \\<equiv> {s. \n    extr (bad s) (ik s) (chan s) \\<subseteq> \n      synth (analz (generators))\n  }\""], ["", "lemmas l2_inv7I = l2_inv7_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas l2_inv7E [elim] = l2_inv7_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas l2_inv7D = l2_inv7_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]"], ["", "lemma l2_inv7_init [iff]:\n  \"init l2 \\<subseteq> l2_inv7\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init l2 \\<subseteq> l2_inv7", "by (auto simp add: l2_def l2_init_def l2_inv7_def)"], ["", "lemma l2_inv7_step1:\n  \"{l2_inv7} l2_step1 Ra A B {> l2_inv7}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l2_inv7} l2_step1 Ra A B {> l2_inv7}", "apply (auto simp add: PO_hoare_defs l2_defs intro!: l2_inv7I)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xb.\n       \\<lbrakk>xb \\<in> l2_inv7; Ra \\<notin> dom (progress xb);\n        guessed_runs Ra =\n        \\<lparr>role = Init, owner = A, partner = B\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> epubKF (Ra $ kE) \\<in> analz generators\n 2. \\<And>xa xb.\n       \\<lbrakk>xb \\<in> l2_inv7; Ra \\<notin> dom (progress xb);\n        guessed_runs Ra =\n        \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        xa \\<in> extr (bad xb) (ik xb) (chan xb)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> synth (analz generators)", "apply (auto dest: l2_inv7D [THEN [2] rev_subsetD])+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma l2_inv7_step2:\n  \"{l2_inv1 \\<inter> l2_inv2 \\<inter> l2_inv4 \\<inter> l2_inv7} l2_step2 Rb A B KE {> l2_inv7}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l2_inv1 \\<inter> l2_inv2 \\<inter> l2_inv4 \\<inter>\n     l2_inv7} l2_step2 Rb A B KE {> l2_inv7}", "proof (auto simp add: PO_hoare_defs l2_nostep_defs intro!: l2_inv7I)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>xa \\<in> extr (bad x) (ik x) (chan x);\n        (xb, x) \\<in> l2_step2 Rb A B KE; xb \\<in> l2_inv7;\n        xb \\<in> l2_inv4; xb \\<in> l2_inv1; xb \\<in> l2_inv2\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> synth (analz generators)", "fix s' s :: l2_state"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>xa \\<in> extr (bad x) (ik x) (chan x);\n        (xb, x) \\<in> l2_step2 Rb A B KE; xb \\<in> l2_inv7;\n        xb \\<in> l2_inv4; xb \\<in> l2_inv1; xb \\<in> l2_inv2\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> synth (analz generators)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>xa \\<in> extr (bad x) (ik x) (chan x);\n        (xb, x) \\<in> l2_step2 Rb A B KE; xb \\<in> l2_inv7;\n        xb \\<in> l2_inv4; xb \\<in> l2_inv1; xb \\<in> l2_inv2\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> synth (analz generators)", "assume Hx:\"x \\<in> extr (bad s') (ik s') (chan s')\""], ["proof (state)\nthis:\n  x \\<in> extr (bad s') (ik s') (chan s')\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>xa \\<in> extr (bad x) (ik x) (chan x);\n        (xb, x) \\<in> l2_step2 Rb A B KE; xb \\<in> l2_inv7;\n        xb \\<in> l2_inv4; xb \\<in> l2_inv1; xb \\<in> l2_inv2\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> synth (analz generators)", "assume Hi:\"s \\<in> l2_inv7\""], ["proof (state)\nthis:\n  s \\<in> l2_inv7\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>xa \\<in> extr (bad x) (ik x) (chan x);\n        (xb, x) \\<in> l2_step2 Rb A B KE; xb \\<in> l2_inv7;\n        xb \\<in> l2_inv4; xb \\<in> l2_inv1; xb \\<in> l2_inv2\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> synth (analz generators)", "assume Hi':\"s \\<in> l2_inv1\""], ["proof (state)\nthis:\n  s \\<in> l2_inv1\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>xa \\<in> extr (bad x) (ik x) (chan x);\n        (xb, x) \\<in> l2_step2 Rb A B KE; xb \\<in> l2_inv7;\n        xb \\<in> l2_inv4; xb \\<in> l2_inv1; xb \\<in> l2_inv2\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> synth (analz generators)", "assume Hi'':\"s \\<in> l2_inv2\""], ["proof (state)\nthis:\n  s \\<in> l2_inv2\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>xa \\<in> extr (bad x) (ik x) (chan x);\n        (xb, x) \\<in> l2_step2 Rb A B KE; xb \\<in> l2_inv7;\n        xb \\<in> l2_inv4; xb \\<in> l2_inv1; xb \\<in> l2_inv2\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> synth (analz generators)", "assume Hi''':\"s \\<in> l2_inv4\""], ["proof (state)\nthis:\n  s \\<in> l2_inv4\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>xa \\<in> extr (bad x) (ik x) (chan x);\n        (xb, x) \\<in> l2_step2 Rb A B KE; xb \\<in> l2_inv7;\n        xb \\<in> l2_inv4; xb \\<in> l2_inv1; xb \\<in> l2_inv2\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> synth (analz generators)", "assume Hs:\"(s, s') \\<in> l2_step2 Rb A B KE\""], ["proof (state)\nthis:\n  (s, s') \\<in> l2_step2 Rb A B KE\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>xa \\<in> extr (bad x) (ik x) (chan x);\n        (xb, x) \\<in> l2_step2 Rb A B KE; xb \\<in> l2_inv7;\n        xb \\<in> l2_inv4; xb \\<in> l2_inv1; xb \\<in> l2_inv2\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> synth (analz generators)", "from Hx Hi Hs"], ["proof (chain)\npicking this:\n  x \\<in> extr (bad s') (ik s') (chan s')\n  s \\<in> l2_inv7\n  (s, s') \\<in> l2_step2 Rb A B KE", "show \" x \\<in> synth (analz (generators))\""], ["proof (prove)\nusing this:\n  x \\<in> extr (bad s') (ik s') (chan s')\n  s \\<in> l2_inv7\n  (s, s') \\<in> l2_step2 Rb A B KE\n\ngoal (1 subgoal):\n 1. x \\<in> synth (analz generators)", "proof (auto simp add: l2_defs dest: l2_inv7D [THEN [2] rev_subsetD])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<in> l2_inv7; can_signal s A B;\n     guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n     Rb \\<notin> dom (progress s); guessed_frame Rb xpkE = Some KE;\n     Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s;\n     s' = s\n     \\<lparr>progress := progress s(Rb \\<mapsto> {xpkE, xsk}),\n        chan := insert (Auth B A (Aenc (NonceF (Rb $ sk)) KE)) (chan s),\n        l1_state.signals := (l1_state.signals s)\n          (Running A B \\<langle>KE, NonceF (Rb $ sk)\\<rangle> :=\n             Suc (l1_state.signals s\n                   (Running A B \\<langle>KE, NonceF (Rb $ sk)\\<rangle>))),\n        secret :=\n          {x. x = NonceF (Rb $ sk) \\<and> Rb = test} \\<union>\n          secret s\\<rparr>;\n     x = Aenc (NonceF (Rb $ sk)) KE\\<rbrakk>\n    \\<Longrightarrow> Aenc (NonceF (Rb $ sk)) KE\n                      \\<in> synth (analz generators)\n 2. \\<lbrakk>s \\<in> l2_inv7; \\<not> can_signal s A B;\n     guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n     Rb \\<notin> dom (progress s); guessed_frame Rb xpkE = Some KE;\n     Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s;\n     s' = s\n     \\<lparr>progress := progress s(Rb \\<mapsto> {xpkE, xsk}),\n        chan := insert (Auth B A (Aenc (NonceF (Rb $ sk)) KE)) (chan s),\n        secret :=\n          {x. x = NonceF (Rb $ sk) \\<and> Rb = test} \\<union>\n          secret s\\<rparr>;\n     x = Aenc (NonceF (Rb $ sk)) KE\\<rbrakk>\n    \\<Longrightarrow> Aenc (NonceF (Rb $ sk)) KE\n                      \\<in> synth (analz generators)", "txt \\<open>first case: @{term \"can_signal s A B\"}, which implies that @{term \"A\"}, @{term \"B\"} are\n      honest, and therefore the public key received by @{term \"B\"} is not from the attacker,\n      which proves that the\n      message added to the channel is in @{term \"{z. \\<exists>x k. z = Aenc x (epubKF k)}\"}\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<in> l2_inv7; can_signal s A B;\n     guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n     Rb \\<notin> dom (progress s); guessed_frame Rb xpkE = Some KE;\n     Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s;\n     s' = s\n     \\<lparr>progress := progress s(Rb \\<mapsto> {xpkE, xsk}),\n        chan := insert (Auth B A (Aenc (NonceF (Rb $ sk)) KE)) (chan s),\n        l1_state.signals := (l1_state.signals s)\n          (Running A B \\<langle>KE, NonceF (Rb $ sk)\\<rangle> :=\n             Suc (l1_state.signals s\n                   (Running A B \\<langle>KE, NonceF (Rb $ sk)\\<rangle>))),\n        secret :=\n          {x. x = NonceF (Rb $ sk) \\<and> Rb = test} \\<union>\n          secret s\\<rparr>;\n     x = Aenc (NonceF (Rb $ sk)) KE\\<rbrakk>\n    \\<Longrightarrow> Aenc (NonceF (Rb $ sk)) KE\n                      \\<in> synth (analz generators)\n 2. \\<lbrakk>s \\<in> l2_inv7; \\<not> can_signal s A B;\n     guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n     Rb \\<notin> dom (progress s); guessed_frame Rb xpkE = Some KE;\n     Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s;\n     s' = s\n     \\<lparr>progress := progress s(Rb \\<mapsto> {xpkE, xsk}),\n        chan := insert (Auth B A (Aenc (NonceF (Rb $ sk)) KE)) (chan s),\n        secret :=\n          {x. x = NonceF (Rb $ sk) \\<and> Rb = test} \\<union>\n          secret s\\<rparr>;\n     x = Aenc (NonceF (Rb $ sk)) KE\\<rbrakk>\n    \\<Longrightarrow> Aenc (NonceF (Rb $ sk)) KE\n                      \\<in> synth (analz generators)", "assume Hc:\"Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s\""], ["proof (state)\nthis:\n  Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<in> l2_inv7; can_signal s A B;\n     guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n     Rb \\<notin> dom (progress s); guessed_frame Rb xpkE = Some KE;\n     Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s;\n     s' = s\n     \\<lparr>progress := progress s(Rb \\<mapsto> {xpkE, xsk}),\n        chan := insert (Auth B A (Aenc (NonceF (Rb $ sk)) KE)) (chan s),\n        l1_state.signals := (l1_state.signals s)\n          (Running A B \\<langle>KE, NonceF (Rb $ sk)\\<rangle> :=\n             Suc (l1_state.signals s\n                   (Running A B \\<langle>KE, NonceF (Rb $ sk)\\<rangle>))),\n        secret :=\n          {x. x = NonceF (Rb $ sk) \\<and> Rb = test} \\<union>\n          secret s\\<rparr>;\n     x = Aenc (NonceF (Rb $ sk)) KE\\<rbrakk>\n    \\<Longrightarrow> Aenc (NonceF (Rb $ sk)) KE\n                      \\<in> synth (analz generators)\n 2. \\<lbrakk>s \\<in> l2_inv7; \\<not> can_signal s A B;\n     guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n     Rb \\<notin> dom (progress s); guessed_frame Rb xpkE = Some KE;\n     Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s;\n     s' = s\n     \\<lparr>progress := progress s(Rb \\<mapsto> {xpkE, xsk}),\n        chan := insert (Auth B A (Aenc (NonceF (Rb $ sk)) KE)) (chan s),\n        secret :=\n          {x. x = NonceF (Rb $ sk) \\<and> Rb = test} \\<union>\n          secret s\\<rparr>;\n     x = Aenc (NonceF (Rb $ sk)) KE\\<rbrakk>\n    \\<Longrightarrow> Aenc (NonceF (Rb $ sk)) KE\n                      \\<in> synth (analz generators)", "assume HRb:\"guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>\"\n                 \"guessed_frame Rb xpkE = Some KE\""], ["proof (state)\nthis:\n  guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>\n  guessed_frame Rb xpkE = Some KE\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<in> l2_inv7; can_signal s A B;\n     guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n     Rb \\<notin> dom (progress s); guessed_frame Rb xpkE = Some KE;\n     Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s;\n     s' = s\n     \\<lparr>progress := progress s(Rb \\<mapsto> {xpkE, xsk}),\n        chan := insert (Auth B A (Aenc (NonceF (Rb $ sk)) KE)) (chan s),\n        l1_state.signals := (l1_state.signals s)\n          (Running A B \\<langle>KE, NonceF (Rb $ sk)\\<rangle> :=\n             Suc (l1_state.signals s\n                   (Running A B \\<langle>KE, NonceF (Rb $ sk)\\<rangle>))),\n        secret :=\n          {x. x = NonceF (Rb $ sk) \\<and> Rb = test} \\<union>\n          secret s\\<rparr>;\n     x = Aenc (NonceF (Rb $ sk)) KE\\<rbrakk>\n    \\<Longrightarrow> Aenc (NonceF (Rb $ sk)) KE\n                      \\<in> synth (analz generators)\n 2. \\<lbrakk>s \\<in> l2_inv7; \\<not> can_signal s A B;\n     guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n     Rb \\<notin> dom (progress s); guessed_frame Rb xpkE = Some KE;\n     Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s;\n     s' = s\n     \\<lparr>progress := progress s(Rb \\<mapsto> {xpkE, xsk}),\n        chan := insert (Auth B A (Aenc (NonceF (Rb $ sk)) KE)) (chan s),\n        secret :=\n          {x. x = NonceF (Rb $ sk) \\<and> Rb = test} \\<union>\n          secret s\\<rparr>;\n     x = Aenc (NonceF (Rb $ sk)) KE\\<rbrakk>\n    \\<Longrightarrow> Aenc (NonceF (Rb $ sk)) KE\n                      \\<in> synth (analz generators)", "assume Hcs: \"can_signal s A B\""], ["proof (state)\nthis:\n  can_signal s A B\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<in> l2_inv7; can_signal s A B;\n     guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n     Rb \\<notin> dom (progress s); guessed_frame Rb xpkE = Some KE;\n     Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s;\n     s' = s\n     \\<lparr>progress := progress s(Rb \\<mapsto> {xpkE, xsk}),\n        chan := insert (Auth B A (Aenc (NonceF (Rb $ sk)) KE)) (chan s),\n        l1_state.signals := (l1_state.signals s)\n          (Running A B \\<langle>KE, NonceF (Rb $ sk)\\<rangle> :=\n             Suc (l1_state.signals s\n                   (Running A B \\<langle>KE, NonceF (Rb $ sk)\\<rangle>))),\n        secret :=\n          {x. x = NonceF (Rb $ sk) \\<and> Rb = test} \\<union>\n          secret s\\<rparr>;\n     x = Aenc (NonceF (Rb $ sk)) KE\\<rbrakk>\n    \\<Longrightarrow> Aenc (NonceF (Rb $ sk)) KE\n                      \\<in> synth (analz generators)\n 2. \\<lbrakk>s \\<in> l2_inv7; \\<not> can_signal s A B;\n     guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n     Rb \\<notin> dom (progress s); guessed_frame Rb xpkE = Some KE;\n     Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s;\n     s' = s\n     \\<lparr>progress := progress s(Rb \\<mapsto> {xpkE, xsk}),\n        chan := insert (Auth B A (Aenc (NonceF (Rb $ sk)) KE)) (chan s),\n        secret :=\n          {x. x = NonceF (Rb $ sk) \\<and> Rb = test} \\<union>\n          secret s\\<rparr>;\n     x = Aenc (NonceF (Rb $ sk)) KE\\<rbrakk>\n    \\<Longrightarrow> Aenc (NonceF (Rb $ sk)) KE\n                      \\<in> synth (analz generators)", "from Hcs Hi'"], ["proof (chain)\npicking this:\n  can_signal s A B\n  s \\<in> l2_inv1", "have \"A \\<notin> bad s \\<and> B \\<notin> bad s\""], ["proof (prove)\nusing this:\n  can_signal s A B\n  s \\<in> l2_inv1\n\ngoal (1 subgoal):\n 1. A \\<notin> bad s \\<and> B \\<notin> bad s", "by auto"], ["proof (state)\nthis:\n  A \\<notin> bad s \\<and> B \\<notin> bad s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<in> l2_inv7; can_signal s A B;\n     guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n     Rb \\<notin> dom (progress s); guessed_frame Rb xpkE = Some KE;\n     Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s;\n     s' = s\n     \\<lparr>progress := progress s(Rb \\<mapsto> {xpkE, xsk}),\n        chan := insert (Auth B A (Aenc (NonceF (Rb $ sk)) KE)) (chan s),\n        l1_state.signals := (l1_state.signals s)\n          (Running A B \\<langle>KE, NonceF (Rb $ sk)\\<rangle> :=\n             Suc (l1_state.signals s\n                   (Running A B \\<langle>KE, NonceF (Rb $ sk)\\<rangle>))),\n        secret :=\n          {x. x = NonceF (Rb $ sk) \\<and> Rb = test} \\<union>\n          secret s\\<rparr>;\n     x = Aenc (NonceF (Rb $ sk)) KE\\<rbrakk>\n    \\<Longrightarrow> Aenc (NonceF (Rb $ sk)) KE\n                      \\<in> synth (analz generators)\n 2. \\<lbrakk>s \\<in> l2_inv7; \\<not> can_signal s A B;\n     guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n     Rb \\<notin> dom (progress s); guessed_frame Rb xpkE = Some KE;\n     Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s;\n     s' = s\n     \\<lparr>progress := progress s(Rb \\<mapsto> {xpkE, xsk}),\n        chan := insert (Auth B A (Aenc (NonceF (Rb $ sk)) KE)) (chan s),\n        secret :=\n          {x. x = NonceF (Rb $ sk) \\<and> Rb = test} \\<union>\n          secret s\\<rparr>;\n     x = Aenc (NonceF (Rb $ sk)) KE\\<rbrakk>\n    \\<Longrightarrow> Aenc (NonceF (Rb $ sk)) KE\n                      \\<in> synth (analz generators)", "with Hc Hi''"], ["proof (chain)\npicking this:\n  Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s\n  s \\<in> l2_inv2\n  A \\<notin> bad s \\<and> B \\<notin> bad s", "obtain Ra where \"KE = epubKF (Ra$kE)\" \n                             and \"guessed_runs Ra = \\<lparr>role=Init, owner=A, partner=B\\<rparr>\""], ["proof (prove)\nusing this:\n  Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s\n  s \\<in> l2_inv2\n  A \\<notin> bad s \\<and> B \\<notin> bad s\n\ngoal (1 subgoal):\n 1. (\\<And>Ra.\n        \\<lbrakk>KE = epubKF (Ra $ kE);\n         guessed_runs Ra =\n         \\<lparr>role = Init, owner = A, partner = B\\<rparr>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: l2_inv2D)"], ["proof (state)\nthis:\n  KE = epubKF (Ra $ kE)\n  guessed_runs Ra = \\<lparr>role = Init, owner = A, partner = B\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<in> l2_inv7; can_signal s A B;\n     guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n     Rb \\<notin> dom (progress s); guessed_frame Rb xpkE = Some KE;\n     Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s;\n     s' = s\n     \\<lparr>progress := progress s(Rb \\<mapsto> {xpkE, xsk}),\n        chan := insert (Auth B A (Aenc (NonceF (Rb $ sk)) KE)) (chan s),\n        l1_state.signals := (l1_state.signals s)\n          (Running A B \\<langle>KE, NonceF (Rb $ sk)\\<rangle> :=\n             Suc (l1_state.signals s\n                   (Running A B \\<langle>KE, NonceF (Rb $ sk)\\<rangle>))),\n        secret :=\n          {x. x = NonceF (Rb $ sk) \\<and> Rb = test} \\<union>\n          secret s\\<rparr>;\n     x = Aenc (NonceF (Rb $ sk)) KE\\<rbrakk>\n    \\<Longrightarrow> Aenc (NonceF (Rb $ sk)) KE\n                      \\<in> synth (analz generators)\n 2. \\<lbrakk>s \\<in> l2_inv7; \\<not> can_signal s A B;\n     guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n     Rb \\<notin> dom (progress s); guessed_frame Rb xpkE = Some KE;\n     Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s;\n     s' = s\n     \\<lparr>progress := progress s(Rb \\<mapsto> {xpkE, xsk}),\n        chan := insert (Auth B A (Aenc (NonceF (Rb $ sk)) KE)) (chan s),\n        secret :=\n          {x. x = NonceF (Rb $ sk) \\<and> Rb = test} \\<union>\n          secret s\\<rparr>;\n     x = Aenc (NonceF (Rb $ sk)) KE\\<rbrakk>\n    \\<Longrightarrow> Aenc (NonceF (Rb $ sk)) KE\n                      \\<in> synth (analz generators)", "with HRb"], ["proof (chain)\npicking this:\n  guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>\n  guessed_frame Rb xpkE = Some KE\n  KE = epubKF (Ra $ kE)\n  guessed_runs Ra = \\<lparr>role = Init, owner = A, partner = B\\<rparr>", "show \"Aenc (NonceF (Rb $ sk)) KE \\<in> synth (analz generators)\""], ["proof (prove)\nusing this:\n  guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>\n  guessed_frame Rb xpkE = Some KE\n  KE = epubKF (Ra $ kE)\n  guessed_runs Ra = \\<lparr>role = Init, owner = A, partner = B\\<rparr>\n\ngoal (1 subgoal):\n 1. Aenc (NonceF (Rb $ sk)) KE \\<in> synth (analz generators)", "by blast"], ["proof (state)\nthis:\n  Aenc (NonceF (Rb $ sk)) KE \\<in> synth (analz generators)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> l2_inv7; \\<not> can_signal s A B;\n     guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n     Rb \\<notin> dom (progress s); guessed_frame Rb xpkE = Some KE;\n     Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s;\n     s' = s\n     \\<lparr>progress := progress s(Rb \\<mapsto> {xpkE, xsk}),\n        chan := insert (Auth B A (Aenc (NonceF (Rb $ sk)) KE)) (chan s),\n        secret :=\n          {x. x = NonceF (Rb $ sk) \\<and> Rb = test} \\<union>\n          secret s\\<rparr>;\n     x = Aenc (NonceF (Rb $ sk)) KE\\<rbrakk>\n    \\<Longrightarrow> Aenc (NonceF (Rb $ sk)) KE\n                      \\<in> synth (analz generators)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> l2_inv7; \\<not> can_signal s A B;\n     guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n     Rb \\<notin> dom (progress s); guessed_frame Rb xpkE = Some KE;\n     Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s;\n     s' = s\n     \\<lparr>progress := progress s(Rb \\<mapsto> {xpkE, xsk}),\n        chan := insert (Auth B A (Aenc (NonceF (Rb $ sk)) KE)) (chan s),\n        secret :=\n          {x. x = NonceF (Rb $ sk) \\<and> Rb = test} \\<union>\n          secret s\\<rparr>;\n     x = Aenc (NonceF (Rb $ sk)) KE\\<rbrakk>\n    \\<Longrightarrow> Aenc (NonceF (Rb $ sk)) KE\n                      \\<in> synth (analz generators)", "txt \\<open>second case: @{term \"\\<not> can_signal s A B\"}. We show that @{term \"Rb\"} is not test and\n        not a partner:\n      - @{term \"Rb\"} is not test because in that case test is not finished and\n        @{term \"A\"}, @{term \"B\"} are the test agents, thus\n        @{term \"can_signal s A B\"}\n      - @{term \"Rb\"} is not a partner for the same reason\n      therefore the message added to the channel can be constructed from\n      @{term \"{NonceF (R $ sk) |R. R \\<noteq> test \\<and> R \\<notin> partners}\"}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> l2_inv7; \\<not> can_signal s A B;\n     guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n     Rb \\<notin> dom (progress s); guessed_frame Rb xpkE = Some KE;\n     Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s;\n     s' = s\n     \\<lparr>progress := progress s(Rb \\<mapsto> {xpkE, xsk}),\n        chan := insert (Auth B A (Aenc (NonceF (Rb $ sk)) KE)) (chan s),\n        secret :=\n          {x. x = NonceF (Rb $ sk) \\<and> Rb = test} \\<union>\n          secret s\\<rparr>;\n     x = Aenc (NonceF (Rb $ sk)) KE\\<rbrakk>\n    \\<Longrightarrow> Aenc (NonceF (Rb $ sk)) KE\n                      \\<in> synth (analz generators)", "assume Hc:\"Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s\""], ["proof (state)\nthis:\n  Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> l2_inv7; \\<not> can_signal s A B;\n     guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n     Rb \\<notin> dom (progress s); guessed_frame Rb xpkE = Some KE;\n     Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s;\n     s' = s\n     \\<lparr>progress := progress s(Rb \\<mapsto> {xpkE, xsk}),\n        chan := insert (Auth B A (Aenc (NonceF (Rb $ sk)) KE)) (chan s),\n        secret :=\n          {x. x = NonceF (Rb $ sk) \\<and> Rb = test} \\<union>\n          secret s\\<rparr>;\n     x = Aenc (NonceF (Rb $ sk)) KE\\<rbrakk>\n    \\<Longrightarrow> Aenc (NonceF (Rb $ sk)) KE\n                      \\<in> synth (analz generators)", "assume Hcs:\"\\<not> can_signal s A B\""], ["proof (state)\nthis:\n  \\<not> can_signal s A B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> l2_inv7; \\<not> can_signal s A B;\n     guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n     Rb \\<notin> dom (progress s); guessed_frame Rb xpkE = Some KE;\n     Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s;\n     s' = s\n     \\<lparr>progress := progress s(Rb \\<mapsto> {xpkE, xsk}),\n        chan := insert (Auth B A (Aenc (NonceF (Rb $ sk)) KE)) (chan s),\n        secret :=\n          {x. x = NonceF (Rb $ sk) \\<and> Rb = test} \\<union>\n          secret s\\<rparr>;\n     x = Aenc (NonceF (Rb $ sk)) KE\\<rbrakk>\n    \\<Longrightarrow> Aenc (NonceF (Rb $ sk)) KE\n                      \\<in> synth (analz generators)", "assume HRb:\"Rb \\<notin> dom (progress s)\"\n                  \"guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>\""], ["proof (state)\nthis:\n  Rb \\<notin> dom (progress s)\n  guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> l2_inv7; \\<not> can_signal s A B;\n     guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n     Rb \\<notin> dom (progress s); guessed_frame Rb xpkE = Some KE;\n     Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s;\n     s' = s\n     \\<lparr>progress := progress s(Rb \\<mapsto> {xpkE, xsk}),\n        chan := insert (Auth B A (Aenc (NonceF (Rb $ sk)) KE)) (chan s),\n        secret :=\n          {x. x = NonceF (Rb $ sk) \\<and> Rb = test} \\<union>\n          secret s\\<rparr>;\n     x = Aenc (NonceF (Rb $ sk)) KE\\<rbrakk>\n    \\<Longrightarrow> Aenc (NonceF (Rb $ sk)) KE\n                      \\<in> synth (analz generators)", "from Hcs HRb"], ["proof (chain)\npicking this:\n  \\<not> can_signal s A B\n  Rb \\<notin> dom (progress s)\n  guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>", "have \"Rb \\<noteq> test\""], ["proof (prove)\nusing this:\n  \\<not> can_signal s A B\n  Rb \\<notin> dom (progress s)\n  guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>\n\ngoal (1 subgoal):\n 1. Rb \\<noteq> test", "by (auto simp add: can_signal_def domIff)"], ["proof (state)\nthis:\n  Rb \\<noteq> test\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> l2_inv7; \\<not> can_signal s A B;\n     guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n     Rb \\<notin> dom (progress s); guessed_frame Rb xpkE = Some KE;\n     Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s;\n     s' = s\n     \\<lparr>progress := progress s(Rb \\<mapsto> {xpkE, xsk}),\n        chan := insert (Auth B A (Aenc (NonceF (Rb $ sk)) KE)) (chan s),\n        secret :=\n          {x. x = NonceF (Rb $ sk) \\<and> Rb = test} \\<union>\n          secret s\\<rparr>;\n     x = Aenc (NonceF (Rb $ sk)) KE\\<rbrakk>\n    \\<Longrightarrow> Aenc (NonceF (Rb $ sk)) KE\n                      \\<in> synth (analz generators)", "moreover"], ["proof (state)\nthis:\n  Rb \\<noteq> test\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> l2_inv7; \\<not> can_signal s A B;\n     guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n     Rb \\<notin> dom (progress s); guessed_frame Rb xpkE = Some KE;\n     Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s;\n     s' = s\n     \\<lparr>progress := progress s(Rb \\<mapsto> {xpkE, xsk}),\n        chan := insert (Auth B A (Aenc (NonceF (Rb $ sk)) KE)) (chan s),\n        secret :=\n          {x. x = NonceF (Rb $ sk) \\<and> Rb = test} \\<union>\n          secret s\\<rparr>;\n     x = Aenc (NonceF (Rb $ sk)) KE\\<rbrakk>\n    \\<Longrightarrow> Aenc (NonceF (Rb $ sk)) KE\n                      \\<in> synth (analz generators)", "from HRb Hi''' Hcs"], ["proof (chain)\npicking this:\n  Rb \\<notin> dom (progress s)\n  guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>\n  s \\<in> l2_inv4\n  \\<not> can_signal s A B", "have \"Rb \\<notin> partners\""], ["proof (prove)\nusing this:\n  Rb \\<notin> dom (progress s)\n  guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>\n  s \\<in> l2_inv4\n  \\<not> can_signal s A B\n\ngoal (1 subgoal):\n 1. Rb \\<notin> partners", "by (clarify, auto simp add: partners_def partner_runs_def can_signal_def matching_def domIff)"], ["proof (state)\nthis:\n  Rb \\<notin> partners\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> l2_inv7; \\<not> can_signal s A B;\n     guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n     Rb \\<notin> dom (progress s); guessed_frame Rb xpkE = Some KE;\n     Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s;\n     s' = s\n     \\<lparr>progress := progress s(Rb \\<mapsto> {xpkE, xsk}),\n        chan := insert (Auth B A (Aenc (NonceF (Rb $ sk)) KE)) (chan s),\n        secret :=\n          {x. x = NonceF (Rb $ sk) \\<and> Rb = test} \\<union>\n          secret s\\<rparr>;\n     x = Aenc (NonceF (Rb $ sk)) KE\\<rbrakk>\n    \\<Longrightarrow> Aenc (NonceF (Rb $ sk)) KE\n                      \\<in> synth (analz generators)", "moreover"], ["proof (state)\nthis:\n  Rb \\<notin> partners\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> l2_inv7; \\<not> can_signal s A B;\n     guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n     Rb \\<notin> dom (progress s); guessed_frame Rb xpkE = Some KE;\n     Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s;\n     s' = s\n     \\<lparr>progress := progress s(Rb \\<mapsto> {xpkE, xsk}),\n        chan := insert (Auth B A (Aenc (NonceF (Rb $ sk)) KE)) (chan s),\n        secret :=\n          {x. x = NonceF (Rb $ sk) \\<and> Rb = test} \\<union>\n          secret s\\<rparr>;\n     x = Aenc (NonceF (Rb $ sk)) KE\\<rbrakk>\n    \\<Longrightarrow> Aenc (NonceF (Rb $ sk)) KE\n                      \\<in> synth (analz generators)", "from Hc Hi"], ["proof (chain)\npicking this:\n  Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s\n  s \\<in> l2_inv7", "have \"KE \\<in> synth (analz (generators))\""], ["proof (prove)\nusing this:\n  Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s\n  s \\<in> l2_inv7\n\ngoal (1 subgoal):\n 1. KE \\<in> synth (analz generators)", "by auto"], ["proof (state)\nthis:\n  KE \\<in> synth (analz generators)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> l2_inv7; \\<not> can_signal s A B;\n     guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n     Rb \\<notin> dom (progress s); guessed_frame Rb xpkE = Some KE;\n     Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan s;\n     s' = s\n     \\<lparr>progress := progress s(Rb \\<mapsto> {xpkE, xsk}),\n        chan := insert (Auth B A (Aenc (NonceF (Rb $ sk)) KE)) (chan s),\n        secret :=\n          {x. x = NonceF (Rb $ sk) \\<and> Rb = test} \\<union>\n          secret s\\<rparr>;\n     x = Aenc (NonceF (Rb $ sk)) KE\\<rbrakk>\n    \\<Longrightarrow> Aenc (NonceF (Rb $ sk)) KE\n                      \\<in> synth (analz generators)", "ultimately"], ["proof (chain)\npicking this:\n  Rb \\<noteq> test\n  Rb \\<notin> partners\n  KE \\<in> synth (analz generators)", "show \"Aenc (NonceF (Rb $ sk)) KE \\<in> synth (analz (generators))\""], ["proof (prove)\nusing this:\n  Rb \\<noteq> test\n  Rb \\<notin> partners\n  KE \\<in> synth (analz generators)\n\ngoal (1 subgoal):\n 1. Aenc (NonceF (Rb $ sk)) KE \\<in> synth (analz generators)", "by blast"], ["proof (state)\nthis:\n  Aenc (NonceF (Rb $ sk)) KE \\<in> synth (analz generators)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> synth (analz generators)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma l2_inv7_step3:\n  \"{l2_inv7} l2_step3 Rb A B K {> l2_inv7}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l2_inv7} l2_step3 Rb A B K {> l2_inv7}", "by (auto simp add: PO_hoare_defs l2_defs intro!: l2_inv7I dest: l2_inv7D [THEN [2] rev_subsetD])"], ["", "lemma l2_inv7_dy_fake_msg:\n  \"{l2_inv7} l2_dy_fake_msg M {> l2_inv7}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l2_inv7} l2_dy_fake_msg M {> l2_inv7}", "by (auto simp add: PO_hoare_defs l2_defs extr_insert_IK_eq \n            intro!: l2_inv7I \n            elim!: l2_inv7E dy_fake_msg_extr [THEN [2] rev_subsetD])"], ["", "lemma l2_inv7_dy_fake_chan:\n  \"{l2_inv7} l2_dy_fake_chan M {> l2_inv7}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l2_inv7} l2_dy_fake_chan M {> l2_inv7}", "by (auto simp add: PO_hoare_defs l2_defs \n            intro!: l2_inv7I \n            dest:  dy_fake_chan_extr_insert [THEN [2] rev_subsetD]\n            elim!: l2_inv7E dy_fake_msg_extr [THEN [2] rev_subsetD])"], ["", "lemma l2_inv7_lkr_others:\n  \"{l2_inv7 \\<inter> l2_inv5} l2_lkr_others A {> l2_inv7}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l2_inv7 \\<inter> l2_inv5} l2_lkr_others A {> l2_inv7}", "apply (auto simp add: PO_hoare_defs l2_defs \n            intro!: l2_inv7I\n            dest!: extr_insert_bad [THEN [2] rev_subsetD]\n            elim!: l2_inv7E l2_inv5E)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>xa xb.\n       \\<lbrakk>A \\<noteq> test_owner; A \\<noteq> test_partner;\n        \\<forall>A B M.\n           (Confid A B M \\<in> chan xb \\<longrightarrow>\n            M \\<in> dy_fake_msg (bad xb) (ik xb) (chan xb)) \\<and>\n           (Secure A B M \\<in> chan xb \\<longrightarrow>\n            M \\<in> dy_fake_msg (bad xb) (ik xb) (chan xb));\n        extr (bad xb) (ik xb) (chan xb)\n        \\<subseteq> synth (analz generators);\n        xa \\<in> extr (bad xb) (ik xb) (chan xb)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> synth (analz generators)\n 2. \\<And>xa xb B.\n       \\<lbrakk>A \\<noteq> test_owner; A \\<noteq> test_partner;\n        \\<forall>A B M.\n           (Confid A B M \\<in> chan xb \\<longrightarrow>\n            M \\<in> dy_fake_msg (bad xb) (ik xb) (chan xb)) \\<and>\n           (Secure A B M \\<in> chan xb \\<longrightarrow>\n            M \\<in> dy_fake_msg (bad xb) (ik xb) (chan xb));\n        extr (bad xb) (ik xb) (chan xb)\n        \\<subseteq> synth (analz generators);\n        Confid A B xa \\<in> chan xb\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> synth (analz generators)\n 3. \\<And>xa xb B.\n       \\<lbrakk>A \\<noteq> test_owner; A \\<noteq> test_partner;\n        \\<forall>A B M.\n           (Confid A B M \\<in> chan xb \\<longrightarrow>\n            M \\<in> dy_fake_msg (bad xb) (ik xb) (chan xb)) \\<and>\n           (Secure A B M \\<in> chan xb \\<longrightarrow>\n            M \\<in> dy_fake_msg (bad xb) (ik xb) (chan xb));\n        extr (bad xb) (ik xb) (chan xb)\n        \\<subseteq> synth (analz generators);\n        Confid B A xa \\<in> chan xb\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> synth (analz generators)\n 4. \\<And>xa xb B.\n       \\<lbrakk>A \\<noteq> test_owner; A \\<noteq> test_partner;\n        \\<forall>A B M.\n           (Confid A B M \\<in> chan xb \\<longrightarrow>\n            M \\<in> dy_fake_msg (bad xb) (ik xb) (chan xb)) \\<and>\n           (Secure A B M \\<in> chan xb \\<longrightarrow>\n            M \\<in> dy_fake_msg (bad xb) (ik xb) (chan xb));\n        extr (bad xb) (ik xb) (chan xb)\n        \\<subseteq> synth (analz generators);\n        Secure A B xa \\<in> chan xb\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> synth (analz generators)\n 5. \\<And>xa xb B.\n       \\<lbrakk>A \\<noteq> test_owner; A \\<noteq> test_partner;\n        \\<forall>A B M.\n           (Confid A B M \\<in> chan xb \\<longrightarrow>\n            M \\<in> dy_fake_msg (bad xb) (ik xb) (chan xb)) \\<and>\n           (Secure A B M \\<in> chan xb \\<longrightarrow>\n            M \\<in> dy_fake_msg (bad xb) (ik xb) (chan xb));\n        extr (bad xb) (ik xb) (chan xb)\n        \\<subseteq> synth (analz generators);\n        Secure B A xa \\<in> chan xb\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> synth (analz generators)", "apply (auto dest: dy_fake_msg_extr [THEN [2] rev_subsetD])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma l2_inv7_lkr_after:\n  \"{l2_inv7 \\<inter> l2_inv5} l2_lkr_after A {> l2_inv7}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l2_inv7 \\<inter> l2_inv5} l2_lkr_after A {> l2_inv7}", "apply (auto simp add: PO_hoare_defs l2_defs \n            intro!: l2_inv7I\n            dest!: extr_insert_bad [THEN [2] rev_subsetD]\n            elim!: l2_inv7E l2_inv5E)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>xa xb.\n       \\<lbrakk>\\<forall>A B M.\n                   (Confid A B M \\<in> chan xb \\<longrightarrow>\n                    M \\<in> dy_fake_msg (bad xb) (ik xb) (chan xb)) \\<and>\n                   (Secure A B M \\<in> chan xb \\<longrightarrow>\n                    M \\<in> dy_fake_msg (bad xb) (ik xb) (chan xb));\n        extr (bad xb) (ik xb) (chan xb)\n        \\<subseteq> synth (analz generators);\n        test_ended xb; xa \\<in> extr (bad xb) (ik xb) (chan xb)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> synth (analz generators)\n 2. \\<And>xa xb B.\n       \\<lbrakk>\\<forall>A B M.\n                   (Confid A B M \\<in> chan xb \\<longrightarrow>\n                    M \\<in> dy_fake_msg (bad xb) (ik xb) (chan xb)) \\<and>\n                   (Secure A B M \\<in> chan xb \\<longrightarrow>\n                    M \\<in> dy_fake_msg (bad xb) (ik xb) (chan xb));\n        extr (bad xb) (ik xb) (chan xb)\n        \\<subseteq> synth (analz generators);\n        test_ended xb; Confid A B xa \\<in> chan xb\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> synth (analz generators)\n 3. \\<And>xa xb B.\n       \\<lbrakk>\\<forall>A B M.\n                   (Confid A B M \\<in> chan xb \\<longrightarrow>\n                    M \\<in> dy_fake_msg (bad xb) (ik xb) (chan xb)) \\<and>\n                   (Secure A B M \\<in> chan xb \\<longrightarrow>\n                    M \\<in> dy_fake_msg (bad xb) (ik xb) (chan xb));\n        extr (bad xb) (ik xb) (chan xb)\n        \\<subseteq> synth (analz generators);\n        test_ended xb; Confid B A xa \\<in> chan xb\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> synth (analz generators)\n 4. \\<And>xa xb B.\n       \\<lbrakk>\\<forall>A B M.\n                   (Confid A B M \\<in> chan xb \\<longrightarrow>\n                    M \\<in> dy_fake_msg (bad xb) (ik xb) (chan xb)) \\<and>\n                   (Secure A B M \\<in> chan xb \\<longrightarrow>\n                    M \\<in> dy_fake_msg (bad xb) (ik xb) (chan xb));\n        extr (bad xb) (ik xb) (chan xb)\n        \\<subseteq> synth (analz generators);\n        test_ended xb; Secure A B xa \\<in> chan xb\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> synth (analz generators)\n 5. \\<And>xa xb B.\n       \\<lbrakk>\\<forall>A B M.\n                   (Confid A B M \\<in> chan xb \\<longrightarrow>\n                    M \\<in> dy_fake_msg (bad xb) (ik xb) (chan xb)) \\<and>\n                   (Secure A B M \\<in> chan xb \\<longrightarrow>\n                    M \\<in> dy_fake_msg (bad xb) (ik xb) (chan xb));\n        extr (bad xb) (ik xb) (chan xb)\n        \\<subseteq> synth (analz generators);\n        test_ended xb; Secure B A xa \\<in> chan xb\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> synth (analz generators)", "apply (auto dest: dy_fake_msg_extr [THEN [2] rev_subsetD])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma l2_inv7_skr:\n  \"{l2_inv7 \\<inter> l2_inv6} l2_skr R K {> l2_inv7}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l2_inv7 \\<inter> l2_inv6} l2_skr R K {> l2_inv7}", "proof (auto simp add: PO_hoare_defs l2_defs extr_insert_IK_eq intro!: l2_inv7I,\n       auto elim: l2_inv7D [THEN subsetD])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xb.\n       \\<lbrakk>R \\<noteq> test; R \\<notin> partners; xb \\<in> l2_inv7;\n        xb \\<in> l2_inv6; run_ended (progress xb R);\n        guessed_frame R xsk = Some K\\<rbrakk>\n       \\<Longrightarrow> K \\<in> synth (analz generators)", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xb.\n       \\<lbrakk>R \\<noteq> test; R \\<notin> partners; xb \\<in> l2_inv7;\n        xb \\<in> l2_inv6; run_ended (progress xb R);\n        guessed_frame R xsk = Some K\\<rbrakk>\n       \\<Longrightarrow> K \\<in> synth (analz generators)", "assume HRtest: \"R \\<noteq> test\" \"R \\<notin> partners\""], ["proof (state)\nthis:\n  R \\<noteq> test\n  R \\<notin> partners\n\ngoal (1 subgoal):\n 1. \\<And>xb.\n       \\<lbrakk>R \\<noteq> test; R \\<notin> partners; xb \\<in> l2_inv7;\n        xb \\<in> l2_inv6; run_ended (progress xb R);\n        guessed_frame R xsk = Some K\\<rbrakk>\n       \\<Longrightarrow> K \\<in> synth (analz generators)", "assume Hi: \"s \\<in> l2_inv7\""], ["proof (state)\nthis:\n  s \\<in> l2_inv7\n\ngoal (1 subgoal):\n 1. \\<And>xb.\n       \\<lbrakk>R \\<noteq> test; R \\<notin> partners; xb \\<in> l2_inv7;\n        xb \\<in> l2_inv6; run_ended (progress xb R);\n        guessed_frame R xsk = Some K\\<rbrakk>\n       \\<Longrightarrow> K \\<in> synth (analz generators)", "assume Hi': \"s \\<in> l2_inv6\""], ["proof (state)\nthis:\n  s \\<in> l2_inv6\n\ngoal (1 subgoal):\n 1. \\<And>xb.\n       \\<lbrakk>R \\<noteq> test; R \\<notin> partners; xb \\<in> l2_inv7;\n        xb \\<in> l2_inv6; run_ended (progress xb R);\n        guessed_frame R xsk = Some K\\<rbrakk>\n       \\<Longrightarrow> K \\<in> synth (analz generators)", "assume HRsk: \"in_progress (progress s R) xsk\" \"guessed_frame R xsk = Some K\""], ["proof (state)\nthis:\n  run_ended (progress s R)\n  guessed_frame R xsk = Some K\n\ngoal (1 subgoal):\n 1. \\<And>xb.\n       \\<lbrakk>R \\<noteq> test; R \\<notin> partners; xb \\<in> l2_inv7;\n        xb \\<in> l2_inv6; run_ended (progress xb R);\n        guessed_frame R xsk = Some K\\<rbrakk>\n       \\<Longrightarrow> K \\<in> synth (analz generators)", "show \"K \\<in> synth (analz generators)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K \\<in> synth (analz generators)", "proof (cases \"role (guessed_runs R)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. role (guessed_runs R) = Init \\<Longrightarrow>\n    K \\<in> synth (analz generators)\n 2. role (guessed_runs R) = Resp \\<Longrightarrow>\n    K \\<in> synth (analz generators)", "txt \\<open>first case: @{term \"R\"} is the initiator, then @{term \"Aenc K epk\"}\n        is in @{term \"extr (bad s) (ik s) (chan s)\"} (by invariant)\n        therefore either @{term \"K \\<in> synth (analz generators)\"} which proves the goal\n        or @{term \"Aenc K epk \\<in> generators\"}, which means that\n        @{term \"K = NonceF (Rb$sk)\"} where @{term \"R\"} and @{term \"Rb\"} are matching\n        and since @{term \"R\"} is not partner or test, neither is\n        @{term \"Rb\"}, and therefore @{term \"K \\<in> synth (analz (generators))\"}\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. role (guessed_runs R) = Init \\<Longrightarrow>\n    K \\<in> synth (analz generators)\n 2. role (guessed_runs R) = Resp \\<Longrightarrow>\n    K \\<in> synth (analz generators)", "assume HRI: \"role (guessed_runs R) = Init\""], ["proof (state)\nthis:\n  role (guessed_runs R) = Init\n\ngoal (2 subgoals):\n 1. role (guessed_runs R) = Init \\<Longrightarrow>\n    K \\<in> synth (analz generators)\n 2. role (guessed_runs R) = Resp \\<Longrightarrow>\n    K \\<in> synth (analz generators)", "with HRsk Hi Hi'"], ["proof (chain)\npicking this:\n  run_ended (progress s R)\n  guessed_frame R xsk = Some K\n  s \\<in> l2_inv7\n  s \\<in> l2_inv6\n  role (guessed_runs R) = Init", "have \"Aenc K (epubKF (R$kE)) \\<in> synth (analz generators)\""], ["proof (prove)\nusing this:\n  run_ended (progress s R)\n  guessed_frame R xsk = Some K\n  s \\<in> l2_inv7\n  s \\<in> l2_inv6\n  role (guessed_runs R) = Init\n\ngoal (1 subgoal):\n 1. Aenc K (epubKF (R $ kE)) \\<in> synth (analz generators)", "by (auto dest!: l2_inv7D)"], ["proof (state)\nthis:\n  Aenc K (epubKF (R $ kE)) \\<in> synth (analz generators)\n\ngoal (2 subgoals):\n 1. role (guessed_runs R) = Init \\<Longrightarrow>\n    K \\<in> synth (analz generators)\n 2. role (guessed_runs R) = Resp \\<Longrightarrow>\n    K \\<in> synth (analz generators)", "then"], ["proof (chain)\npicking this:\n  Aenc K (epubKF (R $ kE)) \\<in> synth (analz generators)", "have \"K \\<in> synth (analz generators) \\<or> Aenc K (epubKF (R$kE)) \\<in> generators\""], ["proof (prove)\nusing this:\n  Aenc K (epubKF (R $ kE)) \\<in> synth (analz generators)\n\ngoal (1 subgoal):\n 1. K \\<in> synth (analz generators) \\<or>\n    Aenc K (epubKF (R $ kE)) \\<in> generators", "by (rule synth.cases, simp_all, simp add: analz_generators)"], ["proof (state)\nthis:\n  K \\<in> synth (analz generators) \\<or>\n  Aenc K (epubKF (R $ kE)) \\<in> generators\n\ngoal (2 subgoals):\n 1. role (guessed_runs R) = Init \\<Longrightarrow>\n    K \\<in> synth (analz generators)\n 2. role (guessed_runs R) = Resp \\<Longrightarrow>\n    K \\<in> synth (analz generators)", "with HRsk"], ["proof (chain)\npicking this:\n  run_ended (progress s R)\n  guessed_frame R xsk = Some K\n  K \\<in> synth (analz generators) \\<or>\n  Aenc K (epubKF (R $ kE)) \\<in> generators", "show ?thesis"], ["proof (prove)\nusing this:\n  run_ended (progress s R)\n  guessed_frame R xsk = Some K\n  K \\<in> synth (analz generators) \\<or>\n  Aenc K (epubKF (R $ kE)) \\<in> generators\n\ngoal (1 subgoal):\n 1. K \\<in> synth (analz generators)", "proof auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Rb A B.\n       \\<lbrakk>run_ended (progress s R);\n        guessed_frame R xsk = Some (NonceF (Rb $ sk)); K = NonceF (Rb $ sk);\n        guessed_runs R =\n        \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        guessed_runs Rb =\n        \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        guessed_frame Rb xpkE = Some (epubKF (R $ kE))\\<rbrakk>\n       \\<Longrightarrow> NonceF (Rb $ sk) \\<in> analz generators", "fix Rb A B"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Rb A B.\n       \\<lbrakk>run_ended (progress s R);\n        guessed_frame R xsk = Some (NonceF (Rb $ sk)); K = NonceF (Rb $ sk);\n        guessed_runs R =\n        \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        guessed_runs Rb =\n        \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        guessed_frame Rb xpkE = Some (epubKF (R $ kE))\\<rbrakk>\n       \\<Longrightarrow> NonceF (Rb $ sk) \\<in> analz generators", "assume HR: \"guessed_runs R = \\<lparr>role = Init, owner = A, partner = B\\<rparr>\"\n                     \"guessed_frame R xsk = Some (NonceF (Rb $ sk))\""], ["proof (state)\nthis:\n  guessed_runs R = \\<lparr>role = Init, owner = A, partner = B\\<rparr>\n  guessed_frame R xsk = Some (NonceF (Rb $ sk))\n\ngoal (1 subgoal):\n 1. \\<And>Rb A B.\n       \\<lbrakk>run_ended (progress s R);\n        guessed_frame R xsk = Some (NonceF (Rb $ sk)); K = NonceF (Rb $ sk);\n        guessed_runs R =\n        \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        guessed_runs Rb =\n        \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        guessed_frame Rb xpkE = Some (epubKF (R $ kE))\\<rbrakk>\n       \\<Longrightarrow> NonceF (Rb $ sk) \\<in> analz generators", "assume HRb: \"guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>\"\n                      \"guessed_frame Rb xpkE = Some (epubKF (R $ kE))\""], ["proof (state)\nthis:\n  guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>\n  guessed_frame Rb xpkE = Some (epubKF (R $ kE))\n\ngoal (1 subgoal):\n 1. \\<And>Rb A B.\n       \\<lbrakk>run_ended (progress s R);\n        guessed_frame R xsk = Some (NonceF (Rb $ sk)); K = NonceF (Rb $ sk);\n        guessed_runs R =\n        \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        guessed_runs Rb =\n        \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        guessed_frame Rb xpkE = Some (epubKF (R $ kE))\\<rbrakk>\n       \\<Longrightarrow> NonceF (Rb $ sk) \\<in> analz generators", "from HR HRb"], ["proof (chain)\npicking this:\n  guessed_runs R = \\<lparr>role = Init, owner = A, partner = B\\<rparr>\n  guessed_frame R xsk = Some (NonceF (Rb $ sk))\n  guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>\n  guessed_frame Rb xpkE = Some (epubKF (R $ kE))", "have \"partner_runs Rb R\""], ["proof (prove)\nusing this:\n  guessed_runs R = \\<lparr>role = Init, owner = A, partner = B\\<rparr>\n  guessed_frame R xsk = Some (NonceF (Rb $ sk))\n  guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>\n  guessed_frame Rb xpkE = Some (epubKF (R $ kE))\n\ngoal (1 subgoal):\n 1. partner_runs Rb R", "by (auto simp add: partner_runs_def matching_def)"], ["proof (state)\nthis:\n  partner_runs Rb R\n\ngoal (1 subgoal):\n 1. \\<And>Rb A B.\n       \\<lbrakk>run_ended (progress s R);\n        guessed_frame R xsk = Some (NonceF (Rb $ sk)); K = NonceF (Rb $ sk);\n        guessed_runs R =\n        \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        guessed_runs Rb =\n        \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        guessed_frame Rb xpkE = Some (epubKF (R $ kE))\\<rbrakk>\n       \\<Longrightarrow> NonceF (Rb $ sk) \\<in> analz generators", "with HRtest"], ["proof (chain)\npicking this:\n  R \\<noteq> test\n  R \\<notin> partners\n  partner_runs Rb R", "have \"Rb \\<noteq> test \\<and> Rb \\<notin> partners\""], ["proof (prove)\nusing this:\n  R \\<noteq> test\n  R \\<notin> partners\n  partner_runs Rb R\n\ngoal (1 subgoal):\n 1. Rb \\<noteq> test \\<and> Rb \\<notin> partners", "by (auto dest: partner_test, simp add:partners_def)"], ["proof (state)\nthis:\n  Rb \\<noteq> test \\<and> Rb \\<notin> partners\n\ngoal (1 subgoal):\n 1. \\<And>Rb A B.\n       \\<lbrakk>run_ended (progress s R);\n        guessed_frame R xsk = Some (NonceF (Rb $ sk)); K = NonceF (Rb $ sk);\n        guessed_runs R =\n        \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        guessed_runs Rb =\n        \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        guessed_frame Rb xpkE = Some (epubKF (R $ kE))\\<rbrakk>\n       \\<Longrightarrow> NonceF (Rb $ sk) \\<in> analz generators", "then"], ["proof (chain)\npicking this:\n  Rb \\<noteq> test \\<and> Rb \\<notin> partners", "show \"NonceF (Rb $ sk) \\<in> analz generators\""], ["proof (prove)\nusing this:\n  Rb \\<noteq> test \\<and> Rb \\<notin> partners\n\ngoal (1 subgoal):\n 1. NonceF (Rb $ sk) \\<in> analz generators", "by blast"], ["proof (state)\nthis:\n  NonceF (Rb $ sk) \\<in> analz generators\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  K \\<in> synth (analz generators)\n\ngoal (1 subgoal):\n 1. role (guessed_runs R) = Resp \\<Longrightarrow>\n    K \\<in> synth (analz generators)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. role (guessed_runs R) = Resp \\<Longrightarrow>\n    K \\<in> synth (analz generators)", "txt \\<open>second case: @{term \"R\"} is the Responder, then @{term \"K\"} is @{term \"R$sk\"}\n        which is in @{term \"synth (analz (generators))\"}\n        since @{term \"R\"} is not test or partner\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. role (guessed_runs R) = Resp \\<Longrightarrow>\n    K \\<in> synth (analz generators)", "assume HRI: \"role (guessed_runs R) = Resp\""], ["proof (state)\nthis:\n  role (guessed_runs R) = Resp\n\ngoal (1 subgoal):\n 1. role (guessed_runs R) = Resp \\<Longrightarrow>\n    K \\<in> synth (analz generators)", "with HRsk HRtest"], ["proof (chain)\npicking this:\n  run_ended (progress s R)\n  guessed_frame R xsk = Some K\n  R \\<noteq> test\n  R \\<notin> partners\n  role (guessed_runs R) = Resp", "show ?thesis"], ["proof (prove)\nusing this:\n  run_ended (progress s R)\n  guessed_frame R xsk = Some K\n  R \\<noteq> test\n  R \\<notin> partners\n  role (guessed_runs R) = Resp\n\ngoal (1 subgoal):\n 1. K \\<in> synth (analz generators)", "by auto"], ["proof (state)\nthis:\n  K \\<in> synth (analz generators)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  K \\<in> synth (analz generators)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas l2_inv7_trans_aux =\n  l2_inv7_step1 l2_inv7_step2 l2_inv7_step3\n  l2_inv7_dy_fake_msg l2_inv7_dy_fake_chan\n  l2_inv7_lkr_others l2_inv7_lkr_after l2_inv7_skr"], ["", "lemma l2_inv7_trans [iff]:\n  \"{l2_inv7 \\<inter> l2_inv1 \\<inter> l2_inv2 \\<inter> l2_inv4 \\<inter> l2_inv5 \\<inter> l2_inv6} trans l2 {> l2_inv7}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l2_inv7 \\<inter> l2_inv1 \\<inter> l2_inv2 \\<inter> l2_inv4 \\<inter>\n     l2_inv5 \\<inter>\n     l2_inv6} TS.trans l2 {> l2_inv7}", "by (auto simp add: l2_nostep_defs intro:l2_inv7_trans_aux)"], ["", "lemma PO_l2_inv7 [iff]: \"reach l2 \\<subseteq> l2_inv7\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l2 \\<subseteq> l2_inv7", "by (rule_tac J=\"l2_inv1 \\<inter> l2_inv2 \\<inter> l2_inv4 \\<inter> l2_inv5 \\<inter> l2_inv6\" in inv_rule_incr) (auto)"], ["", "lemma l2_inv7_aux:\n  \"NonceF (R$sk) \\<in> analz (ik s) \\<Longrightarrow> s \\<in> l2_inv7 \\<Longrightarrow> R \\<noteq> test \\<and> R \\<notin> partners\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>NonceF (R $ sk) \\<in> analz (ik s); s \\<in> l2_inv7\\<rbrakk>\n    \\<Longrightarrow> R \\<noteq> test \\<and> R \\<notin> partners", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>NonceF (R $ sk) \\<in> analz (ik s); s \\<in> l2_inv7\\<rbrakk>\n    \\<Longrightarrow> R \\<noteq> test \\<and> R \\<notin> partners", "assume H:\"s \\<in> l2_inv7\" and H':\"NonceF (R$sk) \\<in> analz (ik s)\""], ["proof (state)\nthis:\n  s \\<in> l2_inv7\n  NonceF (R $ sk) \\<in> analz (ik s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>NonceF (R $ sk) \\<in> analz (ik s); s \\<in> l2_inv7\\<rbrakk>\n    \\<Longrightarrow> R \\<noteq> test \\<and> R \\<notin> partners", "then"], ["proof (chain)\npicking this:\n  s \\<in> l2_inv7\n  NonceF (R $ sk) \\<in> analz (ik s)", "have H'':\"NonceF (R$sk) \\<in> analz (extr (bad s) (ik s) (chan s))\""], ["proof (prove)\nusing this:\n  s \\<in> l2_inv7\n  NonceF (R $ sk) \\<in> analz (ik s)\n\ngoal (1 subgoal):\n 1. NonceF (R $ sk) \\<in> analz (extr (bad s) (ik s) (chan s))", "by (auto elim: analz_monotone)"], ["proof (state)\nthis:\n  NonceF (R $ sk) \\<in> analz (extr (bad s) (ik s) (chan s))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>NonceF (R $ sk) \\<in> analz (ik s); s \\<in> l2_inv7\\<rbrakk>\n    \\<Longrightarrow> R \\<noteq> test \\<and> R \\<notin> partners", "from H"], ["proof (chain)\npicking this:\n  s \\<in> l2_inv7", "have \"analz (extr (bad s) (ik s) (chan s)) \\<subseteq> analz (synth (analz generators))\""], ["proof (prove)\nusing this:\n  s \\<in> l2_inv7\n\ngoal (1 subgoal):\n 1. analz (extr (bad s) (ik s) (chan s))\n    \\<subseteq> analz (synth (analz generators))", "by (blast dest: analz_mono intro: l2_inv7D)"], ["proof (state)\nthis:\n  analz (extr (bad s) (ik s) (chan s))\n  \\<subseteq> analz (synth (analz generators))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>NonceF (R $ sk) \\<in> analz (ik s); s \\<in> l2_inv7\\<rbrakk>\n    \\<Longrightarrow> R \\<noteq> test \\<and> R \\<notin> partners", "with H''"], ["proof (chain)\npicking this:\n  NonceF (R $ sk) \\<in> analz (extr (bad s) (ik s) (chan s))\n  analz (extr (bad s) (ik s) (chan s))\n  \\<subseteq> analz (synth (analz generators))", "have \"NonceF (R$sk) \\<in> analz generators\""], ["proof (prove)\nusing this:\n  NonceF (R $ sk) \\<in> analz (extr (bad s) (ik s) (chan s))\n  analz (extr (bad s) (ik s) (chan s))\n  \\<subseteq> analz (synth (analz generators))\n\ngoal (1 subgoal):\n 1. NonceF (R $ sk) \\<in> analz generators", "by auto"], ["proof (state)\nthis:\n  NonceF (R $ sk) \\<in> analz generators\n\ngoal (1 subgoal):\n 1. \\<lbrakk>NonceF (R $ sk) \\<in> analz (ik s); s \\<in> l2_inv7\\<rbrakk>\n    \\<Longrightarrow> R \\<noteq> test \\<and> R \\<notin> partners", "then"], ["proof (chain)\npicking this:\n  NonceF (R $ sk) \\<in> analz generators", "have \"NonceF (R$sk) \\<in> generators\""], ["proof (prove)\nusing this:\n  NonceF (R $ sk) \\<in> analz generators\n\ngoal (1 subgoal):\n 1. NonceF (R $ sk) \\<in> generators", "by (simp add: analz_generators)"], ["proof (state)\nthis:\n  NonceF (R $ sk) \\<in> generators\n\ngoal (1 subgoal):\n 1. \\<lbrakk>NonceF (R $ sk) \\<in> analz (ik s); s \\<in> l2_inv7\\<rbrakk>\n    \\<Longrightarrow> R \\<noteq> test \\<and> R \\<notin> partners", "then"], ["proof (chain)\npicking this:\n  NonceF (R $ sk) \\<in> generators", "show ?thesis"], ["proof (prove)\nusing this:\n  NonceF (R $ sk) \\<in> generators\n\ngoal (1 subgoal):\n 1. R \\<noteq> test \\<and> R \\<notin> partners", "by auto"], ["proof (state)\nthis:\n  R \\<noteq> test \\<and> R \\<notin> partners\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>inv8\\<close>"], ["", "text \\<open>Form of the secrets = nonces generated by test or partners\\<close>"], ["", "(**************************************************************************************************)"], ["", "definition\n  l2_inv8 :: \"l2_state set\"\nwhere\n  \"l2_inv8 \\<equiv> {s.\n    secret s \\<subseteq> {NonceF (R$sk) | R. R = test \\<or> R \\<in> partners}\n  }\""], ["", "lemmas l2_inv8I = l2_inv8_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas l2_inv8E [elim] = l2_inv8_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas l2_inv8D = l2_inv8_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]"], ["", "lemma l2_inv8_init [iff]:\n  \"init l2 \\<subseteq> l2_inv8\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init l2 \\<subseteq> l2_inv8", "by (auto simp add: l2_def l2_init_def l2_inv8_def)"], ["", "lemma l2_inv8_trans [iff]:\n  \"{l2_inv8 \\<inter> l2_inv1 \\<inter> l2_inv3} trans l2 {> l2_inv8}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l2_inv8 \\<inter> l2_inv1 \\<inter> l2_inv3} TS.trans l2 {> l2_inv8}", "supply [[simproc del: defined_all]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. {l2_inv8 \\<inter> l2_inv1 \\<inter> l2_inv3} TS.trans l2 {> l2_inv8}", "apply (auto simp add: PO_hoare_defs l2_nostep_defs intro!: l2_inv8I)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x xa xb xg xh xi.\n       \\<lbrakk>xa \\<in> secret x; xb \\<in> l2_inv3; xb \\<in> l2_inv8;\n        xb \\<in> l2_inv1; (xb, x) \\<in> l2_step1 xg xh xi\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            xa = NonceF (R $ sk) \\<and>\n                            (R = test \\<or> R \\<in> partners)\n 2. \\<And>x xa xb xe xf xh xi.\n       \\<lbrakk>xa \\<in> secret x; xb \\<in> l2_inv3; xb \\<in> l2_inv8;\n        xb \\<in> l2_inv1; (xb, x) \\<in> l2_step2 xf xh xi xe\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            xa = NonceF (R $ sk) \\<and>\n                            (R = test \\<or> R \\<in> partners)\n 3. \\<And>x xa xb xc xg xh xi.\n       \\<lbrakk>xa \\<in> secret x; xb \\<in> l2_inv3; xb \\<in> l2_inv8;\n        xb \\<in> l2_inv1; (xb, x) \\<in> l2_step3 xg xh xi xc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            xa = NonceF (R $ sk) \\<and>\n                            (R = test \\<or> R \\<in> partners)\n 4. \\<And>x xa xb xd.\n       \\<lbrakk>xa \\<in> secret x; xb \\<in> l2_inv3; xb \\<in> l2_inv8;\n        xb \\<in> l2_inv1; (xb, x) \\<in> l2_dy_fake_chan xd\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            xa = NonceF (R $ sk) \\<and>\n                            (R = test \\<or> R \\<in> partners)\n 5. \\<And>x xa xb xc.\n       \\<lbrakk>xa \\<in> secret x; xb \\<in> l2_inv3; xb \\<in> l2_inv8;\n        xb \\<in> l2_inv1; (xb, x) \\<in> l2_dy_fake_msg xc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            xa = NonceF (R $ sk) \\<and>\n                            (R = test \\<or> R \\<in> partners)\n 6. \\<And>x xa xb xh.\n       \\<lbrakk>xa \\<in> secret x; xb \\<in> l2_inv3; xb \\<in> l2_inv8;\n        xb \\<in> l2_inv1; (xb, x) \\<in> l2_lkr_others xh\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            xa = NonceF (R $ sk) \\<and>\n                            (R = test \\<or> R \\<in> partners)\n 7. \\<And>x xa xb xh.\n       \\<lbrakk>xa \\<in> secret x; xb \\<in> l2_inv3; xb \\<in> l2_inv8;\n        xb \\<in> l2_inv1; (xb, x) \\<in> l2_lkr_after xh\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            xa = NonceF (R $ sk) \\<and>\n                            (R = test \\<or> R \\<in> partners)\n 8. \\<And>x xa xb xg xh.\n       \\<lbrakk>xa \\<in> secret x; xb \\<in> l2_inv3; xb \\<in> l2_inv8;\n        xb \\<in> l2_inv1; (xb, x) \\<in> l2_skr xg xh\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            xa = NonceF (R $ sk) \\<and>\n                            (R = test \\<or> R \\<in> partners)", "apply (auto simp add: l2_defs dy_fake_chan_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xb xc xh xi.\n       \\<lbrakk>xb \\<in> l2_inv3; xb \\<in> l2_inv8; xb \\<in> l2_inv1;\n        can_signal xb xh xi;\n        guessed_runs test =\n        \\<lparr>role = Init, owner = xh, partner = xi\\<rparr>;\n        progress xb test = Some {xpkE, xskE};\n        guessed_frame test xsk = Some xc;\n        Auth xi xh (Aenc xc (epubKF (test $ kE))) \\<in> chan xb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            xc = NonceF (R $ sk) \\<and>\n                            (R = test \\<or> R \\<in> partners)\n 2. \\<And>xb xc xh xi.\n       \\<lbrakk>xb \\<in> l2_inv3; xb \\<in> l2_inv8; xb \\<in> l2_inv1;\n        \\<not> can_signal xb xh xi;\n        guessed_runs test =\n        \\<lparr>role = Init, owner = xh, partner = xi\\<rparr>;\n        progress xb test = Some {xpkE, xskE};\n        guessed_frame test xsk = Some xc;\n        Auth xi xh (Aenc xc (epubKF (test $ kE))) \\<in> chan xb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R.\n                            xc = NonceF (R $ sk) \\<and>\n                            (R = test \\<or> R \\<in> partners)", "apply (auto simp add: partners_def partner_runs_def matching_def dest!: l2_inv3D)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xb xc xh xi.\n       \\<lbrakk>xb \\<in> l2_inv3; xb \\<in> l2_inv8; xb \\<in> l2_inv1;\n        \\<not> can_signal xb xh xi;\n        guessed_runs test =\n        \\<lparr>role = Init, owner = xh, partner = xi\\<rparr>;\n        progress xb test = Some {xpkE, xskE};\n        guessed_frame test xsk = Some xc;\n        \\<forall>R.\n           xc = NonceF (R $ sk) \\<longrightarrow>\n           R \\<noteq> test \\<and>\n           (owner (guessed_runs R) = xi \\<longrightarrow>\n            xh = partner (guessed_runs R) \\<longrightarrow>\n            Init = role_comp (role (guessed_runs R)) \\<longrightarrow>\n            (\\<exists>x.\n                (x = xpkE \\<or> x = xskE \\<or> x = xsk) \\<and>\n                x \\<in> domain (role (guessed_runs R)) \\<and>\n                guessed_frame test x \\<noteq> guessed_frame R x));\n        xh \\<in> bad xb\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>xb xc xh xi.\n       \\<lbrakk>xb \\<in> l2_inv3; xb \\<in> l2_inv8; xb \\<in> l2_inv1;\n        \\<not> can_signal xb xh xi;\n        guessed_runs test =\n        \\<lparr>role = Init, owner = xh, partner = xi\\<rparr>;\n        progress xb test = Some {xpkE, xskE};\n        guessed_frame test xsk = Some xc;\n        \\<forall>R.\n           xc = NonceF (R $ sk) \\<longrightarrow>\n           R \\<noteq> test \\<and>\n           (owner (guessed_runs R) = xi \\<longrightarrow>\n            xh = partner (guessed_runs R) \\<longrightarrow>\n            Init = role_comp (role (guessed_runs R)) \\<longrightarrow>\n            (\\<exists>x.\n                (x = xpkE \\<or> x = xskE \\<or> x = xsk) \\<and>\n                x \\<in> domain (role (guessed_runs R)) \\<and>\n                guessed_frame test x \\<noteq> guessed_frame R x));\n        xi \\<in> bad xb\\<rbrakk>\n       \\<Longrightarrow> False", "apply (simp_all add: can_signal_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_l2_inv8 [iff]: \"reach l2 \\<subseteq> l2_inv8\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l2 \\<subseteq> l2_inv8", "by (rule_tac J=\"l2_inv1 \\<inter> l2_inv3\" in inv_rule_incr) (auto)"], ["", "(**************************************************************************************************)"], ["", "subsection \\<open>Refinement\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>mediator function\\<close>"], ["", "definition \n  med12s :: \"l2_obs \\<Rightarrow> l1_obs\"\nwhere\n  \"med12s t \\<equiv> \\<lparr>\n    ik = ik t,\n    secret = secret t,\n    progress = progress t,\n    signals = signals t\n    \\<rparr>\""], ["", "text \\<open>relation between states\\<close>"], ["", "definition\n  R12s :: \"(l1_state * l2_state) set\"\nwhere\n  \"R12s \\<equiv> {(s,s').\n    s = med12s s'\n    }\""], ["", "lemmas R12s_defs = R12s_def med12s_def"], ["", "lemma can_signal_R12 [simp]:\n  \"(s1, s2) \\<in> R12s \\<Longrightarrow>\n   can_signal s1 A B \\<longleftrightarrow> can_signal s2 A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s1, s2) \\<in> R12s \\<Longrightarrow>\n    can_signal s1 A B = can_signal s2 A B", "by (auto simp add: can_signal_def R12s_defs)"], ["", "text \\<open>protocol events\\<close>"], ["", "lemma l2_step1_refines_step1:\n  \"{R12s} l1_step1 Ra A B, l2_step1 Ra A B {>R12s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12s} l1_step1 Ra A B, l2_step1 Ra A B {> R12s}", "by (auto simp add: PO_rhoare_defs R12s_defs l1_step1_def l2_step1_def)"], ["", "lemma l2_step2_refines_step2:\n  \"{R12s \\<inter> UNIV \\<times> (l2_inv1 \\<inter> l2_inv2 \\<inter> l2_inv7)} \n     l1_step2 Rb A B KE, l2_step2 Rb A B KE \n   {>R12s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12s \\<inter>\n     UNIV \\<times>\n     (l2_inv1 \\<inter> l2_inv2 \\<inter>\n      l2_inv7)} l1_step2 Rb A B KE, l2_step2 Rb A B KE {> R12s}", "apply (auto simp add: PO_rhoare_defs R12s_defs l1_step2_def, simp_all add: l2_step2_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> l2_inv1; y \\<in> l2_inv2; y \\<in> l2_inv7;\n        guessed_runs Rb =\n        \\<lparr>role = Resp, owner = B, partner = A\\<rparr> \\<and>\n        Rb \\<notin> dom (progress y) \\<and>\n        guessed_frame Rb xpkE = Some KE \\<and>\n        Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan y;\n        can_signal y A B\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ra.\n                            guessed_runs Ra =\n                            \\<lparr>role = Init, owner = A,\n                               partner = B\\<rparr> \\<and>\n                            in_progress (progress y Ra) xpkE \\<and>\n                            guessed_frame Ra xpkE = Some KE\n 2. \\<And>y.\n       \\<lbrakk>y \\<in> l2_inv1; y \\<in> l2_inv2; y \\<in> l2_inv7;\n        guessed_runs test =\n        \\<lparr>role = Resp, owner = B, partner = A\\<rparr> \\<and>\n        test \\<notin> dom (progress y) \\<and>\n        guessed_frame test xpkE = Some KE \\<and>\n        Auth A B \\<langle>Number 0, KE\\<rangle> \\<in> chan y;\n        Rb = test; NonceF (test $ sk) \\<in> analz (ik y)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto dest!: l2_inv7_aux l2_inv2D)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>auxiliary lemma needed to prove that the nonce received by the test in step 3\ncomes from a partner\\<close>"], ["", "lemma l2_step3_partners:\n  \"guessed_runs test = \\<lparr>role = Init, owner = A, partner = B\\<rparr> \\<Longrightarrow>\n   guessed_frame test xsk = Some (NonceF (Rb$sk)) \\<Longrightarrow>\n   guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr> \\<Longrightarrow>\n   guessed_frame Rb xpkE = Some (epubKF (test $ kE)) \\<Longrightarrow>\n   Rb \\<in> partners\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>guessed_runs test =\n             \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n     guessed_frame test xsk = Some (NonceF (Rb $ sk));\n     guessed_runs Rb = \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n     guessed_frame Rb xpkE = Some (epubKF (test $ kE))\\<rbrakk>\n    \\<Longrightarrow> Rb \\<in> partners", "by (auto simp add: partners_def partner_runs_def matching_def)"], ["", "lemma l2_step3_refines_step3:\n  \"{R12s \\<inter> UNIV \\<times> (l2_inv1 \\<inter> l2_inv3 \\<inter> l2_inv7)} \n      l1_step3 Ra A B K, l2_step3 Ra A B K \n   {>R12s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12s \\<inter>\n     UNIV \\<times>\n     (l2_inv1 \\<inter> l2_inv3 \\<inter>\n      l2_inv7)} l1_step3 Ra A B K, l2_step3 Ra A B K {> R12s}", "supply [[simproc del: defined_all]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12s \\<inter>\n     UNIV \\<times>\n     (l2_inv1 \\<inter> l2_inv3 \\<inter>\n      l2_inv7)} l1_step3 Ra A B K, l2_step3 Ra A B K {> R12s}", "apply (auto simp add: PO_rhoare_defs R12s_defs l1_step3_def, simp_all add: l2_step3_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b y.\n       \\<lbrakk>y \\<in> l2_inv1; y \\<in> l2_inv3; y \\<in> l2_inv7;\n        guessed_runs Ra =\n        \\<lparr>role = Init, owner = A, partner = B\\<rparr> \\<and>\n        progress y Ra = Some {xpkE, xskE} \\<and>\n        guessed_frame Ra xsk = Some K \\<and>\n        Auth B A (Aenc K (epubKF (Ra $ kE))) \\<in> chan y \\<and>\n        b = y\n        \\<lparr>progress := progress y(Ra \\<mapsto> {xpkE, xskE, xsk}),\n           l1_state.signals := (l1_state.signals y)\n             (Commit A B \\<langle>epubKF (Ra $ kE), K\\<rangle> :=\n                Suc (l1_state.signals y\n                      (Commit A B \\<langle>epubKF (Ra $ kE), K\\<rangle>))),\n           secret := {x. x = K \\<and> Ra = test} \\<union> secret y\\<rparr>;\n        can_signal y A B\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Rb.\n                            guessed_runs Rb =\n                            \\<lparr>role = Resp, owner = B,\n                               partner = A\\<rparr> \\<and>\n                            progress y Rb = Some {xpkE, xsk} \\<and>\n                            guessed_frame Rb xpkE =\n                            Some (epubKF (Ra $ kE)) \\<and>\n                            guessed_frame Rb xsk = Some K\n 2. \\<And>b y.\n       \\<lbrakk>Ra = test; K \\<in> synth (analz (ik y)); y \\<in> l2_inv1;\n        y \\<in> l2_inv3; y \\<in> l2_inv7; can_signal y A B;\n        guessed_runs test =\n        \\<lparr>role = Init, owner = A, partner = B\\<rparr> \\<and>\n        progress y test = Some {xpkE, xskE} \\<and>\n        guessed_frame test xsk = Some K \\<and>\n        Auth B A (Aenc K (epubKF (test $ kE))) \\<in> chan y \\<and>\n        b = y\n        \\<lparr>progress := progress y(test \\<mapsto> {xpkE, xskE, xsk}),\n           l1_state.signals := (l1_state.signals y)\n             (Commit A B \\<langle>epubKF (test $ kE), K\\<rangle> :=\n                Suc (l1_state.signals y\n                      (Commit A B\n                        \\<langle>epubKF (test $ kE), K\\<rangle>))),\n           secret := insert K (secret y)\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>b y.\n       \\<lbrakk>Ra = test; K \\<in> synth (analz (ik y)); y \\<in> l2_inv1;\n        y \\<in> l2_inv3; y \\<in> l2_inv7; \\<not> can_signal y A B;\n        guessed_runs test =\n        \\<lparr>role = Init, owner = A, partner = B\\<rparr> \\<and>\n        progress y test = Some {xpkE, xskE} \\<and>\n        guessed_frame test xsk = Some K \\<and>\n        Auth B A (Aenc K (epubKF (test $ kE))) \\<in> chan y \\<and>\n        b = y\n        \\<lparr>progress := progress y(test \\<mapsto> {xpkE, xskE, xsk}),\n           secret := insert K (secret y)\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto dest!: l2_inv3D l2_inv7_aux intro:l2_step3_partners)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>Ra = test; K \\<in> synth (analz (ik y)); y \\<in> l2_inv1;\n        y \\<in> l2_inv3; y \\<in> l2_inv7; \\<not> can_signal y A B;\n        guessed_runs test =\n        \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        progress y test = Some {xpkE, xskE};\n        guessed_frame test xsk = Some K; A \\<in> bad y\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>y.\n       \\<lbrakk>Ra = test; K \\<in> synth (analz (ik y)); y \\<in> l2_inv1;\n        y \\<in> l2_inv3; y \\<in> l2_inv7; \\<not> can_signal y A B;\n        guessed_runs test =\n        \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        progress y test = Some {xpkE, xskE};\n        guessed_frame test xsk = Some K; B \\<in> bad y\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto simp add: can_signal_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>attacker events\\<close>"], ["", "lemma l2_dy_fake_chan_refines_skip:\n  \"{R12s} Id, l2_dy_fake_chan M {>R12s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12s} Id, l2_dy_fake_chan M {> R12s}", "by (auto simp add: PO_rhoare_defs R12s_defs l2_defs)"], ["", "lemma l2_dy_fake_msg_refines_learn:\n  \"{R12s \\<inter> UNIV \\<times> l2_inv7 \\<inter> UNIV \\<times> l2_inv8} l1_learn m, l2_dy_fake_msg m {>R12s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12s \\<inter> UNIV \\<times> l2_inv7 \\<inter>\n     UNIV \\<times> l2_inv8} l1_learn m, l2_dy_fake_msg m {> R12s}", "apply (auto simp add: PO_rhoare_defs R12s_defs l2_loc_defs l1_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x.\n       \\<lbrakk>y \\<in> l2_inv7; y \\<in> l2_inv8;\n        m \\<in> dy_fake_msg (bad y) (ik y) (chan y);\n        x \\<in> synth (analz (insert m (ik y))); x \\<in> secret y\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule Fake_insert_dy_fake_msg, erule l2_inv7D)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x.\n       \\<lbrakk>y \\<in> l2_inv7; y \\<in> l2_inv8;\n        x \\<in> synth (analz (insert m (ik y))); x \\<in> secret y;\n        synth (analz (insert m (ik y)))\n        \\<subseteq> synth (analz generators)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto simp add: analz_generators dest!: l2_inv8D)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x.\n       \\<lbrakk>y \\<in> l2_inv7; x \\<in> synth (analz (insert m (ik y)));\n        x \\<in> secret y;\n        synth (analz (insert m (ik y))) \\<subseteq> synth generators;\n        secret y\n        \\<subseteq> {NonceF (R $ sk) |R.\n                     R = test \\<or> R \\<in> partners}\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule subsetD, simp, drule subsetD, simp, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "(*change this ?*)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>compromising events\\<close>"], ["", "lemma l2_lkr_others_refines_skip:\n  \"{R12s} Id, l2_lkr_others A {>R12s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12s} Id, l2_lkr_others A {> R12s}", "by (auto simp add: PO_rhoare_defs R12s_defs l2_loc_defs l1_defs)"], ["", "lemma l2_lkr_after_refines_skip:\n  \"{R12s} Id, l2_lkr_after A {>R12s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12s} Id, l2_lkr_after A {> R12s}", "by (auto simp add: PO_rhoare_defs R12s_defs l2_loc_defs l1_defs)"], ["", "lemma l2_skr_refines_learn:\n  \"{R12s \\<inter> UNIV \\<times> l2_inv7 \\<inter> UNIV \\<times> l2_inv6 \\<inter> UNIV \\<times> l2_inv8} l1_learn K, l2_skr R K {>R12s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12s \\<inter> UNIV \\<times> l2_inv7 \\<inter>\n     UNIV \\<times> l2_inv6 \\<inter>\n     UNIV \\<times> l2_inv8} l1_learn K, l2_skr R K {> R12s}", "proof (auto simp add: PO_rhoare_defs R12s_defs l2_loc_defs l1_defs)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y x.\n       \\<lbrakk>y \\<in> l2_inv7; y \\<in> l2_inv6; y \\<in> l2_inv8;\n        R \\<noteq> test; R \\<notin> partners; run_ended (progress y R);\n        guessed_frame R xsk = Some K;\n        x \\<in> synth (analz (insert K (ik y))); x \\<in> secret y\\<rbrakk>\n       \\<Longrightarrow> False", "fix s :: l2_state"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y x.\n       \\<lbrakk>y \\<in> l2_inv7; y \\<in> l2_inv6; y \\<in> l2_inv8;\n        R \\<noteq> test; R \\<notin> partners; run_ended (progress y R);\n        guessed_frame R xsk = Some K;\n        x \\<in> synth (analz (insert K (ik y))); x \\<in> secret y\\<rbrakk>\n       \\<Longrightarrow> False", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y x.\n       \\<lbrakk>y \\<in> l2_inv7; y \\<in> l2_inv6; y \\<in> l2_inv8;\n        R \\<noteq> test; R \\<notin> partners; run_ended (progress y R);\n        guessed_frame R xsk = Some K;\n        x \\<in> synth (analz (insert K (ik y))); x \\<in> secret y\\<rbrakk>\n       \\<Longrightarrow> False", "assume H:\"s \\<in> l2_inv7\" \"s \\<in> l2_inv6\"\n         \"R \\<notin> partners\" \"R \\<noteq> test\" \"run_ended (progress s R)\" \"guessed_frame R xsk = Some K\""], ["proof (state)\nthis:\n  s \\<in> l2_inv7\n  s \\<in> l2_inv6\n  R \\<notin> partners\n  R \\<noteq> test\n  run_ended (progress s R)\n  guessed_frame R xsk = Some K\n\ngoal (1 subgoal):\n 1. \\<And>y x.\n       \\<lbrakk>y \\<in> l2_inv7; y \\<in> l2_inv6; y \\<in> l2_inv8;\n        R \\<noteq> test; R \\<notin> partners; run_ended (progress y R);\n        guessed_frame R xsk = Some K;\n        x \\<in> synth (analz (insert K (ik y))); x \\<in> secret y\\<rbrakk>\n       \\<Longrightarrow> False", "assume Hx:\"x \\<in> synth (analz (insert K (ik s)))\""], ["proof (state)\nthis:\n  x \\<in> synth (analz (insert K (ik s)))\n\ngoal (1 subgoal):\n 1. \\<And>y x.\n       \\<lbrakk>y \\<in> l2_inv7; y \\<in> l2_inv6; y \\<in> l2_inv8;\n        R \\<noteq> test; R \\<notin> partners; run_ended (progress y R);\n        guessed_frame R xsk = Some K;\n        x \\<in> synth (analz (insert K (ik y))); x \\<in> secret y\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"x \\<in> secret s\" \"s \\<in> l2_inv8\""], ["proof (state)\nthis:\n  x \\<in> secret s\n  s \\<in> l2_inv8\n\ngoal (1 subgoal):\n 1. \\<And>y x.\n       \\<lbrakk>y \\<in> l2_inv7; y \\<in> l2_inv6; y \\<in> l2_inv8;\n        R \\<noteq> test; R \\<notin> partners; run_ended (progress y R);\n        guessed_frame R xsk = Some K;\n        x \\<in> synth (analz (insert K (ik y))); x \\<in> secret y\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x \\<in> secret s\n  s \\<in> l2_inv8", "obtain R where \"x = NonceF (R$sk)\" and \"R = test \\<or> R \\<in> partners\""], ["proof (prove)\nusing this:\n  x \\<in> secret s\n  s \\<in> l2_inv8\n\ngoal (1 subgoal):\n 1. (\\<And>R.\n        \\<lbrakk>x = NonceF (R $ sk);\n         R = test \\<or> R \\<in> partners\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = NonceF (R $ sk)\n  R = test \\<or> R \\<in> partners\n\ngoal (1 subgoal):\n 1. \\<And>y x.\n       \\<lbrakk>y \\<in> l2_inv7; y \\<in> l2_inv6; y \\<in> l2_inv8;\n        R \\<noteq> test; R \\<notin> partners; run_ended (progress y R);\n        guessed_frame R xsk = Some K;\n        x \\<in> synth (analz (insert K (ik y))); x \\<in> secret y\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  x = NonceF (R $ sk)\n  R = test \\<or> R \\<in> partners\n\ngoal (1 subgoal):\n 1. \\<And>y x.\n       \\<lbrakk>y \\<in> l2_inv7; y \\<in> l2_inv6; y \\<in> l2_inv8;\n        R \\<noteq> test; R \\<notin> partners; run_ended (progress y R);\n        guessed_frame R xsk = Some K;\n        x \\<in> synth (analz (insert K (ik y))); x \\<in> secret y\\<rbrakk>\n       \\<Longrightarrow> False", "from H"], ["proof (chain)\npicking this:\n  s \\<in> l2_inv7\n  s \\<in> l2_inv6\n  R \\<notin> partners\n  R \\<noteq> test\n  run_ended (progress s R)\n  guessed_frame R xsk = Some K", "have \"s \\<lparr>ik := insert K (ik s)\\<rparr> \\<in> l2_inv7\""], ["proof (prove)\nusing this:\n  s \\<in> l2_inv7\n  s \\<in> l2_inv6\n  R \\<notin> partners\n  R \\<noteq> test\n  run_ended (progress s R)\n  guessed_frame R xsk = Some K\n\ngoal (1 subgoal):\n 1. s\\<lparr>ik := insert K (ik s)\\<rparr> \\<in> l2_inv7", "by (auto intro: hoare_apply [OF l2_inv7_skr] simp add: l2_defs)"], ["proof (state)\nthis:\n  s\\<lparr>ik := insert K (ik s)\\<rparr> \\<in> l2_inv7\n\ngoal (1 subgoal):\n 1. \\<And>y x.\n       \\<lbrakk>y \\<in> l2_inv7; y \\<in> l2_inv6; y \\<in> l2_inv8;\n        R \\<noteq> test; R \\<notin> partners; run_ended (progress y R);\n        guessed_frame R xsk = Some K;\n        x \\<in> synth (analz (insert K (ik y))); x \\<in> secret y\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  x = NonceF (R $ sk)\n  R = test \\<or> R \\<in> partners\n  s\\<lparr>ik := insert K (ik s)\\<rparr> \\<in> l2_inv7", "show False"], ["proof (prove)\nusing this:\n  x = NonceF (R $ sk)\n  R = test \\<or> R \\<in> partners\n  s\\<lparr>ik := insert K (ik s)\\<rparr> \\<in> l2_inv7\n\ngoal (1 subgoal):\n 1. False", "using Hx"], ["proof (prove)\nusing this:\n  x = NonceF (R $ sk)\n  R = test \\<or> R \\<in> partners\n  s\\<lparr>ik := insert K (ik s)\\<rparr> \\<in> l2_inv7\n  x \\<in> synth (analz (insert K (ik s)))\n\ngoal (1 subgoal):\n 1. False", "by (auto dest: l2_inv7_aux [rotated 1])"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>refinement proof\\<close>"], ["", "lemmas l2_trans_refines_l1_trans = \n  l2_dy_fake_msg_refines_learn l2_dy_fake_chan_refines_skip\n  l2_lkr_others_refines_skip l2_lkr_after_refines_skip l2_skr_refines_learn\n  l2_step1_refines_step1 l2_step2_refines_step2 l2_step3_refines_step3"], ["", "lemma l2_refines_init_l1 [iff]:\n  \"init l2 \\<subseteq> R12s `` (init l1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init l2 \\<subseteq> R12s `` init l1", "by (auto simp add: R12s_defs l1_defs l2_loc_defs)"], ["", "lemma l2_refines_trans_l1 [iff]:\n  \"{R12s \\<inter> (UNIV \\<times> (l2_inv1 \\<inter> l2_inv2 \\<inter> l2_inv3 \\<inter> l2_inv6 \\<inter> l2_inv7 \\<inter> l2_inv8))} trans l1, trans l2 {> R12s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R12s \\<inter>\n     UNIV \\<times>\n     (l2_inv1 \\<inter> l2_inv2 \\<inter> l2_inv3 \\<inter> l2_inv6 \\<inter>\n      l2_inv7 \\<inter>\n      l2_inv8)} TS.trans l1, TS.trans l2 {> R12s}", "by (auto 0 3 simp add: l1_def l2_def l1_trans_def l2_trans_def\n             intro!: l2_trans_refines_l1_trans)"], ["", "lemma PO_obs_consistent_R12s [iff]: \n  \"obs_consistent R12s med12s l1 l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent R12s med12s l1 l2", "by (auto simp add: obs_consistent_def R12s_def med12s_def l2_defs)"], ["", "lemma l2_refines_l1 [iff]:\n  \"refines \n     (R12s \\<inter> \n      (reach l1 \\<times> (l2_inv1 \\<inter> l2_inv2 \\<inter> l2_inv3 \\<inter> l2_inv4 \\<inter> l2_inv5 \\<inter> l2_inv6 \\<inter> l2_inv7 \\<inter> l2_inv8)))\n     med12s l1 l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines\n     (R12s \\<inter>\n      reach l1 \\<times>\n      (l2_inv1 \\<inter> l2_inv2 \\<inter> l2_inv3 \\<inter> l2_inv4 \\<inter>\n       l2_inv5 \\<inter>\n       l2_inv6 \\<inter>\n       l2_inv7 \\<inter>\n       l2_inv8))\n     med12s l1 l2", "by (rule Refinement_using_invariants, auto)"], ["", "lemma l2_implements_l1 [iff]:\n  \"implements med12s l1 l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements med12s l1 l2", "by (rule refinement_soundness) (auto)"], ["", "subsection \\<open>Derived invariants\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>\n  We want to prove @{term \"l2_secrecy\"}:\n  @{term \"dy_fake_msg (bad s) (ik s) (chan s) \\<inter> secret s = {}\"}\n  but by refinement we only get @{term \"l2_partial_secrecy\"}:\n  @{term \"synth (analz (ik s)) \\<inter> secret s = {}\"}\n  This is fine, since a message in\n  @{term \"dy_fake_msg (bad s) (ik s) (chan s)\"} could be added to @{term \"ik s\"},\n  and @{term \"l2_partial_secrecy\"} would still hold for this new state.\n\\<close>"], ["", "definition\n  l2_partial_secrecy :: \"('a l2_state_scheme) set\"\nwhere\n  \"l2_partial_secrecy \\<equiv> {s. synth (analz (ik s)) \\<inter> secret s = {}}\""], ["", "lemma l2_obs_partial_secrecy [iff]: \"oreach l2 \\<subseteq> l2_partial_secrecy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oreach l2 \\<subseteq> l2_partial_secrecy", "apply (rule external_invariant_translation \n         [OF l1_obs_secrecy _ l2_implements_l1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. med12s -` l1_secrecy \\<subseteq> l2_partial_secrecy", "apply (auto simp add: med12s_def s0_secrecy_def l2_partial_secrecy_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma l2_oreach_dy_fake_msg:\n  \"s \\<in> oreach l2 \\<Longrightarrow> x \\<in> dy_fake_msg (bad s) (ik s) (chan s) \\<Longrightarrow> s \\<lparr>ik := insert x (ik s)\\<rparr> \\<in> oreach l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> oreach l2;\n     x \\<in> dy_fake_msg (bad s) (ik s) (chan s)\\<rbrakk>\n    \\<Longrightarrow> s\\<lparr>ik := insert x (ik s)\\<rparr> \\<in> oreach l2", "apply (auto simp add: oreach_def, rule, simp_all, simp add: l2_def l2_trans_def l2_dy_fake_msg_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> reach\n                      \\<lparr>init = l2_init,\n                         trans =\n                           (\\<Union>x xa xb xc xd.\n                               (\\<Union>xe.\n                                   (\\<Union>xa.\n l2_step1 xd xe xa \\<union> l2_step2 xc xe xa xb \\<union>\n l2_step3 xd xe xa x) \\<union>\n                                   l2_dy_fake_chan xa \\<union>\n                                   {(s, s').\n                                    x \\<in> dy_fake_msg (bad s) (ik s)\n       (chan s) \\<and>\n                                    s' = s\n                                    \\<lparr>ik :=\n        insert x (ik s)\\<rparr>} \\<union>\n                                   l2_lkr_others xe \\<union>\n                                   l2_lkr_after xe) \\<union>\n                               \\<Union> (range (l2_skr xd)))\\<^sup>=,\n                         obs = id\\<rparr>;\n     x \\<in> dy_fake_msg (bad s) (ik s) (chan s)\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>xa xb xc xd xe.\n                          (\\<exists>xf.\n                              (\\<exists>xb.\n                                  (s, s\n                                   \\<lparr>ik := insert x (ik s)\\<rparr>)\n                                  \\<in> l2_step1 xe xf xb \\<or>\n                                  (s, s\n                                   \\<lparr>ik := insert x (ik s)\\<rparr>)\n                                  \\<in> l2_step2 xd xf xb xc \\<or>\n                                  (s, s\n                                   \\<lparr>ik := insert x (ik s)\\<rparr>)\n                                  \\<in> l2_step3 xe xf xb xa) \\<or>\n                              (s, s\\<lparr>ik := insert x (ik s)\\<rparr>)\n                              \\<in> l2_dy_fake_chan xb \\<or>\n                              xa \\<in> dy_fake_msg (bad s) (ik s)\n  (chan s) \\<and>\n                              s\\<lparr>ik := insert x (ik s)\\<rparr> = s\n                              \\<lparr>ik := insert xa (ik s)\\<rparr> \\<or>\n                              (s, s\\<lparr>ik := insert x (ik s)\\<rparr>)\n                              \\<in> l2_lkr_others xf \\<or>\n                              (s, s\\<lparr>ik := insert x (ik s)\\<rparr>)\n                              \\<in> l2_lkr_after xf) \\<or>\n                          (\\<exists>xa.\n                              (s, s\\<lparr>ik := insert x (ik s)\\<rparr>)\n                              \\<in> l2_skr xe xa)) \\<or>\n                      s = s\\<lparr>ik := insert x (ik s)\\<rparr>", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \n  l2_secrecy :: \"('a l2_state_scheme) set\"\nwhere\n  \"l2_secrecy \\<equiv> {s. dy_fake_msg (bad s) (ik s) (chan s) \\<inter> secret s = {}}\""], ["", "lemma l2_obs_secrecy [iff]: \"oreach l2 \\<subseteq> l2_secrecy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oreach l2 \\<subseteq> l2_secrecy", "apply (auto simp add:l2_secrecy_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> oreach l2;\n        xa \\<in> dy_fake_msg (bad x) (ik x) (chan x);\n        xa \\<in> secret x\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule l2_oreach_dy_fake_msg, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> dy_fake_msg (bad x) (ik x) (chan x);\n        xa \\<in> secret x;\n        x\\<lparr>ik := insert xa (ik x)\\<rparr> \\<in> oreach l2\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule l2_obs_partial_secrecy [THEN [2] rev_subsetD], simp add: l2_partial_secrecy_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> dy_fake_msg (bad x) (ik x) (chan x);\n        xa \\<in> secret x;\n        synth (analz (insert xa (ik x))) \\<inter> secret x = {}\\<rbrakk>\n       \\<Longrightarrow> False", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma l2_secrecy [iff]: \"reach l2 \\<subseteq> l2_secrecy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l2 \\<subseteq> l2_secrecy", "by (rule external_to_internal_invariant [OF l2_obs_secrecy], auto)"], ["", "abbreviation \"l2_iagreement \\<equiv> l1_iagreement\""], ["", "lemma l2_obs_iagreement [iff]: \"oreach l2 \\<subseteq> l2_iagreement\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oreach l2 \\<subseteq> l2_iagreement", "apply (rule external_invariant_translation \n         [OF l1_obs_iagreement _ l2_implements_l1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. med12s -` l2_iagreement \\<subseteq> l2_iagreement", "apply (auto simp add: med12s_def l1_iagreement_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma l2_iagreement [iff]: \"reach l2 \\<subseteq> l2_iagreement\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l2 \\<subseteq> l2_iagreement", "by (rule external_to_internal_invariant [OF l2_obs_iagreement], auto)"], ["", "end"]]}