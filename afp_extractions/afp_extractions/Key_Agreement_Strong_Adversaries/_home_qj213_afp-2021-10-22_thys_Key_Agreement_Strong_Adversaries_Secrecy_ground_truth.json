{"file_name": "/home/qj213/afp-2021-10-22/thys/Key_Agreement_Strong_Adversaries/Secrecy.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Key_Agreement_Strong_Adversaries", "problem_names": ["lemmas s0_secrecyI = s0_secrecy_def [THEN setc_def_to_intro, rule_format]", "lemmas s0_secrecyE [elim] = s0_secrecy_def [THEN setc_def_to_elim, rule_format]", "lemmas s0_defs = s0_def s0_init_def s0_trans_def s0_add_secret_def s0_learn_def", "lemmas s0_all_defs = s0_defs ik_trans_defs", "lemma s0_obs_id [simp]: \"obs s0 = id\"", "lemma s0_secrecy_init [iff]: \"init s0 \\<subseteq> s0_secrecy\"", "lemma s0_secrecy_trans [simp, intro]: \"{s0_secrecy} trans s0 {> s0_secrecy}\"", "lemma s0_secrecy [iff]:\"reach s0 \\<subseteq> s0_secrecy\"", "lemma s0_obs_secrecy [iff]:\"oreach s0 \\<subseteq> s0_secrecy\"", "lemma s0_anyP_observable [iff]: \"observable (obs s0) P\""], "translations": [["", "lemmas s0_secrecyI = s0_secrecy_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas s0_secrecyE [elim] = s0_secrecy_def [THEN setc_def_to_elim, rule_format]"], ["", "text \\<open>Two events: add/declare a message as a secret and learn a (non-secret) message.\\<close>"], ["", "definition\n  s0_add_secret :: \"msg \\<Rightarrow> ('a s0_state_scheme * 'a s0_state_scheme) set\"\nwhere\n  \"s0_add_secret m \\<equiv> {(s,s').\n    \\<comment> \\<open>guard\\<close>\n    m \\<notin> synth (analz (ik s)) \\<and>\n    \n    \\<comment> \\<open>action\\<close>\n    s' = s\\<lparr>secret := insert m (secret s)\\<rparr>\n  }\""], ["", "definition\n  s0_learn :: \"msg \\<Rightarrow> ('a s0_state_scheme * 'a s0_state_scheme) set\"\nwhere\n  \"s0_learn m \\<equiv> {(s,s').\n    \\<comment> \\<open>guard\\<close>\n    s\\<lparr>ik := insert m (ik s)\\<rparr> \\<in> s0_secrecy \\<and> \n\n    \\<comment> \\<open>action\\<close>\n    s' = s\\<lparr>ik := insert m (ik s)\\<rparr>\n  }\""], ["", "definition\n  s0_learn' :: \"msg \\<Rightarrow> ('a s0_state_scheme * 'a s0_state_scheme) set\"\nwhere\n  \"s0_learn' m \\<equiv> {(s,s').\n    \\<comment> \\<open>guard\\<close>\n    synth (analz (insert m (ik s))) \\<inter> secret s = {} \\<and> \n\n    \\<comment> \\<open>action\\<close>\n    s' = s\\<lparr>ik := insert m (ik s)\\<rparr>\n  }\""], ["", "definition\n  s0_trans :: \"('a s0_state_scheme * 'a s0_state_scheme) set\"\nwhere\n  \"s0_trans \\<equiv> (\\<Union>m. s0_add_secret m) \\<union> (\\<Union>m. s0_learn m) \\<union> Id\""], ["", "text \\<open>Initial state is any state satisfying the invariant. The whole state is\nobservable. Put all together to define the L0 specification.\\<close>"], ["", "definition\n  s0_init :: \"'a s0_state_scheme set\"\nwhere\n  \"s0_init \\<equiv> s0_secrecy\""], ["", "type_synonym\n  s0_obs = \"s0_state\""], ["", "definition \n  s0 :: \"(s0_state, s0_obs) spec\" where\n  \"s0 \\<equiv> \\<lparr>\n    init = s0_init,\n    trans = s0_trans,\n    obs = id\n  \\<rparr>\""], ["", "lemmas s0_defs = s0_def s0_init_def s0_trans_def s0_add_secret_def s0_learn_def"], ["", "lemmas s0_all_defs = s0_defs ik_trans_defs"], ["", "lemma s0_obs_id [simp]: \"obs s0 = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs s0 = id", "by (simp add: s0_def)"], ["", "(**************************************************************************************************)"], ["", "subsection \\<open>Proof of secrecy invariant\\<close>"], ["", "(**************************************************************************************************)"], ["", "lemma s0_secrecy_init [iff]: \"init s0 \\<subseteq> s0_secrecy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init s0 \\<subseteq> s0_secrecy", "by (simp add: s0_defs)"], ["", "lemma s0_secrecy_trans [simp, intro]: \"{s0_secrecy} trans s0 {> s0_secrecy}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {s0_secrecy} TS.trans s0 {> s0_secrecy}", "apply (auto simp add: s0_all_defs PO_hoare_defs intro!: s0_secrecyI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb xc.\n       \\<lbrakk>xa \\<in> s0_secrecy; xb \\<in> synth (analz (ik xa));\n        xc \\<notin> synth (analz (ik xa)); xb \\<in> secret xa\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma s0_secrecy [iff]:\"reach s0 \\<subseteq> s0_secrecy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach s0 \\<subseteq> s0_secrecy", "by (rule inv_rule_basic, auto)"], ["", "lemma s0_obs_secrecy [iff]:\"oreach s0 \\<subseteq> s0_secrecy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oreach s0 \\<subseteq> s0_secrecy", "by (rule external_from_internal_invariant) (auto del: subsetI)"], ["", "lemma s0_anyP_observable [iff]: \"observable (obs s0) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. observable (obs s0) P", "by (auto)"], ["", "end"]]}