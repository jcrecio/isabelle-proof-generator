{"file_name": "/home/qj213/afp-2021-10-22/thys/Key_Agreement_Strong_Adversaries/pfslvl1.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Key_Agreement_Strong_Adversaries", "problem_names": ["lemma run_ended_not_None [elim]:\n  \"run_ended R \\<Longrightarrow> R = None \\<Longrightarrow> False\"", "lemmas l1_defs = \n  l1_def l1_init_def l1_trans_def\n  l1_learn_def\n  l1_step1_def l1_step2_def l1_step3_def", "lemmas l1_nostep_defs =\n  l1_def l1_init_def l1_trans_def", "lemma l1_obs_id [simp]: \"obs l1 = id\"", "lemma run_ended_trans:\n  \"run_ended (progress s R) \\<Longrightarrow>\n   (s, s') \\<in> trans l1 \\<Longrightarrow>\n   run_ended (progress s' R)\"", "lemma can_signal_trans:\n  \"can_signal s' A B \\<Longrightarrow>\n  (s, s') \\<in> trans l1 \\<Longrightarrow>\n  can_signal s A B\"", "lemma l1_learn_refines_learn:\n  \"{R01s} s0_learn m, l1_learn m {>R01s}\"", "lemma l1_step1_refines_skip:\n  \"{R01s} Id, l1_step1 Ra A B {>R01s}\"", "lemma l1_step2_refines_add_secret_skip:\n  \"{R01s} s0_add_secret (NonceF (Rb$sk)) \\<union> Id, l1_step2 Rb A B KE {>R01s}\"", "lemma l1_step3_refines_add_secret_skip:\n  \"{R01s} s0_add_secret K \\<union> Id, l1_step3 Ra A B K {>R01s}\"", "lemmas l1_trans_refines_s0_trans = \n  l1_learn_refines_learn\n  l1_step1_refines_skip l1_step2_refines_add_secret_skip l1_step3_refines_add_secret_skip", "lemma l1_refines_init_s0 [iff]:\n  \"init l1 \\<subseteq> R01s `` (init s0)\"", "lemma l1_refines_trans_s0 [iff]:\n  \"{R01s} trans s0, trans l1 {> R01s}\"", "lemma obs_consistent_med01x [iff]: \n  \"obs_consistent R01s med01s s0 l1\"", "lemma l1s_refines_s0 [iff]: \n  \"refines \n     R01s\n     med01s s0 l1\"", "lemma  l1_implements_s0 [iff]: \"implements med01s s0 l1\"", "lemma l1_obs_secrecy [iff]: \"oreach l1 \\<subseteq> l1_secrecy\"", "lemma l1_secrecy [iff]: \"reach l1 \\<subseteq> l1_secrecy\"", "lemmas l1_inv1I = l1_inv1_def [THEN setc_def_to_intro, rule_format]", "lemmas l1_inv1E [elim] = l1_inv1_def [THEN setc_def_to_elim, rule_format]", "lemmas l1_inv1D = l1_inv1_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]", "lemma l1_inv1_init [iff]:\n  \"init l1 \\<subseteq> l1_inv1\"", "lemma l1_inv1_trans [iff]:\n  \"{l1_inv1} trans l1 {> l1_inv1}\"", "lemma PO_l1_inv1 [iff]: \"reach l1 \\<subseteq> l1_inv1\"", "lemmas l1_inv2I = l1_inv2_def [THEN setc_def_to_intro, rule_format]", "lemmas l1_inv2E [elim] = l1_inv2_def [THEN setc_def_to_elim, rule_format]", "lemmas l1_inv2D = l1_inv2_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]", "lemma l1_inv2_init [iff]:\n  \"init l1 \\<subseteq> l1_inv2\"", "lemma l1_inv2_trans [iff]:\n  \"{l1_inv2} trans l1 {> l1_inv2}\"", "lemma PO_l1_inv2 [iff]: \"reach l1 \\<subseteq> l1_inv2\"", "lemmas l1_inv3I = l1_inv3_def [THEN setc_def_to_intro, rule_format]", "lemmas l1_inv3E [elim] = l1_inv3_def [THEN setc_def_to_elim, rule_format]", "lemmas l1_inv3D = l1_inv3_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]", "lemma l1_inv3_derived: \"l1_inv1 \\<inter> l1_inv2 \\<subseteq> l1_inv3\"", "lemma l1_learn_refines_a0_ia_skip:\n  \"{R01ia} Id, l1_learn m {>R01ia}\"", "lemma l1_step1_refines_a0i_skip:\n  \"{R01ia} Id, l1_step1 Ra A B {>R01ia}\"", "lemma l1_step2_refines_a0i_running_skip:\n  \"{R01ia} a0i_running A B \\<langle>KE, NonceF (Rb$sk)\\<rangle> \\<union> Id, l1_step2 Rb A B KE {>R01ia}\"", "lemma l1_step3_refines_a0i_commit_skip:\n  \"{R01ia \\<inter> (UNIV \\<times> l1_inv3)} a0i_commit A B \\<langle>epubKF (Ra$kE), K\\<rangle> \\<union> Id, l1_step3 Ra A B K {>R01ia}\"", "lemmas l1_trans_refines_a0i_trans = \n  l1_learn_refines_a0_ia_skip\n  l1_step1_refines_a0i_skip l1_step2_refines_a0i_running_skip l1_step3_refines_a0i_commit_skip", "lemma l1_refines_init_a0i [iff]:\n  \"init l1 \\<subseteq> R01ia `` (init a0i)\"", "lemma l1_refines_trans_a0i [iff]:\n  \"{R01ia \\<inter> (UNIV \\<times> (l1_inv1 \\<inter> l1_inv2))} trans a0i, trans l1 {> R01ia}\"", "lemma obs_consistent_med01ia [iff]: \n  \"obs_consistent R01ia med01ia a0i l1\"", "lemma l1_refines_a0i [iff]: \n  \"refines \n     (R01ia \\<inter> (reach a0i \\<times> (l1_inv1 \\<inter> l1_inv2)))\n     med01ia a0i l1\"", "lemma  l1_implements_a0i [iff]: \"implements med01ia a0i l1\"", "lemmas l1_iagreementI = l1_iagreement_def [THEN setc_def_to_intro, rule_format]", "lemmas l1_iagreementE [elim] = l1_iagreement_def [THEN setc_def_to_elim, rule_format]", "lemma l1_obs_iagreement [iff]: \"oreach l1 \\<subseteq> l1_iagreement\"", "lemma l1_iagreement [iff]: \"reach l1 \\<subseteq> l1_iagreement\""], "translations": [["", "lemma run_ended_not_None [elim]:\n  \"run_ended R \\<Longrightarrow> R = None \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>run_ended R; R = None\\<rbrakk> \\<Longrightarrow> False", "by (fast dest: in_progress_Some)"], ["", "text \\<open>@{term \"test_ended s\"} $\\longleftrightarrow$ the test run has ended in @{term \"s\"}\\<close>"], ["", "abbreviation\n  test_ended :: \"'a l1_state_scheme \\<Rightarrow> bool\"\nwhere\n  \"test_ended s \\<equiv> run_ended (progress s test)\""], ["", "text \\<open>a run can emit signals if it involves the same agents as the test run, and if the test run \n  has not ended yet\\<close>"], ["", "definition\n  can_signal :: \"'a l1_state_scheme \\<Rightarrow> agent \\<Rightarrow> agent \\<Rightarrow> bool\"\nwhere\n  \"can_signal s A B \\<equiv>\n  ((A = test_owner \\<and> B = test_partner) \\<or> (B = test_owner \\<and> A = test_partner)) \\<and>\n  \\<not> test_ended s\""], ["", "text \\<open>events\\<close>"], ["", "definition\n  l1_learn :: \"msg \\<Rightarrow> ('a l1_state_scheme * 'a l1_state_scheme) set\"\nwhere\n  \"l1_learn m \\<equiv> {(s,s').\n    \\<comment> \\<open>guard\\<close>\n    synth (analz (insert m (ik s))) \\<inter> (secret s) = {}  \\<and>\n    \\<comment> \\<open>action\\<close>\n    s' = s \\<lparr>ik := ik s \\<union> {m}\\<rparr>\n  }\""], ["", "text \\<open>protocol events\\<close>"], ["", "text \\<open>\n\\begin{itemize}\n\\item step 1: create @{term \"Ra\"}, @{term \"A\"} generates @{term \"pkE\"}, @{term \"skE\"}\n\\item step 2: create @{term \"Rb\"}, @{term \"B\"} reads @{term \"pkE\"} authentically,\n  generates @{term \"K\"}, emits a running signal for @{term \"A\"}, @{term \"B\"},\n  (@{term \"pkE\"}, @{term \"K\"})\n\\item step 3: @{term \"A\"} reads @{term \"K\"} and @{term \"pkE\"} authentically,\n  emits a commit signal for @{term \"A\"}, @{term \"B\"}, (@{term \"pkE\"}, @{term \"K\"})\n\\end{itemize}\n\\<close>"], ["", "definition\n  l1_step1 :: \"rid_t \\<Rightarrow> agent \\<Rightarrow> agent \\<Rightarrow> ('a l1_state_scheme * 'a l1_state_scheme) set\"\nwhere\n  \"l1_step1 Ra A B \\<equiv> {(s, s').\n    \\<comment> \\<open>guards:\\<close>\n    Ra \\<notin> dom (progress s) \\<and>\n    guessed_runs Ra = \\<lparr>role=Init, owner=A, partner=B\\<rparr> \\<and>\n    \\<comment> \\<open>actions:\\<close>\n    s' = s\\<lparr>\n      progress := (progress s)(Ra \\<mapsto> {xpkE, xskE})\n      \\<rparr>\n  }\""], ["", "definition\n  l1_step2 :: \"rid_t \\<Rightarrow> agent \\<Rightarrow> agent \\<Rightarrow> msg \\<Rightarrow> ('a l1_state_scheme * 'a l1_state_scheme) set\"\nwhere\n  \"l1_step2 Rb A B KE \\<equiv> {(s, s').\n    \\<comment> \\<open>guards:\\<close>\n    guessed_runs Rb = \\<lparr>role=Resp, owner=B, partner=A\\<rparr> \\<and>\n    Rb \\<notin> dom (progress s) \\<and>\n    guessed_frame Rb xpkE = Some KE \\<and>\n    (can_signal s A B \\<longrightarrow> \\<comment> \\<open>authentication guard\\<close>\n      (\\<exists> Ra. guessed_runs Ra = \\<lparr>role=Init, owner=A, partner=B\\<rparr> \\<and>\n             in_progress (progress s Ra) xpkE \\<and> guessed_frame Ra xpkE = Some KE)) \\<and>\n    (Rb = test \\<longrightarrow> NonceF (Rb$sk) \\<notin> synth (analz (ik s))) \\<and>\n    \\<comment> \\<open>actions:\\<close>\n    s' = s\\<lparr> progress := (progress s)(Rb \\<mapsto> {xpkE, xsk}),\n            secret := {x. x = NonceF (Rb$sk) \\<and> Rb = test} \\<union> secret s,\n            signals := if can_signal s A B then\n                          addSignal (signals s) (Running A B (\\<langle> KE, NonceF (Rb$sk) \\<rangle>))\n                       else\n                          signals s\n          \\<rparr>\n  }\""], ["", "definition\n  l1_step3 :: \"rid_t \\<Rightarrow> agent \\<Rightarrow> agent \\<Rightarrow> msg \\<Rightarrow> ('a l1_state_scheme * 'a l1_state_scheme) set\"\nwhere\n  \"l1_step3 Ra A B K \\<equiv> {(s, s').\n    \\<comment> \\<open>guards:\\<close>\n    guessed_runs Ra = \\<lparr>role=Init, owner=A, partner=B\\<rparr> \\<and>\n    progress s Ra = Some {xpkE, xskE} \\<and>\n    guessed_frame Ra xsk = Some K \\<and>\n    (can_signal s A B \\<longrightarrow> \\<comment> \\<open>authentication guard\\<close>\n      (\\<exists> Rb. guessed_runs Rb = \\<lparr>role=Resp, owner=B, partner=A\\<rparr> \\<and>\n             progress s Rb = Some {xpkE, xsk} \\<and>\n             guessed_frame Rb xpkE = Some (epubKF (Ra$kE)) \\<and>\n             guessed_frame Rb xsk = Some K)) \\<and>\n    (Ra = test \\<longrightarrow> K \\<notin> synth (analz (ik s))) \\<and>\n\n    \\<comment> \\<open>actions:\\<close>\n    s' = s\\<lparr> progress := (progress s)(Ra \\<mapsto> {xpkE, xskE, xsk}),\n            secret := {x. x = K \\<and> Ra = test} \\<union> secret s,\n            signals := if can_signal s A B then\n                         addSignal (signals s) (Commit A B \\<langle>epubKF (Ra$kE), K\\<rangle>)\n                       else\n                         signals s\n          \\<rparr>\n  }\""], ["", "text \\<open>specification\\<close>"], ["", "definition \n  l1_init :: \"l1_state set\"\nwhere\n  \"l1_init \\<equiv> { \\<lparr>\n    ik = {},\n    secret = {},\n    progress = Map.empty,\n    signals = \\<lambda>x. 0\n    \\<rparr> }\""], ["", "definition \n  l1_trans :: \"('a l1_state_scheme * 'a l1_state_scheme) set\" where\n  \"l1_trans \\<equiv> (\\<Union>m Ra Rb A B K KE.\n     l1_step1 Ra A B \\<union>\n     l1_step2 Rb A B KE \\<union>\n     l1_step3 Ra A B K \\<union>\n     l1_learn m \\<union>\n     Id\n  )\""], ["", "definition \n  l1 :: \"(l1_state, l1_obs) spec\" where\n  \"l1 \\<equiv> \\<lparr>\n    init = l1_init,\n    trans = l1_trans,\n    obs = id\n  \\<rparr>\""], ["", "lemmas l1_defs = \n  l1_def l1_init_def l1_trans_def\n  l1_learn_def\n  l1_step1_def l1_step2_def l1_step3_def"], ["", "lemmas l1_nostep_defs =\n  l1_def l1_init_def l1_trans_def"], ["", "lemma l1_obs_id [simp]: \"obs l1 = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs l1 = id", "by (simp add: l1_def)"], ["", "declare domIff [iff]"], ["", "lemma run_ended_trans:\n  \"run_ended (progress s R) \\<Longrightarrow>\n   (s, s') \\<in> trans l1 \\<Longrightarrow>\n   run_ended (progress s' R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>run_ended (progress s R); (s, s') \\<in> TS.trans l1\\<rbrakk>\n    \\<Longrightarrow> run_ended (progress s' R)", "apply (auto simp add: l1_nostep_defs)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xb xc.\n       \\<lbrakk>run_ended (progress s R);\n        (s, s') \\<in> l1_step1 x xb xc\\<rbrakk>\n       \\<Longrightarrow> run_ended (progress s' R)\n 2. \\<And>xa xb xc xd.\n       \\<lbrakk>run_ended (progress s R);\n        (s, s') \\<in> l1_step2 xa xb xc xd\\<rbrakk>\n       \\<Longrightarrow> run_ended (progress s' R)\n 3. \\<And>x xb xc xd.\n       \\<lbrakk>run_ended (progress s R);\n        (s, s') \\<in> l1_step3 x xb xc xd\\<rbrakk>\n       \\<Longrightarrow> run_ended (progress s' R)\n 4. \\<And>x.\n       \\<lbrakk>run_ended (progress s R); (s, s') \\<in> l1_learn x\\<rbrakk>\n       \\<Longrightarrow> run_ended (progress s' R)", "apply (simp add: l1_defs ik_dy_def, fast ?)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare domIff [iff del]"], ["", "lemma can_signal_trans:\n  \"can_signal s' A B \\<Longrightarrow>\n  (s, s') \\<in> trans l1 \\<Longrightarrow>\n  can_signal s A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>can_signal s' A B; (s, s') \\<in> TS.trans l1\\<rbrakk>\n    \\<Longrightarrow> can_signal s A B", "by (auto simp add: can_signal_def run_ended_trans)"], ["", "(**************************************************************************************************)"], ["", "subsection \\<open>Refinement: secrecy\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>mediator function\\<close>"], ["", "definition \n  med01s :: \"l1_obs \\<Rightarrow> s0_obs\"\nwhere\n  \"med01s t \\<equiv> \\<lparr> ik = ik t, secret = secret t \\<rparr>\""], ["", "text \\<open>relation between states\\<close>"], ["", "definition\n  R01s :: \"(s0_state * l1_state) set\"\nwhere\n  \"R01s \\<equiv> {(s,s').\n    s = \\<lparr>ik = ik s', secret = secret s'\\<rparr>\n    }\""], ["", "text \\<open>protocol independent events\\<close>"], ["", "lemma l1_learn_refines_learn:\n  \"{R01s} s0_learn m, l1_learn m {>R01s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01s} s0_learn m, l1_learn m {> R01s}", "apply (simp add: PO_rhoare_defs R01s_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, z).\n     \\<exists>y.\n        x = \\<lparr>ik = ik y, secret = secret y\\<rparr> \\<and>\n        (y, z) \\<in> l1_learn m}\n    \\<subseteq> {(x, z).\n                 (x, \\<lparr>ik = ik z, secret = secret z\\<rparr>)\n                 \\<in> s0_learn m}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b y.\n       (y, b) \\<in> l1_learn m \\<Longrightarrow>\n       (\\<lparr>ik = ik y, secret = secret y\\<rparr>,\n        \\<lparr>ik = ik b, secret = secret b\\<rparr>)\n       \\<in> s0_learn m", "apply (simp add: l1_defs s0_defs s0_secrecy_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>protocol events\\<close>"], ["", "lemma l1_step1_refines_skip:\n  \"{R01s} Id, l1_step1 Ra A B {>R01s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01s} Id, l1_step1 Ra A B {> R01s}", "by (auto simp add: PO_rhoare_defs R01s_def l1_step1_def)"], ["", "lemma l1_step2_refines_add_secret_skip:\n  \"{R01s} s0_add_secret (NonceF (Rb$sk)) \\<union> Id, l1_step2 Rb A B KE {>R01s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01s} (s0_add_secret\n             (NonceF (Rb $ sk)))\\<^sup>=, l1_step2 Rb A B KE {> R01s}", "apply (auto simp add: PO_rhoare_defs R01s_def s0_add_secret_def)"], ["proof (prove)\ngoal (24 subgoals):\n 1. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l1_step2 Rb A B KE;\n        NonceF (Rb $ sk) \\<in> analz (ik y); x \\<in> ik y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ik b\n 2. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l1_step2 Rb A B KE;\n        NonceF (Rb $ sk) \\<in> analz (ik y); x \\<in> ik b\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ik y\n 3. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l1_step2 Rb A B KE;\n        NonceF (Rb $ sk) \\<in> analz (ik y); x \\<in> secret y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> secret b\n 4. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l1_step2 Rb A B KE;\n        NonceF (Rb $ sk) \\<in> analz (ik y); x \\<in> secret b\\<rbrakk>\n       \\<Longrightarrow> x \\<in> secret y\n 5. \\<And>b y x xa.\n       \\<lbrakk>(y, b) \\<in> l1_step2 Rb A B KE; x \\<in> ik y;\n        x \\<notin> ik b; xa \\<in> ik b\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> ik y\n 6. \\<And>b y x xa.\n       \\<lbrakk>(y, b) \\<in> l1_step2 Rb A B KE; x \\<in> ik y;\n        x \\<notin> ik b; xa \\<in> ik y\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> ik b\n 7. \\<And>b y x xa.\n       \\<lbrakk>(y, b) \\<in> l1_step2 Rb A B KE; x \\<in> ik y;\n        x \\<notin> ik b; xa \\<in> secret b; xa \\<notin> secret y\\<rbrakk>\n       \\<Longrightarrow> xa = NonceF (Rb $ sk)\n 8. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l1_step2 Rb A B KE; x \\<in> ik y;\n        x \\<notin> ik b\\<rbrakk>\n       \\<Longrightarrow> NonceF (Rb $ sk) \\<in> secret b\n 9. \\<And>b y x xa.\n       \\<lbrakk>(y, b) \\<in> l1_step2 Rb A B KE; x \\<in> ik y;\n        x \\<notin> ik b; xa \\<in> secret y\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> secret b\n 10. \\<And>b y x xa.\n        \\<lbrakk>(y, b) \\<in> l1_step2 Rb A B KE; x \\<in> ik b;\n         x \\<notin> ik y; xa \\<in> ik b\\<rbrakk>\n        \\<Longrightarrow> xa \\<in> ik y\nA total of 24 subgoals...", "apply (auto simp add: l1_step2_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma l1_step3_refines_add_secret_skip:\n  \"{R01s} s0_add_secret K \\<union> Id, l1_step3 Ra A B K {>R01s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01s} (s0_add_secret K)\\<^sup>=, l1_step3 Ra A B K {> R01s}", "apply (auto simp add: PO_rhoare_defs R01s_def s0_add_secret_def)"], ["proof (prove)\ngoal (24 subgoals):\n 1. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l1_step3 Ra A B K;\n        K \\<in> synth (analz (ik y)); x \\<in> ik y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ik b\n 2. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l1_step3 Ra A B K;\n        K \\<in> synth (analz (ik y)); x \\<in> ik b\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ik y\n 3. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l1_step3 Ra A B K;\n        K \\<in> synth (analz (ik y)); x \\<in> secret y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> secret b\n 4. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l1_step3 Ra A B K;\n        K \\<in> synth (analz (ik y)); x \\<in> secret b\\<rbrakk>\n       \\<Longrightarrow> x \\<in> secret y\n 5. \\<And>b y x xa.\n       \\<lbrakk>(y, b) \\<in> l1_step3 Ra A B K; x \\<in> ik y;\n        x \\<notin> ik b; xa \\<in> ik b\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> ik y\n 6. \\<And>b y x xa.\n       \\<lbrakk>(y, b) \\<in> l1_step3 Ra A B K; x \\<in> ik y;\n        x \\<notin> ik b; xa \\<in> ik y\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> ik b\n 7. \\<And>b y x xa.\n       \\<lbrakk>(y, b) \\<in> l1_step3 Ra A B K; x \\<in> ik y;\n        x \\<notin> ik b; xa \\<in> secret b; xa \\<notin> secret y\\<rbrakk>\n       \\<Longrightarrow> xa = K\n 8. \\<And>b y x.\n       \\<lbrakk>(y, b) \\<in> l1_step3 Ra A B K; x \\<in> ik y;\n        x \\<notin> ik b\\<rbrakk>\n       \\<Longrightarrow> K \\<in> secret b\n 9. \\<And>b y x xa.\n       \\<lbrakk>(y, b) \\<in> l1_step3 Ra A B K; x \\<in> ik y;\n        x \\<notin> ik b; xa \\<in> secret y\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> secret b\n 10. \\<And>b y x xa.\n        \\<lbrakk>(y, b) \\<in> l1_step3 Ra A B K; x \\<in> ik b;\n         x \\<notin> ik y; xa \\<in> ik b\\<rbrakk>\n        \\<Longrightarrow> xa \\<in> ik y\nA total of 24 subgoals...", "apply (auto simp add: l1_step3_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>refinement proof\\<close>"], ["", "lemmas l1_trans_refines_s0_trans = \n  l1_learn_refines_learn\n  l1_step1_refines_skip l1_step2_refines_add_secret_skip l1_step3_refines_add_secret_skip"], ["", "lemma l1_refines_init_s0 [iff]:\n  \"init l1 \\<subseteq> R01s `` (init s0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init l1 \\<subseteq> R01s `` init s0", "by (auto simp add: R01s_def s0_defs l1_defs s0_secrecy_def)"], ["", "lemma l1_refines_trans_s0 [iff]:\n  \"{R01s} trans s0, trans l1 {> R01s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01s} TS.trans s0, TS.trans l1 {> R01s}", "by (auto simp add: s0_def l1_def s0_trans_def l1_trans_def \n         intro: l1_trans_refines_s0_trans)"], ["", "lemma obs_consistent_med01x [iff]: \n  \"obs_consistent R01s med01s s0 l1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent R01s med01s s0 l1", "by (auto simp add: obs_consistent_def R01s_def med01s_def)"], ["", "text \\<open>refinement result\\<close>"], ["", "lemma l1s_refines_s0 [iff]: \n  \"refines \n     R01s\n     med01s s0 l1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines R01s med01s s0 l1", "by (auto simp add:refines_def PO_refines_def)"], ["", "lemma  l1_implements_s0 [iff]: \"implements med01s s0 l1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements med01s s0 l1", "by (rule refinement_soundness) (fast)"], ["", "(**************************************************************************************************)"], ["", "subsection \\<open>Derived invariants: secrecy\\<close>"], ["", "(**************************************************************************************************)"], ["", "abbreviation \"l1_secrecy \\<equiv> s0_secrecy\""], ["", "lemma l1_obs_secrecy [iff]: \"oreach l1 \\<subseteq> l1_secrecy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oreach l1 \\<subseteq> l1_secrecy", "apply (rule external_invariant_translation \n         [OF s0_obs_secrecy _ l1_implements_s0])"], ["proof (prove)\ngoal (1 subgoal):\n 1. med01s -` l1_secrecy \\<subseteq> l1_secrecy", "apply (auto simp add: med01s_def s0_secrecy_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma l1_secrecy [iff]: \"reach l1 \\<subseteq> l1_secrecy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l1 \\<subseteq> l1_secrecy", "by (rule external_to_internal_invariant [OF l1_obs_secrecy], auto)"], ["", "(**************************************************************************************************)"], ["", "subsection \\<open>Invariants\\<close>"], ["", "(**************************************************************************************************)"], ["", "subsubsection \\<open>inv1\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>if a commit signal for a nonce has been emitted,\n then there is a finished initiator run with this nonce.\n\\<close>"], ["", "definition\n  l1_inv1 :: \"l1_state set\"\nwhere\n  \"l1_inv1 \\<equiv> {s. \\<forall> Ra A B K.\n    signals s (Commit A B \\<langle>epubKF (Ra$kE), K\\<rangle>) > 0 \\<longrightarrow>\n      guessed_runs Ra = \\<lparr>role=Init, owner=A, partner=B\\<rparr> \\<and>\n      progress s Ra = Some {xpkE, xskE, xsk} \\<and>\n      guessed_frame Ra xsk = Some K\n   }\""], ["", "lemmas l1_inv1I = l1_inv1_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas l1_inv1E [elim] = l1_inv1_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas l1_inv1D = l1_inv1_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]"], ["", "lemma l1_inv1_init [iff]:\n  \"init l1 \\<subseteq> l1_inv1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init l1 \\<subseteq> l1_inv1", "by (auto simp add: l1_def l1_init_def l1_inv1_def)"], ["", "declare domIff [iff]"], ["", "lemma l1_inv1_trans [iff]:\n  \"{l1_inv1} trans l1 {> l1_inv1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l1_inv1} TS.trans l1 {> l1_inv1}", "apply (auto simp add: PO_hoare_defs l1_nostep_defs intro!: l1_inv1I)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x Ra A B K xa xb xd xe.\n       \\<lbrakk>0 < l1_state.signals x\n                     (Commit A B \\<langle>epubKF (Ra $ kE), K\\<rangle>);\n        xa \\<in> l1_inv1; (xa, x) \\<in> l1_step1 xb xd xe\\<rbrakk>\n       \\<Longrightarrow> guessed_runs Ra =\n                         \\<lparr>role = Init, owner = A, partner = B\\<rparr>\n 2. \\<And>x Ra A B K xa xb xd xe.\n       \\<lbrakk>0 < l1_state.signals x\n                     (Commit A B \\<langle>epubKF (Ra $ kE), K\\<rangle>);\n        xa \\<in> l1_inv1; (xa, x) \\<in> l1_step1 xb xd xe\\<rbrakk>\n       \\<Longrightarrow> progress x Ra = Some {xpkE, xskE, xsk}\n 3. \\<And>x Ra A B K xa xb xd xe.\n       \\<lbrakk>0 < l1_state.signals x\n                     (Commit A B \\<langle>epubKF (Ra $ kE), K\\<rangle>);\n        xa \\<in> l1_inv1; (xa, x) \\<in> l1_step1 xb xd xe\\<rbrakk>\n       \\<Longrightarrow> guessed_frame Ra xsk = Some K\n 4. \\<And>x Ra A B K xa xc xd xe xf.\n       \\<lbrakk>0 < l1_state.signals x\n                     (Commit A B \\<langle>epubKF (Ra $ kE), K\\<rangle>);\n        xa \\<in> l1_inv1; (xa, x) \\<in> l1_step2 xc xd xe xf\\<rbrakk>\n       \\<Longrightarrow> guessed_runs Ra =\n                         \\<lparr>role = Init, owner = A, partner = B\\<rparr>\n 5. \\<And>x Ra A B K xa xc xd xe xf.\n       \\<lbrakk>0 < l1_state.signals x\n                     (Commit A B \\<langle>epubKF (Ra $ kE), K\\<rangle>);\n        xa \\<in> l1_inv1; (xa, x) \\<in> l1_step2 xc xd xe xf\\<rbrakk>\n       \\<Longrightarrow> progress x Ra = Some {xpkE, xskE, xsk}\n 6. \\<And>x Ra A B K xa xc xd xe xf.\n       \\<lbrakk>0 < l1_state.signals x\n                     (Commit A B \\<langle>epubKF (Ra $ kE), K\\<rangle>);\n        xa \\<in> l1_inv1; (xa, x) \\<in> l1_step2 xc xd xe xf\\<rbrakk>\n       \\<Longrightarrow> guessed_frame Ra xsk = Some K\n 7. \\<And>x Ra A B K xa xb xd xe xf.\n       \\<lbrakk>0 < l1_state.signals x\n                     (Commit A B \\<langle>epubKF (Ra $ kE), K\\<rangle>);\n        xa \\<in> l1_inv1; (xa, x) \\<in> l1_step3 xb xd xe xf\\<rbrakk>\n       \\<Longrightarrow> guessed_runs Ra =\n                         \\<lparr>role = Init, owner = A, partner = B\\<rparr>\n 8. \\<And>x Ra A B K xa xb xd xe xf.\n       \\<lbrakk>0 < l1_state.signals x\n                     (Commit A B \\<langle>epubKF (Ra $ kE), K\\<rangle>);\n        xa \\<in> l1_inv1; (xa, x) \\<in> l1_step3 xb xd xe xf\\<rbrakk>\n       \\<Longrightarrow> progress x Ra = Some {xpkE, xskE, xsk}\n 9. \\<And>x Ra A B K xa xb xd xe xf.\n       \\<lbrakk>0 < l1_state.signals x\n                     (Commit A B \\<langle>epubKF (Ra $ kE), K\\<rangle>);\n        xa \\<in> l1_inv1; (xa, x) \\<in> l1_step3 xb xd xe xf\\<rbrakk>\n       \\<Longrightarrow> guessed_frame Ra xsk = Some K\n 10. \\<And>x Ra A B K xa xb.\n        \\<lbrakk>0 < l1_state.signals x\n                      (Commit A B \\<langle>epubKF (Ra $ kE), K\\<rangle>);\n         xa \\<in> l1_inv1; (xa, x) \\<in> l1_learn xb\\<rbrakk>\n        \\<Longrightarrow> guessed_runs Ra =\n                          \\<lparr>role = Init, owner = A,\n                             partner = B\\<rparr>\nA total of 12 subgoals...", "apply (auto simp add: l1_defs ik_dy_def l1_inv1_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_l1_inv1 [iff]: \"reach l1 \\<subseteq> l1_inv1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l1 \\<subseteq> l1_inv1", "by (rule inv_rule_basic) (auto)"], ["", "subsubsection \\<open>inv2\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>if a responder run knows a nonce, then a running signal for this nonce has been emitted\\<close>"], ["", "definition\n  l1_inv2 :: \"l1_state set\"\nwhere\n  \"l1_inv2 \\<equiv> {s. \\<forall> KE A B Rb.\n    guessed_runs Rb = \\<lparr>role=Resp, owner=B, partner=A\\<rparr> \\<longrightarrow>\n    progress s Rb = Some {xpkE, xsk} \\<longrightarrow>\n    guessed_frame Rb xpkE = Some KE \\<longrightarrow>\n    can_signal s A B \\<longrightarrow>\n      signals s (Running A B \\<langle>KE, NonceF (Rb$sk)\\<rangle>) > 0\n  }\""], ["", "lemmas l1_inv2I = l1_inv2_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas l1_inv2E [elim] = l1_inv2_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas l1_inv2D = l1_inv2_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]"], ["", "lemma l1_inv2_init [iff]:\n  \"init l1 \\<subseteq> l1_inv2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init l1 \\<subseteq> l1_inv2", "by (auto simp add: l1_def l1_init_def l1_inv2_def)"], ["", "lemma l1_inv2_trans [iff]:\n  \"{l1_inv2} trans l1 {> l1_inv2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l1_inv2} TS.trans l1 {> l1_inv2}", "apply (auto simp add: PO_hoare_defs intro!: l1_inv2I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x KE A B Rb xa.\n       \\<lbrakk>guessed_runs Rb =\n                \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        progress x Rb = Some {xpkE, xsk}; guessed_frame Rb xpkE = Some KE;\n        can_signal x A B; xa \\<in> l1_inv2;\n        (xa, x) \\<in> TS.trans l1\\<rbrakk>\n       \\<Longrightarrow> 0 < l1_state.signals x\n                              (Running A B\n                                \\<langle>KE, NonceF (Rb $ sk)\\<rangle>)", "apply (drule can_signal_trans, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x KE A B Rb xa.\n       \\<lbrakk>guessed_runs Rb =\n                \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        progress x Rb = Some {xpkE, xsk}; guessed_frame Rb xpkE = Some KE;\n        xa \\<in> l1_inv2; (xa, x) \\<in> TS.trans l1;\n        can_signal xa A B\\<rbrakk>\n       \\<Longrightarrow> 0 < l1_state.signals x\n                              (Running A B\n                                \\<langle>KE, NonceF (Rb $ sk)\\<rangle>)", "apply (auto simp add: l1_nostep_defs)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x KE A B Rb xa xb xd xe.\n       \\<lbrakk>guessed_runs Rb =\n                \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        progress x Rb = Some {xpkE, xsk}; guessed_frame Rb xpkE = Some KE;\n        xa \\<in> l1_inv2; can_signal xa A B;\n        (xa, x) \\<in> l1_step1 xb xd xe\\<rbrakk>\n       \\<Longrightarrow> 0 < l1_state.signals x\n                              (Running A B\n                                \\<langle>KE, NonceF (Rb $ sk)\\<rangle>)\n 2. \\<And>x KE A B Rb xa xc xd xe xf.\n       \\<lbrakk>guessed_runs Rb =\n                \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        progress x Rb = Some {xpkE, xsk}; guessed_frame Rb xpkE = Some KE;\n        xa \\<in> l1_inv2; can_signal xa A B;\n        (xa, x) \\<in> l1_step2 xc xd xe xf\\<rbrakk>\n       \\<Longrightarrow> 0 < l1_state.signals x\n                              (Running A B\n                                \\<langle>KE, NonceF (Rb $ sk)\\<rangle>)\n 3. \\<And>x KE A B Rb xa xb xd xe xf.\n       \\<lbrakk>guessed_runs Rb =\n                \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        progress x Rb = Some {xpkE, xsk}; guessed_frame Rb xpkE = Some KE;\n        xa \\<in> l1_inv2; can_signal xa A B;\n        (xa, x) \\<in> l1_step3 xb xd xe xf\\<rbrakk>\n       \\<Longrightarrow> 0 < l1_state.signals x\n                              (Running A B\n                                \\<langle>KE, NonceF (Rb $ sk)\\<rangle>)\n 4. \\<And>x KE A B Rb xa xb.\n       \\<lbrakk>guessed_runs Rb =\n                \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        progress x Rb = Some {xpkE, xsk}; guessed_frame Rb xpkE = Some KE;\n        xa \\<in> l1_inv2; can_signal xa A B;\n        (xa, x) \\<in> l1_learn xb\\<rbrakk>\n       \\<Longrightarrow> 0 < l1_state.signals x\n                              (Running A B\n                                \\<langle>KE, NonceF (Rb $ sk)\\<rangle>)", "apply (auto simp add: l1_defs ik_dy_def l1_inv2_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma PO_l1_inv2 [iff]: \"reach l1 \\<subseteq> l1_inv2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l1 \\<subseteq> l1_inv2", "by (rule inv_rule_basic) (auto)"], ["", "subsubsection \\<open>inv3 (derived)\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>if an unfinished initiator run and a finished responder run both know the same nonce,\n then the number of running signals for this nonce is strictly greater than the number of commit\n signals.\n (actually, there are 0 commit and 1 running)\n\\<close>"], ["", "definition\n  l1_inv3 :: \"l1_state set\"\nwhere\n  \"l1_inv3 \\<equiv> {s. \\<forall> A B Rb Ra.\n    guessed_runs Rb = \\<lparr>role=Resp, owner=B, partner=A\\<rparr> \\<longrightarrow>\n    progress s Rb = Some {xpkE, xsk} \\<longrightarrow>\n    guessed_frame Rb xpkE = Some (epubKF (Ra$kE)) \\<longrightarrow>\n    guessed_runs Ra = \\<lparr>role=Init, owner=A, partner=B\\<rparr> \\<longrightarrow>\n    progress s Ra = Some {xpkE, xskE} \\<longrightarrow>\n    can_signal s A B \\<longrightarrow>\n      signals s (Commit A B (\\<langle>epubKF (Ra$kE), NonceF (Rb$sk)\\<rangle>)) \n    < signals s (Running A B (\\<langle>epubKF (Ra$kE), NonceF (Rb$sk)\\<rangle>)) \n  }\""], ["", "lemmas l1_inv3I = l1_inv3_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas l1_inv3E [elim] = l1_inv3_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas l1_inv3D = l1_inv3_def [THEN setc_def_to_dest, rule_format, rotated 1, simplified]"], ["", "lemma l1_inv3_derived: \"l1_inv1 \\<inter> l1_inv2 \\<subseteq> l1_inv3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l1_inv1 \\<inter> l1_inv2 \\<subseteq> l1_inv3", "apply (auto intro!: l1_inv3I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Ra.\n       \\<lbrakk>guessed_runs Rb =\n                \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        progress x Rb = Some {xpkE, xsk};\n        guessed_frame Rb xpkE = Some (epubKF (Ra $ kE));\n        guessed_runs Ra =\n        \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        progress x Ra = Some {xpkE, xskE}; can_signal x A B;\n        x \\<in> l1_inv1; x \\<in> l1_inv2\\<rbrakk>\n       \\<Longrightarrow> l1_state.signals x\n                          (Commit A B\n                            \\<langle>epubKF (Ra $ kE),\n                              NonceF (Rb $ sk)\\<rangle>)\n                         < l1_state.signals x\n                            (Running A B\n                              \\<langle>epubKF (Ra $ kE),\n                                NonceF (Rb $ sk)\\<rangle>)", "apply (auto dest!: l1_inv2D)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Ra.\n       \\<lbrakk>progress x Rb = Some {xpkE, xsk};\n        guessed_frame Rb xpkE = Some (epubKF (Ra $ kE));\n        guessed_runs Ra =\n        \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        progress x Ra = Some {xpkE, xskE}; can_signal x A B;\n        x \\<in> l1_inv1; x \\<in> l1_inv2;\n        0 < l1_state.signals x\n             (Running A B\n               \\<langle>epubKF (Ra $ kE),\n                 NonceF (Rb $ sk)\\<rangle>)\\<rbrakk>\n       \\<Longrightarrow> l1_state.signals x\n                          (Commit A B\n                            \\<langle>epubKF (Ra $ kE),\n                              NonceF (Rb $ sk)\\<rangle>)\n                         < l1_state.signals x\n                            (Running A B\n                              \\<langle>epubKF (Ra $ kE),\n                                NonceF (Rb $ sk)\\<rangle>)", "apply (rename_tac x A B Rb Ra)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Ra.\n       \\<lbrakk>progress x Rb = Some {xpkE, xsk};\n        guessed_frame Rb xpkE = Some (epubKF (Ra $ kE));\n        guessed_runs Ra =\n        \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        progress x Ra = Some {xpkE, xskE}; can_signal x A B;\n        x \\<in> l1_inv1; x \\<in> l1_inv2;\n        0 < l1_state.signals x\n             (Running A B\n               \\<langle>epubKF (Ra $ kE),\n                 NonceF (Rb $ sk)\\<rangle>)\\<rbrakk>\n       \\<Longrightarrow> l1_state.signals x\n                          (Commit A B\n                            \\<langle>epubKF (Ra $ kE),\n                              NonceF (Rb $ sk)\\<rangle>)\n                         < l1_state.signals x\n                            (Running A B\n                              \\<langle>epubKF (Ra $ kE),\n                                NonceF (Rb $ sk)\\<rangle>)", "apply (case_tac \"signals x (Commit A B \\<langle>epubKF (Ra $ kE), NonceF (Rb $ sk)\\<rangle>) > 0\", auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x A B Rb Ra.\n       \\<lbrakk>progress x Rb = Some {xpkE, xsk};\n        guessed_frame Rb xpkE = Some (epubKF (Ra $ kE));\n        guessed_runs Ra =\n        \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        progress x Ra = Some {xpkE, xskE}; can_signal x A B;\n        x \\<in> l1_inv1; x \\<in> l1_inv2;\n        0 < l1_state.signals x\n             (Running A B\n               \\<langle>epubKF (Ra $ kE), NonceF (Rb $ sk)\\<rangle>);\n        0 < l1_state.signals x\n             (Commit A B\n               \\<langle>epubKF (Ra $ kE),\n                 NonceF (Rb $ sk)\\<rangle>)\\<rbrakk>\n       \\<Longrightarrow> l1_state.signals x\n                          (Commit A B\n                            \\<langle>epubKF (Ra $ kE),\n                              NonceF (Rb $ sk)\\<rangle>)\n                         < l1_state.signals x\n                            (Running A B\n                              \\<langle>epubKF (Ra $ kE),\n                                NonceF (Rb $ sk)\\<rangle>)", "apply (fastforce dest: l1_inv1D elim: equalityE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(**************************************************************************************************)"], ["", "subsection \\<open>Refinement: injective agreement\\<close>"], ["", "(**************************************************************************************************)"], ["", "text \\<open>mediator function\\<close>"], ["", "definition \n  med01ia :: \"l1_obs \\<Rightarrow> a0i_obs\"\nwhere\n  \"med01ia t \\<equiv> \\<lparr>a0n_state.signals = signals t\\<rparr>\""], ["", "text \\<open>relation between states\\<close>"], ["", "definition\n  R01ia :: \"(a0i_state * l1_state) set\"\nwhere\n  \"R01ia \\<equiv> {(s,s').\n    a0n_state.signals s = signals s'\n    }\""], ["", "text \\<open>protocol independent events\\<close>"], ["", "lemma l1_learn_refines_a0_ia_skip:\n  \"{R01ia} Id, l1_learn m {>R01ia}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01ia} Id, l1_learn m {> R01ia}", "apply (auto simp add: PO_rhoare_defs R01ia_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>a0n_state.signals a = l1_state.signals y;\n        (y, b) \\<in> l1_learn m\\<rbrakk>\n       \\<Longrightarrow> l1_state.signals y = l1_state.signals b", "apply (simp add: l1_learn_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>protocol events\\<close>"], ["", "lemma l1_step1_refines_a0i_skip:\n  \"{R01ia} Id, l1_step1 Ra A B {>R01ia}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01ia} Id, l1_step1 Ra A B {> R01ia}", "by (auto simp add: PO_rhoare_defs R01ia_def l1_step1_def)"], ["", "lemma l1_step2_refines_a0i_running_skip:\n  \"{R01ia} a0i_running A B \\<langle>KE, NonceF (Rb$sk)\\<rangle> \\<union> Id, l1_step2 Rb A B KE {>R01ia}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01ia} (a0i_running A B\n              \\<langle>KE,\n                NonceF\n                 (Rb $ sk)\\<rangle>)\\<^sup>=, l1_step2 Rb A B KE {> R01ia}", "by (auto simp add: PO_rhoare_defs R01ia_def, simp_all add: l1_step2_def a0i_running_def, auto)"], ["", "lemma l1_step3_refines_a0i_commit_skip:\n  \"{R01ia \\<inter> (UNIV \\<times> l1_inv3)} a0i_commit A B \\<langle>epubKF (Ra$kE), K\\<rangle> \\<union> Id, l1_step3 Ra A B K {>R01ia}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01ia \\<inter>\n     UNIV \\<times>\n     l1_inv3} (a0i_commit A B\n                \\<langle>epubKF (Ra $ kE),\n                  K\\<rangle>)\\<^sup>=, l1_step3 Ra A B K {> R01ia}", "apply (auto simp add: PO_rhoare_defs R01ia_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>a0n_state.signals a = l1_state.signals y; y \\<in> l1_inv3;\n        (y, b) \\<in> l1_step3 Ra A B K\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            ((a, y)\n                             \\<in> a0i_commit A B\n                                    \\<langle>epubKF (Ra $ kE),\nK\\<rangle> \\<or>\n                             a = y) \\<and>\n                            a0n_state.signals y = l1_state.signals b", "apply (auto simp add: l1_step3_def a0i_commit_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a y Rb.\n       \\<lbrakk>a0n_state.signals a = l1_state.signals y; y \\<in> l1_inv3;\n        guessed_runs Ra =\n        \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        progress y Ra = Some {xpkE, xskE};\n        guessed_frame Ra xsk = Some (NonceF (Rb $ sk));\n        guessed_runs Rb =\n        \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        progress y Rb = Some {xpkE, xsk};\n        guessed_frame Rb xpkE = Some (epubKF (Ra $ kE)); Ra \\<noteq> test;\n        can_signal y A B; K = NonceF (Rb $ sk)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            (l1_state.signals y\n                              (Commit A B\n                                \\<langle>epubKF (Ra $ kE),\n                                  NonceF (Rb $ sk)\\<rangle>)\n                             < l1_state.signals y\n                                (Running A B\n                                  \\<langle>epubKF (Ra $ kE),\n                                    NonceF (Rb $ sk)\\<rangle>) \\<and>\n                             ya = a\n                             \\<lparr>a0n_state.signals :=\n (l1_state.signals y)\n (Commit A B \\<langle>epubKF (Ra $ kE), NonceF (Rb $ sk)\\<rangle> :=\n    Suc (l1_state.signals y\n          (Commit A B\n            \\<langle>epubKF (Ra $ kE),\n              NonceF (Rb $ sk)\\<rangle>)))\\<rparr> \\<or>\n                             a = ya) \\<and>\n                            a0n_state.signals ya = (l1_state.signals y)\n                            (Commit A B\n                              \\<langle>epubKF (Ra $ kE),\n                                NonceF (Rb $ sk)\\<rangle> :=\n                               Suc (l1_state.signals y\n                                     (Commit A B\n \\<langle>epubKF (Ra $ kE), NonceF (Rb $ sk)\\<rangle>)))\n 2. \\<And>a y Rb.\n       \\<lbrakk>a0n_state.signals a = l1_state.signals y; y \\<in> l1_inv3;\n        guessed_runs Ra =\n        \\<lparr>role = Init, owner = A, partner = B\\<rparr>;\n        progress y Ra = Some {xpkE, xskE};\n        guessed_frame Ra xsk = Some (NonceF (Rb $ sk));\n        guessed_runs Rb =\n        \\<lparr>role = Resp, owner = B, partner = A\\<rparr>;\n        progress y Rb = Some {xpkE, xsk};\n        guessed_frame Rb xpkE = Some (epubKF (Ra $ kE));\n        NonceF (Rb $ sk) \\<notin> analz (ik y); can_signal y A B;\n        K = NonceF (Rb $ sk)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ya.\n                            (l1_state.signals y\n                              (Commit A B\n                                \\<langle>epubKF (Ra $ kE),\n                                  NonceF (Rb $ sk)\\<rangle>)\n                             < l1_state.signals y\n                                (Running A B\n                                  \\<langle>epubKF (Ra $ kE),\n                                    NonceF (Rb $ sk)\\<rangle>) \\<and>\n                             ya = a\n                             \\<lparr>a0n_state.signals :=\n (l1_state.signals y)\n (Commit A B \\<langle>epubKF (Ra $ kE), NonceF (Rb $ sk)\\<rangle> :=\n    Suc (l1_state.signals y\n          (Commit A B\n            \\<langle>epubKF (Ra $ kE),\n              NonceF (Rb $ sk)\\<rangle>)))\\<rparr> \\<or>\n                             a = ya) \\<and>\n                            a0n_state.signals ya = (l1_state.signals y)\n                            (Commit A B\n                              \\<langle>epubKF (Ra $ kE),\n                                NonceF (Rb $ sk)\\<rangle> :=\n                               Suc (l1_state.signals y\n                                     (Commit A B\n \\<langle>epubKF (Ra $ kE), NonceF (Rb $ sk)\\<rangle>)))", "apply (force elim!: l1_inv3E)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>refinement proof\\<close>"], ["", "lemmas l1_trans_refines_a0i_trans = \n  l1_learn_refines_a0_ia_skip\n  l1_step1_refines_a0i_skip l1_step2_refines_a0i_running_skip l1_step3_refines_a0i_commit_skip"], ["", "lemma l1_refines_init_a0i [iff]:\n  \"init l1 \\<subseteq> R01ia `` (init a0i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init l1 \\<subseteq> R01ia `` init a0i", "by (auto simp add: R01ia_def a0i_defs l1_defs)"], ["", "lemma l1_refines_trans_a0i [iff]:\n  \"{R01ia \\<inter> (UNIV \\<times> (l1_inv1 \\<inter> l1_inv2))} trans a0i, trans l1 {> R01ia}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01ia \\<inter>\n     UNIV \\<times>\n     (l1_inv1 \\<inter> l1_inv2)} TS.trans a0i, TS.trans l1 {> R01ia}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {R01ia \\<inter>\n     UNIV \\<times>\n     (l1_inv1 \\<inter> l1_inv2)} TS.trans a0i, TS.trans l1 {> R01ia}", "let ?pre' = \"R01ia \\<inter> (UNIV \\<times> l1_inv3)\""], ["proof (state)\ngoal (1 subgoal):\n 1. {R01ia \\<inter>\n     UNIV \\<times>\n     (l1_inv1 \\<inter> l1_inv2)} TS.trans a0i, TS.trans l1 {> R01ia}", "show ?thesis (is \"{?pre} ?t1, ?t2 {>?post}\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01ia \\<inter>\n     UNIV \\<times>\n     (l1_inv1 \\<inter> l1_inv2)} TS.trans a0i, TS.trans l1 {> R01ia}", "proof (rule relhoare_conseq_left)"], ["proof (state)\ngoal (2 subgoals):\n 1. {?pre'} TS.trans a0i, TS.trans l1 {> R01ia}\n 2. R01ia \\<inter> UNIV \\<times> (l1_inv1 \\<inter> l1_inv2)\n    \\<subseteq> ?pre'", "show \"?pre \\<subseteq> ?pre'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R01ia \\<inter> UNIV \\<times> (l1_inv1 \\<inter> l1_inv2)\n    \\<subseteq> R01ia \\<inter> UNIV \\<times> l1_inv3", "using l1_inv3_derived"], ["proof (prove)\nusing this:\n  l1_inv1 \\<inter> l1_inv2 \\<subseteq> l1_inv3\n\ngoal (1 subgoal):\n 1. R01ia \\<inter> UNIV \\<times> (l1_inv1 \\<inter> l1_inv2)\n    \\<subseteq> R01ia \\<inter> UNIV \\<times> l1_inv3", "by blast"], ["proof (state)\nthis:\n  R01ia \\<inter> UNIV \\<times> (l1_inv1 \\<inter> l1_inv2)\n  \\<subseteq> R01ia \\<inter> UNIV \\<times> l1_inv3\n\ngoal (1 subgoal):\n 1. {R01ia \\<inter>\n     UNIV \\<times> l1_inv3} TS.trans a0i, TS.trans l1 {> R01ia}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {R01ia \\<inter>\n     UNIV \\<times> l1_inv3} TS.trans a0i, TS.trans l1 {> R01ia}", "show \"{?pre'} ?t1, ?t2 {> ?post}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R01ia \\<inter>\n     UNIV \\<times> l1_inv3} TS.trans a0i, TS.trans l1 {> R01ia}", "apply (auto simp add: a0i_def l1_def a0i_trans_def l1_trans_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xb xc.\n       {R01ia \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step1 x xb xc {> R01ia}\n 2. \\<And>xa xb xc xd.\n       {R01ia \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step2 xa xb xc xd {> R01ia}\n 3. \\<And>x xb xc xd.\n       {R01ia \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step3 x xb xc xd {> R01ia}\n 4. \\<And>x.\n       {R01ia \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x xa))))\\<^sup>=, l1_learn x {> R01ia}", "prefer 2"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa xb xc xd.\n       {R01ia \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step2 xa xb xc xd {> R01ia}\n 2. \\<And>x xb xc.\n       {R01ia \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step1 x xb xc {> R01ia}\n 3. \\<And>x xb xc xd.\n       {R01ia \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step3 x xb xc xd {> R01ia}\n 4. \\<And>x.\n       {R01ia \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x xa))))\\<^sup>=, l1_learn x {> R01ia}", "using l1_step2_refines_a0i_running_skip"], ["proof (prove)\nusing this:\n  {R01ia} (a0i_running ?A ?B\n            \\<langle>?KE,\n              NonceF\n               (?Rb $\n                sk)\\<rangle>)\\<^sup>=, l1_step2 ?Rb ?A ?B ?KE {> R01ia}\n\ngoal (4 subgoals):\n 1. \\<And>xa xb xc xd.\n       {R01ia \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step2 xa xb xc xd {> R01ia}\n 2. \\<And>x xb xc.\n       {R01ia \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step1 x xb xc {> R01ia}\n 3. \\<And>x xb xc xd.\n       {R01ia \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step3 x xb xc xd {> R01ia}\n 4. \\<And>x.\n       {R01ia \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x xa))))\\<^sup>=, l1_learn x {> R01ia}", "apply (simp add: PO_rhoare_defs, blast)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xb xc.\n       {R01ia \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step1 x xb xc {> R01ia}\n 2. \\<And>x xb xc xd.\n       {R01ia \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step3 x xb xc xd {> R01ia}\n 3. \\<And>x.\n       {R01ia \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x xa))))\\<^sup>=, l1_learn x {> R01ia}", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xb xc xd.\n       {R01ia \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step3 x xb xc xd {> R01ia}\n 2. \\<And>x xb xc.\n       {R01ia \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step1 x xb xc {> R01ia}\n 3. \\<And>x.\n       {R01ia \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x xa))))\\<^sup>=, l1_learn x {> R01ia}", "using l1_step3_refines_a0i_commit_skip"], ["proof (prove)\nusing this:\n  {R01ia \\<inter>\n   UNIV \\<times>\n   l1_inv3} (a0i_commit ?A ?B\n              \\<langle>epubKF (?Ra $ kE),\n                ?K\\<rangle>)\\<^sup>=, l1_step3 ?Ra ?A ?B ?K {> R01ia}\n\ngoal (3 subgoals):\n 1. \\<And>x xb xc xd.\n       {R01ia \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step3 x xb xc xd {> R01ia}\n 2. \\<And>x xb xc.\n       {R01ia \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step1 x xb xc {> R01ia}\n 3. \\<And>x.\n       {R01ia \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x xa))))\\<^sup>=, l1_learn x {> R01ia}", "apply (simp add: PO_rhoare_defs, blast)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xb xc.\n       {R01ia \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x\n                           xa))))\\<^sup>=, l1_step1 x xb xc {> R01ia}\n 2. \\<And>x.\n       {R01ia \\<inter>\n        UNIV \\<times>\n        l1_inv3} ((\\<Union>x xa.\n                      \\<Union> (range (a0i_running x xa))) \\<union>\n                  (\\<Union>x xa.\n                      \\<Union>\n                       (range\n                         (a0i_commit x xa))))\\<^sup>=, l1_learn x {> R01ia}", "apply (blast intro!:l1_trans_refines_a0i_trans)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {R01ia \\<inter> UNIV \\<times> l1_inv3} TS.trans a0i, TS.trans l1 {> R01ia}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {R01ia \\<inter>\n   UNIV \\<times>\n   (l1_inv1 \\<inter> l1_inv2)} TS.trans a0i, TS.trans l1 {> R01ia}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma obs_consistent_med01ia [iff]: \n  \"obs_consistent R01ia med01ia a0i l1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent R01ia med01ia a0i l1", "by (auto simp add: obs_consistent_def R01ia_def med01ia_def)"], ["", "text \\<open>refinement result\\<close>"], ["", "lemma l1_refines_a0i [iff]: \n  \"refines \n     (R01ia \\<inter> (reach a0i \\<times> (l1_inv1 \\<inter> l1_inv2)))\n     med01ia a0i l1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines (R01ia \\<inter> reach a0i \\<times> (l1_inv1 \\<inter> l1_inv2))\n     med01ia a0i l1", "by (rule Refinement_using_invariants, auto)"], ["", "lemma  l1_implements_a0i [iff]: \"implements med01ia a0i l1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements med01ia a0i l1", "by (rule refinement_soundness) (fast)"], ["", "(**************************************************************************************************)"], ["", "subsection \\<open>Derived invariants: injective agreement\\<close>"], ["", "(**************************************************************************************************)"], ["", "definition \n  l1_iagreement :: \"('a l1_state_scheme) set\"\nwhere\n  \"l1_iagreement \\<equiv> {s. \\<forall> A B N. signals s (Commit A B N) \\<le> signals s (Running A B N)}\""], ["", "lemmas l1_iagreementI = l1_iagreement_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas l1_iagreementE [elim] = l1_iagreement_def [THEN setc_def_to_elim, rule_format]"], ["", "lemma l1_obs_iagreement [iff]: \"oreach l1 \\<subseteq> l1_iagreement\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oreach l1 \\<subseteq> l1_iagreement", "apply (rule external_invariant_translation \n         [OF PO_a0i_obs_agreement _ l1_implements_a0i])"], ["proof (prove)\ngoal (1 subgoal):\n 1. med01ia -` a0i_agreement \\<subseteq> l1_iagreement", "apply (auto simp add: med01ia_def l1_iagreement_def a0i_agreement_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma l1_iagreement [iff]: \"reach l1 \\<subseteq> l1_iagreement\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach l1 \\<subseteq> l1_iagreement", "by (rule external_to_internal_invariant [OF l1_obs_iagreement], auto)"], ["", "end"]]}