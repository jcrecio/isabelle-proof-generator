{"file_name": "/home/qj213/afp-2021-10-22/thys/JiveDataStoreModel/Isabelle/Subtype.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JiveDataStoreModel", "problem_names": ["lemma distinct_rtrancl_into_trancl:\n  assumes neq_x_y: \"x\\<noteq>y\"\n  assumes x_y_rtrancl: \"(x,y) \\<in> r\\<^sup>*\"\n  shows \"(x,y) \\<in> r\\<^sup>+\"", "lemma acyclic_imp_antisym_rtrancl: \"acyclic r \\<Longrightarrow> antisym (r\\<^sup>*)\"", "lemma acyclic_trancl_rtrancl: \n  assumes acyclic: \"acyclic r\"\n  shows \"(x,y) \\<in> r\\<^sup>+ = ((x,y) \\<in> r\\<^sup>* \\<and> x\\<noteq>y)\"", "lemma acyclic_direct_subtype: \"acyclic direct_subtype\"", "lemma antisym_rtrancl_direct_subtype: \"antisym (direct_subtype\\<^sup>*)\"", "lemma widen_strict_to_widen: \"C \\<prec> D = (C \\<preceq> D \\<and> C\\<noteq>D)\"", "lemma widen_refl [iff]: \"X \\<preceq> X\"", "lemma widen_trans [trans] : \n  assumes a_b: \"a \\<preceq> b\"\n  shows \"\\<And> c. b \\<preceq> c \\<Longrightarrow> a \\<preceq> c\"", "lemma widen_antisym [trans]: \n  assumes a_b: \"a \\<preceq> b\" \n  assumes b_c: \"b \\<preceq> a\"  \n  shows \"a = b\"", "lemmas subtype_defs = le_Javatype_def less_Javatype_def\n                      direct_subtype_def", "lemmas subtype_ok_simps = subtype_defs", "lemmas subtype_wrong_elims = rtranclE", "lemma widen_asm: \"(a::Javatype) \\<le> b \\<Longrightarrow> a \\<le> b\"", "lemmas direct_subtype_widened = direct_subtype[THEN r_into_rtrancl]", "lemma Object_root: \"CClassT C \\<le> CClassT Object\"", "lemma Object_root_abs: \"AClassT C \\<le> CClassT Object\"", "lemma Object_root_int: \"InterfaceT C \\<le> CClassT Object\"", "lemma Object_root_array: \"ArrT C \\<le> CClassT Object\"", "lemma Object_rootD: \n  assumes p: \"CClassT Object \\<le> c\"\n  shows \"CClassT Object = c\"", "lemma NullT_leaf [simp]: \"NullT \\<le> CClassT C\"", "lemma NullT_leaf_abs [simp]: \"NullT \\<le> AClassT C\"", "lemma NullT_leaf_int [simp]: \"NullT \\<le> InterfaceT C\"", "lemma NullT_leaf_array: \"NullT \\<le> ArrT C\""], "translations": [["", "lemma distinct_rtrancl_into_trancl:\n  assumes neq_x_y: \"x\\<noteq>y\"\n  assumes x_y_rtrancl: \"(x,y) \\<in> r\\<^sup>*\"\n  shows \"(x,y) \\<in> r\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> r\\<^sup>+", "using x_y_rtrancl neq_x_y"], ["proof (prove)\nusing this:\n  (x, y) \\<in> r\\<^sup>*\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> r\\<^sup>+", "proof (induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<noteq> x \\<Longrightarrow> (x, x) \\<in> r\\<^sup>+\n 2. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> r\\<^sup>*; (y, z) \\<in> r;\n        x \\<noteq> y \\<Longrightarrow> (x, y) \\<in> r\\<^sup>+;\n        x \\<noteq> z\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r\\<^sup>+", "assume \"x\\<noteq>x\""], ["proof (state)\nthis:\n  x \\<noteq> x\n\ngoal (2 subgoals):\n 1. x \\<noteq> x \\<Longrightarrow> (x, x) \\<in> r\\<^sup>+\n 2. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> r\\<^sup>*; (y, z) \\<in> r;\n        x \\<noteq> y \\<Longrightarrow> (x, y) \\<in> r\\<^sup>+;\n        x \\<noteq> z\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r\\<^sup>+", "thus \"(x, x) \\<in> r\\<^sup>+\""], ["proof (prove)\nusing this:\n  x \\<noteq> x\n\ngoal (1 subgoal):\n 1. (x, x) \\<in> r\\<^sup>+", "by simp"], ["proof (state)\nthis:\n  (x, x) \\<in> r\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> r\\<^sup>*; (y, z) \\<in> r;\n        x \\<noteq> y \\<Longrightarrow> (x, y) \\<in> r\\<^sup>+;\n        x \\<noteq> z\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r\\<^sup>+", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> r\\<^sup>*; (y, z) \\<in> r;\n        x \\<noteq> y \\<Longrightarrow> (x, y) \\<in> r\\<^sup>+;\n        x \\<noteq> z\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r\\<^sup>+", "fix y z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> r\\<^sup>*; (y, z) \\<in> r;\n        x \\<noteq> y \\<Longrightarrow> (x, y) \\<in> r\\<^sup>+;\n        x \\<noteq> z\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r\\<^sup>+", "assume x_y_rtrancl: \"(x, y) \\<in> r\\<^sup>*\""], ["proof (state)\nthis:\n  (x, y) \\<in> r\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> r\\<^sup>*; (y, z) \\<in> r;\n        x \\<noteq> y \\<Longrightarrow> (x, y) \\<in> r\\<^sup>+;\n        x \\<noteq> z\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r\\<^sup>+", "assume y_z_r: \"(y, z) \\<in> r\""], ["proof (state)\nthis:\n  (y, z) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> r\\<^sup>*; (y, z) \\<in> r;\n        x \\<noteq> y \\<Longrightarrow> (x, y) \\<in> r\\<^sup>+;\n        x \\<noteq> z\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r\\<^sup>+", "assume \"x \\<noteq> y \\<Longrightarrow> (x, y) \\<in> r\\<^sup>+\""], ["proof (state)\nthis:\n  x \\<noteq> y \\<Longrightarrow> (x, y) \\<in> r\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> r\\<^sup>*; (y, z) \\<in> r;\n        x \\<noteq> y \\<Longrightarrow> (x, y) \\<in> r\\<^sup>+;\n        x \\<noteq> z\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r\\<^sup>+", "assume \"x \\<noteq> z\""], ["proof (state)\nthis:\n  x \\<noteq> z\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> r\\<^sup>*; (y, z) \\<in> r;\n        x \\<noteq> y \\<Longrightarrow> (x, y) \\<in> r\\<^sup>+;\n        x \\<noteq> z\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r\\<^sup>+", "from x_y_rtrancl"], ["proof (chain)\npicking this:\n  (x, y) \\<in> r\\<^sup>*", "show \"(x, z) \\<in> r\\<^sup>+\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> r\\<^sup>*\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> r\\<^sup>+", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> (x, z) \\<in> r\\<^sup>+\n 2. \\<And>y.\n       \\<lbrakk>(x, y) \\<in> r\\<^sup>*; (y, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r\\<^sup>+", "assume \"x=y\""], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> (x, z) \\<in> r\\<^sup>+\n 2. \\<And>y.\n       \\<lbrakk>(x, y) \\<in> r\\<^sup>*; (y, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r\\<^sup>+", "with y_z_r"], ["proof (chain)\npicking this:\n  (y, z) \\<in> r\n  x = y", "have \"(x,z) \\<in> r\""], ["proof (prove)\nusing this:\n  (y, z) \\<in> r\n  x = y\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> r", "by simp"], ["proof (state)\nthis:\n  (x, z) \\<in> r\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> (x, z) \\<in> r\\<^sup>+\n 2. \\<And>y.\n       \\<lbrakk>(x, y) \\<in> r\\<^sup>*; (y, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r\\<^sup>+", "thus \"(x,z) \\<in>  r\\<^sup>+\""], ["proof (prove)\nusing this:\n  (x, z) \\<in> r\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> r\\<^sup>+", ".."], ["proof (state)\nthis:\n  (x, z) \\<in> r\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>(x, y) \\<in> r\\<^sup>*; (y, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r\\<^sup>+", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>(x, y) \\<in> r\\<^sup>*; (y, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r\\<^sup>+", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>(x, y) \\<in> r\\<^sup>*; (y, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r\\<^sup>+", "assume \"(x, w) \\<in> r\\<^sup>*\""], ["proof (state)\nthis:\n  (x, w) \\<in> r\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>(x, y) \\<in> r\\<^sup>*; (y, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r\\<^sup>+", "moreover"], ["proof (state)\nthis:\n  (x, w) \\<in> r\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>(x, y) \\<in> r\\<^sup>*; (y, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r\\<^sup>+", "assume \"(w, y) \\<in> r\""], ["proof (state)\nthis:\n  (w, y) \\<in> r\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>(x, y) \\<in> r\\<^sup>*; (y, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r\\<^sup>+", "ultimately"], ["proof (chain)\npicking this:\n  (x, w) \\<in> r\\<^sup>*\n  (w, y) \\<in> r", "have \"(x,y) \\<in> r\\<^sup>+\""], ["proof (prove)\nusing this:\n  (x, w) \\<in> r\\<^sup>*\n  (w, y) \\<in> r\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> r\\<^sup>+", "by (rule rtrancl_into_trancl1)"], ["proof (state)\nthis:\n  (x, y) \\<in> r\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>(x, y) \\<in> r\\<^sup>*; (y, y) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> r\\<^sup>+", "from this y_z_r"], ["proof (chain)\npicking this:\n  (x, y) \\<in> r\\<^sup>+\n  (y, z) \\<in> r", "show \"(x, z) \\<in> r\\<^sup>+\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> r\\<^sup>+\n  (y, z) \\<in> r\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> r\\<^sup>+", ".."], ["proof (state)\nthis:\n  (x, z) \\<in> r\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x, z) \\<in> r\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma acyclic_imp_antisym_rtrancl: \"acyclic r \\<Longrightarrow> antisym (r\\<^sup>*)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic r \\<Longrightarrow> antisym (r\\<^sup>*)", "proof (clarsimp simp only: acyclic_def antisym_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>x. (x, x) \\<notin> r\\<^sup>+;\n        (x, y) \\<in> r\\<^sup>*; (y, x) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>x. (x, x) \\<notin> r\\<^sup>+;\n        (x, y) \\<in> r\\<^sup>*; (y, x) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume acyclic: \"\\<forall>x. (x, x) \\<notin> r\\<^sup>+\""], ["proof (state)\nthis:\n  \\<forall>x. (x, x) \\<notin> r\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>x. (x, x) \\<notin> r\\<^sup>+;\n        (x, y) \\<in> r\\<^sup>*; (y, x) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume x_y: \"(x, y) \\<in> r\\<^sup>*\""], ["proof (state)\nthis:\n  (x, y) \\<in> r\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>x. (x, x) \\<notin> r\\<^sup>+;\n        (x, y) \\<in> r\\<^sup>*; (y, x) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume y_x: \"(y, x) \\<in> r\\<^sup>*\""], ["proof (state)\nthis:\n  (y, x) \\<in> r\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>x. (x, x) \\<notin> r\\<^sup>+;\n        (x, y) \\<in> r\\<^sup>*; (y, x) \\<in> r\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"x=y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof (cases \"x=y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> x = y\n 2. x \\<noteq> y \\<Longrightarrow> x = y", "case True"], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> x = y\n 2. x \\<noteq> y \\<Longrightarrow> x = y", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. x = y", "."], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> x = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> x = y", "case False"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> x = y", "from False x_y"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  (x, y) \\<in> r\\<^sup>*", "have \"(x, y) \\<in> r\\<^sup>+\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  (x, y) \\<in> r\\<^sup>*\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> r\\<^sup>+", "by (rule distinct_rtrancl_into_trancl)"], ["proof (state)\nthis:\n  (x, y) \\<in> r\\<^sup>+\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> x = y", "also"], ["proof (state)\nthis:\n  (x, y) \\<in> r\\<^sup>+\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> x = y", "from False y_x"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  (y, x) \\<in> r\\<^sup>*", "have \"(y, x) \\<in> r\\<^sup>+\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  (y, x) \\<in> r\\<^sup>*\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> r\\<^sup>+", "by (fastforce intro: distinct_rtrancl_into_trancl)"], ["proof (state)\nthis:\n  (y, x) \\<in> r\\<^sup>+\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> x = y", "finally"], ["proof (chain)\npicking this:\n  (x, x) \\<in> r\\<^sup>+", "have \"(x,x) \\<in> r\\<^sup>+\""], ["proof (prove)\nusing this:\n  (x, x) \\<in> r\\<^sup>+\n\ngoal (1 subgoal):\n 1. (x, x) \\<in> r\\<^sup>+", "."], ["proof (state)\nthis:\n  (x, x) \\<in> r\\<^sup>+\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> x = y", "with acyclic"], ["proof (chain)\npicking this:\n  \\<forall>x. (x, x) \\<notin> r\\<^sup>+\n  (x, x) \\<in> r\\<^sup>+", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x. (x, x) \\<notin> r\\<^sup>+\n  (x, x) \\<in> r\\<^sup>+\n\ngoal (1 subgoal):\n 1. x = y", "by simp"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma acyclic_trancl_rtrancl: \n  assumes acyclic: \"acyclic r\"\n  shows \"(x,y) \\<in> r\\<^sup>+ = ((x,y) \\<in> r\\<^sup>* \\<and> x\\<noteq>y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x, y) \\<in> r\\<^sup>+) = ((x, y) \\<in> r\\<^sup>* \\<and> x \\<noteq> y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (x, y) \\<in> r\\<^sup>+ \\<Longrightarrow>\n    (x, y) \\<in> r\\<^sup>* \\<and> x \\<noteq> y\n 2. (x, y) \\<in> r\\<^sup>* \\<and> x \\<noteq> y \\<Longrightarrow>\n    (x, y) \\<in> r\\<^sup>+", "assume x_y_trancl: \"(x,y) \\<in> r\\<^sup>+\""], ["proof (state)\nthis:\n  (x, y) \\<in> r\\<^sup>+\n\ngoal (2 subgoals):\n 1. (x, y) \\<in> r\\<^sup>+ \\<Longrightarrow>\n    (x, y) \\<in> r\\<^sup>* \\<and> x \\<noteq> y\n 2. (x, y) \\<in> r\\<^sup>* \\<and> x \\<noteq> y \\<Longrightarrow>\n    (x, y) \\<in> r\\<^sup>+", "show \"(x,y) \\<in> r\\<^sup>* \\<and> x\\<noteq>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> r\\<^sup>* \\<and> x \\<noteq> y", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (x, y) \\<in> r\\<^sup>*\n 2. x \\<noteq> y", "from x_y_trancl"], ["proof (chain)\npicking this:\n  (x, y) \\<in> r\\<^sup>+", "show \"(x,y) \\<in> r\\<^sup>*\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> r\\<^sup>+\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> r\\<^sup>*", ".."], ["proof (state)\nthis:\n  (x, y) \\<in> r\\<^sup>*\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y", "from x_y_trancl acyclic"], ["proof (chain)\npicking this:\n  (x, y) \\<in> r\\<^sup>+\n  acyclic r", "show \"x\\<noteq>y\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> r\\<^sup>+\n  acyclic r\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "by (auto simp add: acyclic_def)"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x, y) \\<in> r\\<^sup>* \\<and> x \\<noteq> y\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> r\\<^sup>* \\<and> x \\<noteq> y \\<Longrightarrow>\n    (x, y) \\<in> r\\<^sup>+", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (x, y) \\<in> r\\<^sup>* \\<and> x \\<noteq> y \\<Longrightarrow>\n    (x, y) \\<in> r\\<^sup>+", "assume \"(x,y) \\<in> r\\<^sup>* \\<and> x\\<noteq>y\""], ["proof (state)\nthis:\n  (x, y) \\<in> r\\<^sup>* \\<and> x \\<noteq> y\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> r\\<^sup>* \\<and> x \\<noteq> y \\<Longrightarrow>\n    (x, y) \\<in> r\\<^sup>+", "thus \"(x,y) \\<in> r\\<^sup>+\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> r\\<^sup>* \\<and> x \\<noteq> y\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> r\\<^sup>+", "by (auto intro: distinct_rtrancl_into_trancl)"], ["proof (state)\nthis:\n  (x, y) \\<in> r\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The Widening (Subtype) Relation of Javatypes\\<close>"], ["", "text \\<open>\\label{widening_subtypes}\nIn this section we widen the direct subtype relations specified in Sec. \n\\ref{direct_subtype_relations}.\nIt is done by a calculation of the transitive closure of the \ndirect subtype relation. \n\\<close>"], ["", "text \\<open>This is the concrete syntax that expresses the subtype relations \nbetween all types. \n\\label{subtype_relations_concrete_syntax}\\<close>"], ["", "abbreviation\n  direct_subtype_syntax :: \"Javatype \\<Rightarrow> Javatype \\<Rightarrow> bool\" (\"_ \\<prec>1 _\" [71,71] 70)\nwhere \\<comment> \\<open>direct subtype relation\\<close>\n  \"A \\<prec>1 B == (A,B) \\<in> direct_subtype\""], ["", "abbreviation\n  widen_syntax :: \"Javatype \\<Rightarrow> Javatype \\<Rightarrow> bool\" (\"_ \\<preceq> _\" [71,71] 70)\nwhere \\<comment> \\<open>reflexive transitive closure of direct subtype relation\\<close>\n  \"A \\<preceq> B == (A,B) \\<in> direct_subtype\\<^sup>*\""], ["", "abbreviation\n  widen_strict_syntax :: \"Javatype \\<Rightarrow> Javatype \\<Rightarrow> bool\" (\"_ \\<prec> _\" [71,71] 70)\nwhere \\<comment> \\<open>transitive closure of direct subtype relation\\<close>\n  \"A \\<prec> B == (A,B) \\<in> direct_subtype\\<^sup>+\""], ["", "subsection \\<open>The Subtype Relation as Partial Order\\<close>"], ["", "text \\<open>We prove the axioms required for partial orders, i.e.\\ \nreflexivity, transitivity and antisymmetry, for the widened subtype\nrelation. The direct subtype relation has been\ndefined in Sec. \\ref{direct_subtype_relations}.\nThe reflexivity lemma is\nadded to the Simplifier and to the Classical reasoner (via the\nattribute iff), and the transitivity and antisymmetry lemmas\nare made known as transitivity rules (via the attribute trans).\nThis way, these lemmas will be automatically used in subsequent proofs.\n\\<close>"], ["", "lemma acyclic_direct_subtype: \"acyclic direct_subtype\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic direct_subtype", "proof (clarsimp simp add: acyclic_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<prec> x \\<Longrightarrow> False", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<prec> x \\<Longrightarrow> False", "show \"x \\<prec> x \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<prec> x \\<Longrightarrow> False", "by (cases x) (fastforce elim: tranclE simp add: direct_subtype_def)+"], ["proof (state)\nthis:\n  x \\<prec> x \\<Longrightarrow> False\n\ngoal:\nNo subgoals!", "(* takes a very long time to calculate *)"], ["proof (state)\nthis:\n  x \\<prec> x \\<Longrightarrow> False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma antisym_rtrancl_direct_subtype: \"antisym (direct_subtype\\<^sup>*)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antisym (direct_subtype\\<^sup>*)", "using acyclic_direct_subtype"], ["proof (prove)\nusing this:\n  acyclic direct_subtype\n\ngoal (1 subgoal):\n 1. antisym (direct_subtype\\<^sup>*)", "by (rule acyclic_imp_antisym_rtrancl)"], ["", "lemma widen_strict_to_widen: \"C \\<prec> D = (C \\<preceq> D \\<and> C\\<noteq>D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<prec> D = (C \\<preceq> D \\<and> C \\<noteq> D)", "using acyclic_direct_subtype"], ["proof (prove)\nusing this:\n  acyclic direct_subtype\n\ngoal (1 subgoal):\n 1. C \\<prec> D = (C \\<preceq> D \\<and> C \\<noteq> D)", "by (rule acyclic_trancl_rtrancl)"], ["", "text \\<open>The widening relation on Javatype is reflexive.\\<close>"], ["", "lemma widen_refl [iff]: \"X \\<preceq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<preceq> X", ".."], ["", "text \\<open>The widening relation on Javatype is transitive.\\<close>"], ["", "lemma widen_trans [trans] : \n  assumes a_b: \"a \\<preceq> b\"\n  shows \"\\<And> c. b \\<preceq> c \\<Longrightarrow> a \\<preceq> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c. b \\<preceq> c \\<Longrightarrow> a \\<preceq> c", "by (insert a_b, rule rtrancl_trans)"], ["", "text \\<open>The widening relation on Javatype is antisymmetric.\\<close>"], ["", "lemma widen_antisym [trans]: \n  assumes a_b: \"a \\<preceq> b\" \n  assumes b_c: \"b \\<preceq> a\"  \n  shows \"a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = b", "using a_b b_c antisym_rtrancl_direct_subtype"], ["proof (prove)\nusing this:\n  a \\<preceq> b\n  b \\<preceq> a\n  antisym (direct_subtype\\<^sup>*)\n\ngoal (1 subgoal):\n 1. a = b", "by (unfold antisym_def) blast"], ["", "subsection \\<open>Javatype Ordering Properties\\<close>"], ["", "text \\<open>The type class @{term ord} allows us to overwrite the two comparison \noperators $<$ and $\\leq$.\n  These are  the two comparison operators on @{typ Javatype} that we want\nto use subsequently.\\<close>"], ["", "text \\<open>We can also prove that @{typ Javatype} is in the type class @{term order}. \nFor this we\n  have to prove reflexivity, transitivity, antisymmetry and that $<$ and $\\leq$ are \ndefined in such\n  a way that @{thm Orderings.order_less_le [no_vars]} holds. This proof can easily \nbe achieved by using the\n  lemmas proved above and the definition of @{term less_Javatype_def}.\n\\<close>"], ["", "instantiation Javatype:: order\nbegin"], ["", "definition\n  le_Javatype_def:   \"A \\<le> B \\<equiv> A \\<preceq> B\""], ["", "definition\n  less_Javatype_def: \"A < B \\<equiv> A \\<le> B \\<and> \\<not> B \\<le> (A::Javatype)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(Javatype, order_class)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "fix x y z:: \"Javatype\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "{"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "show \"x \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x", "by (simp add: le_Javatype_def )"], ["proof (state)\nthis:\n  x \\<le> x\n\ngoal (3 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "assume \"x \\<le> y\" \"y \\<le> z\""], ["proof (state)\nthis:\n  x \\<le> y\n  y \\<le> z\n\ngoal (3 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  x \\<le> y\n  y \\<le> z", "show \"x \\<le> z\""], ["proof (prove)\nusing this:\n  x \\<le> y\n  y \\<le> z\n\ngoal (1 subgoal):\n 1. x \\<le> z", "by (unfold le_Javatype_def) (rule rtrancl_trans)"], ["proof (state)\nthis:\n  x \\<le> z\n\ngoal (2 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "assume \"x \\<le> y\" \"y \\<le> x\""], ["proof (state)\nthis:\n  x \\<le> y\n  y \\<le> x\n\ngoal (2 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  x \\<le> y\n  y \\<le> x", "show \"x = y\""], ["proof (prove)\nusing this:\n  x \\<le> y\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. x = y", "apply (unfold le_Javatype_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<preceq> y; y \\<preceq> x\\<rbrakk> \\<Longrightarrow> x = y", "apply (rule widen_antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<preceq> y; y \\<preceq> x\\<rbrakk>\n    \\<Longrightarrow> x \\<preceq> y\n 2. \\<lbrakk>x \\<preceq> y; y \\<preceq> x\\<rbrakk>\n    \\<Longrightarrow> y \\<preceq> x", "apply assumption +"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)", "show \"(x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)", "by (simp add: less_Javatype_def)"], ["proof (state)\nthis:\n  (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Enhancing the Simplifier\\<close>"], ["", "lemmas subtype_defs = le_Javatype_def less_Javatype_def\n                      direct_subtype_def"], ["", "(*\n                      direct_subtype\n                      direct_subtype[THEN r_into_rtrancl]\n*)"], ["", "lemmas subtype_ok_simps = subtype_defs"], ["", "lemmas subtype_wrong_elims = rtranclE"], ["", "text \\<open>During verification we will often have to solve the goal that one type\nwidens to the other. So we equip the simplifier with a special solver-tactic.\n\\<close>"], ["", "lemma widen_asm: \"(a::Javatype) \\<le> b \\<Longrightarrow> a \\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<Longrightarrow> a \\<le> b", "by simp"], ["", "lemmas direct_subtype_widened = direct_subtype[THEN r_into_rtrancl]"], ["", "ML \\<open>\nlocal val ss = simpset_of @{context} in\n\nfun widen_tac ctxt =\n  resolve_tac ctxt @{thms widen_asm} THEN'\n  simp_tac (put_simpset ss ctxt addsimps @{thms le_Javatype_def}) THEN'\n  Method.insert_tac ctxt @{thms direct_subtype_widened} THEN'\n  simp_tac (put_simpset (simpset_of @{theory_context Transitive_Closure}) ctxt)\n\nend\n\\<close>"], ["", "declaration \\<open>fn _ =>\n  Simplifier.map_ss (fn ss => ss addSolver (mk_solver \"widen\" widen_tac))\n\\<close>"], ["", "text \\<open>In this solver-tactic, we first try the trivial resolution with \\<open>widen_asm\\<close> to\ncheck if the actual subgaol really is a request to solve a subtyping problem.\nIf so, we unfold the comparison operator, insert the direct subtype\nrelations and call the simplifier.\n\\<close>"], ["", "subsection \\<open>Properties of the Subtype Relation\\<close>"], ["", "text \\<open>The class \\<open>Object\\<close> has to be the root of the class hierarchy, \ni.e.~it is supertype of each concrete class, abstract class, interface\nand array type.\n  The proof scripts should run on every correctly generated type hierarchy.\n\\<close>"], ["", "lemma Object_root: \"CClassT C \\<le> CClassT Object\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CClassT C \\<le> CClassT Object", "by (cases C, simp_all)"], ["", "lemma Object_root_abs: \"AClassT C \\<le> CClassT Object\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AClassT C \\<le> CClassT Object", "by (cases C, simp_all)"], ["", "lemma Object_root_int: \"InterfaceT C \\<le> CClassT Object\""], ["proof (prove)\ngoal (1 subgoal):\n 1. InterfaceT C \\<le> CClassT Object", "by (cases C, simp_all)"], ["", "lemma Object_root_array: \"ArrT C \\<le> CClassT Object\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ArrT C \\<le> CClassT Object", "proof (cases C)"], ["proof (state)\ngoal (7 subgoals):\n 1. C = BoolAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 2. C = IntgAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 3. C = ShortAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 4. C = ByteAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 5. \\<And>x5. C = CClassAT x5 \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 6. \\<And>x6. C = AClassAT x6 \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 7. \\<And>x7.\n       C = InterfaceAT x7 \\<Longrightarrow> ArrT C \\<le> CClassT Object", "fix x"], ["proof (state)\ngoal (7 subgoals):\n 1. C = BoolAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 2. C = IntgAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 3. C = ShortAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 4. C = ByteAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 5. \\<And>x5. C = CClassAT x5 \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 6. \\<And>x6. C = AClassAT x6 \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 7. \\<And>x7.\n       C = InterfaceAT x7 \\<Longrightarrow> ArrT C \\<le> CClassT Object", "assume c: \"C = CClassAT x\""], ["proof (state)\nthis:\n  C = CClassAT x\n\ngoal (7 subgoals):\n 1. C = BoolAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 2. C = IntgAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 3. C = ShortAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 4. C = ByteAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 5. \\<And>x5. C = CClassAT x5 \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 6. \\<And>x6. C = AClassAT x6 \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 7. \\<And>x7.\n       C = InterfaceAT x7 \\<Longrightarrow> ArrT C \\<le> CClassT Object", "show \"ArrT C \\<le> CClassT Object\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ArrT C \\<le> CClassT Object", "using c"], ["proof (prove)\nusing this:\n  C = CClassAT x\n\ngoal (1 subgoal):\n 1. ArrT C \\<le> CClassT Object", "by (cases x, simp_all)"], ["proof (state)\nthis:\n  ArrT C \\<le> CClassT Object\n\ngoal (6 subgoals):\n 1. C = BoolAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 2. C = IntgAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 3. C = ShortAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 4. C = ByteAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 5. \\<And>x6. C = AClassAT x6 \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 6. \\<And>x7.\n       C = InterfaceAT x7 \\<Longrightarrow> ArrT C \\<le> CClassT Object", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. C = BoolAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 2. C = IntgAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 3. C = ShortAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 4. C = ByteAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 5. \\<And>x6. C = AClassAT x6 \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 6. \\<And>x7.\n       C = InterfaceAT x7 \\<Longrightarrow> ArrT C \\<le> CClassT Object", "fix x"], ["proof (state)\ngoal (6 subgoals):\n 1. C = BoolAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 2. C = IntgAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 3. C = ShortAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 4. C = ByteAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 5. \\<And>x6. C = AClassAT x6 \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 6. \\<And>x7.\n       C = InterfaceAT x7 \\<Longrightarrow> ArrT C \\<le> CClassT Object", "assume c: \"C = AClassAT x\""], ["proof (state)\nthis:\n  C = AClassAT x\n\ngoal (6 subgoals):\n 1. C = BoolAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 2. C = IntgAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 3. C = ShortAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 4. C = ByteAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 5. \\<And>x6. C = AClassAT x6 \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 6. \\<And>x7.\n       C = InterfaceAT x7 \\<Longrightarrow> ArrT C \\<le> CClassT Object", "show \"ArrT C \\<le> CClassT Object\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ArrT C \\<le> CClassT Object", "using c"], ["proof (prove)\nusing this:\n  C = AClassAT x\n\ngoal (1 subgoal):\n 1. ArrT C \\<le> CClassT Object", "by (cases x, simp_all)"], ["proof (state)\nthis:\n  ArrT C \\<le> CClassT Object\n\ngoal (5 subgoals):\n 1. C = BoolAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 2. C = IntgAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 3. C = ShortAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 4. C = ByteAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 5. \\<And>x7.\n       C = InterfaceAT x7 \\<Longrightarrow> ArrT C \\<le> CClassT Object", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. C = BoolAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 2. C = IntgAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 3. C = ShortAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 4. C = ByteAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 5. \\<And>x7.\n       C = InterfaceAT x7 \\<Longrightarrow> ArrT C \\<le> CClassT Object", "fix x"], ["proof (state)\ngoal (5 subgoals):\n 1. C = BoolAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 2. C = IntgAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 3. C = ShortAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 4. C = ByteAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 5. \\<And>x7.\n       C = InterfaceAT x7 \\<Longrightarrow> ArrT C \\<le> CClassT Object", "assume c: \"C = InterfaceAT x\""], ["proof (state)\nthis:\n  C = InterfaceAT x\n\ngoal (5 subgoals):\n 1. C = BoolAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 2. C = IntgAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 3. C = ShortAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 4. C = ByteAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 5. \\<And>x7.\n       C = InterfaceAT x7 \\<Longrightarrow> ArrT C \\<le> CClassT Object", "show \"ArrT C \\<le> CClassT Object\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ArrT C \\<le> CClassT Object", "using c"], ["proof (prove)\nusing this:\n  C = InterfaceAT x\n\ngoal (1 subgoal):\n 1. ArrT C \\<le> CClassT Object", "by (cases x, simp_all)"], ["proof (state)\nthis:\n  ArrT C \\<le> CClassT Object\n\ngoal (4 subgoals):\n 1. C = BoolAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 2. C = IntgAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 3. C = ShortAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 4. C = ByteAT \\<Longrightarrow> ArrT C \\<le> CClassT Object", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. C = BoolAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 2. C = IntgAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 3. C = ShortAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 4. C = ByteAT \\<Longrightarrow> ArrT C \\<le> CClassT Object", "assume c: \"C = BoolAT\""], ["proof (state)\nthis:\n  C = BoolAT\n\ngoal (4 subgoals):\n 1. C = BoolAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 2. C = IntgAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 3. C = ShortAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 4. C = ByteAT \\<Longrightarrow> ArrT C \\<le> CClassT Object", "show \"ArrT C \\<le> CClassT Object\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ArrT C \\<le> CClassT Object", "using c"], ["proof (prove)\nusing this:\n  C = BoolAT\n\ngoal (1 subgoal):\n 1. ArrT C \\<le> CClassT Object", "by simp"], ["proof (state)\nthis:\n  ArrT C \\<le> CClassT Object\n\ngoal (3 subgoals):\n 1. C = IntgAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 2. C = ShortAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 3. C = ByteAT \\<Longrightarrow> ArrT C \\<le> CClassT Object", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. C = IntgAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 2. C = ShortAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 3. C = ByteAT \\<Longrightarrow> ArrT C \\<le> CClassT Object", "assume c: \"C = IntgAT\""], ["proof (state)\nthis:\n  C = IntgAT\n\ngoal (3 subgoals):\n 1. C = IntgAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 2. C = ShortAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 3. C = ByteAT \\<Longrightarrow> ArrT C \\<le> CClassT Object", "show \"ArrT C \\<le> CClassT Object\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ArrT C \\<le> CClassT Object", "using c"], ["proof (prove)\nusing this:\n  C = IntgAT\n\ngoal (1 subgoal):\n 1. ArrT C \\<le> CClassT Object", "by simp"], ["proof (state)\nthis:\n  ArrT C \\<le> CClassT Object\n\ngoal (2 subgoals):\n 1. C = ShortAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 2. C = ByteAT \\<Longrightarrow> ArrT C \\<le> CClassT Object", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. C = ShortAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 2. C = ByteAT \\<Longrightarrow> ArrT C \\<le> CClassT Object", "assume c: \"C = ShortAT\""], ["proof (state)\nthis:\n  C = ShortAT\n\ngoal (2 subgoals):\n 1. C = ShortAT \\<Longrightarrow> ArrT C \\<le> CClassT Object\n 2. C = ByteAT \\<Longrightarrow> ArrT C \\<le> CClassT Object", "show \"ArrT C \\<le> CClassT Object\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ArrT C \\<le> CClassT Object", "using c"], ["proof (prove)\nusing this:\n  C = ShortAT\n\ngoal (1 subgoal):\n 1. ArrT C \\<le> CClassT Object", "by simp"], ["proof (state)\nthis:\n  ArrT C \\<le> CClassT Object\n\ngoal (1 subgoal):\n 1. C = ByteAT \\<Longrightarrow> ArrT C \\<le> CClassT Object", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. C = ByteAT \\<Longrightarrow> ArrT C \\<le> CClassT Object", "assume c: \"C = ByteAT\""], ["proof (state)\nthis:\n  C = ByteAT\n\ngoal (1 subgoal):\n 1. C = ByteAT \\<Longrightarrow> ArrT C \\<le> CClassT Object", "show \"ArrT C \\<le> CClassT Object\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ArrT C \\<le> CClassT Object", "using c"], ["proof (prove)\nusing this:\n  C = ByteAT\n\ngoal (1 subgoal):\n 1. ArrT C \\<le> CClassT Object", "by simp"], ["proof (state)\nthis:\n  ArrT C \\<le> CClassT Object\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>If another type is (non-strict) supertype of Object, \nthen it must be the type Object itself.\\<close>"], ["", "lemma Object_rootD: \n  assumes p: \"CClassT Object \\<le> c\"\n  shows \"CClassT Object = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CClassT Object = c", "using p"], ["proof (prove)\nusing this:\n  CClassT Object \\<le> c\n\ngoal (1 subgoal):\n 1. CClassT Object = c", "apply (cases c)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>CClassT Object \\<le> c; c = BoolT\\<rbrakk>\n    \\<Longrightarrow> CClassT Object = c\n 2. \\<lbrakk>CClassT Object \\<le> c; c = IntgT\\<rbrakk>\n    \\<Longrightarrow> CClassT Object = c\n 3. \\<lbrakk>CClassT Object \\<le> c; c = ShortT\\<rbrakk>\n    \\<Longrightarrow> CClassT Object = c\n 4. \\<lbrakk>CClassT Object \\<le> c; c = ByteT\\<rbrakk>\n    \\<Longrightarrow> CClassT Object = c\n 5. \\<lbrakk>CClassT Object \\<le> c; c = NullT\\<rbrakk>\n    \\<Longrightarrow> CClassT Object = c\n 6. \\<And>x6.\n       \\<lbrakk>CClassT Object \\<le> c; c = ArrT x6\\<rbrakk>\n       \\<Longrightarrow> CClassT Object = c\n 7. \\<And>x7.\n       \\<lbrakk>CClassT Object \\<le> c; c = CClassT x7\\<rbrakk>\n       \\<Longrightarrow> CClassT Object = c\n 8. \\<And>x8.\n       \\<lbrakk>CClassT Object \\<le> c; c = AClassT x8\\<rbrakk>\n       \\<Longrightarrow> CClassT Object = c\n 9. \\<And>x9.\n       \\<lbrakk>CClassT Object \\<le> c; c = InterfaceT x9\\<rbrakk>\n       \\<Longrightarrow> CClassT Object = c", "apply (fastforce elim: subtype_wrong_elims simp add: subtype_defs) +\n  \\<comment> \\<open>In this lemma, we only get contradictory cases except for Object itself.\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>The type NullT has to be the leaf of each branch of the class\nhierarchy, i.e.~it is subtype of each type.\\<close>"], ["", "lemma NullT_leaf [simp]: \"NullT \\<le> CClassT C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NullT \\<le> CClassT C", "by (cases C, simp_all)"], ["", "lemma NullT_leaf_abs [simp]: \"NullT \\<le> AClassT C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NullT \\<le> AClassT C", "by (cases C, simp_all)"], ["", "lemma NullT_leaf_int [simp]: \"NullT \\<le> InterfaceT C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NullT \\<le> InterfaceT C", "by (cases C, simp_all)"], ["", "lemma NullT_leaf_array: \"NullT \\<le> ArrT C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NullT \\<le> ArrT C", "proof (cases C)"], ["proof (state)\ngoal (7 subgoals):\n 1. C = BoolAT \\<Longrightarrow> NullT \\<le> ArrT C\n 2. C = IntgAT \\<Longrightarrow> NullT \\<le> ArrT C\n 3. C = ShortAT \\<Longrightarrow> NullT \\<le> ArrT C\n 4. C = ByteAT \\<Longrightarrow> NullT \\<le> ArrT C\n 5. \\<And>x5. C = CClassAT x5 \\<Longrightarrow> NullT \\<le> ArrT C\n 6. \\<And>x6. C = AClassAT x6 \\<Longrightarrow> NullT \\<le> ArrT C\n 7. \\<And>x7. C = InterfaceAT x7 \\<Longrightarrow> NullT \\<le> ArrT C", "fix x"], ["proof (state)\ngoal (7 subgoals):\n 1. C = BoolAT \\<Longrightarrow> NullT \\<le> ArrT C\n 2. C = IntgAT \\<Longrightarrow> NullT \\<le> ArrT C\n 3. C = ShortAT \\<Longrightarrow> NullT \\<le> ArrT C\n 4. C = ByteAT \\<Longrightarrow> NullT \\<le> ArrT C\n 5. \\<And>x5. C = CClassAT x5 \\<Longrightarrow> NullT \\<le> ArrT C\n 6. \\<And>x6. C = AClassAT x6 \\<Longrightarrow> NullT \\<le> ArrT C\n 7. \\<And>x7. C = InterfaceAT x7 \\<Longrightarrow> NullT \\<le> ArrT C", "assume c: \"C = CClassAT x\""], ["proof (state)\nthis:\n  C = CClassAT x\n\ngoal (7 subgoals):\n 1. C = BoolAT \\<Longrightarrow> NullT \\<le> ArrT C\n 2. C = IntgAT \\<Longrightarrow> NullT \\<le> ArrT C\n 3. C = ShortAT \\<Longrightarrow> NullT \\<le> ArrT C\n 4. C = ByteAT \\<Longrightarrow> NullT \\<le> ArrT C\n 5. \\<And>x5. C = CClassAT x5 \\<Longrightarrow> NullT \\<le> ArrT C\n 6. \\<And>x6. C = AClassAT x6 \\<Longrightarrow> NullT \\<le> ArrT C\n 7. \\<And>x7. C = InterfaceAT x7 \\<Longrightarrow> NullT \\<le> ArrT C", "show \"NullT \\<le> ArrT C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NullT \\<le> ArrT C", "using c"], ["proof (prove)\nusing this:\n  C = CClassAT x\n\ngoal (1 subgoal):\n 1. NullT \\<le> ArrT C", "by (cases x, simp_all)"], ["proof (state)\nthis:\n  NullT \\<le> ArrT C\n\ngoal (6 subgoals):\n 1. C = BoolAT \\<Longrightarrow> NullT \\<le> ArrT C\n 2. C = IntgAT \\<Longrightarrow> NullT \\<le> ArrT C\n 3. C = ShortAT \\<Longrightarrow> NullT \\<le> ArrT C\n 4. C = ByteAT \\<Longrightarrow> NullT \\<le> ArrT C\n 5. \\<And>x6. C = AClassAT x6 \\<Longrightarrow> NullT \\<le> ArrT C\n 6. \\<And>x7. C = InterfaceAT x7 \\<Longrightarrow> NullT \\<le> ArrT C", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. C = BoolAT \\<Longrightarrow> NullT \\<le> ArrT C\n 2. C = IntgAT \\<Longrightarrow> NullT \\<le> ArrT C\n 3. C = ShortAT \\<Longrightarrow> NullT \\<le> ArrT C\n 4. C = ByteAT \\<Longrightarrow> NullT \\<le> ArrT C\n 5. \\<And>x6. C = AClassAT x6 \\<Longrightarrow> NullT \\<le> ArrT C\n 6. \\<And>x7. C = InterfaceAT x7 \\<Longrightarrow> NullT \\<le> ArrT C", "fix x"], ["proof (state)\ngoal (6 subgoals):\n 1. C = BoolAT \\<Longrightarrow> NullT \\<le> ArrT C\n 2. C = IntgAT \\<Longrightarrow> NullT \\<le> ArrT C\n 3. C = ShortAT \\<Longrightarrow> NullT \\<le> ArrT C\n 4. C = ByteAT \\<Longrightarrow> NullT \\<le> ArrT C\n 5. \\<And>x6. C = AClassAT x6 \\<Longrightarrow> NullT \\<le> ArrT C\n 6. \\<And>x7. C = InterfaceAT x7 \\<Longrightarrow> NullT \\<le> ArrT C", "assume c: \"C = AClassAT x\""], ["proof (state)\nthis:\n  C = AClassAT x\n\ngoal (6 subgoals):\n 1. C = BoolAT \\<Longrightarrow> NullT \\<le> ArrT C\n 2. C = IntgAT \\<Longrightarrow> NullT \\<le> ArrT C\n 3. C = ShortAT \\<Longrightarrow> NullT \\<le> ArrT C\n 4. C = ByteAT \\<Longrightarrow> NullT \\<le> ArrT C\n 5. \\<And>x6. C = AClassAT x6 \\<Longrightarrow> NullT \\<le> ArrT C\n 6. \\<And>x7. C = InterfaceAT x7 \\<Longrightarrow> NullT \\<le> ArrT C", "show \"NullT \\<le> ArrT C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NullT \\<le> ArrT C", "using c"], ["proof (prove)\nusing this:\n  C = AClassAT x\n\ngoal (1 subgoal):\n 1. NullT \\<le> ArrT C", "by (cases x, simp_all)"], ["proof (state)\nthis:\n  NullT \\<le> ArrT C\n\ngoal (5 subgoals):\n 1. C = BoolAT \\<Longrightarrow> NullT \\<le> ArrT C\n 2. C = IntgAT \\<Longrightarrow> NullT \\<le> ArrT C\n 3. C = ShortAT \\<Longrightarrow> NullT \\<le> ArrT C\n 4. C = ByteAT \\<Longrightarrow> NullT \\<le> ArrT C\n 5. \\<And>x7. C = InterfaceAT x7 \\<Longrightarrow> NullT \\<le> ArrT C", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. C = BoolAT \\<Longrightarrow> NullT \\<le> ArrT C\n 2. C = IntgAT \\<Longrightarrow> NullT \\<le> ArrT C\n 3. C = ShortAT \\<Longrightarrow> NullT \\<le> ArrT C\n 4. C = ByteAT \\<Longrightarrow> NullT \\<le> ArrT C\n 5. \\<And>x7. C = InterfaceAT x7 \\<Longrightarrow> NullT \\<le> ArrT C", "fix x"], ["proof (state)\ngoal (5 subgoals):\n 1. C = BoolAT \\<Longrightarrow> NullT \\<le> ArrT C\n 2. C = IntgAT \\<Longrightarrow> NullT \\<le> ArrT C\n 3. C = ShortAT \\<Longrightarrow> NullT \\<le> ArrT C\n 4. C = ByteAT \\<Longrightarrow> NullT \\<le> ArrT C\n 5. \\<And>x7. C = InterfaceAT x7 \\<Longrightarrow> NullT \\<le> ArrT C", "assume c: \"C = InterfaceAT x\""], ["proof (state)\nthis:\n  C = InterfaceAT x\n\ngoal (5 subgoals):\n 1. C = BoolAT \\<Longrightarrow> NullT \\<le> ArrT C\n 2. C = IntgAT \\<Longrightarrow> NullT \\<le> ArrT C\n 3. C = ShortAT \\<Longrightarrow> NullT \\<le> ArrT C\n 4. C = ByteAT \\<Longrightarrow> NullT \\<le> ArrT C\n 5. \\<And>x7. C = InterfaceAT x7 \\<Longrightarrow> NullT \\<le> ArrT C", "show \"NullT \\<le> ArrT C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NullT \\<le> ArrT C", "using c"], ["proof (prove)\nusing this:\n  C = InterfaceAT x\n\ngoal (1 subgoal):\n 1. NullT \\<le> ArrT C", "by (cases x, simp_all)"], ["proof (state)\nthis:\n  NullT \\<le> ArrT C\n\ngoal (4 subgoals):\n 1. C = BoolAT \\<Longrightarrow> NullT \\<le> ArrT C\n 2. C = IntgAT \\<Longrightarrow> NullT \\<le> ArrT C\n 3. C = ShortAT \\<Longrightarrow> NullT \\<le> ArrT C\n 4. C = ByteAT \\<Longrightarrow> NullT \\<le> ArrT C", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. C = BoolAT \\<Longrightarrow> NullT \\<le> ArrT C\n 2. C = IntgAT \\<Longrightarrow> NullT \\<le> ArrT C\n 3. C = ShortAT \\<Longrightarrow> NullT \\<le> ArrT C\n 4. C = ByteAT \\<Longrightarrow> NullT \\<le> ArrT C", "assume c: \"C = BoolAT\""], ["proof (state)\nthis:\n  C = BoolAT\n\ngoal (4 subgoals):\n 1. C = BoolAT \\<Longrightarrow> NullT \\<le> ArrT C\n 2. C = IntgAT \\<Longrightarrow> NullT \\<le> ArrT C\n 3. C = ShortAT \\<Longrightarrow> NullT \\<le> ArrT C\n 4. C = ByteAT \\<Longrightarrow> NullT \\<le> ArrT C", "show \"NullT \\<le> ArrT C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NullT \\<le> ArrT C", "using c"], ["proof (prove)\nusing this:\n  C = BoolAT\n\ngoal (1 subgoal):\n 1. NullT \\<le> ArrT C", "by simp"], ["proof (state)\nthis:\n  NullT \\<le> ArrT C\n\ngoal (3 subgoals):\n 1. C = IntgAT \\<Longrightarrow> NullT \\<le> ArrT C\n 2. C = ShortAT \\<Longrightarrow> NullT \\<le> ArrT C\n 3. C = ByteAT \\<Longrightarrow> NullT \\<le> ArrT C", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. C = IntgAT \\<Longrightarrow> NullT \\<le> ArrT C\n 2. C = ShortAT \\<Longrightarrow> NullT \\<le> ArrT C\n 3. C = ByteAT \\<Longrightarrow> NullT \\<le> ArrT C", "assume c: \"C = IntgAT\""], ["proof (state)\nthis:\n  C = IntgAT\n\ngoal (3 subgoals):\n 1. C = IntgAT \\<Longrightarrow> NullT \\<le> ArrT C\n 2. C = ShortAT \\<Longrightarrow> NullT \\<le> ArrT C\n 3. C = ByteAT \\<Longrightarrow> NullT \\<le> ArrT C", "show \"NullT \\<le> ArrT C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NullT \\<le> ArrT C", "using c"], ["proof (prove)\nusing this:\n  C = IntgAT\n\ngoal (1 subgoal):\n 1. NullT \\<le> ArrT C", "by simp"], ["proof (state)\nthis:\n  NullT \\<le> ArrT C\n\ngoal (2 subgoals):\n 1. C = ShortAT \\<Longrightarrow> NullT \\<le> ArrT C\n 2. C = ByteAT \\<Longrightarrow> NullT \\<le> ArrT C", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. C = ShortAT \\<Longrightarrow> NullT \\<le> ArrT C\n 2. C = ByteAT \\<Longrightarrow> NullT \\<le> ArrT C", "assume c: \"C = ShortAT\""], ["proof (state)\nthis:\n  C = ShortAT\n\ngoal (2 subgoals):\n 1. C = ShortAT \\<Longrightarrow> NullT \\<le> ArrT C\n 2. C = ByteAT \\<Longrightarrow> NullT \\<le> ArrT C", "show \"NullT \\<le> ArrT C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NullT \\<le> ArrT C", "using c"], ["proof (prove)\nusing this:\n  C = ShortAT\n\ngoal (1 subgoal):\n 1. NullT \\<le> ArrT C", "by simp"], ["proof (state)\nthis:\n  NullT \\<le> ArrT C\n\ngoal (1 subgoal):\n 1. C = ByteAT \\<Longrightarrow> NullT \\<le> ArrT C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. C = ByteAT \\<Longrightarrow> NullT \\<le> ArrT C", "assume c: \"C = ByteAT\""], ["proof (state)\nthis:\n  C = ByteAT\n\ngoal (1 subgoal):\n 1. C = ByteAT \\<Longrightarrow> NullT \\<le> ArrT C", "show \"NullT \\<le> ArrT C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NullT \\<le> ArrT C", "using c"], ["proof (prove)\nusing this:\n  C = ByteAT\n\ngoal (1 subgoal):\n 1. NullT \\<le> ArrT C", "by simp"], ["proof (state)\nthis:\n  NullT \\<le> ArrT C\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}