{"file_name": "/home/qj213/afp-2021-10-22/thys/JiveDataStoreModel/Isa_Counter_Store/Attributes.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JiveDataStoreModel", "problem_names": ["lemma dtype_simps [simp]:\n\"dtype CounterImpl'value = CClassT CounterImpl\" \n\"dtype UndoCounter'save = CClassT UndoCounter\"\n\"dtype Dummy'dummy = AClassT Dummy\"\n\"dtype Counter'dummy = InterfaceT Counter\"", "lemma DTypeId_simps [simp]:\n\"cDTypeId CounterImpl'value = CounterImpl\" \n\"cDTypeId UndoCounter'save = UndoCounter\"\n\"aDTypeId Dummy'dummy = Dummy\"\n\"iDTypeId Counter'dummy = Counter\"", "lemma rtype_simps [simp]:\n\"rtype CounterImpl'value  = IntgT\"\n\"rtype UndoCounter'save  = IntgT\"\n\"rtype Dummy'dummy = NullT\"\n\"rtype Counter'dummy = NullT\"", "lemma catt_simps [simp]:\n\"catt CounterImpl CounterImpl'value = CounterImpl'CounterImpl'value\"\n\"catt UndoCounter CounterImpl'value = UndoCounter'CounterImpl'value\"\n\"catt UndoCounter UndoCounter'save = UndoCounter'UndoCounter'save\"\n\"catt CounterImpl Counter'dummy = CounterImpl'Counter'dummy\"\n\"catt UndoCounter Counter'dummy = UndoCounter'Counter'dummy\"", "lemma cls_simps [simp]:\n\"cls CounterImpl'CounterImpl'value = CounterImpl\"\n\"cls UndoCounter'CounterImpl'value = UndoCounter\"\n\"cls UndoCounter'UndoCounter'save = UndoCounter\"\n\"cls CounterImpl'Counter'dummy = CounterImpl\"\n\"cls UndoCounter'Counter'dummy = UndoCounter\"", "lemma att_simps [simp]:\n\"att CounterImpl'CounterImpl'value = CounterImpl'value\"\n\"att UndoCounter'CounterImpl'value = CounterImpl'value\"\n\"att UndoCounter'UndoCounter'save = UndoCounter'save\"\n\"att CounterImpl'Counter'dummy = Counter'dummy\"\n\"att UndoCounter'Counter'dummy = Counter'dummy\""], "translations": [["", "lemma dtype_simps [simp]:\n\"dtype CounterImpl'value = CClassT CounterImpl\" \n\"dtype UndoCounter'save = CClassT UndoCounter\"\n\"dtype Dummy'dummy = AClassT Dummy\"\n\"dtype Counter'dummy = InterfaceT Counter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dtype CounterImpl'value = CClassT CounterImpl &&&\n     dtype UndoCounter'save = CClassT UndoCounter) &&&\n    dtype Dummy'dummy = AClassT Dummy &&&\n    dtype Counter'dummy = InterfaceT Counter", "by (simp_all add: dtype_def dtype_def dtype_def)"], ["", "text \\<open>For convenience, we add some functions that directly apply the selectors of \n  the datatype @{typ Javatype}.\n\\<close>"], ["", "definition cDTypeId :: \"AttId \\<Rightarrow> CTypeId\" where\n\"cDTypeId f = (case f of \n              CounterImpl'value \\<Rightarrow> CounterImpl\n            | UndoCounter'save \\<Rightarrow> UndoCounter\n            | Dummy'dummy \\<Rightarrow> undefined\n            | Counter'dummy \\<Rightarrow> undefined )\""], ["", "definition aDTypeId:: \"AttId \\<Rightarrow> ATypeId\" where\n\"aDTypeId f = (case f of \n              CounterImpl'value \\<Rightarrow> undefined\n            | UndoCounter'save \\<Rightarrow> undefined\n            | Dummy'dummy \\<Rightarrow> Dummy\n            | Counter'dummy \\<Rightarrow> undefined )\""], ["", "definition iDTypeId:: \"AttId \\<Rightarrow> ITypeId\" where\n\"iDTypeId f = (case f of \n              CounterImpl'value \\<Rightarrow> undefined\n            | UndoCounter'save \\<Rightarrow> undefined\n            | Dummy'dummy \\<Rightarrow> undefined\n            | Counter'dummy \\<Rightarrow> Counter )\""], ["", "lemma DTypeId_simps [simp]:\n\"cDTypeId CounterImpl'value = CounterImpl\" \n\"cDTypeId UndoCounter'save = UndoCounter\"\n\"aDTypeId Dummy'dummy = Dummy\"\n\"iDTypeId Counter'dummy = Counter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cDTypeId CounterImpl'value = CounterImpl &&&\n     cDTypeId UndoCounter'save = UndoCounter) &&&\n    aDTypeId Dummy'dummy = Dummy &&& iDTypeId Counter'dummy = Counter", "by (simp_all add: cDTypeId_def aDTypeId_def iDTypeId_def)"], ["", "text \\<open>The range type of an attribute is the type of the value stored in that\nattribute.\n\\<close>"], ["", "definition rtype:: \"AttId \\<Rightarrow> Javatype\" where\n\"rtype f = (case f of \n              CounterImpl'value \\<Rightarrow> IntgT\n            | UndoCounter'save \\<Rightarrow> IntgT\n            | Dummy'dummy \\<Rightarrow> NullT\n            | Counter'dummy \\<Rightarrow> NullT)\""], ["", "lemma rtype_simps [simp]:\n\"rtype CounterImpl'value  = IntgT\"\n\"rtype UndoCounter'save  = IntgT\"\n\"rtype Dummy'dummy = NullT\"\n\"rtype Counter'dummy = NullT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rtype CounterImpl'value = IntgT &&& rtype UndoCounter'save = IntgT) &&&\n    rtype Dummy'dummy = NullT &&& rtype Counter'dummy = NullT", "by (simp_all add: rtype_def rtype_def rtype_def)"], ["", "text \\<open>With the datatype \\<open>CAttId\\<close> we describe the possible locations \nin memory for\ninstance fields. We rule out the impossible combinations of class names and\nfield names. For example, a \\<open>CounterImpl\\<close> cannot have a \\<open>save\\<close> \nfield. A store model which provides locations for all possible combinations\nof the Cartesian product of class name and field name works out fine as \nwell, because we cannot express modification of such ``wrong'' \nlocations in a Java program. So we can only prove useful properties about \nreasonable combinations.\nThe only drawback in such a model is that we cannot prove a property like \n\\<open>not_treach_ref_impl_not_reach\\<close> in theory StoreProperties. \nIf the store provides locations for\nevery combination of class name and field name, we cannot rule out \nreachability of certain pointer chains that go through ``wrong'' locations. \nThat is why we decided to introduce the new type \\<open>CAttId\\<close>.\n\n  While \\<open>AttId\\<close> describes which fields \nare declared in which classes and interfaces,\n  \\<open>CAttId\\<close> describes which objects of which classes may contain which \nfields at run-time. Thus,\n  \\<open>CAttId\\<close> makes the inheritance of fields visible in the formalization.\n\nThere is only one such datatype because only objects of concrete classes can be \ncreated at run-time,\nthus only instance fields of concrete classes can occupy memory.\\<close>"], ["", "datatype CAttId = CounterImpl'CounterImpl'value | UndoCounter'CounterImpl'value\n  | UndoCounter'UndoCounter'save \n  | CounterImpl'Counter'dummy | UndoCounter'Counter'dummy"], ["", "text \\<open>Function \\<open>catt\\<close> builds a \\<open>CAttId\\<close> from a class name\nand a field name. In case of the illegal combinations we just return\n\\<open>undefined\\<close>. We can also filter out static fields in \n\\<open>catt\\<close>.\\<close>"], ["", "definition catt:: \"CTypeId \\<Rightarrow> AttId \\<Rightarrow> CAttId\" where\n\"catt C f =\n  (case C of\n     CounterImpl \\<Rightarrow> (case f of \n                CounterImpl'value \\<Rightarrow> CounterImpl'CounterImpl'value\n              | UndoCounter'save \\<Rightarrow> undefined\n              | Dummy'dummy \\<Rightarrow> undefined\n              | Counter'dummy \\<Rightarrow> CounterImpl'Counter'dummy)\n   | UndoCounter \\<Rightarrow> (case f of \n                     CounterImpl'value \\<Rightarrow> UndoCounter'CounterImpl'value\n                   | UndoCounter'save \\<Rightarrow> UndoCounter'UndoCounter'save\n                   | Dummy'dummy \\<Rightarrow> undefined\n                   | Counter'dummy \\<Rightarrow> UndoCounter'Counter'dummy)\n   | Object \\<Rightarrow> undefined\n   | Exception \\<Rightarrow> undefined\n   | ClassCastException \\<Rightarrow> undefined\n   | NullPointerException \\<Rightarrow> undefined\n)\""], ["", "lemma catt_simps [simp]:\n\"catt CounterImpl CounterImpl'value = CounterImpl'CounterImpl'value\"\n\"catt UndoCounter CounterImpl'value = UndoCounter'CounterImpl'value\"\n\"catt UndoCounter UndoCounter'save = UndoCounter'UndoCounter'save\"\n\"catt CounterImpl Counter'dummy = CounterImpl'Counter'dummy\"\n\"catt UndoCounter Counter'dummy = UndoCounter'Counter'dummy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (catt CounterImpl CounterImpl'value = CounterImpl'CounterImpl'value &&&\n     catt UndoCounter CounterImpl'value = UndoCounter'CounterImpl'value) &&&\n    catt UndoCounter UndoCounter'save = UndoCounter'UndoCounter'save &&&\n    catt CounterImpl Counter'dummy = CounterImpl'Counter'dummy &&&\n    catt UndoCounter Counter'dummy = UndoCounter'Counter'dummy", "by (simp_all add: catt_def)"], ["", "text \\<open>Selection of the class name of the type of the object in which the field lives.\n  The field can only be located in a concrete class.\\<close>"], ["", "definition cls:: \"CAttId \\<Rightarrow> CTypeId\" where\n\"cls cf = (case cf of\n             CounterImpl'CounterImpl'value  \\<Rightarrow> CounterImpl\n           | UndoCounter'CounterImpl'value  \\<Rightarrow> UndoCounter\n           | UndoCounter'UndoCounter'save  \\<Rightarrow> UndoCounter\n  | CounterImpl'Counter'dummy \\<Rightarrow> CounterImpl\n  | UndoCounter'Counter'dummy \\<Rightarrow> UndoCounter\n)\""], ["", "lemma cls_simps [simp]:\n\"cls CounterImpl'CounterImpl'value = CounterImpl\"\n\"cls UndoCounter'CounterImpl'value = UndoCounter\"\n\"cls UndoCounter'UndoCounter'save = UndoCounter\"\n\"cls CounterImpl'Counter'dummy = CounterImpl\"\n\"cls UndoCounter'Counter'dummy = UndoCounter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cls CounterImpl'CounterImpl'value = CounterImpl &&&\n     cls UndoCounter'CounterImpl'value = UndoCounter) &&&\n    cls UndoCounter'UndoCounter'save = UndoCounter &&&\n    cls CounterImpl'Counter'dummy = CounterImpl &&&\n    cls UndoCounter'Counter'dummy = UndoCounter", "by (simp_all add: cls_def)"], ["", "text \\<open>Selection of the field name.\\<close>"], ["", "definition att:: \"CAttId \\<Rightarrow> AttId\" where\n\"att cf = (case cf of\n             CounterImpl'CounterImpl'value  \\<Rightarrow> CounterImpl'value\n           | UndoCounter'CounterImpl'value  \\<Rightarrow> CounterImpl'value\n           | UndoCounter'UndoCounter'save  \\<Rightarrow> UndoCounter'save\n           | CounterImpl'Counter'dummy \\<Rightarrow> Counter'dummy\n           | UndoCounter'Counter'dummy \\<Rightarrow> Counter'dummy\n)\""], ["", "lemma att_simps [simp]:\n\"att CounterImpl'CounterImpl'value = CounterImpl'value\"\n\"att UndoCounter'CounterImpl'value = CounterImpl'value\"\n\"att UndoCounter'UndoCounter'save = UndoCounter'save\"\n\"att CounterImpl'Counter'dummy = Counter'dummy\"\n\"att UndoCounter'Counter'dummy = Counter'dummy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (att CounterImpl'CounterImpl'value = CounterImpl'value &&&\n     att UndoCounter'CounterImpl'value = CounterImpl'value) &&&\n    att UndoCounter'UndoCounter'save = UndoCounter'save &&&\n    att CounterImpl'Counter'dummy = Counter'dummy &&&\n    att UndoCounter'Counter'dummy = Counter'dummy", "by (simp_all add: att_def)"], ["", "end"]]}