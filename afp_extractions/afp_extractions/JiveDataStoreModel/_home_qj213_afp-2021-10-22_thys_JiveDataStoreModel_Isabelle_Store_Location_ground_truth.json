{"file_name": "/home/qj213/afp-2021-10-22/thys/JiveDataStoreModel/Isabelle_Store/Location.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JiveDataStoreModel", "problem_names": ["lemma ltype_simps [simp]:\n\"ltype (objLoc cf a)  = rtype (att cf)\"\n\"ltype (staticLoc f)     = rtype f\"\n\"ltype (arrLenLoc T a)   = IntgT\"\n\"ltype (arrLoc T a i) = at2jt T\"", "lemma isArrLenLoc_simps [simp]:\n\"isArrLenLoc (objLoc cf a) = False\" \n\"isArrLenLoc (staticLoc f) = False\"\n\"isArrLenLoc (arrLenLoc T a) = True\"\n\"isArrLenLoc (arrLoc T a i) = False\"", "lemma isStaticLoc_simps [simp]:\n\"isStaticLoc (objLoc cf a) = False\"\n\"isStaticLoc (staticLoc f)     = True\"\n\"isStaticLoc (arrLenLoc T a)   = False\"\n\"isStaticLoc (arrLoc T a i) = False\"", "lemma ref_simps [simp]:\n\"ref (objLoc cf a)  = objV (cls cf) a\"\n\"ref (staticLoc f)     = nullV\"\n\"ref (arrLenLoc T a)   = arrV T a\"\n\"ref (arrLoc T a i) = arrV T a\"", "lemma ref_loc [simp]: \"\\<lbrakk>isObjV r; typeof r \\<le> dtype f\\<rbrakk> \\<Longrightarrow> ref (r..f) = r\"", "lemma obj_arr_loc [simp]: \"isArrV r \\<Longrightarrow> ref (r.[i]) = r\"", "lemma obj_arr_len [simp]: \"isArrV r \\<Longrightarrow> ref (arr_len r) = r\""], "translations": [["", "lemma ltype_simps [simp]:\n\"ltype (objLoc cf a)  = rtype (att cf)\"\n\"ltype (staticLoc f)     = rtype f\"\n\"ltype (arrLenLoc T a)   = IntgT\"\n\"ltype (arrLoc T a i) = at2jt T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ltype (objLoc cf a) = rtype (att cf) &&&\n     ltype (staticLoc f) = rtype f) &&&\n    ltype (arrLenLoc T a) = IntgT &&& ltype (arrLoc T a i) = at2jt T", "by (simp_all add: ltype_def)"], ["", "text \\<open>Discriminator functions to test whether a location denotes an array length\nor whether it denotes a static object. Currently, the discriminator functions for\nobject and array locations are not specified. They can be added if they are needed.\n\\<close>"], ["", "definition isArrLenLoc:: \"Location \\<Rightarrow> bool\" where\n\"isArrLenLoc l = (case l of\n                 objLoc cf a  \\<Rightarrow> False \n               | staticLoc f     \\<Rightarrow> False\n               | arrLenLoc T a   \\<Rightarrow> True\n               | arrLoc T a i \\<Rightarrow> False)\""], ["", "lemma isArrLenLoc_simps [simp]:\n\"isArrLenLoc (objLoc cf a) = False\" \n\"isArrLenLoc (staticLoc f) = False\"\n\"isArrLenLoc (arrLenLoc T a) = True\"\n\"isArrLenLoc (arrLoc T a i) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (isArrLenLoc (objLoc cf a) = False &&&\n     isArrLenLoc (staticLoc f) = False) &&&\n    isArrLenLoc (arrLenLoc T a) = True &&&\n    isArrLenLoc (arrLoc T a i) = False", "by (simp_all add: isArrLenLoc_def)"], ["", "definition isStaticLoc:: \"Location \\<Rightarrow> bool\" where\n\"isStaticLoc l = (case l of\n                 objLoc cff a \\<Rightarrow> False\n               | staticLoc f     \\<Rightarrow> True\n               | arrLenLoc T a   \\<Rightarrow> False\n               | arrLoc T a i \\<Rightarrow> False)\""], ["", "lemma isStaticLoc_simps [simp]:\n\"isStaticLoc (objLoc cf a) = False\"\n\"isStaticLoc (staticLoc f)     = True\"\n\"isStaticLoc (arrLenLoc T a)   = False\"\n\"isStaticLoc (arrLoc T a i) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (isStaticLoc (objLoc cf a) = False &&&\n     isStaticLoc (staticLoc f) = True) &&&\n    isStaticLoc (arrLenLoc T a) = False &&&\n    isStaticLoc (arrLoc T a i) = False", "by (simp_all add: isStaticLoc_def)"], ["", "text \\<open>The function \\<open>ref\\<close> yields the\nobject or array containing the location that is passed\nas argument (see the function \\<open>obj\\<close> in \n\\cite[p. 43 f.]{Poetzsch-Heffter97specification}).\nNote that for static locations\nthe result is \\<open>nullV\\<close> since static locations \nare not associated to any object.\n\\label{ref_def}\n\\<close>"], ["", "definition ref:: \"Location \\<Rightarrow> Value\" where\n\"ref l = (case l of\n            objLoc cf a  \\<Rightarrow> objV (cls cf) a\n          | staticLoc f     \\<Rightarrow> nullV\n          | arrLenLoc T a   \\<Rightarrow> arrV T a\n          | arrLoc T a i \\<Rightarrow> arrV T a)\""], ["", "lemma ref_simps [simp]:\n\"ref (objLoc cf a)  = objV (cls cf) a\"\n\"ref (staticLoc f)     = nullV\"\n\"ref (arrLenLoc T a)   = arrV T a\"\n\"ref (arrLoc T a i) = arrV T a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ref (objLoc cf a) = objV (cls cf) a &&& ref (staticLoc f) = nullV) &&&\n    ref (arrLenLoc T a) = arrV T a &&& ref (arrLoc T a i) = arrV T a", "by (simp_all add: ref_def)"], ["", "text \\<open>The function \\<open>loc\\<close> denotes the subscription of an object \nreference with an attribute.\\<close>"], ["", "primrec loc:: \"Value \\<Rightarrow> AttId \\<Rightarrow> Location\"  (\"_.._\" [80,80] 80)\nwhere \"loc (objV c a) f = objLoc (catt c f) a\""], ["", "text \\<open>Note that we only define subscription properly for object references.\nFor all other values we do not provide any defining equation, so they will \ninternally be mapped to \\<open>arbitrary\\<close>.\n\\<close>"], ["", "text \\<open>The length of an array can be selected with the function \\<open>arr_len\\<close>.\\<close>"], ["", "primrec arr_len:: \"Value \\<Rightarrow> Location\"\nwhere \"arr_len (arrV T a) = arrLenLoc T a\""], ["", "text \\<open>Arrays can be indexed by the function \\<open>arr_loc\\<close>.\\<close>"], ["", "primrec arr_loc:: \"Value \\<Rightarrow> nat \\<Rightarrow> Location\" (\"_.[_]\" [80,80] 80)\nwhere \"arr_loc (arrV T a) i = arrLoc T a i\""], ["", "text \\<open>The functions @{term \"loc\"}, @{term \"arr_len\"} and @{term \"arr_loc\"}\ndefine the interface between the basic store model (based on locations) and\nthe programming language Java. Instance field access {\\tt obj.x} is modelled as \n@{term \"obj..x\"} or \\<open>loc obj x\\<close> (without the syntactic sugar), \narray length {\\tt a.length} with @{term \"arr_len a\"},\narray indexing {\\tt a[i]} with @{term \"a.[i]\"} or \\<open>arr_loc a i\\<close>. \nThe accessing of a static field \n{\\tt C.f} can be expressed by the location itself \\<open>staticLoc C'f\\<close>.\nOf course one can build more infrastructure to make access to instance fields\nand static fields more uniform. We could for example define a \nfunction \\<open>static\\<close> which indicates whether a field is static or not and\nbased on that create an @{term \"objLoc\"} location or a @{term \"staticLoc\"} location. But \nthis will only complicate the actual proofs and we can already easily \nperform the distinction whether a field is static or not in the \\jive-frontend and \ntherefore keep the verification simpler.\n\\<close>"], ["", "lemma ref_loc [simp]: \"\\<lbrakk>isObjV r; typeof r \\<le> dtype f\\<rbrakk> \\<Longrightarrow> ref (r..f) = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isObjV r; \\<tau> r \\<le> dtype f\\<rbrakk>\n    \\<Longrightarrow> ref (r..f) = r", "apply (case_tac r)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>isObjV r; \\<tau> r \\<le> dtype f; r = boolV x1\\<rbrakk>\n       \\<Longrightarrow> ref (r..f) = r\n 2. \\<And>x2.\n       \\<lbrakk>isObjV r; \\<tau> r \\<le> dtype f; r = intgV x2\\<rbrakk>\n       \\<Longrightarrow> ref (r..f) = r\n 3. \\<And>x3.\n       \\<lbrakk>isObjV r; \\<tau> r \\<le> dtype f; r = shortV x3\\<rbrakk>\n       \\<Longrightarrow> ref (r..f) = r\n 4. \\<And>x4.\n       \\<lbrakk>isObjV r; \\<tau> r \\<le> dtype f; r = byteV x4\\<rbrakk>\n       \\<Longrightarrow> ref (r..f) = r\n 5. \\<And>x51 x52.\n       \\<lbrakk>isObjV r; \\<tau> r \\<le> dtype f; r = objV x51 x52\\<rbrakk>\n       \\<Longrightarrow> ref (r..f) = r\n 6. \\<And>x61 x62.\n       \\<lbrakk>isObjV r; \\<tau> r \\<le> dtype f; r = arrV x61 x62\\<rbrakk>\n       \\<Longrightarrow> ref (r..f) = r\n 7. \\<lbrakk>isObjV r; \\<tau> r \\<le> dtype f; r = nullV\\<rbrakk>\n    \\<Longrightarrow> ref (r..f) = r", "apply (case_tac [!] f)"], ["proof (prove)\ngoal (28 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>isObjV r; \\<tau> r \\<le> dtype f; r = boolV x1;\n        f = CounterImpl'value\\<rbrakk>\n       \\<Longrightarrow> ref (r..f) = r\n 2. \\<And>x1.\n       \\<lbrakk>isObjV r; \\<tau> r \\<le> dtype f; r = boolV x1;\n        f = UndoCounter'save\\<rbrakk>\n       \\<Longrightarrow> ref (r..f) = r\n 3. \\<And>x1.\n       \\<lbrakk>isObjV r; \\<tau> r \\<le> dtype f; r = boolV x1;\n        f = Dummy'dummy\\<rbrakk>\n       \\<Longrightarrow> ref (r..f) = r\n 4. \\<And>x1.\n       \\<lbrakk>isObjV r; \\<tau> r \\<le> dtype f; r = boolV x1;\n        f = Counter'dummy\\<rbrakk>\n       \\<Longrightarrow> ref (r..f) = r\n 5. \\<And>x2.\n       \\<lbrakk>isObjV r; \\<tau> r \\<le> dtype f; r = intgV x2;\n        f = CounterImpl'value\\<rbrakk>\n       \\<Longrightarrow> ref (r..f) = r\n 6. \\<And>x2.\n       \\<lbrakk>isObjV r; \\<tau> r \\<le> dtype f; r = intgV x2;\n        f = UndoCounter'save\\<rbrakk>\n       \\<Longrightarrow> ref (r..f) = r\n 7. \\<And>x2.\n       \\<lbrakk>isObjV r; \\<tau> r \\<le> dtype f; r = intgV x2;\n        f = Dummy'dummy\\<rbrakk>\n       \\<Longrightarrow> ref (r..f) = r\n 8. \\<And>x2.\n       \\<lbrakk>isObjV r; \\<tau> r \\<le> dtype f; r = intgV x2;\n        f = Counter'dummy\\<rbrakk>\n       \\<Longrightarrow> ref (r..f) = r\n 9. \\<And>x3.\n       \\<lbrakk>isObjV r; \\<tau> r \\<le> dtype f; r = shortV x3;\n        f = CounterImpl'value\\<rbrakk>\n       \\<Longrightarrow> ref (r..f) = r\n 10. \\<And>x3.\n        \\<lbrakk>isObjV r; \\<tau> r \\<le> dtype f; r = shortV x3;\n         f = UndoCounter'save\\<rbrakk>\n        \\<Longrightarrow> ref (r..f) = r\nA total of 28 subgoals...", "apply (simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma obj_arr_loc [simp]: \"isArrV r \\<Longrightarrow> ref (r.[i]) = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isArrV r \\<Longrightarrow> ref (r.[i]) = r", "by (cases r) simp_all"], ["", "lemma obj_arr_len [simp]: \"isArrV r \\<Longrightarrow> ref (arr_len r) = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isArrV r \\<Longrightarrow> ref (arr_len r) = r", "by (cases r) simp_all"], ["", "end"]]}