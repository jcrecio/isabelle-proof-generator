{"file_name": "/home/qj213/afp-2021-10-22/thys/JiveDataStoreModel/Isabelle_Store/Store.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/JiveDataStoreModel", "problem_names": ["lemma isNewArr_simps [simp]:\n\"isNewArr (new_instance C) = False\"\n\"isNewArr (new_array T l)  = True\"", "lemma typeofNew_simps:\n\"typeofNew (new_instance C) = CClassT C\"\n\"typeofNew (new_array T l)  = ArrT T\"", "lemma alive_trivial_simps [simp,intro]:\n\"alive (boolV b) s\"\n\"alive (intgV i) s\"\n\"alive (shortV sh) s\"\n\"alive (byteV by) s\"\n\"alive nullV     s\"", "lemma alive_init [simp,intro]: \"alive (init T) s\"", "lemma alive_loc [simp]: \n  \"\\<lbrakk>isObjV x; typeof x \\<le> dtype f\\<rbrakk> \\<Longrightarrow> alive (ref (x..f)) s = alive x s\"", "lemma alive_arr_loc [simp]: \n  \"isArrV x \\<Longrightarrow> alive (ref (x.[i])) s = alive x s\"", "lemma alive_arr_len [simp]: \n  \"isArrV x \\<Longrightarrow> alive (ref (arr_len x)) s = alive x s\"", "lemma ref_arr_len_new [simp]: \n  \"ref (arr_len (new s (new_array T n))) = new s (new_array T n)\"", "lemma ref_arr_loc_new [simp]: \n  \"ref ((new s (new_array T n)).[i]) = new s (new_array T n)\"", "lemma ref_loc_new [simp]: \"CClassT C \\<le> dtype f \n  \\<Longrightarrow> ref ((new s (new_instance C))..f) = new s (new_instance C)\"", "lemma access_type_safe [simp,intro]: \"typeof (s@@l) \\<le> ltype l\"", "lemma always_welltyped_store: \"wts OS\"", "lemma alive_access [simp,intro]: \"alive (s@@l) s\"", "lemma access_unalive [simp]: \n  assumes unalive: \"\\<not> alive (ref l) s\" \n  shows \"s@@l = init (ltype l)\"", "lemma update_induct:\n  assumes skip: \"P s\"\n  assumes update: \"\\<lbrakk>alive (ref l) s; alive v s; typeof v \\<le> ltype l\\<rbrakk> \\<Longrightarrow>\n               P (Abs_Store ((Rep_Store s)\\<lparr>vals:=(vals (Rep_Store s))(l:=v)\\<rparr>))\" \n  shows \"P (s\\<langle>l:=v\\<rangle>)\"", "lemma vals_update_in_Store:\n  assumes alive_l: \"alive (ref l) s\" \n  assumes alive_y: \"alive y s\" \n  assumes type_conform: \"typeof y \\<le> ltype l\"\n  shows \"(Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>) \\<in> Store\" \n  (is \"?s_upd \\<in> Store\")", "lemma alive_update_invariant [simp]: \"alive x (s\\<langle>l:=y\\<rangle>) = alive x s\"", "lemma access_update_other [simp]: \n  assumes neq_l_m: \"l \\<noteq> m\" \n  shows \"s\\<langle>l:=x\\<rangle>@@m = s@@m\"", "lemma update_access_same [simp]: \n  assumes alive_l: \"alive (ref l) s\" \n  assumes alive_x: \"alive x s\" \n  assumes widen_x_l: \"typeof x \\<le> ltype l\"\n  shows \"s\\<langle>l:=x\\<rangle>@@l = x\"", "lemma update_unalive_val [simp,intro]: \"\\<not> alive x s \\<Longrightarrow> s\\<langle>l:=x\\<rangle> = s\"", "lemma update_unalive_loc [simp,intro]: \"\\<not> alive (ref l) s \\<Longrightarrow> s\\<langle>l:=x\\<rangle> = s\"", "lemma update_type_mismatch [simp,intro]: \"\\<not> typeof x \\<le> ltype l \\<Longrightarrow> s\\<langle>l:=x\\<rangle> = s\"", "lemma alive_primitive [simp,intro]: \"isprimitive (typeof x) \\<Longrightarrow> alive x s\"", "lemma new_unalive_old_Store [simp]: \"\\<not> alive (new s t) s\"", "lemma alloc_new_instance_in_Store:\n\"(Rep_Store s\\<lparr>newOID := \\<lambda>D. if C = D\n                                   then Suc (newOID (Rep_Store s) C)\n                                   else newOID (Rep_Store s) D\\<rparr>) \\<in> Store\"\n(is \"?s_alloc \\<in> Store\")", "lemma alloc_new_array_in_Store:\n\"(Rep_Store s \\<lparr>newAID :=\n                  \\<lambda>S. if T = S\n                      then Suc (newAID (Rep_Store s) T)\n                      else newAID (Rep_Store s) S,\n               vals := (vals (Rep_Store s))\n                         (arrLenLoc T\n                           (newAID (Rep_Store s) T) :=\n                           intgV (int n))\\<rparr>) \\<in> Store\"\n(is \"?s_alloc \\<in> Store\")", "lemma new_alive_alloc [simp,intro]: \"alive (new s t) (s\\<langle>t\\<rangle>)\"", "lemma value_class_inhabitants: \n\"(\\<forall>x. typeof x = CClassT typeId \\<longrightarrow> P x) = (\\<forall> a. P (objV typeId a))\"\n  (is \"(\\<forall> x. ?A x) = ?B\")", "lemma value_array_inhabitants: \n\"(\\<forall>x. typeof x = ArrT typeId \\<longrightarrow> P x) = (\\<forall> a. P (arrV typeId a))\"\n  (is \"(\\<forall> x. ?A x) = ?B\")", "lemma le_Suc_eq: \"(\\<forall>a. (a < Suc n) = (a < Suc m)) = (\\<forall>a. (a < n) = (a < m))\"\n (is \"(\\<forall>a. ?A a) = (\\<forall> a. ?B a)\")", "lemma all_le_eq_imp_eq: \"\\<And> c::nat. (\\<forall>a. (a < d) = (a < c)) \\<longrightarrow> (d = c)\"", "lemma all_le_eq: \"(\\<forall> a::nat. (a < d) = (a < c)) = (d = c)\"", "lemma typeof_new: \"typeof (new s t) = typeofNew t\"", "lemma new_eq: \"(new s1 t = new s2 t) = \n                 (\\<forall> x. typeof x = typeofNew t \\<longrightarrow> alive x s1 = alive x s2)\"", "lemma new_update [simp]: \"new (s\\<langle>l:=x\\<rangle>) t = new s t\"", "lemma alive_alloc_propagation: \n  assumes alive_s: \"alive x s\" shows  \"alive x (s\\<langle>t\\<rangle>)\"", "lemma alive_alloc_exhaust: \"alive x (s\\<langle>t\\<rangle>) = (alive x s \\<or> (x = new s t))\"", "lemma alive_alloc_cases [consumes 1]: \n  \"\\<lbrakk>alive x (s\\<langle>t\\<rangle>); alive x s \\<Longrightarrow> P; x=new s t \\<Longrightarrow> P\\<rbrakk>\n   \\<Longrightarrow> P\"", "lemma aliveImpl_vals_independent: \"aliveImpl x (s\\<lparr>vals := z\\<rparr>) = aliveImpl x s\"", "lemma access_arr_len_new_alloc [simp]: \n  \"s\\<langle>new_array T l\\<rangle>@@arr_len (new s (new_array T l)) = intgV (int l)\"", "lemma access_new [simp]:\n  assumes ref_new: \"ref l = new s t\"\n  assumes no_arr_len: \"isNewArr t \\<longrightarrow> l \\<noteq> arr_len (new s t)\"\n  shows \"s\\<langle>t\\<rangle>@@l = init (ltype l)\"", "lemma access_alloc [simp]:\n  assumes no_arr_len_new: \"isNewArr t \\<longrightarrow> l \\<noteq> arr_len (new s t)\"\n  shows \"s\\<langle>t\\<rangle>@@l = s@@l\"", "lemma Store_eqI: \n  assumes eq_alive: \"\\<forall> x. alive x s1 = alive x s2\" \n  assumes eq_access: \"\\<forall> l. s1@@l = s2@@l\"\n  shows \"s1=s2\"", "lemma comm: \n  assumes neq_l_new: \"ref l \\<noteq> new s t\"\n  assumes neq_x_new: \"x \\<noteq> new s t\"\n  shows \"s\\<langle>t\\<rangle>\\<langle>l:=x\\<rangle> = s\\<langle>l:=x\\<rangle>\\<langle>t\\<rangle>\""], "translations": [["", "lemma isNewArr_simps [simp]:\n\"isNewArr (new_instance C) = False\"\n\"isNewArr (new_array T l)  = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isNewArr (new_instance C) = False &&& isNewArr (new_array T l) = True", "by (simp_all add: isNewArr_def)"], ["", "text \\<open>The function \\<open>typeofNew\\<close> yields the type of the newly created\nelement.\\<close>"], ["", "definition typeofNew :: \"New \\<Rightarrow> Javatype\" where\n\"typeofNew n = (case n of\n                  new_instance C \\<Rightarrow> CClassT C\n                | new_array T l  \\<Rightarrow> ArrT T)\""], ["", "lemma typeofNew_simps:\n\"typeofNew (new_instance C) = CClassT C\"\n\"typeofNew (new_array T l)  = ArrT T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeofNew (new_instance C) = CClassT C &&&\n    typeofNew (new_array T l) = ArrT T", "by (simp_all add: typeofNew_def)"], ["", "subsection \\<open>The Definition of the Store\\<close>"], ["", "text \\<open>In our store model, all objects\\footnote{In the following, the term ``objects'' \nincludes arrays. This keeps the explanations compact.}\nof all classes exist at all times, but only those objects that have already been allocated\nare alive. Objects cannot be deallocated, thus an object that once gained\nthe aliveness status cannot lose it later on.\n\\\\[12pt]\n To model the store, we need two functions that give us fresh object Id's for \nthe allocation of new objects (function \\<open>newOID\\<close>) and arrays\n(function \\<open>newAID\\<close>) as well as a function that maps locations to\ntheir contents (function \\<open>vals\\<close>).\\<close>"], ["", "record StoreImpl = newOID :: \"CTypeId \\<Rightarrow> ObjectId\"\n                   newAID :: \"Arraytype \\<Rightarrow> ObjectId\"\n                   vals   :: \"Location \\<Rightarrow> Value\""], ["", "text \\<open>The function \\<open>aliveImpl\\<close> determines for a given value whether\nit is alive in a given store.\n\\<close>"], ["", "definition aliveImpl::\"Value \\<Rightarrow> StoreImpl \\<Rightarrow> bool\" where\n\"aliveImpl x s = (case x of\n                    boolV b  \\<Rightarrow> True\n                  | intgV i  \\<Rightarrow> True\n                  | shortV s  \\<Rightarrow> True\n                  | byteV by  \\<Rightarrow> True\n                  | objV C a \\<Rightarrow> (a < newOID s C)\n                  | arrV T a \\<Rightarrow> (a < newAID s T)\n                  | nullV    \\<Rightarrow> True)\""], ["", "text \\<open>The store itself is defined as new type. The store ensures\nand maintains the following \nproperties: All stored values are alive; for all locations whose values are\nnot alive, the store yields the location type's init value; and\nall stored values are of the correct type (i.e.~of the type of the location\nthey are stored in).\n\\<close>"], ["", "definition \"Store = {s. (\\<forall> l. aliveImpl (vals s l) s) \\<and> \n                  (\\<forall> l. \\<not> aliveImpl (ref l) s \\<longrightarrow> vals s l = init (ltype l)) \\<and>\n                  (\\<forall> l. typeof (vals s l) \\<le> ltype l)}\""], ["", "typedef Store = Store"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> Store", "unfolding Store_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> {s. (\\<forall>l. aliveImpl (vals s l) s) \\<and>\n                   (\\<forall>l.\n                       \\<not> aliveImpl (ref l) s \\<longrightarrow>\n                       vals s l = init (ltype l)) \\<and>\n                   (\\<forall>l. \\<tau> vals s l \\<le> ltype l)}", "apply (rule exI [where ?x=\"\\<lparr> newOID = (\\<lambda>C. 0),\n                          newAID = (\\<lambda>T. 0),\n                          vals = (\\<lambda>l. init (ltype l)) \\<rparr>\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>newOID = \\<lambda>C. 0, newAID = \\<lambda>T. 0,\n       vals = \\<lambda>l. init (ltype l)\\<rparr>\n    \\<in> {s. (\\<forall>l. aliveImpl (vals s l) s) \\<and>\n              (\\<forall>l.\n                  \\<not> aliveImpl (ref l) s \\<longrightarrow>\n                  vals s l = init (ltype l)) \\<and>\n              (\\<forall>l. \\<tau> vals s l \\<le> ltype l)}", "apply (auto simp add: aliveImpl_def init_def NullT_leaf_array split: Javatype.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>One might also model the Store as axiomatic type class and prove that the type StoreImpl belongs\nto this type class. This way, a clearer separation between the axiomatic description of the store and its\nproperties on the one hand and the realization that has been chosen in this formalization on the other hand\ncould be achieved. Additionally, it would be easier to make use of  different store implementations that\nmight have different additional features. This separation remains to be performed as future work.\n\\<close>"], ["", "subsection\\<open>The Store Interface\\<close>"], ["", "text \\<open>The Store interface consists of five functions:\n\\<open>access\\<close> to read the value that is stored at a location;\n\\<open>alive\\<close> to test whether a value is alive in the store;\n\\<open>alloc\\<close> to allocate a new element in the store;\n\\<open>new\\<close> to read the value of a newly allocated element;\n\\<open>update\\<close> to change the value that is stored at a location.\n\\<close>"], ["", "consts access:: \"Store \\<Rightarrow> Location \\<Rightarrow> Value\"  (\"_@@_\" [71,71] 70)     \n       alive:: \"Value \\<Rightarrow> Store \\<Rightarrow> bool\"\n       alloc:: \"Store \\<Rightarrow> New \\<Rightarrow> Store\" \n       new:: \"Store \\<Rightarrow> New \\<Rightarrow> Value\"\n       update:: \"Store \\<Rightarrow> Location \\<Rightarrow> Value \\<Rightarrow> Store\""], ["", "nonterminal smodifybinds and smodifybind"], ["", "syntax\n  \"_smodifybind\" :: \"['a, 'a]     \\<Rightarrow> smodifybind\" (\"(2_ :=/ _)\")\n  \"\"         :: \"smodifybind \\<Rightarrow> smodifybinds\"     (\"_\")\n  \"\"         :: \"CTypeId \\<Rightarrow> smodifybind\"          (\"_\")\n  \"_smodifybinds\":: \"[smodifybind, smodifybinds] => smodifybinds\" (\"_,/ _\")\n  \"_sModify\"  :: \"['a, smodifybinds] \\<Rightarrow> 'a\"       (\"_/\\<langle>(_)\\<rangle>\" [900,0] 900)"], ["", "translations\n  \"_sModify s (_smodifybinds b bs)\"  == \"_sModify (_sModify s b) bs\"\n  \"s\\<langle>x:=y\\<rangle>\"                          == \"CONST update s x y\"\n  \"s\\<langle>c\\<rangle>\"                             == \"CONST alloc s c\""], ["", "text \\<open>With this syntactic setup we can write chains of (array) updates and \nallocations like in the\nfollowing term  \n@{term \"s\\<langle>new_instance Node,x:=y,z:=intgV 3,new_array IntgAT 3,a.[i]:=intgV 4,k:=boolV True\\<rangle>\"}. \n\\<close>"], ["", "text \\<open>In the following, the definitions of the five store interface functions and some lemmas \nabout them are given.\\<close>"], ["", "overloading alive \\<equiv> alive\nbegin"], ["", "definition alive where \"alive x s \\<equiv> aliveImpl x (Rep_Store s)\""], ["", "end"], ["", "lemma alive_trivial_simps [simp,intro]:\n\"alive (boolV b) s\"\n\"alive (intgV i) s\"\n\"alive (shortV sh) s\"\n\"alive (byteV by) s\"\n\"alive nullV     s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (alive (boolV b) s &&& alive (intgV i) s) &&&\n    alive (shortV sh) s &&& alive (byteV by) s &&& alive nullV s", "by (simp_all add: alive_def aliveImpl_def)"], ["", "overloading\n  access \\<equiv> access\n  update \\<equiv> update\n  alloc \\<equiv> alloc\n  new \\<equiv> new\nbegin"], ["", "definition access\n  where \"access s l \\<equiv> vals (Rep_Store s) l\""], ["", "definition update\n  where \"update s l v \\<equiv>\n    if alive (ref l) s \\<and> alive v s \\<and> typeof v \\<le> ltype l \n    then Abs_Store ((Rep_Store s)\\<lparr>vals:=(vals (Rep_Store s))(l:=v)\\<rparr>)\n    else s\""], ["", "definition alloc\n  where \"alloc s t \\<equiv>\n    (case t of \n       new_instance C \n        \\<Rightarrow> Abs_Store \n            ((Rep_Store s)\\<lparr>newOID := \\<lambda> D. if C=D \n                              then Suc (newOID (Rep_Store s) C) \n                              else newOID (Rep_Store s) D\\<rparr>)\n     | new_array T l\n        \\<Rightarrow> Abs_Store\n            ((Rep_Store s)\\<lparr>newAID := \\<lambda> S. if T=S \n                             then Suc (newAID (Rep_Store s) T)\n                             else newAID (Rep_Store s) S,\n                           vals :=  (vals (Rep_Store s))\n                                      (arrLenLoc T (newAID (Rep_Store s) T) \n                                        := intgV (int l))\\<rparr>))\""], ["", "definition new\n  where \"new s t \\<equiv>\n    (case t of\n      new_instance C \\<Rightarrow> objV C (newOID (Rep_Store s) C)\n    | new_array T l  \\<Rightarrow> arrV T (newAID (Rep_Store s) T))\""], ["", "end"], ["", "text \\<open>The predicate \\<open>wts\\<close> tests whether the store is well-typed.\\<close>"], ["", "definition\nwts :: \"Store \\<Rightarrow> bool\" where\n\"wts OS = (\\<forall> (l::Location) . (typeof (OS@@l)) \\<le> (ltype l))\""], ["", "subsection \\<open>Derived Properties of the Store\\<close>"], ["", "text \\<open>In this subsection, a number of lemmas formalize various properties of the Store.\nEspecially the 13 axioms are proven that must hold for a modelling of a Store \n(see \\cite[p. 45]{Poetzsch-Heffter97specification}). They are labeled with\nStore1 to Store13.\\<close>"], ["", "lemma alive_init [simp,intro]: \"alive (init T) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alive (init T) s", "by (cases T) (simp_all add: alive_def aliveImpl_def)"], ["", "lemma alive_loc [simp]: \n  \"\\<lbrakk>isObjV x; typeof x \\<le> dtype f\\<rbrakk> \\<Longrightarrow> alive (ref (x..f)) s = alive x s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isObjV x; \\<tau> x \\<le> dtype f\\<rbrakk>\n    \\<Longrightarrow> alive (ref (x..f)) s = alive x s", "by (cases x) (simp_all)"], ["", "lemma alive_arr_loc [simp]: \n  \"isArrV x \\<Longrightarrow> alive (ref (x.[i])) s = alive x s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isArrV x \\<Longrightarrow> alive (ref (x.[i])) s = alive x s", "by (cases x) (simp_all)"], ["", "lemma alive_arr_len [simp]: \n  \"isArrV x \\<Longrightarrow> alive (ref (arr_len x)) s = alive x s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isArrV x \\<Longrightarrow> alive (ref (arr_len x)) s = alive x s", "by (cases x) (simp_all)"], ["", "lemma ref_arr_len_new [simp]: \n  \"ref (arr_len (new s (new_array T n))) = new s (new_array T n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ref (arr_len (new s (new_array T n))) = new s (new_array T n)", "by (simp add: new_def)"], ["", "lemma ref_arr_loc_new [simp]: \n  \"ref ((new s (new_array T n)).[i]) = new s (new_array T n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ref (new s (new_array T n).[i]) = new s (new_array T n)", "by (simp add: new_def)"], ["", "lemma ref_loc_new [simp]: \"CClassT C \\<le> dtype f \n  \\<Longrightarrow> ref ((new s (new_instance C))..f) = new s (new_instance C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CClassT C \\<le> dtype f \\<Longrightarrow>\n    ref (new s (new_instance C)..f) = new s (new_instance C)", "by (simp add: new_def)"], ["", "lemma access_type_safe [simp,intro]: \"typeof (s@@l) \\<le> ltype l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> s@@l \\<le> ltype l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau> s@@l \\<le> ltype l", "have \"Rep_Store s \\<in> Store\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_Store s \\<in> Store", "by (rule Rep_Store)"], ["proof (state)\nthis:\n  Rep_Store s \\<in> Store\n\ngoal (1 subgoal):\n 1. \\<tau> s@@l \\<le> ltype l", "thus ?thesis"], ["proof (prove)\nusing this:\n  Rep_Store s \\<in> Store\n\ngoal (1 subgoal):\n 1. \\<tau> s@@l \\<le> ltype l", "by (auto simp add: access_def Store_def)"], ["proof (state)\nthis:\n  \\<tau> s@@l \\<le> ltype l\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The store is well-typed by construction.\\<close>"], ["", "lemma always_welltyped_store: \"wts OS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wts OS", "by (simp add: wts_def access_type_safe)"], ["", "text \\<open>Store8\\<close>"], ["", "lemma alive_access [simp,intro]: \"alive (s@@l) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alive (s@@l) s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. alive (s@@l) s", "have \"Rep_Store s \\<in> Store\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_Store s \\<in> Store", "by (rule Rep_Store)"], ["proof (state)\nthis:\n  Rep_Store s \\<in> Store\n\ngoal (1 subgoal):\n 1. alive (s@@l) s", "thus ?thesis"], ["proof (prove)\nusing this:\n  Rep_Store s \\<in> Store\n\ngoal (1 subgoal):\n 1. alive (s@@l) s", "by (auto simp add: access_def Store_def alive_def aliveImpl_def)"], ["proof (state)\nthis:\n  alive (s@@l) s\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Store3\\<close>"], ["", "lemma access_unalive [simp]: \n  assumes unalive: \"\\<not> alive (ref l) s\" \n  shows \"s@@l = init (ltype l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s@@l = init (ltype l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s@@l = init (ltype l)", "have \"Rep_Store s \\<in> Store\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_Store s \\<in> Store", "by (rule Rep_Store)"], ["proof (state)\nthis:\n  Rep_Store s \\<in> Store\n\ngoal (1 subgoal):\n 1. s@@l = init (ltype l)", "with unalive"], ["proof (chain)\npicking this:\n  \\<not> alive (ref l) s\n  Rep_Store s \\<in> Store", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> alive (ref l) s\n  Rep_Store s \\<in> Store\n\ngoal (1 subgoal):\n 1. s@@l = init (ltype l)", "by (simp add: access_def Store_def alive_def aliveImpl_def)"], ["proof (state)\nthis:\n  s@@l = init (ltype l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma update_induct:\n  assumes skip: \"P s\"\n  assumes update: \"\\<lbrakk>alive (ref l) s; alive v s; typeof v \\<le> ltype l\\<rbrakk> \\<Longrightarrow>\n               P (Abs_Store ((Rep_Store s)\\<lparr>vals:=(vals (Rep_Store s))(l:=v)\\<rparr>))\" \n  shows \"P (s\\<langle>l:=v\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (s\\<langle>l := v\\<rangle>)", "using update skip"], ["proof (prove)\nusing this:\n  \\<lbrakk>alive (ref l) s; alive v s; \\<tau> v \\<le> ltype l\\<rbrakk>\n  \\<Longrightarrow> P (Abs_Store\n                        (Rep_Store s\n                         \\<lparr>vals := (vals (Rep_Store s))\n                                   (l := v)\\<rparr>))\n  P s\n\ngoal (1 subgoal):\n 1. P (s\\<langle>l := v\\<rangle>)", "by (simp add: update_def)"], ["", "lemma vals_update_in_Store:\n  assumes alive_l: \"alive (ref l) s\" \n  assumes alive_y: \"alive y s\" \n  assumes type_conform: \"typeof y \\<le> ltype l\"\n  shows \"(Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>) \\<in> Store\" \n  (is \"?s_upd \\<in> Store\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>\n    \\<in> Store", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>\n    \\<in> Store", "have s: \"Rep_Store s \\<in> Store\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_Store s \\<in> Store", "by (rule Rep_Store)"], ["proof (state)\nthis:\n  Rep_Store s \\<in> Store\n\ngoal (1 subgoal):\n 1. Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>\n    \\<in> Store", "have alloc_eq: \"newOID ?s_upd = newOID (Rep_Store s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. newOID\n     (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>) =\n    newOID (Rep_Store s)", "by simp"], ["proof (state)\nthis:\n  newOID (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>) =\n  newOID (Rep_Store s)\n\ngoal (1 subgoal):\n 1. Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>\n    \\<in> Store", "have \"\\<forall> l. aliveImpl (vals ?s_upd l) ?s_upd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>la.\n       aliveImpl\n        (vals\n          (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n          la)\n        (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>la.\n       aliveImpl\n        (vals\n          (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n          la)\n        (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>la.\n       aliveImpl\n        (vals\n          (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n          la)\n        (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)", "show \"aliveImpl (vals ?s_upd k) ?s_upd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aliveImpl\n     (vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n       k)\n     (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)", "proof (cases \"k=l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = l \\<Longrightarrow>\n    aliveImpl\n     (vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n       k)\n     (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n 2. k \\<noteq> l \\<Longrightarrow>\n    aliveImpl\n     (vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n       k)\n     (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)", "case True"], ["proof (state)\nthis:\n  k = l\n\ngoal (2 subgoals):\n 1. k = l \\<Longrightarrow>\n    aliveImpl\n     (vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n       k)\n     (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n 2. k \\<noteq> l \\<Longrightarrow>\n    aliveImpl\n     (vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n       k)\n     (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)", "with alive_y"], ["proof (chain)\npicking this:\n  alive y s\n  k = l", "show ?thesis"], ["proof (prove)\nusing this:\n  alive y s\n  k = l\n\ngoal (1 subgoal):\n 1. aliveImpl\n     (vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n       k)\n     (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)", "by (simp add: alloc_eq alive_def aliveImpl_def split: Value.splits)"], ["proof (state)\nthis:\n  aliveImpl\n   (vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n     k)\n   (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n\ngoal (1 subgoal):\n 1. k \\<noteq> l \\<Longrightarrow>\n    aliveImpl\n     (vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n       k)\n     (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> l \\<Longrightarrow>\n    aliveImpl\n     (vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n       k)\n     (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)", "case False"], ["proof (state)\nthis:\n  k \\<noteq> l\n\ngoal (1 subgoal):\n 1. k \\<noteq> l \\<Longrightarrow>\n    aliveImpl\n     (vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n       k)\n     (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)", "from s"], ["proof (chain)\npicking this:\n  Rep_Store s \\<in> Store", "have \"\\<forall> l. aliveImpl (vals (Rep_Store s) l) (Rep_Store s)\""], ["proof (prove)\nusing this:\n  Rep_Store s \\<in> Store\n\ngoal (1 subgoal):\n 1. \\<forall>l. aliveImpl (vals (Rep_Store s) l) (Rep_Store s)", "by (simp add: Store_def)"], ["proof (state)\nthis:\n  \\<forall>l. aliveImpl (vals (Rep_Store s) l) (Rep_Store s)\n\ngoal (1 subgoal):\n 1. k \\<noteq> l \\<Longrightarrow>\n    aliveImpl\n     (vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n       k)\n     (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)", "with False"], ["proof (chain)\npicking this:\n  k \\<noteq> l\n  \\<forall>l. aliveImpl (vals (Rep_Store s) l) (Rep_Store s)", "show ?thesis"], ["proof (prove)\nusing this:\n  k \\<noteq> l\n  \\<forall>l. aliveImpl (vals (Rep_Store s) l) (Rep_Store s)\n\ngoal (1 subgoal):\n 1. aliveImpl\n     (vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n       k)\n     (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)", "by (simp add: aliveImpl_def split: Value.splits)"], ["proof (state)\nthis:\n  aliveImpl\n   (vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n     k)\n   (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aliveImpl\n   (vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n     k)\n   (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>la.\n     aliveImpl\n      (vals\n        (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n        la)\n      (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n\ngoal (1 subgoal):\n 1. Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>\n    \\<in> Store", "moreover"], ["proof (state)\nthis:\n  \\<forall>la.\n     aliveImpl\n      (vals\n        (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n        la)\n      (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n\ngoal (1 subgoal):\n 1. Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>\n    \\<in> Store", "have \"\\<forall> l. \\<not> aliveImpl (ref l) ?s_upd \\<longrightarrow> vals ?s_upd l = init (ltype l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>la.\n       \\<not> aliveImpl (ref la)\n               (Rep_Store s\n                \\<lparr>vals := (vals (Rep_Store s))\n                          (l := y)\\<rparr>) \\<longrightarrow>\n       vals\n        (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n        la =\n       init (ltype la)", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>la.\n       \\<not> aliveImpl (ref la)\n               (Rep_Store s\n                \\<lparr>vals := (vals (Rep_Store s))\n                          (l := y)\\<rparr>) \\<Longrightarrow>\n       vals\n        (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n        la =\n       init (ltype la)", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>la.\n       \\<not> aliveImpl (ref la)\n               (Rep_Store s\n                \\<lparr>vals := (vals (Rep_Store s))\n                          (l := y)\\<rparr>) \\<Longrightarrow>\n       vals\n        (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n        la =\n       init (ltype la)", "assume unalive: \"\\<not> aliveImpl (ref k) ?s_upd\""], ["proof (state)\nthis:\n  \\<not> aliveImpl (ref k)\n          (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>la.\n       \\<not> aliveImpl (ref la)\n               (Rep_Store s\n                \\<lparr>vals := (vals (Rep_Store s))\n                          (l := y)\\<rparr>) \\<Longrightarrow>\n       vals\n        (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n        la =\n       init (ltype la)", "show \"vals ?s_upd k = init (ltype k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n     k =\n    init (ltype k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n     k =\n    init (ltype k)", "from unalive alive_l"], ["proof (chain)\npicking this:\n  \\<not> aliveImpl (ref k)\n          (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n  alive (ref l) s", "have \"k\\<noteq>l\""], ["proof (prove)\nusing this:\n  \\<not> aliveImpl (ref k)\n          (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n  alive (ref l) s\n\ngoal (1 subgoal):\n 1. k \\<noteq> l", "by (auto simp add: alive_def aliveImpl_def split: Value.splits)"], ["proof (state)\nthis:\n  k \\<noteq> l\n\ngoal (1 subgoal):\n 1. vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n     k =\n    init (ltype k)", "hence \"vals ?s_upd k = vals (Rep_Store s) k\""], ["proof (prove)\nusing this:\n  k \\<noteq> l\n\ngoal (1 subgoal):\n 1. vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n     k =\n    vals (Rep_Store s) k", "by simp"], ["proof (state)\nthis:\n  vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>) k =\n  vals (Rep_Store s) k\n\ngoal (1 subgoal):\n 1. vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n     k =\n    init (ltype k)", "moreover"], ["proof (state)\nthis:\n  vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>) k =\n  vals (Rep_Store s) k\n\ngoal (1 subgoal):\n 1. vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n     k =\n    init (ltype k)", "from unalive"], ["proof (chain)\npicking this:\n  \\<not> aliveImpl (ref k)\n          (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)", "have \"\\<not> aliveImpl (ref k) (Rep_Store s)\""], ["proof (prove)\nusing this:\n  \\<not> aliveImpl (ref k)\n          (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<not> aliveImpl (ref k) (Rep_Store s)", "by (simp add: aliveImpl_def split: Value.splits)"], ["proof (state)\nthis:\n  \\<not> aliveImpl (ref k) (Rep_Store s)\n\ngoal (1 subgoal):\n 1. vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n     k =\n    init (ltype k)", "ultimately"], ["proof (chain)\npicking this:\n  vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>) k =\n  vals (Rep_Store s) k\n  \\<not> aliveImpl (ref k) (Rep_Store s)", "show ?thesis"], ["proof (prove)\nusing this:\n  vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>) k =\n  vals (Rep_Store s) k\n  \\<not> aliveImpl (ref k) (Rep_Store s)\n\ngoal (1 subgoal):\n 1. vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n     k =\n    init (ltype k)", "using s"], ["proof (prove)\nusing this:\n  vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>) k =\n  vals (Rep_Store s) k\n  \\<not> aliveImpl (ref k) (Rep_Store s)\n  Rep_Store s \\<in> Store\n\ngoal (1 subgoal):\n 1. vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n     k =\n    init (ltype k)", "by (simp add: Store_def)"], ["proof (state)\nthis:\n  vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>) k =\n  init (ltype k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>) k =\n  init (ltype k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>la.\n     \\<not> aliveImpl (ref la)\n             (Rep_Store s\n              \\<lparr>vals := (vals (Rep_Store s))\n                        (l := y)\\<rparr>) \\<longrightarrow>\n     vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n      la =\n     init (ltype la)\n\ngoal (1 subgoal):\n 1. Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>\n    \\<in> Store", "moreover"], ["proof (state)\nthis:\n  \\<forall>la.\n     \\<not> aliveImpl (ref la)\n             (Rep_Store s\n              \\<lparr>vals := (vals (Rep_Store s))\n                        (l := y)\\<rparr>) \\<longrightarrow>\n     vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n      la =\n     init (ltype la)\n\ngoal (1 subgoal):\n 1. Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>\n    \\<in> Store", "have \"\\<forall> l. typeof (vals ?s_upd l) \\<le> ltype l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>la.\n       \\<tau> vals\n               (Rep_Store s\n                \\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n               la\n       \\<le> ltype la", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>la.\n       \\<tau> vals\n               (Rep_Store s\n                \\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n               la\n       \\<le> ltype la", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>la.\n       \\<tau> vals\n               (Rep_Store s\n                \\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n               la\n       \\<le> ltype la", "show \"typeof (vals ?s_upd k) \\<le> ltype k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> vals\n            (Rep_Store s\n             \\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n            k\n    \\<le> ltype k", "proof (cases \"k=l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = l \\<Longrightarrow>\n    \\<tau> vals\n            (Rep_Store s\n             \\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n            k\n    \\<le> ltype k\n 2. k \\<noteq> l \\<Longrightarrow>\n    \\<tau> vals\n            (Rep_Store s\n             \\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n            k\n    \\<le> ltype k", "case True"], ["proof (state)\nthis:\n  k = l\n\ngoal (2 subgoals):\n 1. k = l \\<Longrightarrow>\n    \\<tau> vals\n            (Rep_Store s\n             \\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n            k\n    \\<le> ltype k\n 2. k \\<noteq> l \\<Longrightarrow>\n    \\<tau> vals\n            (Rep_Store s\n             \\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n            k\n    \\<le> ltype k", "with type_conform"], ["proof (chain)\npicking this:\n  \\<tau> y \\<le> ltype l\n  k = l", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<tau> y \\<le> ltype l\n  k = l\n\ngoal (1 subgoal):\n 1. \\<tau> vals\n            (Rep_Store s\n             \\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n            k\n    \\<le> ltype k", "by simp"], ["proof (state)\nthis:\n  \\<tau> vals\n          (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n          k\n  \\<le> ltype k\n\ngoal (1 subgoal):\n 1. k \\<noteq> l \\<Longrightarrow>\n    \\<tau> vals\n            (Rep_Store s\n             \\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n            k\n    \\<le> ltype k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> l \\<Longrightarrow>\n    \\<tau> vals\n            (Rep_Store s\n             \\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n            k\n    \\<le> ltype k", "case False"], ["proof (state)\nthis:\n  k \\<noteq> l\n\ngoal (1 subgoal):\n 1. k \\<noteq> l \\<Longrightarrow>\n    \\<tau> vals\n            (Rep_Store s\n             \\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n            k\n    \\<le> ltype k", "hence \"vals ?s_upd k = vals (Rep_Store s) k\""], ["proof (prove)\nusing this:\n  k \\<noteq> l\n\ngoal (1 subgoal):\n 1. vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n     k =\n    vals (Rep_Store s) k", "by simp"], ["proof (state)\nthis:\n  vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>) k =\n  vals (Rep_Store s) k\n\ngoal (1 subgoal):\n 1. k \\<noteq> l \\<Longrightarrow>\n    \\<tau> vals\n            (Rep_Store s\n             \\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n            k\n    \\<le> ltype k", "with s"], ["proof (chain)\npicking this:\n  Rep_Store s \\<in> Store\n  vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>) k =\n  vals (Rep_Store s) k", "show ?thesis"], ["proof (prove)\nusing this:\n  Rep_Store s \\<in> Store\n  vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>) k =\n  vals (Rep_Store s) k\n\ngoal (1 subgoal):\n 1. \\<tau> vals\n            (Rep_Store s\n             \\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n            k\n    \\<le> ltype k", "by (simp add: Store_def)"], ["proof (state)\nthis:\n  \\<tau> vals\n          (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n          k\n  \\<le> ltype k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<tau> vals\n          (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n          k\n  \\<le> ltype k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>la.\n     \\<tau> vals\n             (Rep_Store s\n              \\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n             la\n     \\<le> ltype la\n\ngoal (1 subgoal):\n 1. Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>\n    \\<in> Store", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>la.\n     aliveImpl\n      (vals\n        (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n        la)\n      (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n  \\<forall>la.\n     \\<not> aliveImpl (ref la)\n             (Rep_Store s\n              \\<lparr>vals := (vals (Rep_Store s))\n                        (l := y)\\<rparr>) \\<longrightarrow>\n     vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n      la =\n     init (ltype la)\n  \\<forall>la.\n     \\<tau> vals\n             (Rep_Store s\n              \\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n             la\n     \\<le> ltype la", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>la.\n     aliveImpl\n      (vals\n        (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n        la)\n      (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n  \\<forall>la.\n     \\<not> aliveImpl (ref la)\n             (Rep_Store s\n              \\<lparr>vals := (vals (Rep_Store s))\n                        (l := y)\\<rparr>) \\<longrightarrow>\n     vals (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n      la =\n     init (ltype la)\n  \\<forall>la.\n     \\<tau> vals\n             (Rep_Store s\n              \\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)\n             la\n     \\<le> ltype la\n\ngoal (1 subgoal):\n 1. Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>\n    \\<in> Store", "by (simp add: Store_def)"], ["proof (state)\nthis:\n  Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>\n  \\<in> Store\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Store6\\<close>"], ["", "lemma alive_update_invariant [simp]: \"alive x (s\\<langle>l:=y\\<rangle>) = alive x s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alive x (s\\<langle>l := y\\<rangle>) = alive x s", "proof (rule update_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. alive x s = alive x s\n 2. \\<lbrakk>alive (ref l) s; alive y s; \\<tau> y \\<le> ltype l\\<rbrakk>\n    \\<Longrightarrow> alive x\n                       (Abs_Store\n                         (Rep_Store s\n                          \\<lparr>vals := (vals (Rep_Store s))\n                                    (l := y)\\<rparr>)) =\n                      alive x s", "show \"alive x s = alive x s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alive x s = alive x s", ".."], ["proof (state)\nthis:\n  alive x s = alive x s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>alive (ref l) s; alive y s; \\<tau> y \\<le> ltype l\\<rbrakk>\n    \\<Longrightarrow> alive x\n                       (Abs_Store\n                         (Rep_Store s\n                          \\<lparr>vals := (vals (Rep_Store s))\n                                    (l := y)\\<rparr>)) =\n                      alive x s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>alive (ref l) s; alive y s; \\<tau> y \\<le> ltype l\\<rbrakk>\n    \\<Longrightarrow> alive x\n                       (Abs_Store\n                         (Rep_Store s\n                          \\<lparr>vals := (vals (Rep_Store s))\n                                    (l := y)\\<rparr>)) =\n                      alive x s", "assume \"alive (ref l) s\" \"alive y s\" \"typeof y \\<le> ltype l\""], ["proof (state)\nthis:\n  alive (ref l) s\n  alive y s\n  \\<tau> y \\<le> ltype l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>alive (ref l) s; alive y s; \\<tau> y \\<le> ltype l\\<rbrakk>\n    \\<Longrightarrow> alive x\n                       (Abs_Store\n                         (Rep_Store s\n                          \\<lparr>vals := (vals (Rep_Store s))\n                                    (l := y)\\<rparr>)) =\n                      alive x s", "hence \"Rep_Store \n          (Abs_Store (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>))\n         = Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>\""], ["proof (prove)\nusing this:\n  alive (ref l) s\n  alive y s\n  \\<tau> y \\<le> ltype l\n\ngoal (1 subgoal):\n 1. Rep_Store\n     (Abs_Store\n       (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)) =\n    Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>", "by (rule vals_update_in_Store [THEN Abs_Store_inverse])"], ["proof (state)\nthis:\n  Rep_Store\n   (Abs_Store\n     (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)) =\n  Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>alive (ref l) s; alive y s; \\<tau> y \\<le> ltype l\\<rbrakk>\n    \\<Longrightarrow> alive x\n                       (Abs_Store\n                         (Rep_Store s\n                          \\<lparr>vals := (vals (Rep_Store s))\n                                    (l := y)\\<rparr>)) =\n                      alive x s", "thus \"alive x\n         (Abs_Store (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)) =\n        alive x s\""], ["proof (prove)\nusing this:\n  Rep_Store\n   (Abs_Store\n     (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)) =\n  Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>\n\ngoal (1 subgoal):\n 1. alive x\n     (Abs_Store\n       (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)) =\n    alive x s", "by (simp add: alive_def aliveImpl_def split: Value.split)"], ["proof (state)\nthis:\n  alive x\n   (Abs_Store\n     (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := y)\\<rparr>)) =\n  alive x s\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Store1\\<close>"], ["", "lemma access_update_other [simp]: \n  assumes neq_l_m: \"l \\<noteq> m\" \n  shows \"s\\<langle>l:=x\\<rangle>@@m = s@@m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<langle>l := x\\<rangle>@@m = s@@m", "proof (rule update_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. s@@m = s@@m\n 2. \\<lbrakk>alive (ref l) s; alive x s; \\<tau> x \\<le> ltype l\\<rbrakk>\n    \\<Longrightarrow> Abs_Store\n                       (Rep_Store s\n                        \\<lparr>vals := (vals (Rep_Store s))\n                                  (l := x)\\<rparr>)@@m =\n                      s@@m", "show \"s@@m = s@@m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s@@m = s@@m", ".."], ["proof (state)\nthis:\n  s@@m = s@@m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>alive (ref l) s; alive x s; \\<tau> x \\<le> ltype l\\<rbrakk>\n    \\<Longrightarrow> Abs_Store\n                       (Rep_Store s\n                        \\<lparr>vals := (vals (Rep_Store s))\n                                  (l := x)\\<rparr>)@@m =\n                      s@@m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>alive (ref l) s; alive x s; \\<tau> x \\<le> ltype l\\<rbrakk>\n    \\<Longrightarrow> Abs_Store\n                       (Rep_Store s\n                        \\<lparr>vals := (vals (Rep_Store s))\n                                  (l := x)\\<rparr>)@@m =\n                      s@@m", "assume \"alive (ref l) s\" \"alive x s\" \"typeof x \\<le> ltype l\""], ["proof (state)\nthis:\n  alive (ref l) s\n  alive x s\n  \\<tau> x \\<le> ltype l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>alive (ref l) s; alive x s; \\<tau> x \\<le> ltype l\\<rbrakk>\n    \\<Longrightarrow> Abs_Store\n                       (Rep_Store s\n                        \\<lparr>vals := (vals (Rep_Store s))\n                                  (l := x)\\<rparr>)@@m =\n                      s@@m", "hence \"Rep_Store \n          (Abs_Store (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := x)\\<rparr>))\n         = Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := x)\\<rparr>\""], ["proof (prove)\nusing this:\n  alive (ref l) s\n  alive x s\n  \\<tau> x \\<le> ltype l\n\ngoal (1 subgoal):\n 1. Rep_Store\n     (Abs_Store\n       (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := x)\\<rparr>)) =\n    Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := x)\\<rparr>", "by (rule vals_update_in_Store [THEN Abs_Store_inverse])"], ["proof (state)\nthis:\n  Rep_Store\n   (Abs_Store\n     (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := x)\\<rparr>)) =\n  Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := x)\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>alive (ref l) s; alive x s; \\<tau> x \\<le> ltype l\\<rbrakk>\n    \\<Longrightarrow> Abs_Store\n                       (Rep_Store s\n                        \\<lparr>vals := (vals (Rep_Store s))\n                                  (l := x)\\<rparr>)@@m =\n                      s@@m", "with neq_l_m"], ["proof (chain)\npicking this:\n  l \\<noteq> m\n  Rep_Store\n   (Abs_Store\n     (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := x)\\<rparr>)) =\n  Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := x)\\<rparr>", "show \"Abs_Store (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := x)\\<rparr>)@@m = s@@m\""], ["proof (prove)\nusing this:\n  l \\<noteq> m\n  Rep_Store\n   (Abs_Store\n     (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := x)\\<rparr>)) =\n  Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := x)\\<rparr>\n\ngoal (1 subgoal):\n 1. Abs_Store\n     (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := x)\\<rparr>)@@m =\n    s@@m", "by (auto simp add: access_def)"], ["proof (state)\nthis:\n  Abs_Store\n   (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := x)\\<rparr>)@@m =\n  s@@m\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Store2\\<close>"], ["", "lemma update_access_same [simp]: \n  assumes alive_l: \"alive (ref l) s\" \n  assumes alive_x: \"alive x s\" \n  assumes widen_x_l: \"typeof x \\<le> ltype l\"\n  shows \"s\\<langle>l:=x\\<rangle>@@l = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<langle>l := x\\<rangle>@@l = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s\\<langle>l := x\\<rangle>@@l = x", "from alive_l alive_x widen_x_l"], ["proof (chain)\npicking this:\n  alive (ref l) s\n  alive x s\n  \\<tau> x \\<le> ltype l", "have \"Rep_Store \n          (Abs_Store (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := x)\\<rparr>))\n         = Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := x)\\<rparr>\""], ["proof (prove)\nusing this:\n  alive (ref l) s\n  alive x s\n  \\<tau> x \\<le> ltype l\n\ngoal (1 subgoal):\n 1. Rep_Store\n     (Abs_Store\n       (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := x)\\<rparr>)) =\n    Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := x)\\<rparr>", "by (rule vals_update_in_Store [THEN Abs_Store_inverse])"], ["proof (state)\nthis:\n  Rep_Store\n   (Abs_Store\n     (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := x)\\<rparr>)) =\n  Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := x)\\<rparr>\n\ngoal (1 subgoal):\n 1. s\\<langle>l := x\\<rangle>@@l = x", "hence \"Abs_Store (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := x)\\<rparr>)@@l = x\""], ["proof (prove)\nusing this:\n  Rep_Store\n   (Abs_Store\n     (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := x)\\<rparr>)) =\n  Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := x)\\<rparr>\n\ngoal (1 subgoal):\n 1. Abs_Store\n     (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := x)\\<rparr>)@@l =\n    x", "by (simp add: access_def)"], ["proof (state)\nthis:\n  Abs_Store\n   (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := x)\\<rparr>)@@l =\n  x\n\ngoal (1 subgoal):\n 1. s\\<langle>l := x\\<rangle>@@l = x", "with alive_l alive_x widen_x_l"], ["proof (chain)\npicking this:\n  alive (ref l) s\n  alive x s\n  \\<tau> x \\<le> ltype l\n  Abs_Store\n   (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := x)\\<rparr>)@@l =\n  x", "show ?thesis"], ["proof (prove)\nusing this:\n  alive (ref l) s\n  alive x s\n  \\<tau> x \\<le> ltype l\n  Abs_Store\n   (Rep_Store s\\<lparr>vals := (vals (Rep_Store s))(l := x)\\<rparr>)@@l =\n  x\n\ngoal (1 subgoal):\n 1. s\\<langle>l := x\\<rangle>@@l = x", "by (simp add: update_def)"], ["proof (state)\nthis:\n  s\\<langle>l := x\\<rangle>@@l = x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Store4\\<close>"], ["", "lemma update_unalive_val [simp,intro]: \"\\<not> alive x s \\<Longrightarrow> s\\<langle>l:=x\\<rangle> = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> alive x s \\<Longrightarrow> s\\<langle>l := x\\<rangle> = s", "by (simp add: update_def)"], ["", "lemma update_unalive_loc [simp,intro]: \"\\<not> alive (ref l) s \\<Longrightarrow> s\\<langle>l:=x\\<rangle> = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> alive (ref l) s \\<Longrightarrow> s\\<langle>l := x\\<rangle> = s", "by (simp add: update_def)"], ["", "lemma update_type_mismatch [simp,intro]: \"\\<not> typeof x \\<le> ltype l \\<Longrightarrow> s\\<langle>l:=x\\<rangle> = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<tau> x \\<le> ltype l \\<Longrightarrow>\n    s\\<langle>l := x\\<rangle> = s", "by (simp add: update_def)"], ["", "text \\<open>Store9\\<close>"], ["", "lemma alive_primitive [simp,intro]: \"isprimitive (typeof x) \\<Longrightarrow> alive x s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isprimitive \\<tau> x \\<Longrightarrow> alive x s", "by (cases x) (simp_all)"], ["", "text \\<open>Store10\\<close>"], ["", "lemma new_unalive_old_Store [simp]: \"\\<not> alive (new s t) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> alive (new s t) s", "by (cases t) (simp_all add: alive_def aliveImpl_def new_def)"], ["", "lemma alloc_new_instance_in_Store:\n\"(Rep_Store s\\<lparr>newOID := \\<lambda>D. if C = D\n                                   then Suc (newOID (Rep_Store s) C)\n                                   else newOID (Rep_Store s) D\\<rparr>) \\<in> Store\"\n(is \"?s_alloc \\<in> Store\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_Store s\n    \\<lparr>newOID :=\n              \\<lambda>D.\n                 if C = D then Suc (newOID (Rep_Store s) C)\n                 else newOID (Rep_Store s) D\\<rparr>\n    \\<in> Store", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Rep_Store s\n    \\<lparr>newOID :=\n              \\<lambda>D.\n                 if C = D then Suc (newOID (Rep_Store s) C)\n                 else newOID (Rep_Store s) D\\<rparr>\n    \\<in> Store", "have s: \"Rep_Store s \\<in> Store\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_Store s \\<in> Store", "by (rule Rep_Store)"], ["proof (state)\nthis:\n  Rep_Store s \\<in> Store\n\ngoal (1 subgoal):\n 1. Rep_Store s\n    \\<lparr>newOID :=\n              \\<lambda>D.\n                 if C = D then Suc (newOID (Rep_Store s) C)\n                 else newOID (Rep_Store s) D\\<rparr>\n    \\<in> Store", "hence \"\\<forall> l. aliveImpl (vals (Rep_Store s) l) (Rep_Store s)\""], ["proof (prove)\nusing this:\n  Rep_Store s \\<in> Store\n\ngoal (1 subgoal):\n 1. \\<forall>l. aliveImpl (vals (Rep_Store s) l) (Rep_Store s)", "by (simp add: Store_def)"], ["proof (state)\nthis:\n  \\<forall>l. aliveImpl (vals (Rep_Store s) l) (Rep_Store s)\n\ngoal (1 subgoal):\n 1. Rep_Store s\n    \\<lparr>newOID :=\n              \\<lambda>D.\n                 if C = D then Suc (newOID (Rep_Store s) C)\n                 else newOID (Rep_Store s) D\\<rparr>\n    \\<in> Store", "then"], ["proof (chain)\npicking this:\n  \\<forall>l. aliveImpl (vals (Rep_Store s) l) (Rep_Store s)", "have \"\\<forall> l. aliveImpl (vals ?s_alloc l) ?s_alloc\""], ["proof (prove)\nusing this:\n  \\<forall>l. aliveImpl (vals (Rep_Store s) l) (Rep_Store s)\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       aliveImpl\n        (vals\n          (Rep_Store s\n           \\<lparr>newOID :=\n                     \\<lambda>D.\n                        if C = D then Suc (newOID (Rep_Store s) C)\n                        else newOID (Rep_Store s) D\\<rparr>)\n          l)\n        (Rep_Store s\n         \\<lparr>newOID :=\n                   \\<lambda>D.\n                      if C = D then Suc (newOID (Rep_Store s) C)\n                      else newOID (Rep_Store s) D\\<rparr>)", "by (auto intro: less_SucI simp add: aliveImpl_def split: Value.splits)"], ["proof (state)\nthis:\n  \\<forall>l.\n     aliveImpl\n      (vals\n        (Rep_Store s\n         \\<lparr>newOID :=\n                   \\<lambda>D.\n                      if C = D then Suc (newOID (Rep_Store s) C)\n                      else newOID (Rep_Store s) D\\<rparr>)\n        l)\n      (Rep_Store s\n       \\<lparr>newOID :=\n                 \\<lambda>D.\n                    if C = D then Suc (newOID (Rep_Store s) C)\n                    else newOID (Rep_Store s) D\\<rparr>)\n\ngoal (1 subgoal):\n 1. Rep_Store s\n    \\<lparr>newOID :=\n              \\<lambda>D.\n                 if C = D then Suc (newOID (Rep_Store s) C)\n                 else newOID (Rep_Store s) D\\<rparr>\n    \\<in> Store", "moreover"], ["proof (state)\nthis:\n  \\<forall>l.\n     aliveImpl\n      (vals\n        (Rep_Store s\n         \\<lparr>newOID :=\n                   \\<lambda>D.\n                      if C = D then Suc (newOID (Rep_Store s) C)\n                      else newOID (Rep_Store s) D\\<rparr>)\n        l)\n      (Rep_Store s\n       \\<lparr>newOID :=\n                 \\<lambda>D.\n                    if C = D then Suc (newOID (Rep_Store s) C)\n                    else newOID (Rep_Store s) D\\<rparr>)\n\ngoal (1 subgoal):\n 1. Rep_Store s\n    \\<lparr>newOID :=\n              \\<lambda>D.\n                 if C = D then Suc (newOID (Rep_Store s) C)\n                 else newOID (Rep_Store s) D\\<rparr>\n    \\<in> Store", "have \"\\<forall> l. \\<not> aliveImpl (ref l) ?s_alloc \\<longrightarrow> vals ?s_alloc l = init (ltype l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l.\n       \\<not> aliveImpl (ref l)\n               (Rep_Store s\n                \\<lparr>newOID :=\n                          \\<lambda>D.\n                             if C = D then Suc (newOID (Rep_Store s) C)\n                             else newOID (Rep_Store s)\n                                   D\\<rparr>) \\<longrightarrow>\n       vals\n        (Rep_Store s\n         \\<lparr>newOID :=\n                   \\<lambda>D.\n                      if C = D then Suc (newOID (Rep_Store s) C)\n                      else newOID (Rep_Store s) D\\<rparr>)\n        l =\n       init (ltype l)", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<not> aliveImpl (ref l)\n               (Rep_Store s\n                \\<lparr>newOID :=\n                          \\<lambda>D.\n                             if C = D then Suc (newOID (Rep_Store s) C)\n                             else newOID (Rep_Store s)\n                                   D\\<rparr>) \\<Longrightarrow>\n       vals\n        (Rep_Store s\n         \\<lparr>newOID :=\n                   \\<lambda>D.\n                      if C = D then Suc (newOID (Rep_Store s) C)\n                      else newOID (Rep_Store s) D\\<rparr>)\n        l =\n       init (ltype l)", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<not> aliveImpl (ref l)\n               (Rep_Store s\n                \\<lparr>newOID :=\n                          \\<lambda>D.\n                             if C = D then Suc (newOID (Rep_Store s) C)\n                             else newOID (Rep_Store s)\n                                   D\\<rparr>) \\<Longrightarrow>\n       vals\n        (Rep_Store s\n         \\<lparr>newOID :=\n                   \\<lambda>D.\n                      if C = D then Suc (newOID (Rep_Store s) C)\n                      else newOID (Rep_Store s) D\\<rparr>)\n        l =\n       init (ltype l)", "assume \"\\<not> aliveImpl (ref l) ?s_alloc\""], ["proof (state)\nthis:\n  \\<not> aliveImpl (ref l)\n          (Rep_Store s\n           \\<lparr>newOID :=\n                     \\<lambda>D.\n                        if C = D then Suc (newOID (Rep_Store s) C)\n                        else newOID (Rep_Store s) D\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<not> aliveImpl (ref l)\n               (Rep_Store s\n                \\<lparr>newOID :=\n                          \\<lambda>D.\n                             if C = D then Suc (newOID (Rep_Store s) C)\n                             else newOID (Rep_Store s)\n                                   D\\<rparr>) \\<Longrightarrow>\n       vals\n        (Rep_Store s\n         \\<lparr>newOID :=\n                   \\<lambda>D.\n                      if C = D then Suc (newOID (Rep_Store s) C)\n                      else newOID (Rep_Store s) D\\<rparr>)\n        l =\n       init (ltype l)", "hence \"\\<not> aliveImpl (ref l) (Rep_Store s)\""], ["proof (prove)\nusing this:\n  \\<not> aliveImpl (ref l)\n          (Rep_Store s\n           \\<lparr>newOID :=\n                     \\<lambda>D.\n                        if C = D then Suc (newOID (Rep_Store s) C)\n                        else newOID (Rep_Store s) D\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<not> aliveImpl (ref l) (Rep_Store s)", "by (simp add: aliveImpl_def split: Value.splits if_split_asm)"], ["proof (state)\nthis:\n  \\<not> aliveImpl (ref l) (Rep_Store s)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<not> aliveImpl (ref l)\n               (Rep_Store s\n                \\<lparr>newOID :=\n                          \\<lambda>D.\n                             if C = D then Suc (newOID (Rep_Store s) C)\n                             else newOID (Rep_Store s)\n                                   D\\<rparr>) \\<Longrightarrow>\n       vals\n        (Rep_Store s\n         \\<lparr>newOID :=\n                   \\<lambda>D.\n                      if C = D then Suc (newOID (Rep_Store s) C)\n                      else newOID (Rep_Store s) D\\<rparr>)\n        l =\n       init (ltype l)", "with s"], ["proof (chain)\npicking this:\n  Rep_Store s \\<in> Store\n  \\<not> aliveImpl (ref l) (Rep_Store s)", "have \"vals (Rep_Store s) l = init (ltype l)\""], ["proof (prove)\nusing this:\n  Rep_Store s \\<in> Store\n  \\<not> aliveImpl (ref l) (Rep_Store s)\n\ngoal (1 subgoal):\n 1. vals (Rep_Store s) l = init (ltype l)", "by (simp add: Store_def)"], ["proof (state)\nthis:\n  vals (Rep_Store s) l = init (ltype l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<not> aliveImpl (ref l)\n               (Rep_Store s\n                \\<lparr>newOID :=\n                          \\<lambda>D.\n                             if C = D then Suc (newOID (Rep_Store s) C)\n                             else newOID (Rep_Store s)\n                                   D\\<rparr>) \\<Longrightarrow>\n       vals\n        (Rep_Store s\n         \\<lparr>newOID :=\n                   \\<lambda>D.\n                      if C = D then Suc (newOID (Rep_Store s) C)\n                      else newOID (Rep_Store s) D\\<rparr>)\n        l =\n       init (ltype l)", "thus \"vals ?s_alloc l = init (ltype l)\""], ["proof (prove)\nusing this:\n  vals (Rep_Store s) l = init (ltype l)\n\ngoal (1 subgoal):\n 1. vals\n     (Rep_Store s\n      \\<lparr>newOID :=\n                \\<lambda>D.\n                   if C = D then Suc (newOID (Rep_Store s) C)\n                   else newOID (Rep_Store s) D\\<rparr>)\n     l =\n    init (ltype l)", "by simp"], ["proof (state)\nthis:\n  vals\n   (Rep_Store s\n    \\<lparr>newOID :=\n              \\<lambda>D.\n                 if C = D then Suc (newOID (Rep_Store s) C)\n                 else newOID (Rep_Store s) D\\<rparr>)\n   l =\n  init (ltype l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>l.\n     \\<not> aliveImpl (ref l)\n             (Rep_Store s\n              \\<lparr>newOID :=\n                        \\<lambda>D.\n                           if C = D then Suc (newOID (Rep_Store s) C)\n                           else newOID (Rep_Store s)\n                                 D\\<rparr>) \\<longrightarrow>\n     vals\n      (Rep_Store s\n       \\<lparr>newOID :=\n                 \\<lambda>D.\n                    if C = D then Suc (newOID (Rep_Store s) C)\n                    else newOID (Rep_Store s) D\\<rparr>)\n      l =\n     init (ltype l)\n\ngoal (1 subgoal):\n 1. Rep_Store s\n    \\<lparr>newOID :=\n              \\<lambda>D.\n                 if C = D then Suc (newOID (Rep_Store s) C)\n                 else newOID (Rep_Store s) D\\<rparr>\n    \\<in> Store", "moreover"], ["proof (state)\nthis:\n  \\<forall>l.\n     \\<not> aliveImpl (ref l)\n             (Rep_Store s\n              \\<lparr>newOID :=\n                        \\<lambda>D.\n                           if C = D then Suc (newOID (Rep_Store s) C)\n                           else newOID (Rep_Store s)\n                                 D\\<rparr>) \\<longrightarrow>\n     vals\n      (Rep_Store s\n       \\<lparr>newOID :=\n                 \\<lambda>D.\n                    if C = D then Suc (newOID (Rep_Store s) C)\n                    else newOID (Rep_Store s) D\\<rparr>)\n      l =\n     init (ltype l)\n\ngoal (1 subgoal):\n 1. Rep_Store s\n    \\<lparr>newOID :=\n              \\<lambda>D.\n                 if C = D then Suc (newOID (Rep_Store s) C)\n                 else newOID (Rep_Store s) D\\<rparr>\n    \\<in> Store", "from s"], ["proof (chain)\npicking this:\n  Rep_Store s \\<in> Store", "have \"\\<forall> l. typeof (vals ?s_alloc l) \\<le> ltype l\""], ["proof (prove)\nusing this:\n  Rep_Store s \\<in> Store\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       \\<tau> vals\n               (Rep_Store s\n                \\<lparr>newOID :=\n                          \\<lambda>D.\n                             if C = D then Suc (newOID (Rep_Store s) C)\n                             else newOID (Rep_Store s) D\\<rparr>)\n               l\n       \\<le> ltype l", "by (simp add: Store_def)"], ["proof (state)\nthis:\n  \\<forall>l.\n     \\<tau> vals\n             (Rep_Store s\n              \\<lparr>newOID :=\n                        \\<lambda>D.\n                           if C = D then Suc (newOID (Rep_Store s) C)\n                           else newOID (Rep_Store s) D\\<rparr>)\n             l\n     \\<le> ltype l\n\ngoal (1 subgoal):\n 1. Rep_Store s\n    \\<lparr>newOID :=\n              \\<lambda>D.\n                 if C = D then Suc (newOID (Rep_Store s) C)\n                 else newOID (Rep_Store s) D\\<rparr>\n    \\<in> Store", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>l.\n     aliveImpl\n      (vals\n        (Rep_Store s\n         \\<lparr>newOID :=\n                   \\<lambda>D.\n                      if C = D then Suc (newOID (Rep_Store s) C)\n                      else newOID (Rep_Store s) D\\<rparr>)\n        l)\n      (Rep_Store s\n       \\<lparr>newOID :=\n                 \\<lambda>D.\n                    if C = D then Suc (newOID (Rep_Store s) C)\n                    else newOID (Rep_Store s) D\\<rparr>)\n  \\<forall>l.\n     \\<not> aliveImpl (ref l)\n             (Rep_Store s\n              \\<lparr>newOID :=\n                        \\<lambda>D.\n                           if C = D then Suc (newOID (Rep_Store s) C)\n                           else newOID (Rep_Store s)\n                                 D\\<rparr>) \\<longrightarrow>\n     vals\n      (Rep_Store s\n       \\<lparr>newOID :=\n                 \\<lambda>D.\n                    if C = D then Suc (newOID (Rep_Store s) C)\n                    else newOID (Rep_Store s) D\\<rparr>)\n      l =\n     init (ltype l)\n  \\<forall>l.\n     \\<tau> vals\n             (Rep_Store s\n              \\<lparr>newOID :=\n                        \\<lambda>D.\n                           if C = D then Suc (newOID (Rep_Store s) C)\n                           else newOID (Rep_Store s) D\\<rparr>)\n             l\n     \\<le> ltype l", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>l.\n     aliveImpl\n      (vals\n        (Rep_Store s\n         \\<lparr>newOID :=\n                   \\<lambda>D.\n                      if C = D then Suc (newOID (Rep_Store s) C)\n                      else newOID (Rep_Store s) D\\<rparr>)\n        l)\n      (Rep_Store s\n       \\<lparr>newOID :=\n                 \\<lambda>D.\n                    if C = D then Suc (newOID (Rep_Store s) C)\n                    else newOID (Rep_Store s) D\\<rparr>)\n  \\<forall>l.\n     \\<not> aliveImpl (ref l)\n             (Rep_Store s\n              \\<lparr>newOID :=\n                        \\<lambda>D.\n                           if C = D then Suc (newOID (Rep_Store s) C)\n                           else newOID (Rep_Store s)\n                                 D\\<rparr>) \\<longrightarrow>\n     vals\n      (Rep_Store s\n       \\<lparr>newOID :=\n                 \\<lambda>D.\n                    if C = D then Suc (newOID (Rep_Store s) C)\n                    else newOID (Rep_Store s) D\\<rparr>)\n      l =\n     init (ltype l)\n  \\<forall>l.\n     \\<tau> vals\n             (Rep_Store s\n              \\<lparr>newOID :=\n                        \\<lambda>D.\n                           if C = D then Suc (newOID (Rep_Store s) C)\n                           else newOID (Rep_Store s) D\\<rparr>)\n             l\n     \\<le> ltype l\n\ngoal (1 subgoal):\n 1. Rep_Store s\n    \\<lparr>newOID :=\n              \\<lambda>D.\n                 if C = D then Suc (newOID (Rep_Store s) C)\n                 else newOID (Rep_Store s) D\\<rparr>\n    \\<in> Store", "by (simp add: Store_def)"], ["proof (state)\nthis:\n  Rep_Store s\n  \\<lparr>newOID :=\n            \\<lambda>D.\n               if C = D then Suc (newOID (Rep_Store s) C)\n               else newOID (Rep_Store s) D\\<rparr>\n  \\<in> Store\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alloc_new_array_in_Store:\n\"(Rep_Store s \\<lparr>newAID :=\n                  \\<lambda>S. if T = S\n                      then Suc (newAID (Rep_Store s) T)\n                      else newAID (Rep_Store s) S,\n               vals := (vals (Rep_Store s))\n                         (arrLenLoc T\n                           (newAID (Rep_Store s) T) :=\n                           intgV (int n))\\<rparr>) \\<in> Store\"\n(is \"?s_alloc \\<in> Store\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_Store s\n    \\<lparr>newAID :=\n              \\<lambda>S.\n                 if T = S then Suc (newAID (Rep_Store s) T)\n                 else newAID (Rep_Store s) S,\n       vals := (vals (Rep_Store s))\n         (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>\n    \\<in> Store", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Rep_Store s\n    \\<lparr>newAID :=\n              \\<lambda>S.\n                 if T = S then Suc (newAID (Rep_Store s) T)\n                 else newAID (Rep_Store s) S,\n       vals := (vals (Rep_Store s))\n         (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>\n    \\<in> Store", "have s: \"Rep_Store s \\<in> Store\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_Store s \\<in> Store", "by (rule Rep_Store)"], ["proof (state)\nthis:\n  Rep_Store s \\<in> Store\n\ngoal (1 subgoal):\n 1. Rep_Store s\n    \\<lparr>newAID :=\n              \\<lambda>S.\n                 if T = S then Suc (newAID (Rep_Store s) T)\n                 else newAID (Rep_Store s) S,\n       vals := (vals (Rep_Store s))\n         (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>\n    \\<in> Store", "have \"\\<forall> l. aliveImpl (vals ?s_alloc l) ?s_alloc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l.\n       aliveImpl\n        (vals\n          (Rep_Store s\n           \\<lparr>newAID :=\n                     \\<lambda>S.\n                        if T = S then Suc (newAID (Rep_Store s) T)\n                        else newAID (Rep_Store s) S,\n              vals := (vals (Rep_Store s))\n                (arrLenLoc T (newAID (Rep_Store s) T) :=\n                   intgV (int n))\\<rparr>)\n          l)\n        (Rep_Store s\n         \\<lparr>newAID :=\n                   \\<lambda>S.\n                      if T = S then Suc (newAID (Rep_Store s) T)\n                      else newAID (Rep_Store s) S,\n            vals := (vals (Rep_Store s))\n              (arrLenLoc T (newAID (Rep_Store s) T) :=\n                 intgV (int n))\\<rparr>)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       aliveImpl\n        (vals\n          (Rep_Store s\n           \\<lparr>newAID :=\n                     \\<lambda>S.\n                        if T = S then Suc (newAID (Rep_Store s) T)\n                        else newAID (Rep_Store s) S,\n              vals := (vals (Rep_Store s))\n                (arrLenLoc T (newAID (Rep_Store s) T) :=\n                   intgV (int n))\\<rparr>)\n          l)\n        (Rep_Store s\n         \\<lparr>newAID :=\n                   \\<lambda>S.\n                      if T = S then Suc (newAID (Rep_Store s) T)\n                      else newAID (Rep_Store s) S,\n            vals := (vals (Rep_Store s))\n              (arrLenLoc T (newAID (Rep_Store s) T) :=\n                 intgV (int n))\\<rparr>)", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       aliveImpl\n        (vals\n          (Rep_Store s\n           \\<lparr>newAID :=\n                     \\<lambda>S.\n                        if T = S then Suc (newAID (Rep_Store s) T)\n                        else newAID (Rep_Store s) S,\n              vals := (vals (Rep_Store s))\n                (arrLenLoc T (newAID (Rep_Store s) T) :=\n                   intgV (int n))\\<rparr>)\n          l)\n        (Rep_Store s\n         \\<lparr>newAID :=\n                   \\<lambda>S.\n                      if T = S then Suc (newAID (Rep_Store s) T)\n                      else newAID (Rep_Store s) S,\n            vals := (vals (Rep_Store s))\n              (arrLenLoc T (newAID (Rep_Store s) T) :=\n                 intgV (int n))\\<rparr>)", "show \"aliveImpl (vals ?s_alloc l) ?s_alloc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aliveImpl\n     (vals\n       (Rep_Store s\n        \\<lparr>newAID :=\n                  \\<lambda>S.\n                     if T = S then Suc (newAID (Rep_Store s) T)\n                     else newAID (Rep_Store s) S,\n           vals := (vals (Rep_Store s))\n             (arrLenLoc T (newAID (Rep_Store s) T) :=\n                intgV (int n))\\<rparr>)\n       l)\n     (Rep_Store s\n      \\<lparr>newAID :=\n                \\<lambda>S.\n                   if T = S then Suc (newAID (Rep_Store s) T)\n                   else newAID (Rep_Store s) S,\n         vals := (vals (Rep_Store s))\n           (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)", "proof (cases \"l = arrLenLoc T (newAID (Rep_Store s) T)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l = arrLenLoc T (newAID (Rep_Store s) T) \\<Longrightarrow>\n    aliveImpl\n     (vals\n       (Rep_Store s\n        \\<lparr>newAID :=\n                  \\<lambda>S.\n                     if T = S then Suc (newAID (Rep_Store s) T)\n                     else newAID (Rep_Store s) S,\n           vals := (vals (Rep_Store s))\n             (arrLenLoc T (newAID (Rep_Store s) T) :=\n                intgV (int n))\\<rparr>)\n       l)\n     (Rep_Store s\n      \\<lparr>newAID :=\n                \\<lambda>S.\n                   if T = S then Suc (newAID (Rep_Store s) T)\n                   else newAID (Rep_Store s) S,\n         vals := (vals (Rep_Store s))\n           (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n 2. l \\<noteq> arrLenLoc T (newAID (Rep_Store s) T) \\<Longrightarrow>\n    aliveImpl\n     (vals\n       (Rep_Store s\n        \\<lparr>newAID :=\n                  \\<lambda>S.\n                     if T = S then Suc (newAID (Rep_Store s) T)\n                     else newAID (Rep_Store s) S,\n           vals := (vals (Rep_Store s))\n             (arrLenLoc T (newAID (Rep_Store s) T) :=\n                intgV (int n))\\<rparr>)\n       l)\n     (Rep_Store s\n      \\<lparr>newAID :=\n                \\<lambda>S.\n                   if T = S then Suc (newAID (Rep_Store s) T)\n                   else newAID (Rep_Store s) S,\n         vals := (vals (Rep_Store s))\n           (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)", "case True"], ["proof (state)\nthis:\n  l = arrLenLoc T (newAID (Rep_Store s) T)\n\ngoal (2 subgoals):\n 1. l = arrLenLoc T (newAID (Rep_Store s) T) \\<Longrightarrow>\n    aliveImpl\n     (vals\n       (Rep_Store s\n        \\<lparr>newAID :=\n                  \\<lambda>S.\n                     if T = S then Suc (newAID (Rep_Store s) T)\n                     else newAID (Rep_Store s) S,\n           vals := (vals (Rep_Store s))\n             (arrLenLoc T (newAID (Rep_Store s) T) :=\n                intgV (int n))\\<rparr>)\n       l)\n     (Rep_Store s\n      \\<lparr>newAID :=\n                \\<lambda>S.\n                   if T = S then Suc (newAID (Rep_Store s) T)\n                   else newAID (Rep_Store s) S,\n         vals := (vals (Rep_Store s))\n           (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n 2. l \\<noteq> arrLenLoc T (newAID (Rep_Store s) T) \\<Longrightarrow>\n    aliveImpl\n     (vals\n       (Rep_Store s\n        \\<lparr>newAID :=\n                  \\<lambda>S.\n                     if T = S then Suc (newAID (Rep_Store s) T)\n                     else newAID (Rep_Store s) S,\n           vals := (vals (Rep_Store s))\n             (arrLenLoc T (newAID (Rep_Store s) T) :=\n                intgV (int n))\\<rparr>)\n       l)\n     (Rep_Store s\n      \\<lparr>newAID :=\n                \\<lambda>S.\n                   if T = S then Suc (newAID (Rep_Store s) T)\n                   else newAID (Rep_Store s) S,\n         vals := (vals (Rep_Store s))\n           (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  l = arrLenLoc T (newAID (Rep_Store s) T)\n\ngoal (1 subgoal):\n 1. aliveImpl\n     (vals\n       (Rep_Store s\n        \\<lparr>newAID :=\n                  \\<lambda>S.\n                     if T = S then Suc (newAID (Rep_Store s) T)\n                     else newAID (Rep_Store s) S,\n           vals := (vals (Rep_Store s))\n             (arrLenLoc T (newAID (Rep_Store s) T) :=\n                intgV (int n))\\<rparr>)\n       l)\n     (Rep_Store s\n      \\<lparr>newAID :=\n                \\<lambda>S.\n                   if T = S then Suc (newAID (Rep_Store s) T)\n                   else newAID (Rep_Store s) S,\n         vals := (vals (Rep_Store s))\n           (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)", "by (simp add: aliveImpl_def split: Value.splits)"], ["proof (state)\nthis:\n  aliveImpl\n   (vals\n     (Rep_Store s\n      \\<lparr>newAID :=\n                \\<lambda>S.\n                   if T = S then Suc (newAID (Rep_Store s) T)\n                   else newAID (Rep_Store s) S,\n         vals := (vals (Rep_Store s))\n           (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n     l)\n   (Rep_Store s\n    \\<lparr>newAID :=\n              \\<lambda>S.\n                 if T = S then Suc (newAID (Rep_Store s) T)\n                 else newAID (Rep_Store s) S,\n       vals := (vals (Rep_Store s))\n         (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n\ngoal (1 subgoal):\n 1. l \\<noteq> arrLenLoc T (newAID (Rep_Store s) T) \\<Longrightarrow>\n    aliveImpl\n     (vals\n       (Rep_Store s\n        \\<lparr>newAID :=\n                  \\<lambda>S.\n                     if T = S then Suc (newAID (Rep_Store s) T)\n                     else newAID (Rep_Store s) S,\n           vals := (vals (Rep_Store s))\n             (arrLenLoc T (newAID (Rep_Store s) T) :=\n                intgV (int n))\\<rparr>)\n       l)\n     (Rep_Store s\n      \\<lparr>newAID :=\n                \\<lambda>S.\n                   if T = S then Suc (newAID (Rep_Store s) T)\n                   else newAID (Rep_Store s) S,\n         vals := (vals (Rep_Store s))\n           (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<noteq> arrLenLoc T (newAID (Rep_Store s) T) \\<Longrightarrow>\n    aliveImpl\n     (vals\n       (Rep_Store s\n        \\<lparr>newAID :=\n                  \\<lambda>S.\n                     if T = S then Suc (newAID (Rep_Store s) T)\n                     else newAID (Rep_Store s) S,\n           vals := (vals (Rep_Store s))\n             (arrLenLoc T (newAID (Rep_Store s) T) :=\n                intgV (int n))\\<rparr>)\n       l)\n     (Rep_Store s\n      \\<lparr>newAID :=\n                \\<lambda>S.\n                   if T = S then Suc (newAID (Rep_Store s) T)\n                   else newAID (Rep_Store s) S,\n         vals := (vals (Rep_Store s))\n           (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)", "case False"], ["proof (state)\nthis:\n  l \\<noteq> arrLenLoc T (newAID (Rep_Store s) T)\n\ngoal (1 subgoal):\n 1. l \\<noteq> arrLenLoc T (newAID (Rep_Store s) T) \\<Longrightarrow>\n    aliveImpl\n     (vals\n       (Rep_Store s\n        \\<lparr>newAID :=\n                  \\<lambda>S.\n                     if T = S then Suc (newAID (Rep_Store s) T)\n                     else newAID (Rep_Store s) S,\n           vals := (vals (Rep_Store s))\n             (arrLenLoc T (newAID (Rep_Store s) T) :=\n                intgV (int n))\\<rparr>)\n       l)\n     (Rep_Store s\n      \\<lparr>newAID :=\n                \\<lambda>S.\n                   if T = S then Suc (newAID (Rep_Store s) T)\n                   else newAID (Rep_Store s) S,\n         vals := (vals (Rep_Store s))\n           (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)", "from s"], ["proof (chain)\npicking this:\n  Rep_Store s \\<in> Store", "have \"\\<forall> l. aliveImpl (vals (Rep_Store s) l) (Rep_Store s)\""], ["proof (prove)\nusing this:\n  Rep_Store s \\<in> Store\n\ngoal (1 subgoal):\n 1. \\<forall>l. aliveImpl (vals (Rep_Store s) l) (Rep_Store s)", "by (simp add: Store_def)"], ["proof (state)\nthis:\n  \\<forall>l. aliveImpl (vals (Rep_Store s) l) (Rep_Store s)\n\ngoal (1 subgoal):\n 1. l \\<noteq> arrLenLoc T (newAID (Rep_Store s) T) \\<Longrightarrow>\n    aliveImpl\n     (vals\n       (Rep_Store s\n        \\<lparr>newAID :=\n                  \\<lambda>S.\n                     if T = S then Suc (newAID (Rep_Store s) T)\n                     else newAID (Rep_Store s) S,\n           vals := (vals (Rep_Store s))\n             (arrLenLoc T (newAID (Rep_Store s) T) :=\n                intgV (int n))\\<rparr>)\n       l)\n     (Rep_Store s\n      \\<lparr>newAID :=\n                \\<lambda>S.\n                   if T = S then Suc (newAID (Rep_Store s) T)\n                   else newAID (Rep_Store s) S,\n         vals := (vals (Rep_Store s))\n           (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)", "with False"], ["proof (chain)\npicking this:\n  l \\<noteq> arrLenLoc T (newAID (Rep_Store s) T)\n  \\<forall>l. aliveImpl (vals (Rep_Store s) l) (Rep_Store s)", "show ?thesis"], ["proof (prove)\nusing this:\n  l \\<noteq> arrLenLoc T (newAID (Rep_Store s) T)\n  \\<forall>l. aliveImpl (vals (Rep_Store s) l) (Rep_Store s)\n\ngoal (1 subgoal):\n 1. aliveImpl\n     (vals\n       (Rep_Store s\n        \\<lparr>newAID :=\n                  \\<lambda>S.\n                     if T = S then Suc (newAID (Rep_Store s) T)\n                     else newAID (Rep_Store s) S,\n           vals := (vals (Rep_Store s))\n             (arrLenLoc T (newAID (Rep_Store s) T) :=\n                intgV (int n))\\<rparr>)\n       l)\n     (Rep_Store s\n      \\<lparr>newAID :=\n                \\<lambda>S.\n                   if T = S then Suc (newAID (Rep_Store s) T)\n                   else newAID (Rep_Store s) S,\n         vals := (vals (Rep_Store s))\n           (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)", "by (auto intro: less_SucI simp add: aliveImpl_def split: Value.splits)"], ["proof (state)\nthis:\n  aliveImpl\n   (vals\n     (Rep_Store s\n      \\<lparr>newAID :=\n                \\<lambda>S.\n                   if T = S then Suc (newAID (Rep_Store s) T)\n                   else newAID (Rep_Store s) S,\n         vals := (vals (Rep_Store s))\n           (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n     l)\n   (Rep_Store s\n    \\<lparr>newAID :=\n              \\<lambda>S.\n                 if T = S then Suc (newAID (Rep_Store s) T)\n                 else newAID (Rep_Store s) S,\n       vals := (vals (Rep_Store s))\n         (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aliveImpl\n   (vals\n     (Rep_Store s\n      \\<lparr>newAID :=\n                \\<lambda>S.\n                   if T = S then Suc (newAID (Rep_Store s) T)\n                   else newAID (Rep_Store s) S,\n         vals := (vals (Rep_Store s))\n           (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n     l)\n   (Rep_Store s\n    \\<lparr>newAID :=\n              \\<lambda>S.\n                 if T = S then Suc (newAID (Rep_Store s) T)\n                 else newAID (Rep_Store s) S,\n       vals := (vals (Rep_Store s))\n         (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>l.\n     aliveImpl\n      (vals\n        (Rep_Store s\n         \\<lparr>newAID :=\n                   \\<lambda>S.\n                      if T = S then Suc (newAID (Rep_Store s) T)\n                      else newAID (Rep_Store s) S,\n            vals := (vals (Rep_Store s))\n              (arrLenLoc T (newAID (Rep_Store s) T) :=\n                 intgV (int n))\\<rparr>)\n        l)\n      (Rep_Store s\n       \\<lparr>newAID :=\n                 \\<lambda>S.\n                    if T = S then Suc (newAID (Rep_Store s) T)\n                    else newAID (Rep_Store s) S,\n          vals := (vals (Rep_Store s))\n            (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n\ngoal (1 subgoal):\n 1. Rep_Store s\n    \\<lparr>newAID :=\n              \\<lambda>S.\n                 if T = S then Suc (newAID (Rep_Store s) T)\n                 else newAID (Rep_Store s) S,\n       vals := (vals (Rep_Store s))\n         (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>\n    \\<in> Store", "moreover"], ["proof (state)\nthis:\n  \\<forall>l.\n     aliveImpl\n      (vals\n        (Rep_Store s\n         \\<lparr>newAID :=\n                   \\<lambda>S.\n                      if T = S then Suc (newAID (Rep_Store s) T)\n                      else newAID (Rep_Store s) S,\n            vals := (vals (Rep_Store s))\n              (arrLenLoc T (newAID (Rep_Store s) T) :=\n                 intgV (int n))\\<rparr>)\n        l)\n      (Rep_Store s\n       \\<lparr>newAID :=\n                 \\<lambda>S.\n                    if T = S then Suc (newAID (Rep_Store s) T)\n                    else newAID (Rep_Store s) S,\n          vals := (vals (Rep_Store s))\n            (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n\ngoal (1 subgoal):\n 1. Rep_Store s\n    \\<lparr>newAID :=\n              \\<lambda>S.\n                 if T = S then Suc (newAID (Rep_Store s) T)\n                 else newAID (Rep_Store s) S,\n       vals := (vals (Rep_Store s))\n         (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>\n    \\<in> Store", "have \"\\<forall> l. \\<not> aliveImpl (ref l) ?s_alloc \\<longrightarrow> vals ?s_alloc l = init (ltype l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l.\n       \\<not> aliveImpl (ref l)\n               (Rep_Store s\n                \\<lparr>newAID :=\n                          \\<lambda>S.\n                             if T = S then Suc (newAID (Rep_Store s) T)\n                             else newAID (Rep_Store s) S,\n                   vals := (vals (Rep_Store s))\n                     (arrLenLoc T (newAID (Rep_Store s) T) :=\n                        intgV (int n))\\<rparr>) \\<longrightarrow>\n       vals\n        (Rep_Store s\n         \\<lparr>newAID :=\n                   \\<lambda>S.\n                      if T = S then Suc (newAID (Rep_Store s) T)\n                      else newAID (Rep_Store s) S,\n            vals := (vals (Rep_Store s))\n              (arrLenLoc T (newAID (Rep_Store s) T) :=\n                 intgV (int n))\\<rparr>)\n        l =\n       init (ltype l)", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<not> aliveImpl (ref l)\n               (Rep_Store s\n                \\<lparr>newAID :=\n                          \\<lambda>S.\n                             if T = S then Suc (newAID (Rep_Store s) T)\n                             else newAID (Rep_Store s) S,\n                   vals := (vals (Rep_Store s))\n                     (arrLenLoc T (newAID (Rep_Store s) T) :=\n                        intgV (int n))\\<rparr>) \\<Longrightarrow>\n       vals\n        (Rep_Store s\n         \\<lparr>newAID :=\n                   \\<lambda>S.\n                      if T = S then Suc (newAID (Rep_Store s) T)\n                      else newAID (Rep_Store s) S,\n            vals := (vals (Rep_Store s))\n              (arrLenLoc T (newAID (Rep_Store s) T) :=\n                 intgV (int n))\\<rparr>)\n        l =\n       init (ltype l)", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<not> aliveImpl (ref l)\n               (Rep_Store s\n                \\<lparr>newAID :=\n                          \\<lambda>S.\n                             if T = S then Suc (newAID (Rep_Store s) T)\n                             else newAID (Rep_Store s) S,\n                   vals := (vals (Rep_Store s))\n                     (arrLenLoc T (newAID (Rep_Store s) T) :=\n                        intgV (int n))\\<rparr>) \\<Longrightarrow>\n       vals\n        (Rep_Store s\n         \\<lparr>newAID :=\n                   \\<lambda>S.\n                      if T = S then Suc (newAID (Rep_Store s) T)\n                      else newAID (Rep_Store s) S,\n            vals := (vals (Rep_Store s))\n              (arrLenLoc T (newAID (Rep_Store s) T) :=\n                 intgV (int n))\\<rparr>)\n        l =\n       init (ltype l)", "assume unalive: \"\\<not> aliveImpl (ref l) ?s_alloc\""], ["proof (state)\nthis:\n  \\<not> aliveImpl (ref l)\n          (Rep_Store s\n           \\<lparr>newAID :=\n                     \\<lambda>S.\n                        if T = S then Suc (newAID (Rep_Store s) T)\n                        else newAID (Rep_Store s) S,\n              vals := (vals (Rep_Store s))\n                (arrLenLoc T (newAID (Rep_Store s) T) :=\n                   intgV (int n))\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<not> aliveImpl (ref l)\n               (Rep_Store s\n                \\<lparr>newAID :=\n                          \\<lambda>S.\n                             if T = S then Suc (newAID (Rep_Store s) T)\n                             else newAID (Rep_Store s) S,\n                   vals := (vals (Rep_Store s))\n                     (arrLenLoc T (newAID (Rep_Store s) T) :=\n                        intgV (int n))\\<rparr>) \\<Longrightarrow>\n       vals\n        (Rep_Store s\n         \\<lparr>newAID :=\n                   \\<lambda>S.\n                      if T = S then Suc (newAID (Rep_Store s) T)\n                      else newAID (Rep_Store s) S,\n            vals := (vals (Rep_Store s))\n              (arrLenLoc T (newAID (Rep_Store s) T) :=\n                 intgV (int n))\\<rparr>)\n        l =\n       init (ltype l)", "show \"vals ?s_alloc l = init (ltype l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vals\n     (Rep_Store s\n      \\<lparr>newAID :=\n                \\<lambda>S.\n                   if T = S then Suc (newAID (Rep_Store s) T)\n                   else newAID (Rep_Store s) S,\n         vals := (vals (Rep_Store s))\n           (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n     l =\n    init (ltype l)", "proof (cases \"l = arrLenLoc T (newAID (Rep_Store s) T)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l = arrLenLoc T (newAID (Rep_Store s) T) \\<Longrightarrow>\n    vals\n     (Rep_Store s\n      \\<lparr>newAID :=\n                \\<lambda>S.\n                   if T = S then Suc (newAID (Rep_Store s) T)\n                   else newAID (Rep_Store s) S,\n         vals := (vals (Rep_Store s))\n           (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n     l =\n    init (ltype l)\n 2. l \\<noteq> arrLenLoc T (newAID (Rep_Store s) T) \\<Longrightarrow>\n    vals\n     (Rep_Store s\n      \\<lparr>newAID :=\n                \\<lambda>S.\n                   if T = S then Suc (newAID (Rep_Store s) T)\n                   else newAID (Rep_Store s) S,\n         vals := (vals (Rep_Store s))\n           (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n     l =\n    init (ltype l)", "case True"], ["proof (state)\nthis:\n  l = arrLenLoc T (newAID (Rep_Store s) T)\n\ngoal (2 subgoals):\n 1. l = arrLenLoc T (newAID (Rep_Store s) T) \\<Longrightarrow>\n    vals\n     (Rep_Store s\n      \\<lparr>newAID :=\n                \\<lambda>S.\n                   if T = S then Suc (newAID (Rep_Store s) T)\n                   else newAID (Rep_Store s) S,\n         vals := (vals (Rep_Store s))\n           (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n     l =\n    init (ltype l)\n 2. l \\<noteq> arrLenLoc T (newAID (Rep_Store s) T) \\<Longrightarrow>\n    vals\n     (Rep_Store s\n      \\<lparr>newAID :=\n                \\<lambda>S.\n                   if T = S then Suc (newAID (Rep_Store s) T)\n                   else newAID (Rep_Store s) S,\n         vals := (vals (Rep_Store s))\n           (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n     l =\n    init (ltype l)", "with unalive"], ["proof (chain)\npicking this:\n  \\<not> aliveImpl (ref l)\n          (Rep_Store s\n           \\<lparr>newAID :=\n                     \\<lambda>S.\n                        if T = S then Suc (newAID (Rep_Store s) T)\n                        else newAID (Rep_Store s) S,\n              vals := (vals (Rep_Store s))\n                (arrLenLoc T (newAID (Rep_Store s) T) :=\n                   intgV (int n))\\<rparr>)\n  l = arrLenLoc T (newAID (Rep_Store s) T)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> aliveImpl (ref l)\n          (Rep_Store s\n           \\<lparr>newAID :=\n                     \\<lambda>S.\n                        if T = S then Suc (newAID (Rep_Store s) T)\n                        else newAID (Rep_Store s) S,\n              vals := (vals (Rep_Store s))\n                (arrLenLoc T (newAID (Rep_Store s) T) :=\n                   intgV (int n))\\<rparr>)\n  l = arrLenLoc T (newAID (Rep_Store s) T)\n\ngoal (1 subgoal):\n 1. vals\n     (Rep_Store s\n      \\<lparr>newAID :=\n                \\<lambda>S.\n                   if T = S then Suc (newAID (Rep_Store s) T)\n                   else newAID (Rep_Store s) S,\n         vals := (vals (Rep_Store s))\n           (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n     l =\n    init (ltype l)", "by (simp add: aliveImpl_def)"], ["proof (state)\nthis:\n  vals\n   (Rep_Store s\n    \\<lparr>newAID :=\n              \\<lambda>S.\n                 if T = S then Suc (newAID (Rep_Store s) T)\n                 else newAID (Rep_Store s) S,\n       vals := (vals (Rep_Store s))\n         (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n   l =\n  init (ltype l)\n\ngoal (1 subgoal):\n 1. l \\<noteq> arrLenLoc T (newAID (Rep_Store s) T) \\<Longrightarrow>\n    vals\n     (Rep_Store s\n      \\<lparr>newAID :=\n                \\<lambda>S.\n                   if T = S then Suc (newAID (Rep_Store s) T)\n                   else newAID (Rep_Store s) S,\n         vals := (vals (Rep_Store s))\n           (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n     l =\n    init (ltype l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<noteq> arrLenLoc T (newAID (Rep_Store s) T) \\<Longrightarrow>\n    vals\n     (Rep_Store s\n      \\<lparr>newAID :=\n                \\<lambda>S.\n                   if T = S then Suc (newAID (Rep_Store s) T)\n                   else newAID (Rep_Store s) S,\n         vals := (vals (Rep_Store s))\n           (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n     l =\n    init (ltype l)", "case False"], ["proof (state)\nthis:\n  l \\<noteq> arrLenLoc T (newAID (Rep_Store s) T)\n\ngoal (1 subgoal):\n 1. l \\<noteq> arrLenLoc T (newAID (Rep_Store s) T) \\<Longrightarrow>\n    vals\n     (Rep_Store s\n      \\<lparr>newAID :=\n                \\<lambda>S.\n                   if T = S then Suc (newAID (Rep_Store s) T)\n                   else newAID (Rep_Store s) S,\n         vals := (vals (Rep_Store s))\n           (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n     l =\n    init (ltype l)", "from unalive"], ["proof (chain)\npicking this:\n  \\<not> aliveImpl (ref l)\n          (Rep_Store s\n           \\<lparr>newAID :=\n                     \\<lambda>S.\n                        if T = S then Suc (newAID (Rep_Store s) T)\n                        else newAID (Rep_Store s) S,\n              vals := (vals (Rep_Store s))\n                (arrLenLoc T (newAID (Rep_Store s) T) :=\n                   intgV (int n))\\<rparr>)", "have \"\\<not> aliveImpl (ref l) (Rep_Store s)\""], ["proof (prove)\nusing this:\n  \\<not> aliveImpl (ref l)\n          (Rep_Store s\n           \\<lparr>newAID :=\n                     \\<lambda>S.\n                        if T = S then Suc (newAID (Rep_Store s) T)\n                        else newAID (Rep_Store s) S,\n              vals := (vals (Rep_Store s))\n                (arrLenLoc T (newAID (Rep_Store s) T) :=\n                   intgV (int n))\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<not> aliveImpl (ref l) (Rep_Store s)", "by (simp add: aliveImpl_def split: Value.splits if_split_asm)"], ["proof (state)\nthis:\n  \\<not> aliveImpl (ref l) (Rep_Store s)\n\ngoal (1 subgoal):\n 1. l \\<noteq> arrLenLoc T (newAID (Rep_Store s) T) \\<Longrightarrow>\n    vals\n     (Rep_Store s\n      \\<lparr>newAID :=\n                \\<lambda>S.\n                   if T = S then Suc (newAID (Rep_Store s) T)\n                   else newAID (Rep_Store s) S,\n         vals := (vals (Rep_Store s))\n           (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n     l =\n    init (ltype l)", "with s"], ["proof (chain)\npicking this:\n  Rep_Store s \\<in> Store\n  \\<not> aliveImpl (ref l) (Rep_Store s)", "have \"vals (Rep_Store s) l = init (ltype l)\""], ["proof (prove)\nusing this:\n  Rep_Store s \\<in> Store\n  \\<not> aliveImpl (ref l) (Rep_Store s)\n\ngoal (1 subgoal):\n 1. vals (Rep_Store s) l = init (ltype l)", "by (simp add: Store_def)"], ["proof (state)\nthis:\n  vals (Rep_Store s) l = init (ltype l)\n\ngoal (1 subgoal):\n 1. l \\<noteq> arrLenLoc T (newAID (Rep_Store s) T) \\<Longrightarrow>\n    vals\n     (Rep_Store s\n      \\<lparr>newAID :=\n                \\<lambda>S.\n                   if T = S then Suc (newAID (Rep_Store s) T)\n                   else newAID (Rep_Store s) S,\n         vals := (vals (Rep_Store s))\n           (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n     l =\n    init (ltype l)", "with False"], ["proof (chain)\npicking this:\n  l \\<noteq> arrLenLoc T (newAID (Rep_Store s) T)\n  vals (Rep_Store s) l = init (ltype l)", "show ?thesis"], ["proof (prove)\nusing this:\n  l \\<noteq> arrLenLoc T (newAID (Rep_Store s) T)\n  vals (Rep_Store s) l = init (ltype l)\n\ngoal (1 subgoal):\n 1. vals\n     (Rep_Store s\n      \\<lparr>newAID :=\n                \\<lambda>S.\n                   if T = S then Suc (newAID (Rep_Store s) T)\n                   else newAID (Rep_Store s) S,\n         vals := (vals (Rep_Store s))\n           (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n     l =\n    init (ltype l)", "by simp"], ["proof (state)\nthis:\n  vals\n   (Rep_Store s\n    \\<lparr>newAID :=\n              \\<lambda>S.\n                 if T = S then Suc (newAID (Rep_Store s) T)\n                 else newAID (Rep_Store s) S,\n       vals := (vals (Rep_Store s))\n         (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n   l =\n  init (ltype l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vals\n   (Rep_Store s\n    \\<lparr>newAID :=\n              \\<lambda>S.\n                 if T = S then Suc (newAID (Rep_Store s) T)\n                 else newAID (Rep_Store s) S,\n       vals := (vals (Rep_Store s))\n         (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n   l =\n  init (ltype l)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>l.\n     \\<not> aliveImpl (ref l)\n             (Rep_Store s\n              \\<lparr>newAID :=\n                        \\<lambda>S.\n                           if T = S then Suc (newAID (Rep_Store s) T)\n                           else newAID (Rep_Store s) S,\n                 vals := (vals (Rep_Store s))\n                   (arrLenLoc T (newAID (Rep_Store s) T) :=\n                      intgV (int n))\\<rparr>) \\<longrightarrow>\n     vals\n      (Rep_Store s\n       \\<lparr>newAID :=\n                 \\<lambda>S.\n                    if T = S then Suc (newAID (Rep_Store s) T)\n                    else newAID (Rep_Store s) S,\n          vals := (vals (Rep_Store s))\n            (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n      l =\n     init (ltype l)\n\ngoal (1 subgoal):\n 1. Rep_Store s\n    \\<lparr>newAID :=\n              \\<lambda>S.\n                 if T = S then Suc (newAID (Rep_Store s) T)\n                 else newAID (Rep_Store s) S,\n       vals := (vals (Rep_Store s))\n         (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>\n    \\<in> Store", "moreover"], ["proof (state)\nthis:\n  \\<forall>l.\n     \\<not> aliveImpl (ref l)\n             (Rep_Store s\n              \\<lparr>newAID :=\n                        \\<lambda>S.\n                           if T = S then Suc (newAID (Rep_Store s) T)\n                           else newAID (Rep_Store s) S,\n                 vals := (vals (Rep_Store s))\n                   (arrLenLoc T (newAID (Rep_Store s) T) :=\n                      intgV (int n))\\<rparr>) \\<longrightarrow>\n     vals\n      (Rep_Store s\n       \\<lparr>newAID :=\n                 \\<lambda>S.\n                    if T = S then Suc (newAID (Rep_Store s) T)\n                    else newAID (Rep_Store s) S,\n          vals := (vals (Rep_Store s))\n            (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n      l =\n     init (ltype l)\n\ngoal (1 subgoal):\n 1. Rep_Store s\n    \\<lparr>newAID :=\n              \\<lambda>S.\n                 if T = S then Suc (newAID (Rep_Store s) T)\n                 else newAID (Rep_Store s) S,\n       vals := (vals (Rep_Store s))\n         (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>\n    \\<in> Store", "from s"], ["proof (chain)\npicking this:\n  Rep_Store s \\<in> Store", "have \"\\<forall> l. typeof (vals ?s_alloc l) \\<le> ltype l\""], ["proof (prove)\nusing this:\n  Rep_Store s \\<in> Store\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       \\<tau> vals\n               (Rep_Store s\n                \\<lparr>newAID :=\n                          \\<lambda>S.\n                             if T = S then Suc (newAID (Rep_Store s) T)\n                             else newAID (Rep_Store s) S,\n                   vals := (vals (Rep_Store s))\n                     (arrLenLoc T (newAID (Rep_Store s) T) :=\n                        intgV (int n))\\<rparr>)\n               l\n       \\<le> ltype l", "by (simp add: Store_def)"], ["proof (state)\nthis:\n  \\<forall>l.\n     \\<tau> vals\n             (Rep_Store s\n              \\<lparr>newAID :=\n                        \\<lambda>S.\n                           if T = S then Suc (newAID (Rep_Store s) T)\n                           else newAID (Rep_Store s) S,\n                 vals := (vals (Rep_Store s))\n                   (arrLenLoc T (newAID (Rep_Store s) T) :=\n                      intgV (int n))\\<rparr>)\n             l\n     \\<le> ltype l\n\ngoal (1 subgoal):\n 1. Rep_Store s\n    \\<lparr>newAID :=\n              \\<lambda>S.\n                 if T = S then Suc (newAID (Rep_Store s) T)\n                 else newAID (Rep_Store s) S,\n       vals := (vals (Rep_Store s))\n         (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>\n    \\<in> Store", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>l.\n     aliveImpl\n      (vals\n        (Rep_Store s\n         \\<lparr>newAID :=\n                   \\<lambda>S.\n                      if T = S then Suc (newAID (Rep_Store s) T)\n                      else newAID (Rep_Store s) S,\n            vals := (vals (Rep_Store s))\n              (arrLenLoc T (newAID (Rep_Store s) T) :=\n                 intgV (int n))\\<rparr>)\n        l)\n      (Rep_Store s\n       \\<lparr>newAID :=\n                 \\<lambda>S.\n                    if T = S then Suc (newAID (Rep_Store s) T)\n                    else newAID (Rep_Store s) S,\n          vals := (vals (Rep_Store s))\n            (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n  \\<forall>l.\n     \\<not> aliveImpl (ref l)\n             (Rep_Store s\n              \\<lparr>newAID :=\n                        \\<lambda>S.\n                           if T = S then Suc (newAID (Rep_Store s) T)\n                           else newAID (Rep_Store s) S,\n                 vals := (vals (Rep_Store s))\n                   (arrLenLoc T (newAID (Rep_Store s) T) :=\n                      intgV (int n))\\<rparr>) \\<longrightarrow>\n     vals\n      (Rep_Store s\n       \\<lparr>newAID :=\n                 \\<lambda>S.\n                    if T = S then Suc (newAID (Rep_Store s) T)\n                    else newAID (Rep_Store s) S,\n          vals := (vals (Rep_Store s))\n            (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n      l =\n     init (ltype l)\n  \\<forall>l.\n     \\<tau> vals\n             (Rep_Store s\n              \\<lparr>newAID :=\n                        \\<lambda>S.\n                           if T = S then Suc (newAID (Rep_Store s) T)\n                           else newAID (Rep_Store s) S,\n                 vals := (vals (Rep_Store s))\n                   (arrLenLoc T (newAID (Rep_Store s) T) :=\n                      intgV (int n))\\<rparr>)\n             l\n     \\<le> ltype l", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>l.\n     aliveImpl\n      (vals\n        (Rep_Store s\n         \\<lparr>newAID :=\n                   \\<lambda>S.\n                      if T = S then Suc (newAID (Rep_Store s) T)\n                      else newAID (Rep_Store s) S,\n            vals := (vals (Rep_Store s))\n              (arrLenLoc T (newAID (Rep_Store s) T) :=\n                 intgV (int n))\\<rparr>)\n        l)\n      (Rep_Store s\n       \\<lparr>newAID :=\n                 \\<lambda>S.\n                    if T = S then Suc (newAID (Rep_Store s) T)\n                    else newAID (Rep_Store s) S,\n          vals := (vals (Rep_Store s))\n            (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n  \\<forall>l.\n     \\<not> aliveImpl (ref l)\n             (Rep_Store s\n              \\<lparr>newAID :=\n                        \\<lambda>S.\n                           if T = S then Suc (newAID (Rep_Store s) T)\n                           else newAID (Rep_Store s) S,\n                 vals := (vals (Rep_Store s))\n                   (arrLenLoc T (newAID (Rep_Store s) T) :=\n                      intgV (int n))\\<rparr>) \\<longrightarrow>\n     vals\n      (Rep_Store s\n       \\<lparr>newAID :=\n                 \\<lambda>S.\n                    if T = S then Suc (newAID (Rep_Store s) T)\n                    else newAID (Rep_Store s) S,\n          vals := (vals (Rep_Store s))\n            (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>)\n      l =\n     init (ltype l)\n  \\<forall>l.\n     \\<tau> vals\n             (Rep_Store s\n              \\<lparr>newAID :=\n                        \\<lambda>S.\n                           if T = S then Suc (newAID (Rep_Store s) T)\n                           else newAID (Rep_Store s) S,\n                 vals := (vals (Rep_Store s))\n                   (arrLenLoc T (newAID (Rep_Store s) T) :=\n                      intgV (int n))\\<rparr>)\n             l\n     \\<le> ltype l\n\ngoal (1 subgoal):\n 1. Rep_Store s\n    \\<lparr>newAID :=\n              \\<lambda>S.\n                 if T = S then Suc (newAID (Rep_Store s) T)\n                 else newAID (Rep_Store s) S,\n       vals := (vals (Rep_Store s))\n         (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>\n    \\<in> Store", "by (simp add: Store_def)"], ["proof (state)\nthis:\n  Rep_Store s\n  \\<lparr>newAID :=\n            \\<lambda>S.\n               if T = S then Suc (newAID (Rep_Store s) T)\n               else newAID (Rep_Store s) S,\n     vals := (vals (Rep_Store s))\n       (arrLenLoc T (newAID (Rep_Store s) T) := intgV (int n))\\<rparr>\n  \\<in> Store\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma new_alive_alloc [simp,intro]: \"alive (new s t) (s\\<langle>t\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alive (new s t) (s\\<langle>t\\<rangle>)", "proof (cases t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       t = new_instance x1 \\<Longrightarrow>\n       alive (new s t) (s\\<langle>t\\<rangle>)\n 2. \\<And>x21 x22.\n       t = new_array x21 x22 \\<Longrightarrow>\n       alive (new s t) (s\\<langle>t\\<rangle>)", "case new_instance"], ["proof (state)\nthis:\n  t = new_instance x1_\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       t = new_instance x1 \\<Longrightarrow>\n       alive (new s t) (s\\<langle>t\\<rangle>)\n 2. \\<And>x21 x22.\n       t = new_array x21 x22 \\<Longrightarrow>\n       alive (new s t) (s\\<langle>t\\<rangle>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  t = new_instance x1_\n\ngoal (1 subgoal):\n 1. alive (new s t) (s\\<langle>t\\<rangle>)", "by (simp add: alive_def aliveImpl_def new_def alloc_def\n                  alloc_new_instance_in_Store [THEN Abs_Store_inverse])"], ["proof (state)\nthis:\n  alive (new s t) (s\\<langle>t\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = new_array x21 x22 \\<Longrightarrow>\n       alive (new s t) (s\\<langle>t\\<rangle>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = new_array x21 x22 \\<Longrightarrow>\n       alive (new s t) (s\\<langle>t\\<rangle>)", "case new_array"], ["proof (state)\nthis:\n  t = new_array x21_ x22_\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = new_array x21 x22 \\<Longrightarrow>\n       alive (new s t) (s\\<langle>t\\<rangle>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  t = new_array x21_ x22_\n\ngoal (1 subgoal):\n 1. alive (new s t) (s\\<langle>t\\<rangle>)", "by (simp add: alive_def aliveImpl_def new_def alloc_def\n                  alloc_new_array_in_Store [THEN Abs_Store_inverse])"], ["proof (state)\nthis:\n  alive (new s t) (s\\<langle>t\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma value_class_inhabitants: \n\"(\\<forall>x. typeof x = CClassT typeId \\<longrightarrow> P x) = (\\<forall> a. P (objV typeId a))\"\n  (is \"(\\<forall> x. ?A x) = ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. \\<tau> x = CClassT typeId \\<longrightarrow> P x) =\n    (\\<forall>a. P (objV typeId a))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x.\n       \\<tau> x = CClassT typeId \\<longrightarrow> P x \\<Longrightarrow>\n    \\<forall>a. P (objV typeId a)\n 2. \\<forall>a. P (objV typeId a) \\<Longrightarrow>\n    \\<forall>x. \\<tau> x = CClassT typeId \\<longrightarrow> P x", "assume \"\\<forall> x. ?A x\""], ["proof (state)\nthis:\n  \\<forall>x. \\<tau> x = CClassT typeId \\<longrightarrow> P x\n\ngoal (2 subgoals):\n 1. \\<forall>x.\n       \\<tau> x = CClassT typeId \\<longrightarrow> P x \\<Longrightarrow>\n    \\<forall>a. P (objV typeId a)\n 2. \\<forall>a. P (objV typeId a) \\<Longrightarrow>\n    \\<forall>x. \\<tau> x = CClassT typeId \\<longrightarrow> P x", "thus \"?B\""], ["proof (prove)\nusing this:\n  \\<forall>x. \\<tau> x = CClassT typeId \\<longrightarrow> P x\n\ngoal (1 subgoal):\n 1. \\<forall>a. P (objV typeId a)", "by simp"], ["proof (state)\nthis:\n  \\<forall>a. P (objV typeId a)\n\ngoal (1 subgoal):\n 1. \\<forall>a. P (objV typeId a) \\<Longrightarrow>\n    \\<forall>x. \\<tau> x = CClassT typeId \\<longrightarrow> P x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>a. P (objV typeId a) \\<Longrightarrow>\n    \\<forall>x. \\<tau> x = CClassT typeId \\<longrightarrow> P x", "assume B: \"?B\""], ["proof (state)\nthis:\n  \\<forall>a. P (objV typeId a)\n\ngoal (1 subgoal):\n 1. \\<forall>a. P (objV typeId a) \\<Longrightarrow>\n    \\<forall>x. \\<tau> x = CClassT typeId \\<longrightarrow> P x", "show \"\\<forall> x. ?A x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. \\<tau> x = CClassT typeId \\<longrightarrow> P x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<tau> x = CClassT typeId \\<longrightarrow> P x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<tau> x = CClassT typeId \\<longrightarrow> P x", "from B"], ["proof (chain)\npicking this:\n  \\<forall>a. P (objV typeId a)", "show \"?A x\""], ["proof (prove)\nusing this:\n  \\<forall>a. P (objV typeId a)\n\ngoal (1 subgoal):\n 1. \\<tau> x = CClassT typeId \\<longrightarrow> P x", "by (cases x) auto"], ["proof (state)\nthis:\n  \\<tau> x = CClassT typeId \\<longrightarrow> P x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x. \\<tau> x = CClassT typeId \\<longrightarrow> P x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma value_array_inhabitants: \n\"(\\<forall>x. typeof x = ArrT typeId \\<longrightarrow> P x) = (\\<forall> a. P (arrV typeId a))\"\n  (is \"(\\<forall> x. ?A x) = ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. \\<tau> x = ArrT typeId \\<longrightarrow> P x) =\n    (\\<forall>a. P (arrV typeId a))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x.\n       \\<tau> x = ArrT typeId \\<longrightarrow> P x \\<Longrightarrow>\n    \\<forall>a. P (arrV typeId a)\n 2. \\<forall>a. P (arrV typeId a) \\<Longrightarrow>\n    \\<forall>x. \\<tau> x = ArrT typeId \\<longrightarrow> P x", "assume \"\\<forall> x. ?A x\""], ["proof (state)\nthis:\n  \\<forall>x. \\<tau> x = ArrT typeId \\<longrightarrow> P x\n\ngoal (2 subgoals):\n 1. \\<forall>x.\n       \\<tau> x = ArrT typeId \\<longrightarrow> P x \\<Longrightarrow>\n    \\<forall>a. P (arrV typeId a)\n 2. \\<forall>a. P (arrV typeId a) \\<Longrightarrow>\n    \\<forall>x. \\<tau> x = ArrT typeId \\<longrightarrow> P x", "thus \"?B\""], ["proof (prove)\nusing this:\n  \\<forall>x. \\<tau> x = ArrT typeId \\<longrightarrow> P x\n\ngoal (1 subgoal):\n 1. \\<forall>a. P (arrV typeId a)", "by simp"], ["proof (state)\nthis:\n  \\<forall>a. P (arrV typeId a)\n\ngoal (1 subgoal):\n 1. \\<forall>a. P (arrV typeId a) \\<Longrightarrow>\n    \\<forall>x. \\<tau> x = ArrT typeId \\<longrightarrow> P x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>a. P (arrV typeId a) \\<Longrightarrow>\n    \\<forall>x. \\<tau> x = ArrT typeId \\<longrightarrow> P x", "assume B: \"?B\""], ["proof (state)\nthis:\n  \\<forall>a. P (arrV typeId a)\n\ngoal (1 subgoal):\n 1. \\<forall>a. P (arrV typeId a) \\<Longrightarrow>\n    \\<forall>x. \\<tau> x = ArrT typeId \\<longrightarrow> P x", "show \"\\<forall> x. ?A x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. \\<tau> x = ArrT typeId \\<longrightarrow> P x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<tau> x = ArrT typeId \\<longrightarrow> P x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<tau> x = ArrT typeId \\<longrightarrow> P x", "from B"], ["proof (chain)\npicking this:\n  \\<forall>a. P (arrV typeId a)", "show \"?A x\""], ["proof (prove)\nusing this:\n  \\<forall>a. P (arrV typeId a)\n\ngoal (1 subgoal):\n 1. \\<tau> x = ArrT typeId \\<longrightarrow> P x", "by (cases x) auto"], ["proof (state)\nthis:\n  \\<tau> x = ArrT typeId \\<longrightarrow> P x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x. \\<tau> x = ArrT typeId \\<longrightarrow> P x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The following three lemmas are helper lemmas that are not related to the store theory.\nThey might as well be stored in a separate helper theory.\n\\<close>"], ["", "lemma le_Suc_eq: \"(\\<forall>a. (a < Suc n) = (a < Suc m)) = (\\<forall>a. (a < n) = (a < m))\"\n (is \"(\\<forall>a. ?A a) = (\\<forall> a. ?B a)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a. (a < Suc n) = (a < Suc m)) =\n    (\\<forall>a. (a < n) = (a < m))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>a. (a < Suc n) = (a < Suc m) \\<Longrightarrow>\n    \\<forall>a. (a < n) = (a < m)\n 2. \\<forall>a. (a < n) = (a < m) \\<Longrightarrow>\n    \\<forall>a. (a < Suc n) = (a < Suc m)", "assume \"\\<forall>a. ?A a\""], ["proof (state)\nthis:\n  \\<forall>a. (a < Suc n) = (a < Suc m)\n\ngoal (2 subgoals):\n 1. \\<forall>a. (a < Suc n) = (a < Suc m) \\<Longrightarrow>\n    \\<forall>a. (a < n) = (a < m)\n 2. \\<forall>a. (a < n) = (a < m) \\<Longrightarrow>\n    \\<forall>a. (a < Suc n) = (a < Suc m)", "thus \"\\<forall> a. ?B a\""], ["proof (prove)\nusing this:\n  \\<forall>a. (a < Suc n) = (a < Suc m)\n\ngoal (1 subgoal):\n 1. \\<forall>a. (a < n) = (a < m)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>a. (a < n) = (a < m)\n\ngoal (1 subgoal):\n 1. \\<forall>a. (a < n) = (a < m) \\<Longrightarrow>\n    \\<forall>a. (a < Suc n) = (a < Suc m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>a. (a < n) = (a < m) \\<Longrightarrow>\n    \\<forall>a. (a < Suc n) = (a < Suc m)", "assume B: \"\\<forall> a. ?B a\""], ["proof (state)\nthis:\n  \\<forall>a. (a < n) = (a < m)\n\ngoal (1 subgoal):\n 1. \\<forall>a. (a < n) = (a < m) \\<Longrightarrow>\n    \\<forall>a. (a < Suc n) = (a < Suc m)", "show \"\\<forall>a. ?A a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a. (a < Suc n) = (a < Suc m)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. (a < Suc n) = (a < Suc m)", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. (a < Suc n) = (a < Suc m)", "from B"], ["proof (chain)\npicking this:\n  \\<forall>a. (a < n) = (a < m)", "show \"?A a\""], ["proof (prove)\nusing this:\n  \\<forall>a. (a < n) = (a < m)\n\ngoal (1 subgoal):\n 1. (a < Suc n) = (a < Suc m)", "by (cases a) simp_all"], ["proof (state)\nthis:\n  (a < Suc n) = (a < Suc m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>a. (a < Suc n) = (a < Suc m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma all_le_eq_imp_eq: \"\\<And> c::nat. (\\<forall>a. (a < d) = (a < c)) \\<longrightarrow> (d = c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c. (\\<forall>a. (a < d) = (a < c)) \\<longrightarrow> d = c", "proof (induct d)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c. (\\<forall>a. (a < 0) = (a < c)) \\<longrightarrow> 0 = c\n 2. \\<And>d c.\n       (\\<And>c.\n           (\\<forall>a. (a < d) = (a < c)) \\<longrightarrow>\n           d = c) \\<Longrightarrow>\n       (\\<forall>a. (a < Suc d) = (a < c)) \\<longrightarrow> Suc d = c", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>c. (\\<forall>a. (a < 0) = (a < c)) \\<longrightarrow> 0 = c\n 2. \\<And>d c.\n       (\\<And>c.\n           (\\<forall>a. (a < d) = (a < c)) \\<longrightarrow>\n           d = c) \\<Longrightarrow>\n       (\\<forall>a. (a < Suc d) = (a < c)) \\<longrightarrow> Suc d = c", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a. (a < 0) = (a < c)) \\<longrightarrow> 0 = c", "by fastforce"], ["proof (state)\nthis:\n  (\\<forall>a. (a < 0) = (a < c)) \\<longrightarrow> 0 = c\n\ngoal (1 subgoal):\n 1. \\<And>d c.\n       (\\<And>c.\n           (\\<forall>a. (a < d) = (a < c)) \\<longrightarrow>\n           d = c) \\<Longrightarrow>\n       (\\<forall>a. (a < Suc d) = (a < c)) \\<longrightarrow> Suc d = c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d c.\n       (\\<And>c.\n           (\\<forall>a. (a < d) = (a < c)) \\<longrightarrow>\n           d = c) \\<Longrightarrow>\n       (\\<forall>a. (a < Suc d) = (a < c)) \\<longrightarrow> Suc d = c", "case (Suc n c)"], ["proof (state)\nthis:\n  (\\<forall>a. (a < n) = (a < ?c)) \\<longrightarrow> n = ?c\n\ngoal (1 subgoal):\n 1. \\<And>d c.\n       (\\<And>c.\n           (\\<forall>a. (a < d) = (a < c)) \\<longrightarrow>\n           d = c) \\<Longrightarrow>\n       (\\<forall>a. (a < Suc d) = (a < c)) \\<longrightarrow> Suc d = c", "thus ?case"], ["proof (prove)\nusing this:\n  (\\<forall>a. (a < n) = (a < ?c)) \\<longrightarrow> n = ?c\n\ngoal (1 subgoal):\n 1. (\\<forall>a. (a < Suc n) = (a < c)) \\<longrightarrow> Suc n = c", "by (cases c) (auto simp add: le_Suc_eq)"], ["proof (state)\nthis:\n  (\\<forall>a. (a < Suc n) = (a < c)) \\<longrightarrow> Suc n = c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma all_le_eq: \"(\\<forall> a::nat. (a < d) = (a < c)) = (d = c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a. (a < d) = (a < c)) = (d = c)", "using all_le_eq_imp_eq"], ["proof (prove)\nusing this:\n  (\\<forall>a. (a < ?d) = (a < ?c)) \\<longrightarrow> ?d = ?c\n\ngoal (1 subgoal):\n 1. (\\<forall>a. (a < d) = (a < c)) = (d = c)", "by auto"], ["", "text \\<open>Store11\\<close>"], ["", "lemma typeof_new: \"typeof (new s t) = typeofNew t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> new s t = typeofNew t", "by (cases t) (simp_all add: new_def typeofNew_def)"], ["", "text \\<open>Store12\\<close>"], ["", "lemma new_eq: \"(new s1 t = new s2 t) = \n                 (\\<forall> x. typeof x = typeofNew t \\<longrightarrow> alive x s1 = alive x s2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (new s1 t = new s2 t) =\n    (\\<forall>x.\n        \\<tau> x = typeofNew t \\<longrightarrow> alive x s1 = alive x s2)", "by (cases t)\n   (auto simp add: new_def typeofNew_def alive_def aliveImpl_def\n                   value_class_inhabitants value_array_inhabitants all_le_eq)"], ["", "lemma new_update [simp]: \"new (s\\<langle>l:=x\\<rangle>) t = new s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new (s\\<langle>l := x\\<rangle>) t = new s t", "by (simp add: new_eq)"], ["", "lemma alive_alloc_propagation: \n  assumes alive_s: \"alive x s\" shows  \"alive x (s\\<langle>t\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alive x (s\\<langle>t\\<rangle>)", "proof (cases t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       t = new_instance x1 \\<Longrightarrow> alive x (s\\<langle>t\\<rangle>)\n 2. \\<And>x21 x22.\n       t = new_array x21 x22 \\<Longrightarrow>\n       alive x (s\\<langle>t\\<rangle>)", "case new_instance"], ["proof (state)\nthis:\n  t = new_instance x1_\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       t = new_instance x1 \\<Longrightarrow> alive x (s\\<langle>t\\<rangle>)\n 2. \\<And>x21 x22.\n       t = new_array x21 x22 \\<Longrightarrow>\n       alive x (s\\<langle>t\\<rangle>)", "with alive_s"], ["proof (chain)\npicking this:\n  alive x s\n  t = new_instance x1_", "show ?thesis"], ["proof (prove)\nusing this:\n  alive x s\n  t = new_instance x1_\n\ngoal (1 subgoal):\n 1. alive x (s\\<langle>t\\<rangle>)", "by (cases x) \n       (simp_all add: alive_def aliveImpl_def alloc_def \n                      alloc_new_instance_in_Store [THEN Abs_Store_inverse])"], ["proof (state)\nthis:\n  alive x (s\\<langle>t\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = new_array x21 x22 \\<Longrightarrow>\n       alive x (s\\<langle>t\\<rangle>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = new_array x21 x22 \\<Longrightarrow>\n       alive x (s\\<langle>t\\<rangle>)", "case new_array"], ["proof (state)\nthis:\n  t = new_array x21_ x22_\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = new_array x21 x22 \\<Longrightarrow>\n       alive x (s\\<langle>t\\<rangle>)", "with alive_s"], ["proof (chain)\npicking this:\n  alive x s\n  t = new_array x21_ x22_", "show ?thesis"], ["proof (prove)\nusing this:\n  alive x s\n  t = new_array x21_ x22_\n\ngoal (1 subgoal):\n 1. alive x (s\\<langle>t\\<rangle>)", "by (cases x) \n       (simp_all add: alive_def aliveImpl_def alloc_def \n                      alloc_new_array_in_Store [THEN Abs_Store_inverse])"], ["proof (state)\nthis:\n  alive x (s\\<langle>t\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Store7\\<close>"], ["", "lemma alive_alloc_exhaust: \"alive x (s\\<langle>t\\<rangle>) = (alive x s \\<or> (x = new s t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alive x (s\\<langle>t\\<rangle>) = (alive x s \\<or> x = new s t)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. alive x (s\\<langle>t\\<rangle>) \\<Longrightarrow>\n    alive x s \\<or> x = new s t\n 2. alive x s \\<or> x = new s t \\<Longrightarrow>\n    alive x (s\\<langle>t\\<rangle>)", "assume alive_alloc: \"alive x (s\\<langle>t\\<rangle>)\""], ["proof (state)\nthis:\n  alive x (s\\<langle>t\\<rangle>)\n\ngoal (2 subgoals):\n 1. alive x (s\\<langle>t\\<rangle>) \\<Longrightarrow>\n    alive x s \\<or> x = new s t\n 2. alive x s \\<or> x = new s t \\<Longrightarrow>\n    alive x (s\\<langle>t\\<rangle>)", "show \"alive x s \\<or> x = new s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alive x s \\<or> x = new s t", "proof (cases t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       t = new_instance x1 \\<Longrightarrow> alive x s \\<or> x = new s t\n 2. \\<And>x21 x22.\n       t = new_array x21 x22 \\<Longrightarrow> alive x s \\<or> x = new s t", "case (new_instance C)"], ["proof (state)\nthis:\n  t = new_instance C\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       t = new_instance x1 \\<Longrightarrow> alive x s \\<or> x = new s t\n 2. \\<And>x21 x22.\n       t = new_array x21 x22 \\<Longrightarrow> alive x s \\<or> x = new s t", "with alive_alloc"], ["proof (chain)\npicking this:\n  alive x (s\\<langle>t\\<rangle>)\n  t = new_instance C", "show ?thesis"], ["proof (prove)\nusing this:\n  alive x (s\\<langle>t\\<rangle>)\n  t = new_instance C\n\ngoal (1 subgoal):\n 1. alive x s \\<or> x = new s t", "by (cases x) (auto split: if_split_asm \n                         simp add: alive_def new_def alloc_def aliveImpl_def\n                              alloc_new_instance_in_Store [THEN Abs_Store_inverse])"], ["proof (state)\nthis:\n  alive x s \\<or> x = new s t\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = new_array x21 x22 \\<Longrightarrow> alive x s \\<or> x = new s t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = new_array x21 x22 \\<Longrightarrow> alive x s \\<or> x = new s t", "case (new_array T l)"], ["proof (state)\nthis:\n  t = new_array T l\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = new_array x21 x22 \\<Longrightarrow> alive x s \\<or> x = new s t", "with alive_alloc"], ["proof (chain)\npicking this:\n  alive x (s\\<langle>t\\<rangle>)\n  t = new_array T l", "show ?thesis"], ["proof (prove)\nusing this:\n  alive x (s\\<langle>t\\<rangle>)\n  t = new_array T l\n\ngoal (1 subgoal):\n 1. alive x s \\<or> x = new s t", "by (cases x) (auto split: if_split_asm\n                         simp add: alive_def new_def alloc_def aliveImpl_def\n                         alloc_new_array_in_Store [THEN Abs_Store_inverse])"], ["proof (state)\nthis:\n  alive x s \\<or> x = new s t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  alive x s \\<or> x = new s t\n\ngoal (1 subgoal):\n 1. alive x s \\<or> x = new s t \\<Longrightarrow>\n    alive x (s\\<langle>t\\<rangle>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. alive x s \\<or> x = new s t \\<Longrightarrow>\n    alive x (s\\<langle>t\\<rangle>)", "assume \"alive x s \\<or> x = new s t\""], ["proof (state)\nthis:\n  alive x s \\<or> x = new s t\n\ngoal (1 subgoal):\n 1. alive x s \\<or> x = new s t \\<Longrightarrow>\n    alive x (s\\<langle>t\\<rangle>)", "then"], ["proof (chain)\npicking this:\n  alive x s \\<or> x = new s t", "show \"alive x (s\\<langle>t\\<rangle>)\""], ["proof (prove)\nusing this:\n  alive x s \\<or> x = new s t\n\ngoal (1 subgoal):\n 1. alive x (s\\<langle>t\\<rangle>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. alive x s \\<Longrightarrow> alive x (s\\<langle>t\\<rangle>)\n 2. x = new s t \\<Longrightarrow> alive x (s\\<langle>t\\<rangle>)", "assume \"alive x s\""], ["proof (state)\nthis:\n  alive x s\n\ngoal (2 subgoals):\n 1. alive x s \\<Longrightarrow> alive x (s\\<langle>t\\<rangle>)\n 2. x = new s t \\<Longrightarrow> alive x (s\\<langle>t\\<rangle>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  alive x s\n\ngoal (1 subgoal):\n 1. alive x (s\\<langle>t\\<rangle>)", "by (rule alive_alloc_propagation)"], ["proof (state)\nthis:\n  alive x (s\\<langle>t\\<rangle>)\n\ngoal (1 subgoal):\n 1. x = new s t \\<Longrightarrow> alive x (s\\<langle>t\\<rangle>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x = new s t \\<Longrightarrow> alive x (s\\<langle>t\\<rangle>)", "assume new: \"x=new s t\""], ["proof (state)\nthis:\n  x = new s t\n\ngoal (1 subgoal):\n 1. x = new s t \\<Longrightarrow> alive x (s\\<langle>t\\<rangle>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. alive x (s\\<langle>t\\<rangle>)", "proof (cases t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       t = new_instance x1 \\<Longrightarrow> alive x (s\\<langle>t\\<rangle>)\n 2. \\<And>x21 x22.\n       t = new_array x21 x22 \\<Longrightarrow>\n       alive x (s\\<langle>t\\<rangle>)", "case new_instance"], ["proof (state)\nthis:\n  t = new_instance x1_\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       t = new_instance x1 \\<Longrightarrow> alive x (s\\<langle>t\\<rangle>)\n 2. \\<And>x21 x22.\n       t = new_array x21 x22 \\<Longrightarrow>\n       alive x (s\\<langle>t\\<rangle>)", "with new"], ["proof (chain)\npicking this:\n  x = new s t\n  t = new_instance x1_", "show ?thesis"], ["proof (prove)\nusing this:\n  x = new s t\n  t = new_instance x1_\n\ngoal (1 subgoal):\n 1. alive x (s\\<langle>t\\<rangle>)", "by (simp add: alive_def aliveImpl_def new_def alloc_def\n                      alloc_new_instance_in_Store [THEN Abs_Store_inverse])"], ["proof (state)\nthis:\n  alive x (s\\<langle>t\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = new_array x21 x22 \\<Longrightarrow>\n       alive x (s\\<langle>t\\<rangle>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = new_array x21 x22 \\<Longrightarrow>\n       alive x (s\\<langle>t\\<rangle>)", "case new_array"], ["proof (state)\nthis:\n  t = new_array x21_ x22_\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = new_array x21 x22 \\<Longrightarrow>\n       alive x (s\\<langle>t\\<rangle>)", "with new"], ["proof (chain)\npicking this:\n  x = new s t\n  t = new_array x21_ x22_", "show ?thesis"], ["proof (prove)\nusing this:\n  x = new s t\n  t = new_array x21_ x22_\n\ngoal (1 subgoal):\n 1. alive x (s\\<langle>t\\<rangle>)", "by (simp add: alive_def aliveImpl_def new_def alloc_def\n                      alloc_new_array_in_Store [THEN Abs_Store_inverse])"], ["proof (state)\nthis:\n  alive x (s\\<langle>t\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  alive x (s\\<langle>t\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  alive x (s\\<langle>t\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alive_alloc_cases [consumes 1]: \n  \"\\<lbrakk>alive x (s\\<langle>t\\<rangle>); alive x s \\<Longrightarrow> P; x=new s t \\<Longrightarrow> P\\<rbrakk>\n   \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>alive x (s\\<langle>t\\<rangle>); alive x s \\<Longrightarrow> P;\n     x = new s t \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (auto simp add: alive_alloc_exhaust)"], ["", "lemma aliveImpl_vals_independent: \"aliveImpl x (s\\<lparr>vals := z\\<rparr>) = aliveImpl x s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aliveImpl x (s\\<lparr>vals := z\\<rparr>) = aliveImpl x s", "by (cases x) (simp_all add: aliveImpl_def)"], ["", "lemma access_arr_len_new_alloc [simp]: \n  \"s\\<langle>new_array T l\\<rangle>@@arr_len (new s (new_array T l)) = intgV (int l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<langle>new_array T l\\<rangle>@@arr_len (new s (new_array T l)) =\n    intgV (int l)", "by (subst access_def) \n     (simp add: new_def alloc_def alive_def \n                alloc_new_array_in_Store [THEN Abs_Store_inverse] access_def)"], ["", "lemma access_new [simp]:\n  assumes ref_new: \"ref l = new s t\"\n  assumes no_arr_len: \"isNewArr t \\<longrightarrow> l \\<noteq> arr_len (new s t)\"\n  shows \"s\\<langle>t\\<rangle>@@l = init (ltype l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<langle>t\\<rangle>@@l = init (ltype l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s\\<langle>t\\<rangle>@@l = init (ltype l)", "from ref_new"], ["proof (chain)\npicking this:\n  ref l = new s t", "have \"\\<not> alive (ref l) s\""], ["proof (prove)\nusing this:\n  ref l = new s t\n\ngoal (1 subgoal):\n 1. \\<not> alive (ref l) s", "by simp"], ["proof (state)\nthis:\n  \\<not> alive (ref l) s\n\ngoal (1 subgoal):\n 1. s\\<langle>t\\<rangle>@@l = init (ltype l)", "hence \"s@@l = init (ltype l)\""], ["proof (prove)\nusing this:\n  \\<not> alive (ref l) s\n\ngoal (1 subgoal):\n 1. s@@l = init (ltype l)", "by simp"], ["proof (state)\nthis:\n  s@@l = init (ltype l)\n\ngoal (1 subgoal):\n 1. s\\<langle>t\\<rangle>@@l = init (ltype l)", "moreover"], ["proof (state)\nthis:\n  s@@l = init (ltype l)\n\ngoal (1 subgoal):\n 1. s\\<langle>t\\<rangle>@@l = init (ltype l)", "from ref_new"], ["proof (chain)\npicking this:\n  ref l = new s t", "have \"alive (ref l) (s\\<langle>t\\<rangle>)\""], ["proof (prove)\nusing this:\n  ref l = new s t\n\ngoal (1 subgoal):\n 1. alive (ref l) (s\\<langle>t\\<rangle>)", "by simp"], ["proof (state)\nthis:\n  alive (ref l) (s\\<langle>t\\<rangle>)\n\ngoal (1 subgoal):\n 1. s\\<langle>t\\<rangle>@@l = init (ltype l)", "moreover"], ["proof (state)\nthis:\n  alive (ref l) (s\\<langle>t\\<rangle>)\n\ngoal (1 subgoal):\n 1. s\\<langle>t\\<rangle>@@l = init (ltype l)", "from no_arr_len"], ["proof (chain)\npicking this:\n  isNewArr t \\<longrightarrow> l \\<noteq> arr_len (new s t)", "have \"vals (Rep_Store (s\\<langle>t\\<rangle>)) l = s@@l\""], ["proof (prove)\nusing this:\n  isNewArr t \\<longrightarrow> l \\<noteq> arr_len (new s t)\n\ngoal (1 subgoal):\n 1. vals (Rep_Store (s\\<langle>t\\<rangle>)) l = s@@l", "by (cases t)\n       (simp_all add: alloc_def new_def access_def\n                  alloc_new_instance_in_Store [THEN Abs_Store_inverse] \n                  alloc_new_array_in_Store [THEN Abs_Store_inverse] )"], ["proof (state)\nthis:\n  vals (Rep_Store (s\\<langle>t\\<rangle>)) l = s@@l\n\ngoal (1 subgoal):\n 1. s\\<langle>t\\<rangle>@@l = init (ltype l)", "ultimately"], ["proof (chain)\npicking this:\n  s@@l = init (ltype l)\n  alive (ref l) (s\\<langle>t\\<rangle>)\n  vals (Rep_Store (s\\<langle>t\\<rangle>)) l = s@@l", "show \"s\\<langle>t\\<rangle>@@l = init (ltype l)\""], ["proof (prove)\nusing this:\n  s@@l = init (ltype l)\n  alive (ref l) (s\\<langle>t\\<rangle>)\n  vals (Rep_Store (s\\<langle>t\\<rangle>)) l = s@@l\n\ngoal (1 subgoal):\n 1. s\\<langle>t\\<rangle>@@l = init (ltype l)", "by (subst access_def) (simp)"], ["proof (state)\nthis:\n  s\\<langle>t\\<rangle>@@l = init (ltype l)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Store5. We have to take into account that the length of an array\nis changed during allocation.\\<close>"], ["", "lemma access_alloc [simp]:\n  assumes no_arr_len_new: \"isNewArr t \\<longrightarrow> l \\<noteq> arr_len (new s t)\"\n  shows \"s\\<langle>t\\<rangle>@@l = s@@l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<langle>t\\<rangle>@@l = s@@l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s\\<langle>t\\<rangle>@@l = s@@l", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<langle>t\\<rangle>@@l = s@@l", "proof (cases \"alive (ref l) (s\\<langle>t\\<rangle>)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. alive (ref l) (s\\<langle>t\\<rangle>) \\<Longrightarrow>\n    s\\<langle>t\\<rangle>@@l = s@@l\n 2. \\<not> alive (ref l) (s\\<langle>t\\<rangle>) \\<Longrightarrow>\n    s\\<langle>t\\<rangle>@@l = s@@l", "case True"], ["proof (state)\nthis:\n  alive (ref l) (s\\<langle>t\\<rangle>)\n\ngoal (2 subgoals):\n 1. alive (ref l) (s\\<langle>t\\<rangle>) \\<Longrightarrow>\n    s\\<langle>t\\<rangle>@@l = s@@l\n 2. \\<not> alive (ref l) (s\\<langle>t\\<rangle>) \\<Longrightarrow>\n    s\\<langle>t\\<rangle>@@l = s@@l", "then"], ["proof (chain)\npicking this:\n  alive (ref l) (s\\<langle>t\\<rangle>)", "have access_alloc_vals: \"s\\<langle>t\\<rangle>@@l = vals (Rep_Store (s\\<langle>t\\<rangle>)) l\""], ["proof (prove)\nusing this:\n  alive (ref l) (s\\<langle>t\\<rangle>)\n\ngoal (1 subgoal):\n 1. s\\<langle>t\\<rangle>@@l = vals (Rep_Store (s\\<langle>t\\<rangle>)) l", "by (simp add: access_def alloc_def)"], ["proof (state)\nthis:\n  s\\<langle>t\\<rangle>@@l = vals (Rep_Store (s\\<langle>t\\<rangle>)) l\n\ngoal (2 subgoals):\n 1. alive (ref l) (s\\<langle>t\\<rangle>) \\<Longrightarrow>\n    s\\<langle>t\\<rangle>@@l = s@@l\n 2. \\<not> alive (ref l) (s\\<langle>t\\<rangle>) \\<Longrightarrow>\n    s\\<langle>t\\<rangle>@@l = s@@l", "from True"], ["proof (chain)\npicking this:\n  alive (ref l) (s\\<langle>t\\<rangle>)", "show ?thesis"], ["proof (prove)\nusing this:\n  alive (ref l) (s\\<langle>t\\<rangle>)\n\ngoal (1 subgoal):\n 1. s\\<langle>t\\<rangle>@@l = s@@l", "proof (cases rule: alive_alloc_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. alive (ref l) s \\<Longrightarrow> s\\<langle>t\\<rangle>@@l = s@@l\n 2. ref l = new s t \\<Longrightarrow> s\\<langle>t\\<rangle>@@l = s@@l", "assume alive_l_s: \"alive (ref l) s\""], ["proof (state)\nthis:\n  alive (ref l) s\n\ngoal (2 subgoals):\n 1. alive (ref l) s \\<Longrightarrow> s\\<langle>t\\<rangle>@@l = s@@l\n 2. ref l = new s t \\<Longrightarrow> s\\<langle>t\\<rangle>@@l = s@@l", "with new_unalive_old_Store"], ["proof (chain)\npicking this:\n  \\<not> alive (new ?s ?t) ?s\n  alive (ref l) s", "have l_not_new: \"ref l \\<noteq> new s t\""], ["proof (prove)\nusing this:\n  \\<not> alive (new ?s ?t) ?s\n  alive (ref l) s\n\ngoal (1 subgoal):\n 1. ref l \\<noteq> new s t", "by fastforce"], ["proof (state)\nthis:\n  ref l \\<noteq> new s t\n\ngoal (2 subgoals):\n 1. alive (ref l) s \\<Longrightarrow> s\\<langle>t\\<rangle>@@l = s@@l\n 2. ref l = new s t \\<Longrightarrow> s\\<langle>t\\<rangle>@@l = s@@l", "hence \"vals (Rep_Store (s\\<langle>t\\<rangle>)) l = s@@l\""], ["proof (prove)\nusing this:\n  ref l \\<noteq> new s t\n\ngoal (1 subgoal):\n 1. vals (Rep_Store (s\\<langle>t\\<rangle>)) l = s@@l", "by (cases t) \n           (auto simp add: alloc_def new_def access_def \n                 alloc_new_instance_in_Store [THEN Abs_Store_inverse] \n                 alloc_new_array_in_Store [THEN Abs_Store_inverse])"], ["proof (state)\nthis:\n  vals (Rep_Store (s\\<langle>t\\<rangle>)) l = s@@l\n\ngoal (2 subgoals):\n 1. alive (ref l) s \\<Longrightarrow> s\\<langle>t\\<rangle>@@l = s@@l\n 2. ref l = new s t \\<Longrightarrow> s\\<langle>t\\<rangle>@@l = s@@l", "with access_alloc_vals"], ["proof (chain)\npicking this:\n  s\\<langle>t\\<rangle>@@l = vals (Rep_Store (s\\<langle>t\\<rangle>)) l\n  vals (Rep_Store (s\\<langle>t\\<rangle>)) l = s@@l", "show ?thesis"], ["proof (prove)\nusing this:\n  s\\<langle>t\\<rangle>@@l = vals (Rep_Store (s\\<langle>t\\<rangle>)) l\n  vals (Rep_Store (s\\<langle>t\\<rangle>)) l = s@@l\n\ngoal (1 subgoal):\n 1. s\\<langle>t\\<rangle>@@l = s@@l", "by simp"], ["proof (state)\nthis:\n  s\\<langle>t\\<rangle>@@l = s@@l\n\ngoal (1 subgoal):\n 1. ref l = new s t \\<Longrightarrow> s\\<langle>t\\<rangle>@@l = s@@l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ref l = new s t \\<Longrightarrow> s\\<langle>t\\<rangle>@@l = s@@l", "assume ref_new: \"ref l = new s t\""], ["proof (state)\nthis:\n  ref l = new s t\n\ngoal (1 subgoal):\n 1. ref l = new s t \\<Longrightarrow> s\\<langle>t\\<rangle>@@l = s@@l", "with no_arr_len_new"], ["proof (chain)\npicking this:\n  isNewArr t \\<longrightarrow> l \\<noteq> arr_len (new s t)\n  ref l = new s t", "have \"s\\<langle>t\\<rangle>@@l = init (ltype l)\""], ["proof (prove)\nusing this:\n  isNewArr t \\<longrightarrow> l \\<noteq> arr_len (new s t)\n  ref l = new s t\n\ngoal (1 subgoal):\n 1. s\\<langle>t\\<rangle>@@l = init (ltype l)", "by (simp add: access_new)"], ["proof (state)\nthis:\n  s\\<langle>t\\<rangle>@@l = init (ltype l)\n\ngoal (1 subgoal):\n 1. ref l = new s t \\<Longrightarrow> s\\<langle>t\\<rangle>@@l = s@@l", "moreover"], ["proof (state)\nthis:\n  s\\<langle>t\\<rangle>@@l = init (ltype l)\n\ngoal (1 subgoal):\n 1. ref l = new s t \\<Longrightarrow> s\\<langle>t\\<rangle>@@l = s@@l", "from ref_new"], ["proof (chain)\npicking this:\n  ref l = new s t", "have \"s@@l = init (ltype l)\""], ["proof (prove)\nusing this:\n  ref l = new s t\n\ngoal (1 subgoal):\n 1. s@@l = init (ltype l)", "by simp"], ["proof (state)\nthis:\n  s@@l = init (ltype l)\n\ngoal (1 subgoal):\n 1. ref l = new s t \\<Longrightarrow> s\\<langle>t\\<rangle>@@l = s@@l", "ultimately"], ["proof (chain)\npicking this:\n  s\\<langle>t\\<rangle>@@l = init (ltype l)\n  s@@l = init (ltype l)", "show ?thesis"], ["proof (prove)\nusing this:\n  s\\<langle>t\\<rangle>@@l = init (ltype l)\n  s@@l = init (ltype l)\n\ngoal (1 subgoal):\n 1. s\\<langle>t\\<rangle>@@l = s@@l", "by simp"], ["proof (state)\nthis:\n  s\\<langle>t\\<rangle>@@l = s@@l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s\\<langle>t\\<rangle>@@l = s@@l\n\ngoal (1 subgoal):\n 1. \\<not> alive (ref l) (s\\<langle>t\\<rangle>) \\<Longrightarrow>\n    s\\<langle>t\\<rangle>@@l = s@@l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> alive (ref l) (s\\<langle>t\\<rangle>) \\<Longrightarrow>\n    s\\<langle>t\\<rangle>@@l = s@@l", "case False"], ["proof (state)\nthis:\n  \\<not> alive (ref l) (s\\<langle>t\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<not> alive (ref l) (s\\<langle>t\\<rangle>) \\<Longrightarrow>\n    s\\<langle>t\\<rangle>@@l = s@@l", "hence \"s\\<langle>t\\<rangle>@@l = init (ltype l)\""], ["proof (prove)\nusing this:\n  \\<not> alive (ref l) (s\\<langle>t\\<rangle>)\n\ngoal (1 subgoal):\n 1. s\\<langle>t\\<rangle>@@l = init (ltype l)", "by (simp)"], ["proof (state)\nthis:\n  s\\<langle>t\\<rangle>@@l = init (ltype l)\n\ngoal (1 subgoal):\n 1. \\<not> alive (ref l) (s\\<langle>t\\<rangle>) \\<Longrightarrow>\n    s\\<langle>t\\<rangle>@@l = s@@l", "moreover"], ["proof (state)\nthis:\n  s\\<langle>t\\<rangle>@@l = init (ltype l)\n\ngoal (1 subgoal):\n 1. \\<not> alive (ref l) (s\\<langle>t\\<rangle>) \\<Longrightarrow>\n    s\\<langle>t\\<rangle>@@l = s@@l", "from False"], ["proof (chain)\npicking this:\n  \\<not> alive (ref l) (s\\<langle>t\\<rangle>)", "have \"\\<not> alive (ref l) s\""], ["proof (prove)\nusing this:\n  \\<not> alive (ref l) (s\\<langle>t\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<not> alive (ref l) s", "by (auto simp add: alive_alloc_propagation)"], ["proof (state)\nthis:\n  \\<not> alive (ref l) s\n\ngoal (1 subgoal):\n 1. \\<not> alive (ref l) (s\\<langle>t\\<rangle>) \\<Longrightarrow>\n    s\\<langle>t\\<rangle>@@l = s@@l", "hence \"s@@l = init (ltype l)\""], ["proof (prove)\nusing this:\n  \\<not> alive (ref l) s\n\ngoal (1 subgoal):\n 1. s@@l = init (ltype l)", "by simp"], ["proof (state)\nthis:\n  s@@l = init (ltype l)\n\ngoal (1 subgoal):\n 1. \\<not> alive (ref l) (s\\<langle>t\\<rangle>) \\<Longrightarrow>\n    s\\<langle>t\\<rangle>@@l = s@@l", "ultimately"], ["proof (chain)\npicking this:\n  s\\<langle>t\\<rangle>@@l = init (ltype l)\n  s@@l = init (ltype l)", "show ?thesis"], ["proof (prove)\nusing this:\n  s\\<langle>t\\<rangle>@@l = init (ltype l)\n  s@@l = init (ltype l)\n\ngoal (1 subgoal):\n 1. s\\<langle>t\\<rangle>@@l = s@@l", "by simp"], ["proof (state)\nthis:\n  s\\<langle>t\\<rangle>@@l = s@@l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s\\<langle>t\\<rangle>@@l = s@@l\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Store13\\<close>"], ["", "lemma Store_eqI: \n  assumes eq_alive: \"\\<forall> x. alive x s1 = alive x s2\" \n  assumes eq_access: \"\\<forall> l. s1@@l = s2@@l\"\n  shows \"s1=s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s1 = s2", "proof (cases \"s1=s2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. s1 = s2 \\<Longrightarrow> s1 = s2\n 2. s1 \\<noteq> s2 \\<Longrightarrow> s1 = s2", "case True"], ["proof (state)\nthis:\n  s1 = s2\n\ngoal (2 subgoals):\n 1. s1 = s2 \\<Longrightarrow> s1 = s2\n 2. s1 \\<noteq> s2 \\<Longrightarrow> s1 = s2", "thus ?thesis"], ["proof (prove)\nusing this:\n  s1 = s2\n\ngoal (1 subgoal):\n 1. s1 = s2", "."], ["proof (state)\nthis:\n  s1 = s2\n\ngoal (1 subgoal):\n 1. s1 \\<noteq> s2 \\<Longrightarrow> s1 = s2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s1 \\<noteq> s2 \\<Longrightarrow> s1 = s2", "case False"], ["proof (state)\nthis:\n  s1 \\<noteq> s2\n\ngoal (1 subgoal):\n 1. s1 \\<noteq> s2 \\<Longrightarrow> s1 = s2", "note neq_s1_s2 = this"], ["proof (state)\nthis:\n  s1 \\<noteq> s2\n\ngoal (1 subgoal):\n 1. s1 \\<noteq> s2 \\<Longrightarrow> s1 = s2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s1 = s2", "proof (cases \"newOID (Rep_Store s1) = newOID (Rep_Store s2)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. newOID (Rep_Store s1) = newOID (Rep_Store s2) \\<Longrightarrow> s1 = s2\n 2. newOID (Rep_Store s1) \\<noteq> newOID (Rep_Store s2) \\<Longrightarrow>\n    s1 = s2", "case False"], ["proof (state)\nthis:\n  newOID (Rep_Store s1) \\<noteq> newOID (Rep_Store s2)\n\ngoal (2 subgoals):\n 1. newOID (Rep_Store s1) = newOID (Rep_Store s2) \\<Longrightarrow> s1 = s2\n 2. newOID (Rep_Store s1) \\<noteq> newOID (Rep_Store s2) \\<Longrightarrow>\n    s1 = s2", "have \"\\<exists> C. newOID (Rep_Store s1) C \\<noteq> newOID (Rep_Store s2) C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C. newOID (Rep_Store s1) C \\<noteq> newOID (Rep_Store s2) C", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>C.\n       newOID (Rep_Store s1) C \\<noteq>\n       newOID (Rep_Store s2) C \\<Longrightarrow>\n    False", "assume \"\\<not> (\\<exists>C. newOID (Rep_Store s1) C \\<noteq> newOID (Rep_Store s2) C)\""], ["proof (state)\nthis:\n  \\<nexists>C. newOID (Rep_Store s1) C \\<noteq> newOID (Rep_Store s2) C\n\ngoal (1 subgoal):\n 1. \\<nexists>C.\n       newOID (Rep_Store s1) C \\<noteq>\n       newOID (Rep_Store s2) C \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<nexists>C. newOID (Rep_Store s1) C \\<noteq> newOID (Rep_Store s2) C", "have \"newOID (Rep_Store s1) = newOID (Rep_Store s2)\""], ["proof (prove)\nusing this:\n  \\<nexists>C. newOID (Rep_Store s1) C \\<noteq> newOID (Rep_Store s2) C\n\ngoal (1 subgoal):\n 1. newOID (Rep_Store s1) = newOID (Rep_Store s2)", "by (blast intro: ext)"], ["proof (state)\nthis:\n  newOID (Rep_Store s1) = newOID (Rep_Store s2)\n\ngoal (1 subgoal):\n 1. \\<nexists>C.\n       newOID (Rep_Store s1) C \\<noteq>\n       newOID (Rep_Store s2) C \\<Longrightarrow>\n    False", "with False"], ["proof (chain)\npicking this:\n  newOID (Rep_Store s1) \\<noteq> newOID (Rep_Store s2)\n  newOID (Rep_Store s1) = newOID (Rep_Store s2)", "show False"], ["proof (prove)\nusing this:\n  newOID (Rep_Store s1) \\<noteq> newOID (Rep_Store s2)\n  newOID (Rep_Store s1) = newOID (Rep_Store s2)\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>C. newOID (Rep_Store s1) C \\<noteq> newOID (Rep_Store s2) C\n\ngoal (2 subgoals):\n 1. newOID (Rep_Store s1) = newOID (Rep_Store s2) \\<Longrightarrow> s1 = s2\n 2. newOID (Rep_Store s1) \\<noteq> newOID (Rep_Store s2) \\<Longrightarrow>\n    s1 = s2", "with eq_alive"], ["proof (chain)\npicking this:\n  \\<forall>x. alive x s1 = alive x s2\n  \\<exists>C. newOID (Rep_Store s1) C \\<noteq> newOID (Rep_Store s2) C", "obtain C \n      where \"newOID (Rep_Store s1) C \\<noteq> newOID (Rep_Store s2) C\"\n            \"\\<forall> a. alive (objV C a) s1 = alive (objV C a) s2\""], ["proof (prove)\nusing this:\n  \\<forall>x. alive x s1 = alive x s2\n  \\<exists>C. newOID (Rep_Store s1) C \\<noteq> newOID (Rep_Store s2) C\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>newOID (Rep_Store s1) C \\<noteq> newOID (Rep_Store s2) C;\n         \\<forall>a. alive (objV C a) s1 = alive (objV C a) s2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  newOID (Rep_Store s1) C \\<noteq> newOID (Rep_Store s2) C\n  \\<forall>a. alive (objV C a) s1 = alive (objV C a) s2\n\ngoal (2 subgoals):\n 1. newOID (Rep_Store s1) = newOID (Rep_Store s2) \\<Longrightarrow> s1 = s2\n 2. newOID (Rep_Store s1) \\<noteq> newOID (Rep_Store s2) \\<Longrightarrow>\n    s1 = s2", "then"], ["proof (chain)\npicking this:\n  newOID (Rep_Store s1) C \\<noteq> newOID (Rep_Store s2) C\n  \\<forall>a. alive (objV C a) s1 = alive (objV C a) s2", "show ?thesis"], ["proof (prove)\nusing this:\n  newOID (Rep_Store s1) C \\<noteq> newOID (Rep_Store s2) C\n  \\<forall>a. alive (objV C a) s1 = alive (objV C a) s2\n\ngoal (1 subgoal):\n 1. s1 = s2", "by (simp add: all_le_eq alive_def aliveImpl_def)"], ["proof (state)\nthis:\n  s1 = s2\n\ngoal (1 subgoal):\n 1. newOID (Rep_Store s1) = newOID (Rep_Store s2) \\<Longrightarrow> s1 = s2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. newOID (Rep_Store s1) = newOID (Rep_Store s2) \\<Longrightarrow> s1 = s2", "case True"], ["proof (state)\nthis:\n  newOID (Rep_Store s1) = newOID (Rep_Store s2)\n\ngoal (1 subgoal):\n 1. newOID (Rep_Store s1) = newOID (Rep_Store s2) \\<Longrightarrow> s1 = s2", "note eq_newOID = this"], ["proof (state)\nthis:\n  newOID (Rep_Store s1) = newOID (Rep_Store s2)\n\ngoal (1 subgoal):\n 1. newOID (Rep_Store s1) = newOID (Rep_Store s2) \\<Longrightarrow> s1 = s2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s1 = s2", "proof (cases \"newAID (Rep_Store s1) = newAID (Rep_Store s2)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. newAID (Rep_Store s1) = newAID (Rep_Store s2) \\<Longrightarrow> s1 = s2\n 2. newAID (Rep_Store s1) \\<noteq> newAID (Rep_Store s2) \\<Longrightarrow>\n    s1 = s2", "case False"], ["proof (state)\nthis:\n  newAID (Rep_Store s1) \\<noteq> newAID (Rep_Store s2)\n\ngoal (2 subgoals):\n 1. newAID (Rep_Store s1) = newAID (Rep_Store s2) \\<Longrightarrow> s1 = s2\n 2. newAID (Rep_Store s1) \\<noteq> newAID (Rep_Store s2) \\<Longrightarrow>\n    s1 = s2", "have \"\\<exists> T. newAID (Rep_Store s1) T \\<noteq> newAID (Rep_Store s2) T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T. newAID (Rep_Store s1) T \\<noteq> newAID (Rep_Store s2) T", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>T.\n       newAID (Rep_Store s1) T \\<noteq>\n       newAID (Rep_Store s2) T \\<Longrightarrow>\n    False", "assume \"\\<not> (\\<exists>T. newAID (Rep_Store s1) T \\<noteq> newAID (Rep_Store s2) T)\""], ["proof (state)\nthis:\n  \\<nexists>T. newAID (Rep_Store s1) T \\<noteq> newAID (Rep_Store s2) T\n\ngoal (1 subgoal):\n 1. \\<nexists>T.\n       newAID (Rep_Store s1) T \\<noteq>\n       newAID (Rep_Store s2) T \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<nexists>T. newAID (Rep_Store s1) T \\<noteq> newAID (Rep_Store s2) T", "have \"newAID (Rep_Store s1) = newAID (Rep_Store s2)\""], ["proof (prove)\nusing this:\n  \\<nexists>T. newAID (Rep_Store s1) T \\<noteq> newAID (Rep_Store s2) T\n\ngoal (1 subgoal):\n 1. newAID (Rep_Store s1) = newAID (Rep_Store s2)", "by (blast intro: ext)"], ["proof (state)\nthis:\n  newAID (Rep_Store s1) = newAID (Rep_Store s2)\n\ngoal (1 subgoal):\n 1. \\<nexists>T.\n       newAID (Rep_Store s1) T \\<noteq>\n       newAID (Rep_Store s2) T \\<Longrightarrow>\n    False", "with False"], ["proof (chain)\npicking this:\n  newAID (Rep_Store s1) \\<noteq> newAID (Rep_Store s2)\n  newAID (Rep_Store s1) = newAID (Rep_Store s2)", "show False"], ["proof (prove)\nusing this:\n  newAID (Rep_Store s1) \\<noteq> newAID (Rep_Store s2)\n  newAID (Rep_Store s1) = newAID (Rep_Store s2)\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>T. newAID (Rep_Store s1) T \\<noteq> newAID (Rep_Store s2) T\n\ngoal (2 subgoals):\n 1. newAID (Rep_Store s1) = newAID (Rep_Store s2) \\<Longrightarrow> s1 = s2\n 2. newAID (Rep_Store s1) \\<noteq> newAID (Rep_Store s2) \\<Longrightarrow>\n    s1 = s2", "with eq_alive"], ["proof (chain)\npicking this:\n  \\<forall>x. alive x s1 = alive x s2\n  \\<exists>T. newAID (Rep_Store s1) T \\<noteq> newAID (Rep_Store s2) T", "obtain T \n        where \"newAID (Rep_Store s1) T \\<noteq> newAID (Rep_Store s2) T\"\n              \"\\<forall> a. alive (arrV T a) s1 = alive (arrV T a) s2\""], ["proof (prove)\nusing this:\n  \\<forall>x. alive x s1 = alive x s2\n  \\<exists>T. newAID (Rep_Store s1) T \\<noteq> newAID (Rep_Store s2) T\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>newAID (Rep_Store s1) T \\<noteq> newAID (Rep_Store s2) T;\n         \\<forall>a. alive (arrV T a) s1 = alive (arrV T a) s2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  newAID (Rep_Store s1) T \\<noteq> newAID (Rep_Store s2) T\n  \\<forall>a. alive (arrV T a) s1 = alive (arrV T a) s2\n\ngoal (2 subgoals):\n 1. newAID (Rep_Store s1) = newAID (Rep_Store s2) \\<Longrightarrow> s1 = s2\n 2. newAID (Rep_Store s1) \\<noteq> newAID (Rep_Store s2) \\<Longrightarrow>\n    s1 = s2", "then"], ["proof (chain)\npicking this:\n  newAID (Rep_Store s1) T \\<noteq> newAID (Rep_Store s2) T\n  \\<forall>a. alive (arrV T a) s1 = alive (arrV T a) s2", "show ?thesis"], ["proof (prove)\nusing this:\n  newAID (Rep_Store s1) T \\<noteq> newAID (Rep_Store s2) T\n  \\<forall>a. alive (arrV T a) s1 = alive (arrV T a) s2\n\ngoal (1 subgoal):\n 1. s1 = s2", "by (simp add: all_le_eq alive_def aliveImpl_def)"], ["proof (state)\nthis:\n  s1 = s2\n\ngoal (1 subgoal):\n 1. newAID (Rep_Store s1) = newAID (Rep_Store s2) \\<Longrightarrow> s1 = s2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. newAID (Rep_Store s1) = newAID (Rep_Store s2) \\<Longrightarrow> s1 = s2", "case True"], ["proof (state)\nthis:\n  newAID (Rep_Store s1) = newAID (Rep_Store s2)\n\ngoal (1 subgoal):\n 1. newAID (Rep_Store s1) = newAID (Rep_Store s2) \\<Longrightarrow> s1 = s2", "note eq_newAID = this"], ["proof (state)\nthis:\n  newAID (Rep_Store s1) = newAID (Rep_Store s2)\n\ngoal (1 subgoal):\n 1. newAID (Rep_Store s1) = newAID (Rep_Store s2) \\<Longrightarrow> s1 = s2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s1 = s2", "proof (cases \"vals (Rep_Store s1) = vals (Rep_Store s2)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. vals (Rep_Store s1) = vals (Rep_Store s2) \\<Longrightarrow> s1 = s2\n 2. vals (Rep_Store s1) \\<noteq> vals (Rep_Store s2) \\<Longrightarrow>\n    s1 = s2", "case True"], ["proof (state)\nthis:\n  vals (Rep_Store s1) = vals (Rep_Store s2)\n\ngoal (2 subgoals):\n 1. vals (Rep_Store s1) = vals (Rep_Store s2) \\<Longrightarrow> s1 = s2\n 2. vals (Rep_Store s1) \\<noteq> vals (Rep_Store s2) \\<Longrightarrow>\n    s1 = s2", "with eq_newOID eq_newAID"], ["proof (chain)\npicking this:\n  newOID (Rep_Store s1) = newOID (Rep_Store s2)\n  newAID (Rep_Store s1) = newAID (Rep_Store s2)\n  vals (Rep_Store s1) = vals (Rep_Store s2)", "have \"(Rep_Store s1) = (Rep_Store s2)\""], ["proof (prove)\nusing this:\n  newOID (Rep_Store s1) = newOID (Rep_Store s2)\n  newAID (Rep_Store s1) = newAID (Rep_Store s2)\n  vals (Rep_Store s1) = vals (Rep_Store s2)\n\ngoal (1 subgoal):\n 1. Rep_Store s1 = Rep_Store s2", "by (cases \"Rep_Store s1\",cases \"Rep_Store s2\") simp"], ["proof (state)\nthis:\n  Rep_Store s1 = Rep_Store s2\n\ngoal (2 subgoals):\n 1. vals (Rep_Store s1) = vals (Rep_Store s2) \\<Longrightarrow> s1 = s2\n 2. vals (Rep_Store s1) \\<noteq> vals (Rep_Store s2) \\<Longrightarrow>\n    s1 = s2", "hence \"s1=s2\""], ["proof (prove)\nusing this:\n  Rep_Store s1 = Rep_Store s2\n\ngoal (1 subgoal):\n 1. s1 = s2", "by (simp add: Rep_Store_inject)"], ["proof (state)\nthis:\n  s1 = s2\n\ngoal (2 subgoals):\n 1. vals (Rep_Store s1) = vals (Rep_Store s2) \\<Longrightarrow> s1 = s2\n 2. vals (Rep_Store s1) \\<noteq> vals (Rep_Store s2) \\<Longrightarrow>\n    s1 = s2", "with neq_s1_s2"], ["proof (chain)\npicking this:\n  s1 \\<noteq> s2\n  s1 = s2", "show ?thesis"], ["proof (prove)\nusing this:\n  s1 \\<noteq> s2\n  s1 = s2\n\ngoal (1 subgoal):\n 1. s1 = s2", "by simp"], ["proof (state)\nthis:\n  s1 = s2\n\ngoal (1 subgoal):\n 1. vals (Rep_Store s1) \\<noteq> vals (Rep_Store s2) \\<Longrightarrow>\n    s1 = s2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. vals (Rep_Store s1) \\<noteq> vals (Rep_Store s2) \\<Longrightarrow>\n    s1 = s2", "case False"], ["proof (state)\nthis:\n  vals (Rep_Store s1) \\<noteq> vals (Rep_Store s2)\n\ngoal (1 subgoal):\n 1. vals (Rep_Store s1) \\<noteq> vals (Rep_Store s2) \\<Longrightarrow>\n    s1 = s2", "have \"\\<exists> l. vals (Rep_Store s1) l \\<noteq> vals (Rep_Store s2) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l. vals (Rep_Store s1) l \\<noteq> vals (Rep_Store s2) l", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>l.\n       vals (Rep_Store s1) l \\<noteq>\n       vals (Rep_Store s2) l \\<Longrightarrow>\n    False", "assume \"\\<not> (\\<exists>l. vals (Rep_Store s1) l \\<noteq> vals (Rep_Store s2) l)\""], ["proof (state)\nthis:\n  \\<nexists>l. vals (Rep_Store s1) l \\<noteq> vals (Rep_Store s2) l\n\ngoal (1 subgoal):\n 1. \\<nexists>l.\n       vals (Rep_Store s1) l \\<noteq>\n       vals (Rep_Store s2) l \\<Longrightarrow>\n    False", "hence \"vals (Rep_Store s1) = vals (Rep_Store s2)\""], ["proof (prove)\nusing this:\n  \\<nexists>l. vals (Rep_Store s1) l \\<noteq> vals (Rep_Store s2) l\n\ngoal (1 subgoal):\n 1. vals (Rep_Store s1) = vals (Rep_Store s2)", "by (blast intro: ext)"], ["proof (state)\nthis:\n  vals (Rep_Store s1) = vals (Rep_Store s2)\n\ngoal (1 subgoal):\n 1. \\<nexists>l.\n       vals (Rep_Store s1) l \\<noteq>\n       vals (Rep_Store s2) l \\<Longrightarrow>\n    False", "with False"], ["proof (chain)\npicking this:\n  vals (Rep_Store s1) \\<noteq> vals (Rep_Store s2)\n  vals (Rep_Store s1) = vals (Rep_Store s2)", "show False"], ["proof (prove)\nusing this:\n  vals (Rep_Store s1) \\<noteq> vals (Rep_Store s2)\n  vals (Rep_Store s1) = vals (Rep_Store s2)\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>l. vals (Rep_Store s1) l \\<noteq> vals (Rep_Store s2) l\n\ngoal (1 subgoal):\n 1. vals (Rep_Store s1) \\<noteq> vals (Rep_Store s2) \\<Longrightarrow>\n    s1 = s2", "then"], ["proof (chain)\npicking this:\n  \\<exists>l. vals (Rep_Store s1) l \\<noteq> vals (Rep_Store s2) l", "obtain l\n          where \"vals (Rep_Store s1) l \\<noteq> vals (Rep_Store s2) l\""], ["proof (prove)\nusing this:\n  \\<exists>l. vals (Rep_Store s1) l \\<noteq> vals (Rep_Store s2) l\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        vals (Rep_Store s1) l \\<noteq>\n        vals (Rep_Store s2) l \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  vals (Rep_Store s1) l \\<noteq> vals (Rep_Store s2) l\n\ngoal (1 subgoal):\n 1. vals (Rep_Store s1) \\<noteq> vals (Rep_Store s2) \\<Longrightarrow>\n    s1 = s2", "with eq_access"], ["proof (chain)\npicking this:\n  \\<forall>l. s1@@l = s2@@l\n  vals (Rep_Store s1) l \\<noteq> vals (Rep_Store s2) l", "have \"False\""], ["proof (prove)\nusing this:\n  \\<forall>l. s1@@l = s2@@l\n  vals (Rep_Store s1) l \\<noteq> vals (Rep_Store s2) l\n\ngoal (1 subgoal):\n 1. False", "by (simp add: access_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. vals (Rep_Store s1) \\<noteq> vals (Rep_Store s2) \\<Longrightarrow>\n    s1 = s2", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. s1 = s2", ".."], ["proof (state)\nthis:\n  s1 = s2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s1 = s2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s1 = s2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s1 = s2\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Lemma 3.1 in [Poetzsch-Heffter97]. The proof of this lemma is quite an\nimpressive demostration of readable Isar proofs since it closely follows the\ntextual proof.\\<close>"], ["", "lemma comm: \n  assumes neq_l_new: \"ref l \\<noteq> new s t\"\n  assumes neq_x_new: \"x \\<noteq> new s t\"\n  shows \"s\\<langle>t\\<rangle>\\<langle>l:=x\\<rangle> = s\\<langle>l:=x\\<rangle>\\<langle>t\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<langle>t, l := x\\<rangle> = s\\<langle>l := x, t\\<rangle>", "proof (rule Store_eqI [rule_format])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       alive xa (s\\<langle>t, l := x\\<rangle>) =\n       alive xa (s\\<langle>l := x, t\\<rangle>)\n 2. \\<And>la.\n       s\\<langle>t, l := x\\<rangle>@@la = s\\<langle>l := x, t\\<rangle>@@la", "fix y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       alive xa (s\\<langle>t, l := x\\<rangle>) =\n       alive xa (s\\<langle>l := x, t\\<rangle>)\n 2. \\<And>la.\n       s\\<langle>t, l := x\\<rangle>@@la = s\\<langle>l := x, t\\<rangle>@@la", "show \"alive y (s\\<langle>t\\<rangle>\\<langle>l:=x\\<rangle>) = alive y (s\\<langle>l:=x\\<rangle>\\<langle>t\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alive y (s\\<langle>t, l := x\\<rangle>) =\n    alive y (s\\<langle>l := x, t\\<rangle>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. alive y (s\\<langle>t, l := x\\<rangle>) =\n    alive y (s\\<langle>l := x, t\\<rangle>)", "have \"alive y (s\\<langle>t\\<rangle>\\<langle>l:=x\\<rangle>) = alive y (s\\<langle>t\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alive y (s\\<langle>t, l := x\\<rangle>) = alive y (s\\<langle>t\\<rangle>)", "by (rule alive_update_invariant)"], ["proof (state)\nthis:\n  alive y (s\\<langle>t, l := x\\<rangle>) = alive y (s\\<langle>t\\<rangle>)\n\ngoal (1 subgoal):\n 1. alive y (s\\<langle>t, l := x\\<rangle>) =\n    alive y (s\\<langle>l := x, t\\<rangle>)", "also"], ["proof (state)\nthis:\n  alive y (s\\<langle>t, l := x\\<rangle>) = alive y (s\\<langle>t\\<rangle>)\n\ngoal (1 subgoal):\n 1. alive y (s\\<langle>t, l := x\\<rangle>) =\n    alive y (s\\<langle>l := x, t\\<rangle>)", "have \"\\<dots> = (alive y s \\<or> (y = new s t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alive y (s\\<langle>t\\<rangle>) = (alive y s \\<or> y = new s t)", "by (rule alive_alloc_exhaust)"], ["proof (state)\nthis:\n  alive y (s\\<langle>t\\<rangle>) = (alive y s \\<or> y = new s t)\n\ngoal (1 subgoal):\n 1. alive y (s\\<langle>t, l := x\\<rangle>) =\n    alive y (s\\<langle>l := x, t\\<rangle>)", "also"], ["proof (state)\nthis:\n  alive y (s\\<langle>t\\<rangle>) = (alive y s \\<or> y = new s t)\n\ngoal (1 subgoal):\n 1. alive y (s\\<langle>t, l := x\\<rangle>) =\n    alive y (s\\<langle>l := x, t\\<rangle>)", "have \"\\<dots> = (alive y (s\\<langle>l:=x\\<rangle>) \\<or> y = new s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (alive y s \\<or> y = new s t) =\n    (alive y (s\\<langle>l := x\\<rangle>) \\<or> y = new s t)", "by (simp only: alive_update_invariant)"], ["proof (state)\nthis:\n  (alive y s \\<or> y = new s t) =\n  (alive y (s\\<langle>l := x\\<rangle>) \\<or> y = new s t)\n\ngoal (1 subgoal):\n 1. alive y (s\\<langle>t, l := x\\<rangle>) =\n    alive y (s\\<langle>l := x, t\\<rangle>)", "also"], ["proof (state)\nthis:\n  (alive y s \\<or> y = new s t) =\n  (alive y (s\\<langle>l := x\\<rangle>) \\<or> y = new s t)\n\ngoal (1 subgoal):\n 1. alive y (s\\<langle>t, l := x\\<rangle>) =\n    alive y (s\\<langle>l := x, t\\<rangle>)", "have \"\\<dots> = (alive y (s\\<langle>l:=x\\<rangle>) \\<or> y = new (s\\<langle>l:=x\\<rangle>) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (alive y (s\\<langle>l := x\\<rangle>) \\<or> y = new s t) =\n    (alive y (s\\<langle>l := x\\<rangle>) \\<or>\n     y = new (s\\<langle>l := x\\<rangle>) t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (alive y (s\\<langle>l := x\\<rangle>) \\<or> y = new s t) =\n    (alive y (s\\<langle>l := x\\<rangle>) \\<or>\n     y = new (s\\<langle>l := x\\<rangle>) t)", "have \"new s t = new (s\\<langle>l:=x\\<rangle>) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new s t = new (s\\<langle>l := x\\<rangle>) t", "by simp"], ["proof (state)\nthis:\n  new s t = new (s\\<langle>l := x\\<rangle>) t\n\ngoal (1 subgoal):\n 1. (alive y (s\\<langle>l := x\\<rangle>) \\<or> y = new s t) =\n    (alive y (s\\<langle>l := x\\<rangle>) \\<or>\n     y = new (s\\<langle>l := x\\<rangle>) t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  new s t = new (s\\<langle>l := x\\<rangle>) t\n\ngoal (1 subgoal):\n 1. (alive y (s\\<langle>l := x\\<rangle>) \\<or> y = new s t) =\n    (alive y (s\\<langle>l := x\\<rangle>) \\<or>\n     y = new (s\\<langle>l := x\\<rangle>) t)", "by simp"], ["proof (state)\nthis:\n  (alive y (s\\<langle>l := x\\<rangle>) \\<or> y = new s t) =\n  (alive y (s\\<langle>l := x\\<rangle>) \\<or>\n   y = new (s\\<langle>l := x\\<rangle>) t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (alive y (s\\<langle>l := x\\<rangle>) \\<or> y = new s t) =\n  (alive y (s\\<langle>l := x\\<rangle>) \\<or>\n   y = new (s\\<langle>l := x\\<rangle>) t)\n\ngoal (1 subgoal):\n 1. alive y (s\\<langle>t, l := x\\<rangle>) =\n    alive y (s\\<langle>l := x, t\\<rangle>)", "also"], ["proof (state)\nthis:\n  (alive y (s\\<langle>l := x\\<rangle>) \\<or> y = new s t) =\n  (alive y (s\\<langle>l := x\\<rangle>) \\<or>\n   y = new (s\\<langle>l := x\\<rangle>) t)\n\ngoal (1 subgoal):\n 1. alive y (s\\<langle>t, l := x\\<rangle>) =\n    alive y (s\\<langle>l := x, t\\<rangle>)", "have \"\\<dots> = alive y (s\\<langle>l:=x\\<rangle>\\<langle>t\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (alive y (s\\<langle>l := x\\<rangle>) \\<or>\n     y = new (s\\<langle>l := x\\<rangle>) t) =\n    alive y (s\\<langle>l := x, t\\<rangle>)", "by (simp add: alive_alloc_exhaust)"], ["proof (state)\nthis:\n  (alive y (s\\<langle>l := x\\<rangle>) \\<or>\n   y = new (s\\<langle>l := x\\<rangle>) t) =\n  alive y (s\\<langle>l := x, t\\<rangle>)\n\ngoal (1 subgoal):\n 1. alive y (s\\<langle>t, l := x\\<rangle>) =\n    alive y (s\\<langle>l := x, t\\<rangle>)", "finally"], ["proof (chain)\npicking this:\n  alive y (s\\<langle>t, l := x\\<rangle>) =\n  alive y (s\\<langle>l := x, t\\<rangle>)", "show ?thesis"], ["proof (prove)\nusing this:\n  alive y (s\\<langle>t, l := x\\<rangle>) =\n  alive y (s\\<langle>l := x, t\\<rangle>)\n\ngoal (1 subgoal):\n 1. alive y (s\\<langle>t, l := x\\<rangle>) =\n    alive y (s\\<langle>l := x, t\\<rangle>)", "."], ["proof (state)\nthis:\n  alive y (s\\<langle>t, l := x\\<rangle>) =\n  alive y (s\\<langle>l := x, t\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  alive y (s\\<langle>t, l := x\\<rangle>) =\n  alive y (s\\<langle>l := x, t\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<And>la.\n       s\\<langle>t, l := x\\<rangle>@@la = s\\<langle>l := x, t\\<rangle>@@la", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>la.\n       s\\<langle>t, l := x\\<rangle>@@la = s\\<langle>l := x, t\\<rangle>@@la", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>la.\n       s\\<langle>t, l := x\\<rangle>@@la = s\\<langle>l := x, t\\<rangle>@@la", "show \"s\\<langle>t\\<rangle>\\<langle>l := x\\<rangle>@@k = s\\<langle>l := x\\<rangle>\\<langle>t\\<rangle>@@k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "proof (cases \"l=k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l = k \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n 2. l \\<noteq> k \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "case False"], ["proof (state)\nthis:\n  l \\<noteq> k\n\ngoal (2 subgoals):\n 1. l = k \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n 2. l \\<noteq> k \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "note neq_l_k = this"], ["proof (state)\nthis:\n  l \\<noteq> k\n\ngoal (2 subgoals):\n 1. l = k \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n 2. l \\<noteq> k \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "proof (cases \"isNewArr t \\<longrightarrow> k \\<noteq> arr_len (new s t)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. isNewArr t \\<longrightarrow>\n    k \\<noteq> arr_len (new s t) \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n 2. \\<not> (isNewArr t \\<longrightarrow>\n            k \\<noteq> arr_len (new s t)) \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "case True"], ["proof (state)\nthis:\n  isNewArr t \\<longrightarrow> k \\<noteq> arr_len (new s t)\n\ngoal (2 subgoals):\n 1. isNewArr t \\<longrightarrow>\n    k \\<noteq> arr_len (new s t) \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n 2. \\<not> (isNewArr t \\<longrightarrow>\n            k \\<noteq> arr_len (new s t)) \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "from neq_l_k"], ["proof (chain)\npicking this:\n  l \\<noteq> k", "have  \"s\\<langle>t\\<rangle>\\<langle>l := x\\<rangle>@@k = s\\<langle>t\\<rangle>@@k\""], ["proof (prove)\nusing this:\n  l \\<noteq> k\n\ngoal (1 subgoal):\n 1. s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>t\\<rangle>@@k", "by simp"], ["proof (state)\nthis:\n  s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>t\\<rangle>@@k\n\ngoal (2 subgoals):\n 1. isNewArr t \\<longrightarrow>\n    k \\<noteq> arr_len (new s t) \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n 2. \\<not> (isNewArr t \\<longrightarrow>\n            k \\<noteq> arr_len (new s t)) \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "also"], ["proof (state)\nthis:\n  s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>t\\<rangle>@@k\n\ngoal (2 subgoals):\n 1. isNewArr t \\<longrightarrow>\n    k \\<noteq> arr_len (new s t) \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n 2. \\<not> (isNewArr t \\<longrightarrow>\n            k \\<noteq> arr_len (new s t)) \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "from True"], ["proof (chain)\npicking this:\n  isNewArr t \\<longrightarrow> k \\<noteq> arr_len (new s t)", "have \"\\<dots> = s@@k\""], ["proof (prove)\nusing this:\n  isNewArr t \\<longrightarrow> k \\<noteq> arr_len (new s t)\n\ngoal (1 subgoal):\n 1. s\\<langle>t\\<rangle>@@k = s@@k", "by simp"], ["proof (state)\nthis:\n  s\\<langle>t\\<rangle>@@k = s@@k\n\ngoal (2 subgoals):\n 1. isNewArr t \\<longrightarrow>\n    k \\<noteq> arr_len (new s t) \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n 2. \\<not> (isNewArr t \\<longrightarrow>\n            k \\<noteq> arr_len (new s t)) \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "also"], ["proof (state)\nthis:\n  s\\<langle>t\\<rangle>@@k = s@@k\n\ngoal (2 subgoals):\n 1. isNewArr t \\<longrightarrow>\n    k \\<noteq> arr_len (new s t) \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n 2. \\<not> (isNewArr t \\<longrightarrow>\n            k \\<noteq> arr_len (new s t)) \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "from neq_l_k"], ["proof (chain)\npicking this:\n  l \\<noteq> k", "have \"\\<dots> = s\\<langle>l:=x\\<rangle>@@k\""], ["proof (prove)\nusing this:\n  l \\<noteq> k\n\ngoal (1 subgoal):\n 1. s@@k = s\\<langle>l := x\\<rangle>@@k", "by simp"], ["proof (state)\nthis:\n  s@@k = s\\<langle>l := x\\<rangle>@@k\n\ngoal (2 subgoals):\n 1. isNewArr t \\<longrightarrow>\n    k \\<noteq> arr_len (new s t) \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n 2. \\<not> (isNewArr t \\<longrightarrow>\n            k \\<noteq> arr_len (new s t)) \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "also"], ["proof (state)\nthis:\n  s@@k = s\\<langle>l := x\\<rangle>@@k\n\ngoal (2 subgoals):\n 1. isNewArr t \\<longrightarrow>\n    k \\<noteq> arr_len (new s t) \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n 2. \\<not> (isNewArr t \\<longrightarrow>\n            k \\<noteq> arr_len (new s t)) \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "from True"], ["proof (chain)\npicking this:\n  isNewArr t \\<longrightarrow> k \\<noteq> arr_len (new s t)", "have \"\\<dots> = s\\<langle>l := x\\<rangle>\\<langle>t\\<rangle>@@k\""], ["proof (prove)\nusing this:\n  isNewArr t \\<longrightarrow> k \\<noteq> arr_len (new s t)\n\ngoal (1 subgoal):\n 1. s\\<langle>l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "by simp"], ["proof (state)\nthis:\n  s\\<langle>l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n\ngoal (2 subgoals):\n 1. isNewArr t \\<longrightarrow>\n    k \\<noteq> arr_len (new s t) \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n 2. \\<not> (isNewArr t \\<longrightarrow>\n            k \\<noteq> arr_len (new s t)) \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "finally"], ["proof (chain)\npicking this:\n  s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "show ?thesis"], ["proof (prove)\nusing this:\n  s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n\ngoal (1 subgoal):\n 1. s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "."], ["proof (state)\nthis:\n  s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n\ngoal (1 subgoal):\n 1. \\<not> (isNewArr t \\<longrightarrow>\n            k \\<noteq> arr_len (new s t)) \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (isNewArr t \\<longrightarrow>\n            k \\<noteq> arr_len (new s t)) \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "case False"], ["proof (state)\nthis:\n  \\<not> (isNewArr t \\<longrightarrow> k \\<noteq> arr_len (new s t))\n\ngoal (1 subgoal):\n 1. \\<not> (isNewArr t \\<longrightarrow>\n            k \\<noteq> arr_len (new s t)) \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "then"], ["proof (chain)\npicking this:\n  \\<not> (isNewArr t \\<longrightarrow> k \\<noteq> arr_len (new s t))", "obtain T n where \n        t: \"t=new_array T n\" and k: \"k=arr_len (new s (new_array T n))\""], ["proof (prove)\nusing this:\n  \\<not> (isNewArr t \\<longrightarrow> k \\<noteq> arr_len (new s t))\n\ngoal (1 subgoal):\n 1. (\\<And>T n.\n        \\<lbrakk>t = new_array T n;\n         k = arr_len (new s (new_array T n))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases t) auto"], ["proof (state)\nthis:\n  t = new_array T n\n  k = arr_len (new s (new_array T n))\n\ngoal (1 subgoal):\n 1. \\<not> (isNewArr t \\<longrightarrow>\n            k \\<noteq> arr_len (new s t)) \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "from k"], ["proof (chain)\npicking this:\n  k = arr_len (new s (new_array T n))", "have k': \"k=arr_len (new (s\\<langle>l := x\\<rangle>) (new_array T n))\""], ["proof (prove)\nusing this:\n  k = arr_len (new s (new_array T n))\n\ngoal (1 subgoal):\n 1. k = arr_len (new (s\\<langle>l := x\\<rangle>) (new_array T n))", "by simp"], ["proof (state)\nthis:\n  k = arr_len (new (s\\<langle>l := x\\<rangle>) (new_array T n))\n\ngoal (1 subgoal):\n 1. \\<not> (isNewArr t \\<longrightarrow>\n            k \\<noteq> arr_len (new s t)) \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "from neq_l_k"], ["proof (chain)\npicking this:\n  l \\<noteq> k", "have  \"s\\<langle>t\\<rangle>\\<langle>l := x\\<rangle>@@k = s\\<langle>t\\<rangle>@@k\""], ["proof (prove)\nusing this:\n  l \\<noteq> k\n\ngoal (1 subgoal):\n 1. s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>t\\<rangle>@@k", "by simp"], ["proof (state)\nthis:\n  s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>t\\<rangle>@@k\n\ngoal (1 subgoal):\n 1. \\<not> (isNewArr t \\<longrightarrow>\n            k \\<noteq> arr_len (new s t)) \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "also"], ["proof (state)\nthis:\n  s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>t\\<rangle>@@k\n\ngoal (1 subgoal):\n 1. \\<not> (isNewArr t \\<longrightarrow>\n            k \\<noteq> arr_len (new s t)) \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "from t k"], ["proof (chain)\npicking this:\n  t = new_array T n\n  k = arr_len (new s (new_array T n))", "have \"\\<dots> = intgV (int n)\""], ["proof (prove)\nusing this:\n  t = new_array T n\n  k = arr_len (new s (new_array T n))\n\ngoal (1 subgoal):\n 1. s\\<langle>t\\<rangle>@@k = intgV (int n)", "by simp"], ["proof (state)\nthis:\n  s\\<langle>t\\<rangle>@@k = intgV (int n)\n\ngoal (1 subgoal):\n 1. \\<not> (isNewArr t \\<longrightarrow>\n            k \\<noteq> arr_len (new s t)) \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "also"], ["proof (state)\nthis:\n  s\\<langle>t\\<rangle>@@k = intgV (int n)\n\ngoal (1 subgoal):\n 1. \\<not> (isNewArr t \\<longrightarrow>\n            k \\<noteq> arr_len (new s t)) \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "from t k'"], ["proof (chain)\npicking this:\n  t = new_array T n\n  k = arr_len (new (s\\<langle>l := x\\<rangle>) (new_array T n))", "have \"\\<dots> = s\\<langle>l := x\\<rangle>\\<langle>t\\<rangle>@@k\""], ["proof (prove)\nusing this:\n  t = new_array T n\n  k = arr_len (new (s\\<langle>l := x\\<rangle>) (new_array T n))\n\ngoal (1 subgoal):\n 1. intgV (int n) = s\\<langle>l := x, t\\<rangle>@@k", "by (simp del: new_update)"], ["proof (state)\nthis:\n  intgV (int n) = s\\<langle>l := x, t\\<rangle>@@k\n\ngoal (1 subgoal):\n 1. \\<not> (isNewArr t \\<longrightarrow>\n            k \\<noteq> arr_len (new s t)) \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "finally"], ["proof (chain)\npicking this:\n  s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "show ?thesis"], ["proof (prove)\nusing this:\n  s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n\ngoal (1 subgoal):\n 1. s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "."], ["proof (state)\nthis:\n  s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n\ngoal (1 subgoal):\n 1. l = k \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l = k \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "case True"], ["proof (state)\nthis:\n  l = k\n\ngoal (1 subgoal):\n 1. l = k \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "note eq_l_k = this"], ["proof (state)\nthis:\n  l = k\n\ngoal (1 subgoal):\n 1. l = k \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "have lemma_3_1: \n      \"ref l \\<noteq> new s t \\<Longrightarrow> alive (ref l) (s\\<langle>t\\<rangle>) = alive (ref l) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ref l \\<noteq> new s t \\<Longrightarrow>\n    alive (ref l) (s\\<langle>t\\<rangle>) = alive (ref l) s", "by (simp add: alive_alloc_exhaust)"], ["proof (state)\nthis:\n  ref l \\<noteq> new s t \\<Longrightarrow>\n  alive (ref l) (s\\<langle>t\\<rangle>) = alive (ref l) s\n\ngoal (1 subgoal):\n 1. l = k \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "have lemma_3_2: \n      \"x \\<noteq> new s t \\<Longrightarrow> alive x (s\\<langle>t\\<rangle>) = alive x s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> new s t \\<Longrightarrow>\n    alive x (s\\<langle>t\\<rangle>) = alive x s", "by (simp add: alive_alloc_exhaust)"], ["proof (state)\nthis:\n  x \\<noteq> new s t \\<Longrightarrow>\n  alive x (s\\<langle>t\\<rangle>) = alive x s\n\ngoal (1 subgoal):\n 1. l = k \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "have lemma_3_3: \"s\\<langle>l:=x,t\\<rangle>@@l = s\\<langle>l:=x\\<rangle>@@l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<langle>l := x, t\\<rangle>@@l = s\\<langle>l := x\\<rangle>@@l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s\\<langle>l := x, t\\<rangle>@@l = s\\<langle>l := x\\<rangle>@@l", "from neq_l_new"], ["proof (chain)\npicking this:\n  ref l \\<noteq> new s t", "have \"ref l \\<noteq> new (s\\<langle>l:=x\\<rangle>) t\""], ["proof (prove)\nusing this:\n  ref l \\<noteq> new s t\n\ngoal (1 subgoal):\n 1. ref l \\<noteq> new (s\\<langle>l := x\\<rangle>) t", "by simp"], ["proof (state)\nthis:\n  ref l \\<noteq> new (s\\<langle>l := x\\<rangle>) t\n\ngoal (1 subgoal):\n 1. s\\<langle>l := x, t\\<rangle>@@l = s\\<langle>l := x\\<rangle>@@l", "hence \"isNewArr t \\<longrightarrow> l \\<noteq> arr_len (new (s\\<langle>l:=x\\<rangle>) t)\""], ["proof (prove)\nusing this:\n  ref l \\<noteq> new (s\\<langle>l := x\\<rangle>) t\n\ngoal (1 subgoal):\n 1. isNewArr t \\<longrightarrow>\n    l \\<noteq> arr_len (new (s\\<langle>l := x\\<rangle>) t)", "by (cases t) auto"], ["proof (state)\nthis:\n  isNewArr t \\<longrightarrow>\n  l \\<noteq> arr_len (new (s\\<langle>l := x\\<rangle>) t)\n\ngoal (1 subgoal):\n 1. s\\<langle>l := x, t\\<rangle>@@l = s\\<langle>l := x\\<rangle>@@l", "thus ?thesis"], ["proof (prove)\nusing this:\n  isNewArr t \\<longrightarrow>\n  l \\<noteq> arr_len (new (s\\<langle>l := x\\<rangle>) t)\n\ngoal (1 subgoal):\n 1. s\\<langle>l := x, t\\<rangle>@@l = s\\<langle>l := x\\<rangle>@@l", "by (simp)"], ["proof (state)\nthis:\n  s\\<langle>l := x, t\\<rangle>@@l = s\\<langle>l := x\\<rangle>@@l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s\\<langle>l := x, t\\<rangle>@@l = s\\<langle>l := x\\<rangle>@@l\n\ngoal (1 subgoal):\n 1. l = k \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "proof (cases \"alive x s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. alive x s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n 2. \\<not> alive x s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "case True"], ["proof (state)\nthis:\n  alive x s\n\ngoal (2 subgoals):\n 1. alive x s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n 2. \\<not> alive x s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "note alive_x = this"], ["proof (state)\nthis:\n  alive x s\n\ngoal (2 subgoals):\n 1. alive x s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n 2. \\<not> alive x s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "proof (cases \"alive (ref l) s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. alive (ref l) s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n 2. \\<not> alive (ref l) s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "case True"], ["proof (state)\nthis:\n  alive (ref l) s\n\ngoal (2 subgoals):\n 1. alive (ref l) s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n 2. \\<not> alive (ref l) s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "note alive_l = this"], ["proof (state)\nthis:\n  alive (ref l) s\n\ngoal (2 subgoals):\n 1. alive (ref l) s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n 2. \\<not> alive (ref l) s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "proof (cases \"typeof x \\<le> ltype l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<tau> x \\<le> ltype l \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n 2. \\<not> \\<tau> x \\<le> ltype l \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "case True"], ["proof (state)\nthis:\n  \\<tau> x \\<le> ltype l\n\ngoal (2 subgoals):\n 1. \\<tau> x \\<le> ltype l \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n 2. \\<not> \\<tau> x \\<le> ltype l \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "with alive_l alive_x"], ["proof (chain)\npicking this:\n  alive (ref l) s\n  alive x s\n  \\<tau> x \\<le> ltype l", "have \"s\\<langle>l:=x\\<rangle>@@l = x\""], ["proof (prove)\nusing this:\n  alive (ref l) s\n  alive x s\n  \\<tau> x \\<le> ltype l\n\ngoal (1 subgoal):\n 1. s\\<langle>l := x\\<rangle>@@l = x", "by (rule update_access_same)"], ["proof (state)\nthis:\n  s\\<langle>l := x\\<rangle>@@l = x\n\ngoal (2 subgoals):\n 1. \\<tau> x \\<le> ltype l \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n 2. \\<not> \\<tau> x \\<le> ltype l \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "moreover"], ["proof (state)\nthis:\n  s\\<langle>l := x\\<rangle>@@l = x\n\ngoal (2 subgoals):\n 1. \\<tau> x \\<le> ltype l \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n 2. \\<not> \\<tau> x \\<le> ltype l \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "have \"s\\<langle>t\\<rangle>\\<langle>l:=x\\<rangle>@@l = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<langle>t, l := x\\<rangle>@@l = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s\\<langle>t, l := x\\<rangle>@@l = x", "from alive_l neq_l_new"], ["proof (chain)\npicking this:\n  alive (ref l) s\n  ref l \\<noteq> new s t", "have \"alive (ref l) (s\\<langle>t\\<rangle>)\""], ["proof (prove)\nusing this:\n  alive (ref l) s\n  ref l \\<noteq> new s t\n\ngoal (1 subgoal):\n 1. alive (ref l) (s\\<langle>t\\<rangle>)", "by (simp add: lemma_3_1)"], ["proof (state)\nthis:\n  alive (ref l) (s\\<langle>t\\<rangle>)\n\ngoal (1 subgoal):\n 1. s\\<langle>t, l := x\\<rangle>@@l = x", "moreover"], ["proof (state)\nthis:\n  alive (ref l) (s\\<langle>t\\<rangle>)\n\ngoal (1 subgoal):\n 1. s\\<langle>t, l := x\\<rangle>@@l = x", "from alive_x neq_x_new"], ["proof (chain)\npicking this:\n  alive x s\n  x \\<noteq> new s t", "have \"alive x (s\\<langle>t\\<rangle>)\""], ["proof (prove)\nusing this:\n  alive x s\n  x \\<noteq> new s t\n\ngoal (1 subgoal):\n 1. alive x (s\\<langle>t\\<rangle>)", "by (simp add: lemma_3_2)"], ["proof (state)\nthis:\n  alive x (s\\<langle>t\\<rangle>)\n\ngoal (1 subgoal):\n 1. s\\<langle>t, l := x\\<rangle>@@l = x", "ultimately"], ["proof (chain)\npicking this:\n  alive (ref l) (s\\<langle>t\\<rangle>)\n  alive x (s\\<langle>t\\<rangle>)", "show \"s\\<langle>t\\<rangle>\\<langle>l:=x\\<rangle>@@l = x\""], ["proof (prove)\nusing this:\n  alive (ref l) (s\\<langle>t\\<rangle>)\n  alive x (s\\<langle>t\\<rangle>)\n\ngoal (1 subgoal):\n 1. s\\<langle>t, l := x\\<rangle>@@l = x", "using True"], ["proof (prove)\nusing this:\n  alive (ref l) (s\\<langle>t\\<rangle>)\n  alive x (s\\<langle>t\\<rangle>)\n  \\<tau> x \\<le> ltype l\n\ngoal (1 subgoal):\n 1. s\\<langle>t, l := x\\<rangle>@@l = x", "by (rule update_access_same)"], ["proof (state)\nthis:\n  s\\<langle>t, l := x\\<rangle>@@l = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s\\<langle>t, l := x\\<rangle>@@l = x\n\ngoal (2 subgoals):\n 1. \\<tau> x \\<le> ltype l \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n 2. \\<not> \\<tau> x \\<le> ltype l \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "ultimately"], ["proof (chain)\npicking this:\n  s\\<langle>l := x\\<rangle>@@l = x\n  s\\<langle>t, l := x\\<rangle>@@l = x", "show ?thesis"], ["proof (prove)\nusing this:\n  s\\<langle>l := x\\<rangle>@@l = x\n  s\\<langle>t, l := x\\<rangle>@@l = x\n\ngoal (1 subgoal):\n 1. s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "using eq_l_k lemma_3_3"], ["proof (prove)\nusing this:\n  s\\<langle>l := x\\<rangle>@@l = x\n  s\\<langle>t, l := x\\<rangle>@@l = x\n  l = k\n  s\\<langle>l := x, t\\<rangle>@@l = s\\<langle>l := x\\<rangle>@@l\n\ngoal (1 subgoal):\n 1. s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "by simp"], ["proof (state)\nthis:\n  s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n\ngoal (1 subgoal):\n 1. \\<not> \\<tau> x \\<le> ltype l \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<tau> x \\<le> ltype l \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "case False"], ["proof (state)\nthis:\n  \\<not> \\<tau> x \\<le> ltype l\n\ngoal (1 subgoal):\n 1. \\<not> \\<tau> x \\<le> ltype l \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> \\<tau> x \\<le> ltype l\n\ngoal (1 subgoal):\n 1. s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "by simp"], ["proof (state)\nthis:\n  s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n\ngoal (1 subgoal):\n 1. \\<not> alive (ref l) s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> alive (ref l) s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "case False"], ["proof (state)\nthis:\n  \\<not> alive (ref l) s\n\ngoal (1 subgoal):\n 1. \\<not> alive (ref l) s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "note not_alive_l = this"], ["proof (state)\nthis:\n  \\<not> alive (ref l) s\n\ngoal (1 subgoal):\n 1. \\<not> alive (ref l) s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "from not_alive_l neq_l_new"], ["proof (chain)\npicking this:\n  \\<not> alive (ref l) s\n  ref l \\<noteq> new s t", "have \"\\<not> alive (ref l) (s\\<langle>t\\<rangle>)\""], ["proof (prove)\nusing this:\n  \\<not> alive (ref l) s\n  ref l \\<noteq> new s t\n\ngoal (1 subgoal):\n 1. \\<not> alive (ref l) (s\\<langle>t\\<rangle>)", "by (simp add: lemma_3_1)"], ["proof (state)\nthis:\n  \\<not> alive (ref l) (s\\<langle>t\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<not> alive (ref l) s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "then"], ["proof (chain)\npicking this:\n  \\<not> alive (ref l) (s\\<langle>t\\<rangle>)", "have \"s\\<langle>t\\<rangle>\\<langle>l:=x\\<rangle>@@l = init (ltype l)\""], ["proof (prove)\nusing this:\n  \\<not> alive (ref l) (s\\<langle>t\\<rangle>)\n\ngoal (1 subgoal):\n 1. s\\<langle>t, l := x\\<rangle>@@l = init (ltype l)", "by simp"], ["proof (state)\nthis:\n  s\\<langle>t, l := x\\<rangle>@@l = init (ltype l)\n\ngoal (1 subgoal):\n 1. \\<not> alive (ref l) s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "also"], ["proof (state)\nthis:\n  s\\<langle>t, l := x\\<rangle>@@l = init (ltype l)\n\ngoal (1 subgoal):\n 1. \\<not> alive (ref l) s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "from not_alive_l"], ["proof (chain)\npicking this:\n  \\<not> alive (ref l) s", "have \"\\<dots> = s\\<langle>l:=x\\<rangle>@@l\""], ["proof (prove)\nusing this:\n  \\<not> alive (ref l) s\n\ngoal (1 subgoal):\n 1. init (ltype l) = s\\<langle>l := x\\<rangle>@@l", "by simp"], ["proof (state)\nthis:\n  init (ltype l) = s\\<langle>l := x\\<rangle>@@l\n\ngoal (1 subgoal):\n 1. \\<not> alive (ref l) s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "also"], ["proof (state)\nthis:\n  init (ltype l) = s\\<langle>l := x\\<rangle>@@l\n\ngoal (1 subgoal):\n 1. \\<not> alive (ref l) s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "have \"\\<dots> = s\\<langle>l:=x\\<rangle>\\<langle>t\\<rangle>@@l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<langle>l := x\\<rangle>@@l = s\\<langle>l := x, t\\<rangle>@@l", "by (simp add: lemma_3_3)"], ["proof (state)\nthis:\n  s\\<langle>l := x\\<rangle>@@l = s\\<langle>l := x, t\\<rangle>@@l\n\ngoal (1 subgoal):\n 1. \\<not> alive (ref l) s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "finally"], ["proof (chain)\npicking this:\n  s\\<langle>t, l := x\\<rangle>@@l = s\\<langle>l := x, t\\<rangle>@@l", "show ?thesis"], ["proof (prove)\nusing this:\n  s\\<langle>t, l := x\\<rangle>@@l = s\\<langle>l := x, t\\<rangle>@@l\n\ngoal (1 subgoal):\n 1. s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "by (simp add: eq_l_k)"], ["proof (state)\nthis:\n  s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n\ngoal (1 subgoal):\n 1. \\<not> alive x s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> alive x s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "case False"], ["proof (state)\nthis:\n  \\<not> alive x s\n\ngoal (1 subgoal):\n 1. \\<not> alive x s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "note not_alive_x = this"], ["proof (state)\nthis:\n  \\<not> alive x s\n\ngoal (1 subgoal):\n 1. \\<not> alive x s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "from not_alive_x neq_x_new"], ["proof (chain)\npicking this:\n  \\<not> alive x s\n  x \\<noteq> new s t", "have \"\\<not> alive x (s\\<langle>t\\<rangle>)\""], ["proof (prove)\nusing this:\n  \\<not> alive x s\n  x \\<noteq> new s t\n\ngoal (1 subgoal):\n 1. \\<not> alive x (s\\<langle>t\\<rangle>)", "by (simp add: lemma_3_2)"], ["proof (state)\nthis:\n  \\<not> alive x (s\\<langle>t\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<not> alive x s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "then"], ["proof (chain)\npicking this:\n  \\<not> alive x (s\\<langle>t\\<rangle>)", "have \"s\\<langle>t\\<rangle>\\<langle>l:=x\\<rangle>@@l = s\\<langle>t\\<rangle>@@l\""], ["proof (prove)\nusing this:\n  \\<not> alive x (s\\<langle>t\\<rangle>)\n\ngoal (1 subgoal):\n 1. s\\<langle>t, l := x\\<rangle>@@l = s\\<langle>t\\<rangle>@@l", "by (simp)"], ["proof (state)\nthis:\n  s\\<langle>t, l := x\\<rangle>@@l = s\\<langle>t\\<rangle>@@l\n\ngoal (1 subgoal):\n 1. \\<not> alive x s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "also"], ["proof (state)\nthis:\n  s\\<langle>t, l := x\\<rangle>@@l = s\\<langle>t\\<rangle>@@l\n\ngoal (1 subgoal):\n 1. \\<not> alive x s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "have \"\\<dots> = s@@l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<langle>t\\<rangle>@@l = s@@l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s\\<langle>t\\<rangle>@@l = s@@l", "from neq_l_new"], ["proof (chain)\npicking this:\n  ref l \\<noteq> new s t", "have \"isNewArr t \\<longrightarrow> l \\<noteq> arr_len (new s t)\""], ["proof (prove)\nusing this:\n  ref l \\<noteq> new s t\n\ngoal (1 subgoal):\n 1. isNewArr t \\<longrightarrow> l \\<noteq> arr_len (new s t)", "by (cases t) auto"], ["proof (state)\nthis:\n  isNewArr t \\<longrightarrow> l \\<noteq> arr_len (new s t)\n\ngoal (1 subgoal):\n 1. s\\<langle>t\\<rangle>@@l = s@@l", "thus ?thesis"], ["proof (prove)\nusing this:\n  isNewArr t \\<longrightarrow> l \\<noteq> arr_len (new s t)\n\ngoal (1 subgoal):\n 1. s\\<langle>t\\<rangle>@@l = s@@l", "by (simp)"], ["proof (state)\nthis:\n  s\\<langle>t\\<rangle>@@l = s@@l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s\\<langle>t\\<rangle>@@l = s@@l\n\ngoal (1 subgoal):\n 1. \\<not> alive x s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "also"], ["proof (state)\nthis:\n  s\\<langle>t\\<rangle>@@l = s@@l\n\ngoal (1 subgoal):\n 1. \\<not> alive x s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "from not_alive_x"], ["proof (chain)\npicking this:\n  \\<not> alive x s", "have \"\\<dots> = s\\<langle>l:=x\\<rangle>@@l\""], ["proof (prove)\nusing this:\n  \\<not> alive x s\n\ngoal (1 subgoal):\n 1. s@@l = s\\<langle>l := x\\<rangle>@@l", "by (simp)"], ["proof (state)\nthis:\n  s@@l = s\\<langle>l := x\\<rangle>@@l\n\ngoal (1 subgoal):\n 1. \\<not> alive x s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "also"], ["proof (state)\nthis:\n  s@@l = s\\<langle>l := x\\<rangle>@@l\n\ngoal (1 subgoal):\n 1. \\<not> alive x s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "have \"\\<dots> = s\\<langle>l:=x\\<rangle>\\<langle>t\\<rangle>@@l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<langle>l := x\\<rangle>@@l = s\\<langle>l := x, t\\<rangle>@@l", "by (simp add: lemma_3_3)"], ["proof (state)\nthis:\n  s\\<langle>l := x\\<rangle>@@l = s\\<langle>l := x, t\\<rangle>@@l\n\ngoal (1 subgoal):\n 1. \\<not> alive x s \\<Longrightarrow>\n    s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "finally"], ["proof (chain)\npicking this:\n  s\\<langle>t, l := x\\<rangle>@@l = s\\<langle>l := x, t\\<rangle>@@l", "show ?thesis"], ["proof (prove)\nusing this:\n  s\\<langle>t, l := x\\<rangle>@@l = s\\<langle>l := x, t\\<rangle>@@l\n\ngoal (1 subgoal):\n 1. s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k", "by (simp add: eq_l_k)"], ["proof (state)\nthis:\n  s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s\\<langle>t, l := x\\<rangle>@@k = s\\<langle>l := x, t\\<rangle>@@k\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}