{"file_name": "/home/qj213/afp-2021-10-22/thys/MFOTL_Monitor/Interval.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MFOTL_Monitor", "problem_names": ["lemma left_right: \"left I \\<le> right I\"", "lemma point_simps[simp]:\n  \"left (point n) = n\"\n  \"right (point n) = n\"", "lemma init_simps[simp]:\n  \"left (init n) = 0\"\n  \"right (init n) = n\"", "lemma subtract_simps[simp]:\n  \"left (subtract n I) = left I - n\"\n  \"right (subtract n I) = right I - n\"\n  \"subtract 0 I = I\"\n  \"subtract x (point y) = point (y - x)\"", "lemma subtract_too_much: \"i > (case right I of \\<infinity> \\<Rightarrow> left I | enat n \\<Rightarrow> n) \\<Longrightarrow>\n  subtract i I = subtract (case right I of \\<infinity> \\<Rightarrow> left I | enat n \\<Rightarrow> n) I\"", "lemma subtract_shifted: \"subtract n I \\<in> shifted I\"", "lemma finite_shifted: \"finite (shifted I)\"", "lemma [code abstract]: \"Rep_\\<I> (interval l r) = (if l \\<le> r then (l, r) else Rep_\\<I> undefined)\""], "translations": [["", "lemma left_right: \"left I \\<le> right I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat (left I) \\<le> right I", "by transfer auto"], ["", "lemma point_simps[simp]:\n  \"left (point n) = n\"\n  \"right (point n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left (point n) = n &&& right (point n) = enat n", "by (transfer; auto)+"], ["", "lemma init_simps[simp]:\n  \"left (init n) = 0\"\n  \"right (init n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left (init n) = 0 &&& right (init n) = enat n", "by (transfer; auto)+"], ["", "lemma subtract_simps[simp]:\n  \"left (subtract n I) = left I - n\"\n  \"right (subtract n I) = right I - n\"\n  \"subtract 0 I = I\"\n  \"subtract x (point y) = point (y - x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (left (subtract n I) = left I - n &&&\n     right (subtract n I) = right I - enat n) &&&\n    subtract 0 I = I &&& subtract x (point y) = point (y - x)", "by (transfer; auto)+"], ["", "definition shifted :: \"\\<I> \\<Rightarrow> \\<I> set\" where\n  \"shifted I = (\\<lambda>n. subtract n I) ` {0 .. (case right I of \\<infinity> \\<Rightarrow> left I | enat n \\<Rightarrow> n)}\""], ["", "lemma subtract_too_much: \"i > (case right I of \\<infinity> \\<Rightarrow> left I | enat n \\<Rightarrow> n) \\<Longrightarrow>\n  subtract i I = subtract (case right I of \\<infinity> \\<Rightarrow> left I | enat n \\<Rightarrow> n) I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case right I of enat n \\<Rightarrow> n\n     | \\<infinity> \\<Rightarrow> left I)\n    < i \\<Longrightarrow>\n    subtract i I =\n    subtract\n     (case right I of enat n \\<Rightarrow> n\n      | \\<infinity> \\<Rightarrow> left I)\n     I", "by transfer (auto split: enat.splits)"], ["", "lemma subtract_shifted: \"subtract n I \\<in> shifted I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subtract n I \\<in> shifted I", "by (cases \"n \\<le> (case right I of \\<infinity> \\<Rightarrow> left I | enat n \\<Rightarrow> n)\")\n    (auto simp: shifted_def subtract_too_much)"], ["", "lemma finite_shifted: \"finite (shifted I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (shifted I)", "unfolding shifted_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>n. subtract n I) `\n      {0..case right I of enat n \\<Rightarrow> n\n          | \\<infinity> \\<Rightarrow> left I})", "by auto"], ["", "definition interval :: \"nat \\<Rightarrow> enat \\<Rightarrow> \\<I>\" where\n  \"interval l r = (if l \\<le> r then Abs_\\<I> (l, r) else undefined)\""], ["", "lemma [code abstract]: \"Rep_\\<I> (interval l r) = (if l \\<le> r then (l, r) else Rep_\\<I> undefined)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_\\<I> (interval l r) =\n    (if enat l \\<le> r then (l, r) else Rep_\\<I> undefined)", "unfolding interval_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_\\<I> (if enat l \\<le> r then Abs_\\<I> (l, r) else undefined) =\n    (if enat l \\<le> r then (l, r) else Rep_\\<I> undefined)", "using Abs_\\<I>_inverse"], ["proof (prove)\nusing this:\n  ?y \\<in> {(x, j). enat x \\<le> j} \\<Longrightarrow>\n  Rep_\\<I> (Abs_\\<I> ?y) = ?y\n\ngoal (1 subgoal):\n 1. Rep_\\<I> (if enat l \\<le> r then Abs_\\<I> (l, r) else undefined) =\n    (if enat l \\<le> r then (l, r) else Rep_\\<I> undefined)", "by simp"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}