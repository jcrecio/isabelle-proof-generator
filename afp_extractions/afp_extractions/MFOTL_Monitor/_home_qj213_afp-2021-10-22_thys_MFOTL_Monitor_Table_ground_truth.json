{"file_name": "/home/qj213/afp-2021-10-22/thys/MFOTL_Monitor/Table.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MFOTL_Monitor", "problem_names": ["lemma tabulate_alt: \"tabulate f x n = map f [x ..< x + n]\"", "lemma length_tabulate[simp]: \"length (tabulate f x n) = n\"", "lemma map_tabulate[simp]: \"map f (tabulate g x n) = tabulate (\\<lambda>x. f (g x)) x n\"", "lemma nth_tabulate[simp]: \"k < n \\<Longrightarrow> tabulate f x n ! k = f (x + k)\"", "lemma in_empty_table[simp]: \"\\<not> x \\<in> empty_table\"", "lemma empty_table[simp]: \"table n V empty_table\"", "lemma unit_table_wf_tuple[simp]: \"V = {} \\<Longrightarrow> x \\<in> unit_table n \\<Longrightarrow> wf_tuple n V x\"", "lemma unit_table[simp]: \"V = {} \\<Longrightarrow> table n V (unit_table n)\"", "lemma in_unit_table: \"v \\<in> unit_table n \\<longleftrightarrow> wf_tuple n {} v\"", "lemma singleton_table_wf_tuple[simp]: \"V = {i} \\<Longrightarrow> x \\<in> singleton_table n i z \\<Longrightarrow> wf_tuple n V x\"", "lemma singleton_table[simp]: \"V = {i} \\<Longrightarrow> table n V (singleton_table n i z)\"", "lemma table_Un[simp]: \"table n V X \\<Longrightarrow> table n V Y \\<Longrightarrow> table n V (X \\<union> Y)\"", "lemma wf_tuple_length: \"wf_tuple n V x \\<Longrightarrow> length x = n\"", "lemma join_True_code[code]: \"join A True B = (\\<Union>a \\<in> A. \\<Union>b \\<in> B. set_option (join1 (a, b)))\"", "lemma join_False_alt: \"join X False Y = X - join X True Y\"", "lemma self_join1: \"join1 (xs, ys) \\<noteq> Some xs \\<Longrightarrow> join1 (zs, ys) \\<noteq> Some xs\"", "lemma join_False_code[code]: \"join A False B = {a \\<in> A. \\<forall>b \\<in> B. join1 (a, b) \\<noteq> Some a}\"", "lemma wf_tuple_Nil[simp]: \"wf_tuple n A [] = (n = 0)\"", "lemma Suc_pred': \"Suc (x - Suc 0) = (case x of 0 \\<Rightarrow> Suc 0 | _ \\<Rightarrow> x)\"", "lemma wf_tuple_Cons[simp]:\n  \"wf_tuple n A (x # xs) \\<longleftrightarrow> ((if x = None then 0 \\<notin> A else 0 \\<in> A) \\<and>\n   (\\<exists>m. n = Suc m \\<and> wf_tuple m ((\\<lambda>x. x - 1) ` (A - {0})) xs))\"", "lemma join1_wf_tuple:\n  \"join1 (v1, v2) = Some v \\<Longrightarrow> wf_tuple n A v1 \\<Longrightarrow> wf_tuple n B v2 \\<Longrightarrow> wf_tuple n (A \\<union> B) v\"", "lemma join_wf_tuple: \"x \\<in> join X b Y \\<Longrightarrow>\n  \\<forall>v \\<in> X. wf_tuple n A v \\<Longrightarrow> \\<forall>v \\<in> Y. wf_tuple n B v \\<Longrightarrow> (\\<not> b \\<Longrightarrow> B \\<subseteq> A) \\<Longrightarrow> A \\<union> B = C \\<Longrightarrow> wf_tuple n C x\"", "lemma join_table: \"table n A X \\<Longrightarrow> table n B Y \\<Longrightarrow> (\\<not> b \\<Longrightarrow> B \\<subseteq> A) \\<Longrightarrow> A \\<union> B = C \\<Longrightarrow>\n  table n C (join X b Y)\"", "lemma wf_tuple_Suc: \"wf_tuple (Suc m) A a \\<longleftrightarrow> a \\<noteq> [] \\<and>\n   wf_tuple m ((\\<lambda>x. x - 1) ` (A - {0})) (tl a) \\<and> (0 \\<in> A \\<longleftrightarrow> hd a \\<noteq> None)\"", "lemma table_project: \"table (Suc n) A X \\<Longrightarrow> table n ((\\<lambda>x. x - Suc 0) ` (A - {0})) (tl ` X)\"", "lemma restrict_Nil[simp]: \"restrict A [] = []\"", "lemma restrict_Cons[simp]: \"restrict A (x # xs) =\n  (if 0 \\<in> A then x # restrict ((\\<lambda>x. x - 1) ` (A - {0})) xs else None # restrict ((\\<lambda>x. x - 1) ` A) xs)\"", "lemma wf_tuple_restrict: \"wf_tuple n B v \\<Longrightarrow> A \\<inter> B = C \\<Longrightarrow> wf_tuple n C (restrict A v)\"", "lemma wf_tuple_restrict_simple: \"wf_tuple n B v \\<Longrightarrow> A \\<subseteq> B \\<Longrightarrow> wf_tuple n A (restrict A v)\"", "lemma nth_restrict: \"i \\<in> A \\<Longrightarrow> i < length v \\<Longrightarrow> restrict A v ! i = v ! i\"", "lemma restrict_eq_Nil[simp]: \"restrict A v = [] \\<longleftrightarrow> v = []\"", "lemma length_restrict[simp]: \"length (restrict A v) = length v\"", "lemma join1_Some_restrict:\n  fixes x y :: \"'a tuple\"\n  assumes \"wf_tuple n A x\" \"wf_tuple n B y\"\n  shows \"join1 (x, y) = Some z \\<longleftrightarrow> wf_tuple n (A \\<union> B) z \\<and> restrict A z = x \\<and> restrict B z = y\"", "lemma restrict_idle: \"wf_tuple n A v \\<Longrightarrow> restrict A v = v\"", "lemma map_the_restrict:\n  \"i \\<in> A \\<Longrightarrow> map the (restrict A v) ! i = map the v ! i\"", "lemma join_restrict:\n  fixes X Y :: \"'a tuple set\"\n  assumes \"\\<And>v. v \\<in> X \\<Longrightarrow> wf_tuple n A v\" \"\\<And>v. v \\<in> Y \\<Longrightarrow> wf_tuple n B v\" \"\\<not> b \\<Longrightarrow> B \\<subseteq> A\"\n  shows \"v \\<in> join X b Y \\<longleftrightarrow>\n    wf_tuple n (A \\<union> B) v \\<and> restrict A v \\<in> X \\<and> (if b then restrict B v \\<in> Y else restrict B v \\<notin> Y)\"", "lemma join_restrict_table:\n  assumes \"table n A X\" \"table n B Y\" \"\\<not> b \\<Longrightarrow> B \\<subseteq> A\"\n  shows \"v \\<in> join X b Y \\<longleftrightarrow>\n    wf_tuple n (A \\<union> B) v \\<and> restrict A v \\<in> X \\<and> (if b then restrict B v \\<in> Y else restrict B v \\<notin> Y)\"", "lemma join_restrict_annotated:\n  fixes X Y :: \"'a tuple set\"\n  assumes \"\\<not> b =simp=> B \\<subseteq> A\"\n  shows \"join {v. wf_tuple n A v \\<and> P v} b {v. wf_tuple n B v \\<and> Q v} =\n    {v. wf_tuple n (A \\<union> B) v \\<and> P (restrict A v) \\<and> (if b then Q (restrict B v) else \\<not> Q (restrict B v))}\"", "lemma in_joinI: \"table n A X \\<Longrightarrow> table n B Y \\<Longrightarrow> (\\<not>b \\<Longrightarrow> B \\<subseteq> A) \\<Longrightarrow> wf_tuple n (A \\<union> B) v \\<Longrightarrow>\n  restrict A v \\<in> X \\<Longrightarrow> (b \\<Longrightarrow> restrict B v \\<in> Y) \\<Longrightarrow> (\\<not>b \\<Longrightarrow> restrict B v \\<notin> Y) \\<Longrightarrow> v \\<in> join X b Y\"", "lemma in_joinE: \"v \\<in> join X b Y \\<Longrightarrow> table n A X \\<Longrightarrow> table n B Y \\<Longrightarrow> (\\<not> b \\<Longrightarrow> B \\<subseteq> A) \\<Longrightarrow>\n  (wf_tuple n (A \\<union> B) v \\<Longrightarrow> restrict A v \\<in> X \\<Longrightarrow> if b then restrict B v \\<in> Y else restrict B v \\<notin> Y \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma wf_table_iff: \"wf_table n A Q X \\<longleftrightarrow> (\\<forall>x. x \\<in> X \\<longleftrightarrow> (Q x \\<and> wf_tuple n A x))\"", "lemma table_wf_table: \"table n A X = wf_table n A (\\<lambda>v. v \\<in> X) X\"", "lemma qtableI: \"table n A X \\<Longrightarrow>\n  (\\<And>x. x \\<in> X \\<Longrightarrow> wf_tuple n A x \\<Longrightarrow> P x \\<Longrightarrow> Q x) \\<Longrightarrow>\n  (\\<And>x. wf_tuple n A x \\<Longrightarrow> P x \\<Longrightarrow> Q x \\<Longrightarrow> x \\<in> X) \\<Longrightarrow>\n  qtable n A P Q X\"", "lemma in_qtableI: \"qtable n A P Q X \\<Longrightarrow> wf_tuple n A x \\<Longrightarrow> P x \\<Longrightarrow> Q x \\<Longrightarrow> x \\<in> X\"", "lemma in_qtableE: \"qtable n A P Q X \\<Longrightarrow> x \\<in> X \\<Longrightarrow> P x \\<Longrightarrow> (wf_tuple n A x \\<Longrightarrow> Q x \\<Longrightarrow> R) \\<Longrightarrow> R\"", "lemma qtable_empty: \"(\\<And>x. wf_tuple n A x \\<Longrightarrow> P x \\<Longrightarrow> Q x \\<Longrightarrow> False) \\<Longrightarrow> qtable n A P Q empty_table\"", "lemma qtable_empty_iff: \"qtable n A P Q empty_table = (\\<forall>x. wf_tuple n A x \\<longrightarrow> P x \\<longrightarrow> Q x \\<longrightarrow> False)\"", "lemma qtable_unit_table: \"(\\<And>x. wf_tuple n {} x \\<Longrightarrow> P x \\<Longrightarrow> Q x) \\<Longrightarrow> qtable n {} P Q (unit_table n)\"", "lemma qtable_union: \"qtable n A P Q1 X \\<Longrightarrow> qtable n A P Q2 Y \\<Longrightarrow>\n  (\\<And>x. wf_tuple n A x \\<Longrightarrow> P x \\<Longrightarrow> Q x \\<longleftrightarrow> Q1 x \\<or> Q2 x) \\<Longrightarrow> qtable n A P Q (X \\<union> Y)\"", "lemma qtable_Union: \"finite I \\<Longrightarrow> (\\<And>i. i \\<in> I \\<Longrightarrow> qtable n A P (Qi i) (Xi i)) \\<Longrightarrow>\n  (\\<And>x. wf_tuple n A x \\<Longrightarrow> P x \\<Longrightarrow> Q x \\<longleftrightarrow> (\\<exists>i \\<in> I. Qi i x)) \\<Longrightarrow> qtable n A P Q (\\<Union>i \\<in> I. Xi i)\"", "lemma qtable_join: \n  assumes \"qtable n A P Q1 X\" \"qtable n B P Q2 Y\" \"\\<not> b \\<Longrightarrow> B \\<subseteq> A\" \"C = A \\<union> B\"\n  \"\\<And>x. wf_tuple n C x \\<Longrightarrow> P x \\<Longrightarrow> P (restrict A x) \\<and> P (restrict B x)\"\n  \"\\<And>x. b \\<Longrightarrow> wf_tuple n C x \\<Longrightarrow> P x \\<Longrightarrow> Q x \\<longleftrightarrow> Q1 (restrict A x) \\<and> Q2 (restrict B x)\"\n  \"\\<And>x. \\<not> b \\<Longrightarrow> wf_tuple n C x \\<Longrightarrow> P x \\<Longrightarrow> Q x \\<longleftrightarrow> Q1 (restrict A x) \\<and> \\<not> Q2 (restrict B x)\"\n  shows \"qtable n C P Q (join X b Y)\"", "lemma qtable_join_fixed: \n  assumes \"qtable n A P Q1 X\" \"qtable n B P Q2 Y\" \"\\<not> b \\<Longrightarrow> B \\<subseteq> A\" \"C = A \\<union> B\"\n  \"\\<And>x. wf_tuple n C x \\<Longrightarrow> P x \\<Longrightarrow> P (restrict A x) \\<and> P (restrict B x)\"\n  shows \"qtable n C P (\\<lambda>x. Q1 (restrict A x) \\<and> (if b then Q2 (restrict B x) else \\<not> Q2 (restrict B x))) (join X b Y)\"", "lemma wf_tuple_cong:\n  assumes \"wf_tuple n A v\" \"wf_tuple n A w\" \"\\<forall>x \\<in> A. map the v ! x = map the w ! x\"\n  shows \"v = w\"", "lemma mem_restrI: \"y \\<in> A \\<Longrightarrow> length y = n \\<Longrightarrow> wf_tuple n V x \\<Longrightarrow> \\<forall>i\\<in>V. x ! i = Some (y ! i) \\<Longrightarrow> mem_restr A x\"", "lemma mem_restrE: \"mem_restr A x \\<Longrightarrow> wf_tuple n V x \\<Longrightarrow> \\<forall>i\\<in>V. i < n \\<Longrightarrow>\n  (\\<And>y. y \\<in> A \\<Longrightarrow> \\<forall>i\\<in>V. x ! i = Some (y ! i) \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma mem_restr_IntD: \"mem_restr (A \\<inter> B) v \\<Longrightarrow> mem_restr A v \\<and> mem_restr B v\"", "lemma mem_restr_Un_iff: \"mem_restr (A \\<union> B) x \\<longleftrightarrow> mem_restr A x \\<or> mem_restr B x\"", "lemma mem_restr_UNIV [simp]: \"mem_restr UNIV x\"", "lemma restrict_mem_restr[simp]: \"mem_restr A x \\<Longrightarrow> mem_restr A (restrict V x)\"", "lemma lift_envs_mem_restr[simp]: \"mem_restr A x \\<Longrightarrow> mem_restr (lift_envs A) (a # x)\"", "lemma qtable_project:\n  assumes \"qtable (Suc n) A (mem_restr (lift_envs R)) P X\"\n  shows \"qtable n ((\\<lambda>x. x - Suc 0) ` (A - {0})) (mem_restr R)\n      (\\<lambda>v. \\<exists>x. P ((if 0 \\<in> A then Some x else None) # v)) (tl ` X)\"\n      (is \"qtable n ?A (mem_restr R) ?P ?X\")", "lemma qtable_cong: \"qtable n A P Q X \\<Longrightarrow> A = B \\<Longrightarrow> (\\<And>v. P v \\<Longrightarrow> Q v \\<longleftrightarrow> Q' v) \\<Longrightarrow> qtable n B P Q' X\""], "translations": [["", "lemma tabulate_alt: \"tabulate f x n = map f [x ..< x + n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tabulate f x n = map f [x..<x + n]", "by (induct n arbitrary: x) (auto simp: not_le Suc_le_eq upt_rec)"], ["", "lemma length_tabulate[simp]: \"length (tabulate f x n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (tabulate f x n) = n", "by (induction n arbitrary: x) simp_all"], ["", "lemma map_tabulate[simp]: \"map f (tabulate g x n) = tabulate (\\<lambda>x. f (g x)) x n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f (tabulate g x n) = tabulate (\\<lambda>x. f (g x)) x n", "by (induction n arbitrary: x) simp_all"], ["", "lemma nth_tabulate[simp]: \"k < n \\<Longrightarrow> tabulate f x n ! k = f (x + k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < n \\<Longrightarrow> tabulate f x n ! k = f (x + k)", "proof (induction n arbitrary: x k)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x k. k < 0 \\<Longrightarrow> tabulate f x 0 ! k = f (x + k)\n 2. \\<And>n x k.\n       \\<lbrakk>\\<And>x k.\n                   k < n \\<Longrightarrow> tabulate f x n ! k = f (x + k);\n        k < Suc n\\<rbrakk>\n       \\<Longrightarrow> tabulate f x (Suc n) ! k = f (x + k)", "case (Suc n)"], ["proof (state)\nthis:\n  ?k < n \\<Longrightarrow> tabulate f ?x n ! ?k = f (?x + ?k)\n  k < Suc n\n\ngoal (2 subgoals):\n 1. \\<And>x k. k < 0 \\<Longrightarrow> tabulate f x 0 ! k = f (x + k)\n 2. \\<And>n x k.\n       \\<lbrakk>\\<And>x k.\n                   k < n \\<Longrightarrow> tabulate f x n ! k = f (x + k);\n        k < Suc n\\<rbrakk>\n       \\<Longrightarrow> tabulate f x (Suc n) ! k = f (x + k)", "then"], ["proof (chain)\npicking this:\n  ?k < n \\<Longrightarrow> tabulate f ?x n ! ?k = f (?x + ?k)\n  k < Suc n", "show ?case"], ["proof (prove)\nusing this:\n  ?k < n \\<Longrightarrow> tabulate f ?x n ! ?k = f (?x + ?k)\n  k < Suc n\n\ngoal (1 subgoal):\n 1. tabulate f x (Suc n) ! k = f (x + k)", "by (cases k) simp_all"], ["proof (state)\nthis:\n  tabulate f x (Suc n) ! k = f (x + k)\n\ngoal (1 subgoal):\n 1. \\<And>x k. k < 0 \\<Longrightarrow> tabulate f x 0 ! k = f (x + k)", "qed simp"], ["", "type_synonym 'a tuple = \"'a option list\""], ["", "type_synonym 'a table = \"'a tuple set\""], ["", "definition wf_tuple :: \"nat \\<Rightarrow> nat set \\<Rightarrow> 'a tuple \\<Rightarrow> bool\" where\n  \"wf_tuple n V x \\<longleftrightarrow> length x = n \\<and> (\\<forall>i<n. x!i = None \\<longleftrightarrow> i \\<notin> V)\""], ["", "definition table :: \"nat \\<Rightarrow> nat set \\<Rightarrow> 'a table \\<Rightarrow> bool\" where\n  \"table n V X \\<longleftrightarrow> (\\<forall>x\\<in>X. wf_tuple n V x)\""], ["", "definition \"empty_table = {}\""], ["", "definition \"unit_table n = {replicate n None}\""], ["", "definition \"singleton_table n i x = {tabulate (\\<lambda>j. if i = j then Some x else None) 0 n}\""], ["", "lemma in_empty_table[simp]: \"\\<not> x \\<in> empty_table\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> empty_table", "unfolding empty_table_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> {}", "by simp"], ["", "lemma empty_table[simp]: \"table n V empty_table\""], ["proof (prove)\ngoal (1 subgoal):\n 1. table n V empty_table", "unfolding table_def empty_table_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball {} (wf_tuple n V)", "by simp"], ["", "lemma unit_table_wf_tuple[simp]: \"V = {} \\<Longrightarrow> x \\<in> unit_table n \\<Longrightarrow> wf_tuple n V x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>V = {}; x \\<in> unit_table n\\<rbrakk>\n    \\<Longrightarrow> wf_tuple n V x", "unfolding unit_table_def wf_tuple_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>V = {}; x \\<in> {replicate n None}\\<rbrakk>\n    \\<Longrightarrow> length x = n \\<and>\n                      (\\<forall>i<n. (x ! i = None) = (i \\<notin> V))", "by simp"], ["", "lemma unit_table[simp]: \"V = {} \\<Longrightarrow> table n V (unit_table n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V = {} \\<Longrightarrow> table n V (unit_table n)", "unfolding table_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. V = {} \\<Longrightarrow> Ball (unit_table n) (wf_tuple n V)", "by simp"], ["", "lemma in_unit_table: \"v \\<in> unit_table n \\<longleftrightarrow> wf_tuple n {} v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<in> unit_table n) = wf_tuple n {} v", "unfolding unit_table_def wf_tuple_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<in> {replicate n None}) =\n    (length v = n \\<and> (\\<forall>i<n. (v ! i = None) = (i \\<notin> {})))", "by (auto intro!: nth_equalityI)"], ["", "lemma singleton_table_wf_tuple[simp]: \"V = {i} \\<Longrightarrow> x \\<in> singleton_table n i z \\<Longrightarrow> wf_tuple n V x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>V = {i}; x \\<in> singleton_table n i z\\<rbrakk>\n    \\<Longrightarrow> wf_tuple n V x", "unfolding singleton_table_def wf_tuple_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>V = {i};\n     x \\<in> {tabulate (\\<lambda>j. if i = j then Some z else None) 0\n               n}\\<rbrakk>\n    \\<Longrightarrow> length x = n \\<and>\n                      (\\<forall>i<n. (x ! i = None) = (i \\<notin> V))", "by simp"], ["", "lemma singleton_table[simp]: \"V = {i} \\<Longrightarrow> table n V (singleton_table n i z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V = {i} \\<Longrightarrow> table n V (singleton_table n i z)", "unfolding table_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. V = {i} \\<Longrightarrow> Ball (singleton_table n i z) (wf_tuple n V)", "by simp"], ["", "lemma table_Un[simp]: \"table n V X \\<Longrightarrow> table n V Y \\<Longrightarrow> table n V (X \\<union> Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>table n V X; table n V Y\\<rbrakk>\n    \\<Longrightarrow> table n V (X \\<union> Y)", "unfolding table_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ball X (wf_tuple n V); Ball Y (wf_tuple n V)\\<rbrakk>\n    \\<Longrightarrow> Ball (X \\<union> Y) (wf_tuple n V)", "by auto"], ["", "lemma wf_tuple_length: \"wf_tuple n V x \\<Longrightarrow> length x = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tuple n V x \\<Longrightarrow> length x = n", "unfolding wf_tuple_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length x = n \\<and>\n    (\\<forall>i<n. (x ! i = None) = (i \\<notin> V)) \\<Longrightarrow>\n    length x = n", "by simp"], ["", "fun join1 :: \"'a tuple \\<times> 'a tuple \\<Rightarrow> 'a tuple option\" where\n  \"join1 ([], []) = Some []\"\n| \"join1 (None # xs, None # ys) = map_option (Cons None) (join1 (xs, ys))\"\n| \"join1 (Some x # xs, None # ys) = map_option (Cons (Some x)) (join1 (xs, ys))\"\n| \"join1 (None # xs, Some y # ys) = map_option (Cons (Some y)) (join1 (xs, ys))\"\n| \"join1 (Some x # xs, Some y # ys) = (if x = y\n    then map_option (Cons (Some x)) (join1 (xs, ys))\n    else None)\"\n| \"join1 _ = None\""], ["", "definition join :: \"'a table \\<Rightarrow> bool \\<Rightarrow> 'a table \\<Rightarrow> 'a table\" where\n  \"join A pos B = (if pos then Option.these (join1 ` (A \\<times> B))\n    else A - Option.these (join1 ` (A \\<times> B)))\""], ["", "lemma join_True_code[code]: \"join A True B = (\\<Union>a \\<in> A. \\<Union>b \\<in> B. set_option (join1 (a, b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. join A True B =\n    (\\<Union>a\\<in>A. \\<Union>b\\<in>B. set_option (join1 (a, b)))", "unfolding join_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if True then Option.these (join1 ` (A \\<times> B))\n     else A - Option.these (join1 ` (A \\<times> B))) =\n    (\\<Union>a\\<in>A. \\<Union>b\\<in>B. set_option (join1 (a, b)))", "by (force simp: Option.these_def image_iff)"], ["", "lemma join_False_alt: \"join X False Y = X - join X True Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. join X False Y = X - join X True Y", "unfolding join_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if False then Option.these (join1 ` (X \\<times> Y))\n     else X - Option.these (join1 ` (X \\<times> Y))) =\n    X -\n    (if True then Option.these (join1 ` (X \\<times> Y))\n     else X - Option.these (join1 ` (X \\<times> Y)))", "by auto"], ["", "lemma self_join1: \"join1 (xs, ys) \\<noteq> Some xs \\<Longrightarrow> join1 (zs, ys) \\<noteq> Some xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. join1 (xs, ys) \\<noteq> Some xs \\<Longrightarrow>\n    join1 (zs, ys) \\<noteq> Some xs", "by (induct \"(zs, ys)\" arbitrary: zs ys xs rule: join1.induct; auto; auto)"], ["", "lemma join_False_code[code]: \"join A False B = {a \\<in> A. \\<forall>b \\<in> B. join1 (a, b) \\<noteq> Some a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. join A False B =\n    {a \\<in> A. \\<forall>b\\<in>B. join1 (a, b) \\<noteq> Some a}", "unfolding join_False_alt join_True_code"], ["proof (prove)\ngoal (1 subgoal):\n 1. A - (\\<Union>a\\<in>A. \\<Union>b\\<in>B. set_option (join1 (a, b))) =\n    {a \\<in> A. \\<forall>b\\<in>B. join1 (a, b) \\<noteq> Some a}", "by (auto simp: Option.these_def image_iff dest: self_join1)"], ["", "lemma wf_tuple_Nil[simp]: \"wf_tuple n A [] = (n = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tuple n A [] = (n = 0)", "unfolding wf_tuple_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length [] = n \\<and>\n     (\\<forall>i<n. ([] ! i = None) = (i \\<notin> A))) =\n    (n = 0)", "by auto"], ["", "lemma Suc_pred': \"Suc (x - Suc 0) = (case x of 0 \\<Rightarrow> Suc 0 | _ \\<Rightarrow> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (x - Suc 0) =\n    (case x of 0 \\<Rightarrow> Suc 0 | Suc nat \\<Rightarrow> x)", "by (auto split: nat.splits)"], ["", "lemma wf_tuple_Cons[simp]:\n  \"wf_tuple n A (x # xs) \\<longleftrightarrow> ((if x = None then 0 \\<notin> A else 0 \\<in> A) \\<and>\n   (\\<exists>m. n = Suc m \\<and> wf_tuple m ((\\<lambda>x. x - 1) ` (A - {0})) xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tuple n A (x # xs) =\n    ((if x = None then 0 \\<notin> A else 0 \\<in> A) \\<and>\n     (\\<exists>m.\n         n = Suc m \\<and> wf_tuple m ((\\<lambda>x. x - 1) ` (A - {0})) xs))", "unfolding wf_tuple_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length (x # xs) = n \\<and>\n     (\\<forall>i<n. ((x # xs) ! i = None) = (i \\<notin> A))) =\n    ((if x = None then 0 \\<notin> A else 0 \\<in> A) \\<and>\n     (\\<exists>m.\n         n = Suc m \\<and>\n         length xs = m \\<and>\n         (\\<forall>i<m.\n             (xs ! i = None) =\n             (i \\<notin> (\\<lambda>x. x - 1) ` (A - {0})))))", "by (auto 0 3 simp: nth_Cons image_iff Ball_def gr0_conv_Suc Suc_pred' split: nat.splits)"], ["", "lemma join1_wf_tuple:\n  \"join1 (v1, v2) = Some v \\<Longrightarrow> wf_tuple n A v1 \\<Longrightarrow> wf_tuple n B v2 \\<Longrightarrow> wf_tuple n (A \\<union> B) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>join1 (v1, v2) = Some v; wf_tuple n A v1;\n     wf_tuple n B v2\\<rbrakk>\n    \\<Longrightarrow> wf_tuple n (A \\<union> B) v", "by (induct \"(v1, v2)\" arbitrary: n v v1 v2 A B rule: join1.induct)\n    (auto simp: image_Un Un_Diff split: if_splits)"], ["", "lemma join_wf_tuple: \"x \\<in> join X b Y \\<Longrightarrow>\n  \\<forall>v \\<in> X. wf_tuple n A v \\<Longrightarrow> \\<forall>v \\<in> Y. wf_tuple n B v \\<Longrightarrow> (\\<not> b \\<Longrightarrow> B \\<subseteq> A) \\<Longrightarrow> A \\<union> B = C \\<Longrightarrow> wf_tuple n C x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> join X b Y; \\<forall>v\\<in>X. wf_tuple n A v;\n     \\<forall>v\\<in>Y. wf_tuple n B v;\n     \\<not> b \\<Longrightarrow> B \\<subseteq> A; A \\<union> B = C\\<rbrakk>\n    \\<Longrightarrow> wf_tuple n C x", "unfolding join_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> (if b then Option.these (join1 ` (X \\<times> Y))\n                      else X - Option.these (join1 ` (X \\<times> Y)));\n     \\<forall>v\\<in>X. wf_tuple n A v; \\<forall>v\\<in>Y. wf_tuple n B v;\n     \\<not> b \\<Longrightarrow> B \\<subseteq> A; A \\<union> B = C\\<rbrakk>\n    \\<Longrightarrow> wf_tuple n C x", "by (fastforce simp: Option.these_def image_iff sup_absorb1 dest: join1_wf_tuple split: if_splits)"], ["", "lemma join_table: \"table n A X \\<Longrightarrow> table n B Y \\<Longrightarrow> (\\<not> b \\<Longrightarrow> B \\<subseteq> A) \\<Longrightarrow> A \\<union> B = C \\<Longrightarrow>\n  table n C (join X b Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>table n A X; table n B Y;\n     \\<not> b \\<Longrightarrow> B \\<subseteq> A; A \\<union> B = C\\<rbrakk>\n    \\<Longrightarrow> table n C (join X b Y)", "unfolding table_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ball X (wf_tuple n A); Ball Y (wf_tuple n B);\n     \\<not> b \\<Longrightarrow> B \\<subseteq> A; A \\<union> B = C\\<rbrakk>\n    \\<Longrightarrow> Ball (join X b Y) (wf_tuple n C)", "by (auto elim!: join_wf_tuple)"], ["", "lemma wf_tuple_Suc: \"wf_tuple (Suc m) A a \\<longleftrightarrow> a \\<noteq> [] \\<and>\n   wf_tuple m ((\\<lambda>x. x - 1) ` (A - {0})) (tl a) \\<and> (0 \\<in> A \\<longleftrightarrow> hd a \\<noteq> None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tuple (Suc m) A a =\n    (a \\<noteq> [] \\<and>\n     wf_tuple m ((\\<lambda>x. x - 1) ` (A - {0})) (tl a) \\<and>\n     (0 \\<in> A) = (hd a \\<noteq> None))", "by (cases a) (auto simp: nth_Cons image_iff split: nat.splits)"], ["", "lemma table_project: \"table (Suc n) A X \\<Longrightarrow> table n ((\\<lambda>x. x - Suc 0) ` (A - {0})) (tl ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. table (Suc n) A X \\<Longrightarrow>\n    table n ((\\<lambda>x. x - Suc 0) ` (A - {0})) (tl ` X)", "unfolding table_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball X (wf_tuple (Suc n) A) \\<Longrightarrow>\n    Ball (tl ` X) (wf_tuple n ((\\<lambda>x. x - Suc 0) ` (A - {0})))", "by (auto simp: wf_tuple_Suc)"], ["", "definition restrict where\n  \"restrict A v = map (\\<lambda>i. if i \\<in> A then v ! i else None) [0 ..< length v]\""], ["", "lemma restrict_Nil[simp]: \"restrict A [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict A [] = []", "unfolding restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. if i \\<in> A then [] ! i else None) [0..<length []] =\n    []", "by auto"], ["", "lemma restrict_Cons[simp]: \"restrict A (x # xs) =\n  (if 0 \\<in> A then x # restrict ((\\<lambda>x. x - 1) ` (A - {0})) xs else None # restrict ((\\<lambda>x. x - 1) ` A) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict A (x # xs) =\n    (if 0 \\<in> A then x # restrict ((\\<lambda>x. x - 1) ` (A - {0})) xs\n     else None # restrict ((\\<lambda>x. x - 1) ` A) xs)", "unfolding restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. if i \\<in> A then (x # xs) ! i else None)\n     [0..<length (x # xs)] =\n    (if 0 \\<in> A\n     then x #\n          map (\\<lambda>i.\n                  if i \\<in> (\\<lambda>x. x - 1) ` (A - {0}) then xs ! i\n                  else None)\n           [0..<length xs]\n     else None #\n          map (\\<lambda>i.\n                  if i \\<in> (\\<lambda>x. x - 1) ` A then xs ! i else None)\n           [0..<length xs])", "by (auto simp: map_upt_Suc image_iff Suc_pred' Ball_def simp del: upt_Suc split: nat.splits)"], ["", "lemma wf_tuple_restrict: \"wf_tuple n B v \\<Longrightarrow> A \\<inter> B = C \\<Longrightarrow> wf_tuple n C (restrict A v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_tuple n B v; A \\<inter> B = C\\<rbrakk>\n    \\<Longrightarrow> wf_tuple n C (restrict A v)", "unfolding restrict_def wf_tuple_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length v = n \\<and>\n             (\\<forall>i<n. (v ! i = None) = (i \\<notin> B));\n     A \\<inter> B = C\\<rbrakk>\n    \\<Longrightarrow> length\n                       (map (\\<lambda>i. if i \\<in> A then v ! i else None)\n                         [0..<length v]) =\n                      n \\<and>\n                      (\\<forall>i<n.\n                          (map (\\<lambda>i.\n                                   if i \\<in> A then v ! i else None)\n                            [0..<length v] !\n                           i =\n                           None) =\n                          (i \\<notin> C))", "by auto"], ["", "lemma wf_tuple_restrict_simple: \"wf_tuple n B v \\<Longrightarrow> A \\<subseteq> B \\<Longrightarrow> wf_tuple n A (restrict A v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_tuple n B v; A \\<subseteq> B\\<rbrakk>\n    \\<Longrightarrow> wf_tuple n A (restrict A v)", "unfolding restrict_def wf_tuple_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length v = n \\<and>\n             (\\<forall>i<n. (v ! i = None) = (i \\<notin> B));\n     A \\<subseteq> B\\<rbrakk>\n    \\<Longrightarrow> length\n                       (map (\\<lambda>i. if i \\<in> A then v ! i else None)\n                         [0..<length v]) =\n                      n \\<and>\n                      (\\<forall>i<n.\n                          (map (\\<lambda>i.\n                                   if i \\<in> A then v ! i else None)\n                            [0..<length v] !\n                           i =\n                           None) =\n                          (i \\<notin> A))", "by auto"], ["", "lemma nth_restrict: \"i \\<in> A \\<Longrightarrow> i < length v \\<Longrightarrow> restrict A v ! i = v ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<in> A; i < length v\\<rbrakk>\n    \\<Longrightarrow> restrict A v ! i = v ! i", "unfolding restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<in> A; i < length v\\<rbrakk>\n    \\<Longrightarrow> map (\\<lambda>i. if i \\<in> A then v ! i else None)\n                       [0..<length v] !\n                      i =\n                      v ! i", "by auto"], ["", "lemma restrict_eq_Nil[simp]: \"restrict A v = [] \\<longleftrightarrow> v = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (restrict A v = []) = (v = [])", "unfolding restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (\\<lambda>i. if i \\<in> A then v ! i else None) [0..<length v] =\n     []) =\n    (v = [])", "by auto"], ["", "lemma length_restrict[simp]: \"length (restrict A v) = length v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (restrict A v) = length v", "unfolding restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (map (\\<lambda>i. if i \\<in> A then v ! i else None) [0..<length v]) =\n    length v", "by auto"], ["", "lemma join1_Some_restrict:\n  fixes x y :: \"'a tuple\"\n  assumes \"wf_tuple n A x\" \"wf_tuple n B y\"\n  shows \"join1 (x, y) = Some z \\<longleftrightarrow> wf_tuple n (A \\<union> B) z \\<and> restrict A z = x \\<and> restrict B z = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (join1 (x, y) = Some z) =\n    (wf_tuple n (A \\<union> B) z \\<and>\n     restrict A z = x \\<and> restrict B z = y)", "using assms"], ["proof (prove)\nusing this:\n  wf_tuple n A x\n  wf_tuple n B y\n\ngoal (1 subgoal):\n 1. (join1 (x, y) = Some z) =\n    (wf_tuple n (A \\<union> B) z \\<and>\n     restrict A z = x \\<and> restrict B z = y)", "proof (induct \"(x, y)\" arbitrary: n x y z A B rule: join1.induct)"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and> restrict B z = [])\n 2. \\<And>xs ys n z A B.\n       \\<lbrakk>\\<And>n z A B.\n                   \\<lbrakk>wf_tuple n A xs; wf_tuple n B ys\\<rbrakk>\n                   \\<Longrightarrow> (join1 (xs, ys) = Some z) =\n                                     (wf_tuple n (A \\<union> B) z \\<and>\nrestrict A z = xs \\<and> restrict B z = ys);\n        wf_tuple n A (None # xs); wf_tuple n B (None # ys)\\<rbrakk>\n       \\<Longrightarrow> (join1 (None # xs, None # ys) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = None # xs \\<and>\n                          restrict B z = None # ys)\n 3. \\<And>x xs ys n z A B.\n       \\<lbrakk>\\<And>n z A B.\n                   \\<lbrakk>wf_tuple n A xs; wf_tuple n B ys\\<rbrakk>\n                   \\<Longrightarrow> (join1 (xs, ys) = Some z) =\n                                     (wf_tuple n (A \\<union> B) z \\<and>\nrestrict A z = xs \\<and> restrict B z = ys);\n        wf_tuple n A (Some x # xs); wf_tuple n B (None # ys)\\<rbrakk>\n       \\<Longrightarrow> (join1 (Some x # xs, None # ys) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = Some x # xs \\<and>\n                          restrict B z = None # ys)\n 4. \\<And>xs y ys n z A B.\n       \\<lbrakk>\\<And>n z A B.\n                   \\<lbrakk>wf_tuple n A xs; wf_tuple n B ys\\<rbrakk>\n                   \\<Longrightarrow> (join1 (xs, ys) = Some z) =\n                                     (wf_tuple n (A \\<union> B) z \\<and>\nrestrict A z = xs \\<and> restrict B z = ys);\n        wf_tuple n A (None # xs); wf_tuple n B (Some y # ys)\\<rbrakk>\n       \\<Longrightarrow> (join1 (None # xs, Some y # ys) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = None # xs \\<and>\n                          restrict B z = Some y # ys)\n 5. \\<And>x xs y ys n z A B.\n       \\<lbrakk>\\<And>n z A B.\n                   \\<lbrakk>x = y; wf_tuple n A xs; wf_tuple n B ys\\<rbrakk>\n                   \\<Longrightarrow> (join1 (xs, ys) = Some z) =\n                                     (wf_tuple n (A \\<union> B) z \\<and>\nrestrict A z = xs \\<and> restrict B z = ys);\n        wf_tuple n A (Some x # xs); wf_tuple n B (Some y # ys)\\<rbrakk>\n       \\<Longrightarrow> (join1 (Some x # xs, Some y # ys) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = Some x # xs \\<and>\n                          restrict B z = Some y # ys)\n 6. \\<And>v vc n z A B.\n       \\<lbrakk>wf_tuple n A (Some v # vc); wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 (Some v # vc, []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = Some v # vc \\<and>\n                          restrict B z = [])\n 7. \\<And>vb vc n z A B.\n       \\<lbrakk>wf_tuple n A (vb # vc); wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 (vb # vc, []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = vb # vc \\<and> restrict B z = [])\n 8. \\<And>vb vc n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B (vb # vc)\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], vb # vc) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and> restrict B z = vb # vc)\n 9. \\<And>va vc n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B (Some va # vc)\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], Some va # vc) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and>\n                          restrict B z = Some va # vc)", "case (2 xs ys)"], ["proof (state)\nthis:\n  \\<lbrakk>wf_tuple ?n ?A xs; wf_tuple ?n ?B ys\\<rbrakk>\n  \\<Longrightarrow> (join1 (xs, ys) = Some ?z) =\n                    (wf_tuple ?n (?A \\<union> ?B) ?z \\<and>\n                     restrict ?A ?z = xs \\<and> restrict ?B ?z = ys)\n  wf_tuple n A (None # xs)\n  wf_tuple n B (None # ys)\n\ngoal (9 subgoals):\n 1. \\<And>n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and> restrict B z = [])\n 2. \\<And>xs ys n z A B.\n       \\<lbrakk>\\<And>n z A B.\n                   \\<lbrakk>wf_tuple n A xs; wf_tuple n B ys\\<rbrakk>\n                   \\<Longrightarrow> (join1 (xs, ys) = Some z) =\n                                     (wf_tuple n (A \\<union> B) z \\<and>\nrestrict A z = xs \\<and> restrict B z = ys);\n        wf_tuple n A (None # xs); wf_tuple n B (None # ys)\\<rbrakk>\n       \\<Longrightarrow> (join1 (None # xs, None # ys) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = None # xs \\<and>\n                          restrict B z = None # ys)\n 3. \\<And>x xs ys n z A B.\n       \\<lbrakk>\\<And>n z A B.\n                   \\<lbrakk>wf_tuple n A xs; wf_tuple n B ys\\<rbrakk>\n                   \\<Longrightarrow> (join1 (xs, ys) = Some z) =\n                                     (wf_tuple n (A \\<union> B) z \\<and>\nrestrict A z = xs \\<and> restrict B z = ys);\n        wf_tuple n A (Some x # xs); wf_tuple n B (None # ys)\\<rbrakk>\n       \\<Longrightarrow> (join1 (Some x # xs, None # ys) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = Some x # xs \\<and>\n                          restrict B z = None # ys)\n 4. \\<And>xs y ys n z A B.\n       \\<lbrakk>\\<And>n z A B.\n                   \\<lbrakk>wf_tuple n A xs; wf_tuple n B ys\\<rbrakk>\n                   \\<Longrightarrow> (join1 (xs, ys) = Some z) =\n                                     (wf_tuple n (A \\<union> B) z \\<and>\nrestrict A z = xs \\<and> restrict B z = ys);\n        wf_tuple n A (None # xs); wf_tuple n B (Some y # ys)\\<rbrakk>\n       \\<Longrightarrow> (join1 (None # xs, Some y # ys) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = None # xs \\<and>\n                          restrict B z = Some y # ys)\n 5. \\<And>x xs y ys n z A B.\n       \\<lbrakk>\\<And>n z A B.\n                   \\<lbrakk>x = y; wf_tuple n A xs; wf_tuple n B ys\\<rbrakk>\n                   \\<Longrightarrow> (join1 (xs, ys) = Some z) =\n                                     (wf_tuple n (A \\<union> B) z \\<and>\nrestrict A z = xs \\<and> restrict B z = ys);\n        wf_tuple n A (Some x # xs); wf_tuple n B (Some y # ys)\\<rbrakk>\n       \\<Longrightarrow> (join1 (Some x # xs, Some y # ys) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = Some x # xs \\<and>\n                          restrict B z = Some y # ys)\n 6. \\<And>v vc n z A B.\n       \\<lbrakk>wf_tuple n A (Some v # vc); wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 (Some v # vc, []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = Some v # vc \\<and>\n                          restrict B z = [])\n 7. \\<And>vb vc n z A B.\n       \\<lbrakk>wf_tuple n A (vb # vc); wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 (vb # vc, []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = vb # vc \\<and> restrict B z = [])\n 8. \\<And>vb vc n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B (vb # vc)\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], vb # vc) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and> restrict B z = vb # vc)\n 9. \\<And>va vc n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B (Some va # vc)\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], Some va # vc) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and>\n                          restrict B z = Some va # vc)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>wf_tuple ?n ?A xs; wf_tuple ?n ?B ys\\<rbrakk>\n  \\<Longrightarrow> (join1 (xs, ys) = Some ?z) =\n                    (wf_tuple ?n (?A \\<union> ?B) ?z \\<and>\n                     restrict ?A ?z = xs \\<and> restrict ?B ?z = ys)\n  wf_tuple n A (None # xs)\n  wf_tuple n B (None # ys)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_tuple ?n ?A xs; wf_tuple ?n ?B ys\\<rbrakk>\n  \\<Longrightarrow> (join1 (xs, ys) = Some ?z) =\n                    (wf_tuple ?n (?A \\<union> ?B) ?z \\<and>\n                     restrict ?A ?z = xs \\<and> restrict ?B ?z = ys)\n  wf_tuple n A (None # xs)\n  wf_tuple n B (None # ys)\n\ngoal (1 subgoal):\n 1. (join1 (None # xs, None # ys) = Some z) =\n    (wf_tuple n (A \\<union> B) z \\<and>\n     restrict A z = None # xs \\<and> restrict B z = None # ys)", "by (cases z) (auto 4 0 simp: image_Un Un_Diff)+"], ["proof (state)\nthis:\n  (join1 (None # xs, None # ys) = Some z) =\n  (wf_tuple n (A \\<union> B) z \\<and>\n   restrict A z = None # xs \\<and> restrict B z = None # ys)\n\ngoal (8 subgoals):\n 1. \\<And>n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and> restrict B z = [])\n 2. \\<And>x xs ys n z A B.\n       \\<lbrakk>\\<And>n z A B.\n                   \\<lbrakk>wf_tuple n A xs; wf_tuple n B ys\\<rbrakk>\n                   \\<Longrightarrow> (join1 (xs, ys) = Some z) =\n                                     (wf_tuple n (A \\<union> B) z \\<and>\nrestrict A z = xs \\<and> restrict B z = ys);\n        wf_tuple n A (Some x # xs); wf_tuple n B (None # ys)\\<rbrakk>\n       \\<Longrightarrow> (join1 (Some x # xs, None # ys) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = Some x # xs \\<and>\n                          restrict B z = None # ys)\n 3. \\<And>xs y ys n z A B.\n       \\<lbrakk>\\<And>n z A B.\n                   \\<lbrakk>wf_tuple n A xs; wf_tuple n B ys\\<rbrakk>\n                   \\<Longrightarrow> (join1 (xs, ys) = Some z) =\n                                     (wf_tuple n (A \\<union> B) z \\<and>\nrestrict A z = xs \\<and> restrict B z = ys);\n        wf_tuple n A (None # xs); wf_tuple n B (Some y # ys)\\<rbrakk>\n       \\<Longrightarrow> (join1 (None # xs, Some y # ys) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = None # xs \\<and>\n                          restrict B z = Some y # ys)\n 4. \\<And>x xs y ys n z A B.\n       \\<lbrakk>\\<And>n z A B.\n                   \\<lbrakk>x = y; wf_tuple n A xs; wf_tuple n B ys\\<rbrakk>\n                   \\<Longrightarrow> (join1 (xs, ys) = Some z) =\n                                     (wf_tuple n (A \\<union> B) z \\<and>\nrestrict A z = xs \\<and> restrict B z = ys);\n        wf_tuple n A (Some x # xs); wf_tuple n B (Some y # ys)\\<rbrakk>\n       \\<Longrightarrow> (join1 (Some x # xs, Some y # ys) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = Some x # xs \\<and>\n                          restrict B z = Some y # ys)\n 5. \\<And>v vc n z A B.\n       \\<lbrakk>wf_tuple n A (Some v # vc); wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 (Some v # vc, []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = Some v # vc \\<and>\n                          restrict B z = [])\n 6. \\<And>vb vc n z A B.\n       \\<lbrakk>wf_tuple n A (vb # vc); wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 (vb # vc, []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = vb # vc \\<and> restrict B z = [])\n 7. \\<And>vb vc n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B (vb # vc)\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], vb # vc) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and> restrict B z = vb # vc)\n 8. \\<And>va vc n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B (Some va # vc)\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], Some va # vc) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and>\n                          restrict B z = Some va # vc)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and> restrict B z = [])\n 2. \\<And>x xs ys n z A B.\n       \\<lbrakk>\\<And>n z A B.\n                   \\<lbrakk>wf_tuple n A xs; wf_tuple n B ys\\<rbrakk>\n                   \\<Longrightarrow> (join1 (xs, ys) = Some z) =\n                                     (wf_tuple n (A \\<union> B) z \\<and>\nrestrict A z = xs \\<and> restrict B z = ys);\n        wf_tuple n A (Some x # xs); wf_tuple n B (None # ys)\\<rbrakk>\n       \\<Longrightarrow> (join1 (Some x # xs, None # ys) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = Some x # xs \\<and>\n                          restrict B z = None # ys)\n 3. \\<And>xs y ys n z A B.\n       \\<lbrakk>\\<And>n z A B.\n                   \\<lbrakk>wf_tuple n A xs; wf_tuple n B ys\\<rbrakk>\n                   \\<Longrightarrow> (join1 (xs, ys) = Some z) =\n                                     (wf_tuple n (A \\<union> B) z \\<and>\nrestrict A z = xs \\<and> restrict B z = ys);\n        wf_tuple n A (None # xs); wf_tuple n B (Some y # ys)\\<rbrakk>\n       \\<Longrightarrow> (join1 (None # xs, Some y # ys) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = None # xs \\<and>\n                          restrict B z = Some y # ys)\n 4. \\<And>x xs y ys n z A B.\n       \\<lbrakk>\\<And>n z A B.\n                   \\<lbrakk>x = y; wf_tuple n A xs; wf_tuple n B ys\\<rbrakk>\n                   \\<Longrightarrow> (join1 (xs, ys) = Some z) =\n                                     (wf_tuple n (A \\<union> B) z \\<and>\nrestrict A z = xs \\<and> restrict B z = ys);\n        wf_tuple n A (Some x # xs); wf_tuple n B (Some y # ys)\\<rbrakk>\n       \\<Longrightarrow> (join1 (Some x # xs, Some y # ys) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = Some x # xs \\<and>\n                          restrict B z = Some y # ys)\n 5. \\<And>v vc n z A B.\n       \\<lbrakk>wf_tuple n A (Some v # vc); wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 (Some v # vc, []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = Some v # vc \\<and>\n                          restrict B z = [])\n 6. \\<And>vb vc n z A B.\n       \\<lbrakk>wf_tuple n A (vb # vc); wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 (vb # vc, []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = vb # vc \\<and> restrict B z = [])\n 7. \\<And>vb vc n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B (vb # vc)\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], vb # vc) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and> restrict B z = vb # vc)\n 8. \\<And>va vc n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B (Some va # vc)\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], Some va # vc) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and>\n                          restrict B z = Some va # vc)", "case (3 x xs ys)"], ["proof (state)\nthis:\n  \\<lbrakk>wf_tuple ?n ?A xs; wf_tuple ?n ?B ys\\<rbrakk>\n  \\<Longrightarrow> (join1 (xs, ys) = Some ?z) =\n                    (wf_tuple ?n (?A \\<union> ?B) ?z \\<and>\n                     restrict ?A ?z = xs \\<and> restrict ?B ?z = ys)\n  wf_tuple n A (Some x # xs)\n  wf_tuple n B (None # ys)\n\ngoal (8 subgoals):\n 1. \\<And>n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and> restrict B z = [])\n 2. \\<And>x xs ys n z A B.\n       \\<lbrakk>\\<And>n z A B.\n                   \\<lbrakk>wf_tuple n A xs; wf_tuple n B ys\\<rbrakk>\n                   \\<Longrightarrow> (join1 (xs, ys) = Some z) =\n                                     (wf_tuple n (A \\<union> B) z \\<and>\nrestrict A z = xs \\<and> restrict B z = ys);\n        wf_tuple n A (Some x # xs); wf_tuple n B (None # ys)\\<rbrakk>\n       \\<Longrightarrow> (join1 (Some x # xs, None # ys) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = Some x # xs \\<and>\n                          restrict B z = None # ys)\n 3. \\<And>xs y ys n z A B.\n       \\<lbrakk>\\<And>n z A B.\n                   \\<lbrakk>wf_tuple n A xs; wf_tuple n B ys\\<rbrakk>\n                   \\<Longrightarrow> (join1 (xs, ys) = Some z) =\n                                     (wf_tuple n (A \\<union> B) z \\<and>\nrestrict A z = xs \\<and> restrict B z = ys);\n        wf_tuple n A (None # xs); wf_tuple n B (Some y # ys)\\<rbrakk>\n       \\<Longrightarrow> (join1 (None # xs, Some y # ys) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = None # xs \\<and>\n                          restrict B z = Some y # ys)\n 4. \\<And>x xs y ys n z A B.\n       \\<lbrakk>\\<And>n z A B.\n                   \\<lbrakk>x = y; wf_tuple n A xs; wf_tuple n B ys\\<rbrakk>\n                   \\<Longrightarrow> (join1 (xs, ys) = Some z) =\n                                     (wf_tuple n (A \\<union> B) z \\<and>\nrestrict A z = xs \\<and> restrict B z = ys);\n        wf_tuple n A (Some x # xs); wf_tuple n B (Some y # ys)\\<rbrakk>\n       \\<Longrightarrow> (join1 (Some x # xs, Some y # ys) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = Some x # xs \\<and>\n                          restrict B z = Some y # ys)\n 5. \\<And>v vc n z A B.\n       \\<lbrakk>wf_tuple n A (Some v # vc); wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 (Some v # vc, []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = Some v # vc \\<and>\n                          restrict B z = [])\n 6. \\<And>vb vc n z A B.\n       \\<lbrakk>wf_tuple n A (vb # vc); wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 (vb # vc, []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = vb # vc \\<and> restrict B z = [])\n 7. \\<And>vb vc n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B (vb # vc)\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], vb # vc) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and> restrict B z = vb # vc)\n 8. \\<And>va vc n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B (Some va # vc)\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], Some va # vc) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and>\n                          restrict B z = Some va # vc)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>wf_tuple ?n ?A xs; wf_tuple ?n ?B ys\\<rbrakk>\n  \\<Longrightarrow> (join1 (xs, ys) = Some ?z) =\n                    (wf_tuple ?n (?A \\<union> ?B) ?z \\<and>\n                     restrict ?A ?z = xs \\<and> restrict ?B ?z = ys)\n  wf_tuple n A (Some x # xs)\n  wf_tuple n B (None # ys)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_tuple ?n ?A xs; wf_tuple ?n ?B ys\\<rbrakk>\n  \\<Longrightarrow> (join1 (xs, ys) = Some ?z) =\n                    (wf_tuple ?n (?A \\<union> ?B) ?z \\<and>\n                     restrict ?A ?z = xs \\<and> restrict ?B ?z = ys)\n  wf_tuple n A (Some x # xs)\n  wf_tuple n B (None # ys)\n\ngoal (1 subgoal):\n 1. (join1 (Some x # xs, None # ys) = Some z) =\n    (wf_tuple n (A \\<union> B) z \\<and>\n     restrict A z = Some x # xs \\<and> restrict B z = None # ys)", "by (cases z) (auto 4 0 simp: image_Un Un_Diff)+"], ["proof (state)\nthis:\n  (join1 (Some x # xs, None # ys) = Some z) =\n  (wf_tuple n (A \\<union> B) z \\<and>\n   restrict A z = Some x # xs \\<and> restrict B z = None # ys)\n\ngoal (7 subgoals):\n 1. \\<And>n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and> restrict B z = [])\n 2. \\<And>xs y ys n z A B.\n       \\<lbrakk>\\<And>n z A B.\n                   \\<lbrakk>wf_tuple n A xs; wf_tuple n B ys\\<rbrakk>\n                   \\<Longrightarrow> (join1 (xs, ys) = Some z) =\n                                     (wf_tuple n (A \\<union> B) z \\<and>\nrestrict A z = xs \\<and> restrict B z = ys);\n        wf_tuple n A (None # xs); wf_tuple n B (Some y # ys)\\<rbrakk>\n       \\<Longrightarrow> (join1 (None # xs, Some y # ys) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = None # xs \\<and>\n                          restrict B z = Some y # ys)\n 3. \\<And>x xs y ys n z A B.\n       \\<lbrakk>\\<And>n z A B.\n                   \\<lbrakk>x = y; wf_tuple n A xs; wf_tuple n B ys\\<rbrakk>\n                   \\<Longrightarrow> (join1 (xs, ys) = Some z) =\n                                     (wf_tuple n (A \\<union> B) z \\<and>\nrestrict A z = xs \\<and> restrict B z = ys);\n        wf_tuple n A (Some x # xs); wf_tuple n B (Some y # ys)\\<rbrakk>\n       \\<Longrightarrow> (join1 (Some x # xs, Some y # ys) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = Some x # xs \\<and>\n                          restrict B z = Some y # ys)\n 4. \\<And>v vc n z A B.\n       \\<lbrakk>wf_tuple n A (Some v # vc); wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 (Some v # vc, []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = Some v # vc \\<and>\n                          restrict B z = [])\n 5. \\<And>vb vc n z A B.\n       \\<lbrakk>wf_tuple n A (vb # vc); wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 (vb # vc, []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = vb # vc \\<and> restrict B z = [])\n 6. \\<And>vb vc n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B (vb # vc)\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], vb # vc) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and> restrict B z = vb # vc)\n 7. \\<And>va vc n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B (Some va # vc)\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], Some va # vc) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and>\n                          restrict B z = Some va # vc)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and> restrict B z = [])\n 2. \\<And>xs y ys n z A B.\n       \\<lbrakk>\\<And>n z A B.\n                   \\<lbrakk>wf_tuple n A xs; wf_tuple n B ys\\<rbrakk>\n                   \\<Longrightarrow> (join1 (xs, ys) = Some z) =\n                                     (wf_tuple n (A \\<union> B) z \\<and>\nrestrict A z = xs \\<and> restrict B z = ys);\n        wf_tuple n A (None # xs); wf_tuple n B (Some y # ys)\\<rbrakk>\n       \\<Longrightarrow> (join1 (None # xs, Some y # ys) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = None # xs \\<and>\n                          restrict B z = Some y # ys)\n 3. \\<And>x xs y ys n z A B.\n       \\<lbrakk>\\<And>n z A B.\n                   \\<lbrakk>x = y; wf_tuple n A xs; wf_tuple n B ys\\<rbrakk>\n                   \\<Longrightarrow> (join1 (xs, ys) = Some z) =\n                                     (wf_tuple n (A \\<union> B) z \\<and>\nrestrict A z = xs \\<and> restrict B z = ys);\n        wf_tuple n A (Some x # xs); wf_tuple n B (Some y # ys)\\<rbrakk>\n       \\<Longrightarrow> (join1 (Some x # xs, Some y # ys) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = Some x # xs \\<and>\n                          restrict B z = Some y # ys)\n 4. \\<And>v vc n z A B.\n       \\<lbrakk>wf_tuple n A (Some v # vc); wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 (Some v # vc, []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = Some v # vc \\<and>\n                          restrict B z = [])\n 5. \\<And>vb vc n z A B.\n       \\<lbrakk>wf_tuple n A (vb # vc); wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 (vb # vc, []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = vb # vc \\<and> restrict B z = [])\n 6. \\<And>vb vc n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B (vb # vc)\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], vb # vc) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and> restrict B z = vb # vc)\n 7. \\<And>va vc n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B (Some va # vc)\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], Some va # vc) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and>\n                          restrict B z = Some va # vc)", "case (4 xs y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>wf_tuple ?n ?A xs; wf_tuple ?n ?B ys\\<rbrakk>\n  \\<Longrightarrow> (join1 (xs, ys) = Some ?z) =\n                    (wf_tuple ?n (?A \\<union> ?B) ?z \\<and>\n                     restrict ?A ?z = xs \\<and> restrict ?B ?z = ys)\n  wf_tuple n A (None # xs)\n  wf_tuple n B (Some y # ys)\n\ngoal (7 subgoals):\n 1. \\<And>n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and> restrict B z = [])\n 2. \\<And>xs y ys n z A B.\n       \\<lbrakk>\\<And>n z A B.\n                   \\<lbrakk>wf_tuple n A xs; wf_tuple n B ys\\<rbrakk>\n                   \\<Longrightarrow> (join1 (xs, ys) = Some z) =\n                                     (wf_tuple n (A \\<union> B) z \\<and>\nrestrict A z = xs \\<and> restrict B z = ys);\n        wf_tuple n A (None # xs); wf_tuple n B (Some y # ys)\\<rbrakk>\n       \\<Longrightarrow> (join1 (None # xs, Some y # ys) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = None # xs \\<and>\n                          restrict B z = Some y # ys)\n 3. \\<And>x xs y ys n z A B.\n       \\<lbrakk>\\<And>n z A B.\n                   \\<lbrakk>x = y; wf_tuple n A xs; wf_tuple n B ys\\<rbrakk>\n                   \\<Longrightarrow> (join1 (xs, ys) = Some z) =\n                                     (wf_tuple n (A \\<union> B) z \\<and>\nrestrict A z = xs \\<and> restrict B z = ys);\n        wf_tuple n A (Some x # xs); wf_tuple n B (Some y # ys)\\<rbrakk>\n       \\<Longrightarrow> (join1 (Some x # xs, Some y # ys) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = Some x # xs \\<and>\n                          restrict B z = Some y # ys)\n 4. \\<And>v vc n z A B.\n       \\<lbrakk>wf_tuple n A (Some v # vc); wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 (Some v # vc, []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = Some v # vc \\<and>\n                          restrict B z = [])\n 5. \\<And>vb vc n z A B.\n       \\<lbrakk>wf_tuple n A (vb # vc); wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 (vb # vc, []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = vb # vc \\<and> restrict B z = [])\n 6. \\<And>vb vc n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B (vb # vc)\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], vb # vc) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and> restrict B z = vb # vc)\n 7. \\<And>va vc n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B (Some va # vc)\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], Some va # vc) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and>\n                          restrict B z = Some va # vc)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>wf_tuple ?n ?A xs; wf_tuple ?n ?B ys\\<rbrakk>\n  \\<Longrightarrow> (join1 (xs, ys) = Some ?z) =\n                    (wf_tuple ?n (?A \\<union> ?B) ?z \\<and>\n                     restrict ?A ?z = xs \\<and> restrict ?B ?z = ys)\n  wf_tuple n A (None # xs)\n  wf_tuple n B (Some y # ys)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_tuple ?n ?A xs; wf_tuple ?n ?B ys\\<rbrakk>\n  \\<Longrightarrow> (join1 (xs, ys) = Some ?z) =\n                    (wf_tuple ?n (?A \\<union> ?B) ?z \\<and>\n                     restrict ?A ?z = xs \\<and> restrict ?B ?z = ys)\n  wf_tuple n A (None # xs)\n  wf_tuple n B (Some y # ys)\n\ngoal (1 subgoal):\n 1. (join1 (None # xs, Some y # ys) = Some z) =\n    (wf_tuple n (A \\<union> B) z \\<and>\n     restrict A z = None # xs \\<and> restrict B z = Some y # ys)", "by (cases z) (auto 4 0 simp: image_Un Un_Diff)+"], ["proof (state)\nthis:\n  (join1 (None # xs, Some y # ys) = Some z) =\n  (wf_tuple n (A \\<union> B) z \\<and>\n   restrict A z = None # xs \\<and> restrict B z = Some y # ys)\n\ngoal (6 subgoals):\n 1. \\<And>n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and> restrict B z = [])\n 2. \\<And>x xs y ys n z A B.\n       \\<lbrakk>\\<And>n z A B.\n                   \\<lbrakk>x = y; wf_tuple n A xs; wf_tuple n B ys\\<rbrakk>\n                   \\<Longrightarrow> (join1 (xs, ys) = Some z) =\n                                     (wf_tuple n (A \\<union> B) z \\<and>\nrestrict A z = xs \\<and> restrict B z = ys);\n        wf_tuple n A (Some x # xs); wf_tuple n B (Some y # ys)\\<rbrakk>\n       \\<Longrightarrow> (join1 (Some x # xs, Some y # ys) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = Some x # xs \\<and>\n                          restrict B z = Some y # ys)\n 3. \\<And>v vc n z A B.\n       \\<lbrakk>wf_tuple n A (Some v # vc); wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 (Some v # vc, []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = Some v # vc \\<and>\n                          restrict B z = [])\n 4. \\<And>vb vc n z A B.\n       \\<lbrakk>wf_tuple n A (vb # vc); wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 (vb # vc, []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = vb # vc \\<and> restrict B z = [])\n 5. \\<And>vb vc n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B (vb # vc)\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], vb # vc) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and> restrict B z = vb # vc)\n 6. \\<And>va vc n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B (Some va # vc)\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], Some va # vc) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and>\n                          restrict B z = Some va # vc)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and> restrict B z = [])\n 2. \\<And>x xs y ys n z A B.\n       \\<lbrakk>\\<And>n z A B.\n                   \\<lbrakk>x = y; wf_tuple n A xs; wf_tuple n B ys\\<rbrakk>\n                   \\<Longrightarrow> (join1 (xs, ys) = Some z) =\n                                     (wf_tuple n (A \\<union> B) z \\<and>\nrestrict A z = xs \\<and> restrict B z = ys);\n        wf_tuple n A (Some x # xs); wf_tuple n B (Some y # ys)\\<rbrakk>\n       \\<Longrightarrow> (join1 (Some x # xs, Some y # ys) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = Some x # xs \\<and>\n                          restrict B z = Some y # ys)\n 3. \\<And>v vc n z A B.\n       \\<lbrakk>wf_tuple n A (Some v # vc); wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 (Some v # vc, []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = Some v # vc \\<and>\n                          restrict B z = [])\n 4. \\<And>vb vc n z A B.\n       \\<lbrakk>wf_tuple n A (vb # vc); wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 (vb # vc, []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = vb # vc \\<and> restrict B z = [])\n 5. \\<And>vb vc n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B (vb # vc)\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], vb # vc) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and> restrict B z = vb # vc)\n 6. \\<And>va vc n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B (Some va # vc)\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], Some va # vc) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and>\n                          restrict B z = Some va # vc)", "case (5 x xs y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>x = y; wf_tuple ?n ?A xs; wf_tuple ?n ?B ys\\<rbrakk>\n  \\<Longrightarrow> (join1 (xs, ys) = Some ?z) =\n                    (wf_tuple ?n (?A \\<union> ?B) ?z \\<and>\n                     restrict ?A ?z = xs \\<and> restrict ?B ?z = ys)\n  wf_tuple n A (Some x # xs)\n  wf_tuple n B (Some y # ys)\n\ngoal (6 subgoals):\n 1. \\<And>n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and> restrict B z = [])\n 2. \\<And>x xs y ys n z A B.\n       \\<lbrakk>\\<And>n z A B.\n                   \\<lbrakk>x = y; wf_tuple n A xs; wf_tuple n B ys\\<rbrakk>\n                   \\<Longrightarrow> (join1 (xs, ys) = Some z) =\n                                     (wf_tuple n (A \\<union> B) z \\<and>\nrestrict A z = xs \\<and> restrict B z = ys);\n        wf_tuple n A (Some x # xs); wf_tuple n B (Some y # ys)\\<rbrakk>\n       \\<Longrightarrow> (join1 (Some x # xs, Some y # ys) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = Some x # xs \\<and>\n                          restrict B z = Some y # ys)\n 3. \\<And>v vc n z A B.\n       \\<lbrakk>wf_tuple n A (Some v # vc); wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 (Some v # vc, []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = Some v # vc \\<and>\n                          restrict B z = [])\n 4. \\<And>vb vc n z A B.\n       \\<lbrakk>wf_tuple n A (vb # vc); wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 (vb # vc, []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = vb # vc \\<and> restrict B z = [])\n 5. \\<And>vb vc n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B (vb # vc)\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], vb # vc) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and> restrict B z = vb # vc)\n 6. \\<And>va vc n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B (Some va # vc)\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], Some va # vc) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and>\n                          restrict B z = Some va # vc)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>x = y; wf_tuple ?n ?A xs; wf_tuple ?n ?B ys\\<rbrakk>\n  \\<Longrightarrow> (join1 (xs, ys) = Some ?z) =\n                    (wf_tuple ?n (?A \\<union> ?B) ?z \\<and>\n                     restrict ?A ?z = xs \\<and> restrict ?B ?z = ys)\n  wf_tuple n A (Some x # xs)\n  wf_tuple n B (Some y # ys)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>x = y; wf_tuple ?n ?A xs; wf_tuple ?n ?B ys\\<rbrakk>\n  \\<Longrightarrow> (join1 (xs, ys) = Some ?z) =\n                    (wf_tuple ?n (?A \\<union> ?B) ?z \\<and>\n                     restrict ?A ?z = xs \\<and> restrict ?B ?z = ys)\n  wf_tuple n A (Some x # xs)\n  wf_tuple n B (Some y # ys)\n\ngoal (1 subgoal):\n 1. (join1 (Some x # xs, Some y # ys) = Some z) =\n    (wf_tuple n (A \\<union> B) z \\<and>\n     restrict A z = Some x # xs \\<and> restrict B z = Some y # ys)", "by (cases z) (auto 4 0 simp: image_Un Un_Diff)+"], ["proof (state)\nthis:\n  (join1 (Some x # xs, Some y # ys) = Some z) =\n  (wf_tuple n (A \\<union> B) z \\<and>\n   restrict A z = Some x # xs \\<and> restrict B z = Some y # ys)\n\ngoal (5 subgoals):\n 1. \\<And>n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and> restrict B z = [])\n 2. \\<And>v vc n z A B.\n       \\<lbrakk>wf_tuple n A (Some v # vc); wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 (Some v # vc, []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = Some v # vc \\<and>\n                          restrict B z = [])\n 3. \\<And>vb vc n z A B.\n       \\<lbrakk>wf_tuple n A (vb # vc); wf_tuple n B []\\<rbrakk>\n       \\<Longrightarrow> (join1 (vb # vc, []) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = vb # vc \\<and> restrict B z = [])\n 4. \\<And>vb vc n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B (vb # vc)\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], vb # vc) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and> restrict B z = vb # vc)\n 5. \\<And>va vc n z A B.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n B (Some va # vc)\\<rbrakk>\n       \\<Longrightarrow> (join1 ([], Some va # vc) = Some z) =\n                         (wf_tuple n (A \\<union> B) z \\<and>\n                          restrict A z = [] \\<and>\n                          restrict B z = Some va # vc)", "qed auto"], ["", "lemma restrict_idle: \"wf_tuple n A v \\<Longrightarrow> restrict A v = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tuple n A v \\<Longrightarrow> restrict A v = v", "by (induct v arbitrary: n A) (auto split: if_splits)"], ["", "lemma map_the_restrict:\n  \"i \\<in> A \\<Longrightarrow> map the (restrict A v) ! i = map the v ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> A \\<Longrightarrow> map the (restrict A v) ! i = map the v ! i", "by (induct v arbitrary: A i) (auto simp: nth_Cons' gr0_conv_Suc split: option.splits)"], ["", "lemma join_restrict:\n  fixes X Y :: \"'a tuple set\"\n  assumes \"\\<And>v. v \\<in> X \\<Longrightarrow> wf_tuple n A v\" \"\\<And>v. v \\<in> Y \\<Longrightarrow> wf_tuple n B v\" \"\\<not> b \\<Longrightarrow> B \\<subseteq> A\"\n  shows \"v \\<in> join X b Y \\<longleftrightarrow>\n    wf_tuple n (A \\<union> B) v \\<and> restrict A v \\<in> X \\<and> (if b then restrict B v \\<in> Y else restrict B v \\<notin> Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<in> join X b Y) =\n    (wf_tuple n (A \\<union> B) v \\<and>\n     restrict A v \\<in> X \\<and>\n     (if b then restrict B v \\<in> Y else restrict B v \\<notin> Y))", "by (auto 4 4 simp: join_def Option.these_def image_iff assms wf_tuple_restrict sup_absorb1 restrict_idle\n    restrict_idle[OF assms(1)] elim: assms\n    dest: join1_Some_restrict[OF assms(1,2), THEN iffD1, rotated -1]\n    dest!: spec[of _ \"Some v\"]\n    intro!: exI[of _ \"Some v\"] join1_Some_restrict[THEN iffD2, symmetric] bexI[rotated])"], ["", "lemma join_restrict_table:\n  assumes \"table n A X\" \"table n B Y\" \"\\<not> b \\<Longrightarrow> B \\<subseteq> A\"\n  shows \"v \\<in> join X b Y \\<longleftrightarrow>\n    wf_tuple n (A \\<union> B) v \\<and> restrict A v \\<in> X \\<and> (if b then restrict B v \\<in> Y else restrict B v \\<notin> Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<in> join X b Y) =\n    (wf_tuple n (A \\<union> B) v \\<and>\n     restrict A v \\<in> X \\<and>\n     (if b then restrict B v \\<in> Y else restrict B v \\<notin> Y))", "using assms"], ["proof (prove)\nusing this:\n  table n A X\n  table n B Y\n  \\<not> b \\<Longrightarrow> B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. (v \\<in> join X b Y) =\n    (wf_tuple n (A \\<union> B) v \\<and>\n     restrict A v \\<in> X \\<and>\n     (if b then restrict B v \\<in> Y else restrict B v \\<notin> Y))", "unfolding table_def"], ["proof (prove)\nusing this:\n  Ball X (wf_tuple n A)\n  Ball Y (wf_tuple n B)\n  \\<not> b \\<Longrightarrow> B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. (v \\<in> join X b Y) =\n    (wf_tuple n (A \\<union> B) v \\<and>\n     restrict A v \\<in> X \\<and>\n     (if b then restrict B v \\<in> Y else restrict B v \\<notin> Y))", "by (simp add: join_restrict)"], ["", "lemma join_restrict_annotated:\n  fixes X Y :: \"'a tuple set\"\n  assumes \"\\<not> b =simp=> B \\<subseteq> A\"\n  shows \"join {v. wf_tuple n A v \\<and> P v} b {v. wf_tuple n B v \\<and> Q v} =\n    {v. wf_tuple n (A \\<union> B) v \\<and> P (restrict A v) \\<and> (if b then Q (restrict B v) else \\<not> Q (restrict B v))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. join {v. wf_tuple n A v \\<and> P v} b {v. wf_tuple n B v \\<and> Q v} =\n    {v. wf_tuple n (A \\<union> B) v \\<and>\n        P (restrict A v) \\<and>\n        (if b then Q (restrict B v) else \\<not> Q (restrict B v))}", "using assms"], ["proof (prove)\nusing this:\n  \\<not> b =simp=> B \\<subseteq> A\n\ngoal (1 subgoal):\n 1. join {v. wf_tuple n A v \\<and> P v} b {v. wf_tuple n B v \\<and> Q v} =\n    {v. wf_tuple n (A \\<union> B) v \\<and>\n        P (restrict A v) \\<and>\n        (if b then Q (restrict B v) else \\<not> Q (restrict B v))}", "by (intro set_eqI, subst join_restrict) (auto simp: wf_tuple_restrict_simple simp_implies_def)"], ["", "lemma in_joinI: \"table n A X \\<Longrightarrow> table n B Y \\<Longrightarrow> (\\<not>b \\<Longrightarrow> B \\<subseteq> A) \\<Longrightarrow> wf_tuple n (A \\<union> B) v \\<Longrightarrow>\n  restrict A v \\<in> X \\<Longrightarrow> (b \\<Longrightarrow> restrict B v \\<in> Y) \\<Longrightarrow> (\\<not>b \\<Longrightarrow> restrict B v \\<notin> Y) \\<Longrightarrow> v \\<in> join X b Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>table n A X; table n B Y;\n     \\<not> b \\<Longrightarrow> B \\<subseteq> A;\n     wf_tuple n (A \\<union> B) v; restrict A v \\<in> X;\n     b \\<Longrightarrow> restrict B v \\<in> Y;\n     \\<not> b \\<Longrightarrow> restrict B v \\<notin> Y\\<rbrakk>\n    \\<Longrightarrow> v \\<in> join X b Y", "unfolding table_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ball X (wf_tuple n A); Ball Y (wf_tuple n B);\n     \\<not> b \\<Longrightarrow> B \\<subseteq> A;\n     wf_tuple n (A \\<union> B) v; restrict A v \\<in> X;\n     b \\<Longrightarrow> restrict B v \\<in> Y;\n     \\<not> b \\<Longrightarrow> restrict B v \\<notin> Y\\<rbrakk>\n    \\<Longrightarrow> v \\<in> join X b Y", "by (subst join_restrict) (auto)"], ["", "lemma in_joinE: \"v \\<in> join X b Y \\<Longrightarrow> table n A X \\<Longrightarrow> table n B Y \\<Longrightarrow> (\\<not> b \\<Longrightarrow> B \\<subseteq> A) \\<Longrightarrow>\n  (wf_tuple n (A \\<union> B) v \\<Longrightarrow> restrict A v \\<in> X \\<Longrightarrow> if b then restrict B v \\<in> Y else restrict B v \\<notin> Y \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> join X b Y; table n A X; table n B Y;\n     \\<not> b \\<Longrightarrow> B \\<subseteq> A;\n     \\<lbrakk>wf_tuple n (A \\<union> B) v; restrict A v \\<in> X;\n      if b then restrict B v \\<in> Y else restrict B v \\<notin> Y\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "unfolding table_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> join X b Y; Ball X (wf_tuple n A);\n     Ball Y (wf_tuple n B); \\<not> b \\<Longrightarrow> B \\<subseteq> A;\n     \\<lbrakk>wf_tuple n (A \\<union> B) v; restrict A v \\<in> X;\n      if b then restrict B v \\<in> Y else restrict B v \\<notin> Y\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (subst (asm) join_restrict) (auto)"], ["", "definition qtable :: \"nat \\<Rightarrow> nat set \\<Rightarrow> ('a tuple \\<Rightarrow> bool) \\<Rightarrow> ('a tuple \\<Rightarrow> bool) \\<Rightarrow>\n  'a table \\<Rightarrow> bool\" where\n  \"qtable n A P Q X \\<longleftrightarrow> table n A X \\<and> (\\<forall>x. (x \\<in> X \\<and> P x \\<longrightarrow> Q x) \\<and> (wf_tuple n A x \\<and> P x \\<and> Q x \\<longrightarrow> x \\<in> X))\""], ["", "abbreviation wf_table where\n  \"wf_table n A Q X \\<equiv> qtable n A (\\<lambda>_. True) Q X\""], ["", "lemma wf_table_iff: \"wf_table n A Q X \\<longleftrightarrow> (\\<forall>x. x \\<in> X \\<longleftrightarrow> (Q x \\<and> wf_tuple n A x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_table n A Q X =\n    (\\<forall>x. (x \\<in> X) = (Q x \\<and> wf_tuple n A x))", "unfolding qtable_def table_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Ball X (wf_tuple n A) \\<and>\n     (\\<forall>x.\n         (x \\<in> X \\<and> True \\<longrightarrow> Q x) \\<and>\n         (wf_tuple n A x \\<and> True \\<and> Q x \\<longrightarrow>\n          x \\<in> X))) =\n    (\\<forall>x. (x \\<in> X) = (Q x \\<and> wf_tuple n A x))", "by auto"], ["", "lemma table_wf_table: \"table n A X = wf_table n A (\\<lambda>v. v \\<in> X) X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. table n A X = wf_table n A (\\<lambda>v. v \\<in> X) X", "unfolding table_def wf_table_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball X (wf_tuple n A) =\n    (\\<forall>x. (x \\<in> X) = (x \\<in> X \\<and> wf_tuple n A x))", "by auto"], ["", "lemma qtableI: \"table n A X \\<Longrightarrow>\n  (\\<And>x. x \\<in> X \\<Longrightarrow> wf_tuple n A x \\<Longrightarrow> P x \\<Longrightarrow> Q x) \\<Longrightarrow>\n  (\\<And>x. wf_tuple n A x \\<Longrightarrow> P x \\<Longrightarrow> Q x \\<Longrightarrow> x \\<in> X) \\<Longrightarrow>\n  qtable n A P Q X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>table n A X;\n     \\<And>x.\n        \\<lbrakk>x \\<in> X; wf_tuple n A x; P x\\<rbrakk>\n        \\<Longrightarrow> Q x;\n     \\<And>x.\n        \\<lbrakk>wf_tuple n A x; P x; Q x\\<rbrakk>\n        \\<Longrightarrow> x \\<in> X\\<rbrakk>\n    \\<Longrightarrow> qtable n A P Q X", "unfolding qtable_def table_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ball X (wf_tuple n A);\n     \\<And>x.\n        \\<lbrakk>x \\<in> X; wf_tuple n A x; P x\\<rbrakk>\n        \\<Longrightarrow> Q x;\n     \\<And>x.\n        \\<lbrakk>wf_tuple n A x; P x; Q x\\<rbrakk>\n        \\<Longrightarrow> x \\<in> X\\<rbrakk>\n    \\<Longrightarrow> Ball X (wf_tuple n A) \\<and>\n                      (\\<forall>x.\n                          (x \\<in> X \\<and> P x \\<longrightarrow>\n                           Q x) \\<and>\n                          (wf_tuple n A x \\<and>\n                           P x \\<and> Q x \\<longrightarrow>\n                           x \\<in> X))", "by auto"], ["", "lemma in_qtableI: \"qtable n A P Q X \\<Longrightarrow> wf_tuple n A x \\<Longrightarrow> P x \\<Longrightarrow> Q x \\<Longrightarrow> x \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>qtable n A P Q X; wf_tuple n A x; P x; Q x\\<rbrakk>\n    \\<Longrightarrow> x \\<in> X", "unfolding qtable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>table n A X \\<and>\n             (\\<forall>x.\n                 (x \\<in> X \\<and> P x \\<longrightarrow> Q x) \\<and>\n                 (wf_tuple n A x \\<and> P x \\<and> Q x \\<longrightarrow>\n                  x \\<in> X));\n     wf_tuple n A x; P x; Q x\\<rbrakk>\n    \\<Longrightarrow> x \\<in> X", "by blast"], ["", "lemma in_qtableE: \"qtable n A P Q X \\<Longrightarrow> x \\<in> X \\<Longrightarrow> P x \\<Longrightarrow> (wf_tuple n A x \\<Longrightarrow> Q x \\<Longrightarrow> R) \\<Longrightarrow> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>qtable n A P Q X; x \\<in> X; P x;\n     \\<lbrakk>wf_tuple n A x; Q x\\<rbrakk> \\<Longrightarrow> R\\<rbrakk>\n    \\<Longrightarrow> R", "unfolding qtable_def table_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ball X (wf_tuple n A) \\<and>\n             (\\<forall>x.\n                 (x \\<in> X \\<and> P x \\<longrightarrow> Q x) \\<and>\n                 (wf_tuple n A x \\<and> P x \\<and> Q x \\<longrightarrow>\n                  x \\<in> X));\n     x \\<in> X; P x;\n     \\<lbrakk>wf_tuple n A x; Q x\\<rbrakk> \\<Longrightarrow> R\\<rbrakk>\n    \\<Longrightarrow> R", "by blast"], ["", "lemma qtable_empty: \"(\\<And>x. wf_tuple n A x \\<Longrightarrow> P x \\<Longrightarrow> Q x \\<Longrightarrow> False) \\<Longrightarrow> qtable n A P Q empty_table\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>wf_tuple n A x; P x; Q x\\<rbrakk>\n        \\<Longrightarrow> False) \\<Longrightarrow>\n    qtable n A P Q empty_table", "unfolding qtable_def table_def empty_table_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>wf_tuple n A x; P x; Q x\\<rbrakk>\n        \\<Longrightarrow> False) \\<Longrightarrow>\n    Ball {} (wf_tuple n A) \\<and>\n    (\\<forall>x.\n        (x \\<in> {} \\<and> P x \\<longrightarrow> Q x) \\<and>\n        (wf_tuple n A x \\<and> P x \\<and> Q x \\<longrightarrow> x \\<in> {}))", "by auto"], ["", "lemma qtable_empty_iff: \"qtable n A P Q empty_table = (\\<forall>x. wf_tuple n A x \\<longrightarrow> P x \\<longrightarrow> Q x \\<longrightarrow> False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qtable n A P Q empty_table =\n    (\\<forall>x.\n        wf_tuple n A x \\<longrightarrow>\n        P x \\<longrightarrow> Q x \\<longrightarrow> False)", "unfolding qtable_def table_def empty_table_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Ball {} (wf_tuple n A) \\<and>\n     (\\<forall>x.\n         (x \\<in> {} \\<and> P x \\<longrightarrow> Q x) \\<and>\n         (wf_tuple n A x \\<and> P x \\<and> Q x \\<longrightarrow>\n          x \\<in> {}))) =\n    (\\<forall>x.\n        wf_tuple n A x \\<longrightarrow>\n        P x \\<longrightarrow> Q x \\<longrightarrow> False)", "by auto"], ["", "lemma qtable_unit_table: \"(\\<And>x. wf_tuple n {} x \\<Longrightarrow> P x \\<Longrightarrow> Q x) \\<Longrightarrow> qtable n {} P Q (unit_table n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>wf_tuple n {} x; P x\\<rbrakk>\n        \\<Longrightarrow> Q x) \\<Longrightarrow>\n    qtable n {} P Q (unit_table n)", "unfolding qtable_def table_def in_unit_table"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>wf_tuple n {} x; P x\\<rbrakk>\n        \\<Longrightarrow> Q x) \\<Longrightarrow>\n    Ball (unit_table n) (wf_tuple n {}) \\<and>\n    (\\<forall>x.\n        (wf_tuple n {} x \\<and> P x \\<longrightarrow> Q x) \\<and>\n        (wf_tuple n {} x \\<and> P x \\<and> Q x \\<longrightarrow>\n         wf_tuple n {} x))", "by auto"], ["", "lemma qtable_union: \"qtable n A P Q1 X \\<Longrightarrow> qtable n A P Q2 Y \\<Longrightarrow>\n  (\\<And>x. wf_tuple n A x \\<Longrightarrow> P x \\<Longrightarrow> Q x \\<longleftrightarrow> Q1 x \\<or> Q2 x) \\<Longrightarrow> qtable n A P Q (X \\<union> Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>qtable n A P Q1 X; qtable n A P Q2 Y;\n     \\<And>x.\n        \\<lbrakk>wf_tuple n A x; P x\\<rbrakk>\n        \\<Longrightarrow> Q x = (Q1 x \\<or> Q2 x)\\<rbrakk>\n    \\<Longrightarrow> qtable n A P Q (X \\<union> Y)", "unfolding qtable_def table_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ball X (wf_tuple n A) \\<and>\n             (\\<forall>x.\n                 (x \\<in> X \\<and> P x \\<longrightarrow> Q1 x) \\<and>\n                 (wf_tuple n A x \\<and> P x \\<and> Q1 x \\<longrightarrow>\n                  x \\<in> X));\n     Ball Y (wf_tuple n A) \\<and>\n     (\\<forall>x.\n         (x \\<in> Y \\<and> P x \\<longrightarrow> Q2 x) \\<and>\n         (wf_tuple n A x \\<and> P x \\<and> Q2 x \\<longrightarrow>\n          x \\<in> Y));\n     \\<And>x.\n        \\<lbrakk>wf_tuple n A x; P x\\<rbrakk>\n        \\<Longrightarrow> Q x = (Q1 x \\<or> Q2 x)\\<rbrakk>\n    \\<Longrightarrow> Ball (X \\<union> Y) (wf_tuple n A) \\<and>\n                      (\\<forall>x.\n                          (x \\<in> X \\<union> Y \\<and> P x \\<longrightarrow>\n                           Q x) \\<and>\n                          (wf_tuple n A x \\<and>\n                           P x \\<and> Q x \\<longrightarrow>\n                           x \\<in> X \\<union> Y))", "by blast"], ["", "lemma qtable_Union: \"finite I \\<Longrightarrow> (\\<And>i. i \\<in> I \\<Longrightarrow> qtable n A P (Qi i) (Xi i)) \\<Longrightarrow>\n  (\\<And>x. wf_tuple n A x \\<Longrightarrow> P x \\<Longrightarrow> Q x \\<longleftrightarrow> (\\<exists>i \\<in> I. Qi i x)) \\<Longrightarrow> qtable n A P Q (\\<Union>i \\<in> I. Xi i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite I;\n     \\<And>i. i \\<in> I \\<Longrightarrow> qtable n A P (Qi i) (Xi i);\n     \\<And>x.\n        \\<lbrakk>wf_tuple n A x; P x\\<rbrakk>\n        \\<Longrightarrow> Q x = (\\<exists>i\\<in>I. Qi i x)\\<rbrakk>\n    \\<Longrightarrow> qtable n A P Q (\\<Union> (Xi ` I))", "proof (induct I arbitrary: Q rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q.\n       \\<lbrakk>\\<And>i.\n                   i \\<in> {} \\<Longrightarrow> qtable n A P (Qi i) (Xi i);\n        \\<And>x.\n           \\<lbrakk>wf_tuple n A x; P x\\<rbrakk>\n           \\<Longrightarrow> Q x = (\\<exists>i\\<in>{}. Qi i x)\\<rbrakk>\n       \\<Longrightarrow> qtable n A P Q (\\<Union> (Xi ` {}))\n 2. \\<And>x F Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>Q.\n           \\<lbrakk>\\<And>i.\n                       i \\<in> F \\<Longrightarrow>\n                       qtable n A P (Qi i) (Xi i);\n            \\<And>x.\n               \\<lbrakk>wf_tuple n A x; P x\\<rbrakk>\n               \\<Longrightarrow> Q x = (\\<exists>i\\<in>F. Qi i x)\\<rbrakk>\n           \\<Longrightarrow> qtable n A P Q (\\<Union> (Xi ` F));\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> qtable n A P (Qi i) (Xi i);\n        \\<And>xa.\n           \\<lbrakk>wf_tuple n A xa; P xa\\<rbrakk>\n           \\<Longrightarrow> Q xa =\n                             (\\<exists>i\\<in>insert x F. Qi i xa)\\<rbrakk>\n       \\<Longrightarrow> qtable n A P Q (\\<Union> (Xi ` insert x F))", "case (insert i F)"], ["proof (state)\nthis:\n  finite F\n  i \\<notin> F\n  \\<lbrakk>\\<And>i. i \\<in> F \\<Longrightarrow> qtable n A P (Qi i) (Xi i);\n   \\<And>x.\n      \\<lbrakk>wf_tuple n A x; P x\\<rbrakk>\n      \\<Longrightarrow> ?Q x = (\\<exists>i\\<in>F. Qi i x)\\<rbrakk>\n  \\<Longrightarrow> qtable n A P ?Q (\\<Union> (Xi ` F))\n  ?i \\<in> insert i F \\<Longrightarrow> qtable n A P (Qi ?i) (Xi ?i)\n  \\<lbrakk>wf_tuple n A ?x; P ?x\\<rbrakk>\n  \\<Longrightarrow> Q ?x = (\\<exists>i\\<in>insert i F. Qi i ?x)\n\ngoal (2 subgoals):\n 1. \\<And>Q.\n       \\<lbrakk>\\<And>i.\n                   i \\<in> {} \\<Longrightarrow> qtable n A P (Qi i) (Xi i);\n        \\<And>x.\n           \\<lbrakk>wf_tuple n A x; P x\\<rbrakk>\n           \\<Longrightarrow> Q x = (\\<exists>i\\<in>{}. Qi i x)\\<rbrakk>\n       \\<Longrightarrow> qtable n A P Q (\\<Union> (Xi ` {}))\n 2. \\<And>x F Q.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>Q.\n           \\<lbrakk>\\<And>i.\n                       i \\<in> F \\<Longrightarrow>\n                       qtable n A P (Qi i) (Xi i);\n            \\<And>x.\n               \\<lbrakk>wf_tuple n A x; P x\\<rbrakk>\n               \\<Longrightarrow> Q x = (\\<exists>i\\<in>F. Qi i x)\\<rbrakk>\n           \\<Longrightarrow> qtable n A P Q (\\<Union> (Xi ` F));\n        \\<And>i.\n           i \\<in> insert x F \\<Longrightarrow> qtable n A P (Qi i) (Xi i);\n        \\<And>xa.\n           \\<lbrakk>wf_tuple n A xa; P xa\\<rbrakk>\n           \\<Longrightarrow> Q xa =\n                             (\\<exists>i\\<in>insert x F. Qi i xa)\\<rbrakk>\n       \\<Longrightarrow> qtable n A P Q (\\<Union> (Xi ` insert x F))", "then"], ["proof (chain)\npicking this:\n  finite F\n  i \\<notin> F\n  \\<lbrakk>\\<And>i. i \\<in> F \\<Longrightarrow> qtable n A P (Qi i) (Xi i);\n   \\<And>x.\n      \\<lbrakk>wf_tuple n A x; P x\\<rbrakk>\n      \\<Longrightarrow> ?Q x = (\\<exists>i\\<in>F. Qi i x)\\<rbrakk>\n  \\<Longrightarrow> qtable n A P ?Q (\\<Union> (Xi ` F))\n  ?i \\<in> insert i F \\<Longrightarrow> qtable n A P (Qi ?i) (Xi ?i)\n  \\<lbrakk>wf_tuple n A ?x; P ?x\\<rbrakk>\n  \\<Longrightarrow> Q ?x = (\\<exists>i\\<in>insert i F. Qi i ?x)", "show ?case"], ["proof (prove)\nusing this:\n  finite F\n  i \\<notin> F\n  \\<lbrakk>\\<And>i. i \\<in> F \\<Longrightarrow> qtable n A P (Qi i) (Xi i);\n   \\<And>x.\n      \\<lbrakk>wf_tuple n A x; P x\\<rbrakk>\n      \\<Longrightarrow> ?Q x = (\\<exists>i\\<in>F. Qi i x)\\<rbrakk>\n  \\<Longrightarrow> qtable n A P ?Q (\\<Union> (Xi ` F))\n  ?i \\<in> insert i F \\<Longrightarrow> qtable n A P (Qi ?i) (Xi ?i)\n  \\<lbrakk>wf_tuple n A ?x; P ?x\\<rbrakk>\n  \\<Longrightarrow> Q ?x = (\\<exists>i\\<in>insert i F. Qi i ?x)\n\ngoal (1 subgoal):\n 1. qtable n A P Q (\\<Union> (Xi ` insert i F))", "by (auto intro!: qtable_union[where ?Q1.0 = \"Qi i\" and ?Q2.0 = \"\\<lambda>x. \\<exists>i\\<in>F. Qi i x\"])"], ["proof (state)\nthis:\n  qtable n A P Q (\\<Union> (Xi ` insert i F))\n\ngoal (1 subgoal):\n 1. \\<And>Q.\n       \\<lbrakk>\\<And>i.\n                   i \\<in> {} \\<Longrightarrow> qtable n A P (Qi i) (Xi i);\n        \\<And>x.\n           \\<lbrakk>wf_tuple n A x; P x\\<rbrakk>\n           \\<Longrightarrow> Q x = (\\<exists>i\\<in>{}. Qi i x)\\<rbrakk>\n       \\<Longrightarrow> qtable n A P Q (\\<Union> (Xi ` {}))", "qed (auto intro!: qtable_empty[unfolded empty_table_def])"], ["", "lemma qtable_join: \n  assumes \"qtable n A P Q1 X\" \"qtable n B P Q2 Y\" \"\\<not> b \\<Longrightarrow> B \\<subseteq> A\" \"C = A \\<union> B\"\n  \"\\<And>x. wf_tuple n C x \\<Longrightarrow> P x \\<Longrightarrow> P (restrict A x) \\<and> P (restrict B x)\"\n  \"\\<And>x. b \\<Longrightarrow> wf_tuple n C x \\<Longrightarrow> P x \\<Longrightarrow> Q x \\<longleftrightarrow> Q1 (restrict A x) \\<and> Q2 (restrict B x)\"\n  \"\\<And>x. \\<not> b \\<Longrightarrow> wf_tuple n C x \\<Longrightarrow> P x \\<Longrightarrow> Q x \\<longleftrightarrow> Q1 (restrict A x) \\<and> \\<not> Q2 (restrict B x)\"\n  shows \"qtable n C P Q (join X b Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qtable n C P Q (join X b Y)", "proof (rule qtableI)"], ["proof (state)\ngoal (3 subgoals):\n 1. table n C (join X b Y)\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> join X b Y; wf_tuple n C x; P x\\<rbrakk>\n       \\<Longrightarrow> Q x\n 3. \\<And>x.\n       \\<lbrakk>wf_tuple n C x; P x; Q x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> join X b Y", "from assms(1-4)"], ["proof (chain)\npicking this:\n  qtable n A P Q1 X\n  qtable n B P Q2 Y\n  \\<not> b \\<Longrightarrow> B \\<subseteq> A\n  C = A \\<union> B", "show \"table n C (join X b Y)\""], ["proof (prove)\nusing this:\n  qtable n A P Q1 X\n  qtable n B P Q2 Y\n  \\<not> b \\<Longrightarrow> B \\<subseteq> A\n  C = A \\<union> B\n\ngoal (1 subgoal):\n 1. table n C (join X b Y)", "unfolding qtable_def"], ["proof (prove)\nusing this:\n  table n A X \\<and>\n  (\\<forall>x.\n      (x \\<in> X \\<and> P x \\<longrightarrow> Q1 x) \\<and>\n      (wf_tuple n A x \\<and> P x \\<and> Q1 x \\<longrightarrow> x \\<in> X))\n  table n B Y \\<and>\n  (\\<forall>x.\n      (x \\<in> Y \\<and> P x \\<longrightarrow> Q2 x) \\<and>\n      (wf_tuple n B x \\<and> P x \\<and> Q2 x \\<longrightarrow> x \\<in> Y))\n  \\<not> b \\<Longrightarrow> B \\<subseteq> A\n  C = A \\<union> B\n\ngoal (1 subgoal):\n 1. table n C (join X b Y)", "by (auto simp: join_table)"], ["proof (state)\nthis:\n  table n C (join X b Y)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> join X b Y; wf_tuple n C x; P x\\<rbrakk>\n       \\<Longrightarrow> Q x\n 2. \\<And>x.\n       \\<lbrakk>wf_tuple n C x; P x; Q x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> join X b Y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> join X b Y; wf_tuple n C x; P x\\<rbrakk>\n       \\<Longrightarrow> Q x\n 2. \\<And>x.\n       \\<lbrakk>wf_tuple n C x; P x; Q x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> join X b Y", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> join X b Y; wf_tuple n C x; P x\\<rbrakk>\n       \\<Longrightarrow> Q x\n 2. \\<And>x.\n       \\<lbrakk>wf_tuple n C x; P x; Q x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> join X b Y", "assume \"x \\<in> join X b Y\" \"wf_tuple n C x\" \"P x\""], ["proof (state)\nthis:\n  x \\<in> join X b Y\n  wf_tuple n C x\n  P x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> join X b Y; wf_tuple n C x; P x\\<rbrakk>\n       \\<Longrightarrow> Q x\n 2. \\<And>x.\n       \\<lbrakk>wf_tuple n C x; P x; Q x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> join X b Y", "with assms(1-3) assms(5-7)[of x]"], ["proof (chain)\npicking this:\n  qtable n A P Q1 X\n  qtable n B P Q2 Y\n  \\<not> b \\<Longrightarrow> B \\<subseteq> A\n  \\<lbrakk>wf_tuple n C x; P x\\<rbrakk>\n  \\<Longrightarrow> P (restrict A x) \\<and> P (restrict B x)\n  \\<lbrakk>b; wf_tuple n C x; P x\\<rbrakk>\n  \\<Longrightarrow> Q x = (Q1 (restrict A x) \\<and> Q2 (restrict B x))\n  \\<lbrakk>\\<not> b; wf_tuple n C x; P x\\<rbrakk>\n  \\<Longrightarrow> Q x =\n                    (Q1 (restrict A x) \\<and> \\<not> Q2 (restrict B x))\n  x \\<in> join X b Y\n  wf_tuple n C x\n  P x", "show \"Q x\""], ["proof (prove)\nusing this:\n  qtable n A P Q1 X\n  qtable n B P Q2 Y\n  \\<not> b \\<Longrightarrow> B \\<subseteq> A\n  \\<lbrakk>wf_tuple n C x; P x\\<rbrakk>\n  \\<Longrightarrow> P (restrict A x) \\<and> P (restrict B x)\n  \\<lbrakk>b; wf_tuple n C x; P x\\<rbrakk>\n  \\<Longrightarrow> Q x = (Q1 (restrict A x) \\<and> Q2 (restrict B x))\n  \\<lbrakk>\\<not> b; wf_tuple n C x; P x\\<rbrakk>\n  \\<Longrightarrow> Q x =\n                    (Q1 (restrict A x) \\<and> \\<not> Q2 (restrict B x))\n  x \\<in> join X b Y\n  wf_tuple n C x\n  P x\n\ngoal (1 subgoal):\n 1. Q x", "unfolding qtable_def"], ["proof (prove)\nusing this:\n  table n A X \\<and>\n  (\\<forall>x.\n      (x \\<in> X \\<and> P x \\<longrightarrow> Q1 x) \\<and>\n      (wf_tuple n A x \\<and> P x \\<and> Q1 x \\<longrightarrow> x \\<in> X))\n  table n B Y \\<and>\n  (\\<forall>x.\n      (x \\<in> Y \\<and> P x \\<longrightarrow> Q2 x) \\<and>\n      (wf_tuple n B x \\<and> P x \\<and> Q2 x \\<longrightarrow> x \\<in> Y))\n  \\<not> b \\<Longrightarrow> B \\<subseteq> A\n  \\<lbrakk>wf_tuple n C x; P x\\<rbrakk>\n  \\<Longrightarrow> P (restrict A x) \\<and> P (restrict B x)\n  \\<lbrakk>b; wf_tuple n C x; P x\\<rbrakk>\n  \\<Longrightarrow> Q x = (Q1 (restrict A x) \\<and> Q2 (restrict B x))\n  \\<lbrakk>\\<not> b; wf_tuple n C x; P x\\<rbrakk>\n  \\<Longrightarrow> Q x =\n                    (Q1 (restrict A x) \\<and> \\<not> Q2 (restrict B x))\n  x \\<in> join X b Y\n  wf_tuple n C x\n  P x\n\ngoal (1 subgoal):\n 1. Q x", "by (auto 0 2 simp: wf_tuple_restrict_simple elim!: in_joinE split: if_splits)"], ["proof (state)\nthis:\n  Q x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>wf_tuple n C x; P x; Q x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> join X b Y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>wf_tuple n C x; P x; Q x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> join X b Y", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>wf_tuple n C x; P x; Q x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> join X b Y", "assume \"wf_tuple n C x\" \"P x\" \"Q x\""], ["proof (state)\nthis:\n  wf_tuple n C x\n  P x\n  Q x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>wf_tuple n C x; P x; Q x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> join X b Y", "with assms(1-4) assms(5-7)[of x]"], ["proof (chain)\npicking this:\n  qtable n A P Q1 X\n  qtable n B P Q2 Y\n  \\<not> b \\<Longrightarrow> B \\<subseteq> A\n  C = A \\<union> B\n  \\<lbrakk>wf_tuple n C x; P x\\<rbrakk>\n  \\<Longrightarrow> P (restrict A x) \\<and> P (restrict B x)\n  \\<lbrakk>b; wf_tuple n C x; P x\\<rbrakk>\n  \\<Longrightarrow> Q x = (Q1 (restrict A x) \\<and> Q2 (restrict B x))\n  \\<lbrakk>\\<not> b; wf_tuple n C x; P x\\<rbrakk>\n  \\<Longrightarrow> Q x =\n                    (Q1 (restrict A x) \\<and> \\<not> Q2 (restrict B x))\n  wf_tuple n C x\n  P x\n  Q x", "show \"x \\<in> join X b Y\""], ["proof (prove)\nusing this:\n  qtable n A P Q1 X\n  qtable n B P Q2 Y\n  \\<not> b \\<Longrightarrow> B \\<subseteq> A\n  C = A \\<union> B\n  \\<lbrakk>wf_tuple n C x; P x\\<rbrakk>\n  \\<Longrightarrow> P (restrict A x) \\<and> P (restrict B x)\n  \\<lbrakk>b; wf_tuple n C x; P x\\<rbrakk>\n  \\<Longrightarrow> Q x = (Q1 (restrict A x) \\<and> Q2 (restrict B x))\n  \\<lbrakk>\\<not> b; wf_tuple n C x; P x\\<rbrakk>\n  \\<Longrightarrow> Q x =\n                    (Q1 (restrict A x) \\<and> \\<not> Q2 (restrict B x))\n  wf_tuple n C x\n  P x\n  Q x\n\ngoal (1 subgoal):\n 1. x \\<in> join X b Y", "unfolding qtable_def"], ["proof (prove)\nusing this:\n  table n A X \\<and>\n  (\\<forall>x.\n      (x \\<in> X \\<and> P x \\<longrightarrow> Q1 x) \\<and>\n      (wf_tuple n A x \\<and> P x \\<and> Q1 x \\<longrightarrow> x \\<in> X))\n  table n B Y \\<and>\n  (\\<forall>x.\n      (x \\<in> Y \\<and> P x \\<longrightarrow> Q2 x) \\<and>\n      (wf_tuple n B x \\<and> P x \\<and> Q2 x \\<longrightarrow> x \\<in> Y))\n  \\<not> b \\<Longrightarrow> B \\<subseteq> A\n  C = A \\<union> B\n  \\<lbrakk>wf_tuple n C x; P x\\<rbrakk>\n  \\<Longrightarrow> P (restrict A x) \\<and> P (restrict B x)\n  \\<lbrakk>b; wf_tuple n C x; P x\\<rbrakk>\n  \\<Longrightarrow> Q x = (Q1 (restrict A x) \\<and> Q2 (restrict B x))\n  \\<lbrakk>\\<not> b; wf_tuple n C x; P x\\<rbrakk>\n  \\<Longrightarrow> Q x =\n                    (Q1 (restrict A x) \\<and> \\<not> Q2 (restrict B x))\n  wf_tuple n C x\n  P x\n  Q x\n\ngoal (1 subgoal):\n 1. x \\<in> join X b Y", "by (auto dest: wf_tuple_restrict_simple intro!: in_joinI[of n A X B Y])"], ["proof (state)\nthis:\n  x \\<in> join X b Y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma qtable_join_fixed: \n  assumes \"qtable n A P Q1 X\" \"qtable n B P Q2 Y\" \"\\<not> b \\<Longrightarrow> B \\<subseteq> A\" \"C = A \\<union> B\"\n  \"\\<And>x. wf_tuple n C x \\<Longrightarrow> P x \\<Longrightarrow> P (restrict A x) \\<and> P (restrict B x)\"\n  shows \"qtable n C P (\\<lambda>x. Q1 (restrict A x) \\<and> (if b then Q2 (restrict B x) else \\<not> Q2 (restrict B x))) (join X b Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qtable n C P\n     (\\<lambda>x.\n         Q1 (restrict A x) \\<and>\n         (if b then Q2 (restrict B x) else \\<not> Q2 (restrict B x)))\n     (join X b Y)", "by (rule qtable_join[OF assms]) auto"], ["", "lemma wf_tuple_cong:\n  assumes \"wf_tuple n A v\" \"wf_tuple n A w\" \"\\<forall>x \\<in> A. map the v ! x = map the w ! x\"\n  shows \"v = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v = w", "from assms(1,2)"], ["proof (chain)\npicking this:\n  wf_tuple n A v\n  wf_tuple n A w", "have \"length v = length w\""], ["proof (prove)\nusing this:\n  wf_tuple n A v\n  wf_tuple n A w\n\ngoal (1 subgoal):\n 1. length v = length w", "unfolding wf_tuple_def"], ["proof (prove)\nusing this:\n  length v = n \\<and> (\\<forall>i<n. (v ! i = None) = (i \\<notin> A))\n  length w = n \\<and> (\\<forall>i<n. (w ! i = None) = (i \\<notin> A))\n\ngoal (1 subgoal):\n 1. length v = length w", "by simp"], ["proof (state)\nthis:\n  length v = length w\n\ngoal (1 subgoal):\n 1. v = w", "from this assms"], ["proof (chain)\npicking this:\n  length v = length w\n  wf_tuple n A v\n  wf_tuple n A w\n  \\<forall>x\\<in>A. map the v ! x = map the w ! x", "show \"v = w\""], ["proof (prove)\nusing this:\n  length v = length w\n  wf_tuple n A v\n  wf_tuple n A w\n  \\<forall>x\\<in>A. map the v ! x = map the w ! x\n\ngoal (1 subgoal):\n 1. v = w", "proof (induct v w arbitrary: n A rule: list_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n A.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n A [];\n        \\<forall>x\\<in>A. map the [] ! x = map the [] ! x\\<rbrakk>\n       \\<Longrightarrow> [] = []\n 2. \\<And>x xs y ys n A.\n       \\<lbrakk>length xs = length ys;\n        \\<And>n A.\n           \\<lbrakk>wf_tuple n A xs; wf_tuple n A ys;\n            \\<forall>x\\<in>A. map the xs ! x = map the ys ! x\\<rbrakk>\n           \\<Longrightarrow> xs = ys;\n        wf_tuple n A (x # xs); wf_tuple n A (y # ys);\n        \\<forall>xa\\<in>A.\n           map the (x # xs) ! xa = map the (y # ys) ! xa\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "case (Cons x xs y ys)"], ["proof (state)\nthis:\n  length xs = length ys\n  \\<lbrakk>wf_tuple ?n ?A xs; wf_tuple ?n ?A ys;\n   \\<forall>x\\<in>?A. map the xs ! x = map the ys ! x\\<rbrakk>\n  \\<Longrightarrow> xs = ys\n  wf_tuple n A (x # xs)\n  wf_tuple n A (y # ys)\n  \\<forall>xa\\<in>A. map the (x # xs) ! xa = map the (y # ys) ! xa\n\ngoal (2 subgoals):\n 1. \\<And>n A.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n A [];\n        \\<forall>x\\<in>A. map the [] ! x = map the [] ! x\\<rbrakk>\n       \\<Longrightarrow> [] = []\n 2. \\<And>x xs y ys n A.\n       \\<lbrakk>length xs = length ys;\n        \\<And>n A.\n           \\<lbrakk>wf_tuple n A xs; wf_tuple n A ys;\n            \\<forall>x\\<in>A. map the xs ! x = map the ys ! x\\<rbrakk>\n           \\<Longrightarrow> xs = ys;\n        wf_tuple n A (x # xs); wf_tuple n A (y # ys);\n        \\<forall>xa\\<in>A.\n           map the (x # xs) ! xa = map the (y # ys) ! xa\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "let ?n = \"n - 1\" and ?A = \"(\\<lambda>x. x - 1) ` (A - {0})\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n A.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n A [];\n        \\<forall>x\\<in>A. map the [] ! x = map the [] ! x\\<rbrakk>\n       \\<Longrightarrow> [] = []\n 2. \\<And>x xs y ys n A.\n       \\<lbrakk>length xs = length ys;\n        \\<And>n A.\n           \\<lbrakk>wf_tuple n A xs; wf_tuple n A ys;\n            \\<forall>x\\<in>A. map the xs ! x = map the ys ! x\\<rbrakk>\n           \\<Longrightarrow> xs = ys;\n        wf_tuple n A (x # xs); wf_tuple n A (y # ys);\n        \\<forall>xa\\<in>A.\n           map the (x # xs) ! xa = map the (y # ys) ! xa\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "have *: \"map the xs ! z = map the ys ! z\" if \"z \\<in> ?A\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. map the xs ! z = map the ys ! z", "using that Cons(5)[THEN bspec, of \"Suc z\"]"], ["proof (prove)\nusing this:\n  z \\<in> (\\<lambda>x. x - 1) ` (A - {0})\n  Suc z \\<in> A \\<Longrightarrow>\n  map the (x # xs) ! Suc z = map the (y # ys) ! Suc z\n\ngoal (1 subgoal):\n 1. map the xs ! z = map the ys ! z", "by (cases z) (auto simp: le_Suc_eq split: if_splits)"], ["proof (state)\nthis:\n  ?z \\<in> (\\<lambda>x. x - 1) ` (A - {0}) \\<Longrightarrow>\n  map the xs ! ?z = map the ys ! ?z\n\ngoal (2 subgoals):\n 1. \\<And>n A.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n A [];\n        \\<forall>x\\<in>A. map the [] ! x = map the [] ! x\\<rbrakk>\n       \\<Longrightarrow> [] = []\n 2. \\<And>x xs y ys n A.\n       \\<lbrakk>length xs = length ys;\n        \\<And>n A.\n           \\<lbrakk>wf_tuple n A xs; wf_tuple n A ys;\n            \\<forall>x\\<in>A. map the xs ! x = map the ys ! x\\<rbrakk>\n           \\<Longrightarrow> xs = ys;\n        wf_tuple n A (x # xs); wf_tuple n A (y # ys);\n        \\<forall>xa\\<in>A.\n           map the (x # xs) ! xa = map the (y # ys) ! xa\\<rbrakk>\n       \\<Longrightarrow> x # xs = y # ys", "from Cons(1,3-5)"], ["proof (chain)\npicking this:\n  length xs = length ys\n  wf_tuple n A (x # xs)\n  wf_tuple n A (y # ys)\n  \\<forall>xa\\<in>A. map the (x # xs) ! xa = map the (y # ys) ! xa", "show ?case"], ["proof (prove)\nusing this:\n  length xs = length ys\n  wf_tuple n A (x # xs)\n  wf_tuple n A (y # ys)\n  \\<forall>xa\\<in>A. map the (x # xs) ! xa = map the (y # ys) ! xa\n\ngoal (1 subgoal):\n 1. x # xs = y # ys", "by (auto intro!: Cons(2)[of ?n ?A] * split: if_splits)"], ["proof (state)\nthis:\n  x # xs = y # ys\n\ngoal (1 subgoal):\n 1. \\<And>n A.\n       \\<lbrakk>wf_tuple n A []; wf_tuple n A [];\n        \\<forall>x\\<in>A. map the [] ! x = map the [] ! x\\<rbrakk>\n       \\<Longrightarrow> [] = []", "qed simp"], ["proof (state)\nthis:\n  v = w\n\ngoal:\nNo subgoals!", "qed"], ["", "definition mem_restr :: \"'a list set \\<Rightarrow> 'a tuple \\<Rightarrow> bool\" where\n  \"mem_restr A x \\<longleftrightarrow> (\\<exists>y\\<in>A. list_all2 (\\<lambda>a b. a \\<noteq> None \\<longrightarrow> a = Some b) x y)\""], ["", "lemma mem_restrI: \"y \\<in> A \\<Longrightarrow> length y = n \\<Longrightarrow> wf_tuple n V x \\<Longrightarrow> \\<forall>i\\<in>V. x ! i = Some (y ! i) \\<Longrightarrow> mem_restr A x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> A; length y = n; wf_tuple n V x;\n     \\<forall>i\\<in>V. x ! i = Some (y ! i)\\<rbrakk>\n    \\<Longrightarrow> mem_restr A x", "unfolding mem_restr_def wf_tuple_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<in> A; length y = n;\n     length x = n \\<and> (\\<forall>i<n. (x ! i = None) = (i \\<notin> V));\n     \\<forall>i\\<in>V. x ! i = Some (y ! i)\\<rbrakk>\n    \\<Longrightarrow> Bex A\n                       (list_all2\n                         (\\<lambda>a b.\n                             a \\<noteq> None \\<longrightarrow> a = Some b)\n                         x)", "by (force simp add: list_all2_conv_all_nth)"], ["", "lemma mem_restrE: \"mem_restr A x \\<Longrightarrow> wf_tuple n V x \\<Longrightarrow> \\<forall>i\\<in>V. i < n \\<Longrightarrow>\n  (\\<And>y. y \\<in> A \\<Longrightarrow> \\<forall>i\\<in>V. x ! i = Some (y ! i) \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mem_restr A x; wf_tuple n V x; \\<forall>i\\<in>V. i < n;\n     \\<And>y.\n        \\<lbrakk>y \\<in> A; \\<forall>i\\<in>V. x ! i = Some (y ! i)\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "unfolding mem_restr_def wf_tuple_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Bex A\n              (list_all2\n                (\\<lambda>a b. a \\<noteq> None \\<longrightarrow> a = Some b)\n                x);\n     length x = n \\<and> (\\<forall>i<n. (x ! i = None) = (i \\<notin> V));\n     \\<forall>i\\<in>V. i < n;\n     \\<And>y.\n        \\<lbrakk>y \\<in> A; \\<forall>i\\<in>V. x ! i = Some (y ! i)\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (fastforce simp add: list_all2_conv_all_nth)"], ["", "lemma mem_restr_IntD: \"mem_restr (A \\<inter> B) v \\<Longrightarrow> mem_restr A v \\<and> mem_restr B v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem_restr (A \\<inter> B) v \\<Longrightarrow>\n    mem_restr A v \\<and> mem_restr B v", "unfolding mem_restr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bex (A \\<inter> B)\n     (list_all2 (\\<lambda>a b. a \\<noteq> None \\<longrightarrow> a = Some b)\n       v) \\<Longrightarrow>\n    Bex A\n     (list_all2 (\\<lambda>a b. a \\<noteq> None \\<longrightarrow> a = Some b)\n       v) \\<and>\n    Bex B\n     (list_all2 (\\<lambda>a b. a \\<noteq> None \\<longrightarrow> a = Some b)\n       v)", "by auto"], ["", "lemma mem_restr_Un_iff: \"mem_restr (A \\<union> B) x \\<longleftrightarrow> mem_restr A x \\<or> mem_restr B x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem_restr (A \\<union> B) x = (mem_restr A x \\<or> mem_restr B x)", "unfolding mem_restr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bex (A \\<union> B)\n     (list_all2 (\\<lambda>a b. a \\<noteq> None \\<longrightarrow> a = Some b)\n       x) =\n    (Bex A\n      (list_all2\n        (\\<lambda>a b. a \\<noteq> None \\<longrightarrow> a = Some b)\n        x) \\<or>\n     Bex B\n      (list_all2\n        (\\<lambda>a b. a \\<noteq> None \\<longrightarrow> a = Some b) x))", "by blast"], ["", "lemma mem_restr_UNIV [simp]: \"mem_restr UNIV x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem_restr UNIV x", "unfolding mem_restr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bex UNIV\n     (list_all2 (\\<lambda>a b. a \\<noteq> None \\<longrightarrow> a = Some b)\n       x)", "by (auto simp add: list.rel_map intro!: exI[of _ \"map the x\"] list.rel_refl)"], ["", "lemma restrict_mem_restr[simp]: \"mem_restr A x \\<Longrightarrow> mem_restr A (restrict V x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem_restr A x \\<Longrightarrow> mem_restr A (restrict V x)", "unfolding mem_restr_def restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Bex A\n     (list_all2 (\\<lambda>a b. a \\<noteq> None \\<longrightarrow> a = Some b)\n       x) \\<Longrightarrow>\n    Bex A\n     (list_all2 (\\<lambda>a b. a \\<noteq> None \\<longrightarrow> a = Some b)\n       (map (\\<lambda>i. if i \\<in> V then x ! i else None) [0..<length x]))", "by (auto simp: list_all2_conv_all_nth elim!: bexI[rotated])"], ["", "definition lift_envs :: \"'a list set \\<Rightarrow> 'a list set\" where\n  \"lift_envs R = (\\<lambda>(a,b). a # b) ` (UNIV \\<times> R)\""], ["", "lemma lift_envs_mem_restr[simp]: \"mem_restr A x \\<Longrightarrow> mem_restr (lift_envs A) (a # x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem_restr A x \\<Longrightarrow> mem_restr (lift_envs A) (a # x)", "by (auto simp: mem_restr_def lift_envs_def)"], ["", "lemma qtable_project:\n  assumes \"qtable (Suc n) A (mem_restr (lift_envs R)) P X\"\n  shows \"qtable n ((\\<lambda>x. x - Suc 0) ` (A - {0})) (mem_restr R)\n      (\\<lambda>v. \\<exists>x. P ((if 0 \\<in> A then Some x else None) # v)) (tl ` X)\"\n      (is \"qtable n ?A (mem_restr R) ?P ?X\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. qtable n ((\\<lambda>x. x - Suc 0) ` (A - {0})) (mem_restr R)\n     (\\<lambda>v. \\<exists>x. P ((if 0 \\<in> A then Some x else None) # v))\n     (tl ` X)", "proof ((rule qtableI; (elim exE)?), goal_cases table left right)"], ["proof (state)\ngoal (3 subgoals):\n 1. table n ((\\<lambda>x. x - Suc 0) ` (A - {0})) (tl ` X)\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> tl ` X;\n        wf_tuple n ((\\<lambda>x. x - Suc 0) ` (A - {0})) x;\n        mem_restr R x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            P ((if 0 \\<in> A then Some xa else None) # x)\n 3. \\<And>x xa.\n       \\<lbrakk>wf_tuple n ((\\<lambda>x. x - Suc 0) ` (A - {0})) x;\n        mem_restr R x;\n        P ((if 0 \\<in> A then Some xa else None) # x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> tl ` X", "case table"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. table n ((\\<lambda>x. x - Suc 0) ` (A - {0})) (tl ` X)\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> tl ` X;\n        wf_tuple n ((\\<lambda>x. x - Suc 0) ` (A - {0})) x;\n        mem_restr R x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            P ((if 0 \\<in> A then Some xa else None) # x)\n 3. \\<And>x xa.\n       \\<lbrakk>wf_tuple n ((\\<lambda>x. x - Suc 0) ` (A - {0})) x;\n        mem_restr R x;\n        P ((if 0 \\<in> A then Some xa else None) # x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> tl ` X", "with assms"], ["proof (chain)\npicking this:\n  qtable (Suc n) A (mem_restr (lift_envs R)) P X", "show ?case"], ["proof (prove)\nusing this:\n  qtable (Suc n) A (mem_restr (lift_envs R)) P X\n\ngoal (1 subgoal):\n 1. table n ((\\<lambda>x. x - Suc 0) ` (A - {0})) (tl ` X)", "unfolding qtable_def"], ["proof (prove)\nusing this:\n  table (Suc n) A X \\<and>\n  (\\<forall>x.\n      (x \\<in> X \\<and> mem_restr (lift_envs R) x \\<longrightarrow>\n       P x) \\<and>\n      (wf_tuple (Suc n) A x \\<and>\n       mem_restr (lift_envs R) x \\<and> P x \\<longrightarrow>\n       x \\<in> X))\n\ngoal (1 subgoal):\n 1. table n ((\\<lambda>x. x - Suc 0) ` (A - {0})) (tl ` X)", "by (simp add: table_project)"], ["proof (state)\nthis:\n  table n ((\\<lambda>x. x - Suc 0) ` (A - {0})) (tl ` X)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> tl ` X;\n        wf_tuple n ((\\<lambda>x. x - Suc 0) ` (A - {0})) x;\n        mem_restr R x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            P ((if 0 \\<in> A then Some xa else None) # x)\n 2. \\<And>x xa.\n       \\<lbrakk>wf_tuple n ((\\<lambda>x. x - Suc 0) ` (A - {0})) x;\n        mem_restr R x;\n        P ((if 0 \\<in> A then Some xa else None) # x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> tl ` X", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> tl ` X;\n        wf_tuple n ((\\<lambda>x. x - Suc 0) ` (A - {0})) x;\n        mem_restr R x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            P ((if 0 \\<in> A then Some xa else None) # x)\n 2. \\<And>x xa.\n       \\<lbrakk>wf_tuple n ((\\<lambda>x. x - Suc 0) ` (A - {0})) x;\n        mem_restr R x;\n        P ((if 0 \\<in> A then Some xa else None) # x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> tl ` X", "case (left v)"], ["proof (state)\nthis:\n  v \\<in> tl ` X\n  wf_tuple n ((\\<lambda>x. x - Suc 0) ` (A - {0})) v\n  mem_restr R v\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> tl ` X;\n        wf_tuple n ((\\<lambda>x. x - Suc 0) ` (A - {0})) x;\n        mem_restr R x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            P ((if 0 \\<in> A then Some xa else None) # x)\n 2. \\<And>x xa.\n       \\<lbrakk>wf_tuple n ((\\<lambda>x. x - Suc 0) ` (A - {0})) x;\n        mem_restr R x;\n        P ((if 0 \\<in> A then Some xa else None) # x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> tl ` X", "from assms"], ["proof (chain)\npicking this:\n  qtable (Suc n) A (mem_restr (lift_envs R)) P X", "have \"[] \\<notin> X\""], ["proof (prove)\nusing this:\n  qtable (Suc n) A (mem_restr (lift_envs R)) P X\n\ngoal (1 subgoal):\n 1. [] \\<notin> X", "unfolding qtable_def table_def"], ["proof (prove)\nusing this:\n  Ball X (wf_tuple (Suc n) A) \\<and>\n  (\\<forall>x.\n      (x \\<in> X \\<and> mem_restr (lift_envs R) x \\<longrightarrow>\n       P x) \\<and>\n      (wf_tuple (Suc n) A x \\<and>\n       mem_restr (lift_envs R) x \\<and> P x \\<longrightarrow>\n       x \\<in> X))\n\ngoal (1 subgoal):\n 1. [] \\<notin> X", "by fastforce"], ["proof (state)\nthis:\n  [] \\<notin> X\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> tl ` X;\n        wf_tuple n ((\\<lambda>x. x - Suc 0) ` (A - {0})) x;\n        mem_restr R x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            P ((if 0 \\<in> A then Some xa else None) # x)\n 2. \\<And>x xa.\n       \\<lbrakk>wf_tuple n ((\\<lambda>x. x - Suc 0) ` (A - {0})) x;\n        mem_restr R x;\n        P ((if 0 \\<in> A then Some xa else None) # x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> tl ` X", "with left(1)"], ["proof (chain)\npicking this:\n  v \\<in> tl ` X\n  [] \\<notin> X", "obtain x where \"x # v \\<in> X\""], ["proof (prove)\nusing this:\n  v \\<in> tl ` X\n  [] \\<notin> X\n\ngoal (1 subgoal):\n 1. (\\<And>x. x # v \\<in> X \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, hide_lams) image_iff hd_Cons_tl)"], ["proof (state)\nthis:\n  x # v \\<in> X\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> tl ` X;\n        wf_tuple n ((\\<lambda>x. x - Suc 0) ` (A - {0})) x;\n        mem_restr R x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            P ((if 0 \\<in> A then Some xa else None) # x)\n 2. \\<And>x xa.\n       \\<lbrakk>wf_tuple n ((\\<lambda>x. x - Suc 0) ` (A - {0})) x;\n        mem_restr R x;\n        P ((if 0 \\<in> A then Some xa else None) # x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> tl ` X", "with assms"], ["proof (chain)\npicking this:\n  qtable (Suc n) A (mem_restr (lift_envs R)) P X\n  x # v \\<in> X", "show ?case"], ["proof (prove)\nusing this:\n  qtable (Suc n) A (mem_restr (lift_envs R)) P X\n  x # v \\<in> X\n\ngoal (1 subgoal):\n 1. \\<exists>x. P ((if 0 \\<in> A then Some x else None) # v)", "by (rule in_qtableE) (auto simp: left(3) split: if_splits)"], ["proof (state)\nthis:\n  \\<exists>x. P ((if 0 \\<in> A then Some x else None) # v)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>wf_tuple n ((\\<lambda>x. x - Suc 0) ` (A - {0})) x;\n        mem_restr R x;\n        P ((if 0 \\<in> A then Some xa else None) # x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> tl ` X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>wf_tuple n ((\\<lambda>x. x - Suc 0) ` (A - {0})) x;\n        mem_restr R x;\n        P ((if 0 \\<in> A then Some xa else None) # x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> tl ` X", "case (right v x)"], ["proof (state)\nthis:\n  wf_tuple n ((\\<lambda>x. x - Suc 0) ` (A - {0})) v\n  mem_restr R v\n  P ((if 0 \\<in> A then Some x else None) # v)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>wf_tuple n ((\\<lambda>x. x - Suc 0) ` (A - {0})) x;\n        mem_restr R x;\n        P ((if 0 \\<in> A then Some xa else None) # x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> tl ` X", "with assms"], ["proof (chain)\npicking this:\n  qtable (Suc n) A (mem_restr (lift_envs R)) P X\n  wf_tuple n ((\\<lambda>x. x - Suc 0) ` (A - {0})) v\n  mem_restr R v\n  P ((if 0 \\<in> A then Some x else None) # v)", "have \"(if 0 \\<in> A then Some x else None) # v \\<in> X\""], ["proof (prove)\nusing this:\n  qtable (Suc n) A (mem_restr (lift_envs R)) P X\n  wf_tuple n ((\\<lambda>x. x - Suc 0) ` (A - {0})) v\n  mem_restr R v\n  P ((if 0 \\<in> A then Some x else None) # v)\n\ngoal (1 subgoal):\n 1. (if 0 \\<in> A then Some x else None) # v \\<in> X", "by (elim in_qtableI) auto"], ["proof (state)\nthis:\n  (if 0 \\<in> A then Some x else None) # v \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>wf_tuple n ((\\<lambda>x. x - Suc 0) ` (A - {0})) x;\n        mem_restr R x;\n        P ((if 0 \\<in> A then Some xa else None) # x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> tl ` X", "then"], ["proof (chain)\npicking this:\n  (if 0 \\<in> A then Some x else None) # v \\<in> X", "show ?case"], ["proof (prove)\nusing this:\n  (if 0 \\<in> A then Some x else None) # v \\<in> X\n\ngoal (1 subgoal):\n 1. v \\<in> tl ` X", "by (auto simp: image_iff elim: bexI[rotated])"], ["proof (state)\nthis:\n  v \\<in> tl ` X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma qtable_cong: \"qtable n A P Q X \\<Longrightarrow> A = B \\<Longrightarrow> (\\<And>v. P v \\<Longrightarrow> Q v \\<longleftrightarrow> Q' v) \\<Longrightarrow> qtable n B P Q' X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>qtable n A P Q X; A = B;\n     \\<And>v. P v \\<Longrightarrow> Q v = Q' v\\<rbrakk>\n    \\<Longrightarrow> qtable n B P Q' X", "by (auto simp: qtable_def)"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}