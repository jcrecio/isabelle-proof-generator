{"file_name": "/home/qj213/afp-2021-10-22/thys/MFOTL_Monitor/Trace.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MFOTL_Monitor", "problem_names": ["lemma ssorted_siterate[simp]: \"(\\<And>n. n \\<le> f n) \\<Longrightarrow> ssorted (siterate f n)\"", "lemma ssortedD: \"ssorted s \\<Longrightarrow> s !! i \\<le> stl s !! i\"", "lemma ssorted_sdrop: \"ssorted s \\<Longrightarrow> ssorted (sdrop i s)\"", "lemma ssorted_monoD: \"ssorted s \\<Longrightarrow> i \\<le> j \\<Longrightarrow> s !! i \\<le> s !! j\"", "lemma sorted_stake: \"ssorted s \\<Longrightarrow> sorted (stake i s)\"", "lemma ssorted_monoI: \"\\<forall>i j. i \\<le> j \\<longrightarrow> s !! i \\<le> s !! j \\<Longrightarrow> ssorted s\"", "lemma ssorted_iff_mono: \"ssorted s \\<longleftrightarrow> (\\<forall>i j. i \\<le> j \\<longrightarrow> s !! i \\<le> s !! j)\"", "lemma ssorted_iff_le_Suc: \"ssorted s \\<longleftrightarrow> (\\<forall>i. s !! i \\<le> s !! Suc i)\"", "lemma sincreasingI: \"(\\<And>x. \\<exists>i. x < s !! i) \\<Longrightarrow> sincreasing s\"", "lemma sincreasing_grD:\n  fixes x :: \"'a :: semilattice_sup\"\n  assumes \"sincreasing s\"\n  shows \"\\<exists>j>i. x < s !! j\"", "lemma sincreasing_siterate_nat[simp]:\n  fixes n :: nat\n  assumes \"(\\<And>n. n < f n)\"\n  shows \"sincreasing (siterate f n)\"", "lemma sincreasing_stl: \"sincreasing s \\<Longrightarrow> sincreasing (stl s)\" for s :: \"'a :: semilattice_sup stream\"", "lemma stream_eq_iff: \"s = s' \\<longleftrightarrow> (\\<forall>n. s !! n = s' !! n)\"", "lemma trace_eqI: \"(\\<And>i. \\<Gamma> \\<sigma> i = \\<Gamma> \\<sigma>' i) \\<Longrightarrow> (\\<And>i. \\<tau> \\<sigma> i = \\<tau> \\<sigma>' i) \\<Longrightarrow> \\<sigma> = \\<sigma>'\"", "lemma \\<tau>_mono[simp]: \"i \\<le> j \\<Longrightarrow> \\<tau> s i \\<le> \\<tau> s j\"", "lemma ex_le_\\<tau>: \"\\<exists>j\\<ge>i. x \\<le> \\<tau> s j\"", "lemma le_\\<tau>_less: \"\\<tau> \\<sigma> i \\<le> \\<tau> \\<sigma> j \\<Longrightarrow> j < i \\<Longrightarrow> \\<tau> \\<sigma> i = \\<tau> \\<sigma> j\"", "lemma less_\\<tau>D: \"\\<tau> \\<sigma> i < \\<tau> \\<sigma> j \\<Longrightarrow> i < j\"", "lemma \\<Gamma>_map_\\<Gamma>[simp]: \"\\<Gamma> (map_\\<Gamma> f s) i = f (\\<Gamma> s i)\"", "lemma \\<tau>_map_\\<Gamma>[simp]: \"\\<tau> (map_\\<Gamma> f s) i = \\<tau> s i\"", "lemma map_\\<Gamma>_id[simp]: \"map_\\<Gamma> id s = s\"", "lemma map_\\<Gamma>_comp: \"map_\\<Gamma> g (map_\\<Gamma> f s) = map_\\<Gamma> (g \\<circ> f) s\"", "lemma map_\\<Gamma>_cong: \"\\<sigma>\\<^sub>1 = \\<sigma>\\<^sub>2 \\<Longrightarrow> (\\<And>x. f\\<^sub>1 x = f\\<^sub>2 x) \\<Longrightarrow> map_\\<Gamma> f\\<^sub>1 \\<sigma>\\<^sub>1 = map_\\<Gamma> f\\<^sub>2 \\<sigma>\\<^sub>2\"", "lemma psnoc_inject[simp]:\n  \"last_ts p \\<le> snd x \\<Longrightarrow> last_ts q \\<le> snd y \\<Longrightarrow> psnoc p x = psnoc q y \\<longleftrightarrow> (p = q \\<and> x = y)\"", "lemma prefix_of_pnil[simp]: \"prefix_of pnil \\<sigma>\"", "lemma plen_pnil[simp]: \"plen pnil = 0\"", "lemma prefix_of_pmap_\\<Gamma>[simp]: \"prefix_of \\<pi> \\<sigma> \\<Longrightarrow> prefix_of (pmap_\\<Gamma> f \\<pi>) (map_\\<Gamma> f \\<sigma>)\"", "lemma plen_mono: \"\\<pi> \\<le> \\<pi>' \\<Longrightarrow> plen \\<pi> \\<le> plen \\<pi>'\"", "lemma prefix_of_psnocE: \"prefix_of (psnoc p x) s \\<Longrightarrow> last_ts p \\<le> snd x \\<Longrightarrow>\n  (prefix_of p s \\<Longrightarrow> \\<Gamma> s (plen p) = fst x \\<Longrightarrow> \\<tau> s (plen p) = snd x \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma le_pnil[simp]: \"pnil \\<le> \\<pi>\"", "lemma plen_take_prefix[simp]: \"plen (take_prefix i \\<sigma>) = i\"", "lemma plen_psnoc[simp]: \"last_ts \\<pi> \\<le> snd x \\<Longrightarrow> plen (psnoc \\<pi> x) = plen \\<pi> + 1\"", "lemma prefix_of_take_prefix[simp]: \"prefix_of (take_prefix i \\<sigma>) \\<sigma>\"", "lemma pdrop_0[simp]: \"pdrop 0 \\<pi> = \\<pi>\"", "lemma prefix_of_antimono: \"\\<pi> \\<le> \\<pi>' \\<Longrightarrow> prefix_of \\<pi>' s \\<Longrightarrow> prefix_of \\<pi> s\"", "lemma prefix_of_imp_linear: \"prefix_of \\<pi> \\<sigma> \\<Longrightarrow> prefix_of \\<pi>' \\<sigma> \\<Longrightarrow> \\<pi> \\<le> \\<pi>' \\<or> \\<pi>' \\<le> \\<pi>\"", "lemma ex_prefix_of: \"\\<exists>s. prefix_of p s\"", "lemma \\<tau>_prefix_conv: \"prefix_of p s \\<Longrightarrow> prefix_of p s' \\<Longrightarrow> i < plen p \\<Longrightarrow> \\<tau> s i = \\<tau> s' i\"", "lemma \\<Gamma>_prefix_conv: \"prefix_of p s \\<Longrightarrow> prefix_of p s' \\<Longrightarrow> i < plen p \\<Longrightarrow> \\<Gamma> s i = \\<Gamma> s' i\"", "lemma sincreasing_sdrop:\n  fixes s :: \"('a :: semilattice_sup) stream\"\n  assumes \"sincreasing s\"\n  shows \"sincreasing (sdrop n s)\"", "lemma ssorted_shift:\n  \"ssorted (xs @- s) = (sorted xs \\<and> ssorted s \\<and> (\\<forall>x\\<in>set xs. \\<forall>y\\<in>sset s. x \\<le> y))\"", "lemma sincreasing_shift:\n  assumes \"sincreasing s\"\n  shows \"sincreasing (xs @- s)\"", "lemma prefix_of_replace_prefix:\n  \"prefix_of (pmap_\\<Gamma> f \\<pi>) \\<sigma> \\<Longrightarrow> prefix_of \\<pi> (replace_prefix \\<pi> \\<sigma>)\"", "lemma map_\\<Gamma>_replace_prefix:\n  \"\\<forall>x. f (f x) = f x \\<Longrightarrow> prefix_of (pmap_\\<Gamma> f \\<pi>) \\<sigma> \\<Longrightarrow> map_\\<Gamma> f (replace_prefix \\<pi> \\<sigma>) = map_\\<Gamma> f \\<sigma>\"", "lemma prefix_of_pmap_\\<Gamma>_D:\n  assumes \"prefix_of (pmap_\\<Gamma> f \\<pi>) \\<sigma>\"\n  shows \"\\<exists>\\<sigma>'. prefix_of \\<pi> \\<sigma>' \\<and> prefix_of (pmap_\\<Gamma> f \\<pi>) (map_\\<Gamma> f \\<sigma>')\"", "lemma prefix_of_map_\\<Gamma>_D:\n  assumes \"prefix_of \\<pi>' (map_\\<Gamma> f \\<sigma>)\"\n  shows \"\\<exists>\\<pi>''. \\<pi>' = pmap_\\<Gamma> f \\<pi>'' \\<and> prefix_of \\<pi>'' \\<sigma>\"", "lemma pts_pmap_\\<Gamma>[simp]: \"pts (pmap_\\<Gamma> f \\<pi>) = pts \\<pi>\""], "translations": [["", "lemma ssorted_siterate[simp]: \"(\\<And>n. n \\<le> f n) \\<Longrightarrow> ssorted (siterate f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n. n \\<le> f n) \\<Longrightarrow> ssorted (siterate f n)", "by (coinduction arbitrary: n) auto"], ["", "lemma ssortedD: \"ssorted s \\<Longrightarrow> s !! i \\<le> stl s !! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ssorted s \\<Longrightarrow> s !! i \\<le> stl s !! i", "by (induct i arbitrary: s) (auto elim: ssorted.cases)"], ["", "lemma ssorted_sdrop: \"ssorted s \\<Longrightarrow> ssorted (sdrop i s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ssorted s \\<Longrightarrow> ssorted (sdrop i s)", "by (coinduction arbitrary: i s) (auto elim: ssorted.cases ssortedD)"], ["", "lemma ssorted_monoD: \"ssorted s \\<Longrightarrow> i \\<le> j \\<Longrightarrow> s !! i \\<le> s !! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ssorted s; i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> s !! i \\<le> s !! j", "proof (induct \"j - i\" arbitrary: j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>0 = j - i; ssorted s; i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> s !! i \\<le> s !! j\n 2. \\<And>x j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>x = j - i; ssorted s; i \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> s !! i \\<le> s !! j;\n        Suc x = j - i; ssorted s; i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> s !! i \\<le> s !! j", "case (Suc x)"], ["proof (state)\nthis:\n  \\<lbrakk>x = ?j - i; ssorted s; i \\<le> ?j\\<rbrakk>\n  \\<Longrightarrow> s !! i \\<le> s !! ?j\n  Suc x = j - i\n  ssorted s\n  i \\<le> j\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>0 = j - i; ssorted s; i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> s !! i \\<le> s !! j\n 2. \\<And>x j.\n       \\<lbrakk>\\<And>j.\n                   \\<lbrakk>x = j - i; ssorted s; i \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> s !! i \\<le> s !! j;\n        Suc x = j - i; ssorted s; i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> s !! i \\<le> s !! j", "from Suc(1)[of \"j - 1\"] Suc(2-4) ssortedD[of s \"j - 1\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>x = j - 1 - i; ssorted s; i \\<le> j - 1\\<rbrakk>\n  \\<Longrightarrow> s !! i \\<le> s !! (j - 1)\n  Suc x = j - i\n  ssorted s\n  i \\<le> j\n  ssorted s \\<Longrightarrow> s !! (j - 1) \\<le> stl s !! (j - 1)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>x = j - 1 - i; ssorted s; i \\<le> j - 1\\<rbrakk>\n  \\<Longrightarrow> s !! i \\<le> s !! (j - 1)\n  Suc x = j - i\n  ssorted s\n  i \\<le> j\n  ssorted s \\<Longrightarrow> s !! (j - 1) \\<le> stl s !! (j - 1)\n\ngoal (1 subgoal):\n 1. s !! i \\<le> s !! j", "by (cases j) (auto simp: le_Suc_eq Suc_diff_le)"], ["proof (state)\nthis:\n  s !! i \\<le> s !! j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>0 = j - i; ssorted s; i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> s !! i \\<le> s !! j", "qed simp"], ["", "lemma sorted_stake: \"ssorted s \\<Longrightarrow> sorted (stake i s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ssorted s \\<Longrightarrow> sorted (stake i s)", "by (induct i arbitrary: s)\n    (auto elim: ssorted.cases simp: in_set_conv_nth\n      intro!: ssorted_monoD[of _ 0, simplified, THEN order_trans, OF _ ssortedD])"], ["", "lemma ssorted_monoI: \"\\<forall>i j. i \\<le> j \\<longrightarrow> s !! i \\<le> s !! j \\<Longrightarrow> ssorted s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i \\<le> j \\<longrightarrow> s !! i \\<le> s !! j \\<Longrightarrow>\n    ssorted s", "by (coinduction arbitrary: s)\n    (auto dest: spec2[of _ \"Suc _\" \"Suc _\"] spec2[of _ 0 \"Suc 0\"])"], ["", "lemma ssorted_iff_mono: \"ssorted s \\<longleftrightarrow> (\\<forall>i j. i \\<le> j \\<longrightarrow> s !! i \\<le> s !! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ssorted s =\n    (\\<forall>i j. i \\<le> j \\<longrightarrow> s !! i \\<le> s !! j)", "using ssorted_monoI ssorted_monoD"], ["proof (prove)\nusing this:\n  \\<forall>i j.\n     i \\<le> j \\<longrightarrow> ?s !! i \\<le> ?s !! j \\<Longrightarrow>\n  ssorted ?s\n  \\<lbrakk>ssorted ?s; ?i \\<le> ?j\\<rbrakk>\n  \\<Longrightarrow> ?s !! ?i \\<le> ?s !! ?j\n\ngoal (1 subgoal):\n 1. ssorted s =\n    (\\<forall>i j. i \\<le> j \\<longrightarrow> s !! i \\<le> s !! j)", "by metis"], ["", "lemma ssorted_iff_le_Suc: \"ssorted s \\<longleftrightarrow> (\\<forall>i. s !! i \\<le> s !! Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ssorted s = (\\<forall>i. s !! i \\<le> s !! Suc i)", "using mono_iff_le_Suc[of \"snth s\"]"], ["proof (prove)\nusing this:\n  mono ((!!) s) = (\\<forall>n. s !! n \\<le> s !! Suc n)\n\ngoal (1 subgoal):\n 1. ssorted s = (\\<forall>i. s !! i \\<le> s !! Suc i)", "by (simp add: mono_def ssorted_iff_mono)"], ["", "definition \"sincreasing s = (\\<forall>x. \\<exists>i. x < s !! i)\""], ["", "lemma sincreasingI: \"(\\<And>x. \\<exists>i. x < s !! i) \\<Longrightarrow> sincreasing s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. \\<exists>i. x < s !! i) \\<Longrightarrow> sincreasing s", "by (simp add: sincreasing_def)"], ["", "lemma sincreasing_grD:\n  fixes x :: \"'a :: semilattice_sup\"\n  assumes \"sincreasing s\"\n  shows \"\\<exists>j>i. x < s !! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j>i. x < s !! j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>j>i. x < s !! j", "let ?A = \"insert x {s !! n | n. n \\<le> i}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>j>i. x < s !! j", "from assms"], ["proof (chain)\npicking this:\n  sincreasing s", "obtain j where *: \"Sup_fin ?A < s !! j\""], ["proof (prove)\nusing this:\n  sincreasing s\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<Squnion>\\<^sub>f\\<^sub>i\\<^sub>n insert x {s !! n |n. n \\<le> i}\n        < s !! j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: sincreasing_def)"], ["proof (state)\nthis:\n  \\<Squnion>\\<^sub>f\\<^sub>i\\<^sub>n insert x {s !! n |n. n \\<le> i}\n  < s !! j\n\ngoal (1 subgoal):\n 1. \\<exists>j>i. x < s !! j", "then"], ["proof (chain)\npicking this:\n  \\<Squnion>\\<^sub>f\\<^sub>i\\<^sub>n insert x {s !! n |n. n \\<le> i}\n  < s !! j", "have \"x < s !! j\""], ["proof (prove)\nusing this:\n  \\<Squnion>\\<^sub>f\\<^sub>i\\<^sub>n insert x {s !! n |n. n \\<le> i}\n  < s !! j\n\ngoal (1 subgoal):\n 1. x < s !! j", "by (rule order.strict_trans1[rotated]) (auto intro: Sup_fin.coboundedI)"], ["proof (state)\nthis:\n  x < s !! j\n\ngoal (1 subgoal):\n 1. \\<exists>j>i. x < s !! j", "moreover"], ["proof (state)\nthis:\n  x < s !! j\n\ngoal (1 subgoal):\n 1. \\<exists>j>i. x < s !! j", "have \"i < j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> False", "assume \"\\<not> i < j\""], ["proof (state)\nthis:\n  \\<not> i < j\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> i < j", "have \"s !! j \\<in> ?A\""], ["proof (prove)\nusing this:\n  \\<not> i < j\n\ngoal (1 subgoal):\n 1. s !! j \\<in> insert x {s !! n |n. n \\<le> i}", "by (auto simp: not_less)"], ["proof (state)\nthis:\n  s !! j \\<in> insert x {s !! n |n. n \\<le> i}\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  s !! j \\<in> insert x {s !! n |n. n \\<le> i}", "have \"s !! j \\<le> Sup_fin ?A\""], ["proof (prove)\nusing this:\n  s !! j \\<in> insert x {s !! n |n. n \\<le> i}\n\ngoal (1 subgoal):\n 1. s !! j\n    \\<le> \\<Squnion>\\<^sub>f\\<^sub>i\\<^sub>n insert x {s !! n |n. n \\<le> i}", "by (auto intro: Sup_fin.coboundedI)"], ["proof (state)\nthis:\n  s !! j\n  \\<le> \\<Squnion>\\<^sub>f\\<^sub>i\\<^sub>n insert x {s !! n |n. n \\<le> i}\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow> False", "with *"], ["proof (chain)\npicking this:\n  \\<Squnion>\\<^sub>f\\<^sub>i\\<^sub>n insert x {s !! n |n. n \\<le> i}\n  < s !! j\n  s !! j\n  \\<le> \\<Squnion>\\<^sub>f\\<^sub>i\\<^sub>n insert x {s !! n |n. n \\<le> i}", "show False"], ["proof (prove)\nusing this:\n  \\<Squnion>\\<^sub>f\\<^sub>i\\<^sub>n insert x {s !! n |n. n \\<le> i}\n  < s !! j\n  s !! j\n  \\<le> \\<Squnion>\\<^sub>f\\<^sub>i\\<^sub>n insert x {s !! n |n. n \\<le> i}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i < j\n\ngoal (1 subgoal):\n 1. \\<exists>j>i. x < s !! j", "ultimately"], ["proof (chain)\npicking this:\n  x < s !! j\n  i < j", "show ?thesis"], ["proof (prove)\nusing this:\n  x < s !! j\n  i < j\n\ngoal (1 subgoal):\n 1. \\<exists>j>i. x < s !! j", "by blast"], ["proof (state)\nthis:\n  \\<exists>j>i. x < s !! j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sincreasing_siterate_nat[simp]:\n  fixes n :: nat\n  assumes \"(\\<And>n. n < f n)\"\n  shows \"sincreasing (siterate f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sincreasing (siterate f n)", "unfolding sincreasing_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. \\<exists>i. x < siterate f n !! i", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>i. x < siterate f n !! i", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>i. x < siterate f n !! i", "show \"\\<exists>i. x < siterate f n !! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. x < siterate f n !! i", "proof (induction x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>i. 0 < siterate f n !! i\n 2. \\<And>x.\n       \\<exists>i. x < siterate f n !! i \\<Longrightarrow>\n       \\<exists>i. Suc x < siterate f n !! i", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<exists>i. 0 < siterate f n !! i\n 2. \\<And>x.\n       \\<exists>i. x < siterate f n !! i \\<Longrightarrow>\n       \\<exists>i. Suc x < siterate f n !! i", "have \"0 < siterate f n !! 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < siterate f n !! 1", "using order.strict_trans1[OF le0 assms]"], ["proof (prove)\nusing this:\n  0 < f ?b\n\ngoal (1 subgoal):\n 1. 0 < siterate f n !! 1", "by simp"], ["proof (state)\nthis:\n  0 < siterate f n !! 1\n\ngoal (2 subgoals):\n 1. \\<exists>i. 0 < siterate f n !! i\n 2. \\<And>x.\n       \\<exists>i. x < siterate f n !! i \\<Longrightarrow>\n       \\<exists>i. Suc x < siterate f n !! i", "then"], ["proof (chain)\npicking this:\n  0 < siterate f n !! 1", "show ?case"], ["proof (prove)\nusing this:\n  0 < siterate f n !! 1\n\ngoal (1 subgoal):\n 1. \\<exists>i. 0 < siterate f n !! i", ".."], ["proof (state)\nthis:\n  \\<exists>i. 0 < siterate f n !! i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>i. x < siterate f n !! i \\<Longrightarrow>\n       \\<exists>i. Suc x < siterate f n !! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>i. x < siterate f n !! i \\<Longrightarrow>\n       \\<exists>i. Suc x < siterate f n !! i", "case (Suc x)"], ["proof (state)\nthis:\n  \\<exists>i. x < siterate f n !! i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>i. x < siterate f n !! i \\<Longrightarrow>\n       \\<exists>i. Suc x < siterate f n !! i", "then"], ["proof (chain)\npicking this:\n  \\<exists>i. x < siterate f n !! i", "obtain i where \"x < siterate f n !! i\""], ["proof (prove)\nusing this:\n  \\<exists>i. x < siterate f n !! i\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        x < siterate f n !! i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  x < siterate f n !! i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>i. x < siterate f n !! i \\<Longrightarrow>\n       \\<exists>i. Suc x < siterate f n !! i", "then"], ["proof (chain)\npicking this:\n  x < siterate f n !! i", "have \"Suc x < siterate f n !! Suc i\""], ["proof (prove)\nusing this:\n  x < siterate f n !! i\n\ngoal (1 subgoal):\n 1. Suc x < siterate f n !! Suc i", "using order.strict_trans1[OF _ assms]"], ["proof (prove)\nusing this:\n  x < siterate f n !! i\n  ?a \\<le> ?b \\<Longrightarrow> ?a < f ?b\n\ngoal (1 subgoal):\n 1. Suc x < siterate f n !! Suc i", "by (simp del: snth.simps)"], ["proof (state)\nthis:\n  Suc x < siterate f n !! Suc i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>i. x < siterate f n !! i \\<Longrightarrow>\n       \\<exists>i. Suc x < siterate f n !! i", "then"], ["proof (chain)\npicking this:\n  Suc x < siterate f n !! Suc i", "show ?case"], ["proof (prove)\nusing this:\n  Suc x < siterate f n !! Suc i\n\ngoal (1 subgoal):\n 1. \\<exists>i. Suc x < siterate f n !! i", ".."], ["proof (state)\nthis:\n  \\<exists>i. Suc x < siterate f n !! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i. x < siterate f n !! i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sincreasing_stl: \"sincreasing s \\<Longrightarrow> sincreasing (stl s)\" for s :: \"'a :: semilattice_sup stream\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sincreasing s \\<Longrightarrow> sincreasing (stl s)", "by (auto 0 4 simp: gr0_conv_Suc intro!: sincreasingI dest: sincreasing_grD[of s 0])"], ["", "typedef 'a trace = \"{s :: ('a set \\<times> nat) stream. ssorted (smap snd s) \\<and> sincreasing (smap snd s)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> {s. ssorted (smap snd s) \\<and> sincreasing (smap snd s)}", "by (intro exI[of _ \"smap (\\<lambda>i. ({}, i)) nats\"])\n    (auto simp: stream.map_comp stream.map_ident cong: stream.map_cong)"], ["", "setup_lifting type_definition_trace"], ["", "lift_definition \\<Gamma> :: \"'a trace \\<Rightarrow> nat \\<Rightarrow> 'a set\" is\n  \"\\<lambda>s i. fst (s !! i)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition \\<tau> :: \"'a trace \\<Rightarrow> nat \\<Rightarrow> nat\" is\n  \"\\<lambda>s i. snd (s !! i)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma stream_eq_iff: \"s = s' \\<longleftrightarrow> (\\<forall>n. s !! n = s' !! n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s = s') = (\\<forall>n. s !! n = s' !! n)", "by (metis stream.map_cong0 stream_smap_nats)"], ["", "lemma trace_eqI: \"(\\<And>i. \\<Gamma> \\<sigma> i = \\<Gamma> \\<sigma>' i) \\<Longrightarrow> (\\<And>i. \\<tau> \\<sigma> i = \\<tau> \\<sigma>' i) \\<Longrightarrow> \\<sigma> = \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>i. \\<Gamma> \\<sigma> i = \\<Gamma> \\<sigma>' i;\n     \\<And>i. \\<tau> \\<sigma> i = \\<tau> \\<sigma>' i\\<rbrakk>\n    \\<Longrightarrow> \\<sigma> = \\<sigma>'", "by transfer (auto simp: stream_eq_iff intro!: prod_eqI)"], ["", "lemma \\<tau>_mono[simp]: \"i \\<le> j \\<Longrightarrow> \\<tau> s i \\<le> \\<tau> s j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow> \\<tau> s i \\<le> \\<tau> s j", "by transfer (auto simp: ssorted_iff_mono)"], ["", "lemma ex_le_\\<tau>: \"\\<exists>j\\<ge>i. x \\<le> \\<tau> s j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i. x \\<le> \\<tau> s j", "by (transfer fixing: i x) (auto dest!: sincreasing_grD[of _ i x] less_imp_le)"], ["", "lemma le_\\<tau>_less: \"\\<tau> \\<sigma> i \\<le> \\<tau> \\<sigma> j \\<Longrightarrow> j < i \\<Longrightarrow> \\<tau> \\<sigma> i = \\<tau> \\<sigma> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<sigma> i \\<le> \\<tau> \\<sigma> j; j < i\\<rbrakk>\n    \\<Longrightarrow> \\<tau> \\<sigma> i = \\<tau> \\<sigma> j", "by (simp add: antisym)"], ["", "lemma less_\\<tau>D: \"\\<tau> \\<sigma> i < \\<tau> \\<sigma> j \\<Longrightarrow> i < j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<sigma> i < \\<tau> \\<sigma> j \\<Longrightarrow> i < j", "by (meson \\<tau>_mono less_le_not_le not_le_imp_less)"], ["", "abbreviation \"\\<Delta> s i \\<equiv> \\<tau> s i - \\<tau> s (i - 1)\""], ["", "lift_definition map_\\<Gamma> :: \"('a set \\<Rightarrow> 'b set) \\<Rightarrow> 'a trace \\<Rightarrow> 'b trace\" is\n  \"\\<lambda>f s. smap (\\<lambda>(x, i). (f x, i)) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun stream.\n       ssorted (smap snd stream) \\<and>\n       sincreasing (smap snd stream) \\<Longrightarrow>\n       ssorted (smap snd (smap (\\<lambda>(x, y). (fun x, y)) stream)) \\<and>\n       sincreasing (smap snd (smap (\\<lambda>(x, y). (fun x, y)) stream))", "by (auto simp: stream.map_comp prod.case_eq_if cong: stream.map_cong)"], ["", "lemma \\<Gamma>_map_\\<Gamma>[simp]: \"\\<Gamma> (map_\\<Gamma> f s) i = f (\\<Gamma> s i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> (map_\\<Gamma> f s) i = f (\\<Gamma> s i)", "by transfer (simp add: prod.case_eq_if)"], ["", "lemma \\<tau>_map_\\<Gamma>[simp]: \"\\<tau> (map_\\<Gamma> f s) i = \\<tau> s i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> (map_\\<Gamma> f s) i = \\<tau> s i", "by transfer (simp add: prod.case_eq_if)"], ["", "lemma map_\\<Gamma>_id[simp]: \"map_\\<Gamma> id s = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_\\<Gamma> id s = s", "by transfer (simp add: stream.map_id)"], ["", "lemma map_\\<Gamma>_comp: \"map_\\<Gamma> g (map_\\<Gamma> f s) = map_\\<Gamma> (g \\<circ> f) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_\\<Gamma> g (map_\\<Gamma> f s) = map_\\<Gamma> (g \\<circ> f) s", "by transfer (simp add: stream.map_comp comp_def prod.case_eq_if case_prod_beta')"], ["", "lemma map_\\<Gamma>_cong: \"\\<sigma>\\<^sub>1 = \\<sigma>\\<^sub>2 \\<Longrightarrow> (\\<And>x. f\\<^sub>1 x = f\\<^sub>2 x) \\<Longrightarrow> map_\\<Gamma> f\\<^sub>1 \\<sigma>\\<^sub>1 = map_\\<Gamma> f\\<^sub>2 \\<sigma>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<sigma>\\<^sub>1 = \\<sigma>\\<^sub>2;\n     \\<And>x. f\\<^sub>1 x = f\\<^sub>2 x\\<rbrakk>\n    \\<Longrightarrow> map_\\<Gamma> f\\<^sub>1 \\<sigma>\\<^sub>1 =\n                      map_\\<Gamma> f\\<^sub>2 \\<sigma>\\<^sub>2", "by transfer (auto intro!: stream.map_cong)"], ["", "subsection \\<open>Finite trace prefixes\\<close>"], ["", "typedef 'a prefix = \"{p :: ('a set \\<times> nat) list. sorted (map snd p)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {p. sorted (map snd p)}", "by (auto intro!: exI[of _ \"[]\"])"], ["", "setup_lifting type_definition_prefix"], ["", "lift_definition pmap_\\<Gamma> :: \"('a set \\<Rightarrow> 'b set) \\<Rightarrow> 'a prefix \\<Rightarrow> 'b prefix\" is\n  \"\\<lambda>f. map (\\<lambda>(x, i). (f x, i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun list.\n       sorted (map snd list) \\<Longrightarrow>\n       sorted (map snd (map (\\<lambda>(x, y). (fun x, y)) list))", "by (simp add: split_beta comp_def)"], ["", "lift_definition last_ts :: \"'a prefix \\<Rightarrow> nat\" is\n  \"\\<lambda>p. (case p of [] \\<Rightarrow> 0 | _ \\<Rightarrow> snd (last p))\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition first_ts :: \"nat \\<Rightarrow> 'a prefix \\<Rightarrow> nat\" is\n  \"\\<lambda>n p. (case p of [] \\<Rightarrow> n | _ \\<Rightarrow> snd (hd p))\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition pnil :: \"'a prefix\" is \"[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (map snd [])", "by simp"], ["", "lift_definition plen :: \"'a prefix \\<Rightarrow> nat\" is \"length\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition psnoc :: \"'a prefix \\<Rightarrow> 'a set \\<times> nat \\<Rightarrow> 'a prefix\" is\n  \"\\<lambda>p x. if (case p of [] \\<Rightarrow> 0 | _ \\<Rightarrow> snd (last p)) \\<le> snd x then p @ [x] else []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list prod.\n       sorted (map snd list) \\<Longrightarrow>\n       sorted\n        (map snd\n          (if (case list of [] \\<Rightarrow> 0\n               | a # lista \\<Rightarrow> snd (last list))\n              \\<le> snd prod\n           then list @ [prod] else []))", "proof (goal_cases sorted_psnoc)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>list prod.\n       sorted (map snd list) \\<Longrightarrow>\n       sorted\n        (map snd\n          (if (case list of [] \\<Rightarrow> 0\n               | a # lista \\<Rightarrow> snd (last list))\n              \\<le> snd prod\n           then list @ [prod] else []))", "case (sorted_psnoc p x)"], ["proof (state)\nthis:\n  sorted (map snd p)\n\ngoal (1 subgoal):\n 1. \\<And>list prod.\n       sorted (map snd list) \\<Longrightarrow>\n       sorted\n        (map snd\n          (if (case list of [] \\<Rightarrow> 0\n               | a # lista \\<Rightarrow> snd (last list))\n              \\<le> snd prod\n           then list @ [prod] else []))", "then"], ["proof (chain)\npicking this:\n  sorted (map snd p)", "show ?case"], ["proof (prove)\nusing this:\n  sorted (map snd p)\n\ngoal (1 subgoal):\n 1. sorted\n     (map snd\n       (if (case p of [] \\<Rightarrow> 0\n            | a # list \\<Rightarrow> snd (last p))\n           \\<le> snd x\n        then p @ [x] else []))", "by (induction p) (auto split: if_splits list.splits)"], ["proof (state)\nthis:\n  sorted\n   (map snd\n     (if (case p of [] \\<Rightarrow> 0\n          | a # list \\<Rightarrow> snd (last p))\n         \\<le> snd x\n      then p @ [x] else []))\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation prefix :: (type) order begin"], ["", "lift_definition less_eq_prefix :: \"'a prefix \\<Rightarrow> 'a prefix \\<Rightarrow> bool\" is\n  \"\\<lambda>p q. \\<exists>r. q = p @ r\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition less_prefix :: \"'a prefix \\<Rightarrow> 'a prefix \\<Rightarrow> bool\" where\n  \"less_prefix x y = (x \\<le> y \\<and> \\<not> y \\<le> x)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a prefix, order_class)", "proof (standard, goal_cases less refl trans antisym)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "case (less x y)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)", "unfolding less_prefix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y \\<and> \\<not> y \\<le> x) =\n    (x \\<le> y \\<and> \\<not> y \\<le> x)", ".."], ["proof (state)\nthis:\n  (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n\ngoal (3 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "case (refl x)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x", "by transfer auto"], ["proof (state)\nthis:\n  x \\<le> x\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "case (trans x y z)"], ["proof (state)\nthis:\n  x \\<le> y\n  y \\<le> z\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  x \\<le> y\n  y \\<le> z", "show ?case"], ["proof (prove)\nusing this:\n  x \\<le> y\n  y \\<le> z\n\ngoal (1 subgoal):\n 1. x \\<le> z", "by transfer auto"], ["proof (state)\nthis:\n  x \\<le> z\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "case (antisym x y)"], ["proof (state)\nthis:\n  x \\<le> y\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  x \\<le> y\n  y \\<le> x", "show ?case"], ["proof (prove)\nusing this:\n  x \\<le> y\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. x = y", "by transfer auto"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma psnoc_inject[simp]:\n  \"last_ts p \\<le> snd x \\<Longrightarrow> last_ts q \\<le> snd y \\<Longrightarrow> psnoc p x = psnoc q y \\<longleftrightarrow> (p = q \\<and> x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>last_ts p \\<le> snd x; last_ts q \\<le> snd y\\<rbrakk>\n    \\<Longrightarrow> (psnoc p x = psnoc q y) = (p = q \\<and> x = y)", "by transfer auto"], ["", "lift_definition prefix_of :: \"'a prefix \\<Rightarrow> 'a trace \\<Rightarrow> bool\" is \"\\<lambda>p s. stake (length p) s = p\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma prefix_of_pnil[simp]: \"prefix_of pnil \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_of pnil \\<sigma>", "by transfer auto"], ["", "lemma plen_pnil[simp]: \"plen pnil = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plen pnil = 0", "by transfer auto"], ["", "lemma prefix_of_pmap_\\<Gamma>[simp]: \"prefix_of \\<pi> \\<sigma> \\<Longrightarrow> prefix_of (pmap_\\<Gamma> f \\<pi>) (map_\\<Gamma> f \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_of \\<pi> \\<sigma> \\<Longrightarrow>\n    prefix_of (pmap_\\<Gamma> f \\<pi>) (map_\\<Gamma> f \\<sigma>)", "by transfer auto"], ["", "lemma plen_mono: \"\\<pi> \\<le> \\<pi>' \\<Longrightarrow> plen \\<pi> \\<le> plen \\<pi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<le> \\<pi>' \\<Longrightarrow> plen \\<pi> \\<le> plen \\<pi>'", "by transfer auto"], ["", "lemma prefix_of_psnocE: \"prefix_of (psnoc p x) s \\<Longrightarrow> last_ts p \\<le> snd x \\<Longrightarrow>\n  (prefix_of p s \\<Longrightarrow> \\<Gamma> s (plen p) = fst x \\<Longrightarrow> \\<tau> s (plen p) = snd x \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prefix_of (psnoc p x) s; last_ts p \\<le> snd x;\n     \\<lbrakk>prefix_of p s; \\<Gamma> s (plen p) = fst x;\n      \\<tau> s (plen p) = snd x\\<rbrakk>\n     \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by transfer (simp del: stake.simps add: stake_Suc)"], ["", "lemma le_pnil[simp]: \"pnil \\<le> \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pnil \\<le> \\<pi>", "by transfer auto"], ["", "lift_definition take_prefix :: \"nat \\<Rightarrow> 'a trace \\<Rightarrow> 'a prefix\" is stake"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat stream.\n       ssorted (smap snd stream) \\<and>\n       sincreasing (smap snd stream) \\<Longrightarrow>\n       sorted (map snd (stake nat stream))", "by (auto dest: sorted_stake)"], ["", "lemma plen_take_prefix[simp]: \"plen (take_prefix i \\<sigma>) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plen (take_prefix i \\<sigma>) = i", "by transfer auto"], ["", "lemma plen_psnoc[simp]: \"last_ts \\<pi> \\<le> snd x \\<Longrightarrow> plen (psnoc \\<pi> x) = plen \\<pi> + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last_ts \\<pi> \\<le> snd x \\<Longrightarrow>\n    plen (psnoc \\<pi> x) = plen \\<pi> + 1", "by transfer auto"], ["", "lemma prefix_of_take_prefix[simp]: \"prefix_of (take_prefix i \\<sigma>) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_of (take_prefix i \\<sigma>) \\<sigma>", "by transfer auto"], ["", "lift_definition pdrop :: \"nat \\<Rightarrow> 'a prefix \\<Rightarrow> 'a prefix\" is drop"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat list.\n       sorted (map snd list) \\<Longrightarrow>\n       sorted (map snd (drop nat list))", "by (auto simp: drop_map[symmetric] sorted_drop)"], ["", "lemma pdrop_0[simp]: \"pdrop 0 \\<pi> = \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdrop 0 \\<pi> = \\<pi>", "by transfer auto"], ["", "lemma prefix_of_antimono: \"\\<pi> \\<le> \\<pi>' \\<Longrightarrow> prefix_of \\<pi>' s \\<Longrightarrow> prefix_of \\<pi> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<pi> \\<le> \\<pi>'; prefix_of \\<pi>' s\\<rbrakk>\n    \\<Longrightarrow> prefix_of \\<pi> s", "by transfer (auto simp del: stake_add simp add: stake_add[symmetric])"], ["", "lemma prefix_of_imp_linear: \"prefix_of \\<pi> \\<sigma> \\<Longrightarrow> prefix_of \\<pi>' \\<sigma> \\<Longrightarrow> \\<pi> \\<le> \\<pi>' \\<or> \\<pi>' \\<le> \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prefix_of \\<pi> \\<sigma>; prefix_of \\<pi>' \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> \\<pi> \\<le> \\<pi>' \\<or> \\<pi>' \\<le> \\<pi>", "proof transfer"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi> \\<sigma> \\<pi>'.\n       \\<lbrakk>sorted (map snd \\<pi>);\n        ssorted (smap snd \\<sigma>) \\<and> sincreasing (smap snd \\<sigma>);\n        stake (length \\<pi>) \\<sigma> = \\<pi>; sorted (map snd \\<pi>');\n        stake (length \\<pi>') \\<sigma> = \\<pi>'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>r. \\<pi>' = \\<pi> @ r) \\<or>\n                         (\\<exists>r. \\<pi> = \\<pi>' @ r)", "fix \\<pi> \\<pi>' and \\<sigma> :: \"('a set \\<times> nat) stream\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi> \\<sigma> \\<pi>'.\n       \\<lbrakk>sorted (map snd \\<pi>);\n        ssorted (smap snd \\<sigma>) \\<and> sincreasing (smap snd \\<sigma>);\n        stake (length \\<pi>) \\<sigma> = \\<pi>; sorted (map snd \\<pi>');\n        stake (length \\<pi>') \\<sigma> = \\<pi>'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>r. \\<pi>' = \\<pi> @ r) \\<or>\n                         (\\<exists>r. \\<pi> = \\<pi>' @ r)", "assume assms: \"stake (length \\<pi>) \\<sigma> = \\<pi>\" \"stake (length \\<pi>') \\<sigma> = \\<pi>'\""], ["proof (state)\nthis:\n  stake (length \\<pi>) \\<sigma> = \\<pi>\n  stake (length \\<pi>') \\<sigma> = \\<pi>'\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi> \\<sigma> \\<pi>'.\n       \\<lbrakk>sorted (map snd \\<pi>);\n        ssorted (smap snd \\<sigma>) \\<and> sincreasing (smap snd \\<sigma>);\n        stake (length \\<pi>) \\<sigma> = \\<pi>; sorted (map snd \\<pi>');\n        stake (length \\<pi>') \\<sigma> = \\<pi>'\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>r. \\<pi>' = \\<pi> @ r) \\<or>\n                         (\\<exists>r. \\<pi> = \\<pi>' @ r)", "show \"(\\<exists>r. \\<pi>' = \\<pi> @ r) \\<or> (\\<exists>r. \\<pi> = \\<pi>' @ r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>r. \\<pi>' = \\<pi> @ r) \\<or> (\\<exists>r. \\<pi> = \\<pi>' @ r)", "proof (cases \"length \\<pi>\" \"length \\<pi>'\" rule: le_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. length \\<pi> \\<le> length \\<pi>' \\<Longrightarrow>\n    (\\<exists>r. \\<pi>' = \\<pi> @ r) \\<or> (\\<exists>r. \\<pi> = \\<pi>' @ r)\n 2. length \\<pi>' \\<le> length \\<pi> \\<Longrightarrow>\n    (\\<exists>r. \\<pi>' = \\<pi> @ r) \\<or> (\\<exists>r. \\<pi> = \\<pi>' @ r)", "case le"], ["proof (state)\nthis:\n  length \\<pi> \\<le> length \\<pi>'\n\ngoal (2 subgoals):\n 1. length \\<pi> \\<le> length \\<pi>' \\<Longrightarrow>\n    (\\<exists>r. \\<pi>' = \\<pi> @ r) \\<or> (\\<exists>r. \\<pi> = \\<pi>' @ r)\n 2. length \\<pi>' \\<le> length \\<pi> \\<Longrightarrow>\n    (\\<exists>r. \\<pi>' = \\<pi> @ r) \\<or> (\\<exists>r. \\<pi> = \\<pi>' @ r)", "then"], ["proof (chain)\npicking this:\n  length \\<pi> \\<le> length \\<pi>'", "have \"\\<pi>' = take (length \\<pi>) \\<pi>' @ drop (length \\<pi>) \\<pi>'\""], ["proof (prove)\nusing this:\n  length \\<pi> \\<le> length \\<pi>'\n\ngoal (1 subgoal):\n 1. \\<pi>' = take (length \\<pi>) \\<pi>' @ drop (length \\<pi>) \\<pi>'", "by simp"], ["proof (state)\nthis:\n  \\<pi>' = take (length \\<pi>) \\<pi>' @ drop (length \\<pi>) \\<pi>'\n\ngoal (2 subgoals):\n 1. length \\<pi> \\<le> length \\<pi>' \\<Longrightarrow>\n    (\\<exists>r. \\<pi>' = \\<pi> @ r) \\<or> (\\<exists>r. \\<pi> = \\<pi>' @ r)\n 2. length \\<pi>' \\<le> length \\<pi> \\<Longrightarrow>\n    (\\<exists>r. \\<pi>' = \\<pi> @ r) \\<or> (\\<exists>r. \\<pi> = \\<pi>' @ r)", "moreover"], ["proof (state)\nthis:\n  \\<pi>' = take (length \\<pi>) \\<pi>' @ drop (length \\<pi>) \\<pi>'\n\ngoal (2 subgoals):\n 1. length \\<pi> \\<le> length \\<pi>' \\<Longrightarrow>\n    (\\<exists>r. \\<pi>' = \\<pi> @ r) \\<or> (\\<exists>r. \\<pi> = \\<pi>' @ r)\n 2. length \\<pi>' \\<le> length \\<pi> \\<Longrightarrow>\n    (\\<exists>r. \\<pi>' = \\<pi> @ r) \\<or> (\\<exists>r. \\<pi> = \\<pi>' @ r)", "have \"take (length \\<pi>) \\<pi>' = \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (length \\<pi>) \\<pi>' = \\<pi>", "using assms le"], ["proof (prove)\nusing this:\n  stake (length \\<pi>) \\<sigma> = \\<pi>\n  stake (length \\<pi>') \\<sigma> = \\<pi>'\n  length \\<pi> \\<le> length \\<pi>'\n\ngoal (1 subgoal):\n 1. take (length \\<pi>) \\<pi>' = \\<pi>", "by (metis min.absorb1 take_stake)"], ["proof (state)\nthis:\n  take (length \\<pi>) \\<pi>' = \\<pi>\n\ngoal (2 subgoals):\n 1. length \\<pi> \\<le> length \\<pi>' \\<Longrightarrow>\n    (\\<exists>r. \\<pi>' = \\<pi> @ r) \\<or> (\\<exists>r. \\<pi> = \\<pi>' @ r)\n 2. length \\<pi>' \\<le> length \\<pi> \\<Longrightarrow>\n    (\\<exists>r. \\<pi>' = \\<pi> @ r) \\<or> (\\<exists>r. \\<pi> = \\<pi>' @ r)", "ultimately"], ["proof (chain)\npicking this:\n  \\<pi>' = take (length \\<pi>) \\<pi>' @ drop (length \\<pi>) \\<pi>'\n  take (length \\<pi>) \\<pi>' = \\<pi>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<pi>' = take (length \\<pi>) \\<pi>' @ drop (length \\<pi>) \\<pi>'\n  take (length \\<pi>) \\<pi>' = \\<pi>\n\ngoal (1 subgoal):\n 1. (\\<exists>r. \\<pi>' = \\<pi> @ r) \\<or> (\\<exists>r. \\<pi> = \\<pi>' @ r)", "by auto"], ["proof (state)\nthis:\n  (\\<exists>r. \\<pi>' = \\<pi> @ r) \\<or> (\\<exists>r. \\<pi> = \\<pi>' @ r)\n\ngoal (1 subgoal):\n 1. length \\<pi>' \\<le> length \\<pi> \\<Longrightarrow>\n    (\\<exists>r. \\<pi>' = \\<pi> @ r) \\<or> (\\<exists>r. \\<pi> = \\<pi>' @ r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. length \\<pi>' \\<le> length \\<pi> \\<Longrightarrow>\n    (\\<exists>r. \\<pi>' = \\<pi> @ r) \\<or> (\\<exists>r. \\<pi> = \\<pi>' @ r)", "case ge"], ["proof (state)\nthis:\n  length \\<pi>' \\<le> length \\<pi>\n\ngoal (1 subgoal):\n 1. length \\<pi>' \\<le> length \\<pi> \\<Longrightarrow>\n    (\\<exists>r. \\<pi>' = \\<pi> @ r) \\<or> (\\<exists>r. \\<pi> = \\<pi>' @ r)", "then"], ["proof (chain)\npicking this:\n  length \\<pi>' \\<le> length \\<pi>", "have \"\\<pi> = take (length \\<pi>') \\<pi> @ drop (length \\<pi>') \\<pi>\""], ["proof (prove)\nusing this:\n  length \\<pi>' \\<le> length \\<pi>\n\ngoal (1 subgoal):\n 1. \\<pi> = take (length \\<pi>') \\<pi> @ drop (length \\<pi>') \\<pi>", "by simp"], ["proof (state)\nthis:\n  \\<pi> = take (length \\<pi>') \\<pi> @ drop (length \\<pi>') \\<pi>\n\ngoal (1 subgoal):\n 1. length \\<pi>' \\<le> length \\<pi> \\<Longrightarrow>\n    (\\<exists>r. \\<pi>' = \\<pi> @ r) \\<or> (\\<exists>r. \\<pi> = \\<pi>' @ r)", "moreover"], ["proof (state)\nthis:\n  \\<pi> = take (length \\<pi>') \\<pi> @ drop (length \\<pi>') \\<pi>\n\ngoal (1 subgoal):\n 1. length \\<pi>' \\<le> length \\<pi> \\<Longrightarrow>\n    (\\<exists>r. \\<pi>' = \\<pi> @ r) \\<or> (\\<exists>r. \\<pi> = \\<pi>' @ r)", "have \"take (length \\<pi>') \\<pi> = \\<pi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (length \\<pi>') \\<pi> = \\<pi>'", "using assms ge"], ["proof (prove)\nusing this:\n  stake (length \\<pi>) \\<sigma> = \\<pi>\n  stake (length \\<pi>') \\<sigma> = \\<pi>'\n  length \\<pi>' \\<le> length \\<pi>\n\ngoal (1 subgoal):\n 1. take (length \\<pi>') \\<pi> = \\<pi>'", "by (metis min.absorb1 take_stake)"], ["proof (state)\nthis:\n  take (length \\<pi>') \\<pi> = \\<pi>'\n\ngoal (1 subgoal):\n 1. length \\<pi>' \\<le> length \\<pi> \\<Longrightarrow>\n    (\\<exists>r. \\<pi>' = \\<pi> @ r) \\<or> (\\<exists>r. \\<pi> = \\<pi>' @ r)", "ultimately"], ["proof (chain)\npicking this:\n  \\<pi> = take (length \\<pi>') \\<pi> @ drop (length \\<pi>') \\<pi>\n  take (length \\<pi>') \\<pi> = \\<pi>'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<pi> = take (length \\<pi>') \\<pi> @ drop (length \\<pi>') \\<pi>\n  take (length \\<pi>') \\<pi> = \\<pi>'\n\ngoal (1 subgoal):\n 1. (\\<exists>r. \\<pi>' = \\<pi> @ r) \\<or> (\\<exists>r. \\<pi> = \\<pi>' @ r)", "by auto"], ["proof (state)\nthis:\n  (\\<exists>r. \\<pi>' = \\<pi> @ r) \\<or> (\\<exists>r. \\<pi> = \\<pi>' @ r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>r. \\<pi>' = \\<pi> @ r) \\<or> (\\<exists>r. \\<pi> = \\<pi>' @ r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ex_prefix_of: \"\\<exists>s. prefix_of p s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s. prefix_of p s", "proof (transfer, intro bexI CollectI conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>p.\n       sorted (map snd p) \\<Longrightarrow> stake (length p) (?s26 p) = p\n 2. \\<And>p.\n       sorted (map snd p) \\<Longrightarrow> ssorted (smap snd (?s26 p))\n 3. \\<And>p.\n       sorted (map snd p) \\<Longrightarrow> sincreasing (smap snd (?s26 p))", "fix p :: \"('a set \\<times> nat) list\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>p.\n       sorted (map snd p) \\<Longrightarrow> stake (length p) (?s26 p) = p\n 2. \\<And>p.\n       sorted (map snd p) \\<Longrightarrow> ssorted (smap snd (?s26 p))\n 3. \\<And>p.\n       sorted (map snd p) \\<Longrightarrow> sincreasing (smap snd (?s26 p))", "assume *: \"sorted (map snd p)\""], ["proof (state)\nthis:\n  sorted (map snd p)\n\ngoal (3 subgoals):\n 1. \\<And>p.\n       sorted (map snd p) \\<Longrightarrow> stake (length p) (?s26 p) = p\n 2. \\<And>p.\n       sorted (map snd p) \\<Longrightarrow> ssorted (smap snd (?s26 p))\n 3. \\<And>p.\n       sorted (map snd p) \\<Longrightarrow> sincreasing (smap snd (?s26 p))", "let ?\\<sigma> = \"p @- smap (Pair undefined) (fromN (snd (last p)))\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>p.\n       sorted (map snd p) \\<Longrightarrow> stake (length p) (?s26 p) = p\n 2. \\<And>p.\n       sorted (map snd p) \\<Longrightarrow> ssorted (smap snd (?s26 p))\n 3. \\<And>p.\n       sorted (map snd p) \\<Longrightarrow> sincreasing (smap snd (?s26 p))", "show \"stake (length p) ?\\<sigma> = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stake (length p) (p @- smap (Pair undefined) (fromN (snd (last p)))) = p", "by (simp add: stake_shift)"], ["proof (state)\nthis:\n  stake (length p) (p @- smap (Pair undefined) (fromN (snd (last p)))) = p\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       sorted (map snd p) \\<Longrightarrow>\n       ssorted\n        (smap snd (p @- smap (Pair undefined) (fromN (snd (last p)))))\n 2. \\<And>p.\n       sorted (map snd p) \\<Longrightarrow>\n       sincreasing\n        (smap snd (p @- smap (Pair undefined) (fromN (snd (last p)))))", "have le_last: \"snd (p ! i) \\<le> snd (last p)\" if \"i < length p\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (p ! i) \\<le> snd (last p)", "using sorted_nth_mono[OF *, of i \"length p - 1\"] that"], ["proof (prove)\nusing this:\n  \\<lbrakk>i \\<le> length p - 1; length p - 1 < length (map snd p)\\<rbrakk>\n  \\<Longrightarrow> map snd p ! i \\<le> map snd p ! (length p - 1)\n  i < length p\n\ngoal (1 subgoal):\n 1. snd (p ! i) \\<le> snd (last p)", "by (cases p) (auto simp: last_conv_nth nth_Cons')"], ["proof (state)\nthis:\n  ?i < length p \\<Longrightarrow> snd (p ! ?i) \\<le> snd (last p)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       sorted (map snd p) \\<Longrightarrow>\n       ssorted\n        (smap snd (p @- smap (Pair undefined) (fromN (snd (last p)))))\n 2. \\<And>p.\n       sorted (map snd p) \\<Longrightarrow>\n       sincreasing\n        (smap snd (p @- smap (Pair undefined) (fromN (snd (last p)))))", "with *"], ["proof (chain)\npicking this:\n  sorted (map snd p)\n  ?i < length p \\<Longrightarrow> snd (p ! ?i) \\<le> snd (last p)", "show \"ssorted (smap snd ?\\<sigma>)\""], ["proof (prove)\nusing this:\n  sorted (map snd p)\n  ?i < length p \\<Longrightarrow> snd (p ! ?i) \\<le> snd (last p)\n\ngoal (1 subgoal):\n 1. ssorted (smap snd (p @- smap (Pair undefined) (fromN (snd (last p)))))", "by (force simp: ssorted_iff_mono sorted_iff_nth_mono shift_snth)"], ["proof (state)\nthis:\n  ssorted (smap snd (p @- smap (Pair undefined) (fromN (snd (last p)))))\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       sorted (map snd p) \\<Longrightarrow>\n       sincreasing\n        (smap snd (p @- smap (Pair undefined) (fromN (snd (last p)))))", "show \"sincreasing (smap snd ?\\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sincreasing\n     (smap snd (p @- smap (Pair undefined) (fromN (snd (last p)))))", "proof (rule sincreasingI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>i.\n          x < smap snd\n               (p @- smap (Pair undefined) (fromN (snd (last p)))) !!\n              i", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>i.\n          x < smap snd\n               (p @- smap (Pair undefined) (fromN (snd (last p)))) !!\n              i", "have \"x < smap snd ?\\<sigma> !! Suc (length p + x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < smap snd (p @- smap (Pair undefined) (fromN (snd (last p)))) !!\n        Suc (length p + x)", "by simp (metis Suc_pred add.commute diff_Suc_Suc length_greater_0_conv less_add_Suc1 less_diff_conv)"], ["proof (state)\nthis:\n  x < smap snd (p @- smap (Pair undefined) (fromN (snd (last p)))) !!\n      Suc (length p + x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>i.\n          x < smap snd\n               (p @- smap (Pair undefined) (fromN (snd (last p)))) !!\n              i", "then"], ["proof (chain)\npicking this:\n  x < smap snd (p @- smap (Pair undefined) (fromN (snd (last p)))) !!\n      Suc (length p + x)", "show \"\\<exists>i. x < smap snd ?\\<sigma> !! i\""], ["proof (prove)\nusing this:\n  x < smap snd (p @- smap (Pair undefined) (fromN (snd (last p)))) !!\n      Suc (length p + x)\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       x < smap snd (p @- smap (Pair undefined) (fromN (snd (last p)))) !! i", ".."], ["proof (state)\nthis:\n  \\<exists>i.\n     x < smap snd (p @- smap (Pair undefined) (fromN (snd (last p)))) !! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sincreasing (smap snd (p @- smap (Pair undefined) (fromN (snd (last p)))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<tau>_prefix_conv: \"prefix_of p s \\<Longrightarrow> prefix_of p s' \\<Longrightarrow> i < plen p \\<Longrightarrow> \\<tau> s i = \\<tau> s' i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prefix_of p s; prefix_of p s'; i < plen p\\<rbrakk>\n    \\<Longrightarrow> \\<tau> s i = \\<tau> s' i", "by transfer (simp add: stake_nth[symmetric])"], ["", "lemma \\<Gamma>_prefix_conv: \"prefix_of p s \\<Longrightarrow> prefix_of p s' \\<Longrightarrow> i < plen p \\<Longrightarrow> \\<Gamma> s i = \\<Gamma> s' i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prefix_of p s; prefix_of p s'; i < plen p\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> s i = \\<Gamma> s' i", "by transfer (simp add: stake_nth[symmetric])"], ["", "lemma sincreasing_sdrop:\n  fixes s :: \"('a :: semilattice_sup) stream\"\n  assumes \"sincreasing s\"\n  shows \"sincreasing (sdrop n s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sincreasing (sdrop n s)", "proof (rule sincreasingI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>i. x < sdrop n s !! i", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>i. x < sdrop n s !! i", "obtain i where \"n < i\" and \"x < s !! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>n < i; x < s !! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using sincreasing_grD[OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>j>?i. ?x < s !! j\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>n < i; x < s !! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n < i\n  x < s !! i\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>i. x < sdrop n s !! i", "then"], ["proof (chain)\npicking this:\n  n < i\n  x < s !! i", "have \"x < sdrop n s !! (i - n)\""], ["proof (prove)\nusing this:\n  n < i\n  x < s !! i\n\ngoal (1 subgoal):\n 1. x < sdrop n s !! (i - n)", "by (simp add: sdrop_snth)"], ["proof (state)\nthis:\n  x < sdrop n s !! (i - n)\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>i. x < sdrop n s !! i", "then"], ["proof (chain)\npicking this:\n  x < sdrop n s !! (i - n)", "show \"\\<exists>i. x < sdrop n s !! i\""], ["proof (prove)\nusing this:\n  x < sdrop n s !! (i - n)\n\ngoal (1 subgoal):\n 1. \\<exists>i. x < sdrop n s !! i", ".."], ["proof (state)\nthis:\n  \\<exists>i. x < sdrop n s !! i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ssorted_shift:\n  \"ssorted (xs @- s) = (sorted xs \\<and> ssorted s \\<and> (\\<forall>x\\<in>set xs. \\<forall>y\\<in>sset s. x \\<le> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ssorted (xs @- s) =\n    (sorted xs \\<and>\n     ssorted s \\<and>\n     (\\<forall>x\\<in>set xs. \\<forall>y\\<in>sset s. x \\<le> y))", "proof safe"], ["proof (state)\ngoal (4 subgoals):\n 1. ssorted (xs @- s) \\<Longrightarrow> sorted xs\n 2. ssorted (xs @- s) \\<Longrightarrow> ssorted s\n 3. \\<And>x y.\n       \\<lbrakk>ssorted (xs @- s); x \\<in> set xs; y \\<in> sset s\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y\n 4. \\<lbrakk>sorted xs; ssorted s;\n     \\<forall>x\\<in>set xs. \\<forall>y\\<in>sset s. x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> ssorted (xs @- s)", "assume *: \"ssorted (xs @- s)\""], ["proof (state)\nthis:\n  ssorted (xs @- s)\n\ngoal (4 subgoals):\n 1. ssorted (xs @- s) \\<Longrightarrow> sorted xs\n 2. ssorted (xs @- s) \\<Longrightarrow> ssorted s\n 3. \\<And>x y.\n       \\<lbrakk>ssorted (xs @- s); x \\<in> set xs; y \\<in> sset s\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y\n 4. \\<lbrakk>sorted xs; ssorted s;\n     \\<forall>x\\<in>set xs. \\<forall>y\\<in>sset s. x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> ssorted (xs @- s)", "then"], ["proof (chain)\npicking this:\n  ssorted (xs @- s)", "show \"sorted xs\""], ["proof (prove)\nusing this:\n  ssorted (xs @- s)\n\ngoal (1 subgoal):\n 1. sorted xs", "by (auto simp: ssorted_iff_mono shift_snth sorted_iff_nth_mono split: if_splits)"], ["proof (state)\nthis:\n  sorted xs\n\ngoal (3 subgoals):\n 1. ssorted (xs @- s) \\<Longrightarrow> ssorted s\n 2. \\<And>x y.\n       \\<lbrakk>ssorted (xs @- s); x \\<in> set xs; y \\<in> sset s\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y\n 3. \\<lbrakk>sorted xs; ssorted s;\n     \\<forall>x\\<in>set xs. \\<forall>y\\<in>sset s. x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> ssorted (xs @- s)", "from ssorted_sdrop[OF *, of \"length xs\"]"], ["proof (chain)\npicking this:\n  ssorted (sdrop (length xs) (xs @- s))", "show \"ssorted s\""], ["proof (prove)\nusing this:\n  ssorted (sdrop (length xs) (xs @- s))\n\ngoal (1 subgoal):\n 1. ssorted s", "by (auto simp: sdrop_shift)"], ["proof (state)\nthis:\n  ssorted s\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>ssorted (xs @- s); x \\<in> set xs; y \\<in> sset s\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y\n 2. \\<lbrakk>sorted xs; ssorted s;\n     \\<forall>x\\<in>set xs. \\<forall>y\\<in>sset s. x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> ssorted (xs @- s)", "fix x y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>ssorted (xs @- s); x \\<in> set xs; y \\<in> sset s\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y\n 2. \\<lbrakk>sorted xs; ssorted s;\n     \\<forall>x\\<in>set xs. \\<forall>y\\<in>sset s. x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> ssorted (xs @- s)", "assume \"x \\<in> set xs\" \"y \\<in> sset s\""], ["proof (state)\nthis:\n  x \\<in> set xs\n  y \\<in> sset s\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>ssorted (xs @- s); x \\<in> set xs; y \\<in> sset s\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y\n 2. \\<lbrakk>sorted xs; ssorted s;\n     \\<forall>x\\<in>set xs. \\<forall>y\\<in>sset s. x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> ssorted (xs @- s)", "then"], ["proof (chain)\npicking this:\n  x \\<in> set xs\n  y \\<in> sset s", "obtain i j where \"i < length xs\" \"xs ! i = x\" \"s !! j = y\""], ["proof (prove)\nusing this:\n  x \\<in> set xs\n  y \\<in> sset s\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>i < length xs; xs ! i = x; s !! j = y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: set_conv_nth sset_range)"], ["proof (state)\nthis:\n  i < length xs\n  xs ! i = x\n  s !! j = y\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>ssorted (xs @- s); x \\<in> set xs; y \\<in> sset s\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y\n 2. \\<lbrakk>sorted xs; ssorted s;\n     \\<forall>x\\<in>set xs. \\<forall>y\\<in>sset s. x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> ssorted (xs @- s)", "with ssorted_monoD[OF *, of i \"j + length xs\"]"], ["proof (chain)\npicking this:\n  i \\<le> j + length xs \\<Longrightarrow>\n  (xs @- s) !! i \\<le> (xs @- s) !! (j + length xs)\n  i < length xs\n  xs ! i = x\n  s !! j = y", "show \"x \\<le> y\""], ["proof (prove)\nusing this:\n  i \\<le> j + length xs \\<Longrightarrow>\n  (xs @- s) !! i \\<le> (xs @- s) !! (j + length xs)\n  i < length xs\n  xs ! i = x\n  s !! j = y\n\ngoal (1 subgoal):\n 1. x \\<le> y", "by auto"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted xs; ssorted s;\n     \\<forall>x\\<in>set xs. \\<forall>y\\<in>sset s. x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> ssorted (xs @- s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted xs; ssorted s;\n     \\<forall>x\\<in>set xs. \\<forall>y\\<in>sset s. x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> ssorted (xs @- s)", "assume \"sorted xs\" \"ssorted s\" \"\\<forall>x\\<in>set xs. \\<forall>y\\<in>sset s. x \\<le> y\""], ["proof (state)\nthis:\n  sorted xs\n  ssorted s\n  \\<forall>x\\<in>set xs. \\<forall>y\\<in>sset s. x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted xs; ssorted s;\n     \\<forall>x\\<in>set xs. \\<forall>y\\<in>sset s. x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> ssorted (xs @- s)", "then"], ["proof (chain)\npicking this:\n  sorted xs\n  ssorted s\n  \\<forall>x\\<in>set xs. \\<forall>y\\<in>sset s. x \\<le> y", "show \"ssorted (xs @- s)\""], ["proof (prove)\nusing this:\n  sorted xs\n  ssorted s\n  \\<forall>x\\<in>set xs. \\<forall>y\\<in>sset s. x \\<le> y\n\ngoal (1 subgoal):\n 1. ssorted (xs @- s)", "proof (coinduction arbitrary: xs s)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs s.\n       \\<lbrakk>sorted xs; ssorted s;\n        \\<forall>x\\<in>set xs. Ball (sset s) ((\\<le>) x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sa.\n                            xs @- s = sa \\<and>\n                            shd sa \\<le> shd (stl sa) \\<and>\n                            ((\\<exists>xs s.\n                                 stl sa = xs @- s \\<and>\n                                 sorted xs \\<and>\n                                 ssorted s \\<and>\n                                 (\\<forall>x\\<in>set xs.\n                                     Ball (sset s) ((\\<le>) x))) \\<or>\n                             ssorted (stl sa))", "case (ssorted xs s)"], ["proof (state)\nthis:\n  sorted xs\n  ssorted s\n  \\<forall>x\\<in>set xs. Ball (sset s) ((\\<le>) x)\n\ngoal (1 subgoal):\n 1. \\<And>xs s.\n       \\<lbrakk>sorted xs; ssorted s;\n        \\<forall>x\\<in>set xs. Ball (sset s) ((\\<le>) x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sa.\n                            xs @- s = sa \\<and>\n                            shd sa \\<le> shd (stl sa) \\<and>\n                            ((\\<exists>xs s.\n                                 stl sa = xs @- s \\<and>\n                                 sorted xs \\<and>\n                                 ssorted s \\<and>\n                                 (\\<forall>x\\<in>set xs.\n                                     Ball (sset s) ((\\<le>) x))) \\<or>\n                             ssorted (stl sa))", "with \\<open>ssorted s\\<close>"], ["proof (chain)\npicking this:\n  ssorted s\n  sorted xs\n  ssorted s\n  \\<forall>x\\<in>set xs. Ball (sset s) ((\\<le>) x)", "show ?case"], ["proof (prove)\nusing this:\n  ssorted s\n  sorted xs\n  ssorted s\n  \\<forall>x\\<in>set xs. Ball (sset s) ((\\<le>) x)\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       xs @- s = s \\<and>\n       shd s \\<le> shd (stl s) \\<and>\n       ((\\<exists>xs sa.\n            stl s = xs @- sa \\<and>\n            sorted xs \\<and>\n            ssorted sa \\<and>\n            (\\<forall>x\\<in>set xs. Ball (sset sa) ((\\<le>) x))) \\<or>\n        ssorted (stl s))", "by (subst (asm) ssorted.simps) (auto 0 4 simp: neq_Nil_conv shd_sset intro: exI[of _ \"_ # _\"])"], ["proof (state)\nthis:\n  \\<exists>s.\n     xs @- s = s \\<and>\n     shd s \\<le> shd (stl s) \\<and>\n     ((\\<exists>xs sa.\n          stl s = xs @- sa \\<and>\n          sorted xs \\<and>\n          ssorted sa \\<and>\n          (\\<forall>x\\<in>set xs. Ball (sset sa) ((\\<le>) x))) \\<or>\n      ssorted (stl s))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ssorted (xs @- s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sincreasing_shift:\n  assumes \"sincreasing s\"\n  shows \"sincreasing (xs @- s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sincreasing (xs @- s)", "proof (rule sincreasingI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>i. x < (xs @- s) !! i", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>i. x < (xs @- s) !! i", "from assms"], ["proof (chain)\npicking this:\n  sincreasing s", "obtain i where \"x < s !! i\""], ["proof (prove)\nusing this:\n  sincreasing s\n\ngoal (1 subgoal):\n 1. (\\<And>i. x < s !! i \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding sincreasing_def"], ["proof (prove)\nusing this:\n  \\<forall>x. \\<exists>i. x < s !! i\n\ngoal (1 subgoal):\n 1. (\\<And>i. x < s !! i \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  x < s !! i\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>i. x < (xs @- s) !! i", "then"], ["proof (chain)\npicking this:\n  x < s !! i", "have \"x < (xs @- s) !! (length xs + i)\""], ["proof (prove)\nusing this:\n  x < s !! i\n\ngoal (1 subgoal):\n 1. x < (xs @- s) !! (length xs + i)", "by simp"], ["proof (state)\nthis:\n  x < (xs @- s) !! (length xs + i)\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<exists>i. x < (xs @- s) !! i", "then"], ["proof (chain)\npicking this:\n  x < (xs @- s) !! (length xs + i)", "show \"\\<exists>i. x < (xs @- s) !! i\""], ["proof (prove)\nusing this:\n  x < (xs @- s) !! (length xs + i)\n\ngoal (1 subgoal):\n 1. \\<exists>i. x < (xs @- s) !! i", ".."], ["proof (state)\nthis:\n  \\<exists>i. x < (xs @- s) !! i\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition replace_prefix :: \"'a prefix \\<Rightarrow> 'a trace \\<Rightarrow> 'a trace\" is\n   \"\\<lambda>\\<pi> \\<sigma>. if ssorted (smap snd (\\<pi> @- sdrop (length \\<pi>) \\<sigma>)) then\n     \\<pi> @- sdrop (length \\<pi>) \\<sigma> else smap (\\<lambda>i. ({}, i)) nats\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list stream.\n       \\<lbrakk>sorted (map snd list);\n        ssorted (smap snd stream) \\<and>\n        sincreasing (smap snd stream)\\<rbrakk>\n       \\<Longrightarrow> ssorted\n                          (smap snd\n                            (if ssorted\n                                 (smap snd\n                                   (list @- sdrop (length list) stream))\n                             then list @- sdrop (length list) stream\n                             else smap (Pair {}) nats)) \\<and>\n                         sincreasing\n                          (smap snd\n                            (if ssorted\n                                 (smap snd\n                                   (list @- sdrop (length list) stream))\n                             then list @- sdrop (length list) stream\n                             else smap (Pair {}) nats))", "by (auto split: if_splits simp: stream.map_comp stream.map_ident sdrop_smap[symmetric]\n    simp del: sdrop_smap intro!: sincreasing_shift sincreasing_sdrop cong: stream.map_cong)"], ["", "lemma prefix_of_replace_prefix:\n  \"prefix_of (pmap_\\<Gamma> f \\<pi>) \\<sigma> \\<Longrightarrow> prefix_of \\<pi> (replace_prefix \\<pi> \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_of (pmap_\\<Gamma> f \\<pi>) \\<sigma> \\<Longrightarrow>\n    prefix_of \\<pi> (replace_prefix \\<pi> \\<sigma>)", "proof (transfer; safe; goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f \\<pi> \\<sigma>.\n       \\<lbrakk>sorted (map snd \\<pi>);\n        stake (length (map (\\<lambda>(x, y). (f x, y)) \\<pi>)) \\<sigma> =\n        map (\\<lambda>(x, y). (f x, y)) \\<pi>;\n        ssorted (smap snd \\<sigma>);\n        sincreasing (smap snd \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> stake (length \\<pi>)\n                          (if ssorted\n                               (smap snd\n                                 (\\<pi> @- sdrop (length \\<pi>) \\<sigma>))\n                           then \\<pi> @- sdrop (length \\<pi>) \\<sigma>\n                           else smap (Pair {}) nats) =\n                         \\<pi>", "case (1 f \\<pi> \\<sigma>)"], ["proof (state)\nthis:\n  sorted (map snd \\<pi>)\n  stake (length (map (\\<lambda>(x, y). (f x, y)) \\<pi>)) \\<sigma> =\n  map (\\<lambda>(x, y). (f x, y)) \\<pi>\n  ssorted (smap snd \\<sigma>)\n  sincreasing (smap snd \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>f \\<pi> \\<sigma>.\n       \\<lbrakk>sorted (map snd \\<pi>);\n        stake (length (map (\\<lambda>(x, y). (f x, y)) \\<pi>)) \\<sigma> =\n        map (\\<lambda>(x, y). (f x, y)) \\<pi>;\n        ssorted (smap snd \\<sigma>);\n        sincreasing (smap snd \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> stake (length \\<pi>)\n                          (if ssorted\n                               (smap snd\n                                 (\\<pi> @- sdrop (length \\<pi>) \\<sigma>))\n                           then \\<pi> @- sdrop (length \\<pi>) \\<sigma>\n                           else smap (Pair {}) nats) =\n                         \\<pi>", "then"], ["proof (chain)\npicking this:\n  sorted (map snd \\<pi>)\n  stake (length (map (\\<lambda>(x, y). (f x, y)) \\<pi>)) \\<sigma> =\n  map (\\<lambda>(x, y). (f x, y)) \\<pi>\n  ssorted (smap snd \\<sigma>)\n  sincreasing (smap snd \\<sigma>)", "show ?case"], ["proof (prove)\nusing this:\n  sorted (map snd \\<pi>)\n  stake (length (map (\\<lambda>(x, y). (f x, y)) \\<pi>)) \\<sigma> =\n  map (\\<lambda>(x, y). (f x, y)) \\<pi>\n  ssorted (smap snd \\<sigma>)\n  sincreasing (smap snd \\<sigma>)\n\ngoal (1 subgoal):\n 1. stake (length \\<pi>)\n     (if ssorted (smap snd (\\<pi> @- sdrop (length \\<pi>) \\<sigma>))\n      then \\<pi> @- sdrop (length \\<pi>) \\<sigma>\n      else smap (Pair {}) nats) =\n    \\<pi>", "by (subst (asm) (2) stake_sdrop[symmetric, of _ \"length \\<pi>\"])\n      (auto 0 3 simp: ssorted_shift split_beta o_def stake_shift sdrop_smap[symmetric]\n        ssorted_sdrop not_le simp del: sdrop_smap)"], ["proof (state)\nthis:\n  stake (length \\<pi>)\n   (if ssorted (smap snd (\\<pi> @- sdrop (length \\<pi>) \\<sigma>))\n    then \\<pi> @- sdrop (length \\<pi>) \\<sigma> else smap (Pair {}) nats) =\n  \\<pi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_\\<Gamma>_replace_prefix:\n  \"\\<forall>x. f (f x) = f x \\<Longrightarrow> prefix_of (pmap_\\<Gamma> f \\<pi>) \\<sigma> \\<Longrightarrow> map_\\<Gamma> f (replace_prefix \\<pi> \\<sigma>) = map_\\<Gamma> f \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x. f (f x) = f x;\n     prefix_of (pmap_\\<Gamma> f \\<pi>) \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> map_\\<Gamma> f (replace_prefix \\<pi> \\<sigma>) =\n                      map_\\<Gamma> f \\<sigma>", "proof (transfer; safe; goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f \\<pi> \\<sigma>.\n       \\<lbrakk>\\<forall>x. f (f x) = f x; sorted (map snd \\<pi>);\n        stake (length (map (\\<lambda>(x, y). (f x, y)) \\<pi>)) \\<sigma> =\n        map (\\<lambda>(x, y). (f x, y)) \\<pi>;\n        ssorted (smap snd \\<sigma>);\n        sincreasing (smap snd \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> smap (\\<lambda>(x, y). (f x, y))\n                          (if ssorted\n                               (smap snd\n                                 (\\<pi> @- sdrop (length \\<pi>) \\<sigma>))\n                           then \\<pi> @- sdrop (length \\<pi>) \\<sigma>\n                           else smap (Pair {}) nats) =\n                         smap (\\<lambda>(x, y). (f x, y)) \\<sigma>", "case (1 f \\<pi> \\<sigma>)"], ["proof (state)\nthis:\n  \\<forall>x. f (f x) = f x\n  sorted (map snd \\<pi>)\n  stake (length (map (\\<lambda>(x, y). (f x, y)) \\<pi>)) \\<sigma> =\n  map (\\<lambda>(x, y). (f x, y)) \\<pi>\n  ssorted (smap snd \\<sigma>)\n  sincreasing (smap snd \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>f \\<pi> \\<sigma>.\n       \\<lbrakk>\\<forall>x. f (f x) = f x; sorted (map snd \\<pi>);\n        stake (length (map (\\<lambda>(x, y). (f x, y)) \\<pi>)) \\<sigma> =\n        map (\\<lambda>(x, y). (f x, y)) \\<pi>;\n        ssorted (smap snd \\<sigma>);\n        sincreasing (smap snd \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> smap (\\<lambda>(x, y). (f x, y))\n                          (if ssorted\n                               (smap snd\n                                 (\\<pi> @- sdrop (length \\<pi>) \\<sigma>))\n                           then \\<pi> @- sdrop (length \\<pi>) \\<sigma>\n                           else smap (Pair {}) nats) =\n                         smap (\\<lambda>(x, y). (f x, y)) \\<sigma>", "then"], ["proof (chain)\npicking this:\n  \\<forall>x. f (f x) = f x\n  sorted (map snd \\<pi>)\n  stake (length (map (\\<lambda>(x, y). (f x, y)) \\<pi>)) \\<sigma> =\n  map (\\<lambda>(x, y). (f x, y)) \\<pi>\n  ssorted (smap snd \\<sigma>)\n  sincreasing (smap snd \\<sigma>)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>x. f (f x) = f x\n  sorted (map snd \\<pi>)\n  stake (length (map (\\<lambda>(x, y). (f x, y)) \\<pi>)) \\<sigma> =\n  map (\\<lambda>(x, y). (f x, y)) \\<pi>\n  ssorted (smap snd \\<sigma>)\n  sincreasing (smap snd \\<sigma>)\n\ngoal (1 subgoal):\n 1. smap (\\<lambda>(x, y). (f x, y))\n     (if ssorted (smap snd (\\<pi> @- sdrop (length \\<pi>) \\<sigma>))\n      then \\<pi> @- sdrop (length \\<pi>) \\<sigma>\n      else smap (Pair {}) nats) =\n    smap (\\<lambda>(x, y). (f x, y)) \\<sigma>", "by (subst (asm) (2) stake_sdrop[symmetric, of \\<sigma> \"length \\<pi>\"],\n        subst (3) stake_sdrop[symmetric, of \\<sigma> \"length \\<pi>\"])\n      (auto simp: ssorted_shift split_beta o_def stake_shift sdrop_smap[symmetric] ssorted_sdrop\n        not_le simp del: sdrop_smap cong: map_cong)"], ["proof (state)\nthis:\n  smap (\\<lambda>(x, y). (f x, y))\n   (if ssorted (smap snd (\\<pi> @- sdrop (length \\<pi>) \\<sigma>))\n    then \\<pi> @- sdrop (length \\<pi>) \\<sigma> else smap (Pair {}) nats) =\n  smap (\\<lambda>(x, y). (f x, y)) \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prefix_of_pmap_\\<Gamma>_D:\n  assumes \"prefix_of (pmap_\\<Gamma> f \\<pi>) \\<sigma>\"\n  shows \"\\<exists>\\<sigma>'. prefix_of \\<pi> \\<sigma>' \\<and> prefix_of (pmap_\\<Gamma> f \\<pi>) (map_\\<Gamma> f \\<sigma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>'.\n       prefix_of \\<pi> \\<sigma>' \\<and>\n       prefix_of (pmap_\\<Gamma> f \\<pi>) (map_\\<Gamma> f \\<sigma>')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>'.\n       prefix_of \\<pi> \\<sigma>' \\<and>\n       prefix_of (pmap_\\<Gamma> f \\<pi>) (map_\\<Gamma> f \\<sigma>')", "from assms(1)"], ["proof (chain)\npicking this:\n  prefix_of (pmap_\\<Gamma> f \\<pi>) \\<sigma>", "obtain \\<sigma>' where 1: \"prefix_of \\<pi> \\<sigma>'\""], ["proof (prove)\nusing this:\n  prefix_of (pmap_\\<Gamma> f \\<pi>) \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>'.\n        prefix_of \\<pi> \\<sigma>' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ex_prefix_of"], ["proof (prove)\nusing this:\n  prefix_of (pmap_\\<Gamma> f \\<pi>) \\<sigma>\n  \\<exists>s. prefix_of ?p s\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>'.\n        prefix_of \\<pi> \\<sigma>' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  prefix_of \\<pi> \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>'.\n       prefix_of \\<pi> \\<sigma>' \\<and>\n       prefix_of (pmap_\\<Gamma> f \\<pi>) (map_\\<Gamma> f \\<sigma>')", "then"], ["proof (chain)\npicking this:\n  prefix_of \\<pi> \\<sigma>'", "have \"prefix_of (pmap_\\<Gamma> f \\<pi>) (map_\\<Gamma> f \\<sigma>')\""], ["proof (prove)\nusing this:\n  prefix_of \\<pi> \\<sigma>'\n\ngoal (1 subgoal):\n 1. prefix_of (pmap_\\<Gamma> f \\<pi>) (map_\\<Gamma> f \\<sigma>')", "by transfer simp"], ["proof (state)\nthis:\n  prefix_of (pmap_\\<Gamma> f \\<pi>) (map_\\<Gamma> f \\<sigma>')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>'.\n       prefix_of \\<pi> \\<sigma>' \\<and>\n       prefix_of (pmap_\\<Gamma> f \\<pi>) (map_\\<Gamma> f \\<sigma>')", "with 1"], ["proof (chain)\npicking this:\n  prefix_of \\<pi> \\<sigma>'\n  prefix_of (pmap_\\<Gamma> f \\<pi>) (map_\\<Gamma> f \\<sigma>')", "show ?thesis"], ["proof (prove)\nusing this:\n  prefix_of \\<pi> \\<sigma>'\n  prefix_of (pmap_\\<Gamma> f \\<pi>) (map_\\<Gamma> f \\<sigma>')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>'.\n       prefix_of \\<pi> \\<sigma>' \\<and>\n       prefix_of (pmap_\\<Gamma> f \\<pi>) (map_\\<Gamma> f \\<sigma>')", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<sigma>'.\n     prefix_of \\<pi> \\<sigma>' \\<and>\n     prefix_of (pmap_\\<Gamma> f \\<pi>) (map_\\<Gamma> f \\<sigma>')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prefix_of_map_\\<Gamma>_D:\n  assumes \"prefix_of \\<pi>' (map_\\<Gamma> f \\<sigma>)\"\n  shows \"\\<exists>\\<pi>''. \\<pi>' = pmap_\\<Gamma> f \\<pi>'' \\<and> prefix_of \\<pi>'' \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>''.\n       \\<pi>' = pmap_\\<Gamma> f \\<pi>'' \\<and> prefix_of \\<pi>'' \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  prefix_of \\<pi>' (map_\\<Gamma> f \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>''.\n       \\<pi>' = pmap_\\<Gamma> f \\<pi>'' \\<and> prefix_of \\<pi>'' \\<sigma>", "by transfer (auto intro!: exI[of _ \"stake (length _) _\"] elim: sym dest: sorted_stake)"], ["", "lift_definition pts :: \"'a prefix \\<Rightarrow> nat list\" is \"map snd\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma pts_pmap_\\<Gamma>[simp]: \"pts (pmap_\\<Gamma> f \\<pi>) = pts \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pts (pmap_\\<Gamma> f \\<pi>) = pts \\<pi>", "by (transfer fixing: f) (simp add: split_beta)"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}