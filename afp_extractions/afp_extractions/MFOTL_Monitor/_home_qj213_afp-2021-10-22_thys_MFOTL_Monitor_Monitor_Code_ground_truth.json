{"file_name": "/home/qj213/afp-2021-10-22/thys/MFOTL_Monitor/Monitor_Code.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MFOTL_Monitor", "problem_names": ["lemma image_these: \"f ` Option.these X = Option.these (map_option f ` X)\"", "lemma meval_MPred: \"meval n t db (MPred e ts) = ([Option.these\n  ((map_option (\\<lambda>f. tabulate f 0 n) o match ts) ` (\\<Union>(e', x)\\<in>db. if e = e' then {x} else {}))], MPred e ts)\"", "lemma meval_MPred': \"meval n t db (MPred e ts) = ([Option.these\n  (\\<Union>(e', x)\\<in>db. if e = e' then {map_option (\\<lambda>f. tabulate f 0 n) (match ts x)} else {})], MPred e ts)\"", "lemma these_UNION: \"Option.these (\\<Union> (B ` A)) = (\\<Union> ((Option.these o B) ` A))\"", "lemma meval_MPred'': \"meval n t db (MPred e ts) = ([\n  (\\<Union>(e', x)\\<in>db. if e = e' then set_option (map_option (\\<lambda>f. tabulate f 0 n) (match ts x)) else {})], MPred e ts)\"", "lemmas meval_code[code] = meval.simps(1) meval_MPred'' meval.simps(3-9)"], "translations": [["", "lemma image_these: \"f ` Option.these X = Option.these (map_option f ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` Option.these X = Option.these (map_option f ` X)", "by (force simp: in_these_eq Bex_def image_iff map_option_case split: option.splits)"], ["", "lemma meval_MPred: \"meval n t db (MPred e ts) = ([Option.these\n  ((map_option (\\<lambda>f. tabulate f 0 n) o match ts) ` (\\<Union>(e', x)\\<in>db. if e = e' then {x} else {}))], MPred e ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. meval n t db (MPred e ts) =\n    ([Option.these\n       ((map_option (\\<lambda>f. tabulate f 0 n) \\<circ> match ts) `\n        (\\<Union>(e', x)\\<in>db. if e = e' then {x} else {}))],\n     MPred e ts)", "unfolding meval.simps image_these image_image o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([Option.these\n       ((\\<lambda>x. map_option (\\<lambda>f. tabulate f 0 n) (match ts x)) `\n        (\\<Union>(e', x)\\<in>db. if e = e' then {x} else {}))],\n     MPred e ts) =\n    ([Option.these\n       ((\\<lambda>x. map_option (\\<lambda>f. tabulate f 0 n) (match ts x)) `\n        (\\<Union>(e', x)\\<in>db. if e = e' then {x} else {}))],\n     MPred e ts)", ".."], ["", "lemma meval_MPred': \"meval n t db (MPred e ts) = ([Option.these\n  (\\<Union>(e', x)\\<in>db. if e = e' then {map_option (\\<lambda>f. tabulate f 0 n) (match ts x)} else {})], MPred e ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. meval n t db (MPred e ts) =\n    ([Option.these\n       (\\<Union>(e', x)\\<in>db.\n           if e = e'\n           then {map_option (\\<lambda>f. tabulate f 0 n) (match ts x)}\n           else {})],\n     MPred e ts)", "unfolding meval_MPred image_UN split_beta if_distrib[of \"image _\"] image_insert image_empty o_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([Option.these\n       (\\<Union>x\\<in>db.\n           if e = fst x\n           then {map_option (\\<lambda>f. tabulate f 0 n) (match ts (snd x))}\n           else {})],\n     MPred e ts) =\n    ([Option.these\n       (\\<Union>prod\\<in>db.\n           if e = fst prod\n           then {map_option (\\<lambda>f. tabulate f 0 n)\n                  (match ts (snd prod))}\n           else {})],\n     MPred e ts)", ".."], ["", "lemma these_UNION: \"Option.these (\\<Union> (B ` A)) = (\\<Union> ((Option.these o B) ` A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Option.these (\\<Union> (B ` A)) =\n    \\<Union> ((Option.these \\<circ> B) ` A)", "by (auto simp: Option.these_def)"], ["", "lemma meval_MPred'': \"meval n t db (MPred e ts) = ([\n  (\\<Union>(e', x)\\<in>db. if e = e' then set_option (map_option (\\<lambda>f. tabulate f 0 n) (match ts x)) else {})], MPred e ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. meval n t db (MPred e ts) =\n    ([\\<Union>(e', x)\\<in>db.\n         if e = e'\n         then set_option\n               (map_option (\\<lambda>f. tabulate f 0 n) (match ts x))\n         else {}],\n     MPred e ts)", "unfolding meval_MPred' these_UNION o_def prod.case_distrib[of Option.these]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([\\<Union>x\\<in>db.\n         case x of\n         (x1, x2) \\<Rightarrow>\n           Option.these\n            (if e = x1\n             then {map_option (\\<lambda>f. tabulate f 0 n) (match ts x2)}\n             else {})],\n     MPred e ts) =\n    ([\\<Union>(e', x)\\<in>db.\n         if e = e'\n         then set_option\n               (map_option (\\<lambda>f. tabulate f 0 n) (match ts x))\n         else {}],\n     MPred e ts)", "by (auto simp: Option.these_def map_option_case image_iff split: if_splits option.splits)"], ["", "lemmas meval_code[code] = meval.simps(1) meval_MPred'' meval.simps(3-9)"], ["", "definition db_code :: \"(char list \\<times> 'a list) list \\<Rightarrow> (char list \\<times> 'a list) set\" where\n  \"db_code = set\""], ["", "definition verdict_code :: \"_ \\<Rightarrow> (nat \\<times> 'a :: ccompare option list) list\" where\n  \"verdict_code = RBT_Set2.keys\""], ["", "export_code HOL.equal Collection_Eq.ceq Collection_Order.ccompare Eq Lt Gt set_RBT set_impl phantom\n  nat_of_integer integer_of_nat enat literal.explode db_code set interval RBT_set verdict_code\n  MFOTL.Var MFOTL.Const\n  MFOTL.Pred MFOTL.Eq MFOTL.Neg MFOTL.Or MFOTL.Exists\n  MFOTL.Prev MFOTL.Next MFOTL.Since MFOTL.Until\n  checking OCaml?"], ["", "export_code HOL.equal Collection_Eq.ceq Collection_Order.ccompare Eq Lt Gt set_RBT set_impl phantom\n  nat_of_integer integer_of_nat enat literal.explode db_code set interval RBT_set verdict_code\n  MFOTL.Var MFOTL.Const\n  MFOTL.Pred MFOTL.Eq MFOTL.Neg MFOTL.Or MFOTL.Exists\n  MFOTL.Prev MFOTL.Next MFOTL.Since MFOTL.Until\n  minit_safe mstep in OCaml module_name Monitor file_prefix \"verified\""], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}