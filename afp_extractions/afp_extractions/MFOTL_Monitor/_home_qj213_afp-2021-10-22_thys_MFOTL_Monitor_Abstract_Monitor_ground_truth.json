{"file_name": "/home/qj213/afp-2021-10-22/thys/MFOTL_Monitor/Abstract_Monitor.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MFOTL_Monitor", "problem_names": ["lemma cosafety: \"sat \\<sigma> v i \\<longleftrightarrow> (\\<exists>\\<pi>. prefix_of \\<pi> \\<sigma> \\<and> (\\<forall>\\<sigma>'. prefix_of \\<pi> \\<sigma>' \\<longrightarrow> sat \\<sigma>' v i))\"", "lemma M_limit_eq: \"M_limit \\<sigma> = verdicts \\<sigma>\"", "lemma M_alt: \"M \\<pi> = {(i, v). i < progress \\<pi> \\<and> wf_tuple nfv fv v \\<and>\n    (\\<exists>\\<sigma>. prefix_of \\<pi> \\<sigma> \\<and> sat \\<sigma> (map the v) i)}\"", "lemma prefix_of_psliceI: \"prefix_of \\<pi> \\<sigma> \\<Longrightarrow> prefix_of (pslice S \\<pi>) (slice S \\<sigma>)\"", "lemma plen_pslice[simp]: \"plen (pslice S \\<pi>) = plen \\<pi>\"", "lemma pslice_pnil[simp]: \"pslice S pnil = pnil\"", "lemma last_ts_pslice[simp]: \"last_ts (pslice S \\<pi>) = last_ts \\<pi>\"", "lemma union_verdicts_slice:\n  assumes part: \"\\<Union>\\<S> = UNIV\"\n  shows \"\\<Union>((\\<lambda>S. verdict_filter S (verdicts (slice S \\<sigma>))) ` \\<S>) = verdicts \\<sigma>\"", "lemma union_M_pslice:\n  assumes part: \"\\<Union>\\<S> = UNIV\"\n  shows \"\\<Union>((\\<lambda>S. verdict_filter S (M (pslice S \\<pi>))) ` \\<S>) = M \\<pi>\"", "lemma progress_pslice[simp]: \"progress (pslice S \\<pi>) = progress \\<pi>\""], "translations": [["", "lemma cosafety: \"sat \\<sigma> v i \\<longleftrightarrow> (\\<exists>\\<pi>. prefix_of \\<pi> \\<sigma> \\<and> (\\<forall>\\<sigma>'. prefix_of \\<pi> \\<sigma>' \\<longrightarrow> sat \\<sigma>' v i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sat \\<sigma> v i =\n    (\\<exists>\\<pi>.\n        prefix_of \\<pi> \\<sigma> \\<and>\n        (\\<forall>\\<sigma>'.\n            prefix_of \\<pi> \\<sigma>' \\<longrightarrow> sat \\<sigma>' v i))", "using cosafety_lr"], ["proof (prove)\nusing this:\n  sat ?\\<sigma> ?v ?i \\<Longrightarrow>\n  \\<exists>\\<pi>.\n     prefix_of \\<pi> ?\\<sigma> \\<and>\n     (\\<forall>\\<sigma>'.\n         prefix_of \\<pi> \\<sigma>' \\<longrightarrow> sat \\<sigma>' ?v ?i)\n\ngoal (1 subgoal):\n 1. sat \\<sigma> v i =\n    (\\<exists>\\<pi>.\n        prefix_of \\<pi> \\<sigma> \\<and>\n        (\\<forall>\\<sigma>'.\n            prefix_of \\<pi> \\<sigma>' \\<longrightarrow> sat \\<sigma>' v i))", "by blast"], ["", "end"], ["", "subsection \\<open>Monitor function\\<close>"], ["", "text \\<open>\n  We model monitors abstractly as functions from prefixes to verdict sets.\n  The following locale specifies a minimal set of properties that any\n  reasonable monitor should have.\n\\<close>"], ["", "locale monitor = fo_spec +\n  fixes M :: \"'a prefix \\<Rightarrow> (nat \\<times> 'b tuple) set\"\n  assumes\n    mono_monitor: \"\\<pi> \\<le> \\<pi>' \\<Longrightarrow> M \\<pi> \\<subseteq> M \\<pi>'\" and\n    wf_monitor: \"(i, v) \\<in> M \\<pi> \\<Longrightarrow> wf_tuple nfv fv v\" and\n    sound_monitor: \"(i, v) \\<in> M \\<pi> \\<Longrightarrow> prefix_of \\<pi> \\<sigma> \\<Longrightarrow> sat \\<sigma> (map the v) i\" and\n    complete_monitor: \"prefix_of \\<pi> \\<sigma> \\<Longrightarrow> wf_tuple nfv fv v \\<Longrightarrow>\n      (\\<And>\\<sigma>. prefix_of \\<pi> \\<sigma> \\<Longrightarrow> sat \\<sigma> (map the v) i) \\<Longrightarrow> \\<exists>\\<pi>'. prefix_of \\<pi>' \\<sigma> \\<and> (i, v) \\<in> M \\<pi>'\""], ["", "text \\<open>\n  A monitor for a co-safety specification computes precisely the set of all\n  satisfactions in the limit:\n\\<close>"], ["", "abbreviation (in monitor) \"M_limit \\<sigma> \\<equiv> \\<Union>{M \\<pi> | \\<pi>. prefix_of \\<pi> \\<sigma>}\""], ["", "locale cosafety_monitor = cosafety_fo_spec + monitor\nbegin"], ["", "lemma M_limit_eq: \"M_limit \\<sigma> = verdicts \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M_limit \\<sigma> = verdicts \\<sigma>", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. M_limit \\<sigma> \\<subseteq> verdicts \\<sigma>\n 2. verdicts \\<sigma> \\<subseteq> M_limit \\<sigma>", "show \"\\<Union>{M \\<pi> | \\<pi>. prefix_of \\<pi> \\<sigma>} \\<subseteq> verdicts \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M_limit \\<sigma> \\<subseteq> verdicts \\<sigma>", "by (auto simp: verdicts_def wf_monitor sound_monitor)"], ["proof (state)\nthis:\n  M_limit \\<sigma> \\<subseteq> verdicts \\<sigma>\n\ngoal (1 subgoal):\n 1. verdicts \\<sigma> \\<subseteq> M_limit \\<sigma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. verdicts \\<sigma> \\<subseteq> M_limit \\<sigma>", "show \"\\<Union>{M \\<pi> | \\<pi>. prefix_of \\<pi> \\<sigma>} \\<supseteq> verdicts \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. verdicts \\<sigma> \\<subseteq> M_limit \\<sigma>", "unfolding verdicts_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(i, v). wf_tuple nfv fv v \\<and> sat \\<sigma> (map the v) i}\n    \\<subseteq> M_limit \\<sigma>", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>wf_tuple nfv fv b; sat \\<sigma> (map the b) a\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> M_limit \\<sigma>", "fix i v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>wf_tuple nfv fv b; sat \\<sigma> (map the b) a\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> M_limit \\<sigma>", "assume \"wf_tuple nfv fv v\" and \"sat \\<sigma> (map the v) i\""], ["proof (state)\nthis:\n  wf_tuple nfv fv v\n  sat \\<sigma> (map the v) i\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>wf_tuple nfv fv b; sat \\<sigma> (map the b) a\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> M_limit \\<sigma>", "then"], ["proof (chain)\npicking this:\n  wf_tuple nfv fv v\n  sat \\<sigma> (map the v) i", "obtain \\<pi> where \"prefix_of \\<pi> \\<sigma> \\<and> (\\<forall>\\<sigma>'. prefix_of \\<pi> \\<sigma>' \\<longrightarrow> sat \\<sigma>' (map the v) i)\""], ["proof (prove)\nusing this:\n  wf_tuple nfv fv v\n  sat \\<sigma> (map the v) i\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        prefix_of \\<pi> \\<sigma> \\<and>\n        (\\<forall>\\<sigma>'.\n            prefix_of \\<pi> \\<sigma>' \\<longrightarrow>\n            sat \\<sigma>' (map the v) i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using cosafety_lr"], ["proof (prove)\nusing this:\n  wf_tuple nfv fv v\n  sat \\<sigma> (map the v) i\n  sat ?\\<sigma> ?v ?i \\<Longrightarrow>\n  \\<exists>\\<pi>.\n     prefix_of \\<pi> ?\\<sigma> \\<and>\n     (\\<forall>\\<sigma>'.\n         prefix_of \\<pi> \\<sigma>' \\<longrightarrow> sat \\<sigma>' ?v ?i)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        prefix_of \\<pi> \\<sigma> \\<and>\n        (\\<forall>\\<sigma>'.\n            prefix_of \\<pi> \\<sigma>' \\<longrightarrow>\n            sat \\<sigma>' (map the v) i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  prefix_of \\<pi> \\<sigma> \\<and>\n  (\\<forall>\\<sigma>'.\n      prefix_of \\<pi> \\<sigma>' \\<longrightarrow>\n      sat \\<sigma>' (map the v) i)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>wf_tuple nfv fv b; sat \\<sigma> (map the b) a\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> M_limit \\<sigma>", "with \\<open>wf_tuple nfv fv v\\<close>"], ["proof (chain)\npicking this:\n  wf_tuple nfv fv v\n  prefix_of \\<pi> \\<sigma> \\<and>\n  (\\<forall>\\<sigma>'.\n      prefix_of \\<pi> \\<sigma>' \\<longrightarrow>\n      sat \\<sigma>' (map the v) i)", "obtain \\<pi>' where \"prefix_of \\<pi>' \\<sigma> \\<and> (i, v) \\<in> M \\<pi>'\""], ["proof (prove)\nusing this:\n  wf_tuple nfv fv v\n  prefix_of \\<pi> \\<sigma> \\<and>\n  (\\<forall>\\<sigma>'.\n      prefix_of \\<pi> \\<sigma>' \\<longrightarrow>\n      sat \\<sigma>' (map the v) i)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>'.\n        prefix_of \\<pi>' \\<sigma> \\<and>\n        (i, v) \\<in> M \\<pi>' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using complete_monitor"], ["proof (prove)\nusing this:\n  wf_tuple nfv fv v\n  prefix_of \\<pi> \\<sigma> \\<and>\n  (\\<forall>\\<sigma>'.\n      prefix_of \\<pi> \\<sigma>' \\<longrightarrow>\n      sat \\<sigma>' (map the v) i)\n  \\<lbrakk>prefix_of ?\\<pi> ?\\<sigma>; wf_tuple nfv fv ?v;\n   \\<And>\\<sigma>.\n      prefix_of ?\\<pi> \\<sigma> \\<Longrightarrow>\n      sat \\<sigma> (map the ?v) ?i\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<pi>'.\n                       prefix_of \\<pi>' ?\\<sigma> \\<and>\n                       (?i, ?v) \\<in> M \\<pi>'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>'.\n        prefix_of \\<pi>' \\<sigma> \\<and>\n        (i, v) \\<in> M \\<pi>' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  prefix_of \\<pi>' \\<sigma> \\<and> (i, v) \\<in> M \\<pi>'\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>wf_tuple nfv fv b; sat \\<sigma> (map the b) a\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> M_limit \\<sigma>", "then"], ["proof (chain)\npicking this:\n  prefix_of \\<pi>' \\<sigma> \\<and> (i, v) \\<in> M \\<pi>'", "show \"(i, v) \\<in> \\<Union>{M \\<pi> | \\<pi>. prefix_of \\<pi> \\<sigma>}\""], ["proof (prove)\nusing this:\n  prefix_of \\<pi>' \\<sigma> \\<and> (i, v) \\<in> M \\<pi>'\n\ngoal (1 subgoal):\n 1. (i, v) \\<in> M_limit \\<sigma>", "by blast"], ["proof (state)\nthis:\n  (i, v) \\<in> M_limit \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  verdicts \\<sigma> \\<subseteq> M_limit \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>\n  The monitor function \\<^term>\\<open>M\\<close> adds some information over \\<^term>\\<open>sat\\<close>, namely\n  when a verdict is output. One possible behavior is that the monitor outputs\n  its verdicts for one time-point at a time, in increasing order of\n  time-points. Then \\<^term>\\<open>M\\<close> is uniquely defined by a progress function, which\n  returns for every prefix the time-point up to which all verdicts are computed.\n\\<close>"], ["", "locale progress = fo_spec _ _ sat for sat :: \"'a trace \\<Rightarrow> 'b list \\<Rightarrow> nat \\<Rightarrow> bool\" +\n  fixes progress :: \"'a prefix \\<Rightarrow> nat\"\n  assumes\n    progress_mono: \"\\<pi> \\<le> \\<pi>' \\<Longrightarrow> progress \\<pi> \\<le> progress \\<pi>'\" and\n    ex_progress_ge: \"\\<exists>\\<pi>. prefix_of \\<pi> \\<sigma> \\<and> x \\<le> progress \\<pi>\" and\n    progress_sat_cong: \"prefix_of \\<pi> \\<sigma> \\<Longrightarrow> prefix_of \\<pi> \\<sigma>' \\<Longrightarrow> i < progress \\<pi> \\<Longrightarrow>\n      sat \\<sigma> v i \\<longleftrightarrow> sat \\<sigma>' v i\"\n    \\<comment> \\<open>The last condition is not necessary to obtain a proper monitor function.\n      However, it corresponds to the intuitive understanding of monitor progress,\n      and it results in a stronger characterisation. In particular, it implies that\n      the specification is co-safety, as we will show below.\\<close>\nbegin"], ["", "definition M :: \"'a prefix \\<Rightarrow> (nat \\<times> 'b tuple) set\" where\n  \"M \\<pi> = {(i, v). i < progress \\<pi> \\<and> wf_tuple nfv fv v \\<and>\n    (\\<forall>\\<sigma>. prefix_of \\<pi> \\<sigma> \\<longrightarrow> sat \\<sigma> (map the v) i)}\""], ["", "lemma M_alt: \"M \\<pi> = {(i, v). i < progress \\<pi> \\<and> wf_tuple nfv fv v \\<and>\n    (\\<exists>\\<sigma>. prefix_of \\<pi> \\<sigma> \\<and> sat \\<sigma> (map the v) i)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<pi> =\n    {(i, v).\n     i < progress \\<pi> \\<and>\n     wf_tuple nfv fv v \\<and>\n     (\\<exists>\\<sigma>.\n         prefix_of \\<pi> \\<sigma> \\<and> sat \\<sigma> (map the v) i)}", "using ex_prefix_of[of \\<pi>]"], ["proof (prove)\nusing this:\n  \\<exists>s. prefix_of \\<pi> s\n\ngoal (1 subgoal):\n 1. M \\<pi> =\n    {(i, v).\n     i < progress \\<pi> \\<and>\n     wf_tuple nfv fv v \\<and>\n     (\\<exists>\\<sigma>.\n         prefix_of \\<pi> \\<sigma> \\<and> sat \\<sigma> (map the v) i)}", "by (auto simp: M_def cong: progress_sat_cong)"], ["", "end"], ["", "sublocale progress \\<subseteq> cosafety_monitor _ _ _ M"], ["proof (prove)\ngoal (1 subgoal):\n 1. cosafety_monitor nfv fv sat M", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<sigma> v i.\n       sat \\<sigma> v i \\<Longrightarrow>\n       \\<exists>\\<pi>.\n          prefix_of \\<pi> \\<sigma> \\<and>\n          (\\<forall>\\<sigma>'.\n              prefix_of \\<pi> \\<sigma>' \\<longrightarrow> sat \\<sigma>' v i)\n 2. \\<And>\\<pi> \\<pi>'.\n       \\<pi> \\<le> \\<pi>' \\<Longrightarrow> M \\<pi> \\<subseteq> M \\<pi>'\n 3. \\<And>i v \\<pi>.\n       (i, v) \\<in> M \\<pi> \\<Longrightarrow> wf_tuple nfv fv v\n 4. \\<And>i v \\<pi> \\<sigma>.\n       \\<lbrakk>(i, v) \\<in> M \\<pi>; prefix_of \\<pi> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> sat \\<sigma> (map the v) i\n 5. \\<And>\\<pi> \\<sigma> v i.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; wf_tuple nfv fv v;\n        \\<And>\\<sigma>.\n           prefix_of \\<pi> \\<sigma> \\<Longrightarrow>\n           sat \\<sigma> (map the v) i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<pi>'.\n                            prefix_of \\<pi>' \\<sigma> \\<and>\n                            (i, v) \\<in> M \\<pi>'", "fix i v and \\<sigma> :: \"'a trace\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<sigma> v i.\n       sat \\<sigma> v i \\<Longrightarrow>\n       \\<exists>\\<pi>.\n          prefix_of \\<pi> \\<sigma> \\<and>\n          (\\<forall>\\<sigma>'.\n              prefix_of \\<pi> \\<sigma>' \\<longrightarrow> sat \\<sigma>' v i)\n 2. \\<And>\\<pi> \\<pi>'.\n       \\<pi> \\<le> \\<pi>' \\<Longrightarrow> M \\<pi> \\<subseteq> M \\<pi>'\n 3. \\<And>i v \\<pi>.\n       (i, v) \\<in> M \\<pi> \\<Longrightarrow> wf_tuple nfv fv v\n 4. \\<And>i v \\<pi> \\<sigma>.\n       \\<lbrakk>(i, v) \\<in> M \\<pi>; prefix_of \\<pi> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> sat \\<sigma> (map the v) i\n 5. \\<And>\\<pi> \\<sigma> v i.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; wf_tuple nfv fv v;\n        \\<And>\\<sigma>.\n           prefix_of \\<pi> \\<sigma> \\<Longrightarrow>\n           sat \\<sigma> (map the v) i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<pi>'.\n                            prefix_of \\<pi>' \\<sigma> \\<and>\n                            (i, v) \\<in> M \\<pi>'", "assume \"sat \\<sigma> v i\""], ["proof (state)\nthis:\n  sat \\<sigma> v i\n\ngoal (5 subgoals):\n 1. \\<And>\\<sigma> v i.\n       sat \\<sigma> v i \\<Longrightarrow>\n       \\<exists>\\<pi>.\n          prefix_of \\<pi> \\<sigma> \\<and>\n          (\\<forall>\\<sigma>'.\n              prefix_of \\<pi> \\<sigma>' \\<longrightarrow> sat \\<sigma>' v i)\n 2. \\<And>\\<pi> \\<pi>'.\n       \\<pi> \\<le> \\<pi>' \\<Longrightarrow> M \\<pi> \\<subseteq> M \\<pi>'\n 3. \\<And>i v \\<pi>.\n       (i, v) \\<in> M \\<pi> \\<Longrightarrow> wf_tuple nfv fv v\n 4. \\<And>i v \\<pi> \\<sigma>.\n       \\<lbrakk>(i, v) \\<in> M \\<pi>; prefix_of \\<pi> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> sat \\<sigma> (map the v) i\n 5. \\<And>\\<pi> \\<sigma> v i.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; wf_tuple nfv fv v;\n        \\<And>\\<sigma>.\n           prefix_of \\<pi> \\<sigma> \\<Longrightarrow>\n           sat \\<sigma> (map the v) i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<pi>'.\n                            prefix_of \\<pi>' \\<sigma> \\<and>\n                            (i, v) \\<in> M \\<pi>'", "moreover"], ["proof (state)\nthis:\n  sat \\<sigma> v i\n\ngoal (5 subgoals):\n 1. \\<And>\\<sigma> v i.\n       sat \\<sigma> v i \\<Longrightarrow>\n       \\<exists>\\<pi>.\n          prefix_of \\<pi> \\<sigma> \\<and>\n          (\\<forall>\\<sigma>'.\n              prefix_of \\<pi> \\<sigma>' \\<longrightarrow> sat \\<sigma>' v i)\n 2. \\<And>\\<pi> \\<pi>'.\n       \\<pi> \\<le> \\<pi>' \\<Longrightarrow> M \\<pi> \\<subseteq> M \\<pi>'\n 3. \\<And>i v \\<pi>.\n       (i, v) \\<in> M \\<pi> \\<Longrightarrow> wf_tuple nfv fv v\n 4. \\<And>i v \\<pi> \\<sigma>.\n       \\<lbrakk>(i, v) \\<in> M \\<pi>; prefix_of \\<pi> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> sat \\<sigma> (map the v) i\n 5. \\<And>\\<pi> \\<sigma> v i.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; wf_tuple nfv fv v;\n        \\<And>\\<sigma>.\n           prefix_of \\<pi> \\<sigma> \\<Longrightarrow>\n           sat \\<sigma> (map the v) i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<pi>'.\n                            prefix_of \\<pi>' \\<sigma> \\<and>\n                            (i, v) \\<in> M \\<pi>'", "obtain \\<pi> where *: \"prefix_of \\<pi> \\<sigma>\" \"i < progress \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        \\<lbrakk>prefix_of \\<pi> \\<sigma>; i < progress \\<pi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ex_progress_ge"], ["proof (prove)\nusing this:\n  \\<exists>\\<pi>. prefix_of \\<pi> ?\\<sigma> \\<and> ?x \\<le> progress \\<pi>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>.\n        \\<lbrakk>prefix_of \\<pi> \\<sigma>; i < progress \\<pi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: less_eq_Suc_le)"], ["proof (state)\nthis:\n  prefix_of \\<pi> \\<sigma>\n  i < progress \\<pi>\n\ngoal (5 subgoals):\n 1. \\<And>\\<sigma> v i.\n       sat \\<sigma> v i \\<Longrightarrow>\n       \\<exists>\\<pi>.\n          prefix_of \\<pi> \\<sigma> \\<and>\n          (\\<forall>\\<sigma>'.\n              prefix_of \\<pi> \\<sigma>' \\<longrightarrow> sat \\<sigma>' v i)\n 2. \\<And>\\<pi> \\<pi>'.\n       \\<pi> \\<le> \\<pi>' \\<Longrightarrow> M \\<pi> \\<subseteq> M \\<pi>'\n 3. \\<And>i v \\<pi>.\n       (i, v) \\<in> M \\<pi> \\<Longrightarrow> wf_tuple nfv fv v\n 4. \\<And>i v \\<pi> \\<sigma>.\n       \\<lbrakk>(i, v) \\<in> M \\<pi>; prefix_of \\<pi> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> sat \\<sigma> (map the v) i\n 5. \\<And>\\<pi> \\<sigma> v i.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; wf_tuple nfv fv v;\n        \\<And>\\<sigma>.\n           prefix_of \\<pi> \\<sigma> \\<Longrightarrow>\n           sat \\<sigma> (map the v) i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<pi>'.\n                            prefix_of \\<pi>' \\<sigma> \\<and>\n                            (i, v) \\<in> M \\<pi>'", "ultimately"], ["proof (chain)\npicking this:\n  sat \\<sigma> v i\n  prefix_of \\<pi> \\<sigma>\n  i < progress \\<pi>", "have \"sat \\<sigma>' v i\" if \"prefix_of \\<pi> \\<sigma>'\" for \\<sigma>'"], ["proof (prove)\nusing this:\n  sat \\<sigma> v i\n  prefix_of \\<pi> \\<sigma>\n  i < progress \\<pi>\n\ngoal (1 subgoal):\n 1. sat \\<sigma>' v i", "using that"], ["proof (prove)\nusing this:\n  sat \\<sigma> v i\n  prefix_of \\<pi> \\<sigma>\n  i < progress \\<pi>\n  prefix_of \\<pi> \\<sigma>'\n\ngoal (1 subgoal):\n 1. sat \\<sigma>' v i", "by (simp cong: progress_sat_cong)"], ["proof (state)\nthis:\n  prefix_of \\<pi> ?\\<sigma>' \\<Longrightarrow> sat ?\\<sigma>' v i\n\ngoal (5 subgoals):\n 1. \\<And>\\<sigma> v i.\n       sat \\<sigma> v i \\<Longrightarrow>\n       \\<exists>\\<pi>.\n          prefix_of \\<pi> \\<sigma> \\<and>\n          (\\<forall>\\<sigma>'.\n              prefix_of \\<pi> \\<sigma>' \\<longrightarrow> sat \\<sigma>' v i)\n 2. \\<And>\\<pi> \\<pi>'.\n       \\<pi> \\<le> \\<pi>' \\<Longrightarrow> M \\<pi> \\<subseteq> M \\<pi>'\n 3. \\<And>i v \\<pi>.\n       (i, v) \\<in> M \\<pi> \\<Longrightarrow> wf_tuple nfv fv v\n 4. \\<And>i v \\<pi> \\<sigma>.\n       \\<lbrakk>(i, v) \\<in> M \\<pi>; prefix_of \\<pi> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> sat \\<sigma> (map the v) i\n 5. \\<And>\\<pi> \\<sigma> v i.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; wf_tuple nfv fv v;\n        \\<And>\\<sigma>.\n           prefix_of \\<pi> \\<sigma> \\<Longrightarrow>\n           sat \\<sigma> (map the v) i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<pi>'.\n                            prefix_of \\<pi>' \\<sigma> \\<and>\n                            (i, v) \\<in> M \\<pi>'", "with *"], ["proof (chain)\npicking this:\n  prefix_of \\<pi> \\<sigma>\n  i < progress \\<pi>\n  prefix_of \\<pi> ?\\<sigma>' \\<Longrightarrow> sat ?\\<sigma>' v i", "show \"\\<exists>\\<pi>. prefix_of \\<pi> \\<sigma> \\<and> (\\<forall>\\<sigma>'. prefix_of \\<pi> \\<sigma>' \\<longrightarrow> sat \\<sigma>' v i)\""], ["proof (prove)\nusing this:\n  prefix_of \\<pi> \\<sigma>\n  i < progress \\<pi>\n  prefix_of \\<pi> ?\\<sigma>' \\<Longrightarrow> sat ?\\<sigma>' v i\n\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>.\n       prefix_of \\<pi> \\<sigma> \\<and>\n       (\\<forall>\\<sigma>'.\n           prefix_of \\<pi> \\<sigma>' \\<longrightarrow> sat \\<sigma>' v i)", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<pi>.\n     prefix_of \\<pi> \\<sigma> \\<and>\n     (\\<forall>\\<sigma>'.\n         prefix_of \\<pi> \\<sigma>' \\<longrightarrow> sat \\<sigma>' v i)\n\ngoal (4 subgoals):\n 1. \\<And>\\<pi> \\<pi>'.\n       \\<pi> \\<le> \\<pi>' \\<Longrightarrow> M \\<pi> \\<subseteq> M \\<pi>'\n 2. \\<And>i v \\<pi>.\n       (i, v) \\<in> M \\<pi> \\<Longrightarrow> wf_tuple nfv fv v\n 3. \\<And>i v \\<pi> \\<sigma>.\n       \\<lbrakk>(i, v) \\<in> M \\<pi>; prefix_of \\<pi> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> sat \\<sigma> (map the v) i\n 4. \\<And>\\<pi> \\<sigma> v i.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; wf_tuple nfv fv v;\n        \\<And>\\<sigma>.\n           prefix_of \\<pi> \\<sigma> \\<Longrightarrow>\n           sat \\<sigma> (map the v) i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<pi>'.\n                            prefix_of \\<pi>' \\<sigma> \\<and>\n                            (i, v) \\<in> M \\<pi>'", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<pi> \\<pi>'.\n       \\<pi> \\<le> \\<pi>' \\<Longrightarrow> M \\<pi> \\<subseteq> M \\<pi>'\n 2. \\<And>i v \\<pi>.\n       (i, v) \\<in> M \\<pi> \\<Longrightarrow> wf_tuple nfv fv v\n 3. \\<And>i v \\<pi> \\<sigma>.\n       \\<lbrakk>(i, v) \\<in> M \\<pi>; prefix_of \\<pi> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> sat \\<sigma> (map the v) i\n 4. \\<And>\\<pi> \\<sigma> v i.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; wf_tuple nfv fv v;\n        \\<And>\\<sigma>.\n           prefix_of \\<pi> \\<sigma> \\<Longrightarrow>\n           sat \\<sigma> (map the v) i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<pi>'.\n                            prefix_of \\<pi>' \\<sigma> \\<and>\n                            (i, v) \\<in> M \\<pi>'", "fix \\<pi> \\<pi>' :: \"'a prefix\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<pi> \\<pi>'.\n       \\<pi> \\<le> \\<pi>' \\<Longrightarrow> M \\<pi> \\<subseteq> M \\<pi>'\n 2. \\<And>i v \\<pi>.\n       (i, v) \\<in> M \\<pi> \\<Longrightarrow> wf_tuple nfv fv v\n 3. \\<And>i v \\<pi> \\<sigma>.\n       \\<lbrakk>(i, v) \\<in> M \\<pi>; prefix_of \\<pi> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> sat \\<sigma> (map the v) i\n 4. \\<And>\\<pi> \\<sigma> v i.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; wf_tuple nfv fv v;\n        \\<And>\\<sigma>.\n           prefix_of \\<pi> \\<sigma> \\<Longrightarrow>\n           sat \\<sigma> (map the v) i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<pi>'.\n                            prefix_of \\<pi>' \\<sigma> \\<and>\n                            (i, v) \\<in> M \\<pi>'", "assume \"\\<pi> \\<le> \\<pi>'\""], ["proof (state)\nthis:\n  \\<pi> \\<le> \\<pi>'\n\ngoal (4 subgoals):\n 1. \\<And>\\<pi> \\<pi>'.\n       \\<pi> \\<le> \\<pi>' \\<Longrightarrow> M \\<pi> \\<subseteq> M \\<pi>'\n 2. \\<And>i v \\<pi>.\n       (i, v) \\<in> M \\<pi> \\<Longrightarrow> wf_tuple nfv fv v\n 3. \\<And>i v \\<pi> \\<sigma>.\n       \\<lbrakk>(i, v) \\<in> M \\<pi>; prefix_of \\<pi> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> sat \\<sigma> (map the v) i\n 4. \\<And>\\<pi> \\<sigma> v i.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; wf_tuple nfv fv v;\n        \\<And>\\<sigma>.\n           prefix_of \\<pi> \\<sigma> \\<Longrightarrow>\n           sat \\<sigma> (map the v) i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<pi>'.\n                            prefix_of \\<pi>' \\<sigma> \\<and>\n                            (i, v) \\<in> M \\<pi>'", "then"], ["proof (chain)\npicking this:\n  \\<pi> \\<le> \\<pi>'", "show \"M \\<pi> \\<subseteq> M \\<pi>'\""], ["proof (prove)\nusing this:\n  \\<pi> \\<le> \\<pi>'\n\ngoal (1 subgoal):\n 1. M \\<pi> \\<subseteq> M \\<pi>'", "by (auto simp: M_def intro: progress_mono prefix_of_antimono\n        elim: order.strict_trans2)"], ["proof (state)\nthis:\n  M \\<pi> \\<subseteq> M \\<pi>'\n\ngoal (3 subgoals):\n 1. \\<And>i v \\<pi>.\n       (i, v) \\<in> M \\<pi> \\<Longrightarrow> wf_tuple nfv fv v\n 2. \\<And>i v \\<pi> \\<sigma>.\n       \\<lbrakk>(i, v) \\<in> M \\<pi>; prefix_of \\<pi> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> sat \\<sigma> (map the v) i\n 3. \\<And>\\<pi> \\<sigma> v i.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; wf_tuple nfv fv v;\n        \\<And>\\<sigma>.\n           prefix_of \\<pi> \\<sigma> \\<Longrightarrow>\n           sat \\<sigma> (map the v) i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<pi>'.\n                            prefix_of \\<pi>' \\<sigma> \\<and>\n                            (i, v) \\<in> M \\<pi>'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i v \\<pi>.\n       (i, v) \\<in> M \\<pi> \\<Longrightarrow> wf_tuple nfv fv v\n 2. \\<And>i v \\<pi> \\<sigma>.\n       \\<lbrakk>(i, v) \\<in> M \\<pi>; prefix_of \\<pi> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> sat \\<sigma> (map the v) i\n 3. \\<And>\\<pi> \\<sigma> v i.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; wf_tuple nfv fv v;\n        \\<And>\\<sigma>.\n           prefix_of \\<pi> \\<sigma> \\<Longrightarrow>\n           sat \\<sigma> (map the v) i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<pi>'.\n                            prefix_of \\<pi>' \\<sigma> \\<and>\n                            (i, v) \\<in> M \\<pi>'", "fix i v \\<pi> and \\<sigma> :: \"'a trace\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i v \\<pi>.\n       (i, v) \\<in> M \\<pi> \\<Longrightarrow> wf_tuple nfv fv v\n 2. \\<And>i v \\<pi> \\<sigma>.\n       \\<lbrakk>(i, v) \\<in> M \\<pi>; prefix_of \\<pi> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> sat \\<sigma> (map the v) i\n 3. \\<And>\\<pi> \\<sigma> v i.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; wf_tuple nfv fv v;\n        \\<And>\\<sigma>.\n           prefix_of \\<pi> \\<sigma> \\<Longrightarrow>\n           sat \\<sigma> (map the v) i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<pi>'.\n                            prefix_of \\<pi>' \\<sigma> \\<and>\n                            (i, v) \\<in> M \\<pi>'", "assume *: \"(i, v) \\<in> M \\<pi>\""], ["proof (state)\nthis:\n  (i, v) \\<in> M \\<pi>\n\ngoal (3 subgoals):\n 1. \\<And>i v \\<pi>.\n       (i, v) \\<in> M \\<pi> \\<Longrightarrow> wf_tuple nfv fv v\n 2. \\<And>i v \\<pi> \\<sigma>.\n       \\<lbrakk>(i, v) \\<in> M \\<pi>; prefix_of \\<pi> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> sat \\<sigma> (map the v) i\n 3. \\<And>\\<pi> \\<sigma> v i.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; wf_tuple nfv fv v;\n        \\<And>\\<sigma>.\n           prefix_of \\<pi> \\<sigma> \\<Longrightarrow>\n           sat \\<sigma> (map the v) i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<pi>'.\n                            prefix_of \\<pi>' \\<sigma> \\<and>\n                            (i, v) \\<in> M \\<pi>'", "then"], ["proof (chain)\npicking this:\n  (i, v) \\<in> M \\<pi>", "show \"wf_tuple nfv fv v\""], ["proof (prove)\nusing this:\n  (i, v) \\<in> M \\<pi>\n\ngoal (1 subgoal):\n 1. wf_tuple nfv fv v", "by (simp add: M_def)"], ["proof (state)\nthis:\n  wf_tuple nfv fv v\n\ngoal (2 subgoals):\n 1. \\<And>i v \\<pi> \\<sigma>.\n       \\<lbrakk>(i, v) \\<in> M \\<pi>; prefix_of \\<pi> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> sat \\<sigma> (map the v) i\n 2. \\<And>\\<pi> \\<sigma> v i.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; wf_tuple nfv fv v;\n        \\<And>\\<sigma>.\n           prefix_of \\<pi> \\<sigma> \\<Longrightarrow>\n           sat \\<sigma> (map the v) i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<pi>'.\n                            prefix_of \\<pi>' \\<sigma> \\<and>\n                            (i, v) \\<in> M \\<pi>'", "assume \"prefix_of \\<pi> \\<sigma>\""], ["proof (state)\nthis:\n  prefix_of \\<pi> \\<sigma>\n\ngoal (2 subgoals):\n 1. \\<And>i v \\<pi> \\<sigma>.\n       \\<lbrakk>(i, v) \\<in> M \\<pi>; prefix_of \\<pi> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> sat \\<sigma> (map the v) i\n 2. \\<And>\\<pi> \\<sigma> v i.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; wf_tuple nfv fv v;\n        \\<And>\\<sigma>.\n           prefix_of \\<pi> \\<sigma> \\<Longrightarrow>\n           sat \\<sigma> (map the v) i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<pi>'.\n                            prefix_of \\<pi>' \\<sigma> \\<and>\n                            (i, v) \\<in> M \\<pi>'", "with *"], ["proof (chain)\npicking this:\n  (i, v) \\<in> M \\<pi>\n  prefix_of \\<pi> \\<sigma>", "show \"sat \\<sigma> (map the v) i\""], ["proof (prove)\nusing this:\n  (i, v) \\<in> M \\<pi>\n  prefix_of \\<pi> \\<sigma>\n\ngoal (1 subgoal):\n 1. sat \\<sigma> (map the v) i", "by (simp add: M_def)"], ["proof (state)\nthis:\n  sat \\<sigma> (map the v) i\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi> \\<sigma> v i.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; wf_tuple nfv fv v;\n        \\<And>\\<sigma>.\n           prefix_of \\<pi> \\<sigma> \\<Longrightarrow>\n           sat \\<sigma> (map the v) i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<pi>'.\n                            prefix_of \\<pi>' \\<sigma> \\<and>\n                            (i, v) \\<in> M \\<pi>'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi> \\<sigma> v i.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; wf_tuple nfv fv v;\n        \\<And>\\<sigma>.\n           prefix_of \\<pi> \\<sigma> \\<Longrightarrow>\n           sat \\<sigma> (map the v) i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<pi>'.\n                            prefix_of \\<pi>' \\<sigma> \\<and>\n                            (i, v) \\<in> M \\<pi>'", "fix i v \\<pi> and \\<sigma> :: \"'a trace\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi> \\<sigma> v i.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; wf_tuple nfv fv v;\n        \\<And>\\<sigma>.\n           prefix_of \\<pi> \\<sigma> \\<Longrightarrow>\n           sat \\<sigma> (map the v) i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<pi>'.\n                            prefix_of \\<pi>' \\<sigma> \\<and>\n                            (i, v) \\<in> M \\<pi>'", "assume *: \"prefix_of \\<pi> \\<sigma>\" \"wf_tuple nfv fv v\" \"\\<And>\\<sigma>'. prefix_of \\<pi> \\<sigma>' \\<Longrightarrow> sat \\<sigma>' (map the v) i\""], ["proof (state)\nthis:\n  prefix_of \\<pi> \\<sigma>\n  wf_tuple nfv fv v\n  prefix_of \\<pi> ?\\<sigma>' \\<Longrightarrow> sat ?\\<sigma>' (map the v) i\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi> \\<sigma> v i.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; wf_tuple nfv fv v;\n        \\<And>\\<sigma>.\n           prefix_of \\<pi> \\<sigma> \\<Longrightarrow>\n           sat \\<sigma> (map the v) i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<pi>'.\n                            prefix_of \\<pi>' \\<sigma> \\<and>\n                            (i, v) \\<in> M \\<pi>'", "show \"\\<exists>\\<pi>'. prefix_of \\<pi>' \\<sigma> \\<and> (i, v) \\<in> M \\<pi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>'. prefix_of \\<pi>' \\<sigma> \\<and> (i, v) \\<in> M \\<pi>'", "proof (cases \"i < progress \\<pi>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < progress \\<pi> \\<Longrightarrow>\n    \\<exists>\\<pi>'. prefix_of \\<pi>' \\<sigma> \\<and> (i, v) \\<in> M \\<pi>'\n 2. \\<not> i < progress \\<pi> \\<Longrightarrow>\n    \\<exists>\\<pi>'. prefix_of \\<pi>' \\<sigma> \\<and> (i, v) \\<in> M \\<pi>'", "case True"], ["proof (state)\nthis:\n  i < progress \\<pi>\n\ngoal (2 subgoals):\n 1. i < progress \\<pi> \\<Longrightarrow>\n    \\<exists>\\<pi>'. prefix_of \\<pi>' \\<sigma> \\<and> (i, v) \\<in> M \\<pi>'\n 2. \\<not> i < progress \\<pi> \\<Longrightarrow>\n    \\<exists>\\<pi>'. prefix_of \\<pi>' \\<sigma> \\<and> (i, v) \\<in> M \\<pi>'", "with *"], ["proof (chain)\npicking this:\n  prefix_of \\<pi> \\<sigma>\n  wf_tuple nfv fv v\n  prefix_of \\<pi> ?\\<sigma>' \\<Longrightarrow> sat ?\\<sigma>' (map the v) i\n  i < progress \\<pi>", "show ?thesis"], ["proof (prove)\nusing this:\n  prefix_of \\<pi> \\<sigma>\n  wf_tuple nfv fv v\n  prefix_of \\<pi> ?\\<sigma>' \\<Longrightarrow> sat ?\\<sigma>' (map the v) i\n  i < progress \\<pi>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>'. prefix_of \\<pi>' \\<sigma> \\<and> (i, v) \\<in> M \\<pi>'", "by (auto simp: M_def)"], ["proof (state)\nthis:\n  \\<exists>\\<pi>'. prefix_of \\<pi>' \\<sigma> \\<and> (i, v) \\<in> M \\<pi>'\n\ngoal (1 subgoal):\n 1. \\<not> i < progress \\<pi> \\<Longrightarrow>\n    \\<exists>\\<pi>'. prefix_of \\<pi>' \\<sigma> \\<and> (i, v) \\<in> M \\<pi>'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < progress \\<pi> \\<Longrightarrow>\n    \\<exists>\\<pi>'. prefix_of \\<pi>' \\<sigma> \\<and> (i, v) \\<in> M \\<pi>'", "case False"], ["proof (state)\nthis:\n  \\<not> i < progress \\<pi>\n\ngoal (1 subgoal):\n 1. \\<not> i < progress \\<pi> \\<Longrightarrow>\n    \\<exists>\\<pi>'. prefix_of \\<pi>' \\<sigma> \\<and> (i, v) \\<in> M \\<pi>'", "obtain \\<pi>' where **: \"prefix_of \\<pi>' \\<sigma> \\<and> i < progress \\<pi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>'.\n        prefix_of \\<pi>' \\<sigma> \\<and>\n        i < progress \\<pi>' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ex_progress_ge"], ["proof (prove)\nusing this:\n  \\<exists>\\<pi>. prefix_of \\<pi> ?\\<sigma> \\<and> ?x \\<le> progress \\<pi>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>'.\n        prefix_of \\<pi>' \\<sigma> \\<and>\n        i < progress \\<pi>' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: less_eq_Suc_le)"], ["proof (state)\nthis:\n  prefix_of \\<pi>' \\<sigma> \\<and> i < progress \\<pi>'\n\ngoal (1 subgoal):\n 1. \\<not> i < progress \\<pi> \\<Longrightarrow>\n    \\<exists>\\<pi>'. prefix_of \\<pi>' \\<sigma> \\<and> (i, v) \\<in> M \\<pi>'", "then"], ["proof (chain)\npicking this:\n  prefix_of \\<pi>' \\<sigma> \\<and> i < progress \\<pi>'", "have \"\\<pi> \\<le> \\<pi>'\""], ["proof (prove)\nusing this:\n  prefix_of \\<pi>' \\<sigma> \\<and> i < progress \\<pi>'\n\ngoal (1 subgoal):\n 1. \\<pi> \\<le> \\<pi>'", "using \\<open>prefix_of \\<pi> \\<sigma>\\<close> prefix_of_imp_linear False progress_mono"], ["proof (prove)\nusing this:\n  prefix_of \\<pi>' \\<sigma> \\<and> i < progress \\<pi>'\n  prefix_of \\<pi> \\<sigma>\n  \\<lbrakk>prefix_of ?\\<pi> ?\\<sigma>; prefix_of ?\\<pi>' ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> ?\\<pi> \\<le> ?\\<pi>' \\<or> ?\\<pi>' \\<le> ?\\<pi>\n  \\<not> i < progress \\<pi>\n  ?\\<pi> \\<le> ?\\<pi>' \\<Longrightarrow>\n  progress ?\\<pi> \\<le> progress ?\\<pi>'\n\ngoal (1 subgoal):\n 1. \\<pi> \\<le> \\<pi>'", "by (blast intro: order.strict_trans2)"], ["proof (state)\nthis:\n  \\<pi> \\<le> \\<pi>'\n\ngoal (1 subgoal):\n 1. \\<not> i < progress \\<pi> \\<Longrightarrow>\n    \\<exists>\\<pi>'. prefix_of \\<pi>' \\<sigma> \\<and> (i, v) \\<in> M \\<pi>'", "with * **"], ["proof (chain)\npicking this:\n  prefix_of \\<pi> \\<sigma>\n  wf_tuple nfv fv v\n  prefix_of \\<pi> ?\\<sigma>' \\<Longrightarrow> sat ?\\<sigma>' (map the v) i\n  prefix_of \\<pi>' \\<sigma> \\<and> i < progress \\<pi>'\n  \\<pi> \\<le> \\<pi>'", "show ?thesis"], ["proof (prove)\nusing this:\n  prefix_of \\<pi> \\<sigma>\n  wf_tuple nfv fv v\n  prefix_of \\<pi> ?\\<sigma>' \\<Longrightarrow> sat ?\\<sigma>' (map the v) i\n  prefix_of \\<pi>' \\<sigma> \\<and> i < progress \\<pi>'\n  \\<pi> \\<le> \\<pi>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>'. prefix_of \\<pi>' \\<sigma> \\<and> (i, v) \\<in> M \\<pi>'", "by (auto simp: M_def intro: prefix_of_antimono)"], ["proof (state)\nthis:\n  \\<exists>\\<pi>'. prefix_of \\<pi>' \\<sigma> \\<and> (i, v) \\<in> M \\<pi>'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>\\<pi>'. prefix_of \\<pi>' \\<sigma> \\<and> (i, v) \\<in> M \\<pi>'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Slicing\\<close>"], ["", "text \\<open>Sliceable specifications can be evaluated meaningfully on a subset of events.\\<close>"], ["", "locale abstract_slicer =\n  fixes relevant_events :: \"'b list set \\<Rightarrow> 'a set\"\nbegin"], ["", "abbreviation slice :: \"'b list set \\<Rightarrow> 'a trace \\<Rightarrow> 'a trace\" where\n  \"slice S \\<equiv> map_\\<Gamma> (\\<lambda>D. D \\<inter> relevant_events S)\""], ["", "abbreviation pslice :: \"'b list set \\<Rightarrow> 'a prefix \\<Rightarrow> 'a prefix\" where\n  \"pslice S \\<equiv> pmap_\\<Gamma> (\\<lambda>D. D \\<inter> relevant_events S)\""], ["", "lemma prefix_of_psliceI: \"prefix_of \\<pi> \\<sigma> \\<Longrightarrow> prefix_of (pslice S \\<pi>) (slice S \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_of \\<pi> \\<sigma> \\<Longrightarrow>\n    prefix_of (pslice S \\<pi>) (slice S \\<sigma>)", "by (transfer fixing: S) auto"], ["", "lemma plen_pslice[simp]: \"plen (pslice S \\<pi>) = plen \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plen (pslice S \\<pi>) = plen \\<pi>", "by (transfer fixing: S) simp"], ["", "lemma pslice_pnil[simp]: \"pslice S pnil = pnil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pslice S pnil = pnil", "by (transfer fixing: S) simp"], ["", "lemma last_ts_pslice[simp]: \"last_ts (pslice S \\<pi>) = last_ts \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last_ts (pslice S \\<pi>) = last_ts \\<pi>", "by (transfer fixing: S) (simp add: last_map case_prod_beta split: list.split)"], ["", "abbreviation verdict_filter :: \"'b list set \\<Rightarrow> (nat \\<times> 'b tuple) set \\<Rightarrow> (nat \\<times> 'b tuple) set\" where\n  \"verdict_filter S V \\<equiv> {(i, v) \\<in> V. mem_restr S v}\""], ["", "end"], ["", "locale sliceable_fo_spec = fo_spec _ _ sat + abstract_slicer relevant_events\n  for relevant_events :: \"'b list set \\<Rightarrow> 'a set\" and sat :: \"'a trace \\<Rightarrow> 'b list \\<Rightarrow> nat \\<Rightarrow> bool\" +\n  assumes sliceable: \"v \\<in> S \\<Longrightarrow> sat (slice S \\<sigma>) v i \\<longleftrightarrow> sat \\<sigma> v i\"\nbegin"], ["", "lemma union_verdicts_slice:\n  assumes part: \"\\<Union>\\<S> = UNIV\"\n  shows \"\\<Union>((\\<lambda>S. verdict_filter S (verdicts (slice S \\<sigma>))) ` \\<S>) = verdicts \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>S\\<in>\\<S>. verdict_filter S (verdicts (slice S \\<sigma>))) =\n    verdicts \\<sigma>", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b S.\n       \\<lbrakk>S \\<in> \\<S>; (a, b) \\<in> verdicts (slice S \\<sigma>);\n        mem_restr S b\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> verdicts \\<sigma>\n 2. \\<And>a b.\n       (a, b) \\<in> verdicts \\<sigma> \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>S\\<in>\\<S>.\n                 verdict_filter S (verdicts (slice S \\<sigma>)))", "fix S i and v :: \"'b tuple\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b S.\n       \\<lbrakk>S \\<in> \\<S>; (a, b) \\<in> verdicts (slice S \\<sigma>);\n        mem_restr S b\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> verdicts \\<sigma>\n 2. \\<And>a b.\n       (a, b) \\<in> verdicts \\<sigma> \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>S\\<in>\\<S>.\n                 verdict_filter S (verdicts (slice S \\<sigma>)))", "assume \"(i, v) \\<in> verdicts (slice S \\<sigma>)\""], ["proof (state)\nthis:\n  (i, v) \\<in> verdicts (slice S \\<sigma>)\n\ngoal (2 subgoals):\n 1. \\<And>a b S.\n       \\<lbrakk>S \\<in> \\<S>; (a, b) \\<in> verdicts (slice S \\<sigma>);\n        mem_restr S b\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> verdicts \\<sigma>\n 2. \\<And>a b.\n       (a, b) \\<in> verdicts \\<sigma> \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>S\\<in>\\<S>.\n                 verdict_filter S (verdicts (slice S \\<sigma>)))", "then"], ["proof (chain)\npicking this:\n  (i, v) \\<in> verdicts (slice S \\<sigma>)", "have tuple: \"wf_tuple nfv fv v\" and \"sat (slice S \\<sigma>) (map the v) i\""], ["proof (prove)\nusing this:\n  (i, v) \\<in> verdicts (slice S \\<sigma>)\n\ngoal (1 subgoal):\n 1. wf_tuple nfv fv v &&& sat (slice S \\<sigma>) (map the v) i", "by (auto simp: verdicts_def)"], ["proof (state)\nthis:\n  wf_tuple nfv fv v\n  sat (slice S \\<sigma>) (map the v) i\n\ngoal (2 subgoals):\n 1. \\<And>a b S.\n       \\<lbrakk>S \\<in> \\<S>; (a, b) \\<in> verdicts (slice S \\<sigma>);\n        mem_restr S b\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> verdicts \\<sigma>\n 2. \\<And>a b.\n       (a, b) \\<in> verdicts \\<sigma> \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>S\\<in>\\<S>.\n                 verdict_filter S (verdicts (slice S \\<sigma>)))", "assume \"mem_restr S v\""], ["proof (state)\nthis:\n  mem_restr S v\n\ngoal (2 subgoals):\n 1. \\<And>a b S.\n       \\<lbrakk>S \\<in> \\<S>; (a, b) \\<in> verdicts (slice S \\<sigma>);\n        mem_restr S b\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> verdicts \\<sigma>\n 2. \\<And>a b.\n       (a, b) \\<in> verdicts \\<sigma> \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>S\\<in>\\<S>.\n                 verdict_filter S (verdicts (slice S \\<sigma>)))", "then"], ["proof (chain)\npicking this:\n  mem_restr S v", "obtain v' where \"v' \\<in> S\" and 1: \"\\<forall>i\\<in>fv. v ! i = Some (v' ! i)\""], ["proof (prove)\nusing this:\n  mem_restr S v\n\ngoal (1 subgoal):\n 1. (\\<And>v'.\n        \\<lbrakk>v' \\<in> S;\n         \\<forall>i\\<in>fv. v ! i = Some (v' ! i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using tuple"], ["proof (prove)\nusing this:\n  mem_restr S v\n  wf_tuple nfv fv v\n\ngoal (1 subgoal):\n 1. (\\<And>v'.\n        \\<lbrakk>v' \\<in> S;\n         \\<forall>i\\<in>fv. v ! i = Some (v' ! i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: fv_less_nfv elim: mem_restrE)"], ["proof (state)\nthis:\n  v' \\<in> S\n  \\<forall>i\\<in>fv. v ! i = Some (v' ! i)\n\ngoal (2 subgoals):\n 1. \\<And>a b S.\n       \\<lbrakk>S \\<in> \\<S>; (a, b) \\<in> verdicts (slice S \\<sigma>);\n        mem_restr S b\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> verdicts \\<sigma>\n 2. \\<And>a b.\n       (a, b) \\<in> verdicts \\<sigma> \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>S\\<in>\\<S>.\n                 verdict_filter S (verdicts (slice S \\<sigma>)))", "then"], ["proof (chain)\npicking this:\n  v' \\<in> S\n  \\<forall>i\\<in>fv. v ! i = Some (v' ! i)", "have \"sat (slice S \\<sigma>) v' i\""], ["proof (prove)\nusing this:\n  v' \\<in> S\n  \\<forall>i\\<in>fv. v ! i = Some (v' ! i)\n\ngoal (1 subgoal):\n 1. sat (slice S \\<sigma>) v' i", "using \\<open>sat (slice S \\<sigma>) (map the v) i\\<close> tuple"], ["proof (prove)\nusing this:\n  v' \\<in> S\n  \\<forall>i\\<in>fv. v ! i = Some (v' ! i)\n  sat (slice S \\<sigma>) (map the v) i\n  wf_tuple nfv fv v\n\ngoal (1 subgoal):\n 1. sat (slice S \\<sigma>) v' i", "by (auto simp: wf_tuple_length fv_less_nfv cong: sat_fv_cong)"], ["proof (state)\nthis:\n  sat (slice S \\<sigma>) v' i\n\ngoal (2 subgoals):\n 1. \\<And>a b S.\n       \\<lbrakk>S \\<in> \\<S>; (a, b) \\<in> verdicts (slice S \\<sigma>);\n        mem_restr S b\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> verdicts \\<sigma>\n 2. \\<And>a b.\n       (a, b) \\<in> verdicts \\<sigma> \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>S\\<in>\\<S>.\n                 verdict_filter S (verdicts (slice S \\<sigma>)))", "then"], ["proof (chain)\npicking this:\n  sat (slice S \\<sigma>) v' i", "have \"sat \\<sigma> v' i\""], ["proof (prove)\nusing this:\n  sat (slice S \\<sigma>) v' i\n\ngoal (1 subgoal):\n 1. sat \\<sigma> v' i", "using sliceable[OF \\<open>v' \\<in> S\\<close>]"], ["proof (prove)\nusing this:\n  sat (slice S \\<sigma>) v' i\n  sat (slice S ?\\<sigma>) v' ?i = sat ?\\<sigma> v' ?i\n\ngoal (1 subgoal):\n 1. sat \\<sigma> v' i", "by simp"], ["proof (state)\nthis:\n  sat \\<sigma> v' i\n\ngoal (2 subgoals):\n 1. \\<And>a b S.\n       \\<lbrakk>S \\<in> \\<S>; (a, b) \\<in> verdicts (slice S \\<sigma>);\n        mem_restr S b\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> verdicts \\<sigma>\n 2. \\<And>a b.\n       (a, b) \\<in> verdicts \\<sigma> \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>S\\<in>\\<S>.\n                 verdict_filter S (verdicts (slice S \\<sigma>)))", "then"], ["proof (chain)\npicking this:\n  sat \\<sigma> v' i", "have \"sat \\<sigma> (map the v) i\""], ["proof (prove)\nusing this:\n  sat \\<sigma> v' i\n\ngoal (1 subgoal):\n 1. sat \\<sigma> (map the v) i", "using tuple 1"], ["proof (prove)\nusing this:\n  sat \\<sigma> v' i\n  wf_tuple nfv fv v\n  \\<forall>i\\<in>fv. v ! i = Some (v' ! i)\n\ngoal (1 subgoal):\n 1. sat \\<sigma> (map the v) i", "by (auto simp: wf_tuple_length fv_less_nfv cong: sat_fv_cong)"], ["proof (state)\nthis:\n  sat \\<sigma> (map the v) i\n\ngoal (2 subgoals):\n 1. \\<And>a b S.\n       \\<lbrakk>S \\<in> \\<S>; (a, b) \\<in> verdicts (slice S \\<sigma>);\n        mem_restr S b\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> verdicts \\<sigma>\n 2. \\<And>a b.\n       (a, b) \\<in> verdicts \\<sigma> \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>S\\<in>\\<S>.\n                 verdict_filter S (verdicts (slice S \\<sigma>)))", "then"], ["proof (chain)\npicking this:\n  sat \\<sigma> (map the v) i", "show \"(i, v) \\<in> verdicts \\<sigma>\""], ["proof (prove)\nusing this:\n  sat \\<sigma> (map the v) i\n\ngoal (1 subgoal):\n 1. (i, v) \\<in> verdicts \\<sigma>", "using tuple"], ["proof (prove)\nusing this:\n  sat \\<sigma> (map the v) i\n  wf_tuple nfv fv v\n\ngoal (1 subgoal):\n 1. (i, v) \\<in> verdicts \\<sigma>", "by (simp add: verdicts_def)"], ["proof (state)\nthis:\n  (i, v) \\<in> verdicts \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> verdicts \\<sigma> \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>S\\<in>\\<S>.\n                 verdict_filter S (verdicts (slice S \\<sigma>)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> verdicts \\<sigma> \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>S\\<in>\\<S>.\n                 verdict_filter S (verdicts (slice S \\<sigma>)))", "fix i and v :: \"'b tuple\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> verdicts \\<sigma> \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>S\\<in>\\<S>.\n                 verdict_filter S (verdicts (slice S \\<sigma>)))", "assume \"(i, v) \\<in> verdicts \\<sigma>\""], ["proof (state)\nthis:\n  (i, v) \\<in> verdicts \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> verdicts \\<sigma> \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>S\\<in>\\<S>.\n                 verdict_filter S (verdicts (slice S \\<sigma>)))", "then"], ["proof (chain)\npicking this:\n  (i, v) \\<in> verdicts \\<sigma>", "have tuple: \"wf_tuple nfv fv v\" and \"sat \\<sigma> (map the v) i\""], ["proof (prove)\nusing this:\n  (i, v) \\<in> verdicts \\<sigma>\n\ngoal (1 subgoal):\n 1. wf_tuple nfv fv v &&& sat \\<sigma> (map the v) i", "by (auto simp: verdicts_def)"], ["proof (state)\nthis:\n  wf_tuple nfv fv v\n  sat \\<sigma> (map the v) i\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> verdicts \\<sigma> \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>S\\<in>\\<S>.\n                 verdict_filter S (verdicts (slice S \\<sigma>)))", "from part"], ["proof (chain)\npicking this:\n  \\<Union> \\<S> = UNIV", "obtain S where \"S \\<in> \\<S>\" and \"map the v \\<in> S\""], ["proof (prove)\nusing this:\n  \\<Union> \\<S> = UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>S \\<in> \\<S>; map the v \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  S \\<in> \\<S>\n  map the v \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> verdicts \\<sigma> \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>S\\<in>\\<S>.\n                 verdict_filter S (verdicts (slice S \\<sigma>)))", "then"], ["proof (chain)\npicking this:\n  S \\<in> \\<S>\n  map the v \\<in> S", "have \"mem_restr S v\""], ["proof (prove)\nusing this:\n  S \\<in> \\<S>\n  map the v \\<in> S\n\ngoal (1 subgoal):\n 1. mem_restr S v", "using mem_restrI[of \"map the v\" S nfv fv] tuple"], ["proof (prove)\nusing this:\n  S \\<in> \\<S>\n  map the v \\<in> S\n  \\<lbrakk>map the v \\<in> S; length (map the v) = nfv; wf_tuple nfv fv ?x;\n   \\<forall>i\\<in>fv. ?x ! i = Some (map the v ! i)\\<rbrakk>\n  \\<Longrightarrow> mem_restr S ?x\n  wf_tuple nfv fv v\n\ngoal (1 subgoal):\n 1. mem_restr S v", "by (auto simp: wf_tuple_def fv_less_nfv)"], ["proof (state)\nthis:\n  mem_restr S v\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> verdicts \\<sigma> \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>S\\<in>\\<S>.\n                 verdict_filter S (verdicts (slice S \\<sigma>)))", "moreover"], ["proof (state)\nthis:\n  mem_restr S v\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> verdicts \\<sigma> \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>S\\<in>\\<S>.\n                 verdict_filter S (verdicts (slice S \\<sigma>)))", "have \"sat (slice S \\<sigma>) (map the v) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sat (slice S \\<sigma>) (map the v) i", "using \\<open>sat \\<sigma> (map the v) i\\<close> sliceable[OF \\<open>map the v \\<in> S\\<close>]"], ["proof (prove)\nusing this:\n  sat \\<sigma> (map the v) i\n  sat (slice S ?\\<sigma>) (map the v) ?i = sat ?\\<sigma> (map the v) ?i\n\ngoal (1 subgoal):\n 1. sat (slice S \\<sigma>) (map the v) i", "by simp"], ["proof (state)\nthis:\n  sat (slice S \\<sigma>) (map the v) i\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> verdicts \\<sigma> \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>S\\<in>\\<S>.\n                 verdict_filter S (verdicts (slice S \\<sigma>)))", "then"], ["proof (chain)\npicking this:\n  sat (slice S \\<sigma>) (map the v) i", "have \"(i, v) \\<in> verdicts (slice S \\<sigma>)\""], ["proof (prove)\nusing this:\n  sat (slice S \\<sigma>) (map the v) i\n\ngoal (1 subgoal):\n 1. (i, v) \\<in> verdicts (slice S \\<sigma>)", "using tuple"], ["proof (prove)\nusing this:\n  sat (slice S \\<sigma>) (map the v) i\n  wf_tuple nfv fv v\n\ngoal (1 subgoal):\n 1. (i, v) \\<in> verdicts (slice S \\<sigma>)", "by (simp add: verdicts_def)"], ["proof (state)\nthis:\n  (i, v) \\<in> verdicts (slice S \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> verdicts \\<sigma> \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>S\\<in>\\<S>.\n                 verdict_filter S (verdicts (slice S \\<sigma>)))", "ultimately"], ["proof (chain)\npicking this:\n  mem_restr S v\n  (i, v) \\<in> verdicts (slice S \\<sigma>)", "show \"(i, v) \\<in> (\\<Union>S\\<in>\\<S>. verdict_filter S (verdicts (slice S \\<sigma>)))\""], ["proof (prove)\nusing this:\n  mem_restr S v\n  (i, v) \\<in> verdicts (slice S \\<sigma>)\n\ngoal (1 subgoal):\n 1. (i, v)\n    \\<in> (\\<Union>S\\<in>\\<S>.\n              verdict_filter S (verdicts (slice S \\<sigma>)))", "using \\<open>S \\<in> \\<S>\\<close>"], ["proof (prove)\nusing this:\n  mem_restr S v\n  (i, v) \\<in> verdicts (slice S \\<sigma>)\n  S \\<in> \\<S>\n\ngoal (1 subgoal):\n 1. (i, v)\n    \\<in> (\\<Union>S\\<in>\\<S>.\n              verdict_filter S (verdicts (slice S \\<sigma>)))", "by blast"], ["proof (state)\nthis:\n  (i, v)\n  \\<in> (\\<Union>S\\<in>\\<S>. verdict_filter S (verdicts (slice S \\<sigma>)))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>\n  We define a similar notion for monitors. It is potentially stronger because\n  the time-point at which verdicts are output must not change.\n\\<close>"], ["", "locale sliceable_monitor = monitor _ _ sat M + abstract_slicer relevant_events\n  for relevant_events :: \"'b list set \\<Rightarrow> 'a set\" and sat :: \"'a trace \\<Rightarrow> 'b list \\<Rightarrow> nat \\<Rightarrow> bool\" and M +\n  assumes sliceable_M: \"mem_restr S v \\<Longrightarrow> (i, v) \\<in> M (pslice S \\<pi>) \\<longleftrightarrow> (i, v) \\<in> M \\<pi>\"\nbegin"], ["", "lemma union_M_pslice:\n  assumes part: \"\\<Union>\\<S> = UNIV\"\n  shows \"\\<Union>((\\<lambda>S. verdict_filter S (M (pslice S \\<pi>))) ` \\<S>) = M \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>S\\<in>\\<S>. verdict_filter S (M (pslice S \\<pi>))) = M \\<pi>", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b S.\n       \\<lbrakk>S \\<in> \\<S>; (a, b) \\<in> M (pslice S \\<pi>);\n        mem_restr S b\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> M \\<pi>\n 2. \\<And>a b.\n       (a, b) \\<in> M \\<pi> \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>S\\<in>\\<S>. verdict_filter S (M (pslice S \\<pi>)))", "fix S i and v :: \"'b tuple\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b S.\n       \\<lbrakk>S \\<in> \\<S>; (a, b) \\<in> M (pslice S \\<pi>);\n        mem_restr S b\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> M \\<pi>\n 2. \\<And>a b.\n       (a, b) \\<in> M \\<pi> \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>S\\<in>\\<S>. verdict_filter S (M (pslice S \\<pi>)))", "assume \"mem_restr S v\" and \"(i, v) \\<in> M (pslice S \\<pi>)\""], ["proof (state)\nthis:\n  mem_restr S v\n  (i, v) \\<in> M (pslice S \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<And>a b S.\n       \\<lbrakk>S \\<in> \\<S>; (a, b) \\<in> M (pslice S \\<pi>);\n        mem_restr S b\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> M \\<pi>\n 2. \\<And>a b.\n       (a, b) \\<in> M \\<pi> \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>S\\<in>\\<S>. verdict_filter S (M (pslice S \\<pi>)))", "then"], ["proof (chain)\npicking this:\n  mem_restr S v\n  (i, v) \\<in> M (pslice S \\<pi>)", "show \"(i, v) \\<in> M \\<pi>\""], ["proof (prove)\nusing this:\n  mem_restr S v\n  (i, v) \\<in> M (pslice S \\<pi>)\n\ngoal (1 subgoal):\n 1. (i, v) \\<in> M \\<pi>", "using sliceable_M"], ["proof (prove)\nusing this:\n  mem_restr S v\n  (i, v) \\<in> M (pslice S \\<pi>)\n  mem_restr ?S ?v \\<Longrightarrow>\n  ((?i, ?v) \\<in> M (pslice ?S ?\\<pi>)) = ((?i, ?v) \\<in> M ?\\<pi>)\n\ngoal (1 subgoal):\n 1. (i, v) \\<in> M \\<pi>", "by blast"], ["proof (state)\nthis:\n  (i, v) \\<in> M \\<pi>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> M \\<pi> \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>S\\<in>\\<S>. verdict_filter S (M (pslice S \\<pi>)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> M \\<pi> \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>S\\<in>\\<S>. verdict_filter S (M (pslice S \\<pi>)))", "fix i and v :: \"'b tuple\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> M \\<pi> \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>S\\<in>\\<S>. verdict_filter S (M (pslice S \\<pi>)))", "assume \"(i, v) \\<in> M \\<pi>\""], ["proof (state)\nthis:\n  (i, v) \\<in> M \\<pi>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> M \\<pi> \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>S\\<in>\\<S>. verdict_filter S (M (pslice S \\<pi>)))", "then"], ["proof (chain)\npicking this:\n  (i, v) \\<in> M \\<pi>", "have tuple: \"wf_tuple nfv fv v\""], ["proof (prove)\nusing this:\n  (i, v) \\<in> M \\<pi>\n\ngoal (1 subgoal):\n 1. wf_tuple nfv fv v", "by (rule wf_monitor)"], ["proof (state)\nthis:\n  wf_tuple nfv fv v\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> M \\<pi> \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>S\\<in>\\<S>. verdict_filter S (M (pslice S \\<pi>)))", "from part"], ["proof (chain)\npicking this:\n  \\<Union> \\<S> = UNIV", "obtain S where \"S \\<in> \\<S>\" and \"map the v \\<in> S\""], ["proof (prove)\nusing this:\n  \\<Union> \\<S> = UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>S.\n        \\<lbrakk>S \\<in> \\<S>; map the v \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  S \\<in> \\<S>\n  map the v \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> M \\<pi> \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>S\\<in>\\<S>. verdict_filter S (M (pslice S \\<pi>)))", "then"], ["proof (chain)\npicking this:\n  S \\<in> \\<S>\n  map the v \\<in> S", "have \"mem_restr S v\""], ["proof (prove)\nusing this:\n  S \\<in> \\<S>\n  map the v \\<in> S\n\ngoal (1 subgoal):\n 1. mem_restr S v", "using mem_restrI[of \"map the v\" S nfv fv] tuple"], ["proof (prove)\nusing this:\n  S \\<in> \\<S>\n  map the v \\<in> S\n  \\<lbrakk>map the v \\<in> S; length (map the v) = nfv; wf_tuple nfv fv ?x;\n   \\<forall>i\\<in>fv. ?x ! i = Some (map the v ! i)\\<rbrakk>\n  \\<Longrightarrow> mem_restr S ?x\n  wf_tuple nfv fv v\n\ngoal (1 subgoal):\n 1. mem_restr S v", "by (auto simp: wf_tuple_def fv_less_nfv)"], ["proof (state)\nthis:\n  mem_restr S v\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> M \\<pi> \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>S\\<in>\\<S>. verdict_filter S (M (pslice S \\<pi>)))", "then"], ["proof (chain)\npicking this:\n  mem_restr S v", "have \"(i, v) \\<in> M (pslice S \\<pi>)\""], ["proof (prove)\nusing this:\n  mem_restr S v\n\ngoal (1 subgoal):\n 1. (i, v) \\<in> M (pslice S \\<pi>)", "using \\<open>(i, v) \\<in> M \\<pi>\\<close> sliceable_M"], ["proof (prove)\nusing this:\n  mem_restr S v\n  (i, v) \\<in> M \\<pi>\n  mem_restr ?S ?v \\<Longrightarrow>\n  ((?i, ?v) \\<in> M (pslice ?S ?\\<pi>)) = ((?i, ?v) \\<in> M ?\\<pi>)\n\ngoal (1 subgoal):\n 1. (i, v) \\<in> M (pslice S \\<pi>)", "by blast"], ["proof (state)\nthis:\n  (i, v) \\<in> M (pslice S \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> M \\<pi> \\<Longrightarrow>\n       (a, b)\n       \\<in> (\\<Union>S\\<in>\\<S>. verdict_filter S (M (pslice S \\<pi>)))", "then"], ["proof (chain)\npicking this:\n  (i, v) \\<in> M (pslice S \\<pi>)", "show \"(i, v) \\<in> (\\<Union>S\\<in>\\<S>. verdict_filter S (M (pslice S \\<pi>)))\""], ["proof (prove)\nusing this:\n  (i, v) \\<in> M (pslice S \\<pi>)\n\ngoal (1 subgoal):\n 1. (i, v) \\<in> (\\<Union>S\\<in>\\<S>. verdict_filter S (M (pslice S \\<pi>)))", "using \\<open>S \\<in> \\<S>\\<close> \\<open>mem_restr S v\\<close>"], ["proof (prove)\nusing this:\n  (i, v) \\<in> M (pslice S \\<pi>)\n  S \\<in> \\<S>\n  mem_restr S v\n\ngoal (1 subgoal):\n 1. (i, v) \\<in> (\\<Union>S\\<in>\\<S>. verdict_filter S (M (pslice S \\<pi>)))", "by blast"], ["proof (state)\nthis:\n  (i, v) \\<in> (\\<Union>S\\<in>\\<S>. verdict_filter S (M (pslice S \\<pi>)))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>\n  If the specification is sliceable and the monitor's progress depends only on\n  time-stamps, then also the monitor itself is sliceable.\n\\<close>"], ["", "locale timed_progress = progress +\n  assumes progress_time_conv: \"pts \\<pi> = pts \\<pi>' \\<Longrightarrow> progress \\<pi> = progress \\<pi>'\""], ["", "locale sliceable_timed_progress = sliceable_fo_spec + timed_progress\nbegin"], ["", "lemma progress_pslice[simp]: \"progress (pslice S \\<pi>) = progress \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. progress (pslice S \\<pi>) = progress \\<pi>", "by (simp cong: progress_time_conv)"], ["", "end"], ["", "sublocale sliceable_timed_progress \\<subseteq> sliceable_monitor _ _ _ _ M"], ["proof (prove)\ngoal (1 subgoal):\n 1. sliceable_monitor nfv fv relevant_events sat M", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S v i \\<pi>.\n       mem_restr S v \\<Longrightarrow>\n       ((i, v) \\<in> M (pslice S \\<pi>)) = ((i, v) \\<in> M \\<pi>)", "fix S :: \"'a list set\" and v i \\<pi>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S v i \\<pi>.\n       mem_restr S v \\<Longrightarrow>\n       ((i, v) \\<in> M (pslice S \\<pi>)) = ((i, v) \\<in> M \\<pi>)", "assume *: \"mem_restr S v\""], ["proof (state)\nthis:\n  mem_restr S v\n\ngoal (1 subgoal):\n 1. \\<And>S v i \\<pi>.\n       mem_restr S v \\<Longrightarrow>\n       ((i, v) \\<in> M (pslice S \\<pi>)) = ((i, v) \\<in> M \\<pi>)", "show \"(i, v) \\<in> M (pslice S \\<pi>) \\<longleftrightarrow> (i, v) \\<in> M \\<pi>\" (is \"?L \\<longleftrightarrow> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((i, v) \\<in> M (pslice S \\<pi>)) = ((i, v) \\<in> M \\<pi>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (i, v) \\<in> M (pslice S \\<pi>) \\<Longrightarrow> (i, v) \\<in> M \\<pi>\n 2. (i, v) \\<in> M \\<pi> \\<Longrightarrow> (i, v) \\<in> M (pslice S \\<pi>)", "assume ?L"], ["proof (state)\nthis:\n  (i, v) \\<in> M (pslice S \\<pi>)\n\ngoal (2 subgoals):\n 1. (i, v) \\<in> M (pslice S \\<pi>) \\<Longrightarrow> (i, v) \\<in> M \\<pi>\n 2. (i, v) \\<in> M \\<pi> \\<Longrightarrow> (i, v) \\<in> M (pslice S \\<pi>)", "with *"], ["proof (chain)\npicking this:\n  mem_restr S v\n  (i, v) \\<in> M (pslice S \\<pi>)", "show ?R"], ["proof (prove)\nusing this:\n  mem_restr S v\n  (i, v) \\<in> M (pslice S \\<pi>)\n\ngoal (1 subgoal):\n 1. (i, v) \\<in> M \\<pi>", "by (auto 0 4 simp: M_def wf_tuple_def elim!: mem_restrE\n          box_equals[OF sliceable sat_fv_cong sat_fv_cong, THEN iffD1, rotated -1]\n          intro: prefix_of_psliceI dest: fv_less_nfv spec[of _ \"slice S _\"])"], ["proof (state)\nthis:\n  (i, v) \\<in> M \\<pi>\n\ngoal (1 subgoal):\n 1. (i, v) \\<in> M \\<pi> \\<Longrightarrow> (i, v) \\<in> M (pslice S \\<pi>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (i, v) \\<in> M \\<pi> \\<Longrightarrow> (i, v) \\<in> M (pslice S \\<pi>)", "assume ?R"], ["proof (state)\nthis:\n  (i, v) \\<in> M \\<pi>\n\ngoal (1 subgoal):\n 1. (i, v) \\<in> M \\<pi> \\<Longrightarrow> (i, v) \\<in> M (pslice S \\<pi>)", "with *"], ["proof (chain)\npicking this:\n  mem_restr S v\n  (i, v) \\<in> M \\<pi>", "show ?L"], ["proof (prove)\nusing this:\n  mem_restr S v\n  (i, v) \\<in> M \\<pi>\n\ngoal (1 subgoal):\n 1. (i, v) \\<in> M (pslice S \\<pi>)", "by (auto 0 4 simp: M_alt wf_tuple_def elim!: mem_restrE\n        box_equals[OF sliceable sat_fv_cong sat_fv_cong, THEN iffD2, rotated -1]\n        intro: exI[of _ \"slice S _\"] prefix_of_psliceI dest: fv_less_nfv)"], ["proof (state)\nthis:\n  (i, v) \\<in> M (pslice S \\<pi>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((i, v) \\<in> M (pslice S \\<pi>)) = ((i, v) \\<in> M \\<pi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}