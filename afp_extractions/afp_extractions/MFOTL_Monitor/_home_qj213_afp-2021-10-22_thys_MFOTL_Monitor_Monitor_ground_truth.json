{"file_name": "/home/qj213/afp-2021-10-22/thys/MFOTL_Monitor/Monitor.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/MFOTL_Monitor", "problem_names": ["lemma plus_eq_enat_iff: \"a + b = enat i \\<longleftrightarrow> (\\<exists>j k. a = enat j \\<and> b = enat k \\<and> j + k = i)\"", "lemma minus_eq_enat_iff: \"a - enat k = enat i \\<longleftrightarrow> (\\<exists>j. a = enat j \\<and> j - k = i)\"", "lemma safe_formula_mmonitorable_exec: \"safe_formula \\<phi> \\<Longrightarrow> MFOTL.future_reach \\<phi> \\<noteq> \\<infinity> \\<Longrightarrow> mmonitorable_exec \\<phi>\"", "lemma mmonitorable_exec_mmonitorable: \"mmonitorable_exec \\<phi> \\<Longrightarrow> mmonitorable \\<phi>\"", "lemma monitorable_formula_code[code]: \"mmonitorable \\<phi> = mmonitorable_exec \\<phi>\"", "lemma mstep_alt: \"mstep tdb st =\n     (let (xs, m) = meval (mstate_n st) (snd tdb) (fst tdb) (mstate_m st)\n     in (\\<Union>(i, X) \\<in> set (List.enumerate (mstate_i st) xs). \\<Union>v \\<in> X. {(i,v)},\n      \\<lparr>mstate_i = mstate_i st + length xs, mstate_m = m, mstate_n = mstate_n st\\<rparr>))\"", "lemma progress_And[simp]: \"progress \\<sigma> (MFOTL.And \\<phi> \\<psi>) j = min (progress \\<sigma> \\<phi> j) (progress \\<sigma> \\<psi> j)\"", "lemma progress_And_Not[simp]: \"progress \\<sigma> (MFOTL.And_Not \\<phi> \\<psi>) j = min (progress \\<sigma> \\<phi> j) (progress \\<sigma> \\<psi> j)\"", "lemma progress_mono: \"j \\<le> j' \\<Longrightarrow> progress \\<sigma> \\<phi> j \\<le> progress \\<sigma> \\<phi> j'\"", "lemma progress_le: \"progress \\<sigma> \\<phi> j \\<le> j\"", "lemma progress_0[simp]: \"progress \\<sigma> \\<phi> 0 = 0\"", "lemma progress_ge: \"MFOTL.future_reach \\<phi> \\<noteq> \\<infinity> \\<Longrightarrow> \\<exists>j. i \\<le> progress \\<sigma> \\<phi> j\"", "lemma cInf_restrict_nat:\n  fixes x :: nat\n  assumes \"x \\<in> A\"\n  shows \"Inf A = Inf {y \\<in> A. y \\<le> x}\"", "lemma progress_time_conv:\n  assumes \"\\<forall>i<j. \\<tau> \\<sigma> i = \\<tau> \\<sigma>' i\"\n  shows \"progress \\<sigma> \\<phi> j = progress \\<sigma>' \\<phi> j\"", "lemma Inf_UNIV_nat: \"(Inf UNIV :: nat) = 0\"", "lemma progress_prefix_conv:\n  assumes \"prefix_of \\<pi> \\<sigma>\" and \"prefix_of \\<pi> \\<sigma>'\"\n  shows \"progress \\<sigma> \\<phi> (plen \\<pi>) = progress \\<sigma>' \\<phi> (plen \\<pi>)\"", "lemma sat_prefix_conv:\n  assumes \"prefix_of \\<pi> \\<sigma>\" and \"prefix_of \\<pi> \\<sigma>'\" and \"i < progress \\<sigma> \\<phi> (plen \\<pi>)\"\n  shows \"MFOTL.sat \\<sigma> v i \\<phi> \\<longleftrightarrow> MFOTL.sat \\<sigma>' v i \\<phi>\"", "lemma pprogress_eq: \"prefix_of \\<pi> \\<sigma> \\<Longrightarrow> pprogress \\<phi> \\<pi> = progress \\<sigma> \\<phi> (plen \\<pi>)\"", "lemma wf_mbuf2'_UNIV_alt: \"wf_mbuf2' \\<sigma> j n UNIV \\<phi> \\<psi> buf \\<longleftrightarrow> (case buf of (xs, ys) \\<Rightarrow>\n  list_all2 (\\<lambda>i. wf_table n (MFOTL.fv \\<phi>) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n    [min (progress \\<sigma> \\<phi> j) (progress \\<sigma> \\<psi> j) ..< (progress \\<sigma> \\<phi> j)] xs \\<and>\n  list_all2 (\\<lambda>i. wf_table n (MFOTL.fv \\<psi>) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n    [min (progress \\<sigma> \\<phi> j) (progress \\<sigma> \\<psi> j) ..< (progress \\<sigma> \\<psi> j)] ys)\"", "lemma qtable_mem_restr_UNIV: \"qtable n A (mem_restr UNIV) Q X = wf_table n A Q X\"", "lemma wf_since_aux_UNIV_alt:\n  \"wf_since_aux \\<sigma> n UNIV pos \\<phi> I \\<psi> aux ne \\<longleftrightarrow> sorted_wrt (\\<lambda>x y. fst x > fst y) aux \\<and>\n    (\\<forall>t X. (t, X) \\<in> set aux \\<longrightarrow> ne \\<noteq> 0 \\<and> t \\<le> \\<tau> \\<sigma> (ne-1) \\<and> \\<tau> \\<sigma> (ne-1) - t \\<le> right I \\<and> (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n      wf_table n (MFOTL.fv \\<psi>)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) (ne-1) (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (ne-1) - t)) \\<psi>)) X) \\<and>\n    (\\<forall>t. ne \\<noteq> 0 \\<and> t \\<le> \\<tau> \\<sigma> (ne-1) \\<and> \\<tau> \\<sigma> (ne-1) - t \\<le> right I \\<and> (\\<exists>i. \\<tau> \\<sigma> i = t) \\<longrightarrow>\n      (\\<exists>X. (t, X) \\<in> set aux))\"", "lemma wf_until_aux_UNIV_alt:\n  \"wf_until_aux \\<sigma> n UNIV pos \\<phi> I \\<psi> aux ne \\<longleftrightarrow> list_all2 (\\<lambda>x i. case x of (t, r1, r2) \\<Rightarrow> t = \\<tau> \\<sigma> i \\<and>\n      wf_table n (MFOTL.fv \\<phi>) (\\<lambda>v. if pos\n          then (\\<forall>k\\<in>{i..<ne+length aux}. MFOTL.sat \\<sigma> (map the v) k \\<phi>)\n          else (\\<exists>k\\<in>{i..<ne+length aux}. MFOTL.sat \\<sigma> (map the v) k \\<phi>)) r1 \\<and>\n      wf_table n (MFOTL.fv \\<psi>) (\\<lambda>v. \\<exists>j. i \\<le> j \\<and> j < ne + length aux \\<and> mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and>\n          MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n          (\\<forall>k\\<in>{i..<j}. if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi> else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>)) r2)\n    aux [ne..<ne+length aux]\"", "lemma minit0_And: \"\\<not> (safe_formula (MFOTL.Neg \\<psi>) \\<and> MFOTL.fv \\<psi> \\<subseteq> MFOTL.fv \\<phi>) \\<Longrightarrow>\n     minit0 n (MFOTL.And \\<phi> \\<psi>) = MAnd (minit0 n \\<phi>) True (minit0 n \\<psi>) ([], [])\"", "lemma minit0_And_Not: \"safe_formula \\<psi> \\<and> MFOTL.fv \\<psi> \\<subseteq> MFOTL.fv \\<phi> \\<Longrightarrow>\n  minit0 n (MFOTL.And_Not \\<phi> \\<psi>) = (MAnd (minit0 n \\<phi>) False (minit0 n \\<psi>) ([], []))\"", "lemma wf_mbuf2'_0: \"wf_mbuf2' \\<sigma> 0 n R \\<phi> \\<psi> ([], [])\"", "lemma wf_ts_0: \"wf_ts \\<sigma> 0 \\<phi> \\<psi> []\"", "lemma wf_since_aux_Nil: \"wf_since_aux \\<sigma> n R pos \\<phi>' I \\<psi>' [] 0\"", "lemma wf_until_aux_Nil: \"wf_until_aux \\<sigma> n R pos \\<phi>' I \\<psi>' [] 0\"", "lemma wf_minit0: \"safe_formula \\<phi> \\<Longrightarrow> \\<forall>x\\<in>MFOTL.fv \\<phi>. x < n \\<Longrightarrow>\n  wf_mformula \\<sigma> 0 n R (minit0 n \\<phi>) \\<phi>\"", "lemma wf_mstate_minit: \"safe_formula \\<phi> \\<Longrightarrow> wf_mstate \\<phi> pnil R (minit \\<phi>)\"", "lemma match_wf_tuple: \"Some f = match ts xs \\<Longrightarrow> wf_tuple n (\\<Union>t\\<in>set ts. MFOTL.fv_trm t) (tabulate f 0 n)\"", "lemma match_fvi_trm_None: \"Some f = match ts xs \\<Longrightarrow> \\<forall>t\\<in>set ts. x \\<notin> MFOTL.fv_trm t \\<Longrightarrow> f x = None\"", "lemma match_fvi_trm_Some: \"Some f = match ts xs \\<Longrightarrow> t \\<in> set ts \\<Longrightarrow> x \\<in> MFOTL.fv_trm t \\<Longrightarrow> f x \\<noteq> None\"", "lemma match_eval_trm: \"\\<forall>t\\<in>set ts. \\<forall>i\\<in>MFOTL.fv_trm t. i < n \\<Longrightarrow> Some f = match ts xs \\<Longrightarrow>\n    map (MFOTL.eval_trm (tabulate (\\<lambda>i. the (f i)) 0 n)) ts = xs\"", "lemma wf_tuple_tabulate_Some: \"wf_tuple n A (tabulate f 0 n) \\<Longrightarrow> x \\<in> A \\<Longrightarrow> x < n \\<Longrightarrow> \\<exists>y. f x = Some y\"", "lemma ex_match: \"wf_tuple n (\\<Union>t\\<in>set ts. MFOTL.fv_trm t) v \\<Longrightarrow> \\<forall>t\\<in>set ts. \\<forall>x\\<in>MFOTL.fv_trm t. x < n \\<Longrightarrow>\n    \\<exists>f. match ts (map (MFOTL.eval_trm (map the v)) ts) = Some f \\<and> v = tabulate f 0 n\"", "lemma eq_rel_eval_trm: \"v \\<in> eq_rel n t1 t2 \\<Longrightarrow> MFOTL.is_Const t1 \\<or> MFOTL.is_Const t2 \\<Longrightarrow>\n  \\<forall>x\\<in>MFOTL.fv_trm t1 \\<union> MFOTL.fv_trm t2. x < n \\<Longrightarrow>\n  MFOTL.eval_trm (map the v) t1 = MFOTL.eval_trm (map the v) t2\"", "lemma in_eq_rel: \"wf_tuple n (MFOTL.fv_trm t1 \\<union> MFOTL.fv_trm t2) v \\<Longrightarrow>\n  MFOTL.is_Const t1 \\<or> MFOTL.is_Const t2 \\<Longrightarrow>\n  MFOTL.eval_trm (map the v) t1 = MFOTL.eval_trm (map the v) t2 \\<Longrightarrow>\n  v \\<in> eq_rel n t1 t2\"", "lemma table_eq_rel: \"MFOTL.is_Const t1 \\<or> MFOTL.is_Const t2 \\<Longrightarrow>\n  table n (MFOTL.fv_trm t1 \\<union> MFOTL.fv_trm t2) (eq_rel n t1 t2)\"", "lemma wf_tuple_Suc_fviD: \"wf_tuple (Suc n) (MFOTL.fvi b \\<phi>) v \\<Longrightarrow> wf_tuple n (MFOTL.fvi (Suc b) \\<phi>) (tl v)\"", "lemma table_fvi_tl: \"table (Suc n) (MFOTL.fvi b \\<phi>) X \\<Longrightarrow> table n (MFOTL.fvi (Suc b) \\<phi>) (tl ` X)\"", "lemma wf_tuple_Suc_fvi_SomeI: \"0 \\<in> MFOTL.fvi b \\<phi> \\<Longrightarrow> wf_tuple n (MFOTL.fvi (Suc b) \\<phi>) v \\<Longrightarrow>\n  wf_tuple (Suc n) (MFOTL.fvi b \\<phi>) (Some x # v)\"", "lemma wf_tuple_Suc_fvi_NoneI: \"0 \\<notin> MFOTL.fvi b \\<phi> \\<Longrightarrow> wf_tuple n (MFOTL.fvi (Suc b) \\<phi>) v \\<Longrightarrow>\n  wf_tuple (Suc n) (MFOTL.fvi b \\<phi>) (None # v)\"", "lemma qtable_project_fv: \"qtable (Suc n) (fv \\<phi>) (mem_restr (lift_envs R)) P X \\<Longrightarrow>\n    qtable n (MFOTL.fvi (Suc 0) \\<phi>) (mem_restr R)\n      (\\<lambda>v. \\<exists>x. P ((if 0 \\<in> fv \\<phi> then Some x else None) # v)) (tl ` X)\"", "lemma mprev: \"mprev_next I xs ts = (ys, xs', ts') \\<Longrightarrow>\n  list_all2 P [i..<j'] xs \\<Longrightarrow> list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] ts \\<Longrightarrow> i \\<le> j' \\<Longrightarrow> i < j \\<Longrightarrow>\n  list_all2 (\\<lambda>i X. if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then P i X else X = empty_table)\n    [i..<min j' (j-1)] ys \\<and>\n  list_all2 P [min j' (j-1)..<j'] xs' \\<and>\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [min j' (j-1)..<j] ts'\"", "lemma mnext: \"mprev_next I xs ts = (ys, xs', ts') \\<Longrightarrow>\n  list_all2 P [Suc i..<j'] xs \\<Longrightarrow> list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] ts \\<Longrightarrow> Suc i \\<le> j' \\<Longrightarrow> i < j \\<Longrightarrow>\n  list_all2 (\\<lambda>i X. if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then P (Suc i) X else X = empty_table)\n    [i..<min (j'-1) (j-1)] ys \\<and>\n  list_all2 P [Suc (min (j'-1) (j-1))..<j'] xs' \\<and>\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [min (j'-1) (j-1)..<j] ts'\"", "lemma in_foldr_UnI: \"x \\<in> A \\<Longrightarrow> A \\<in> set xs \\<Longrightarrow> x \\<in> foldr (\\<union>) xs {}\"", "lemma in_foldr_UnE: \"x \\<in> foldr (\\<union>) xs {} \\<Longrightarrow> (\\<And>A. A \\<in> set xs \\<Longrightarrow> x \\<in> A \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma sat_the_restrict: \"fv \\<phi> \\<subseteq> A \\<Longrightarrow> MFOTL.sat \\<sigma> (map the (restrict A v)) i \\<phi> = MFOTL.sat \\<sigma> (map the v) i \\<phi>\"", "lemma update_since:\n  assumes pre: \"wf_since_aux \\<sigma> n R pos \\<phi> I \\<psi> aux ne\"\n    and qtable1: \"qtable n (MFOTL.fv \\<phi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) ne \\<phi>) rel1\"\n    and qtable2: \"qtable n (MFOTL.fv \\<psi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) ne \\<psi>) rel2\"\n    and result_eq: \"(rel, aux') = update_since I pos rel1 rel2 (\\<tau> \\<sigma> ne) aux\"\n    and fvi_subset: \"MFOTL.fv \\<phi> \\<subseteq> MFOTL.fv \\<psi>\"\n  shows \"wf_since_aux \\<sigma> n R pos \\<phi> I \\<psi> aux' (Suc ne)\"\n    and \"qtable n (MFOTL.fv \\<psi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>)) rel\"", "lemma length_update_until: \"length (update_until pos I rel1 rel2 nt aux) = Suc (length aux)\"", "lemma wf_update_until:\n  assumes pre: \"wf_until_aux \\<sigma> n R pos \\<phi> I \\<psi> aux ne\"\n    and qtable1: \"qtable n (MFOTL.fv \\<phi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) (ne + length aux) \\<phi>) rel1\"\n    and qtable2: \"qtable n (MFOTL.fv \\<psi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) (ne + length aux) \\<psi>) rel2\"\n    and fvi_subset: \"MFOTL.fv \\<phi> \\<subseteq> MFOTL.fv \\<psi>\"\n  shows \"wf_until_aux \\<sigma> n R pos \\<phi> I \\<psi> (update_until I pos rel1 rel2 (\\<tau> \\<sigma> (ne + length aux)) aux) ne\"", "lemma wf_until_aux_Cons: \"wf_until_aux \\<sigma> n R pos \\<phi> I \\<psi> (a # aux) ne \\<Longrightarrow>\n  wf_until_aux \\<sigma> n R pos \\<phi> I \\<psi> aux (Suc ne)\"", "lemma wf_until_aux_Cons1: \"wf_until_aux \\<sigma> n R pos \\<phi> I \\<psi> ((t, a1, a2) # aux) ne \\<Longrightarrow> t = \\<tau> \\<sigma> ne\"", "lemma wf_until_aux_Cons3: \"wf_until_aux \\<sigma> n R pos \\<phi> I \\<psi> ((t, a1, a2) # aux) ne \\<Longrightarrow>\n  qtable n (MFOTL.fv \\<psi>) (mem_restr R) (\\<lambda>v. (\\<exists>j. ne \\<le> j \\<and> j < Suc (ne + length aux) \\<and> mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> ne) I \\<and>\n    MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and> (\\<forall>k\\<in>{ne..<j}. if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi> else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))) a2\"", "lemma upt_append: \"a \\<le> b \\<Longrightarrow> b \\<le> c \\<Longrightarrow> [a..<b] @ [b..<c] = [a..<c]\"", "lemma wf_mbuf2_add:\n  assumes \"wf_mbuf2 i ja jb P Q buf\"\n    and \"list_all2 P [ja..<ja'] xs\"\n    and \"list_all2 Q [jb..<jb'] ys\"\n    and \"ja \\<le> ja'\" \"jb \\<le> jb'\"\n  shows \"wf_mbuf2 i ja' jb' P Q (mbuf2_add xs ys buf)\"", "lemma mbuf2_take_eqD:\n  assumes \"mbuf2_take f buf = (xs, buf')\"\n    and \"wf_mbuf2 i ja jb P Q buf\"\n  shows \"wf_mbuf2 (min ja jb) ja jb P Q buf'\"\n    and \"list_all2 (\\<lambda>i z. \\<exists>x y. P i x \\<and> Q i y \\<and> z = f x y) [i..<min ja jb] xs\"", "lemma mbuf2t_take_eqD:\n  assumes \"mbuf2t_take f z buf nts = (z', buf', nts')\"\n    and \"wf_mbuf2 i ja jb P Q buf\"\n    and \"list_all2 R [i..<j] nts\"\n    and \"ja \\<le> j\" \"jb \\<le> j\"\n  shows \"wf_mbuf2 (min ja jb) ja jb P Q buf'\"\n    and \"list_all2 R [min ja jb..<j] nts'\"", "lemma mbuf2t_take_induct[consumes 5, case_names base step]:\n  assumes \"mbuf2t_take f z buf nts = (z', buf', nts')\"\n    and \"wf_mbuf2 i ja jb P Q buf\"\n    and \"list_all2 R [i..<j] nts\"\n    and \"ja \\<le> j\" \"jb \\<le> j\"\n    and \"U i z\"\n    and \"\\<And>k x y t z. i \\<le> k \\<Longrightarrow> Suc k \\<le> ja \\<Longrightarrow> Suc k \\<le> jb \\<Longrightarrow>\n      P k x \\<Longrightarrow> Q k y \\<Longrightarrow> R k t \\<Longrightarrow> U k z \\<Longrightarrow> U (Suc k) (f x y t z)\"\n  shows \"U (min ja jb) z'\"", "lemma mbuf2_take_add':\n  assumes eq: \"mbuf2_take f (mbuf2_add xs ys buf) = (zs, buf')\"\n    and pre: \"wf_mbuf2' \\<sigma> j n R \\<phi> \\<psi> buf\"\n    and xs: \"list_all2 (\\<lambda>i. qtable n (MFOTL.fv \\<phi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n      [progress \\<sigma> \\<phi> j..<progress \\<sigma> \\<phi> j'] xs\"\n    and ys: \"list_all2 (\\<lambda>i. qtable n (MFOTL.fv \\<psi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n      [progress \\<sigma> \\<psi> j..<progress \\<sigma> \\<psi> j'] ys\"\n    and \"j \\<le> j'\"\n  shows \"wf_mbuf2' \\<sigma> j' n R \\<phi> \\<psi> buf'\"\n    and \"list_all2 (\\<lambda>i Z. \\<exists>X Y.\n      qtable n (MFOTL.fv \\<phi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>) X \\<and>\n      qtable n (MFOTL.fv \\<psi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>) Y \\<and>\n      Z = f X Y)\n      [min (progress \\<sigma> \\<phi> j) (progress \\<sigma> \\<psi> j)..<min (progress \\<sigma> \\<phi> j') (progress \\<sigma> \\<psi> j')] zs\"", "lemma mbuf2t_take_add':\n  assumes eq: \"mbuf2t_take f z (mbuf2_add xs ys buf) nts = (z', buf', nts')\"\n    and pre_buf: \"wf_mbuf2' \\<sigma> j n R \\<phi> \\<psi> buf\"\n    and pre_nts: \"list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [min (progress \\<sigma> \\<phi> j) (progress \\<sigma> \\<psi> j)..<j'] nts\"\n    and xs: \"list_all2 (\\<lambda>i. qtable n (MFOTL.fv \\<phi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n      [progress \\<sigma> \\<phi> j..<progress \\<sigma> \\<phi> j'] xs\"\n    and ys: \"list_all2 (\\<lambda>i. qtable n (MFOTL.fv \\<psi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n      [progress \\<sigma> \\<psi> j..<progress \\<sigma> \\<psi> j'] ys\"\n    and \"j \\<le> j'\"\n  shows \"wf_mbuf2' \\<sigma> j' n R \\<phi> \\<psi> buf'\"\n    and \"wf_ts \\<sigma> j' \\<phi> \\<psi> nts'\"", "lemma mbuf2t_take_add_induct'[consumes 6, case_names base step]:\n  assumes eq: \"mbuf2t_take f z (mbuf2_add xs ys buf) nts = (z', buf', nts')\"\n    and pre_buf: \"wf_mbuf2' \\<sigma> j n R \\<phi> \\<psi> buf\"\n    and pre_nts: \"list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [min (progress \\<sigma> \\<phi> j) (progress \\<sigma> \\<psi> j)..<j'] nts\"\n    and xs: \"list_all2 (\\<lambda>i. qtable n (MFOTL.fv \\<phi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n      [progress \\<sigma> \\<phi> j..<progress \\<sigma> \\<phi> j'] xs\"\n    and ys: \"list_all2 (\\<lambda>i. qtable n (MFOTL.fv \\<psi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n      [progress \\<sigma> \\<psi> j..<progress \\<sigma> \\<psi> j'] ys\"\n    and \"j \\<le> j'\"\n    and base: \"U (min (progress \\<sigma> \\<phi> j) (progress \\<sigma> \\<psi> j)) z\"\n    and step: \"\\<And>k X Y z. min (progress \\<sigma> \\<phi> j) (progress \\<sigma> \\<psi> j) \\<le> k \\<Longrightarrow>\n      Suc k \\<le> progress \\<sigma> \\<phi> j' \\<Longrightarrow> Suc k \\<le> progress \\<sigma> \\<psi> j' \\<Longrightarrow>\n      qtable n (MFOTL.fv \\<phi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<phi>) X \\<Longrightarrow>\n      qtable n (MFOTL.fv \\<psi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<psi>) Y \\<Longrightarrow>\n      U k z \\<Longrightarrow> U (Suc k) (f X Y (\\<tau> \\<sigma> k) z)\"\n  shows \"U (min (progress \\<sigma> \\<phi> j') (progress \\<sigma> \\<psi> j')) z'\"", "lemma progress_Until_le: \"progress \\<sigma> (formula.Until \\<phi> I \\<psi>) j \\<le> min (progress \\<sigma> \\<phi> j) (progress \\<sigma> \\<psi> j)\"", "lemma list_all2_upt_Cons: \"P a x \\<Longrightarrow> list_all2 P [Suc a..<b] xs \\<Longrightarrow> Suc a \\<le> b \\<Longrightarrow>\n  list_all2 P [a..<b] (x # xs)\"", "lemma list_all2_upt_append: \"list_all2 P [a..<b] xs \\<Longrightarrow> list_all2 P [b..<c] ys \\<Longrightarrow>\n  a \\<le> b \\<Longrightarrow> b \\<le> c \\<Longrightarrow> list_all2 P [a..<c] (xs @ ys)\"", "lemma meval:\n  assumes \"wf_mformula \\<sigma> j n R \\<phi> \\<phi>'\"\n  shows \"case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi> of (xs, \\<phi>\\<^sub>n) \\<Rightarrow> wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n    list_all2 (\\<lambda>i. qtable n (MFOTL.fv \\<phi>') (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n    [progress \\<sigma> \\<phi>' j..<progress \\<sigma> \\<phi>' (Suc j)] xs\"", "lemma wf_mstate_mstep: \"wf_mstate \\<phi> \\<pi> R st \\<Longrightarrow> last_ts \\<pi> \\<le> snd tdb \\<Longrightarrow>\n  wf_mstate \\<phi> (psnoc \\<pi> tdb) R (snd (mstep tdb st))\"", "lemma mstep_output_iff: \n  assumes \"wf_mstate \\<phi> \\<pi> R st\" \"last_ts \\<pi> \\<le> snd tdb\" \"prefix_of (psnoc \\<pi> tdb) \\<sigma>\" \"mem_restr R v\" \n  shows \"(i, v) \\<in> fst (mstep tdb st) \\<longleftrightarrow>\n    progress \\<sigma> \\<phi> (plen \\<pi>) \\<le> i \\<and> i < progress \\<sigma> \\<phi> (Suc (plen \\<pi>)) \\<and>\n    wf_tuple (MFOTL.nfv \\<phi>) (MFOTL.fv \\<phi>) v \\<and> MFOTL.sat \\<sigma> (map the v) i \\<phi>\"", "lemma minit_safe_minit: \"mmonitorable \\<phi> \\<Longrightarrow> minit_safe \\<phi> = minit \\<phi>\"", "lemma (in monitorable_mfotl) mstep_mverdicts:\n  assumes wf: \"wf_mstate \\<phi> \\<pi> R st\"\n    and le[simp]: \"last_ts \\<pi> \\<le> snd tdb\"\n    and restrict: \"mem_restr R v\"\n  shows \"(i, v) \\<in> fst (mstep tdb st) \\<longleftrightarrow> (i, v) \\<in> M (psnoc \\<pi> tdb) - M \\<pi>\"", "lemma msteps0_msteps0_stateless: \"fst (msteps0 w st) = msteps0_stateless w st\"", "lemma msteps_msteps_stateless: \"fst (msteps w st) = msteps_stateless w st\"", "lemma msteps0_snoc: \"msteps0 (\\<pi> @ [tdb]) st =\n   (let (V', st') = msteps0 \\<pi> st; (V'', st'') = mstep tdb st' in (V' \\<union> V'', st''))\"", "lemma msteps_psnoc: \"last_ts \\<pi> \\<le> snd tdb \\<Longrightarrow> msteps (psnoc \\<pi> tdb) st =\n   (let (V', st') = msteps \\<pi> st; (V'', st'') = mstep tdb st' in (V' \\<union> V'', st''))\"", "lemma Suc_length_conv_snoc: \"(Suc n = length xs) = (\\<exists>y ys. xs = ys @ [y] \\<and> length ys = n)\"", "lemma (in monitorable_mfotl) wf_mstate_msteps: \"wf_mstate \\<phi> \\<pi> R st \\<Longrightarrow> mem_restr R v \\<Longrightarrow> \\<pi> \\<le> \\<pi>' \\<Longrightarrow>\n  X = msteps (pdrop (plen \\<pi>) \\<pi>') st \\<Longrightarrow> wf_mstate \\<phi> \\<pi>' R (snd X) \\<and>\n  ((i, v) \\<in> fst X) = ((i, v) \\<in> M \\<pi>' - M \\<pi>)\"", "lemma (in monitorable_mfotl) wf_mstate_msteps_stateless:\n  assumes \"wf_mstate \\<phi> \\<pi> R st\" \"mem_restr R v\" \"\\<pi> \\<le> \\<pi>'\"\n  shows \"(i, v) \\<in> msteps_stateless (pdrop (plen \\<pi>) \\<pi>') st \\<longleftrightarrow> (i, v) \\<in> M \\<pi>' - M \\<pi>\"", "lemma (in monitorable_mfotl) wf_mstate_msteps_stateless_UNIV: \"wf_mstate \\<phi> \\<pi> UNIV st \\<Longrightarrow> \\<pi> \\<le> \\<pi>' \\<Longrightarrow>\n  msteps_stateless (pdrop (plen \\<pi>) \\<pi>') st = M \\<pi>' - M \\<pi>\"", "lemma (in monitorable_mfotl) mverdicts_Nil: \"M pnil = {}\"", "lemma wf_mstate_minit_safe: \"mmonitorable \\<phi> \\<Longrightarrow> wf_mstate \\<phi> pnil R (minit_safe \\<phi>)\"", "lemma (in monitorable_mfotl) monitor_mverdicts: \"monitor \\<phi> \\<pi> = M \\<pi>\""], "translations": [["", "lemma plus_eq_enat_iff: \"a + b = enat i \\<longleftrightarrow> (\\<exists>j k. a = enat j \\<and> b = enat k \\<and> j + k = i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a + b = enat i) =\n    (\\<exists>j k. a = enat j \\<and> b = enat k \\<and> j + k = i)", "by (cases a; cases b) auto"], ["", "lemma minus_eq_enat_iff: \"a - enat k = enat i \\<longleftrightarrow> (\\<exists>j. a = enat j \\<and> j - k = i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a - enat k = enat i) = (\\<exists>j. a = enat j \\<and> j - k = i)", "by (cases a) auto"], ["", "lemma safe_formula_mmonitorable_exec: \"safe_formula \\<phi> \\<Longrightarrow> MFOTL.future_reach \\<phi> \\<noteq> \\<infinity> \\<Longrightarrow> mmonitorable_exec \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>safe_formula \\<phi>;\n     MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> mmonitorable_exec \\<phi>", "proof (induct \\<phi> rule: safe_formula.induct)"], ["proof (state)\ngoal (28 subgoals):\n 1. \\<And>t1 t2.\n       \\<lbrakk>safe_formula (formula.Eq t1 t2);\n        MFOTL.future_reach (formula.Eq t1 t2) \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Eq t1 t2)\n 2. \\<And>x y.\n       \\<lbrakk>safe_formula\n                 (formula.Neg (formula.Eq (trm.Const x) (trm.Const y)));\n        MFOTL.future_reach\n         (formula.Neg (formula.Eq (trm.Const x) (trm.Const y))) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg\n                            (formula.Eq (trm.Const x) (trm.Const y)))\n 3. \\<And>x y.\n       \\<lbrakk>safe_formula\n                 (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)));\n        MFOTL.future_reach\n         (formula.Neg (formula.Eq (trm.Var x) (trm.Var y))) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)))\n 4. \\<And>e ts.\n       \\<lbrakk>safe_formula (formula.Pred e ts);\n        MFOTL.future_reach (formula.Pred e ts) \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Pred e ts)\n 5. \\<And>\\<phi> \\<psi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        \\<lbrakk>safe_formula \\<psi>;\n         MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec \\<psi>;\n        \\<And>x3.\n           \\<lbrakk>\\<psi> = formula.Neg x3; safe_formula x3;\n            MFOTL.future_reach x3 \\<noteq> \\<infinity>\\<rbrakk>\n           \\<Longrightarrow> mmonitorable_exec x3;\n        safe_formula (formula.Neg (formula.Or (formula.Neg \\<phi>) \\<psi>));\n        MFOTL.future_reach\n         (formula.Neg (formula.Or (formula.Neg \\<phi>) \\<psi>)) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg\n                            (formula.Or (formula.Neg \\<phi>) \\<psi>))\n 6. \\<And>\\<phi> \\<psi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        \\<lbrakk>safe_formula \\<psi>;\n         MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec \\<psi>;\n        safe_formula (formula.Or \\<phi> \\<psi>);\n        MFOTL.future_reach (formula.Or \\<phi> \\<psi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Or \\<phi> \\<psi>)\n 7. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Exists \\<phi>);\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Exists \\<phi>)\n 8. \\<And>I \\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Prev I \\<phi>);\n        MFOTL.future_reach (formula.Prev I \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Prev I \\<phi>)\n 9. \\<And>I \\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Next I \\<phi>);\n        MFOTL.future_reach (formula.Next I \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Next I \\<phi>)\n 10. \\<And>\\<phi> I \\<psi>.\n        \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                  MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                 \\<Longrightarrow> mmonitorable_exec \\<phi>;\n         \\<And>x3.\n            \\<lbrakk>\\<phi> = formula.Neg x3; safe_formula x3;\n             MFOTL.future_reach x3 \\<noteq> \\<infinity>\\<rbrakk>\n            \\<Longrightarrow> mmonitorable_exec x3;\n         \\<lbrakk>safe_formula \\<psi>;\n          MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n         \\<Longrightarrow> mmonitorable_exec \\<psi>;\n         safe_formula (formula.Since \\<phi> I \\<psi>);\n         MFOTL.future_reach (formula.Since \\<phi> I \\<psi>) \\<noteq>\n         \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec (formula.Since \\<phi> I \\<psi>)\nA total of 28 subgoals...", "case (5 \\<phi> \\<psi>)"], ["proof (state)\nthis:\n  \\<lbrakk>safe_formula \\<phi>;\n   MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<phi>\n  \\<lbrakk>safe_formula \\<psi>;\n   MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<psi>\n  \\<lbrakk>\\<psi> = formula.Neg ?x3.0; safe_formula ?x3.0;\n   MFOTL.future_reach ?x3.0 \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec ?x3.0\n  safe_formula (formula.Neg (formula.Or (formula.Neg \\<phi>) \\<psi>))\n  MFOTL.future_reach\n   (formula.Neg (formula.Or (formula.Neg \\<phi>) \\<psi>)) \\<noteq>\n  \\<infinity>\n\ngoal (28 subgoals):\n 1. \\<And>t1 t2.\n       \\<lbrakk>safe_formula (formula.Eq t1 t2);\n        MFOTL.future_reach (formula.Eq t1 t2) \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Eq t1 t2)\n 2. \\<And>x y.\n       \\<lbrakk>safe_formula\n                 (formula.Neg (formula.Eq (trm.Const x) (trm.Const y)));\n        MFOTL.future_reach\n         (formula.Neg (formula.Eq (trm.Const x) (trm.Const y))) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg\n                            (formula.Eq (trm.Const x) (trm.Const y)))\n 3. \\<And>x y.\n       \\<lbrakk>safe_formula\n                 (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)));\n        MFOTL.future_reach\n         (formula.Neg (formula.Eq (trm.Var x) (trm.Var y))) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)))\n 4. \\<And>e ts.\n       \\<lbrakk>safe_formula (formula.Pred e ts);\n        MFOTL.future_reach (formula.Pred e ts) \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Pred e ts)\n 5. \\<And>\\<phi> \\<psi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        \\<lbrakk>safe_formula \\<psi>;\n         MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec \\<psi>;\n        \\<And>x3.\n           \\<lbrakk>\\<psi> = formula.Neg x3; safe_formula x3;\n            MFOTL.future_reach x3 \\<noteq> \\<infinity>\\<rbrakk>\n           \\<Longrightarrow> mmonitorable_exec x3;\n        safe_formula (formula.Neg (formula.Or (formula.Neg \\<phi>) \\<psi>));\n        MFOTL.future_reach\n         (formula.Neg (formula.Or (formula.Neg \\<phi>) \\<psi>)) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg\n                            (formula.Or (formula.Neg \\<phi>) \\<psi>))\n 6. \\<And>\\<phi> \\<psi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        \\<lbrakk>safe_formula \\<psi>;\n         MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec \\<psi>;\n        safe_formula (formula.Or \\<phi> \\<psi>);\n        MFOTL.future_reach (formula.Or \\<phi> \\<psi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Or \\<phi> \\<psi>)\n 7. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Exists \\<phi>);\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Exists \\<phi>)\n 8. \\<And>I \\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Prev I \\<phi>);\n        MFOTL.future_reach (formula.Prev I \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Prev I \\<phi>)\n 9. \\<And>I \\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Next I \\<phi>);\n        MFOTL.future_reach (formula.Next I \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Next I \\<phi>)\n 10. \\<And>\\<phi> I \\<psi>.\n        \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                  MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                 \\<Longrightarrow> mmonitorable_exec \\<phi>;\n         \\<And>x3.\n            \\<lbrakk>\\<phi> = formula.Neg x3; safe_formula x3;\n             MFOTL.future_reach x3 \\<noteq> \\<infinity>\\<rbrakk>\n            \\<Longrightarrow> mmonitorable_exec x3;\n         \\<lbrakk>safe_formula \\<psi>;\n          MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n         \\<Longrightarrow> mmonitorable_exec \\<psi>;\n         safe_formula (formula.Since \\<phi> I \\<psi>);\n         MFOTL.future_reach (formula.Since \\<phi> I \\<psi>) \\<noteq>\n         \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec (formula.Since \\<phi> I \\<psi>)\nA total of 28 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>safe_formula \\<phi>;\n   MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<phi>\n  \\<lbrakk>safe_formula \\<psi>;\n   MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<psi>\n  \\<lbrakk>\\<psi> = formula.Neg ?x3.0; safe_formula ?x3.0;\n   MFOTL.future_reach ?x3.0 \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec ?x3.0\n  safe_formula (formula.Neg (formula.Or (formula.Neg \\<phi>) \\<psi>))\n  MFOTL.future_reach\n   (formula.Neg (formula.Or (formula.Neg \\<phi>) \\<psi>)) \\<noteq>\n  \\<infinity>", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>safe_formula \\<phi>;\n   MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<phi>\n  \\<lbrakk>safe_formula \\<psi>;\n   MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<psi>\n  \\<lbrakk>\\<psi> = formula.Neg ?x3.0; safe_formula ?x3.0;\n   MFOTL.future_reach ?x3.0 \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec ?x3.0\n  safe_formula (formula.Neg (formula.Or (formula.Neg \\<phi>) \\<psi>))\n  MFOTL.future_reach\n   (formula.Neg (formula.Or (formula.Neg \\<phi>) \\<psi>)) \\<noteq>\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. mmonitorable_exec (formula.Neg (formula.Or (formula.Neg \\<phi>) \\<psi>))", "unfolding safe_formula.simps future_reach.simps mmonitorable_exec.simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>safe_formula \\<phi>;\n   MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<phi>\n  \\<lbrakk>safe_formula \\<psi>;\n   MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<psi>\n  \\<lbrakk>\\<psi> = formula.Neg ?x3.0; safe_formula ?x3.0;\n   MFOTL.future_reach ?x3.0 \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec ?x3.0\n  safe_formula \\<phi> \\<and>\n  (safe_formula \\<psi> \\<and> fv \\<psi> \\<subseteq> fv \\<phi> \\<or>\n   (case \\<psi> of formula.Neg x \\<Rightarrow> safe_formula x\n    | _ \\<Rightarrow> False))\n  max (MFOTL.future_reach \\<phi>) (MFOTL.future_reach \\<psi>) \\<noteq>\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. mmonitorable_exec \\<phi> \\<and>\n    (mmonitorable_exec \\<psi> \\<and> fv \\<psi> \\<subseteq> fv \\<phi> \\<or>\n     (case \\<psi> of formula.Neg x \\<Rightarrow> mmonitorable_exec x\n      | _ \\<Rightarrow> False))", "by (fastforce split: formula.splits)"], ["proof (state)\nthis:\n  mmonitorable_exec (formula.Neg (formula.Or (formula.Neg \\<phi>) \\<psi>))\n\ngoal (27 subgoals):\n 1. \\<And>t1 t2.\n       \\<lbrakk>safe_formula (formula.Eq t1 t2);\n        MFOTL.future_reach (formula.Eq t1 t2) \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Eq t1 t2)\n 2. \\<And>x y.\n       \\<lbrakk>safe_formula\n                 (formula.Neg (formula.Eq (trm.Const x) (trm.Const y)));\n        MFOTL.future_reach\n         (formula.Neg (formula.Eq (trm.Const x) (trm.Const y))) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg\n                            (formula.Eq (trm.Const x) (trm.Const y)))\n 3. \\<And>x y.\n       \\<lbrakk>safe_formula\n                 (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)));\n        MFOTL.future_reach\n         (formula.Neg (formula.Eq (trm.Var x) (trm.Var y))) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)))\n 4. \\<And>e ts.\n       \\<lbrakk>safe_formula (formula.Pred e ts);\n        MFOTL.future_reach (formula.Pred e ts) \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Pred e ts)\n 5. \\<And>\\<phi> \\<psi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        \\<lbrakk>safe_formula \\<psi>;\n         MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec \\<psi>;\n        safe_formula (formula.Or \\<phi> \\<psi>);\n        MFOTL.future_reach (formula.Or \\<phi> \\<psi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Or \\<phi> \\<psi>)\n 6. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Exists \\<phi>);\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Exists \\<phi>)\n 7. \\<And>I \\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Prev I \\<phi>);\n        MFOTL.future_reach (formula.Prev I \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Prev I \\<phi>)\n 8. \\<And>I \\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Next I \\<phi>);\n        MFOTL.future_reach (formula.Next I \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Next I \\<phi>)\n 9. \\<And>\\<phi> I \\<psi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        \\<And>x3.\n           \\<lbrakk>\\<phi> = formula.Neg x3; safe_formula x3;\n            MFOTL.future_reach x3 \\<noteq> \\<infinity>\\<rbrakk>\n           \\<Longrightarrow> mmonitorable_exec x3;\n        \\<lbrakk>safe_formula \\<psi>;\n         MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec \\<psi>;\n        safe_formula (formula.Since \\<phi> I \\<psi>);\n        MFOTL.future_reach (formula.Since \\<phi> I \\<psi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Since \\<phi> I \\<psi>)\n 10. \\<And>\\<phi> I \\<psi>.\n        \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                  MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                 \\<Longrightarrow> mmonitorable_exec \\<phi>;\n         \\<And>x3.\n            \\<lbrakk>\\<phi> = formula.Neg x3; safe_formula x3;\n             MFOTL.future_reach x3 \\<noteq> \\<infinity>\\<rbrakk>\n            \\<Longrightarrow> mmonitorable_exec x3;\n         \\<lbrakk>safe_formula \\<psi>;\n          MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n         \\<Longrightarrow> mmonitorable_exec \\<psi>;\n         safe_formula (formula.Until \\<phi> I \\<psi>);\n         MFOTL.future_reach (formula.Until \\<phi> I \\<psi>) \\<noteq>\n         \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec (formula.Until \\<phi> I \\<psi>)\nA total of 27 subgoals...", "next"], ["proof (state)\ngoal (27 subgoals):\n 1. \\<And>t1 t2.\n       \\<lbrakk>safe_formula (formula.Eq t1 t2);\n        MFOTL.future_reach (formula.Eq t1 t2) \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Eq t1 t2)\n 2. \\<And>x y.\n       \\<lbrakk>safe_formula\n                 (formula.Neg (formula.Eq (trm.Const x) (trm.Const y)));\n        MFOTL.future_reach\n         (formula.Neg (formula.Eq (trm.Const x) (trm.Const y))) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg\n                            (formula.Eq (trm.Const x) (trm.Const y)))\n 3. \\<And>x y.\n       \\<lbrakk>safe_formula\n                 (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)));\n        MFOTL.future_reach\n         (formula.Neg (formula.Eq (trm.Var x) (trm.Var y))) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)))\n 4. \\<And>e ts.\n       \\<lbrakk>safe_formula (formula.Pred e ts);\n        MFOTL.future_reach (formula.Pred e ts) \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Pred e ts)\n 5. \\<And>\\<phi> \\<psi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        \\<lbrakk>safe_formula \\<psi>;\n         MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec \\<psi>;\n        safe_formula (formula.Or \\<phi> \\<psi>);\n        MFOTL.future_reach (formula.Or \\<phi> \\<psi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Or \\<phi> \\<psi>)\n 6. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Exists \\<phi>);\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Exists \\<phi>)\n 7. \\<And>I \\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Prev I \\<phi>);\n        MFOTL.future_reach (formula.Prev I \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Prev I \\<phi>)\n 8. \\<And>I \\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Next I \\<phi>);\n        MFOTL.future_reach (formula.Next I \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Next I \\<phi>)\n 9. \\<And>\\<phi> I \\<psi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        \\<And>x3.\n           \\<lbrakk>\\<phi> = formula.Neg x3; safe_formula x3;\n            MFOTL.future_reach x3 \\<noteq> \\<infinity>\\<rbrakk>\n           \\<Longrightarrow> mmonitorable_exec x3;\n        \\<lbrakk>safe_formula \\<psi>;\n         MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec \\<psi>;\n        safe_formula (formula.Since \\<phi> I \\<psi>);\n        MFOTL.future_reach (formula.Since \\<phi> I \\<psi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Since \\<phi> I \\<psi>)\n 10. \\<And>\\<phi> I \\<psi>.\n        \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                  MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                 \\<Longrightarrow> mmonitorable_exec \\<phi>;\n         \\<And>x3.\n            \\<lbrakk>\\<phi> = formula.Neg x3; safe_formula x3;\n             MFOTL.future_reach x3 \\<noteq> \\<infinity>\\<rbrakk>\n            \\<Longrightarrow> mmonitorable_exec x3;\n         \\<lbrakk>safe_formula \\<psi>;\n          MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n         \\<Longrightarrow> mmonitorable_exec \\<psi>;\n         safe_formula (formula.Until \\<phi> I \\<psi>);\n         MFOTL.future_reach (formula.Until \\<phi> I \\<psi>) \\<noteq>\n         \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec (formula.Until \\<phi> I \\<psi>)\nA total of 27 subgoals...", "case (6 \\<phi> \\<psi>)"], ["proof (state)\nthis:\n  \\<lbrakk>safe_formula \\<phi>;\n   MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<phi>\n  \\<lbrakk>safe_formula \\<psi>;\n   MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<psi>\n  safe_formula (formula.Or \\<phi> \\<psi>)\n  MFOTL.future_reach (formula.Or \\<phi> \\<psi>) \\<noteq> \\<infinity>\n\ngoal (27 subgoals):\n 1. \\<And>t1 t2.\n       \\<lbrakk>safe_formula (formula.Eq t1 t2);\n        MFOTL.future_reach (formula.Eq t1 t2) \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Eq t1 t2)\n 2. \\<And>x y.\n       \\<lbrakk>safe_formula\n                 (formula.Neg (formula.Eq (trm.Const x) (trm.Const y)));\n        MFOTL.future_reach\n         (formula.Neg (formula.Eq (trm.Const x) (trm.Const y))) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg\n                            (formula.Eq (trm.Const x) (trm.Const y)))\n 3. \\<And>x y.\n       \\<lbrakk>safe_formula\n                 (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)));\n        MFOTL.future_reach\n         (formula.Neg (formula.Eq (trm.Var x) (trm.Var y))) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)))\n 4. \\<And>e ts.\n       \\<lbrakk>safe_formula (formula.Pred e ts);\n        MFOTL.future_reach (formula.Pred e ts) \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Pred e ts)\n 5. \\<And>\\<phi> \\<psi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        \\<lbrakk>safe_formula \\<psi>;\n         MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec \\<psi>;\n        safe_formula (formula.Or \\<phi> \\<psi>);\n        MFOTL.future_reach (formula.Or \\<phi> \\<psi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Or \\<phi> \\<psi>)\n 6. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Exists \\<phi>);\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Exists \\<phi>)\n 7. \\<And>I \\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Prev I \\<phi>);\n        MFOTL.future_reach (formula.Prev I \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Prev I \\<phi>)\n 8. \\<And>I \\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Next I \\<phi>);\n        MFOTL.future_reach (formula.Next I \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Next I \\<phi>)\n 9. \\<And>\\<phi> I \\<psi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        \\<And>x3.\n           \\<lbrakk>\\<phi> = formula.Neg x3; safe_formula x3;\n            MFOTL.future_reach x3 \\<noteq> \\<infinity>\\<rbrakk>\n           \\<Longrightarrow> mmonitorable_exec x3;\n        \\<lbrakk>safe_formula \\<psi>;\n         MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec \\<psi>;\n        safe_formula (formula.Since \\<phi> I \\<psi>);\n        MFOTL.future_reach (formula.Since \\<phi> I \\<psi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Since \\<phi> I \\<psi>)\n 10. \\<And>\\<phi> I \\<psi>.\n        \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                  MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                 \\<Longrightarrow> mmonitorable_exec \\<phi>;\n         \\<And>x3.\n            \\<lbrakk>\\<phi> = formula.Neg x3; safe_formula x3;\n             MFOTL.future_reach x3 \\<noteq> \\<infinity>\\<rbrakk>\n            \\<Longrightarrow> mmonitorable_exec x3;\n         \\<lbrakk>safe_formula \\<psi>;\n          MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n         \\<Longrightarrow> mmonitorable_exec \\<psi>;\n         safe_formula (formula.Until \\<phi> I \\<psi>);\n         MFOTL.future_reach (formula.Until \\<phi> I \\<psi>) \\<noteq>\n         \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec (formula.Until \\<phi> I \\<psi>)\nA total of 27 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>safe_formula \\<phi>;\n   MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<phi>\n  \\<lbrakk>safe_formula \\<psi>;\n   MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<psi>\n  safe_formula (formula.Or \\<phi> \\<psi>)\n  MFOTL.future_reach (formula.Or \\<phi> \\<psi>) \\<noteq> \\<infinity>", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>safe_formula \\<phi>;\n   MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<phi>\n  \\<lbrakk>safe_formula \\<psi>;\n   MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<psi>\n  safe_formula (formula.Or \\<phi> \\<psi>)\n  MFOTL.future_reach (formula.Or \\<phi> \\<psi>) \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. mmonitorable_exec (formula.Or \\<phi> \\<psi>)", "unfolding safe_formula.simps future_reach.simps mmonitorable_exec.simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>safe_formula \\<phi>;\n   MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<phi>\n  \\<lbrakk>safe_formula \\<psi>;\n   MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<psi>\n  fv \\<psi> = fv \\<phi> \\<and>\n  safe_formula \\<phi> \\<and> safe_formula \\<psi>\n  max (MFOTL.future_reach \\<phi>) (MFOTL.future_reach \\<psi>) \\<noteq>\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. fv \\<psi> = fv \\<phi> \\<and>\n    mmonitorable_exec \\<phi> \\<and> mmonitorable_exec \\<psi>", "by (fastforce split: formula.splits)"], ["proof (state)\nthis:\n  mmonitorable_exec (formula.Or \\<phi> \\<psi>)\n\ngoal (26 subgoals):\n 1. \\<And>t1 t2.\n       \\<lbrakk>safe_formula (formula.Eq t1 t2);\n        MFOTL.future_reach (formula.Eq t1 t2) \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Eq t1 t2)\n 2. \\<And>x y.\n       \\<lbrakk>safe_formula\n                 (formula.Neg (formula.Eq (trm.Const x) (trm.Const y)));\n        MFOTL.future_reach\n         (formula.Neg (formula.Eq (trm.Const x) (trm.Const y))) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg\n                            (formula.Eq (trm.Const x) (trm.Const y)))\n 3. \\<And>x y.\n       \\<lbrakk>safe_formula\n                 (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)));\n        MFOTL.future_reach\n         (formula.Neg (formula.Eq (trm.Var x) (trm.Var y))) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)))\n 4. \\<And>e ts.\n       \\<lbrakk>safe_formula (formula.Pred e ts);\n        MFOTL.future_reach (formula.Pred e ts) \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Pred e ts)\n 5. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Exists \\<phi>);\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Exists \\<phi>)\n 6. \\<And>I \\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Prev I \\<phi>);\n        MFOTL.future_reach (formula.Prev I \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Prev I \\<phi>)\n 7. \\<And>I \\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Next I \\<phi>);\n        MFOTL.future_reach (formula.Next I \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Next I \\<phi>)\n 8. \\<And>\\<phi> I \\<psi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        \\<And>x3.\n           \\<lbrakk>\\<phi> = formula.Neg x3; safe_formula x3;\n            MFOTL.future_reach x3 \\<noteq> \\<infinity>\\<rbrakk>\n           \\<Longrightarrow> mmonitorable_exec x3;\n        \\<lbrakk>safe_formula \\<psi>;\n         MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec \\<psi>;\n        safe_formula (formula.Since \\<phi> I \\<psi>);\n        MFOTL.future_reach (formula.Since \\<phi> I \\<psi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Since \\<phi> I \\<psi>)\n 9. \\<And>\\<phi> I \\<psi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        \\<And>x3.\n           \\<lbrakk>\\<phi> = formula.Neg x3; safe_formula x3;\n            MFOTL.future_reach x3 \\<noteq> \\<infinity>\\<rbrakk>\n           \\<Longrightarrow> mmonitorable_exec x3;\n        \\<lbrakk>safe_formula \\<psi>;\n         MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec \\<psi>;\n        safe_formula (formula.Until \\<phi> I \\<psi>);\n        MFOTL.future_reach (formula.Until \\<phi> I \\<psi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Until \\<phi> I \\<psi>)\n 10. \\<And>va vb.\n        \\<lbrakk>safe_formula (formula.Neg (formula.Pred va vb));\n         MFOTL.future_reach (formula.Neg (formula.Pred va vb)) \\<noteq>\n         \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec\n                           (formula.Neg (formula.Pred va vb))\nA total of 26 subgoals...", "next"], ["proof (state)\ngoal (26 subgoals):\n 1. \\<And>t1 t2.\n       \\<lbrakk>safe_formula (formula.Eq t1 t2);\n        MFOTL.future_reach (formula.Eq t1 t2) \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Eq t1 t2)\n 2. \\<And>x y.\n       \\<lbrakk>safe_formula\n                 (formula.Neg (formula.Eq (trm.Const x) (trm.Const y)));\n        MFOTL.future_reach\n         (formula.Neg (formula.Eq (trm.Const x) (trm.Const y))) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg\n                            (formula.Eq (trm.Const x) (trm.Const y)))\n 3. \\<And>x y.\n       \\<lbrakk>safe_formula\n                 (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)));\n        MFOTL.future_reach\n         (formula.Neg (formula.Eq (trm.Var x) (trm.Var y))) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)))\n 4. \\<And>e ts.\n       \\<lbrakk>safe_formula (formula.Pred e ts);\n        MFOTL.future_reach (formula.Pred e ts) \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Pred e ts)\n 5. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Exists \\<phi>);\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Exists \\<phi>)\n 6. \\<And>I \\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Prev I \\<phi>);\n        MFOTL.future_reach (formula.Prev I \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Prev I \\<phi>)\n 7. \\<And>I \\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Next I \\<phi>);\n        MFOTL.future_reach (formula.Next I \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Next I \\<phi>)\n 8. \\<And>\\<phi> I \\<psi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        \\<And>x3.\n           \\<lbrakk>\\<phi> = formula.Neg x3; safe_formula x3;\n            MFOTL.future_reach x3 \\<noteq> \\<infinity>\\<rbrakk>\n           \\<Longrightarrow> mmonitorable_exec x3;\n        \\<lbrakk>safe_formula \\<psi>;\n         MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec \\<psi>;\n        safe_formula (formula.Since \\<phi> I \\<psi>);\n        MFOTL.future_reach (formula.Since \\<phi> I \\<psi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Since \\<phi> I \\<psi>)\n 9. \\<And>\\<phi> I \\<psi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        \\<And>x3.\n           \\<lbrakk>\\<phi> = formula.Neg x3; safe_formula x3;\n            MFOTL.future_reach x3 \\<noteq> \\<infinity>\\<rbrakk>\n           \\<Longrightarrow> mmonitorable_exec x3;\n        \\<lbrakk>safe_formula \\<psi>;\n         MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec \\<psi>;\n        safe_formula (formula.Until \\<phi> I \\<psi>);\n        MFOTL.future_reach (formula.Until \\<phi> I \\<psi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Until \\<phi> I \\<psi>)\n 10. \\<And>va vb.\n        \\<lbrakk>safe_formula (formula.Neg (formula.Pred va vb));\n         MFOTL.future_reach (formula.Neg (formula.Pred va vb)) \\<noteq>\n         \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec\n                           (formula.Neg (formula.Pred va vb))\nA total of 26 subgoals...", "case (10 \\<phi> I \\<psi>)"], ["proof (state)\nthis:\n  \\<lbrakk>safe_formula \\<phi>;\n   MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<phi>\n  \\<lbrakk>\\<phi> = formula.Neg ?x3.0; safe_formula ?x3.0;\n   MFOTL.future_reach ?x3.0 \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec ?x3.0\n  \\<lbrakk>safe_formula \\<psi>;\n   MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<psi>\n  safe_formula (formula.Since \\<phi> I \\<psi>)\n  MFOTL.future_reach (formula.Since \\<phi> I \\<psi>) \\<noteq> \\<infinity>\n\ngoal (26 subgoals):\n 1. \\<And>t1 t2.\n       \\<lbrakk>safe_formula (formula.Eq t1 t2);\n        MFOTL.future_reach (formula.Eq t1 t2) \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Eq t1 t2)\n 2. \\<And>x y.\n       \\<lbrakk>safe_formula\n                 (formula.Neg (formula.Eq (trm.Const x) (trm.Const y)));\n        MFOTL.future_reach\n         (formula.Neg (formula.Eq (trm.Const x) (trm.Const y))) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg\n                            (formula.Eq (trm.Const x) (trm.Const y)))\n 3. \\<And>x y.\n       \\<lbrakk>safe_formula\n                 (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)));\n        MFOTL.future_reach\n         (formula.Neg (formula.Eq (trm.Var x) (trm.Var y))) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)))\n 4. \\<And>e ts.\n       \\<lbrakk>safe_formula (formula.Pred e ts);\n        MFOTL.future_reach (formula.Pred e ts) \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Pred e ts)\n 5. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Exists \\<phi>);\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Exists \\<phi>)\n 6. \\<And>I \\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Prev I \\<phi>);\n        MFOTL.future_reach (formula.Prev I \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Prev I \\<phi>)\n 7. \\<And>I \\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Next I \\<phi>);\n        MFOTL.future_reach (formula.Next I \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Next I \\<phi>)\n 8. \\<And>\\<phi> I \\<psi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        \\<And>x3.\n           \\<lbrakk>\\<phi> = formula.Neg x3; safe_formula x3;\n            MFOTL.future_reach x3 \\<noteq> \\<infinity>\\<rbrakk>\n           \\<Longrightarrow> mmonitorable_exec x3;\n        \\<lbrakk>safe_formula \\<psi>;\n         MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec \\<psi>;\n        safe_formula (formula.Since \\<phi> I \\<psi>);\n        MFOTL.future_reach (formula.Since \\<phi> I \\<psi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Since \\<phi> I \\<psi>)\n 9. \\<And>\\<phi> I \\<psi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        \\<And>x3.\n           \\<lbrakk>\\<phi> = formula.Neg x3; safe_formula x3;\n            MFOTL.future_reach x3 \\<noteq> \\<infinity>\\<rbrakk>\n           \\<Longrightarrow> mmonitorable_exec x3;\n        \\<lbrakk>safe_formula \\<psi>;\n         MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec \\<psi>;\n        safe_formula (formula.Until \\<phi> I \\<psi>);\n        MFOTL.future_reach (formula.Until \\<phi> I \\<psi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Until \\<phi> I \\<psi>)\n 10. \\<And>va vb.\n        \\<lbrakk>safe_formula (formula.Neg (formula.Pred va vb));\n         MFOTL.future_reach (formula.Neg (formula.Pred va vb)) \\<noteq>\n         \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec\n                           (formula.Neg (formula.Pred va vb))\nA total of 26 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>safe_formula \\<phi>;\n   MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<phi>\n  \\<lbrakk>\\<phi> = formula.Neg ?x3.0; safe_formula ?x3.0;\n   MFOTL.future_reach ?x3.0 \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec ?x3.0\n  \\<lbrakk>safe_formula \\<psi>;\n   MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<psi>\n  safe_formula (formula.Since \\<phi> I \\<psi>)\n  MFOTL.future_reach (formula.Since \\<phi> I \\<psi>) \\<noteq> \\<infinity>", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>safe_formula \\<phi>;\n   MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<phi>\n  \\<lbrakk>\\<phi> = formula.Neg ?x3.0; safe_formula ?x3.0;\n   MFOTL.future_reach ?x3.0 \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec ?x3.0\n  \\<lbrakk>safe_formula \\<psi>;\n   MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<psi>\n  safe_formula (formula.Since \\<phi> I \\<psi>)\n  MFOTL.future_reach (formula.Since \\<phi> I \\<psi>) \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. mmonitorable_exec (formula.Since \\<phi> I \\<psi>)", "unfolding safe_formula.simps future_reach.simps mmonitorable_exec.simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>safe_formula \\<phi>;\n   MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<phi>\n  \\<lbrakk>\\<phi> = formula.Neg ?x3.0; safe_formula ?x3.0;\n   MFOTL.future_reach ?x3.0 \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec ?x3.0\n  \\<lbrakk>safe_formula \\<psi>;\n   MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<psi>\n  fv \\<phi> \\<subseteq> fv \\<psi> \\<and>\n  (safe_formula \\<phi> \\<or>\n   (case \\<phi> of formula.Neg x \\<Rightarrow> safe_formula x\n    | _ \\<Rightarrow> False)) \\<and>\n  safe_formula \\<psi>\n  max (MFOTL.future_reach \\<phi>)\n   (MFOTL.future_reach \\<psi> - enat (left I)) \\<noteq>\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. fv \\<phi> \\<subseteq> fv \\<psi> \\<and>\n    (mmonitorable_exec \\<phi> \\<or>\n     (case \\<phi> of formula.Neg x \\<Rightarrow> mmonitorable_exec x\n      | _ \\<Rightarrow> False)) \\<and>\n    mmonitorable_exec \\<psi>", "by (fastforce split: formula.splits)"], ["proof (state)\nthis:\n  mmonitorable_exec (formula.Since \\<phi> I \\<psi>)\n\ngoal (25 subgoals):\n 1. \\<And>t1 t2.\n       \\<lbrakk>safe_formula (formula.Eq t1 t2);\n        MFOTL.future_reach (formula.Eq t1 t2) \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Eq t1 t2)\n 2. \\<And>x y.\n       \\<lbrakk>safe_formula\n                 (formula.Neg (formula.Eq (trm.Const x) (trm.Const y)));\n        MFOTL.future_reach\n         (formula.Neg (formula.Eq (trm.Const x) (trm.Const y))) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg\n                            (formula.Eq (trm.Const x) (trm.Const y)))\n 3. \\<And>x y.\n       \\<lbrakk>safe_formula\n                 (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)));\n        MFOTL.future_reach\n         (formula.Neg (formula.Eq (trm.Var x) (trm.Var y))) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)))\n 4. \\<And>e ts.\n       \\<lbrakk>safe_formula (formula.Pred e ts);\n        MFOTL.future_reach (formula.Pred e ts) \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Pred e ts)\n 5. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Exists \\<phi>);\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Exists \\<phi>)\n 6. \\<And>I \\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Prev I \\<phi>);\n        MFOTL.future_reach (formula.Prev I \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Prev I \\<phi>)\n 7. \\<And>I \\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Next I \\<phi>);\n        MFOTL.future_reach (formula.Next I \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Next I \\<phi>)\n 8. \\<And>\\<phi> I \\<psi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        \\<And>x3.\n           \\<lbrakk>\\<phi> = formula.Neg x3; safe_formula x3;\n            MFOTL.future_reach x3 \\<noteq> \\<infinity>\\<rbrakk>\n           \\<Longrightarrow> mmonitorable_exec x3;\n        \\<lbrakk>safe_formula \\<psi>;\n         MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec \\<psi>;\n        safe_formula (formula.Until \\<phi> I \\<psi>);\n        MFOTL.future_reach (formula.Until \\<phi> I \\<psi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Until \\<phi> I \\<psi>)\n 9. \\<And>va vb.\n       \\<lbrakk>safe_formula (formula.Neg (formula.Pred va vb));\n        MFOTL.future_reach (formula.Neg (formula.Pred va vb)) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg (formula.Pred va vb))\n 10. \\<And>vc v.\n        \\<lbrakk>safe_formula\n                  (formula.Neg (formula.Eq (trm.Var vc) (trm.Const v)));\n         MFOTL.future_reach\n          (formula.Neg (formula.Eq (trm.Var vc) (trm.Const v))) \\<noteq>\n         \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec\n                           (formula.Neg\n                             (formula.Eq (trm.Var vc) (trm.Const v)))\nA total of 25 subgoals...", "next"], ["proof (state)\ngoal (25 subgoals):\n 1. \\<And>t1 t2.\n       \\<lbrakk>safe_formula (formula.Eq t1 t2);\n        MFOTL.future_reach (formula.Eq t1 t2) \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Eq t1 t2)\n 2. \\<And>x y.\n       \\<lbrakk>safe_formula\n                 (formula.Neg (formula.Eq (trm.Const x) (trm.Const y)));\n        MFOTL.future_reach\n         (formula.Neg (formula.Eq (trm.Const x) (trm.Const y))) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg\n                            (formula.Eq (trm.Const x) (trm.Const y)))\n 3. \\<And>x y.\n       \\<lbrakk>safe_formula\n                 (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)));\n        MFOTL.future_reach\n         (formula.Neg (formula.Eq (trm.Var x) (trm.Var y))) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)))\n 4. \\<And>e ts.\n       \\<lbrakk>safe_formula (formula.Pred e ts);\n        MFOTL.future_reach (formula.Pred e ts) \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Pred e ts)\n 5. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Exists \\<phi>);\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Exists \\<phi>)\n 6. \\<And>I \\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Prev I \\<phi>);\n        MFOTL.future_reach (formula.Prev I \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Prev I \\<phi>)\n 7. \\<And>I \\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Next I \\<phi>);\n        MFOTL.future_reach (formula.Next I \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Next I \\<phi>)\n 8. \\<And>\\<phi> I \\<psi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        \\<And>x3.\n           \\<lbrakk>\\<phi> = formula.Neg x3; safe_formula x3;\n            MFOTL.future_reach x3 \\<noteq> \\<infinity>\\<rbrakk>\n           \\<Longrightarrow> mmonitorable_exec x3;\n        \\<lbrakk>safe_formula \\<psi>;\n         MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec \\<psi>;\n        safe_formula (formula.Until \\<phi> I \\<psi>);\n        MFOTL.future_reach (formula.Until \\<phi> I \\<psi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Until \\<phi> I \\<psi>)\n 9. \\<And>va vb.\n       \\<lbrakk>safe_formula (formula.Neg (formula.Pred va vb));\n        MFOTL.future_reach (formula.Neg (formula.Pred va vb)) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg (formula.Pred va vb))\n 10. \\<And>vc v.\n        \\<lbrakk>safe_formula\n                  (formula.Neg (formula.Eq (trm.Var vc) (trm.Const v)));\n         MFOTL.future_reach\n          (formula.Neg (formula.Eq (trm.Var vc) (trm.Const v))) \\<noteq>\n         \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec\n                           (formula.Neg\n                             (formula.Eq (trm.Var vc) (trm.Const v)))\nA total of 25 subgoals...", "case (11 \\<phi> I \\<psi>)"], ["proof (state)\nthis:\n  \\<lbrakk>safe_formula \\<phi>;\n   MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<phi>\n  \\<lbrakk>\\<phi> = formula.Neg ?x3.0; safe_formula ?x3.0;\n   MFOTL.future_reach ?x3.0 \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec ?x3.0\n  \\<lbrakk>safe_formula \\<psi>;\n   MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<psi>\n  safe_formula (formula.Until \\<phi> I \\<psi>)\n  MFOTL.future_reach (formula.Until \\<phi> I \\<psi>) \\<noteq> \\<infinity>\n\ngoal (25 subgoals):\n 1. \\<And>t1 t2.\n       \\<lbrakk>safe_formula (formula.Eq t1 t2);\n        MFOTL.future_reach (formula.Eq t1 t2) \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Eq t1 t2)\n 2. \\<And>x y.\n       \\<lbrakk>safe_formula\n                 (formula.Neg (formula.Eq (trm.Const x) (trm.Const y)));\n        MFOTL.future_reach\n         (formula.Neg (formula.Eq (trm.Const x) (trm.Const y))) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg\n                            (formula.Eq (trm.Const x) (trm.Const y)))\n 3. \\<And>x y.\n       \\<lbrakk>safe_formula\n                 (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)));\n        MFOTL.future_reach\n         (formula.Neg (formula.Eq (trm.Var x) (trm.Var y))) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)))\n 4. \\<And>e ts.\n       \\<lbrakk>safe_formula (formula.Pred e ts);\n        MFOTL.future_reach (formula.Pred e ts) \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Pred e ts)\n 5. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Exists \\<phi>);\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Exists \\<phi>)\n 6. \\<And>I \\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Prev I \\<phi>);\n        MFOTL.future_reach (formula.Prev I \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Prev I \\<phi>)\n 7. \\<And>I \\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Next I \\<phi>);\n        MFOTL.future_reach (formula.Next I \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Next I \\<phi>)\n 8. \\<And>\\<phi> I \\<psi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        \\<And>x3.\n           \\<lbrakk>\\<phi> = formula.Neg x3; safe_formula x3;\n            MFOTL.future_reach x3 \\<noteq> \\<infinity>\\<rbrakk>\n           \\<Longrightarrow> mmonitorable_exec x3;\n        \\<lbrakk>safe_formula \\<psi>;\n         MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec \\<psi>;\n        safe_formula (formula.Until \\<phi> I \\<psi>);\n        MFOTL.future_reach (formula.Until \\<phi> I \\<psi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Until \\<phi> I \\<psi>)\n 9. \\<And>va vb.\n       \\<lbrakk>safe_formula (formula.Neg (formula.Pred va vb));\n        MFOTL.future_reach (formula.Neg (formula.Pred va vb)) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg (formula.Pred va vb))\n 10. \\<And>vc v.\n        \\<lbrakk>safe_formula\n                  (formula.Neg (formula.Eq (trm.Var vc) (trm.Const v)));\n         MFOTL.future_reach\n          (formula.Neg (formula.Eq (trm.Var vc) (trm.Const v))) \\<noteq>\n         \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec\n                           (formula.Neg\n                             (formula.Eq (trm.Var vc) (trm.Const v)))\nA total of 25 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>safe_formula \\<phi>;\n   MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<phi>\n  \\<lbrakk>\\<phi> = formula.Neg ?x3.0; safe_formula ?x3.0;\n   MFOTL.future_reach ?x3.0 \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec ?x3.0\n  \\<lbrakk>safe_formula \\<psi>;\n   MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<psi>\n  safe_formula (formula.Until \\<phi> I \\<psi>)\n  MFOTL.future_reach (formula.Until \\<phi> I \\<psi>) \\<noteq> \\<infinity>", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>safe_formula \\<phi>;\n   MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<phi>\n  \\<lbrakk>\\<phi> = formula.Neg ?x3.0; safe_formula ?x3.0;\n   MFOTL.future_reach ?x3.0 \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec ?x3.0\n  \\<lbrakk>safe_formula \\<psi>;\n   MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<psi>\n  safe_formula (formula.Until \\<phi> I \\<psi>)\n  MFOTL.future_reach (formula.Until \\<phi> I \\<psi>) \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. mmonitorable_exec (formula.Until \\<phi> I \\<psi>)", "unfolding safe_formula.simps future_reach.simps mmonitorable_exec.simps"], ["proof (prove)\nusing this:\n  \\<lbrakk>safe_formula \\<phi>;\n   MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<phi>\n  \\<lbrakk>\\<phi> = formula.Neg ?x3.0; safe_formula ?x3.0;\n   MFOTL.future_reach ?x3.0 \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec ?x3.0\n  \\<lbrakk>safe_formula \\<psi>;\n   MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec \\<psi>\n  fv \\<phi> \\<subseteq> fv \\<psi> \\<and>\n  (safe_formula \\<phi> \\<or>\n   (case \\<phi> of formula.Neg x \\<Rightarrow> safe_formula x\n    | _ \\<Rightarrow> False)) \\<and>\n  safe_formula \\<psi>\n  max (MFOTL.future_reach \\<phi>) (MFOTL.future_reach \\<psi>) + right I +\n  1 \\<noteq>\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. fv \\<phi> \\<subseteq> fv \\<psi> \\<and>\n    right I \\<noteq> \\<infinity> \\<and>\n    (mmonitorable_exec \\<phi> \\<or>\n     (case \\<phi> of formula.Neg x \\<Rightarrow> mmonitorable_exec x\n      | _ \\<Rightarrow> False)) \\<and>\n    mmonitorable_exec \\<psi>", "by (fastforce simp: plus_eq_enat_iff split: formula.splits)"], ["proof (state)\nthis:\n  mmonitorable_exec (formula.Until \\<phi> I \\<psi>)\n\ngoal (24 subgoals):\n 1. \\<And>t1 t2.\n       \\<lbrakk>safe_formula (formula.Eq t1 t2);\n        MFOTL.future_reach (formula.Eq t1 t2) \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Eq t1 t2)\n 2. \\<And>x y.\n       \\<lbrakk>safe_formula\n                 (formula.Neg (formula.Eq (trm.Const x) (trm.Const y)));\n        MFOTL.future_reach\n         (formula.Neg (formula.Eq (trm.Const x) (trm.Const y))) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg\n                            (formula.Eq (trm.Const x) (trm.Const y)))\n 3. \\<And>x y.\n       \\<lbrakk>safe_formula\n                 (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)));\n        MFOTL.future_reach\n         (formula.Neg (formula.Eq (trm.Var x) (trm.Var y))) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)))\n 4. \\<And>e ts.\n       \\<lbrakk>safe_formula (formula.Pred e ts);\n        MFOTL.future_reach (formula.Pred e ts) \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Pred e ts)\n 5. \\<And>\\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Exists \\<phi>);\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Exists \\<phi>)\n 6. \\<And>I \\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Prev I \\<phi>);\n        MFOTL.future_reach (formula.Prev I \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Prev I \\<phi>)\n 7. \\<And>I \\<phi>.\n       \\<lbrakk>\\<lbrakk>safe_formula \\<phi>;\n                 MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> mmonitorable_exec \\<phi>;\n        safe_formula (formula.Next I \\<phi>);\n        MFOTL.future_reach (formula.Next I \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec (formula.Next I \\<phi>)\n 8. \\<And>va vb.\n       \\<lbrakk>safe_formula (formula.Neg (formula.Pred va vb));\n        MFOTL.future_reach (formula.Neg (formula.Pred va vb)) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg (formula.Pred va vb))\n 9. \\<And>vc v.\n       \\<lbrakk>safe_formula\n                 (formula.Neg (formula.Eq (trm.Var vc) (trm.Const v)));\n        MFOTL.future_reach\n         (formula.Neg (formula.Eq (trm.Var vc) (trm.Const v))) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> mmonitorable_exec\n                          (formula.Neg\n                            (formula.Eq (trm.Var vc) (trm.Const v)))\n 10. \\<And>v vc.\n        \\<lbrakk>safe_formula\n                  (formula.Neg (formula.Eq (trm.Const v) (trm.Var vc)));\n         MFOTL.future_reach\n          (formula.Neg (formula.Eq (trm.Const v) (trm.Var vc))) \\<noteq>\n         \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> mmonitorable_exec\n                           (formula.Neg\n                             (formula.Eq (trm.Const v) (trm.Var vc)))\nA total of 24 subgoals...", "qed (auto simp add: plus_eq_enat_iff minus_eq_enat_iff)"], ["", "lemma mmonitorable_exec_mmonitorable: \"mmonitorable_exec \\<phi> \\<Longrightarrow> mmonitorable \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mmonitorable_exec \\<phi> \\<Longrightarrow> mmonitorable \\<phi>", "proof (induct \\<phi> rule: mmonitorable_exec.induct)"], ["proof (state)\ngoal (28 subgoals):\n 1. \\<And>t1 t2.\n       mmonitorable_exec (formula.Eq t1 t2) \\<Longrightarrow>\n       mmonitorable (formula.Eq t1 t2)\n 2. \\<And>x y.\n       mmonitorable_exec\n        (formula.Neg\n          (formula.Eq (trm.Const x) (trm.Const y))) \\<Longrightarrow>\n       mmonitorable (formula.Neg (formula.Eq (trm.Const x) (trm.Const y)))\n 3. \\<And>x y.\n       mmonitorable_exec\n        (formula.Neg (formula.Eq (trm.Var x) (trm.Var y))) \\<Longrightarrow>\n       mmonitorable (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)))\n 4. \\<And>e ts.\n       mmonitorable_exec (formula.Pred e ts) \\<Longrightarrow>\n       mmonitorable (formula.Pred e ts)\n 5. \\<And>\\<phi> \\<psi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>;\n        \\<And>x3.\n           \\<lbrakk>\\<psi> = formula.Neg x3; mmonitorable_exec x3\\<rbrakk>\n           \\<Longrightarrow> mmonitorable x3;\n        mmonitorable_exec\n         (formula.Neg (formula.Or (formula.Neg \\<phi>) \\<psi>))\\<rbrakk>\n       \\<Longrightarrow> mmonitorable\n                          (formula.Neg\n                            (formula.Or (formula.Neg \\<phi>) \\<psi>))\n 6. \\<And>\\<phi> \\<psi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>;\n        mmonitorable_exec (formula.Or \\<phi> \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Or \\<phi> \\<psi>)\n 7. \\<And>\\<phi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec (formula.Exists \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Exists \\<phi>)\n 8. \\<And>I \\<phi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec (formula.Prev I \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Prev I \\<phi>)\n 9. \\<And>I \\<phi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec (formula.Next I \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Next I \\<phi>)\n 10. \\<And>\\<phi> I \\<psi>.\n        \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                 mmonitorable \\<phi>;\n         \\<And>x3.\n            \\<lbrakk>\\<phi> = formula.Neg x3; mmonitorable_exec x3\\<rbrakk>\n            \\<Longrightarrow> mmonitorable x3;\n         mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>;\n         mmonitorable_exec (formula.Since \\<phi> I \\<psi>)\\<rbrakk>\n        \\<Longrightarrow> mmonitorable (formula.Since \\<phi> I \\<psi>)\nA total of 28 subgoals...", "case (5 \\<phi> \\<psi>)"], ["proof (state)\nthis:\n  mmonitorable_exec \\<phi> \\<Longrightarrow> mmonitorable \\<phi>\n  mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>\n  \\<lbrakk>\\<psi> = formula.Neg ?x3.0; mmonitorable_exec ?x3.0\\<rbrakk>\n  \\<Longrightarrow> mmonitorable ?x3.0\n  mmonitorable_exec (formula.Neg (formula.Or (formula.Neg \\<phi>) \\<psi>))\n\ngoal (28 subgoals):\n 1. \\<And>t1 t2.\n       mmonitorable_exec (formula.Eq t1 t2) \\<Longrightarrow>\n       mmonitorable (formula.Eq t1 t2)\n 2. \\<And>x y.\n       mmonitorable_exec\n        (formula.Neg\n          (formula.Eq (trm.Const x) (trm.Const y))) \\<Longrightarrow>\n       mmonitorable (formula.Neg (formula.Eq (trm.Const x) (trm.Const y)))\n 3. \\<And>x y.\n       mmonitorable_exec\n        (formula.Neg (formula.Eq (trm.Var x) (trm.Var y))) \\<Longrightarrow>\n       mmonitorable (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)))\n 4. \\<And>e ts.\n       mmonitorable_exec (formula.Pred e ts) \\<Longrightarrow>\n       mmonitorable (formula.Pred e ts)\n 5. \\<And>\\<phi> \\<psi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>;\n        \\<And>x3.\n           \\<lbrakk>\\<psi> = formula.Neg x3; mmonitorable_exec x3\\<rbrakk>\n           \\<Longrightarrow> mmonitorable x3;\n        mmonitorable_exec\n         (formula.Neg (formula.Or (formula.Neg \\<phi>) \\<psi>))\\<rbrakk>\n       \\<Longrightarrow> mmonitorable\n                          (formula.Neg\n                            (formula.Or (formula.Neg \\<phi>) \\<psi>))\n 6. \\<And>\\<phi> \\<psi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>;\n        mmonitorable_exec (formula.Or \\<phi> \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Or \\<phi> \\<psi>)\n 7. \\<And>\\<phi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec (formula.Exists \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Exists \\<phi>)\n 8. \\<And>I \\<phi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec (formula.Prev I \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Prev I \\<phi>)\n 9. \\<And>I \\<phi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec (formula.Next I \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Next I \\<phi>)\n 10. \\<And>\\<phi> I \\<psi>.\n        \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                 mmonitorable \\<phi>;\n         \\<And>x3.\n            \\<lbrakk>\\<phi> = formula.Neg x3; mmonitorable_exec x3\\<rbrakk>\n            \\<Longrightarrow> mmonitorable x3;\n         mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>;\n         mmonitorable_exec (formula.Since \\<phi> I \\<psi>)\\<rbrakk>\n        \\<Longrightarrow> mmonitorable (formula.Since \\<phi> I \\<psi>)\nA total of 28 subgoals...", "then"], ["proof (chain)\npicking this:\n  mmonitorable_exec \\<phi> \\<Longrightarrow> mmonitorable \\<phi>\n  mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>\n  \\<lbrakk>\\<psi> = formula.Neg ?x3.0; mmonitorable_exec ?x3.0\\<rbrakk>\n  \\<Longrightarrow> mmonitorable ?x3.0\n  mmonitorable_exec (formula.Neg (formula.Or (formula.Neg \\<phi>) \\<psi>))", "show ?case"], ["proof (prove)\nusing this:\n  mmonitorable_exec \\<phi> \\<Longrightarrow> mmonitorable \\<phi>\n  mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>\n  \\<lbrakk>\\<psi> = formula.Neg ?x3.0; mmonitorable_exec ?x3.0\\<rbrakk>\n  \\<Longrightarrow> mmonitorable ?x3.0\n  mmonitorable_exec (formula.Neg (formula.Or (formula.Neg \\<phi>) \\<psi>))\n\ngoal (1 subgoal):\n 1. mmonitorable (formula.Neg (formula.Or (formula.Neg \\<phi>) \\<psi>))", "unfolding mmonitorable_def mmonitorable_exec.simps safe_formula.simps"], ["proof (prove)\nusing this:\n  mmonitorable_exec \\<phi> \\<Longrightarrow>\n  safe_formula \\<phi> \\<and> MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\n  mmonitorable_exec \\<psi> \\<Longrightarrow>\n  safe_formula \\<psi> \\<and> MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\n  \\<lbrakk>\\<psi> = formula.Neg ?x3.0; mmonitorable_exec ?x3.0\\<rbrakk>\n  \\<Longrightarrow> safe_formula ?x3.0 \\<and>\n                    MFOTL.future_reach ?x3.0 \\<noteq> \\<infinity>\n  mmonitorable_exec \\<phi> \\<and>\n  (mmonitorable_exec \\<psi> \\<and> fv \\<psi> \\<subseteq> fv \\<phi> \\<or>\n   (case \\<psi> of formula.Neg x \\<Rightarrow> mmonitorable_exec x\n    | _ \\<Rightarrow> False))\n\ngoal (1 subgoal):\n 1. (safe_formula \\<phi> \\<and>\n     (safe_formula \\<psi> \\<and> fv \\<psi> \\<subseteq> fv \\<phi> \\<or>\n      (case \\<psi> of formula.Neg x \\<Rightarrow> safe_formula x\n       | _ \\<Rightarrow> False))) \\<and>\n    MFOTL.future_reach\n     (formula.Neg (formula.Or (formula.Neg \\<phi>) \\<psi>)) \\<noteq>\n    \\<infinity>", "by (fastforce split: formula.splits)"], ["proof (state)\nthis:\n  mmonitorable (formula.Neg (formula.Or (formula.Neg \\<phi>) \\<psi>))\n\ngoal (27 subgoals):\n 1. \\<And>t1 t2.\n       mmonitorable_exec (formula.Eq t1 t2) \\<Longrightarrow>\n       mmonitorable (formula.Eq t1 t2)\n 2. \\<And>x y.\n       mmonitorable_exec\n        (formula.Neg\n          (formula.Eq (trm.Const x) (trm.Const y))) \\<Longrightarrow>\n       mmonitorable (formula.Neg (formula.Eq (trm.Const x) (trm.Const y)))\n 3. \\<And>x y.\n       mmonitorable_exec\n        (formula.Neg (formula.Eq (trm.Var x) (trm.Var y))) \\<Longrightarrow>\n       mmonitorable (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)))\n 4. \\<And>e ts.\n       mmonitorable_exec (formula.Pred e ts) \\<Longrightarrow>\n       mmonitorable (formula.Pred e ts)\n 5. \\<And>\\<phi> \\<psi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>;\n        mmonitorable_exec (formula.Or \\<phi> \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Or \\<phi> \\<psi>)\n 6. \\<And>\\<phi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec (formula.Exists \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Exists \\<phi>)\n 7. \\<And>I \\<phi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec (formula.Prev I \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Prev I \\<phi>)\n 8. \\<And>I \\<phi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec (formula.Next I \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Next I \\<phi>)\n 9. \\<And>\\<phi> I \\<psi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        \\<And>x3.\n           \\<lbrakk>\\<phi> = formula.Neg x3; mmonitorable_exec x3\\<rbrakk>\n           \\<Longrightarrow> mmonitorable x3;\n        mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>;\n        mmonitorable_exec (formula.Since \\<phi> I \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Since \\<phi> I \\<psi>)\n 10. \\<And>\\<phi> I \\<psi>.\n        \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                 mmonitorable \\<phi>;\n         \\<And>x3.\n            \\<lbrakk>\\<phi> = formula.Neg x3; mmonitorable_exec x3\\<rbrakk>\n            \\<Longrightarrow> mmonitorable x3;\n         mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>;\n         mmonitorable_exec (formula.Until \\<phi> I \\<psi>)\\<rbrakk>\n        \\<Longrightarrow> mmonitorable (formula.Until \\<phi> I \\<psi>)\nA total of 27 subgoals...", "next"], ["proof (state)\ngoal (27 subgoals):\n 1. \\<And>t1 t2.\n       mmonitorable_exec (formula.Eq t1 t2) \\<Longrightarrow>\n       mmonitorable (formula.Eq t1 t2)\n 2. \\<And>x y.\n       mmonitorable_exec\n        (formula.Neg\n          (formula.Eq (trm.Const x) (trm.Const y))) \\<Longrightarrow>\n       mmonitorable (formula.Neg (formula.Eq (trm.Const x) (trm.Const y)))\n 3. \\<And>x y.\n       mmonitorable_exec\n        (formula.Neg (formula.Eq (trm.Var x) (trm.Var y))) \\<Longrightarrow>\n       mmonitorable (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)))\n 4. \\<And>e ts.\n       mmonitorable_exec (formula.Pred e ts) \\<Longrightarrow>\n       mmonitorable (formula.Pred e ts)\n 5. \\<And>\\<phi> \\<psi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>;\n        mmonitorable_exec (formula.Or \\<phi> \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Or \\<phi> \\<psi>)\n 6. \\<And>\\<phi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec (formula.Exists \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Exists \\<phi>)\n 7. \\<And>I \\<phi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec (formula.Prev I \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Prev I \\<phi>)\n 8. \\<And>I \\<phi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec (formula.Next I \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Next I \\<phi>)\n 9. \\<And>\\<phi> I \\<psi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        \\<And>x3.\n           \\<lbrakk>\\<phi> = formula.Neg x3; mmonitorable_exec x3\\<rbrakk>\n           \\<Longrightarrow> mmonitorable x3;\n        mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>;\n        mmonitorable_exec (formula.Since \\<phi> I \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Since \\<phi> I \\<psi>)\n 10. \\<And>\\<phi> I \\<psi>.\n        \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                 mmonitorable \\<phi>;\n         \\<And>x3.\n            \\<lbrakk>\\<phi> = formula.Neg x3; mmonitorable_exec x3\\<rbrakk>\n            \\<Longrightarrow> mmonitorable x3;\n         mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>;\n         mmonitorable_exec (formula.Until \\<phi> I \\<psi>)\\<rbrakk>\n        \\<Longrightarrow> mmonitorable (formula.Until \\<phi> I \\<psi>)\nA total of 27 subgoals...", "case (10 \\<phi> I \\<psi>)"], ["proof (state)\nthis:\n  mmonitorable_exec \\<phi> \\<Longrightarrow> mmonitorable \\<phi>\n  \\<lbrakk>\\<phi> = formula.Neg ?x3.0; mmonitorable_exec ?x3.0\\<rbrakk>\n  \\<Longrightarrow> mmonitorable ?x3.0\n  mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>\n  mmonitorable_exec (formula.Since \\<phi> I \\<psi>)\n\ngoal (27 subgoals):\n 1. \\<And>t1 t2.\n       mmonitorable_exec (formula.Eq t1 t2) \\<Longrightarrow>\n       mmonitorable (formula.Eq t1 t2)\n 2. \\<And>x y.\n       mmonitorable_exec\n        (formula.Neg\n          (formula.Eq (trm.Const x) (trm.Const y))) \\<Longrightarrow>\n       mmonitorable (formula.Neg (formula.Eq (trm.Const x) (trm.Const y)))\n 3. \\<And>x y.\n       mmonitorable_exec\n        (formula.Neg (formula.Eq (trm.Var x) (trm.Var y))) \\<Longrightarrow>\n       mmonitorable (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)))\n 4. \\<And>e ts.\n       mmonitorable_exec (formula.Pred e ts) \\<Longrightarrow>\n       mmonitorable (formula.Pred e ts)\n 5. \\<And>\\<phi> \\<psi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>;\n        mmonitorable_exec (formula.Or \\<phi> \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Or \\<phi> \\<psi>)\n 6. \\<And>\\<phi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec (formula.Exists \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Exists \\<phi>)\n 7. \\<And>I \\<phi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec (formula.Prev I \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Prev I \\<phi>)\n 8. \\<And>I \\<phi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec (formula.Next I \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Next I \\<phi>)\n 9. \\<And>\\<phi> I \\<psi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        \\<And>x3.\n           \\<lbrakk>\\<phi> = formula.Neg x3; mmonitorable_exec x3\\<rbrakk>\n           \\<Longrightarrow> mmonitorable x3;\n        mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>;\n        mmonitorable_exec (formula.Since \\<phi> I \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Since \\<phi> I \\<psi>)\n 10. \\<And>\\<phi> I \\<psi>.\n        \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                 mmonitorable \\<phi>;\n         \\<And>x3.\n            \\<lbrakk>\\<phi> = formula.Neg x3; mmonitorable_exec x3\\<rbrakk>\n            \\<Longrightarrow> mmonitorable x3;\n         mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>;\n         mmonitorable_exec (formula.Until \\<phi> I \\<psi>)\\<rbrakk>\n        \\<Longrightarrow> mmonitorable (formula.Until \\<phi> I \\<psi>)\nA total of 27 subgoals...", "then"], ["proof (chain)\npicking this:\n  mmonitorable_exec \\<phi> \\<Longrightarrow> mmonitorable \\<phi>\n  \\<lbrakk>\\<phi> = formula.Neg ?x3.0; mmonitorable_exec ?x3.0\\<rbrakk>\n  \\<Longrightarrow> mmonitorable ?x3.0\n  mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>\n  mmonitorable_exec (formula.Since \\<phi> I \\<psi>)", "show ?case"], ["proof (prove)\nusing this:\n  mmonitorable_exec \\<phi> \\<Longrightarrow> mmonitorable \\<phi>\n  \\<lbrakk>\\<phi> = formula.Neg ?x3.0; mmonitorable_exec ?x3.0\\<rbrakk>\n  \\<Longrightarrow> mmonitorable ?x3.0\n  mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>\n  mmonitorable_exec (formula.Since \\<phi> I \\<psi>)\n\ngoal (1 subgoal):\n 1. mmonitorable (formula.Since \\<phi> I \\<psi>)", "unfolding mmonitorable_def mmonitorable_exec.simps safe_formula.simps"], ["proof (prove)\nusing this:\n  mmonitorable_exec \\<phi> \\<Longrightarrow>\n  safe_formula \\<phi> \\<and> MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\n  \\<lbrakk>\\<phi> = formula.Neg ?x3.0; mmonitorable_exec ?x3.0\\<rbrakk>\n  \\<Longrightarrow> safe_formula ?x3.0 \\<and>\n                    MFOTL.future_reach ?x3.0 \\<noteq> \\<infinity>\n  mmonitorable_exec \\<psi> \\<Longrightarrow>\n  safe_formula \\<psi> \\<and> MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\n  fv \\<phi> \\<subseteq> fv \\<psi> \\<and>\n  (mmonitorable_exec \\<phi> \\<or>\n   (case \\<phi> of formula.Neg x \\<Rightarrow> mmonitorable_exec x\n    | _ \\<Rightarrow> False)) \\<and>\n  mmonitorable_exec \\<psi>\n\ngoal (1 subgoal):\n 1. (fv \\<phi> \\<subseteq> fv \\<psi> \\<and>\n     (safe_formula \\<phi> \\<or>\n      (case \\<phi> of formula.Neg x \\<Rightarrow> safe_formula x\n       | _ \\<Rightarrow> False)) \\<and>\n     safe_formula \\<psi>) \\<and>\n    MFOTL.future_reach (formula.Since \\<phi> I \\<psi>) \\<noteq> \\<infinity>", "by (fastforce split: formula.splits)"], ["proof (state)\nthis:\n  mmonitorable (formula.Since \\<phi> I \\<psi>)\n\ngoal (26 subgoals):\n 1. \\<And>t1 t2.\n       mmonitorable_exec (formula.Eq t1 t2) \\<Longrightarrow>\n       mmonitorable (formula.Eq t1 t2)\n 2. \\<And>x y.\n       mmonitorable_exec\n        (formula.Neg\n          (formula.Eq (trm.Const x) (trm.Const y))) \\<Longrightarrow>\n       mmonitorable (formula.Neg (formula.Eq (trm.Const x) (trm.Const y)))\n 3. \\<And>x y.\n       mmonitorable_exec\n        (formula.Neg (formula.Eq (trm.Var x) (trm.Var y))) \\<Longrightarrow>\n       mmonitorable (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)))\n 4. \\<And>e ts.\n       mmonitorable_exec (formula.Pred e ts) \\<Longrightarrow>\n       mmonitorable (formula.Pred e ts)\n 5. \\<And>\\<phi> \\<psi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>;\n        mmonitorable_exec (formula.Or \\<phi> \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Or \\<phi> \\<psi>)\n 6. \\<And>\\<phi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec (formula.Exists \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Exists \\<phi>)\n 7. \\<And>I \\<phi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec (formula.Prev I \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Prev I \\<phi>)\n 8. \\<And>I \\<phi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec (formula.Next I \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Next I \\<phi>)\n 9. \\<And>\\<phi> I \\<psi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        \\<And>x3.\n           \\<lbrakk>\\<phi> = formula.Neg x3; mmonitorable_exec x3\\<rbrakk>\n           \\<Longrightarrow> mmonitorable x3;\n        mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>;\n        mmonitorable_exec (formula.Until \\<phi> I \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Until \\<phi> I \\<psi>)\n 10. \\<And>va vb.\n        mmonitorable_exec\n         (formula.Neg (formula.Pred va vb)) \\<Longrightarrow>\n        mmonitorable (formula.Neg (formula.Pred va vb))\nA total of 26 subgoals...", "next"], ["proof (state)\ngoal (26 subgoals):\n 1. \\<And>t1 t2.\n       mmonitorable_exec (formula.Eq t1 t2) \\<Longrightarrow>\n       mmonitorable (formula.Eq t1 t2)\n 2. \\<And>x y.\n       mmonitorable_exec\n        (formula.Neg\n          (formula.Eq (trm.Const x) (trm.Const y))) \\<Longrightarrow>\n       mmonitorable (formula.Neg (formula.Eq (trm.Const x) (trm.Const y)))\n 3. \\<And>x y.\n       mmonitorable_exec\n        (formula.Neg (formula.Eq (trm.Var x) (trm.Var y))) \\<Longrightarrow>\n       mmonitorable (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)))\n 4. \\<And>e ts.\n       mmonitorable_exec (formula.Pred e ts) \\<Longrightarrow>\n       mmonitorable (formula.Pred e ts)\n 5. \\<And>\\<phi> \\<psi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>;\n        mmonitorable_exec (formula.Or \\<phi> \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Or \\<phi> \\<psi>)\n 6. \\<And>\\<phi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec (formula.Exists \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Exists \\<phi>)\n 7. \\<And>I \\<phi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec (formula.Prev I \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Prev I \\<phi>)\n 8. \\<And>I \\<phi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec (formula.Next I \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Next I \\<phi>)\n 9. \\<And>\\<phi> I \\<psi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        \\<And>x3.\n           \\<lbrakk>\\<phi> = formula.Neg x3; mmonitorable_exec x3\\<rbrakk>\n           \\<Longrightarrow> mmonitorable x3;\n        mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>;\n        mmonitorable_exec (formula.Until \\<phi> I \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Until \\<phi> I \\<psi>)\n 10. \\<And>va vb.\n        mmonitorable_exec\n         (formula.Neg (formula.Pred va vb)) \\<Longrightarrow>\n        mmonitorable (formula.Neg (formula.Pred va vb))\nA total of 26 subgoals...", "case (11 \\<phi> I \\<psi>)"], ["proof (state)\nthis:\n  mmonitorable_exec \\<phi> \\<Longrightarrow> mmonitorable \\<phi>\n  \\<lbrakk>\\<phi> = formula.Neg ?x3.0; mmonitorable_exec ?x3.0\\<rbrakk>\n  \\<Longrightarrow> mmonitorable ?x3.0\n  mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>\n  mmonitorable_exec (formula.Until \\<phi> I \\<psi>)\n\ngoal (26 subgoals):\n 1. \\<And>t1 t2.\n       mmonitorable_exec (formula.Eq t1 t2) \\<Longrightarrow>\n       mmonitorable (formula.Eq t1 t2)\n 2. \\<And>x y.\n       mmonitorable_exec\n        (formula.Neg\n          (formula.Eq (trm.Const x) (trm.Const y))) \\<Longrightarrow>\n       mmonitorable (formula.Neg (formula.Eq (trm.Const x) (trm.Const y)))\n 3. \\<And>x y.\n       mmonitorable_exec\n        (formula.Neg (formula.Eq (trm.Var x) (trm.Var y))) \\<Longrightarrow>\n       mmonitorable (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)))\n 4. \\<And>e ts.\n       mmonitorable_exec (formula.Pred e ts) \\<Longrightarrow>\n       mmonitorable (formula.Pred e ts)\n 5. \\<And>\\<phi> \\<psi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>;\n        mmonitorable_exec (formula.Or \\<phi> \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Or \\<phi> \\<psi>)\n 6. \\<And>\\<phi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec (formula.Exists \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Exists \\<phi>)\n 7. \\<And>I \\<phi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec (formula.Prev I \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Prev I \\<phi>)\n 8. \\<And>I \\<phi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec (formula.Next I \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Next I \\<phi>)\n 9. \\<And>\\<phi> I \\<psi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        \\<And>x3.\n           \\<lbrakk>\\<phi> = formula.Neg x3; mmonitorable_exec x3\\<rbrakk>\n           \\<Longrightarrow> mmonitorable x3;\n        mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>;\n        mmonitorable_exec (formula.Until \\<phi> I \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Until \\<phi> I \\<psi>)\n 10. \\<And>va vb.\n        mmonitorable_exec\n         (formula.Neg (formula.Pred va vb)) \\<Longrightarrow>\n        mmonitorable (formula.Neg (formula.Pred va vb))\nA total of 26 subgoals...", "then"], ["proof (chain)\npicking this:\n  mmonitorable_exec \\<phi> \\<Longrightarrow> mmonitorable \\<phi>\n  \\<lbrakk>\\<phi> = formula.Neg ?x3.0; mmonitorable_exec ?x3.0\\<rbrakk>\n  \\<Longrightarrow> mmonitorable ?x3.0\n  mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>\n  mmonitorable_exec (formula.Until \\<phi> I \\<psi>)", "show ?case"], ["proof (prove)\nusing this:\n  mmonitorable_exec \\<phi> \\<Longrightarrow> mmonitorable \\<phi>\n  \\<lbrakk>\\<phi> = formula.Neg ?x3.0; mmonitorable_exec ?x3.0\\<rbrakk>\n  \\<Longrightarrow> mmonitorable ?x3.0\n  mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>\n  mmonitorable_exec (formula.Until \\<phi> I \\<psi>)\n\ngoal (1 subgoal):\n 1. mmonitorable (formula.Until \\<phi> I \\<psi>)", "unfolding mmonitorable_def mmonitorable_exec.simps safe_formula.simps"], ["proof (prove)\nusing this:\n  mmonitorable_exec \\<phi> \\<Longrightarrow>\n  safe_formula \\<phi> \\<and> MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\n  \\<lbrakk>\\<phi> = formula.Neg ?x3.0; mmonitorable_exec ?x3.0\\<rbrakk>\n  \\<Longrightarrow> safe_formula ?x3.0 \\<and>\n                    MFOTL.future_reach ?x3.0 \\<noteq> \\<infinity>\n  mmonitorable_exec \\<psi> \\<Longrightarrow>\n  safe_formula \\<psi> \\<and> MFOTL.future_reach \\<psi> \\<noteq> \\<infinity>\n  fv \\<phi> \\<subseteq> fv \\<psi> \\<and>\n  right I \\<noteq> \\<infinity> \\<and>\n  (mmonitorable_exec \\<phi> \\<or>\n   (case \\<phi> of formula.Neg x \\<Rightarrow> mmonitorable_exec x\n    | _ \\<Rightarrow> False)) \\<and>\n  mmonitorable_exec \\<psi>\n\ngoal (1 subgoal):\n 1. (fv \\<phi> \\<subseteq> fv \\<psi> \\<and>\n     (safe_formula \\<phi> \\<or>\n      (case \\<phi> of formula.Neg x \\<Rightarrow> safe_formula x\n       | _ \\<Rightarrow> False)) \\<and>\n     safe_formula \\<psi>) \\<and>\n    MFOTL.future_reach (formula.Until \\<phi> I \\<psi>) \\<noteq> \\<infinity>", "by (fastforce simp: one_enat_def split: formula.splits)"], ["proof (state)\nthis:\n  mmonitorable (formula.Until \\<phi> I \\<psi>)\n\ngoal (25 subgoals):\n 1. \\<And>t1 t2.\n       mmonitorable_exec (formula.Eq t1 t2) \\<Longrightarrow>\n       mmonitorable (formula.Eq t1 t2)\n 2. \\<And>x y.\n       mmonitorable_exec\n        (formula.Neg\n          (formula.Eq (trm.Const x) (trm.Const y))) \\<Longrightarrow>\n       mmonitorable (formula.Neg (formula.Eq (trm.Const x) (trm.Const y)))\n 3. \\<And>x y.\n       mmonitorable_exec\n        (formula.Neg (formula.Eq (trm.Var x) (trm.Var y))) \\<Longrightarrow>\n       mmonitorable (formula.Neg (formula.Eq (trm.Var x) (trm.Var y)))\n 4. \\<And>e ts.\n       mmonitorable_exec (formula.Pred e ts) \\<Longrightarrow>\n       mmonitorable (formula.Pred e ts)\n 5. \\<And>\\<phi> \\<psi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec \\<psi> \\<Longrightarrow> mmonitorable \\<psi>;\n        mmonitorable_exec (formula.Or \\<phi> \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Or \\<phi> \\<psi>)\n 6. \\<And>\\<phi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec (formula.Exists \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Exists \\<phi>)\n 7. \\<And>I \\<phi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec (formula.Prev I \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Prev I \\<phi>)\n 8. \\<And>I \\<phi>.\n       \\<lbrakk>mmonitorable_exec \\<phi> \\<Longrightarrow>\n                mmonitorable \\<phi>;\n        mmonitorable_exec (formula.Next I \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> mmonitorable (formula.Next I \\<phi>)\n 9. \\<And>va vb.\n       mmonitorable_exec\n        (formula.Neg (formula.Pred va vb)) \\<Longrightarrow>\n       mmonitorable (formula.Neg (formula.Pred va vb))\n 10. \\<And>vc v.\n        mmonitorable_exec\n         (formula.Neg\n           (formula.Eq (trm.Var vc) (trm.Const v))) \\<Longrightarrow>\n        mmonitorable (formula.Neg (formula.Eq (trm.Var vc) (trm.Const v)))\nA total of 25 subgoals...", "qed (auto simp add: mmonitorable_def one_enat_def)"], ["", "lemma monitorable_formula_code[code]: \"mmonitorable \\<phi> = mmonitorable_exec \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mmonitorable \\<phi> = mmonitorable_exec \\<phi>", "using mmonitorable_exec_mmonitorable safe_formula_mmonitorable_exec mmonitorable_def"], ["proof (prove)\nusing this:\n  mmonitorable_exec ?\\<phi> \\<Longrightarrow> mmonitorable ?\\<phi>\n  \\<lbrakk>safe_formula ?\\<phi>;\n   MFOTL.future_reach ?\\<phi> \\<noteq> \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> mmonitorable_exec ?\\<phi>\n  mmonitorable ?\\<phi> =\n  (safe_formula ?\\<phi> \\<and>\n   MFOTL.future_reach ?\\<phi> \\<noteq> \\<infinity>)\n\ngoal (1 subgoal):\n 1. mmonitorable \\<phi> = mmonitorable_exec \\<phi>", "by blast"], ["", "subsection \\<open>The executable monitor\\<close>"], ["", "type_synonym ts = nat"], ["", "type_synonym 'a mbuf2 = \"'a table list \\<times> 'a table list\""], ["", "type_synonym 'a msaux = \"(ts \\<times> 'a table) list\""], ["", "type_synonym 'a muaux = \"(ts \\<times> 'a table \\<times> 'a table) list\""], ["", "datatype 'a mformula =\n    MRel \"'a table\"\n  | MPred MFOTL.name \"'a MFOTL.trm list\"\n  | MAnd \"'a mformula\" bool \"'a mformula\" \"'a mbuf2\"\n  | MOr \"'a mformula\" \"'a mformula\" \"'a mbuf2\"\n  | MExists \"'a mformula\"\n  | MPrev \\<I> \"'a mformula\" bool \"'a table list\" \"ts list\"\n  | MNext \\<I> \"'a mformula\" bool \"ts list\"\n  | MSince bool \"'a mformula\" \\<I> \"'a mformula\" \"'a mbuf2\" \"ts list\" \"'a msaux\"\n  | MUntil bool \"'a mformula\" \\<I> \"'a mformula\" \"'a mbuf2\" \"ts list\" \"'a muaux\""], ["", "record 'a mstate =\n  mstate_i :: nat\n  mstate_m :: \"'a mformula\"\n  mstate_n :: nat"], ["", "fun eq_rel :: \"nat \\<Rightarrow> 'a MFOTL.trm \\<Rightarrow> 'a MFOTL.trm \\<Rightarrow> 'a table\" where\n  \"eq_rel n (MFOTL.Const x) (MFOTL.Const y) = (if x = y then unit_table n else empty_table)\"\n| \"eq_rel n (MFOTL.Var x) (MFOTL.Const y) = singleton_table n x y\"\n| \"eq_rel n (MFOTL.Const x) (MFOTL.Var y) = singleton_table n y x\"\n| \"eq_rel n (MFOTL.Var x) (MFOTL.Var y) = undefined\""], ["", "fun neq_rel :: \"nat \\<Rightarrow> 'a MFOTL.trm \\<Rightarrow> 'a MFOTL.trm \\<Rightarrow> 'a table\" where\n  \"neq_rel n (MFOTL.Const x) (MFOTL.Const y) = (if x = y then empty_table else unit_table n)\"\n| \"neq_rel n (MFOTL.Var x) (MFOTL.Var y) = (if x = y then empty_table else undefined)\"\n| \"neq_rel _ _ _ = undefined\""], ["", "fun minit0 :: \"nat \\<Rightarrow> 'a MFOTL.formula \\<Rightarrow> 'a mformula\" where\n  \"minit0 n (MFOTL.Neg \\<phi>) = (case \\<phi> of\n    MFOTL.Eq t1 t2 \\<Rightarrow> MRel (neq_rel n t1 t2)\n  | MFOTL.Or (MFOTL.Neg \\<phi>) \\<psi> \\<Rightarrow> (if safe_formula \\<psi> \\<and> MFOTL.fv \\<psi> \\<subseteq> MFOTL.fv \\<phi>\n      then MAnd (minit0 n \\<phi>) False (minit0 n \\<psi>) ([], [])\n      else (case \\<psi> of MFOTL.Neg \\<psi> \\<Rightarrow> MAnd (minit0 n \\<phi>) True (minit0 n \\<psi>) ([], []) | _ \\<Rightarrow> undefined))\n  | _ \\<Rightarrow> undefined)\"\n| \"minit0 n (MFOTL.Eq t1 t2) = MRel (eq_rel n t1 t2)\"\n| \"minit0 n (MFOTL.Pred e ts) = MPred e ts\"\n| \"minit0 n (MFOTL.Or \\<phi> \\<psi>) = MOr (minit0 n \\<phi>) (minit0 n \\<psi>) ([], [])\"\n| \"minit0 n (MFOTL.Exists \\<phi>) = MExists (minit0 (Suc n) \\<phi>)\"\n| \"minit0 n (MFOTL.Prev I \\<phi>) = MPrev I (minit0 n \\<phi>) True [] []\"\n| \"minit0 n (MFOTL.Next I \\<phi>) = MNext I (minit0 n \\<phi>) True []\"\n| \"minit0 n (MFOTL.Since \\<phi> I \\<psi>) = (if safe_formula \\<phi>\n    then MSince True (minit0 n \\<phi>) I (minit0 n \\<psi>) ([], []) [] []\n    else (case \\<phi> of\n      MFOTL.Neg \\<phi> \\<Rightarrow> MSince False (minit0 n \\<phi>) I (minit0 n \\<psi>) ([], []) [] []\n    | _ \\<Rightarrow> undefined))\"\n| \"minit0 n (MFOTL.Until \\<phi> I \\<psi>) = (if safe_formula \\<phi>\n    then MUntil True (minit0 n \\<phi>) I (minit0 n \\<psi>) ([], []) [] []\n    else (case \\<phi> of\n      MFOTL.Neg \\<phi> \\<Rightarrow> MUntil False (minit0 n \\<phi>) I (minit0 n \\<psi>) ([], []) [] []\n    | _ \\<Rightarrow> undefined))\""], ["", "definition minit :: \"'a MFOTL.formula \\<Rightarrow> 'a mstate\" where\n  \"minit \\<phi> = (let n = MFOTL.nfv \\<phi> in \\<lparr>mstate_i = 0, mstate_m = minit0 n \\<phi>, mstate_n = n\\<rparr>)\""], ["", "fun mprev_next :: \"\\<I> \\<Rightarrow> 'a table list \\<Rightarrow> ts list \\<Rightarrow> 'a table list \\<times> 'a table list \\<times> ts list\" where\n  \"mprev_next I [] ts = ([], [], ts)\"\n| \"mprev_next I xs [] = ([], xs, [])\"\n| \"mprev_next I xs [t] = ([], xs, [t])\"\n| \"mprev_next I (x # xs) (t # t' # ts) = (let (ys, zs) = mprev_next I xs (t' # ts)\n    in ((if mem (t' - t) I then x else empty_table) # ys, zs))\""], ["", "fun mbuf2_add :: \"'a table list \\<Rightarrow> 'a table list \\<Rightarrow> 'a mbuf2 \\<Rightarrow> 'a mbuf2\" where\n \"mbuf2_add xs' ys' (xs, ys) = (xs @ xs', ys @ ys')\""], ["", "fun mbuf2_take :: \"('a table \\<Rightarrow> 'a table \\<Rightarrow> 'b) \\<Rightarrow> 'a mbuf2 \\<Rightarrow> 'b list \\<times> 'a mbuf2\" where\n  \"mbuf2_take f (x # xs, y # ys) = (let (zs, buf) = mbuf2_take f (xs, ys) in (f x y # zs, buf))\"\n| \"mbuf2_take f (xs, ys) = ([], (xs, ys))\""], ["", "fun mbuf2t_take :: \"('a table \\<Rightarrow> 'a table \\<Rightarrow> ts \\<Rightarrow> 'b \\<Rightarrow> 'b) \\<Rightarrow> 'b \\<Rightarrow>\n  'a mbuf2 \\<Rightarrow> ts list \\<Rightarrow> 'b \\<times> 'a mbuf2 \\<times> ts list\" where\n  \"mbuf2t_take f z (x # xs, y # ys) (t # ts) = mbuf2t_take f (f x y t z) (xs, ys) ts\"\n| \"mbuf2t_take f z (xs, ys) ts = (z, (xs, ys), ts)\""], ["", "fun match :: \"'a MFOTL.trm list \\<Rightarrow> 'a list \\<Rightarrow> (nat \\<rightharpoonup> 'a) option\" where\n  \"match [] [] = Some Map.empty\"\n| \"match (MFOTL.Const x # ts) (y # ys) = (if x = y then match ts ys else None)\"\n| \"match (MFOTL.Var x # ts) (y # ys) = (case match ts ys of\n      None \\<Rightarrow> None\n    | Some f \\<Rightarrow> (case f x of\n        None \\<Rightarrow> Some (f(x \\<mapsto> y))\n      | Some z \\<Rightarrow> if y = z then Some f else None))\"\n| \"match _ _ = None\""], ["", "definition update_since :: \"\\<I> \\<Rightarrow> bool \\<Rightarrow> 'a table \\<Rightarrow> 'a table \\<Rightarrow> ts \\<Rightarrow>\n  'a msaux \\<Rightarrow> 'a table \\<times> 'a msaux\" where\n  \"update_since I pos rel1 rel2 nt aux =\n    (let aux = (case [(t, join rel pos rel1). (t, rel) \\<leftarrow> aux, nt - t \\<le> right I] of\n        [] \\<Rightarrow> [(nt, rel2)]\n      | x # aux' \\<Rightarrow> (if fst x = nt then (fst x, snd x \\<union> rel2) # aux' else (nt, rel2) # x # aux'))\n    in (foldr (\\<union>) [rel. (t, rel) \\<leftarrow> aux, left I \\<le> nt - t] {}, aux))\""], ["", "definition update_until :: \"\\<I> \\<Rightarrow> bool \\<Rightarrow> 'a table \\<Rightarrow> 'a table \\<Rightarrow> ts \\<Rightarrow> 'a muaux \\<Rightarrow> 'a muaux\" where\n  \"update_until I pos rel1 rel2 nt aux =\n    (map (\\<lambda>x. case x of (t, a1, a2) \\<Rightarrow> (t, if pos then join a1 True rel1 else a1 \\<union> rel1,\n      if mem (nt - t) I then a2 \\<union> join rel2 pos a1 else a2)) aux) @\n    [(nt, rel1, if left I = 0 then rel2 else empty_table)]\""], ["", "fun eval_until :: \"\\<I> \\<Rightarrow> ts \\<Rightarrow> 'a muaux \\<Rightarrow> 'a table list \\<times> 'a muaux\" where\n  \"eval_until I nt [] = ([], [])\"\n| \"eval_until I nt ((t, a1, a2) # aux) = (if t + right I < nt then\n    (let (xs, aux) = eval_until I nt aux in (a2 # xs, aux)) else ([], (t, a1, a2) # aux))\""], ["", "primrec meval :: \"nat \\<Rightarrow> ts \\<Rightarrow> 'a MFOTL.database \\<Rightarrow> 'a mformula \\<Rightarrow> 'a table list \\<times> 'a mformula\" where\n  \"meval n t db (MRel rel) = ([rel], MRel rel)\"\n| \"meval n t db (MPred e ts) = ([(\\<lambda>f. tabulate f 0 n) ` Option.these\n    (match ts ` (\\<Union>(e', x)\\<in>db. if e = e' then {x} else {}))], MPred e ts)\"\n| \"meval n t db (MAnd \\<phi> pos \\<psi> buf) =\n    (let (xs, \\<phi>) = meval n t db \\<phi>; (ys, \\<psi>) = meval n t db \\<psi>;\n      (zs, buf) = mbuf2_take (\\<lambda>r1 r2. join r1 pos r2) (mbuf2_add xs ys buf)\n    in (zs, MAnd \\<phi> pos \\<psi> buf))\"\n| \"meval n t db (MOr \\<phi> \\<psi> buf) =\n    (let (xs, \\<phi>) = meval n t db \\<phi>; (ys, \\<psi>) = meval n t db \\<psi>;\n      (zs, buf) = mbuf2_take (\\<lambda>r1 r2. r1 \\<union> r2) (mbuf2_add xs ys buf)\n    in (zs, MOr \\<phi> \\<psi> buf))\"\n| \"meval n t db (MExists \\<phi>) =\n    (let (xs, \\<phi>) = meval (Suc n) t db \\<phi> in (map (\\<lambda>r. tl ` r) xs, MExists \\<phi>))\"\n| \"meval n t db (MPrev I \\<phi> first buf nts) =\n    (let (xs, \\<phi>) = meval n t db \\<phi>;\n      (zs, buf, nts) = mprev_next I (buf @ xs) (nts @ [t])\n    in (if first then empty_table # zs else zs, MPrev I \\<phi> False buf nts))\"\n| \"meval n t db (MNext I \\<phi> first nts) =\n    (let (xs, \\<phi>) = meval n t db \\<phi>;\n      (xs, first) = (case (xs, first) of (_ # xs, True) \\<Rightarrow> (xs, False) | a \\<Rightarrow> a);\n      (zs, _, nts) = mprev_next I xs (nts @ [t])\n    in (zs, MNext I \\<phi> first nts))\"\n| \"meval n t db (MSince pos \\<phi> I \\<psi> buf nts aux) =\n    (let (xs, \\<phi>) = meval n t db \\<phi>; (ys, \\<psi>) = meval n t db \\<psi>;\n      ((zs, aux), buf, nts) = mbuf2t_take (\\<lambda>r1 r2 t (zs, aux).\n        let (z, aux) = update_since I pos r1 r2 t aux\n        in (zs @ [z], aux)) ([], aux) (mbuf2_add xs ys buf) (nts @ [t])\n    in (zs, MSince pos \\<phi> I \\<psi> buf nts aux))\"\n| \"meval n t db (MUntil pos \\<phi> I \\<psi> buf nts aux) =\n    (let (xs, \\<phi>) = meval n t db \\<phi>; (ys, \\<psi>) = meval n t db \\<psi>;\n      (aux, buf, nts) = mbuf2t_take (update_until I pos) aux (mbuf2_add xs ys buf) (nts @ [t]);\n      (zs, aux) = eval_until I (case nts of [] \\<Rightarrow> t | nt # _ \\<Rightarrow> nt) aux\n    in (zs, MUntil pos \\<phi> I \\<psi> buf nts aux))\""], ["", "definition mstep :: \"'a MFOTL.database \\<times> ts \\<Rightarrow> 'a mstate \\<Rightarrow> (nat \\<times> 'a tuple) set \\<times> 'a mstate\" where\n  \"mstep tdb st =\n     (let (xs, m) = meval (mstate_n st) (snd tdb) (fst tdb) (mstate_m st)\n     in (\\<Union> (set (map (\\<lambda>(i, X). (\\<lambda>v. (i, v)) ` X) (List.enumerate (mstate_i st) xs))),\n      \\<lparr>mstate_i = mstate_i st + length xs, mstate_m = m, mstate_n = mstate_n st\\<rparr>))\""], ["", "lemma mstep_alt: \"mstep tdb st =\n     (let (xs, m) = meval (mstate_n st) (snd tdb) (fst tdb) (mstate_m st)\n     in (\\<Union>(i, X) \\<in> set (List.enumerate (mstate_i st) xs). \\<Union>v \\<in> X. {(i,v)},\n      \\<lparr>mstate_i = mstate_i st + length xs, mstate_m = m, mstate_n = mstate_n st\\<rparr>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mstep tdb st =\n    (let (xs, m) = meval (mstate_n st) (snd tdb) (fst tdb) (mstate_m st)\n     in (\\<Union>(i, X)\\<in>set (List.enumerate (mstate_i st) xs).\n            \\<Union>v\\<in>X. {(i, v)},\n         \\<lparr>mstate_i = mstate_i st + length xs, mstate_m = m,\n            mstate_n = mstate_n st\\<rparr>))", "unfolding mstep_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (xs, m) = meval (mstate_n st) (snd tdb) (fst tdb) (mstate_m st)\n     in (\\<Union>\n          (set (map (\\<lambda>(i, y). Pair i ` y)\n                 (List.enumerate (mstate_i st) xs))),\n         \\<lparr>mstate_i = mstate_i st + length xs, mstate_m = m,\n            mstate_n = mstate_n st\\<rparr>)) =\n    (let (xs, m) = meval (mstate_n st) (snd tdb) (fst tdb) (mstate_m st)\n     in (\\<Union>(i, X)\\<in>set (List.enumerate (mstate_i st) xs).\n            \\<Union>v\\<in>X. {(i, v)},\n         \\<lparr>mstate_i = mstate_i st + length xs, mstate_m = m,\n            mstate_n = mstate_n st\\<rparr>))", "by (auto split: prod.split)"], ["", "subsection \\<open>Progress\\<close>"], ["", "primrec progress :: \"'a MFOTL.trace \\<Rightarrow> 'a MFOTL.formula \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"progress \\<sigma> (MFOTL.Pred e ts) j = j\"\n| \"progress \\<sigma> (MFOTL.Eq t1 t2) j = j\"\n| \"progress \\<sigma> (MFOTL.Neg \\<phi>) j = progress \\<sigma> \\<phi> j\"\n| \"progress \\<sigma> (MFOTL.Or \\<phi> \\<psi>) j = min (progress \\<sigma> \\<phi> j) (progress \\<sigma> \\<psi> j)\"\n| \"progress \\<sigma> (MFOTL.Exists \\<phi>) j = progress \\<sigma> \\<phi> j\"\n| \"progress \\<sigma> (MFOTL.Prev I \\<phi>) j = (if j = 0 then 0 else min (Suc (progress \\<sigma> \\<phi> j)) j)\"\n| \"progress \\<sigma> (MFOTL.Next I \\<phi>) j = progress \\<sigma> \\<phi> j - 1\"\n| \"progress \\<sigma> (MFOTL.Since \\<phi> I \\<psi>) j = min (progress \\<sigma> \\<phi> j) (progress \\<sigma> \\<psi> j)\"\n| \"progress \\<sigma> (MFOTL.Until \\<phi> I \\<psi>) j =\n    Inf {i. \\<forall>k. k < j \\<and> k \\<le> min (progress \\<sigma> \\<phi> j) (progress \\<sigma> \\<psi> j) \\<longrightarrow> \\<tau> \\<sigma> i + right I \\<ge> \\<tau> \\<sigma> k}\""], ["", "lemma progress_And[simp]: \"progress \\<sigma> (MFOTL.And \\<phi> \\<psi>) j = min (progress \\<sigma> \\<phi> j) (progress \\<sigma> \\<psi> j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Monitor.progress \\<sigma> (MFOTL.And \\<phi> \\<psi>) j =\n    min (Monitor.progress \\<sigma> \\<phi> j)\n     (Monitor.progress \\<sigma> \\<psi> j)", "unfolding MFOTL.And_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Monitor.progress \\<sigma>\n     (formula.Neg (formula.Or (formula.Neg \\<phi>) (formula.Neg \\<psi>)))\n     j =\n    min (Monitor.progress \\<sigma> \\<phi> j)\n     (Monitor.progress \\<sigma> \\<psi> j)", "by simp"], ["", "lemma progress_And_Not[simp]: \"progress \\<sigma> (MFOTL.And_Not \\<phi> \\<psi>) j = min (progress \\<sigma> \\<phi> j) (progress \\<sigma> \\<psi> j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Monitor.progress \\<sigma> (MFOTL.And_Not \\<phi> \\<psi>) j =\n    min (Monitor.progress \\<sigma> \\<phi> j)\n     (Monitor.progress \\<sigma> \\<psi> j)", "unfolding MFOTL.And_Not_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Monitor.progress \\<sigma>\n     (formula.Neg (formula.Or (formula.Neg \\<phi>) \\<psi>)) j =\n    min (Monitor.progress \\<sigma> \\<phi> j)\n     (Monitor.progress \\<sigma> \\<psi> j)", "by simp"], ["", "lemma progress_mono: \"j \\<le> j' \\<Longrightarrow> progress \\<sigma> \\<phi> j \\<le> progress \\<sigma> \\<phi> j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> j' \\<Longrightarrow>\n    Monitor.progress \\<sigma> \\<phi> j\n    \\<le> Monitor.progress \\<sigma> \\<phi> j'", "proof (induction \\<phi>)"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>x1 x2.\n       j \\<le> j' \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Pred x1 x2) j\n       \\<le> Monitor.progress \\<sigma> (formula.Pred x1 x2) j'\n 2. \\<And>x1 x2.\n       j \\<le> j' \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Eq x1 x2) j\n       \\<le> Monitor.progress \\<sigma> (formula.Eq x1 x2) j'\n 3. \\<And>\\<phi>.\n       \\<lbrakk>j \\<le> j' \\<Longrightarrow>\n                Monitor.progress \\<sigma> \\<phi> j\n                \\<le> Monitor.progress \\<sigma> \\<phi> j';\n        j \\<le> j'\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma> (formula.Neg \\<phi>) j\n                         \\<le> Monitor.progress \\<sigma>\n                                (formula.Neg \\<phi>) j'\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>j \\<le> j' \\<Longrightarrow>\n                Monitor.progress \\<sigma> \\<phi>1 j\n                \\<le> Monitor.progress \\<sigma> \\<phi>1 j';\n        j \\<le> j' \\<Longrightarrow>\n        Monitor.progress \\<sigma> \\<phi>2 j\n        \\<le> Monitor.progress \\<sigma> \\<phi>2 j';\n        j \\<le> j'\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Or \\<phi>1 \\<phi>2) j\n                         \\<le> Monitor.progress \\<sigma>\n                                (formula.Or \\<phi>1 \\<phi>2) j'\n 5. \\<And>\\<phi>.\n       \\<lbrakk>j \\<le> j' \\<Longrightarrow>\n                Monitor.progress \\<sigma> \\<phi> j\n                \\<le> Monitor.progress \\<sigma> \\<phi> j';\n        j \\<le> j'\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma> (formula.Exists \\<phi>) j\n                         \\<le> Monitor.progress \\<sigma>\n                                (formula.Exists \\<phi>) j'\n 6. \\<And>x1 \\<phi>.\n       \\<lbrakk>j \\<le> j' \\<Longrightarrow>\n                Monitor.progress \\<sigma> \\<phi> j\n                \\<le> Monitor.progress \\<sigma> \\<phi> j';\n        j \\<le> j'\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma> (formula.Prev x1 \\<phi>)\n                          j\n                         \\<le> Monitor.progress \\<sigma>\n                                (formula.Prev x1 \\<phi>) j'\n 7. \\<And>x1 \\<phi>.\n       \\<lbrakk>j \\<le> j' \\<Longrightarrow>\n                Monitor.progress \\<sigma> \\<phi> j\n                \\<le> Monitor.progress \\<sigma> \\<phi> j';\n        j \\<le> j'\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma> (formula.Next x1 \\<phi>)\n                          j\n                         \\<le> Monitor.progress \\<sigma>\n                                (formula.Next x1 \\<phi>) j'\n 8. \\<And>\\<phi>1 x2 \\<phi>2.\n       \\<lbrakk>j \\<le> j' \\<Longrightarrow>\n                Monitor.progress \\<sigma> \\<phi>1 j\n                \\<le> Monitor.progress \\<sigma> \\<phi>1 j';\n        j \\<le> j' \\<Longrightarrow>\n        Monitor.progress \\<sigma> \\<phi>2 j\n        \\<le> Monitor.progress \\<sigma> \\<phi>2 j';\n        j \\<le> j'\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Since \\<phi>1 x2 \\<phi>2) j\n                         \\<le> Monitor.progress \\<sigma>\n                                (formula.Since \\<phi>1 x2 \\<phi>2) j'\n 9. \\<And>\\<phi>1 x2 \\<phi>2.\n       \\<lbrakk>j \\<le> j' \\<Longrightarrow>\n                Monitor.progress \\<sigma> \\<phi>1 j\n                \\<le> Monitor.progress \\<sigma> \\<phi>1 j';\n        j \\<le> j' \\<Longrightarrow>\n        Monitor.progress \\<sigma> \\<phi>2 j\n        \\<le> Monitor.progress \\<sigma> \\<phi>2 j';\n        j \\<le> j'\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Until \\<phi>1 x2 \\<phi>2) j\n                         \\<le> Monitor.progress \\<sigma>\n                                (formula.Until \\<phi>1 x2 \\<phi>2) j'", "case (Until \\<phi> I \\<psi>)"], ["proof (state)\nthis:\n  j \\<le> j' \\<Longrightarrow>\n  Monitor.progress \\<sigma> \\<phi> j\n  \\<le> Monitor.progress \\<sigma> \\<phi> j'\n  j \\<le> j' \\<Longrightarrow>\n  Monitor.progress \\<sigma> \\<psi> j\n  \\<le> Monitor.progress \\<sigma> \\<psi> j'\n  j \\<le> j'\n\ngoal (9 subgoals):\n 1. \\<And>x1 x2.\n       j \\<le> j' \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Pred x1 x2) j\n       \\<le> Monitor.progress \\<sigma> (formula.Pred x1 x2) j'\n 2. \\<And>x1 x2.\n       j \\<le> j' \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Eq x1 x2) j\n       \\<le> Monitor.progress \\<sigma> (formula.Eq x1 x2) j'\n 3. \\<And>\\<phi>.\n       \\<lbrakk>j \\<le> j' \\<Longrightarrow>\n                Monitor.progress \\<sigma> \\<phi> j\n                \\<le> Monitor.progress \\<sigma> \\<phi> j';\n        j \\<le> j'\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma> (formula.Neg \\<phi>) j\n                         \\<le> Monitor.progress \\<sigma>\n                                (formula.Neg \\<phi>) j'\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>j \\<le> j' \\<Longrightarrow>\n                Monitor.progress \\<sigma> \\<phi>1 j\n                \\<le> Monitor.progress \\<sigma> \\<phi>1 j';\n        j \\<le> j' \\<Longrightarrow>\n        Monitor.progress \\<sigma> \\<phi>2 j\n        \\<le> Monitor.progress \\<sigma> \\<phi>2 j';\n        j \\<le> j'\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Or \\<phi>1 \\<phi>2) j\n                         \\<le> Monitor.progress \\<sigma>\n                                (formula.Or \\<phi>1 \\<phi>2) j'\n 5. \\<And>\\<phi>.\n       \\<lbrakk>j \\<le> j' \\<Longrightarrow>\n                Monitor.progress \\<sigma> \\<phi> j\n                \\<le> Monitor.progress \\<sigma> \\<phi> j';\n        j \\<le> j'\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma> (formula.Exists \\<phi>) j\n                         \\<le> Monitor.progress \\<sigma>\n                                (formula.Exists \\<phi>) j'\n 6. \\<And>x1 \\<phi>.\n       \\<lbrakk>j \\<le> j' \\<Longrightarrow>\n                Monitor.progress \\<sigma> \\<phi> j\n                \\<le> Monitor.progress \\<sigma> \\<phi> j';\n        j \\<le> j'\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma> (formula.Prev x1 \\<phi>)\n                          j\n                         \\<le> Monitor.progress \\<sigma>\n                                (formula.Prev x1 \\<phi>) j'\n 7. \\<And>x1 \\<phi>.\n       \\<lbrakk>j \\<le> j' \\<Longrightarrow>\n                Monitor.progress \\<sigma> \\<phi> j\n                \\<le> Monitor.progress \\<sigma> \\<phi> j';\n        j \\<le> j'\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma> (formula.Next x1 \\<phi>)\n                          j\n                         \\<le> Monitor.progress \\<sigma>\n                                (formula.Next x1 \\<phi>) j'\n 8. \\<And>\\<phi>1 x2 \\<phi>2.\n       \\<lbrakk>j \\<le> j' \\<Longrightarrow>\n                Monitor.progress \\<sigma> \\<phi>1 j\n                \\<le> Monitor.progress \\<sigma> \\<phi>1 j';\n        j \\<le> j' \\<Longrightarrow>\n        Monitor.progress \\<sigma> \\<phi>2 j\n        \\<le> Monitor.progress \\<sigma> \\<phi>2 j';\n        j \\<le> j'\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Since \\<phi>1 x2 \\<phi>2) j\n                         \\<le> Monitor.progress \\<sigma>\n                                (formula.Since \\<phi>1 x2 \\<phi>2) j'\n 9. \\<And>\\<phi>1 x2 \\<phi>2.\n       \\<lbrakk>j \\<le> j' \\<Longrightarrow>\n                Monitor.progress \\<sigma> \\<phi>1 j\n                \\<le> Monitor.progress \\<sigma> \\<phi>1 j';\n        j \\<le> j' \\<Longrightarrow>\n        Monitor.progress \\<sigma> \\<phi>2 j\n        \\<le> Monitor.progress \\<sigma> \\<phi>2 j';\n        j \\<le> j'\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Until \\<phi>1 x2 \\<phi>2) j\n                         \\<le> Monitor.progress \\<sigma>\n                                (formula.Until \\<phi>1 x2 \\<phi>2) j'", "then"], ["proof (chain)\npicking this:\n  j \\<le> j' \\<Longrightarrow>\n  Monitor.progress \\<sigma> \\<phi> j\n  \\<le> Monitor.progress \\<sigma> \\<phi> j'\n  j \\<le> j' \\<Longrightarrow>\n  Monitor.progress \\<sigma> \\<psi> j\n  \\<le> Monitor.progress \\<sigma> \\<psi> j'\n  j \\<le> j'", "show ?case"], ["proof (prove)\nusing this:\n  j \\<le> j' \\<Longrightarrow>\n  Monitor.progress \\<sigma> \\<phi> j\n  \\<le> Monitor.progress \\<sigma> \\<phi> j'\n  j \\<le> j' \\<Longrightarrow>\n  Monitor.progress \\<sigma> \\<psi> j\n  \\<le> Monitor.progress \\<sigma> \\<psi> j'\n  j \\<le> j'\n\ngoal (1 subgoal):\n 1. Monitor.progress \\<sigma> (formula.Until \\<phi> I \\<psi>) j\n    \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi> I \\<psi>) j'", "by (cases \"right I\")\n      (auto dest: trans_le_add1[OF \\<tau>_mono] intro!: cInf_superset_mono)"], ["proof (state)\nthis:\n  Monitor.progress \\<sigma> (formula.Until \\<phi> I \\<psi>) j\n  \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi> I \\<psi>) j'\n\ngoal (8 subgoals):\n 1. \\<And>x1 x2.\n       j \\<le> j' \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Pred x1 x2) j\n       \\<le> Monitor.progress \\<sigma> (formula.Pred x1 x2) j'\n 2. \\<And>x1 x2.\n       j \\<le> j' \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Eq x1 x2) j\n       \\<le> Monitor.progress \\<sigma> (formula.Eq x1 x2) j'\n 3. \\<And>\\<phi>.\n       \\<lbrakk>j \\<le> j' \\<Longrightarrow>\n                Monitor.progress \\<sigma> \\<phi> j\n                \\<le> Monitor.progress \\<sigma> \\<phi> j';\n        j \\<le> j'\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma> (formula.Neg \\<phi>) j\n                         \\<le> Monitor.progress \\<sigma>\n                                (formula.Neg \\<phi>) j'\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>j \\<le> j' \\<Longrightarrow>\n                Monitor.progress \\<sigma> \\<phi>1 j\n                \\<le> Monitor.progress \\<sigma> \\<phi>1 j';\n        j \\<le> j' \\<Longrightarrow>\n        Monitor.progress \\<sigma> \\<phi>2 j\n        \\<le> Monitor.progress \\<sigma> \\<phi>2 j';\n        j \\<le> j'\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Or \\<phi>1 \\<phi>2) j\n                         \\<le> Monitor.progress \\<sigma>\n                                (formula.Or \\<phi>1 \\<phi>2) j'\n 5. \\<And>\\<phi>.\n       \\<lbrakk>j \\<le> j' \\<Longrightarrow>\n                Monitor.progress \\<sigma> \\<phi> j\n                \\<le> Monitor.progress \\<sigma> \\<phi> j';\n        j \\<le> j'\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma> (formula.Exists \\<phi>) j\n                         \\<le> Monitor.progress \\<sigma>\n                                (formula.Exists \\<phi>) j'\n 6. \\<And>x1 \\<phi>.\n       \\<lbrakk>j \\<le> j' \\<Longrightarrow>\n                Monitor.progress \\<sigma> \\<phi> j\n                \\<le> Monitor.progress \\<sigma> \\<phi> j';\n        j \\<le> j'\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma> (formula.Prev x1 \\<phi>)\n                          j\n                         \\<le> Monitor.progress \\<sigma>\n                                (formula.Prev x1 \\<phi>) j'\n 7. \\<And>x1 \\<phi>.\n       \\<lbrakk>j \\<le> j' \\<Longrightarrow>\n                Monitor.progress \\<sigma> \\<phi> j\n                \\<le> Monitor.progress \\<sigma> \\<phi> j';\n        j \\<le> j'\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma> (formula.Next x1 \\<phi>)\n                          j\n                         \\<le> Monitor.progress \\<sigma>\n                                (formula.Next x1 \\<phi>) j'\n 8. \\<And>\\<phi>1 x2 \\<phi>2.\n       \\<lbrakk>j \\<le> j' \\<Longrightarrow>\n                Monitor.progress \\<sigma> \\<phi>1 j\n                \\<le> Monitor.progress \\<sigma> \\<phi>1 j';\n        j \\<le> j' \\<Longrightarrow>\n        Monitor.progress \\<sigma> \\<phi>2 j\n        \\<le> Monitor.progress \\<sigma> \\<phi>2 j';\n        j \\<le> j'\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Since \\<phi>1 x2 \\<phi>2) j\n                         \\<le> Monitor.progress \\<sigma>\n                                (formula.Since \\<phi>1 x2 \\<phi>2) j'", "qed auto"], ["", "lemma progress_le: \"progress \\<sigma> \\<phi> j \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Monitor.progress \\<sigma> \\<phi> j \\<le> j", "proof (induction \\<phi>)"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>x1 x2. Monitor.progress \\<sigma> (formula.Pred x1 x2) j \\<le> j\n 2. \\<And>x1 x2. Monitor.progress \\<sigma> (formula.Eq x1 x2) j \\<le> j\n 3. \\<And>\\<phi>.\n       Monitor.progress \\<sigma> \\<phi> j \\<le> j \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Neg \\<phi>) j \\<le> j\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>Monitor.progress \\<sigma> \\<phi>1 j \\<le> j;\n        Monitor.progress \\<sigma> \\<phi>2 j \\<le> j\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Or \\<phi>1 \\<phi>2) j\n                         \\<le> j\n 5. \\<And>\\<phi>.\n       Monitor.progress \\<sigma> \\<phi> j \\<le> j \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Exists \\<phi>) j \\<le> j\n 6. \\<And>x1 \\<phi>.\n       Monitor.progress \\<sigma> \\<phi> j \\<le> j \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Prev x1 \\<phi>) j \\<le> j\n 7. \\<And>x1 \\<phi>.\n       Monitor.progress \\<sigma> \\<phi> j \\<le> j \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Next x1 \\<phi>) j \\<le> j\n 8. \\<And>\\<phi>1 x2 \\<phi>2.\n       \\<lbrakk>Monitor.progress \\<sigma> \\<phi>1 j \\<le> j;\n        Monitor.progress \\<sigma> \\<phi>2 j \\<le> j\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Since \\<phi>1 x2 \\<phi>2) j\n                         \\<le> j\n 9. \\<And>\\<phi>1 x2 \\<phi>2.\n       \\<lbrakk>Monitor.progress \\<sigma> \\<phi>1 j \\<le> j;\n        Monitor.progress \\<sigma> \\<phi>2 j \\<le> j\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Until \\<phi>1 x2 \\<phi>2) j\n                         \\<le> j", "case (Until \\<phi> I \\<psi>)"], ["proof (state)\nthis:\n  Monitor.progress \\<sigma> \\<phi> j \\<le> j\n  Monitor.progress \\<sigma> \\<psi> j \\<le> j\n\ngoal (9 subgoals):\n 1. \\<And>x1 x2. Monitor.progress \\<sigma> (formula.Pred x1 x2) j \\<le> j\n 2. \\<And>x1 x2. Monitor.progress \\<sigma> (formula.Eq x1 x2) j \\<le> j\n 3. \\<And>\\<phi>.\n       Monitor.progress \\<sigma> \\<phi> j \\<le> j \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Neg \\<phi>) j \\<le> j\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>Monitor.progress \\<sigma> \\<phi>1 j \\<le> j;\n        Monitor.progress \\<sigma> \\<phi>2 j \\<le> j\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Or \\<phi>1 \\<phi>2) j\n                         \\<le> j\n 5. \\<And>\\<phi>.\n       Monitor.progress \\<sigma> \\<phi> j \\<le> j \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Exists \\<phi>) j \\<le> j\n 6. \\<And>x1 \\<phi>.\n       Monitor.progress \\<sigma> \\<phi> j \\<le> j \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Prev x1 \\<phi>) j \\<le> j\n 7. \\<And>x1 \\<phi>.\n       Monitor.progress \\<sigma> \\<phi> j \\<le> j \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Next x1 \\<phi>) j \\<le> j\n 8. \\<And>\\<phi>1 x2 \\<phi>2.\n       \\<lbrakk>Monitor.progress \\<sigma> \\<phi>1 j \\<le> j;\n        Monitor.progress \\<sigma> \\<phi>2 j \\<le> j\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Since \\<phi>1 x2 \\<phi>2) j\n                         \\<le> j\n 9. \\<And>\\<phi>1 x2 \\<phi>2.\n       \\<lbrakk>Monitor.progress \\<sigma> \\<phi>1 j \\<le> j;\n        Monitor.progress \\<sigma> \\<phi>2 j \\<le> j\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Until \\<phi>1 x2 \\<phi>2) j\n                         \\<le> j", "then"], ["proof (chain)\npicking this:\n  Monitor.progress \\<sigma> \\<phi> j \\<le> j\n  Monitor.progress \\<sigma> \\<psi> j \\<le> j", "show ?case"], ["proof (prove)\nusing this:\n  Monitor.progress \\<sigma> \\<phi> j \\<le> j\n  Monitor.progress \\<sigma> \\<psi> j \\<le> j\n\ngoal (1 subgoal):\n 1. Monitor.progress \\<sigma> (formula.Until \\<phi> I \\<psi>) j \\<le> j", "by (cases \"right I\")\n      (auto intro: trans_le_add1[OF \\<tau>_mono] intro!: cInf_lower)"], ["proof (state)\nthis:\n  Monitor.progress \\<sigma> (formula.Until \\<phi> I \\<psi>) j \\<le> j\n\ngoal (8 subgoals):\n 1. \\<And>x1 x2. Monitor.progress \\<sigma> (formula.Pred x1 x2) j \\<le> j\n 2. \\<And>x1 x2. Monitor.progress \\<sigma> (formula.Eq x1 x2) j \\<le> j\n 3. \\<And>\\<phi>.\n       Monitor.progress \\<sigma> \\<phi> j \\<le> j \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Neg \\<phi>) j \\<le> j\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>Monitor.progress \\<sigma> \\<phi>1 j \\<le> j;\n        Monitor.progress \\<sigma> \\<phi>2 j \\<le> j\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Or \\<phi>1 \\<phi>2) j\n                         \\<le> j\n 5. \\<And>\\<phi>.\n       Monitor.progress \\<sigma> \\<phi> j \\<le> j \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Exists \\<phi>) j \\<le> j\n 6. \\<And>x1 \\<phi>.\n       Monitor.progress \\<sigma> \\<phi> j \\<le> j \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Prev x1 \\<phi>) j \\<le> j\n 7. \\<And>x1 \\<phi>.\n       Monitor.progress \\<sigma> \\<phi> j \\<le> j \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Next x1 \\<phi>) j \\<le> j\n 8. \\<And>\\<phi>1 x2 \\<phi>2.\n       \\<lbrakk>Monitor.progress \\<sigma> \\<phi>1 j \\<le> j;\n        Monitor.progress \\<sigma> \\<phi>2 j \\<le> j\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Since \\<phi>1 x2 \\<phi>2) j\n                         \\<le> j", "qed auto"], ["", "lemma progress_0[simp]: \"progress \\<sigma> \\<phi> 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Monitor.progress \\<sigma> \\<phi> 0 = 0", "using progress_le"], ["proof (prove)\nusing this:\n  Monitor.progress ?\\<sigma> ?\\<phi> ?j \\<le> ?j\n\ngoal (1 subgoal):\n 1. Monitor.progress \\<sigma> \\<phi> 0 = 0", "by auto"], ["", "lemma progress_ge: \"MFOTL.future_reach \\<phi> \\<noteq> \\<infinity> \\<Longrightarrow> \\<exists>j. i \\<le> progress \\<sigma> \\<phi> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MFOTL.future_reach \\<phi> \\<noteq> \\<infinity> \\<Longrightarrow>\n    \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j", "proof (induction \\<phi> arbitrary: i)"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>x1 x2 i.\n       MFOTL.future_reach (formula.Pred x1 x2) \\<noteq>\n       \\<infinity> \\<Longrightarrow>\n       \\<exists>j. i \\<le> Monitor.progress \\<sigma> (formula.Pred x1 x2) j\n 2. \\<And>x1 x2 i.\n       MFOTL.future_reach (formula.Eq x1 x2) \\<noteq>\n       \\<infinity> \\<Longrightarrow>\n       \\<exists>j. i \\<le> Monitor.progress \\<sigma> (formula.Eq x1 x2) j\n 3. \\<And>\\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Neg \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Neg \\<phi>) j\n 4. \\<And>\\<phi>1 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Or \\<phi>1 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Or \\<phi>1 \\<phi>2) j\n 5. \\<And>\\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Exists \\<phi>) j\n 6. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Prev x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Prev x1 \\<phi>) j\n 7. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Next x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Next x1 \\<phi>) j\n 8. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 9. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "case (Pred e ts)"], ["proof (state)\nthis:\n  MFOTL.future_reach (formula.Pred e ts) \\<noteq> \\<infinity>\n\ngoal (9 subgoals):\n 1. \\<And>x1 x2 i.\n       MFOTL.future_reach (formula.Pred x1 x2) \\<noteq>\n       \\<infinity> \\<Longrightarrow>\n       \\<exists>j. i \\<le> Monitor.progress \\<sigma> (formula.Pred x1 x2) j\n 2. \\<And>x1 x2 i.\n       MFOTL.future_reach (formula.Eq x1 x2) \\<noteq>\n       \\<infinity> \\<Longrightarrow>\n       \\<exists>j. i \\<le> Monitor.progress \\<sigma> (formula.Eq x1 x2) j\n 3. \\<And>\\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Neg \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Neg \\<phi>) j\n 4. \\<And>\\<phi>1 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Or \\<phi>1 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Or \\<phi>1 \\<phi>2) j\n 5. \\<And>\\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Exists \\<phi>) j\n 6. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Prev x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Prev x1 \\<phi>) j\n 7. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Next x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Next x1 \\<phi>) j\n 8. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 9. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "then"], ["proof (chain)\npicking this:\n  MFOTL.future_reach (formula.Pred e ts) \\<noteq> \\<infinity>", "show ?case"], ["proof (prove)\nusing this:\n  MFOTL.future_reach (formula.Pred e ts) \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>j. i \\<le> Monitor.progress \\<sigma> (formula.Pred e ts) j", "by auto"], ["proof (state)\nthis:\n  \\<exists>j. i \\<le> Monitor.progress \\<sigma> (formula.Pred e ts) j\n\ngoal (8 subgoals):\n 1. \\<And>x1 x2 i.\n       MFOTL.future_reach (formula.Eq x1 x2) \\<noteq>\n       \\<infinity> \\<Longrightarrow>\n       \\<exists>j. i \\<le> Monitor.progress \\<sigma> (formula.Eq x1 x2) j\n 2. \\<And>\\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Neg \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Neg \\<phi>) j\n 3. \\<And>\\<phi>1 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Or \\<phi>1 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Or \\<phi>1 \\<phi>2) j\n 4. \\<And>\\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Exists \\<phi>) j\n 5. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Prev x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Prev x1 \\<phi>) j\n 6. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Next x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Next x1 \\<phi>) j\n 7. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 8. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x1 x2 i.\n       MFOTL.future_reach (formula.Eq x1 x2) \\<noteq>\n       \\<infinity> \\<Longrightarrow>\n       \\<exists>j. i \\<le> Monitor.progress \\<sigma> (formula.Eq x1 x2) j\n 2. \\<And>\\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Neg \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Neg \\<phi>) j\n 3. \\<And>\\<phi>1 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Or \\<phi>1 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Or \\<phi>1 \\<phi>2) j\n 4. \\<And>\\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Exists \\<phi>) j\n 5. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Prev x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Prev x1 \\<phi>) j\n 6. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Next x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Next x1 \\<phi>) j\n 7. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 8. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "case (Eq t1 t2)"], ["proof (state)\nthis:\n  MFOTL.future_reach (formula.Eq t1 t2) \\<noteq> \\<infinity>\n\ngoal (8 subgoals):\n 1. \\<And>x1 x2 i.\n       MFOTL.future_reach (formula.Eq x1 x2) \\<noteq>\n       \\<infinity> \\<Longrightarrow>\n       \\<exists>j. i \\<le> Monitor.progress \\<sigma> (formula.Eq x1 x2) j\n 2. \\<And>\\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Neg \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Neg \\<phi>) j\n 3. \\<And>\\<phi>1 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Or \\<phi>1 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Or \\<phi>1 \\<phi>2) j\n 4. \\<And>\\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Exists \\<phi>) j\n 5. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Prev x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Prev x1 \\<phi>) j\n 6. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Next x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Next x1 \\<phi>) j\n 7. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 8. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "then"], ["proof (chain)\npicking this:\n  MFOTL.future_reach (formula.Eq t1 t2) \\<noteq> \\<infinity>", "show ?case"], ["proof (prove)\nusing this:\n  MFOTL.future_reach (formula.Eq t1 t2) \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>j. i \\<le> Monitor.progress \\<sigma> (formula.Eq t1 t2) j", "by auto"], ["proof (state)\nthis:\n  \\<exists>j. i \\<le> Monitor.progress \\<sigma> (formula.Eq t1 t2) j\n\ngoal (7 subgoals):\n 1. \\<And>\\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Neg \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Neg \\<phi>) j\n 2. \\<And>\\<phi>1 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Or \\<phi>1 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Or \\<phi>1 \\<phi>2) j\n 3. \\<And>\\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Exists \\<phi>) j\n 4. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Prev x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Prev x1 \\<phi>) j\n 5. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Next x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Next x1 \\<phi>) j\n 6. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 7. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>\\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Neg \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Neg \\<phi>) j\n 2. \\<And>\\<phi>1 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Or \\<phi>1 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Or \\<phi>1 \\<phi>2) j\n 3. \\<And>\\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Exists \\<phi>) j\n 4. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Prev x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Prev x1 \\<phi>) j\n 5. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Next x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Next x1 \\<phi>) j\n 6. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 7. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "case (Neg \\<phi>)"], ["proof (state)\nthis:\n  MFOTL.future_reach \\<phi> \\<noteq> \\<infinity> \\<Longrightarrow>\n  \\<exists>j. ?i \\<le> Monitor.progress \\<sigma> \\<phi> j\n  MFOTL.future_reach (formula.Neg \\<phi>) \\<noteq> \\<infinity>\n\ngoal (7 subgoals):\n 1. \\<And>\\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Neg \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Neg \\<phi>) j\n 2. \\<And>\\<phi>1 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Or \\<phi>1 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Or \\<phi>1 \\<phi>2) j\n 3. \\<And>\\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Exists \\<phi>) j\n 4. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Prev x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Prev x1 \\<phi>) j\n 5. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Next x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Next x1 \\<phi>) j\n 6. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 7. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "then"], ["proof (chain)\npicking this:\n  MFOTL.future_reach \\<phi> \\<noteq> \\<infinity> \\<Longrightarrow>\n  \\<exists>j. ?i \\<le> Monitor.progress \\<sigma> \\<phi> j\n  MFOTL.future_reach (formula.Neg \\<phi>) \\<noteq> \\<infinity>", "show ?case"], ["proof (prove)\nusing this:\n  MFOTL.future_reach \\<phi> \\<noteq> \\<infinity> \\<Longrightarrow>\n  \\<exists>j. ?i \\<le> Monitor.progress \\<sigma> \\<phi> j\n  MFOTL.future_reach (formula.Neg \\<phi>) \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>j. i \\<le> Monitor.progress \\<sigma> (formula.Neg \\<phi>) j", "by simp"], ["proof (state)\nthis:\n  \\<exists>j. i \\<le> Monitor.progress \\<sigma> (formula.Neg \\<phi>) j\n\ngoal (6 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Or \\<phi>1 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Or \\<phi>1 \\<phi>2) j\n 2. \\<And>\\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Exists \\<phi>) j\n 3. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Prev x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Prev x1 \\<phi>) j\n 4. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Next x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Next x1 \\<phi>) j\n 5. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 6. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Or \\<phi>1 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Or \\<phi>1 \\<phi>2) j\n 2. \\<And>\\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Exists \\<phi>) j\n 3. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Prev x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Prev x1 \\<phi>) j\n 4. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Next x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Next x1 \\<phi>) j\n 5. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 6. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "case (Or \\<phi>1 \\<phi>2)"], ["proof (state)\nthis:\n  MFOTL.future_reach \\<phi>1 \\<noteq> \\<infinity> \\<Longrightarrow>\n  \\<exists>j. ?i \\<le> Monitor.progress \\<sigma> \\<phi>1 j\n  MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n  \\<exists>j. ?i \\<le> Monitor.progress \\<sigma> \\<phi>2 j\n  MFOTL.future_reach (formula.Or \\<phi>1 \\<phi>2) \\<noteq> \\<infinity>\n\ngoal (6 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Or \\<phi>1 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Or \\<phi>1 \\<phi>2) j\n 2. \\<And>\\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Exists \\<phi>) j\n 3. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Prev x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Prev x1 \\<phi>) j\n 4. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Next x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Next x1 \\<phi>) j\n 5. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 6. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "from Or.prems"], ["proof (chain)\npicking this:\n  MFOTL.future_reach (formula.Or \\<phi>1 \\<phi>2) \\<noteq> \\<infinity>", "have \"MFOTL.future_reach \\<phi>1 \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  MFOTL.future_reach (formula.Or \\<phi>1 \\<phi>2) \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. MFOTL.future_reach \\<phi>1 \\<noteq> \\<infinity>", "by (cases \"MFOTL.future_reach \\<phi>1\") (auto)"], ["proof (state)\nthis:\n  MFOTL.future_reach \\<phi>1 \\<noteq> \\<infinity>\n\ngoal (6 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Or \\<phi>1 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Or \\<phi>1 \\<phi>2) j\n 2. \\<And>\\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Exists \\<phi>) j\n 3. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Prev x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Prev x1 \\<phi>) j\n 4. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Next x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Next x1 \\<phi>) j\n 5. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 6. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "moreover"], ["proof (state)\nthis:\n  MFOTL.future_reach \\<phi>1 \\<noteq> \\<infinity>\n\ngoal (6 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Or \\<phi>1 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Or \\<phi>1 \\<phi>2) j\n 2. \\<And>\\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Exists \\<phi>) j\n 3. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Prev x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Prev x1 \\<phi>) j\n 4. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Next x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Next x1 \\<phi>) j\n 5. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 6. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "from Or.prems"], ["proof (chain)\npicking this:\n  MFOTL.future_reach (formula.Or \\<phi>1 \\<phi>2) \\<noteq> \\<infinity>", "have \"MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  MFOTL.future_reach (formula.Or \\<phi>1 \\<phi>2) \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity>", "by (cases \"MFOTL.future_reach \\<phi>2\") (auto)"], ["proof (state)\nthis:\n  MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity>\n\ngoal (6 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Or \\<phi>1 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Or \\<phi>1 \\<phi>2) j\n 2. \\<And>\\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Exists \\<phi>) j\n 3. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Prev x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Prev x1 \\<phi>) j\n 4. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Next x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Next x1 \\<phi>) j\n 5. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 6. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "ultimately"], ["proof (chain)\npicking this:\n  MFOTL.future_reach \\<phi>1 \\<noteq> \\<infinity>\n  MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity>", "obtain j1 j2 where \"i \\<le> progress \\<sigma> \\<phi>1 j1\" and \"i \\<le> progress \\<sigma> \\<phi>2 j2\""], ["proof (prove)\nusing this:\n  MFOTL.future_reach \\<phi>1 \\<noteq> \\<infinity>\n  MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>j1 j2.\n        \\<lbrakk>i \\<le> Monitor.progress \\<sigma> \\<phi>1 j1;\n         i \\<le> Monitor.progress \\<sigma> \\<phi>2 j2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Or.IH[of i]"], ["proof (prove)\nusing this:\n  MFOTL.future_reach \\<phi>1 \\<noteq> \\<infinity>\n  MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity>\n  MFOTL.future_reach \\<phi>1 \\<noteq> \\<infinity> \\<Longrightarrow>\n  \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j\n  MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n  \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j\n\ngoal (1 subgoal):\n 1. (\\<And>j1 j2.\n        \\<lbrakk>i \\<le> Monitor.progress \\<sigma> \\<phi>1 j1;\n         i \\<le> Monitor.progress \\<sigma> \\<phi>2 j2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i \\<le> Monitor.progress \\<sigma> \\<phi>1 j1\n  i \\<le> Monitor.progress \\<sigma> \\<phi>2 j2\n\ngoal (6 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Or \\<phi>1 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Or \\<phi>1 \\<phi>2) j\n 2. \\<And>\\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Exists \\<phi>) j\n 3. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Prev x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Prev x1 \\<phi>) j\n 4. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Next x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Next x1 \\<phi>) j\n 5. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 6. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "then"], ["proof (chain)\npicking this:\n  i \\<le> Monitor.progress \\<sigma> \\<phi>1 j1\n  i \\<le> Monitor.progress \\<sigma> \\<phi>2 j2", "have \"i \\<le> progress \\<sigma> (MFOTL.Or \\<phi>1 \\<phi>2) (max j1 j2)\""], ["proof (prove)\nusing this:\n  i \\<le> Monitor.progress \\<sigma> \\<phi>1 j1\n  i \\<le> Monitor.progress \\<sigma> \\<phi>2 j2\n\ngoal (1 subgoal):\n 1. i \\<le> Monitor.progress \\<sigma> (formula.Or \\<phi>1 \\<phi>2)\n             (max j1 j2)", "by (cases \"j1 \\<le> j2\") (auto elim!: order.trans[OF _ progress_mono])"], ["proof (state)\nthis:\n  i \\<le> Monitor.progress \\<sigma> (formula.Or \\<phi>1 \\<phi>2) (max j1 j2)\n\ngoal (6 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Or \\<phi>1 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Or \\<phi>1 \\<phi>2) j\n 2. \\<And>\\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Exists \\<phi>) j\n 3. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Prev x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Prev x1 \\<phi>) j\n 4. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Next x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Next x1 \\<phi>) j\n 5. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 6. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "then"], ["proof (chain)\npicking this:\n  i \\<le> Monitor.progress \\<sigma> (formula.Or \\<phi>1 \\<phi>2) (max j1 j2)", "show ?case"], ["proof (prove)\nusing this:\n  i \\<le> Monitor.progress \\<sigma> (formula.Or \\<phi>1 \\<phi>2) (max j1 j2)\n\ngoal (1 subgoal):\n 1. \\<exists>j.\n       i \\<le> Monitor.progress \\<sigma> (formula.Or \\<phi>1 \\<phi>2) j", "by blast"], ["proof (state)\nthis:\n  \\<exists>j.\n     i \\<le> Monitor.progress \\<sigma> (formula.Or \\<phi>1 \\<phi>2) j\n\ngoal (5 subgoals):\n 1. \\<And>\\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Exists \\<phi>) j\n 2. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Prev x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Prev x1 \\<phi>) j\n 3. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Next x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Next x1 \\<phi>) j\n 4. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 5. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Exists \\<phi>) j\n 2. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Prev x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Prev x1 \\<phi>) j\n 3. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Next x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Next x1 \\<phi>) j\n 4. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 5. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "case (Exists \\<phi>)"], ["proof (state)\nthis:\n  MFOTL.future_reach \\<phi> \\<noteq> \\<infinity> \\<Longrightarrow>\n  \\<exists>j. ?i \\<le> Monitor.progress \\<sigma> \\<phi> j\n  MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq> \\<infinity>\n\ngoal (5 subgoals):\n 1. \\<And>\\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Exists \\<phi>) j\n 2. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Prev x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Prev x1 \\<phi>) j\n 3. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Next x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Next x1 \\<phi>) j\n 4. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 5. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "then"], ["proof (chain)\npicking this:\n  MFOTL.future_reach \\<phi> \\<noteq> \\<infinity> \\<Longrightarrow>\n  \\<exists>j. ?i \\<le> Monitor.progress \\<sigma> \\<phi> j\n  MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq> \\<infinity>", "show ?case"], ["proof (prove)\nusing this:\n  MFOTL.future_reach \\<phi> \\<noteq> \\<infinity> \\<Longrightarrow>\n  \\<exists>j. ?i \\<le> Monitor.progress \\<sigma> \\<phi> j\n  MFOTL.future_reach (formula.Exists \\<phi>) \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>j. i \\<le> Monitor.progress \\<sigma> (formula.Exists \\<phi>) j", "by simp"], ["proof (state)\nthis:\n  \\<exists>j. i \\<le> Monitor.progress \\<sigma> (formula.Exists \\<phi>) j\n\ngoal (4 subgoals):\n 1. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Prev x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Prev x1 \\<phi>) j\n 2. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Next x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Next x1 \\<phi>) j\n 3. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 4. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Prev x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Prev x1 \\<phi>) j\n 2. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Next x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Next x1 \\<phi>) j\n 3. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 4. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "case (Prev I \\<phi>)"], ["proof (state)\nthis:\n  MFOTL.future_reach \\<phi> \\<noteq> \\<infinity> \\<Longrightarrow>\n  \\<exists>j. ?i \\<le> Monitor.progress \\<sigma> \\<phi> j\n  MFOTL.future_reach (formula.Prev I \\<phi>) \\<noteq> \\<infinity>\n\ngoal (4 subgoals):\n 1. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Prev x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Prev x1 \\<phi>) j\n 2. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Next x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Next x1 \\<phi>) j\n 3. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 4. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "from Prev.prems"], ["proof (chain)\npicking this:\n  MFOTL.future_reach (formula.Prev I \\<phi>) \\<noteq> \\<infinity>", "have \"MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  MFOTL.future_reach (formula.Prev I \\<phi>) \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>", "by (cases \"MFOTL.future_reach \\<phi>\") (auto)"], ["proof (state)\nthis:\n  MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\n\ngoal (4 subgoals):\n 1. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Prev x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Prev x1 \\<phi>) j\n 2. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Next x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Next x1 \\<phi>) j\n 3. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 4. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "then"], ["proof (chain)\npicking this:\n  MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>", "obtain j where \"i \\<le> progress \\<sigma> \\<phi> j\""], ["proof (prove)\nusing this:\n  MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        i \\<le> Monitor.progress \\<sigma> \\<phi> j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Prev.IH[of i]"], ["proof (prove)\nusing this:\n  MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\n  MFOTL.future_reach \\<phi> \\<noteq> \\<infinity> \\<Longrightarrow>\n  \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        i \\<le> Monitor.progress \\<sigma> \\<phi> j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i \\<le> Monitor.progress \\<sigma> \\<phi> j\n\ngoal (4 subgoals):\n 1. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Prev x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Prev x1 \\<phi>) j\n 2. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Next x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Next x1 \\<phi>) j\n 3. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 4. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "then"], ["proof (chain)\npicking this:\n  i \\<le> Monitor.progress \\<sigma> \\<phi> j", "show ?case"], ["proof (prove)\nusing this:\n  i \\<le> Monitor.progress \\<sigma> \\<phi> j\n\ngoal (1 subgoal):\n 1. \\<exists>j. i \\<le> Monitor.progress \\<sigma> (formula.Prev I \\<phi>) j", "by (auto intro!: exI[of _ j] elim!: order.trans[OF _ progress_le])"], ["proof (state)\nthis:\n  \\<exists>j. i \\<le> Monitor.progress \\<sigma> (formula.Prev I \\<phi>) j\n\ngoal (3 subgoals):\n 1. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Next x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Next x1 \\<phi>) j\n 2. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 3. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Next x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Next x1 \\<phi>) j\n 2. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 3. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "case (Next I \\<phi>)"], ["proof (state)\nthis:\n  MFOTL.future_reach \\<phi> \\<noteq> \\<infinity> \\<Longrightarrow>\n  \\<exists>j. ?i \\<le> Monitor.progress \\<sigma> \\<phi> j\n  MFOTL.future_reach (formula.Next I \\<phi>) \\<noteq> \\<infinity>\n\ngoal (3 subgoals):\n 1. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Next x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Next x1 \\<phi>) j\n 2. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 3. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "from Next.prems"], ["proof (chain)\npicking this:\n  MFOTL.future_reach (formula.Next I \\<phi>) \\<noteq> \\<infinity>", "have \"MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  MFOTL.future_reach (formula.Next I \\<phi>) \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>", "by (cases \"MFOTL.future_reach \\<phi>\") (auto)"], ["proof (state)\nthis:\n  MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\n\ngoal (3 subgoals):\n 1. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Next x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Next x1 \\<phi>) j\n 2. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 3. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "then"], ["proof (chain)\npicking this:\n  MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>", "obtain j where \"Suc i \\<le> progress \\<sigma> \\<phi> j\""], ["proof (prove)\nusing this:\n  MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        Suc i \\<le> Monitor.progress \\<sigma> \\<phi> j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Next.IH[of \"Suc i\"]"], ["proof (prove)\nusing this:\n  MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\n  MFOTL.future_reach \\<phi> \\<noteq> \\<infinity> \\<Longrightarrow>\n  \\<exists>j. Suc i \\<le> Monitor.progress \\<sigma> \\<phi> j\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        Suc i \\<le> Monitor.progress \\<sigma> \\<phi> j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Suc i \\<le> Monitor.progress \\<sigma> \\<phi> j\n\ngoal (3 subgoals):\n 1. \\<And>x1 \\<phi> i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi> \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi> j;\n        MFOTL.future_reach (formula.Next x1 \\<phi>) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Next x1 \\<phi>) j\n 2. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 3. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "then"], ["proof (chain)\npicking this:\n  Suc i \\<le> Monitor.progress \\<sigma> \\<phi> j", "show ?case"], ["proof (prove)\nusing this:\n  Suc i \\<le> Monitor.progress \\<sigma> \\<phi> j\n\ngoal (1 subgoal):\n 1. \\<exists>j. i \\<le> Monitor.progress \\<sigma> (formula.Next I \\<phi>) j", "by (auto intro!: exI[of _ j])"], ["proof (state)\nthis:\n  \\<exists>j. i \\<le> Monitor.progress \\<sigma> (formula.Next I \\<phi>) j\n\ngoal (2 subgoals):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 2. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 2. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "case (Since \\<phi>1 I \\<phi>2)"], ["proof (state)\nthis:\n  MFOTL.future_reach \\<phi>1 \\<noteq> \\<infinity> \\<Longrightarrow>\n  \\<exists>j. ?i \\<le> Monitor.progress \\<sigma> \\<phi>1 j\n  MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n  \\<exists>j. ?i \\<le> Monitor.progress \\<sigma> \\<phi>2 j\n  MFOTL.future_reach (formula.Since \\<phi>1 I \\<phi>2) \\<noteq> \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 2. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "from Since.prems"], ["proof (chain)\npicking this:\n  MFOTL.future_reach (formula.Since \\<phi>1 I \\<phi>2) \\<noteq> \\<infinity>", "have \"MFOTL.future_reach \\<phi>1 \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  MFOTL.future_reach (formula.Since \\<phi>1 I \\<phi>2) \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. MFOTL.future_reach \\<phi>1 \\<noteq> \\<infinity>", "by (cases \"MFOTL.future_reach \\<phi>1\") (auto)"], ["proof (state)\nthis:\n  MFOTL.future_reach \\<phi>1 \\<noteq> \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 2. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "moreover"], ["proof (state)\nthis:\n  MFOTL.future_reach \\<phi>1 \\<noteq> \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 2. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "from Since.prems"], ["proof (chain)\npicking this:\n  MFOTL.future_reach (formula.Since \\<phi>1 I \\<phi>2) \\<noteq> \\<infinity>", "have \"MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  MFOTL.future_reach (formula.Since \\<phi>1 I \\<phi>2) \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity>", "by (cases \"MFOTL.future_reach \\<phi>2\") (auto)"], ["proof (state)\nthis:\n  MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 2. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "ultimately"], ["proof (chain)\npicking this:\n  MFOTL.future_reach \\<phi>1 \\<noteq> \\<infinity>\n  MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity>", "obtain j1 j2 where \"i \\<le> progress \\<sigma> \\<phi>1 j1\" and \"i \\<le> progress \\<sigma> \\<phi>2 j2\""], ["proof (prove)\nusing this:\n  MFOTL.future_reach \\<phi>1 \\<noteq> \\<infinity>\n  MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>j1 j2.\n        \\<lbrakk>i \\<le> Monitor.progress \\<sigma> \\<phi>1 j1;\n         i \\<le> Monitor.progress \\<sigma> \\<phi>2 j2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Since.IH[of i]"], ["proof (prove)\nusing this:\n  MFOTL.future_reach \\<phi>1 \\<noteq> \\<infinity>\n  MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity>\n  MFOTL.future_reach \\<phi>1 \\<noteq> \\<infinity> \\<Longrightarrow>\n  \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j\n  MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n  \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j\n\ngoal (1 subgoal):\n 1. (\\<And>j1 j2.\n        \\<lbrakk>i \\<le> Monitor.progress \\<sigma> \\<phi>1 j1;\n         i \\<le> Monitor.progress \\<sigma> \\<phi>2 j2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i \\<le> Monitor.progress \\<sigma> \\<phi>1 j1\n  i \\<le> Monitor.progress \\<sigma> \\<phi>2 j2\n\ngoal (2 subgoals):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 2. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "then"], ["proof (chain)\npicking this:\n  i \\<le> Monitor.progress \\<sigma> \\<phi>1 j1\n  i \\<le> Monitor.progress \\<sigma> \\<phi>2 j2", "have \"i \\<le> progress \\<sigma> (MFOTL.Since \\<phi>1 I \\<phi>2) (max j1 j2)\""], ["proof (prove)\nusing this:\n  i \\<le> Monitor.progress \\<sigma> \\<phi>1 j1\n  i \\<le> Monitor.progress \\<sigma> \\<phi>2 j2\n\ngoal (1 subgoal):\n 1. i \\<le> Monitor.progress \\<sigma> (formula.Since \\<phi>1 I \\<phi>2)\n             (max j1 j2)", "by (cases \"j1 \\<le> j2\") (auto elim!: order.trans[OF _ progress_mono])"], ["proof (state)\nthis:\n  i \\<le> Monitor.progress \\<sigma> (formula.Since \\<phi>1 I \\<phi>2)\n           (max j1 j2)\n\ngoal (2 subgoals):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Since \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Since \\<phi>1 x2 \\<phi>2) j\n 2. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "then"], ["proof (chain)\npicking this:\n  i \\<le> Monitor.progress \\<sigma> (formula.Since \\<phi>1 I \\<phi>2)\n           (max j1 j2)", "show ?case"], ["proof (prove)\nusing this:\n  i \\<le> Monitor.progress \\<sigma> (formula.Since \\<phi>1 I \\<phi>2)\n           (max j1 j2)\n\ngoal (1 subgoal):\n 1. \\<exists>j.\n       i \\<le> Monitor.progress \\<sigma> (formula.Since \\<phi>1 I \\<phi>2) j", "by blast"], ["proof (state)\nthis:\n  \\<exists>j.\n     i \\<le> Monitor.progress \\<sigma> (formula.Since \\<phi>1 I \\<phi>2) j\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "case (Until \\<phi>1 I \\<phi>2)"], ["proof (state)\nthis:\n  MFOTL.future_reach \\<phi>1 \\<noteq> \\<infinity> \\<Longrightarrow>\n  \\<exists>j. ?i \\<le> Monitor.progress \\<sigma> \\<phi>1 j\n  MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n  \\<exists>j. ?i \\<le> Monitor.progress \\<sigma> \\<phi>2 j\n  MFOTL.future_reach (formula.Until \\<phi>1 I \\<phi>2) \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "from Until.prems"], ["proof (chain)\npicking this:\n  MFOTL.future_reach (formula.Until \\<phi>1 I \\<phi>2) \\<noteq> \\<infinity>", "obtain b where [simp]: \"right I = enat b\""], ["proof (prove)\nusing this:\n  MFOTL.future_reach (formula.Until \\<phi>1 I \\<phi>2) \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>b. right I = enat b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"right I\") (auto)"], ["proof (state)\nthis:\n  right I = enat b\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "obtain i' where \"i < i'\" and \"\\<tau> \\<sigma> i + b + 1 \\<le> \\<tau> \\<sigma> i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i'.\n        \\<lbrakk>i < i';\n         \\<tau> \\<sigma> i + b + 1 \\<le> \\<tau> \\<sigma> i'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ex_le_\\<tau>[where x=\"\\<tau> \\<sigma> i + b + 1\"]"], ["proof (prove)\nusing this:\n  \\<exists>j\\<ge>?i. \\<tau> \\<sigma> i + b + 1 \\<le> \\<tau> ?s j\n\ngoal (1 subgoal):\n 1. (\\<And>i'.\n        \\<lbrakk>i < i';\n         \\<tau> \\<sigma> i + b + 1 \\<le> \\<tau> \\<sigma> i'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: less_eq_Suc_le)"], ["proof (state)\nthis:\n  i < i'\n  \\<tau> \\<sigma> i + b + 1 \\<le> \\<tau> \\<sigma> i'\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "then"], ["proof (chain)\npicking this:\n  i < i'\n  \\<tau> \\<sigma> i + b + 1 \\<le> \\<tau> \\<sigma> i'", "have 1: \"\\<tau> \\<sigma> i + b < \\<tau> \\<sigma> i'\""], ["proof (prove)\nusing this:\n  i < i'\n  \\<tau> \\<sigma> i + b + 1 \\<le> \\<tau> \\<sigma> i'\n\ngoal (1 subgoal):\n 1. \\<tau> \\<sigma> i + b < \\<tau> \\<sigma> i'", "by simp"], ["proof (state)\nthis:\n  \\<tau> \\<sigma> i + b < \\<tau> \\<sigma> i'\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "from Until.prems"], ["proof (chain)\npicking this:\n  MFOTL.future_reach (formula.Until \\<phi>1 I \\<phi>2) \\<noteq> \\<infinity>", "have \"MFOTL.future_reach \\<phi>1 \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  MFOTL.future_reach (formula.Until \\<phi>1 I \\<phi>2) \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. MFOTL.future_reach \\<phi>1 \\<noteq> \\<infinity>", "by (cases \"MFOTL.future_reach \\<phi>1\") (auto)"], ["proof (state)\nthis:\n  MFOTL.future_reach \\<phi>1 \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "moreover"], ["proof (state)\nthis:\n  MFOTL.future_reach \\<phi>1 \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "from Until.prems"], ["proof (chain)\npicking this:\n  MFOTL.future_reach (formula.Until \\<phi>1 I \\<phi>2) \\<noteq> \\<infinity>", "have \"MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  MFOTL.future_reach (formula.Until \\<phi>1 I \\<phi>2) \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity>", "by (cases \"MFOTL.future_reach \\<phi>2\") (auto)"], ["proof (state)\nthis:\n  MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "ultimately"], ["proof (chain)\npicking this:\n  MFOTL.future_reach \\<phi>1 \\<noteq> \\<infinity>\n  MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity>", "obtain j1 j2 where \"Suc i' \\<le> progress \\<sigma> \\<phi>1 j1\" and \"Suc i' \\<le> progress \\<sigma> \\<phi>2 j2\""], ["proof (prove)\nusing this:\n  MFOTL.future_reach \\<phi>1 \\<noteq> \\<infinity>\n  MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>j1 j2.\n        \\<lbrakk>Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>1 j1;\n         Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>2 j2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Until.IH[of \"Suc i'\"]"], ["proof (prove)\nusing this:\n  MFOTL.future_reach \\<phi>1 \\<noteq> \\<infinity>\n  MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity>\n  MFOTL.future_reach \\<phi>1 \\<noteq> \\<infinity> \\<Longrightarrow>\n  \\<exists>j. Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>1 j\n  MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n  \\<exists>j. Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>2 j\n\ngoal (1 subgoal):\n 1. (\\<And>j1 j2.\n        \\<lbrakk>Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>1 j1;\n         Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>2 j2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>1 j1\n  Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>2 j2\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "then"], ["proof (chain)\npicking this:\n  Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>1 j1\n  Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>2 j2", "have \"i \\<le> progress \\<sigma> (MFOTL.Until \\<phi>1 I \\<phi>2) (max j1 j2)\""], ["proof (prove)\nusing this:\n  Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>1 j1\n  Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>2 j2\n\ngoal (1 subgoal):\n 1. i \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>1 I \\<phi>2)\n             (max j1 j2)", "unfolding progress.simps"], ["proof (prove)\nusing this:\n  Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>1 j1\n  Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>2 j2\n\ngoal (1 subgoal):\n 1. i \\<le> Inf {i. \\<forall>k.\n                       k < max j1 j2 \\<and>\n                       k \\<le> min (Monitor.progress \\<sigma> \\<phi>1\n                                     (max j1 j2))\n                                (Monitor.progress \\<sigma> \\<phi>2\n                                  (max j1 j2)) \\<longrightarrow>\n                       enat (\\<tau> \\<sigma> k)\n                       \\<le> enat (\\<tau> \\<sigma> i) + right I}", "proof (intro cInf_greatest, goal_cases nonempty greatest)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>1 j1;\n     Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>2 j2\\<rbrakk>\n    \\<Longrightarrow> {i. \\<forall>k.\n                             k < max j1 j2 \\<and>\n                             k \\<le> min\n(Monitor.progress \\<sigma> \\<phi>1 (max j1 j2))\n(Monitor.progress \\<sigma> \\<phi>2 (max j1 j2)) \\<longrightarrow>\n                             enat (\\<tau> \\<sigma> k)\n                             \\<le> enat (\\<tau> \\<sigma> i) +\n                                   right I} \\<noteq>\n                      {}\n 2. \\<And>x.\n       \\<lbrakk>Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>1 j1;\n        Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>2 j2;\n        x \\<in> {i. \\<forall>k.\n                       k < max j1 j2 \\<and>\n                       k \\<le> min (Monitor.progress \\<sigma> \\<phi>1\n                                     (max j1 j2))\n                                (Monitor.progress \\<sigma> \\<phi>2\n                                  (max j1 j2)) \\<longrightarrow>\n                       enat (\\<tau> \\<sigma> k)\n                       \\<le> enat (\\<tau> \\<sigma> i) + right I}\\<rbrakk>\n       \\<Longrightarrow> i \\<le> x", "case nonempty"], ["proof (state)\nthis:\n  Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>1 j1\n  Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>2 j2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>1 j1;\n     Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>2 j2\\<rbrakk>\n    \\<Longrightarrow> {i. \\<forall>k.\n                             k < max j1 j2 \\<and>\n                             k \\<le> min\n(Monitor.progress \\<sigma> \\<phi>1 (max j1 j2))\n(Monitor.progress \\<sigma> \\<phi>2 (max j1 j2)) \\<longrightarrow>\n                             enat (\\<tau> \\<sigma> k)\n                             \\<le> enat (\\<tau> \\<sigma> i) +\n                                   right I} \\<noteq>\n                      {}\n 2. \\<And>x.\n       \\<lbrakk>Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>1 j1;\n        Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>2 j2;\n        x \\<in> {i. \\<forall>k.\n                       k < max j1 j2 \\<and>\n                       k \\<le> min (Monitor.progress \\<sigma> \\<phi>1\n                                     (max j1 j2))\n                                (Monitor.progress \\<sigma> \\<phi>2\n                                  (max j1 j2)) \\<longrightarrow>\n                       enat (\\<tau> \\<sigma> k)\n                       \\<le> enat (\\<tau> \\<sigma> i) + right I}\\<rbrakk>\n       \\<Longrightarrow> i \\<le> x", "then"], ["proof (chain)\npicking this:\n  Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>1 j1\n  Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>2 j2", "show ?case"], ["proof (prove)\nusing this:\n  Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>1 j1\n  Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>2 j2\n\ngoal (1 subgoal):\n 1. {i. \\<forall>k.\n           k < max j1 j2 \\<and>\n           k \\<le> min (Monitor.progress \\<sigma> \\<phi>1 (max j1 j2))\n                    (Monitor.progress \\<sigma> \\<phi>2\n                      (max j1 j2)) \\<longrightarrow>\n           enat (\\<tau> \\<sigma> k)\n           \\<le> enat (\\<tau> \\<sigma> i) + right I} \\<noteq>\n    {}", "by (auto simp: trans_le_add1[OF \\<tau>_mono] intro!: exI[of _ \"max j1 j2\"])"], ["proof (state)\nthis:\n  {i. \\<forall>k.\n         k < max j1 j2 \\<and>\n         k \\<le> min (Monitor.progress \\<sigma> \\<phi>1 (max j1 j2))\n                  (Monitor.progress \\<sigma> \\<phi>2\n                    (max j1 j2)) \\<longrightarrow>\n         enat (\\<tau> \\<sigma> k)\n         \\<le> enat (\\<tau> \\<sigma> i) + right I} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>1 j1;\n        Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>2 j2;\n        x \\<in> {i. \\<forall>k.\n                       k < max j1 j2 \\<and>\n                       k \\<le> min (Monitor.progress \\<sigma> \\<phi>1\n                                     (max j1 j2))\n                                (Monitor.progress \\<sigma> \\<phi>2\n                                  (max j1 j2)) \\<longrightarrow>\n                       enat (\\<tau> \\<sigma> k)\n                       \\<le> enat (\\<tau> \\<sigma> i) + right I}\\<rbrakk>\n       \\<Longrightarrow> i \\<le> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>1 j1;\n        Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>2 j2;\n        x \\<in> {i. \\<forall>k.\n                       k < max j1 j2 \\<and>\n                       k \\<le> min (Monitor.progress \\<sigma> \\<phi>1\n                                     (max j1 j2))\n                                (Monitor.progress \\<sigma> \\<phi>2\n                                  (max j1 j2)) \\<longrightarrow>\n                       enat (\\<tau> \\<sigma> k)\n                       \\<le> enat (\\<tau> \\<sigma> i) + right I}\\<rbrakk>\n       \\<Longrightarrow> i \\<le> x", "case (greatest x)"], ["proof (state)\nthis:\n  Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>1 j1\n  Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>2 j2\n  x \\<in> {i. \\<forall>k.\n                 k < max j1 j2 \\<and>\n                 k \\<le> min (Monitor.progress \\<sigma> \\<phi>1 (max j1 j2))\n                          (Monitor.progress \\<sigma> \\<phi>2\n                            (max j1 j2)) \\<longrightarrow>\n                 enat (\\<tau> \\<sigma> k)\n                 \\<le> enat (\\<tau> \\<sigma> i) + right I}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>1 j1;\n        Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>2 j2;\n        x \\<in> {i. \\<forall>k.\n                       k < max j1 j2 \\<and>\n                       k \\<le> min (Monitor.progress \\<sigma> \\<phi>1\n                                     (max j1 j2))\n                                (Monitor.progress \\<sigma> \\<phi>2\n                                  (max j1 j2)) \\<longrightarrow>\n                       enat (\\<tau> \\<sigma> k)\n                       \\<le> enat (\\<tau> \\<sigma> i) + right I}\\<rbrakk>\n       \\<Longrightarrow> i \\<le> x", "with \\<open>i < i'\\<close> 1"], ["proof (chain)\npicking this:\n  i < i'\n  \\<tau> \\<sigma> i + b < \\<tau> \\<sigma> i'\n  Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>1 j1\n  Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>2 j2\n  x \\<in> {i. \\<forall>k.\n                 k < max j1 j2 \\<and>\n                 k \\<le> min (Monitor.progress \\<sigma> \\<phi>1 (max j1 j2))\n                          (Monitor.progress \\<sigma> \\<phi>2\n                            (max j1 j2)) \\<longrightarrow>\n                 enat (\\<tau> \\<sigma> k)\n                 \\<le> enat (\\<tau> \\<sigma> i) + right I}", "show ?case"], ["proof (prove)\nusing this:\n  i < i'\n  \\<tau> \\<sigma> i + b < \\<tau> \\<sigma> i'\n  Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>1 j1\n  Suc i' \\<le> Monitor.progress \\<sigma> \\<phi>2 j2\n  x \\<in> {i. \\<forall>k.\n                 k < max j1 j2 \\<and>\n                 k \\<le> min (Monitor.progress \\<sigma> \\<phi>1 (max j1 j2))\n                          (Monitor.progress \\<sigma> \\<phi>2\n                            (max j1 j2)) \\<longrightarrow>\n                 enat (\\<tau> \\<sigma> k)\n                 \\<le> enat (\\<tau> \\<sigma> i) + right I}\n\ngoal (1 subgoal):\n 1. i \\<le> x", "by (cases \"j1 \\<le> j2\")\n        (auto dest!: spec[of _ i'] simp: max_absorb1 max_absorb2 less_eq_Suc_le\n          elim: order.trans[OF _ progress_le] order.trans[OF _ progress_mono, rotated]\n          dest!: not_le_imp_less[THEN less_imp_le] intro!: less_\\<tau>D[THEN less_imp_le, of \\<sigma> i x])"], ["proof (state)\nthis:\n  i \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>1 I \\<phi>2)\n           (max j1 j2)\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 i.\n       \\<lbrakk>\\<And>i.\n                   MFOTL.future_reach \\<phi>1 \\<noteq>\n                   \\<infinity> \\<Longrightarrow>\n                   \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>1 j;\n        \\<And>i.\n           MFOTL.future_reach \\<phi>2 \\<noteq> \\<infinity> \\<Longrightarrow>\n           \\<exists>j. i \\<le> Monitor.progress \\<sigma> \\<phi>2 j;\n        MFOTL.future_reach (formula.Until \\<phi>1 x2 \\<phi>2) \\<noteq>\n        \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j.\n                            i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>1 x2 \\<phi>2) j", "then"], ["proof (chain)\npicking this:\n  i \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>1 I \\<phi>2)\n           (max j1 j2)", "show ?case"], ["proof (prove)\nusing this:\n  i \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>1 I \\<phi>2)\n           (max j1 j2)\n\ngoal (1 subgoal):\n 1. \\<exists>j.\n       i \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>1 I \\<phi>2) j", "by blast"], ["proof (state)\nthis:\n  \\<exists>j.\n     i \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>1 I \\<phi>2) j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cInf_restrict_nat:\n  fixes x :: nat\n  assumes \"x \\<in> A\"\n  shows \"Inf A = Inf {y \\<in> A. y \\<le> x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf A = Inf {y \\<in> A. y \\<le> x}", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. Inf A = Inf {y \\<in> A. y \\<le> x}", "by (auto intro!: antisym intro: cInf_greatest cInf_lower Inf_nat_def1)"], ["", "lemma progress_time_conv:\n  assumes \"\\<forall>i<j. \\<tau> \\<sigma> i = \\<tau> \\<sigma>' i\"\n  shows \"progress \\<sigma> \\<phi> j = progress \\<sigma>' \\<phi> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Monitor.progress \\<sigma> \\<phi> j = Monitor.progress \\<sigma>' \\<phi> j", "proof (induction \\<phi>)"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>x1 x2.\n       Monitor.progress \\<sigma> (formula.Pred x1 x2) j =\n       Monitor.progress \\<sigma>' (formula.Pred x1 x2) j\n 2. \\<And>x1 x2.\n       Monitor.progress \\<sigma> (formula.Eq x1 x2) j =\n       Monitor.progress \\<sigma>' (formula.Eq x1 x2) j\n 3. \\<And>\\<phi>.\n       Monitor.progress \\<sigma> \\<phi> j =\n       Monitor.progress \\<sigma>' \\<phi> j \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Neg \\<phi>) j =\n       Monitor.progress \\<sigma>' (formula.Neg \\<phi>) j\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>Monitor.progress \\<sigma> \\<phi>1 j =\n                Monitor.progress \\<sigma>' \\<phi>1 j;\n        Monitor.progress \\<sigma> \\<phi>2 j =\n        Monitor.progress \\<sigma>' \\<phi>2 j\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Or \\<phi>1 \\<phi>2) j =\n                         Monitor.progress \\<sigma>'\n                          (formula.Or \\<phi>1 \\<phi>2) j\n 5. \\<And>\\<phi>.\n       Monitor.progress \\<sigma> \\<phi> j =\n       Monitor.progress \\<sigma>' \\<phi> j \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Exists \\<phi>) j =\n       Monitor.progress \\<sigma>' (formula.Exists \\<phi>) j\n 6. \\<And>x1 \\<phi>.\n       Monitor.progress \\<sigma> \\<phi> j =\n       Monitor.progress \\<sigma>' \\<phi> j \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Prev x1 \\<phi>) j =\n       Monitor.progress \\<sigma>' (formula.Prev x1 \\<phi>) j\n 7. \\<And>x1 \\<phi>.\n       Monitor.progress \\<sigma> \\<phi> j =\n       Monitor.progress \\<sigma>' \\<phi> j \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Next x1 \\<phi>) j =\n       Monitor.progress \\<sigma>' (formula.Next x1 \\<phi>) j\n 8. \\<And>\\<phi>1 x2 \\<phi>2.\n       \\<lbrakk>Monitor.progress \\<sigma> \\<phi>1 j =\n                Monitor.progress \\<sigma>' \\<phi>1 j;\n        Monitor.progress \\<sigma> \\<phi>2 j =\n        Monitor.progress \\<sigma>' \\<phi>2 j\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Since \\<phi>1 x2 \\<phi>2) j =\n                         Monitor.progress \\<sigma>'\n                          (formula.Since \\<phi>1 x2 \\<phi>2) j\n 9. \\<And>\\<phi>1 x2 \\<phi>2.\n       \\<lbrakk>Monitor.progress \\<sigma> \\<phi>1 j =\n                Monitor.progress \\<sigma>' \\<phi>1 j;\n        Monitor.progress \\<sigma> \\<phi>2 j =\n        Monitor.progress \\<sigma>' \\<phi>2 j\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Until \\<phi>1 x2 \\<phi>2) j =\n                         Monitor.progress \\<sigma>'\n                          (formula.Until \\<phi>1 x2 \\<phi>2) j", "case (Until \\<phi>1 I \\<phi>2)"], ["proof (state)\nthis:\n  Monitor.progress \\<sigma> \\<phi>1 j = Monitor.progress \\<sigma>' \\<phi>1 j\n  Monitor.progress \\<sigma> \\<phi>2 j = Monitor.progress \\<sigma>' \\<phi>2 j\n\ngoal (9 subgoals):\n 1. \\<And>x1 x2.\n       Monitor.progress \\<sigma> (formula.Pred x1 x2) j =\n       Monitor.progress \\<sigma>' (formula.Pred x1 x2) j\n 2. \\<And>x1 x2.\n       Monitor.progress \\<sigma> (formula.Eq x1 x2) j =\n       Monitor.progress \\<sigma>' (formula.Eq x1 x2) j\n 3. \\<And>\\<phi>.\n       Monitor.progress \\<sigma> \\<phi> j =\n       Monitor.progress \\<sigma>' \\<phi> j \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Neg \\<phi>) j =\n       Monitor.progress \\<sigma>' (formula.Neg \\<phi>) j\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>Monitor.progress \\<sigma> \\<phi>1 j =\n                Monitor.progress \\<sigma>' \\<phi>1 j;\n        Monitor.progress \\<sigma> \\<phi>2 j =\n        Monitor.progress \\<sigma>' \\<phi>2 j\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Or \\<phi>1 \\<phi>2) j =\n                         Monitor.progress \\<sigma>'\n                          (formula.Or \\<phi>1 \\<phi>2) j\n 5. \\<And>\\<phi>.\n       Monitor.progress \\<sigma> \\<phi> j =\n       Monitor.progress \\<sigma>' \\<phi> j \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Exists \\<phi>) j =\n       Monitor.progress \\<sigma>' (formula.Exists \\<phi>) j\n 6. \\<And>x1 \\<phi>.\n       Monitor.progress \\<sigma> \\<phi> j =\n       Monitor.progress \\<sigma>' \\<phi> j \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Prev x1 \\<phi>) j =\n       Monitor.progress \\<sigma>' (formula.Prev x1 \\<phi>) j\n 7. \\<And>x1 \\<phi>.\n       Monitor.progress \\<sigma> \\<phi> j =\n       Monitor.progress \\<sigma>' \\<phi> j \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Next x1 \\<phi>) j =\n       Monitor.progress \\<sigma>' (formula.Next x1 \\<phi>) j\n 8. \\<And>\\<phi>1 x2 \\<phi>2.\n       \\<lbrakk>Monitor.progress \\<sigma> \\<phi>1 j =\n                Monitor.progress \\<sigma>' \\<phi>1 j;\n        Monitor.progress \\<sigma> \\<phi>2 j =\n        Monitor.progress \\<sigma>' \\<phi>2 j\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Since \\<phi>1 x2 \\<phi>2) j =\n                         Monitor.progress \\<sigma>'\n                          (formula.Since \\<phi>1 x2 \\<phi>2) j\n 9. \\<And>\\<phi>1 x2 \\<phi>2.\n       \\<lbrakk>Monitor.progress \\<sigma> \\<phi>1 j =\n                Monitor.progress \\<sigma>' \\<phi>1 j;\n        Monitor.progress \\<sigma> \\<phi>2 j =\n        Monitor.progress \\<sigma>' \\<phi>2 j\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Until \\<phi>1 x2 \\<phi>2) j =\n                         Monitor.progress \\<sigma>'\n                          (formula.Until \\<phi>1 x2 \\<phi>2) j", "have *: \"i \\<le> j - 1 \\<longleftrightarrow> i < j\" if \"j \\<noteq> 0\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<le> j - 1) = (i < j)", "using that"], ["proof (prove)\nusing this:\n  j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (i \\<le> j - 1) = (i < j)", "by auto"], ["proof (state)\nthis:\n  j \\<noteq> 0 \\<Longrightarrow> (?i \\<le> j - 1) = (?i < j)\n\ngoal (9 subgoals):\n 1. \\<And>x1 x2.\n       Monitor.progress \\<sigma> (formula.Pred x1 x2) j =\n       Monitor.progress \\<sigma>' (formula.Pred x1 x2) j\n 2. \\<And>x1 x2.\n       Monitor.progress \\<sigma> (formula.Eq x1 x2) j =\n       Monitor.progress \\<sigma>' (formula.Eq x1 x2) j\n 3. \\<And>\\<phi>.\n       Monitor.progress \\<sigma> \\<phi> j =\n       Monitor.progress \\<sigma>' \\<phi> j \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Neg \\<phi>) j =\n       Monitor.progress \\<sigma>' (formula.Neg \\<phi>) j\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>Monitor.progress \\<sigma> \\<phi>1 j =\n                Monitor.progress \\<sigma>' \\<phi>1 j;\n        Monitor.progress \\<sigma> \\<phi>2 j =\n        Monitor.progress \\<sigma>' \\<phi>2 j\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Or \\<phi>1 \\<phi>2) j =\n                         Monitor.progress \\<sigma>'\n                          (formula.Or \\<phi>1 \\<phi>2) j\n 5. \\<And>\\<phi>.\n       Monitor.progress \\<sigma> \\<phi> j =\n       Monitor.progress \\<sigma>' \\<phi> j \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Exists \\<phi>) j =\n       Monitor.progress \\<sigma>' (formula.Exists \\<phi>) j\n 6. \\<And>x1 \\<phi>.\n       Monitor.progress \\<sigma> \\<phi> j =\n       Monitor.progress \\<sigma>' \\<phi> j \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Prev x1 \\<phi>) j =\n       Monitor.progress \\<sigma>' (formula.Prev x1 \\<phi>) j\n 7. \\<And>x1 \\<phi>.\n       Monitor.progress \\<sigma> \\<phi> j =\n       Monitor.progress \\<sigma>' \\<phi> j \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Next x1 \\<phi>) j =\n       Monitor.progress \\<sigma>' (formula.Next x1 \\<phi>) j\n 8. \\<And>\\<phi>1 x2 \\<phi>2.\n       \\<lbrakk>Monitor.progress \\<sigma> \\<phi>1 j =\n                Monitor.progress \\<sigma>' \\<phi>1 j;\n        Monitor.progress \\<sigma> \\<phi>2 j =\n        Monitor.progress \\<sigma>' \\<phi>2 j\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Since \\<phi>1 x2 \\<phi>2) j =\n                         Monitor.progress \\<sigma>'\n                          (formula.Since \\<phi>1 x2 \\<phi>2) j\n 9. \\<And>\\<phi>1 x2 \\<phi>2.\n       \\<lbrakk>Monitor.progress \\<sigma> \\<phi>1 j =\n                Monitor.progress \\<sigma>' \\<phi>1 j;\n        Monitor.progress \\<sigma> \\<phi>2 j =\n        Monitor.progress \\<sigma>' \\<phi>2 j\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Until \\<phi>1 x2 \\<phi>2) j =\n                         Monitor.progress \\<sigma>'\n                          (formula.Until \\<phi>1 x2 \\<phi>2) j", "with Until"], ["proof (chain)\npicking this:\n  Monitor.progress \\<sigma> \\<phi>1 j = Monitor.progress \\<sigma>' \\<phi>1 j\n  Monitor.progress \\<sigma> \\<phi>2 j = Monitor.progress \\<sigma>' \\<phi>2 j\n  j \\<noteq> 0 \\<Longrightarrow> (?i \\<le> j - 1) = (?i < j)", "show ?case"], ["proof (prove)\nusing this:\n  Monitor.progress \\<sigma> \\<phi>1 j = Monitor.progress \\<sigma>' \\<phi>1 j\n  Monitor.progress \\<sigma> \\<phi>2 j = Monitor.progress \\<sigma>' \\<phi>2 j\n  j \\<noteq> 0 \\<Longrightarrow> (?i \\<le> j - 1) = (?i < j)\n\ngoal (1 subgoal):\n 1. Monitor.progress \\<sigma> (formula.Until \\<phi>1 I \\<phi>2) j =\n    Monitor.progress \\<sigma>' (formula.Until \\<phi>1 I \\<phi>2) j", "proof (cases \"right I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>Monitor.progress \\<sigma> \\<phi>1 j =\n                Monitor.progress \\<sigma>' \\<phi>1 j;\n        Monitor.progress \\<sigma> \\<phi>2 j =\n        Monitor.progress \\<sigma>' \\<phi>2 j;\n        \\<And>i. j \\<noteq> 0 \\<Longrightarrow> (i \\<le> j - 1) = (i < j);\n        right I = enat nat\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Until \\<phi>1 I \\<phi>2) j =\n                         Monitor.progress \\<sigma>'\n                          (formula.Until \\<phi>1 I \\<phi>2) j\n 2. \\<lbrakk>Monitor.progress \\<sigma> \\<phi>1 j =\n             Monitor.progress \\<sigma>' \\<phi>1 j;\n     Monitor.progress \\<sigma> \\<phi>2 j =\n     Monitor.progress \\<sigma>' \\<phi>2 j;\n     \\<And>i. j \\<noteq> 0 \\<Longrightarrow> (i \\<le> j - 1) = (i < j);\n     right I = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> Monitor.progress \\<sigma>\n                       (formula.Until \\<phi>1 I \\<phi>2) j =\n                      Monitor.progress \\<sigma>'\n                       (formula.Until \\<phi>1 I \\<phi>2) j", "case (enat b)"], ["proof (state)\nthis:\n  right I = enat b\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>Monitor.progress \\<sigma> \\<phi>1 j =\n                Monitor.progress \\<sigma>' \\<phi>1 j;\n        Monitor.progress \\<sigma> \\<phi>2 j =\n        Monitor.progress \\<sigma>' \\<phi>2 j;\n        \\<And>i. j \\<noteq> 0 \\<Longrightarrow> (i \\<le> j - 1) = (i < j);\n        right I = enat nat\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Until \\<phi>1 I \\<phi>2) j =\n                         Monitor.progress \\<sigma>'\n                          (formula.Until \\<phi>1 I \\<phi>2) j\n 2. \\<lbrakk>Monitor.progress \\<sigma> \\<phi>1 j =\n             Monitor.progress \\<sigma>' \\<phi>1 j;\n     Monitor.progress \\<sigma> \\<phi>2 j =\n     Monitor.progress \\<sigma>' \\<phi>2 j;\n     \\<And>i. j \\<noteq> 0 \\<Longrightarrow> (i \\<le> j - 1) = (i < j);\n     right I = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> Monitor.progress \\<sigma>\n                       (formula.Until \\<phi>1 I \\<phi>2) j =\n                      Monitor.progress \\<sigma>'\n                       (formula.Until \\<phi>1 I \\<phi>2) j", "then"], ["proof (chain)\npicking this:\n  right I = enat b", "show ?thesis"], ["proof (prove)\nusing this:\n  right I = enat b\n\ngoal (1 subgoal):\n 1. Monitor.progress \\<sigma> (formula.Until \\<phi>1 I \\<phi>2) j =\n    Monitor.progress \\<sigma>' (formula.Until \\<phi>1 I \\<phi>2) j", "proof (cases \"j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>right I = enat b; j = 0\\<rbrakk>\n    \\<Longrightarrow> Monitor.progress \\<sigma>\n                       (formula.Until \\<phi>1 I \\<phi>2) j =\n                      Monitor.progress \\<sigma>'\n                       (formula.Until \\<phi>1 I \\<phi>2) j\n 2. \\<And>nat.\n       \\<lbrakk>right I = enat b; j = Suc nat\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Until \\<phi>1 I \\<phi>2) j =\n                         Monitor.progress \\<sigma>'\n                          (formula.Until \\<phi>1 I \\<phi>2) j", "case (Suc n)"], ["proof (state)\nthis:\n  j = Suc n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>right I = enat b; j = 0\\<rbrakk>\n    \\<Longrightarrow> Monitor.progress \\<sigma>\n                       (formula.Until \\<phi>1 I \\<phi>2) j =\n                      Monitor.progress \\<sigma>'\n                       (formula.Until \\<phi>1 I \\<phi>2) j\n 2. \\<And>nat.\n       \\<lbrakk>right I = enat b; j = Suc nat\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Until \\<phi>1 I \\<phi>2) j =\n                         Monitor.progress \\<sigma>'\n                          (formula.Until \\<phi>1 I \\<phi>2) j", "with enat * Until"], ["proof (chain)\npicking this:\n  right I = enat b\n  j \\<noteq> 0 \\<Longrightarrow> (?i \\<le> j - 1) = (?i < j)\n  Monitor.progress \\<sigma> \\<phi>1 j = Monitor.progress \\<sigma>' \\<phi>1 j\n  Monitor.progress \\<sigma> \\<phi>2 j = Monitor.progress \\<sigma>' \\<phi>2 j\n  j = Suc n", "show ?thesis"], ["proof (prove)\nusing this:\n  right I = enat b\n  j \\<noteq> 0 \\<Longrightarrow> (?i \\<le> j - 1) = (?i < j)\n  Monitor.progress \\<sigma> \\<phi>1 j = Monitor.progress \\<sigma>' \\<phi>1 j\n  Monitor.progress \\<sigma> \\<phi>2 j = Monitor.progress \\<sigma>' \\<phi>2 j\n  j = Suc n\n\ngoal (1 subgoal):\n 1. Monitor.progress \\<sigma> (formula.Until \\<phi>1 I \\<phi>2) j =\n    Monitor.progress \\<sigma>' (formula.Until \\<phi>1 I \\<phi>2) j", "using assms \\<tau>_mono[THEN trans_le_add1]"], ["proof (prove)\nusing this:\n  right I = enat b\n  j \\<noteq> 0 \\<Longrightarrow> (?i \\<le> j - 1) = (?i < j)\n  Monitor.progress \\<sigma> \\<phi>1 j = Monitor.progress \\<sigma>' \\<phi>1 j\n  Monitor.progress \\<sigma> \\<phi>2 j = Monitor.progress \\<sigma>' \\<phi>2 j\n  j = Suc n\n  \\<forall>i<j. \\<tau> \\<sigma> i = \\<tau> \\<sigma>' i\n  ?i1 \\<le> ?j1 \\<Longrightarrow> \\<tau> ?s1 ?i1 \\<le> \\<tau> ?s1 ?j1 + ?m\n\ngoal (1 subgoal):\n 1. Monitor.progress \\<sigma> (formula.Until \\<phi>1 I \\<phi>2) j =\n    Monitor.progress \\<sigma>' (formula.Until \\<phi>1 I \\<phi>2) j", "by (auto 6 0\n          intro!: box_equals[OF arg_cong[where f=Inf]\n            cInf_restrict_nat[symmetric, where x=n] cInf_restrict_nat[symmetric, where x=n]])"], ["proof (state)\nthis:\n  Monitor.progress \\<sigma> (formula.Until \\<phi>1 I \\<phi>2) j =\n  Monitor.progress \\<sigma>' (formula.Until \\<phi>1 I \\<phi>2) j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>right I = enat b; j = 0\\<rbrakk>\n    \\<Longrightarrow> Monitor.progress \\<sigma>\n                       (formula.Until \\<phi>1 I \\<phi>2) j =\n                      Monitor.progress \\<sigma>'\n                       (formula.Until \\<phi>1 I \\<phi>2) j", "qed simp"], ["proof (state)\nthis:\n  Monitor.progress \\<sigma> (formula.Until \\<phi>1 I \\<phi>2) j =\n  Monitor.progress \\<sigma>' (formula.Until \\<phi>1 I \\<phi>2) j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Monitor.progress \\<sigma> \\<phi>1 j =\n             Monitor.progress \\<sigma>' \\<phi>1 j;\n     Monitor.progress \\<sigma> \\<phi>2 j =\n     Monitor.progress \\<sigma>' \\<phi>2 j;\n     \\<And>i. j \\<noteq> 0 \\<Longrightarrow> (i \\<le> j - 1) = (i < j);\n     right I = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> Monitor.progress \\<sigma>\n                       (formula.Until \\<phi>1 I \\<phi>2) j =\n                      Monitor.progress \\<sigma>'\n                       (formula.Until \\<phi>1 I \\<phi>2) j", "qed simp"], ["proof (state)\nthis:\n  Monitor.progress \\<sigma> (formula.Until \\<phi>1 I \\<phi>2) j =\n  Monitor.progress \\<sigma>' (formula.Until \\<phi>1 I \\<phi>2) j\n\ngoal (8 subgoals):\n 1. \\<And>x1 x2.\n       Monitor.progress \\<sigma> (formula.Pred x1 x2) j =\n       Monitor.progress \\<sigma>' (formula.Pred x1 x2) j\n 2. \\<And>x1 x2.\n       Monitor.progress \\<sigma> (formula.Eq x1 x2) j =\n       Monitor.progress \\<sigma>' (formula.Eq x1 x2) j\n 3. \\<And>\\<phi>.\n       Monitor.progress \\<sigma> \\<phi> j =\n       Monitor.progress \\<sigma>' \\<phi> j \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Neg \\<phi>) j =\n       Monitor.progress \\<sigma>' (formula.Neg \\<phi>) j\n 4. \\<And>\\<phi>1 \\<phi>2.\n       \\<lbrakk>Monitor.progress \\<sigma> \\<phi>1 j =\n                Monitor.progress \\<sigma>' \\<phi>1 j;\n        Monitor.progress \\<sigma> \\<phi>2 j =\n        Monitor.progress \\<sigma>' \\<phi>2 j\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Or \\<phi>1 \\<phi>2) j =\n                         Monitor.progress \\<sigma>'\n                          (formula.Or \\<phi>1 \\<phi>2) j\n 5. \\<And>\\<phi>.\n       Monitor.progress \\<sigma> \\<phi> j =\n       Monitor.progress \\<sigma>' \\<phi> j \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Exists \\<phi>) j =\n       Monitor.progress \\<sigma>' (formula.Exists \\<phi>) j\n 6. \\<And>x1 \\<phi>.\n       Monitor.progress \\<sigma> \\<phi> j =\n       Monitor.progress \\<sigma>' \\<phi> j \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Prev x1 \\<phi>) j =\n       Monitor.progress \\<sigma>' (formula.Prev x1 \\<phi>) j\n 7. \\<And>x1 \\<phi>.\n       Monitor.progress \\<sigma> \\<phi> j =\n       Monitor.progress \\<sigma>' \\<phi> j \\<Longrightarrow>\n       Monitor.progress \\<sigma> (formula.Next x1 \\<phi>) j =\n       Monitor.progress \\<sigma>' (formula.Next x1 \\<phi>) j\n 8. \\<And>\\<phi>1 x2 \\<phi>2.\n       \\<lbrakk>Monitor.progress \\<sigma> \\<phi>1 j =\n                Monitor.progress \\<sigma>' \\<phi>1 j;\n        Monitor.progress \\<sigma> \\<phi>2 j =\n        Monitor.progress \\<sigma>' \\<phi>2 j\\<rbrakk>\n       \\<Longrightarrow> Monitor.progress \\<sigma>\n                          (formula.Since \\<phi>1 x2 \\<phi>2) j =\n                         Monitor.progress \\<sigma>'\n                          (formula.Since \\<phi>1 x2 \\<phi>2) j", "qed simp_all"], ["", "lemma Inf_UNIV_nat: \"(Inf UNIV :: nat) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf UNIV = 0", "by (simp add: cInf_eq_minimum)"], ["", "lemma progress_prefix_conv:\n  assumes \"prefix_of \\<pi> \\<sigma>\" and \"prefix_of \\<pi> \\<sigma>'\"\n  shows \"progress \\<sigma> \\<phi> (plen \\<pi>) = progress \\<sigma>' \\<phi> (plen \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) =\n    Monitor.progress \\<sigma>' \\<phi> (plen \\<pi>)", "using assms"], ["proof (prove)\nusing this:\n  prefix_of \\<pi> \\<sigma>\n  prefix_of \\<pi> \\<sigma>'\n\ngoal (1 subgoal):\n 1. Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) =\n    Monitor.progress \\<sigma>' \\<phi> (plen \\<pi>)", "by (auto intro: progress_time_conv \\<tau>_prefix_conv)"], ["", "lemma sat_prefix_conv:\n  assumes \"prefix_of \\<pi> \\<sigma>\" and \"prefix_of \\<pi> \\<sigma>'\" and \"i < progress \\<sigma> \\<phi> (plen \\<pi>)\"\n  shows \"MFOTL.sat \\<sigma> v i \\<phi> \\<longleftrightarrow> MFOTL.sat \\<sigma>' v i \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MFOTL.sat \\<sigma> v i \\<phi> = MFOTL.sat \\<sigma>' v i \\<phi>", "using assms(3)"], ["proof (prove)\nusing this:\n  i < Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)\n\ngoal (1 subgoal):\n 1. MFOTL.sat \\<sigma> v i \\<phi> = MFOTL.sat \\<sigma>' v i \\<phi>", "proof (induction \\<phi> arbitrary: v i)"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>x1 x2 v i.\n       i < Monitor.progress \\<sigma> (formula.Pred x1 x2)\n            (plen \\<pi>) \\<Longrightarrow>\n       MFOTL.sat \\<sigma> v i (formula.Pred x1 x2) =\n       MFOTL.sat \\<sigma>' v i (formula.Pred x1 x2)\n 2. \\<And>x1 x2 v i.\n       i < Monitor.progress \\<sigma> (formula.Eq x1 x2)\n            (plen \\<pi>) \\<Longrightarrow>\n       MFOTL.sat \\<sigma> v i (formula.Eq x1 x2) =\n       MFOTL.sat \\<sigma>' v i (formula.Eq x1 x2)\n 3. \\<And>\\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Neg \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Neg \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Neg \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Or \\<phi>1 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Or \\<phi>1 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Or \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Exists \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Exists \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Exists \\<phi>)\n 6. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Prev x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Prev x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Prev x1 \\<phi>)\n 7. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Next x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Next x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Next x1 \\<phi>)\n 8. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Since \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2)\n 9. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "case (Pred e ts)"], ["proof (state)\nthis:\n  i < Monitor.progress \\<sigma> (formula.Pred e ts) (plen \\<pi>)\n\ngoal (9 subgoals):\n 1. \\<And>x1 x2 v i.\n       i < Monitor.progress \\<sigma> (formula.Pred x1 x2)\n            (plen \\<pi>) \\<Longrightarrow>\n       MFOTL.sat \\<sigma> v i (formula.Pred x1 x2) =\n       MFOTL.sat \\<sigma>' v i (formula.Pred x1 x2)\n 2. \\<And>x1 x2 v i.\n       i < Monitor.progress \\<sigma> (formula.Eq x1 x2)\n            (plen \\<pi>) \\<Longrightarrow>\n       MFOTL.sat \\<sigma> v i (formula.Eq x1 x2) =\n       MFOTL.sat \\<sigma>' v i (formula.Eq x1 x2)\n 3. \\<And>\\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Neg \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Neg \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Neg \\<phi>)\n 4. \\<And>\\<phi>1 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Or \\<phi>1 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Or \\<phi>1 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Or \\<phi>1 \\<phi>2)\n 5. \\<And>\\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Exists \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Exists \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Exists \\<phi>)\n 6. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Prev x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Prev x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Prev x1 \\<phi>)\n 7. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Next x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Next x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Next x1 \\<phi>)\n 8. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Since \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2)\n 9. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "with \\<Gamma>_prefix_conv[OF assms(1,2)]"], ["proof (chain)\npicking this:\n  ?i < plen \\<pi> \\<Longrightarrow>\n  \\<Gamma> \\<sigma> ?i = \\<Gamma> \\<sigma>' ?i\n  i < Monitor.progress \\<sigma> (formula.Pred e ts) (plen \\<pi>)", "show ?case"], ["proof (prove)\nusing this:\n  ?i < plen \\<pi> \\<Longrightarrow>\n  \\<Gamma> \\<sigma> ?i = \\<Gamma> \\<sigma>' ?i\n  i < Monitor.progress \\<sigma> (formula.Pred e ts) (plen \\<pi>)\n\ngoal (1 subgoal):\n 1. MFOTL.sat \\<sigma> v i (formula.Pred e ts) =\n    MFOTL.sat \\<sigma>' v i (formula.Pred e ts)", "by simp"], ["proof (state)\nthis:\n  MFOTL.sat \\<sigma> v i (formula.Pred e ts) =\n  MFOTL.sat \\<sigma>' v i (formula.Pred e ts)\n\ngoal (8 subgoals):\n 1. \\<And>x1 x2 v i.\n       i < Monitor.progress \\<sigma> (formula.Eq x1 x2)\n            (plen \\<pi>) \\<Longrightarrow>\n       MFOTL.sat \\<sigma> v i (formula.Eq x1 x2) =\n       MFOTL.sat \\<sigma>' v i (formula.Eq x1 x2)\n 2. \\<And>\\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Neg \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Neg \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Neg \\<phi>)\n 3. \\<And>\\<phi>1 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Or \\<phi>1 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Or \\<phi>1 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Or \\<phi>1 \\<phi>2)\n 4. \\<And>\\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Exists \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Exists \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Exists \\<phi>)\n 5. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Prev x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Prev x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Prev x1 \\<phi>)\n 6. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Next x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Next x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Next x1 \\<phi>)\n 7. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Since \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2)\n 8. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x1 x2 v i.\n       i < Monitor.progress \\<sigma> (formula.Eq x1 x2)\n            (plen \\<pi>) \\<Longrightarrow>\n       MFOTL.sat \\<sigma> v i (formula.Eq x1 x2) =\n       MFOTL.sat \\<sigma>' v i (formula.Eq x1 x2)\n 2. \\<And>\\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Neg \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Neg \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Neg \\<phi>)\n 3. \\<And>\\<phi>1 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Or \\<phi>1 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Or \\<phi>1 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Or \\<phi>1 \\<phi>2)\n 4. \\<And>\\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Exists \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Exists \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Exists \\<phi>)\n 5. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Prev x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Prev x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Prev x1 \\<phi>)\n 6. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Next x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Next x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Next x1 \\<phi>)\n 7. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Since \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2)\n 8. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "case (Eq t1 t2)"], ["proof (state)\nthis:\n  i < Monitor.progress \\<sigma> (formula.Eq t1 t2) (plen \\<pi>)\n\ngoal (8 subgoals):\n 1. \\<And>x1 x2 v i.\n       i < Monitor.progress \\<sigma> (formula.Eq x1 x2)\n            (plen \\<pi>) \\<Longrightarrow>\n       MFOTL.sat \\<sigma> v i (formula.Eq x1 x2) =\n       MFOTL.sat \\<sigma>' v i (formula.Eq x1 x2)\n 2. \\<And>\\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Neg \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Neg \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Neg \\<phi>)\n 3. \\<And>\\<phi>1 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Or \\<phi>1 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Or \\<phi>1 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Or \\<phi>1 \\<phi>2)\n 4. \\<And>\\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Exists \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Exists \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Exists \\<phi>)\n 5. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Prev x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Prev x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Prev x1 \\<phi>)\n 6. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Next x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Next x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Next x1 \\<phi>)\n 7. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Since \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2)\n 8. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. MFOTL.sat \\<sigma> v i (formula.Eq t1 t2) =\n    MFOTL.sat \\<sigma>' v i (formula.Eq t1 t2)", "by simp"], ["proof (state)\nthis:\n  MFOTL.sat \\<sigma> v i (formula.Eq t1 t2) =\n  MFOTL.sat \\<sigma>' v i (formula.Eq t1 t2)\n\ngoal (7 subgoals):\n 1. \\<And>\\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Neg \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Neg \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Neg \\<phi>)\n 2. \\<And>\\<phi>1 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Or \\<phi>1 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Or \\<phi>1 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Or \\<phi>1 \\<phi>2)\n 3. \\<And>\\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Exists \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Exists \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Exists \\<phi>)\n 4. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Prev x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Prev x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Prev x1 \\<phi>)\n 5. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Next x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Next x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Next x1 \\<phi>)\n 6. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Since \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2)\n 7. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>\\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Neg \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Neg \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Neg \\<phi>)\n 2. \\<And>\\<phi>1 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Or \\<phi>1 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Or \\<phi>1 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Or \\<phi>1 \\<phi>2)\n 3. \\<And>\\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Exists \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Exists \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Exists \\<phi>)\n 4. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Prev x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Prev x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Prev x1 \\<phi>)\n 5. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Next x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Next x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Next x1 \\<phi>)\n 6. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Since \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2)\n 7. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "case (Neg \\<phi>)"], ["proof (state)\nthis:\n  ?i < Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi> = MFOTL.sat \\<sigma>' ?v ?i \\<phi>\n  i < Monitor.progress \\<sigma> (formula.Neg \\<phi>) (plen \\<pi>)\n\ngoal (7 subgoals):\n 1. \\<And>\\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Neg \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Neg \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Neg \\<phi>)\n 2. \\<And>\\<phi>1 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Or \\<phi>1 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Or \\<phi>1 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Or \\<phi>1 \\<phi>2)\n 3. \\<And>\\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Exists \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Exists \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Exists \\<phi>)\n 4. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Prev x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Prev x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Prev x1 \\<phi>)\n 5. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Next x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Next x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Next x1 \\<phi>)\n 6. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Since \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2)\n 7. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "then"], ["proof (chain)\npicking this:\n  ?i < Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi> = MFOTL.sat \\<sigma>' ?v ?i \\<phi>\n  i < Monitor.progress \\<sigma> (formula.Neg \\<phi>) (plen \\<pi>)", "show ?case"], ["proof (prove)\nusing this:\n  ?i < Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi> = MFOTL.sat \\<sigma>' ?v ?i \\<phi>\n  i < Monitor.progress \\<sigma> (formula.Neg \\<phi>) (plen \\<pi>)\n\ngoal (1 subgoal):\n 1. MFOTL.sat \\<sigma> v i (formula.Neg \\<phi>) =\n    MFOTL.sat \\<sigma>' v i (formula.Neg \\<phi>)", "by simp"], ["proof (state)\nthis:\n  MFOTL.sat \\<sigma> v i (formula.Neg \\<phi>) =\n  MFOTL.sat \\<sigma>' v i (formula.Neg \\<phi>)\n\ngoal (6 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Or \\<phi>1 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Or \\<phi>1 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Or \\<phi>1 \\<phi>2)\n 2. \\<And>\\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Exists \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Exists \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Exists \\<phi>)\n 3. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Prev x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Prev x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Prev x1 \\<phi>)\n 4. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Next x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Next x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Next x1 \\<phi>)\n 5. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Since \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2)\n 6. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Or \\<phi>1 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Or \\<phi>1 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Or \\<phi>1 \\<phi>2)\n 2. \\<And>\\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Exists \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Exists \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Exists \\<phi>)\n 3. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Prev x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Prev x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Prev x1 \\<phi>)\n 4. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Next x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Next x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Next x1 \\<phi>)\n 5. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Since \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2)\n 6. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "case (Or \\<phi>1 \\<phi>2)"], ["proof (state)\nthis:\n  ?i < Monitor.progress \\<sigma> \\<phi>1 (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi>1 = MFOTL.sat \\<sigma>' ?v ?i \\<phi>1\n  ?i < Monitor.progress \\<sigma> \\<phi>2 (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi>2 = MFOTL.sat \\<sigma>' ?v ?i \\<phi>2\n  i < Monitor.progress \\<sigma> (formula.Or \\<phi>1 \\<phi>2) (plen \\<pi>)\n\ngoal (6 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Or \\<phi>1 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Or \\<phi>1 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Or \\<phi>1 \\<phi>2)\n 2. \\<And>\\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Exists \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Exists \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Exists \\<phi>)\n 3. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Prev x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Prev x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Prev x1 \\<phi>)\n 4. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Next x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Next x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Next x1 \\<phi>)\n 5. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Since \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2)\n 6. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "then"], ["proof (chain)\npicking this:\n  ?i < Monitor.progress \\<sigma> \\<phi>1 (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi>1 = MFOTL.sat \\<sigma>' ?v ?i \\<phi>1\n  ?i < Monitor.progress \\<sigma> \\<phi>2 (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi>2 = MFOTL.sat \\<sigma>' ?v ?i \\<phi>2\n  i < Monitor.progress \\<sigma> (formula.Or \\<phi>1 \\<phi>2) (plen \\<pi>)", "show ?case"], ["proof (prove)\nusing this:\n  ?i < Monitor.progress \\<sigma> \\<phi>1 (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi>1 = MFOTL.sat \\<sigma>' ?v ?i \\<phi>1\n  ?i < Monitor.progress \\<sigma> \\<phi>2 (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi>2 = MFOTL.sat \\<sigma>' ?v ?i \\<phi>2\n  i < Monitor.progress \\<sigma> (formula.Or \\<phi>1 \\<phi>2) (plen \\<pi>)\n\ngoal (1 subgoal):\n 1. MFOTL.sat \\<sigma> v i (formula.Or \\<phi>1 \\<phi>2) =\n    MFOTL.sat \\<sigma>' v i (formula.Or \\<phi>1 \\<phi>2)", "by simp"], ["proof (state)\nthis:\n  MFOTL.sat \\<sigma> v i (formula.Or \\<phi>1 \\<phi>2) =\n  MFOTL.sat \\<sigma>' v i (formula.Or \\<phi>1 \\<phi>2)\n\ngoal (5 subgoals):\n 1. \\<And>\\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Exists \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Exists \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Exists \\<phi>)\n 2. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Prev x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Prev x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Prev x1 \\<phi>)\n 3. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Next x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Next x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Next x1 \\<phi>)\n 4. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Since \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2)\n 5. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Exists \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Exists \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Exists \\<phi>)\n 2. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Prev x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Prev x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Prev x1 \\<phi>)\n 3. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Next x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Next x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Next x1 \\<phi>)\n 4. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Since \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2)\n 5. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "case (Exists \\<phi>)"], ["proof (state)\nthis:\n  ?i < Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi> = MFOTL.sat \\<sigma>' ?v ?i \\<phi>\n  i < Monitor.progress \\<sigma> (formula.Exists \\<phi>) (plen \\<pi>)\n\ngoal (5 subgoals):\n 1. \\<And>\\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Exists \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Exists \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Exists \\<phi>)\n 2. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Prev x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Prev x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Prev x1 \\<phi>)\n 3. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Next x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Next x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Next x1 \\<phi>)\n 4. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Since \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2)\n 5. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "then"], ["proof (chain)\npicking this:\n  ?i < Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi> = MFOTL.sat \\<sigma>' ?v ?i \\<phi>\n  i < Monitor.progress \\<sigma> (formula.Exists \\<phi>) (plen \\<pi>)", "show ?case"], ["proof (prove)\nusing this:\n  ?i < Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi> = MFOTL.sat \\<sigma>' ?v ?i \\<phi>\n  i < Monitor.progress \\<sigma> (formula.Exists \\<phi>) (plen \\<pi>)\n\ngoal (1 subgoal):\n 1. MFOTL.sat \\<sigma> v i (formula.Exists \\<phi>) =\n    MFOTL.sat \\<sigma>' v i (formula.Exists \\<phi>)", "by simp"], ["proof (state)\nthis:\n  MFOTL.sat \\<sigma> v i (formula.Exists \\<phi>) =\n  MFOTL.sat \\<sigma>' v i (formula.Exists \\<phi>)\n\ngoal (4 subgoals):\n 1. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Prev x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Prev x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Prev x1 \\<phi>)\n 2. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Next x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Next x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Next x1 \\<phi>)\n 3. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Since \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2)\n 4. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Prev x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Prev x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Prev x1 \\<phi>)\n 2. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Next x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Next x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Next x1 \\<phi>)\n 3. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Since \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2)\n 4. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "case (Prev I \\<phi>)"], ["proof (state)\nthis:\n  ?i < Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi> = MFOTL.sat \\<sigma>' ?v ?i \\<phi>\n  i < Monitor.progress \\<sigma> (formula.Prev I \\<phi>) (plen \\<pi>)\n\ngoal (4 subgoals):\n 1. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Prev x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Prev x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Prev x1 \\<phi>)\n 2. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Next x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Next x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Next x1 \\<phi>)\n 3. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Since \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2)\n 4. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "with \\<tau>_prefix_conv[OF assms(1,2)]"], ["proof (chain)\npicking this:\n  ?i < plen \\<pi> \\<Longrightarrow> \\<tau> \\<sigma> ?i = \\<tau> \\<sigma>' ?i\n  ?i < Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi> = MFOTL.sat \\<sigma>' ?v ?i \\<phi>\n  i < Monitor.progress \\<sigma> (formula.Prev I \\<phi>) (plen \\<pi>)", "show ?case"], ["proof (prove)\nusing this:\n  ?i < plen \\<pi> \\<Longrightarrow> \\<tau> \\<sigma> ?i = \\<tau> \\<sigma>' ?i\n  ?i < Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi> = MFOTL.sat \\<sigma>' ?v ?i \\<phi>\n  i < Monitor.progress \\<sigma> (formula.Prev I \\<phi>) (plen \\<pi>)\n\ngoal (1 subgoal):\n 1. MFOTL.sat \\<sigma> v i (formula.Prev I \\<phi>) =\n    MFOTL.sat \\<sigma>' v i (formula.Prev I \\<phi>)", "by (cases i) (auto split: if_splits)"], ["proof (state)\nthis:\n  MFOTL.sat \\<sigma> v i (formula.Prev I \\<phi>) =\n  MFOTL.sat \\<sigma>' v i (formula.Prev I \\<phi>)\n\ngoal (3 subgoals):\n 1. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Next x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Next x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Next x1 \\<phi>)\n 2. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Since \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2)\n 3. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Next x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Next x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Next x1 \\<phi>)\n 2. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Since \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2)\n 3. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "case (Next I \\<phi>)"], ["proof (state)\nthis:\n  ?i < Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi> = MFOTL.sat \\<sigma>' ?v ?i \\<phi>\n  i < Monitor.progress \\<sigma> (formula.Next I \\<phi>) (plen \\<pi>)\n\ngoal (3 subgoals):\n 1. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Next x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Next x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Next x1 \\<phi>)\n 2. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Since \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2)\n 3. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "then"], ["proof (chain)\npicking this:\n  ?i < Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi> = MFOTL.sat \\<sigma>' ?v ?i \\<phi>\n  i < Monitor.progress \\<sigma> (formula.Next I \\<phi>) (plen \\<pi>)", "have \"Suc i < plen \\<pi>\""], ["proof (prove)\nusing this:\n  ?i < Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi> = MFOTL.sat \\<sigma>' ?v ?i \\<phi>\n  i < Monitor.progress \\<sigma> (formula.Next I \\<phi>) (plen \\<pi>)\n\ngoal (1 subgoal):\n 1. Suc i < plen \\<pi>", "by (auto intro: order.strict_trans2[OF _ progress_le[of \\<sigma> \\<phi>]])"], ["proof (state)\nthis:\n  Suc i < plen \\<pi>\n\ngoal (3 subgoals):\n 1. \\<And>x1 \\<phi> v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi> =\n                   MFOTL.sat \\<sigma>' v i \\<phi>;\n        i < Monitor.progress \\<sigma> (formula.Next x1 \\<phi>)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i (formula.Next x1 \\<phi>) =\n                         MFOTL.sat \\<sigma>' v i (formula.Next x1 \\<phi>)\n 2. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Since \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2)\n 3. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "with Next \\<tau>_prefix_conv[OF assms(1,2)]"], ["proof (chain)\npicking this:\n  ?i < Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi> = MFOTL.sat \\<sigma>' ?v ?i \\<phi>\n  i < Monitor.progress \\<sigma> (formula.Next I \\<phi>) (plen \\<pi>)\n  ?i < plen \\<pi> \\<Longrightarrow> \\<tau> \\<sigma> ?i = \\<tau> \\<sigma>' ?i\n  Suc i < plen \\<pi>", "show ?case"], ["proof (prove)\nusing this:\n  ?i < Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi> = MFOTL.sat \\<sigma>' ?v ?i \\<phi>\n  i < Monitor.progress \\<sigma> (formula.Next I \\<phi>) (plen \\<pi>)\n  ?i < plen \\<pi> \\<Longrightarrow> \\<tau> \\<sigma> ?i = \\<tau> \\<sigma>' ?i\n  Suc i < plen \\<pi>\n\ngoal (1 subgoal):\n 1. MFOTL.sat \\<sigma> v i (formula.Next I \\<phi>) =\n    MFOTL.sat \\<sigma>' v i (formula.Next I \\<phi>)", "by simp"], ["proof (state)\nthis:\n  MFOTL.sat \\<sigma> v i (formula.Next I \\<phi>) =\n  MFOTL.sat \\<sigma>' v i (formula.Next I \\<phi>)\n\ngoal (2 subgoals):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Since \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2)\n 2. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Since \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2)\n 2. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "case (Since \\<phi>1 I \\<phi>2)"], ["proof (state)\nthis:\n  ?i < Monitor.progress \\<sigma> \\<phi>1 (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi>1 = MFOTL.sat \\<sigma>' ?v ?i \\<phi>1\n  ?i < Monitor.progress \\<sigma> \\<phi>2 (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi>2 = MFOTL.sat \\<sigma>' ?v ?i \\<phi>2\n  i < Monitor.progress \\<sigma> (formula.Since \\<phi>1 I \\<phi>2)\n       (plen \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Since \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2)\n 2. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "then"], ["proof (chain)\npicking this:\n  ?i < Monitor.progress \\<sigma> \\<phi>1 (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi>1 = MFOTL.sat \\<sigma>' ?v ?i \\<phi>1\n  ?i < Monitor.progress \\<sigma> \\<phi>2 (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi>2 = MFOTL.sat \\<sigma>' ?v ?i \\<phi>2\n  i < Monitor.progress \\<sigma> (formula.Since \\<phi>1 I \\<phi>2)\n       (plen \\<pi>)", "have \"i < plen \\<pi>\""], ["proof (prove)\nusing this:\n  ?i < Monitor.progress \\<sigma> \\<phi>1 (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi>1 = MFOTL.sat \\<sigma>' ?v ?i \\<phi>1\n  ?i < Monitor.progress \\<sigma> \\<phi>2 (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi>2 = MFOTL.sat \\<sigma>' ?v ?i \\<phi>2\n  i < Monitor.progress \\<sigma> (formula.Since \\<phi>1 I \\<phi>2)\n       (plen \\<pi>)\n\ngoal (1 subgoal):\n 1. i < plen \\<pi>", "by (auto elim!: order.strict_trans2[OF _ progress_le])"], ["proof (state)\nthis:\n  i < plen \\<pi>\n\ngoal (2 subgoals):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Since \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Since \\<phi>1 x2 \\<phi>2)\n 2. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "with Since \\<tau>_prefix_conv[OF assms(1,2)]"], ["proof (chain)\npicking this:\n  ?i < Monitor.progress \\<sigma> \\<phi>1 (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi>1 = MFOTL.sat \\<sigma>' ?v ?i \\<phi>1\n  ?i < Monitor.progress \\<sigma> \\<phi>2 (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi>2 = MFOTL.sat \\<sigma>' ?v ?i \\<phi>2\n  i < Monitor.progress \\<sigma> (formula.Since \\<phi>1 I \\<phi>2)\n       (plen \\<pi>)\n  ?i < plen \\<pi> \\<Longrightarrow> \\<tau> \\<sigma> ?i = \\<tau> \\<sigma>' ?i\n  i < plen \\<pi>", "show ?case"], ["proof (prove)\nusing this:\n  ?i < Monitor.progress \\<sigma> \\<phi>1 (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi>1 = MFOTL.sat \\<sigma>' ?v ?i \\<phi>1\n  ?i < Monitor.progress \\<sigma> \\<phi>2 (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi>2 = MFOTL.sat \\<sigma>' ?v ?i \\<phi>2\n  i < Monitor.progress \\<sigma> (formula.Since \\<phi>1 I \\<phi>2)\n       (plen \\<pi>)\n  ?i < plen \\<pi> \\<Longrightarrow> \\<tau> \\<sigma> ?i = \\<tau> \\<sigma>' ?i\n  i < plen \\<pi>\n\ngoal (1 subgoal):\n 1. MFOTL.sat \\<sigma> v i (formula.Since \\<phi>1 I \\<phi>2) =\n    MFOTL.sat \\<sigma>' v i (formula.Since \\<phi>1 I \\<phi>2)", "by auto"], ["proof (state)\nthis:\n  MFOTL.sat \\<sigma> v i (formula.Since \\<phi>1 I \\<phi>2) =\n  MFOTL.sat \\<sigma>' v i (formula.Since \\<phi>1 I \\<phi>2)\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "case (Until \\<phi>1 I \\<phi>2)"], ["proof (state)\nthis:\n  ?i < Monitor.progress \\<sigma> \\<phi>1 (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi>1 = MFOTL.sat \\<sigma>' ?v ?i \\<phi>1\n  ?i < Monitor.progress \\<sigma> \\<phi>2 (plen \\<pi>) \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi>2 = MFOTL.sat \\<sigma>' ?v ?i \\<phi>2\n  i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 I \\<phi>2)\n       (plen \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "from Until.prems"], ["proof (chain)\npicking this:\n  i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 I \\<phi>2)\n       (plen \\<pi>)", "obtain b where [simp]: \"right I = enat b\""], ["proof (prove)\nusing this:\n  i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 I \\<phi>2)\n       (plen \\<pi>)\n\ngoal (1 subgoal):\n 1. (\\<And>b. right I = enat b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"right I\") (auto simp add: Inf_UNIV_nat)"], ["proof (state)\nthis:\n  right I = enat b\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "from Until.prems"], ["proof (chain)\npicking this:\n  i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 I \\<phi>2)\n       (plen \\<pi>)", "obtain j where \"\\<tau> \\<sigma> i + b + 1 \\<le> \\<tau> \\<sigma> j\"\n    \"j \\<le> progress \\<sigma> \\<phi>1 (plen \\<pi>)\" \"j \\<le> progress \\<sigma> \\<phi>2 (plen \\<pi>)\""], ["proof (prove)\nusing this:\n  i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 I \\<phi>2)\n       (plen \\<pi>)\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>\\<tau> \\<sigma> i + b + 1 \\<le> \\<tau> \\<sigma> j;\n         j \\<le> Monitor.progress \\<sigma> \\<phi>1 (plen \\<pi>);\n         j \\<le> Monitor.progress \\<sigma> \\<phi>2 (plen \\<pi>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim (auto 0 4 simp add: less_eq_Suc_le not_le intro: Suc_leI dest: spec[of _ \"i\"]\n      dest!: le_cInf_iff[THEN iffD1, rotated -1])"], ["proof (state)\nthis:\n  \\<tau> \\<sigma> i + b + 1 \\<le> \\<tau> \\<sigma> j\n  j \\<le> Monitor.progress \\<sigma> \\<phi>1 (plen \\<pi>)\n  j \\<le> Monitor.progress \\<sigma> \\<phi>2 (plen \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "then"], ["proof (chain)\npicking this:\n  \\<tau> \\<sigma> i + b + 1 \\<le> \\<tau> \\<sigma> j\n  j \\<le> Monitor.progress \\<sigma> \\<phi>1 (plen \\<pi>)\n  j \\<le> Monitor.progress \\<sigma> \\<phi>2 (plen \\<pi>)", "have 1: \"k < progress \\<sigma> \\<phi>1 (plen \\<pi>)\" and 2: \"k < progress \\<sigma> \\<phi>2 (plen \\<pi>)\"\n    if \"\\<tau> \\<sigma> k \\<le> \\<tau> \\<sigma> i + b\" for k"], ["proof (prove)\nusing this:\n  \\<tau> \\<sigma> i + b + 1 \\<le> \\<tau> \\<sigma> j\n  j \\<le> Monitor.progress \\<sigma> \\<phi>1 (plen \\<pi>)\n  j \\<le> Monitor.progress \\<sigma> \\<phi>2 (plen \\<pi>)\n\ngoal (1 subgoal):\n 1. k < Monitor.progress \\<sigma> \\<phi>1 (plen \\<pi>) &&&\n    k < Monitor.progress \\<sigma> \\<phi>2 (plen \\<pi>)", "using that"], ["proof (prove)\nusing this:\n  \\<tau> \\<sigma> i + b + 1 \\<le> \\<tau> \\<sigma> j\n  j \\<le> Monitor.progress \\<sigma> \\<phi>1 (plen \\<pi>)\n  j \\<le> Monitor.progress \\<sigma> \\<phi>2 (plen \\<pi>)\n  \\<tau> \\<sigma> k \\<le> \\<tau> \\<sigma> i + b\n\ngoal (1 subgoal):\n 1. k < Monitor.progress \\<sigma> \\<phi>1 (plen \\<pi>) &&&\n    k < Monitor.progress \\<sigma> \\<phi>2 (plen \\<pi>)", "by (fastforce elim!: order.strict_trans2[rotated] intro: less_\\<tau>D[of \\<sigma>])+"], ["proof (state)\nthis:\n  \\<tau> \\<sigma> ?k \\<le> \\<tau> \\<sigma> i + b \\<Longrightarrow>\n  ?k < Monitor.progress \\<sigma> \\<phi>1 (plen \\<pi>)\n  \\<tau> \\<sigma> ?k \\<le> \\<tau> \\<sigma> i + b \\<Longrightarrow>\n  ?k < Monitor.progress \\<sigma> \\<phi>2 (plen \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "have 3: \"k < plen \\<pi>\" if \"\\<tau> \\<sigma> k \\<le> \\<tau> \\<sigma> i + b\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < plen \\<pi>", "using 1[OF that]"], ["proof (prove)\nusing this:\n  k < Monitor.progress \\<sigma> \\<phi>1 (plen \\<pi>)\n\ngoal (1 subgoal):\n 1. k < plen \\<pi>", "by (simp add: less_eq_Suc_le order.trans[OF _ progress_le])"], ["proof (state)\nthis:\n  \\<tau> \\<sigma> ?k \\<le> \\<tau> \\<sigma> i + b \\<Longrightarrow>\n  ?k < plen \\<pi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "from Until.prems"], ["proof (chain)\npicking this:\n  i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 I \\<phi>2)\n       (plen \\<pi>)", "have \"i < progress \\<sigma>' (MFOTL.Until \\<phi>1 I \\<phi>2) (plen \\<pi>)\""], ["proof (prove)\nusing this:\n  i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 I \\<phi>2)\n       (plen \\<pi>)\n\ngoal (1 subgoal):\n 1. i < Monitor.progress \\<sigma>' (formula.Until \\<phi>1 I \\<phi>2)\n         (plen \\<pi>)", "unfolding progress_prefix_conv[OF assms(1,2)]"], ["proof (prove)\nusing this:\n  i < Monitor.progress \\<sigma>' (formula.Until \\<phi>1 I \\<phi>2)\n       (plen \\<pi>)\n\ngoal (1 subgoal):\n 1. i < Monitor.progress \\<sigma>' (formula.Until \\<phi>1 I \\<phi>2)\n         (plen \\<pi>)", "."], ["proof (state)\nthis:\n  i < Monitor.progress \\<sigma>' (formula.Until \\<phi>1 I \\<phi>2)\n       (plen \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "then"], ["proof (chain)\npicking this:\n  i < Monitor.progress \\<sigma>' (formula.Until \\<phi>1 I \\<phi>2)\n       (plen \\<pi>)", "obtain j where \"\\<tau> \\<sigma>' i + b + 1 \\<le> \\<tau> \\<sigma>' j\"\n    \"j \\<le> progress \\<sigma>' \\<phi>1 (plen \\<pi>)\" \"j \\<le> progress \\<sigma>' \\<phi>2 (plen \\<pi>)\""], ["proof (prove)\nusing this:\n  i < Monitor.progress \\<sigma>' (formula.Until \\<phi>1 I \\<phi>2)\n       (plen \\<pi>)\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>\\<tau> \\<sigma>' i + b + 1 \\<le> \\<tau> \\<sigma>' j;\n         j \\<le> Monitor.progress \\<sigma>' \\<phi>1 (plen \\<pi>);\n         j \\<le> Monitor.progress \\<sigma>' \\<phi>2 (plen \\<pi>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim (auto 0 4 simp add: less_eq_Suc_le not_le intro: Suc_leI dest: spec[of _ \"i\"]\n      dest!: le_cInf_iff[THEN iffD1, rotated -1])"], ["proof (state)\nthis:\n  \\<tau> \\<sigma>' i + b + 1 \\<le> \\<tau> \\<sigma>' j\n  j \\<le> Monitor.progress \\<sigma>' \\<phi>1 (plen \\<pi>)\n  j \\<le> Monitor.progress \\<sigma>' \\<phi>2 (plen \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "then"], ["proof (chain)\npicking this:\n  \\<tau> \\<sigma>' i + b + 1 \\<le> \\<tau> \\<sigma>' j\n  j \\<le> Monitor.progress \\<sigma>' \\<phi>1 (plen \\<pi>)\n  j \\<le> Monitor.progress \\<sigma>' \\<phi>2 (plen \\<pi>)", "have 11: \"k < progress \\<sigma> \\<phi>1 (plen \\<pi>)\" and 21: \"k < progress \\<sigma> \\<phi>2 (plen \\<pi>)\"\n    if \"\\<tau> \\<sigma>' k \\<le> \\<tau> \\<sigma>' i + b\" for k"], ["proof (prove)\nusing this:\n  \\<tau> \\<sigma>' i + b + 1 \\<le> \\<tau> \\<sigma>' j\n  j \\<le> Monitor.progress \\<sigma>' \\<phi>1 (plen \\<pi>)\n  j \\<le> Monitor.progress \\<sigma>' \\<phi>2 (plen \\<pi>)\n\ngoal (1 subgoal):\n 1. k < Monitor.progress \\<sigma> \\<phi>1 (plen \\<pi>) &&&\n    k < Monitor.progress \\<sigma> \\<phi>2 (plen \\<pi>)", "unfolding progress_prefix_conv[OF assms(1,2)]"], ["proof (prove)\nusing this:\n  \\<tau> \\<sigma>' i + b + 1 \\<le> \\<tau> \\<sigma>' j\n  j \\<le> Monitor.progress \\<sigma>' \\<phi>1 (plen \\<pi>)\n  j \\<le> Monitor.progress \\<sigma>' \\<phi>2 (plen \\<pi>)\n\ngoal (1 subgoal):\n 1. k < Monitor.progress \\<sigma>' \\<phi>1 (plen \\<pi>) &&&\n    k < Monitor.progress \\<sigma>' \\<phi>2 (plen \\<pi>)", "using that"], ["proof (prove)\nusing this:\n  \\<tau> \\<sigma>' i + b + 1 \\<le> \\<tau> \\<sigma>' j\n  j \\<le> Monitor.progress \\<sigma>' \\<phi>1 (plen \\<pi>)\n  j \\<le> Monitor.progress \\<sigma>' \\<phi>2 (plen \\<pi>)\n  \\<tau> \\<sigma>' k \\<le> \\<tau> \\<sigma>' i + b\n\ngoal (1 subgoal):\n 1. k < Monitor.progress \\<sigma>' \\<phi>1 (plen \\<pi>) &&&\n    k < Monitor.progress \\<sigma>' \\<phi>2 (plen \\<pi>)", "by (fastforce elim!: order.strict_trans2[rotated] intro: less_\\<tau>D[of \\<sigma>'])+"], ["proof (state)\nthis:\n  \\<tau> \\<sigma>' ?k \\<le> \\<tau> \\<sigma>' i + b \\<Longrightarrow>\n  ?k < Monitor.progress \\<sigma> \\<phi>1 (plen \\<pi>)\n  \\<tau> \\<sigma>' ?k \\<le> \\<tau> \\<sigma>' i + b \\<Longrightarrow>\n  ?k < Monitor.progress \\<sigma> \\<phi>2 (plen \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "have 31: \"k < plen \\<pi>\" if \"\\<tau> \\<sigma>' k \\<le> \\<tau> \\<sigma>' i + b\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < plen \\<pi>", "using 11[OF that]"], ["proof (prove)\nusing this:\n  k < Monitor.progress \\<sigma> \\<phi>1 (plen \\<pi>)\n\ngoal (1 subgoal):\n 1. k < plen \\<pi>", "by (simp add: less_eq_Suc_le order.trans[OF _ progress_le])"], ["proof (state)\nthis:\n  \\<tau> \\<sigma>' ?k \\<le> \\<tau> \\<sigma>' i + b \\<Longrightarrow>\n  ?k < plen \\<pi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 v i.\n       \\<lbrakk>\\<And>v i.\n                   i < Monitor.progress \\<sigma> \\<phi>1\n                        (plen \\<pi>) \\<Longrightarrow>\n                   MFOTL.sat \\<sigma> v i \\<phi>1 =\n                   MFOTL.sat \\<sigma>' v i \\<phi>1;\n        \\<And>v i.\n           i < Monitor.progress \\<sigma> \\<phi>2\n                (plen \\<pi>) \\<Longrightarrow>\n           MFOTL.sat \\<sigma> v i \\<phi>2 = MFOTL.sat \\<sigma>' v i \\<phi>2;\n        i < Monitor.progress \\<sigma> (formula.Until \\<phi>1 x2 \\<phi>2)\n             (plen \\<pi>)\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2) =\n                         MFOTL.sat \\<sigma>' v i\n                          (formula.Until \\<phi>1 x2 \\<phi>2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. MFOTL.sat \\<sigma> v i (formula.Until \\<phi>1 I \\<phi>2) =\n    MFOTL.sat \\<sigma>' v i (formula.Until \\<phi>1 I \\<phi>2)", "unfolding sat.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>j\\<ge>i.\n        mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and>\n        MFOTL.sat \\<sigma> v j \\<phi>2 \\<and>\n        (\\<forall>k\\<in>{i..<j}. MFOTL.sat \\<sigma> v k \\<phi>1)) =\n    (\\<exists>j\\<ge>i.\n        mem (\\<tau> \\<sigma>' j - \\<tau> \\<sigma>' i) I \\<and>\n        MFOTL.sat \\<sigma>' v j \\<phi>2 \\<and>\n        (\\<forall>k\\<in>{i..<j}. MFOTL.sat \\<sigma>' v k \\<phi>1))", "proof ((intro ex_cong iffI; elim conjE), goal_cases LR RL)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>i \\<le> j;\n        left I \\<le> \\<tau> \\<sigma> j - \\<tau> \\<sigma> i;\n        enat (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) \\<le> right I;\n        MFOTL.sat \\<sigma> v j \\<phi>2;\n        \\<forall>k\\<in>{i..<j}. MFOTL.sat \\<sigma> v k \\<phi>1\\<rbrakk>\n       \\<Longrightarrow> mem (\\<tau> \\<sigma>' j - \\<tau> \\<sigma>' i)\n                          I \\<and>\n                         MFOTL.sat \\<sigma>' v j \\<phi>2 \\<and>\n                         (\\<forall>k\\<in>{i..<j}.\n                             MFOTL.sat \\<sigma>' v k \\<phi>1)\n 2. \\<And>j.\n       \\<lbrakk>i \\<le> j;\n        left I \\<le> \\<tau> \\<sigma>' j - \\<tau> \\<sigma>' i;\n        enat (\\<tau> \\<sigma>' j - \\<tau> \\<sigma>' i) \\<le> right I;\n        MFOTL.sat \\<sigma>' v j \\<phi>2;\n        \\<forall>k\\<in>{i..<j}. MFOTL.sat \\<sigma>' v k \\<phi>1\\<rbrakk>\n       \\<Longrightarrow> mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i)\n                          I \\<and>\n                         MFOTL.sat \\<sigma> v j \\<phi>2 \\<and>\n                         (\\<forall>k\\<in>{i..<j}.\n                             MFOTL.sat \\<sigma> v k \\<phi>1)", "case (LR j)"], ["proof (state)\nthis:\n  i \\<le> j\n  left I \\<le> \\<tau> \\<sigma> j - \\<tau> \\<sigma> i\n  enat (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) \\<le> right I\n  MFOTL.sat \\<sigma> v j \\<phi>2\n  \\<forall>k\\<in>{i..<j}. MFOTL.sat \\<sigma> v k \\<phi>1\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>i \\<le> j;\n        left I \\<le> \\<tau> \\<sigma> j - \\<tau> \\<sigma> i;\n        enat (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) \\<le> right I;\n        MFOTL.sat \\<sigma> v j \\<phi>2;\n        \\<forall>k\\<in>{i..<j}. MFOTL.sat \\<sigma> v k \\<phi>1\\<rbrakk>\n       \\<Longrightarrow> mem (\\<tau> \\<sigma>' j - \\<tau> \\<sigma>' i)\n                          I \\<and>\n                         MFOTL.sat \\<sigma>' v j \\<phi>2 \\<and>\n                         (\\<forall>k\\<in>{i..<j}.\n                             MFOTL.sat \\<sigma>' v k \\<phi>1)\n 2. \\<And>j.\n       \\<lbrakk>i \\<le> j;\n        left I \\<le> \\<tau> \\<sigma>' j - \\<tau> \\<sigma>' i;\n        enat (\\<tau> \\<sigma>' j - \\<tau> \\<sigma>' i) \\<le> right I;\n        MFOTL.sat \\<sigma>' v j \\<phi>2;\n        \\<forall>k\\<in>{i..<j}. MFOTL.sat \\<sigma>' v k \\<phi>1\\<rbrakk>\n       \\<Longrightarrow> mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i)\n                          I \\<and>\n                         MFOTL.sat \\<sigma> v j \\<phi>2 \\<and>\n                         (\\<forall>k\\<in>{i..<j}.\n                             MFOTL.sat \\<sigma> v k \\<phi>1)", "with Until.IH(1)[OF 1] Until.IH(2)[OF 2] \\<tau>_prefix_conv[OF assms(1,2) 3]"], ["proof (chain)\npicking this:\n  \\<tau> \\<sigma> ?i \\<le> \\<tau> \\<sigma> i + b \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi>1 = MFOTL.sat \\<sigma>' ?v ?i \\<phi>1\n  \\<tau> \\<sigma> ?i \\<le> \\<tau> \\<sigma> i + b \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi>2 = MFOTL.sat \\<sigma>' ?v ?i \\<phi>2\n  \\<tau> \\<sigma> ?i \\<le> \\<tau> \\<sigma> i + b \\<Longrightarrow>\n  \\<tau> \\<sigma> ?i = \\<tau> \\<sigma>' ?i\n  i \\<le> j\n  left I \\<le> \\<tau> \\<sigma> j - \\<tau> \\<sigma> i\n  enat (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) \\<le> right I\n  MFOTL.sat \\<sigma> v j \\<phi>2\n  \\<forall>k\\<in>{i..<j}. MFOTL.sat \\<sigma> v k \\<phi>1", "show ?case"], ["proof (prove)\nusing this:\n  \\<tau> \\<sigma> ?i \\<le> \\<tau> \\<sigma> i + b \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi>1 = MFOTL.sat \\<sigma>' ?v ?i \\<phi>1\n  \\<tau> \\<sigma> ?i \\<le> \\<tau> \\<sigma> i + b \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi>2 = MFOTL.sat \\<sigma>' ?v ?i \\<phi>2\n  \\<tau> \\<sigma> ?i \\<le> \\<tau> \\<sigma> i + b \\<Longrightarrow>\n  \\<tau> \\<sigma> ?i = \\<tau> \\<sigma>' ?i\n  i \\<le> j\n  left I \\<le> \\<tau> \\<sigma> j - \\<tau> \\<sigma> i\n  enat (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) \\<le> right I\n  MFOTL.sat \\<sigma> v j \\<phi>2\n  \\<forall>k\\<in>{i..<j}. MFOTL.sat \\<sigma> v k \\<phi>1\n\ngoal (1 subgoal):\n 1. mem (\\<tau> \\<sigma>' j - \\<tau> \\<sigma>' i) I \\<and>\n    MFOTL.sat \\<sigma>' v j \\<phi>2 \\<and>\n    (\\<forall>k\\<in>{i..<j}. MFOTL.sat \\<sigma>' v k \\<phi>1)", "by (auto 0 4 simp: le_diff_conv add.commute dest: less_imp_le order.trans[OF \\<tau>_mono, rotated])"], ["proof (state)\nthis:\n  mem (\\<tau> \\<sigma>' j - \\<tau> \\<sigma>' i) I \\<and>\n  MFOTL.sat \\<sigma>' v j \\<phi>2 \\<and>\n  (\\<forall>k\\<in>{i..<j}. MFOTL.sat \\<sigma>' v k \\<phi>1)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>i \\<le> j;\n        left I \\<le> \\<tau> \\<sigma>' j - \\<tau> \\<sigma>' i;\n        enat (\\<tau> \\<sigma>' j - \\<tau> \\<sigma>' i) \\<le> right I;\n        MFOTL.sat \\<sigma>' v j \\<phi>2;\n        \\<forall>k\\<in>{i..<j}. MFOTL.sat \\<sigma>' v k \\<phi>1\\<rbrakk>\n       \\<Longrightarrow> mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i)\n                          I \\<and>\n                         MFOTL.sat \\<sigma> v j \\<phi>2 \\<and>\n                         (\\<forall>k\\<in>{i..<j}.\n                             MFOTL.sat \\<sigma> v k \\<phi>1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>i \\<le> j;\n        left I \\<le> \\<tau> \\<sigma>' j - \\<tau> \\<sigma>' i;\n        enat (\\<tau> \\<sigma>' j - \\<tau> \\<sigma>' i) \\<le> right I;\n        MFOTL.sat \\<sigma>' v j \\<phi>2;\n        \\<forall>k\\<in>{i..<j}. MFOTL.sat \\<sigma>' v k \\<phi>1\\<rbrakk>\n       \\<Longrightarrow> mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i)\n                          I \\<and>\n                         MFOTL.sat \\<sigma> v j \\<phi>2 \\<and>\n                         (\\<forall>k\\<in>{i..<j}.\n                             MFOTL.sat \\<sigma> v k \\<phi>1)", "case (RL j)"], ["proof (state)\nthis:\n  i \\<le> j\n  left I \\<le> \\<tau> \\<sigma>' j - \\<tau> \\<sigma>' i\n  enat (\\<tau> \\<sigma>' j - \\<tau> \\<sigma>' i) \\<le> right I\n  MFOTL.sat \\<sigma>' v j \\<phi>2\n  \\<forall>k\\<in>{i..<j}. MFOTL.sat \\<sigma>' v k \\<phi>1\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>i \\<le> j;\n        left I \\<le> \\<tau> \\<sigma>' j - \\<tau> \\<sigma>' i;\n        enat (\\<tau> \\<sigma>' j - \\<tau> \\<sigma>' i) \\<le> right I;\n        MFOTL.sat \\<sigma>' v j \\<phi>2;\n        \\<forall>k\\<in>{i..<j}. MFOTL.sat \\<sigma>' v k \\<phi>1\\<rbrakk>\n       \\<Longrightarrow> mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i)\n                          I \\<and>\n                         MFOTL.sat \\<sigma> v j \\<phi>2 \\<and>\n                         (\\<forall>k\\<in>{i..<j}.\n                             MFOTL.sat \\<sigma> v k \\<phi>1)", "with Until.IH(1)[OF 11] Until.IH(2)[OF 21] \\<tau>_prefix_conv[OF assms(1,2) 31]"], ["proof (chain)\npicking this:\n  \\<tau> \\<sigma>' ?i \\<le> \\<tau> \\<sigma>' i + b \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi>1 = MFOTL.sat \\<sigma>' ?v ?i \\<phi>1\n  \\<tau> \\<sigma>' ?i \\<le> \\<tau> \\<sigma>' i + b \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi>2 = MFOTL.sat \\<sigma>' ?v ?i \\<phi>2\n  \\<tau> \\<sigma>' ?i \\<le> \\<tau> \\<sigma>' i + b \\<Longrightarrow>\n  \\<tau> \\<sigma> ?i = \\<tau> \\<sigma>' ?i\n  i \\<le> j\n  left I \\<le> \\<tau> \\<sigma>' j - \\<tau> \\<sigma>' i\n  enat (\\<tau> \\<sigma>' j - \\<tau> \\<sigma>' i) \\<le> right I\n  MFOTL.sat \\<sigma>' v j \\<phi>2\n  \\<forall>k\\<in>{i..<j}. MFOTL.sat \\<sigma>' v k \\<phi>1", "show ?case"], ["proof (prove)\nusing this:\n  \\<tau> \\<sigma>' ?i \\<le> \\<tau> \\<sigma>' i + b \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi>1 = MFOTL.sat \\<sigma>' ?v ?i \\<phi>1\n  \\<tau> \\<sigma>' ?i \\<le> \\<tau> \\<sigma>' i + b \\<Longrightarrow>\n  MFOTL.sat \\<sigma> ?v ?i \\<phi>2 = MFOTL.sat \\<sigma>' ?v ?i \\<phi>2\n  \\<tau> \\<sigma>' ?i \\<le> \\<tau> \\<sigma>' i + b \\<Longrightarrow>\n  \\<tau> \\<sigma> ?i = \\<tau> \\<sigma>' ?i\n  i \\<le> j\n  left I \\<le> \\<tau> \\<sigma>' j - \\<tau> \\<sigma>' i\n  enat (\\<tau> \\<sigma>' j - \\<tau> \\<sigma>' i) \\<le> right I\n  MFOTL.sat \\<sigma>' v j \\<phi>2\n  \\<forall>k\\<in>{i..<j}. MFOTL.sat \\<sigma>' v k \\<phi>1\n\ngoal (1 subgoal):\n 1. mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and>\n    MFOTL.sat \\<sigma> v j \\<phi>2 \\<and>\n    (\\<forall>k\\<in>{i..<j}. MFOTL.sat \\<sigma> v k \\<phi>1)", "by (auto 0 4 simp: le_diff_conv add.commute dest: less_imp_le order.trans[OF \\<tau>_mono, rotated])"], ["proof (state)\nthis:\n  mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and>\n  MFOTL.sat \\<sigma> v j \\<phi>2 \\<and>\n  (\\<forall>k\\<in>{i..<j}. MFOTL.sat \\<sigma> v k \\<phi>1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  MFOTL.sat \\<sigma> v i (formula.Until \\<phi>1 I \\<phi>2) =\n  MFOTL.sat \\<sigma>' v i (formula.Until \\<phi>1 I \\<phi>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Specification\\<close>"], ["", "definition pprogress :: \"'a MFOTL.formula \\<Rightarrow> 'a MFOTL.prefix \\<Rightarrow> nat\" where\n  \"pprogress \\<phi> \\<pi> = (THE n. \\<forall>\\<sigma>. prefix_of \\<pi> \\<sigma> \\<longrightarrow> progress \\<sigma> \\<phi> (plen \\<pi>) = n)\""], ["", "lemma pprogress_eq: \"prefix_of \\<pi> \\<sigma> \\<Longrightarrow> pprogress \\<phi> \\<pi> = progress \\<sigma> \\<phi> (plen \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_of \\<pi> \\<sigma> \\<Longrightarrow>\n    pprogress \\<phi> \\<pi> = Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)", "unfolding pprogress_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_of \\<pi> \\<sigma> \\<Longrightarrow>\n    (THE n.\n        \\<forall>\\<sigma>.\n           prefix_of \\<pi> \\<sigma> \\<longrightarrow>\n           Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) = n) =\n    Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)", "using progress_prefix_conv"], ["proof (prove)\nusing this:\n  \\<lbrakk>prefix_of ?\\<pi> ?\\<sigma>; prefix_of ?\\<pi> ?\\<sigma>'\\<rbrakk>\n  \\<Longrightarrow> Monitor.progress ?\\<sigma> ?\\<phi> (plen ?\\<pi>) =\n                    Monitor.progress ?\\<sigma>' ?\\<phi> (plen ?\\<pi>)\n\ngoal (1 subgoal):\n 1. prefix_of \\<pi> \\<sigma> \\<Longrightarrow>\n    (THE n.\n        \\<forall>\\<sigma>.\n           prefix_of \\<pi> \\<sigma> \\<longrightarrow>\n           Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) = n) =\n    Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)", "by blast"], ["", "locale future_bounded_mfotl =\n  fixes \\<phi> :: \"'a MFOTL.formula\"\n  assumes future_bounded: \"MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\""], ["", "sublocale future_bounded_mfotl \\<subseteq> sliceable_timed_progress \"MFOTL.nfv \\<phi>\" \"MFOTL.fv \\<phi>\" \"relevant_events \\<phi>\"\n  \"\\<lambda>\\<sigma> v i. MFOTL.sat \\<sigma> v i \\<phi>\" \"pprogress \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sliceable_timed_progress (MFOTL.nfv \\<phi>) (fv \\<phi>)\n     (relevant_events \\<phi>)\n     (\\<lambda>\\<sigma> v i. MFOTL.sat \\<sigma> v i \\<phi>)\n     (pprogress \\<phi>)", "proof (unfold_locales, goal_cases)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x. x \\<in> fv \\<phi> \\<Longrightarrow> x < MFOTL.nfv \\<phi>\n 2. \\<And>v v' \\<sigma> i.\n       (\\<And>x.\n           x \\<in> fv \\<phi> \\<Longrightarrow>\n           v ! x = v' ! x) \\<Longrightarrow>\n       MFOTL.sat \\<sigma> v i \\<phi> = MFOTL.sat \\<sigma> v' i \\<phi>\n 3. \\<And>v S \\<sigma> i.\n       v \\<in> S \\<Longrightarrow>\n       MFOTL.sat\n        (map_\\<Gamma> (\\<lambda>D. D \\<inter> relevant_events \\<phi> S)\n          \\<sigma>)\n        v i \\<phi> =\n       MFOTL.sat \\<sigma> v i \\<phi>\n 4. \\<And>\\<pi> \\<pi>'.\n       \\<pi> \\<le> \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> \\<le> pprogress \\<phi> \\<pi>'\n 5. \\<And>\\<sigma> x.\n       \\<exists>\\<pi>.\n          prefix_of \\<pi> \\<sigma> \\<and> x \\<le> pprogress \\<phi> \\<pi>\n 6. \\<And>\\<pi> \\<sigma> \\<sigma>' i v.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; prefix_of \\<pi> \\<sigma>';\n        i < pprogress \\<phi> \\<pi>\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i \\<phi> =\n                         MFOTL.sat \\<sigma>' v i \\<phi>\n 7. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "case (1 x)"], ["proof (state)\nthis:\n  x \\<in> fv \\<phi>\n\ngoal (7 subgoals):\n 1. \\<And>x. x \\<in> fv \\<phi> \\<Longrightarrow> x < MFOTL.nfv \\<phi>\n 2. \\<And>v v' \\<sigma> i.\n       (\\<And>x.\n           x \\<in> fv \\<phi> \\<Longrightarrow>\n           v ! x = v' ! x) \\<Longrightarrow>\n       MFOTL.sat \\<sigma> v i \\<phi> = MFOTL.sat \\<sigma> v' i \\<phi>\n 3. \\<And>v S \\<sigma> i.\n       v \\<in> S \\<Longrightarrow>\n       MFOTL.sat\n        (map_\\<Gamma> (\\<lambda>D. D \\<inter> relevant_events \\<phi> S)\n          \\<sigma>)\n        v i \\<phi> =\n       MFOTL.sat \\<sigma> v i \\<phi>\n 4. \\<And>\\<pi> \\<pi>'.\n       \\<pi> \\<le> \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> \\<le> pprogress \\<phi> \\<pi>'\n 5. \\<And>\\<sigma> x.\n       \\<exists>\\<pi>.\n          prefix_of \\<pi> \\<sigma> \\<and> x \\<le> pprogress \\<phi> \\<pi>\n 6. \\<And>\\<pi> \\<sigma> \\<sigma>' i v.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; prefix_of \\<pi> \\<sigma>';\n        i < pprogress \\<phi> \\<pi>\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i \\<phi> =\n                         MFOTL.sat \\<sigma>' v i \\<phi>\n 7. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "then"], ["proof (chain)\npicking this:\n  x \\<in> fv \\<phi>", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> fv \\<phi>\n\ngoal (1 subgoal):\n 1. x < MFOTL.nfv \\<phi>", "by (simp add: fvi_less_nfv)"], ["proof (state)\nthis:\n  x < MFOTL.nfv \\<phi>\n\ngoal (6 subgoals):\n 1. \\<And>v v' \\<sigma> i.\n       (\\<And>x.\n           x \\<in> fv \\<phi> \\<Longrightarrow>\n           v ! x = v' ! x) \\<Longrightarrow>\n       MFOTL.sat \\<sigma> v i \\<phi> = MFOTL.sat \\<sigma> v' i \\<phi>\n 2. \\<And>v S \\<sigma> i.\n       v \\<in> S \\<Longrightarrow>\n       MFOTL.sat\n        (map_\\<Gamma> (\\<lambda>D. D \\<inter> relevant_events \\<phi> S)\n          \\<sigma>)\n        v i \\<phi> =\n       MFOTL.sat \\<sigma> v i \\<phi>\n 3. \\<And>\\<pi> \\<pi>'.\n       \\<pi> \\<le> \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> \\<le> pprogress \\<phi> \\<pi>'\n 4. \\<And>\\<sigma> x.\n       \\<exists>\\<pi>.\n          prefix_of \\<pi> \\<sigma> \\<and> x \\<le> pprogress \\<phi> \\<pi>\n 5. \\<And>\\<pi> \\<sigma> \\<sigma>' i v.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; prefix_of \\<pi> \\<sigma>';\n        i < pprogress \\<phi> \\<pi>\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i \\<phi> =\n                         MFOTL.sat \\<sigma>' v i \\<phi>\n 6. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>v v' \\<sigma> i.\n       (\\<And>x.\n           x \\<in> fv \\<phi> \\<Longrightarrow>\n           v ! x = v' ! x) \\<Longrightarrow>\n       MFOTL.sat \\<sigma> v i \\<phi> = MFOTL.sat \\<sigma> v' i \\<phi>\n 2. \\<And>v S \\<sigma> i.\n       v \\<in> S \\<Longrightarrow>\n       MFOTL.sat\n        (map_\\<Gamma> (\\<lambda>D. D \\<inter> relevant_events \\<phi> S)\n          \\<sigma>)\n        v i \\<phi> =\n       MFOTL.sat \\<sigma> v i \\<phi>\n 3. \\<And>\\<pi> \\<pi>'.\n       \\<pi> \\<le> \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> \\<le> pprogress \\<phi> \\<pi>'\n 4. \\<And>\\<sigma> x.\n       \\<exists>\\<pi>.\n          prefix_of \\<pi> \\<sigma> \\<and> x \\<le> pprogress \\<phi> \\<pi>\n 5. \\<And>\\<pi> \\<sigma> \\<sigma>' i v.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; prefix_of \\<pi> \\<sigma>';\n        i < pprogress \\<phi> \\<pi>\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i \\<phi> =\n                         MFOTL.sat \\<sigma>' v i \\<phi>\n 6. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "case (2 v v' \\<sigma> i)"], ["proof (state)\nthis:\n  ?x \\<in> fv \\<phi> \\<Longrightarrow> v ! ?x = v' ! ?x\n\ngoal (6 subgoals):\n 1. \\<And>v v' \\<sigma> i.\n       (\\<And>x.\n           x \\<in> fv \\<phi> \\<Longrightarrow>\n           v ! x = v' ! x) \\<Longrightarrow>\n       MFOTL.sat \\<sigma> v i \\<phi> = MFOTL.sat \\<sigma> v' i \\<phi>\n 2. \\<And>v S \\<sigma> i.\n       v \\<in> S \\<Longrightarrow>\n       MFOTL.sat\n        (map_\\<Gamma> (\\<lambda>D. D \\<inter> relevant_events \\<phi> S)\n          \\<sigma>)\n        v i \\<phi> =\n       MFOTL.sat \\<sigma> v i \\<phi>\n 3. \\<And>\\<pi> \\<pi>'.\n       \\<pi> \\<le> \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> \\<le> pprogress \\<phi> \\<pi>'\n 4. \\<And>\\<sigma> x.\n       \\<exists>\\<pi>.\n          prefix_of \\<pi> \\<sigma> \\<and> x \\<le> pprogress \\<phi> \\<pi>\n 5. \\<And>\\<pi> \\<sigma> \\<sigma>' i v.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; prefix_of \\<pi> \\<sigma>';\n        i < pprogress \\<phi> \\<pi>\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i \\<phi> =\n                         MFOTL.sat \\<sigma>' v i \\<phi>\n 6. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> fv \\<phi> \\<Longrightarrow> v ! ?x = v' ! ?x", "show ?case"], ["proof (prove)\nusing this:\n  ?x \\<in> fv \\<phi> \\<Longrightarrow> v ! ?x = v' ! ?x\n\ngoal (1 subgoal):\n 1. MFOTL.sat \\<sigma> v i \\<phi> = MFOTL.sat \\<sigma> v' i \\<phi>", "by (simp cong: sat_fvi_cong[rule_format])"], ["proof (state)\nthis:\n  MFOTL.sat \\<sigma> v i \\<phi> = MFOTL.sat \\<sigma> v' i \\<phi>\n\ngoal (5 subgoals):\n 1. \\<And>v S \\<sigma> i.\n       v \\<in> S \\<Longrightarrow>\n       MFOTL.sat\n        (map_\\<Gamma> (\\<lambda>D. D \\<inter> relevant_events \\<phi> S)\n          \\<sigma>)\n        v i \\<phi> =\n       MFOTL.sat \\<sigma> v i \\<phi>\n 2. \\<And>\\<pi> \\<pi>'.\n       \\<pi> \\<le> \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> \\<le> pprogress \\<phi> \\<pi>'\n 3. \\<And>\\<sigma> x.\n       \\<exists>\\<pi>.\n          prefix_of \\<pi> \\<sigma> \\<and> x \\<le> pprogress \\<phi> \\<pi>\n 4. \\<And>\\<pi> \\<sigma> \\<sigma>' i v.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; prefix_of \\<pi> \\<sigma>';\n        i < pprogress \\<phi> \\<pi>\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i \\<phi> =\n                         MFOTL.sat \\<sigma>' v i \\<phi>\n 5. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>v S \\<sigma> i.\n       v \\<in> S \\<Longrightarrow>\n       MFOTL.sat\n        (map_\\<Gamma> (\\<lambda>D. D \\<inter> relevant_events \\<phi> S)\n          \\<sigma>)\n        v i \\<phi> =\n       MFOTL.sat \\<sigma> v i \\<phi>\n 2. \\<And>\\<pi> \\<pi>'.\n       \\<pi> \\<le> \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> \\<le> pprogress \\<phi> \\<pi>'\n 3. \\<And>\\<sigma> x.\n       \\<exists>\\<pi>.\n          prefix_of \\<pi> \\<sigma> \\<and> x \\<le> pprogress \\<phi> \\<pi>\n 4. \\<And>\\<pi> \\<sigma> \\<sigma>' i v.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; prefix_of \\<pi> \\<sigma>';\n        i < pprogress \\<phi> \\<pi>\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i \\<phi> =\n                         MFOTL.sat \\<sigma>' v i \\<phi>\n 5. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "case (3 v S \\<sigma> i)"], ["proof (state)\nthis:\n  v \\<in> S\n\ngoal (5 subgoals):\n 1. \\<And>v S \\<sigma> i.\n       v \\<in> S \\<Longrightarrow>\n       MFOTL.sat\n        (map_\\<Gamma> (\\<lambda>D. D \\<inter> relevant_events \\<phi> S)\n          \\<sigma>)\n        v i \\<phi> =\n       MFOTL.sat \\<sigma> v i \\<phi>\n 2. \\<And>\\<pi> \\<pi>'.\n       \\<pi> \\<le> \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> \\<le> pprogress \\<phi> \\<pi>'\n 3. \\<And>\\<sigma> x.\n       \\<exists>\\<pi>.\n          prefix_of \\<pi> \\<sigma> \\<and> x \\<le> pprogress \\<phi> \\<pi>\n 4. \\<And>\\<pi> \\<sigma> \\<sigma>' i v.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; prefix_of \\<pi> \\<sigma>';\n        i < pprogress \\<phi> \\<pi>\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i \\<phi> =\n                         MFOTL.sat \\<sigma>' v i \\<phi>\n 5. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "then"], ["proof (chain)\npicking this:\n  v \\<in> S", "show ?case"], ["proof (prove)\nusing this:\n  v \\<in> S\n\ngoal (1 subgoal):\n 1. MFOTL.sat\n     (map_\\<Gamma> (\\<lambda>D. D \\<inter> relevant_events \\<phi> S)\n       \\<sigma>)\n     v i \\<phi> =\n    MFOTL.sat \\<sigma> v i \\<phi>", "using sat_slice_iff[of v, symmetric]"], ["proof (prove)\nusing this:\n  v \\<in> S\n  v \\<in> ?S \\<Longrightarrow>\n  MFOTL.sat\n   (map_\\<Gamma> (\\<lambda>D. D \\<inter> relevant_events ?\\<phi> ?S)\n     ?\\<sigma>)\n   v ?i ?\\<phi> =\n  MFOTL.sat ?\\<sigma> v ?i ?\\<phi>\n\ngoal (1 subgoal):\n 1. MFOTL.sat\n     (map_\\<Gamma> (\\<lambda>D. D \\<inter> relevant_events \\<phi> S)\n       \\<sigma>)\n     v i \\<phi> =\n    MFOTL.sat \\<sigma> v i \\<phi>", "by simp"], ["proof (state)\nthis:\n  MFOTL.sat\n   (map_\\<Gamma> (\\<lambda>D. D \\<inter> relevant_events \\<phi> S) \\<sigma>)\n   v i \\<phi> =\n  MFOTL.sat \\<sigma> v i \\<phi>\n\ngoal (4 subgoals):\n 1. \\<And>\\<pi> \\<pi>'.\n       \\<pi> \\<le> \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> \\<le> pprogress \\<phi> \\<pi>'\n 2. \\<And>\\<sigma> x.\n       \\<exists>\\<pi>.\n          prefix_of \\<pi> \\<sigma> \\<and> x \\<le> pprogress \\<phi> \\<pi>\n 3. \\<And>\\<pi> \\<sigma> \\<sigma>' i v.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; prefix_of \\<pi> \\<sigma>';\n        i < pprogress \\<phi> \\<pi>\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i \\<phi> =\n                         MFOTL.sat \\<sigma>' v i \\<phi>\n 4. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<pi> \\<pi>'.\n       \\<pi> \\<le> \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> \\<le> pprogress \\<phi> \\<pi>'\n 2. \\<And>\\<sigma> x.\n       \\<exists>\\<pi>.\n          prefix_of \\<pi> \\<sigma> \\<and> x \\<le> pprogress \\<phi> \\<pi>\n 3. \\<And>\\<pi> \\<sigma> \\<sigma>' i v.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; prefix_of \\<pi> \\<sigma>';\n        i < pprogress \\<phi> \\<pi>\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i \\<phi> =\n                         MFOTL.sat \\<sigma>' v i \\<phi>\n 4. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "case (4 \\<pi> \\<pi>')"], ["proof (state)\nthis:\n  \\<pi> \\<le> \\<pi>'\n\ngoal (4 subgoals):\n 1. \\<And>\\<pi> \\<pi>'.\n       \\<pi> \\<le> \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> \\<le> pprogress \\<phi> \\<pi>'\n 2. \\<And>\\<sigma> x.\n       \\<exists>\\<pi>.\n          prefix_of \\<pi> \\<sigma> \\<and> x \\<le> pprogress \\<phi> \\<pi>\n 3. \\<And>\\<pi> \\<sigma> \\<sigma>' i v.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; prefix_of \\<pi> \\<sigma>';\n        i < pprogress \\<phi> \\<pi>\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i \\<phi> =\n                         MFOTL.sat \\<sigma>' v i \\<phi>\n 4. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "moreover"], ["proof (state)\nthis:\n  \\<pi> \\<le> \\<pi>'\n\ngoal (4 subgoals):\n 1. \\<And>\\<pi> \\<pi>'.\n       \\<pi> \\<le> \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> \\<le> pprogress \\<phi> \\<pi>'\n 2. \\<And>\\<sigma> x.\n       \\<exists>\\<pi>.\n          prefix_of \\<pi> \\<sigma> \\<and> x \\<le> pprogress \\<phi> \\<pi>\n 3. \\<And>\\<pi> \\<sigma> \\<sigma>' i v.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; prefix_of \\<pi> \\<sigma>';\n        i < pprogress \\<phi> \\<pi>\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i \\<phi> =\n                         MFOTL.sat \\<sigma>' v i \\<phi>\n 4. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "obtain \\<sigma> where \"prefix_of \\<pi>' \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        prefix_of \\<pi>' \\<sigma> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ex_prefix_of"], ["proof (prove)\nusing this:\n  \\<exists>s. prefix_of ?p s\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        prefix_of \\<pi>' \\<sigma> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  prefix_of \\<pi>' \\<sigma>\n\ngoal (4 subgoals):\n 1. \\<And>\\<pi> \\<pi>'.\n       \\<pi> \\<le> \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> \\<le> pprogress \\<phi> \\<pi>'\n 2. \\<And>\\<sigma> x.\n       \\<exists>\\<pi>.\n          prefix_of \\<pi> \\<sigma> \\<and> x \\<le> pprogress \\<phi> \\<pi>\n 3. \\<And>\\<pi> \\<sigma> \\<sigma>' i v.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; prefix_of \\<pi> \\<sigma>';\n        i < pprogress \\<phi> \\<pi>\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i \\<phi> =\n                         MFOTL.sat \\<sigma>' v i \\<phi>\n 4. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "moreover"], ["proof (state)\nthis:\n  prefix_of \\<pi>' \\<sigma>\n\ngoal (4 subgoals):\n 1. \\<And>\\<pi> \\<pi>'.\n       \\<pi> \\<le> \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> \\<le> pprogress \\<phi> \\<pi>'\n 2. \\<And>\\<sigma> x.\n       \\<exists>\\<pi>.\n          prefix_of \\<pi> \\<sigma> \\<and> x \\<le> pprogress \\<phi> \\<pi>\n 3. \\<And>\\<pi> \\<sigma> \\<sigma>' i v.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; prefix_of \\<pi> \\<sigma>';\n        i < pprogress \\<phi> \\<pi>\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i \\<phi> =\n                         MFOTL.sat \\<sigma>' v i \\<phi>\n 4. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "have \"prefix_of \\<pi> \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix_of \\<pi> \\<sigma>", "using prefix_of_antimono[OF \\<open>\\<pi> \\<le> \\<pi>'\\<close> \\<open>prefix_of \\<pi>' \\<sigma>\\<close>]"], ["proof (prove)\nusing this:\n  prefix_of \\<pi> \\<sigma>\n\ngoal (1 subgoal):\n 1. prefix_of \\<pi> \\<sigma>", "."], ["proof (state)\nthis:\n  prefix_of \\<pi> \\<sigma>\n\ngoal (4 subgoals):\n 1. \\<And>\\<pi> \\<pi>'.\n       \\<pi> \\<le> \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> \\<le> pprogress \\<phi> \\<pi>'\n 2. \\<And>\\<sigma> x.\n       \\<exists>\\<pi>.\n          prefix_of \\<pi> \\<sigma> \\<and> x \\<le> pprogress \\<phi> \\<pi>\n 3. \\<And>\\<pi> \\<sigma> \\<sigma>' i v.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; prefix_of \\<pi> \\<sigma>';\n        i < pprogress \\<phi> \\<pi>\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i \\<phi> =\n                         MFOTL.sat \\<sigma>' v i \\<phi>\n 4. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "ultimately"], ["proof (chain)\npicking this:\n  \\<pi> \\<le> \\<pi>'\n  prefix_of \\<pi>' \\<sigma>\n  prefix_of \\<pi> \\<sigma>", "show ?case"], ["proof (prove)\nusing this:\n  \\<pi> \\<le> \\<pi>'\n  prefix_of \\<pi>' \\<sigma>\n  prefix_of \\<pi> \\<sigma>\n\ngoal (1 subgoal):\n 1. pprogress \\<phi> \\<pi> \\<le> pprogress \\<phi> \\<pi>'", "by (simp add: pprogress_eq plen_mono progress_mono)"], ["proof (state)\nthis:\n  pprogress \\<phi> \\<pi> \\<le> pprogress \\<phi> \\<pi>'\n\ngoal (3 subgoals):\n 1. \\<And>\\<sigma> x.\n       \\<exists>\\<pi>.\n          prefix_of \\<pi> \\<sigma> \\<and> x \\<le> pprogress \\<phi> \\<pi>\n 2. \\<And>\\<pi> \\<sigma> \\<sigma>' i v.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; prefix_of \\<pi> \\<sigma>';\n        i < pprogress \\<phi> \\<pi>\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i \\<phi> =\n                         MFOTL.sat \\<sigma>' v i \\<phi>\n 3. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<sigma> x.\n       \\<exists>\\<pi>.\n          prefix_of \\<pi> \\<sigma> \\<and> x \\<le> pprogress \\<phi> \\<pi>\n 2. \\<And>\\<pi> \\<sigma> \\<sigma>' i v.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; prefix_of \\<pi> \\<sigma>';\n        i < pprogress \\<phi> \\<pi>\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i \\<phi> =\n                         MFOTL.sat \\<sigma>' v i \\<phi>\n 3. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "case (5 \\<sigma> x)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>\\<sigma> x.\n       \\<exists>\\<pi>.\n          prefix_of \\<pi> \\<sigma> \\<and> x \\<le> pprogress \\<phi> \\<pi>\n 2. \\<And>\\<pi> \\<sigma> \\<sigma>' i v.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; prefix_of \\<pi> \\<sigma>';\n        i < pprogress \\<phi> \\<pi>\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i \\<phi> =\n                         MFOTL.sat \\<sigma>' v i \\<phi>\n 3. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "obtain j where \"x \\<le> progress \\<sigma> \\<phi> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j.\n        x \\<le> Monitor.progress \\<sigma> \\<phi> j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using future_bounded progress_ge"], ["proof (prove)\nusing this:\n  MFOTL.future_reach \\<phi> \\<noteq> \\<infinity>\n  MFOTL.future_reach ?\\<phi> \\<noteq> \\<infinity> \\<Longrightarrow>\n  \\<exists>j. ?i \\<le> Monitor.progress ?\\<sigma> ?\\<phi> j\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        x \\<le> Monitor.progress \\<sigma> \\<phi> j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<le> Monitor.progress \\<sigma> \\<phi> j\n\ngoal (3 subgoals):\n 1. \\<And>\\<sigma> x.\n       \\<exists>\\<pi>.\n          prefix_of \\<pi> \\<sigma> \\<and> x \\<le> pprogress \\<phi> \\<pi>\n 2. \\<And>\\<pi> \\<sigma> \\<sigma>' i v.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; prefix_of \\<pi> \\<sigma>';\n        i < pprogress \\<phi> \\<pi>\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i \\<phi> =\n                         MFOTL.sat \\<sigma>' v i \\<phi>\n 3. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "then"], ["proof (chain)\npicking this:\n  x \\<le> Monitor.progress \\<sigma> \\<phi> j", "have \"x \\<le> pprogress \\<phi> (take_prefix j \\<sigma>)\""], ["proof (prove)\nusing this:\n  x \\<le> Monitor.progress \\<sigma> \\<phi> j\n\ngoal (1 subgoal):\n 1. x \\<le> pprogress \\<phi> (take_prefix j \\<sigma>)", "by (simp add: pprogress_eq[of _ \\<sigma>])"], ["proof (state)\nthis:\n  x \\<le> pprogress \\<phi> (take_prefix j \\<sigma>)\n\ngoal (3 subgoals):\n 1. \\<And>\\<sigma> x.\n       \\<exists>\\<pi>.\n          prefix_of \\<pi> \\<sigma> \\<and> x \\<le> pprogress \\<phi> \\<pi>\n 2. \\<And>\\<pi> \\<sigma> \\<sigma>' i v.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; prefix_of \\<pi> \\<sigma>';\n        i < pprogress \\<phi> \\<pi>\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i \\<phi> =\n                         MFOTL.sat \\<sigma>' v i \\<phi>\n 3. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "then"], ["proof (chain)\npicking this:\n  x \\<le> pprogress \\<phi> (take_prefix j \\<sigma>)", "show ?case"], ["proof (prove)\nusing this:\n  x \\<le> pprogress \\<phi> (take_prefix j \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>.\n       prefix_of \\<pi> \\<sigma> \\<and> x \\<le> pprogress \\<phi> \\<pi>", "by force"], ["proof (state)\nthis:\n  \\<exists>\\<pi>.\n     prefix_of \\<pi> \\<sigma> \\<and> x \\<le> pprogress \\<phi> \\<pi>\n\ngoal (2 subgoals):\n 1. \\<And>\\<pi> \\<sigma> \\<sigma>' i v.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; prefix_of \\<pi> \\<sigma>';\n        i < pprogress \\<phi> \\<pi>\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i \\<phi> =\n                         MFOTL.sat \\<sigma>' v i \\<phi>\n 2. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<pi> \\<sigma> \\<sigma>' i v.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; prefix_of \\<pi> \\<sigma>';\n        i < pprogress \\<phi> \\<pi>\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i \\<phi> =\n                         MFOTL.sat \\<sigma>' v i \\<phi>\n 2. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "case (6 \\<pi> \\<sigma> \\<sigma>' i v)"], ["proof (state)\nthis:\n  prefix_of \\<pi> \\<sigma>\n  prefix_of \\<pi> \\<sigma>'\n  i < pprogress \\<phi> \\<pi>\n\ngoal (2 subgoals):\n 1. \\<And>\\<pi> \\<sigma> \\<sigma>' i v.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; prefix_of \\<pi> \\<sigma>';\n        i < pprogress \\<phi> \\<pi>\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i \\<phi> =\n                         MFOTL.sat \\<sigma>' v i \\<phi>\n 2. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "then"], ["proof (chain)\npicking this:\n  prefix_of \\<pi> \\<sigma>\n  prefix_of \\<pi> \\<sigma>'\n  i < pprogress \\<phi> \\<pi>", "have \"i < progress \\<sigma> \\<phi> (plen \\<pi>)\""], ["proof (prove)\nusing this:\n  prefix_of \\<pi> \\<sigma>\n  prefix_of \\<pi> \\<sigma>'\n  i < pprogress \\<phi> \\<pi>\n\ngoal (1 subgoal):\n 1. i < Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)", "by (simp add: pprogress_eq)"], ["proof (state)\nthis:\n  i < Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)\n\ngoal (2 subgoals):\n 1. \\<And>\\<pi> \\<sigma> \\<sigma>' i v.\n       \\<lbrakk>prefix_of \\<pi> \\<sigma>; prefix_of \\<pi> \\<sigma>';\n        i < pprogress \\<phi> \\<pi>\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> v i \\<phi> =\n                         MFOTL.sat \\<sigma>' v i \\<phi>\n 2. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "with 6"], ["proof (chain)\npicking this:\n  prefix_of \\<pi> \\<sigma>\n  prefix_of \\<pi> \\<sigma>'\n  i < pprogress \\<phi> \\<pi>\n  i < Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)", "show ?case"], ["proof (prove)\nusing this:\n  prefix_of \\<pi> \\<sigma>\n  prefix_of \\<pi> \\<sigma>'\n  i < pprogress \\<phi> \\<pi>\n  i < Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)\n\ngoal (1 subgoal):\n 1. MFOTL.sat \\<sigma> v i \\<phi> = MFOTL.sat \\<sigma>' v i \\<phi>", "using sat_prefix_conv"], ["proof (prove)\nusing this:\n  prefix_of \\<pi> \\<sigma>\n  prefix_of \\<pi> \\<sigma>'\n  i < pprogress \\<phi> \\<pi>\n  i < Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)\n  \\<lbrakk>prefix_of ?\\<pi> ?\\<sigma>; prefix_of ?\\<pi> ?\\<sigma>';\n   ?i < Monitor.progress ?\\<sigma> ?\\<phi> (plen ?\\<pi>)\\<rbrakk>\n  \\<Longrightarrow> MFOTL.sat ?\\<sigma> ?v ?i ?\\<phi> =\n                    MFOTL.sat ?\\<sigma>' ?v ?i ?\\<phi>\n\ngoal (1 subgoal):\n 1. MFOTL.sat \\<sigma> v i \\<phi> = MFOTL.sat \\<sigma>' v i \\<phi>", "by blast"], ["proof (state)\nthis:\n  MFOTL.sat \\<sigma> v i \\<phi> = MFOTL.sat \\<sigma>' v i \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "case (7 \\<pi> \\<pi>')"], ["proof (state)\nthis:\n  pts \\<pi> = pts \\<pi>'\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "then"], ["proof (chain)\npicking this:\n  pts \\<pi> = pts \\<pi>'", "have \"plen \\<pi> = plen \\<pi>'\""], ["proof (prove)\nusing this:\n  pts \\<pi> = pts \\<pi>'\n\ngoal (1 subgoal):\n 1. plen \\<pi> = plen \\<pi>'", "by transfer (simp add: list_eq_iff_nth_eq)"], ["proof (state)\nthis:\n  plen \\<pi> = plen \\<pi>'\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "moreover"], ["proof (state)\nthis:\n  plen \\<pi> = plen \\<pi>'\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "obtain \\<sigma> \\<sigma>' where \"prefix_of \\<pi> \\<sigma>\" \"prefix_of \\<pi>' \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma> \\<sigma>'.\n        \\<lbrakk>prefix_of \\<pi> \\<sigma>;\n         prefix_of \\<pi>' \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ex_prefix_of"], ["proof (prove)\nusing this:\n  \\<exists>s. prefix_of ?p s\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma> \\<sigma>'.\n        \\<lbrakk>prefix_of \\<pi> \\<sigma>;\n         prefix_of \\<pi>' \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast+"], ["proof (state)\nthis:\n  prefix_of \\<pi> \\<sigma>\n  prefix_of \\<pi>' \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "moreover"], ["proof (state)\nthis:\n  prefix_of \\<pi> \\<sigma>\n  prefix_of \\<pi>' \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "have \"\\<forall>i < plen \\<pi>. \\<tau> \\<sigma> i = \\<tau> \\<sigma>' i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<plen \\<pi>. \\<tau> \\<sigma> i = \\<tau> \\<sigma>' i", "using 7 calculation"], ["proof (prove)\nusing this:\n  pts \\<pi> = pts \\<pi>'\n  plen \\<pi> = plen \\<pi>'\n  prefix_of \\<pi> \\<sigma>\n  prefix_of \\<pi>' \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<forall>i<plen \\<pi>. \\<tau> \\<sigma> i = \\<tau> \\<sigma>' i", "by transfer (simp add: list_eq_iff_nth_eq)"], ["proof (state)\nthis:\n  \\<forall>i<plen \\<pi>. \\<tau> \\<sigma> i = \\<tau> \\<sigma>' i\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi> \\<pi>'.\n       pts \\<pi> = pts \\<pi>' \\<Longrightarrow>\n       pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "ultimately"], ["proof (chain)\npicking this:\n  plen \\<pi> = plen \\<pi>'\n  prefix_of \\<pi> \\<sigma>\n  prefix_of \\<pi>' \\<sigma>'\n  \\<forall>i<plen \\<pi>. \\<tau> \\<sigma> i = \\<tau> \\<sigma>' i", "show ?case"], ["proof (prove)\nusing this:\n  plen \\<pi> = plen \\<pi>'\n  prefix_of \\<pi> \\<sigma>\n  prefix_of \\<pi>' \\<sigma>'\n  \\<forall>i<plen \\<pi>. \\<tau> \\<sigma> i = \\<tau> \\<sigma>' i\n\ngoal (1 subgoal):\n 1. pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'", "by (simp add: pprogress_eq progress_time_conv)"], ["proof (state)\nthis:\n  pprogress \\<phi> \\<pi> = pprogress \\<phi> \\<pi>'\n\ngoal:\nNo subgoals!", "qed"], ["", "locale monitorable_mfotl =\n  fixes \\<phi> :: \"'a MFOTL.formula\"\n  assumes monitorable: \"mmonitorable \\<phi>\""], ["", "sublocale monitorable_mfotl \\<subseteq> future_bounded_mfotl"], ["proof (prove)\ngoal (1 subgoal):\n 1. future_bounded_mfotl \\<phi>", "using monitorable"], ["proof (prove)\nusing this:\n  mmonitorable \\<phi>\n\ngoal (1 subgoal):\n 1. future_bounded_mfotl \\<phi>", "by unfold_locales (simp add: mmonitorable_def)"], ["", "subsection \\<open>Correctness\\<close>"], ["", "subsubsection \\<open>Invariants\\<close>"], ["", "definition wf_mbuf2 :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> (nat \\<Rightarrow> 'a table \\<Rightarrow> bool) \\<Rightarrow> (nat \\<Rightarrow> 'a table \\<Rightarrow> bool) \\<Rightarrow>\n  'a mbuf2 \\<Rightarrow> bool\" where\n  \"wf_mbuf2 i ja jb P Q buf \\<longleftrightarrow> i \\<le> ja \\<and> i \\<le> jb \\<and> (case buf of (xs, ys) \\<Rightarrow>\n    list_all2 P [i..<ja] xs \\<and> list_all2 Q [i..<jb] ys)\""], ["", "definition wf_mbuf2' :: \"'a MFOTL.trace \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a list set \\<Rightarrow>\n  'a MFOTL.formula \\<Rightarrow> 'a MFOTL.formula \\<Rightarrow> 'a mbuf2 \\<Rightarrow> bool\" where\n  \"wf_mbuf2' \\<sigma> j n R \\<phi> \\<psi> buf \\<longleftrightarrow> wf_mbuf2 (min (progress \\<sigma> \\<phi> j) (progress \\<sigma> \\<psi> j))\n    (progress \\<sigma> \\<phi> j) (progress \\<sigma> \\<psi> j)\n    (\\<lambda>i. qtable n (MFOTL.fv \\<phi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n    (\\<lambda>i. qtable n (MFOTL.fv \\<psi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>)) buf\""], ["", "lemma wf_mbuf2'_UNIV_alt: \"wf_mbuf2' \\<sigma> j n UNIV \\<phi> \\<psi> buf \\<longleftrightarrow> (case buf of (xs, ys) \\<Rightarrow>\n  list_all2 (\\<lambda>i. wf_table n (MFOTL.fv \\<phi>) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n    [min (progress \\<sigma> \\<phi> j) (progress \\<sigma> \\<psi> j) ..< (progress \\<sigma> \\<phi> j)] xs \\<and>\n  list_all2 (\\<lambda>i. wf_table n (MFOTL.fv \\<psi>) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n    [min (progress \\<sigma> \\<phi> j) (progress \\<sigma> \\<psi> j) ..< (progress \\<sigma> \\<psi> j)] ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_mbuf2' \\<sigma> j n UNIV \\<phi> \\<psi> buf =\n    (case buf of\n     (xs, ys) \\<Rightarrow>\n       list_all2\n        (\\<lambda>i.\n            wf_table n (fv \\<phi>)\n             (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n        [min (Monitor.progress \\<sigma> \\<phi> j)\n          (Monitor.progress \\<sigma> \\<psi> j)..<\n         Monitor.progress \\<sigma> \\<phi> j]\n        xs \\<and>\n       list_all2\n        (\\<lambda>i.\n            wf_table n (fv \\<psi>)\n             (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n        [min (Monitor.progress \\<sigma> \\<phi> j)\n          (Monitor.progress \\<sigma> \\<psi> j)..<\n         Monitor.progress \\<sigma> \\<psi> j]\n        ys)", "unfolding wf_mbuf2'_def wf_mbuf2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (min (Monitor.progress \\<sigma> \\<phi> j)\n      (Monitor.progress \\<sigma> \\<psi> j)\n     \\<le> Monitor.progress \\<sigma> \\<phi> j \\<and>\n     min (Monitor.progress \\<sigma> \\<phi> j)\n      (Monitor.progress \\<sigma> \\<psi> j)\n     \\<le> Monitor.progress \\<sigma> \\<psi> j \\<and>\n     (case buf of\n      (xs, ys) \\<Rightarrow>\n        list_all2\n         (\\<lambda>i.\n             qtable n (fv \\<phi>) (mem_restr UNIV)\n              (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n         [min (Monitor.progress \\<sigma> \\<phi> j)\n           (Monitor.progress \\<sigma> \\<psi> j)..<\n          Monitor.progress \\<sigma> \\<phi> j]\n         xs \\<and>\n        list_all2\n         (\\<lambda>i.\n             qtable n (fv \\<psi>) (mem_restr UNIV)\n              (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n         [min (Monitor.progress \\<sigma> \\<phi> j)\n           (Monitor.progress \\<sigma> \\<psi> j)..<\n          Monitor.progress \\<sigma> \\<psi> j]\n         ys)) =\n    (case buf of\n     (xs, ys) \\<Rightarrow>\n       list_all2\n        (\\<lambda>i.\n            wf_table n (fv \\<phi>)\n             (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n        [min (Monitor.progress \\<sigma> \\<phi> j)\n          (Monitor.progress \\<sigma> \\<psi> j)..<\n         Monitor.progress \\<sigma> \\<phi> j]\n        xs \\<and>\n       list_all2\n        (\\<lambda>i.\n            wf_table n (fv \\<psi>)\n             (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n        [min (Monitor.progress \\<sigma> \\<phi> j)\n          (Monitor.progress \\<sigma> \\<psi> j)..<\n         Monitor.progress \\<sigma> \\<psi> j]\n        ys)", "by (simp add: mem_restr_UNIV[THEN eqTrueI, abs_def] split: prod.split)"], ["", "definition wf_ts :: \"'a MFOTL.trace \\<Rightarrow> nat \\<Rightarrow> 'a MFOTL.formula \\<Rightarrow> 'a MFOTL.formula \\<Rightarrow> ts list \\<Rightarrow> bool\" where\n  \"wf_ts \\<sigma> j \\<phi> \\<psi> ts \\<longleftrightarrow> list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [min (progress \\<sigma> \\<phi> j) (progress \\<sigma> \\<psi> j)..<j] ts\""], ["", "abbreviation \"Sincep pos \\<phi> I \\<psi> \\<equiv> MFOTL.Since (if pos then \\<phi> else MFOTL.Neg \\<phi>) I \\<psi>\""], ["", "definition wf_since_aux :: \"'a MFOTL.trace \\<Rightarrow> nat \\<Rightarrow> 'a list set \\<Rightarrow> bool \\<Rightarrow>\n    'a MFOTL.formula \\<Rightarrow> \\<I> \\<Rightarrow> 'a MFOTL.formula \\<Rightarrow> 'a msaux \\<Rightarrow> nat \\<Rightarrow> bool\" where\n  \"wf_since_aux \\<sigma> n R pos \\<phi> I \\<psi> aux ne \\<longleftrightarrow> sorted_wrt (\\<lambda>x y. fst x > fst y) aux \\<and>\n    (\\<forall>t X. (t, X) \\<in> set aux \\<longrightarrow> ne \\<noteq> 0 \\<and> t \\<le> \\<tau> \\<sigma> (ne-1) \\<and> \\<tau> \\<sigma> (ne-1) - t \\<le> right I \\<and> (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n      qtable n (MFOTL.fv \\<psi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) (ne-1) (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (ne-1) - t)) \\<psi>)) X) \\<and>\n    (\\<forall>t. ne \\<noteq> 0 \\<and> t \\<le> \\<tau> \\<sigma> (ne-1) \\<and> \\<tau> \\<sigma> (ne-1) - t \\<le> right I \\<and> (\\<exists>i. \\<tau> \\<sigma> i = t) \\<longrightarrow>\n      (\\<exists>X. (t, X) \\<in> set aux))\""], ["", "lemma qtable_mem_restr_UNIV: \"qtable n A (mem_restr UNIV) Q X = wf_table n A Q X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qtable n A (mem_restr UNIV) Q X = wf_table n A Q X", "unfolding qtable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (table n A X \\<and>\n     (\\<forall>x.\n         (x \\<in> X \\<and> mem_restr UNIV x \\<longrightarrow> Q x) \\<and>\n         (wf_tuple n A x \\<and>\n          mem_restr UNIV x \\<and> Q x \\<longrightarrow>\n          x \\<in> X))) =\n    (table n A X \\<and>\n     (\\<forall>x.\n         (x \\<in> X \\<and> True \\<longrightarrow> Q x) \\<and>\n         (wf_tuple n A x \\<and> True \\<and> Q x \\<longrightarrow>\n          x \\<in> X)))", "by auto"], ["", "lemma wf_since_aux_UNIV_alt:\n  \"wf_since_aux \\<sigma> n UNIV pos \\<phi> I \\<psi> aux ne \\<longleftrightarrow> sorted_wrt (\\<lambda>x y. fst x > fst y) aux \\<and>\n    (\\<forall>t X. (t, X) \\<in> set aux \\<longrightarrow> ne \\<noteq> 0 \\<and> t \\<le> \\<tau> \\<sigma> (ne-1) \\<and> \\<tau> \\<sigma> (ne-1) - t \\<le> right I \\<and> (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n      wf_table n (MFOTL.fv \\<psi>)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) (ne-1) (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (ne-1) - t)) \\<psi>)) X) \\<and>\n    (\\<forall>t. ne \\<noteq> 0 \\<and> t \\<le> \\<tau> \\<sigma> (ne-1) \\<and> \\<tau> \\<sigma> (ne-1) - t \\<le> right I \\<and> (\\<exists>i. \\<tau> \\<sigma> i = t) \\<longrightarrow>\n      (\\<exists>X. (t, X) \\<in> set aux))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_since_aux \\<sigma> n UNIV pos \\<phi> I \\<psi> aux ne =\n    (sorted_wrt (\\<lambda>x y. fst y < fst x) aux \\<and>\n     (\\<forall>t X.\n         (t, X) \\<in> set aux \\<longrightarrow>\n         ne \\<noteq> 0 \\<and>\n         t \\<le> \\<tau> \\<sigma> (ne - 1) \\<and>\n         enat (\\<tau> \\<sigma> (ne - 1) - t) \\<le> right I \\<and>\n         (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n         wf_table n (fv \\<psi>)\n          (\\<lambda>v.\n              MFOTL.sat \\<sigma> (map the v) (ne - 1)\n               (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (ne - 1) - t))\n                 \\<psi>))\n          X) \\<and>\n     (\\<forall>t.\n         ne \\<noteq> 0 \\<and>\n         t \\<le> \\<tau> \\<sigma> (ne - 1) \\<and>\n         enat (\\<tau> \\<sigma> (ne - 1) - t) \\<le> right I \\<and>\n         (\\<exists>i. \\<tau> \\<sigma> i = t) \\<longrightarrow>\n         (\\<exists>X. (t, X) \\<in> set aux)))", "unfolding wf_since_aux_def qtable_mem_restr_UNIV"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sorted_wrt (\\<lambda>x y. fst y < fst x) aux \\<and>\n     (\\<forall>t X.\n         (t, X) \\<in> set aux \\<longrightarrow>\n         ne \\<noteq> 0 \\<and>\n         t \\<le> \\<tau> \\<sigma> (ne - 1) \\<and>\n         enat (\\<tau> \\<sigma> (ne - 1) - t) \\<le> right I \\<and>\n         (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n         wf_table n (fv \\<psi>)\n          (\\<lambda>v.\n              MFOTL.sat \\<sigma> (map the v) (ne - 1)\n               (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (ne - 1) - t))\n                 \\<psi>))\n          X) \\<and>\n     (\\<forall>t.\n         ne \\<noteq> 0 \\<and>\n         t \\<le> \\<tau> \\<sigma> (ne - 1) \\<and>\n         enat (\\<tau> \\<sigma> (ne - 1) - t) \\<le> right I \\<and>\n         (\\<exists>i. \\<tau> \\<sigma> i = t) \\<longrightarrow>\n         (\\<exists>X. (t, X) \\<in> set aux))) =\n    (sorted_wrt (\\<lambda>x y. fst y < fst x) aux \\<and>\n     (\\<forall>t X.\n         (t, X) \\<in> set aux \\<longrightarrow>\n         ne \\<noteq> 0 \\<and>\n         t \\<le> \\<tau> \\<sigma> (ne - 1) \\<and>\n         enat (\\<tau> \\<sigma> (ne - 1) - t) \\<le> right I \\<and>\n         (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n         wf_table n (fv \\<psi>)\n          (\\<lambda>v.\n              MFOTL.sat \\<sigma> (map the v) (ne - 1)\n               (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (ne - 1) - t))\n                 \\<psi>))\n          X) \\<and>\n     (\\<forall>t.\n         ne \\<noteq> 0 \\<and>\n         t \\<le> \\<tau> \\<sigma> (ne - 1) \\<and>\n         enat (\\<tau> \\<sigma> (ne - 1) - t) \\<le> right I \\<and>\n         (\\<exists>i. \\<tau> \\<sigma> i = t) \\<longrightarrow>\n         (\\<exists>X. (t, X) \\<in> set aux)))", ".."], ["", "definition wf_until_aux :: \"'a MFOTL.trace \\<Rightarrow> nat \\<Rightarrow> 'a list set \\<Rightarrow> bool \\<Rightarrow>\n    'a MFOTL.formula \\<Rightarrow> \\<I> \\<Rightarrow> 'a MFOTL.formula \\<Rightarrow> 'a muaux \\<Rightarrow> nat \\<Rightarrow> bool\" where\n  \"wf_until_aux \\<sigma> n R pos \\<phi> I \\<psi> aux ne \\<longleftrightarrow> list_all2 (\\<lambda>x i. case x of (t, r1, r2) \\<Rightarrow> t = \\<tau> \\<sigma> i \\<and>\n      qtable n (MFOTL.fv \\<phi>) (mem_restr R) (\\<lambda>v. if pos then (\\<forall>k\\<in>{i..<ne+length aux}. MFOTL.sat \\<sigma> (map the v) k \\<phi>)\n          else (\\<exists>k\\<in>{i..<ne+length aux}. MFOTL.sat \\<sigma> (map the v) k \\<phi>)) r1 \\<and>\n      qtable n (MFOTL.fv \\<psi>) (mem_restr R) (\\<lambda>v. (\\<exists>j. i \\<le> j \\<and> j < ne + length aux \\<and> mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and>\n          MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n          (\\<forall>k\\<in>{i..<j}. if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi> else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))) r2)\n    aux [ne..<ne+length aux]\""], ["", "lemma wf_until_aux_UNIV_alt:\n  \"wf_until_aux \\<sigma> n UNIV pos \\<phi> I \\<psi> aux ne \\<longleftrightarrow> list_all2 (\\<lambda>x i. case x of (t, r1, r2) \\<Rightarrow> t = \\<tau> \\<sigma> i \\<and>\n      wf_table n (MFOTL.fv \\<phi>) (\\<lambda>v. if pos\n          then (\\<forall>k\\<in>{i..<ne+length aux}. MFOTL.sat \\<sigma> (map the v) k \\<phi>)\n          else (\\<exists>k\\<in>{i..<ne+length aux}. MFOTL.sat \\<sigma> (map the v) k \\<phi>)) r1 \\<and>\n      wf_table n (MFOTL.fv \\<psi>) (\\<lambda>v. \\<exists>j. i \\<le> j \\<and> j < ne + length aux \\<and> mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and>\n          MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n          (\\<forall>k\\<in>{i..<j}. if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi> else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>)) r2)\n    aux [ne..<ne+length aux]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_until_aux \\<sigma> n UNIV pos \\<phi> I \\<psi> aux ne =\n    list_all2\n     (\\<lambda>x i.\n         case x of\n         (t, r1, r2) \\<Rightarrow>\n           t = \\<tau> \\<sigma> i \\<and>\n           wf_table n (fv \\<phi>)\n            (\\<lambda>v.\n                if pos\n                then \\<forall>k\\<in>{i..<ne + length aux}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                else \\<exists>k\\<in>{i..<ne + length aux}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>)\n            r1 \\<and>\n           wf_table n (fv \\<psi>)\n            (\\<lambda>v.\n                \\<exists>j\\<ge>i.\n                   j < ne + length aux \\<and>\n                   mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and>\n                   MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n                   (\\<forall>k\\<in>{i..<j}.\n                       if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                       else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))\n            r2)\n     aux [ne..<ne + length aux]", "unfolding wf_until_aux_def qtable_mem_restr_UNIV"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>x i.\n         case x of\n         (t, r1, r2) \\<Rightarrow>\n           t = \\<tau> \\<sigma> i \\<and>\n           wf_table n (fv \\<phi>)\n            (\\<lambda>v.\n                if pos\n                then \\<forall>k\\<in>{i..<ne + length aux}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                else \\<exists>k\\<in>{i..<ne + length aux}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>)\n            r1 \\<and>\n           wf_table n (fv \\<psi>)\n            (\\<lambda>v.\n                \\<exists>j\\<ge>i.\n                   j < ne + length aux \\<and>\n                   mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and>\n                   MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n                   (\\<forall>k\\<in>{i..<j}.\n                       if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                       else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))\n            r2)\n     aux [ne..<ne + length aux] =\n    list_all2\n     (\\<lambda>x i.\n         case x of\n         (t, r1, r2) \\<Rightarrow>\n           t = \\<tau> \\<sigma> i \\<and>\n           wf_table n (fv \\<phi>)\n            (\\<lambda>v.\n                if pos\n                then \\<forall>k\\<in>{i..<ne + length aux}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                else \\<exists>k\\<in>{i..<ne + length aux}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>)\n            r1 \\<and>\n           wf_table n (fv \\<psi>)\n            (\\<lambda>v.\n                \\<exists>j\\<ge>i.\n                   j < ne + length aux \\<and>\n                   mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and>\n                   MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n                   (\\<forall>k\\<in>{i..<j}.\n                       if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                       else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))\n            r2)\n     aux [ne..<ne + length aux]", ".."], ["", "inductive wf_mformula :: \"'a MFOTL.trace \\<Rightarrow> nat \\<Rightarrow>\n  nat \\<Rightarrow> 'a list set \\<Rightarrow> 'a mformula \\<Rightarrow> 'a MFOTL.formula \\<Rightarrow> bool\"\n  for \\<sigma> j where\n  Eq: \"MFOTL.is_Const t1 \\<or> MFOTL.is_Const t2 \\<Longrightarrow>\n    \\<forall>x\\<in>MFOTL.fv_trm t1. x < n \\<Longrightarrow> \\<forall>x\\<in>MFOTL.fv_trm t2. x < n \\<Longrightarrow>\n    wf_mformula \\<sigma> j n R (MRel (eq_rel n t1 t2)) (MFOTL.Eq t1 t2)\"\n| neq_Const: \"\\<phi> = MRel (neq_rel n (MFOTL.Const x) (MFOTL.Const y)) \\<Longrightarrow>\n    wf_mformula \\<sigma> j n R \\<phi> (MFOTL.Neg (MFOTL.Eq (MFOTL.Const x) (MFOTL.Const y)))\"\n| neq_Var: \"x < n \\<Longrightarrow>\n    wf_mformula \\<sigma> j n R (MRel empty_table) (MFOTL.Neg (MFOTL.Eq (MFOTL.Var x) (MFOTL.Var x)))\"\n| Pred: \"\\<forall>x\\<in>MFOTL.fv (MFOTL.Pred e ts). x < n \\<Longrightarrow>\n    wf_mformula \\<sigma> j n R (MPred e ts) (MFOTL.Pred e ts)\"\n| And: \"wf_mformula \\<sigma> j n R \\<phi> \\<phi>' \\<Longrightarrow> wf_mformula \\<sigma> j n R \\<psi> \\<psi>' \\<Longrightarrow>\n    if pos then \\<chi> = MFOTL.And \\<phi>' \\<psi>' \\<and> \\<not> (safe_formula (MFOTL.Neg \\<psi>') \\<and> MFOTL.fv \\<psi>' \\<subseteq> MFOTL.fv \\<phi>')\n      else \\<chi> = MFOTL.And_Not \\<phi>' \\<psi>' \\<and> safe_formula \\<psi>' \\<and> MFOTL.fv \\<psi>' \\<subseteq> MFOTL.fv \\<phi>' \\<Longrightarrow>\n    wf_mbuf2' \\<sigma> j n R \\<phi>' \\<psi>' buf \\<Longrightarrow>\n    wf_mformula \\<sigma> j n R (MAnd \\<phi> pos \\<psi> buf) \\<chi>\"\n| Or: \"wf_mformula \\<sigma> j n R \\<phi> \\<phi>' \\<Longrightarrow> wf_mformula \\<sigma> j n R \\<psi> \\<psi>' \\<Longrightarrow>\n    MFOTL.fv \\<phi>' = MFOTL.fv \\<psi>' \\<Longrightarrow>\n    wf_mbuf2' \\<sigma> j n R \\<phi>' \\<psi>' buf \\<Longrightarrow>\n    wf_mformula \\<sigma> j n R (MOr \\<phi> \\<psi> buf) (MFOTL.Or \\<phi>' \\<psi>')\"\n| Exists: \"wf_mformula \\<sigma> j (Suc n) (lift_envs R) \\<phi> \\<phi>' \\<Longrightarrow>\n    wf_mformula \\<sigma> j n R (MExists \\<phi>) (MFOTL.Exists \\<phi>')\"\n| Prev: \"wf_mformula \\<sigma> j n R \\<phi> \\<phi>' \\<Longrightarrow>\n    first \\<longleftrightarrow> j = 0 \\<Longrightarrow>\n    list_all2 (\\<lambda>i. qtable n (MFOTL.fv \\<phi>') (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n      [min (progress \\<sigma> \\<phi>' j) (j-1)..<progress \\<sigma> \\<phi>' j] buf \\<Longrightarrow>\n    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [min (progress \\<sigma> \\<phi>' j) (j-1)..<j] nts \\<Longrightarrow>\n    wf_mformula \\<sigma> j n R (MPrev I \\<phi> first buf nts) (MFOTL.Prev I \\<phi>')\"\n| Next: \"wf_mformula \\<sigma> j n R \\<phi> \\<phi>' \\<Longrightarrow>\n    first \\<longleftrightarrow> progress \\<sigma> \\<phi>' j = 0 \\<Longrightarrow>\n    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [progress \\<sigma> \\<phi>' j - 1..<j] nts \\<Longrightarrow>\n    wf_mformula \\<sigma> j n R (MNext I \\<phi> first nts) (MFOTL.Next I \\<phi>')\"\n| Since: \"wf_mformula \\<sigma> j n R \\<phi> \\<phi>' \\<Longrightarrow> wf_mformula \\<sigma> j n R \\<psi> \\<psi>' \\<Longrightarrow>\n    if pos then \\<phi>'' = \\<phi>' else \\<phi>'' = MFOTL.Neg \\<phi>' \\<Longrightarrow>\n    safe_formula \\<phi>'' = pos \\<Longrightarrow>\n    MFOTL.fv \\<phi>' \\<subseteq> MFOTL.fv \\<psi>' \\<Longrightarrow>\n    wf_mbuf2' \\<sigma> j n R \\<phi>' \\<psi>' buf \\<Longrightarrow>\n    wf_ts \\<sigma> j \\<phi>' \\<psi>' nts \\<Longrightarrow>\n    wf_since_aux \\<sigma> n R pos \\<phi>' I \\<psi>' aux (progress \\<sigma> (MFOTL.Since \\<phi>'' I \\<psi>') j) \\<Longrightarrow>\n    wf_mformula \\<sigma> j n R (MSince pos \\<phi> I \\<psi> buf nts aux) (MFOTL.Since \\<phi>'' I \\<psi>')\"\n| Until: \"wf_mformula \\<sigma> j n R \\<phi> \\<phi>' \\<Longrightarrow> wf_mformula \\<sigma> j n R \\<psi> \\<psi>' \\<Longrightarrow>\n    if pos then \\<phi>'' = \\<phi>' else \\<phi>'' = MFOTL.Neg \\<phi>' \\<Longrightarrow>\n    safe_formula \\<phi>'' = pos \\<Longrightarrow>\n    MFOTL.fv \\<phi>' \\<subseteq> MFOTL.fv \\<psi>' \\<Longrightarrow>\n    wf_mbuf2' \\<sigma> j n R \\<phi>' \\<psi>' buf \\<Longrightarrow>\n    wf_ts \\<sigma> j \\<phi>' \\<psi>' nts \\<Longrightarrow>\n    wf_until_aux \\<sigma> n R pos \\<phi>' I \\<psi>' aux (progress \\<sigma> (MFOTL.Until \\<phi>'' I \\<psi>') j) \\<Longrightarrow>\n    progress \\<sigma> (MFOTL.Until \\<phi>'' I \\<psi>') j + length aux = min (progress \\<sigma> \\<phi>' j) (progress \\<sigma> \\<psi>' j) \\<Longrightarrow>\n    wf_mformula \\<sigma> j n R (MUntil pos \\<phi> I \\<psi> buf nts aux) (MFOTL.Until \\<phi>'' I \\<psi>')\""], ["", "definition wf_mstate :: \"'a MFOTL.formula \\<Rightarrow> 'a MFOTL.prefix \\<Rightarrow> 'a list set \\<Rightarrow> 'a mstate \\<Rightarrow> bool\" where\n  \"wf_mstate \\<phi> \\<pi> R st \\<longleftrightarrow> mstate_n st = MFOTL.nfv \\<phi> \\<and> (\\<forall>\\<sigma>. prefix_of \\<pi> \\<sigma> \\<longrightarrow>\n    mstate_i st = progress \\<sigma> \\<phi> (plen \\<pi>) \\<and>\n    wf_mformula \\<sigma> (plen \\<pi>) (mstate_n st) R (mstate_m st) \\<phi>)\""], ["", "subsubsection \\<open>Initialisation\\<close>"], ["", "lemma minit0_And: \"\\<not> (safe_formula (MFOTL.Neg \\<psi>) \\<and> MFOTL.fv \\<psi> \\<subseteq> MFOTL.fv \\<phi>) \\<Longrightarrow>\n     minit0 n (MFOTL.And \\<phi> \\<psi>) = MAnd (minit0 n \\<phi>) True (minit0 n \\<psi>) ([], [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (safe_formula (formula.Neg \\<psi>) \\<and>\n            fv \\<psi> \\<subseteq> fv \\<phi>) \\<Longrightarrow>\n    minit0 n (MFOTL.And \\<phi> \\<psi>) =\n    MAnd (minit0 n \\<phi>) True (minit0 n \\<psi>) ([], [])", "unfolding MFOTL.And_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (safe_formula (formula.Neg \\<psi>) \\<and>\n            fv \\<psi> \\<subseteq> fv \\<phi>) \\<Longrightarrow>\n    minit0 n\n     (formula.Neg (formula.Or (formula.Neg \\<phi>) (formula.Neg \\<psi>))) =\n    MAnd (minit0 n \\<phi>) True (minit0 n \\<psi>) ([], [])", "by simp"], ["", "lemma minit0_And_Not: \"safe_formula \\<psi> \\<and> MFOTL.fv \\<psi> \\<subseteq> MFOTL.fv \\<phi> \\<Longrightarrow>\n  minit0 n (MFOTL.And_Not \\<phi> \\<psi>) = (MAnd (minit0 n \\<phi>) False (minit0 n \\<psi>) ([], []))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe_formula \\<psi> \\<and>\n    fv \\<psi> \\<subseteq> fv \\<phi> \\<Longrightarrow>\n    minit0 n (MFOTL.And_Not \\<phi> \\<psi>) =\n    MAnd (minit0 n \\<phi>) False (minit0 n \\<psi>) ([], [])", "unfolding MFOTL.And_Not_def MFOTL.is_Neg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. safe_formula \\<psi> \\<and>\n    fv \\<psi> \\<subseteq> fv \\<phi> \\<Longrightarrow>\n    minit0 n (formula.Neg (formula.Or (formula.Neg \\<phi>) \\<psi>)) =\n    MAnd (minit0 n \\<phi>) False (minit0 n \\<psi>) ([], [])", "by (simp split: formula.split)"], ["", "lemma wf_mbuf2'_0: \"wf_mbuf2' \\<sigma> 0 n R \\<phi> \\<psi> ([], [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_mbuf2' \\<sigma> 0 n R \\<phi> \\<psi> ([], [])", "unfolding wf_mbuf2'_def wf_mbuf2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. min (Monitor.progress \\<sigma> \\<phi> 0)\n     (Monitor.progress \\<sigma> \\<psi> 0)\n    \\<le> Monitor.progress \\<sigma> \\<phi> 0 \\<and>\n    min (Monitor.progress \\<sigma> \\<phi> 0)\n     (Monitor.progress \\<sigma> \\<psi> 0)\n    \\<le> Monitor.progress \\<sigma> \\<psi> 0 \\<and>\n    (case ([], []) of\n     (xs, ys) \\<Rightarrow>\n       list_all2\n        (\\<lambda>i.\n            qtable n (fv \\<phi>) (mem_restr R)\n             (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n        [min (Monitor.progress \\<sigma> \\<phi> 0)\n          (Monitor.progress \\<sigma> \\<psi> 0)..<\n         Monitor.progress \\<sigma> \\<phi> 0]\n        xs \\<and>\n       list_all2\n        (\\<lambda>i.\n            qtable n (fv \\<psi>) (mem_restr R)\n             (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n        [min (Monitor.progress \\<sigma> \\<phi> 0)\n          (Monitor.progress \\<sigma> \\<psi> 0)..<\n         Monitor.progress \\<sigma> \\<psi> 0]\n        ys)", "by simp"], ["", "lemma wf_ts_0: \"wf_ts \\<sigma> 0 \\<phi> \\<psi> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_ts \\<sigma> 0 \\<phi> \\<psi> []", "unfolding wf_ts_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n     [min (Monitor.progress \\<sigma> \\<phi> 0)\n       (Monitor.progress \\<sigma> \\<psi> 0)..<\n      0]\n     []", "by simp"], ["", "lemma wf_since_aux_Nil: \"wf_since_aux \\<sigma> n R pos \\<phi>' I \\<psi>' [] 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_since_aux \\<sigma> n R pos \\<phi>' I \\<psi>' [] 0", "unfolding wf_since_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. fst y < fst x) [] \\<and>\n    (\\<forall>t X.\n        (t, X) \\<in> set [] \\<longrightarrow>\n        0 \\<noteq> 0 \\<and>\n        t \\<le> \\<tau> \\<sigma> (0 - 1) \\<and>\n        enat (\\<tau> \\<sigma> (0 - 1) - t) \\<le> right I \\<and>\n        (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n        qtable n (fv \\<psi>') (mem_restr R)\n         (\\<lambda>v.\n             MFOTL.sat \\<sigma> (map the v) (0 - 1)\n              (Sincep pos \\<phi>' (point (\\<tau> \\<sigma> (0 - 1) - t))\n                \\<psi>'))\n         X) \\<and>\n    (\\<forall>t.\n        0 \\<noteq> 0 \\<and>\n        t \\<le> \\<tau> \\<sigma> (0 - 1) \\<and>\n        enat (\\<tau> \\<sigma> (0 - 1) - t) \\<le> right I \\<and>\n        (\\<exists>i. \\<tau> \\<sigma> i = t) \\<longrightarrow>\n        (\\<exists>X. (t, X) \\<in> set []))", "by simp"], ["", "lemma wf_until_aux_Nil: \"wf_until_aux \\<sigma> n R pos \\<phi>' I \\<psi>' [] 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_until_aux \\<sigma> n R pos \\<phi>' I \\<psi>' [] 0", "unfolding wf_until_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>x i.\n         case x of\n         (t, r1, r2) \\<Rightarrow>\n           t = \\<tau> \\<sigma> i \\<and>\n           qtable n (fv \\<phi>') (mem_restr R)\n            (\\<lambda>v.\n                if pos\n                then \\<forall>k\\<in>{i..<0 + length []}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>'\n                else \\<exists>k\\<in>{i..<0 + length []}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>')\n            r1 \\<and>\n           qtable n (fv \\<psi>') (mem_restr R)\n            (\\<lambda>v.\n                \\<exists>j\\<ge>i.\n                   j < 0 + length [] \\<and>\n                   mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and>\n                   MFOTL.sat \\<sigma> (map the v) j \\<psi>' \\<and>\n                   (\\<forall>k\\<in>{i..<j}.\n                       if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>'\n                       else \\<not> MFOTL.sat \\<sigma> (map the v) k\n                                    \\<phi>'))\n            r2)\n     [] [0..<0 + length []]", "by simp"], ["", "lemma wf_minit0: \"safe_formula \\<phi> \\<Longrightarrow> \\<forall>x\\<in>MFOTL.fv \\<phi>. x < n \\<Longrightarrow>\n  wf_mformula \\<sigma> 0 n R (minit0 n \\<phi>) \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>safe_formula \\<phi>; \\<forall>x\\<in>fv \\<phi>. x < n\\<rbrakk>\n    \\<Longrightarrow> wf_mformula \\<sigma> 0 n R (minit0 n \\<phi>) \\<phi>", "by (induction arbitrary: n R rule: safe_formula_induct)\n    (auto simp add: minit0_And fvi_And minit0_And_Not fvi_And_Not\n      intro!: wf_mformula.intros wf_mbuf2'_0 wf_ts_0 wf_since_aux_Nil wf_until_aux_Nil\n      dest: fvi_Suc_bound)"], ["", "lemma wf_mstate_minit: \"safe_formula \\<phi> \\<Longrightarrow> wf_mstate \\<phi> pnil R (minit \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe_formula \\<phi> \\<Longrightarrow>\n    wf_mstate \\<phi> pnil R (minit \\<phi>)", "unfolding wf_mstate_def minit_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. safe_formula \\<phi> \\<Longrightarrow>\n    mstate_n\n     \\<lparr>mstate_i = 0, mstate_m = minit0 (MFOTL.nfv \\<phi>) \\<phi>,\n        mstate_n = MFOTL.nfv \\<phi>\\<rparr> =\n    MFOTL.nfv \\<phi> \\<and>\n    (\\<forall>\\<sigma>.\n        prefix_of pnil \\<sigma> \\<longrightarrow>\n        mstate_i\n         \\<lparr>mstate_i = 0, mstate_m = minit0 (MFOTL.nfv \\<phi>) \\<phi>,\n            mstate_n = MFOTL.nfv \\<phi>\\<rparr> =\n        Monitor.progress \\<sigma> \\<phi> (plen pnil) \\<and>\n        wf_mformula \\<sigma> (plen pnil)\n         (mstate_n\n           \\<lparr>mstate_i = 0,\n              mstate_m = minit0 (MFOTL.nfv \\<phi>) \\<phi>,\n              mstate_n = MFOTL.nfv \\<phi>\\<rparr>)\n         R (mstate_m\n             \\<lparr>mstate_i = 0,\n                mstate_m = minit0 (MFOTL.nfv \\<phi>) \\<phi>,\n                mstate_n = MFOTL.nfv \\<phi>\\<rparr>)\n         \\<phi>)", "by (auto intro!: wf_minit0 fvi_less_nfv)"], ["", "subsubsection \\<open>Evaluation\\<close>"], ["", "lemma match_wf_tuple: \"Some f = match ts xs \\<Longrightarrow> wf_tuple n (\\<Union>t\\<in>set ts. MFOTL.fv_trm t) (tabulate f 0 n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some f = match ts xs \\<Longrightarrow>\n    wf_tuple n (\\<Union> (fv_trm ` set ts)) (tabulate f 0 n)", "by (induction ts xs arbitrary: f rule: match.induct)\n    (fastforce simp: wf_tuple_def split: if_splits option.splits)+"], ["", "lemma match_fvi_trm_None: \"Some f = match ts xs \\<Longrightarrow> \\<forall>t\\<in>set ts. x \\<notin> MFOTL.fv_trm t \\<Longrightarrow> f x = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Some f = match ts xs;\n     \\<forall>t\\<in>set ts. x \\<notin> fv_trm t\\<rbrakk>\n    \\<Longrightarrow> f x = None", "by (induction ts xs arbitrary: f rule: match.induct) (auto split: if_splits option.splits)"], ["", "lemma match_fvi_trm_Some: \"Some f = match ts xs \\<Longrightarrow> t \\<in> set ts \\<Longrightarrow> x \\<in> MFOTL.fv_trm t \\<Longrightarrow> f x \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Some f = match ts xs; t \\<in> set ts; x \\<in> fv_trm t\\<rbrakk>\n    \\<Longrightarrow> f x \\<noteq> None", "by (induction ts xs arbitrary: f rule: match.induct) (auto split: if_splits option.splits)"], ["", "lemma match_eval_trm: \"\\<forall>t\\<in>set ts. \\<forall>i\\<in>MFOTL.fv_trm t. i < n \\<Longrightarrow> Some f = match ts xs \\<Longrightarrow>\n    map (MFOTL.eval_trm (tabulate (\\<lambda>i. the (f i)) 0 n)) ts = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t\\<in>set ts. \\<forall>i\\<in>fv_trm t. i < n;\n     Some f = match ts xs\\<rbrakk>\n    \\<Longrightarrow> map (MFOTL.eval_trm\n                            (tabulate (\\<lambda>i. the (f i)) 0 n))\n                       ts =\n                      xs", "proof (induction ts xs arbitrary: f rule: match.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>\\<forall>t\\<in>set []. \\<forall>i\\<in>fv_trm t. i < n;\n        Some f = match [] []\\<rbrakk>\n       \\<Longrightarrow> map (MFOTL.eval_trm\n                               (tabulate (\\<lambda>i. the (f i)) 0 n))\n                          [] =\n                         []\n 2. \\<And>x ts y ys f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>x = y;\n                    \\<forall>t\\<in>set ts. \\<forall>i\\<in>fv_trm t. i < n;\n                    Some f = match ts ys\\<rbrakk>\n                   \\<Longrightarrow> map\n(MFOTL.eval_trm (tabulate (\\<lambda>i. the (f i)) 0 n)) ts =\n                                     ys;\n        \\<forall>t\\<in>set (trm.Const x # ts).\n           \\<forall>i\\<in>fv_trm t. i < n;\n        Some f = match (trm.Const x # ts) (y # ys)\\<rbrakk>\n       \\<Longrightarrow> map (MFOTL.eval_trm\n                               (tabulate (\\<lambda>i. the (f i)) 0 n))\n                          (trm.Const x # ts) =\n                         y # ys\n 3. \\<And>x ts y ys f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>\\<forall>t\\<in>set ts.\n                               \\<forall>i\\<in>fv_trm t. i < n;\n                    Some f = match ts ys\\<rbrakk>\n                   \\<Longrightarrow> map\n(MFOTL.eval_trm (tabulate (\\<lambda>i. the (f i)) 0 n)) ts =\n                                     ys;\n        \\<forall>t\\<in>set (trm.Var x # ts). \\<forall>i\\<in>fv_trm t. i < n;\n        Some f = match (trm.Var x # ts) (y # ys)\\<rbrakk>\n       \\<Longrightarrow> map (MFOTL.eval_trm\n                               (tabulate (\\<lambda>i. the (f i)) 0 n))\n                          (trm.Var x # ts) =\n                         y # ys\n 4. \\<And>vb va f.\n       \\<lbrakk>\\<forall>t\\<in>set (trm.Var vb # va).\n                   \\<forall>i\\<in>fv_trm t. i < n;\n        Some f = match (trm.Var vb # va) []\\<rbrakk>\n       \\<Longrightarrow> map (MFOTL.eval_trm\n                               (tabulate (\\<lambda>i. the (f i)) 0 n))\n                          (trm.Var vb # va) =\n                         []\n 5. \\<And>v va f.\n       \\<lbrakk>\\<forall>t\\<in>set (v # va). \\<forall>i\\<in>fv_trm t. i < n;\n        Some f = match (v # va) []\\<rbrakk>\n       \\<Longrightarrow> map (MFOTL.eval_trm\n                               (tabulate (\\<lambda>i. the (f i)) 0 n))\n                          (v # va) =\n                         []\n 6. \\<And>v va f.\n       \\<lbrakk>\\<forall>t\\<in>set []. \\<forall>i\\<in>fv_trm t. i < n;\n        Some f = match [] (v # va)\\<rbrakk>\n       \\<Longrightarrow> map (MFOTL.eval_trm\n                               (tabulate (\\<lambda>i. the (f i)) 0 n))\n                          [] =\n                         v # va", "case (3 x ts y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>t\\<in>set ts. \\<forall>i\\<in>fv_trm t. i < n;\n   Some ?f = match ts ys\\<rbrakk>\n  \\<Longrightarrow> map (MFOTL.eval_trm\n                          (tabulate (\\<lambda>i. the (?f i)) 0 n))\n                     ts =\n                    ys\n  \\<forall>t\\<in>set (trm.Var x # ts). \\<forall>i\\<in>fv_trm t. i < n\n  Some f = match (trm.Var x # ts) (y # ys)\n\ngoal (6 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>\\<forall>t\\<in>set []. \\<forall>i\\<in>fv_trm t. i < n;\n        Some f = match [] []\\<rbrakk>\n       \\<Longrightarrow> map (MFOTL.eval_trm\n                               (tabulate (\\<lambda>i. the (f i)) 0 n))\n                          [] =\n                         []\n 2. \\<And>x ts y ys f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>x = y;\n                    \\<forall>t\\<in>set ts. \\<forall>i\\<in>fv_trm t. i < n;\n                    Some f = match ts ys\\<rbrakk>\n                   \\<Longrightarrow> map\n(MFOTL.eval_trm (tabulate (\\<lambda>i. the (f i)) 0 n)) ts =\n                                     ys;\n        \\<forall>t\\<in>set (trm.Const x # ts).\n           \\<forall>i\\<in>fv_trm t. i < n;\n        Some f = match (trm.Const x # ts) (y # ys)\\<rbrakk>\n       \\<Longrightarrow> map (MFOTL.eval_trm\n                               (tabulate (\\<lambda>i. the (f i)) 0 n))\n                          (trm.Const x # ts) =\n                         y # ys\n 3. \\<And>x ts y ys f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>\\<forall>t\\<in>set ts.\n                               \\<forall>i\\<in>fv_trm t. i < n;\n                    Some f = match ts ys\\<rbrakk>\n                   \\<Longrightarrow> map\n(MFOTL.eval_trm (tabulate (\\<lambda>i. the (f i)) 0 n)) ts =\n                                     ys;\n        \\<forall>t\\<in>set (trm.Var x # ts). \\<forall>i\\<in>fv_trm t. i < n;\n        Some f = match (trm.Var x # ts) (y # ys)\\<rbrakk>\n       \\<Longrightarrow> map (MFOTL.eval_trm\n                               (tabulate (\\<lambda>i. the (f i)) 0 n))\n                          (trm.Var x # ts) =\n                         y # ys\n 4. \\<And>vb va f.\n       \\<lbrakk>\\<forall>t\\<in>set (trm.Var vb # va).\n                   \\<forall>i\\<in>fv_trm t. i < n;\n        Some f = match (trm.Var vb # va) []\\<rbrakk>\n       \\<Longrightarrow> map (MFOTL.eval_trm\n                               (tabulate (\\<lambda>i. the (f i)) 0 n))\n                          (trm.Var vb # va) =\n                         []\n 5. \\<And>v va f.\n       \\<lbrakk>\\<forall>t\\<in>set (v # va). \\<forall>i\\<in>fv_trm t. i < n;\n        Some f = match (v # va) []\\<rbrakk>\n       \\<Longrightarrow> map (MFOTL.eval_trm\n                               (tabulate (\\<lambda>i. the (f i)) 0 n))\n                          (v # va) =\n                         []\n 6. \\<And>v va f.\n       \\<lbrakk>\\<forall>t\\<in>set []. \\<forall>i\\<in>fv_trm t. i < n;\n        Some f = match [] (v # va)\\<rbrakk>\n       \\<Longrightarrow> map (MFOTL.eval_trm\n                               (tabulate (\\<lambda>i. the (f i)) 0 n))\n                          [] =\n                         v # va", "from 3(1)[symmetric] 3(2,3)"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>t\\<in>set ts. \\<forall>i\\<in>fv_trm t. i < n;\n   Some ?f = match ts ys\\<rbrakk>\n  \\<Longrightarrow> ys =\n                    map (MFOTL.eval_trm\n                          (tabulate (\\<lambda>i. the (?f i)) 0 n))\n                     ts\n  \\<forall>t\\<in>set (trm.Var x # ts). \\<forall>i\\<in>fv_trm t. i < n\n  Some f = match (trm.Var x # ts) (y # ys)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>t\\<in>set ts. \\<forall>i\\<in>fv_trm t. i < n;\n   Some ?f = match ts ys\\<rbrakk>\n  \\<Longrightarrow> ys =\n                    map (MFOTL.eval_trm\n                          (tabulate (\\<lambda>i. the (?f i)) 0 n))\n                     ts\n  \\<forall>t\\<in>set (trm.Var x # ts). \\<forall>i\\<in>fv_trm t. i < n\n  Some f = match (trm.Var x # ts) (y # ys)\n\ngoal (1 subgoal):\n 1. map (MFOTL.eval_trm (tabulate (\\<lambda>i. the (f i)) 0 n))\n     (trm.Var x # ts) =\n    y # ys", "by (auto 0 3 dest: match_fvi_trm_Some sym split: option.splits if_splits intro!: eval_trm_cong)"], ["proof (state)\nthis:\n  map (MFOTL.eval_trm (tabulate (\\<lambda>i. the (f i)) 0 n))\n   (trm.Var x # ts) =\n  y # ys\n\ngoal (5 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>\\<forall>t\\<in>set []. \\<forall>i\\<in>fv_trm t. i < n;\n        Some f = match [] []\\<rbrakk>\n       \\<Longrightarrow> map (MFOTL.eval_trm\n                               (tabulate (\\<lambda>i. the (f i)) 0 n))\n                          [] =\n                         []\n 2. \\<And>x ts y ys f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>x = y;\n                    \\<forall>t\\<in>set ts. \\<forall>i\\<in>fv_trm t. i < n;\n                    Some f = match ts ys\\<rbrakk>\n                   \\<Longrightarrow> map\n(MFOTL.eval_trm (tabulate (\\<lambda>i. the (f i)) 0 n)) ts =\n                                     ys;\n        \\<forall>t\\<in>set (trm.Const x # ts).\n           \\<forall>i\\<in>fv_trm t. i < n;\n        Some f = match (trm.Const x # ts) (y # ys)\\<rbrakk>\n       \\<Longrightarrow> map (MFOTL.eval_trm\n                               (tabulate (\\<lambda>i. the (f i)) 0 n))\n                          (trm.Const x # ts) =\n                         y # ys\n 3. \\<And>vb va f.\n       \\<lbrakk>\\<forall>t\\<in>set (trm.Var vb # va).\n                   \\<forall>i\\<in>fv_trm t. i < n;\n        Some f = match (trm.Var vb # va) []\\<rbrakk>\n       \\<Longrightarrow> map (MFOTL.eval_trm\n                               (tabulate (\\<lambda>i. the (f i)) 0 n))\n                          (trm.Var vb # va) =\n                         []\n 4. \\<And>v va f.\n       \\<lbrakk>\\<forall>t\\<in>set (v # va). \\<forall>i\\<in>fv_trm t. i < n;\n        Some f = match (v # va) []\\<rbrakk>\n       \\<Longrightarrow> map (MFOTL.eval_trm\n                               (tabulate (\\<lambda>i. the (f i)) 0 n))\n                          (v # va) =\n                         []\n 5. \\<And>v va f.\n       \\<lbrakk>\\<forall>t\\<in>set []. \\<forall>i\\<in>fv_trm t. i < n;\n        Some f = match [] (v # va)\\<rbrakk>\n       \\<Longrightarrow> map (MFOTL.eval_trm\n                               (tabulate (\\<lambda>i. the (f i)) 0 n))\n                          [] =\n                         v # va", "qed (auto split: if_splits)"], ["", "lemma wf_tuple_tabulate_Some: \"wf_tuple n A (tabulate f 0 n) \\<Longrightarrow> x \\<in> A \\<Longrightarrow> x < n \\<Longrightarrow> \\<exists>y. f x = Some y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_tuple n A (tabulate f 0 n); x \\<in> A; x < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y. f x = Some y", "unfolding wf_tuple_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length (tabulate f 0 n) = n \\<and>\n             (\\<forall>i<n. (tabulate f 0 n ! i = None) = (i \\<notin> A));\n     x \\<in> A; x < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y. f x = Some y", "by auto"], ["", "lemma ex_match: \"wf_tuple n (\\<Union>t\\<in>set ts. MFOTL.fv_trm t) v \\<Longrightarrow> \\<forall>t\\<in>set ts. \\<forall>x\\<in>MFOTL.fv_trm t. x < n \\<Longrightarrow>\n    \\<exists>f. match ts (map (MFOTL.eval_trm (map the v)) ts) = Some f \\<and> v = tabulate f 0 n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_tuple n (\\<Union> (fv_trm ` set ts)) v;\n     \\<forall>t\\<in>set ts. \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f.\n                         match ts (map (MFOTL.eval_trm (map the v)) ts) =\n                         Some f \\<and>\n                         v = tabulate f 0 n", "proof (induction ts \"map (MFOTL.eval_trm (map the v)) ts\" arbitrary: v rule: match.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>[] = map (MFOTL.eval_trm (map the v)) [];\n        wf_tuple n (\\<Union> (fv_trm ` set [])) v;\n        \\<forall>t\\<in>set []. \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            match [] (map (MFOTL.eval_trm (map the v)) []) =\n                            Some f \\<and>\n                            v = tabulate f 0 n\n 2. \\<And>x ts y ys v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>x = y; ys = map (MFOTL.eval_trm (map the v)) ts;\n                    wf_tuple n (\\<Union> (fv_trm ` set ts)) v;\n                    \\<forall>t\\<in>set ts.\n                       \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>f.\n  match ts (map (MFOTL.eval_trm (map the v)) ts) = Some f \\<and>\n  v = tabulate f 0 n;\n        y # ys = map (MFOTL.eval_trm (map the v)) (trm.Const x # ts);\n        wf_tuple n (\\<Union> (fv_trm ` set (trm.Const x # ts))) v;\n        \\<forall>t\\<in>set (trm.Const x # ts).\n           \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            match (trm.Const x # ts)\n                             (map (MFOTL.eval_trm (map the v))\n                               (trm.Const x # ts)) =\n                            Some f \\<and>\n                            v = tabulate f 0 n\n 3. \\<And>x ts y ys v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>ys = map (MFOTL.eval_trm (map the v)) ts;\n                    wf_tuple n (\\<Union> (fv_trm ` set ts)) v;\n                    \\<forall>t\\<in>set ts.\n                       \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>f.\n  match ts (map (MFOTL.eval_trm (map the v)) ts) = Some f \\<and>\n  v = tabulate f 0 n;\n        y # ys = map (MFOTL.eval_trm (map the v)) (trm.Var x # ts);\n        wf_tuple n (\\<Union> (fv_trm ` set (trm.Var x # ts))) v;\n        \\<forall>t\\<in>set (trm.Var x # ts).\n           \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            match (trm.Var x # ts)\n                             (map (MFOTL.eval_trm (map the v))\n                               (trm.Var x # ts)) =\n                            Some f \\<and>\n                            v = tabulate f 0 n\n 4. \\<And>vb va v.\n       \\<lbrakk>[] = map (MFOTL.eval_trm (map the v)) (trm.Var vb # va);\n        wf_tuple n (\\<Union> (fv_trm ` set (trm.Var vb # va))) v;\n        \\<forall>t\\<in>set (trm.Var vb # va).\n           \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            match (trm.Var vb # va)\n                             (map (MFOTL.eval_trm (map the v))\n                               (trm.Var vb # va)) =\n                            Some f \\<and>\n                            v = tabulate f 0 n\n 5. \\<And>v va vb.\n       \\<lbrakk>[] = map (MFOTL.eval_trm (map the vb)) (v # va);\n        wf_tuple n (\\<Union> (fv_trm ` set (v # va))) vb;\n        \\<forall>t\\<in>set (v # va). \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            match (v # va)\n                             (map (MFOTL.eval_trm (map the vb)) (v # va)) =\n                            Some f \\<and>\n                            vb = tabulate f 0 n\n 6. \\<And>v va vb.\n       \\<lbrakk>v # va = map (MFOTL.eval_trm (map the vb)) [];\n        wf_tuple n (\\<Union> (fv_trm ` set [])) vb;\n        \\<forall>t\\<in>set []. \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            match []\n                             (map (MFOTL.eval_trm (map the vb)) []) =\n                            Some f \\<and>\n                            vb = tabulate f 0 n", "case (3 x ts y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>ys = map (MFOTL.eval_trm (map the ?v)) ts;\n   wf_tuple n (\\<Union> (fv_trm ` set ts)) ?v;\n   \\<forall>t\\<in>set ts. \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f.\n                       match ts (map (MFOTL.eval_trm (map the ?v)) ts) =\n                       Some f \\<and>\n                       ?v = tabulate f 0 n\n  y # ys = map (MFOTL.eval_trm (map the v)) (trm.Var x # ts)\n  wf_tuple n (\\<Union> (fv_trm ` set (trm.Var x # ts))) v\n  \\<forall>t\\<in>set (trm.Var x # ts). \\<forall>x\\<in>fv_trm t. x < n\n\ngoal (6 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>[] = map (MFOTL.eval_trm (map the v)) [];\n        wf_tuple n (\\<Union> (fv_trm ` set [])) v;\n        \\<forall>t\\<in>set []. \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            match [] (map (MFOTL.eval_trm (map the v)) []) =\n                            Some f \\<and>\n                            v = tabulate f 0 n\n 2. \\<And>x ts y ys v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>x = y; ys = map (MFOTL.eval_trm (map the v)) ts;\n                    wf_tuple n (\\<Union> (fv_trm ` set ts)) v;\n                    \\<forall>t\\<in>set ts.\n                       \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>f.\n  match ts (map (MFOTL.eval_trm (map the v)) ts) = Some f \\<and>\n  v = tabulate f 0 n;\n        y # ys = map (MFOTL.eval_trm (map the v)) (trm.Const x # ts);\n        wf_tuple n (\\<Union> (fv_trm ` set (trm.Const x # ts))) v;\n        \\<forall>t\\<in>set (trm.Const x # ts).\n           \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            match (trm.Const x # ts)\n                             (map (MFOTL.eval_trm (map the v))\n                               (trm.Const x # ts)) =\n                            Some f \\<and>\n                            v = tabulate f 0 n\n 3. \\<And>x ts y ys v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>ys = map (MFOTL.eval_trm (map the v)) ts;\n                    wf_tuple n (\\<Union> (fv_trm ` set ts)) v;\n                    \\<forall>t\\<in>set ts.\n                       \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>f.\n  match ts (map (MFOTL.eval_trm (map the v)) ts) = Some f \\<and>\n  v = tabulate f 0 n;\n        y # ys = map (MFOTL.eval_trm (map the v)) (trm.Var x # ts);\n        wf_tuple n (\\<Union> (fv_trm ` set (trm.Var x # ts))) v;\n        \\<forall>t\\<in>set (trm.Var x # ts).\n           \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            match (trm.Var x # ts)\n                             (map (MFOTL.eval_trm (map the v))\n                               (trm.Var x # ts)) =\n                            Some f \\<and>\n                            v = tabulate f 0 n\n 4. \\<And>vb va v.\n       \\<lbrakk>[] = map (MFOTL.eval_trm (map the v)) (trm.Var vb # va);\n        wf_tuple n (\\<Union> (fv_trm ` set (trm.Var vb # va))) v;\n        \\<forall>t\\<in>set (trm.Var vb # va).\n           \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            match (trm.Var vb # va)\n                             (map (MFOTL.eval_trm (map the v))\n                               (trm.Var vb # va)) =\n                            Some f \\<and>\n                            v = tabulate f 0 n\n 5. \\<And>v va vb.\n       \\<lbrakk>[] = map (MFOTL.eval_trm (map the vb)) (v # va);\n        wf_tuple n (\\<Union> (fv_trm ` set (v # va))) vb;\n        \\<forall>t\\<in>set (v # va). \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            match (v # va)\n                             (map (MFOTL.eval_trm (map the vb)) (v # va)) =\n                            Some f \\<and>\n                            vb = tabulate f 0 n\n 6. \\<And>v va vb.\n       \\<lbrakk>v # va = map (MFOTL.eval_trm (map the vb)) [];\n        wf_tuple n (\\<Union> (fv_trm ` set [])) vb;\n        \\<forall>t\\<in>set []. \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            match []\n                             (map (MFOTL.eval_trm (map the vb)) []) =\n                            Some f \\<and>\n                            vb = tabulate f 0 n", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>ys = map (MFOTL.eval_trm (map the ?v)) ts;\n   wf_tuple n (\\<Union> (fv_trm ` set ts)) ?v;\n   \\<forall>t\\<in>set ts. \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f.\n                       match ts (map (MFOTL.eval_trm (map the ?v)) ts) =\n                       Some f \\<and>\n                       ?v = tabulate f 0 n\n  y # ys = map (MFOTL.eval_trm (map the v)) (trm.Var x # ts)\n  wf_tuple n (\\<Union> (fv_trm ` set (trm.Var x # ts))) v\n  \\<forall>t\\<in>set (trm.Var x # ts). \\<forall>x\\<in>fv_trm t. x < n", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>ys = map (MFOTL.eval_trm (map the ?v)) ts;\n   wf_tuple n (\\<Union> (fv_trm ` set ts)) ?v;\n   \\<forall>t\\<in>set ts. \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f.\n                       match ts (map (MFOTL.eval_trm (map the ?v)) ts) =\n                       Some f \\<and>\n                       ?v = tabulate f 0 n\n  y # ys = map (MFOTL.eval_trm (map the v)) (trm.Var x # ts)\n  wf_tuple n (\\<Union> (fv_trm ` set (trm.Var x # ts))) v\n  \\<forall>t\\<in>set (trm.Var x # ts). \\<forall>x\\<in>fv_trm t. x < n\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       match (trm.Var x # ts)\n        (map (MFOTL.eval_trm (map the v)) (trm.Var x # ts)) =\n       Some f \\<and>\n       v = tabulate f 0 n", "proof (cases \"x \\<in> (\\<Union>t\\<in>set ts. MFOTL.fv_trm t)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v.\n                \\<lbrakk>ys = map (MFOTL.eval_trm (map the v)) ts;\n                 wf_tuple n (\\<Union> (fv_trm ` set ts)) v;\n                 \\<forall>t\\<in>set ts.\n                    \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n                \\<Longrightarrow> \\<exists>f.\n                                     match ts\n(map (MFOTL.eval_trm (map the v)) ts) =\n                                     Some f \\<and>\n                                     v = tabulate f 0 n;\n     y # ys = map (MFOTL.eval_trm (map the v)) (trm.Var x # ts);\n     wf_tuple n (\\<Union> (fv_trm ` set (trm.Var x # ts))) v;\n     \\<forall>t\\<in>set (trm.Var x # ts). \\<forall>x\\<in>fv_trm t. x < n;\n     x \\<in> \\<Union> (fv_trm ` set ts)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f.\n                         match (trm.Var x # ts)\n                          (map (MFOTL.eval_trm (map the v))\n                            (trm.Var x # ts)) =\n                         Some f \\<and>\n                         v = tabulate f 0 n\n 2. \\<lbrakk>\\<And>v.\n                \\<lbrakk>ys = map (MFOTL.eval_trm (map the v)) ts;\n                 wf_tuple n (\\<Union> (fv_trm ` set ts)) v;\n                 \\<forall>t\\<in>set ts.\n                    \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n                \\<Longrightarrow> \\<exists>f.\n                                     match ts\n(map (MFOTL.eval_trm (map the v)) ts) =\n                                     Some f \\<and>\n                                     v = tabulate f 0 n;\n     y # ys = map (MFOTL.eval_trm (map the v)) (trm.Var x # ts);\n     wf_tuple n (\\<Union> (fv_trm ` set (trm.Var x # ts))) v;\n     \\<forall>t\\<in>set (trm.Var x # ts). \\<forall>x\\<in>fv_trm t. x < n;\n     x \\<notin> \\<Union> (fv_trm ` set ts)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f.\n                         match (trm.Var x # ts)\n                          (map (MFOTL.eval_trm (map the v))\n                            (trm.Var x # ts)) =\n                         Some f \\<and>\n                         v = tabulate f 0 n", "case True"], ["proof (state)\nthis:\n  x \\<in> \\<Union> (fv_trm ` set ts)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v.\n                \\<lbrakk>ys = map (MFOTL.eval_trm (map the v)) ts;\n                 wf_tuple n (\\<Union> (fv_trm ` set ts)) v;\n                 \\<forall>t\\<in>set ts.\n                    \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n                \\<Longrightarrow> \\<exists>f.\n                                     match ts\n(map (MFOTL.eval_trm (map the v)) ts) =\n                                     Some f \\<and>\n                                     v = tabulate f 0 n;\n     y # ys = map (MFOTL.eval_trm (map the v)) (trm.Var x # ts);\n     wf_tuple n (\\<Union> (fv_trm ` set (trm.Var x # ts))) v;\n     \\<forall>t\\<in>set (trm.Var x # ts). \\<forall>x\\<in>fv_trm t. x < n;\n     x \\<in> \\<Union> (fv_trm ` set ts)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f.\n                         match (trm.Var x # ts)\n                          (map (MFOTL.eval_trm (map the v))\n                            (trm.Var x # ts)) =\n                         Some f \\<and>\n                         v = tabulate f 0 n\n 2. \\<lbrakk>\\<And>v.\n                \\<lbrakk>ys = map (MFOTL.eval_trm (map the v)) ts;\n                 wf_tuple n (\\<Union> (fv_trm ` set ts)) v;\n                 \\<forall>t\\<in>set ts.\n                    \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n                \\<Longrightarrow> \\<exists>f.\n                                     match ts\n(map (MFOTL.eval_trm (map the v)) ts) =\n                                     Some f \\<and>\n                                     v = tabulate f 0 n;\n     y # ys = map (MFOTL.eval_trm (map the v)) (trm.Var x # ts);\n     wf_tuple n (\\<Union> (fv_trm ` set (trm.Var x # ts))) v;\n     \\<forall>t\\<in>set (trm.Var x # ts). \\<forall>x\\<in>fv_trm t. x < n;\n     x \\<notin> \\<Union> (fv_trm ` set ts)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f.\n                         match (trm.Var x # ts)\n                          (map (MFOTL.eval_trm (map the v))\n                            (trm.Var x # ts)) =\n                         Some f \\<and>\n                         v = tabulate f 0 n", "with 3"], ["proof (chain)\npicking this:\n  \\<lbrakk>ys = map (MFOTL.eval_trm (map the ?v)) ts;\n   wf_tuple n (\\<Union> (fv_trm ` set ts)) ?v;\n   \\<forall>t\\<in>set ts. \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f.\n                       match ts (map (MFOTL.eval_trm (map the ?v)) ts) =\n                       Some f \\<and>\n                       ?v = tabulate f 0 n\n  y # ys = map (MFOTL.eval_trm (map the v)) (trm.Var x # ts)\n  wf_tuple n (\\<Union> (fv_trm ` set (trm.Var x # ts))) v\n  \\<forall>t\\<in>set (trm.Var x # ts). \\<forall>x\\<in>fv_trm t. x < n\n  x \\<in> \\<Union> (fv_trm ` set ts)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>ys = map (MFOTL.eval_trm (map the ?v)) ts;\n   wf_tuple n (\\<Union> (fv_trm ` set ts)) ?v;\n   \\<forall>t\\<in>set ts. \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f.\n                       match ts (map (MFOTL.eval_trm (map the ?v)) ts) =\n                       Some f \\<and>\n                       ?v = tabulate f 0 n\n  y # ys = map (MFOTL.eval_trm (map the v)) (trm.Var x # ts)\n  wf_tuple n (\\<Union> (fv_trm ` set (trm.Var x # ts))) v\n  \\<forall>t\\<in>set (trm.Var x # ts). \\<forall>x\\<in>fv_trm t. x < n\n  x \\<in> \\<Union> (fv_trm ` set ts)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       match (trm.Var x # ts)\n        (map (MFOTL.eval_trm (map the v)) (trm.Var x # ts)) =\n       Some f \\<and>\n       v = tabulate f 0 n", "by (auto simp: insert_absorb dest!: wf_tuple_tabulate_Some meta_spec[of _ v])"], ["proof (state)\nthis:\n  \\<exists>f.\n     match (trm.Var x # ts)\n      (map (MFOTL.eval_trm (map the v)) (trm.Var x # ts)) =\n     Some f \\<and>\n     v = tabulate f 0 n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v.\n                \\<lbrakk>ys = map (MFOTL.eval_trm (map the v)) ts;\n                 wf_tuple n (\\<Union> (fv_trm ` set ts)) v;\n                 \\<forall>t\\<in>set ts.\n                    \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n                \\<Longrightarrow> \\<exists>f.\n                                     match ts\n(map (MFOTL.eval_trm (map the v)) ts) =\n                                     Some f \\<and>\n                                     v = tabulate f 0 n;\n     y # ys = map (MFOTL.eval_trm (map the v)) (trm.Var x # ts);\n     wf_tuple n (\\<Union> (fv_trm ` set (trm.Var x # ts))) v;\n     \\<forall>t\\<in>set (trm.Var x # ts). \\<forall>x\\<in>fv_trm t. x < n;\n     x \\<notin> \\<Union> (fv_trm ` set ts)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f.\n                         match (trm.Var x # ts)\n                          (map (MFOTL.eval_trm (map the v))\n                            (trm.Var x # ts)) =\n                         Some f \\<and>\n                         v = tabulate f 0 n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v.\n                \\<lbrakk>ys = map (MFOTL.eval_trm (map the v)) ts;\n                 wf_tuple n (\\<Union> (fv_trm ` set ts)) v;\n                 \\<forall>t\\<in>set ts.\n                    \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n                \\<Longrightarrow> \\<exists>f.\n                                     match ts\n(map (MFOTL.eval_trm (map the v)) ts) =\n                                     Some f \\<and>\n                                     v = tabulate f 0 n;\n     y # ys = map (MFOTL.eval_trm (map the v)) (trm.Var x # ts);\n     wf_tuple n (\\<Union> (fv_trm ` set (trm.Var x # ts))) v;\n     \\<forall>t\\<in>set (trm.Var x # ts). \\<forall>x\\<in>fv_trm t. x < n;\n     x \\<notin> \\<Union> (fv_trm ` set ts)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f.\n                         match (trm.Var x # ts)\n                          (map (MFOTL.eval_trm (map the v))\n                            (trm.Var x # ts)) =\n                         Some f \\<and>\n                         v = tabulate f 0 n", "case False"], ["proof (state)\nthis:\n  x \\<notin> \\<Union> (fv_trm ` set ts)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v.\n                \\<lbrakk>ys = map (MFOTL.eval_trm (map the v)) ts;\n                 wf_tuple n (\\<Union> (fv_trm ` set ts)) v;\n                 \\<forall>t\\<in>set ts.\n                    \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n                \\<Longrightarrow> \\<exists>f.\n                                     match ts\n(map (MFOTL.eval_trm (map the v)) ts) =\n                                     Some f \\<and>\n                                     v = tabulate f 0 n;\n     y # ys = map (MFOTL.eval_trm (map the v)) (trm.Var x # ts);\n     wf_tuple n (\\<Union> (fv_trm ` set (trm.Var x # ts))) v;\n     \\<forall>t\\<in>set (trm.Var x # ts). \\<forall>x\\<in>fv_trm t. x < n;\n     x \\<notin> \\<Union> (fv_trm ` set ts)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f.\n                         match (trm.Var x # ts)\n                          (map (MFOTL.eval_trm (map the v))\n                            (trm.Var x # ts)) =\n                         Some f \\<and>\n                         v = tabulate f 0 n", "with 3(3,4)"], ["proof (chain)\npicking this:\n  wf_tuple n (\\<Union> (fv_trm ` set (trm.Var x # ts))) v\n  \\<forall>t\\<in>set (trm.Var x # ts). \\<forall>x\\<in>fv_trm t. x < n\n  x \\<notin> \\<Union> (fv_trm ` set ts)", "have\n      *: \"map (MFOTL.eval_trm (map the v)) ts = map (MFOTL.eval_trm (map the (v[x := None]))) ts\""], ["proof (prove)\nusing this:\n  wf_tuple n (\\<Union> (fv_trm ` set (trm.Var x # ts))) v\n  \\<forall>t\\<in>set (trm.Var x # ts). \\<forall>x\\<in>fv_trm t. x < n\n  x \\<notin> \\<Union> (fv_trm ` set ts)\n\ngoal (1 subgoal):\n 1. map (MFOTL.eval_trm (map the v)) ts =\n    map (MFOTL.eval_trm (map the (v[x := None]))) ts", "by (auto simp: wf_tuple_def nth_list_update intro!: eval_trm_cong)"], ["proof (state)\nthis:\n  map (MFOTL.eval_trm (map the v)) ts =\n  map (MFOTL.eval_trm (map the (v[x := None]))) ts\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v.\n                \\<lbrakk>ys = map (MFOTL.eval_trm (map the v)) ts;\n                 wf_tuple n (\\<Union> (fv_trm ` set ts)) v;\n                 \\<forall>t\\<in>set ts.\n                    \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n                \\<Longrightarrow> \\<exists>f.\n                                     match ts\n(map (MFOTL.eval_trm (map the v)) ts) =\n                                     Some f \\<and>\n                                     v = tabulate f 0 n;\n     y # ys = map (MFOTL.eval_trm (map the v)) (trm.Var x # ts);\n     wf_tuple n (\\<Union> (fv_trm ` set (trm.Var x # ts))) v;\n     \\<forall>t\\<in>set (trm.Var x # ts). \\<forall>x\\<in>fv_trm t. x < n;\n     x \\<notin> \\<Union> (fv_trm ` set ts)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f.\n                         match (trm.Var x # ts)\n                          (map (MFOTL.eval_trm (map the v))\n                            (trm.Var x # ts)) =\n                         Some f \\<and>\n                         v = tabulate f 0 n", "from False 3(2-4)"], ["proof (chain)\npicking this:\n  x \\<notin> \\<Union> (fv_trm ` set ts)\n  y # ys = map (MFOTL.eval_trm (map the v)) (trm.Var x # ts)\n  wf_tuple n (\\<Union> (fv_trm ` set (trm.Var x # ts))) v\n  \\<forall>t\\<in>set (trm.Var x # ts). \\<forall>x\\<in>fv_trm t. x < n", "obtain f where\n      \"match ts (map (MFOTL.eval_trm (map the v)) ts) = Some f\" \"v[x := None] = tabulate f 0 n\""], ["proof (prove)\nusing this:\n  x \\<notin> \\<Union> (fv_trm ` set ts)\n  y # ys = map (MFOTL.eval_trm (map the v)) (trm.Var x # ts)\n  wf_tuple n (\\<Union> (fv_trm ` set (trm.Var x # ts))) v\n  \\<forall>t\\<in>set (trm.Var x # ts). \\<forall>x\\<in>fv_trm t. x < n\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>match ts (map (MFOTL.eval_trm (map the v)) ts) = Some f;\n         v[x := None] = tabulate f 0 n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding *"], ["proof (prove)\nusing this:\n  x \\<notin> \\<Union> (fv_trm ` set ts)\n  y # ys = map (MFOTL.eval_trm (map the v)) (trm.Var x # ts)\n  wf_tuple n (\\<Union> (fv_trm ` set (trm.Var x # ts))) v\n  \\<forall>t\\<in>set (trm.Var x # ts). \\<forall>x\\<in>fv_trm t. x < n\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>match ts\n                  (map (MFOTL.eval_trm (map the (v[x := None]))) ts) =\n                 Some f;\n         v[x := None] = tabulate f 0 n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (atomize_elim, intro 3(1)[of \"v[x := None]\"])\n        (auto simp: wf_tuple_def nth_list_update intro!: eval_trm_cong)"], ["proof (state)\nthis:\n  match ts (map (MFOTL.eval_trm (map the v)) ts) = Some f\n  v[x := None] = tabulate f 0 n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v.\n                \\<lbrakk>ys = map (MFOTL.eval_trm (map the v)) ts;\n                 wf_tuple n (\\<Union> (fv_trm ` set ts)) v;\n                 \\<forall>t\\<in>set ts.\n                    \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n                \\<Longrightarrow> \\<exists>f.\n                                     match ts\n(map (MFOTL.eval_trm (map the v)) ts) =\n                                     Some f \\<and>\n                                     v = tabulate f 0 n;\n     y # ys = map (MFOTL.eval_trm (map the v)) (trm.Var x # ts);\n     wf_tuple n (\\<Union> (fv_trm ` set (trm.Var x # ts))) v;\n     \\<forall>t\\<in>set (trm.Var x # ts). \\<forall>x\\<in>fv_trm t. x < n;\n     x \\<notin> \\<Union> (fv_trm ` set ts)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f.\n                         match (trm.Var x # ts)\n                          (map (MFOTL.eval_trm (map the v))\n                            (trm.Var x # ts)) =\n                         Some f \\<and>\n                         v = tabulate f 0 n", "moreover"], ["proof (state)\nthis:\n  match ts (map (MFOTL.eval_trm (map the v)) ts) = Some f\n  v[x := None] = tabulate f 0 n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v.\n                \\<lbrakk>ys = map (MFOTL.eval_trm (map the v)) ts;\n                 wf_tuple n (\\<Union> (fv_trm ` set ts)) v;\n                 \\<forall>t\\<in>set ts.\n                    \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n                \\<Longrightarrow> \\<exists>f.\n                                     match ts\n(map (MFOTL.eval_trm (map the v)) ts) =\n                                     Some f \\<and>\n                                     v = tabulate f 0 n;\n     y # ys = map (MFOTL.eval_trm (map the v)) (trm.Var x # ts);\n     wf_tuple n (\\<Union> (fv_trm ` set (trm.Var x # ts))) v;\n     \\<forall>t\\<in>set (trm.Var x # ts). \\<forall>x\\<in>fv_trm t. x < n;\n     x \\<notin> \\<Union> (fv_trm ` set ts)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f.\n                         match (trm.Var x # ts)\n                          (map (MFOTL.eval_trm (map the v))\n                            (trm.Var x # ts)) =\n                         Some f \\<and>\n                         v = tabulate f 0 n", "from False this"], ["proof (chain)\npicking this:\n  x \\<notin> \\<Union> (fv_trm ` set ts)\n  match ts (map (MFOTL.eval_trm (map the v)) ts) = Some f\n  v[x := None] = tabulate f 0 n", "have \"f x = None\" \"length v = n\""], ["proof (prove)\nusing this:\n  x \\<notin> \\<Union> (fv_trm ` set ts)\n  match ts (map (MFOTL.eval_trm (map the v)) ts) = Some f\n  v[x := None] = tabulate f 0 n\n\ngoal (1 subgoal):\n 1. f x = None &&& length v = n", "by (auto dest: match_fvi_trm_None[OF sym] arg_cong[of _ _ length])"], ["proof (state)\nthis:\n  f x = None\n  length v = n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v.\n                \\<lbrakk>ys = map (MFOTL.eval_trm (map the v)) ts;\n                 wf_tuple n (\\<Union> (fv_trm ` set ts)) v;\n                 \\<forall>t\\<in>set ts.\n                    \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n                \\<Longrightarrow> \\<exists>f.\n                                     match ts\n(map (MFOTL.eval_trm (map the v)) ts) =\n                                     Some f \\<and>\n                                     v = tabulate f 0 n;\n     y # ys = map (MFOTL.eval_trm (map the v)) (trm.Var x # ts);\n     wf_tuple n (\\<Union> (fv_trm ` set (trm.Var x # ts))) v;\n     \\<forall>t\\<in>set (trm.Var x # ts). \\<forall>x\\<in>fv_trm t. x < n;\n     x \\<notin> \\<Union> (fv_trm ` set ts)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f.\n                         match (trm.Var x # ts)\n                          (map (MFOTL.eval_trm (map the v))\n                            (trm.Var x # ts)) =\n                         Some f \\<and>\n                         v = tabulate f 0 n", "ultimately"], ["proof (chain)\npicking this:\n  match ts (map (MFOTL.eval_trm (map the v)) ts) = Some f\n  v[x := None] = tabulate f 0 n\n  f x = None\n  length v = n", "show ?thesis"], ["proof (prove)\nusing this:\n  match ts (map (MFOTL.eval_trm (map the v)) ts) = Some f\n  v[x := None] = tabulate f 0 n\n  f x = None\n  length v = n\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       match (trm.Var x # ts)\n        (map (MFOTL.eval_trm (map the v)) (trm.Var x # ts)) =\n       Some f \\<and>\n       v = tabulate f 0 n", "using 3(3)"], ["proof (prove)\nusing this:\n  match ts (map (MFOTL.eval_trm (map the v)) ts) = Some f\n  v[x := None] = tabulate f 0 n\n  f x = None\n  length v = n\n  wf_tuple n (\\<Union> (fv_trm ` set (trm.Var x # ts))) v\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       match (trm.Var x # ts)\n        (map (MFOTL.eval_trm (map the v)) (trm.Var x # ts)) =\n       Some f \\<and>\n       v = tabulate f 0 n", "by (auto simp: list_eq_iff_nth_eq wf_tuple_def)"], ["proof (state)\nthis:\n  \\<exists>f.\n     match (trm.Var x # ts)\n      (map (MFOTL.eval_trm (map the v)) (trm.Var x # ts)) =\n     Some f \\<and>\n     v = tabulate f 0 n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>f.\n     match (trm.Var x # ts)\n      (map (MFOTL.eval_trm (map the v)) (trm.Var x # ts)) =\n     Some f \\<and>\n     v = tabulate f 0 n\n\ngoal (5 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>[] = map (MFOTL.eval_trm (map the v)) [];\n        wf_tuple n (\\<Union> (fv_trm ` set [])) v;\n        \\<forall>t\\<in>set []. \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            match [] (map (MFOTL.eval_trm (map the v)) []) =\n                            Some f \\<and>\n                            v = tabulate f 0 n\n 2. \\<And>x ts y ys v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>x = y; ys = map (MFOTL.eval_trm (map the v)) ts;\n                    wf_tuple n (\\<Union> (fv_trm ` set ts)) v;\n                    \\<forall>t\\<in>set ts.\n                       \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>f.\n  match ts (map (MFOTL.eval_trm (map the v)) ts) = Some f \\<and>\n  v = tabulate f 0 n;\n        y # ys = map (MFOTL.eval_trm (map the v)) (trm.Const x # ts);\n        wf_tuple n (\\<Union> (fv_trm ` set (trm.Const x # ts))) v;\n        \\<forall>t\\<in>set (trm.Const x # ts).\n           \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            match (trm.Const x # ts)\n                             (map (MFOTL.eval_trm (map the v))\n                               (trm.Const x # ts)) =\n                            Some f \\<and>\n                            v = tabulate f 0 n\n 3. \\<And>vb va v.\n       \\<lbrakk>[] = map (MFOTL.eval_trm (map the v)) (trm.Var vb # va);\n        wf_tuple n (\\<Union> (fv_trm ` set (trm.Var vb # va))) v;\n        \\<forall>t\\<in>set (trm.Var vb # va).\n           \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            match (trm.Var vb # va)\n                             (map (MFOTL.eval_trm (map the v))\n                               (trm.Var vb # va)) =\n                            Some f \\<and>\n                            v = tabulate f 0 n\n 4. \\<And>v va vb.\n       \\<lbrakk>[] = map (MFOTL.eval_trm (map the vb)) (v # va);\n        wf_tuple n (\\<Union> (fv_trm ` set (v # va))) vb;\n        \\<forall>t\\<in>set (v # va). \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            match (v # va)\n                             (map (MFOTL.eval_trm (map the vb)) (v # va)) =\n                            Some f \\<and>\n                            vb = tabulate f 0 n\n 5. \\<And>v va vb.\n       \\<lbrakk>v # va = map (MFOTL.eval_trm (map the vb)) [];\n        wf_tuple n (\\<Union> (fv_trm ` set [])) vb;\n        \\<forall>t\\<in>set []. \\<forall>x\\<in>fv_trm t. x < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            match []\n                             (map (MFOTL.eval_trm (map the vb)) []) =\n                            Some f \\<and>\n                            vb = tabulate f 0 n", "qed (auto simp: wf_tuple_def intro: nth_equalityI)"], ["", "lemma eq_rel_eval_trm: \"v \\<in> eq_rel n t1 t2 \\<Longrightarrow> MFOTL.is_Const t1 \\<or> MFOTL.is_Const t2 \\<Longrightarrow>\n  \\<forall>x\\<in>MFOTL.fv_trm t1 \\<union> MFOTL.fv_trm t2. x < n \\<Longrightarrow>\n  MFOTL.eval_trm (map the v) t1 = MFOTL.eval_trm (map the v) t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> eq_rel n t1 t2; trm.is_Const t1 \\<or> trm.is_Const t2;\n     \\<forall>x\\<in>fv_trm t1 \\<union> fv_trm t2. x < n\\<rbrakk>\n    \\<Longrightarrow> MFOTL.eval_trm (map the v) t1 =\n                      MFOTL.eval_trm (map the v) t2", "by (cases t1; cases t2) (simp_all add: singleton_table_def split: if_splits)"], ["", "lemma in_eq_rel: \"wf_tuple n (MFOTL.fv_trm t1 \\<union> MFOTL.fv_trm t2) v \\<Longrightarrow>\n  MFOTL.is_Const t1 \\<or> MFOTL.is_Const t2 \\<Longrightarrow>\n  MFOTL.eval_trm (map the v) t1 = MFOTL.eval_trm (map the v) t2 \\<Longrightarrow>\n  v \\<in> eq_rel n t1 t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_tuple n (fv_trm t1 \\<union> fv_trm t2) v;\n     trm.is_Const t1 \\<or> trm.is_Const t2;\n     MFOTL.eval_trm (map the v) t1 = MFOTL.eval_trm (map the v) t2\\<rbrakk>\n    \\<Longrightarrow> v \\<in> eq_rel n t1 t2", "by (cases t1; cases t2)\n    (auto simp: singleton_table_def wf_tuple_def unit_table_def intro!: nth_equalityI split: if_splits)"], ["", "lemma table_eq_rel: \"MFOTL.is_Const t1 \\<or> MFOTL.is_Const t2 \\<Longrightarrow>\n  table n (MFOTL.fv_trm t1 \\<union> MFOTL.fv_trm t2) (eq_rel n t1 t2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trm.is_Const t1 \\<or> trm.is_Const t2 \\<Longrightarrow>\n    table n (fv_trm t1 \\<union> fv_trm t2) (eq_rel n t1 t2)", "by (cases t1; cases t2; simp)"], ["", "lemma wf_tuple_Suc_fviD: \"wf_tuple (Suc n) (MFOTL.fvi b \\<phi>) v \\<Longrightarrow> wf_tuple n (MFOTL.fvi (Suc b) \\<phi>) (tl v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tuple (Suc n) (MFOTL.fvi b \\<phi>) v \\<Longrightarrow>\n    wf_tuple n (MFOTL.fvi (Suc b) \\<phi>) (tl v)", "unfolding wf_tuple_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length v = Suc n \\<and>\n    (\\<forall>i<Suc n.\n        (v ! i = None) = (i \\<notin> MFOTL.fvi b \\<phi>)) \\<Longrightarrow>\n    length (tl v) = n \\<and>\n    (\\<forall>i<n.\n        (tl v ! i = None) = (i \\<notin> MFOTL.fvi (Suc b) \\<phi>))", "by (simp add: fvi_Suc nth_tl)"], ["", "lemma table_fvi_tl: \"table (Suc n) (MFOTL.fvi b \\<phi>) X \\<Longrightarrow> table n (MFOTL.fvi (Suc b) \\<phi>) (tl ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. table (Suc n) (MFOTL.fvi b \\<phi>) X \\<Longrightarrow>\n    table n (MFOTL.fvi (Suc b) \\<phi>) (tl ` X)", "unfolding table_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball X (wf_tuple (Suc n) (MFOTL.fvi b \\<phi>)) \\<Longrightarrow>\n    Ball (tl ` X) (wf_tuple n (MFOTL.fvi (Suc b) \\<phi>))", "by (auto intro: wf_tuple_Suc_fviD)"], ["", "lemma wf_tuple_Suc_fvi_SomeI: \"0 \\<in> MFOTL.fvi b \\<phi> \\<Longrightarrow> wf_tuple n (MFOTL.fvi (Suc b) \\<phi>) v \\<Longrightarrow>\n  wf_tuple (Suc n) (MFOTL.fvi b \\<phi>) (Some x # v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<in> MFOTL.fvi b \\<phi>;\n     wf_tuple n (MFOTL.fvi (Suc b) \\<phi>) v\\<rbrakk>\n    \\<Longrightarrow> wf_tuple (Suc n) (MFOTL.fvi b \\<phi>) (Some x # v)", "unfolding wf_tuple_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<in> MFOTL.fvi b \\<phi>;\n     length v = n \\<and>\n     (\\<forall>i<n.\n         (v ! i = None) = (i \\<notin> MFOTL.fvi (Suc b) \\<phi>))\\<rbrakk>\n    \\<Longrightarrow> length (Some x # v) = Suc n \\<and>\n                      (\\<forall>i<Suc n.\n                          ((Some x # v) ! i = None) =\n                          (i \\<notin> MFOTL.fvi b \\<phi>))", "by (auto simp: fvi_Suc less_Suc_eq_0_disj)"], ["", "lemma wf_tuple_Suc_fvi_NoneI: \"0 \\<notin> MFOTL.fvi b \\<phi> \\<Longrightarrow> wf_tuple n (MFOTL.fvi (Suc b) \\<phi>) v \\<Longrightarrow>\n  wf_tuple (Suc n) (MFOTL.fvi b \\<phi>) (None # v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<notin> MFOTL.fvi b \\<phi>;\n     wf_tuple n (MFOTL.fvi (Suc b) \\<phi>) v\\<rbrakk>\n    \\<Longrightarrow> wf_tuple (Suc n) (MFOTL.fvi b \\<phi>) (None # v)", "unfolding wf_tuple_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<notin> MFOTL.fvi b \\<phi>;\n     length v = n \\<and>\n     (\\<forall>i<n.\n         (v ! i = None) = (i \\<notin> MFOTL.fvi (Suc b) \\<phi>))\\<rbrakk>\n    \\<Longrightarrow> length (None # v) = Suc n \\<and>\n                      (\\<forall>i<Suc n.\n                          ((None # v) ! i = None) =\n                          (i \\<notin> MFOTL.fvi b \\<phi>))", "by (auto simp: fvi_Suc less_Suc_eq_0_disj)"], ["", "lemma qtable_project_fv: \"qtable (Suc n) (fv \\<phi>) (mem_restr (lift_envs R)) P X \\<Longrightarrow>\n    qtable n (MFOTL.fvi (Suc 0) \\<phi>) (mem_restr R)\n      (\\<lambda>v. \\<exists>x. P ((if 0 \\<in> fv \\<phi> then Some x else None) # v)) (tl ` X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qtable (Suc n) (fv \\<phi>) (mem_restr (lift_envs R)) P\n     X \\<Longrightarrow>\n    qtable n (MFOTL.fvi (Suc 0) \\<phi>) (mem_restr R)\n     (\\<lambda>v.\n         \\<exists>x. P ((if 0 \\<in> fv \\<phi> then Some x else None) # v))\n     (tl ` X)", "using neq0_conv"], ["proof (prove)\nusing this:\n  (?n \\<noteq> 0) = (0 < ?n)\n\ngoal (1 subgoal):\n 1. qtable (Suc n) (fv \\<phi>) (mem_restr (lift_envs R)) P\n     X \\<Longrightarrow>\n    qtable n (MFOTL.fvi (Suc 0) \\<phi>) (mem_restr R)\n     (\\<lambda>v.\n         \\<exists>x. P ((if 0 \\<in> fv \\<phi> then Some x else None) # v))\n     (tl ` X)", "by (fastforce simp: image_iff Bex_def fvi_Suc elim!: qtable_cong dest!: qtable_project)"], ["", "lemma mprev: \"mprev_next I xs ts = (ys, xs', ts') \\<Longrightarrow>\n  list_all2 P [i..<j'] xs \\<Longrightarrow> list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] ts \\<Longrightarrow> i \\<le> j' \\<Longrightarrow> i < j \\<Longrightarrow>\n  list_all2 (\\<lambda>i X. if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then P i X else X = empty_table)\n    [i..<min j' (j-1)] ys \\<and>\n  list_all2 P [min j' (j-1)..<j'] xs' \\<and>\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [min j' (j-1)..<j] ts'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mprev_next I xs ts = (ys, xs', ts'); list_all2 P [i..<j'] xs;\n     list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] ts; i \\<le> j';\n     i < j\\<rbrakk>\n    \\<Longrightarrow> list_all2\n                       (\\<lambda>i X.\n                           if mem (\\<tau> \\<sigma> (Suc i) -\n                                   \\<tau> \\<sigma> i)\n                               I\n                           then P i X else X = empty_table)\n                       [i..<min j' (j - 1)] ys \\<and>\n                      list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                      list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                       [min j' (j - 1)..<j] ts'", "proof (induction I xs ts arbitrary: i ys xs' ts' rule: mprev_next.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>I ts i ys xs' ts'.\n       \\<lbrakk>mprev_next I [] ts = (ys, xs', ts');\n        list_all2 P [i..<j'] [];\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] ts;\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'\n 2. \\<And>I v va i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [] = (ys, xs', ts');\n        list_all2 P [i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [];\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'\n 3. \\<And>I v va t i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [t] = (ys, xs', ts');\n        list_all2 P [i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [t];\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'\n 4. \\<And>I x xs t t' ts i ys xs' ts'.\n       \\<lbrakk>\\<And>i ys xs' ts'.\n                   \\<lbrakk>mprev_next I xs (t' # ts) = (ys, xs', ts');\n                    list_all2 P [i..<j'] xs;\n                    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n                     (t' # ts);\n                    i \\<le> j'; i < j\\<rbrakk>\n                   \\<Longrightarrow> list_all2\n(\\<lambda>i X.\n    if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then P i X\n    else X = empty_table)\n[i..<min j' (j - 1)] ys \\<and>\n                                     list_all2 P [min j' (j - 1)..<j']\nxs' \\<and>\n                                     list_all2\n(\\<lambda>i t. t = \\<tau> \\<sigma> i) [min j' (j - 1)..<j] ts';\n        mprev_next I (x # xs) (t # t' # ts) = (ys, xs', ts');\n        list_all2 P [i..<j'] (x # xs);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n         (t # t' # ts);\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'", "case (1 I ts)"], ["proof (state)\nthis:\n  mprev_next I [] ts = (ys, xs', ts')\n  list_all2 P [i..<j'] []\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] ts\n  i \\<le> j'\n  i < j\n\ngoal (4 subgoals):\n 1. \\<And>I ts i ys xs' ts'.\n       \\<lbrakk>mprev_next I [] ts = (ys, xs', ts');\n        list_all2 P [i..<j'] [];\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] ts;\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'\n 2. \\<And>I v va i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [] = (ys, xs', ts');\n        list_all2 P [i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [];\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'\n 3. \\<And>I v va t i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [t] = (ys, xs', ts');\n        list_all2 P [i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [t];\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'\n 4. \\<And>I x xs t t' ts i ys xs' ts'.\n       \\<lbrakk>\\<And>i ys xs' ts'.\n                   \\<lbrakk>mprev_next I xs (t' # ts) = (ys, xs', ts');\n                    list_all2 P [i..<j'] xs;\n                    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n                     (t' # ts);\n                    i \\<le> j'; i < j\\<rbrakk>\n                   \\<Longrightarrow> list_all2\n(\\<lambda>i X.\n    if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then P i X\n    else X = empty_table)\n[i..<min j' (j - 1)] ys \\<and>\n                                     list_all2 P [min j' (j - 1)..<j']\nxs' \\<and>\n                                     list_all2\n(\\<lambda>i t. t = \\<tau> \\<sigma> i) [min j' (j - 1)..<j] ts';\n        mprev_next I (x # xs) (t # t' # ts) = (ys, xs', ts');\n        list_all2 P [i..<j'] (x # xs);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n         (t # t' # ts);\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'", "then"], ["proof (chain)\npicking this:\n  mprev_next I [] ts = (ys, xs', ts')\n  list_all2 P [i..<j'] []\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] ts\n  i \\<le> j'\n  i < j", "have \"min j' (j-1) = i\""], ["proof (prove)\nusing this:\n  mprev_next I [] ts = (ys, xs', ts')\n  list_all2 P [i..<j'] []\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] ts\n  i \\<le> j'\n  i < j\n\ngoal (1 subgoal):\n 1. min j' (j - 1) = i", "by auto"], ["proof (state)\nthis:\n  min j' (j - 1) = i\n\ngoal (4 subgoals):\n 1. \\<And>I ts i ys xs' ts'.\n       \\<lbrakk>mprev_next I [] ts = (ys, xs', ts');\n        list_all2 P [i..<j'] [];\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] ts;\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'\n 2. \\<And>I v va i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [] = (ys, xs', ts');\n        list_all2 P [i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [];\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'\n 3. \\<And>I v va t i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [t] = (ys, xs', ts');\n        list_all2 P [i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [t];\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'\n 4. \\<And>I x xs t t' ts i ys xs' ts'.\n       \\<lbrakk>\\<And>i ys xs' ts'.\n                   \\<lbrakk>mprev_next I xs (t' # ts) = (ys, xs', ts');\n                    list_all2 P [i..<j'] xs;\n                    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n                     (t' # ts);\n                    i \\<le> j'; i < j\\<rbrakk>\n                   \\<Longrightarrow> list_all2\n(\\<lambda>i X.\n    if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then P i X\n    else X = empty_table)\n[i..<min j' (j - 1)] ys \\<and>\n                                     list_all2 P [min j' (j - 1)..<j']\nxs' \\<and>\n                                     list_all2\n(\\<lambda>i t. t = \\<tau> \\<sigma> i) [min j' (j - 1)..<j] ts';\n        mprev_next I (x # xs) (t # t' # ts) = (ys, xs', ts');\n        list_all2 P [i..<j'] (x # xs);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n         (t # t' # ts);\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'", "with 1"], ["proof (chain)\npicking this:\n  mprev_next I [] ts = (ys, xs', ts')\n  list_all2 P [i..<j'] []\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] ts\n  i \\<le> j'\n  i < j\n  min j' (j - 1) = i", "show ?case"], ["proof (prove)\nusing this:\n  mprev_next I [] ts = (ys, xs', ts')\n  list_all2 P [i..<j'] []\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] ts\n  i \\<le> j'\n  i < j\n  min j' (j - 1) = i\n\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>i X.\n         if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then P i X\n         else X = empty_table)\n     [i..<min j' (j - 1)] ys \\<and>\n    list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [min j' (j - 1)..<j] ts'", "by auto"], ["proof (state)\nthis:\n  list_all2\n   (\\<lambda>i X.\n       if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then P i X\n       else X = empty_table)\n   [i..<min j' (j - 1)] ys \\<and>\n  list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [min j' (j - 1)..<j] ts'\n\ngoal (3 subgoals):\n 1. \\<And>I v va i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [] = (ys, xs', ts');\n        list_all2 P [i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [];\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'\n 2. \\<And>I v va t i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [t] = (ys, xs', ts');\n        list_all2 P [i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [t];\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'\n 3. \\<And>I x xs t t' ts i ys xs' ts'.\n       \\<lbrakk>\\<And>i ys xs' ts'.\n                   \\<lbrakk>mprev_next I xs (t' # ts) = (ys, xs', ts');\n                    list_all2 P [i..<j'] xs;\n                    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n                     (t' # ts);\n                    i \\<le> j'; i < j\\<rbrakk>\n                   \\<Longrightarrow> list_all2\n(\\<lambda>i X.\n    if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then P i X\n    else X = empty_table)\n[i..<min j' (j - 1)] ys \\<and>\n                                     list_all2 P [min j' (j - 1)..<j']\nxs' \\<and>\n                                     list_all2\n(\\<lambda>i t. t = \\<tau> \\<sigma> i) [min j' (j - 1)..<j] ts';\n        mprev_next I (x # xs) (t # t' # ts) = (ys, xs', ts');\n        list_all2 P [i..<j'] (x # xs);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n         (t # t' # ts);\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>I v va i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [] = (ys, xs', ts');\n        list_all2 P [i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [];\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'\n 2. \\<And>I v va t i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [t] = (ys, xs', ts');\n        list_all2 P [i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [t];\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'\n 3. \\<And>I x xs t t' ts i ys xs' ts'.\n       \\<lbrakk>\\<And>i ys xs' ts'.\n                   \\<lbrakk>mprev_next I xs (t' # ts) = (ys, xs', ts');\n                    list_all2 P [i..<j'] xs;\n                    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n                     (t' # ts);\n                    i \\<le> j'; i < j\\<rbrakk>\n                   \\<Longrightarrow> list_all2\n(\\<lambda>i X.\n    if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then P i X\n    else X = empty_table)\n[i..<min j' (j - 1)] ys \\<and>\n                                     list_all2 P [min j' (j - 1)..<j']\nxs' \\<and>\n                                     list_all2\n(\\<lambda>i t. t = \\<tau> \\<sigma> i) [min j' (j - 1)..<j] ts';\n        mprev_next I (x # xs) (t # t' # ts) = (ys, xs', ts');\n        list_all2 P [i..<j'] (x # xs);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n         (t # t' # ts);\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'", "case (3 I v v' t)"], ["proof (state)\nthis:\n  mprev_next I (v # v') [t] = (ys, xs', ts')\n  list_all2 P [i..<j'] (v # v')\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [t]\n  i \\<le> j'\n  i < j\n\ngoal (3 subgoals):\n 1. \\<And>I v va i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [] = (ys, xs', ts');\n        list_all2 P [i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [];\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'\n 2. \\<And>I v va t i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [t] = (ys, xs', ts');\n        list_all2 P [i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [t];\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'\n 3. \\<And>I x xs t t' ts i ys xs' ts'.\n       \\<lbrakk>\\<And>i ys xs' ts'.\n                   \\<lbrakk>mprev_next I xs (t' # ts) = (ys, xs', ts');\n                    list_all2 P [i..<j'] xs;\n                    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n                     (t' # ts);\n                    i \\<le> j'; i < j\\<rbrakk>\n                   \\<Longrightarrow> list_all2\n(\\<lambda>i X.\n    if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then P i X\n    else X = empty_table)\n[i..<min j' (j - 1)] ys \\<and>\n                                     list_all2 P [min j' (j - 1)..<j']\nxs' \\<and>\n                                     list_all2\n(\\<lambda>i t. t = \\<tau> \\<sigma> i) [min j' (j - 1)..<j] ts';\n        mprev_next I (x # xs) (t # t' # ts) = (ys, xs', ts');\n        list_all2 P [i..<j'] (x # xs);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n         (t # t' # ts);\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'", "then"], ["proof (chain)\npicking this:\n  mprev_next I (v # v') [t] = (ys, xs', ts')\n  list_all2 P [i..<j'] (v # v')\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [t]\n  i \\<le> j'\n  i < j", "have \"min j' (j-1) = i\""], ["proof (prove)\nusing this:\n  mprev_next I (v # v') [t] = (ys, xs', ts')\n  list_all2 P [i..<j'] (v # v')\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [t]\n  i \\<le> j'\n  i < j\n\ngoal (1 subgoal):\n 1. min j' (j - 1) = i", "by (auto simp: list_all2_Cons2 upt_eq_Cons_conv)"], ["proof (state)\nthis:\n  min j' (j - 1) = i\n\ngoal (3 subgoals):\n 1. \\<And>I v va i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [] = (ys, xs', ts');\n        list_all2 P [i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [];\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'\n 2. \\<And>I v va t i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [t] = (ys, xs', ts');\n        list_all2 P [i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [t];\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'\n 3. \\<And>I x xs t t' ts i ys xs' ts'.\n       \\<lbrakk>\\<And>i ys xs' ts'.\n                   \\<lbrakk>mprev_next I xs (t' # ts) = (ys, xs', ts');\n                    list_all2 P [i..<j'] xs;\n                    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n                     (t' # ts);\n                    i \\<le> j'; i < j\\<rbrakk>\n                   \\<Longrightarrow> list_all2\n(\\<lambda>i X.\n    if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then P i X\n    else X = empty_table)\n[i..<min j' (j - 1)] ys \\<and>\n                                     list_all2 P [min j' (j - 1)..<j']\nxs' \\<and>\n                                     list_all2\n(\\<lambda>i t. t = \\<tau> \\<sigma> i) [min j' (j - 1)..<j] ts';\n        mprev_next I (x # xs) (t # t' # ts) = (ys, xs', ts');\n        list_all2 P [i..<j'] (x # xs);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n         (t # t' # ts);\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'", "with 3"], ["proof (chain)\npicking this:\n  mprev_next I (v # v') [t] = (ys, xs', ts')\n  list_all2 P [i..<j'] (v # v')\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [t]\n  i \\<le> j'\n  i < j\n  min j' (j - 1) = i", "show ?case"], ["proof (prove)\nusing this:\n  mprev_next I (v # v') [t] = (ys, xs', ts')\n  list_all2 P [i..<j'] (v # v')\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [t]\n  i \\<le> j'\n  i < j\n  min j' (j - 1) = i\n\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>i X.\n         if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then P i X\n         else X = empty_table)\n     [i..<min j' (j - 1)] ys \\<and>\n    list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [min j' (j - 1)..<j] ts'", "by auto"], ["proof (state)\nthis:\n  list_all2\n   (\\<lambda>i X.\n       if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then P i X\n       else X = empty_table)\n   [i..<min j' (j - 1)] ys \\<and>\n  list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [min j' (j - 1)..<j] ts'\n\ngoal (2 subgoals):\n 1. \\<And>I v va i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [] = (ys, xs', ts');\n        list_all2 P [i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [];\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'\n 2. \\<And>I x xs t t' ts i ys xs' ts'.\n       \\<lbrakk>\\<And>i ys xs' ts'.\n                   \\<lbrakk>mprev_next I xs (t' # ts) = (ys, xs', ts');\n                    list_all2 P [i..<j'] xs;\n                    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n                     (t' # ts);\n                    i \\<le> j'; i < j\\<rbrakk>\n                   \\<Longrightarrow> list_all2\n(\\<lambda>i X.\n    if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then P i X\n    else X = empty_table)\n[i..<min j' (j - 1)] ys \\<and>\n                                     list_all2 P [min j' (j - 1)..<j']\nxs' \\<and>\n                                     list_all2\n(\\<lambda>i t. t = \\<tau> \\<sigma> i) [min j' (j - 1)..<j] ts';\n        mprev_next I (x # xs) (t # t' # ts) = (ys, xs', ts');\n        list_all2 P [i..<j'] (x # xs);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n         (t # t' # ts);\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I v va i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [] = (ys, xs', ts');\n        list_all2 P [i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [];\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'\n 2. \\<And>I x xs t t' ts i ys xs' ts'.\n       \\<lbrakk>\\<And>i ys xs' ts'.\n                   \\<lbrakk>mprev_next I xs (t' # ts) = (ys, xs', ts');\n                    list_all2 P [i..<j'] xs;\n                    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n                     (t' # ts);\n                    i \\<le> j'; i < j\\<rbrakk>\n                   \\<Longrightarrow> list_all2\n(\\<lambda>i X.\n    if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then P i X\n    else X = empty_table)\n[i..<min j' (j - 1)] ys \\<and>\n                                     list_all2 P [min j' (j - 1)..<j']\nxs' \\<and>\n                                     list_all2\n(\\<lambda>i t. t = \\<tau> \\<sigma> i) [min j' (j - 1)..<j] ts';\n        mprev_next I (x # xs) (t # t' # ts) = (ys, xs', ts');\n        list_all2 P [i..<j'] (x # xs);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n         (t # t' # ts);\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'", "case (4 I x xs t t' ts)"], ["proof (state)\nthis:\n  \\<lbrakk>mprev_next I xs (t' # ts) = (?ys, ?xs', ?ts');\n   list_all2 P [?i..<j'] xs;\n   list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [?i..<j] (t' # ts);\n   ?i \\<le> j'; ?i < j\\<rbrakk>\n  \\<Longrightarrow> list_all2\n                     (\\<lambda>i X.\n                         if mem (\\<tau> \\<sigma> (Suc i) -\n                                 \\<tau> \\<sigma> i)\n                             I\n                         then P i X else X = empty_table)\n                     [?i..<min j' (j - 1)] ?ys \\<and>\n                    list_all2 P [min j' (j - 1)..<j'] ?xs' \\<and>\n                    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                     [min j' (j - 1)..<j] ?ts'\n  mprev_next I (x # xs) (t # t' # ts) = (ys, xs', ts')\n  list_all2 P [i..<j'] (x # xs)\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] (t # t' # ts)\n  i \\<le> j'\n  i < j\n\ngoal (2 subgoals):\n 1. \\<And>I v va i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [] = (ys, xs', ts');\n        list_all2 P [i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [];\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'\n 2. \\<And>I x xs t t' ts i ys xs' ts'.\n       \\<lbrakk>\\<And>i ys xs' ts'.\n                   \\<lbrakk>mprev_next I xs (t' # ts) = (ys, xs', ts');\n                    list_all2 P [i..<j'] xs;\n                    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n                     (t' # ts);\n                    i \\<le> j'; i < j\\<rbrakk>\n                   \\<Longrightarrow> list_all2\n(\\<lambda>i X.\n    if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then P i X\n    else X = empty_table)\n[i..<min j' (j - 1)] ys \\<and>\n                                     list_all2 P [min j' (j - 1)..<j']\nxs' \\<and>\n                                     list_all2\n(\\<lambda>i t. t = \\<tau> \\<sigma> i) [min j' (j - 1)..<j] ts';\n        mprev_next I (x # xs) (t # t' # ts) = (ys, xs', ts');\n        list_all2 P [i..<j'] (x # xs);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n         (t # t' # ts);\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'", "from 4(1)[of \"tl ys\" xs' ts' \"Suc i\"] 4(2-6)"], ["proof (chain)\npicking this:\n  \\<lbrakk>mprev_next I xs (t' # ts) = (tl ys, xs', ts');\n   list_all2 P [Suc i..<j'] xs;\n   list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [Suc i..<j] (t' # ts);\n   Suc i \\<le> j'; Suc i < j\\<rbrakk>\n  \\<Longrightarrow> list_all2\n                     (\\<lambda>i X.\n                         if mem (\\<tau> \\<sigma> (Suc i) -\n                                 \\<tau> \\<sigma> i)\n                             I\n                         then P i X else X = empty_table)\n                     [Suc i..<min j' (j - 1)] (tl ys) \\<and>\n                    list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                     [min j' (j - 1)..<j] ts'\n  mprev_next I (x # xs) (t # t' # ts) = (ys, xs', ts')\n  list_all2 P [i..<j'] (x # xs)\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] (t # t' # ts)\n  i \\<le> j'\n  i < j", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>mprev_next I xs (t' # ts) = (tl ys, xs', ts');\n   list_all2 P [Suc i..<j'] xs;\n   list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [Suc i..<j] (t' # ts);\n   Suc i \\<le> j'; Suc i < j\\<rbrakk>\n  \\<Longrightarrow> list_all2\n                     (\\<lambda>i X.\n                         if mem (\\<tau> \\<sigma> (Suc i) -\n                                 \\<tau> \\<sigma> i)\n                             I\n                         then P i X else X = empty_table)\n                     [Suc i..<min j' (j - 1)] (tl ys) \\<and>\n                    list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                     [min j' (j - 1)..<j] ts'\n  mprev_next I (x # xs) (t # t' # ts) = (ys, xs', ts')\n  list_all2 P [i..<j'] (x # xs)\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] (t # t' # ts)\n  i \\<le> j'\n  i < j\n\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>i X.\n         if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then P i X\n         else X = empty_table)\n     [i..<min j' (j - 1)] ys \\<and>\n    list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [min j' (j - 1)..<j] ts'", "by (auto simp add: list_all2_Cons2 upt_eq_Cons_conv Suc_less_eq2\n      elim!: list.rel_mono_strong split: prod.splits if_splits)"], ["proof (state)\nthis:\n  list_all2\n   (\\<lambda>i X.\n       if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then P i X\n       else X = empty_table)\n   [i..<min j' (j - 1)] ys \\<and>\n  list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [min j' (j - 1)..<j] ts'\n\ngoal (1 subgoal):\n 1. \\<And>I v va i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [] = (ys, xs', ts');\n        list_all2 P [i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [];\n        i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P i X else X = empty_table)\n                          [i..<min j' (j - 1)] ys \\<and>\n                         list_all2 P [min j' (j - 1)..<j'] xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min j' (j - 1)..<j] ts'", "qed simp"], ["", "lemma mnext: \"mprev_next I xs ts = (ys, xs', ts') \\<Longrightarrow>\n  list_all2 P [Suc i..<j'] xs \\<Longrightarrow> list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] ts \\<Longrightarrow> Suc i \\<le> j' \\<Longrightarrow> i < j \\<Longrightarrow>\n  list_all2 (\\<lambda>i X. if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then P (Suc i) X else X = empty_table)\n    [i..<min (j'-1) (j-1)] ys \\<and>\n  list_all2 P [Suc (min (j'-1) (j-1))..<j'] xs' \\<and>\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [min (j'-1) (j-1)..<j] ts'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mprev_next I xs ts = (ys, xs', ts');\n     list_all2 P [Suc i..<j'] xs;\n     list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] ts;\n     Suc i \\<le> j'; i < j\\<rbrakk>\n    \\<Longrightarrow> list_all2\n                       (\\<lambda>i X.\n                           if mem (\\<tau> \\<sigma> (Suc i) -\n                                   \\<tau> \\<sigma> i)\n                               I\n                           then P (Suc i) X else X = empty_table)\n                       [i..<min (j' - 1) (j - 1)] ys \\<and>\n                      list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                       xs' \\<and>\n                      list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                       [min (j' - 1) (j - 1)..<j] ts'", "proof (induction I xs ts arbitrary: i ys xs' ts' rule: mprev_next.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>I ts i ys xs' ts'.\n       \\<lbrakk>mprev_next I [] ts = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] [];\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] ts;\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'\n 2. \\<And>I v va i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [] = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [];\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'\n 3. \\<And>I v va t i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [t] = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [t];\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'\n 4. \\<And>I x xs t t' ts i ys xs' ts'.\n       \\<lbrakk>\\<And>i ys xs' ts'.\n                   \\<lbrakk>mprev_next I xs (t' # ts) = (ys, xs', ts');\n                    list_all2 P [Suc i..<j'] xs;\n                    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n                     (t' # ts);\n                    Suc i \\<le> j'; i < j\\<rbrakk>\n                   \\<Longrightarrow> list_all2\n(\\<lambda>i X.\n    if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then P (Suc i) X\n    else X = empty_table)\n[i..<min (j' - 1) (j - 1)] ys \\<and>\n                                     list_all2 P\n[Suc (min (j' - 1) (j - 1))..<j'] xs' \\<and>\n                                     list_all2\n(\\<lambda>i t. t = \\<tau> \\<sigma> i) [min (j' - 1) (j - 1)..<j] ts';\n        mprev_next I (x # xs) (t # t' # ts) = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] (x # xs);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n         (t # t' # ts);\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'", "case (1 I ts)"], ["proof (state)\nthis:\n  mprev_next I [] ts = (ys, xs', ts')\n  list_all2 P [Suc i..<j'] []\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] ts\n  Suc i \\<le> j'\n  i < j\n\ngoal (4 subgoals):\n 1. \\<And>I ts i ys xs' ts'.\n       \\<lbrakk>mprev_next I [] ts = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] [];\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] ts;\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'\n 2. \\<And>I v va i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [] = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [];\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'\n 3. \\<And>I v va t i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [t] = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [t];\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'\n 4. \\<And>I x xs t t' ts i ys xs' ts'.\n       \\<lbrakk>\\<And>i ys xs' ts'.\n                   \\<lbrakk>mprev_next I xs (t' # ts) = (ys, xs', ts');\n                    list_all2 P [Suc i..<j'] xs;\n                    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n                     (t' # ts);\n                    Suc i \\<le> j'; i < j\\<rbrakk>\n                   \\<Longrightarrow> list_all2\n(\\<lambda>i X.\n    if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then P (Suc i) X\n    else X = empty_table)\n[i..<min (j' - 1) (j - 1)] ys \\<and>\n                                     list_all2 P\n[Suc (min (j' - 1) (j - 1))..<j'] xs' \\<and>\n                                     list_all2\n(\\<lambda>i t. t = \\<tau> \\<sigma> i) [min (j' - 1) (j - 1)..<j] ts';\n        mprev_next I (x # xs) (t # t' # ts) = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] (x # xs);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n         (t # t' # ts);\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'", "then"], ["proof (chain)\npicking this:\n  mprev_next I [] ts = (ys, xs', ts')\n  list_all2 P [Suc i..<j'] []\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] ts\n  Suc i \\<le> j'\n  i < j", "have \"min (j' - 1) (j-1) = i\""], ["proof (prove)\nusing this:\n  mprev_next I [] ts = (ys, xs', ts')\n  list_all2 P [Suc i..<j'] []\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] ts\n  Suc i \\<le> j'\n  i < j\n\ngoal (1 subgoal):\n 1. min (j' - 1) (j - 1) = i", "by auto"], ["proof (state)\nthis:\n  min (j' - 1) (j - 1) = i\n\ngoal (4 subgoals):\n 1. \\<And>I ts i ys xs' ts'.\n       \\<lbrakk>mprev_next I [] ts = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] [];\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] ts;\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'\n 2. \\<And>I v va i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [] = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [];\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'\n 3. \\<And>I v va t i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [t] = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [t];\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'\n 4. \\<And>I x xs t t' ts i ys xs' ts'.\n       \\<lbrakk>\\<And>i ys xs' ts'.\n                   \\<lbrakk>mprev_next I xs (t' # ts) = (ys, xs', ts');\n                    list_all2 P [Suc i..<j'] xs;\n                    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n                     (t' # ts);\n                    Suc i \\<le> j'; i < j\\<rbrakk>\n                   \\<Longrightarrow> list_all2\n(\\<lambda>i X.\n    if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then P (Suc i) X\n    else X = empty_table)\n[i..<min (j' - 1) (j - 1)] ys \\<and>\n                                     list_all2 P\n[Suc (min (j' - 1) (j - 1))..<j'] xs' \\<and>\n                                     list_all2\n(\\<lambda>i t. t = \\<tau> \\<sigma> i) [min (j' - 1) (j - 1)..<j] ts';\n        mprev_next I (x # xs) (t # t' # ts) = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] (x # xs);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n         (t # t' # ts);\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'", "with 1"], ["proof (chain)\npicking this:\n  mprev_next I [] ts = (ys, xs', ts')\n  list_all2 P [Suc i..<j'] []\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] ts\n  Suc i \\<le> j'\n  i < j\n  min (j' - 1) (j - 1) = i", "show ?case"], ["proof (prove)\nusing this:\n  mprev_next I [] ts = (ys, xs', ts')\n  list_all2 P [Suc i..<j'] []\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] ts\n  Suc i \\<le> j'\n  i < j\n  min (j' - 1) (j - 1) = i\n\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>i X.\n         if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I\n         then P (Suc i) X else X = empty_table)\n     [i..<min (j' - 1) (j - 1)] ys \\<and>\n    list_all2 P [Suc (min (j' - 1) (j - 1))..<j'] xs' \\<and>\n    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n     [min (j' - 1) (j - 1)..<j] ts'", "by auto"], ["proof (state)\nthis:\n  list_all2\n   (\\<lambda>i X.\n       if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I\n       then P (Suc i) X else X = empty_table)\n   [i..<min (j' - 1) (j - 1)] ys \\<and>\n  list_all2 P [Suc (min (j' - 1) (j - 1))..<j'] xs' \\<and>\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [min (j' - 1) (j - 1)..<j]\n   ts'\n\ngoal (3 subgoals):\n 1. \\<And>I v va i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [] = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [];\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'\n 2. \\<And>I v va t i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [t] = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [t];\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'\n 3. \\<And>I x xs t t' ts i ys xs' ts'.\n       \\<lbrakk>\\<And>i ys xs' ts'.\n                   \\<lbrakk>mprev_next I xs (t' # ts) = (ys, xs', ts');\n                    list_all2 P [Suc i..<j'] xs;\n                    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n                     (t' # ts);\n                    Suc i \\<le> j'; i < j\\<rbrakk>\n                   \\<Longrightarrow> list_all2\n(\\<lambda>i X.\n    if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then P (Suc i) X\n    else X = empty_table)\n[i..<min (j' - 1) (j - 1)] ys \\<and>\n                                     list_all2 P\n[Suc (min (j' - 1) (j - 1))..<j'] xs' \\<and>\n                                     list_all2\n(\\<lambda>i t. t = \\<tau> \\<sigma> i) [min (j' - 1) (j - 1)..<j] ts';\n        mprev_next I (x # xs) (t # t' # ts) = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] (x # xs);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n         (t # t' # ts);\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>I v va i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [] = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [];\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'\n 2. \\<And>I v va t i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [t] = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [t];\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'\n 3. \\<And>I x xs t t' ts i ys xs' ts'.\n       \\<lbrakk>\\<And>i ys xs' ts'.\n                   \\<lbrakk>mprev_next I xs (t' # ts) = (ys, xs', ts');\n                    list_all2 P [Suc i..<j'] xs;\n                    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n                     (t' # ts);\n                    Suc i \\<le> j'; i < j\\<rbrakk>\n                   \\<Longrightarrow> list_all2\n(\\<lambda>i X.\n    if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then P (Suc i) X\n    else X = empty_table)\n[i..<min (j' - 1) (j - 1)] ys \\<and>\n                                     list_all2 P\n[Suc (min (j' - 1) (j - 1))..<j'] xs' \\<and>\n                                     list_all2\n(\\<lambda>i t. t = \\<tau> \\<sigma> i) [min (j' - 1) (j - 1)..<j] ts';\n        mprev_next I (x # xs) (t # t' # ts) = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] (x # xs);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n         (t # t' # ts);\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'", "case (3 I v v' t)"], ["proof (state)\nthis:\n  mprev_next I (v # v') [t] = (ys, xs', ts')\n  list_all2 P [Suc i..<j'] (v # v')\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [t]\n  Suc i \\<le> j'\n  i < j\n\ngoal (3 subgoals):\n 1. \\<And>I v va i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [] = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [];\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'\n 2. \\<And>I v va t i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [t] = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [t];\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'\n 3. \\<And>I x xs t t' ts i ys xs' ts'.\n       \\<lbrakk>\\<And>i ys xs' ts'.\n                   \\<lbrakk>mprev_next I xs (t' # ts) = (ys, xs', ts');\n                    list_all2 P [Suc i..<j'] xs;\n                    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n                     (t' # ts);\n                    Suc i \\<le> j'; i < j\\<rbrakk>\n                   \\<Longrightarrow> list_all2\n(\\<lambda>i X.\n    if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then P (Suc i) X\n    else X = empty_table)\n[i..<min (j' - 1) (j - 1)] ys \\<and>\n                                     list_all2 P\n[Suc (min (j' - 1) (j - 1))..<j'] xs' \\<and>\n                                     list_all2\n(\\<lambda>i t. t = \\<tau> \\<sigma> i) [min (j' - 1) (j - 1)..<j] ts';\n        mprev_next I (x # xs) (t # t' # ts) = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] (x # xs);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n         (t # t' # ts);\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'", "then"], ["proof (chain)\npicking this:\n  mprev_next I (v # v') [t] = (ys, xs', ts')\n  list_all2 P [Suc i..<j'] (v # v')\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [t]\n  Suc i \\<le> j'\n  i < j", "have \"min (j' - 1) (j-1) = i\""], ["proof (prove)\nusing this:\n  mprev_next I (v # v') [t] = (ys, xs', ts')\n  list_all2 P [Suc i..<j'] (v # v')\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [t]\n  Suc i \\<le> j'\n  i < j\n\ngoal (1 subgoal):\n 1. min (j' - 1) (j - 1) = i", "by (auto simp: list_all2_Cons2 upt_eq_Cons_conv)"], ["proof (state)\nthis:\n  min (j' - 1) (j - 1) = i\n\ngoal (3 subgoals):\n 1. \\<And>I v va i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [] = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [];\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'\n 2. \\<And>I v va t i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [t] = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [t];\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'\n 3. \\<And>I x xs t t' ts i ys xs' ts'.\n       \\<lbrakk>\\<And>i ys xs' ts'.\n                   \\<lbrakk>mprev_next I xs (t' # ts) = (ys, xs', ts');\n                    list_all2 P [Suc i..<j'] xs;\n                    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n                     (t' # ts);\n                    Suc i \\<le> j'; i < j\\<rbrakk>\n                   \\<Longrightarrow> list_all2\n(\\<lambda>i X.\n    if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then P (Suc i) X\n    else X = empty_table)\n[i..<min (j' - 1) (j - 1)] ys \\<and>\n                                     list_all2 P\n[Suc (min (j' - 1) (j - 1))..<j'] xs' \\<and>\n                                     list_all2\n(\\<lambda>i t. t = \\<tau> \\<sigma> i) [min (j' - 1) (j - 1)..<j] ts';\n        mprev_next I (x # xs) (t # t' # ts) = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] (x # xs);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n         (t # t' # ts);\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'", "with 3"], ["proof (chain)\npicking this:\n  mprev_next I (v # v') [t] = (ys, xs', ts')\n  list_all2 P [Suc i..<j'] (v # v')\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [t]\n  Suc i \\<le> j'\n  i < j\n  min (j' - 1) (j - 1) = i", "show ?case"], ["proof (prove)\nusing this:\n  mprev_next I (v # v') [t] = (ys, xs', ts')\n  list_all2 P [Suc i..<j'] (v # v')\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [t]\n  Suc i \\<le> j'\n  i < j\n  min (j' - 1) (j - 1) = i\n\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>i X.\n         if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I\n         then P (Suc i) X else X = empty_table)\n     [i..<min (j' - 1) (j - 1)] ys \\<and>\n    list_all2 P [Suc (min (j' - 1) (j - 1))..<j'] xs' \\<and>\n    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n     [min (j' - 1) (j - 1)..<j] ts'", "by auto"], ["proof (state)\nthis:\n  list_all2\n   (\\<lambda>i X.\n       if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I\n       then P (Suc i) X else X = empty_table)\n   [i..<min (j' - 1) (j - 1)] ys \\<and>\n  list_all2 P [Suc (min (j' - 1) (j - 1))..<j'] xs' \\<and>\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [min (j' - 1) (j - 1)..<j]\n   ts'\n\ngoal (2 subgoals):\n 1. \\<And>I v va i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [] = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [];\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'\n 2. \\<And>I x xs t t' ts i ys xs' ts'.\n       \\<lbrakk>\\<And>i ys xs' ts'.\n                   \\<lbrakk>mprev_next I xs (t' # ts) = (ys, xs', ts');\n                    list_all2 P [Suc i..<j'] xs;\n                    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n                     (t' # ts);\n                    Suc i \\<le> j'; i < j\\<rbrakk>\n                   \\<Longrightarrow> list_all2\n(\\<lambda>i X.\n    if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then P (Suc i) X\n    else X = empty_table)\n[i..<min (j' - 1) (j - 1)] ys \\<and>\n                                     list_all2 P\n[Suc (min (j' - 1) (j - 1))..<j'] xs' \\<and>\n                                     list_all2\n(\\<lambda>i t. t = \\<tau> \\<sigma> i) [min (j' - 1) (j - 1)..<j] ts';\n        mprev_next I (x # xs) (t # t' # ts) = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] (x # xs);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n         (t # t' # ts);\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I v va i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [] = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [];\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'\n 2. \\<And>I x xs t t' ts i ys xs' ts'.\n       \\<lbrakk>\\<And>i ys xs' ts'.\n                   \\<lbrakk>mprev_next I xs (t' # ts) = (ys, xs', ts');\n                    list_all2 P [Suc i..<j'] xs;\n                    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n                     (t' # ts);\n                    Suc i \\<le> j'; i < j\\<rbrakk>\n                   \\<Longrightarrow> list_all2\n(\\<lambda>i X.\n    if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then P (Suc i) X\n    else X = empty_table)\n[i..<min (j' - 1) (j - 1)] ys \\<and>\n                                     list_all2 P\n[Suc (min (j' - 1) (j - 1))..<j'] xs' \\<and>\n                                     list_all2\n(\\<lambda>i t. t = \\<tau> \\<sigma> i) [min (j' - 1) (j - 1)..<j] ts';\n        mprev_next I (x # xs) (t # t' # ts) = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] (x # xs);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n         (t # t' # ts);\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'", "case (4 I x xs t t' ts)"], ["proof (state)\nthis:\n  \\<lbrakk>mprev_next I xs (t' # ts) = (?ys, ?xs', ?ts');\n   list_all2 P [Suc ?i..<j'] xs;\n   list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [?i..<j] (t' # ts);\n   Suc ?i \\<le> j'; ?i < j\\<rbrakk>\n  \\<Longrightarrow> list_all2\n                     (\\<lambda>i X.\n                         if mem (\\<tau> \\<sigma> (Suc i) -\n                                 \\<tau> \\<sigma> i)\n                             I\n                         then P (Suc i) X else X = empty_table)\n                     [?i..<min (j' - 1) (j - 1)] ?ys \\<and>\n                    list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                     ?xs' \\<and>\n                    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                     [min (j' - 1) (j - 1)..<j] ?ts'\n  mprev_next I (x # xs) (t # t' # ts) = (ys, xs', ts')\n  list_all2 P [Suc i..<j'] (x # xs)\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] (t # t' # ts)\n  Suc i \\<le> j'\n  i < j\n\ngoal (2 subgoals):\n 1. \\<And>I v va i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [] = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [];\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'\n 2. \\<And>I x xs t t' ts i ys xs' ts'.\n       \\<lbrakk>\\<And>i ys xs' ts'.\n                   \\<lbrakk>mprev_next I xs (t' # ts) = (ys, xs', ts');\n                    list_all2 P [Suc i..<j'] xs;\n                    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n                     (t' # ts);\n                    Suc i \\<le> j'; i < j\\<rbrakk>\n                   \\<Longrightarrow> list_all2\n(\\<lambda>i X.\n    if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then P (Suc i) X\n    else X = empty_table)\n[i..<min (j' - 1) (j - 1)] ys \\<and>\n                                     list_all2 P\n[Suc (min (j' - 1) (j - 1))..<j'] xs' \\<and>\n                                     list_all2\n(\\<lambda>i t. t = \\<tau> \\<sigma> i) [min (j' - 1) (j - 1)..<j] ts';\n        mprev_next I (x # xs) (t # t' # ts) = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] (x # xs);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j]\n         (t # t' # ts);\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'", "from 4(1)[of \"tl ys\" xs' ts' \"Suc i\"] 4(2-6)"], ["proof (chain)\npicking this:\n  \\<lbrakk>mprev_next I xs (t' # ts) = (tl ys, xs', ts');\n   list_all2 P [Suc (Suc i)..<j'] xs;\n   list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [Suc i..<j] (t' # ts);\n   Suc (Suc i) \\<le> j'; Suc i < j\\<rbrakk>\n  \\<Longrightarrow> list_all2\n                     (\\<lambda>i X.\n                         if mem (\\<tau> \\<sigma> (Suc i) -\n                                 \\<tau> \\<sigma> i)\n                             I\n                         then P (Suc i) X else X = empty_table)\n                     [Suc i..<min (j' - 1) (j - 1)] (tl ys) \\<and>\n                    list_all2 P [Suc (min (j' - 1) (j - 1))..<j'] xs' \\<and>\n                    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                     [min (j' - 1) (j - 1)..<j] ts'\n  mprev_next I (x # xs) (t # t' # ts) = (ys, xs', ts')\n  list_all2 P [Suc i..<j'] (x # xs)\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] (t # t' # ts)\n  Suc i \\<le> j'\n  i < j", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>mprev_next I xs (t' # ts) = (tl ys, xs', ts');\n   list_all2 P [Suc (Suc i)..<j'] xs;\n   list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [Suc i..<j] (t' # ts);\n   Suc (Suc i) \\<le> j'; Suc i < j\\<rbrakk>\n  \\<Longrightarrow> list_all2\n                     (\\<lambda>i X.\n                         if mem (\\<tau> \\<sigma> (Suc i) -\n                                 \\<tau> \\<sigma> i)\n                             I\n                         then P (Suc i) X else X = empty_table)\n                     [Suc i..<min (j' - 1) (j - 1)] (tl ys) \\<and>\n                    list_all2 P [Suc (min (j' - 1) (j - 1))..<j'] xs' \\<and>\n                    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                     [min (j' - 1) (j - 1)..<j] ts'\n  mprev_next I (x # xs) (t # t' # ts) = (ys, xs', ts')\n  list_all2 P [Suc i..<j'] (x # xs)\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] (t # t' # ts)\n  Suc i \\<le> j'\n  i < j\n\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>i X.\n         if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I\n         then P (Suc i) X else X = empty_table)\n     [i..<min (j' - 1) (j - 1)] ys \\<and>\n    list_all2 P [Suc (min (j' - 1) (j - 1))..<j'] xs' \\<and>\n    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n     [min (j' - 1) (j - 1)..<j] ts'", "by (auto simp add: list_all2_Cons2 upt_eq_Cons_conv Suc_less_eq2\n      elim!: list.rel_mono_strong split: prod.splits if_splits)"], ["proof (state)\nthis:\n  list_all2\n   (\\<lambda>i X.\n       if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I\n       then P (Suc i) X else X = empty_table)\n   [i..<min (j' - 1) (j - 1)] ys \\<and>\n  list_all2 P [Suc (min (j' - 1) (j - 1))..<j'] xs' \\<and>\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [min (j' - 1) (j - 1)..<j]\n   ts'\n\ngoal (1 subgoal):\n 1. \\<And>I v va i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [] = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [];\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'", "(* slow 10 sec *)"], ["proof (state)\nthis:\n  list_all2\n   (\\<lambda>i X.\n       if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I\n       then P (Suc i) X else X = empty_table)\n   [i..<min (j' - 1) (j - 1)] ys \\<and>\n  list_all2 P [Suc (min (j' - 1) (j - 1))..<j'] xs' \\<and>\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [min (j' - 1) (j - 1)..<j]\n   ts'\n\ngoal (1 subgoal):\n 1. \\<And>I v va i ys xs' ts'.\n       \\<lbrakk>mprev_next I (v # va) [] = (ys, xs', ts');\n        list_all2 P [Suc i..<j'] (v # va);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [i..<j] [];\n        Suc i \\<le> j'; i < j\\<rbrakk>\n       \\<Longrightarrow> list_all2\n                          (\\<lambda>i X.\n                              if mem (\\<tau> \\<sigma> (Suc i) -\n\\<tau> \\<sigma> i)\n                                  I\n                              then P (Suc i) X else X = empty_table)\n                          [i..<min (j' - 1) (j - 1)] ys \\<and>\n                         list_all2 P [Suc (min (j' - 1) (j - 1))..<j']\n                          xs' \\<and>\n                         list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n                          [min (j' - 1) (j - 1)..<j] ts'", "qed simp"], ["", "lemma in_foldr_UnI: \"x \\<in> A \\<Longrightarrow> A \\<in> set xs \\<Longrightarrow> x \\<in> foldr (\\<union>) xs {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> A; A \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> x \\<in> foldr (\\<union>) xs {}", "by (induction xs) auto"], ["", "lemma in_foldr_UnE: \"x \\<in> foldr (\\<union>) xs {} \\<Longrightarrow> (\\<And>A. A \\<in> set xs \\<Longrightarrow> x \\<in> A \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> foldr (\\<union>) xs {};\n     \\<And>A.\n        \\<lbrakk>A \\<in> set xs; x \\<in> A\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (induction xs) auto"], ["", "lemma sat_the_restrict: \"fv \\<phi> \\<subseteq> A \\<Longrightarrow> MFOTL.sat \\<sigma> (map the (restrict A v)) i \\<phi> = MFOTL.sat \\<sigma> (map the v) i \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv \\<phi> \\<subseteq> A \\<Longrightarrow>\n    MFOTL.sat \\<sigma> (map the (restrict A v)) i \\<phi> =\n    MFOTL.sat \\<sigma> (map the v) i \\<phi>", "by (rule sat_fvi_cong) (auto intro!: map_the_restrict)"], ["", "lemma update_since:\n  assumes pre: \"wf_since_aux \\<sigma> n R pos \\<phi> I \\<psi> aux ne\"\n    and qtable1: \"qtable n (MFOTL.fv \\<phi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) ne \\<phi>) rel1\"\n    and qtable2: \"qtable n (MFOTL.fv \\<psi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) ne \\<psi>) rel2\"\n    and result_eq: \"(rel, aux') = update_since I pos rel1 rel2 (\\<tau> \\<sigma> ne) aux\"\n    and fvi_subset: \"MFOTL.fv \\<phi> \\<subseteq> MFOTL.fv \\<psi>\"\n  shows \"wf_since_aux \\<sigma> n R pos \\<phi> I \\<psi> aux' (Suc ne)\"\n    and \"qtable n (MFOTL.fv \\<psi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>)) rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_since_aux \\<sigma> n R pos \\<phi> I \\<psi> aux' (Suc ne) &&&\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>))\n     rel", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. wf_since_aux \\<sigma> n R pos \\<phi> I \\<psi> aux' (Suc ne)\n 2. qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>))\n     rel", "let ?wf_tuple = \"\\<lambda>v. wf_tuple n (MFOTL.fv \\<psi>) v\""], ["proof (state)\ngoal (2 subgoals):\n 1. wf_since_aux \\<sigma> n R pos \\<phi> I \\<psi> aux' (Suc ne)\n 2. qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>))\n     rel", "note sat.simps[simp del]"], ["proof (state)\nthis:\n  MFOTL.sat ?\\<sigma> ?v ?i (formula.Pred ?r ?ts) =\n  ((?r, map (MFOTL.eval_trm ?v) ?ts) \\<in> \\<Gamma> ?\\<sigma> ?i)\n  MFOTL.sat ?\\<sigma> ?v ?i (formula.Eq ?t1.0 ?t2.0) =\n  (MFOTL.eval_trm ?v ?t1.0 = MFOTL.eval_trm ?v ?t2.0)\n  MFOTL.sat ?\\<sigma> ?v ?i (formula.Neg ?\\<phi>) =\n  (\\<not> MFOTL.sat ?\\<sigma> ?v ?i ?\\<phi>)\n  MFOTL.sat ?\\<sigma> ?v ?i (formula.Or ?\\<phi> ?\\<psi>) =\n  (MFOTL.sat ?\\<sigma> ?v ?i ?\\<phi> \\<or>\n   MFOTL.sat ?\\<sigma> ?v ?i ?\\<psi>)\n  MFOTL.sat ?\\<sigma> ?v ?i (formula.Exists ?\\<phi>) =\n  (\\<exists>z. MFOTL.sat ?\\<sigma> (z # ?v) ?i ?\\<phi>)\n  MFOTL.sat ?\\<sigma> ?v ?i (formula.Prev ?I ?\\<phi>) =\n  (case ?i of 0 \\<Rightarrow> False\n   | Suc j \\<Rightarrow>\n       mem (\\<tau> ?\\<sigma> ?i - \\<tau> ?\\<sigma> j) ?I \\<and>\n       MFOTL.sat ?\\<sigma> ?v j ?\\<phi>)\n  MFOTL.sat ?\\<sigma> ?v ?i (formula.Next ?I ?\\<phi>) =\n  (mem (\\<tau> ?\\<sigma> (Suc ?i) - \\<tau> ?\\<sigma> ?i) ?I \\<and>\n   MFOTL.sat ?\\<sigma> ?v (Suc ?i) ?\\<phi>)\n  MFOTL.sat ?\\<sigma> ?v ?i (formula.Since ?\\<phi> ?I ?\\<psi>) =\n  (\\<exists>j\\<le>?i.\n      mem (\\<tau> ?\\<sigma> ?i - \\<tau> ?\\<sigma> j) ?I \\<and>\n      MFOTL.sat ?\\<sigma> ?v j ?\\<psi> \\<and>\n      (\\<forall>k\\<in>{j<..?i}. MFOTL.sat ?\\<sigma> ?v k ?\\<phi>))\n  MFOTL.sat ?\\<sigma> ?v ?i (formula.Until ?\\<phi> ?I ?\\<psi>) =\n  (\\<exists>j\\<ge>?i.\n      mem (\\<tau> ?\\<sigma> j - \\<tau> ?\\<sigma> ?i) ?I \\<and>\n      MFOTL.sat ?\\<sigma> ?v j ?\\<psi> \\<and>\n      (\\<forall>k\\<in>{?i..<j}. MFOTL.sat ?\\<sigma> ?v k ?\\<phi>))\n\ngoal (2 subgoals):\n 1. wf_since_aux \\<sigma> n R pos \\<phi> I \\<psi> aux' (Suc ne)\n 2. qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>))\n     rel", "define aux0 where \"aux0 = [(t, join rel pos rel1). (t, rel) \\<leftarrow> aux, \\<tau> \\<sigma> ne - t \\<le> right I]\""], ["proof (state)\nthis:\n  aux0 =\n  concat\n   (map (\\<lambda>(t, rel).\n            if enat (\\<tau> \\<sigma> ne - t) \\<le> right I\n            then [(t, join rel pos rel1)] else [])\n     aux)\n\ngoal (2 subgoals):\n 1. wf_since_aux \\<sigma> n R pos \\<phi> I \\<psi> aux' (Suc ne)\n 2. qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>))\n     rel", "have sorted_aux0: \"sorted_wrt (\\<lambda>x y. fst x > fst y) aux0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. fst y < fst x) aux0", "using pre[unfolded wf_since_aux_def, THEN conjunct1]"], ["proof (prove)\nusing this:\n  sorted_wrt (\\<lambda>x y. fst y < fst x) aux\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. fst y < fst x) aux0", "unfolding aux0_def"], ["proof (prove)\nusing this:\n  sorted_wrt (\\<lambda>x y. fst y < fst x) aux\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. fst y < fst x)\n     (concat\n       (map (\\<lambda>(t, rel).\n                if enat (\\<tau> \\<sigma> ne - t) \\<le> right I\n                then [(t, join rel pos rel1)] else [])\n         aux))", "by (induction aux) (auto simp add: sorted_wrt_append)"], ["proof (state)\nthis:\n  sorted_wrt (\\<lambda>x y. fst y < fst x) aux0\n\ngoal (2 subgoals):\n 1. wf_since_aux \\<sigma> n R pos \\<phi> I \\<psi> aux' (Suc ne)\n 2. qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>))\n     rel", "have in_aux0_1: \"(t, X) \\<in> set aux0 \\<Longrightarrow> ne \\<noteq> 0 \\<and> t \\<le> \\<tau> \\<sigma> (ne-1) \\<and> \\<tau> \\<sigma> ne - t \\<le> right I \\<and>\n      (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n      qtable n (MFOTL.fv \\<psi>) (mem_restr R) (\\<lambda>v. (MFOTL.sat \\<sigma> (map the v) (ne-1) (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (ne-1) - t)) \\<psi>) \\<and>\n        (if pos then MFOTL.sat \\<sigma> (map the v) ne \\<phi> else \\<not> MFOTL.sat \\<sigma> (map the v) ne \\<phi>))) X\" for t X"], ["proof (prove)\ngoal (1 subgoal):\n 1. (t, X) \\<in> set aux0 \\<Longrightarrow>\n    ne \\<noteq> 0 \\<and>\n    t \\<le> \\<tau> \\<sigma> (ne - 1) \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) (ne - 1)\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (ne - 1) - t))\n            \\<psi>) \\<and>\n         (if pos then MFOTL.sat \\<sigma> (map the v) ne \\<phi>\n          else \\<not> MFOTL.sat \\<sigma> (map the v) ne \\<phi>))\n     X", "unfolding aux0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (t, X)\n    \\<in> set (concat\n                (map (\\<lambda>(t, rel).\n                         if enat (\\<tau> \\<sigma> ne - t) \\<le> right I\n                         then [(t, join rel pos rel1)] else [])\n                  aux)) \\<Longrightarrow>\n    ne \\<noteq> 0 \\<and>\n    t \\<le> \\<tau> \\<sigma> (ne - 1) \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) (ne - 1)\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (ne - 1) - t))\n            \\<psi>) \\<and>\n         (if pos then MFOTL.sat \\<sigma> (map the v) ne \\<phi>\n          else \\<not> MFOTL.sat \\<sigma> (map the v) ne \\<phi>))\n     X", "using fvi_subset"], ["proof (prove)\nusing this:\n  fv \\<phi> \\<subseteq> fv \\<psi>\n\ngoal (1 subgoal):\n 1. (t, X)\n    \\<in> set (concat\n                (map (\\<lambda>(t, rel).\n                         if enat (\\<tau> \\<sigma> ne - t) \\<le> right I\n                         then [(t, join rel pos rel1)] else [])\n                  aux)) \\<Longrightarrow>\n    ne \\<noteq> 0 \\<and>\n    t \\<le> \\<tau> \\<sigma> (ne - 1) \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) (ne - 1)\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (ne - 1) - t))\n            \\<psi>) \\<and>\n         (if pos then MFOTL.sat \\<sigma> (map the v) ne \\<phi>\n          else \\<not> MFOTL.sat \\<sigma> (map the v) ne \\<phi>))\n     X", "by (auto 0 1 elim!: qtable_join[OF _ qtable1] simp: sat_the_restrict\n      dest!: assms(1)[unfolded wf_since_aux_def, THEN conjunct2, THEN conjunct1, rule_format])"], ["proof (state)\nthis:\n  (?t1, ?X1) \\<in> set aux0 \\<Longrightarrow>\n  ne \\<noteq> 0 \\<and>\n  ?t1 \\<le> \\<tau> \\<sigma> (ne - 1) \\<and>\n  enat (\\<tau> \\<sigma> ne - ?t1) \\<le> right I \\<and>\n  (\\<exists>i. \\<tau> \\<sigma> i = ?t1) \\<and>\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>v.\n       MFOTL.sat \\<sigma> (map the v) (ne - 1)\n        (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (ne - 1) - ?t1))\n          \\<psi>) \\<and>\n       (if pos then MFOTL.sat \\<sigma> (map the v) ne \\<phi>\n        else \\<not> MFOTL.sat \\<sigma> (map the v) ne \\<phi>))\n   ?X1\n\ngoal (2 subgoals):\n 1. wf_since_aux \\<sigma> n R pos \\<phi> I \\<psi> aux' (Suc ne)\n 2. qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>))\n     rel", "then"], ["proof (chain)\npicking this:\n  (?t1, ?X1) \\<in> set aux0 \\<Longrightarrow>\n  ne \\<noteq> 0 \\<and>\n  ?t1 \\<le> \\<tau> \\<sigma> (ne - 1) \\<and>\n  enat (\\<tau> \\<sigma> ne - ?t1) \\<le> right I \\<and>\n  (\\<exists>i. \\<tau> \\<sigma> i = ?t1) \\<and>\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>v.\n       MFOTL.sat \\<sigma> (map the v) (ne - 1)\n        (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (ne - 1) - ?t1))\n          \\<psi>) \\<and>\n       (if pos then MFOTL.sat \\<sigma> (map the v) ne \\<phi>\n        else \\<not> MFOTL.sat \\<sigma> (map the v) ne \\<phi>))\n   ?X1", "have in_aux0_le_\\<tau>: \"(t, X) \\<in> set aux0 \\<Longrightarrow> t \\<le> \\<tau> \\<sigma> ne\" for t X"], ["proof (prove)\nusing this:\n  (?t1, ?X1) \\<in> set aux0 \\<Longrightarrow>\n  ne \\<noteq> 0 \\<and>\n  ?t1 \\<le> \\<tau> \\<sigma> (ne - 1) \\<and>\n  enat (\\<tau> \\<sigma> ne - ?t1) \\<le> right I \\<and>\n  (\\<exists>i. \\<tau> \\<sigma> i = ?t1) \\<and>\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>v.\n       MFOTL.sat \\<sigma> (map the v) (ne - 1)\n        (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (ne - 1) - ?t1))\n          \\<psi>) \\<and>\n       (if pos then MFOTL.sat \\<sigma> (map the v) ne \\<phi>\n        else \\<not> MFOTL.sat \\<sigma> (map the v) ne \\<phi>))\n   ?X1\n\ngoal (1 subgoal):\n 1. (t, X) \\<in> set aux0 \\<Longrightarrow> t \\<le> \\<tau> \\<sigma> ne", "by (meson \\<tau>_mono diff_le_self le_trans)"], ["proof (state)\nthis:\n  (?t1, ?X1) \\<in> set aux0 \\<Longrightarrow> ?t1 \\<le> \\<tau> \\<sigma> ne\n\ngoal (2 subgoals):\n 1. wf_since_aux \\<sigma> n R pos \\<phi> I \\<psi> aux' (Suc ne)\n 2. qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>))\n     rel", "have in_aux0_2: \"ne \\<noteq> 0 \\<Longrightarrow> t \\<le> \\<tau> \\<sigma> (ne-1) \\<Longrightarrow> \\<tau> \\<sigma> ne - t \\<le> right I \\<Longrightarrow> \\<exists>i. \\<tau> \\<sigma> i = t \\<Longrightarrow>\n    \\<exists>X. (t, X) \\<in> set aux0\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ne \\<noteq> 0; t \\<le> \\<tau> \\<sigma> (ne - 1);\n     enat (\\<tau> \\<sigma> ne - t) \\<le> right I;\n     \\<exists>i. \\<tau> \\<sigma> i = t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>X. (t, X) \\<in> set aux0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ne \\<noteq> 0; t \\<le> \\<tau> \\<sigma> (ne - 1);\n     enat (\\<tau> \\<sigma> ne - t) \\<le> right I;\n     \\<exists>i. \\<tau> \\<sigma> i = t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>X. (t, X) \\<in> set aux0", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ne \\<noteq> 0; t__ \\<le> \\<tau> \\<sigma> (ne - 1);\n     enat (\\<tau> \\<sigma> ne - t__) \\<le> right I;\n     \\<exists>i. \\<tau> \\<sigma> i = t__\\<rbrakk>\n    \\<Longrightarrow> \\<exists>X. (t__, X) \\<in> set aux0", "assume \"ne \\<noteq> 0\" \"t \\<le> \\<tau> \\<sigma> (ne-1)\" \"\\<tau> \\<sigma> ne - t \\<le> right I\" \"\\<exists>i. \\<tau> \\<sigma> i = t\""], ["proof (state)\nthis:\n  ne \\<noteq> 0\n  t \\<le> \\<tau> \\<sigma> (ne - 1)\n  enat (\\<tau> \\<sigma> ne - t) \\<le> right I\n  \\<exists>i. \\<tau> \\<sigma> i = t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ne \\<noteq> 0; t__ \\<le> \\<tau> \\<sigma> (ne - 1);\n     enat (\\<tau> \\<sigma> ne - t__) \\<le> right I;\n     \\<exists>i. \\<tau> \\<sigma> i = t__\\<rbrakk>\n    \\<Longrightarrow> \\<exists>X. (t__, X) \\<in> set aux0", "then"], ["proof (chain)\npicking this:\n  ne \\<noteq> 0\n  t \\<le> \\<tau> \\<sigma> (ne - 1)\n  enat (\\<tau> \\<sigma> ne - t) \\<le> right I\n  \\<exists>i. \\<tau> \\<sigma> i = t", "obtain X where \"(t, X) \\<in> set aux\""], ["proof (prove)\nusing this:\n  ne \\<noteq> 0\n  t \\<le> \\<tau> \\<sigma> (ne - 1)\n  enat (\\<tau> \\<sigma> ne - t) \\<le> right I\n  \\<exists>i. \\<tau> \\<sigma> i = t\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        (t, X) \\<in> set aux \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (atomize_elim, intro assms(1)[unfolded wf_since_aux_def, THEN conjunct2, THEN conjunct2, rule_format])\n        (auto simp: gr0_conv_Suc elim!: order_trans[rotated] intro!: diff_le_mono \\<tau>_mono)"], ["proof (state)\nthis:\n  (t, X) \\<in> set aux\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ne \\<noteq> 0; t__ \\<le> \\<tau> \\<sigma> (ne - 1);\n     enat (\\<tau> \\<sigma> ne - t__) \\<le> right I;\n     \\<exists>i. \\<tau> \\<sigma> i = t__\\<rbrakk>\n    \\<Longrightarrow> \\<exists>X. (t__, X) \\<in> set aux0", "with \\<open>\\<tau> \\<sigma> ne - t \\<le> right I\\<close>"], ["proof (chain)\npicking this:\n  enat (\\<tau> \\<sigma> ne - t) \\<le> right I\n  (t, X) \\<in> set aux", "have \"(t, join X pos rel1) \\<in> set aux0\""], ["proof (prove)\nusing this:\n  enat (\\<tau> \\<sigma> ne - t) \\<le> right I\n  (t, X) \\<in> set aux\n\ngoal (1 subgoal):\n 1. (t, join X pos rel1) \\<in> set aux0", "unfolding aux0_def"], ["proof (prove)\nusing this:\n  enat (\\<tau> \\<sigma> ne - t) \\<le> right I\n  (t, X) \\<in> set aux\n\ngoal (1 subgoal):\n 1. (t, join X pos rel1)\n    \\<in> set (concat\n                (map (\\<lambda>(t, rel).\n                         if enat (\\<tau> \\<sigma> ne - t) \\<le> right I\n                         then [(t, join rel pos rel1)] else [])\n                  aux))", "by (auto elim!: bexI[rotated] intro!: exI[of _ X])"], ["proof (state)\nthis:\n  (t, join X pos rel1) \\<in> set aux0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ne \\<noteq> 0; t__ \\<le> \\<tau> \\<sigma> (ne - 1);\n     enat (\\<tau> \\<sigma> ne - t__) \\<le> right I;\n     \\<exists>i. \\<tau> \\<sigma> i = t__\\<rbrakk>\n    \\<Longrightarrow> \\<exists>X. (t__, X) \\<in> set aux0", "then"], ["proof (chain)\npicking this:\n  (t, join X pos rel1) \\<in> set aux0", "show \"\\<exists>X. (t, X) \\<in> set aux0\""], ["proof (prove)\nusing this:\n  (t, join X pos rel1) \\<in> set aux0\n\ngoal (1 subgoal):\n 1. \\<exists>X. (t, X) \\<in> set aux0", "by blast"], ["proof (state)\nthis:\n  \\<exists>X. (t, X) \\<in> set aux0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>ne \\<noteq> 0; ?t1 \\<le> \\<tau> \\<sigma> (ne - 1);\n   enat (\\<tau> \\<sigma> ne - ?t1) \\<le> right I;\n   \\<exists>i. \\<tau> \\<sigma> i = ?t1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>X. (?t1, X) \\<in> set aux0\n\ngoal (2 subgoals):\n 1. wf_since_aux \\<sigma> n R pos \\<phi> I \\<psi> aux' (Suc ne)\n 2. qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>))\n     rel", "have aux0_Nil: \"aux0 = [] \\<Longrightarrow> ne = 0 \\<or> ne \\<noteq> 0 \\<and> (\\<forall>t. t \\<le> \\<tau> \\<sigma> (ne-1) \\<and> \\<tau> \\<sigma> ne - t \\<le> right I \\<longrightarrow>\n        (\\<nexists>i. \\<tau> \\<sigma> i = t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aux0 = [] \\<Longrightarrow>\n    ne = 0 \\<or>\n    ne \\<noteq> 0 \\<and>\n    (\\<forall>t.\n        t \\<le> \\<tau> \\<sigma> (ne - 1) \\<and>\n        enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<longrightarrow>\n        (\\<nexists>i. \\<tau> \\<sigma> i = t))", "using in_aux0_2"], ["proof (prove)\nusing this:\n  \\<lbrakk>ne \\<noteq> 0; ?t1 \\<le> \\<tau> \\<sigma> (ne - 1);\n   enat (\\<tau> \\<sigma> ne - ?t1) \\<le> right I;\n   \\<exists>i. \\<tau> \\<sigma> i = ?t1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>X. (?t1, X) \\<in> set aux0\n\ngoal (1 subgoal):\n 1. aux0 = [] \\<Longrightarrow>\n    ne = 0 \\<or>\n    ne \\<noteq> 0 \\<and>\n    (\\<forall>t.\n        t \\<le> \\<tau> \\<sigma> (ne - 1) \\<and>\n        enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<longrightarrow>\n        (\\<nexists>i. \\<tau> \\<sigma> i = t))", "by (cases \"ne = 0\") (auto)"], ["proof (state)\nthis:\n  aux0 = [] \\<Longrightarrow>\n  ne = 0 \\<or>\n  ne \\<noteq> 0 \\<and>\n  (\\<forall>t.\n      t \\<le> \\<tau> \\<sigma> (ne - 1) \\<and>\n      enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<longrightarrow>\n      (\\<nexists>i. \\<tau> \\<sigma> i = t))\n\ngoal (2 subgoals):\n 1. wf_since_aux \\<sigma> n R pos \\<phi> I \\<psi> aux' (Suc ne)\n 2. qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>))\n     rel", "have aux'_eq: \"aux' = (case aux0 of\n      [] \\<Rightarrow> [(\\<tau> \\<sigma> ne, rel2)]\n    | x # aux' \\<Rightarrow> (if fst x = \\<tau> \\<sigma> ne then (fst x, snd x \\<union> rel2) # aux' else (\\<tau> \\<sigma> ne, rel2) # x # aux'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aux' =\n    (case aux0 of [] \\<Rightarrow> [(\\<tau> \\<sigma> ne, rel2)]\n     | x # aux' \\<Rightarrow>\n         if fst x = \\<tau> \\<sigma> ne\n         then (fst x, snd x \\<union> rel2) # aux'\n         else (\\<tau> \\<sigma> ne, rel2) # x # aux')", "using result_eq"], ["proof (prove)\nusing this:\n  (rel, aux') = update_since I pos rel1 rel2 (\\<tau> \\<sigma> ne) aux\n\ngoal (1 subgoal):\n 1. aux' =\n    (case aux0 of [] \\<Rightarrow> [(\\<tau> \\<sigma> ne, rel2)]\n     | x # aux' \\<Rightarrow>\n         if fst x = \\<tau> \\<sigma> ne\n         then (fst x, snd x \\<union> rel2) # aux'\n         else (\\<tau> \\<sigma> ne, rel2) # x # aux')", "unfolding aux0_def update_since_def Let_def"], ["proof (prove)\nusing this:\n  (rel, aux') =\n  (foldr (\\<union>)\n    (concat\n      (map (\\<lambda>(t, rel).\n               if left I \\<le> \\<tau> \\<sigma> ne - t then [rel] else [])\n        (case concat\n               (map (\\<lambda>(t, rel).\n                        if enat (\\<tau> \\<sigma> ne) - enat t \\<le> right I\n                        then [(t, join rel pos rel1)] else [])\n                 aux) of\n         [] \\<Rightarrow> [(\\<tau> \\<sigma> ne, rel2)]\n         | x # aux' \\<Rightarrow>\n             if fst x = \\<tau> \\<sigma> ne\n             then (fst x, snd x \\<union> rel2) # aux'\n             else (\\<tau> \\<sigma> ne, rel2) # x # aux')))\n    {},\n   case concat\n         (map (\\<lambda>(t, rel).\n                  if enat (\\<tau> \\<sigma> ne) - enat t \\<le> right I\n                  then [(t, join rel pos rel1)] else [])\n           aux) of\n   [] \\<Rightarrow> [(\\<tau> \\<sigma> ne, rel2)]\n   | x # aux' \\<Rightarrow>\n       if fst x = \\<tau> \\<sigma> ne\n       then (fst x, snd x \\<union> rel2) # aux'\n       else (\\<tau> \\<sigma> ne, rel2) # x # aux')\n\ngoal (1 subgoal):\n 1. aux' =\n    (case concat\n           (map (\\<lambda>(t, rel).\n                    if enat (\\<tau> \\<sigma> ne - t) \\<le> right I\n                    then [(t, join rel pos rel1)] else [])\n             aux) of\n     [] \\<Rightarrow> [(\\<tau> \\<sigma> ne, rel2)]\n     | x # aux' \\<Rightarrow>\n         if fst x = \\<tau> \\<sigma> ne\n         then (fst x, snd x \\<union> rel2) # aux'\n         else (\\<tau> \\<sigma> ne, rel2) # x # aux')", "by simp"], ["proof (state)\nthis:\n  aux' =\n  (case aux0 of [] \\<Rightarrow> [(\\<tau> \\<sigma> ne, rel2)]\n   | x # aux' \\<Rightarrow>\n       if fst x = \\<tau> \\<sigma> ne\n       then (fst x, snd x \\<union> rel2) # aux'\n       else (\\<tau> \\<sigma> ne, rel2) # x # aux')\n\ngoal (2 subgoals):\n 1. wf_since_aux \\<sigma> n R pos \\<phi> I \\<psi> aux' (Suc ne)\n 2. qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>))\n     rel", "have sorted_aux': \"sorted_wrt (\\<lambda>x y. fst x > fst y) aux'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. fst y < fst x) aux'", "unfolding aux'_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. fst y < fst x)\n     (case aux0 of [] \\<Rightarrow> [(\\<tau> \\<sigma> ne, rel2)]\n      | x # aux' \\<Rightarrow>\n          if fst x = \\<tau> \\<sigma> ne\n          then (fst x, snd x \\<union> rel2) # aux'\n          else (\\<tau> \\<sigma> ne, rel2) # x # aux')", "using sorted_aux0 in_aux0_le_\\<tau>"], ["proof (prove)\nusing this:\n  sorted_wrt (\\<lambda>x y. fst y < fst x) aux0\n  (?t1, ?X1) \\<in> set aux0 \\<Longrightarrow> ?t1 \\<le> \\<tau> \\<sigma> ne\n\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. fst y < fst x)\n     (case aux0 of [] \\<Rightarrow> [(\\<tau> \\<sigma> ne, rel2)]\n      | x # aux' \\<Rightarrow>\n          if fst x = \\<tau> \\<sigma> ne\n          then (fst x, snd x \\<union> rel2) # aux'\n          else (\\<tau> \\<sigma> ne, rel2) # x # aux')", "by (cases aux0) (fastforce)+"], ["proof (state)\nthis:\n  sorted_wrt (\\<lambda>x y. fst y < fst x) aux'\n\ngoal (2 subgoals):\n 1. wf_since_aux \\<sigma> n R pos \\<phi> I \\<psi> aux' (Suc ne)\n 2. qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>))\n     rel", "have in_aux'_1: \"t \\<le> \\<tau> \\<sigma> ne \\<and> \\<tau> \\<sigma> ne - t \\<le> right I \\<and> (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n      qtable n (MFOTL.fv \\<psi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>)) X\"\n    if aux': \"(t, X) \\<in> set aux'\" for t X"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X", "proof (cases aux0)"], ["proof (state)\ngoal (2 subgoals):\n 1. aux0 = [] \\<Longrightarrow>\n    t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X\n 2. \\<And>a list.\n       aux0 = a # list \\<Longrightarrow>\n       t \\<le> \\<tau> \\<sigma> ne \\<and>\n       enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n       (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n       qtable n (fv \\<psi>) (mem_restr R)\n        (\\<lambda>v.\n            MFOTL.sat \\<sigma> (map the v) ne\n             (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n        X", "case Nil"], ["proof (state)\nthis:\n  aux0 = []\n\ngoal (2 subgoals):\n 1. aux0 = [] \\<Longrightarrow>\n    t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X\n 2. \\<And>a list.\n       aux0 = a # list \\<Longrightarrow>\n       t \\<le> \\<tau> \\<sigma> ne \\<and>\n       enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n       (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n       qtable n (fv \\<psi>) (mem_restr R)\n        (\\<lambda>v.\n            MFOTL.sat \\<sigma> (map the v) ne\n             (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n        X", "with aux'"], ["proof (chain)\npicking this:\n  (t, X) \\<in> set aux'\n  aux0 = []", "show ?thesis"], ["proof (prove)\nusing this:\n  (t, X) \\<in> set aux'\n  aux0 = []\n\ngoal (1 subgoal):\n 1. t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X", "unfolding aux'_eq"], ["proof (prove)\nusing this:\n  (t, X)\n  \\<in> set (case aux0 of [] \\<Rightarrow> [(\\<tau> \\<sigma> ne, rel2)]\n             | x # aux' \\<Rightarrow>\n                 if fst x = \\<tau> \\<sigma> ne\n                 then (fst x, snd x \\<union> rel2) # aux'\n                 else (\\<tau> \\<sigma> ne, rel2) # x # aux')\n  aux0 = []\n\ngoal (1 subgoal):\n 1. t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X", "using qtable2 aux0_Nil"], ["proof (prove)\nusing this:\n  (t, X)\n  \\<in> set (case aux0 of [] \\<Rightarrow> [(\\<tau> \\<sigma> ne, rel2)]\n             | x # aux' \\<Rightarrow>\n                 if fst x = \\<tau> \\<sigma> ne\n                 then (fst x, snd x \\<union> rel2) # aux'\n                 else (\\<tau> \\<sigma> ne, rel2) # x # aux')\n  aux0 = []\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) ne \\<psi>) rel2\n  aux0 = [] \\<Longrightarrow>\n  ne = 0 \\<or>\n  ne \\<noteq> 0 \\<and>\n  (\\<forall>t.\n      t \\<le> \\<tau> \\<sigma> (ne - 1) \\<and>\n      enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<longrightarrow>\n      (\\<nexists>i. \\<tau> \\<sigma> i = t))\n\ngoal (1 subgoal):\n 1. t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X", "by (auto simp: zero_enat_def[symmetric] sat_Since_rec[where i=ne]\n        dest: spec[of _ \"\\<tau> \\<sigma> (ne-1)\"] elim!: qtable_cong[OF _ refl])"], ["proof (state)\nthis:\n  t \\<le> \\<tau> \\<sigma> ne \\<and>\n  enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n  (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>v.\n       MFOTL.sat \\<sigma> (map the v) ne\n        (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n   X\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       aux0 = a # list \\<Longrightarrow>\n       t \\<le> \\<tau> \\<sigma> ne \\<and>\n       enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n       (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n       qtable n (fv \\<psi>) (mem_restr R)\n        (\\<lambda>v.\n            MFOTL.sat \\<sigma> (map the v) ne\n             (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n        X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       aux0 = a # list \\<Longrightarrow>\n       t \\<le> \\<tau> \\<sigma> ne \\<and>\n       enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n       (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n       qtable n (fv \\<psi>) (mem_restr R)\n        (\\<lambda>v.\n            MFOTL.sat \\<sigma> (map the v) ne\n             (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n        X", "case (Cons a as)"], ["proof (state)\nthis:\n  aux0 = a # as\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       aux0 = a # list \\<Longrightarrow>\n       t \\<le> \\<tau> \\<sigma> ne \\<and>\n       enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n       (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n       qtable n (fv \\<psi>) (mem_restr R)\n        (\\<lambda>v.\n            MFOTL.sat \\<sigma> (map the v) ne\n             (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n        X", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X", "proof (cases \"t = \\<tau> \\<sigma> ne\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t = \\<tau> \\<sigma> ne \\<Longrightarrow>\n    t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X\n 2. t \\<noteq> \\<tau> \\<sigma> ne \\<Longrightarrow>\n    t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X", "case t: True"], ["proof (state)\nthis:\n  t = \\<tau> \\<sigma> ne\n\ngoal (2 subgoals):\n 1. t = \\<tau> \\<sigma> ne \\<Longrightarrow>\n    t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X\n 2. t \\<noteq> \\<tau> \\<sigma> ne \\<Longrightarrow>\n    t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X", "proof (cases \"fst a = \\<tau> \\<sigma> ne\")"], ["proof (state)\ngoal (2 subgoals):\n 1. fst a = \\<tau> \\<sigma> ne \\<Longrightarrow>\n    t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X\n 2. fst a \\<noteq> \\<tau> \\<sigma> ne \\<Longrightarrow>\n    t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X", "case True"], ["proof (state)\nthis:\n  fst a = \\<tau> \\<sigma> ne\n\ngoal (2 subgoals):\n 1. fst a = \\<tau> \\<sigma> ne \\<Longrightarrow>\n    t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X\n 2. fst a \\<noteq> \\<tau> \\<sigma> ne \\<Longrightarrow>\n    t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X", "with aux' Cons t"], ["proof (chain)\npicking this:\n  (t, X) \\<in> set aux'\n  aux0 = a # as\n  t = \\<tau> \\<sigma> ne\n  fst a = \\<tau> \\<sigma> ne", "have \"X = snd a \\<union> rel2\""], ["proof (prove)\nusing this:\n  (t, X) \\<in> set aux'\n  aux0 = a # as\n  t = \\<tau> \\<sigma> ne\n  fst a = \\<tau> \\<sigma> ne\n\ngoal (1 subgoal):\n 1. X = snd a \\<union> rel2", "unfolding aux'_eq"], ["proof (prove)\nusing this:\n  (t, X)\n  \\<in> set (case aux0 of [] \\<Rightarrow> [(\\<tau> \\<sigma> ne, rel2)]\n             | x # aux' \\<Rightarrow>\n                 if fst x = \\<tau> \\<sigma> ne\n                 then (fst x, snd x \\<union> rel2) # aux'\n                 else (\\<tau> \\<sigma> ne, rel2) # x # aux')\n  aux0 = a # as\n  t = \\<tau> \\<sigma> ne\n  fst a = \\<tau> \\<sigma> ne\n\ngoal (1 subgoal):\n 1. X = snd a \\<union> rel2", "using sorted_aux0"], ["proof (prove)\nusing this:\n  (t, X)\n  \\<in> set (case aux0 of [] \\<Rightarrow> [(\\<tau> \\<sigma> ne, rel2)]\n             | x # aux' \\<Rightarrow>\n                 if fst x = \\<tau> \\<sigma> ne\n                 then (fst x, snd x \\<union> rel2) # aux'\n                 else (\\<tau> \\<sigma> ne, rel2) # x # aux')\n  aux0 = a # as\n  t = \\<tau> \\<sigma> ne\n  fst a = \\<tau> \\<sigma> ne\n  sorted_wrt (\\<lambda>x y. fst y < fst x) aux0\n\ngoal (1 subgoal):\n 1. X = snd a \\<union> rel2", "by auto"], ["proof (state)\nthis:\n  X = snd a \\<union> rel2\n\ngoal (2 subgoals):\n 1. fst a = \\<tau> \\<sigma> ne \\<Longrightarrow>\n    t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X\n 2. fst a \\<noteq> \\<tau> \\<sigma> ne \\<Longrightarrow>\n    t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X", "moreover"], ["proof (state)\nthis:\n  X = snd a \\<union> rel2\n\ngoal (2 subgoals):\n 1. fst a = \\<tau> \\<sigma> ne \\<Longrightarrow>\n    t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X\n 2. fst a \\<noteq> \\<tau> \\<sigma> ne \\<Longrightarrow>\n    t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X", "from in_aux0_1[of \"fst a\" \"snd a\"] Cons"], ["proof (chain)\npicking this:\n  (fst a, snd a) \\<in> set aux0 \\<Longrightarrow>\n  ne \\<noteq> 0 \\<and>\n  fst a \\<le> \\<tau> \\<sigma> (ne - 1) \\<and>\n  enat (\\<tau> \\<sigma> ne - fst a) \\<le> right I \\<and>\n  (\\<exists>i. \\<tau> \\<sigma> i = fst a) \\<and>\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>v.\n       MFOTL.sat \\<sigma> (map the v) (ne - 1)\n        (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (ne - 1) - fst a))\n          \\<psi>) \\<and>\n       (if pos then MFOTL.sat \\<sigma> (map the v) ne \\<phi>\n        else \\<not> MFOTL.sat \\<sigma> (map the v) ne \\<phi>))\n   (snd a)\n  aux0 = a # as", "have \"ne \\<noteq> 0\"\n          \"fst a \\<le> \\<tau> \\<sigma> (ne - 1)\" \"\\<tau> \\<sigma> ne - fst a \\<le> right I\" \"\\<exists>i. \\<tau> \\<sigma> i = fst a\"\n          \"qtable n (fv \\<psi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) (ne - 1)\n            (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (ne - 1) - fst a)) \\<psi>) \\<and> (if pos then MFOTL.sat \\<sigma> (map the v) ne \\<phi>\n              else \\<not> MFOTL.sat \\<sigma> (map the v) ne \\<phi>)) (snd a)\""], ["proof (prove)\nusing this:\n  (fst a, snd a) \\<in> set aux0 \\<Longrightarrow>\n  ne \\<noteq> 0 \\<and>\n  fst a \\<le> \\<tau> \\<sigma> (ne - 1) \\<and>\n  enat (\\<tau> \\<sigma> ne - fst a) \\<le> right I \\<and>\n  (\\<exists>i. \\<tau> \\<sigma> i = fst a) \\<and>\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>v.\n       MFOTL.sat \\<sigma> (map the v) (ne - 1)\n        (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (ne - 1) - fst a))\n          \\<psi>) \\<and>\n       (if pos then MFOTL.sat \\<sigma> (map the v) ne \\<phi>\n        else \\<not> MFOTL.sat \\<sigma> (map the v) ne \\<phi>))\n   (snd a)\n  aux0 = a # as\n\ngoal (1 subgoal):\n 1. (ne \\<noteq> 0 &&& fst a \\<le> \\<tau> \\<sigma> (ne - 1)) &&&\n    enat (\\<tau> \\<sigma> ne - fst a) \\<le> right I &&&\n    \\<exists>i. \\<tau> \\<sigma> i = fst a &&&\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) (ne - 1)\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (ne - 1) - fst a))\n            \\<psi>) \\<and>\n         (if pos then MFOTL.sat \\<sigma> (map the v) ne \\<phi>\n          else \\<not> MFOTL.sat \\<sigma> (map the v) ne \\<phi>))\n     (snd a)", "by auto"], ["proof (state)\nthis:\n  ne \\<noteq> 0\n  fst a \\<le> \\<tau> \\<sigma> (ne - 1)\n  enat (\\<tau> \\<sigma> ne - fst a) \\<le> right I\n  \\<exists>i. \\<tau> \\<sigma> i = fst a\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>v.\n       MFOTL.sat \\<sigma> (map the v) (ne - 1)\n        (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (ne - 1) - fst a))\n          \\<psi>) \\<and>\n       (if pos then MFOTL.sat \\<sigma> (map the v) ne \\<phi>\n        else \\<not> MFOTL.sat \\<sigma> (map the v) ne \\<phi>))\n   (snd a)\n\ngoal (2 subgoals):\n 1. fst a = \\<tau> \\<sigma> ne \\<Longrightarrow>\n    t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X\n 2. fst a \\<noteq> \\<tau> \\<sigma> ne \\<Longrightarrow>\n    t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X", "ultimately"], ["proof (chain)\npicking this:\n  X = snd a \\<union> rel2\n  ne \\<noteq> 0\n  fst a \\<le> \\<tau> \\<sigma> (ne - 1)\n  enat (\\<tau> \\<sigma> ne - fst a) \\<le> right I\n  \\<exists>i. \\<tau> \\<sigma> i = fst a\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>v.\n       MFOTL.sat \\<sigma> (map the v) (ne - 1)\n        (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (ne - 1) - fst a))\n          \\<psi>) \\<and>\n       (if pos then MFOTL.sat \\<sigma> (map the v) ne \\<phi>\n        else \\<not> MFOTL.sat \\<sigma> (map the v) ne \\<phi>))\n   (snd a)", "show ?thesis"], ["proof (prove)\nusing this:\n  X = snd a \\<union> rel2\n  ne \\<noteq> 0\n  fst a \\<le> \\<tau> \\<sigma> (ne - 1)\n  enat (\\<tau> \\<sigma> ne - fst a) \\<le> right I\n  \\<exists>i. \\<tau> \\<sigma> i = fst a\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>v.\n       MFOTL.sat \\<sigma> (map the v) (ne - 1)\n        (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (ne - 1) - fst a))\n          \\<psi>) \\<and>\n       (if pos then MFOTL.sat \\<sigma> (map the v) ne \\<phi>\n        else \\<not> MFOTL.sat \\<sigma> (map the v) ne \\<phi>))\n   (snd a)\n\ngoal (1 subgoal):\n 1. t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X", "using qtable2 t True"], ["proof (prove)\nusing this:\n  X = snd a \\<union> rel2\n  ne \\<noteq> 0\n  fst a \\<le> \\<tau> \\<sigma> (ne - 1)\n  enat (\\<tau> \\<sigma> ne - fst a) \\<le> right I\n  \\<exists>i. \\<tau> \\<sigma> i = fst a\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>v.\n       MFOTL.sat \\<sigma> (map the v) (ne - 1)\n        (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (ne - 1) - fst a))\n          \\<psi>) \\<and>\n       (if pos then MFOTL.sat \\<sigma> (map the v) ne \\<phi>\n        else \\<not> MFOTL.sat \\<sigma> (map the v) ne \\<phi>))\n   (snd a)\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) ne \\<psi>) rel2\n  t = \\<tau> \\<sigma> ne\n  fst a = \\<tau> \\<sigma> ne\n\ngoal (1 subgoal):\n 1. t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X", "by (auto simp: sat_Since_rec[where i=ne] sat.simps(3) elim!: qtable_union)"], ["proof (state)\nthis:\n  t \\<le> \\<tau> \\<sigma> ne \\<and>\n  enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n  (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>v.\n       MFOTL.sat \\<sigma> (map the v) ne\n        (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n   X\n\ngoal (1 subgoal):\n 1. fst a \\<noteq> \\<tau> \\<sigma> ne \\<Longrightarrow>\n    t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fst a \\<noteq> \\<tau> \\<sigma> ne \\<Longrightarrow>\n    t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X", "case False"], ["proof (state)\nthis:\n  fst a \\<noteq> \\<tau> \\<sigma> ne\n\ngoal (1 subgoal):\n 1. fst a \\<noteq> \\<tau> \\<sigma> ne \\<Longrightarrow>\n    t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X", "with aux' Cons t"], ["proof (chain)\npicking this:\n  (t, X) \\<in> set aux'\n  aux0 = a # as\n  t = \\<tau> \\<sigma> ne\n  fst a \\<noteq> \\<tau> \\<sigma> ne", "have \"X = rel2\""], ["proof (prove)\nusing this:\n  (t, X) \\<in> set aux'\n  aux0 = a # as\n  t = \\<tau> \\<sigma> ne\n  fst a \\<noteq> \\<tau> \\<sigma> ne\n\ngoal (1 subgoal):\n 1. X = rel2", "unfolding aux'_eq"], ["proof (prove)\nusing this:\n  (t, X)\n  \\<in> set (case aux0 of [] \\<Rightarrow> [(\\<tau> \\<sigma> ne, rel2)]\n             | x # aux' \\<Rightarrow>\n                 if fst x = \\<tau> \\<sigma> ne\n                 then (fst x, snd x \\<union> rel2) # aux'\n                 else (\\<tau> \\<sigma> ne, rel2) # x # aux')\n  aux0 = a # as\n  t = \\<tau> \\<sigma> ne\n  fst a \\<noteq> \\<tau> \\<sigma> ne\n\ngoal (1 subgoal):\n 1. X = rel2", "using sorted_aux0 in_aux0_le_\\<tau>[of \"fst a\" \"snd a\"]"], ["proof (prove)\nusing this:\n  (t, X)\n  \\<in> set (case aux0 of [] \\<Rightarrow> [(\\<tau> \\<sigma> ne, rel2)]\n             | x # aux' \\<Rightarrow>\n                 if fst x = \\<tau> \\<sigma> ne\n                 then (fst x, snd x \\<union> rel2) # aux'\n                 else (\\<tau> \\<sigma> ne, rel2) # x # aux')\n  aux0 = a # as\n  t = \\<tau> \\<sigma> ne\n  fst a \\<noteq> \\<tau> \\<sigma> ne\n  sorted_wrt (\\<lambda>x y. fst y < fst x) aux0\n  (fst a, snd a) \\<in> set aux0 \\<Longrightarrow>\n  fst a \\<le> \\<tau> \\<sigma> ne\n\ngoal (1 subgoal):\n 1. X = rel2", "by auto"], ["proof (state)\nthis:\n  X = rel2\n\ngoal (1 subgoal):\n 1. fst a \\<noteq> \\<tau> \\<sigma> ne \\<Longrightarrow>\n    t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X", "with aux' Cons t False"], ["proof (chain)\npicking this:\n  (t, X) \\<in> set aux'\n  aux0 = a # as\n  t = \\<tau> \\<sigma> ne\n  fst a \\<noteq> \\<tau> \\<sigma> ne\n  X = rel2", "show ?thesis"], ["proof (prove)\nusing this:\n  (t, X) \\<in> set aux'\n  aux0 = a # as\n  t = \\<tau> \\<sigma> ne\n  fst a \\<noteq> \\<tau> \\<sigma> ne\n  X = rel2\n\ngoal (1 subgoal):\n 1. t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X", "unfolding aux'_eq"], ["proof (prove)\nusing this:\n  (t, X)\n  \\<in> set (case aux0 of [] \\<Rightarrow> [(\\<tau> \\<sigma> ne, rel2)]\n             | x # aux' \\<Rightarrow>\n                 if fst x = \\<tau> \\<sigma> ne\n                 then (fst x, snd x \\<union> rel2) # aux'\n                 else (\\<tau> \\<sigma> ne, rel2) # x # aux')\n  aux0 = a # as\n  t = \\<tau> \\<sigma> ne\n  fst a \\<noteq> \\<tau> \\<sigma> ne\n  X = rel2\n\ngoal (1 subgoal):\n 1. t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X", "using qtable2 in_aux0_2[of \"\\<tau> \\<sigma> (ne-1)\"] in_aux0_le_\\<tau>[of \"fst a\" \"snd a\"] sorted_aux0"], ["proof (prove)\nusing this:\n  (t, X)\n  \\<in> set (case aux0 of [] \\<Rightarrow> [(\\<tau> \\<sigma> ne, rel2)]\n             | x # aux' \\<Rightarrow>\n                 if fst x = \\<tau> \\<sigma> ne\n                 then (fst x, snd x \\<union> rel2) # aux'\n                 else (\\<tau> \\<sigma> ne, rel2) # x # aux')\n  aux0 = a # as\n  t = \\<tau> \\<sigma> ne\n  fst a \\<noteq> \\<tau> \\<sigma> ne\n  X = rel2\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) ne \\<psi>) rel2\n  \\<lbrakk>ne \\<noteq> 0;\n   \\<tau> \\<sigma> (ne - 1) \\<le> \\<tau> \\<sigma> (ne - 1);\n   enat (\\<Delta> \\<sigma> ne) \\<le> right I;\n   \\<exists>i. \\<tau> \\<sigma> i = \\<tau> \\<sigma> (ne - 1)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>X. (\\<tau> \\<sigma> (ne - 1), X) \\<in> set aux0\n  (fst a, snd a) \\<in> set aux0 \\<Longrightarrow>\n  fst a \\<le> \\<tau> \\<sigma> ne\n  sorted_wrt (\\<lambda>x y. fst y < fst x) aux0\n\ngoal (1 subgoal):\n 1. t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X", "by (auto simp: sat_Since_rec[where i=ne] sat.simps(3) zero_enat_def[symmetric] enat_0_iff not_le\n            elim!: qtable_cong[OF _ refl] dest!: le_\\<tau>_less meta_mp)"], ["proof (state)\nthis:\n  t \\<le> \\<tau> \\<sigma> ne \\<and>\n  enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n  (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>v.\n       MFOTL.sat \\<sigma> (map the v) ne\n        (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n   X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<le> \\<tau> \\<sigma> ne \\<and>\n  enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n  (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>v.\n       MFOTL.sat \\<sigma> (map the v) ne\n        (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n   X\n\ngoal (1 subgoal):\n 1. t \\<noteq> \\<tau> \\<sigma> ne \\<Longrightarrow>\n    t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<noteq> \\<tau> \\<sigma> ne \\<Longrightarrow>\n    t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X", "case False"], ["proof (state)\nthis:\n  t \\<noteq> \\<tau> \\<sigma> ne\n\ngoal (1 subgoal):\n 1. t \\<noteq> \\<tau> \\<sigma> ne \\<Longrightarrow>\n    t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X", "with aux' Cons"], ["proof (chain)\npicking this:\n  (t, X) \\<in> set aux'\n  aux0 = a # as\n  t \\<noteq> \\<tau> \\<sigma> ne", "have \"(t, X) \\<in> set aux0\""], ["proof (prove)\nusing this:\n  (t, X) \\<in> set aux'\n  aux0 = a # as\n  t \\<noteq> \\<tau> \\<sigma> ne\n\ngoal (1 subgoal):\n 1. (t, X) \\<in> set aux0", "unfolding aux'_eq"], ["proof (prove)\nusing this:\n  (t, X)\n  \\<in> set (case aux0 of [] \\<Rightarrow> [(\\<tau> \\<sigma> ne, rel2)]\n             | x # aux' \\<Rightarrow>\n                 if fst x = \\<tau> \\<sigma> ne\n                 then (fst x, snd x \\<union> rel2) # aux'\n                 else (\\<tau> \\<sigma> ne, rel2) # x # aux')\n  aux0 = a # as\n  t \\<noteq> \\<tau> \\<sigma> ne\n\ngoal (1 subgoal):\n 1. (t, X) \\<in> set aux0", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  (t, X) \\<in> set aux0\n\ngoal (1 subgoal):\n 1. t \\<noteq> \\<tau> \\<sigma> ne \\<Longrightarrow>\n    t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X", "then"], ["proof (chain)\npicking this:\n  (t, X) \\<in> set aux0", "have \"ne \\<noteq> 0\" \"t \\<le> \\<tau> \\<sigma> (ne - 1)\" \"\\<tau> \\<sigma> ne - t \\<le> right I\" \"\\<exists>i. \\<tau> \\<sigma> i = t\"\n        \"qtable n (fv \\<psi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) (ne - 1) (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (ne - 1) - t)) \\<psi>) \\<and>\n           (if pos then MFOTL.sat \\<sigma> (map the v) ne \\<phi> else \\<not> MFOTL.sat \\<sigma> (map the v) ne \\<phi>)) X\""], ["proof (prove)\nusing this:\n  (t, X) \\<in> set aux0\n\ngoal (1 subgoal):\n 1. (ne \\<noteq> 0 &&& t \\<le> \\<tau> \\<sigma> (ne - 1)) &&&\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I &&&\n    \\<exists>i. \\<tau> \\<sigma> i = t &&&\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) (ne - 1)\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (ne - 1) - t))\n            \\<psi>) \\<and>\n         (if pos then MFOTL.sat \\<sigma> (map the v) ne \\<phi>\n          else \\<not> MFOTL.sat \\<sigma> (map the v) ne \\<phi>))\n     X", "using in_aux0_1"], ["proof (prove)\nusing this:\n  (t, X) \\<in> set aux0\n  (?t1, ?X1) \\<in> set aux0 \\<Longrightarrow>\n  ne \\<noteq> 0 \\<and>\n  ?t1 \\<le> \\<tau> \\<sigma> (ne - 1) \\<and>\n  enat (\\<tau> \\<sigma> ne - ?t1) \\<le> right I \\<and>\n  (\\<exists>i. \\<tau> \\<sigma> i = ?t1) \\<and>\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>v.\n       MFOTL.sat \\<sigma> (map the v) (ne - 1)\n        (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (ne - 1) - ?t1))\n          \\<psi>) \\<and>\n       (if pos then MFOTL.sat \\<sigma> (map the v) ne \\<phi>\n        else \\<not> MFOTL.sat \\<sigma> (map the v) ne \\<phi>))\n   ?X1\n\ngoal (1 subgoal):\n 1. (ne \\<noteq> 0 &&& t \\<le> \\<tau> \\<sigma> (ne - 1)) &&&\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I &&&\n    \\<exists>i. \\<tau> \\<sigma> i = t &&&\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) (ne - 1)\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (ne - 1) - t))\n            \\<psi>) \\<and>\n         (if pos then MFOTL.sat \\<sigma> (map the v) ne \\<phi>\n          else \\<not> MFOTL.sat \\<sigma> (map the v) ne \\<phi>))\n     X", "by blast+"], ["proof (state)\nthis:\n  ne \\<noteq> 0\n  t \\<le> \\<tau> \\<sigma> (ne - 1)\n  enat (\\<tau> \\<sigma> ne - t) \\<le> right I\n  \\<exists>i. \\<tau> \\<sigma> i = t\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>v.\n       MFOTL.sat \\<sigma> (map the v) (ne - 1)\n        (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (ne - 1) - t))\n          \\<psi>) \\<and>\n       (if pos then MFOTL.sat \\<sigma> (map the v) ne \\<phi>\n        else \\<not> MFOTL.sat \\<sigma> (map the v) ne \\<phi>))\n   X\n\ngoal (1 subgoal):\n 1. t \\<noteq> \\<tau> \\<sigma> ne \\<Longrightarrow>\n    t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X", "with False aux' Cons"], ["proof (chain)\npicking this:\n  t \\<noteq> \\<tau> \\<sigma> ne\n  (t, X) \\<in> set aux'\n  aux0 = a # as\n  ne \\<noteq> 0\n  t \\<le> \\<tau> \\<sigma> (ne - 1)\n  enat (\\<tau> \\<sigma> ne - t) \\<le> right I\n  \\<exists>i. \\<tau> \\<sigma> i = t\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>v.\n       MFOTL.sat \\<sigma> (map the v) (ne - 1)\n        (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (ne - 1) - t))\n          \\<psi>) \\<and>\n       (if pos then MFOTL.sat \\<sigma> (map the v) ne \\<phi>\n        else \\<not> MFOTL.sat \\<sigma> (map the v) ne \\<phi>))\n   X", "show ?thesis"], ["proof (prove)\nusing this:\n  t \\<noteq> \\<tau> \\<sigma> ne\n  (t, X) \\<in> set aux'\n  aux0 = a # as\n  ne \\<noteq> 0\n  t \\<le> \\<tau> \\<sigma> (ne - 1)\n  enat (\\<tau> \\<sigma> ne - t) \\<le> right I\n  \\<exists>i. \\<tau> \\<sigma> i = t\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>v.\n       MFOTL.sat \\<sigma> (map the v) (ne - 1)\n        (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (ne - 1) - t))\n          \\<psi>) \\<and>\n       (if pos then MFOTL.sat \\<sigma> (map the v) ne \\<phi>\n        else \\<not> MFOTL.sat \\<sigma> (map the v) ne \\<phi>))\n   X\n\ngoal (1 subgoal):\n 1. t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X", "unfolding aux'_eq"], ["proof (prove)\nusing this:\n  t \\<noteq> \\<tau> \\<sigma> ne\n  (t, X)\n  \\<in> set (case aux0 of [] \\<Rightarrow> [(\\<tau> \\<sigma> ne, rel2)]\n             | x # aux' \\<Rightarrow>\n                 if fst x = \\<tau> \\<sigma> ne\n                 then (fst x, snd x \\<union> rel2) # aux'\n                 else (\\<tau> \\<sigma> ne, rel2) # x # aux')\n  aux0 = a # as\n  ne \\<noteq> 0\n  t \\<le> \\<tau> \\<sigma> (ne - 1)\n  enat (\\<tau> \\<sigma> ne - t) \\<le> right I\n  \\<exists>i. \\<tau> \\<sigma> i = t\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>v.\n       MFOTL.sat \\<sigma> (map the v) (ne - 1)\n        (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (ne - 1) - t))\n          \\<psi>) \\<and>\n       (if pos then MFOTL.sat \\<sigma> (map the v) ne \\<phi>\n        else \\<not> MFOTL.sat \\<sigma> (map the v) ne \\<phi>))\n   X\n\ngoal (1 subgoal):\n 1. t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X", "using qtable2"], ["proof (prove)\nusing this:\n  t \\<noteq> \\<tau> \\<sigma> ne\n  (t, X)\n  \\<in> set (case aux0 of [] \\<Rightarrow> [(\\<tau> \\<sigma> ne, rel2)]\n             | x # aux' \\<Rightarrow>\n                 if fst x = \\<tau> \\<sigma> ne\n                 then (fst x, snd x \\<union> rel2) # aux'\n                 else (\\<tau> \\<sigma> ne, rel2) # x # aux')\n  aux0 = a # as\n  ne \\<noteq> 0\n  t \\<le> \\<tau> \\<sigma> (ne - 1)\n  enat (\\<tau> \\<sigma> ne - t) \\<le> right I\n  \\<exists>i. \\<tau> \\<sigma> i = t\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>v.\n       MFOTL.sat \\<sigma> (map the v) (ne - 1)\n        (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (ne - 1) - t))\n          \\<psi>) \\<and>\n       (if pos then MFOTL.sat \\<sigma> (map the v) ne \\<phi>\n        else \\<not> MFOTL.sat \\<sigma> (map the v) ne \\<phi>))\n   X\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) ne \\<psi>) rel2\n\ngoal (1 subgoal):\n 1. t \\<le> \\<tau> \\<sigma> ne \\<and>\n    enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n    (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne\n          (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n     X", "by (fastforce simp: sat_Since_rec[where i=ne] sat.simps(3)\n          diff_diff_right[where i=\"\\<tau> \\<sigma> ne\" and j=\"\\<tau> \\<sigma> _ + \\<tau> \\<sigma> ne\" and k=\"\\<tau> \\<sigma> (ne - 1)\",\n            OF trans_le_add2, simplified] elim!: qtable_cong[OF _ refl] order_trans dest: le_\\<tau>_less)"], ["proof (state)\nthis:\n  t \\<le> \\<tau> \\<sigma> ne \\<and>\n  enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n  (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>v.\n       MFOTL.sat \\<sigma> (map the v) ne\n        (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n   X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<le> \\<tau> \\<sigma> ne \\<and>\n  enat (\\<tau> \\<sigma> ne - t) \\<le> right I \\<and>\n  (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>v.\n       MFOTL.sat \\<sigma> (map the v) ne\n        (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n   X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?t1, ?X1) \\<in> set aux' \\<Longrightarrow>\n  ?t1 \\<le> \\<tau> \\<sigma> ne \\<and>\n  enat (\\<tau> \\<sigma> ne - ?t1) \\<le> right I \\<and>\n  (\\<exists>i. \\<tau> \\<sigma> i = ?t1) \\<and>\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>v.\n       MFOTL.sat \\<sigma> (map the v) ne\n        (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - ?t1)) \\<psi>))\n   ?X1\n\ngoal (2 subgoals):\n 1. wf_since_aux \\<sigma> n R pos \\<phi> I \\<psi> aux' (Suc ne)\n 2. qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>))\n     rel", "have in_aux'_2: \"\\<exists>X. (t, X) \\<in> set aux'\" if \"t \\<le> \\<tau> \\<sigma> ne\" \"\\<tau> \\<sigma> ne - t \\<le> right I\" \"\\<exists>i. \\<tau> \\<sigma> i = t\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X. (t, X) \\<in> set aux'", "proof (cases \"t = \\<tau> \\<sigma> ne\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t = \\<tau> \\<sigma> ne \\<Longrightarrow>\n    \\<exists>X. (t, X) \\<in> set aux'\n 2. t \\<noteq> \\<tau> \\<sigma> ne \\<Longrightarrow>\n    \\<exists>X. (t, X) \\<in> set aux'", "case True"], ["proof (state)\nthis:\n  t = \\<tau> \\<sigma> ne\n\ngoal (2 subgoals):\n 1. t = \\<tau> \\<sigma> ne \\<Longrightarrow>\n    \\<exists>X. (t, X) \\<in> set aux'\n 2. t \\<noteq> \\<tau> \\<sigma> ne \\<Longrightarrow>\n    \\<exists>X. (t, X) \\<in> set aux'", "then"], ["proof (chain)\npicking this:\n  t = \\<tau> \\<sigma> ne", "show ?thesis"], ["proof (prove)\nusing this:\n  t = \\<tau> \\<sigma> ne\n\ngoal (1 subgoal):\n 1. \\<exists>X. (t, X) \\<in> set aux'", "proof (cases aux0)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>t = \\<tau> \\<sigma> ne; aux0 = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>X. (t, X) \\<in> set aux'\n 2. \\<And>a list.\n       \\<lbrakk>t = \\<tau> \\<sigma> ne; aux0 = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X. (t, X) \\<in> set aux'", "case Nil"], ["proof (state)\nthis:\n  aux0 = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>t = \\<tau> \\<sigma> ne; aux0 = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>X. (t, X) \\<in> set aux'\n 2. \\<And>a list.\n       \\<lbrakk>t = \\<tau> \\<sigma> ne; aux0 = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X. (t, X) \\<in> set aux'", "with True"], ["proof (chain)\npicking this:\n  t = \\<tau> \\<sigma> ne\n  aux0 = []", "show ?thesis"], ["proof (prove)\nusing this:\n  t = \\<tau> \\<sigma> ne\n  aux0 = []\n\ngoal (1 subgoal):\n 1. \\<exists>X. (t, X) \\<in> set aux'", "unfolding aux'_eq"], ["proof (prove)\nusing this:\n  t = \\<tau> \\<sigma> ne\n  aux0 = []\n\ngoal (1 subgoal):\n 1. \\<exists>X.\n       (t, X)\n       \\<in> set (case aux0 of [] \\<Rightarrow> [(\\<tau> \\<sigma> ne, rel2)]\n                  | x # aux' \\<Rightarrow>\n                      if fst x = \\<tau> \\<sigma> ne\n                      then (fst x, snd x \\<union> rel2) # aux'\n                      else (\\<tau> \\<sigma> ne, rel2) # x # aux')", "by simp"], ["proof (state)\nthis:\n  \\<exists>X. (t, X) \\<in> set aux'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>t = \\<tau> \\<sigma> ne; aux0 = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X. (t, X) \\<in> set aux'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>t = \\<tau> \\<sigma> ne; aux0 = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X. (t, X) \\<in> set aux'", "case (Cons a as)"], ["proof (state)\nthis:\n  aux0 = a # as\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>t = \\<tau> \\<sigma> ne; aux0 = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>X. (t, X) \\<in> set aux'", "with True"], ["proof (chain)\npicking this:\n  t = \\<tau> \\<sigma> ne\n  aux0 = a # as", "show ?thesis"], ["proof (prove)\nusing this:\n  t = \\<tau> \\<sigma> ne\n  aux0 = a # as\n\ngoal (1 subgoal):\n 1. \\<exists>X. (t, X) \\<in> set aux'", "unfolding aux'_eq"], ["proof (prove)\nusing this:\n  t = \\<tau> \\<sigma> ne\n  aux0 = a # as\n\ngoal (1 subgoal):\n 1. \\<exists>X.\n       (t, X)\n       \\<in> set (case aux0 of [] \\<Rightarrow> [(\\<tau> \\<sigma> ne, rel2)]\n                  | x # aux' \\<Rightarrow>\n                      if fst x = \\<tau> \\<sigma> ne\n                      then (fst x, snd x \\<union> rel2) # aux'\n                      else (\\<tau> \\<sigma> ne, rel2) # x # aux')", "by (cases \"fst a = \\<tau> \\<sigma> ne\") auto"], ["proof (state)\nthis:\n  \\<exists>X. (t, X) \\<in> set aux'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>X. (t, X) \\<in> set aux'\n\ngoal (1 subgoal):\n 1. t \\<noteq> \\<tau> \\<sigma> ne \\<Longrightarrow>\n    \\<exists>X. (t, X) \\<in> set aux'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<noteq> \\<tau> \\<sigma> ne \\<Longrightarrow>\n    \\<exists>X. (t, X) \\<in> set aux'", "case False"], ["proof (state)\nthis:\n  t \\<noteq> \\<tau> \\<sigma> ne\n\ngoal (1 subgoal):\n 1. t \\<noteq> \\<tau> \\<sigma> ne \\<Longrightarrow>\n    \\<exists>X. (t, X) \\<in> set aux'", "with that"], ["proof (chain)\npicking this:\n  t \\<le> \\<tau> \\<sigma> ne\n  enat (\\<tau> \\<sigma> ne - t) \\<le> right I\n  \\<exists>i. \\<tau> \\<sigma> i = t\n  t \\<noteq> \\<tau> \\<sigma> ne", "have \"ne \\<noteq> 0\""], ["proof (prove)\nusing this:\n  t \\<le> \\<tau> \\<sigma> ne\n  enat (\\<tau> \\<sigma> ne - t) \\<le> right I\n  \\<exists>i. \\<tau> \\<sigma> i = t\n  t \\<noteq> \\<tau> \\<sigma> ne\n\ngoal (1 subgoal):\n 1. ne \\<noteq> 0", "using le_\\<tau>_less neq0_conv"], ["proof (prove)\nusing this:\n  t \\<le> \\<tau> \\<sigma> ne\n  enat (\\<tau> \\<sigma> ne - t) \\<le> right I\n  \\<exists>i. \\<tau> \\<sigma> i = t\n  t \\<noteq> \\<tau> \\<sigma> ne\n  \\<lbrakk>\\<tau> ?\\<sigma> ?i \\<le> \\<tau> ?\\<sigma> ?j; ?j < ?i\\<rbrakk>\n  \\<Longrightarrow> \\<tau> ?\\<sigma> ?i = \\<tau> ?\\<sigma> ?j\n  (?n \\<noteq> 0) = (0 < ?n)\n\ngoal (1 subgoal):\n 1. ne \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  ne \\<noteq> 0\n\ngoal (1 subgoal):\n 1. t \\<noteq> \\<tau> \\<sigma> ne \\<Longrightarrow>\n    \\<exists>X. (t, X) \\<in> set aux'", "moreover"], ["proof (state)\nthis:\n  ne \\<noteq> 0\n\ngoal (1 subgoal):\n 1. t \\<noteq> \\<tau> \\<sigma> ne \\<Longrightarrow>\n    \\<exists>X. (t, X) \\<in> set aux'", "from False that"], ["proof (chain)\npicking this:\n  t \\<noteq> \\<tau> \\<sigma> ne\n  t \\<le> \\<tau> \\<sigma> ne\n  enat (\\<tau> \\<sigma> ne - t) \\<le> right I\n  \\<exists>i. \\<tau> \\<sigma> i = t", "have  \"t \\<le> \\<tau> \\<sigma> (ne-1)\""], ["proof (prove)\nusing this:\n  t \\<noteq> \\<tau> \\<sigma> ne\n  t \\<le> \\<tau> \\<sigma> ne\n  enat (\\<tau> \\<sigma> ne - t) \\<le> right I\n  \\<exists>i. \\<tau> \\<sigma> i = t\n\ngoal (1 subgoal):\n 1. t \\<le> \\<tau> \\<sigma> (ne - 1)", "by (metis One_nat_def Suc_leI Suc_pred \\<tau>_mono diff_is_0_eq' order.antisym neq0_conv not_le)"], ["proof (state)\nthis:\n  t \\<le> \\<tau> \\<sigma> (ne - 1)\n\ngoal (1 subgoal):\n 1. t \\<noteq> \\<tau> \\<sigma> ne \\<Longrightarrow>\n    \\<exists>X. (t, X) \\<in> set aux'", "ultimately"], ["proof (chain)\npicking this:\n  ne \\<noteq> 0\n  t \\<le> \\<tau> \\<sigma> (ne - 1)", "obtain X where \"(t, X) \\<in> set aux0\""], ["proof (prove)\nusing this:\n  ne \\<noteq> 0\n  t \\<le> \\<tau> \\<sigma> (ne - 1)\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        (t, X) \\<in> set aux0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>\\<tau> \\<sigma> ne - t \\<le> right I\\<close> \\<open>\\<exists>i. \\<tau> \\<sigma> i = t\\<close>"], ["proof (prove)\nusing this:\n  ne \\<noteq> 0\n  t \\<le> \\<tau> \\<sigma> (ne - 1)\n  enat (\\<tau> \\<sigma> ne - t) \\<le> right I\n  \\<exists>i. \\<tau> \\<sigma> i = t\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        (t, X) \\<in> set aux0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim (auto intro!: in_aux0_2)"], ["proof (state)\nthis:\n  (t, X) \\<in> set aux0\n\ngoal (1 subgoal):\n 1. t \\<noteq> \\<tau> \\<sigma> ne \\<Longrightarrow>\n    \\<exists>X. (t, X) \\<in> set aux'", "then"], ["proof (chain)\npicking this:\n  (t, X) \\<in> set aux0", "show ?thesis"], ["proof (prove)\nusing this:\n  (t, X) \\<in> set aux0\n\ngoal (1 subgoal):\n 1. \\<exists>X. (t, X) \\<in> set aux'", "unfolding aux'_eq"], ["proof (prove)\nusing this:\n  (t, X) \\<in> set aux0\n\ngoal (1 subgoal):\n 1. \\<exists>X.\n       (t, X)\n       \\<in> set (case aux0 of [] \\<Rightarrow> [(\\<tau> \\<sigma> ne, rel2)]\n                  | x # aux' \\<Rightarrow>\n                      if fst x = \\<tau> \\<sigma> ne\n                      then (fst x, snd x \\<union> rel2) # aux'\n                      else (\\<tau> \\<sigma> ne, rel2) # x # aux')", "using False"], ["proof (prove)\nusing this:\n  (t, X) \\<in> set aux0\n  t \\<noteq> \\<tau> \\<sigma> ne\n\ngoal (1 subgoal):\n 1. \\<exists>X.\n       (t, X)\n       \\<in> set (case aux0 of [] \\<Rightarrow> [(\\<tau> \\<sigma> ne, rel2)]\n                  | x # aux' \\<Rightarrow>\n                      if fst x = \\<tau> \\<sigma> ne\n                      then (fst x, snd x \\<union> rel2) # aux'\n                      else (\\<tau> \\<sigma> ne, rel2) # x # aux')", "by (auto intro: exI[of _ X] split: list.split)"], ["proof (state)\nthis:\n  \\<exists>X. (t, X) \\<in> set aux'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?t1 \\<le> \\<tau> \\<sigma> ne;\n   enat (\\<tau> \\<sigma> ne - ?t1) \\<le> right I;\n   \\<exists>i. \\<tau> \\<sigma> i = ?t1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>X. (?t1, X) \\<in> set aux'\n\ngoal (2 subgoals):\n 1. wf_since_aux \\<sigma> n R pos \\<phi> I \\<psi> aux' (Suc ne)\n 2. qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>))\n     rel", "show \"wf_since_aux \\<sigma> n R pos \\<phi> I \\<psi> aux' (Suc ne)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_since_aux \\<sigma> n R pos \\<phi> I \\<psi> aux' (Suc ne)", "unfolding wf_since_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (\\<lambda>x y. fst y < fst x) aux' \\<and>\n    (\\<forall>t X.\n        (t, X) \\<in> set aux' \\<longrightarrow>\n        Suc ne \\<noteq> 0 \\<and>\n        t \\<le> \\<tau> \\<sigma> (Suc ne - 1) \\<and>\n        enat (\\<tau> \\<sigma> (Suc ne - 1) - t) \\<le> right I \\<and>\n        (\\<exists>i. \\<tau> \\<sigma> i = t) \\<and>\n        qtable n (fv \\<psi>) (mem_restr R)\n         (\\<lambda>v.\n             MFOTL.sat \\<sigma> (map the v) (Suc ne - 1)\n              (Sincep pos \\<phi> (point (\\<tau> \\<sigma> (Suc ne - 1) - t))\n                \\<psi>))\n         X) \\<and>\n    (\\<forall>t.\n        Suc ne \\<noteq> 0 \\<and>\n        t \\<le> \\<tau> \\<sigma> (Suc ne - 1) \\<and>\n        enat (\\<tau> \\<sigma> (Suc ne - 1) - t) \\<le> right I \\<and>\n        (\\<exists>i. \\<tau> \\<sigma> i = t) \\<longrightarrow>\n        (\\<exists>X. (t, X) \\<in> set aux'))", "by (auto dest: in_aux'_1 intro: sorted_aux' in_aux'_2)"], ["proof (state)\nthis:\n  wf_since_aux \\<sigma> n R pos \\<phi> I \\<psi> aux' (Suc ne)\n\ngoal (1 subgoal):\n 1. qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>))\n     rel", "have rel_eq: \"rel = foldr (\\<union>) [rel. (t, rel) \\<leftarrow> aux', left I \\<le> \\<tau> \\<sigma> ne - t] {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel =\n    foldr (\\<union>)\n     (concat\n       (map (\\<lambda>(t, rel).\n                if left I \\<le> \\<tau> \\<sigma> ne - t then [rel] else [])\n         aux'))\n     {}", "unfolding aux'_eq aux0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel =\n    foldr (\\<union>)\n     (concat\n       (map (\\<lambda>(t, rel).\n                if left I \\<le> \\<tau> \\<sigma> ne - t then [rel] else [])\n         (case concat\n                (map (\\<lambda>(t, rel).\n                         if enat (\\<tau> \\<sigma> ne - t) \\<le> right I\n                         then [(t, join rel pos rel1)] else [])\n                  aux) of\n          [] \\<Rightarrow> [(\\<tau> \\<sigma> ne, rel2)]\n          | x # aux' \\<Rightarrow>\n              if fst x = \\<tau> \\<sigma> ne\n              then (fst x, snd x \\<union> rel2) # aux'\n              else (\\<tau> \\<sigma> ne, rel2) # x # aux')))\n     {}", "using result_eq"], ["proof (prove)\nusing this:\n  (rel, aux') = update_since I pos rel1 rel2 (\\<tau> \\<sigma> ne) aux\n\ngoal (1 subgoal):\n 1. rel =\n    foldr (\\<union>)\n     (concat\n       (map (\\<lambda>(t, rel).\n                if left I \\<le> \\<tau> \\<sigma> ne - t then [rel] else [])\n         (case concat\n                (map (\\<lambda>(t, rel).\n                         if enat (\\<tau> \\<sigma> ne - t) \\<le> right I\n                         then [(t, join rel pos rel1)] else [])\n                  aux) of\n          [] \\<Rightarrow> [(\\<tau> \\<sigma> ne, rel2)]\n          | x # aux' \\<Rightarrow>\n              if fst x = \\<tau> \\<sigma> ne\n              then (fst x, snd x \\<union> rel2) # aux'\n              else (\\<tau> \\<sigma> ne, rel2) # x # aux')))\n     {}", "by (simp add: update_since_def Let_def)"], ["proof (state)\nthis:\n  rel =\n  foldr (\\<union>)\n   (concat\n     (map (\\<lambda>(t, rel).\n              if left I \\<le> \\<tau> \\<sigma> ne - t then [rel] else [])\n       aux'))\n   {}\n\ngoal (1 subgoal):\n 1. qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>))\n     rel", "have rel_alt: \"rel = (\\<Union>(t, rel) \\<in> set aux'. if left I \\<le> \\<tau> \\<sigma> ne - t then rel else empty_table)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel =\n    (\\<Union>(t, rel)\\<in>set aux'.\n        if left I \\<le> \\<tau> \\<sigma> ne - t then rel else empty_table)", "unfolding rel_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<union>)\n     (concat\n       (map (\\<lambda>(t, rel).\n                if left I \\<le> \\<tau> \\<sigma> ne - t then [rel] else [])\n         aux'))\n     {} =\n    (\\<Union>(t, rel)\\<in>set aux'.\n        if left I \\<le> \\<tau> \\<sigma> ne - t then rel else empty_table)", "by (auto elim!: in_foldr_UnE bexI[rotated] intro!: in_foldr_UnI)"], ["proof (state)\nthis:\n  rel =\n  (\\<Union>(t, rel)\\<in>set aux'.\n      if left I \\<le> \\<tau> \\<sigma> ne - t then rel else empty_table)\n\ngoal (1 subgoal):\n 1. qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>))\n     rel", "show \"qtable n (fv \\<psi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>)) rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>))\n     rel", "unfolding rel_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>))\n     (\\<Union>(t, rel)\\<in>set aux'.\n         if left I \\<le> \\<tau> \\<sigma> ne - t then rel else empty_table)", "proof (rule qtable_Union[where Qi=\"\\<lambda>(t, X) v.\n    left I \\<le> \\<tau> \\<sigma> ne - t \\<and> MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>)\"],\n    goal_cases finite qtable equiv)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite (set aux')\n 2. \\<And>i.\n       i \\<in> set aux' \\<Longrightarrow>\n       qtable n (fv \\<psi>) (mem_restr R)\n        (case i of\n         (t, X) \\<Rightarrow>\n           \\<lambda>v.\n              left I \\<le> \\<tau> \\<sigma> ne - t \\<and>\n              MFOTL.sat \\<sigma> (map the v) ne\n               (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n        (case i of\n         (t, rel) \\<Rightarrow>\n           if left I \\<le> \\<tau> \\<sigma> ne - t then rel else empty_table)\n 3. \\<And>x.\n       \\<lbrakk>wf_tuple n (fv \\<psi>) x; mem_restr R x\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> (map the x) ne\n                          (Sincep pos \\<phi> I \\<psi>) =\n                         (\\<exists>i\\<in>set aux'.\n                             (case i of\n                              (t, X) \\<Rightarrow>\n                                \\<lambda>v.\n                                   left I\n                                   \\<le> \\<tau> \\<sigma> ne - t \\<and>\n                                   MFOTL.sat \\<sigma> (map the v) ne\n                                    (Sincep pos \\<phi>\n(point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n                              x)", "case (equiv v)"], ["proof (state)\nthis:\n  wf_tuple n (fv \\<psi>) v\n  mem_restr R v\n\ngoal (3 subgoals):\n 1. finite (set aux')\n 2. \\<And>i.\n       i \\<in> set aux' \\<Longrightarrow>\n       qtable n (fv \\<psi>) (mem_restr R)\n        (case i of\n         (t, X) \\<Rightarrow>\n           \\<lambda>v.\n              left I \\<le> \\<tau> \\<sigma> ne - t \\<and>\n              MFOTL.sat \\<sigma> (map the v) ne\n               (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n        (case i of\n         (t, rel) \\<Rightarrow>\n           if left I \\<le> \\<tau> \\<sigma> ne - t then rel else empty_table)\n 3. \\<And>x.\n       \\<lbrakk>wf_tuple n (fv \\<psi>) x; mem_restr R x\\<rbrakk>\n       \\<Longrightarrow> MFOTL.sat \\<sigma> (map the x) ne\n                          (Sincep pos \\<phi> I \\<psi>) =\n                         (\\<exists>i\\<in>set aux'.\n                             (case i of\n                              (t, X) \\<Rightarrow>\n                                \\<lambda>v.\n                                   left I\n                                   \\<le> \\<tau> \\<sigma> ne - t \\<and>\n                                   MFOTL.sat \\<sigma> (map the v) ne\n                                    (Sincep pos \\<phi>\n(point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n                              x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>) =\n    (\\<exists>i\\<in>set aux'.\n        (case i of\n         (t, X) \\<Rightarrow>\n           \\<lambda>v.\n              left I \\<le> \\<tau> \\<sigma> ne - t \\<and>\n              MFOTL.sat \\<sigma> (map the v) ne\n               (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n         v)", "proof (rule iffI, erule sat_Since_point, goal_cases left right)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> ne; mem (\\<tau> \\<sigma> ne - \\<tau> \\<sigma> j) I;\n        MFOTL.sat \\<sigma> (map the v) ne\n         (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - \\<tau> \\<sigma> j))\n           \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i\\<in>set aux'.\n                            (case i of\n                             (t, X) \\<Rightarrow>\n                               \\<lambda>v.\n                                  left I \\<le> \\<tau> \\<sigma> ne - t \\<and>\n                                  MFOTL.sat \\<sigma> (map the v) ne\n                                   (Sincep pos \\<phi>\n                                     (point (\\<tau> \\<sigma> ne - t))\n                                     \\<psi>))\n                             v\n 2. \\<exists>i\\<in>set aux'.\n       (case i of\n        (t, X) \\<Rightarrow>\n          \\<lambda>v.\n             left I \\<le> \\<tau> \\<sigma> ne - t \\<and>\n             MFOTL.sat \\<sigma> (map the v) ne\n              (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n        v \\<Longrightarrow>\n    MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>)", "case (left j)"], ["proof (state)\nthis:\n  j \\<le> ne\n  mem (\\<tau> \\<sigma> ne - \\<tau> \\<sigma> j) I\n  MFOTL.sat \\<sigma> (map the v) ne\n   (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - \\<tau> \\<sigma> j))\n     \\<psi>)\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> ne; mem (\\<tau> \\<sigma> ne - \\<tau> \\<sigma> j) I;\n        MFOTL.sat \\<sigma> (map the v) ne\n         (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - \\<tau> \\<sigma> j))\n           \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i\\<in>set aux'.\n                            (case i of\n                             (t, X) \\<Rightarrow>\n                               \\<lambda>v.\n                                  left I \\<le> \\<tau> \\<sigma> ne - t \\<and>\n                                  MFOTL.sat \\<sigma> (map the v) ne\n                                   (Sincep pos \\<phi>\n                                     (point (\\<tau> \\<sigma> ne - t))\n                                     \\<psi>))\n                             v\n 2. \\<exists>i\\<in>set aux'.\n       (case i of\n        (t, X) \\<Rightarrow>\n          \\<lambda>v.\n             left I \\<le> \\<tau> \\<sigma> ne - t \\<and>\n             MFOTL.sat \\<sigma> (map the v) ne\n              (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n        v \\<Longrightarrow>\n    MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>)", "then"], ["proof (chain)\npicking this:\n  j \\<le> ne\n  mem (\\<tau> \\<sigma> ne - \\<tau> \\<sigma> j) I\n  MFOTL.sat \\<sigma> (map the v) ne\n   (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - \\<tau> \\<sigma> j))\n     \\<psi>)", "show ?case"], ["proof (prove)\nusing this:\n  j \\<le> ne\n  mem (\\<tau> \\<sigma> ne - \\<tau> \\<sigma> j) I\n  MFOTL.sat \\<sigma> (map the v) ne\n   (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - \\<tau> \\<sigma> j))\n     \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>set aux'.\n       (case i of\n        (t, X) \\<Rightarrow>\n          \\<lambda>v.\n             left I \\<le> \\<tau> \\<sigma> ne - t \\<and>\n             MFOTL.sat \\<sigma> (map the v) ne\n              (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n        v", "using in_aux'_2[of \"\\<tau> \\<sigma> j\", OF _ _ exI, OF _ _ refl]"], ["proof (prove)\nusing this:\n  j \\<le> ne\n  mem (\\<tau> \\<sigma> ne - \\<tau> \\<sigma> j) I\n  MFOTL.sat \\<sigma> (map the v) ne\n   (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - \\<tau> \\<sigma> j))\n     \\<psi>)\n  \\<lbrakk>\\<tau> \\<sigma> j \\<le> \\<tau> \\<sigma> ne;\n   enat (\\<tau> \\<sigma> ne - \\<tau> \\<sigma> j) \\<le> right I\\<rbrakk>\n  \\<Longrightarrow> \\<exists>X. (\\<tau> \\<sigma> j, X) \\<in> set aux'\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>set aux'.\n       (case i of\n        (t, X) \\<Rightarrow>\n          \\<lambda>v.\n             left I \\<le> \\<tau> \\<sigma> ne - t \\<and>\n             MFOTL.sat \\<sigma> (map the v) ne\n              (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n        v", "by auto"], ["proof (state)\nthis:\n  \\<exists>i\\<in>set aux'.\n     (case i of\n      (t, X) \\<Rightarrow>\n        \\<lambda>v.\n           left I \\<le> \\<tau> \\<sigma> ne - t \\<and>\n           MFOTL.sat \\<sigma> (map the v) ne\n            (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n      v\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>set aux'.\n       (case i of\n        (t, X) \\<Rightarrow>\n          \\<lambda>v.\n             left I \\<le> \\<tau> \\<sigma> ne - t \\<and>\n             MFOTL.sat \\<sigma> (map the v) ne\n              (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n        v \\<Longrightarrow>\n    MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>set aux'.\n       (case i of\n        (t, X) \\<Rightarrow>\n          \\<lambda>v.\n             left I \\<le> \\<tau> \\<sigma> ne - t \\<and>\n             MFOTL.sat \\<sigma> (map the v) ne\n              (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n        v \\<Longrightarrow>\n    MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>)", "case right"], ["proof (state)\nthis:\n  \\<exists>i\\<in>set aux'.\n     (case i of\n      (t, X) \\<Rightarrow>\n        \\<lambda>v.\n           left I \\<le> \\<tau> \\<sigma> ne - t \\<and>\n           MFOTL.sat \\<sigma> (map the v) ne\n            (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n      v\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>set aux'.\n       (case i of\n        (t, X) \\<Rightarrow>\n          \\<lambda>v.\n             left I \\<le> \\<tau> \\<sigma> ne - t \\<and>\n             MFOTL.sat \\<sigma> (map the v) ne\n              (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n        v \\<Longrightarrow>\n    MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>i\\<in>set aux'.\n     (case i of\n      (t, X) \\<Rightarrow>\n        \\<lambda>v.\n           left I \\<le> \\<tau> \\<sigma> ne - t \\<and>\n           MFOTL.sat \\<sigma> (map the v) ne\n            (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n      v", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>i\\<in>set aux'.\n     (case i of\n      (t, X) \\<Rightarrow>\n        \\<lambda>v.\n           left I \\<le> \\<tau> \\<sigma> ne - t \\<and>\n           MFOTL.sat \\<sigma> (map the v) ne\n            (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n      v\n\ngoal (1 subgoal):\n 1. MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>)", "by (auto elim!: sat_Since_pointD dest: in_aux'_1)"], ["proof (state)\nthis:\n  MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>) =\n  (\\<exists>i\\<in>set aux'.\n      (case i of\n       (t, X) \\<Rightarrow>\n         \\<lambda>v.\n            left I \\<le> \\<tau> \\<sigma> ne - t \\<and>\n            MFOTL.sat \\<sigma> (map the v) ne\n             (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n       v)\n\ngoal (2 subgoals):\n 1. finite (set aux')\n 2. \\<And>i.\n       i \\<in> set aux' \\<Longrightarrow>\n       qtable n (fv \\<psi>) (mem_restr R)\n        (case i of\n         (t, X) \\<Rightarrow>\n           \\<lambda>v.\n              left I \\<le> \\<tau> \\<sigma> ne - t \\<and>\n              MFOTL.sat \\<sigma> (map the v) ne\n               (Sincep pos \\<phi> (point (\\<tau> \\<sigma> ne - t)) \\<psi>))\n        (case i of\n         (t, rel) \\<Rightarrow>\n           if left I \\<le> \\<tau> \\<sigma> ne - t then rel else empty_table)", "qed (auto dest!: in_aux'_1 intro!: qtable_empty)"], ["proof (state)\nthis:\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>v.\n       MFOTL.sat \\<sigma> (map the v) ne (Sincep pos \\<phi> I \\<psi>))\n   rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_update_until: \"length (update_until pos I rel1 rel2 nt aux) = Suc (length aux)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (update_until pos I rel1 rel2 nt aux) = Suc (length aux)", "unfolding update_until_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (map (\\<lambda>(t, a1, a2).\n              (t, if I then join a1 True rel1 else a1 \\<union> rel1,\n               if mem (nt - t) pos then a2 \\<union> join rel2 I a1 else a2))\n       aux @\n      [(nt, rel1, if left pos = 0 then rel2 else empty_table)]) =\n    Suc (length aux)", "by simp"], ["", "lemma wf_update_until:\n  assumes pre: \"wf_until_aux \\<sigma> n R pos \\<phi> I \\<psi> aux ne\"\n    and qtable1: \"qtable n (MFOTL.fv \\<phi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) (ne + length aux) \\<phi>) rel1\"\n    and qtable2: \"qtable n (MFOTL.fv \\<psi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) (ne + length aux) \\<psi>) rel2\"\n    and fvi_subset: \"MFOTL.fv \\<phi> \\<subseteq> MFOTL.fv \\<psi>\"\n  shows \"wf_until_aux \\<sigma> n R pos \\<phi> I \\<psi> (update_until I pos rel1 rel2 (\\<tau> \\<sigma> (ne + length aux)) aux) ne\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_until_aux \\<sigma> n R pos \\<phi> I \\<psi>\n     (update_until I pos rel1 rel2 (\\<tau> \\<sigma> (ne + length aux)) aux)\n     ne", "unfolding wf_until_aux_def length_update_until"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>x i.\n         case x of\n         (t, r1, r2) \\<Rightarrow>\n           t = \\<tau> \\<sigma> i \\<and>\n           qtable n (fv \\<phi>) (mem_restr R)\n            (\\<lambda>v.\n                if pos\n                then \\<forall>k\\<in>{i..<ne + Suc (length aux)}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                else \\<exists>k\\<in>{i..<ne + Suc (length aux)}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>)\n            r1 \\<and>\n           qtable n (fv \\<psi>) (mem_restr R)\n            (\\<lambda>v.\n                \\<exists>j\\<ge>i.\n                   j < ne + Suc (length aux) \\<and>\n                   mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and>\n                   MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n                   (\\<forall>k\\<in>{i..<j}.\n                       if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                       else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))\n            r2)\n     (update_until I pos rel1 rel2 (\\<tau> \\<sigma> (ne + length aux)) aux)\n     [ne..<ne + Suc (length aux)]", "unfolding update_until_def list.rel_map add_Suc_right upt.simps eqTrueI[OF le_add1] if_True"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>x i.\n         case x of\n         (t, r1, r2) \\<Rightarrow>\n           t = \\<tau> \\<sigma> i \\<and>\n           qtable n (fv \\<phi>) (mem_restr R)\n            (\\<lambda>v.\n                if pos\n                then \\<forall>k\\<in>{i..<Suc (ne + length aux)}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                else \\<exists>k\\<in>{i..<Suc (ne + length aux)}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>)\n            r1 \\<and>\n           qtable n (fv \\<psi>) (mem_restr R)\n            (\\<lambda>v.\n                \\<exists>j\\<ge>i.\n                   j < Suc (ne + length aux) \\<and>\n                   mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and>\n                   MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n                   (\\<forall>k\\<in>{i..<j}.\n                       if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                       else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))\n            r2)\n     (map (\\<lambda>(t, a1, a2).\n              (t, if pos then join a1 True rel1 else a1 \\<union> rel1,\n               if mem (\\<tau> \\<sigma> (ne + length aux) - t) I\n               then a2 \\<union> join rel2 pos a1 else a2))\n       aux @\n      [(\\<tau> \\<sigma> (ne + length aux), rel1,\n        if left I = 0 then rel2 else empty_table)])\n     ([ne..<ne + length aux] @ [ne + length aux])", "proof (rule list_all2_appendI, unfold list.rel_map, goal_cases old new)"], ["proof (state)\ngoal (2 subgoals):\n 1. list_all2\n     (\\<lambda>x i.\n         case case x of\n              (t, a1, a2) \\<Rightarrow>\n                (t, if pos then join a1 True rel1 else a1 \\<union> rel1,\n                 if mem (\\<tau> \\<sigma> (ne + length aux) - t) I\n                 then a2 \\<union> join rel2 pos a1 else a2) of\n         (t, r1, r2) \\<Rightarrow>\n           t = \\<tau> \\<sigma> i \\<and>\n           qtable n (fv \\<phi>) (mem_restr R)\n            (\\<lambda>v.\n                if pos\n                then \\<forall>k\\<in>{i..<Suc (ne + length aux)}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                else \\<exists>k\\<in>{i..<Suc (ne + length aux)}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>)\n            r1 \\<and>\n           qtable n (fv \\<psi>) (mem_restr R)\n            (\\<lambda>v.\n                \\<exists>j\\<ge>i.\n                   j < Suc (ne + length aux) \\<and>\n                   mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and>\n                   MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n                   (\\<forall>k\\<in>{i..<j}.\n                       if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                       else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))\n            r2)\n     aux [ne..<ne + length aux]\n 2. list_all2\n     (\\<lambda>x i.\n         case x of\n         (t, r1, r2) \\<Rightarrow>\n           t = \\<tau> \\<sigma> i \\<and>\n           qtable n (fv \\<phi>) (mem_restr R)\n            (\\<lambda>v.\n                if pos\n                then \\<forall>k\\<in>{i..<Suc (ne + length aux)}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                else \\<exists>k\\<in>{i..<Suc (ne + length aux)}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>)\n            r1 \\<and>\n           qtable n (fv \\<psi>) (mem_restr R)\n            (\\<lambda>v.\n                \\<exists>j\\<ge>i.\n                   j < Suc (ne + length aux) \\<and>\n                   mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and>\n                   MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n                   (\\<forall>k\\<in>{i..<j}.\n                       if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                       else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))\n            r2)\n     [(\\<tau> \\<sigma> (ne + length aux), rel1,\n       if left I = 0 then rel2 else empty_table)]\n     [ne + length aux]", "case old"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. list_all2\n     (\\<lambda>x i.\n         case case x of\n              (t, a1, a2) \\<Rightarrow>\n                (t, if pos then join a1 True rel1 else a1 \\<union> rel1,\n                 if mem (\\<tau> \\<sigma> (ne + length aux) - t) I\n                 then a2 \\<union> join rel2 pos a1 else a2) of\n         (t, r1, r2) \\<Rightarrow>\n           t = \\<tau> \\<sigma> i \\<and>\n           qtable n (fv \\<phi>) (mem_restr R)\n            (\\<lambda>v.\n                if pos\n                then \\<forall>k\\<in>{i..<Suc (ne + length aux)}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                else \\<exists>k\\<in>{i..<Suc (ne + length aux)}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>)\n            r1 \\<and>\n           qtable n (fv \\<psi>) (mem_restr R)\n            (\\<lambda>v.\n                \\<exists>j\\<ge>i.\n                   j < Suc (ne + length aux) \\<and>\n                   mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and>\n                   MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n                   (\\<forall>k\\<in>{i..<j}.\n                       if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                       else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))\n            r2)\n     aux [ne..<ne + length aux]\n 2. list_all2\n     (\\<lambda>x i.\n         case x of\n         (t, r1, r2) \\<Rightarrow>\n           t = \\<tau> \\<sigma> i \\<and>\n           qtable n (fv \\<phi>) (mem_restr R)\n            (\\<lambda>v.\n                if pos\n                then \\<forall>k\\<in>{i..<Suc (ne + length aux)}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                else \\<exists>k\\<in>{i..<Suc (ne + length aux)}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>)\n            r1 \\<and>\n           qtable n (fv \\<psi>) (mem_restr R)\n            (\\<lambda>v.\n                \\<exists>j\\<ge>i.\n                   j < Suc (ne + length aux) \\<and>\n                   mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and>\n                   MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n                   (\\<forall>k\\<in>{i..<j}.\n                       if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                       else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))\n            r2)\n     [(\\<tau> \\<sigma> (ne + length aux), rel1,\n       if left I = 0 then rel2 else empty_table)]\n     [ne + length aux]", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>x i.\n         case case x of\n              (t, a1, a2) \\<Rightarrow>\n                (t, if pos then join a1 True rel1 else a1 \\<union> rel1,\n                 if mem (\\<tau> \\<sigma> (ne + length aux) - t) I\n                 then a2 \\<union> join rel2 pos a1 else a2) of\n         (t, r1, r2) \\<Rightarrow>\n           t = \\<tau> \\<sigma> i \\<and>\n           qtable n (fv \\<phi>) (mem_restr R)\n            (\\<lambda>v.\n                if pos\n                then \\<forall>k\\<in>{i..<Suc (ne + length aux)}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                else \\<exists>k\\<in>{i..<Suc (ne + length aux)}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>)\n            r1 \\<and>\n           qtable n (fv \\<psi>) (mem_restr R)\n            (\\<lambda>v.\n                \\<exists>j\\<ge>i.\n                   j < Suc (ne + length aux) \\<and>\n                   mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and>\n                   MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n                   (\\<forall>k\\<in>{i..<j}.\n                       if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                       else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))\n            r2)\n     aux [ne..<ne + length aux]", "proof (rule list.rel_mono_strong[OF assms(1)[unfolded wf_until_aux_def]]; safe, goal_cases mono1 mono2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a aa b yb.\n       \\<lbrakk>(\\<tau> \\<sigma> yb, aa, b) \\<in> set aux;\n        yb \\<in> set [ne..<ne + length aux];\n        qtable n (fv \\<phi>) (mem_restr R)\n         (\\<lambda>v.\n             if pos\n             then \\<forall>k\\<in>{yb..<ne + length aux}.\n                     MFOTL.sat \\<sigma> (map the v) k \\<phi>\n             else \\<exists>k\\<in>{yb..<ne + length aux}.\n                     MFOTL.sat \\<sigma> (map the v) k \\<phi>)\n         aa;\n        qtable n (fv \\<psi>) (mem_restr R)\n         (\\<lambda>v.\n             \\<exists>j\\<ge>yb.\n                j < ne + length aux \\<and>\n                mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> yb) I \\<and>\n                MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n                (\\<forall>k\\<in>{yb..<j}.\n                    if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                    else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))\n         b\\<rbrakk>\n       \\<Longrightarrow> qtable n (fv \\<phi>) (mem_restr R)\n                          (\\<lambda>v.\n                              if pos\n                              then \\<forall>k\n      \\<in>{yb..<Suc (ne + length aux)}.\nMFOTL.sat \\<sigma> (map the v) k \\<phi>\n                              else \\<exists>k\n      \\<in>{yb..<Suc (ne + length aux)}.\nMFOTL.sat \\<sigma> (map the v) k \\<phi>)\n                          (if pos then join aa True rel1\n                           else aa \\<union> rel1)\n 2. \\<And>a aa b yb.\n       \\<lbrakk>(\\<tau> \\<sigma> yb, aa, b) \\<in> set aux;\n        yb \\<in> set [ne..<ne + length aux];\n        qtable n (fv \\<phi>) (mem_restr R)\n         (\\<lambda>v.\n             if pos\n             then \\<forall>k\\<in>{yb..<ne + length aux}.\n                     MFOTL.sat \\<sigma> (map the v) k \\<phi>\n             else \\<exists>k\\<in>{yb..<ne + length aux}.\n                     MFOTL.sat \\<sigma> (map the v) k \\<phi>)\n         aa;\n        qtable n (fv \\<psi>) (mem_restr R)\n         (\\<lambda>v.\n             \\<exists>j\\<ge>yb.\n                j < ne + length aux \\<and>\n                mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> yb) I \\<and>\n                MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n                (\\<forall>k\\<in>{yb..<j}.\n                    if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                    else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))\n         b\\<rbrakk>\n       \\<Longrightarrow> qtable n (fv \\<psi>) (mem_restr R)\n                          (\\<lambda>v.\n                              \\<exists>j\\<ge>yb.\n                                 j < Suc (ne + length aux) \\<and>\n                                 mem (\\<tau> \\<sigma> j -\n\\<tau> \\<sigma> yb)\n                                  I \\<and>\n                                 MFOTL.sat \\<sigma> (map the v) j\n                                  \\<psi> \\<and>\n                                 (\\<forall>k\\<in>{yb..<j}.\n                                     if pos\n                                     then MFOTL.sat \\<sigma> (map the v) k\n     \\<phi>\n                                     else \\<not> MFOTL.sat \\<sigma>\n            (map the v) k \\<phi>))\n                          (if mem (\\<tau> \\<sigma> (ne + length aux) -\n                                   \\<tau> \\<sigma> yb)\n                               I\n                           then b \\<union> join rel2 pos aa else b)", "case (mono1 i X Y v)"], ["proof (state)\nthis:\n  (\\<tau> \\<sigma> v, X, Y) \\<in> set aux\n  v \\<in> set [ne..<ne + length aux]\n  qtable n (fv \\<phi>) (mem_restr R)\n   (\\<lambda>va.\n       if pos\n       then \\<forall>k\\<in>{v..<ne + length aux}.\n               MFOTL.sat \\<sigma> (map the va) k \\<phi>\n       else \\<exists>k\\<in>{v..<ne + length aux}.\n               MFOTL.sat \\<sigma> (map the va) k \\<phi>)\n   X\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>va.\n       \\<exists>j\\<ge>v.\n          j < ne + length aux \\<and>\n          mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> v) I \\<and>\n          MFOTL.sat \\<sigma> (map the va) j \\<psi> \\<and>\n          (\\<forall>k\\<in>{v..<j}.\n              if pos then MFOTL.sat \\<sigma> (map the va) k \\<phi>\n              else \\<not> MFOTL.sat \\<sigma> (map the va) k \\<phi>))\n   Y\n\ngoal (2 subgoals):\n 1. \\<And>a aa b yb.\n       \\<lbrakk>(\\<tau> \\<sigma> yb, aa, b) \\<in> set aux;\n        yb \\<in> set [ne..<ne + length aux];\n        qtable n (fv \\<phi>) (mem_restr R)\n         (\\<lambda>v.\n             if pos\n             then \\<forall>k\\<in>{yb..<ne + length aux}.\n                     MFOTL.sat \\<sigma> (map the v) k \\<phi>\n             else \\<exists>k\\<in>{yb..<ne + length aux}.\n                     MFOTL.sat \\<sigma> (map the v) k \\<phi>)\n         aa;\n        qtable n (fv \\<psi>) (mem_restr R)\n         (\\<lambda>v.\n             \\<exists>j\\<ge>yb.\n                j < ne + length aux \\<and>\n                mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> yb) I \\<and>\n                MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n                (\\<forall>k\\<in>{yb..<j}.\n                    if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                    else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))\n         b\\<rbrakk>\n       \\<Longrightarrow> qtable n (fv \\<phi>) (mem_restr R)\n                          (\\<lambda>v.\n                              if pos\n                              then \\<forall>k\n      \\<in>{yb..<Suc (ne + length aux)}.\nMFOTL.sat \\<sigma> (map the v) k \\<phi>\n                              else \\<exists>k\n      \\<in>{yb..<Suc (ne + length aux)}.\nMFOTL.sat \\<sigma> (map the v) k \\<phi>)\n                          (if pos then join aa True rel1\n                           else aa \\<union> rel1)\n 2. \\<And>a aa b yb.\n       \\<lbrakk>(\\<tau> \\<sigma> yb, aa, b) \\<in> set aux;\n        yb \\<in> set [ne..<ne + length aux];\n        qtable n (fv \\<phi>) (mem_restr R)\n         (\\<lambda>v.\n             if pos\n             then \\<forall>k\\<in>{yb..<ne + length aux}.\n                     MFOTL.sat \\<sigma> (map the v) k \\<phi>\n             else \\<exists>k\\<in>{yb..<ne + length aux}.\n                     MFOTL.sat \\<sigma> (map the v) k \\<phi>)\n         aa;\n        qtable n (fv \\<psi>) (mem_restr R)\n         (\\<lambda>v.\n             \\<exists>j\\<ge>yb.\n                j < ne + length aux \\<and>\n                mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> yb) I \\<and>\n                MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n                (\\<forall>k\\<in>{yb..<j}.\n                    if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                    else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))\n         b\\<rbrakk>\n       \\<Longrightarrow> qtable n (fv \\<psi>) (mem_restr R)\n                          (\\<lambda>v.\n                              \\<exists>j\\<ge>yb.\n                                 j < Suc (ne + length aux) \\<and>\n                                 mem (\\<tau> \\<sigma> j -\n\\<tau> \\<sigma> yb)\n                                  I \\<and>\n                                 MFOTL.sat \\<sigma> (map the v) j\n                                  \\<psi> \\<and>\n                                 (\\<forall>k\\<in>{yb..<j}.\n                                     if pos\n                                     then MFOTL.sat \\<sigma> (map the v) k\n     \\<phi>\n                                     else \\<not> MFOTL.sat \\<sigma>\n            (map the v) k \\<phi>))\n                          (if mem (\\<tau> \\<sigma> (ne + length aux) -\n                                   \\<tau> \\<sigma> yb)\n                               I\n                           then b \\<union> join rel2 pos aa else b)", "then"], ["proof (chain)\npicking this:\n  (\\<tau> \\<sigma> v, X, Y) \\<in> set aux\n  v \\<in> set [ne..<ne + length aux]\n  qtable n (fv \\<phi>) (mem_restr R)\n   (\\<lambda>va.\n       if pos\n       then \\<forall>k\\<in>{v..<ne + length aux}.\n               MFOTL.sat \\<sigma> (map the va) k \\<phi>\n       else \\<exists>k\\<in>{v..<ne + length aux}.\n               MFOTL.sat \\<sigma> (map the va) k \\<phi>)\n   X\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>va.\n       \\<exists>j\\<ge>v.\n          j < ne + length aux \\<and>\n          mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> v) I \\<and>\n          MFOTL.sat \\<sigma> (map the va) j \\<psi> \\<and>\n          (\\<forall>k\\<in>{v..<j}.\n              if pos then MFOTL.sat \\<sigma> (map the va) k \\<phi>\n              else \\<not> MFOTL.sat \\<sigma> (map the va) k \\<phi>))\n   Y", "show ?case"], ["proof (prove)\nusing this:\n  (\\<tau> \\<sigma> v, X, Y) \\<in> set aux\n  v \\<in> set [ne..<ne + length aux]\n  qtable n (fv \\<phi>) (mem_restr R)\n   (\\<lambda>va.\n       if pos\n       then \\<forall>k\\<in>{v..<ne + length aux}.\n               MFOTL.sat \\<sigma> (map the va) k \\<phi>\n       else \\<exists>k\\<in>{v..<ne + length aux}.\n               MFOTL.sat \\<sigma> (map the va) k \\<phi>)\n   X\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>va.\n       \\<exists>j\\<ge>v.\n          j < ne + length aux \\<and>\n          mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> v) I \\<and>\n          MFOTL.sat \\<sigma> (map the va) j \\<psi> \\<and>\n          (\\<forall>k\\<in>{v..<j}.\n              if pos then MFOTL.sat \\<sigma> (map the va) k \\<phi>\n              else \\<not> MFOTL.sat \\<sigma> (map the va) k \\<phi>))\n   Y\n\ngoal (1 subgoal):\n 1. qtable n (fv \\<phi>) (mem_restr R)\n     (\\<lambda>va.\n         if pos\n         then \\<forall>k\\<in>{v..<Suc (ne + length aux)}.\n                 MFOTL.sat \\<sigma> (map the va) k \\<phi>\n         else \\<exists>k\\<in>{v..<Suc (ne + length aux)}.\n                 MFOTL.sat \\<sigma> (map the va) k \\<phi>)\n     (if pos then join X True rel1 else X \\<union> rel1)", "by (fastforce simp: sat_the_restrict less_Suc_eq\n        elim!: qtable_join[OF _ qtable1] qtable_union[OF _ qtable1])"], ["proof (state)\nthis:\n  qtable n (fv \\<phi>) (mem_restr R)\n   (\\<lambda>va.\n       if pos\n       then \\<forall>k\\<in>{v..<Suc (ne + length aux)}.\n               MFOTL.sat \\<sigma> (map the va) k \\<phi>\n       else \\<exists>k\\<in>{v..<Suc (ne + length aux)}.\n               MFOTL.sat \\<sigma> (map the va) k \\<phi>)\n   (if pos then join X True rel1 else X \\<union> rel1)\n\ngoal (1 subgoal):\n 1. \\<And>a aa b yb.\n       \\<lbrakk>(\\<tau> \\<sigma> yb, aa, b) \\<in> set aux;\n        yb \\<in> set [ne..<ne + length aux];\n        qtable n (fv \\<phi>) (mem_restr R)\n         (\\<lambda>v.\n             if pos\n             then \\<forall>k\\<in>{yb..<ne + length aux}.\n                     MFOTL.sat \\<sigma> (map the v) k \\<phi>\n             else \\<exists>k\\<in>{yb..<ne + length aux}.\n                     MFOTL.sat \\<sigma> (map the v) k \\<phi>)\n         aa;\n        qtable n (fv \\<psi>) (mem_restr R)\n         (\\<lambda>v.\n             \\<exists>j\\<ge>yb.\n                j < ne + length aux \\<and>\n                mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> yb) I \\<and>\n                MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n                (\\<forall>k\\<in>{yb..<j}.\n                    if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                    else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))\n         b\\<rbrakk>\n       \\<Longrightarrow> qtable n (fv \\<psi>) (mem_restr R)\n                          (\\<lambda>v.\n                              \\<exists>j\\<ge>yb.\n                                 j < Suc (ne + length aux) \\<and>\n                                 mem (\\<tau> \\<sigma> j -\n\\<tau> \\<sigma> yb)\n                                  I \\<and>\n                                 MFOTL.sat \\<sigma> (map the v) j\n                                  \\<psi> \\<and>\n                                 (\\<forall>k\\<in>{yb..<j}.\n                                     if pos\n                                     then MFOTL.sat \\<sigma> (map the v) k\n     \\<phi>\n                                     else \\<not> MFOTL.sat \\<sigma>\n            (map the v) k \\<phi>))\n                          (if mem (\\<tau> \\<sigma> (ne + length aux) -\n                                   \\<tau> \\<sigma> yb)\n                               I\n                           then b \\<union> join rel2 pos aa else b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b yb.\n       \\<lbrakk>(\\<tau> \\<sigma> yb, aa, b) \\<in> set aux;\n        yb \\<in> set [ne..<ne + length aux];\n        qtable n (fv \\<phi>) (mem_restr R)\n         (\\<lambda>v.\n             if pos\n             then \\<forall>k\\<in>{yb..<ne + length aux}.\n                     MFOTL.sat \\<sigma> (map the v) k \\<phi>\n             else \\<exists>k\\<in>{yb..<ne + length aux}.\n                     MFOTL.sat \\<sigma> (map the v) k \\<phi>)\n         aa;\n        qtable n (fv \\<psi>) (mem_restr R)\n         (\\<lambda>v.\n             \\<exists>j\\<ge>yb.\n                j < ne + length aux \\<and>\n                mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> yb) I \\<and>\n                MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n                (\\<forall>k\\<in>{yb..<j}.\n                    if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                    else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))\n         b\\<rbrakk>\n       \\<Longrightarrow> qtable n (fv \\<psi>) (mem_restr R)\n                          (\\<lambda>v.\n                              \\<exists>j\\<ge>yb.\n                                 j < Suc (ne + length aux) \\<and>\n                                 mem (\\<tau> \\<sigma> j -\n\\<tau> \\<sigma> yb)\n                                  I \\<and>\n                                 MFOTL.sat \\<sigma> (map the v) j\n                                  \\<psi> \\<and>\n                                 (\\<forall>k\\<in>{yb..<j}.\n                                     if pos\n                                     then MFOTL.sat \\<sigma> (map the v) k\n     \\<phi>\n                                     else \\<not> MFOTL.sat \\<sigma>\n            (map the v) k \\<phi>))\n                          (if mem (\\<tau> \\<sigma> (ne + length aux) -\n                                   \\<tau> \\<sigma> yb)\n                               I\n                           then b \\<union> join rel2 pos aa else b)", "case (mono2 i X Y v)"], ["proof (state)\nthis:\n  (\\<tau> \\<sigma> v, X, Y) \\<in> set aux\n  v \\<in> set [ne..<ne + length aux]\n  qtable n (fv \\<phi>) (mem_restr R)\n   (\\<lambda>va.\n       if pos\n       then \\<forall>k\\<in>{v..<ne + length aux}.\n               MFOTL.sat \\<sigma> (map the va) k \\<phi>\n       else \\<exists>k\\<in>{v..<ne + length aux}.\n               MFOTL.sat \\<sigma> (map the va) k \\<phi>)\n   X\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>va.\n       \\<exists>j\\<ge>v.\n          j < ne + length aux \\<and>\n          mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> v) I \\<and>\n          MFOTL.sat \\<sigma> (map the va) j \\<psi> \\<and>\n          (\\<forall>k\\<in>{v..<j}.\n              if pos then MFOTL.sat \\<sigma> (map the va) k \\<phi>\n              else \\<not> MFOTL.sat \\<sigma> (map the va) k \\<phi>))\n   Y\n\ngoal (1 subgoal):\n 1. \\<And>a aa b yb.\n       \\<lbrakk>(\\<tau> \\<sigma> yb, aa, b) \\<in> set aux;\n        yb \\<in> set [ne..<ne + length aux];\n        qtable n (fv \\<phi>) (mem_restr R)\n         (\\<lambda>v.\n             if pos\n             then \\<forall>k\\<in>{yb..<ne + length aux}.\n                     MFOTL.sat \\<sigma> (map the v) k \\<phi>\n             else \\<exists>k\\<in>{yb..<ne + length aux}.\n                     MFOTL.sat \\<sigma> (map the v) k \\<phi>)\n         aa;\n        qtable n (fv \\<psi>) (mem_restr R)\n         (\\<lambda>v.\n             \\<exists>j\\<ge>yb.\n                j < ne + length aux \\<and>\n                mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> yb) I \\<and>\n                MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n                (\\<forall>k\\<in>{yb..<j}.\n                    if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                    else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))\n         b\\<rbrakk>\n       \\<Longrightarrow> qtable n (fv \\<psi>) (mem_restr R)\n                          (\\<lambda>v.\n                              \\<exists>j\\<ge>yb.\n                                 j < Suc (ne + length aux) \\<and>\n                                 mem (\\<tau> \\<sigma> j -\n\\<tau> \\<sigma> yb)\n                                  I \\<and>\n                                 MFOTL.sat \\<sigma> (map the v) j\n                                  \\<psi> \\<and>\n                                 (\\<forall>k\\<in>{yb..<j}.\n                                     if pos\n                                     then MFOTL.sat \\<sigma> (map the v) k\n     \\<phi>\n                                     else \\<not> MFOTL.sat \\<sigma>\n            (map the v) k \\<phi>))\n                          (if mem (\\<tau> \\<sigma> (ne + length aux) -\n                                   \\<tau> \\<sigma> yb)\n                               I\n                           then b \\<union> join rel2 pos aa else b)", "then"], ["proof (chain)\npicking this:\n  (\\<tau> \\<sigma> v, X, Y) \\<in> set aux\n  v \\<in> set [ne..<ne + length aux]\n  qtable n (fv \\<phi>) (mem_restr R)\n   (\\<lambda>va.\n       if pos\n       then \\<forall>k\\<in>{v..<ne + length aux}.\n               MFOTL.sat \\<sigma> (map the va) k \\<phi>\n       else \\<exists>k\\<in>{v..<ne + length aux}.\n               MFOTL.sat \\<sigma> (map the va) k \\<phi>)\n   X\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>va.\n       \\<exists>j\\<ge>v.\n          j < ne + length aux \\<and>\n          mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> v) I \\<and>\n          MFOTL.sat \\<sigma> (map the va) j \\<psi> \\<and>\n          (\\<forall>k\\<in>{v..<j}.\n              if pos then MFOTL.sat \\<sigma> (map the va) k \\<phi>\n              else \\<not> MFOTL.sat \\<sigma> (map the va) k \\<phi>))\n   Y", "show ?case"], ["proof (prove)\nusing this:\n  (\\<tau> \\<sigma> v, X, Y) \\<in> set aux\n  v \\<in> set [ne..<ne + length aux]\n  qtable n (fv \\<phi>) (mem_restr R)\n   (\\<lambda>va.\n       if pos\n       then \\<forall>k\\<in>{v..<ne + length aux}.\n               MFOTL.sat \\<sigma> (map the va) k \\<phi>\n       else \\<exists>k\\<in>{v..<ne + length aux}.\n               MFOTL.sat \\<sigma> (map the va) k \\<phi>)\n   X\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>va.\n       \\<exists>j\\<ge>v.\n          j < ne + length aux \\<and>\n          mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> v) I \\<and>\n          MFOTL.sat \\<sigma> (map the va) j \\<psi> \\<and>\n          (\\<forall>k\\<in>{v..<j}.\n              if pos then MFOTL.sat \\<sigma> (map the va) k \\<phi>\n              else \\<not> MFOTL.sat \\<sigma> (map the va) k \\<phi>))\n   Y\n\ngoal (1 subgoal):\n 1. qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>va.\n         \\<exists>j\\<ge>v.\n            j < Suc (ne + length aux) \\<and>\n            mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> v) I \\<and>\n            MFOTL.sat \\<sigma> (map the va) j \\<psi> \\<and>\n            (\\<forall>k\\<in>{v..<j}.\n                if pos then MFOTL.sat \\<sigma> (map the va) k \\<phi>\n                else \\<not> MFOTL.sat \\<sigma> (map the va) k \\<phi>))\n     (if mem (\\<tau> \\<sigma> (ne + length aux) - \\<tau> \\<sigma> v) I\n      then Y \\<union> join rel2 pos X else Y)", "using fvi_subset"], ["proof (prove)\nusing this:\n  (\\<tau> \\<sigma> v, X, Y) \\<in> set aux\n  v \\<in> set [ne..<ne + length aux]\n  qtable n (fv \\<phi>) (mem_restr R)\n   (\\<lambda>va.\n       if pos\n       then \\<forall>k\\<in>{v..<ne + length aux}.\n               MFOTL.sat \\<sigma> (map the va) k \\<phi>\n       else \\<exists>k\\<in>{v..<ne + length aux}.\n               MFOTL.sat \\<sigma> (map the va) k \\<phi>)\n   X\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>va.\n       \\<exists>j\\<ge>v.\n          j < ne + length aux \\<and>\n          mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> v) I \\<and>\n          MFOTL.sat \\<sigma> (map the va) j \\<psi> \\<and>\n          (\\<forall>k\\<in>{v..<j}.\n              if pos then MFOTL.sat \\<sigma> (map the va) k \\<phi>\n              else \\<not> MFOTL.sat \\<sigma> (map the va) k \\<phi>))\n   Y\n  fv \\<phi> \\<subseteq> fv \\<psi>\n\ngoal (1 subgoal):\n 1. qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>va.\n         \\<exists>j\\<ge>v.\n            j < Suc (ne + length aux) \\<and>\n            mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> v) I \\<and>\n            MFOTL.sat \\<sigma> (map the va) j \\<psi> \\<and>\n            (\\<forall>k\\<in>{v..<j}.\n                if pos then MFOTL.sat \\<sigma> (map the va) k \\<phi>\n                else \\<not> MFOTL.sat \\<sigma> (map the va) k \\<phi>))\n     (if mem (\\<tau> \\<sigma> (ne + length aux) - \\<tau> \\<sigma> v) I\n      then Y \\<union> join rel2 pos X else Y)", "by (auto 0 3 simp: sat_the_restrict less_Suc_eq split: if_splits\n        elim!: qtable_union[OF _ qtable_join_fixed[OF qtable2]]\n        elim: qtable_cong[OF _ refl] intro: exI[of _ \"ne + length aux\"])"], ["proof (state)\nthis:\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>va.\n       \\<exists>j\\<ge>v.\n          j < Suc (ne + length aux) \\<and>\n          mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> v) I \\<and>\n          MFOTL.sat \\<sigma> (map the va) j \\<psi> \\<and>\n          (\\<forall>k\\<in>{v..<j}.\n              if pos then MFOTL.sat \\<sigma> (map the va) k \\<phi>\n              else \\<not> MFOTL.sat \\<sigma> (map the va) k \\<phi>))\n   (if mem (\\<tau> \\<sigma> (ne + length aux) - \\<tau> \\<sigma> v) I\n    then Y \\<union> join rel2 pos X else Y)\n\ngoal:\nNo subgoals!", "(* slow 8 sec*)"], ["proof (state)\nthis:\n  qtable n (fv \\<psi>) (mem_restr R)\n   (\\<lambda>va.\n       \\<exists>j\\<ge>v.\n          j < Suc (ne + length aux) \\<and>\n          mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> v) I \\<and>\n          MFOTL.sat \\<sigma> (map the va) j \\<psi> \\<and>\n          (\\<forall>k\\<in>{v..<j}.\n              if pos then MFOTL.sat \\<sigma> (map the va) k \\<phi>\n              else \\<not> MFOTL.sat \\<sigma> (map the va) k \\<phi>))\n   (if mem (\\<tau> \\<sigma> (ne + length aux) - \\<tau> \\<sigma> v) I\n    then Y \\<union> join rel2 pos X else Y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_all2\n   (\\<lambda>x i.\n       case case x of\n            (t, a1, a2) \\<Rightarrow>\n              (t, if pos then join a1 True rel1 else a1 \\<union> rel1,\n               if mem (\\<tau> \\<sigma> (ne + length aux) - t) I\n               then a2 \\<union> join rel2 pos a1 else a2) of\n       (t, r1, r2) \\<Rightarrow>\n         t = \\<tau> \\<sigma> i \\<and>\n         qtable n (fv \\<phi>) (mem_restr R)\n          (\\<lambda>v.\n              if pos\n              then \\<forall>k\\<in>{i..<Suc (ne + length aux)}.\n                      MFOTL.sat \\<sigma> (map the v) k \\<phi>\n              else \\<exists>k\\<in>{i..<Suc (ne + length aux)}.\n                      MFOTL.sat \\<sigma> (map the v) k \\<phi>)\n          r1 \\<and>\n         qtable n (fv \\<psi>) (mem_restr R)\n          (\\<lambda>v.\n              \\<exists>j\\<ge>i.\n                 j < Suc (ne + length aux) \\<and>\n                 mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and>\n                 MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n                 (\\<forall>k\\<in>{i..<j}.\n                     if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                     else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))\n          r2)\n   aux [ne..<ne + length aux]\n\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>x i.\n         case x of\n         (t, r1, r2) \\<Rightarrow>\n           t = \\<tau> \\<sigma> i \\<and>\n           qtable n (fv \\<phi>) (mem_restr R)\n            (\\<lambda>v.\n                if pos\n                then \\<forall>k\\<in>{i..<Suc (ne + length aux)}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                else \\<exists>k\\<in>{i..<Suc (ne + length aux)}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>)\n            r1 \\<and>\n           qtable n (fv \\<psi>) (mem_restr R)\n            (\\<lambda>v.\n                \\<exists>j\\<ge>i.\n                   j < Suc (ne + length aux) \\<and>\n                   mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and>\n                   MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n                   (\\<forall>k\\<in>{i..<j}.\n                       if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                       else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))\n            r2)\n     [(\\<tau> \\<sigma> (ne + length aux), rel1,\n       if left I = 0 then rel2 else empty_table)]\n     [ne + length aux]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>x i.\n         case x of\n         (t, r1, r2) \\<Rightarrow>\n           t = \\<tau> \\<sigma> i \\<and>\n           qtable n (fv \\<phi>) (mem_restr R)\n            (\\<lambda>v.\n                if pos\n                then \\<forall>k\\<in>{i..<Suc (ne + length aux)}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                else \\<exists>k\\<in>{i..<Suc (ne + length aux)}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>)\n            r1 \\<and>\n           qtable n (fv \\<psi>) (mem_restr R)\n            (\\<lambda>v.\n                \\<exists>j\\<ge>i.\n                   j < Suc (ne + length aux) \\<and>\n                   mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and>\n                   MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n                   (\\<forall>k\\<in>{i..<j}.\n                       if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                       else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))\n            r2)\n     [(\\<tau> \\<sigma> (ne + length aux), rel1,\n       if left I = 0 then rel2 else empty_table)]\n     [ne + length aux]", "case new"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>x i.\n         case x of\n         (t, r1, r2) \\<Rightarrow>\n           t = \\<tau> \\<sigma> i \\<and>\n           qtable n (fv \\<phi>) (mem_restr R)\n            (\\<lambda>v.\n                if pos\n                then \\<forall>k\\<in>{i..<Suc (ne + length aux)}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                else \\<exists>k\\<in>{i..<Suc (ne + length aux)}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>)\n            r1 \\<and>\n           qtable n (fv \\<psi>) (mem_restr R)\n            (\\<lambda>v.\n                \\<exists>j\\<ge>i.\n                   j < Suc (ne + length aux) \\<and>\n                   mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and>\n                   MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n                   (\\<forall>k\\<in>{i..<j}.\n                       if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                       else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))\n            r2)\n     [(\\<tau> \\<sigma> (ne + length aux), rel1,\n       if left I = 0 then rel2 else empty_table)]\n     [ne + length aux]", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>x i.\n         case x of\n         (t, r1, r2) \\<Rightarrow>\n           t = \\<tau> \\<sigma> i \\<and>\n           qtable n (fv \\<phi>) (mem_restr R)\n            (\\<lambda>v.\n                if pos\n                then \\<forall>k\\<in>{i..<Suc (ne + length aux)}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                else \\<exists>k\\<in>{i..<Suc (ne + length aux)}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>)\n            r1 \\<and>\n           qtable n (fv \\<psi>) (mem_restr R)\n            (\\<lambda>v.\n                \\<exists>j\\<ge>i.\n                   j < Suc (ne + length aux) \\<and>\n                   mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and>\n                   MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n                   (\\<forall>k\\<in>{i..<j}.\n                       if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                       else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))\n            r2)\n     [(\\<tau> \\<sigma> (ne + length aux), rel1,\n       if left I = 0 then rel2 else empty_table)]\n     [ne + length aux]", "by (auto intro!: qtable_empty qtable1 qtable2[THEN qtable_cong] exI[of _ \"ne + length aux\"]\n      simp: less_Suc_eq zero_enat_def[symmetric])"], ["proof (state)\nthis:\n  list_all2\n   (\\<lambda>x i.\n       case x of\n       (t, r1, r2) \\<Rightarrow>\n         t = \\<tau> \\<sigma> i \\<and>\n         qtable n (fv \\<phi>) (mem_restr R)\n          (\\<lambda>v.\n              if pos\n              then \\<forall>k\\<in>{i..<Suc (ne + length aux)}.\n                      MFOTL.sat \\<sigma> (map the v) k \\<phi>\n              else \\<exists>k\\<in>{i..<Suc (ne + length aux)}.\n                      MFOTL.sat \\<sigma> (map the v) k \\<phi>)\n          r1 \\<and>\n         qtable n (fv \\<psi>) (mem_restr R)\n          (\\<lambda>v.\n              \\<exists>j\\<ge>i.\n                 j < Suc (ne + length aux) \\<and>\n                 mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and>\n                 MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n                 (\\<forall>k\\<in>{i..<j}.\n                     if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                     else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))\n          r2)\n   [(\\<tau> \\<sigma> (ne + length aux), rel1,\n     if left I = 0 then rel2 else empty_table)]\n   [ne + length aux]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_until_aux_Cons: \"wf_until_aux \\<sigma> n R pos \\<phi> I \\<psi> (a # aux) ne \\<Longrightarrow>\n  wf_until_aux \\<sigma> n R pos \\<phi> I \\<psi> aux (Suc ne)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_until_aux \\<sigma> n R pos \\<phi> I \\<psi> (a # aux)\n     ne \\<Longrightarrow>\n    wf_until_aux \\<sigma> n R pos \\<phi> I \\<psi> aux (Suc ne)", "unfolding wf_until_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>x i.\n         case x of\n         (t, r1, r2) \\<Rightarrow>\n           t = \\<tau> \\<sigma> i \\<and>\n           qtable n (fv \\<phi>) (mem_restr R)\n            (\\<lambda>v.\n                if pos\n                then \\<forall>k\\<in>{i..<ne + length (a # aux)}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                else \\<exists>k\\<in>{i..<ne + length (a # aux)}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>)\n            r1 \\<and>\n           qtable n (fv \\<psi>) (mem_restr R)\n            (\\<lambda>v.\n                \\<exists>j\\<ge>i.\n                   j < ne + length (a # aux) \\<and>\n                   mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and>\n                   MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n                   (\\<forall>k\\<in>{i..<j}.\n                       if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                       else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))\n            r2)\n     (a # aux) [ne..<ne + length (a # aux)] \\<Longrightarrow>\n    list_all2\n     (\\<lambda>x i.\n         case x of\n         (t, r1, r2) \\<Rightarrow>\n           t = \\<tau> \\<sigma> i \\<and>\n           qtable n (fv \\<phi>) (mem_restr R)\n            (\\<lambda>v.\n                if pos\n                then \\<forall>k\\<in>{i..<Suc ne + length aux}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                else \\<exists>k\\<in>{i..<Suc ne + length aux}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>)\n            r1 \\<and>\n           qtable n (fv \\<psi>) (mem_restr R)\n            (\\<lambda>v.\n                \\<exists>j\\<ge>i.\n                   j < Suc ne + length aux \\<and>\n                   mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and>\n                   MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n                   (\\<forall>k\\<in>{i..<j}.\n                       if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                       else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))\n            r2)\n     aux [Suc ne..<Suc ne + length aux]", "by (simp add: upt_conv_Cons del: upt_Suc cong: if_cong)"], ["", "lemma wf_until_aux_Cons1: \"wf_until_aux \\<sigma> n R pos \\<phi> I \\<psi> ((t, a1, a2) # aux) ne \\<Longrightarrow> t = \\<tau> \\<sigma> ne\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_until_aux \\<sigma> n R pos \\<phi> I \\<psi> ((t, a1, a2) # aux)\n     ne \\<Longrightarrow>\n    t = \\<tau> \\<sigma> ne", "unfolding wf_until_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>x i.\n         case x of\n         (ta, r1, r2) \\<Rightarrow>\n           ta = \\<tau> \\<sigma> i \\<and>\n           qtable n (fv \\<phi>) (mem_restr R)\n            (\\<lambda>v.\n                if pos\n                then \\<forall>k\\<in>{i..<ne + length ((t, a1, a2) # aux)}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                else \\<exists>k\\<in>{i..<ne + length ((t, a1, a2) # aux)}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>)\n            r1 \\<and>\n           qtable n (fv \\<psi>) (mem_restr R)\n            (\\<lambda>v.\n                \\<exists>j\\<ge>i.\n                   j < ne + length ((t, a1, a2) # aux) \\<and>\n                   mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and>\n                   MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n                   (\\<forall>k\\<in>{i..<j}.\n                       if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                       else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))\n            r2)\n     ((t, a1, a2) # aux)\n     [ne..<ne + length ((t, a1, a2) # aux)] \\<Longrightarrow>\n    t = \\<tau> \\<sigma> ne", "by (simp add: upt_conv_Cons del: upt_Suc)"], ["", "lemma wf_until_aux_Cons3: \"wf_until_aux \\<sigma> n R pos \\<phi> I \\<psi> ((t, a1, a2) # aux) ne \\<Longrightarrow>\n  qtable n (MFOTL.fv \\<psi>) (mem_restr R) (\\<lambda>v. (\\<exists>j. ne \\<le> j \\<and> j < Suc (ne + length aux) \\<and> mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> ne) I \\<and>\n    MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and> (\\<forall>k\\<in>{ne..<j}. if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi> else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))) a2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_until_aux \\<sigma> n R pos \\<phi> I \\<psi> ((t, a1, a2) # aux)\n     ne \\<Longrightarrow>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         \\<exists>j\\<ge>ne.\n            j < Suc (ne + length aux) \\<and>\n            mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> ne) I \\<and>\n            MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n            (\\<forall>k\\<in>{ne..<j}.\n                if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))\n     a2", "unfolding wf_until_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>x i.\n         case x of\n         (ta, r1, r2) \\<Rightarrow>\n           ta = \\<tau> \\<sigma> i \\<and>\n           qtable n (fv \\<phi>) (mem_restr R)\n            (\\<lambda>v.\n                if pos\n                then \\<forall>k\\<in>{i..<ne + length ((t, a1, a2) # aux)}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                else \\<exists>k\\<in>{i..<ne + length ((t, a1, a2) # aux)}.\n                        MFOTL.sat \\<sigma> (map the v) k \\<phi>)\n            r1 \\<and>\n           qtable n (fv \\<psi>) (mem_restr R)\n            (\\<lambda>v.\n                \\<exists>j\\<ge>i.\n                   j < ne + length ((t, a1, a2) # aux) \\<and>\n                   mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and>\n                   MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n                   (\\<forall>k\\<in>{i..<j}.\n                       if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                       else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))\n            r2)\n     ((t, a1, a2) # aux)\n     [ne..<ne + length ((t, a1, a2) # aux)] \\<Longrightarrow>\n    qtable n (fv \\<psi>) (mem_restr R)\n     (\\<lambda>v.\n         \\<exists>j\\<ge>ne.\n            j < Suc (ne + length aux) \\<and>\n            mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> ne) I \\<and>\n            MFOTL.sat \\<sigma> (map the v) j \\<psi> \\<and>\n            (\\<forall>k\\<in>{ne..<j}.\n                if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>\n                else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>))\n     a2", "by (simp add: upt_conv_Cons del: upt_Suc)"], ["", "lemma upt_append: \"a \\<le> b \\<Longrightarrow> b \\<le> c \\<Longrightarrow> [a..<b] @ [b..<c] = [a..<c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<le> b; b \\<le> c\\<rbrakk>\n    \\<Longrightarrow> [a..<b] @ [b..<c] = [a..<c]", "by (metis le_Suc_ex upt_add_eq_append)"], ["", "lemma wf_mbuf2_add:\n  assumes \"wf_mbuf2 i ja jb P Q buf\"\n    and \"list_all2 P [ja..<ja'] xs\"\n    and \"list_all2 Q [jb..<jb'] ys\"\n    and \"ja \\<le> ja'\" \"jb \\<le> jb'\"\n  shows \"wf_mbuf2 i ja' jb' P Q (mbuf2_add xs ys buf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_mbuf2 i ja' jb' P Q (mbuf2_add xs ys buf)", "using assms"], ["proof (prove)\nusing this:\n  wf_mbuf2 i ja jb P Q buf\n  list_all2 P [ja..<ja'] xs\n  list_all2 Q [jb..<jb'] ys\n  ja \\<le> ja'\n  jb \\<le> jb'\n\ngoal (1 subgoal):\n 1. wf_mbuf2 i ja' jb' P Q (mbuf2_add xs ys buf)", "unfolding wf_mbuf2_def"], ["proof (prove)\nusing this:\n  i \\<le> ja \\<and>\n  i \\<le> jb \\<and>\n  (case buf of\n   (xs, ys) \\<Rightarrow>\n     list_all2 P [i..<ja] xs \\<and> list_all2 Q [i..<jb] ys)\n  list_all2 P [ja..<ja'] xs\n  list_all2 Q [jb..<jb'] ys\n  ja \\<le> ja'\n  jb \\<le> jb'\n\ngoal (1 subgoal):\n 1. i \\<le> ja' \\<and>\n    i \\<le> jb' \\<and>\n    (case mbuf2_add xs ys buf of\n     (xs, ys) \\<Rightarrow>\n       list_all2 P [i..<ja'] xs \\<and> list_all2 Q [i..<jb'] ys)", "by (auto 0 3 simp: list_all2_append2 upt_append dest: list_all2_lengthD\n    intro: exI[where x=\"[i..<ja]\"] exI[where x=\"[ja..<ja']\"]\n           exI[where x=\"[i..<jb]\"] exI[where x=\"[jb..<jb']\"] split: prod.splits)"], ["", "lemma mbuf2_take_eqD:\n  assumes \"mbuf2_take f buf = (xs, buf')\"\n    and \"wf_mbuf2 i ja jb P Q buf\"\n  shows \"wf_mbuf2 (min ja jb) ja jb P Q buf'\"\n    and \"list_all2 (\\<lambda>i z. \\<exists>x y. P i x \\<and> Q i y \\<and> z = f x y) [i..<min ja jb] xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_mbuf2 (min ja jb) ja jb P Q buf' &&&\n    list_all2\n     (\\<lambda>i z. \\<exists>x y. P i x \\<and> Q i y \\<and> z = f x y)\n     [i..<min ja jb] xs", "using assms"], ["proof (prove)\nusing this:\n  mbuf2_take f buf = (xs, buf')\n  wf_mbuf2 i ja jb P Q buf\n\ngoal (1 subgoal):\n 1. wf_mbuf2 (min ja jb) ja jb P Q buf' &&&\n    list_all2\n     (\\<lambda>i z. \\<exists>x y. P i x \\<and> Q i y \\<and> z = f x y)\n     [i..<min ja jb] xs", "unfolding wf_mbuf2_def"], ["proof (prove)\nusing this:\n  mbuf2_take f buf = (xs, buf')\n  i \\<le> ja \\<and>\n  i \\<le> jb \\<and>\n  (case buf of\n   (xs, ys) \\<Rightarrow>\n     list_all2 P [i..<ja] xs \\<and> list_all2 Q [i..<jb] ys)\n\ngoal (1 subgoal):\n 1. min ja jb \\<le> ja \\<and>\n    min ja jb \\<le> jb \\<and>\n    (case buf' of\n     (xs, ys) \\<Rightarrow>\n       list_all2 P [min ja jb..<ja] xs \\<and>\n       list_all2 Q [min ja jb..<jb] ys) &&&\n    list_all2\n     (\\<lambda>i z. \\<exists>x y. P i x \\<and> Q i y \\<and> z = f x y)\n     [i..<min ja jb] xs", "by (induction f buf arbitrary: i xs buf' rule: mbuf2_take.induct)\n    (fastforce simp add: list_all2_Cons2 upt_eq_Cons_conv min_absorb1 min_absorb2 split: prod.splits)+"], ["", "lemma mbuf2t_take_eqD:\n  assumes \"mbuf2t_take f z buf nts = (z', buf', nts')\"\n    and \"wf_mbuf2 i ja jb P Q buf\"\n    and \"list_all2 R [i..<j] nts\"\n    and \"ja \\<le> j\" \"jb \\<le> j\"\n  shows \"wf_mbuf2 (min ja jb) ja jb P Q buf'\"\n    and \"list_all2 R [min ja jb..<j] nts'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_mbuf2 (min ja jb) ja jb P Q buf' &&& list_all2 R [min ja jb..<j] nts'", "using assms"], ["proof (prove)\nusing this:\n  mbuf2t_take f z buf nts = (z', buf', nts')\n  wf_mbuf2 i ja jb P Q buf\n  list_all2 R [i..<j] nts\n  ja \\<le> j\n  jb \\<le> j\n\ngoal (1 subgoal):\n 1. wf_mbuf2 (min ja jb) ja jb P Q buf' &&& list_all2 R [min ja jb..<j] nts'", "unfolding wf_mbuf2_def"], ["proof (prove)\nusing this:\n  mbuf2t_take f z buf nts = (z', buf', nts')\n  i \\<le> ja \\<and>\n  i \\<le> jb \\<and>\n  (case buf of\n   (xs, ys) \\<Rightarrow>\n     list_all2 P [i..<ja] xs \\<and> list_all2 Q [i..<jb] ys)\n  list_all2 R [i..<j] nts\n  ja \\<le> j\n  jb \\<le> j\n\ngoal (1 subgoal):\n 1. min ja jb \\<le> ja \\<and>\n    min ja jb \\<le> jb \\<and>\n    (case buf' of\n     (xs, ys) \\<Rightarrow>\n       list_all2 P [min ja jb..<ja] xs \\<and>\n       list_all2 Q [min ja jb..<jb] ys) &&&\n    list_all2 R [min ja jb..<j] nts'", "by (induction f z buf nts arbitrary: i z' buf' nts' rule: mbuf2t_take.induct)\n    (auto simp add: list_all2_Cons2 upt_eq_Cons_conv less_eq_Suc_le min_absorb1 min_absorb2\n      split: prod.split)"], ["", "lemma mbuf2t_take_induct[consumes 5, case_names base step]:\n  assumes \"mbuf2t_take f z buf nts = (z', buf', nts')\"\n    and \"wf_mbuf2 i ja jb P Q buf\"\n    and \"list_all2 R [i..<j] nts\"\n    and \"ja \\<le> j\" \"jb \\<le> j\"\n    and \"U i z\"\n    and \"\\<And>k x y t z. i \\<le> k \\<Longrightarrow> Suc k \\<le> ja \\<Longrightarrow> Suc k \\<le> jb \\<Longrightarrow>\n      P k x \\<Longrightarrow> Q k y \\<Longrightarrow> R k t \\<Longrightarrow> U k z \\<Longrightarrow> U (Suc k) (f x y t z)\"\n  shows \"U (min ja jb) z'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U (min ja jb) z'", "using assms"], ["proof (prove)\nusing this:\n  mbuf2t_take f z buf nts = (z', buf', nts')\n  wf_mbuf2 i ja jb P Q buf\n  list_all2 R [i..<j] nts\n  ja \\<le> j\n  jb \\<le> j\n  U i z\n  \\<lbrakk>i \\<le> ?k; Suc ?k \\<le> ja; Suc ?k \\<le> jb; P ?k ?x; Q ?k ?y;\n   R ?k ?t; U ?k ?z\\<rbrakk>\n  \\<Longrightarrow> U (Suc ?k) (f ?x ?y ?t ?z)\n\ngoal (1 subgoal):\n 1. U (min ja jb) z'", "unfolding wf_mbuf2_def"], ["proof (prove)\nusing this:\n  mbuf2t_take f z buf nts = (z', buf', nts')\n  i \\<le> ja \\<and>\n  i \\<le> jb \\<and>\n  (case buf of\n   (xs, ys) \\<Rightarrow>\n     list_all2 P [i..<ja] xs \\<and> list_all2 Q [i..<jb] ys)\n  list_all2 R [i..<j] nts\n  ja \\<le> j\n  jb \\<le> j\n  U i z\n  \\<lbrakk>i \\<le> ?k; Suc ?k \\<le> ja; Suc ?k \\<le> jb; P ?k ?x; Q ?k ?y;\n   R ?k ?t; U ?k ?z\\<rbrakk>\n  \\<Longrightarrow> U (Suc ?k) (f ?x ?y ?t ?z)\n\ngoal (1 subgoal):\n 1. U (min ja jb) z'", "by (induction f z buf nts arbitrary: i z' buf' nts' rule: mbuf2t_take.induct)\n    (auto simp add: list_all2_Cons2 upt_eq_Cons_conv less_eq_Suc_le min_absorb1 min_absorb2\n       elim!: arg_cong2[of _ _ _ _ U, OF _ refl, THEN iffD1, rotated] split: prod.split)"], ["", "lemma mbuf2_take_add':\n  assumes eq: \"mbuf2_take f (mbuf2_add xs ys buf) = (zs, buf')\"\n    and pre: \"wf_mbuf2' \\<sigma> j n R \\<phi> \\<psi> buf\"\n    and xs: \"list_all2 (\\<lambda>i. qtable n (MFOTL.fv \\<phi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n      [progress \\<sigma> \\<phi> j..<progress \\<sigma> \\<phi> j'] xs\"\n    and ys: \"list_all2 (\\<lambda>i. qtable n (MFOTL.fv \\<psi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n      [progress \\<sigma> \\<psi> j..<progress \\<sigma> \\<psi> j'] ys\"\n    and \"j \\<le> j'\"\n  shows \"wf_mbuf2' \\<sigma> j' n R \\<phi> \\<psi> buf'\"\n    and \"list_all2 (\\<lambda>i Z. \\<exists>X Y.\n      qtable n (MFOTL.fv \\<phi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>) X \\<and>\n      qtable n (MFOTL.fv \\<psi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>) Y \\<and>\n      Z = f X Y)\n      [min (progress \\<sigma> \\<phi> j) (progress \\<sigma> \\<psi> j)..<min (progress \\<sigma> \\<phi> j') (progress \\<sigma> \\<psi> j')] zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_mbuf2' \\<sigma> j' n R \\<phi> \\<psi> buf' &&&\n    list_all2\n     (\\<lambda>i Z.\n         \\<exists>X Y.\n            qtable n (fv \\<phi>) (mem_restr R)\n             (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>) X \\<and>\n            qtable n (fv \\<psi>) (mem_restr R)\n             (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>) Y \\<and>\n            Z = f X Y)\n     [min (Monitor.progress \\<sigma> \\<phi> j)\n       (Monitor.progress \\<sigma> \\<psi> j)..<\n      min (Monitor.progress \\<sigma> \\<phi> j')\n       (Monitor.progress \\<sigma> \\<psi> j')]\n     zs", "using pre"], ["proof (prove)\nusing this:\n  wf_mbuf2' \\<sigma> j n R \\<phi> \\<psi> buf\n\ngoal (1 subgoal):\n 1. wf_mbuf2' \\<sigma> j' n R \\<phi> \\<psi> buf' &&&\n    list_all2\n     (\\<lambda>i Z.\n         \\<exists>X Y.\n            qtable n (fv \\<phi>) (mem_restr R)\n             (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>) X \\<and>\n            qtable n (fv \\<psi>) (mem_restr R)\n             (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>) Y \\<and>\n            Z = f X Y)\n     [min (Monitor.progress \\<sigma> \\<phi> j)\n       (Monitor.progress \\<sigma> \\<psi> j)..<\n      min (Monitor.progress \\<sigma> \\<phi> j')\n       (Monitor.progress \\<sigma> \\<psi> j')]\n     zs", "unfolding wf_mbuf2'_def"], ["proof (prove)\nusing this:\n  wf_mbuf2\n   (min (Monitor.progress \\<sigma> \\<phi> j)\n     (Monitor.progress \\<sigma> \\<psi> j))\n   (Monitor.progress \\<sigma> \\<phi> j) (Monitor.progress \\<sigma> \\<psi> j)\n   (\\<lambda>i.\n       qtable n (fv \\<phi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n   (\\<lambda>i.\n       qtable n (fv \\<psi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n   buf\n\ngoal (1 subgoal):\n 1. wf_mbuf2\n     (min (Monitor.progress \\<sigma> \\<phi> j')\n       (Monitor.progress \\<sigma> \\<psi> j'))\n     (Monitor.progress \\<sigma> \\<phi> j')\n     (Monitor.progress \\<sigma> \\<psi> j')\n     (\\<lambda>i.\n         qtable n (fv \\<phi>) (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n     (\\<lambda>i.\n         qtable n (fv \\<psi>) (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n     buf' &&&\n    list_all2\n     (\\<lambda>i Z.\n         \\<exists>X Y.\n            qtable n (fv \\<phi>) (mem_restr R)\n             (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>) X \\<and>\n            qtable n (fv \\<psi>) (mem_restr R)\n             (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>) Y \\<and>\n            Z = f X Y)\n     [min (Monitor.progress \\<sigma> \\<phi> j)\n       (Monitor.progress \\<sigma> \\<psi> j)..<\n      min (Monitor.progress \\<sigma> \\<phi> j')\n       (Monitor.progress \\<sigma> \\<psi> j')]\n     zs", "by (force intro!: mbuf2_take_eqD[OF eq] wf_mbuf2_add[OF _ xs ys] progress_mono[OF \\<open>j \\<le> j'\\<close>])+"], ["", "lemma mbuf2t_take_add':\n  assumes eq: \"mbuf2t_take f z (mbuf2_add xs ys buf) nts = (z', buf', nts')\"\n    and pre_buf: \"wf_mbuf2' \\<sigma> j n R \\<phi> \\<psi> buf\"\n    and pre_nts: \"list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [min (progress \\<sigma> \\<phi> j) (progress \\<sigma> \\<psi> j)..<j'] nts\"\n    and xs: \"list_all2 (\\<lambda>i. qtable n (MFOTL.fv \\<phi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n      [progress \\<sigma> \\<phi> j..<progress \\<sigma> \\<phi> j'] xs\"\n    and ys: \"list_all2 (\\<lambda>i. qtable n (MFOTL.fv \\<psi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n      [progress \\<sigma> \\<psi> j..<progress \\<sigma> \\<psi> j'] ys\"\n    and \"j \\<le> j'\"\n  shows \"wf_mbuf2' \\<sigma> j' n R \\<phi> \\<psi> buf'\"\n    and \"wf_ts \\<sigma> j' \\<phi> \\<psi> nts'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_mbuf2' \\<sigma> j' n R \\<phi> \\<psi> buf' &&&\n    wf_ts \\<sigma> j' \\<phi> \\<psi> nts'", "using pre_buf pre_nts"], ["proof (prove)\nusing this:\n  wf_mbuf2' \\<sigma> j n R \\<phi> \\<psi> buf\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<phi> j)\n     (Monitor.progress \\<sigma> \\<psi> j)..<\n    j']\n   nts\n\ngoal (1 subgoal):\n 1. wf_mbuf2' \\<sigma> j' n R \\<phi> \\<psi> buf' &&&\n    wf_ts \\<sigma> j' \\<phi> \\<psi> nts'", "unfolding wf_mbuf2'_def wf_ts_def"], ["proof (prove)\nusing this:\n  wf_mbuf2\n   (min (Monitor.progress \\<sigma> \\<phi> j)\n     (Monitor.progress \\<sigma> \\<psi> j))\n   (Monitor.progress \\<sigma> \\<phi> j) (Monitor.progress \\<sigma> \\<psi> j)\n   (\\<lambda>i.\n       qtable n (fv \\<phi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n   (\\<lambda>i.\n       qtable n (fv \\<psi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n   buf\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<phi> j)\n     (Monitor.progress \\<sigma> \\<psi> j)..<\n    j']\n   nts\n\ngoal (1 subgoal):\n 1. wf_mbuf2\n     (min (Monitor.progress \\<sigma> \\<phi> j')\n       (Monitor.progress \\<sigma> \\<psi> j'))\n     (Monitor.progress \\<sigma> \\<phi> j')\n     (Monitor.progress \\<sigma> \\<psi> j')\n     (\\<lambda>i.\n         qtable n (fv \\<phi>) (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n     (\\<lambda>i.\n         qtable n (fv \\<psi>) (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n     buf' &&&\n    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n     [min (Monitor.progress \\<sigma> \\<phi> j')\n       (Monitor.progress \\<sigma> \\<psi> j')..<\n      j']\n     nts'", "by (blast intro!: mbuf2t_take_eqD[OF eq] wf_mbuf2_add[OF _ xs ys] progress_mono[OF \\<open>j \\<le> j'\\<close>]\n      progress_le)+"], ["", "lemma mbuf2t_take_add_induct'[consumes 6, case_names base step]:\n  assumes eq: \"mbuf2t_take f z (mbuf2_add xs ys buf) nts = (z', buf', nts')\"\n    and pre_buf: \"wf_mbuf2' \\<sigma> j n R \\<phi> \\<psi> buf\"\n    and pre_nts: \"list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [min (progress \\<sigma> \\<phi> j) (progress \\<sigma> \\<psi> j)..<j'] nts\"\n    and xs: \"list_all2 (\\<lambda>i. qtable n (MFOTL.fv \\<phi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n      [progress \\<sigma> \\<phi> j..<progress \\<sigma> \\<phi> j'] xs\"\n    and ys: \"list_all2 (\\<lambda>i. qtable n (MFOTL.fv \\<psi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n      [progress \\<sigma> \\<psi> j..<progress \\<sigma> \\<psi> j'] ys\"\n    and \"j \\<le> j'\"\n    and base: \"U (min (progress \\<sigma> \\<phi> j) (progress \\<sigma> \\<psi> j)) z\"\n    and step: \"\\<And>k X Y z. min (progress \\<sigma> \\<phi> j) (progress \\<sigma> \\<psi> j) \\<le> k \\<Longrightarrow>\n      Suc k \\<le> progress \\<sigma> \\<phi> j' \\<Longrightarrow> Suc k \\<le> progress \\<sigma> \\<psi> j' \\<Longrightarrow>\n      qtable n (MFOTL.fv \\<phi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<phi>) X \\<Longrightarrow>\n      qtable n (MFOTL.fv \\<psi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<psi>) Y \\<Longrightarrow>\n      U k z \\<Longrightarrow> U (Suc k) (f X Y (\\<tau> \\<sigma> k) z)\"\n  shows \"U (min (progress \\<sigma> \\<phi> j') (progress \\<sigma> \\<psi> j')) z'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U (min (Monitor.progress \\<sigma> \\<phi> j')\n        (Monitor.progress \\<sigma> \\<psi> j'))\n     z'", "using pre_buf pre_nts"], ["proof (prove)\nusing this:\n  wf_mbuf2' \\<sigma> j n R \\<phi> \\<psi> buf\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<phi> j)\n     (Monitor.progress \\<sigma> \\<psi> j)..<\n    j']\n   nts\n\ngoal (1 subgoal):\n 1. U (min (Monitor.progress \\<sigma> \\<phi> j')\n        (Monitor.progress \\<sigma> \\<psi> j'))\n     z'", "unfolding wf_mbuf2'_def wf_ts_def"], ["proof (prove)\nusing this:\n  wf_mbuf2\n   (min (Monitor.progress \\<sigma> \\<phi> j)\n     (Monitor.progress \\<sigma> \\<psi> j))\n   (Monitor.progress \\<sigma> \\<phi> j) (Monitor.progress \\<sigma> \\<psi> j)\n   (\\<lambda>i.\n       qtable n (fv \\<phi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n   (\\<lambda>i.\n       qtable n (fv \\<psi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n   buf\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<phi> j)\n     (Monitor.progress \\<sigma> \\<psi> j)..<\n    j']\n   nts\n\ngoal (1 subgoal):\n 1. U (min (Monitor.progress \\<sigma> \\<phi> j')\n        (Monitor.progress \\<sigma> \\<psi> j'))\n     z'", "by (blast intro!: mbuf2t_take_induct[OF eq] wf_mbuf2_add[OF _ xs ys] progress_mono[OF \\<open>j \\<le> j'\\<close>]\n      progress_le base step)"], ["", "lemma progress_Until_le: \"progress \\<sigma> (formula.Until \\<phi> I \\<psi>) j \\<le> min (progress \\<sigma> \\<phi> j) (progress \\<sigma> \\<psi> j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Monitor.progress \\<sigma> (formula.Until \\<phi> I \\<psi>) j\n    \\<le> min (Monitor.progress \\<sigma> \\<phi> j)\n           (Monitor.progress \\<sigma> \\<psi> j)", "by (cases \"right I\") (auto simp: trans_le_add1 intro!: cInf_lower)"], ["", "lemma list_all2_upt_Cons: \"P a x \\<Longrightarrow> list_all2 P [Suc a..<b] xs \\<Longrightarrow> Suc a \\<le> b \\<Longrightarrow>\n  list_all2 P [a..<b] (x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P a x; list_all2 P [Suc a..<b] xs; Suc a \\<le> b\\<rbrakk>\n    \\<Longrightarrow> list_all2 P [a..<b] (x # xs)", "by (simp add: list_all2_Cons2 upt_eq_Cons_conv)"], ["", "lemma list_all2_upt_append: \"list_all2 P [a..<b] xs \\<Longrightarrow> list_all2 P [b..<c] ys \\<Longrightarrow>\n  a \\<le> b \\<Longrightarrow> b \\<le> c \\<Longrightarrow> list_all2 P [a..<c] (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all2 P [a..<b] xs; list_all2 P [b..<c] ys; a \\<le> b;\n     b \\<le> c\\<rbrakk>\n    \\<Longrightarrow> list_all2 P [a..<c] (xs @ ys)", "by (induction xs arbitrary: a) (auto simp add: list_all2_Cons2 upt_eq_Cons_conv)"], ["", "lemma meval:\n  assumes \"wf_mformula \\<sigma> j n R \\<phi> \\<phi>'\"\n  shows \"case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi> of (xs, \\<phi>\\<^sub>n) \\<Rightarrow> wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n    list_all2 (\\<lambda>i. qtable n (MFOTL.fv \\<phi>') (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n    [progress \\<sigma> \\<phi>' j..<progress \\<sigma> \\<phi>' (Suc j)] xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi> of\n    (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n      wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n      list_all2\n       (\\<lambda>i.\n           qtable n (fv \\<phi>') (mem_restr R)\n            (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n       [Monitor.progress \\<sigma> \\<phi>' j..<\n        Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n       xs", "using assms"], ["proof (prove)\nusing this:\n  wf_mformula \\<sigma> j n R \\<phi> \\<phi>'\n\ngoal (1 subgoal):\n 1. case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi> of\n    (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n      wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n      list_all2\n       (\\<lambda>i.\n           qtable n (fv \\<phi>') (mem_restr R)\n            (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n       [Monitor.progress \\<sigma> \\<phi>' j..<\n        Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n       xs", "proof (induction \\<phi> arbitrary: n R \\<phi>')"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>x n R \\<phi>'.\n       wf_mformula \\<sigma> j n R (MRel x) \\<phi>' \\<Longrightarrow>\n       case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) (MRel x) of\n       (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n         wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n         list_all2\n          (\\<lambda>i.\n              qtable n (fv \\<phi>') (mem_restr R)\n               (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n          [Monitor.progress \\<sigma> \\<phi>' j..<\n           Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n          xs\n 2. \\<And>x1a x2 n R \\<phi>'.\n       wf_mformula \\<sigma> j n R (MPred x1a x2) \\<phi>' \\<Longrightarrow>\n       case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n             (MPred x1a x2) of\n       (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n         wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n         list_all2\n          (\\<lambda>i.\n              qtable n (fv \\<phi>') (mem_restr R)\n               (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n          [Monitor.progress \\<sigma> \\<phi>' j..<\n           Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n          xs\n 3. \\<And>\\<phi>1 x2 \\<phi>2 x4 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MAnd \\<phi>1 x2 \\<phi>2 x4)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MAnd \\<phi>1 x2 \\<phi>2 x4) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 4. \\<And>\\<phi>1 \\<phi>2 x3 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MOr \\<phi>1 \\<phi>2 x3) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MOr \\<phi>1 \\<phi>2 x3) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 5. \\<And>\\<phi> n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MExists \\<phi>) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j) (MExists \\<phi>) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 6. \\<And>x1a \\<phi> x3 x4 x5a n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MPrev x1a \\<phi> x3 x4 x5a)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev x1a \\<phi> x3 x4 x5a) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 7. \\<And>x1a \\<phi> x3 x4 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MNext x1a \\<phi> x3 x4) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext x1a \\<phi> x3 x4) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 8. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 9. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "case (MRel rel)"], ["proof (state)\nthis:\n  wf_mformula \\<sigma> j n R (MRel rel) \\<phi>'\n\ngoal (9 subgoals):\n 1. \\<And>x n R \\<phi>'.\n       wf_mformula \\<sigma> j n R (MRel x) \\<phi>' \\<Longrightarrow>\n       case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) (MRel x) of\n       (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n         wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n         list_all2\n          (\\<lambda>i.\n              qtable n (fv \\<phi>') (mem_restr R)\n               (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n          [Monitor.progress \\<sigma> \\<phi>' j..<\n           Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n          xs\n 2. \\<And>x1a x2 n R \\<phi>'.\n       wf_mformula \\<sigma> j n R (MPred x1a x2) \\<phi>' \\<Longrightarrow>\n       case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n             (MPred x1a x2) of\n       (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n         wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n         list_all2\n          (\\<lambda>i.\n              qtable n (fv \\<phi>') (mem_restr R)\n               (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n          [Monitor.progress \\<sigma> \\<phi>' j..<\n           Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n          xs\n 3. \\<And>\\<phi>1 x2 \\<phi>2 x4 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MAnd \\<phi>1 x2 \\<phi>2 x4)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MAnd \\<phi>1 x2 \\<phi>2 x4) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 4. \\<And>\\<phi>1 \\<phi>2 x3 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MOr \\<phi>1 \\<phi>2 x3) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MOr \\<phi>1 \\<phi>2 x3) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 5. \\<And>\\<phi> n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MExists \\<phi>) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j) (MExists \\<phi>) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 6. \\<And>x1a \\<phi> x3 x4 x5a n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MPrev x1a \\<phi> x3 x4 x5a)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev x1a \\<phi> x3 x4 x5a) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 7. \\<And>x1a \\<phi> x3 x4 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MNext x1a \\<phi> x3 x4) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext x1a \\<phi> x3 x4) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 8. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 9. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "then"], ["proof (chain)\npicking this:\n  wf_mformula \\<sigma> j n R (MRel rel) \\<phi>'", "show ?case"], ["proof (prove)\nusing this:\n  wf_mformula \\<sigma> j n R (MRel rel) \\<phi>'\n\ngoal (1 subgoal):\n 1. case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) (MRel rel) of\n    (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n      wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n      list_all2\n       (\\<lambda>i.\n           qtable n (fv \\<phi>') (mem_restr R)\n            (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n       [Monitor.progress \\<sigma> \\<phi>' j..<\n        Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n       xs", "by (cases pred: wf_mformula)\n      (auto simp add: ball_Un intro: wf_mformula.intros qtableI table_eq_rel eq_rel_eval_trm\n        in_eq_rel qtable_empty qtable_unit_table)"], ["proof (state)\nthis:\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) (MRel rel) of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n     [Monitor.progress \\<sigma> \\<phi>' j..<\n      Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n     xs\n\ngoal (8 subgoals):\n 1. \\<And>x1a x2 n R \\<phi>'.\n       wf_mformula \\<sigma> j n R (MPred x1a x2) \\<phi>' \\<Longrightarrow>\n       case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n             (MPred x1a x2) of\n       (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n         wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n         list_all2\n          (\\<lambda>i.\n              qtable n (fv \\<phi>') (mem_restr R)\n               (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n          [Monitor.progress \\<sigma> \\<phi>' j..<\n           Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n          xs\n 2. \\<And>\\<phi>1 x2 \\<phi>2 x4 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MAnd \\<phi>1 x2 \\<phi>2 x4)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MAnd \\<phi>1 x2 \\<phi>2 x4) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 3. \\<And>\\<phi>1 \\<phi>2 x3 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MOr \\<phi>1 \\<phi>2 x3) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MOr \\<phi>1 \\<phi>2 x3) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 4. \\<And>\\<phi> n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MExists \\<phi>) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j) (MExists \\<phi>) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 5. \\<And>x1a \\<phi> x3 x4 x5a n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MPrev x1a \\<phi> x3 x4 x5a)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev x1a \\<phi> x3 x4 x5a) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 6. \\<And>x1a \\<phi> x3 x4 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MNext x1a \\<phi> x3 x4) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext x1a \\<phi> x3 x4) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 7. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 8. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x1a x2 n R \\<phi>'.\n       wf_mformula \\<sigma> j n R (MPred x1a x2) \\<phi>' \\<Longrightarrow>\n       case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n             (MPred x1a x2) of\n       (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n         wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n         list_all2\n          (\\<lambda>i.\n              qtable n (fv \\<phi>') (mem_restr R)\n               (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n          [Monitor.progress \\<sigma> \\<phi>' j..<\n           Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n          xs\n 2. \\<And>\\<phi>1 x2 \\<phi>2 x4 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MAnd \\<phi>1 x2 \\<phi>2 x4)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MAnd \\<phi>1 x2 \\<phi>2 x4) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 3. \\<And>\\<phi>1 \\<phi>2 x3 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MOr \\<phi>1 \\<phi>2 x3) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MOr \\<phi>1 \\<phi>2 x3) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 4. \\<And>\\<phi> n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MExists \\<phi>) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j) (MExists \\<phi>) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 5. \\<And>x1a \\<phi> x3 x4 x5a n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MPrev x1a \\<phi> x3 x4 x5a)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev x1a \\<phi> x3 x4 x5a) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 6. \\<And>x1a \\<phi> x3 x4 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MNext x1a \\<phi> x3 x4) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext x1a \\<phi> x3 x4) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 7. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 8. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "case (MPred e ts)"], ["proof (state)\nthis:\n  wf_mformula \\<sigma> j n R (MPred e ts) \\<phi>'\n\ngoal (8 subgoals):\n 1. \\<And>x1a x2 n R \\<phi>'.\n       wf_mformula \\<sigma> j n R (MPred x1a x2) \\<phi>' \\<Longrightarrow>\n       case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n             (MPred x1a x2) of\n       (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n         wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n         list_all2\n          (\\<lambda>i.\n              qtable n (fv \\<phi>') (mem_restr R)\n               (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n          [Monitor.progress \\<sigma> \\<phi>' j..<\n           Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n          xs\n 2. \\<And>\\<phi>1 x2 \\<phi>2 x4 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MAnd \\<phi>1 x2 \\<phi>2 x4)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MAnd \\<phi>1 x2 \\<phi>2 x4) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 3. \\<And>\\<phi>1 \\<phi>2 x3 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MOr \\<phi>1 \\<phi>2 x3) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MOr \\<phi>1 \\<phi>2 x3) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 4. \\<And>\\<phi> n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MExists \\<phi>) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j) (MExists \\<phi>) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 5. \\<And>x1a \\<phi> x3 x4 x5a n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MPrev x1a \\<phi> x3 x4 x5a)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev x1a \\<phi> x3 x4 x5a) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 6. \\<And>x1a \\<phi> x3 x4 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MNext x1a \\<phi> x3 x4) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext x1a \\<phi> x3 x4) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 7. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 8. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "then"], ["proof (chain)\npicking this:\n  wf_mformula \\<sigma> j n R (MPred e ts) \\<phi>'", "show ?case"], ["proof (prove)\nusing this:\n  wf_mformula \\<sigma> j n R (MPred e ts) \\<phi>'\n\ngoal (1 subgoal):\n 1. case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) (MPred e ts) of\n    (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n      wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n      list_all2\n       (\\<lambda>i.\n           qtable n (fv \\<phi>') (mem_restr R)\n            (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n       [Monitor.progress \\<sigma> \\<phi>' j..<\n        Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n       xs", "by (cases pred: wf_mformula)\n      (auto 0 4 simp: table_def in_these_eq match_wf_tuple match_eval_trm image_iff dest: ex_match\n        split: if_splits intro!: wf_mformula.intros qtableI elim!: bexI[rotated])"], ["proof (state)\nthis:\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) (MPred e ts) of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n     [Monitor.progress \\<sigma> \\<phi>' j..<\n      Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n     xs\n\ngoal (7 subgoals):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 x4 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MAnd \\<phi>1 x2 \\<phi>2 x4)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MAnd \\<phi>1 x2 \\<phi>2 x4) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi>1 \\<phi>2 x3 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MOr \\<phi>1 \\<phi>2 x3) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MOr \\<phi>1 \\<phi>2 x3) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 3. \\<And>\\<phi> n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MExists \\<phi>) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j) (MExists \\<phi>) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 4. \\<And>x1a \\<phi> x3 x4 x5a n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MPrev x1a \\<phi> x3 x4 x5a)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev x1a \\<phi> x3 x4 x5a) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 5. \\<And>x1a \\<phi> x3 x4 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MNext x1a \\<phi> x3 x4) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext x1a \\<phi> x3 x4) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 6. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 7. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 x4 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MAnd \\<phi>1 x2 \\<phi>2 x4)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MAnd \\<phi>1 x2 \\<phi>2 x4) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi>1 \\<phi>2 x3 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MOr \\<phi>1 \\<phi>2 x3) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MOr \\<phi>1 \\<phi>2 x3) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 3. \\<And>\\<phi> n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MExists \\<phi>) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j) (MExists \\<phi>) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 4. \\<And>x1a \\<phi> x3 x4 x5a n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MPrev x1a \\<phi> x3 x4 x5a)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev x1a \\<phi> x3 x4 x5a) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 5. \\<And>x1a \\<phi> x3 x4 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MNext x1a \\<phi> x3 x4) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext x1a \\<phi> x3 x4) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 6. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 7. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "case (MAnd \\<phi> pos \\<psi> buf)"], ["proof (state)\nthis:\n  wf_mformula \\<sigma> j ?n ?R \\<phi> ?\\<phi>' \\<Longrightarrow>\n  case meval ?n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) ?n ?R \\<phi>\\<^sub>n ?\\<phi>' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable ?n (fv ?\\<phi>') (mem_restr ?R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i ?\\<phi>'))\n     [Monitor.progress \\<sigma> ?\\<phi>' j..<\n      Monitor.progress \\<sigma> ?\\<phi>' (Suc j)]\n     xs\n  wf_mformula \\<sigma> j ?n ?R \\<psi> ?\\<phi>' \\<Longrightarrow>\n  case meval ?n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<psi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) ?n ?R \\<phi>\\<^sub>n ?\\<phi>' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable ?n (fv ?\\<phi>') (mem_restr ?R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i ?\\<phi>'))\n     [Monitor.progress \\<sigma> ?\\<phi>' j..<\n      Monitor.progress \\<sigma> ?\\<phi>' (Suc j)]\n     xs\n  wf_mformula \\<sigma> j n R (MAnd \\<phi> pos \\<psi> buf) \\<phi>'\n\ngoal (7 subgoals):\n 1. \\<And>\\<phi>1 x2 \\<phi>2 x4 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MAnd \\<phi>1 x2 \\<phi>2 x4)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MAnd \\<phi>1 x2 \\<phi>2 x4) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi>1 \\<phi>2 x3 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MOr \\<phi>1 \\<phi>2 x3) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MOr \\<phi>1 \\<phi>2 x3) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 3. \\<And>\\<phi> n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MExists \\<phi>) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j) (MExists \\<phi>) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 4. \\<And>x1a \\<phi> x3 x4 x5a n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MPrev x1a \\<phi> x3 x4 x5a)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev x1a \\<phi> x3 x4 x5a) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 5. \\<And>x1a \\<phi> x3 x4 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MNext x1a \\<phi> x3 x4) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext x1a \\<phi> x3 x4) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 6. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 7. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "from MAnd.prems"], ["proof (chain)\npicking this:\n  wf_mformula \\<sigma> j n R (MAnd \\<phi> pos \\<psi> buf) \\<phi>'", "show ?case"], ["proof (prove)\nusing this:\n  wf_mformula \\<sigma> j n R (MAnd \\<phi> pos \\<psi> buf) \\<phi>'\n\ngoal (1 subgoal):\n 1. case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n          (MAnd \\<phi> pos \\<psi> buf) of\n    (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n      wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n      list_all2\n       (\\<lambda>i.\n           qtable n (fv \\<phi>') (mem_restr R)\n            (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n       [Monitor.progress \\<sigma> \\<phi>' j..<\n        Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n       xs", "by (cases pred: wf_mformula)\n      (auto simp: fvi_And sat_And fvi_And_Not sat_And_Not sat_the_restrict\n       dest!: MAnd.IH split: if_splits prod.splits intro!: wf_mformula.And qtable_join\n       dest: mbuf2_take_add' elim!: list.rel_mono_strong)"], ["proof (state)\nthis:\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n        (MAnd \\<phi> pos \\<psi> buf) of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n     [Monitor.progress \\<sigma> \\<phi>' j..<\n      Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n     xs\n\ngoal (6 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2 x3 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MOr \\<phi>1 \\<phi>2 x3) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MOr \\<phi>1 \\<phi>2 x3) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi> n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MExists \\<phi>) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j) (MExists \\<phi>) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 3. \\<And>x1a \\<phi> x3 x4 x5a n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MPrev x1a \\<phi> x3 x4 x5a)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev x1a \\<phi> x3 x4 x5a) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 4. \\<And>x1a \\<phi> x3 x4 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MNext x1a \\<phi> x3 x4) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext x1a \\<phi> x3 x4) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 5. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 6. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2 x3 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MOr \\<phi>1 \\<phi>2 x3) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MOr \\<phi>1 \\<phi>2 x3) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi> n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MExists \\<phi>) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j) (MExists \\<phi>) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 3. \\<And>x1a \\<phi> x3 x4 x5a n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MPrev x1a \\<phi> x3 x4 x5a)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev x1a \\<phi> x3 x4 x5a) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 4. \\<And>x1a \\<phi> x3 x4 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MNext x1a \\<phi> x3 x4) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext x1a \\<phi> x3 x4) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 5. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 6. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "case (MOr \\<phi> \\<psi> buf)"], ["proof (state)\nthis:\n  wf_mformula \\<sigma> j ?n ?R \\<phi> ?\\<phi>' \\<Longrightarrow>\n  case meval ?n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) ?n ?R \\<phi>\\<^sub>n ?\\<phi>' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable ?n (fv ?\\<phi>') (mem_restr ?R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i ?\\<phi>'))\n     [Monitor.progress \\<sigma> ?\\<phi>' j..<\n      Monitor.progress \\<sigma> ?\\<phi>' (Suc j)]\n     xs\n  wf_mformula \\<sigma> j ?n ?R \\<psi> ?\\<phi>' \\<Longrightarrow>\n  case meval ?n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<psi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) ?n ?R \\<phi>\\<^sub>n ?\\<phi>' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable ?n (fv ?\\<phi>') (mem_restr ?R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i ?\\<phi>'))\n     [Monitor.progress \\<sigma> ?\\<phi>' j..<\n      Monitor.progress \\<sigma> ?\\<phi>' (Suc j)]\n     xs\n  wf_mformula \\<sigma> j n R (MOr \\<phi> \\<psi> buf) \\<phi>'\n\ngoal (6 subgoals):\n 1. \\<And>\\<phi>1 \\<phi>2 x3 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MOr \\<phi>1 \\<phi>2 x3) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MOr \\<phi>1 \\<phi>2 x3) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi> n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MExists \\<phi>) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j) (MExists \\<phi>) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 3. \\<And>x1a \\<phi> x3 x4 x5a n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MPrev x1a \\<phi> x3 x4 x5a)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev x1a \\<phi> x3 x4 x5a) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 4. \\<And>x1a \\<phi> x3 x4 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MNext x1a \\<phi> x3 x4) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext x1a \\<phi> x3 x4) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 5. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 6. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "from MOr.prems"], ["proof (chain)\npicking this:\n  wf_mformula \\<sigma> j n R (MOr \\<phi> \\<psi> buf) \\<phi>'", "show ?case"], ["proof (prove)\nusing this:\n  wf_mformula \\<sigma> j n R (MOr \\<phi> \\<psi> buf) \\<phi>'\n\ngoal (1 subgoal):\n 1. case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n          (MOr \\<phi> \\<psi> buf) of\n    (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n      wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n      list_all2\n       (\\<lambda>i.\n           qtable n (fv \\<phi>') (mem_restr R)\n            (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n       [Monitor.progress \\<sigma> \\<phi>' j..<\n        Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n       xs", "by (cases pred: wf_mformula)\n      (auto dest!: MOr.IH split: if_splits prod.splits intro!: wf_mformula.Or qtable_union\n       dest: mbuf2_take_add' elim!: list.rel_mono_strong)"], ["proof (state)\nthis:\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n        (MOr \\<phi> \\<psi> buf) of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n     [Monitor.progress \\<sigma> \\<phi>' j..<\n      Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n     xs\n\ngoal (5 subgoals):\n 1. \\<And>\\<phi> n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MExists \\<phi>) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j) (MExists \\<phi>) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>x1a \\<phi> x3 x4 x5a n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MPrev x1a \\<phi> x3 x4 x5a)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev x1a \\<phi> x3 x4 x5a) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 3. \\<And>x1a \\<phi> x3 x4 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MNext x1a \\<phi> x3 x4) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext x1a \\<phi> x3 x4) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 4. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 5. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<phi> n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MExists \\<phi>) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j) (MExists \\<phi>) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>x1a \\<phi> x3 x4 x5a n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MPrev x1a \\<phi> x3 x4 x5a)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev x1a \\<phi> x3 x4 x5a) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 3. \\<And>x1a \\<phi> x3 x4 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MNext x1a \\<phi> x3 x4) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext x1a \\<phi> x3 x4) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 4. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 5. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "case (MExists \\<phi>)"], ["proof (state)\nthis:\n  wf_mformula \\<sigma> j ?n ?R \\<phi> ?\\<phi>' \\<Longrightarrow>\n  case meval ?n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) ?n ?R \\<phi>\\<^sub>n ?\\<phi>' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable ?n (fv ?\\<phi>') (mem_restr ?R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i ?\\<phi>'))\n     [Monitor.progress \\<sigma> ?\\<phi>' j..<\n      Monitor.progress \\<sigma> ?\\<phi>' (Suc j)]\n     xs\n  wf_mformula \\<sigma> j n R (MExists \\<phi>) \\<phi>'\n\ngoal (5 subgoals):\n 1. \\<And>\\<phi> n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MExists \\<phi>) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j) (MExists \\<phi>) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>x1a \\<phi> x3 x4 x5a n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MPrev x1a \\<phi> x3 x4 x5a)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev x1a \\<phi> x3 x4 x5a) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 3. \\<And>x1a \\<phi> x3 x4 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MNext x1a \\<phi> x3 x4) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext x1a \\<phi> x3 x4) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 4. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 5. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "from MExists.prems"], ["proof (chain)\npicking this:\n  wf_mformula \\<sigma> j n R (MExists \\<phi>) \\<phi>'", "show ?case"], ["proof (prove)\nusing this:\n  wf_mformula \\<sigma> j n R (MExists \\<phi>) \\<phi>'\n\ngoal (1 subgoal):\n 1. case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n          (MExists \\<phi>) of\n    (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n      wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n      list_all2\n       (\\<lambda>i.\n           qtable n (fv \\<phi>') (mem_restr R)\n            (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n       [Monitor.progress \\<sigma> \\<phi>' j..<\n        Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n       xs", "by (cases pred: wf_mformula)\n      (force simp: list.rel_map fvi_Suc sat_fvi_cong nth_Cons'\n        intro!: wf_mformula.Exists dest!: MExists.IH qtable_project_fv \n        elim!: list.rel_mono_strong table_fvi_tl qtable_cong sat_fvi_cong[THEN iffD1, rotated -1]\n        split: if_splits)+"], ["proof (state)\nthis:\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) (MExists \\<phi>) of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n     [Monitor.progress \\<sigma> \\<phi>' j..<\n      Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n     xs\n\ngoal (4 subgoals):\n 1. \\<And>x1a \\<phi> x3 x4 x5a n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MPrev x1a \\<phi> x3 x4 x5a)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev x1a \\<phi> x3 x4 x5a) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>x1a \\<phi> x3 x4 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MNext x1a \\<phi> x3 x4) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext x1a \\<phi> x3 x4) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 3. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 4. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1a \\<phi> x3 x4 x5a n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MPrev x1a \\<phi> x3 x4 x5a)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev x1a \\<phi> x3 x4 x5a) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>x1a \\<phi> x3 x4 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MNext x1a \\<phi> x3 x4) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext x1a \\<phi> x3 x4) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 3. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 4. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "case (MPrev I \\<phi> first buf nts)"], ["proof (state)\nthis:\n  wf_mformula \\<sigma> j ?n ?R \\<phi> ?\\<phi>' \\<Longrightarrow>\n  case meval ?n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) ?n ?R \\<phi>\\<^sub>n ?\\<phi>' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable ?n (fv ?\\<phi>') (mem_restr ?R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i ?\\<phi>'))\n     [Monitor.progress \\<sigma> ?\\<phi>' j..<\n      Monitor.progress \\<sigma> ?\\<phi>' (Suc j)]\n     xs\n  wf_mformula \\<sigma> j n R (MPrev I \\<phi> first buf nts) \\<phi>'\n\ngoal (4 subgoals):\n 1. \\<And>x1a \\<phi> x3 x4 x5a n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MPrev x1a \\<phi> x3 x4 x5a)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev x1a \\<phi> x3 x4 x5a) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>x1a \\<phi> x3 x4 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MNext x1a \\<phi> x3 x4) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext x1a \\<phi> x3 x4) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 3. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 4. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "from MPrev.prems"], ["proof (chain)\npicking this:\n  wf_mformula \\<sigma> j n R (MPrev I \\<phi> first buf nts) \\<phi>'", "show ?case"], ["proof (prove)\nusing this:\n  wf_mformula \\<sigma> j n R (MPrev I \\<phi> first buf nts) \\<phi>'\n\ngoal (1 subgoal):\n 1. case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n          (MPrev I \\<phi> first buf nts) of\n    (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n      wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n      list_all2\n       (\\<lambda>i.\n           qtable n (fv \\<phi>') (mem_restr R)\n            (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n       [Monitor.progress \\<sigma> \\<phi>' j..<\n        Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n       xs", "proof (cases pred: wf_mformula)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<phi>' =\n                formula.Neg (formula.Eq (trm.Const x) (trm.Const y));\n        MPrev I \\<phi> first buf nts =\n        MRel (neq_rel n (trm.Const x) (trm.Const y))\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev I \\<phi> first buf nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi>'.\n       \\<lbrakk>\\<phi>' = formula.Prev I \\<phi>';\n        wf_mformula \\<sigma> j n R \\<phi> \\<phi>'; first = (j = 0);\n        list_all2\n         (\\<lambda>i.\n             qtable n (fv \\<phi>') (mem_restr R)\n              (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n         [min (Monitor.progress \\<sigma> \\<phi>' j) (j - 1)..<\n          Monitor.progress \\<sigma> \\<phi>' j]\n         buf;\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n         [min (Monitor.progress \\<sigma> \\<phi>' j) (j - 1)..<j]\n         nts\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev I \\<phi> first buf nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "case (Prev \\<psi>)"], ["proof (state)\nthis:\n  \\<phi>' = formula.Prev I \\<psi>\n  wf_mformula \\<sigma> j n R \\<phi> \\<psi>\n  first = (j = 0)\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<psi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n   [min (Monitor.progress \\<sigma> \\<psi> j) (j - 1)..<\n    Monitor.progress \\<sigma> \\<psi> j]\n   buf\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<psi> j) (j - 1)..<j] nts\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<phi>' =\n                formula.Neg (formula.Eq (trm.Const x) (trm.Const y));\n        MPrev I \\<phi> first buf nts =\n        MRel (neq_rel n (trm.Const x) (trm.Const y))\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev I \\<phi> first buf nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi>'.\n       \\<lbrakk>\\<phi>' = formula.Prev I \\<phi>';\n        wf_mformula \\<sigma> j n R \\<phi> \\<phi>'; first = (j = 0);\n        list_all2\n         (\\<lambda>i.\n             qtable n (fv \\<phi>') (mem_restr R)\n              (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n         [min (Monitor.progress \\<sigma> \\<phi>' j) (j - 1)..<\n          Monitor.progress \\<sigma> \\<phi>' j]\n         buf;\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n         [min (Monitor.progress \\<sigma> \\<phi>' j) (j - 1)..<j]\n         nts\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev I \\<phi> first buf nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "let ?xs = \"fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<phi>' =\n                formula.Neg (formula.Eq (trm.Const x) (trm.Const y));\n        MPrev I \\<phi> first buf nts =\n        MRel (neq_rel n (trm.Const x) (trm.Const y))\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev I \\<phi> first buf nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi>'.\n       \\<lbrakk>\\<phi>' = formula.Prev I \\<phi>';\n        wf_mformula \\<sigma> j n R \\<phi> \\<phi>'; first = (j = 0);\n        list_all2\n         (\\<lambda>i.\n             qtable n (fv \\<phi>') (mem_restr R)\n              (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n         [min (Monitor.progress \\<sigma> \\<phi>' j) (j - 1)..<\n          Monitor.progress \\<sigma> \\<phi>' j]\n         buf;\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n         [min (Monitor.progress \\<sigma> \\<phi>' j) (j - 1)..<j]\n         nts\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev I \\<phi> first buf nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "let ?\\<phi> = \"snd (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<phi>' =\n                formula.Neg (formula.Eq (trm.Const x) (trm.Const y));\n        MPrev I \\<phi> first buf nts =\n        MRel (neq_rel n (trm.Const x) (trm.Const y))\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev I \\<phi> first buf nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi>'.\n       \\<lbrakk>\\<phi>' = formula.Prev I \\<phi>';\n        wf_mformula \\<sigma> j n R \\<phi> \\<phi>'; first = (j = 0);\n        list_all2\n         (\\<lambda>i.\n             qtable n (fv \\<phi>') (mem_restr R)\n              (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n         [min (Monitor.progress \\<sigma> \\<phi>' j) (j - 1)..<\n          Monitor.progress \\<sigma> \\<phi>' j]\n         buf;\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n         [min (Monitor.progress \\<sigma> \\<phi>' j) (j - 1)..<j]\n         nts\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev I \\<phi> first buf nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "let ?ls = \"fst (mprev_next I (buf @ ?xs) (nts @ [\\<tau> \\<sigma> j]))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<phi>' =\n                formula.Neg (formula.Eq (trm.Const x) (trm.Const y));\n        MPrev I \\<phi> first buf nts =\n        MRel (neq_rel n (trm.Const x) (trm.Const y))\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev I \\<phi> first buf nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi>'.\n       \\<lbrakk>\\<phi>' = formula.Prev I \\<phi>';\n        wf_mformula \\<sigma> j n R \\<phi> \\<phi>'; first = (j = 0);\n        list_all2\n         (\\<lambda>i.\n             qtable n (fv \\<phi>') (mem_restr R)\n              (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n         [min (Monitor.progress \\<sigma> \\<phi>' j) (j - 1)..<\n          Monitor.progress \\<sigma> \\<phi>' j]\n         buf;\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n         [min (Monitor.progress \\<sigma> \\<phi>' j) (j - 1)..<j]\n         nts\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev I \\<phi> first buf nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "let ?rs = \"fst (snd (mprev_next I (buf @ ?xs) (nts @ [\\<tau> \\<sigma> j])))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<phi>' =\n                formula.Neg (formula.Eq (trm.Const x) (trm.Const y));\n        MPrev I \\<phi> first buf nts =\n        MRel (neq_rel n (trm.Const x) (trm.Const y))\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev I \\<phi> first buf nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi>'.\n       \\<lbrakk>\\<phi>' = formula.Prev I \\<phi>';\n        wf_mformula \\<sigma> j n R \\<phi> \\<phi>'; first = (j = 0);\n        list_all2\n         (\\<lambda>i.\n             qtable n (fv \\<phi>') (mem_restr R)\n              (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n         [min (Monitor.progress \\<sigma> \\<phi>' j) (j - 1)..<\n          Monitor.progress \\<sigma> \\<phi>' j]\n         buf;\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n         [min (Monitor.progress \\<sigma> \\<phi>' j) (j - 1)..<j]\n         nts\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev I \\<phi> first buf nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "let ?ts = \"snd (snd (mprev_next I (buf @ ?xs) (nts @ [\\<tau> \\<sigma> j])))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<phi>' =\n                formula.Neg (formula.Eq (trm.Const x) (trm.Const y));\n        MPrev I \\<phi> first buf nts =\n        MRel (neq_rel n (trm.Const x) (trm.Const y))\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev I \\<phi> first buf nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi>'.\n       \\<lbrakk>\\<phi>' = formula.Prev I \\<phi>';\n        wf_mformula \\<sigma> j n R \\<phi> \\<phi>'; first = (j = 0);\n        list_all2\n         (\\<lambda>i.\n             qtable n (fv \\<phi>') (mem_restr R)\n              (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n         [min (Monitor.progress \\<sigma> \\<phi>' j) (j - 1)..<\n          Monitor.progress \\<sigma> \\<phi>' j]\n         buf;\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n         [min (Monitor.progress \\<sigma> \\<phi>' j) (j - 1)..<j]\n         nts\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev I \\<phi> first buf nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "let ?P = \"\\<lambda>i X. qtable n (fv \\<psi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>) X\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<phi>' =\n                formula.Neg (formula.Eq (trm.Const x) (trm.Const y));\n        MPrev I \\<phi> first buf nts =\n        MRel (neq_rel n (trm.Const x) (trm.Const y))\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev I \\<phi> first buf nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi>'.\n       \\<lbrakk>\\<phi>' = formula.Prev I \\<phi>';\n        wf_mformula \\<sigma> j n R \\<phi> \\<phi>'; first = (j = 0);\n        list_all2\n         (\\<lambda>i.\n             qtable n (fv \\<phi>') (mem_restr R)\n              (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n         [min (Monitor.progress \\<sigma> \\<phi>' j) (j - 1)..<\n          Monitor.progress \\<sigma> \\<phi>' j]\n         buf;\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n         [min (Monitor.progress \\<sigma> \\<phi>' j) (j - 1)..<j]\n         nts\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev I \\<phi> first buf nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "let ?min = \"min (progress \\<sigma> \\<psi> (Suc j)) (Suc j - 1)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<phi>' =\n                formula.Neg (formula.Eq (trm.Const x) (trm.Const y));\n        MPrev I \\<phi> first buf nts =\n        MRel (neq_rel n (trm.Const x) (trm.Const y))\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev I \\<phi> first buf nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi>'.\n       \\<lbrakk>\\<phi>' = formula.Prev I \\<phi>';\n        wf_mformula \\<sigma> j n R \\<phi> \\<phi>'; first = (j = 0);\n        list_all2\n         (\\<lambda>i.\n             qtable n (fv \\<phi>') (mem_restr R)\n              (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n         [min (Monitor.progress \\<sigma> \\<phi>' j) (j - 1)..<\n          Monitor.progress \\<sigma> \\<phi>' j]\n         buf;\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n         [min (Monitor.progress \\<sigma> \\<phi>' j) (j - 1)..<j]\n         nts\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev I \\<phi> first buf nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "from Prev MPrev.IH[of n R \\<psi>]"], ["proof (chain)\npicking this:\n  \\<phi>' = formula.Prev I \\<psi>\n  wf_mformula \\<sigma> j n R \\<phi> \\<psi>\n  first = (j = 0)\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<psi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n   [min (Monitor.progress \\<sigma> \\<psi> j) (j - 1)..<\n    Monitor.progress \\<sigma> \\<psi> j]\n   buf\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<psi> j) (j - 1)..<j] nts\n  wf_mformula \\<sigma> j n R \\<phi> \\<psi> \\<Longrightarrow>\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<psi> \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<psi>) (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n     [Monitor.progress \\<sigma> \\<psi> j..<\n      Monitor.progress \\<sigma> \\<psi> (Suc j)]\n     xs", "have IH: \"wf_mformula \\<sigma> (Suc j) n R ?\\<phi> \\<psi>\" and\n      \"list_all2 ?P [progress \\<sigma> \\<psi> j..<progress \\<sigma> \\<psi> (Suc j)] ?xs\""], ["proof (prove)\nusing this:\n  \\<phi>' = formula.Prev I \\<psi>\n  wf_mformula \\<sigma> j n R \\<phi> \\<psi>\n  first = (j = 0)\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<psi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n   [min (Monitor.progress \\<sigma> \\<psi> j) (j - 1)..<\n    Monitor.progress \\<sigma> \\<psi> j]\n   buf\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<psi> j) (j - 1)..<j] nts\n  wf_mformula \\<sigma> j n R \\<phi> \\<psi> \\<Longrightarrow>\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<psi> \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<psi>) (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n     [Monitor.progress \\<sigma> \\<psi> j..<\n      Monitor.progress \\<sigma> \\<psi> (Suc j)]\n     xs\n\ngoal (1 subgoal):\n 1. wf_mformula \\<sigma> (Suc j) n R\n     (snd (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>))\n     \\<psi> &&&\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<psi>) (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n     [Monitor.progress \\<sigma> \\<psi> j..<\n      Monitor.progress \\<sigma> \\<psi> (Suc j)]\n     (fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>))", "by auto"], ["proof (state)\nthis:\n  wf_mformula \\<sigma> (Suc j) n R\n   (snd (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>)) \\<psi>\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<psi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n   [Monitor.progress \\<sigma> \\<psi> j..<\n    Monitor.progress \\<sigma> \\<psi> (Suc j)]\n   (fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>))\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<phi>' =\n                formula.Neg (formula.Eq (trm.Const x) (trm.Const y));\n        MPrev I \\<phi> first buf nts =\n        MRel (neq_rel n (trm.Const x) (trm.Const y))\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev I \\<phi> first buf nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi>'.\n       \\<lbrakk>\\<phi>' = formula.Prev I \\<phi>';\n        wf_mformula \\<sigma> j n R \\<phi> \\<phi>'; first = (j = 0);\n        list_all2\n         (\\<lambda>i.\n             qtable n (fv \\<phi>') (mem_restr R)\n              (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n         [min (Monitor.progress \\<sigma> \\<phi>' j) (j - 1)..<\n          Monitor.progress \\<sigma> \\<phi>' j]\n         buf;\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n         [min (Monitor.progress \\<sigma> \\<phi>' j) (j - 1)..<j]\n         nts\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev I \\<phi> first buf nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "with Prev(4,5)"], ["proof (chain)\npicking this:\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<psi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n   [min (Monitor.progress \\<sigma> \\<psi> j) (j - 1)..<\n    Monitor.progress \\<sigma> \\<psi> j]\n   buf\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<psi> j) (j - 1)..<j] nts\n  wf_mformula \\<sigma> (Suc j) n R\n   (snd (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>)) \\<psi>\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<psi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n   [Monitor.progress \\<sigma> \\<psi> j..<\n    Monitor.progress \\<sigma> \\<psi> (Suc j)]\n   (fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>))", "have \"list_all2 (\\<lambda>i X. if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then ?P i X else X = empty_table)\n        [min (progress \\<sigma> \\<psi> j) (j - 1)..<?min] ?ls \\<and>\n       list_all2 ?P [?min..<progress \\<sigma> \\<psi> (Suc j)] ?rs \\<and>\n       list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [?min..<Suc j] ?ts\""], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<psi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n   [min (Monitor.progress \\<sigma> \\<psi> j) (j - 1)..<\n    Monitor.progress \\<sigma> \\<psi> j]\n   buf\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<psi> j) (j - 1)..<j] nts\n  wf_mformula \\<sigma> (Suc j) n R\n   (snd (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>)) \\<psi>\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<psi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n   [Monitor.progress \\<sigma> \\<psi> j..<\n    Monitor.progress \\<sigma> \\<psi> (Suc j)]\n   (fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>))\n\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>i X.\n         if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I\n         then qtable n (fv \\<psi>) (mem_restr R)\n               (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>) X\n         else X = empty_table)\n     [min (Monitor.progress \\<sigma> \\<psi> j) (j - 1)..<\n      min (Monitor.progress \\<sigma> \\<psi> (Suc j)) (Suc j - 1)]\n     (fst (mprev_next I\n            (buf @\n             fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>))\n            (nts @ [\\<tau> \\<sigma> j]))) \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<psi>) (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n     [min (Monitor.progress \\<sigma> \\<psi> (Suc j)) (Suc j - 1)..<\n      Monitor.progress \\<sigma> \\<psi> (Suc j)]\n     (fst (snd (mprev_next I\n                 (buf @\n                  fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                        \\<phi>))\n                 (nts @ [\\<tau> \\<sigma> j])))) \\<and>\n    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n     [min (Monitor.progress \\<sigma> \\<psi> (Suc j)) (Suc j - 1)..<Suc j]\n     (snd (snd (mprev_next I\n                 (buf @\n                  fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                        \\<phi>))\n                 (nts @ [\\<tau> \\<sigma> j]))))", "by (intro mprev)\n        (auto simp: progress_mono progress_le simp del: \n          intro!: list_all2_upt_append list_all2_appendI order.trans[OF min.cobounded1])"], ["proof (state)\nthis:\n  list_all2\n   (\\<lambda>i X.\n       if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I\n       then qtable n (fv \\<psi>) (mem_restr R)\n             (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>) X\n       else X = empty_table)\n   [min (Monitor.progress \\<sigma> \\<psi> j) (j - 1)..<\n    min (Monitor.progress \\<sigma> \\<psi> (Suc j)) (Suc j - 1)]\n   (fst (mprev_next I\n          (buf @\n           fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>))\n          (nts @ [\\<tau> \\<sigma> j]))) \\<and>\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<psi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n   [min (Monitor.progress \\<sigma> \\<psi> (Suc j)) (Suc j - 1)..<\n    Monitor.progress \\<sigma> \\<psi> (Suc j)]\n   (fst (snd (mprev_next I\n               (buf @\n                fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                      \\<phi>))\n               (nts @ [\\<tau> \\<sigma> j])))) \\<and>\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<psi> (Suc j)) (Suc j - 1)..<Suc j]\n   (snd (snd (mprev_next I\n               (buf @\n                fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                      \\<phi>))\n               (nts @ [\\<tau> \\<sigma> j]))))\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<phi>' =\n                formula.Neg (formula.Eq (trm.Const x) (trm.Const y));\n        MPrev I \\<phi> first buf nts =\n        MRel (neq_rel n (trm.Const x) (trm.Const y))\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev I \\<phi> first buf nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi>'.\n       \\<lbrakk>\\<phi>' = formula.Prev I \\<phi>';\n        wf_mformula \\<sigma> j n R \\<phi> \\<phi>'; first = (j = 0);\n        list_all2\n         (\\<lambda>i.\n             qtable n (fv \\<phi>') (mem_restr R)\n              (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n         [min (Monitor.progress \\<sigma> \\<phi>' j) (j - 1)..<\n          Monitor.progress \\<sigma> \\<phi>' j]\n         buf;\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n         [min (Monitor.progress \\<sigma> \\<phi>' j) (j - 1)..<j]\n         nts\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev I \\<phi> first buf nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "moreover"], ["proof (state)\nthis:\n  list_all2\n   (\\<lambda>i X.\n       if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I\n       then qtable n (fv \\<psi>) (mem_restr R)\n             (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>) X\n       else X = empty_table)\n   [min (Monitor.progress \\<sigma> \\<psi> j) (j - 1)..<\n    min (Monitor.progress \\<sigma> \\<psi> (Suc j)) (Suc j - 1)]\n   (fst (mprev_next I\n          (buf @\n           fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>))\n          (nts @ [\\<tau> \\<sigma> j]))) \\<and>\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<psi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n   [min (Monitor.progress \\<sigma> \\<psi> (Suc j)) (Suc j - 1)..<\n    Monitor.progress \\<sigma> \\<psi> (Suc j)]\n   (fst (snd (mprev_next I\n               (buf @\n                fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                      \\<phi>))\n               (nts @ [\\<tau> \\<sigma> j])))) \\<and>\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<psi> (Suc j)) (Suc j - 1)..<Suc j]\n   (snd (snd (mprev_next I\n               (buf @\n                fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                      \\<phi>))\n               (nts @ [\\<tau> \\<sigma> j]))))\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<phi>' =\n                formula.Neg (formula.Eq (trm.Const x) (trm.Const y));\n        MPrev I \\<phi> first buf nts =\n        MRel (neq_rel n (trm.Const x) (trm.Const y))\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev I \\<phi> first buf nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi>'.\n       \\<lbrakk>\\<phi>' = formula.Prev I \\<phi>';\n        wf_mformula \\<sigma> j n R \\<phi> \\<phi>'; first = (j = 0);\n        list_all2\n         (\\<lambda>i.\n             qtable n (fv \\<phi>') (mem_restr R)\n              (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n         [min (Monitor.progress \\<sigma> \\<phi>' j) (j - 1)..<\n          Monitor.progress \\<sigma> \\<phi>' j]\n         buf;\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n         [min (Monitor.progress \\<sigma> \\<phi>' j) (j - 1)..<j]\n         nts\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev I \\<phi> first buf nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "have \"min (Suc (progress \\<sigma> \\<psi> j)) j = Suc (min (progress \\<sigma> \\<psi> j) (j-1))\" if \"j > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (Suc (Monitor.progress \\<sigma> \\<psi> j)) j =\n    Suc (min (Monitor.progress \\<sigma> \\<psi> j) (j - 1))", "using that"], ["proof (prove)\nusing this:\n  0 < j\n\ngoal (1 subgoal):\n 1. min (Suc (Monitor.progress \\<sigma> \\<psi> j)) j =\n    Suc (min (Monitor.progress \\<sigma> \\<psi> j) (j - 1))", "by auto"], ["proof (state)\nthis:\n  0 < j \\<Longrightarrow>\n  min (Suc (Monitor.progress \\<sigma> \\<psi> j)) j =\n  Suc (min (Monitor.progress \\<sigma> \\<psi> j) (j - 1))\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<phi>' =\n                formula.Neg (formula.Eq (trm.Const x) (trm.Const y));\n        MPrev I \\<phi> first buf nts =\n        MRel (neq_rel n (trm.Const x) (trm.Const y))\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev I \\<phi> first buf nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi>'.\n       \\<lbrakk>\\<phi>' = formula.Prev I \\<phi>';\n        wf_mformula \\<sigma> j n R \\<phi> \\<phi>'; first = (j = 0);\n        list_all2\n         (\\<lambda>i.\n             qtable n (fv \\<phi>') (mem_restr R)\n              (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n         [min (Monitor.progress \\<sigma> \\<phi>' j) (j - 1)..<\n          Monitor.progress \\<sigma> \\<phi>' j]\n         buf;\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n         [min (Monitor.progress \\<sigma> \\<phi>' j) (j - 1)..<j]\n         nts\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev I \\<phi> first buf nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "ultimately"], ["proof (chain)\npicking this:\n  list_all2\n   (\\<lambda>i X.\n       if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I\n       then qtable n (fv \\<psi>) (mem_restr R)\n             (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>) X\n       else X = empty_table)\n   [min (Monitor.progress \\<sigma> \\<psi> j) (j - 1)..<\n    min (Monitor.progress \\<sigma> \\<psi> (Suc j)) (Suc j - 1)]\n   (fst (mprev_next I\n          (buf @\n           fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>))\n          (nts @ [\\<tau> \\<sigma> j]))) \\<and>\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<psi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n   [min (Monitor.progress \\<sigma> \\<psi> (Suc j)) (Suc j - 1)..<\n    Monitor.progress \\<sigma> \\<psi> (Suc j)]\n   (fst (snd (mprev_next I\n               (buf @\n                fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                      \\<phi>))\n               (nts @ [\\<tau> \\<sigma> j])))) \\<and>\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<psi> (Suc j)) (Suc j - 1)..<Suc j]\n   (snd (snd (mprev_next I\n               (buf @\n                fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                      \\<phi>))\n               (nts @ [\\<tau> \\<sigma> j]))))\n  0 < j \\<Longrightarrow>\n  min (Suc (Monitor.progress \\<sigma> \\<psi> j)) j =\n  Suc (min (Monitor.progress \\<sigma> \\<psi> j) (j - 1))", "show ?thesis"], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>i X.\n       if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I\n       then qtable n (fv \\<psi>) (mem_restr R)\n             (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>) X\n       else X = empty_table)\n   [min (Monitor.progress \\<sigma> \\<psi> j) (j - 1)..<\n    min (Monitor.progress \\<sigma> \\<psi> (Suc j)) (Suc j - 1)]\n   (fst (mprev_next I\n          (buf @\n           fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>))\n          (nts @ [\\<tau> \\<sigma> j]))) \\<and>\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<psi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n   [min (Monitor.progress \\<sigma> \\<psi> (Suc j)) (Suc j - 1)..<\n    Monitor.progress \\<sigma> \\<psi> (Suc j)]\n   (fst (snd (mprev_next I\n               (buf @\n                fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                      \\<phi>))\n               (nts @ [\\<tau> \\<sigma> j])))) \\<and>\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<psi> (Suc j)) (Suc j - 1)..<Suc j]\n   (snd (snd (mprev_next I\n               (buf @\n                fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                      \\<phi>))\n               (nts @ [\\<tau> \\<sigma> j]))))\n  0 < j \\<Longrightarrow>\n  min (Suc (Monitor.progress \\<sigma> \\<psi> j)) j =\n  Suc (min (Monitor.progress \\<sigma> \\<psi> j) (j - 1))\n\ngoal (1 subgoal):\n 1. case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n          (MPrev I \\<phi> first buf nts) of\n    (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n      wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n      list_all2\n       (\\<lambda>i.\n           qtable n (fv \\<phi>') (mem_restr R)\n            (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n       [Monitor.progress \\<sigma> \\<phi>' j..<\n        Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n       xs", "using progress_mono[of j \"Suc j\" \\<sigma> \\<psi>] Prev(1,3) IH"], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>i X.\n       if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I\n       then qtable n (fv \\<psi>) (mem_restr R)\n             (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>) X\n       else X = empty_table)\n   [min (Monitor.progress \\<sigma> \\<psi> j) (j - 1)..<\n    min (Monitor.progress \\<sigma> \\<psi> (Suc j)) (Suc j - 1)]\n   (fst (mprev_next I\n          (buf @\n           fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>))\n          (nts @ [\\<tau> \\<sigma> j]))) \\<and>\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<psi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n   [min (Monitor.progress \\<sigma> \\<psi> (Suc j)) (Suc j - 1)..<\n    Monitor.progress \\<sigma> \\<psi> (Suc j)]\n   (fst (snd (mprev_next I\n               (buf @\n                fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                      \\<phi>))\n               (nts @ [\\<tau> \\<sigma> j])))) \\<and>\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<psi> (Suc j)) (Suc j - 1)..<Suc j]\n   (snd (snd (mprev_next I\n               (buf @\n                fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                      \\<phi>))\n               (nts @ [\\<tau> \\<sigma> j]))))\n  0 < j \\<Longrightarrow>\n  min (Suc (Monitor.progress \\<sigma> \\<psi> j)) j =\n  Suc (min (Monitor.progress \\<sigma> \\<psi> j) (j - 1))\n  j \\<le> Suc j \\<Longrightarrow>\n  Monitor.progress \\<sigma> \\<psi> j\n  \\<le> Monitor.progress \\<sigma> \\<psi> (Suc j)\n  \\<phi>' = formula.Prev I \\<psi>\n  first = (j = 0)\n  wf_mformula \\<sigma> (Suc j) n R\n   (snd (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>)) \\<psi>\n\ngoal (1 subgoal):\n 1. case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n          (MPrev I \\<phi> first buf nts) of\n    (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n      wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n      list_all2\n       (\\<lambda>i.\n           qtable n (fv \\<phi>') (mem_restr R)\n            (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n       [Monitor.progress \\<sigma> \\<phi>' j..<\n        Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n       xs", "by (auto simp: map_Suc_upt[symmetric] upt_Suc[of 0] list.rel_map qtable_empty_iff\n        simp del: upt_Suc elim!: wf_mformula.Prev list.rel_mono_strong\n        split: prod.split if_split_asm)"], ["proof (state)\nthis:\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n        (MPrev I \\<phi> first buf nts) of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n     [Monitor.progress \\<sigma> \\<phi>' j..<\n      Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n     xs\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<phi>' =\n                formula.Neg (formula.Eq (trm.Const x) (trm.Const y));\n        MPrev I \\<phi> first buf nts =\n        MRel (neq_rel n (trm.Const x) (trm.Const y))\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MPrev I \\<phi> first buf nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "qed simp"], ["proof (state)\nthis:\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n        (MPrev I \\<phi> first buf nts) of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n     [Monitor.progress \\<sigma> \\<phi>' j..<\n      Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n     xs\n\ngoal (3 subgoals):\n 1. \\<And>x1a \\<phi> x3 x4 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MNext x1a \\<phi> x3 x4) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext x1a \\<phi> x3 x4) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 3. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1a \\<phi> x3 x4 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MNext x1a \\<phi> x3 x4) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext x1a \\<phi> x3 x4) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 3. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "case (MNext I \\<phi> first nts)"], ["proof (state)\nthis:\n  wf_mformula \\<sigma> j ?n ?R \\<phi> ?\\<phi>' \\<Longrightarrow>\n  case meval ?n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) ?n ?R \\<phi>\\<^sub>n ?\\<phi>' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable ?n (fv ?\\<phi>') (mem_restr ?R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i ?\\<phi>'))\n     [Monitor.progress \\<sigma> ?\\<phi>' j..<\n      Monitor.progress \\<sigma> ?\\<phi>' (Suc j)]\n     xs\n  wf_mformula \\<sigma> j n R (MNext I \\<phi> first nts) \\<phi>'\n\ngoal (3 subgoals):\n 1. \\<And>x1a \\<phi> x3 x4 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi> of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        wf_mformula \\<sigma> j n R (MNext x1a \\<phi> x3 x4) \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext x1a \\<phi> x3 x4) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 3. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "from MNext.prems"], ["proof (chain)\npicking this:\n  wf_mformula \\<sigma> j n R (MNext I \\<phi> first nts) \\<phi>'", "show ?case"], ["proof (prove)\nusing this:\n  wf_mformula \\<sigma> j n R (MNext I \\<phi> first nts) \\<phi>'\n\ngoal (1 subgoal):\n 1. case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n          (MNext I \\<phi> first nts) of\n    (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n      wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n      list_all2\n       (\\<lambda>i.\n           qtable n (fv \\<phi>') (mem_restr R)\n            (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n       [Monitor.progress \\<sigma> \\<phi>' j..<\n        Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n       xs", "proof (cases pred: wf_mformula)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<phi>' =\n                formula.Neg (formula.Eq (trm.Const x) (trm.Const y));\n        MNext I \\<phi> first nts =\n        MRel (neq_rel n (trm.Const x) (trm.Const y))\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext I \\<phi> first nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi>'.\n       \\<lbrakk>\\<phi>' = formula.Next I \\<phi>';\n        wf_mformula \\<sigma> j n R \\<phi> \\<phi>';\n        first = (Monitor.progress \\<sigma> \\<phi>' j = 0);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n         [Monitor.progress \\<sigma> \\<phi>' j - 1..<j] nts\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext I \\<phi> first nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "case (Next \\<psi>)"], ["proof (state)\nthis:\n  \\<phi>' = formula.Next I \\<psi>\n  wf_mformula \\<sigma> j n R \\<phi> \\<psi>\n  first = (Monitor.progress \\<sigma> \\<psi> j = 0)\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [Monitor.progress \\<sigma> \\<psi> j - 1..<j] nts\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<phi>' =\n                formula.Neg (formula.Eq (trm.Const x) (trm.Const y));\n        MNext I \\<phi> first nts =\n        MRel (neq_rel n (trm.Const x) (trm.Const y))\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext I \\<phi> first nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi>'.\n       \\<lbrakk>\\<phi>' = formula.Next I \\<phi>';\n        wf_mformula \\<sigma> j n R \\<phi> \\<phi>';\n        first = (Monitor.progress \\<sigma> \\<phi>' j = 0);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n         [Monitor.progress \\<sigma> \\<phi>' j - 1..<j] nts\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext I \\<phi> first nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "have min[simp]:\n      \"min (progress \\<sigma> \\<psi> j - Suc 0) (j - Suc 0) = progress \\<sigma> \\<psi> j - Suc 0\"\n      \"min (progress \\<sigma> \\<psi> (Suc j) - Suc 0) j = progress \\<sigma> \\<psi> (Suc j) - Suc 0\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. min (Monitor.progress \\<sigma> \\<psi> j - Suc 0) (j - Suc 0) =\n    Monitor.progress \\<sigma> \\<psi> j - Suc 0 &&&\n    min (Monitor.progress \\<sigma> \\<psi> (Suc j) - Suc 0) j =\n    Monitor.progress \\<sigma> \\<psi> (Suc j) - Suc 0", "using progress_le[of \\<sigma> \\<psi> j] progress_le[of \\<sigma> \\<psi> \"Suc j\"]"], ["proof (prove)\nusing this:\n  Monitor.progress \\<sigma> \\<psi> j \\<le> j\n  Monitor.progress \\<sigma> \\<psi> (Suc j) \\<le> Suc j\n\ngoal (1 subgoal):\n 1. min (Monitor.progress \\<sigma> \\<psi> j - Suc 0) (j - Suc 0) =\n    Monitor.progress \\<sigma> \\<psi> j - Suc 0 &&&\n    min (Monitor.progress \\<sigma> \\<psi> (Suc j) - Suc 0) j =\n    Monitor.progress \\<sigma> \\<psi> (Suc j) - Suc 0", "by auto"], ["proof (state)\nthis:\n  min (Monitor.progress \\<sigma> \\<psi> ?j - Suc 0) (?j - Suc 0) =\n  Monitor.progress \\<sigma> \\<psi> ?j - Suc 0\n  min (Monitor.progress \\<sigma> \\<psi> (Suc ?j) - Suc 0) ?j =\n  Monitor.progress \\<sigma> \\<psi> (Suc ?j) - Suc 0\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<phi>' =\n                formula.Neg (formula.Eq (trm.Const x) (trm.Const y));\n        MNext I \\<phi> first nts =\n        MRel (neq_rel n (trm.Const x) (trm.Const y))\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext I \\<phi> first nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi>'.\n       \\<lbrakk>\\<phi>' = formula.Next I \\<phi>';\n        wf_mformula \\<sigma> j n R \\<phi> \\<phi>';\n        first = (Monitor.progress \\<sigma> \\<phi>' j = 0);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n         [Monitor.progress \\<sigma> \\<phi>' j - 1..<j] nts\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext I \\<phi> first nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "let ?xs = \"fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<phi>' =\n                formula.Neg (formula.Eq (trm.Const x) (trm.Const y));\n        MNext I \\<phi> first nts =\n        MRel (neq_rel n (trm.Const x) (trm.Const y))\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext I \\<phi> first nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi>'.\n       \\<lbrakk>\\<phi>' = formula.Next I \\<phi>';\n        wf_mformula \\<sigma> j n R \\<phi> \\<phi>';\n        first = (Monitor.progress \\<sigma> \\<phi>' j = 0);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n         [Monitor.progress \\<sigma> \\<phi>' j - 1..<j] nts\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext I \\<phi> first nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "let ?ys = \"case (?xs, first) of (_ # xs, True) \\<Rightarrow> xs | _ \\<Rightarrow> ?xs\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<phi>' =\n                formula.Neg (formula.Eq (trm.Const x) (trm.Const y));\n        MNext I \\<phi> first nts =\n        MRel (neq_rel n (trm.Const x) (trm.Const y))\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext I \\<phi> first nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi>'.\n       \\<lbrakk>\\<phi>' = formula.Next I \\<phi>';\n        wf_mformula \\<sigma> j n R \\<phi> \\<phi>';\n        first = (Monitor.progress \\<sigma> \\<phi>' j = 0);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n         [Monitor.progress \\<sigma> \\<phi>' j - 1..<j] nts\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext I \\<phi> first nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "let ?\\<phi> = \"snd (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<phi>' =\n                formula.Neg (formula.Eq (trm.Const x) (trm.Const y));\n        MNext I \\<phi> first nts =\n        MRel (neq_rel n (trm.Const x) (trm.Const y))\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext I \\<phi> first nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi>'.\n       \\<lbrakk>\\<phi>' = formula.Next I \\<phi>';\n        wf_mformula \\<sigma> j n R \\<phi> \\<phi>';\n        first = (Monitor.progress \\<sigma> \\<phi>' j = 0);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n         [Monitor.progress \\<sigma> \\<phi>' j - 1..<j] nts\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext I \\<phi> first nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "let ?ls = \"fst (mprev_next I ?ys (nts @ [\\<tau> \\<sigma> j]))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<phi>' =\n                formula.Neg (formula.Eq (trm.Const x) (trm.Const y));\n        MNext I \\<phi> first nts =\n        MRel (neq_rel n (trm.Const x) (trm.Const y))\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext I \\<phi> first nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi>'.\n       \\<lbrakk>\\<phi>' = formula.Next I \\<phi>';\n        wf_mformula \\<sigma> j n R \\<phi> \\<phi>';\n        first = (Monitor.progress \\<sigma> \\<phi>' j = 0);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n         [Monitor.progress \\<sigma> \\<phi>' j - 1..<j] nts\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext I \\<phi> first nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "let ?rs = \"fst (snd (mprev_next I ?ys (nts @ [\\<tau> \\<sigma> j])))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<phi>' =\n                formula.Neg (formula.Eq (trm.Const x) (trm.Const y));\n        MNext I \\<phi> first nts =\n        MRel (neq_rel n (trm.Const x) (trm.Const y))\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext I \\<phi> first nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi>'.\n       \\<lbrakk>\\<phi>' = formula.Next I \\<phi>';\n        wf_mformula \\<sigma> j n R \\<phi> \\<phi>';\n        first = (Monitor.progress \\<sigma> \\<phi>' j = 0);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n         [Monitor.progress \\<sigma> \\<phi>' j - 1..<j] nts\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext I \\<phi> first nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "let ?ts = \"snd (snd (mprev_next I ?ys (nts @ [\\<tau> \\<sigma> j])))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<phi>' =\n                formula.Neg (formula.Eq (trm.Const x) (trm.Const y));\n        MNext I \\<phi> first nts =\n        MRel (neq_rel n (trm.Const x) (trm.Const y))\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext I \\<phi> first nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi>'.\n       \\<lbrakk>\\<phi>' = formula.Next I \\<phi>';\n        wf_mformula \\<sigma> j n R \\<phi> \\<phi>';\n        first = (Monitor.progress \\<sigma> \\<phi>' j = 0);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n         [Monitor.progress \\<sigma> \\<phi>' j - 1..<j] nts\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext I \\<phi> first nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "let ?P = \"\\<lambda>i X. qtable n (fv \\<psi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>) X\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<phi>' =\n                formula.Neg (formula.Eq (trm.Const x) (trm.Const y));\n        MNext I \\<phi> first nts =\n        MRel (neq_rel n (trm.Const x) (trm.Const y))\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext I \\<phi> first nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi>'.\n       \\<lbrakk>\\<phi>' = formula.Next I \\<phi>';\n        wf_mformula \\<sigma> j n R \\<phi> \\<phi>';\n        first = (Monitor.progress \\<sigma> \\<phi>' j = 0);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n         [Monitor.progress \\<sigma> \\<phi>' j - 1..<j] nts\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext I \\<phi> first nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "let ?min = \"min (progress \\<sigma> \\<psi> (Suc j) - 1) (Suc j - 1)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<phi>' =\n                formula.Neg (formula.Eq (trm.Const x) (trm.Const y));\n        MNext I \\<phi> first nts =\n        MRel (neq_rel n (trm.Const x) (trm.Const y))\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext I \\<phi> first nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi>'.\n       \\<lbrakk>\\<phi>' = formula.Next I \\<phi>';\n        wf_mformula \\<sigma> j n R \\<phi> \\<phi>';\n        first = (Monitor.progress \\<sigma> \\<phi>' j = 0);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n         [Monitor.progress \\<sigma> \\<phi>' j - 1..<j] nts\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext I \\<phi> first nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "from Next MNext.IH[of n R \\<psi>]"], ["proof (chain)\npicking this:\n  \\<phi>' = formula.Next I \\<psi>\n  wf_mformula \\<sigma> j n R \\<phi> \\<psi>\n  first = (Monitor.progress \\<sigma> \\<psi> j = 0)\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [Monitor.progress \\<sigma> \\<psi> j - 1..<j] nts\n  wf_mformula \\<sigma> j n R \\<phi> \\<psi> \\<Longrightarrow>\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<psi> \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<psi>) (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n     [Monitor.progress \\<sigma> \\<psi> j..<\n      Monitor.progress \\<sigma> \\<psi> (Suc j)]\n     xs", "have IH: \"wf_mformula \\<sigma> (Suc j) n R ?\\<phi> \\<psi>\"\n      \"list_all2 ?P [progress \\<sigma> \\<psi> j..<progress \\<sigma> \\<psi> (Suc j)] ?xs\""], ["proof (prove)\nusing this:\n  \\<phi>' = formula.Next I \\<psi>\n  wf_mformula \\<sigma> j n R \\<phi> \\<psi>\n  first = (Monitor.progress \\<sigma> \\<psi> j = 0)\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [Monitor.progress \\<sigma> \\<psi> j - 1..<j] nts\n  wf_mformula \\<sigma> j n R \\<phi> \\<psi> \\<Longrightarrow>\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<psi> \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<psi>) (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n     [Monitor.progress \\<sigma> \\<psi> j..<\n      Monitor.progress \\<sigma> \\<psi> (Suc j)]\n     xs\n\ngoal (1 subgoal):\n 1. wf_mformula \\<sigma> (Suc j) n R\n     (snd (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>))\n     \\<psi> &&&\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<psi>) (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n     [Monitor.progress \\<sigma> \\<psi> j..<\n      Monitor.progress \\<sigma> \\<psi> (Suc j)]\n     (fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>))", "by auto"], ["proof (state)\nthis:\n  wf_mformula \\<sigma> (Suc j) n R\n   (snd (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>)) \\<psi>\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<psi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n   [Monitor.progress \\<sigma> \\<psi> j..<\n    Monitor.progress \\<sigma> \\<psi> (Suc j)]\n   (fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>))\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<phi>' =\n                formula.Neg (formula.Eq (trm.Const x) (trm.Const y));\n        MNext I \\<phi> first nts =\n        MRel (neq_rel n (trm.Const x) (trm.Const y))\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext I \\<phi> first nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi>'.\n       \\<lbrakk>\\<phi>' = formula.Next I \\<phi>';\n        wf_mformula \\<sigma> j n R \\<phi> \\<phi>';\n        first = (Monitor.progress \\<sigma> \\<phi>' j = 0);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n         [Monitor.progress \\<sigma> \\<phi>' j - 1..<j] nts\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext I \\<phi> first nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "with Next"], ["proof (chain)\npicking this:\n  \\<phi>' = formula.Next I \\<psi>\n  wf_mformula \\<sigma> j n R \\<phi> \\<psi>\n  first = (Monitor.progress \\<sigma> \\<psi> j = 0)\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [Monitor.progress \\<sigma> \\<psi> j - 1..<j] nts\n  wf_mformula \\<sigma> (Suc j) n R\n   (snd (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>)) \\<psi>\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<psi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n   [Monitor.progress \\<sigma> \\<psi> j..<\n    Monitor.progress \\<sigma> \\<psi> (Suc j)]\n   (fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>))", "have \"list_all2 (\\<lambda>i X. if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I then ?P (Suc i) X else X = empty_table)\n        [progress \\<sigma> \\<psi> j - 1..<?min] ?ls \\<and>\n       list_all2 ?P [Suc ?min..<progress \\<sigma> \\<psi> (Suc j)] ?rs \\<and>\n       list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i) [?min..<Suc j] ?ts\" if \"progress \\<sigma> \\<psi> j < progress \\<sigma> \\<psi> (Suc j)\""], ["proof (prove)\nusing this:\n  \\<phi>' = formula.Next I \\<psi>\n  wf_mformula \\<sigma> j n R \\<phi> \\<psi>\n  first = (Monitor.progress \\<sigma> \\<psi> j = 0)\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [Monitor.progress \\<sigma> \\<psi> j - 1..<j] nts\n  wf_mformula \\<sigma> (Suc j) n R\n   (snd (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>)) \\<psi>\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<psi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n   [Monitor.progress \\<sigma> \\<psi> j..<\n    Monitor.progress \\<sigma> \\<psi> (Suc j)]\n   (fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>))\n\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>i X.\n         if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I\n         then qtable n (fv \\<psi>) (mem_restr R)\n               (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) (Suc i) \\<psi>) X\n         else X = empty_table)\n     [Monitor.progress \\<sigma> \\<psi> j - 1..<\n      min (Monitor.progress \\<sigma> \\<psi> (Suc j) - 1) (Suc j - 1)]\n     (fst (mprev_next I\n            (case (fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>),\n                   first) of\n             ([], b) \\<Rightarrow>\n               fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                     \\<phi>)\n             | (x # xs, True) \\<Rightarrow> xs\n             | (x # xs, False) \\<Rightarrow>\n                 fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                       \\<phi>))\n            (nts @ [\\<tau> \\<sigma> j]))) \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<psi>) (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n     [Suc (min (Monitor.progress \\<sigma> \\<psi> (Suc j) - 1)\n            (Suc j - 1))..<\n      Monitor.progress \\<sigma> \\<psi> (Suc j)]\n     (fst (snd (mprev_next I\n                 (case (fst (meval n (\\<tau> \\<sigma> j)\n                              (\\<Gamma> \\<sigma> j) \\<phi>),\n                        first) of\n                  ([], b) \\<Rightarrow>\n                    fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                          \\<phi>)\n                  | (x # xs, True) \\<Rightarrow> xs\n                  | (x # xs, False) \\<Rightarrow>\n                      fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                            \\<phi>))\n                 (nts @ [\\<tau> \\<sigma> j])))) \\<and>\n    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n     [min (Monitor.progress \\<sigma> \\<psi> (Suc j) - 1) (Suc j - 1)..<\n      Suc j]\n     (snd (snd (mprev_next I\n                 (case (fst (meval n (\\<tau> \\<sigma> j)\n                              (\\<Gamma> \\<sigma> j) \\<phi>),\n                        first) of\n                  ([], b) \\<Rightarrow>\n                    fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                          \\<phi>)\n                  | (x # xs, True) \\<Rightarrow> xs\n                  | (x # xs, False) \\<Rightarrow>\n                      fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                            \\<phi>))\n                 (nts @ [\\<tau> \\<sigma> j]))))", "using progress_le[of \\<sigma> \\<psi> j] that"], ["proof (prove)\nusing this:\n  \\<phi>' = formula.Next I \\<psi>\n  wf_mformula \\<sigma> j n R \\<phi> \\<psi>\n  first = (Monitor.progress \\<sigma> \\<psi> j = 0)\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [Monitor.progress \\<sigma> \\<psi> j - 1..<j] nts\n  wf_mformula \\<sigma> (Suc j) n R\n   (snd (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>)) \\<psi>\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<psi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n   [Monitor.progress \\<sigma> \\<psi> j..<\n    Monitor.progress \\<sigma> \\<psi> (Suc j)]\n   (fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>))\n  Monitor.progress \\<sigma> \\<psi> j \\<le> j\n  Monitor.progress \\<sigma> \\<psi> j\n  < Monitor.progress \\<sigma> \\<psi> (Suc j)\n\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>i X.\n         if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I\n         then qtable n (fv \\<psi>) (mem_restr R)\n               (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) (Suc i) \\<psi>) X\n         else X = empty_table)\n     [Monitor.progress \\<sigma> \\<psi> j - 1..<\n      min (Monitor.progress \\<sigma> \\<psi> (Suc j) - 1) (Suc j - 1)]\n     (fst (mprev_next I\n            (case (fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>),\n                   first) of\n             ([], b) \\<Rightarrow>\n               fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                     \\<phi>)\n             | (x # xs, True) \\<Rightarrow> xs\n             | (x # xs, False) \\<Rightarrow>\n                 fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                       \\<phi>))\n            (nts @ [\\<tau> \\<sigma> j]))) \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<psi>) (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n     [Suc (min (Monitor.progress \\<sigma> \\<psi> (Suc j) - 1)\n            (Suc j - 1))..<\n      Monitor.progress \\<sigma> \\<psi> (Suc j)]\n     (fst (snd (mprev_next I\n                 (case (fst (meval n (\\<tau> \\<sigma> j)\n                              (\\<Gamma> \\<sigma> j) \\<phi>),\n                        first) of\n                  ([], b) \\<Rightarrow>\n                    fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                          \\<phi>)\n                  | (x # xs, True) \\<Rightarrow> xs\n                  | (x # xs, False) \\<Rightarrow>\n                      fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                            \\<phi>))\n                 (nts @ [\\<tau> \\<sigma> j])))) \\<and>\n    list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n     [min (Monitor.progress \\<sigma> \\<psi> (Suc j) - 1) (Suc j - 1)..<\n      Suc j]\n     (snd (snd (mprev_next I\n                 (case (fst (meval n (\\<tau> \\<sigma> j)\n                              (\\<Gamma> \\<sigma> j) \\<phi>),\n                        first) of\n                  ([], b) \\<Rightarrow>\n                    fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                          \\<phi>)\n                  | (x # xs, True) \\<Rightarrow> xs\n                  | (x # xs, False) \\<Rightarrow>\n                      fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                            \\<phi>))\n                 (nts @ [\\<tau> \\<sigma> j]))))", "by (intro mnext)\n        (auto simp: progress_mono list_all2_Cons2 upt_eq_Cons_conv\n          intro!: list_all2_upt_append list_all2_appendI split: list.splits)"], ["proof (state)\nthis:\n  Monitor.progress \\<sigma> \\<psi> j\n  < Monitor.progress \\<sigma> \\<psi> (Suc j) \\<Longrightarrow>\n  list_all2\n   (\\<lambda>i X.\n       if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I\n       then qtable n (fv \\<psi>) (mem_restr R)\n             (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) (Suc i) \\<psi>) X\n       else X = empty_table)\n   [Monitor.progress \\<sigma> \\<psi> j - 1..<\n    min (Monitor.progress \\<sigma> \\<psi> (Suc j) - 1) (Suc j - 1)]\n   (fst (mprev_next I\n          (case (fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                       \\<phi>),\n                 first) of\n           ([], b) \\<Rightarrow>\n             fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>)\n           | (x # xs, True) \\<Rightarrow> xs\n           | (x # xs, False) \\<Rightarrow>\n               fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                     \\<phi>))\n          (nts @ [\\<tau> \\<sigma> j]))) \\<and>\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<psi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n   [Suc (min (Monitor.progress \\<sigma> \\<psi> (Suc j) - 1) (Suc j - 1))..<\n    Monitor.progress \\<sigma> \\<psi> (Suc j)]\n   (fst (snd (mprev_next I\n               (case (fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                            \\<phi>),\n                      first) of\n                ([], b) \\<Rightarrow>\n                  fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                        \\<phi>)\n                | (x # xs, True) \\<Rightarrow> xs\n                | (x # xs, False) \\<Rightarrow>\n                    fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                          \\<phi>))\n               (nts @ [\\<tau> \\<sigma> j])))) \\<and>\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<psi> (Suc j) - 1) (Suc j - 1)..<Suc j]\n   (snd (snd (mprev_next I\n               (case (fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                            \\<phi>),\n                      first) of\n                ([], b) \\<Rightarrow>\n                  fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                        \\<phi>)\n                | (x # xs, True) \\<Rightarrow> xs\n                | (x # xs, False) \\<Rightarrow>\n                    fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                          \\<phi>))\n               (nts @ [\\<tau> \\<sigma> j]))))\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<phi>' =\n                formula.Neg (formula.Eq (trm.Const x) (trm.Const y));\n        MNext I \\<phi> first nts =\n        MRel (neq_rel n (trm.Const x) (trm.Const y))\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext I \\<phi> first nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>\\<phi>'.\n       \\<lbrakk>\\<phi>' = formula.Next I \\<phi>';\n        wf_mformula \\<sigma> j n R \\<phi> \\<phi>';\n        first = (Monitor.progress \\<sigma> \\<phi>' j = 0);\n        list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n         [Monitor.progress \\<sigma> \\<phi>' j - 1..<j] nts\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext I \\<phi> first nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "then"], ["proof (chain)\npicking this:\n  Monitor.progress \\<sigma> \\<psi> j\n  < Monitor.progress \\<sigma> \\<psi> (Suc j) \\<Longrightarrow>\n  list_all2\n   (\\<lambda>i X.\n       if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I\n       then qtable n (fv \\<psi>) (mem_restr R)\n             (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) (Suc i) \\<psi>) X\n       else X = empty_table)\n   [Monitor.progress \\<sigma> \\<psi> j - 1..<\n    min (Monitor.progress \\<sigma> \\<psi> (Suc j) - 1) (Suc j - 1)]\n   (fst (mprev_next I\n          (case (fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                       \\<phi>),\n                 first) of\n           ([], b) \\<Rightarrow>\n             fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>)\n           | (x # xs, True) \\<Rightarrow> xs\n           | (x # xs, False) \\<Rightarrow>\n               fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                     \\<phi>))\n          (nts @ [\\<tau> \\<sigma> j]))) \\<and>\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<psi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n   [Suc (min (Monitor.progress \\<sigma> \\<psi> (Suc j) - 1) (Suc j - 1))..<\n    Monitor.progress \\<sigma> \\<psi> (Suc j)]\n   (fst (snd (mprev_next I\n               (case (fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                            \\<phi>),\n                      first) of\n                ([], b) \\<Rightarrow>\n                  fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                        \\<phi>)\n                | (x # xs, True) \\<Rightarrow> xs\n                | (x # xs, False) \\<Rightarrow>\n                    fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                          \\<phi>))\n               (nts @ [\\<tau> \\<sigma> j])))) \\<and>\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<psi> (Suc j) - 1) (Suc j - 1)..<Suc j]\n   (snd (snd (mprev_next I\n               (case (fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                            \\<phi>),\n                      first) of\n                ([], b) \\<Rightarrow>\n                  fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                        \\<phi>)\n                | (x # xs, True) \\<Rightarrow> xs\n                | (x # xs, False) \\<Rightarrow>\n                    fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                          \\<phi>))\n               (nts @ [\\<tau> \\<sigma> j]))))", "show ?thesis"], ["proof (prove)\nusing this:\n  Monitor.progress \\<sigma> \\<psi> j\n  < Monitor.progress \\<sigma> \\<psi> (Suc j) \\<Longrightarrow>\n  list_all2\n   (\\<lambda>i X.\n       if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I\n       then qtable n (fv \\<psi>) (mem_restr R)\n             (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) (Suc i) \\<psi>) X\n       else X = empty_table)\n   [Monitor.progress \\<sigma> \\<psi> j - 1..<\n    min (Monitor.progress \\<sigma> \\<psi> (Suc j) - 1) (Suc j - 1)]\n   (fst (mprev_next I\n          (case (fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                       \\<phi>),\n                 first) of\n           ([], b) \\<Rightarrow>\n             fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>)\n           | (x # xs, True) \\<Rightarrow> xs\n           | (x # xs, False) \\<Rightarrow>\n               fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                     \\<phi>))\n          (nts @ [\\<tau> \\<sigma> j]))) \\<and>\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<psi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n   [Suc (min (Monitor.progress \\<sigma> \\<psi> (Suc j) - 1) (Suc j - 1))..<\n    Monitor.progress \\<sigma> \\<psi> (Suc j)]\n   (fst (snd (mprev_next I\n               (case (fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                            \\<phi>),\n                      first) of\n                ([], b) \\<Rightarrow>\n                  fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                        \\<phi>)\n                | (x # xs, True) \\<Rightarrow> xs\n                | (x # xs, False) \\<Rightarrow>\n                    fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                          \\<phi>))\n               (nts @ [\\<tau> \\<sigma> j])))) \\<and>\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<psi> (Suc j) - 1) (Suc j - 1)..<Suc j]\n   (snd (snd (mprev_next I\n               (case (fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                            \\<phi>),\n                      first) of\n                ([], b) \\<Rightarrow>\n                  fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                        \\<phi>)\n                | (x # xs, True) \\<Rightarrow> xs\n                | (x # xs, False) \\<Rightarrow>\n                    fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                          \\<phi>))\n               (nts @ [\\<tau> \\<sigma> j]))))\n\ngoal (1 subgoal):\n 1. case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n          (MNext I \\<phi> first nts) of\n    (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n      wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n      list_all2\n       (\\<lambda>i.\n           qtable n (fv \\<phi>') (mem_restr R)\n            (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n       [Monitor.progress \\<sigma> \\<phi>' j..<\n        Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n       xs", "using progress_mono[of j \"Suc j\" \\<sigma> \\<psi>] progress_le[of \\<sigma> \\<psi> \"Suc j\"] Next IH"], ["proof (prove)\nusing this:\n  Monitor.progress \\<sigma> \\<psi> j\n  < Monitor.progress \\<sigma> \\<psi> (Suc j) \\<Longrightarrow>\n  list_all2\n   (\\<lambda>i X.\n       if mem (\\<tau> \\<sigma> (Suc i) - \\<tau> \\<sigma> i) I\n       then qtable n (fv \\<psi>) (mem_restr R)\n             (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) (Suc i) \\<psi>) X\n       else X = empty_table)\n   [Monitor.progress \\<sigma> \\<psi> j - 1..<\n    min (Monitor.progress \\<sigma> \\<psi> (Suc j) - 1) (Suc j - 1)]\n   (fst (mprev_next I\n          (case (fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                       \\<phi>),\n                 first) of\n           ([], b) \\<Rightarrow>\n             fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>)\n           | (x # xs, True) \\<Rightarrow> xs\n           | (x # xs, False) \\<Rightarrow>\n               fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                     \\<phi>))\n          (nts @ [\\<tau> \\<sigma> j]))) \\<and>\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<psi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n   [Suc (min (Monitor.progress \\<sigma> \\<psi> (Suc j) - 1) (Suc j - 1))..<\n    Monitor.progress \\<sigma> \\<psi> (Suc j)]\n   (fst (snd (mprev_next I\n               (case (fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                            \\<phi>),\n                      first) of\n                ([], b) \\<Rightarrow>\n                  fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                        \\<phi>)\n                | (x # xs, True) \\<Rightarrow> xs\n                | (x # xs, False) \\<Rightarrow>\n                    fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                          \\<phi>))\n               (nts @ [\\<tau> \\<sigma> j])))) \\<and>\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<psi> (Suc j) - 1) (Suc j - 1)..<Suc j]\n   (snd (snd (mprev_next I\n               (case (fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                            \\<phi>),\n                      first) of\n                ([], b) \\<Rightarrow>\n                  fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                        \\<phi>)\n                | (x # xs, True) \\<Rightarrow> xs\n                | (x # xs, False) \\<Rightarrow>\n                    fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                          \\<phi>))\n               (nts @ [\\<tau> \\<sigma> j]))))\n  j \\<le> Suc j \\<Longrightarrow>\n  Monitor.progress \\<sigma> \\<psi> j\n  \\<le> Monitor.progress \\<sigma> \\<psi> (Suc j)\n  Monitor.progress \\<sigma> \\<psi> (Suc j) \\<le> Suc j\n  \\<phi>' = formula.Next I \\<psi>\n  wf_mformula \\<sigma> j n R \\<phi> \\<psi>\n  first = (Monitor.progress \\<sigma> \\<psi> j = 0)\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [Monitor.progress \\<sigma> \\<psi> j - 1..<j] nts\n  wf_mformula \\<sigma> (Suc j) n R\n   (snd (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>)) \\<psi>\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<psi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>))\n   [Monitor.progress \\<sigma> \\<psi> j..<\n    Monitor.progress \\<sigma> \\<psi> (Suc j)]\n   (fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>))\n\ngoal (1 subgoal):\n 1. case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n          (MNext I \\<phi> first nts) of\n    (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n      wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n      list_all2\n       (\\<lambda>i.\n           qtable n (fv \\<phi>') (mem_restr R)\n            (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n       [Monitor.progress \\<sigma> \\<phi>' j..<\n        Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n       xs", "by (cases \"progress \\<sigma> \\<psi> (Suc j) > progress \\<sigma> \\<psi> j\")\n        (auto 0 3 simp: qtable_empty_iff le_Suc_eq le_diff_conv\n         elim!: wf_mformula.Next list.rel_mono_strong list_all2_appendI\n         split: prod.split list.splits if_split_asm)"], ["proof (state)\nthis:\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n        (MNext I \\<phi> first nts) of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n     [Monitor.progress \\<sigma> \\<phi>' j..<\n      Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n     xs\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<phi>' =\n                formula.Neg (formula.Eq (trm.Const x) (trm.Const y));\n        MNext I \\<phi> first nts =\n        MRel (neq_rel n (trm.Const x) (trm.Const y))\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext I \\<phi> first nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "(* slow 5 sec*)"], ["proof (state)\nthis:\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n        (MNext I \\<phi> first nts) of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n     [Monitor.progress \\<sigma> \\<phi>' j..<\n      Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n     xs\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<phi>' =\n                formula.Neg (formula.Eq (trm.Const x) (trm.Const y));\n        MNext I \\<phi> first nts =\n        MRel (neq_rel n (trm.Const x) (trm.Const y))\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MNext I \\<phi> first nts) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "qed simp"], ["proof (state)\nthis:\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n        (MNext I \\<phi> first nts) of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n     [Monitor.progress \\<sigma> \\<phi>' j..<\n      Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n     xs\n\ngoal (2 subgoals):\n 1. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "case (MSince pos \\<phi> I \\<psi> buf nts aux)"], ["proof (state)\nthis:\n  wf_mformula \\<sigma> j ?n ?R \\<phi> ?\\<phi>' \\<Longrightarrow>\n  case meval ?n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) ?n ?R \\<phi>\\<^sub>n ?\\<phi>' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable ?n (fv ?\\<phi>') (mem_restr ?R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i ?\\<phi>'))\n     [Monitor.progress \\<sigma> ?\\<phi>' j..<\n      Monitor.progress \\<sigma> ?\\<phi>' (Suc j)]\n     xs\n  wf_mformula \\<sigma> j ?n ?R \\<psi> ?\\<phi>' \\<Longrightarrow>\n  case meval ?n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<psi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) ?n ?R \\<phi>\\<^sub>n ?\\<phi>' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable ?n (fv ?\\<phi>') (mem_restr ?R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i ?\\<phi>'))\n     [Monitor.progress \\<sigma> ?\\<phi>' j..<\n      Monitor.progress \\<sigma> ?\\<phi>' (Suc j)]\n     xs\n  wf_mformula \\<sigma> j n R (MSince pos \\<phi> I \\<psi> buf nts aux)\n   \\<phi>'\n\ngoal (2 subgoals):\n 1. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "note sat.simps[simp del]"], ["proof (state)\nthis:\n  MFOTL.sat ?\\<sigma> ?v ?i (formula.Pred ?r ?ts) =\n  ((?r, map (MFOTL.eval_trm ?v) ?ts) \\<in> \\<Gamma> ?\\<sigma> ?i)\n  MFOTL.sat ?\\<sigma> ?v ?i (formula.Eq ?t1.0 ?t2.0) =\n  (MFOTL.eval_trm ?v ?t1.0 = MFOTL.eval_trm ?v ?t2.0)\n  MFOTL.sat ?\\<sigma> ?v ?i (formula.Neg ?\\<phi>) =\n  (\\<not> MFOTL.sat ?\\<sigma> ?v ?i ?\\<phi>)\n  MFOTL.sat ?\\<sigma> ?v ?i (formula.Or ?\\<phi> ?\\<psi>) =\n  (MFOTL.sat ?\\<sigma> ?v ?i ?\\<phi> \\<or>\n   MFOTL.sat ?\\<sigma> ?v ?i ?\\<psi>)\n  MFOTL.sat ?\\<sigma> ?v ?i (formula.Exists ?\\<phi>) =\n  (\\<exists>z. MFOTL.sat ?\\<sigma> (z # ?v) ?i ?\\<phi>)\n  MFOTL.sat ?\\<sigma> ?v ?i (formula.Prev ?I ?\\<phi>) =\n  (case ?i of 0 \\<Rightarrow> False\n   | Suc j \\<Rightarrow>\n       mem (\\<tau> ?\\<sigma> ?i - \\<tau> ?\\<sigma> j) ?I \\<and>\n       MFOTL.sat ?\\<sigma> ?v j ?\\<phi>)\n  MFOTL.sat ?\\<sigma> ?v ?i (formula.Next ?I ?\\<phi>) =\n  (mem (\\<tau> ?\\<sigma> (Suc ?i) - \\<tau> ?\\<sigma> ?i) ?I \\<and>\n   MFOTL.sat ?\\<sigma> ?v (Suc ?i) ?\\<phi>)\n  MFOTL.sat ?\\<sigma> ?v ?i (formula.Since ?\\<phi> ?I ?\\<psi>) =\n  (\\<exists>j\\<le>?i.\n      mem (\\<tau> ?\\<sigma> ?i - \\<tau> ?\\<sigma> j) ?I \\<and>\n      MFOTL.sat ?\\<sigma> ?v j ?\\<psi> \\<and>\n      (\\<forall>k\\<in>{j<..?i}. MFOTL.sat ?\\<sigma> ?v k ?\\<phi>))\n  MFOTL.sat ?\\<sigma> ?v ?i (formula.Until ?\\<phi> ?I ?\\<psi>) =\n  (\\<exists>j\\<ge>?i.\n      mem (\\<tau> ?\\<sigma> j - \\<tau> ?\\<sigma> ?i) ?I \\<and>\n      MFOTL.sat ?\\<sigma> ?v j ?\\<psi> \\<and>\n      (\\<forall>k\\<in>{?i..<j}. MFOTL.sat ?\\<sigma> ?v k ?\\<phi>))\n\ngoal (2 subgoals):\n 1. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "from MSince.prems"], ["proof (chain)\npicking this:\n  wf_mformula \\<sigma> j n R (MSince pos \\<phi> I \\<psi> buf nts aux)\n   \\<phi>'", "obtain \\<phi>'' \\<phi>''' \\<psi>'' where Since_eq: \"\\<phi>' = MFOTL.Since \\<phi>''' I \\<psi>''\"\n    and pos: \"if pos then \\<phi>''' = \\<phi>'' else \\<phi>''' = MFOTL.Neg \\<phi>''\"\n    and pos_eq: \"safe_formula \\<phi>''' = pos\"\n    and \\<phi>: \"wf_mformula \\<sigma> j n R \\<phi> \\<phi>''\"\n    and \\<psi>: \"wf_mformula \\<sigma> j n R \\<psi> \\<psi>''\"\n    and fvi_subset: \"MFOTL.fv \\<phi>'' \\<subseteq> MFOTL.fv \\<psi>''\"\n    and buf: \"wf_mbuf2' \\<sigma> j n R \\<phi>'' \\<psi>'' buf\"\n    and nts: \"wf_ts \\<sigma> j \\<phi>'' \\<psi>'' nts\"\n    and aux: \"wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux (progress \\<sigma> (formula.Since \\<phi>''' I \\<psi>'') j)\""], ["proof (prove)\nusing this:\n  wf_mformula \\<sigma> j n R (MSince pos \\<phi> I \\<psi> buf nts aux)\n   \\<phi>'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>'''' \\<psi>'' \\<phi>'''''.\n        \\<lbrakk>\\<phi>' = formula.Since \\<phi>'''' I \\<psi>'';\n         if pos then \\<phi>'''' = \\<phi>'''''\n         else \\<phi>'''' = formula.Neg \\<phi>''''';\n         safe_formula \\<phi>'''' = pos;\n         wf_mformula \\<sigma> j n R \\<phi> \\<phi>''''';\n         wf_mformula \\<sigma> j n R \\<psi> \\<psi>'';\n         fv \\<phi>''''' \\<subseteq> fv \\<psi>'';\n         wf_mbuf2' \\<sigma> j n R \\<phi>''''' \\<psi>'' buf;\n         wf_ts \\<sigma> j \\<phi>''''' \\<psi>'' nts;\n         wf_since_aux \\<sigma> n R pos \\<phi>''''' I \\<psi>'' aux\n          (Monitor.progress \\<sigma> (formula.Since \\<phi>'''' I \\<psi>'')\n            j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases pred: wf_mformula) (auto)"], ["proof (state)\nthis:\n  \\<phi>' = formula.Since \\<phi>''' I \\<psi>''\n  if pos then \\<phi>''' = \\<phi>'' else \\<phi>''' = formula.Neg \\<phi>''\n  safe_formula \\<phi>''' = pos\n  wf_mformula \\<sigma> j n R \\<phi> \\<phi>''\n  wf_mformula \\<sigma> j n R \\<psi> \\<psi>''\n  fv \\<phi>'' \\<subseteq> fv \\<psi>''\n  wf_mbuf2' \\<sigma> j n R \\<phi>'' \\<psi>'' buf\n  wf_ts \\<sigma> j \\<phi>'' \\<psi>'' nts\n  wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux\n   (Monitor.progress \\<sigma> (formula.Since \\<phi>''' I \\<psi>'') j)\n\ngoal (2 subgoals):\n 1. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "have \\<phi>''': \"MFOTL.fv \\<phi>''' = MFOTL.fv \\<phi>''\" \"progress \\<sigma> \\<phi>''' j = progress \\<sigma> \\<phi>'' j\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. fv \\<phi>''' = fv \\<phi>'' &&&\n    Monitor.progress \\<sigma> \\<phi>''' j =\n    Monitor.progress \\<sigma> \\<phi>'' j", "using pos"], ["proof (prove)\nusing this:\n  if pos then \\<phi>''' = \\<phi>'' else \\<phi>''' = formula.Neg \\<phi>''\n\ngoal (1 subgoal):\n 1. fv \\<phi>''' = fv \\<phi>'' &&&\n    Monitor.progress \\<sigma> \\<phi>''' j =\n    Monitor.progress \\<sigma> \\<phi>'' j", "by (simp_all split: if_splits)"], ["proof (state)\nthis:\n  fv \\<phi>''' = fv \\<phi>''\n  Monitor.progress \\<sigma> \\<phi>''' ?j =\n  Monitor.progress \\<sigma> \\<phi>'' ?j\n\ngoal (2 subgoals):\n 1. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "have nts_snoc: \"list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n    [min (progress \\<sigma> \\<phi>'' j) (progress \\<sigma> \\<psi>'' j)..<Suc j] (nts @ [\\<tau> \\<sigma> j])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n     [min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)..<\n      Suc j]\n     (nts @ [\\<tau> \\<sigma> j])", "using nts"], ["proof (prove)\nusing this:\n  wf_ts \\<sigma> j \\<phi>'' \\<psi>'' nts\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n     [min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)..<\n      Suc j]\n     (nts @ [\\<tau> \\<sigma> j])", "unfolding wf_ts_def"], ["proof (prove)\nusing this:\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<phi>'' j)\n     (Monitor.progress \\<sigma> \\<psi>'' j)..<\n    j]\n   nts\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n     [min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)..<\n      Suc j]\n     (nts @ [\\<tau> \\<sigma> j])", "by (auto simp add: progress_le[THEN min.coboundedI1] intro: list_all2_appendI)"], ["proof (state)\nthis:\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<phi>'' j)\n     (Monitor.progress \\<sigma> \\<psi>'' j)..<\n    Suc j]\n   (nts @ [\\<tau> \\<sigma> j])\n\ngoal (2 subgoals):\n 1. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "have update: \"wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (snd (zs, aux')) (progress \\<sigma> (formula.Since \\<phi>''' I \\<psi>'') (Suc j)) \\<and>\n    list_all2 (\\<lambda>i. qtable n (MFOTL.fv \\<phi>''' \\<union> MFOTL.fv \\<psi>'') (mem_restr R)\n      (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i (formula.Since \\<phi>''' I \\<psi>'')))\n      [progress \\<sigma> (formula.Since \\<phi>''' I \\<psi>'') j..<progress \\<sigma> (formula.Since \\<phi>''' I \\<psi>'') (Suc j)] (fst (zs, aux'))\"\n    if eval_\\<phi>: \"fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>) = xs\"\n      and eval_\\<psi>: \"fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<psi>) = ys\"\n      and eq: \"mbuf2t_take (\\<lambda>r1 r2 t (zs, aux).\n        case update_since I pos r1 r2 t aux of (z, x) \\<Rightarrow> (zs @ [z], x))\n        ([], aux) (mbuf2_add xs ys buf) (nts @ [\\<tau> \\<sigma> j]) = ((zs, aux'), buf', nts')\"\n    for xs ys zs aux' buf' nts'"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (snd (zs, aux'))\n     (Monitor.progress \\<sigma> (formula.Since \\<phi>''' I \\<psi>'')\n       (Suc j)) \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>''' \\<union> fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v.\n              MFOTL.sat \\<sigma> (map the v) i\n               (formula.Since \\<phi>''' I \\<psi>'')))\n     [Monitor.progress \\<sigma> (formula.Since \\<phi>''' I \\<psi>'') j..<\n      Monitor.progress \\<sigma> (formula.Since \\<phi>''' I \\<psi>'')\n       (Suc j)]\n     (fst (zs, aux'))", "unfolding progress.simps \\<phi>'''"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (snd (zs, aux'))\n     (min (Monitor.progress \\<sigma> \\<phi>'' (Suc j))\n       (Monitor.progress \\<sigma> \\<psi>'' (Suc j))) \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>'' \\<union> fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v.\n              MFOTL.sat \\<sigma> (map the v) i\n               (formula.Since \\<phi>''' I \\<psi>'')))\n     [min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)..<\n      min (Monitor.progress \\<sigma> \\<phi>'' (Suc j))\n       (Monitor.progress \\<sigma> \\<psi>'' (Suc j))]\n     (fst (zs, aux'))", "proof (rule mbuf2t_take_add_induct'[where j'=\"Suc j\" and z'=\"(zs, aux')\", OF eq buf nts_snoc],\n      goal_cases xs ys _ base step)"], ["proof (state)\ngoal (5 subgoals):\n 1. list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>'') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>''))\n     [Monitor.progress \\<sigma> \\<phi>'' j..<\n      Monitor.progress \\<sigma> \\<phi>'' (Suc j)]\n     xs\n 2. list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>''))\n     [Monitor.progress \\<sigma> \\<psi>'' j..<\n      Monitor.progress \\<sigma> \\<psi>'' (Suc j)]\n     ys\n 3. j \\<le> Suc j\n 4. wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (snd ([], aux))\n     (min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)) \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>'' \\<union> fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v.\n              MFOTL.sat \\<sigma> (map the v) i\n               (formula.Since \\<phi>''' I \\<psi>'')))\n     [min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)..<\n      min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)]\n     (fst ([], aux))\n 5. \\<And>k X Y z.\n       \\<lbrakk>min (Monitor.progress \\<sigma> \\<phi>'' j)\n                 (Monitor.progress \\<sigma> \\<psi>'' j)\n                \\<le> k;\n        Suc k \\<le> Monitor.progress \\<sigma> \\<phi>'' (Suc j);\n        Suc k \\<le> Monitor.progress \\<sigma> \\<psi>'' (Suc j);\n        qtable n (fv \\<phi>'') (mem_restr R)\n         (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<phi>'') X;\n        qtable n (fv \\<psi>'') (mem_restr R)\n         (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<psi>'') Y;\n        wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (snd z) k \\<and>\n        list_all2\n         (\\<lambda>i.\n             qtable n (fv \\<phi>'' \\<union> fv \\<psi>'') (mem_restr R)\n              (\\<lambda>v.\n                  MFOTL.sat \\<sigma> (map the v) i\n                   (formula.Since \\<phi>''' I \\<psi>'')))\n         [min (Monitor.progress \\<sigma> \\<phi>'' j)\n           (Monitor.progress \\<sigma> \\<psi>'' j)..<\n          k]\n         (fst z)\\<rbrakk>\n       \\<Longrightarrow> wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                          (snd (case z of\n                                (zs, aux) \\<Rightarrow>\n                                  case update_since I pos X Y\n  (\\<tau> \\<sigma> k) aux of\n                                  (z, x) \\<Rightarrow> (zs @ [z], x)))\n                          (Suc k) \\<and>\n                         list_all2\n                          (\\<lambda>i.\n                              qtable n (fv \\<phi>'' \\<union> fv \\<psi>'')\n                               (mem_restr R)\n                               (\\<lambda>v.\n                                   MFOTL.sat \\<sigma> (map the v) i\n                                    (formula.Since \\<phi>''' I \\<psi>'')))\n                          [min (Monitor.progress \\<sigma> \\<phi>'' j)\n                            (Monitor.progress \\<sigma> \\<psi>'' j)..<\n                           Suc k]\n                          (fst (case z of\n                                (zs, aux) \\<Rightarrow>\n                                  case update_since I pos X Y\n  (\\<tau> \\<sigma> k) aux of\n                                  (z, x) \\<Rightarrow> (zs @ [z], x)))", "case xs"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>'') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>''))\n     [Monitor.progress \\<sigma> \\<phi>'' j..<\n      Monitor.progress \\<sigma> \\<phi>'' (Suc j)]\n     xs\n 2. list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>''))\n     [Monitor.progress \\<sigma> \\<psi>'' j..<\n      Monitor.progress \\<sigma> \\<psi>'' (Suc j)]\n     ys\n 3. j \\<le> Suc j\n 4. wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (snd ([], aux))\n     (min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)) \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>'' \\<union> fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v.\n              MFOTL.sat \\<sigma> (map the v) i\n               (formula.Since \\<phi>''' I \\<psi>'')))\n     [min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)..<\n      min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)]\n     (fst ([], aux))\n 5. \\<And>k X Y z.\n       \\<lbrakk>min (Monitor.progress \\<sigma> \\<phi>'' j)\n                 (Monitor.progress \\<sigma> \\<psi>'' j)\n                \\<le> k;\n        Suc k \\<le> Monitor.progress \\<sigma> \\<phi>'' (Suc j);\n        Suc k \\<le> Monitor.progress \\<sigma> \\<psi>'' (Suc j);\n        qtable n (fv \\<phi>'') (mem_restr R)\n         (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<phi>'') X;\n        qtable n (fv \\<psi>'') (mem_restr R)\n         (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<psi>'') Y;\n        wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (snd z) k \\<and>\n        list_all2\n         (\\<lambda>i.\n             qtable n (fv \\<phi>'' \\<union> fv \\<psi>'') (mem_restr R)\n              (\\<lambda>v.\n                  MFOTL.sat \\<sigma> (map the v) i\n                   (formula.Since \\<phi>''' I \\<psi>'')))\n         [min (Monitor.progress \\<sigma> \\<phi>'' j)\n           (Monitor.progress \\<sigma> \\<psi>'' j)..<\n          k]\n         (fst z)\\<rbrakk>\n       \\<Longrightarrow> wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                          (snd (case z of\n                                (zs, aux) \\<Rightarrow>\n                                  case update_since I pos X Y\n  (\\<tau> \\<sigma> k) aux of\n                                  (z, x) \\<Rightarrow> (zs @ [z], x)))\n                          (Suc k) \\<and>\n                         list_all2\n                          (\\<lambda>i.\n                              qtable n (fv \\<phi>'' \\<union> fv \\<psi>'')\n                               (mem_restr R)\n                               (\\<lambda>v.\n                                   MFOTL.sat \\<sigma> (map the v) i\n                                    (formula.Since \\<phi>''' I \\<psi>'')))\n                          [min (Monitor.progress \\<sigma> \\<phi>'' j)\n                            (Monitor.progress \\<sigma> \\<psi>'' j)..<\n                           Suc k]\n                          (fst (case z of\n                                (zs, aux) \\<Rightarrow>\n                                  case update_since I pos X Y\n  (\\<tau> \\<sigma> k) aux of\n                                  (z, x) \\<Rightarrow> (zs @ [z], x)))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>'') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>''))\n     [Monitor.progress \\<sigma> \\<phi>'' j..<\n      Monitor.progress \\<sigma> \\<phi>'' (Suc j)]\n     xs", "using MSince.IH(1)[OF \\<phi>] eval_\\<phi>"], ["proof (prove)\nusing this:\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>'' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>'') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>''))\n     [Monitor.progress \\<sigma> \\<phi>'' j..<\n      Monitor.progress \\<sigma> \\<phi>'' (Suc j)]\n     xs\n  fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>) = xs\n\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>'') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>''))\n     [Monitor.progress \\<sigma> \\<phi>'' j..<\n      Monitor.progress \\<sigma> \\<phi>'' (Suc j)]\n     xs", "by auto"], ["proof (state)\nthis:\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<phi>'') (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>''))\n   [Monitor.progress \\<sigma> \\<phi>'' j..<\n    Monitor.progress \\<sigma> \\<phi>'' (Suc j)]\n   xs\n\ngoal (4 subgoals):\n 1. list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>''))\n     [Monitor.progress \\<sigma> \\<psi>'' j..<\n      Monitor.progress \\<sigma> \\<psi>'' (Suc j)]\n     ys\n 2. j \\<le> Suc j\n 3. wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (snd ([], aux))\n     (min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)) \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>'' \\<union> fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v.\n              MFOTL.sat \\<sigma> (map the v) i\n               (formula.Since \\<phi>''' I \\<psi>'')))\n     [min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)..<\n      min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)]\n     (fst ([], aux))\n 4. \\<And>k X Y z.\n       \\<lbrakk>min (Monitor.progress \\<sigma> \\<phi>'' j)\n                 (Monitor.progress \\<sigma> \\<psi>'' j)\n                \\<le> k;\n        Suc k \\<le> Monitor.progress \\<sigma> \\<phi>'' (Suc j);\n        Suc k \\<le> Monitor.progress \\<sigma> \\<psi>'' (Suc j);\n        qtable n (fv \\<phi>'') (mem_restr R)\n         (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<phi>'') X;\n        qtable n (fv \\<psi>'') (mem_restr R)\n         (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<psi>'') Y;\n        wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (snd z) k \\<and>\n        list_all2\n         (\\<lambda>i.\n             qtable n (fv \\<phi>'' \\<union> fv \\<psi>'') (mem_restr R)\n              (\\<lambda>v.\n                  MFOTL.sat \\<sigma> (map the v) i\n                   (formula.Since \\<phi>''' I \\<psi>'')))\n         [min (Monitor.progress \\<sigma> \\<phi>'' j)\n           (Monitor.progress \\<sigma> \\<psi>'' j)..<\n          k]\n         (fst z)\\<rbrakk>\n       \\<Longrightarrow> wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                          (snd (case z of\n                                (zs, aux) \\<Rightarrow>\n                                  case update_since I pos X Y\n  (\\<tau> \\<sigma> k) aux of\n                                  (z, x) \\<Rightarrow> (zs @ [z], x)))\n                          (Suc k) \\<and>\n                         list_all2\n                          (\\<lambda>i.\n                              qtable n (fv \\<phi>'' \\<union> fv \\<psi>'')\n                               (mem_restr R)\n                               (\\<lambda>v.\n                                   MFOTL.sat \\<sigma> (map the v) i\n                                    (formula.Since \\<phi>''' I \\<psi>'')))\n                          [min (Monitor.progress \\<sigma> \\<phi>'' j)\n                            (Monitor.progress \\<sigma> \\<psi>'' j)..<\n                           Suc k]\n                          (fst (case z of\n                                (zs, aux) \\<Rightarrow>\n                                  case update_since I pos X Y\n  (\\<tau> \\<sigma> k) aux of\n                                  (z, x) \\<Rightarrow> (zs @ [z], x)))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>''))\n     [Monitor.progress \\<sigma> \\<psi>'' j..<\n      Monitor.progress \\<sigma> \\<psi>'' (Suc j)]\n     ys\n 2. j \\<le> Suc j\n 3. wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (snd ([], aux))\n     (min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)) \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>'' \\<union> fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v.\n              MFOTL.sat \\<sigma> (map the v) i\n               (formula.Since \\<phi>''' I \\<psi>'')))\n     [min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)..<\n      min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)]\n     (fst ([], aux))\n 4. \\<And>k X Y z.\n       \\<lbrakk>min (Monitor.progress \\<sigma> \\<phi>'' j)\n                 (Monitor.progress \\<sigma> \\<psi>'' j)\n                \\<le> k;\n        Suc k \\<le> Monitor.progress \\<sigma> \\<phi>'' (Suc j);\n        Suc k \\<le> Monitor.progress \\<sigma> \\<psi>'' (Suc j);\n        qtable n (fv \\<phi>'') (mem_restr R)\n         (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<phi>'') X;\n        qtable n (fv \\<psi>'') (mem_restr R)\n         (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<psi>'') Y;\n        wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (snd z) k \\<and>\n        list_all2\n         (\\<lambda>i.\n             qtable n (fv \\<phi>'' \\<union> fv \\<psi>'') (mem_restr R)\n              (\\<lambda>v.\n                  MFOTL.sat \\<sigma> (map the v) i\n                   (formula.Since \\<phi>''' I \\<psi>'')))\n         [min (Monitor.progress \\<sigma> \\<phi>'' j)\n           (Monitor.progress \\<sigma> \\<psi>'' j)..<\n          k]\n         (fst z)\\<rbrakk>\n       \\<Longrightarrow> wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                          (snd (case z of\n                                (zs, aux) \\<Rightarrow>\n                                  case update_since I pos X Y\n  (\\<tau> \\<sigma> k) aux of\n                                  (z, x) \\<Rightarrow> (zs @ [z], x)))\n                          (Suc k) \\<and>\n                         list_all2\n                          (\\<lambda>i.\n                              qtable n (fv \\<phi>'' \\<union> fv \\<psi>'')\n                               (mem_restr R)\n                               (\\<lambda>v.\n                                   MFOTL.sat \\<sigma> (map the v) i\n                                    (formula.Since \\<phi>''' I \\<psi>'')))\n                          [min (Monitor.progress \\<sigma> \\<phi>'' j)\n                            (Monitor.progress \\<sigma> \\<psi>'' j)..<\n                           Suc k]\n                          (fst (case z of\n                                (zs, aux) \\<Rightarrow>\n                                  case update_since I pos X Y\n  (\\<tau> \\<sigma> k) aux of\n                                  (z, x) \\<Rightarrow> (zs @ [z], x)))", "case ys"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>''))\n     [Monitor.progress \\<sigma> \\<psi>'' j..<\n      Monitor.progress \\<sigma> \\<psi>'' (Suc j)]\n     ys\n 2. j \\<le> Suc j\n 3. wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (snd ([], aux))\n     (min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)) \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>'' \\<union> fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v.\n              MFOTL.sat \\<sigma> (map the v) i\n               (formula.Since \\<phi>''' I \\<psi>'')))\n     [min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)..<\n      min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)]\n     (fst ([], aux))\n 4. \\<And>k X Y z.\n       \\<lbrakk>min (Monitor.progress \\<sigma> \\<phi>'' j)\n                 (Monitor.progress \\<sigma> \\<psi>'' j)\n                \\<le> k;\n        Suc k \\<le> Monitor.progress \\<sigma> \\<phi>'' (Suc j);\n        Suc k \\<le> Monitor.progress \\<sigma> \\<psi>'' (Suc j);\n        qtable n (fv \\<phi>'') (mem_restr R)\n         (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<phi>'') X;\n        qtable n (fv \\<psi>'') (mem_restr R)\n         (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<psi>'') Y;\n        wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (snd z) k \\<and>\n        list_all2\n         (\\<lambda>i.\n             qtable n (fv \\<phi>'' \\<union> fv \\<psi>'') (mem_restr R)\n              (\\<lambda>v.\n                  MFOTL.sat \\<sigma> (map the v) i\n                   (formula.Since \\<phi>''' I \\<psi>'')))\n         [min (Monitor.progress \\<sigma> \\<phi>'' j)\n           (Monitor.progress \\<sigma> \\<psi>'' j)..<\n          k]\n         (fst z)\\<rbrakk>\n       \\<Longrightarrow> wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                          (snd (case z of\n                                (zs, aux) \\<Rightarrow>\n                                  case update_since I pos X Y\n  (\\<tau> \\<sigma> k) aux of\n                                  (z, x) \\<Rightarrow> (zs @ [z], x)))\n                          (Suc k) \\<and>\n                         list_all2\n                          (\\<lambda>i.\n                              qtable n (fv \\<phi>'' \\<union> fv \\<psi>'')\n                               (mem_restr R)\n                               (\\<lambda>v.\n                                   MFOTL.sat \\<sigma> (map the v) i\n                                    (formula.Since \\<phi>''' I \\<psi>'')))\n                          [min (Monitor.progress \\<sigma> \\<phi>'' j)\n                            (Monitor.progress \\<sigma> \\<psi>'' j)..<\n                           Suc k]\n                          (fst (case z of\n                                (zs, aux) \\<Rightarrow>\n                                  case update_since I pos X Y\n  (\\<tau> \\<sigma> k) aux of\n                                  (z, x) \\<Rightarrow> (zs @ [z], x)))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>''))\n     [Monitor.progress \\<sigma> \\<psi>'' j..<\n      Monitor.progress \\<sigma> \\<psi>'' (Suc j)]\n     ys", "using MSince.IH(2)[OF \\<psi>] eval_\\<psi>"], ["proof (prove)\nusing this:\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<psi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<psi>'' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>''))\n     [Monitor.progress \\<sigma> \\<psi>'' j..<\n      Monitor.progress \\<sigma> \\<psi>'' (Suc j)]\n     xs\n  fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<psi>) = ys\n\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>''))\n     [Monitor.progress \\<sigma> \\<psi>'' j..<\n      Monitor.progress \\<sigma> \\<psi>'' (Suc j)]\n     ys", "by auto"], ["proof (state)\nthis:\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<psi>'') (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>''))\n   [Monitor.progress \\<sigma> \\<psi>'' j..<\n    Monitor.progress \\<sigma> \\<psi>'' (Suc j)]\n   ys\n\ngoal (3 subgoals):\n 1. j \\<le> Suc j\n 2. wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (snd ([], aux))\n     (min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)) \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>'' \\<union> fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v.\n              MFOTL.sat \\<sigma> (map the v) i\n               (formula.Since \\<phi>''' I \\<psi>'')))\n     [min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)..<\n      min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)]\n     (fst ([], aux))\n 3. \\<And>k X Y z.\n       \\<lbrakk>min (Monitor.progress \\<sigma> \\<phi>'' j)\n                 (Monitor.progress \\<sigma> \\<psi>'' j)\n                \\<le> k;\n        Suc k \\<le> Monitor.progress \\<sigma> \\<phi>'' (Suc j);\n        Suc k \\<le> Monitor.progress \\<sigma> \\<psi>'' (Suc j);\n        qtable n (fv \\<phi>'') (mem_restr R)\n         (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<phi>'') X;\n        qtable n (fv \\<psi>'') (mem_restr R)\n         (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<psi>'') Y;\n        wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (snd z) k \\<and>\n        list_all2\n         (\\<lambda>i.\n             qtable n (fv \\<phi>'' \\<union> fv \\<psi>'') (mem_restr R)\n              (\\<lambda>v.\n                  MFOTL.sat \\<sigma> (map the v) i\n                   (formula.Since \\<phi>''' I \\<psi>'')))\n         [min (Monitor.progress \\<sigma> \\<phi>'' j)\n           (Monitor.progress \\<sigma> \\<psi>'' j)..<\n          k]\n         (fst z)\\<rbrakk>\n       \\<Longrightarrow> wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                          (snd (case z of\n                                (zs, aux) \\<Rightarrow>\n                                  case update_since I pos X Y\n  (\\<tau> \\<sigma> k) aux of\n                                  (z, x) \\<Rightarrow> (zs @ [z], x)))\n                          (Suc k) \\<and>\n                         list_all2\n                          (\\<lambda>i.\n                              qtable n (fv \\<phi>'' \\<union> fv \\<psi>'')\n                               (mem_restr R)\n                               (\\<lambda>v.\n                                   MFOTL.sat \\<sigma> (map the v) i\n                                    (formula.Since \\<phi>''' I \\<psi>'')))\n                          [min (Monitor.progress \\<sigma> \\<phi>'' j)\n                            (Monitor.progress \\<sigma> \\<psi>'' j)..<\n                           Suc k]\n                          (fst (case z of\n                                (zs, aux) \\<Rightarrow>\n                                  case update_since I pos X Y\n  (\\<tau> \\<sigma> k) aux of\n                                  (z, x) \\<Rightarrow> (zs @ [z], x)))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. j \\<le> Suc j\n 2. wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (snd ([], aux))\n     (min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)) \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>'' \\<union> fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v.\n              MFOTL.sat \\<sigma> (map the v) i\n               (formula.Since \\<phi>''' I \\<psi>'')))\n     [min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)..<\n      min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)]\n     (fst ([], aux))\n 3. \\<And>k X Y z.\n       \\<lbrakk>min (Monitor.progress \\<sigma> \\<phi>'' j)\n                 (Monitor.progress \\<sigma> \\<psi>'' j)\n                \\<le> k;\n        Suc k \\<le> Monitor.progress \\<sigma> \\<phi>'' (Suc j);\n        Suc k \\<le> Monitor.progress \\<sigma> \\<psi>'' (Suc j);\n        qtable n (fv \\<phi>'') (mem_restr R)\n         (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<phi>'') X;\n        qtable n (fv \\<psi>'') (mem_restr R)\n         (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<psi>'') Y;\n        wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (snd z) k \\<and>\n        list_all2\n         (\\<lambda>i.\n             qtable n (fv \\<phi>'' \\<union> fv \\<psi>'') (mem_restr R)\n              (\\<lambda>v.\n                  MFOTL.sat \\<sigma> (map the v) i\n                   (formula.Since \\<phi>''' I \\<psi>'')))\n         [min (Monitor.progress \\<sigma> \\<phi>'' j)\n           (Monitor.progress \\<sigma> \\<psi>'' j)..<\n          k]\n         (fst z)\\<rbrakk>\n       \\<Longrightarrow> wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                          (snd (case z of\n                                (zs, aux) \\<Rightarrow>\n                                  case update_since I pos X Y\n  (\\<tau> \\<sigma> k) aux of\n                                  (z, x) \\<Rightarrow> (zs @ [z], x)))\n                          (Suc k) \\<and>\n                         list_all2\n                          (\\<lambda>i.\n                              qtable n (fv \\<phi>'' \\<union> fv \\<psi>'')\n                               (mem_restr R)\n                               (\\<lambda>v.\n                                   MFOTL.sat \\<sigma> (map the v) i\n                                    (formula.Since \\<phi>''' I \\<psi>'')))\n                          [min (Monitor.progress \\<sigma> \\<phi>'' j)\n                            (Monitor.progress \\<sigma> \\<psi>'' j)..<\n                           Suc k]\n                          (fst (case z of\n                                (zs, aux) \\<Rightarrow>\n                                  case update_since I pos X Y\n  (\\<tau> \\<sigma> k) aux of\n                                  (z, x) \\<Rightarrow> (zs @ [z], x)))", "case base"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. j \\<le> Suc j\n 2. wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (snd ([], aux))\n     (min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)) \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>'' \\<union> fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v.\n              MFOTL.sat \\<sigma> (map the v) i\n               (formula.Since \\<phi>''' I \\<psi>'')))\n     [min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)..<\n      min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)]\n     (fst ([], aux))\n 3. \\<And>k X Y z.\n       \\<lbrakk>min (Monitor.progress \\<sigma> \\<phi>'' j)\n                 (Monitor.progress \\<sigma> \\<psi>'' j)\n                \\<le> k;\n        Suc k \\<le> Monitor.progress \\<sigma> \\<phi>'' (Suc j);\n        Suc k \\<le> Monitor.progress \\<sigma> \\<psi>'' (Suc j);\n        qtable n (fv \\<phi>'') (mem_restr R)\n         (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<phi>'') X;\n        qtable n (fv \\<psi>'') (mem_restr R)\n         (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<psi>'') Y;\n        wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (snd z) k \\<and>\n        list_all2\n         (\\<lambda>i.\n             qtable n (fv \\<phi>'' \\<union> fv \\<psi>'') (mem_restr R)\n              (\\<lambda>v.\n                  MFOTL.sat \\<sigma> (map the v) i\n                   (formula.Since \\<phi>''' I \\<psi>'')))\n         [min (Monitor.progress \\<sigma> \\<phi>'' j)\n           (Monitor.progress \\<sigma> \\<psi>'' j)..<\n          k]\n         (fst z)\\<rbrakk>\n       \\<Longrightarrow> wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                          (snd (case z of\n                                (zs, aux) \\<Rightarrow>\n                                  case update_since I pos X Y\n  (\\<tau> \\<sigma> k) aux of\n                                  (z, x) \\<Rightarrow> (zs @ [z], x)))\n                          (Suc k) \\<and>\n                         list_all2\n                          (\\<lambda>i.\n                              qtable n (fv \\<phi>'' \\<union> fv \\<psi>'')\n                               (mem_restr R)\n                               (\\<lambda>v.\n                                   MFOTL.sat \\<sigma> (map the v) i\n                                    (formula.Since \\<phi>''' I \\<psi>'')))\n                          [min (Monitor.progress \\<sigma> \\<phi>'' j)\n                            (Monitor.progress \\<sigma> \\<psi>'' j)..<\n                           Suc k]\n                          (fst (case z of\n                                (zs, aux) \\<Rightarrow>\n                                  case update_since I pos X Y\n  (\\<tau> \\<sigma> k) aux of\n                                  (z, x) \\<Rightarrow> (zs @ [z], x)))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (snd ([], aux))\n     (min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)) \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>'' \\<union> fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v.\n              MFOTL.sat \\<sigma> (map the v) i\n               (formula.Since \\<phi>''' I \\<psi>'')))\n     [min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)..<\n      min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)]\n     (fst ([], aux))", "using aux"], ["proof (prove)\nusing this:\n  wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux\n   (Monitor.progress \\<sigma> (formula.Since \\<phi>''' I \\<psi>'') j)\n\ngoal (1 subgoal):\n 1. wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (snd ([], aux))\n     (min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)) \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>'' \\<union> fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v.\n              MFOTL.sat \\<sigma> (map the v) i\n               (formula.Since \\<phi>''' I \\<psi>'')))\n     [min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)..<\n      min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)]\n     (fst ([], aux))", "by (simp add: \\<phi>''')"], ["proof (state)\nthis:\n  wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (snd ([], aux))\n   (min (Monitor.progress \\<sigma> \\<phi>'' j)\n     (Monitor.progress \\<sigma> \\<psi>'' j)) \\<and>\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<phi>'' \\<union> fv \\<psi>'') (mem_restr R)\n        (\\<lambda>v.\n            MFOTL.sat \\<sigma> (map the v) i\n             (formula.Since \\<phi>''' I \\<psi>'')))\n   [min (Monitor.progress \\<sigma> \\<phi>'' j)\n     (Monitor.progress \\<sigma> \\<psi>'' j)..<\n    min (Monitor.progress \\<sigma> \\<phi>'' j)\n     (Monitor.progress \\<sigma> \\<psi>'' j)]\n   (fst ([], aux))\n\ngoal (2 subgoals):\n 1. j \\<le> Suc j\n 2. \\<And>k X Y z.\n       \\<lbrakk>min (Monitor.progress \\<sigma> \\<phi>'' j)\n                 (Monitor.progress \\<sigma> \\<psi>'' j)\n                \\<le> k;\n        Suc k \\<le> Monitor.progress \\<sigma> \\<phi>'' (Suc j);\n        Suc k \\<le> Monitor.progress \\<sigma> \\<psi>'' (Suc j);\n        qtable n (fv \\<phi>'') (mem_restr R)\n         (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<phi>'') X;\n        qtable n (fv \\<psi>'') (mem_restr R)\n         (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<psi>'') Y;\n        wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (snd z) k \\<and>\n        list_all2\n         (\\<lambda>i.\n             qtable n (fv \\<phi>'' \\<union> fv \\<psi>'') (mem_restr R)\n              (\\<lambda>v.\n                  MFOTL.sat \\<sigma> (map the v) i\n                   (formula.Since \\<phi>''' I \\<psi>'')))\n         [min (Monitor.progress \\<sigma> \\<phi>'' j)\n           (Monitor.progress \\<sigma> \\<psi>'' j)..<\n          k]\n         (fst z)\\<rbrakk>\n       \\<Longrightarrow> wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                          (snd (case z of\n                                (zs, aux) \\<Rightarrow>\n                                  case update_since I pos X Y\n  (\\<tau> \\<sigma> k) aux of\n                                  (z, x) \\<Rightarrow> (zs @ [z], x)))\n                          (Suc k) \\<and>\n                         list_all2\n                          (\\<lambda>i.\n                              qtable n (fv \\<phi>'' \\<union> fv \\<psi>'')\n                               (mem_restr R)\n                               (\\<lambda>v.\n                                   MFOTL.sat \\<sigma> (map the v) i\n                                    (formula.Since \\<phi>''' I \\<psi>'')))\n                          [min (Monitor.progress \\<sigma> \\<phi>'' j)\n                            (Monitor.progress \\<sigma> \\<psi>'' j)..<\n                           Suc k]\n                          (fst (case z of\n                                (zs, aux) \\<Rightarrow>\n                                  case update_since I pos X Y\n  (\\<tau> \\<sigma> k) aux of\n                                  (z, x) \\<Rightarrow> (zs @ [z], x)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. j \\<le> Suc j\n 2. \\<And>k X Y z.\n       \\<lbrakk>min (Monitor.progress \\<sigma> \\<phi>'' j)\n                 (Monitor.progress \\<sigma> \\<psi>'' j)\n                \\<le> k;\n        Suc k \\<le> Monitor.progress \\<sigma> \\<phi>'' (Suc j);\n        Suc k \\<le> Monitor.progress \\<sigma> \\<psi>'' (Suc j);\n        qtable n (fv \\<phi>'') (mem_restr R)\n         (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<phi>'') X;\n        qtable n (fv \\<psi>'') (mem_restr R)\n         (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<psi>'') Y;\n        wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (snd z) k \\<and>\n        list_all2\n         (\\<lambda>i.\n             qtable n (fv \\<phi>'' \\<union> fv \\<psi>'') (mem_restr R)\n              (\\<lambda>v.\n                  MFOTL.sat \\<sigma> (map the v) i\n                   (formula.Since \\<phi>''' I \\<psi>'')))\n         [min (Monitor.progress \\<sigma> \\<phi>'' j)\n           (Monitor.progress \\<sigma> \\<psi>'' j)..<\n          k]\n         (fst z)\\<rbrakk>\n       \\<Longrightarrow> wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                          (snd (case z of\n                                (zs, aux) \\<Rightarrow>\n                                  case update_since I pos X Y\n  (\\<tau> \\<sigma> k) aux of\n                                  (z, x) \\<Rightarrow> (zs @ [z], x)))\n                          (Suc k) \\<and>\n                         list_all2\n                          (\\<lambda>i.\n                              qtable n (fv \\<phi>'' \\<union> fv \\<psi>'')\n                               (mem_restr R)\n                               (\\<lambda>v.\n                                   MFOTL.sat \\<sigma> (map the v) i\n                                    (formula.Since \\<phi>''' I \\<psi>'')))\n                          [min (Monitor.progress \\<sigma> \\<phi>'' j)\n                            (Monitor.progress \\<sigma> \\<psi>'' j)..<\n                           Suc k]\n                          (fst (case z of\n                                (zs, aux) \\<Rightarrow>\n                                  case update_since I pos X Y\n  (\\<tau> \\<sigma> k) aux of\n                                  (z, x) \\<Rightarrow> (zs @ [z], x)))", "case (step k X Y z)"], ["proof (state)\nthis:\n  min (Monitor.progress \\<sigma> \\<phi>'' j)\n   (Monitor.progress \\<sigma> \\<psi>'' j)\n  \\<le> k\n  Suc k \\<le> Monitor.progress \\<sigma> \\<phi>'' (Suc j)\n  Suc k \\<le> Monitor.progress \\<sigma> \\<psi>'' (Suc j)\n  qtable n (fv \\<phi>'') (mem_restr R)\n   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<phi>'') X\n  qtable n (fv \\<psi>'') (mem_restr R)\n   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<psi>'') Y\n  wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (snd z) k \\<and>\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<phi>'' \\<union> fv \\<psi>'') (mem_restr R)\n        (\\<lambda>v.\n            MFOTL.sat \\<sigma> (map the v) i\n             (formula.Since \\<phi>''' I \\<psi>'')))\n   [min (Monitor.progress \\<sigma> \\<phi>'' j)\n     (Monitor.progress \\<sigma> \\<psi>'' j)..<\n    k]\n   (fst z)\n\ngoal (2 subgoals):\n 1. j \\<le> Suc j\n 2. \\<And>k X Y z.\n       \\<lbrakk>min (Monitor.progress \\<sigma> \\<phi>'' j)\n                 (Monitor.progress \\<sigma> \\<psi>'' j)\n                \\<le> k;\n        Suc k \\<le> Monitor.progress \\<sigma> \\<phi>'' (Suc j);\n        Suc k \\<le> Monitor.progress \\<sigma> \\<psi>'' (Suc j);\n        qtable n (fv \\<phi>'') (mem_restr R)\n         (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<phi>'') X;\n        qtable n (fv \\<psi>'') (mem_restr R)\n         (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<psi>'') Y;\n        wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (snd z) k \\<and>\n        list_all2\n         (\\<lambda>i.\n             qtable n (fv \\<phi>'' \\<union> fv \\<psi>'') (mem_restr R)\n              (\\<lambda>v.\n                  MFOTL.sat \\<sigma> (map the v) i\n                   (formula.Since \\<phi>''' I \\<psi>'')))\n         [min (Monitor.progress \\<sigma> \\<phi>'' j)\n           (Monitor.progress \\<sigma> \\<psi>'' j)..<\n          k]\n         (fst z)\\<rbrakk>\n       \\<Longrightarrow> wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                          (snd (case z of\n                                (zs, aux) \\<Rightarrow>\n                                  case update_since I pos X Y\n  (\\<tau> \\<sigma> k) aux of\n                                  (z, x) \\<Rightarrow> (zs @ [z], x)))\n                          (Suc k) \\<and>\n                         list_all2\n                          (\\<lambda>i.\n                              qtable n (fv \\<phi>'' \\<union> fv \\<psi>'')\n                               (mem_restr R)\n                               (\\<lambda>v.\n                                   MFOTL.sat \\<sigma> (map the v) i\n                                    (formula.Since \\<phi>''' I \\<psi>'')))\n                          [min (Monitor.progress \\<sigma> \\<phi>'' j)\n                            (Monitor.progress \\<sigma> \\<psi>'' j)..<\n                           Suc k]\n                          (fst (case z of\n                                (zs, aux) \\<Rightarrow>\n                                  case update_since I pos X Y\n  (\\<tau> \\<sigma> k) aux of\n                                  (z, x) \\<Rightarrow> (zs @ [z], x)))", "then"], ["proof (chain)\npicking this:\n  min (Monitor.progress \\<sigma> \\<phi>'' j)\n   (Monitor.progress \\<sigma> \\<psi>'' j)\n  \\<le> k\n  Suc k \\<le> Monitor.progress \\<sigma> \\<phi>'' (Suc j)\n  Suc k \\<le> Monitor.progress \\<sigma> \\<psi>'' (Suc j)\n  qtable n (fv \\<phi>'') (mem_restr R)\n   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<phi>'') X\n  qtable n (fv \\<psi>'') (mem_restr R)\n   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<psi>'') Y\n  wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (snd z) k \\<and>\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<phi>'' \\<union> fv \\<psi>'') (mem_restr R)\n        (\\<lambda>v.\n            MFOTL.sat \\<sigma> (map the v) i\n             (formula.Since \\<phi>''' I \\<psi>'')))\n   [min (Monitor.progress \\<sigma> \\<phi>'' j)\n     (Monitor.progress \\<sigma> \\<psi>'' j)..<\n    k]\n   (fst z)", "show ?case"], ["proof (prove)\nusing this:\n  min (Monitor.progress \\<sigma> \\<phi>'' j)\n   (Monitor.progress \\<sigma> \\<psi>'' j)\n  \\<le> k\n  Suc k \\<le> Monitor.progress \\<sigma> \\<phi>'' (Suc j)\n  Suc k \\<le> Monitor.progress \\<sigma> \\<psi>'' (Suc j)\n  qtable n (fv \\<phi>'') (mem_restr R)\n   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<phi>'') X\n  qtable n (fv \\<psi>'') (mem_restr R)\n   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<psi>'') Y\n  wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (snd z) k \\<and>\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<phi>'' \\<union> fv \\<psi>'') (mem_restr R)\n        (\\<lambda>v.\n            MFOTL.sat \\<sigma> (map the v) i\n             (formula.Since \\<phi>''' I \\<psi>'')))\n   [min (Monitor.progress \\<sigma> \\<phi>'' j)\n     (Monitor.progress \\<sigma> \\<psi>'' j)..<\n    k]\n   (fst z)\n\ngoal (1 subgoal):\n 1. wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n     (snd (case z of\n           (zs, aux) \\<Rightarrow>\n             case update_since I pos X Y (\\<tau> \\<sigma> k) aux of\n             (z, x) \\<Rightarrow> (zs @ [z], x)))\n     (Suc k) \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>'' \\<union> fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v.\n              MFOTL.sat \\<sigma> (map the v) i\n               (formula.Since \\<phi>''' I \\<psi>'')))\n     [min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)..<\n      Suc k]\n     (fst (case z of\n           (zs, aux) \\<Rightarrow>\n             case update_since I pos X Y (\\<tau> \\<sigma> k) aux of\n             (z, x) \\<Rightarrow> (zs @ [z], x)))", "using fvi_subset pos"], ["proof (prove)\nusing this:\n  min (Monitor.progress \\<sigma> \\<phi>'' j)\n   (Monitor.progress \\<sigma> \\<psi>'' j)\n  \\<le> k\n  Suc k \\<le> Monitor.progress \\<sigma> \\<phi>'' (Suc j)\n  Suc k \\<le> Monitor.progress \\<sigma> \\<psi>'' (Suc j)\n  qtable n (fv \\<phi>'') (mem_restr R)\n   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<phi>'') X\n  qtable n (fv \\<psi>'') (mem_restr R)\n   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) k \\<psi>'') Y\n  wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (snd z) k \\<and>\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<phi>'' \\<union> fv \\<psi>'') (mem_restr R)\n        (\\<lambda>v.\n            MFOTL.sat \\<sigma> (map the v) i\n             (formula.Since \\<phi>''' I \\<psi>'')))\n   [min (Monitor.progress \\<sigma> \\<phi>'' j)\n     (Monitor.progress \\<sigma> \\<psi>'' j)..<\n    k]\n   (fst z)\n  fv \\<phi>'' \\<subseteq> fv \\<psi>''\n  if pos then \\<phi>''' = \\<phi>'' else \\<phi>''' = formula.Neg \\<phi>''\n\ngoal (1 subgoal):\n 1. wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n     (snd (case z of\n           (zs, aux) \\<Rightarrow>\n             case update_since I pos X Y (\\<tau> \\<sigma> k) aux of\n             (z, x) \\<Rightarrow> (zs @ [z], x)))\n     (Suc k) \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>'' \\<union> fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v.\n              MFOTL.sat \\<sigma> (map the v) i\n               (formula.Since \\<phi>''' I \\<psi>'')))\n     [min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)..<\n      Suc k]\n     (fst (case z of\n           (zs, aux) \\<Rightarrow>\n             case update_since I pos X Y (\\<tau> \\<sigma> k) aux of\n             (z, x) \\<Rightarrow> (zs @ [z], x)))", "by (auto simp: Un_absorb1 elim!: update_since(1) list_all2_appendI dest!: update_since(2)\n        split: prod.split if_splits)"], ["proof (state)\nthis:\n  wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n   (snd (case z of\n         (zs, aux) \\<Rightarrow>\n           case update_since I pos X Y (\\<tau> \\<sigma> k) aux of\n           (z, x) \\<Rightarrow> (zs @ [z], x)))\n   (Suc k) \\<and>\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<phi>'' \\<union> fv \\<psi>'') (mem_restr R)\n        (\\<lambda>v.\n            MFOTL.sat \\<sigma> (map the v) i\n             (formula.Since \\<phi>''' I \\<psi>'')))\n   [min (Monitor.progress \\<sigma> \\<phi>'' j)\n     (Monitor.progress \\<sigma> \\<psi>'' j)..<\n    Suc k]\n   (fst (case z of\n         (zs, aux) \\<Rightarrow>\n           case update_since I pos X Y (\\<tau> \\<sigma> k) aux of\n           (z, x) \\<Rightarrow> (zs @ [z], x)))\n\ngoal (1 subgoal):\n 1. j \\<le> Suc j", "qed simp"], ["proof (state)\nthis:\n  \\<lbrakk>fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>) =\n           ?xs;\n   fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<psi>) = ?ys;\n   mbuf2t_take\n    (\\<lambda>r1 r2 t (zs, aux).\n        case update_since I pos r1 r2 t aux of\n        (z, x) \\<Rightarrow> (zs @ [z], x))\n    ([], aux) (mbuf2_add ?xs ?ys buf) (nts @ [\\<tau> \\<sigma> j]) =\n   ((?zs, ?aux'), ?buf', ?nts')\\<rbrakk>\n  \\<Longrightarrow> wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                     (snd (?zs, ?aux'))\n                     (Monitor.progress \\<sigma>\n                       (formula.Since \\<phi>''' I \\<psi>'') (Suc j)) \\<and>\n                    list_all2\n                     (\\<lambda>i.\n                         qtable n (fv \\<phi>''' \\<union> fv \\<psi>'')\n                          (mem_restr R)\n                          (\\<lambda>v.\n                              MFOTL.sat \\<sigma> (map the v) i\n                               (formula.Since \\<phi>''' I \\<psi>'')))\n                     [Monitor.progress \\<sigma>\n                       (formula.Since \\<phi>''' I \\<psi>'') j..<\n                      Monitor.progress \\<sigma>\n                       (formula.Since \\<phi>''' I \\<psi>'') (Suc j)]\n                     (fst (?zs, ?aux'))\n\ngoal (2 subgoals):\n 1. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MSince x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs\n 2. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "with MSince.IH(1)[OF \\<phi>] MSince.IH(2)[OF \\<psi>]"], ["proof (chain)\npicking this:\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>'' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>'') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>''))\n     [Monitor.progress \\<sigma> \\<phi>'' j..<\n      Monitor.progress \\<sigma> \\<phi>'' (Suc j)]\n     xs\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<psi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<psi>'' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>''))\n     [Monitor.progress \\<sigma> \\<psi>'' j..<\n      Monitor.progress \\<sigma> \\<psi>'' (Suc j)]\n     xs\n  \\<lbrakk>fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>) =\n           ?xs;\n   fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<psi>) = ?ys;\n   mbuf2t_take\n    (\\<lambda>r1 r2 t (zs, aux).\n        case update_since I pos r1 r2 t aux of\n        (z, x) \\<Rightarrow> (zs @ [z], x))\n    ([], aux) (mbuf2_add ?xs ?ys buf) (nts @ [\\<tau> \\<sigma> j]) =\n   ((?zs, ?aux'), ?buf', ?nts')\\<rbrakk>\n  \\<Longrightarrow> wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                     (snd (?zs, ?aux'))\n                     (Monitor.progress \\<sigma>\n                       (formula.Since \\<phi>''' I \\<psi>'') (Suc j)) \\<and>\n                    list_all2\n                     (\\<lambda>i.\n                         qtable n (fv \\<phi>''' \\<union> fv \\<psi>'')\n                          (mem_restr R)\n                          (\\<lambda>v.\n                              MFOTL.sat \\<sigma> (map the v) i\n                               (formula.Since \\<phi>''' I \\<psi>'')))\n                     [Monitor.progress \\<sigma>\n                       (formula.Since \\<phi>''' I \\<psi>'') j..<\n                      Monitor.progress \\<sigma>\n                       (formula.Since \\<phi>''' I \\<psi>'') (Suc j)]\n                     (fst (?zs, ?aux'))", "show ?case"], ["proof (prove)\nusing this:\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>'' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>'') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>''))\n     [Monitor.progress \\<sigma> \\<phi>'' j..<\n      Monitor.progress \\<sigma> \\<phi>'' (Suc j)]\n     xs\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<psi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<psi>'' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>''))\n     [Monitor.progress \\<sigma> \\<psi>'' j..<\n      Monitor.progress \\<sigma> \\<psi>'' (Suc j)]\n     xs\n  \\<lbrakk>fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>) =\n           ?xs;\n   fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<psi>) = ?ys;\n   mbuf2t_take\n    (\\<lambda>r1 r2 t (zs, aux).\n        case update_since I pos r1 r2 t aux of\n        (z, x) \\<Rightarrow> (zs @ [z], x))\n    ([], aux) (mbuf2_add ?xs ?ys buf) (nts @ [\\<tau> \\<sigma> j]) =\n   ((?zs, ?aux'), ?buf', ?nts')\\<rbrakk>\n  \\<Longrightarrow> wf_since_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                     (snd (?zs, ?aux'))\n                     (Monitor.progress \\<sigma>\n                       (formula.Since \\<phi>''' I \\<psi>'') (Suc j)) \\<and>\n                    list_all2\n                     (\\<lambda>i.\n                         qtable n (fv \\<phi>''' \\<union> fv \\<psi>'')\n                          (mem_restr R)\n                          (\\<lambda>v.\n                              MFOTL.sat \\<sigma> (map the v) i\n                               (formula.Since \\<phi>''' I \\<psi>'')))\n                     [Monitor.progress \\<sigma>\n                       (formula.Since \\<phi>''' I \\<psi>'') j..<\n                      Monitor.progress \\<sigma>\n                       (formula.Since \\<phi>''' I \\<psi>'') (Suc j)]\n                     (fst (?zs, ?aux'))\n\ngoal (1 subgoal):\n 1. case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n          (MSince pos \\<phi> I \\<psi> buf nts aux) of\n    (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n      wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n      list_all2\n       (\\<lambda>i.\n           qtable n (fv \\<phi>') (mem_restr R)\n            (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n       [Monitor.progress \\<sigma> \\<phi>' j..<\n        Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n       xs", "by (auto 0 3 simp: Since_eq split: prod.split\n      intro: wf_mformula.Since[OF _  _ pos pos_eq fvi_subset]\n      elim: mbuf2t_take_add'(1)[OF _ buf nts_snoc] mbuf2t_take_add'(2)[OF _ buf nts_snoc])"], ["proof (state)\nthis:\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n        (MSince pos \\<phi> I \\<psi> buf nts aux) of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n     [Monitor.progress \\<sigma> \\<phi>' j..<\n      Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n     xs\n\ngoal (1 subgoal):\n 1. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "case (MUntil pos \\<phi> I \\<psi> buf nts aux)"], ["proof (state)\nthis:\n  wf_mformula \\<sigma> j ?n ?R \\<phi> ?\\<phi>' \\<Longrightarrow>\n  case meval ?n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) ?n ?R \\<phi>\\<^sub>n ?\\<phi>' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable ?n (fv ?\\<phi>') (mem_restr ?R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i ?\\<phi>'))\n     [Monitor.progress \\<sigma> ?\\<phi>' j..<\n      Monitor.progress \\<sigma> ?\\<phi>' (Suc j)]\n     xs\n  wf_mformula \\<sigma> j ?n ?R \\<psi> ?\\<phi>' \\<Longrightarrow>\n  case meval ?n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<psi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) ?n ?R \\<phi>\\<^sub>n ?\\<phi>' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable ?n (fv ?\\<phi>') (mem_restr ?R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i ?\\<phi>'))\n     [Monitor.progress \\<sigma> ?\\<phi>' j..<\n      Monitor.progress \\<sigma> ?\\<phi>' (Suc j)]\n     xs\n  wf_mformula \\<sigma> j n R (MUntil pos \\<phi> I \\<psi> buf nts aux)\n   \\<phi>'\n\ngoal (1 subgoal):\n 1. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "note sat.simps[simp del] progress.simps[simp del]"], ["proof (state)\nthis:\n  MFOTL.sat ?\\<sigma> ?v ?i (formula.Pred ?r ?ts) =\n  ((?r, map (MFOTL.eval_trm ?v) ?ts) \\<in> \\<Gamma> ?\\<sigma> ?i)\n  MFOTL.sat ?\\<sigma> ?v ?i (formula.Eq ?t1.0 ?t2.0) =\n  (MFOTL.eval_trm ?v ?t1.0 = MFOTL.eval_trm ?v ?t2.0)\n  MFOTL.sat ?\\<sigma> ?v ?i (formula.Neg ?\\<phi>) =\n  (\\<not> MFOTL.sat ?\\<sigma> ?v ?i ?\\<phi>)\n  MFOTL.sat ?\\<sigma> ?v ?i (formula.Or ?\\<phi> ?\\<psi>) =\n  (MFOTL.sat ?\\<sigma> ?v ?i ?\\<phi> \\<or>\n   MFOTL.sat ?\\<sigma> ?v ?i ?\\<psi>)\n  MFOTL.sat ?\\<sigma> ?v ?i (formula.Exists ?\\<phi>) =\n  (\\<exists>z. MFOTL.sat ?\\<sigma> (z # ?v) ?i ?\\<phi>)\n  MFOTL.sat ?\\<sigma> ?v ?i (formula.Prev ?I ?\\<phi>) =\n  (case ?i of 0 \\<Rightarrow> False\n   | Suc j \\<Rightarrow>\n       mem (\\<tau> ?\\<sigma> ?i - \\<tau> ?\\<sigma> j) ?I \\<and>\n       MFOTL.sat ?\\<sigma> ?v j ?\\<phi>)\n  MFOTL.sat ?\\<sigma> ?v ?i (formula.Next ?I ?\\<phi>) =\n  (mem (\\<tau> ?\\<sigma> (Suc ?i) - \\<tau> ?\\<sigma> ?i) ?I \\<and>\n   MFOTL.sat ?\\<sigma> ?v (Suc ?i) ?\\<phi>)\n  MFOTL.sat ?\\<sigma> ?v ?i (formula.Since ?\\<phi> ?I ?\\<psi>) =\n  (\\<exists>j\\<le>?i.\n      mem (\\<tau> ?\\<sigma> ?i - \\<tau> ?\\<sigma> j) ?I \\<and>\n      MFOTL.sat ?\\<sigma> ?v j ?\\<psi> \\<and>\n      (\\<forall>k\\<in>{j<..?i}. MFOTL.sat ?\\<sigma> ?v k ?\\<phi>))\n  MFOTL.sat ?\\<sigma> ?v ?i (formula.Until ?\\<phi> ?I ?\\<psi>) =\n  (\\<exists>j\\<ge>?i.\n      mem (\\<tau> ?\\<sigma> j - \\<tau> ?\\<sigma> ?i) ?I \\<and>\n      MFOTL.sat ?\\<sigma> ?v j ?\\<psi> \\<and>\n      (\\<forall>k\\<in>{?i..<j}. MFOTL.sat ?\\<sigma> ?v k ?\\<phi>))\n  Monitor.progress ?\\<sigma> (formula.Pred ?e ?ts) ?j = ?j\n  Monitor.progress ?\\<sigma> (formula.Eq ?t1.0 ?t2.0) ?j = ?j\n  Monitor.progress ?\\<sigma> (formula.Neg ?\\<phi>) ?j =\n  Monitor.progress ?\\<sigma> ?\\<phi> ?j\n  Monitor.progress ?\\<sigma> (formula.Or ?\\<phi> ?\\<psi>) ?j =\n  min (Monitor.progress ?\\<sigma> ?\\<phi> ?j)\n   (Monitor.progress ?\\<sigma> ?\\<psi> ?j)\n  Monitor.progress ?\\<sigma> (formula.Exists ?\\<phi>) ?j =\n  Monitor.progress ?\\<sigma> ?\\<phi> ?j\n  Monitor.progress ?\\<sigma> (formula.Prev ?I ?\\<phi>) ?j =\n  (if ?j = 0 then 0\n   else min (Suc (Monitor.progress ?\\<sigma> ?\\<phi> ?j)) ?j)\n  Monitor.progress ?\\<sigma> (formula.Next ?I ?\\<phi>) ?j =\n  Monitor.progress ?\\<sigma> ?\\<phi> ?j - 1\n  Monitor.progress ?\\<sigma> (formula.Since ?\\<phi> ?I ?\\<psi>) ?j =\n  min (Monitor.progress ?\\<sigma> ?\\<phi> ?j)\n   (Monitor.progress ?\\<sigma> ?\\<psi> ?j)\n  Monitor.progress ?\\<sigma> (formula.Until ?\\<phi> ?I ?\\<psi>) ?j =\n  Inf {i. \\<forall>k.\n             k < ?j \\<and>\n             k \\<le> min (Monitor.progress ?\\<sigma> ?\\<phi> ?j)\n                      (Monitor.progress ?\\<sigma> ?\\<psi>\n                        ?j) \\<longrightarrow>\n             enat (\\<tau> ?\\<sigma> k)\n             \\<le> enat (\\<tau> ?\\<sigma> i) + right ?I}\n\ngoal (1 subgoal):\n 1. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "from MUntil.prems"], ["proof (chain)\npicking this:\n  wf_mformula \\<sigma> j n R (MUntil pos \\<phi> I \\<psi> buf nts aux)\n   \\<phi>'", "obtain \\<phi>'' \\<phi>''' \\<psi>'' where Until_eq: \"\\<phi>' = MFOTL.Until \\<phi>''' I \\<psi>''\"\n    and pos: \"if pos then \\<phi>''' = \\<phi>'' else \\<phi>''' = MFOTL.Neg \\<phi>''\"\n    and pos_eq: \"safe_formula \\<phi>''' = pos\"\n    and \\<phi>: \"wf_mformula \\<sigma> j n R \\<phi> \\<phi>''\"\n    and \\<psi>: \"wf_mformula \\<sigma> j n R \\<psi> \\<psi>''\"\n    and fvi_subset: \"MFOTL.fv \\<phi>'' \\<subseteq> MFOTL.fv \\<psi>''\"\n    and buf: \"wf_mbuf2' \\<sigma> j n R \\<phi>'' \\<psi>'' buf\"\n    and nts: \"wf_ts \\<sigma> j \\<phi>'' \\<psi>'' nts\"\n    and aux: \"wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux (progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') j)\"\n    and length_aux: \"progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') j + length aux =\n      min (progress \\<sigma> \\<phi>'' j) (progress \\<sigma> \\<psi>'' j)\""], ["proof (prove)\nusing this:\n  wf_mformula \\<sigma> j n R (MUntil pos \\<phi> I \\<psi> buf nts aux)\n   \\<phi>'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>'''' \\<psi>'' \\<phi>'''''.\n        \\<lbrakk>\\<phi>' = formula.Until \\<phi>'''' I \\<psi>'';\n         if pos then \\<phi>'''' = \\<phi>'''''\n         else \\<phi>'''' = formula.Neg \\<phi>''''';\n         safe_formula \\<phi>'''' = pos;\n         wf_mformula \\<sigma> j n R \\<phi> \\<phi>''''';\n         wf_mformula \\<sigma> j n R \\<psi> \\<psi>'';\n         fv \\<phi>''''' \\<subseteq> fv \\<psi>'';\n         wf_mbuf2' \\<sigma> j n R \\<phi>''''' \\<psi>'' buf;\n         wf_ts \\<sigma> j \\<phi>''''' \\<psi>'' nts;\n         wf_until_aux \\<sigma> n R pos \\<phi>''''' I \\<psi>'' aux\n          (Monitor.progress \\<sigma> (formula.Until \\<phi>'''' I \\<psi>'')\n            j);\n         Monitor.progress \\<sigma> (formula.Until \\<phi>'''' I \\<psi>'') j +\n         length aux =\n         min (Monitor.progress \\<sigma> \\<phi>''''' j)\n          (Monitor.progress \\<sigma> \\<psi>'' j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases pred: wf_mformula) (auto)"], ["proof (state)\nthis:\n  \\<phi>' = formula.Until \\<phi>''' I \\<psi>''\n  if pos then \\<phi>''' = \\<phi>'' else \\<phi>''' = formula.Neg \\<phi>''\n  safe_formula \\<phi>''' = pos\n  wf_mformula \\<sigma> j n R \\<phi> \\<phi>''\n  wf_mformula \\<sigma> j n R \\<psi> \\<psi>''\n  fv \\<phi>'' \\<subseteq> fv \\<psi>''\n  wf_mbuf2' \\<sigma> j n R \\<phi>'' \\<psi>'' buf\n  wf_ts \\<sigma> j \\<phi>'' \\<psi>'' nts\n  wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux\n   (Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') j)\n  Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') j +\n  length aux =\n  min (Monitor.progress \\<sigma> \\<phi>'' j)\n   (Monitor.progress \\<sigma> \\<psi>'' j)\n\ngoal (1 subgoal):\n 1. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "have \\<phi>''': \"progress \\<sigma> \\<phi>''' j = progress \\<sigma> \\<phi>'' j\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. Monitor.progress \\<sigma> \\<phi>''' j =\n    Monitor.progress \\<sigma> \\<phi>'' j", "using pos"], ["proof (prove)\nusing this:\n  if pos then \\<phi>''' = \\<phi>'' else \\<phi>''' = formula.Neg \\<phi>''\n\ngoal (1 subgoal):\n 1. Monitor.progress \\<sigma> \\<phi>''' j =\n    Monitor.progress \\<sigma> \\<phi>'' j", "by (simp_all add: progress.simps split: if_splits)"], ["proof (state)\nthis:\n  Monitor.progress \\<sigma> \\<phi>''' ?j =\n  Monitor.progress \\<sigma> \\<phi>'' ?j\n\ngoal (1 subgoal):\n 1. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "have nts_snoc: \"list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n    [min (progress \\<sigma> \\<phi>'' j) (progress \\<sigma> \\<psi>'' j)..<Suc j] (nts @ [\\<tau> \\<sigma> j])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n     [min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)..<\n      Suc j]\n     (nts @ [\\<tau> \\<sigma> j])", "using nts"], ["proof (prove)\nusing this:\n  wf_ts \\<sigma> j \\<phi>'' \\<psi>'' nts\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n     [min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)..<\n      Suc j]\n     (nts @ [\\<tau> \\<sigma> j])", "unfolding wf_ts_def"], ["proof (prove)\nusing this:\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<phi>'' j)\n     (Monitor.progress \\<sigma> \\<psi>'' j)..<\n    j]\n   nts\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n     [min (Monitor.progress \\<sigma> \\<phi>'' j)\n       (Monitor.progress \\<sigma> \\<psi>'' j)..<\n      Suc j]\n     (nts @ [\\<tau> \\<sigma> j])", "by (auto simp add: progress_le[THEN min.coboundedI1] intro: list_all2_appendI)"], ["proof (state)\nthis:\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<phi>'' j)\n     (Monitor.progress \\<sigma> \\<psi>'' j)..<\n    Suc j]\n   (nts @ [\\<tau> \\<sigma> j])\n\ngoal (1 subgoal):\n 1. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "{"], ["proof (state)\nthis:\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<phi>'' j)\n     (Monitor.progress \\<sigma> \\<psi>'' j)..<\n    Suc j]\n   (nts @ [\\<tau> \\<sigma> j])\n\ngoal (1 subgoal):\n 1. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "fix xs ys zs aux' aux'' buf' nts'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "assume eval_\\<phi>: \"fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>) = xs\"\n      and eval_\\<psi>: \"fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<psi>) = ys\"\n      and eq1: \"mbuf2t_take (update_until I pos) aux (mbuf2_add xs ys buf) (nts @ [\\<tau> \\<sigma> j]) =\n        (aux', buf', nts')\"\n      and eq2: \"eval_until I (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j | nt # _ \\<Rightarrow> nt) aux' = (zs, aux'')\""], ["proof (state)\nthis:\n  fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>) = xs\n  fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<psi>) = ys\n  mbuf2t_take (update_until I pos) aux (mbuf2_add xs ys buf)\n   (nts @ [\\<tau> \\<sigma> j]) =\n  (aux', buf', nts')\n  eval_until I\n   (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n    | nt # x \\<Rightarrow> nt)\n   aux' =\n  (zs, aux'')\n\ngoal (1 subgoal):\n 1. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "have update1: \"wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux' (progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') j) \\<and>\n      progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') j + length aux' =\n        min (progress \\<sigma> \\<phi>''' (Suc j)) (progress \\<sigma> \\<psi>'' (Suc j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux'\n     (Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n       j) \\<and>\n    Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') j +\n    length aux' =\n    min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n     (Monitor.progress \\<sigma> \\<psi>'' (Suc j))", "using MUntil.IH(1)[OF \\<phi>] eval_\\<phi> MUntil.IH(2)[OF \\<psi>]\n        eval_\\<psi> nts_snoc nts_snoc length_aux aux fvi_subset"], ["proof (prove)\nusing this:\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>'' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>'') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>''))\n     [Monitor.progress \\<sigma> \\<phi>'' j..<\n      Monitor.progress \\<sigma> \\<phi>'' (Suc j)]\n     xs\n  fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>) = xs\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<psi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<psi>'' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>''))\n     [Monitor.progress \\<sigma> \\<psi>'' j..<\n      Monitor.progress \\<sigma> \\<psi>'' (Suc j)]\n     xs\n  fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<psi>) = ys\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<phi>'' j)\n     (Monitor.progress \\<sigma> \\<psi>'' j)..<\n    Suc j]\n   (nts @ [\\<tau> \\<sigma> j])\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<phi>'' j)\n     (Monitor.progress \\<sigma> \\<psi>'' j)..<\n    Suc j]\n   (nts @ [\\<tau> \\<sigma> j])\n  Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') j +\n  length aux =\n  min (Monitor.progress \\<sigma> \\<phi>'' j)\n   (Monitor.progress \\<sigma> \\<psi>'' j)\n  wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux\n   (Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') j)\n  fv \\<phi>'' \\<subseteq> fv \\<psi>''\n\ngoal (1 subgoal):\n 1. wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux'\n     (Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n       j) \\<and>\n    Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') j +\n    length aux' =\n    min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n     (Monitor.progress \\<sigma> \\<psi>'' (Suc j))", "unfolding \\<phi>'''"], ["proof (prove)\nusing this:\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>'' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>'') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>''))\n     [Monitor.progress \\<sigma> \\<phi>'' j..<\n      Monitor.progress \\<sigma> \\<phi>'' (Suc j)]\n     xs\n  fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>) = xs\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<psi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<psi>'' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>''))\n     [Monitor.progress \\<sigma> \\<psi>'' j..<\n      Monitor.progress \\<sigma> \\<psi>'' (Suc j)]\n     xs\n  fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<psi>) = ys\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<phi>'' j)\n     (Monitor.progress \\<sigma> \\<psi>'' j)..<\n    Suc j]\n   (nts @ [\\<tau> \\<sigma> j])\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<phi>'' j)\n     (Monitor.progress \\<sigma> \\<psi>'' j)..<\n    Suc j]\n   (nts @ [\\<tau> \\<sigma> j])\n  Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') j +\n  length aux =\n  min (Monitor.progress \\<sigma> \\<phi>'' j)\n   (Monitor.progress \\<sigma> \\<psi>'' j)\n  wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux\n   (Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') j)\n  fv \\<phi>'' \\<subseteq> fv \\<psi>''\n\ngoal (1 subgoal):\n 1. wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux'\n     (Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n       j) \\<and>\n    Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') j +\n    length aux' =\n    min (Monitor.progress \\<sigma> \\<phi>'' (Suc j))\n     (Monitor.progress \\<sigma> \\<psi>'' (Suc j))", "by (elim mbuf2t_take_add_induct'[where j'=\"Suc j\", OF eq1 buf])\n        (auto simp: length_update_until elim: wf_update_until)"], ["proof (state)\nthis:\n  wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux'\n   (Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') j) \\<and>\n  Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') j +\n  length aux' =\n  min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n   (Monitor.progress \\<sigma> \\<psi>'' (Suc j))\n\ngoal (1 subgoal):\n 1. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "have nts': \"wf_ts \\<sigma> (Suc j) \\<phi>'' \\<psi>'' nts'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_ts \\<sigma> (Suc j) \\<phi>'' \\<psi>'' nts'", "using MUntil.IH(1)[OF \\<phi>] eval_\\<phi> MUntil.IH(2)[OF \\<psi>] eval_\\<psi> nts_snoc"], ["proof (prove)\nusing this:\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>'' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>'') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>''))\n     [Monitor.progress \\<sigma> \\<phi>'' j..<\n      Monitor.progress \\<sigma> \\<phi>'' (Suc j)]\n     xs\n  fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>) = xs\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<psi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<psi>'' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>''))\n     [Monitor.progress \\<sigma> \\<psi>'' j..<\n      Monitor.progress \\<sigma> \\<psi>'' (Suc j)]\n     xs\n  fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<psi>) = ys\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<phi>'' j)\n     (Monitor.progress \\<sigma> \\<psi>'' j)..<\n    Suc j]\n   (nts @ [\\<tau> \\<sigma> j])\n\ngoal (1 subgoal):\n 1. wf_ts \\<sigma> (Suc j) \\<phi>'' \\<psi>'' nts'", "unfolding wf_ts_def"], ["proof (prove)\nusing this:\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>'' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>'') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>''))\n     [Monitor.progress \\<sigma> \\<phi>'' j..<\n      Monitor.progress \\<sigma> \\<phi>'' (Suc j)]\n     xs\n  fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>) = xs\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<psi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<psi>'' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>''))\n     [Monitor.progress \\<sigma> \\<psi>'' j..<\n      Monitor.progress \\<sigma> \\<psi>'' (Suc j)]\n     xs\n  fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<psi>) = ys\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<phi>'' j)\n     (Monitor.progress \\<sigma> \\<psi>'' j)..<\n    Suc j]\n   (nts @ [\\<tau> \\<sigma> j])\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n     [min (Monitor.progress \\<sigma> \\<phi>'' (Suc j))\n       (Monitor.progress \\<sigma> \\<psi>'' (Suc j))..<\n      Suc j]\n     nts'", "by (intro mbuf2t_take_eqD(2)[OF eq1]) (auto simp: progress_mono progress_le\n        intro: wf_mbuf2_add buf[unfolded wf_mbuf2'_def])"], ["proof (state)\nthis:\n  wf_ts \\<sigma> (Suc j) \\<phi>'' \\<psi>'' nts'\n\ngoal (1 subgoal):\n 1. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "have \"i \\<le> progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') (Suc j) \\<Longrightarrow>\n      wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux' i \\<Longrightarrow>\n      i + length aux' = min (progress \\<sigma> \\<phi>''' (Suc j)) (progress \\<sigma> \\<psi>'' (Suc j)) \\<Longrightarrow>\n      wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux'' (progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') (Suc j)) \\<and>\n        i + length zs = progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') (Suc j) \\<and>\n        i + length zs + length aux'' = min (progress \\<sigma> \\<phi>''' (Suc j)) (progress \\<sigma> \\<psi>'' (Suc j)) \\<and>\n        list_all2 (\\<lambda>i. qtable n (MFOTL.fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i (formula.Until (if pos then \\<phi>'' else MFOTL.Neg \\<phi>'') I \\<psi>'')))\n          [i..<i + length zs] zs\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> Monitor.progress \\<sigma>\n                      (formula.Until \\<phi>''' I \\<psi>'') (Suc j);\n     wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux' i;\n     i + length aux' =\n     min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n      (Monitor.progress \\<sigma> \\<psi>'' (Suc j))\\<rbrakk>\n    \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                       aux''\n                       (Monitor.progress \\<sigma>\n                         (formula.Until \\<phi>''' I \\<psi>'')\n                         (Suc j)) \\<and>\n                      i + length zs =\n                      Monitor.progress \\<sigma>\n                       (formula.Until \\<phi>''' I \\<psi>'') (Suc j) \\<and>\n                      i + length zs + length aux'' =\n                      min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                       (Monitor.progress \\<sigma> \\<psi>'' (Suc j)) \\<and>\n                      list_all2\n                       (\\<lambda>i.\n                           qtable n (fv \\<psi>'') (mem_restr R)\n                            (\\<lambda>v.\n                                MFOTL.sat \\<sigma> (map the v) i\n                                 (formula.Until\n                                   (if pos then \\<phi>''\n                                    else formula.Neg \\<phi>'')\n                                   I \\<psi>'')))\n                       [i..<i + length zs] zs", "using eq2"], ["proof (prove)\nusing this:\n  eval_until I\n   (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n    | nt # x \\<Rightarrow> nt)\n   aux' =\n  (zs, aux'')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> Monitor.progress \\<sigma>\n                      (formula.Until \\<phi>''' I \\<psi>'') (Suc j);\n     wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux' i;\n     i + length aux' =\n     min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n      (Monitor.progress \\<sigma> \\<psi>'' (Suc j))\\<rbrakk>\n    \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                       aux''\n                       (Monitor.progress \\<sigma>\n                         (formula.Until \\<phi>''' I \\<psi>'')\n                         (Suc j)) \\<and>\n                      i + length zs =\n                      Monitor.progress \\<sigma>\n                       (formula.Until \\<phi>''' I \\<psi>'') (Suc j) \\<and>\n                      i + length zs + length aux'' =\n                      min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                       (Monitor.progress \\<sigma> \\<psi>'' (Suc j)) \\<and>\n                      list_all2\n                       (\\<lambda>i.\n                           qtable n (fv \\<psi>'') (mem_restr R)\n                            (\\<lambda>v.\n                                MFOTL.sat \\<sigma> (map the v) i\n                                 (formula.Until\n                                   (if pos then \\<phi>''\n                                    else formula.Neg \\<phi>'')\n                                   I \\<psi>'')))\n                       [i..<i + length zs] zs", "proof (induction aux' arbitrary: zs aux'' i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>zs aux'' i.\n       \\<lbrakk>i \\<le> Monitor.progress \\<sigma>\n                         (formula.Until \\<phi>''' I \\<psi>'') (Suc j);\n        wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' [] i;\n        i + length [] =\n        min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n         (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n        eval_until I\n         (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n          | nt # x \\<Rightarrow> nt)\n         [] =\n        (zs, aux'')\\<rbrakk>\n       \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                          aux''\n                          (Monitor.progress \\<sigma>\n                            (formula.Until \\<phi>''' I \\<psi>'')\n                            (Suc j)) \\<and>\n                         i + length zs =\n                         Monitor.progress \\<sigma>\n                          (formula.Until \\<phi>''' I \\<psi>'')\n                          (Suc j) \\<and>\n                         i + length zs + length aux'' =\n                         min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                          (Monitor.progress \\<sigma> \\<psi>''\n                            (Suc j)) \\<and>\n                         list_all2\n                          (\\<lambda>i.\n                              qtable n (fv \\<psi>'') (mem_restr R)\n                               (\\<lambda>v.\n                                   MFOTL.sat \\<sigma> (map the v) i\n                                    (formula.Until\n(if pos then \\<phi>'' else formula.Neg \\<phi>'') I \\<psi>'')))\n                          [i..<i + length zs] zs\n 2. \\<And>a aux' zs aux'' i.\n       \\<lbrakk>\\<And>zs aux'' i.\n                   \\<lbrakk>i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>''' I \\<psi>'')\n                                     (Suc j);\n                    wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux'\n                     i;\n                    i + length aux' =\n                    min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                     (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n                    eval_until I\n                     (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n                      | nt # x \\<Rightarrow> nt)\n                     aux' =\n                    (zs, aux'')\\<rbrakk>\n                   \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>''\nI \\<psi>'' aux''\n(Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n  (Suc j)) \\<and>\n                                     i + length zs =\n                                     Monitor.progress \\<sigma>\n(formula.Until \\<phi>''' I \\<psi>'') (Suc j) \\<and>\n                                     i + length zs + length aux'' =\n                                     min\n(Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n(Monitor.progress \\<sigma> \\<psi>'' (Suc j)) \\<and>\n                                     list_all2\n(\\<lambda>i.\n    qtable n (fv \\<psi>'') (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) i\n          (formula.Until (if pos then \\<phi>'' else formula.Neg \\<phi>'') I\n            \\<psi>'')))\n[i..<i + length zs] zs;\n        i \\<le> Monitor.progress \\<sigma>\n                 (formula.Until \\<phi>''' I \\<psi>'') (Suc j);\n        wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (a # aux') i;\n        i + length (a # aux') =\n        min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n         (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n        eval_until I\n         (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n          | nt # x \\<Rightarrow> nt)\n         (a # aux') =\n        (zs, aux'')\\<rbrakk>\n       \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                          aux''\n                          (Monitor.progress \\<sigma>\n                            (formula.Until \\<phi>''' I \\<psi>'')\n                            (Suc j)) \\<and>\n                         i + length zs =\n                         Monitor.progress \\<sigma>\n                          (formula.Until \\<phi>''' I \\<psi>'')\n                          (Suc j) \\<and>\n                         i + length zs + length aux'' =\n                         min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                          (Monitor.progress \\<sigma> \\<psi>''\n                            (Suc j)) \\<and>\n                         list_all2\n                          (\\<lambda>i.\n                              qtable n (fv \\<psi>'') (mem_restr R)\n                               (\\<lambda>v.\n                                   MFOTL.sat \\<sigma> (map the v) i\n                                    (formula.Until\n(if pos then \\<phi>'' else formula.Neg \\<phi>'') I \\<psi>'')))\n                          [i..<i + length zs] zs", "case Nil"], ["proof (state)\nthis:\n  i \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n           (Suc j)\n  wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' [] i\n  i + length [] =\n  min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n   (Monitor.progress \\<sigma> \\<psi>'' (Suc j))\n  eval_until I\n   (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n    | nt # x \\<Rightarrow> nt)\n   [] =\n  (zs, aux'')\n\ngoal (2 subgoals):\n 1. \\<And>zs aux'' i.\n       \\<lbrakk>i \\<le> Monitor.progress \\<sigma>\n                         (formula.Until \\<phi>''' I \\<psi>'') (Suc j);\n        wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' [] i;\n        i + length [] =\n        min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n         (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n        eval_until I\n         (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n          | nt # x \\<Rightarrow> nt)\n         [] =\n        (zs, aux'')\\<rbrakk>\n       \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                          aux''\n                          (Monitor.progress \\<sigma>\n                            (formula.Until \\<phi>''' I \\<psi>'')\n                            (Suc j)) \\<and>\n                         i + length zs =\n                         Monitor.progress \\<sigma>\n                          (formula.Until \\<phi>''' I \\<psi>'')\n                          (Suc j) \\<and>\n                         i + length zs + length aux'' =\n                         min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                          (Monitor.progress \\<sigma> \\<psi>''\n                            (Suc j)) \\<and>\n                         list_all2\n                          (\\<lambda>i.\n                              qtable n (fv \\<psi>'') (mem_restr R)\n                               (\\<lambda>v.\n                                   MFOTL.sat \\<sigma> (map the v) i\n                                    (formula.Until\n(if pos then \\<phi>'' else formula.Neg \\<phi>'') I \\<psi>'')))\n                          [i..<i + length zs] zs\n 2. \\<And>a aux' zs aux'' i.\n       \\<lbrakk>\\<And>zs aux'' i.\n                   \\<lbrakk>i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>''' I \\<psi>'')\n                                     (Suc j);\n                    wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux'\n                     i;\n                    i + length aux' =\n                    min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                     (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n                    eval_until I\n                     (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n                      | nt # x \\<Rightarrow> nt)\n                     aux' =\n                    (zs, aux'')\\<rbrakk>\n                   \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>''\nI \\<psi>'' aux''\n(Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n  (Suc j)) \\<and>\n                                     i + length zs =\n                                     Monitor.progress \\<sigma>\n(formula.Until \\<phi>''' I \\<psi>'') (Suc j) \\<and>\n                                     i + length zs + length aux'' =\n                                     min\n(Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n(Monitor.progress \\<sigma> \\<psi>'' (Suc j)) \\<and>\n                                     list_all2\n(\\<lambda>i.\n    qtable n (fv \\<psi>'') (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) i\n          (formula.Until (if pos then \\<phi>'' else formula.Neg \\<phi>'') I\n            \\<psi>'')))\n[i..<i + length zs] zs;\n        i \\<le> Monitor.progress \\<sigma>\n                 (formula.Until \\<phi>''' I \\<psi>'') (Suc j);\n        wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (a # aux') i;\n        i + length (a # aux') =\n        min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n         (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n        eval_until I\n         (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n          | nt # x \\<Rightarrow> nt)\n         (a # aux') =\n        (zs, aux'')\\<rbrakk>\n       \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                          aux''\n                          (Monitor.progress \\<sigma>\n                            (formula.Until \\<phi>''' I \\<psi>'')\n                            (Suc j)) \\<and>\n                         i + length zs =\n                         Monitor.progress \\<sigma>\n                          (formula.Until \\<phi>''' I \\<psi>'')\n                          (Suc j) \\<and>\n                         i + length zs + length aux'' =\n                         min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                          (Monitor.progress \\<sigma> \\<psi>''\n                            (Suc j)) \\<and>\n                         list_all2\n                          (\\<lambda>i.\n                              qtable n (fv \\<psi>'') (mem_restr R)\n                               (\\<lambda>v.\n                                   MFOTL.sat \\<sigma> (map the v) i\n                                    (formula.Until\n(if pos then \\<phi>'' else formula.Neg \\<phi>'') I \\<psi>'')))\n                          [i..<i + length zs] zs", "then"], ["proof (chain)\npicking this:\n  i \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n           (Suc j)\n  wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' [] i\n  i + length [] =\n  min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n   (Monitor.progress \\<sigma> \\<psi>'' (Suc j))\n  eval_until I\n   (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n    | nt # x \\<Rightarrow> nt)\n   [] =\n  (zs, aux'')", "show ?case"], ["proof (prove)\nusing this:\n  i \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n           (Suc j)\n  wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' [] i\n  i + length [] =\n  min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n   (Monitor.progress \\<sigma> \\<psi>'' (Suc j))\n  eval_until I\n   (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n    | nt # x \\<Rightarrow> nt)\n   [] =\n  (zs, aux'')\n\ngoal (1 subgoal):\n 1. wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux''\n     (Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n       (Suc j)) \\<and>\n    i + length zs =\n    Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n     (Suc j) \\<and>\n    i + length zs + length aux'' =\n    min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n     (Monitor.progress \\<sigma> \\<psi>'' (Suc j)) \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v.\n              MFOTL.sat \\<sigma> (map the v) i\n               (formula.Until\n                 (if pos then \\<phi>'' else formula.Neg \\<phi>'') I\n                 \\<psi>'')))\n     [i..<i + length zs] zs", "by (auto dest!: antisym[OF progress_Until_le])"], ["proof (state)\nthis:\n  wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux''\n   (Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n     (Suc j)) \\<and>\n  i + length zs =\n  Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n   (Suc j) \\<and>\n  i + length zs + length aux'' =\n  min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n   (Monitor.progress \\<sigma> \\<psi>'' (Suc j)) \\<and>\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<psi>'') (mem_restr R)\n        (\\<lambda>v.\n            MFOTL.sat \\<sigma> (map the v) i\n             (formula.Until (if pos then \\<phi>'' else formula.Neg \\<phi>'')\n               I \\<psi>'')))\n   [i..<i + length zs] zs\n\ngoal (1 subgoal):\n 1. \\<And>a aux' zs aux'' i.\n       \\<lbrakk>\\<And>zs aux'' i.\n                   \\<lbrakk>i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>''' I \\<psi>'')\n                                     (Suc j);\n                    wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux'\n                     i;\n                    i + length aux' =\n                    min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                     (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n                    eval_until I\n                     (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n                      | nt # x \\<Rightarrow> nt)\n                     aux' =\n                    (zs, aux'')\\<rbrakk>\n                   \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>''\nI \\<psi>'' aux''\n(Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n  (Suc j)) \\<and>\n                                     i + length zs =\n                                     Monitor.progress \\<sigma>\n(formula.Until \\<phi>''' I \\<psi>'') (Suc j) \\<and>\n                                     i + length zs + length aux'' =\n                                     min\n(Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n(Monitor.progress \\<sigma> \\<psi>'' (Suc j)) \\<and>\n                                     list_all2\n(\\<lambda>i.\n    qtable n (fv \\<psi>'') (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) i\n          (formula.Until (if pos then \\<phi>'' else formula.Neg \\<phi>'') I\n            \\<psi>'')))\n[i..<i + length zs] zs;\n        i \\<le> Monitor.progress \\<sigma>\n                 (formula.Until \\<phi>''' I \\<psi>'') (Suc j);\n        wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (a # aux') i;\n        i + length (a # aux') =\n        min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n         (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n        eval_until I\n         (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n          | nt # x \\<Rightarrow> nt)\n         (a # aux') =\n        (zs, aux'')\\<rbrakk>\n       \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                          aux''\n                          (Monitor.progress \\<sigma>\n                            (formula.Until \\<phi>''' I \\<psi>'')\n                            (Suc j)) \\<and>\n                         i + length zs =\n                         Monitor.progress \\<sigma>\n                          (formula.Until \\<phi>''' I \\<psi>'')\n                          (Suc j) \\<and>\n                         i + length zs + length aux'' =\n                         min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                          (Monitor.progress \\<sigma> \\<psi>''\n                            (Suc j)) \\<and>\n                         list_all2\n                          (\\<lambda>i.\n                              qtable n (fv \\<psi>'') (mem_restr R)\n                               (\\<lambda>v.\n                                   MFOTL.sat \\<sigma> (map the v) i\n                                    (formula.Until\n(if pos then \\<phi>'' else formula.Neg \\<phi>'') I \\<psi>'')))\n                          [i..<i + length zs] zs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aux' zs aux'' i.\n       \\<lbrakk>\\<And>zs aux'' i.\n                   \\<lbrakk>i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>''' I \\<psi>'')\n                                     (Suc j);\n                    wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux'\n                     i;\n                    i + length aux' =\n                    min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                     (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n                    eval_until I\n                     (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n                      | nt # x \\<Rightarrow> nt)\n                     aux' =\n                    (zs, aux'')\\<rbrakk>\n                   \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>''\nI \\<psi>'' aux''\n(Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n  (Suc j)) \\<and>\n                                     i + length zs =\n                                     Monitor.progress \\<sigma>\n(formula.Until \\<phi>''' I \\<psi>'') (Suc j) \\<and>\n                                     i + length zs + length aux'' =\n                                     min\n(Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n(Monitor.progress \\<sigma> \\<psi>'' (Suc j)) \\<and>\n                                     list_all2\n(\\<lambda>i.\n    qtable n (fv \\<psi>'') (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) i\n          (formula.Until (if pos then \\<phi>'' else formula.Neg \\<phi>'') I\n            \\<psi>'')))\n[i..<i + length zs] zs;\n        i \\<le> Monitor.progress \\<sigma>\n                 (formula.Until \\<phi>''' I \\<psi>'') (Suc j);\n        wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (a # aux') i;\n        i + length (a # aux') =\n        min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n         (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n        eval_until I\n         (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n          | nt # x \\<Rightarrow> nt)\n         (a # aux') =\n        (zs, aux'')\\<rbrakk>\n       \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                          aux''\n                          (Monitor.progress \\<sigma>\n                            (formula.Until \\<phi>''' I \\<psi>'')\n                            (Suc j)) \\<and>\n                         i + length zs =\n                         Monitor.progress \\<sigma>\n                          (formula.Until \\<phi>''' I \\<psi>'')\n                          (Suc j) \\<and>\n                         i + length zs + length aux'' =\n                         min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                          (Monitor.progress \\<sigma> \\<psi>''\n                            (Suc j)) \\<and>\n                         list_all2\n                          (\\<lambda>i.\n                              qtable n (fv \\<psi>'') (mem_restr R)\n                               (\\<lambda>v.\n                                   MFOTL.sat \\<sigma> (map the v) i\n                                    (formula.Until\n(if pos then \\<phi>'' else formula.Neg \\<phi>'') I \\<psi>'')))\n                          [i..<i + length zs] zs", "case (Cons a aux')"], ["proof (state)\nthis:\n  \\<lbrakk>?i \\<le> Monitor.progress \\<sigma>\n                     (formula.Until \\<phi>''' I \\<psi>'') (Suc j);\n   wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux' ?i;\n   ?i + length aux' =\n   min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n    (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n   eval_until I\n    (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n     | nt # x \\<Rightarrow> nt)\n    aux' =\n   (?zs, ?aux'')\\<rbrakk>\n  \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' ?aux''\n                     (Monitor.progress \\<sigma>\n                       (formula.Until \\<phi>''' I \\<psi>'') (Suc j)) \\<and>\n                    ?i + length ?zs =\n                    Monitor.progress \\<sigma>\n                     (formula.Until \\<phi>''' I \\<psi>'') (Suc j) \\<and>\n                    ?i + length ?zs + length ?aux'' =\n                    min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                     (Monitor.progress \\<sigma> \\<psi>'' (Suc j)) \\<and>\n                    list_all2\n                     (\\<lambda>i.\n                         qtable n (fv \\<psi>'') (mem_restr R)\n                          (\\<lambda>v.\n                              MFOTL.sat \\<sigma> (map the v) i\n                               (formula.Until\n                                 (if pos then \\<phi>''\n                                  else formula.Neg \\<phi>'')\n                                 I \\<psi>'')))\n                     [?i..<?i + length ?zs] ?zs\n  i \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n           (Suc j)\n  wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (a # aux') i\n  i + length (a # aux') =\n  min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n   (Monitor.progress \\<sigma> \\<psi>'' (Suc j))\n  eval_until I\n   (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n    | nt # x \\<Rightarrow> nt)\n   (a # aux') =\n  (zs, aux'')\n\ngoal (1 subgoal):\n 1. \\<And>a aux' zs aux'' i.\n       \\<lbrakk>\\<And>zs aux'' i.\n                   \\<lbrakk>i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>''' I \\<psi>'')\n                                     (Suc j);\n                    wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux'\n                     i;\n                    i + length aux' =\n                    min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                     (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n                    eval_until I\n                     (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n                      | nt # x \\<Rightarrow> nt)\n                     aux' =\n                    (zs, aux'')\\<rbrakk>\n                   \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>''\nI \\<psi>'' aux''\n(Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n  (Suc j)) \\<and>\n                                     i + length zs =\n                                     Monitor.progress \\<sigma>\n(formula.Until \\<phi>''' I \\<psi>'') (Suc j) \\<and>\n                                     i + length zs + length aux'' =\n                                     min\n(Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n(Monitor.progress \\<sigma> \\<psi>'' (Suc j)) \\<and>\n                                     list_all2\n(\\<lambda>i.\n    qtable n (fv \\<psi>'') (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) i\n          (formula.Until (if pos then \\<phi>'' else formula.Neg \\<phi>'') I\n            \\<psi>'')))\n[i..<i + length zs] zs;\n        i \\<le> Monitor.progress \\<sigma>\n                 (formula.Until \\<phi>''' I \\<psi>'') (Suc j);\n        wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (a # aux') i;\n        i + length (a # aux') =\n        min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n         (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n        eval_until I\n         (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n          | nt # x \\<Rightarrow> nt)\n         (a # aux') =\n        (zs, aux'')\\<rbrakk>\n       \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                          aux''\n                          (Monitor.progress \\<sigma>\n                            (formula.Until \\<phi>''' I \\<psi>'')\n                            (Suc j)) \\<and>\n                         i + length zs =\n                         Monitor.progress \\<sigma>\n                          (formula.Until \\<phi>''' I \\<psi>'')\n                          (Suc j) \\<and>\n                         i + length zs + length aux'' =\n                         min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                          (Monitor.progress \\<sigma> \\<psi>''\n                            (Suc j)) \\<and>\n                         list_all2\n                          (\\<lambda>i.\n                              qtable n (fv \\<psi>'') (mem_restr R)\n                               (\\<lambda>v.\n                                   MFOTL.sat \\<sigma> (map the v) i\n                                    (formula.Until\n(if pos then \\<phi>'' else formula.Neg \\<phi>'') I \\<psi>'')))\n                          [i..<i + length zs] zs", "obtain t a1 a2 where \"a = (t, a1, a2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t a1 a2.\n        a = (t, a1, a2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases a)"], ["proof (state)\nthis:\n  a = (t, a1, a2)\n\ngoal (1 subgoal):\n 1. \\<And>a aux' zs aux'' i.\n       \\<lbrakk>\\<And>zs aux'' i.\n                   \\<lbrakk>i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>''' I \\<psi>'')\n                                     (Suc j);\n                    wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux'\n                     i;\n                    i + length aux' =\n                    min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                     (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n                    eval_until I\n                     (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n                      | nt # x \\<Rightarrow> nt)\n                     aux' =\n                    (zs, aux'')\\<rbrakk>\n                   \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>''\nI \\<psi>'' aux''\n(Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n  (Suc j)) \\<and>\n                                     i + length zs =\n                                     Monitor.progress \\<sigma>\n(formula.Until \\<phi>''' I \\<psi>'') (Suc j) \\<and>\n                                     i + length zs + length aux'' =\n                                     min\n(Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n(Monitor.progress \\<sigma> \\<psi>'' (Suc j)) \\<and>\n                                     list_all2\n(\\<lambda>i.\n    qtable n (fv \\<psi>'') (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) i\n          (formula.Until (if pos then \\<phi>'' else formula.Neg \\<phi>'') I\n            \\<psi>'')))\n[i..<i + length zs] zs;\n        i \\<le> Monitor.progress \\<sigma>\n                 (formula.Until \\<phi>''' I \\<psi>'') (Suc j);\n        wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (a # aux') i;\n        i + length (a # aux') =\n        min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n         (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n        eval_until I\n         (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n          | nt # x \\<Rightarrow> nt)\n         (a # aux') =\n        (zs, aux'')\\<rbrakk>\n       \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                          aux''\n                          (Monitor.progress \\<sigma>\n                            (formula.Until \\<phi>''' I \\<psi>'')\n                            (Suc j)) \\<and>\n                         i + length zs =\n                         Monitor.progress \\<sigma>\n                          (formula.Until \\<phi>''' I \\<psi>'')\n                          (Suc j) \\<and>\n                         i + length zs + length aux'' =\n                         min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                          (Monitor.progress \\<sigma> \\<psi>''\n                            (Suc j)) \\<and>\n                         list_all2\n                          (\\<lambda>i.\n                              qtable n (fv \\<psi>'') (mem_restr R)\n                               (\\<lambda>v.\n                                   MFOTL.sat \\<sigma> (map the v) i\n                                    (formula.Until\n(if pos then \\<phi>'' else formula.Neg \\<phi>'') I \\<psi>'')))\n                          [i..<i + length zs] zs", "from Cons.prems(2)"], ["proof (chain)\npicking this:\n  wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (a # aux') i", "have aux': \"wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux' (Suc i)\""], ["proof (prove)\nusing this:\n  wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (a # aux') i\n\ngoal (1 subgoal):\n 1. wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux' (Suc i)", "by (rule wf_until_aux_Cons)"], ["proof (state)\nthis:\n  wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux' (Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>a aux' zs aux'' i.\n       \\<lbrakk>\\<And>zs aux'' i.\n                   \\<lbrakk>i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>''' I \\<psi>'')\n                                     (Suc j);\n                    wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux'\n                     i;\n                    i + length aux' =\n                    min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                     (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n                    eval_until I\n                     (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n                      | nt # x \\<Rightarrow> nt)\n                     aux' =\n                    (zs, aux'')\\<rbrakk>\n                   \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>''\nI \\<psi>'' aux''\n(Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n  (Suc j)) \\<and>\n                                     i + length zs =\n                                     Monitor.progress \\<sigma>\n(formula.Until \\<phi>''' I \\<psi>'') (Suc j) \\<and>\n                                     i + length zs + length aux'' =\n                                     min\n(Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n(Monitor.progress \\<sigma> \\<psi>'' (Suc j)) \\<and>\n                                     list_all2\n(\\<lambda>i.\n    qtable n (fv \\<psi>'') (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) i\n          (formula.Until (if pos then \\<phi>'' else formula.Neg \\<phi>'') I\n            \\<psi>'')))\n[i..<i + length zs] zs;\n        i \\<le> Monitor.progress \\<sigma>\n                 (formula.Until \\<phi>''' I \\<psi>'') (Suc j);\n        wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (a # aux') i;\n        i + length (a # aux') =\n        min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n         (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n        eval_until I\n         (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n          | nt # x \\<Rightarrow> nt)\n         (a # aux') =\n        (zs, aux'')\\<rbrakk>\n       \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                          aux''\n                          (Monitor.progress \\<sigma>\n                            (formula.Until \\<phi>''' I \\<psi>'')\n                            (Suc j)) \\<and>\n                         i + length zs =\n                         Monitor.progress \\<sigma>\n                          (formula.Until \\<phi>''' I \\<psi>'')\n                          (Suc j) \\<and>\n                         i + length zs + length aux'' =\n                         min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                          (Monitor.progress \\<sigma> \\<psi>''\n                            (Suc j)) \\<and>\n                         list_all2\n                          (\\<lambda>i.\n                              qtable n (fv \\<psi>'') (mem_restr R)\n                               (\\<lambda>v.\n                                   MFOTL.sat \\<sigma> (map the v) i\n                                    (formula.Until\n(if pos then \\<phi>'' else formula.Neg \\<phi>'') I \\<psi>'')))\n                          [i..<i + length zs] zs", "from Cons.prems(2)"], ["proof (chain)\npicking this:\n  wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (a # aux') i", "have 1: \"t = \\<tau> \\<sigma> i\""], ["proof (prove)\nusing this:\n  wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (a # aux') i\n\ngoal (1 subgoal):\n 1. t = \\<tau> \\<sigma> i", "unfolding \\<open>a = (t, a1, a2)\\<close>"], ["proof (prove)\nusing this:\n  wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' ((t, a1, a2) # aux') i\n\ngoal (1 subgoal):\n 1. t = \\<tau> \\<sigma> i", "by (rule wf_until_aux_Cons1)"], ["proof (state)\nthis:\n  t = \\<tau> \\<sigma> i\n\ngoal (1 subgoal):\n 1. \\<And>a aux' zs aux'' i.\n       \\<lbrakk>\\<And>zs aux'' i.\n                   \\<lbrakk>i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>''' I \\<psi>'')\n                                     (Suc j);\n                    wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux'\n                     i;\n                    i + length aux' =\n                    min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                     (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n                    eval_until I\n                     (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n                      | nt # x \\<Rightarrow> nt)\n                     aux' =\n                    (zs, aux'')\\<rbrakk>\n                   \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>''\nI \\<psi>'' aux''\n(Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n  (Suc j)) \\<and>\n                                     i + length zs =\n                                     Monitor.progress \\<sigma>\n(formula.Until \\<phi>''' I \\<psi>'') (Suc j) \\<and>\n                                     i + length zs + length aux'' =\n                                     min\n(Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n(Monitor.progress \\<sigma> \\<psi>'' (Suc j)) \\<and>\n                                     list_all2\n(\\<lambda>i.\n    qtable n (fv \\<psi>'') (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) i\n          (formula.Until (if pos then \\<phi>'' else formula.Neg \\<phi>'') I\n            \\<psi>'')))\n[i..<i + length zs] zs;\n        i \\<le> Monitor.progress \\<sigma>\n                 (formula.Until \\<phi>''' I \\<psi>'') (Suc j);\n        wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (a # aux') i;\n        i + length (a # aux') =\n        min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n         (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n        eval_until I\n         (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n          | nt # x \\<Rightarrow> nt)\n         (a # aux') =\n        (zs, aux'')\\<rbrakk>\n       \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                          aux''\n                          (Monitor.progress \\<sigma>\n                            (formula.Until \\<phi>''' I \\<psi>'')\n                            (Suc j)) \\<and>\n                         i + length zs =\n                         Monitor.progress \\<sigma>\n                          (formula.Until \\<phi>''' I \\<psi>'')\n                          (Suc j) \\<and>\n                         i + length zs + length aux'' =\n                         min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                          (Monitor.progress \\<sigma> \\<psi>''\n                            (Suc j)) \\<and>\n                         list_all2\n                          (\\<lambda>i.\n                              qtable n (fv \\<psi>'') (mem_restr R)\n                               (\\<lambda>v.\n                                   MFOTL.sat \\<sigma> (map the v) i\n                                    (formula.Until\n(if pos then \\<phi>'' else formula.Neg \\<phi>'') I \\<psi>'')))\n                          [i..<i + length zs] zs", "from Cons.prems(2)"], ["proof (chain)\npicking this:\n  wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (a # aux') i", "have 3: \"qtable n (MFOTL.fv \\<psi>'') (mem_restr R) (\\<lambda>v.\n        (\\<exists>j\\<ge>i. j < Suc (i + length aux') \\<and> mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and> MFOTL.sat \\<sigma> (map the v) j \\<psi>'' \\<and>\n        (\\<forall>k\\<in>{i..<j}. if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>'' else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>''))) a2\""], ["proof (prove)\nusing this:\n  wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (a # aux') i\n\ngoal (1 subgoal):\n 1. qtable n (fv \\<psi>'') (mem_restr R)\n     (\\<lambda>v.\n         \\<exists>j\\<ge>i.\n            j < Suc (i + length aux') \\<and>\n            mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and>\n            MFOTL.sat \\<sigma> (map the v) j \\<psi>'' \\<and>\n            (\\<forall>k\\<in>{i..<j}.\n                if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>''\n                else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>''))\n     a2", "unfolding \\<open>a = (t, a1, a2)\\<close>"], ["proof (prove)\nusing this:\n  wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' ((t, a1, a2) # aux') i\n\ngoal (1 subgoal):\n 1. qtable n (fv \\<psi>'') (mem_restr R)\n     (\\<lambda>v.\n         \\<exists>j\\<ge>i.\n            j < Suc (i + length aux') \\<and>\n            mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and>\n            MFOTL.sat \\<sigma> (map the v) j \\<psi>'' \\<and>\n            (\\<forall>k\\<in>{i..<j}.\n                if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>''\n                else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>''))\n     a2", "by (rule wf_until_aux_Cons3)"], ["proof (state)\nthis:\n  qtable n (fv \\<psi>'') (mem_restr R)\n   (\\<lambda>v.\n       \\<exists>j\\<ge>i.\n          j < Suc (i + length aux') \\<and>\n          mem (\\<tau> \\<sigma> j - \\<tau> \\<sigma> i) I \\<and>\n          MFOTL.sat \\<sigma> (map the v) j \\<psi>'' \\<and>\n          (\\<forall>k\\<in>{i..<j}.\n              if pos then MFOTL.sat \\<sigma> (map the v) k \\<phi>''\n              else \\<not> MFOTL.sat \\<sigma> (map the v) k \\<phi>''))\n   a2\n\ngoal (1 subgoal):\n 1. \\<And>a aux' zs aux'' i.\n       \\<lbrakk>\\<And>zs aux'' i.\n                   \\<lbrakk>i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>''' I \\<psi>'')\n                                     (Suc j);\n                    wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux'\n                     i;\n                    i + length aux' =\n                    min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                     (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n                    eval_until I\n                     (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n                      | nt # x \\<Rightarrow> nt)\n                     aux' =\n                    (zs, aux'')\\<rbrakk>\n                   \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>''\nI \\<psi>'' aux''\n(Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n  (Suc j)) \\<and>\n                                     i + length zs =\n                                     Monitor.progress \\<sigma>\n(formula.Until \\<phi>''' I \\<psi>'') (Suc j) \\<and>\n                                     i + length zs + length aux'' =\n                                     min\n(Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n(Monitor.progress \\<sigma> \\<psi>'' (Suc j)) \\<and>\n                                     list_all2\n(\\<lambda>i.\n    qtable n (fv \\<psi>'') (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) i\n          (formula.Until (if pos then \\<phi>'' else formula.Neg \\<phi>'') I\n            \\<psi>'')))\n[i..<i + length zs] zs;\n        i \\<le> Monitor.progress \\<sigma>\n                 (formula.Until \\<phi>''' I \\<psi>'') (Suc j);\n        wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (a # aux') i;\n        i + length (a # aux') =\n        min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n         (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n        eval_until I\n         (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n          | nt # x \\<Rightarrow> nt)\n         (a # aux') =\n        (zs, aux'')\\<rbrakk>\n       \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                          aux''\n                          (Monitor.progress \\<sigma>\n                            (formula.Until \\<phi>''' I \\<psi>'')\n                            (Suc j)) \\<and>\n                         i + length zs =\n                         Monitor.progress \\<sigma>\n                          (formula.Until \\<phi>''' I \\<psi>'')\n                          (Suc j) \\<and>\n                         i + length zs + length aux'' =\n                         min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                          (Monitor.progress \\<sigma> \\<psi>''\n                            (Suc j)) \\<and>\n                         list_all2\n                          (\\<lambda>i.\n                              qtable n (fv \\<psi>'') (mem_restr R)\n                               (\\<lambda>v.\n                                   MFOTL.sat \\<sigma> (map the v) i\n                                    (formula.Until\n(if pos then \\<phi>'' else formula.Neg \\<phi>'') I \\<psi>'')))\n                          [i..<i + length zs] zs", "from Cons.prems(3)"], ["proof (chain)\npicking this:\n  i + length (a # aux') =\n  min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n   (Monitor.progress \\<sigma> \\<psi>'' (Suc j))", "have Suc_i_aux': \"Suc i + length aux' =\n          min (progress \\<sigma> \\<phi>''' (Suc j)) (progress \\<sigma> \\<psi>'' (Suc j))\""], ["proof (prove)\nusing this:\n  i + length (a # aux') =\n  min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n   (Monitor.progress \\<sigma> \\<psi>'' (Suc j))\n\ngoal (1 subgoal):\n 1. Suc i + length aux' =\n    min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n     (Monitor.progress \\<sigma> \\<psi>'' (Suc j))", "by simp"], ["proof (state)\nthis:\n  Suc i + length aux' =\n  min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n   (Monitor.progress \\<sigma> \\<psi>'' (Suc j))\n\ngoal (1 subgoal):\n 1. \\<And>a aux' zs aux'' i.\n       \\<lbrakk>\\<And>zs aux'' i.\n                   \\<lbrakk>i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>''' I \\<psi>'')\n                                     (Suc j);\n                    wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux'\n                     i;\n                    i + length aux' =\n                    min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                     (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n                    eval_until I\n                     (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n                      | nt # x \\<Rightarrow> nt)\n                     aux' =\n                    (zs, aux'')\\<rbrakk>\n                   \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>''\nI \\<psi>'' aux''\n(Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n  (Suc j)) \\<and>\n                                     i + length zs =\n                                     Monitor.progress \\<sigma>\n(formula.Until \\<phi>''' I \\<psi>'') (Suc j) \\<and>\n                                     i + length zs + length aux'' =\n                                     min\n(Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n(Monitor.progress \\<sigma> \\<psi>'' (Suc j)) \\<and>\n                                     list_all2\n(\\<lambda>i.\n    qtable n (fv \\<psi>'') (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) i\n          (formula.Until (if pos then \\<phi>'' else formula.Neg \\<phi>'') I\n            \\<psi>'')))\n[i..<i + length zs] zs;\n        i \\<le> Monitor.progress \\<sigma>\n                 (formula.Until \\<phi>''' I \\<psi>'') (Suc j);\n        wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (a # aux') i;\n        i + length (a # aux') =\n        min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n         (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n        eval_until I\n         (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n          | nt # x \\<Rightarrow> nt)\n         (a # aux') =\n        (zs, aux'')\\<rbrakk>\n       \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                          aux''\n                          (Monitor.progress \\<sigma>\n                            (formula.Until \\<phi>''' I \\<psi>'')\n                            (Suc j)) \\<and>\n                         i + length zs =\n                         Monitor.progress \\<sigma>\n                          (formula.Until \\<phi>''' I \\<psi>'')\n                          (Suc j) \\<and>\n                         i + length zs + length aux'' =\n                         min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                          (Monitor.progress \\<sigma> \\<psi>''\n                            (Suc j)) \\<and>\n                         list_all2\n                          (\\<lambda>i.\n                              qtable n (fv \\<psi>'') (mem_restr R)\n                               (\\<lambda>v.\n                                   MFOTL.sat \\<sigma> (map the v) i\n                                    (formula.Until\n(if pos then \\<phi>'' else formula.Neg \\<phi>'') I \\<psi>'')))\n                          [i..<i + length zs] zs", "have \"i \\<ge> progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') (Suc j)\"\n        if \"enat (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j | nt # x \\<Rightarrow> nt) \\<le> enat t + right I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') (Suc j)\n    \\<le> i", "using that nts'"], ["proof (prove)\nusing this:\n  enat\n   (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n    | nt # x \\<Rightarrow> nt)\n  \\<le> enat t + right I\n  wf_ts \\<sigma> (Suc j) \\<phi>'' \\<psi>'' nts'\n\ngoal (1 subgoal):\n 1. Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') (Suc j)\n    \\<le> i", "unfolding wf_ts_def progress.simps"], ["proof (prove)\nusing this:\n  enat\n   (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n    | nt # x \\<Rightarrow> nt)\n  \\<le> enat t + right I\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<phi>'' (Suc j))\n     (Monitor.progress \\<sigma> \\<psi>'' (Suc j))..<\n    Suc j]\n   nts'\n\ngoal (1 subgoal):\n 1. Inf {i. \\<forall>k.\n               k < Suc j \\<and>\n               k \\<le> min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                        (Monitor.progress \\<sigma> \\<psi>''\n                          (Suc j)) \\<longrightarrow>\n               enat (\\<tau> \\<sigma> k)\n               \\<le> enat (\\<tau> \\<sigma> i) + right I}\n    \\<le> i", "by (auto simp add: 1 list_all2_Cons2 upt_eq_Cons_conv \\<phi>'''\n          intro!: cInf_lower \\<tau>_mono elim!: order.trans[rotated] simp del: upt_Suc split: if_splits list.splits)"], ["proof (state)\nthis:\n  enat\n   (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n    | nt # x \\<Rightarrow> nt)\n  \\<le> enat t + right I \\<Longrightarrow>\n  Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') (Suc j)\n  \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>a aux' zs aux'' i.\n       \\<lbrakk>\\<And>zs aux'' i.\n                   \\<lbrakk>i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>''' I \\<psi>'')\n                                     (Suc j);\n                    wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux'\n                     i;\n                    i + length aux' =\n                    min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                     (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n                    eval_until I\n                     (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n                      | nt # x \\<Rightarrow> nt)\n                     aux' =\n                    (zs, aux'')\\<rbrakk>\n                   \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>''\nI \\<psi>'' aux''\n(Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n  (Suc j)) \\<and>\n                                     i + length zs =\n                                     Monitor.progress \\<sigma>\n(formula.Until \\<phi>''' I \\<psi>'') (Suc j) \\<and>\n                                     i + length zs + length aux'' =\n                                     min\n(Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n(Monitor.progress \\<sigma> \\<psi>'' (Suc j)) \\<and>\n                                     list_all2\n(\\<lambda>i.\n    qtable n (fv \\<psi>'') (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) i\n          (formula.Until (if pos then \\<phi>'' else formula.Neg \\<phi>'') I\n            \\<psi>'')))\n[i..<i + length zs] zs;\n        i \\<le> Monitor.progress \\<sigma>\n                 (formula.Until \\<phi>''' I \\<psi>'') (Suc j);\n        wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (a # aux') i;\n        i + length (a # aux') =\n        min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n         (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n        eval_until I\n         (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n          | nt # x \\<Rightarrow> nt)\n         (a # aux') =\n        (zs, aux'')\\<rbrakk>\n       \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                          aux''\n                          (Monitor.progress \\<sigma>\n                            (formula.Until \\<phi>''' I \\<psi>'')\n                            (Suc j)) \\<and>\n                         i + length zs =\n                         Monitor.progress \\<sigma>\n                          (formula.Until \\<phi>''' I \\<psi>'')\n                          (Suc j) \\<and>\n                         i + length zs + length aux'' =\n                         min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                          (Monitor.progress \\<sigma> \\<psi>''\n                            (Suc j)) \\<and>\n                         list_all2\n                          (\\<lambda>i.\n                              qtable n (fv \\<psi>'') (mem_restr R)\n                               (\\<lambda>v.\n                                   MFOTL.sat \\<sigma> (map the v) i\n                                    (formula.Until\n(if pos then \\<phi>'' else formula.Neg \\<phi>'') I \\<psi>'')))\n                          [i..<i + length zs] zs", "moreover"], ["proof (state)\nthis:\n  enat\n   (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n    | nt # x \\<Rightarrow> nt)\n  \\<le> enat t + right I \\<Longrightarrow>\n  Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') (Suc j)\n  \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>a aux' zs aux'' i.\n       \\<lbrakk>\\<And>zs aux'' i.\n                   \\<lbrakk>i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>''' I \\<psi>'')\n                                     (Suc j);\n                    wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux'\n                     i;\n                    i + length aux' =\n                    min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                     (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n                    eval_until I\n                     (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n                      | nt # x \\<Rightarrow> nt)\n                     aux' =\n                    (zs, aux'')\\<rbrakk>\n                   \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>''\nI \\<psi>'' aux''\n(Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n  (Suc j)) \\<and>\n                                     i + length zs =\n                                     Monitor.progress \\<sigma>\n(formula.Until \\<phi>''' I \\<psi>'') (Suc j) \\<and>\n                                     i + length zs + length aux'' =\n                                     min\n(Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n(Monitor.progress \\<sigma> \\<psi>'' (Suc j)) \\<and>\n                                     list_all2\n(\\<lambda>i.\n    qtable n (fv \\<psi>'') (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) i\n          (formula.Until (if pos then \\<phi>'' else formula.Neg \\<phi>'') I\n            \\<psi>'')))\n[i..<i + length zs] zs;\n        i \\<le> Monitor.progress \\<sigma>\n                 (formula.Until \\<phi>''' I \\<psi>'') (Suc j);\n        wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (a # aux') i;\n        i + length (a # aux') =\n        min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n         (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n        eval_until I\n         (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n          | nt # x \\<Rightarrow> nt)\n         (a # aux') =\n        (zs, aux'')\\<rbrakk>\n       \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                          aux''\n                          (Monitor.progress \\<sigma>\n                            (formula.Until \\<phi>''' I \\<psi>'')\n                            (Suc j)) \\<and>\n                         i + length zs =\n                         Monitor.progress \\<sigma>\n                          (formula.Until \\<phi>''' I \\<psi>'')\n                          (Suc j) \\<and>\n                         i + length zs + length aux'' =\n                         min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                          (Monitor.progress \\<sigma> \\<psi>''\n                            (Suc j)) \\<and>\n                         list_all2\n                          (\\<lambda>i.\n                              qtable n (fv \\<psi>'') (mem_restr R)\n                               (\\<lambda>v.\n                                   MFOTL.sat \\<sigma> (map the v) i\n                                    (formula.Until\n(if pos then \\<phi>'' else formula.Neg \\<phi>'') I \\<psi>'')))\n                          [i..<i + length zs] zs", "have \"Suc i \\<le> progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') (Suc j)\"\n        if \"enat t + right I < enat (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j | nt # x \\<Rightarrow> nt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc i\n    \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n           (Suc j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc i\n    \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n           (Suc j)", "from that"], ["proof (chain)\npicking this:\n  enat t + right I\n  < enat\n     (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n      | nt # x \\<Rightarrow> nt)", "obtain m where m: \"right I = enat m\""], ["proof (prove)\nusing this:\n  enat t + right I\n  < enat\n     (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n      | nt # x \\<Rightarrow> nt)\n\ngoal (1 subgoal):\n 1. (\\<And>m. right I = enat m \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"right I\") auto"], ["proof (state)\nthis:\n  right I = enat m\n\ngoal (1 subgoal):\n 1. Suc i\n    \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n           (Suc j)", "have \\<tau>_min:  \"\\<tau> \\<sigma> (min j k) = min (\\<tau> \\<sigma> j) (\\<tau> \\<sigma> k)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<sigma> (min j k) = min (\\<tau> \\<sigma> j) (\\<tau> \\<sigma> k)", "by (simp add: min_of_mono monoI)"], ["proof (state)\nthis:\n  \\<tau> \\<sigma> (min j ?k) = min (\\<tau> \\<sigma> j) (\\<tau> \\<sigma> ?k)\n\ngoal (1 subgoal):\n 1. Suc i\n    \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n           (Suc j)", "have le_progress_iff[simp]: \"i \\<le> progress \\<sigma> \\<phi> i \\<longleftrightarrow> progress \\<sigma> \\<phi> i = i\" for \\<phi> i"], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<le> Monitor.progress \\<sigma> \\<phi> i) =\n    (Monitor.progress \\<sigma> \\<phi> i = i)", "using progress_le[of \\<sigma> \\<phi> i]"], ["proof (prove)\nusing this:\n  Monitor.progress \\<sigma> \\<phi> i \\<le> i\n\ngoal (1 subgoal):\n 1. (i \\<le> Monitor.progress \\<sigma> \\<phi> i) =\n    (Monitor.progress \\<sigma> \\<phi> i = i)", "by auto"], ["proof (state)\nthis:\n  (?i \\<le> Monitor.progress \\<sigma> ?\\<phi> ?i) =\n  (Monitor.progress \\<sigma> ?\\<phi> ?i = ?i)\n\ngoal (1 subgoal):\n 1. Suc i\n    \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n           (Suc j)", "have min_Suc[simp]: \"min j (Suc j) = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min j (Suc j) = j", "by auto"], ["proof (state)\nthis:\n  min j (Suc j) = j\n\ngoal (1 subgoal):\n 1. Suc i\n    \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n           (Suc j)", "let ?X = \"{i. \\<forall>k. k < Suc j \\<and> k \\<le>min (progress \\<sigma> \\<phi>''' (Suc j)) (progress \\<sigma> \\<psi>'' (Suc j)) \\<longrightarrow> enat (\\<tau> \\<sigma> k) \\<le> enat (\\<tau> \\<sigma> i) + right I}\""], ["proof (state)\ngoal (1 subgoal):\n 1. Suc i\n    \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n           (Suc j)", "let ?min = \"min j (min (progress \\<sigma> \\<phi>'' (Suc j)) (progress \\<sigma> \\<psi>'' (Suc j)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. Suc i\n    \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n           (Suc j)", "have \"\\<tau> \\<sigma> ?min \\<le> \\<tau> \\<sigma> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<sigma>\n     (min j\n       (min (Monitor.progress \\<sigma> \\<phi>'' (Suc j))\n         (Monitor.progress \\<sigma> \\<psi>'' (Suc j))))\n    \\<le> \\<tau> \\<sigma> j", "by (rule \\<tau>_mono) auto"], ["proof (state)\nthis:\n  \\<tau> \\<sigma>\n   (min j\n     (min (Monitor.progress \\<sigma> \\<phi>'' (Suc j))\n       (Monitor.progress \\<sigma> \\<psi>'' (Suc j))))\n  \\<le> \\<tau> \\<sigma> j\n\ngoal (1 subgoal):\n 1. Suc i\n    \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n           (Suc j)", "from m"], ["proof (chain)\npicking this:\n  right I = enat m", "have \"?X \\<noteq> {}\""], ["proof (prove)\nusing this:\n  right I = enat m\n\ngoal (1 subgoal):\n 1. {i. \\<forall>k.\n           k < Suc j \\<and>\n           k \\<le> min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                    (Monitor.progress \\<sigma> \\<psi>''\n                      (Suc j)) \\<longrightarrow>\n           enat (\\<tau> \\<sigma> k)\n           \\<le> enat (\\<tau> \\<sigma> i) + right I} \\<noteq>\n    {}", "by (auto dest!: \\<tau>_mono[of _ \"progress \\<sigma> \\<phi>'' (Suc j)\" \\<sigma>]\n           simp: not_le not_less \\<phi>''' intro!: exI[of _ \"progress \\<sigma> \\<phi>'' (Suc j)\"])"], ["proof (state)\nthis:\n  {i. \\<forall>k.\n         k < Suc j \\<and>\n         k \\<le> min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                  (Monitor.progress \\<sigma> \\<psi>''\n                    (Suc j)) \\<longrightarrow>\n         enat (\\<tau> \\<sigma> k)\n         \\<le> enat (\\<tau> \\<sigma> i) + right I} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. Suc i\n    \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n           (Suc j)", "thm less_le_trans[of \"\\<tau> \\<sigma> i + m\" \"\\<tau> \\<sigma> _\" \"\\<tau> \\<sigma> _ + m\"]"], ["proof (state)\nthis:\n  {i. \\<forall>k.\n         k < Suc j \\<and>\n         k \\<le> min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                  (Monitor.progress \\<sigma> \\<psi>''\n                    (Suc j)) \\<longrightarrow>\n         enat (\\<tau> \\<sigma> k)\n         \\<le> enat (\\<tau> \\<sigma> i) + right I} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. Suc i\n    \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n           (Suc j)", "from m"], ["proof (chain)\npicking this:\n  right I = enat m", "show ?thesis"], ["proof (prove)\nusing this:\n  right I = enat m\n\ngoal (1 subgoal):\n 1. Suc i\n    \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n           (Suc j)", "using that nts'"], ["proof (prove)\nusing this:\n  right I = enat m\n  enat t + right I\n  < enat\n     (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n      | nt # x \\<Rightarrow> nt)\n  wf_ts \\<sigma> (Suc j) \\<phi>'' \\<psi>'' nts'\n\ngoal (1 subgoal):\n 1. Suc i\n    \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n           (Suc j)", "unfolding wf_ts_def progress.simps"], ["proof (prove)\nusing this:\n  right I = enat m\n  enat t + right I\n  < enat\n     (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n      | nt # x \\<Rightarrow> nt)\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<phi>'' (Suc j))\n     (Monitor.progress \\<sigma> \\<psi>'' (Suc j))..<\n    Suc j]\n   nts'\n\ngoal (1 subgoal):\n 1. Suc i\n    \\<le> Inf {i. \\<forall>k.\n                     k < Suc j \\<and>\n                     k \\<le> min (Monitor.progress \\<sigma> \\<phi>'''\n                                   (Suc j))\n                              (Monitor.progress \\<sigma> \\<psi>''\n                                (Suc j)) \\<longrightarrow>\n                     enat (\\<tau> \\<sigma> k)\n                     \\<le> enat (\\<tau> \\<sigma> i) + right I}", "by (intro cInf_greatest[OF \\<open>?X \\<noteq> {}\\<close>])\n            (auto simp: 1 \\<phi>''' not_le not_less list_all2_Cons2 upt_eq_Cons_conv less_Suc_eq\n              simp del: upt_Suc split: list.splits if_splits\n              dest!: spec[of _ \"?min\"] less_le_trans[of \"\\<tau> \\<sigma> i + m\" \"\\<tau> \\<sigma> _\" \"\\<tau> \\<sigma> _ + m\"] less_\\<tau>D)"], ["proof (state)\nthis:\n  Suc i\n  \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n         (Suc j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  enat t + right I\n  < enat\n     (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n      | nt # x \\<Rightarrow> nt) \\<Longrightarrow>\n  Suc i\n  \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n         (Suc j)\n\ngoal (1 subgoal):\n 1. \\<And>a aux' zs aux'' i.\n       \\<lbrakk>\\<And>zs aux'' i.\n                   \\<lbrakk>i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>''' I \\<psi>'')\n                                     (Suc j);\n                    wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux'\n                     i;\n                    i + length aux' =\n                    min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                     (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n                    eval_until I\n                     (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n                      | nt # x \\<Rightarrow> nt)\n                     aux' =\n                    (zs, aux'')\\<rbrakk>\n                   \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>''\nI \\<psi>'' aux''\n(Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n  (Suc j)) \\<and>\n                                     i + length zs =\n                                     Monitor.progress \\<sigma>\n(formula.Until \\<phi>''' I \\<psi>'') (Suc j) \\<and>\n                                     i + length zs + length aux'' =\n                                     min\n(Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n(Monitor.progress \\<sigma> \\<psi>'' (Suc j)) \\<and>\n                                     list_all2\n(\\<lambda>i.\n    qtable n (fv \\<psi>'') (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) i\n          (formula.Until (if pos then \\<phi>'' else formula.Neg \\<phi>'') I\n            \\<psi>'')))\n[i..<i + length zs] zs;\n        i \\<le> Monitor.progress \\<sigma>\n                 (formula.Until \\<phi>''' I \\<psi>'') (Suc j);\n        wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (a # aux') i;\n        i + length (a # aux') =\n        min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n         (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n        eval_until I\n         (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n          | nt # x \\<Rightarrow> nt)\n         (a # aux') =\n        (zs, aux'')\\<rbrakk>\n       \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                          aux''\n                          (Monitor.progress \\<sigma>\n                            (formula.Until \\<phi>''' I \\<psi>'')\n                            (Suc j)) \\<and>\n                         i + length zs =\n                         Monitor.progress \\<sigma>\n                          (formula.Until \\<phi>''' I \\<psi>'')\n                          (Suc j) \\<and>\n                         i + length zs + length aux'' =\n                         min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                          (Monitor.progress \\<sigma> \\<psi>''\n                            (Suc j)) \\<and>\n                         list_all2\n                          (\\<lambda>i.\n                              qtable n (fv \\<psi>'') (mem_restr R)\n                               (\\<lambda>v.\n                                   MFOTL.sat \\<sigma> (map the v) i\n                                    (formula.Until\n(if pos then \\<phi>'' else formula.Neg \\<phi>'') I \\<psi>'')))\n                          [i..<i + length zs] zs", "moreover"], ["proof (state)\nthis:\n  enat t + right I\n  < enat\n     (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n      | nt # x \\<Rightarrow> nt) \\<Longrightarrow>\n  Suc i\n  \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n         (Suc j)\n\ngoal (1 subgoal):\n 1. \\<And>a aux' zs aux'' i.\n       \\<lbrakk>\\<And>zs aux'' i.\n                   \\<lbrakk>i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>''' I \\<psi>'')\n                                     (Suc j);\n                    wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux'\n                     i;\n                    i + length aux' =\n                    min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                     (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n                    eval_until I\n                     (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n                      | nt # x \\<Rightarrow> nt)\n                     aux' =\n                    (zs, aux'')\\<rbrakk>\n                   \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>''\nI \\<psi>'' aux''\n(Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n  (Suc j)) \\<and>\n                                     i + length zs =\n                                     Monitor.progress \\<sigma>\n(formula.Until \\<phi>''' I \\<psi>'') (Suc j) \\<and>\n                                     i + length zs + length aux'' =\n                                     min\n(Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n(Monitor.progress \\<sigma> \\<psi>'' (Suc j)) \\<and>\n                                     list_all2\n(\\<lambda>i.\n    qtable n (fv \\<psi>'') (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) i\n          (formula.Until (if pos then \\<phi>'' else formula.Neg \\<phi>'') I\n            \\<psi>'')))\n[i..<i + length zs] zs;\n        i \\<le> Monitor.progress \\<sigma>\n                 (formula.Until \\<phi>''' I \\<psi>'') (Suc j);\n        wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (a # aux') i;\n        i + length (a # aux') =\n        min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n         (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n        eval_until I\n         (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n          | nt # x \\<Rightarrow> nt)\n         (a # aux') =\n        (zs, aux'')\\<rbrakk>\n       \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                          aux''\n                          (Monitor.progress \\<sigma>\n                            (formula.Until \\<phi>''' I \\<psi>'')\n                            (Suc j)) \\<and>\n                         i + length zs =\n                         Monitor.progress \\<sigma>\n                          (formula.Until \\<phi>''' I \\<psi>'')\n                          (Suc j) \\<and>\n                         i + length zs + length aux'' =\n                         min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                          (Monitor.progress \\<sigma> \\<psi>''\n                            (Suc j)) \\<and>\n                         list_all2\n                          (\\<lambda>i.\n                              qtable n (fv \\<psi>'') (mem_restr R)\n                               (\\<lambda>v.\n                                   MFOTL.sat \\<sigma> (map the v) i\n                                    (formula.Until\n(if pos then \\<phi>'' else formula.Neg \\<phi>'') I \\<psi>'')))\n                          [i..<i + length zs] zs", "have *: \"k < progress \\<sigma> \\<psi> (Suc j)\" if\n        \"enat (\\<tau> \\<sigma> i) + right I < enat (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j | nt # x \\<Rightarrow> nt)\"\n        \"enat (\\<tau> \\<sigma> k - \\<tau> \\<sigma> i) \\<le> right I\" \"\\<psi> = \\<psi>'' \\<or> \\<psi> = \\<phi>''\" for k \\<psi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. k < Monitor.progress \\<sigma> \\<psi> (Suc j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. k < Monitor.progress \\<sigma> \\<psi> (Suc j)", "from that(1,2)"], ["proof (chain)\npicking this:\n  enat (\\<tau> \\<sigma> i) + right I\n  < enat\n     (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n      | nt # x \\<Rightarrow> nt)\n  enat (\\<tau> \\<sigma> k - \\<tau> \\<sigma> i) \\<le> right I", "obtain m where \"right I = enat m\"\n           \"\\<tau> \\<sigma> i + m < (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j | nt # x \\<Rightarrow> nt)\" \"\\<tau> \\<sigma> k - \\<tau> \\<sigma> i \\<le> m\""], ["proof (prove)\nusing this:\n  enat (\\<tau> \\<sigma> i) + right I\n  < enat\n     (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n      | nt # x \\<Rightarrow> nt)\n  enat (\\<tau> \\<sigma> k - \\<tau> \\<sigma> i) \\<le> right I\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>right I = enat m;\n         \\<tau> \\<sigma> i + m\n         < (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n            | nt # x \\<Rightarrow> nt);\n         \\<tau> \\<sigma> k - \\<tau> \\<sigma> i \\<le> m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"right I\") auto"], ["proof (state)\nthis:\n  right I = enat m\n  \\<tau> \\<sigma> i + m\n  < (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n     | nt # x \\<Rightarrow> nt)\n  \\<tau> \\<sigma> k - \\<tau> \\<sigma> i \\<le> m\n\ngoal (1 subgoal):\n 1. k < Monitor.progress \\<sigma> \\<psi> (Suc j)", "with that(3) nts' progress_le[of \\<sigma> \\<psi>'' \"Suc j\"] progress_le[of \\<sigma> \\<phi>'' \"Suc j\"]"], ["proof (chain)\npicking this:\n  \\<psi> = \\<psi>'' \\<or> \\<psi> = \\<phi>''\n  wf_ts \\<sigma> (Suc j) \\<phi>'' \\<psi>'' nts'\n  Monitor.progress \\<sigma> \\<psi>'' (Suc j) \\<le> Suc j\n  Monitor.progress \\<sigma> \\<phi>'' (Suc j) \\<le> Suc j\n  right I = enat m\n  \\<tau> \\<sigma> i + m\n  < (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n     | nt # x \\<Rightarrow> nt)\n  \\<tau> \\<sigma> k - \\<tau> \\<sigma> i \\<le> m", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<psi> = \\<psi>'' \\<or> \\<psi> = \\<phi>''\n  wf_ts \\<sigma> (Suc j) \\<phi>'' \\<psi>'' nts'\n  Monitor.progress \\<sigma> \\<psi>'' (Suc j) \\<le> Suc j\n  Monitor.progress \\<sigma> \\<phi>'' (Suc j) \\<le> Suc j\n  right I = enat m\n  \\<tau> \\<sigma> i + m\n  < (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n     | nt # x \\<Rightarrow> nt)\n  \\<tau> \\<sigma> k - \\<tau> \\<sigma> i \\<le> m\n\ngoal (1 subgoal):\n 1. k < Monitor.progress \\<sigma> \\<psi> (Suc j)", "unfolding wf_ts_def le_diff_conv"], ["proof (prove)\nusing this:\n  \\<psi> = \\<psi>'' \\<or> \\<psi> = \\<phi>''\n  list_all2 (\\<lambda>i t. t = \\<tau> \\<sigma> i)\n   [min (Monitor.progress \\<sigma> \\<phi>'' (Suc j))\n     (Monitor.progress \\<sigma> \\<psi>'' (Suc j))..<\n    Suc j]\n   nts'\n  Monitor.progress \\<sigma> \\<psi>'' (Suc j) \\<le> Suc j\n  Monitor.progress \\<sigma> \\<phi>'' (Suc j) \\<le> Suc j\n  right I = enat m\n  \\<tau> \\<sigma> i + m\n  < (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n     | nt # x \\<Rightarrow> nt)\n  \\<tau> \\<sigma> k \\<le> m + \\<tau> \\<sigma> i\n\ngoal (1 subgoal):\n 1. k < Monitor.progress \\<sigma> \\<psi> (Suc j)", "by (auto simp: not_le list_all2_Cons2 upt_eq_Cons_conv less_Suc_eq add.commute\n            simp del: upt_Suc split: list.splits if_splits dest!: le_less_trans[of \"\\<tau> \\<sigma> k\"] less_\\<tau>D)"], ["proof (state)\nthis:\n  k < Monitor.progress \\<sigma> \\<psi> (Suc j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>enat (\\<tau> \\<sigma> i) + right I\n           < enat\n              (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n               | nt # x \\<Rightarrow> nt);\n   enat (\\<tau> \\<sigma> ?k - \\<tau> \\<sigma> i) \\<le> right I;\n   ?\\<psi> = \\<psi>'' \\<or> ?\\<psi> = \\<phi>''\\<rbrakk>\n  \\<Longrightarrow> ?k < Monitor.progress \\<sigma> ?\\<psi> (Suc j)\n\ngoal (1 subgoal):\n 1. \\<And>a aux' zs aux'' i.\n       \\<lbrakk>\\<And>zs aux'' i.\n                   \\<lbrakk>i \\<le> Monitor.progress \\<sigma>\n                                     (formula.Until \\<phi>''' I \\<psi>'')\n                                     (Suc j);\n                    wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux'\n                     i;\n                    i + length aux' =\n                    min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                     (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n                    eval_until I\n                     (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n                      | nt # x \\<Rightarrow> nt)\n                     aux' =\n                    (zs, aux'')\\<rbrakk>\n                   \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>''\nI \\<psi>'' aux''\n(Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n  (Suc j)) \\<and>\n                                     i + length zs =\n                                     Monitor.progress \\<sigma>\n(formula.Until \\<phi>''' I \\<psi>'') (Suc j) \\<and>\n                                     i + length zs + length aux'' =\n                                     min\n(Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n(Monitor.progress \\<sigma> \\<psi>'' (Suc j)) \\<and>\n                                     list_all2\n(\\<lambda>i.\n    qtable n (fv \\<psi>'') (mem_restr R)\n     (\\<lambda>v.\n         MFOTL.sat \\<sigma> (map the v) i\n          (formula.Until (if pos then \\<phi>'' else formula.Neg \\<phi>'') I\n            \\<psi>'')))\n[i..<i + length zs] zs;\n        i \\<le> Monitor.progress \\<sigma>\n                 (formula.Until \\<phi>''' I \\<psi>'') (Suc j);\n        wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (a # aux') i;\n        i + length (a # aux') =\n        min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n         (Monitor.progress \\<sigma> \\<psi>'' (Suc j));\n        eval_until I\n         (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n          | nt # x \\<Rightarrow> nt)\n         (a # aux') =\n        (zs, aux'')\\<rbrakk>\n       \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                          aux''\n                          (Monitor.progress \\<sigma>\n                            (formula.Until \\<phi>''' I \\<psi>'')\n                            (Suc j)) \\<and>\n                         i + length zs =\n                         Monitor.progress \\<sigma>\n                          (formula.Until \\<phi>''' I \\<psi>'')\n                          (Suc j) \\<and>\n                         i + length zs + length aux'' =\n                         min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                          (Monitor.progress \\<sigma> \\<psi>''\n                            (Suc j)) \\<and>\n                         list_all2\n                          (\\<lambda>i.\n                              qtable n (fv \\<psi>'') (mem_restr R)\n                               (\\<lambda>v.\n                                   MFOTL.sat \\<sigma> (map the v) i\n                                    (formula.Until\n(if pos then \\<phi>'' else formula.Neg \\<phi>'') I \\<psi>'')))\n                          [i..<i + length zs] zs", "ultimately"], ["proof (chain)\npicking this:\n  enat\n   (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n    | nt # x \\<Rightarrow> nt)\n  \\<le> enat t + right I \\<Longrightarrow>\n  Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') (Suc j)\n  \\<le> i\n  enat t + right I\n  < enat\n     (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n      | nt # x \\<Rightarrow> nt) \\<Longrightarrow>\n  Suc i\n  \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n         (Suc j)\n  \\<lbrakk>enat (\\<tau> \\<sigma> i) + right I\n           < enat\n              (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n               | nt # x \\<Rightarrow> nt);\n   enat (\\<tau> \\<sigma> ?k - \\<tau> \\<sigma> i) \\<le> right I;\n   ?\\<psi> = \\<psi>'' \\<or> ?\\<psi> = \\<phi>''\\<rbrakk>\n  \\<Longrightarrow> ?k < Monitor.progress \\<sigma> ?\\<psi> (Suc j)", "show ?case"], ["proof (prove)\nusing this:\n  enat\n   (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n    | nt # x \\<Rightarrow> nt)\n  \\<le> enat t + right I \\<Longrightarrow>\n  Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') (Suc j)\n  \\<le> i\n  enat t + right I\n  < enat\n     (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n      | nt # x \\<Rightarrow> nt) \\<Longrightarrow>\n  Suc i\n  \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n         (Suc j)\n  \\<lbrakk>enat (\\<tau> \\<sigma> i) + right I\n           < enat\n              (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n               | nt # x \\<Rightarrow> nt);\n   enat (\\<tau> \\<sigma> ?k - \\<tau> \\<sigma> i) \\<le> right I;\n   ?\\<psi> = \\<psi>'' \\<or> ?\\<psi> = \\<phi>''\\<rbrakk>\n  \\<Longrightarrow> ?k < Monitor.progress \\<sigma> ?\\<psi> (Suc j)\n\ngoal (1 subgoal):\n 1. wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux''\n     (Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n       (Suc j)) \\<and>\n    i + length zs =\n    Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n     (Suc j) \\<and>\n    i + length zs + length aux'' =\n    min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n     (Monitor.progress \\<sigma> \\<psi>'' (Suc j)) \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v.\n              MFOTL.sat \\<sigma> (map the v) i\n               (formula.Until\n                 (if pos then \\<phi>'' else formula.Neg \\<phi>'') I\n                 \\<psi>'')))\n     [i..<i + length zs] zs", "using Cons.prems Suc_i_aux'[simplified]"], ["proof (prove)\nusing this:\n  enat\n   (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n    | nt # x \\<Rightarrow> nt)\n  \\<le> enat t + right I \\<Longrightarrow>\n  Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') (Suc j)\n  \\<le> i\n  enat t + right I\n  < enat\n     (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n      | nt # x \\<Rightarrow> nt) \\<Longrightarrow>\n  Suc i\n  \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n         (Suc j)\n  \\<lbrakk>enat (\\<tau> \\<sigma> i) + right I\n           < enat\n              (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n               | nt # x \\<Rightarrow> nt);\n   enat (\\<tau> \\<sigma> ?k - \\<tau> \\<sigma> i) \\<le> right I;\n   ?\\<psi> = \\<psi>'' \\<or> ?\\<psi> = \\<phi>''\\<rbrakk>\n  \\<Longrightarrow> ?k < Monitor.progress \\<sigma> ?\\<psi> (Suc j)\n  i \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n           (Suc j)\n  wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' (a # aux') i\n  i + length (a # aux') =\n  min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n   (Monitor.progress \\<sigma> \\<psi>'' (Suc j))\n  eval_until I\n   (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n    | nt # x \\<Rightarrow> nt)\n   (a # aux') =\n  (zs, aux'')\n  Suc (i + length aux') =\n  min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n   (Monitor.progress \\<sigma> \\<psi>'' (Suc j))\n\ngoal (1 subgoal):\n 1. wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux''\n     (Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n       (Suc j)) \\<and>\n    i + length zs =\n    Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n     (Suc j) \\<and>\n    i + length zs + length aux'' =\n    min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n     (Monitor.progress \\<sigma> \\<psi>'' (Suc j)) \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v.\n              MFOTL.sat \\<sigma> (map the v) i\n               (formula.Until\n                 (if pos then \\<phi>'' else formula.Neg \\<phi>'') I\n                 \\<psi>'')))\n     [i..<i + length zs] zs", "unfolding \\<open>a = (t, a1, a2)\\<close>"], ["proof (prove)\nusing this:\n  enat\n   (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n    | nt # x \\<Rightarrow> nt)\n  \\<le> enat t + right I \\<Longrightarrow>\n  Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') (Suc j)\n  \\<le> i\n  enat t + right I\n  < enat\n     (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n      | nt # x \\<Rightarrow> nt) \\<Longrightarrow>\n  Suc i\n  \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n         (Suc j)\n  \\<lbrakk>enat (\\<tau> \\<sigma> i) + right I\n           < enat\n              (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n               | nt # x \\<Rightarrow> nt);\n   enat (\\<tau> \\<sigma> ?k - \\<tau> \\<sigma> i) \\<le> right I;\n   ?\\<psi> = \\<psi>'' \\<or> ?\\<psi> = \\<phi>''\\<rbrakk>\n  \\<Longrightarrow> ?k < Monitor.progress \\<sigma> ?\\<psi> (Suc j)\n  i \\<le> Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n           (Suc j)\n  wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' ((t, a1, a2) # aux') i\n  i + length ((t, a1, a2) # aux') =\n  min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n   (Monitor.progress \\<sigma> \\<psi>'' (Suc j))\n  eval_until I\n   (case nts' of [] \\<Rightarrow> \\<tau> \\<sigma> j\n    | nt # x \\<Rightarrow> nt)\n   ((t, a1, a2) # aux') =\n  (zs, aux'')\n  Suc (i + length aux') =\n  min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n   (Monitor.progress \\<sigma> \\<psi>'' (Suc j))\n\ngoal (1 subgoal):\n 1. wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux''\n     (Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n       (Suc j)) \\<and>\n    i + length zs =\n    Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n     (Suc j) \\<and>\n    i + length zs + length aux'' =\n    min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n     (Monitor.progress \\<sigma> \\<psi>'' (Suc j)) \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v.\n              MFOTL.sat \\<sigma> (map the v) i\n               (formula.Until\n                 (if pos then \\<phi>'' else formula.Neg \\<phi>'') I\n                 \\<psi>'')))\n     [i..<i + length zs] zs", "by (auto simp: \\<phi>''' 1 sat.simps upt_conv_Cons dest!:  Cons.IH[OF _ aux' Suc_i_aux']\n          simp del: upt_Suc split: if_splits prod.splits intro!: iff_exI qtable_cong[OF 3 refl])"], ["proof (state)\nthis:\n  wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux''\n   (Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n     (Suc j)) \\<and>\n  i + length zs =\n  Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n   (Suc j) \\<and>\n  i + length zs + length aux'' =\n  min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n   (Monitor.progress \\<sigma> \\<psi>'' (Suc j)) \\<and>\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<psi>'') (mem_restr R)\n        (\\<lambda>v.\n            MFOTL.sat \\<sigma> (map the v) i\n             (formula.Until (if pos then \\<phi>'' else formula.Neg \\<phi>'')\n               I \\<psi>'')))\n   [i..<i + length zs] zs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?i \\<le> Monitor.progress \\<sigma>\n                     (formula.Until \\<phi>''' I \\<psi>'') (Suc j);\n   wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux' ?i;\n   ?i + length aux' =\n   min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n    (Monitor.progress \\<sigma> \\<psi>'' (Suc j))\\<rbrakk>\n  \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux''\n                     (Monitor.progress \\<sigma>\n                       (formula.Until \\<phi>''' I \\<psi>'') (Suc j)) \\<and>\n                    ?i + length zs =\n                    Monitor.progress \\<sigma>\n                     (formula.Until \\<phi>''' I \\<psi>'') (Suc j) \\<and>\n                    ?i + length zs + length aux'' =\n                    min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                     (Monitor.progress \\<sigma> \\<psi>'' (Suc j)) \\<and>\n                    list_all2\n                     (\\<lambda>i.\n                         qtable n (fv \\<psi>'') (mem_restr R)\n                          (\\<lambda>v.\n                              MFOTL.sat \\<sigma> (map the v) i\n                               (formula.Until\n                                 (if pos then \\<phi>''\n                                  else formula.Neg \\<phi>'')\n                                 I \\<psi>'')))\n                     [?i..<?i + length zs] zs\n\ngoal (1 subgoal):\n 1. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "note this[OF progress_mono[OF le_SucI, OF order.refl] conjunct1[OF update1] conjunct2[OF update1]]"], ["proof (state)\nthis:\n  wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>'' aux''\n   (Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n     (Suc j)) \\<and>\n  Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') j +\n  length zs =\n  Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'')\n   (Suc j) \\<and>\n  Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') j +\n  length zs +\n  length aux'' =\n  min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n   (Monitor.progress \\<sigma> \\<psi>'' (Suc j)) \\<and>\n  list_all2\n   (\\<lambda>i.\n       qtable n (fv \\<psi>'') (mem_restr R)\n        (\\<lambda>v.\n            MFOTL.sat \\<sigma> (map the v) i\n             (formula.Until (if pos then \\<phi>'' else formula.Neg \\<phi>'')\n               I \\<psi>'')))\n   [Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') j..<\n    Monitor.progress \\<sigma> (formula.Until \\<phi>''' I \\<psi>'') j +\n    length zs]\n   zs\n\ngoal (1 subgoal):\n 1. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "}"], ["proof (state)\nthis:\n  \\<lbrakk>fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>) =\n           ?xs2;\n   fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<psi>) = ?ys2;\n   mbuf2t_take (update_until I pos) aux (mbuf2_add ?xs2 ?ys2 buf)\n    (nts @ [\\<tau> \\<sigma> j]) =\n   (?aux'2, ?buf'2, ?nts'2);\n   eval_until I\n    (case ?nts'2 of [] \\<Rightarrow> \\<tau> \\<sigma> j\n     | nt # x \\<Rightarrow> nt)\n    ?aux'2 =\n   (?zs2, ?aux''2)\\<rbrakk>\n  \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                     ?aux''2\n                     (Monitor.progress \\<sigma>\n                       (formula.Until \\<phi>''' I \\<psi>'') (Suc j)) \\<and>\n                    Monitor.progress \\<sigma>\n                     (formula.Until \\<phi>''' I \\<psi>'') j +\n                    length ?zs2 =\n                    Monitor.progress \\<sigma>\n                     (formula.Until \\<phi>''' I \\<psi>'') (Suc j) \\<and>\n                    Monitor.progress \\<sigma>\n                     (formula.Until \\<phi>''' I \\<psi>'') j +\n                    length ?zs2 +\n                    length ?aux''2 =\n                    min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                     (Monitor.progress \\<sigma> \\<psi>'' (Suc j)) \\<and>\n                    list_all2\n                     (\\<lambda>i.\n                         qtable n (fv \\<psi>'') (mem_restr R)\n                          (\\<lambda>v.\n                              MFOTL.sat \\<sigma> (map the v) i\n                               (formula.Until\n                                 (if pos then \\<phi>''\n                                  else formula.Neg \\<phi>'')\n                                 I \\<psi>'')))\n                     [Monitor.progress \\<sigma>\n                       (formula.Until \\<phi>''' I \\<psi>'') j..<\n                      Monitor.progress \\<sigma>\n                       (formula.Until \\<phi>''' I \\<psi>'') j +\n                      length ?zs2]\n                     ?zs2\n\ngoal (1 subgoal):\n 1. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "note update = this"], ["proof (state)\nthis:\n  \\<lbrakk>fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>) =\n           ?xs2;\n   fst (meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<psi>) = ?ys2;\n   mbuf2t_take (update_until I pos) aux (mbuf2_add ?xs2 ?ys2 buf)\n    (nts @ [\\<tau> \\<sigma> j]) =\n   (?aux'2, ?buf'2, ?nts'2);\n   eval_until I\n    (case ?nts'2 of [] \\<Rightarrow> \\<tau> \\<sigma> j\n     | nt # x \\<Rightarrow> nt)\n    ?aux'2 =\n   (?zs2, ?aux''2)\\<rbrakk>\n  \\<Longrightarrow> wf_until_aux \\<sigma> n R pos \\<phi>'' I \\<psi>''\n                     ?aux''2\n                     (Monitor.progress \\<sigma>\n                       (formula.Until \\<phi>''' I \\<psi>'') (Suc j)) \\<and>\n                    Monitor.progress \\<sigma>\n                     (formula.Until \\<phi>''' I \\<psi>'') j +\n                    length ?zs2 =\n                    Monitor.progress \\<sigma>\n                     (formula.Until \\<phi>''' I \\<psi>'') (Suc j) \\<and>\n                    Monitor.progress \\<sigma>\n                     (formula.Until \\<phi>''' I \\<psi>'') j +\n                    length ?zs2 +\n                    length ?aux''2 =\n                    min (Monitor.progress \\<sigma> \\<phi>''' (Suc j))\n                     (Monitor.progress \\<sigma> \\<psi>'' (Suc j)) \\<and>\n                    list_all2\n                     (\\<lambda>i.\n                         qtable n (fv \\<psi>'') (mem_restr R)\n                          (\\<lambda>v.\n                              MFOTL.sat \\<sigma> (map the v) i\n                               (formula.Until\n                                 (if pos then \\<phi>''\n                                  else formula.Neg \\<phi>'')\n                                 I \\<psi>'')))\n                     [Monitor.progress \\<sigma>\n                       (formula.Until \\<phi>''' I \\<psi>'') j..<\n                      Monitor.progress \\<sigma>\n                       (formula.Until \\<phi>''' I \\<psi>'') j +\n                      length ?zs2]\n                     ?zs2\n\ngoal (1 subgoal):\n 1. \\<And>x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7 n R \\<phi>'.\n       \\<lbrakk>\\<And>n R \\<phi>'.\n                   wf_mformula \\<sigma> j n R \\<phi>1\n                    \\<phi>' \\<Longrightarrow>\n                   case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n                         \\<phi>1 of\n                   (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                     wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                      \\<phi>' \\<and>\n                     list_all2\n                      (\\<lambda>i.\n                          qtable n (fv \\<phi>') (mem_restr R)\n                           (\\<lambda>v.\n                               MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n                      [Monitor.progress \\<sigma> \\<phi>' j..<\n                       Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                      xs;\n        \\<And>n R \\<phi>'.\n           wf_mformula \\<sigma> j n R \\<phi>2 \\<phi>' \\<Longrightarrow>\n           case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi>2 of\n           (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n             wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n             list_all2\n              (\\<lambda>i.\n                  qtable n (fv \\<phi>') (mem_restr R)\n                   (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n              [Monitor.progress \\<sigma> \\<phi>' j..<\n               Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n              xs;\n        wf_mformula \\<sigma> j n R (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7)\n         \\<phi>'\\<rbrakk>\n       \\<Longrightarrow> case meval n (\\<tau> \\<sigma> j)\n                               (\\<Gamma> \\<sigma> j)\n                               (MUntil x1a \\<phi>1 x3 \\<phi>2 x5a x6 x7) of\n                         (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n                           wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n\n                            \\<phi>' \\<and>\n                           list_all2\n                            (\\<lambda>i.\n                                qtable n (fv \\<phi>') (mem_restr R)\n                                 (\\<lambda>v.\n                                     MFOTL.sat \\<sigma> (map the v) i\n\\<phi>'))\n                            [Monitor.progress \\<sigma> \\<phi>' j..<\n                             Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n                            xs", "from MUntil.IH(1)[OF \\<phi>] MUntil.IH(2)[OF \\<psi>] pos pos_eq fvi_subset"], ["proof (chain)\npicking this:\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>'' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>'') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>''))\n     [Monitor.progress \\<sigma> \\<phi>'' j..<\n      Monitor.progress \\<sigma> \\<phi>'' (Suc j)]\n     xs\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<psi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<psi>'' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>''))\n     [Monitor.progress \\<sigma> \\<psi>'' j..<\n      Monitor.progress \\<sigma> \\<psi>'' (Suc j)]\n     xs\n  if pos then \\<phi>''' = \\<phi>'' else \\<phi>''' = formula.Neg \\<phi>''\n  safe_formula \\<phi>''' = pos\n  fv \\<phi>'' \\<subseteq> fv \\<psi>''", "show ?case"], ["proof (prove)\nusing this:\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<phi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>'' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>'') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>''))\n     [Monitor.progress \\<sigma> \\<phi>'' j..<\n      Monitor.progress \\<sigma> \\<phi>'' (Suc j)]\n     xs\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j) \\<psi> of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<psi>'' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<psi>'') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<psi>''))\n     [Monitor.progress \\<sigma> \\<psi>'' j..<\n      Monitor.progress \\<sigma> \\<psi>'' (Suc j)]\n     xs\n  if pos then \\<phi>''' = \\<phi>'' else \\<phi>''' = formula.Neg \\<phi>''\n  safe_formula \\<phi>''' = pos\n  fv \\<phi>'' \\<subseteq> fv \\<psi>''\n\ngoal (1 subgoal):\n 1. case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n          (MUntil pos \\<phi> I \\<psi> buf nts aux) of\n    (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n      wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n      list_all2\n       (\\<lambda>i.\n           qtable n (fv \\<phi>') (mem_restr R)\n            (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n       [Monitor.progress \\<sigma> \\<phi>' j..<\n        Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n       xs", "by (auto 0 4 simp: Until_eq \\<phi>''' progress.simps(3) split: prod.split if_splits\n      dest!: update[OF refl refl, rotated]\n      intro!: wf_mformula.Until\n      elim!: list.rel_mono_strong qtable_cong\n      elim: mbuf2t_take_add'(1)[OF _ buf nts_snoc] mbuf2t_take_add'(2)[OF _ buf nts_snoc])"], ["proof (state)\nthis:\n  case meval n (\\<tau> \\<sigma> j) (\\<Gamma> \\<sigma> j)\n        (MUntil pos \\<phi> I \\<psi> buf nts aux) of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc j) n R \\<phi>\\<^sub>n \\<phi>' \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable n (fv \\<phi>') (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>'))\n     [Monitor.progress \\<sigma> \\<phi>' j..<\n      Monitor.progress \\<sigma> \\<phi>' (Suc j)]\n     xs\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Monitor step\\<close>"], ["", "lemma wf_mstate_mstep: \"wf_mstate \\<phi> \\<pi> R st \\<Longrightarrow> last_ts \\<pi> \\<le> snd tdb \\<Longrightarrow>\n  wf_mstate \\<phi> (psnoc \\<pi> tdb) R (snd (mstep tdb st))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_mstate \\<phi> \\<pi> R st;\n     last_ts \\<pi> \\<le> snd tdb\\<rbrakk>\n    \\<Longrightarrow> wf_mstate \\<phi> (psnoc \\<pi> tdb) R\n                       (snd (mstep tdb st))", "unfolding wf_mstate_def mstep_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mstate_n st = MFOTL.nfv \\<phi> \\<and>\n             (\\<forall>\\<sigma>.\n                 prefix_of \\<pi> \\<sigma> \\<longrightarrow>\n                 mstate_i st =\n                 Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<and>\n                 wf_mformula \\<sigma> (plen \\<pi>) (mstate_n st) R\n                  (mstate_m st) \\<phi>);\n     last_ts \\<pi> \\<le> snd tdb\\<rbrakk>\n    \\<Longrightarrow> mstate_n\n                       (snd (case meval (mstate_n st) (snd tdb) (fst tdb)\n                                   (mstate_m st) of\n                             (xs, m) \\<Rightarrow>\n                               (\\<Union>\n                                 (set (map (\\<lambda>(i, y). Pair i ` y)\n  (List.enumerate (mstate_i st) xs))),\n                                \\<lparr>mstate_i = mstate_i st + length xs,\n                                   mstate_m = m,\n                                   mstate_n = mstate_n st\\<rparr>))) =\n                      MFOTL.nfv \\<phi> \\<and>\n                      (\\<forall>\\<sigma>.\n                          prefix_of (psnoc \\<pi> tdb)\n                           \\<sigma> \\<longrightarrow>\n                          mstate_i\n                           (snd (case meval (mstate_n st) (snd tdb)\n (fst tdb) (mstate_m st) of\n                                 (xs, m) \\<Rightarrow>\n                                   (\\<Union>\n                                     (set\n (map (\\<lambda>(i, y). Pair i ` y) (List.enumerate (mstate_i st) xs))),\n                                    \\<lparr>mstate_i =\n        mstate_i st + length xs,\n mstate_m = m, mstate_n = mstate_n st\\<rparr>))) =\n                          Monitor.progress \\<sigma> \\<phi>\n                           (plen (psnoc \\<pi> tdb)) \\<and>\n                          wf_mformula \\<sigma> (plen (psnoc \\<pi> tdb))\n                           (mstate_n\n                             (snd (case meval (mstate_n st) (snd tdb)\n   (fst tdb) (mstate_m st) of\n                                   (xs, m) \\<Rightarrow>\n                                     (\\<Union>\n (set (map (\\<lambda>(i, y). Pair i ` y)\n        (List.enumerate (mstate_i st) xs))),\n\\<lparr>mstate_i = mstate_i st + length xs, mstate_m = m,\n   mstate_n = mstate_n st\\<rparr>))))\n                           R (mstate_m\n                               (snd (case meval (mstate_n st) (snd tdb)\n     (fst tdb) (mstate_m st) of\n                                     (xs, m) \\<Rightarrow>\n (\\<Union>\n   (set (map (\\<lambda>(i, y). Pair i ` y)\n          (List.enumerate (mstate_i st) xs))),\n  \\<lparr>mstate_i = mstate_i st + length xs, mstate_m = m,\n     mstate_n = mstate_n st\\<rparr>))))\n                           \\<phi>)", "by (fastforce simp add: progress_mono le_imp_diff_is_add split: prod.splits\n      elim!: prefix_of_psnocE dest: meval list_all2_lengthD)"], ["", "lemma mstep_output_iff: \n  assumes \"wf_mstate \\<phi> \\<pi> R st\" \"last_ts \\<pi> \\<le> snd tdb\" \"prefix_of (psnoc \\<pi> tdb) \\<sigma>\" \"mem_restr R v\" \n  shows \"(i, v) \\<in> fst (mstep tdb st) \\<longleftrightarrow>\n    progress \\<sigma> \\<phi> (plen \\<pi>) \\<le> i \\<and> i < progress \\<sigma> \\<phi> (Suc (plen \\<pi>)) \\<and>\n    wf_tuple (MFOTL.nfv \\<phi>) (MFOTL.fv \\<phi>) v \\<and> MFOTL.sat \\<sigma> (map the v) i \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((i, v) \\<in> fst (mstep tdb st)) =\n    (Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<le> i \\<and>\n     i < Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>)) \\<and>\n     wf_tuple (MFOTL.nfv \\<phi>) (fv \\<phi>) v \\<and>\n     MFOTL.sat \\<sigma> (map the v) i \\<phi>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((i, v) \\<in> fst (mstep tdb st)) =\n    (Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<le> i \\<and>\n     i < Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>)) \\<and>\n     wf_tuple (MFOTL.nfv \\<phi>) (fv \\<phi>) v \\<and>\n     MFOTL.sat \\<sigma> (map the v) i \\<phi>)", "from prefix_of_psnocE[OF assms(3,2)]"], ["proof (chain)\npicking this:\n  (\\<lbrakk>prefix_of \\<pi> \\<sigma>;\n    \\<Gamma> \\<sigma> (plen \\<pi>) = fst tdb;\n    \\<tau> \\<sigma> (plen \\<pi>) = snd tdb\\<rbrakk>\n   \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P", "have \"prefix_of \\<pi> \\<sigma>\" \n    \"\\<Gamma> \\<sigma> (plen \\<pi>) = fst tdb\" \"\\<tau> \\<sigma> (plen \\<pi>) = snd tdb\""], ["proof (prove)\nusing this:\n  (\\<lbrakk>prefix_of \\<pi> \\<sigma>;\n    \\<Gamma> \\<sigma> (plen \\<pi>) = fst tdb;\n    \\<tau> \\<sigma> (plen \\<pi>) = snd tdb\\<rbrakk>\n   \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. prefix_of \\<pi> \\<sigma> &&&\n    \\<Gamma> \\<sigma> (plen \\<pi>) = fst tdb &&&\n    \\<tau> \\<sigma> (plen \\<pi>) = snd tdb", "by auto"], ["proof (state)\nthis:\n  prefix_of \\<pi> \\<sigma>\n  \\<Gamma> \\<sigma> (plen \\<pi>) = fst tdb\n  \\<tau> \\<sigma> (plen \\<pi>) = snd tdb\n\ngoal (1 subgoal):\n 1. ((i, v) \\<in> fst (mstep tdb st)) =\n    (Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<le> i \\<and>\n     i < Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>)) \\<and>\n     wf_tuple (MFOTL.nfv \\<phi>) (fv \\<phi>) v \\<and>\n     MFOTL.sat \\<sigma> (map the v) i \\<phi>)", "moreover"], ["proof (state)\nthis:\n  prefix_of \\<pi> \\<sigma>\n  \\<Gamma> \\<sigma> (plen \\<pi>) = fst tdb\n  \\<tau> \\<sigma> (plen \\<pi>) = snd tdb\n\ngoal (1 subgoal):\n 1. ((i, v) \\<in> fst (mstep tdb st)) =\n    (Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<le> i \\<and>\n     i < Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>)) \\<and>\n     wf_tuple (MFOTL.nfv \\<phi>) (fv \\<phi>) v \\<and>\n     MFOTL.sat \\<sigma> (map the v) i \\<phi>)", "from assms(1) \\<open>prefix_of \\<pi> \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  wf_mstate \\<phi> \\<pi> R st\n  prefix_of \\<pi> \\<sigma>", "have \"mstate_n st = MFOTL.nfv \\<phi>\"\n    \"mstate_i st = progress \\<sigma> \\<phi> (plen \\<pi>)\" \"wf_mformula \\<sigma> (plen \\<pi>) (mstate_n st) R (mstate_m st) \\<phi>\""], ["proof (prove)\nusing this:\n  wf_mstate \\<phi> \\<pi> R st\n  prefix_of \\<pi> \\<sigma>\n\ngoal (1 subgoal):\n 1. mstate_n st = MFOTL.nfv \\<phi> &&&\n    mstate_i st = Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) &&&\n    wf_mformula \\<sigma> (plen \\<pi>) (mstate_n st) R (mstate_m st) \\<phi>", "unfolding wf_mstate_def"], ["proof (prove)\nusing this:\n  mstate_n st = MFOTL.nfv \\<phi> \\<and>\n  (\\<forall>\\<sigma>.\n      prefix_of \\<pi> \\<sigma> \\<longrightarrow>\n      mstate_i st = Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<and>\n      wf_mformula \\<sigma> (plen \\<pi>) (mstate_n st) R (mstate_m st)\n       \\<phi>)\n  prefix_of \\<pi> \\<sigma>\n\ngoal (1 subgoal):\n 1. mstate_n st = MFOTL.nfv \\<phi> &&&\n    mstate_i st = Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) &&&\n    wf_mformula \\<sigma> (plen \\<pi>) (mstate_n st) R (mstate_m st) \\<phi>", "by blast+"], ["proof (state)\nthis:\n  mstate_n st = MFOTL.nfv \\<phi>\n  mstate_i st = Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)\n  wf_mformula \\<sigma> (plen \\<pi>) (mstate_n st) R (mstate_m st) \\<phi>\n\ngoal (1 subgoal):\n 1. ((i, v) \\<in> fst (mstep tdb st)) =\n    (Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<le> i \\<and>\n     i < Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>)) \\<and>\n     wf_tuple (MFOTL.nfv \\<phi>) (fv \\<phi>) v \\<and>\n     MFOTL.sat \\<sigma> (map the v) i \\<phi>)", "moreover"], ["proof (state)\nthis:\n  mstate_n st = MFOTL.nfv \\<phi>\n  mstate_i st = Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)\n  wf_mformula \\<sigma> (plen \\<pi>) (mstate_n st) R (mstate_m st) \\<phi>\n\ngoal (1 subgoal):\n 1. ((i, v) \\<in> fst (mstep tdb st)) =\n    (Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<le> i \\<and>\n     i < Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>)) \\<and>\n     wf_tuple (MFOTL.nfv \\<phi>) (fv \\<phi>) v \\<and>\n     MFOTL.sat \\<sigma> (map the v) i \\<phi>)", "from meval[OF \\<open>wf_mformula \\<sigma> (plen \\<pi>) (mstate_n st) R (mstate_m st) \\<phi>\\<close>]"], ["proof (chain)\npicking this:\n  case meval (mstate_n st) (\\<tau> \\<sigma> (plen \\<pi>))\n        (\\<Gamma> \\<sigma> (plen \\<pi>)) (mstate_m st) of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc (plen \\<pi>)) (mstate_n st) R \\<phi>\\<^sub>n\n     \\<phi> \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable (mstate_n st) (fv \\<phi>) (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n     [Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)..<\n      Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>))]\n     xs", "obtain Vs st' where\n    \"meval (mstate_n st) (\\<tau> \\<sigma> (plen \\<pi>)) (\\<Gamma> \\<sigma> (plen \\<pi>)) (mstate_m st) = (Vs, st')\"\n    \"wf_mformula \\<sigma> (Suc (plen \\<pi>)) (mstate_n st) R st' \\<phi>\"\n    \"list_all2 (\\<lambda>i. qtable (mstate_n st) (fv \\<phi>) (mem_restr R) (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n      [progress \\<sigma> \\<phi> (plen \\<pi>)..<progress \\<sigma> \\<phi> (Suc (plen \\<pi>))] Vs\""], ["proof (prove)\nusing this:\n  case meval (mstate_n st) (\\<tau> \\<sigma> (plen \\<pi>))\n        (\\<Gamma> \\<sigma> (plen \\<pi>)) (mstate_m st) of\n  (xs, \\<phi>\\<^sub>n) \\<Rightarrow>\n    wf_mformula \\<sigma> (Suc (plen \\<pi>)) (mstate_n st) R \\<phi>\\<^sub>n\n     \\<phi> \\<and>\n    list_all2\n     (\\<lambda>i.\n         qtable (mstate_n st) (fv \\<phi>) (mem_restr R)\n          (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n     [Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)..<\n      Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>))]\n     xs\n\ngoal (1 subgoal):\n 1. (\\<And>Vs st'.\n        \\<lbrakk>meval (mstate_n st) (\\<tau> \\<sigma> (plen \\<pi>))\n                  (\\<Gamma> \\<sigma> (plen \\<pi>)) (mstate_m st) =\n                 (Vs, st');\n         wf_mformula \\<sigma> (Suc (plen \\<pi>)) (mstate_n st) R st' \\<phi>;\n         list_all2\n          (\\<lambda>i.\n              qtable (mstate_n st) (fv \\<phi>) (mem_restr R)\n               (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n          [Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)..<\n           Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>))]\n          Vs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  meval (mstate_n st) (\\<tau> \\<sigma> (plen \\<pi>))\n   (\\<Gamma> \\<sigma> (plen \\<pi>)) (mstate_m st) =\n  (Vs, st')\n  wf_mformula \\<sigma> (Suc (plen \\<pi>)) (mstate_n st) R st' \\<phi>\n  list_all2\n   (\\<lambda>i.\n       qtable (mstate_n st) (fv \\<phi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n   [Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)..<\n    Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>))]\n   Vs\n\ngoal (1 subgoal):\n 1. ((i, v) \\<in> fst (mstep tdb st)) =\n    (Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<le> i \\<and>\n     i < Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>)) \\<and>\n     wf_tuple (MFOTL.nfv \\<phi>) (fv \\<phi>) v \\<and>\n     MFOTL.sat \\<sigma> (map the v) i \\<phi>)", "moreover"], ["proof (state)\nthis:\n  meval (mstate_n st) (\\<tau> \\<sigma> (plen \\<pi>))\n   (\\<Gamma> \\<sigma> (plen \\<pi>)) (mstate_m st) =\n  (Vs, st')\n  wf_mformula \\<sigma> (Suc (plen \\<pi>)) (mstate_n st) R st' \\<phi>\n  list_all2\n   (\\<lambda>i.\n       qtable (mstate_n st) (fv \\<phi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n   [Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)..<\n    Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>))]\n   Vs\n\ngoal (1 subgoal):\n 1. ((i, v) \\<in> fst (mstep tdb st)) =\n    (Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<le> i \\<and>\n     i < Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>)) \\<and>\n     wf_tuple (MFOTL.nfv \\<phi>) (fv \\<phi>) v \\<and>\n     MFOTL.sat \\<sigma> (map the v) i \\<phi>)", "from this assms(4)"], ["proof (chain)\npicking this:\n  meval (mstate_n st) (\\<tau> \\<sigma> (plen \\<pi>))\n   (\\<Gamma> \\<sigma> (plen \\<pi>)) (mstate_m st) =\n  (Vs, st')\n  wf_mformula \\<sigma> (Suc (plen \\<pi>)) (mstate_n st) R st' \\<phi>\n  list_all2\n   (\\<lambda>i.\n       qtable (mstate_n st) (fv \\<phi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n   [Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)..<\n    Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>))]\n   Vs\n  mem_restr R v", "have \"qtable (mstate_n st) (fv \\<phi>) (mem_restr R)\n    (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>) (Vs ! (i - progress \\<sigma> \\<phi> (plen \\<pi>)))\"\n      if \"progress \\<sigma> \\<phi> (plen \\<pi>) \\<le> i\" \"i < progress \\<sigma> \\<phi> (Suc (plen \\<pi>))\""], ["proof (prove)\nusing this:\n  meval (mstate_n st) (\\<tau> \\<sigma> (plen \\<pi>))\n   (\\<Gamma> \\<sigma> (plen \\<pi>)) (mstate_m st) =\n  (Vs, st')\n  wf_mformula \\<sigma> (Suc (plen \\<pi>)) (mstate_n st) R st' \\<phi>\n  list_all2\n   (\\<lambda>i.\n       qtable (mstate_n st) (fv \\<phi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n   [Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)..<\n    Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>))]\n   Vs\n  mem_restr R v\n\ngoal (1 subgoal):\n 1. qtable (mstate_n st) (fv \\<phi>) (mem_restr R)\n     (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>)\n     (Vs ! (i - Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)))", "using that"], ["proof (prove)\nusing this:\n  meval (mstate_n st) (\\<tau> \\<sigma> (plen \\<pi>))\n   (\\<Gamma> \\<sigma> (plen \\<pi>)) (mstate_m st) =\n  (Vs, st')\n  wf_mformula \\<sigma> (Suc (plen \\<pi>)) (mstate_n st) R st' \\<phi>\n  list_all2\n   (\\<lambda>i.\n       qtable (mstate_n st) (fv \\<phi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n   [Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)..<\n    Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>))]\n   Vs\n  mem_restr R v\n  Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<le> i\n  i < Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>))\n\ngoal (1 subgoal):\n 1. qtable (mstate_n st) (fv \\<phi>) (mem_restr R)\n     (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>)\n     (Vs ! (i - Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)))", "by (auto simp: list_all2_conv_all_nth\n      dest!: spec[of _ \"(i - progress \\<sigma> \\<phi> (plen \\<pi>))\"])"], ["proof (state)\nthis:\n  \\<lbrakk>Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<le> i;\n   i < Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>))\\<rbrakk>\n  \\<Longrightarrow> qtable (mstate_n st) (fv \\<phi>) (mem_restr R)\n                     (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>)\n                     (Vs !\n                      (i - Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)))\n\ngoal (1 subgoal):\n 1. ((i, v) \\<in> fst (mstep tdb st)) =\n    (Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<le> i \\<and>\n     i < Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>)) \\<and>\n     wf_tuple (MFOTL.nfv \\<phi>) (fv \\<phi>) v \\<and>\n     MFOTL.sat \\<sigma> (map the v) i \\<phi>)", "ultimately"], ["proof (chain)\npicking this:\n  prefix_of \\<pi> \\<sigma>\n  \\<Gamma> \\<sigma> (plen \\<pi>) = fst tdb\n  \\<tau> \\<sigma> (plen \\<pi>) = snd tdb\n  mstate_n st = MFOTL.nfv \\<phi>\n  mstate_i st = Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)\n  wf_mformula \\<sigma> (plen \\<pi>) (mstate_n st) R (mstate_m st) \\<phi>\n  meval (mstate_n st) (\\<tau> \\<sigma> (plen \\<pi>))\n   (\\<Gamma> \\<sigma> (plen \\<pi>)) (mstate_m st) =\n  (Vs, st')\n  wf_mformula \\<sigma> (Suc (plen \\<pi>)) (mstate_n st) R st' \\<phi>\n  list_all2\n   (\\<lambda>i.\n       qtable (mstate_n st) (fv \\<phi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n   [Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)..<\n    Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>))]\n   Vs\n  \\<lbrakk>Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<le> i;\n   i < Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>))\\<rbrakk>\n  \\<Longrightarrow> qtable (mstate_n st) (fv \\<phi>) (mem_restr R)\n                     (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>)\n                     (Vs !\n                      (i - Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)))", "show ?thesis"], ["proof (prove)\nusing this:\n  prefix_of \\<pi> \\<sigma>\n  \\<Gamma> \\<sigma> (plen \\<pi>) = fst tdb\n  \\<tau> \\<sigma> (plen \\<pi>) = snd tdb\n  mstate_n st = MFOTL.nfv \\<phi>\n  mstate_i st = Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)\n  wf_mformula \\<sigma> (plen \\<pi>) (mstate_n st) R (mstate_m st) \\<phi>\n  meval (mstate_n st) (\\<tau> \\<sigma> (plen \\<pi>))\n   (\\<Gamma> \\<sigma> (plen \\<pi>)) (mstate_m st) =\n  (Vs, st')\n  wf_mformula \\<sigma> (Suc (plen \\<pi>)) (mstate_n st) R st' \\<phi>\n  list_all2\n   (\\<lambda>i.\n       qtable (mstate_n st) (fv \\<phi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n   [Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)..<\n    Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>))]\n   Vs\n  \\<lbrakk>Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<le> i;\n   i < Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>))\\<rbrakk>\n  \\<Longrightarrow> qtable (mstate_n st) (fv \\<phi>) (mem_restr R)\n                     (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>)\n                     (Vs !\n                      (i - Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)))\n\ngoal (1 subgoal):\n 1. ((i, v) \\<in> fst (mstep tdb st)) =\n    (Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<le> i \\<and>\n     i < Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>)) \\<and>\n     wf_tuple (MFOTL.nfv \\<phi>) (fv \\<phi>) v \\<and>\n     MFOTL.sat \\<sigma> (map the v) i \\<phi>)", "using assms(4)"], ["proof (prove)\nusing this:\n  prefix_of \\<pi> \\<sigma>\n  \\<Gamma> \\<sigma> (plen \\<pi>) = fst tdb\n  \\<tau> \\<sigma> (plen \\<pi>) = snd tdb\n  mstate_n st = MFOTL.nfv \\<phi>\n  mstate_i st = Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)\n  wf_mformula \\<sigma> (plen \\<pi>) (mstate_n st) R (mstate_m st) \\<phi>\n  meval (mstate_n st) (\\<tau> \\<sigma> (plen \\<pi>))\n   (\\<Gamma> \\<sigma> (plen \\<pi>)) (mstate_m st) =\n  (Vs, st')\n  wf_mformula \\<sigma> (Suc (plen \\<pi>)) (mstate_n st) R st' \\<phi>\n  list_all2\n   (\\<lambda>i.\n       qtable (mstate_n st) (fv \\<phi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n   [Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)..<\n    Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>))]\n   Vs\n  \\<lbrakk>Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<le> i;\n   i < Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>))\\<rbrakk>\n  \\<Longrightarrow> qtable (mstate_n st) (fv \\<phi>) (mem_restr R)\n                     (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>)\n                     (Vs !\n                      (i - Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)))\n  mem_restr R v\n\ngoal (1 subgoal):\n 1. ((i, v) \\<in> fst (mstep tdb st)) =\n    (Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<le> i \\<and>\n     i < Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>)) \\<and>\n     wf_tuple (MFOTL.nfv \\<phi>) (fv \\<phi>) v \\<and>\n     MFOTL.sat \\<sigma> (map the v) i \\<phi>)", "unfolding mstep_def Let_def"], ["proof (prove)\nusing this:\n  prefix_of \\<pi> \\<sigma>\n  \\<Gamma> \\<sigma> (plen \\<pi>) = fst tdb\n  \\<tau> \\<sigma> (plen \\<pi>) = snd tdb\n  mstate_n st = MFOTL.nfv \\<phi>\n  mstate_i st = Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)\n  wf_mformula \\<sigma> (plen \\<pi>) (mstate_n st) R (mstate_m st) \\<phi>\n  meval (mstate_n st) (\\<tau> \\<sigma> (plen \\<pi>))\n   (\\<Gamma> \\<sigma> (plen \\<pi>)) (mstate_m st) =\n  (Vs, st')\n  wf_mformula \\<sigma> (Suc (plen \\<pi>)) (mstate_n st) R st' \\<phi>\n  list_all2\n   (\\<lambda>i.\n       qtable (mstate_n st) (fv \\<phi>) (mem_restr R)\n        (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>))\n   [Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)..<\n    Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>))]\n   Vs\n  \\<lbrakk>Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<le> i;\n   i < Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>))\\<rbrakk>\n  \\<Longrightarrow> qtable (mstate_n st) (fv \\<phi>) (mem_restr R)\n                     (\\<lambda>v. MFOTL.sat \\<sigma> (map the v) i \\<phi>)\n                     (Vs !\n                      (i - Monitor.progress \\<sigma> \\<phi> (plen \\<pi>)))\n  mem_restr R v\n\ngoal (1 subgoal):\n 1. ((i, v)\n     \\<in> fst (case meval (mstate_n st) (snd tdb) (fst tdb)\n                      (mstate_m st) of\n                (xs, m) \\<Rightarrow>\n                  (\\<Union>\n                    (set (map (\\<lambda>(i, y). Pair i ` y)\n                           (List.enumerate (mstate_i st) xs))),\n                   \\<lparr>mstate_i = mstate_i st + length xs, mstate_m = m,\n                      mstate_n = mstate_n st\\<rparr>))) =\n    (Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<le> i \\<and>\n     i < Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>)) \\<and>\n     wf_tuple (MFOTL.nfv \\<phi>) (fv \\<phi>) v \\<and>\n     MFOTL.sat \\<sigma> (map the v) i \\<phi>)", "by (auto simp: in_set_enumerate_eq list_all2_conv_all_nth progress_mono le_imp_diff_is_add\n      elim!: in_qtableE in_qtableI intro!: bexI[of _ \"(i, Vs ! (i - progress \\<sigma> \\<phi> (plen \\<pi>)))\"])"], ["proof (state)\nthis:\n  ((i, v) \\<in> fst (mstep tdb st)) =\n  (Monitor.progress \\<sigma> \\<phi> (plen \\<pi>) \\<le> i \\<and>\n   i < Monitor.progress \\<sigma> \\<phi> (Suc (plen \\<pi>)) \\<and>\n   wf_tuple (MFOTL.nfv \\<phi>) (fv \\<phi>) v \\<and>\n   MFOTL.sat \\<sigma> (map the v) i \\<phi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Monitor function\\<close>"], ["", "definition minit_safe where\n  \"minit_safe \\<phi> = (if mmonitorable_exec \\<phi> then minit \\<phi> else undefined)\""], ["", "lemma minit_safe_minit: \"mmonitorable \\<phi> \\<Longrightarrow> minit_safe \\<phi> = minit \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mmonitorable \\<phi> \\<Longrightarrow> minit_safe \\<phi> = minit \\<phi>", "unfolding minit_safe_def monitorable_formula_code"], ["proof (prove)\ngoal (1 subgoal):\n 1. mmonitorable_exec \\<phi> \\<Longrightarrow>\n    (if mmonitorable_exec \\<phi> then minit \\<phi> else undefined) =\n    minit \\<phi>", "by simp"], ["", "lemma (in monitorable_mfotl) mstep_mverdicts:\n  assumes wf: \"wf_mstate \\<phi> \\<pi> R st\"\n    and le[simp]: \"last_ts \\<pi> \\<le> snd tdb\"\n    and restrict: \"mem_restr R v\"\n  shows \"(i, v) \\<in> fst (mstep tdb st) \\<longleftrightarrow> (i, v) \\<in> M (psnoc \\<pi> tdb) - M \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((i, v) \\<in> fst (mstep tdb st)) =\n    ((i, v) \\<in> M (psnoc \\<pi> tdb) - M \\<pi>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((i, v) \\<in> fst (mstep tdb st)) =\n    ((i, v) \\<in> M (psnoc \\<pi> tdb) - M \\<pi>)", "obtain \\<sigma> where p2: \"prefix_of (psnoc \\<pi> tdb) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        prefix_of (psnoc \\<pi> tdb) \\<sigma> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ex_prefix_of"], ["proof (prove)\nusing this:\n  \\<exists>s. prefix_of ?p s\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        prefix_of (psnoc \\<pi> tdb) \\<sigma> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  prefix_of (psnoc \\<pi> tdb) \\<sigma>\n\ngoal (1 subgoal):\n 1. ((i, v) \\<in> fst (mstep tdb st)) =\n    ((i, v) \\<in> M (psnoc \\<pi> tdb) - M \\<pi>)", "with le"], ["proof (chain)\npicking this:\n  last_ts \\<pi> \\<le> snd tdb\n  prefix_of (psnoc \\<pi> tdb) \\<sigma>", "have p1: \"prefix_of \\<pi> \\<sigma>\""], ["proof (prove)\nusing this:\n  last_ts \\<pi> \\<le> snd tdb\n  prefix_of (psnoc \\<pi> tdb) \\<sigma>\n\ngoal (1 subgoal):\n 1. prefix_of \\<pi> \\<sigma>", "by (blast elim!: prefix_of_psnocE)"], ["proof (state)\nthis:\n  prefix_of \\<pi> \\<sigma>\n\ngoal (1 subgoal):\n 1. ((i, v) \\<in> fst (mstep tdb st)) =\n    ((i, v) \\<in> M (psnoc \\<pi> tdb) - M \\<pi>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((i, v) \\<in> fst (mstep tdb st)) =\n    ((i, v) \\<in> M (psnoc \\<pi> tdb) - M \\<pi>)", "unfolding M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((i, v) \\<in> fst (mstep tdb st)) =\n    ((i, v)\n     \\<in> {(i, v).\n            i < pprogress \\<phi> (psnoc \\<pi> tdb) \\<and>\n            wf_tuple (MFOTL.nfv \\<phi>) (fv \\<phi>) v \\<and>\n            (\\<forall>\\<sigma>.\n                prefix_of (psnoc \\<pi> tdb) \\<sigma> \\<longrightarrow>\n                MFOTL.sat \\<sigma> (map the v) i \\<phi>)} -\n           {(i, v).\n            i < pprogress \\<phi> \\<pi> \\<and>\n            wf_tuple (MFOTL.nfv \\<phi>) (fv \\<phi>) v \\<and>\n            (\\<forall>\\<sigma>.\n                prefix_of \\<pi> \\<sigma> \\<longrightarrow>\n                MFOTL.sat \\<sigma> (map the v) i \\<phi>)})", "by (auto 0 3 simp: p2 progress_prefix_conv[OF _ p1] sat_prefix_conv[OF _ p1] not_less\n        pprogress_eq[OF p1] pprogress_eq[OF p2]\n      dest:  mstep_output_iff[OF wf le p2 restrict, THEN iffD1] spec[of _ \\<sigma>]\n             mstep_output_iff[OF wf le _ restrict, THEN iffD1] progress_sat_cong[OF p1]\n      intro: mstep_output_iff[OF wf le p2 restrict, THEN iffD2] p1)"], ["proof (state)\nthis:\n  ((i, v) \\<in> fst (mstep tdb st)) =\n  ((i, v) \\<in> M (psnoc \\<pi> tdb) - M \\<pi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "primrec msteps0 where\n  \"msteps0 [] st = ({}, st)\"\n| \"msteps0 (tdb # \\<pi>) st =\n    (let (V', st') = mstep tdb st; (V'', st'') = msteps0 \\<pi> st' in (V' \\<union> V'', st''))\""], ["", "primrec msteps0_stateless where\n  \"msteps0_stateless [] st = {}\"\n| \"msteps0_stateless (tdb # \\<pi>) st = (let (V', st') = mstep tdb st in V' \\<union> msteps0_stateless \\<pi> st')\""], ["", "lemma msteps0_msteps0_stateless: \"fst (msteps0 w st) = msteps0_stateless w st\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (msteps0 w st) = msteps0_stateless w st", "by (induct w arbitrary: st) (auto simp: split_beta)"], ["", "lift_definition msteps :: \"'a MFOTL.prefix \\<Rightarrow> 'a mstate \\<Rightarrow> (nat \\<times> 'a option list) set \\<times> 'a mstate\"\n  is msteps0"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition msteps_stateless :: \"'a MFOTL.prefix \\<Rightarrow> 'a mstate \\<Rightarrow> (nat \\<times> 'a option list) set\"\n  is msteps0_stateless"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma msteps_msteps_stateless: \"fst (msteps w st) = msteps_stateless w st\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (msteps w st) = msteps_stateless w st", "by transfer (rule msteps0_msteps0_stateless)"], ["", "lemma msteps0_snoc: \"msteps0 (\\<pi> @ [tdb]) st =\n   (let (V', st') = msteps0 \\<pi> st; (V'', st'') = mstep tdb st' in (V' \\<union> V'', st''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msteps0 (\\<pi> @ [tdb]) st =\n    (let (V', st') = msteps0 \\<pi> st; (V'', st'') = mstep tdb st'\n     in (V' \\<union> V'', st''))", "by (induct \\<pi> arbitrary: st) (auto split: prod.splits)"], ["", "lemma msteps_psnoc: \"last_ts \\<pi> \\<le> snd tdb \\<Longrightarrow> msteps (psnoc \\<pi> tdb) st =\n   (let (V', st') = msteps \\<pi> st; (V'', st'') = mstep tdb st' in (V' \\<union> V'', st''))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last_ts \\<pi> \\<le> snd tdb \\<Longrightarrow>\n    msteps (psnoc \\<pi> tdb) st =\n    (let (V', st') = msteps \\<pi> st; (V'', st'') = mstep tdb st'\n     in (V' \\<union> V'', st''))", "by transfer (auto simp: msteps0_snoc split: list.splits prod.splits if_splits)"], ["", "definition monitor where\n  \"monitor \\<phi> \\<pi> = msteps_stateless \\<pi> (minit_safe \\<phi>)\""], ["", "lemma Suc_length_conv_snoc: \"(Suc n = length xs) = (\\<exists>y ys. xs = ys @ [y] \\<and> length ys = n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc n = length xs) =\n    (\\<exists>y ys. xs = ys @ [y] \\<and> length ys = n)", "by (cases xs rule: rev_cases) auto"], ["", "lemma (in monitorable_mfotl) wf_mstate_msteps: \"wf_mstate \\<phi> \\<pi> R st \\<Longrightarrow> mem_restr R v \\<Longrightarrow> \\<pi> \\<le> \\<pi>' \\<Longrightarrow>\n  X = msteps (pdrop (plen \\<pi>) \\<pi>') st \\<Longrightarrow> wf_mstate \\<phi> \\<pi>' R (snd X) \\<and>\n  ((i, v) \\<in> fst X) = ((i, v) \\<in> M \\<pi>' - M \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_mstate \\<phi> \\<pi> R st; mem_restr R v; \\<pi> \\<le> \\<pi>';\n     X = msteps (pdrop (plen \\<pi>) \\<pi>') st\\<rbrakk>\n    \\<Longrightarrow> wf_mstate \\<phi> \\<pi>' R (snd X) \\<and>\n                      ((i, v) \\<in> fst X) =\n                      ((i, v) \\<in> M \\<pi>' - M \\<pi>)", "proof (induct \"plen \\<pi>' - plen \\<pi>\" arbitrary: X st \\<pi> \\<pi>')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<pi> \\<pi>' X st.\n       \\<lbrakk>0 = plen \\<pi>' - plen \\<pi>; wf_mstate \\<phi> \\<pi> R st;\n        mem_restr R v; \\<pi> \\<le> \\<pi>';\n        X = msteps (pdrop (plen \\<pi>) \\<pi>') st\\<rbrakk>\n       \\<Longrightarrow> wf_mstate \\<phi> \\<pi>' R (snd X) \\<and>\n                         ((i, v) \\<in> fst X) =\n                         ((i, v) \\<in> M \\<pi>' - M \\<pi>)\n 2. \\<And>x \\<pi> \\<pi>' X st.\n       \\<lbrakk>\\<And>\\<pi> \\<pi>' X st.\n                   \\<lbrakk>x = plen \\<pi>' - plen \\<pi>;\n                    wf_mstate \\<phi> \\<pi> R st; mem_restr R v;\n                    \\<pi> \\<le> \\<pi>';\n                    X = msteps (pdrop (plen \\<pi>) \\<pi>') st\\<rbrakk>\n                   \\<Longrightarrow> wf_mstate \\<phi> \\<pi>' R\n(snd X) \\<and>\n                                     ((i, v) \\<in> fst X) =\n                                     ((i, v) \\<in> M \\<pi>' - M \\<pi>);\n        Suc x = plen \\<pi>' - plen \\<pi>; wf_mstate \\<phi> \\<pi> R st;\n        mem_restr R v; \\<pi> \\<le> \\<pi>';\n        X = msteps (pdrop (plen \\<pi>) \\<pi>') st\\<rbrakk>\n       \\<Longrightarrow> wf_mstate \\<phi> \\<pi>' R (snd X) \\<and>\n                         ((i, v) \\<in> fst X) =\n                         ((i, v) \\<in> M \\<pi>' - M \\<pi>)", "case 0"], ["proof (state)\nthis:\n  0 = plen \\<pi>' - plen \\<pi>\n  wf_mstate \\<phi> \\<pi> R st\n  mem_restr R v\n  \\<pi> \\<le> \\<pi>'\n  X = msteps (pdrop (plen \\<pi>) \\<pi>') st\n\ngoal (2 subgoals):\n 1. \\<And>\\<pi> \\<pi>' X st.\n       \\<lbrakk>0 = plen \\<pi>' - plen \\<pi>; wf_mstate \\<phi> \\<pi> R st;\n        mem_restr R v; \\<pi> \\<le> \\<pi>';\n        X = msteps (pdrop (plen \\<pi>) \\<pi>') st\\<rbrakk>\n       \\<Longrightarrow> wf_mstate \\<phi> \\<pi>' R (snd X) \\<and>\n                         ((i, v) \\<in> fst X) =\n                         ((i, v) \\<in> M \\<pi>' - M \\<pi>)\n 2. \\<And>x \\<pi> \\<pi>' X st.\n       \\<lbrakk>\\<And>\\<pi> \\<pi>' X st.\n                   \\<lbrakk>x = plen \\<pi>' - plen \\<pi>;\n                    wf_mstate \\<phi> \\<pi> R st; mem_restr R v;\n                    \\<pi> \\<le> \\<pi>';\n                    X = msteps (pdrop (plen \\<pi>) \\<pi>') st\\<rbrakk>\n                   \\<Longrightarrow> wf_mstate \\<phi> \\<pi>' R\n(snd X) \\<and>\n                                     ((i, v) \\<in> fst X) =\n                                     ((i, v) \\<in> M \\<pi>' - M \\<pi>);\n        Suc x = plen \\<pi>' - plen \\<pi>; wf_mstate \\<phi> \\<pi> R st;\n        mem_restr R v; \\<pi> \\<le> \\<pi>';\n        X = msteps (pdrop (plen \\<pi>) \\<pi>') st\\<rbrakk>\n       \\<Longrightarrow> wf_mstate \\<phi> \\<pi>' R (snd X) \\<and>\n                         ((i, v) \\<in> fst X) =\n                         ((i, v) \\<in> M \\<pi>' - M \\<pi>)", "from 0(1,4,5)"], ["proof (chain)\npicking this:\n  0 = plen \\<pi>' - plen \\<pi>\n  \\<pi> \\<le> \\<pi>'\n  X = msteps (pdrop (plen \\<pi>) \\<pi>') st", "have \"\\<pi> = \\<pi>'\"  \"X = ({}, st)\""], ["proof (prove)\nusing this:\n  0 = plen \\<pi>' - plen \\<pi>\n  \\<pi> \\<le> \\<pi>'\n  X = msteps (pdrop (plen \\<pi>) \\<pi>') st\n\ngoal (1 subgoal):\n 1. \\<pi> = \\<pi>' &&& X = ({}, st)", "by (transfer; auto)+"], ["proof (state)\nthis:\n  \\<pi> = \\<pi>'\n  X = ({}, st)\n\ngoal (2 subgoals):\n 1. \\<And>\\<pi> \\<pi>' X st.\n       \\<lbrakk>0 = plen \\<pi>' - plen \\<pi>; wf_mstate \\<phi> \\<pi> R st;\n        mem_restr R v; \\<pi> \\<le> \\<pi>';\n        X = msteps (pdrop (plen \\<pi>) \\<pi>') st\\<rbrakk>\n       \\<Longrightarrow> wf_mstate \\<phi> \\<pi>' R (snd X) \\<and>\n                         ((i, v) \\<in> fst X) =\n                         ((i, v) \\<in> M \\<pi>' - M \\<pi>)\n 2. \\<And>x \\<pi> \\<pi>' X st.\n       \\<lbrakk>\\<And>\\<pi> \\<pi>' X st.\n                   \\<lbrakk>x = plen \\<pi>' - plen \\<pi>;\n                    wf_mstate \\<phi> \\<pi> R st; mem_restr R v;\n                    \\<pi> \\<le> \\<pi>';\n                    X = msteps (pdrop (plen \\<pi>) \\<pi>') st\\<rbrakk>\n                   \\<Longrightarrow> wf_mstate \\<phi> \\<pi>' R\n(snd X) \\<and>\n                                     ((i, v) \\<in> fst X) =\n                                     ((i, v) \\<in> M \\<pi>' - M \\<pi>);\n        Suc x = plen \\<pi>' - plen \\<pi>; wf_mstate \\<phi> \\<pi> R st;\n        mem_restr R v; \\<pi> \\<le> \\<pi>';\n        X = msteps (pdrop (plen \\<pi>) \\<pi>') st\\<rbrakk>\n       \\<Longrightarrow> wf_mstate \\<phi> \\<pi>' R (snd X) \\<and>\n                         ((i, v) \\<in> fst X) =\n                         ((i, v) \\<in> M \\<pi>' - M \\<pi>)", "with 0(2)"], ["proof (chain)\npicking this:\n  wf_mstate \\<phi> \\<pi> R st\n  \\<pi> = \\<pi>'\n  X = ({}, st)", "show ?case"], ["proof (prove)\nusing this:\n  wf_mstate \\<phi> \\<pi> R st\n  \\<pi> = \\<pi>'\n  X = ({}, st)\n\ngoal (1 subgoal):\n 1. wf_mstate \\<phi> \\<pi>' R (snd X) \\<and>\n    ((i, v) \\<in> fst X) = ((i, v) \\<in> M \\<pi>' - M \\<pi>)", "by simp"], ["proof (state)\nthis:\n  wf_mstate \\<phi> \\<pi>' R (snd X) \\<and>\n  ((i, v) \\<in> fst X) = ((i, v) \\<in> M \\<pi>' - M \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<And>x \\<pi> \\<pi>' X st.\n       \\<lbrakk>\\<And>\\<pi> \\<pi>' X st.\n                   \\<lbrakk>x = plen \\<pi>' - plen \\<pi>;\n                    wf_mstate \\<phi> \\<pi> R st; mem_restr R v;\n                    \\<pi> \\<le> \\<pi>';\n                    X = msteps (pdrop (plen \\<pi>) \\<pi>') st\\<rbrakk>\n                   \\<Longrightarrow> wf_mstate \\<phi> \\<pi>' R\n(snd X) \\<and>\n                                     ((i, v) \\<in> fst X) =\n                                     ((i, v) \\<in> M \\<pi>' - M \\<pi>);\n        Suc x = plen \\<pi>' - plen \\<pi>; wf_mstate \\<phi> \\<pi> R st;\n        mem_restr R v; \\<pi> \\<le> \\<pi>';\n        X = msteps (pdrop (plen \\<pi>) \\<pi>') st\\<rbrakk>\n       \\<Longrightarrow> wf_mstate \\<phi> \\<pi>' R (snd X) \\<and>\n                         ((i, v) \\<in> fst X) =\n                         ((i, v) \\<in> M \\<pi>' - M \\<pi>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x \\<pi> \\<pi>' X st.\n       \\<lbrakk>\\<And>\\<pi> \\<pi>' X st.\n                   \\<lbrakk>x = plen \\<pi>' - plen \\<pi>;\n                    wf_mstate \\<phi> \\<pi> R st; mem_restr R v;\n                    \\<pi> \\<le> \\<pi>';\n                    X = msteps (pdrop (plen \\<pi>) \\<pi>') st\\<rbrakk>\n                   \\<Longrightarrow> wf_mstate \\<phi> \\<pi>' R\n(snd X) \\<and>\n                                     ((i, v) \\<in> fst X) =\n                                     ((i, v) \\<in> M \\<pi>' - M \\<pi>);\n        Suc x = plen \\<pi>' - plen \\<pi>; wf_mstate \\<phi> \\<pi> R st;\n        mem_restr R v; \\<pi> \\<le> \\<pi>';\n        X = msteps (pdrop (plen \\<pi>) \\<pi>') st\\<rbrakk>\n       \\<Longrightarrow> wf_mstate \\<phi> \\<pi>' R (snd X) \\<and>\n                         ((i, v) \\<in> fst X) =\n                         ((i, v) \\<in> M \\<pi>' - M \\<pi>)", "case (Suc x)"], ["proof (state)\nthis:\n  \\<lbrakk>x = plen ?\\<pi>' - plen ?\\<pi>; wf_mstate \\<phi> ?\\<pi> R ?st;\n   mem_restr R v; ?\\<pi> \\<le> ?\\<pi>';\n   ?X = msteps (pdrop (plen ?\\<pi>) ?\\<pi>') ?st\\<rbrakk>\n  \\<Longrightarrow> wf_mstate \\<phi> ?\\<pi>' R (snd ?X) \\<and>\n                    ((i, v) \\<in> fst ?X) =\n                    ((i, v) \\<in> M ?\\<pi>' - M ?\\<pi>)\n  Suc x = plen \\<pi>' - plen \\<pi>\n  wf_mstate \\<phi> \\<pi> R st\n  mem_restr R v\n  \\<pi> \\<le> \\<pi>'\n  X = msteps (pdrop (plen \\<pi>) \\<pi>') st\n\ngoal (1 subgoal):\n 1. \\<And>x \\<pi> \\<pi>' X st.\n       \\<lbrakk>\\<And>\\<pi> \\<pi>' X st.\n                   \\<lbrakk>x = plen \\<pi>' - plen \\<pi>;\n                    wf_mstate \\<phi> \\<pi> R st; mem_restr R v;\n                    \\<pi> \\<le> \\<pi>';\n                    X = msteps (pdrop (plen \\<pi>) \\<pi>') st\\<rbrakk>\n                   \\<Longrightarrow> wf_mstate \\<phi> \\<pi>' R\n(snd X) \\<and>\n                                     ((i, v) \\<in> fst X) =\n                                     ((i, v) \\<in> M \\<pi>' - M \\<pi>);\n        Suc x = plen \\<pi>' - plen \\<pi>; wf_mstate \\<phi> \\<pi> R st;\n        mem_restr R v; \\<pi> \\<le> \\<pi>';\n        X = msteps (pdrop (plen \\<pi>) \\<pi>') st\\<rbrakk>\n       \\<Longrightarrow> wf_mstate \\<phi> \\<pi>' R (snd X) \\<and>\n                         ((i, v) \\<in> fst X) =\n                         ((i, v) \\<in> M \\<pi>' - M \\<pi>)", "from Suc(2,5)"], ["proof (chain)\npicking this:\n  Suc x = plen \\<pi>' - plen \\<pi>\n  \\<pi> \\<le> \\<pi>'", "obtain \\<pi>'' tdb where \"x = plen \\<pi>'' - plen \\<pi>\"  \"\\<pi> \\<le> \\<pi>''\"\n    \"\\<pi>' = psnoc \\<pi>'' tdb\" \"pdrop (plen \\<pi>) (psnoc \\<pi>'' tdb) = psnoc (pdrop (plen \\<pi>) \\<pi>'') tdb\"\n    \"last_ts (pdrop (plen \\<pi>) \\<pi>'') \\<le> snd tdb\" \"last_ts \\<pi>'' \\<le> snd tdb\"\n    \"\\<pi>'' \\<le> psnoc \\<pi>'' tdb\""], ["proof (prove)\nusing this:\n  Suc x = plen \\<pi>' - plen \\<pi>\n  \\<pi> \\<le> \\<pi>'\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>'''' tdb.\n        \\<lbrakk>x = plen \\<pi>'''' - plen \\<pi>; \\<pi> \\<le> \\<pi>'''';\n         \\<pi>' = psnoc \\<pi>'''' tdb;\n         pdrop (plen \\<pi>) (psnoc \\<pi>'''' tdb) =\n         psnoc (pdrop (plen \\<pi>) \\<pi>'''') tdb;\n         last_ts (pdrop (plen \\<pi>) \\<pi>'''') \\<le> snd tdb;\n         last_ts \\<pi>'''' \\<le> snd tdb;\n         \\<pi>'''' \\<le> psnoc \\<pi>'''' tdb\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (atomize_elim, transfer, elim exE, goal_cases prefix)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa \\<pi>' \\<pi> r ra.\n       \\<lbrakk>sorted (map snd \\<pi>'); sorted (map snd \\<pi>);\n        Suc xa = length \\<pi>' - length \\<pi>;\n        Suc xa = length \\<pi>' - length \\<pi>;\n        Suc x = plen \\<pi>' - plen \\<pi>; \\<pi> \\<le> \\<pi>';\n        \\<pi>' = \\<pi> @ r; \\<pi>' = \\<pi> @ ra\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<pi>''\\<in>{p. sorted (map snd p)}.\n                            \\<exists>tdb.\n                               xa = length \\<pi>'' - length \\<pi> \\<and>\n                               (\\<exists>r. \\<pi>'' = \\<pi> @ r) \\<and>\n                               \\<pi>' =\n                               (if (case \\<pi>'' of [] \\<Rightarrow> 0\n                                    | a # list \\<Rightarrow>\n  snd (last \\<pi>''))\n                                   \\<le> snd tdb\n                                then \\<pi>'' @ [tdb] else []) \\<and>\n                               drop (length \\<pi>)\n                                (if (case \\<pi>'' of [] \\<Rightarrow> 0\n                                     | a # list \\<Rightarrow>\n   snd (last \\<pi>''))\n                                    \\<le> snd tdb\n                                 then \\<pi>'' @ [tdb] else []) =\n                               (if (case drop (length \\<pi>) \\<pi>'' of\n                                    [] \\<Rightarrow> 0\n                                    | a # list \\<Rightarrow>\n  snd (last (drop (length \\<pi>) \\<pi>'')))\n                                   \\<le> snd tdb\n                                then drop (length \\<pi>) \\<pi>'' @ [tdb]\n                                else []) \\<and>\n                               (case drop (length \\<pi>) \\<pi>'' of\n                                [] \\<Rightarrow> 0\n                                | a # list \\<Rightarrow>\n                                    snd (last\n    (drop (length \\<pi>) \\<pi>'')))\n                               \\<le> snd tdb \\<and>\n                               (case \\<pi>'' of [] \\<Rightarrow> 0\n                                | a # list \\<Rightarrow> snd (last \\<pi>''))\n                               \\<le> snd tdb \\<and>\n                               (\\<exists>r.\n                                   (if (case \\<pi>'' of [] \\<Rightarrow> 0\n  | a # list \\<Rightarrow> snd (last \\<pi>''))\n \\<le> snd tdb\n                                    then \\<pi>'' @ [tdb] else []) =\n                                   \\<pi>'' @ r)", "case (prefix _ _ \\<pi>' _ \\<pi>_tdb)"], ["proof (state)\nthis:\n  sorted (map snd \\<pi>'_)\n  sorted (map snd \\<pi>')\n  Suc x_ = length \\<pi>'_ - length \\<pi>'\n  Suc x_ = length \\<pi>'_ - length \\<pi>'\n  Suc x = plen \\<pi>'''__ - plen \\<pi>\n  \\<pi> \\<le> \\<pi>'''__\n  \\<pi>'_ = \\<pi>' @ r_\n  \\<pi>'_ = \\<pi>' @ \\<pi>_tdb\n\ngoal (1 subgoal):\n 1. \\<And>xa \\<pi>' \\<pi> r ra.\n       \\<lbrakk>sorted (map snd \\<pi>'); sorted (map snd \\<pi>);\n        Suc xa = length \\<pi>' - length \\<pi>;\n        Suc xa = length \\<pi>' - length \\<pi>;\n        Suc x = plen \\<pi>'''__ - plen \\<pi>; \\<pi> \\<le> \\<pi>'''__;\n        \\<pi>' = \\<pi> @ r; \\<pi>' = \\<pi> @ ra\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<pi>''\\<in>{p. sorted (map snd p)}.\n                            \\<exists>tdb.\n                               xa = length \\<pi>'' - length \\<pi> \\<and>\n                               (\\<exists>r. \\<pi>'' = \\<pi> @ r) \\<and>\n                               \\<pi>' =\n                               (if (case \\<pi>'' of [] \\<Rightarrow> 0\n                                    | a # list \\<Rightarrow>\n  snd (last \\<pi>''))\n                                   \\<le> snd tdb\n                                then \\<pi>'' @ [tdb] else []) \\<and>\n                               drop (length \\<pi>)\n                                (if (case \\<pi>'' of [] \\<Rightarrow> 0\n                                     | a # list \\<Rightarrow>\n   snd (last \\<pi>''))\n                                    \\<le> snd tdb\n                                 then \\<pi>'' @ [tdb] else []) =\n                               (if (case drop (length \\<pi>) \\<pi>'' of\n                                    [] \\<Rightarrow> 0\n                                    | a # list \\<Rightarrow>\n  snd (last (drop (length \\<pi>) \\<pi>'')))\n                                   \\<le> snd tdb\n                                then drop (length \\<pi>) \\<pi>'' @ [tdb]\n                                else []) \\<and>\n                               (case drop (length \\<pi>) \\<pi>'' of\n                                [] \\<Rightarrow> 0\n                                | a # list \\<Rightarrow>\n                                    snd (last\n    (drop (length \\<pi>) \\<pi>'')))\n                               \\<le> snd tdb \\<and>\n                               (case \\<pi>'' of [] \\<Rightarrow> 0\n                                | a # list \\<Rightarrow> snd (last \\<pi>''))\n                               \\<le> snd tdb \\<and>\n                               (\\<exists>r.\n                                   (if (case \\<pi>'' of [] \\<Rightarrow> 0\n  | a # list \\<Rightarrow> snd (last \\<pi>''))\n \\<le> snd tdb\n                                    then \\<pi>'' @ [tdb] else []) =\n                                   \\<pi>'' @ r)", "then"], ["proof (chain)\npicking this:\n  sorted (map snd \\<pi>'_)\n  sorted (map snd \\<pi>')\n  Suc x_ = length \\<pi>'_ - length \\<pi>'\n  Suc x_ = length \\<pi>'_ - length \\<pi>'\n  Suc x = plen \\<pi>'''__ - plen \\<pi>\n  \\<pi> \\<le> \\<pi>'''__\n  \\<pi>'_ = \\<pi>' @ r_\n  \\<pi>'_ = \\<pi>' @ \\<pi>_tdb", "show ?case"], ["proof (prove)\nusing this:\n  sorted (map snd \\<pi>'_)\n  sorted (map snd \\<pi>')\n  Suc x_ = length \\<pi>'_ - length \\<pi>'\n  Suc x_ = length \\<pi>'_ - length \\<pi>'\n  Suc x = plen \\<pi>'''__ - plen \\<pi>\n  \\<pi> \\<le> \\<pi>'''__\n  \\<pi>'_ = \\<pi>' @ r_\n  \\<pi>'_ = \\<pi>' @ \\<pi>_tdb\n\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>''\\<in>{p. sorted (map snd p)}.\n       \\<exists>tdb.\n          x_ = length \\<pi>'' - length \\<pi>' \\<and>\n          (\\<exists>r. \\<pi>'' = \\<pi>' @ r) \\<and>\n          \\<pi>'_ =\n          (if (case \\<pi>'' of [] \\<Rightarrow> 0\n               | a # list \\<Rightarrow> snd (last \\<pi>''))\n              \\<le> snd tdb\n           then \\<pi>'' @ [tdb] else []) \\<and>\n          drop (length \\<pi>')\n           (if (case \\<pi>'' of [] \\<Rightarrow> 0\n                | a # list \\<Rightarrow> snd (last \\<pi>''))\n               \\<le> snd tdb\n            then \\<pi>'' @ [tdb] else []) =\n          (if (case drop (length \\<pi>') \\<pi>'' of [] \\<Rightarrow> 0\n               | a # list \\<Rightarrow>\n                   snd (last (drop (length \\<pi>') \\<pi>'')))\n              \\<le> snd tdb\n           then drop (length \\<pi>') \\<pi>'' @ [tdb] else []) \\<and>\n          (case drop (length \\<pi>') \\<pi>'' of [] \\<Rightarrow> 0\n           | a # list \\<Rightarrow>\n               snd (last (drop (length \\<pi>') \\<pi>'')))\n          \\<le> snd tdb \\<and>\n          (case \\<pi>'' of [] \\<Rightarrow> 0\n           | a # list \\<Rightarrow> snd (last \\<pi>''))\n          \\<le> snd tdb \\<and>\n          (\\<exists>r.\n              (if (case \\<pi>'' of [] \\<Rightarrow> 0\n                   | a # list \\<Rightarrow> snd (last \\<pi>''))\n                  \\<le> snd tdb\n               then \\<pi>'' @ [tdb] else []) =\n              \\<pi>'' @ r)", "proof (cases \\<pi>_tdb rule: rev_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted (map snd \\<pi>'_); sorted (map snd \\<pi>');\n     Suc x_ = length \\<pi>'_ - length \\<pi>';\n     Suc x_ = length \\<pi>'_ - length \\<pi>';\n     Suc x = plen \\<pi>'''__ - plen \\<pi>; \\<pi> \\<le> \\<pi>'''__;\n     \\<pi>'_ = \\<pi>' @ r_; \\<pi>'_ = \\<pi>' @ \\<pi>_tdb;\n     \\<pi>_tdb = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<pi>''\\<in>{p. sorted (map snd p)}.\n                         \\<exists>tdb.\n                            x_ = length \\<pi>'' - length \\<pi>' \\<and>\n                            (\\<exists>r. \\<pi>'' = \\<pi>' @ r) \\<and>\n                            \\<pi>'_ =\n                            (if (case \\<pi>'' of [] \\<Rightarrow> 0\n                                 | a # list \\<Rightarrow>\n                                     snd (last \\<pi>''))\n                                \\<le> snd tdb\n                             then \\<pi>'' @ [tdb] else []) \\<and>\n                            drop (length \\<pi>')\n                             (if (case \\<pi>'' of [] \\<Rightarrow> 0\n                                  | a # list \\<Rightarrow>\nsnd (last \\<pi>''))\n                                 \\<le> snd tdb\n                              then \\<pi>'' @ [tdb] else []) =\n                            (if (case drop (length \\<pi>') \\<pi>'' of\n                                 [] \\<Rightarrow> 0\n                                 | a # list \\<Rightarrow>\n                                     snd\n(last (drop (length \\<pi>') \\<pi>'')))\n                                \\<le> snd tdb\n                             then drop (length \\<pi>') \\<pi>'' @ [tdb]\n                             else []) \\<and>\n                            (case drop (length \\<pi>') \\<pi>'' of\n                             [] \\<Rightarrow> 0\n                             | a # list \\<Rightarrow>\n                                 snd (last (drop (length \\<pi>') \\<pi>'')))\n                            \\<le> snd tdb \\<and>\n                            (case \\<pi>'' of [] \\<Rightarrow> 0\n                             | a # list \\<Rightarrow> snd (last \\<pi>''))\n                            \\<le> snd tdb \\<and>\n                            (\\<exists>r.\n                                (if (case \\<pi>'' of [] \\<Rightarrow> 0\n                                     | a # list \\<Rightarrow>\n   snd (last \\<pi>''))\n                                    \\<le> snd tdb\n                                 then \\<pi>'' @ [tdb] else []) =\n                                \\<pi>'' @ r)\n 2. \\<And>ys y.\n       \\<lbrakk>sorted (map snd \\<pi>'_); sorted (map snd \\<pi>');\n        Suc x_ = length \\<pi>'_ - length \\<pi>';\n        Suc x_ = length \\<pi>'_ - length \\<pi>';\n        Suc x = plen \\<pi>'''__ - plen \\<pi>; \\<pi> \\<le> \\<pi>'''__;\n        \\<pi>'_ = \\<pi>' @ r_; \\<pi>'_ = \\<pi>' @ \\<pi>_tdb;\n        \\<pi>_tdb = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<pi>''\\<in>{p. sorted (map snd p)}.\n                            \\<exists>tdb.\n                               x_ = length \\<pi>'' - length \\<pi>' \\<and>\n                               (\\<exists>r. \\<pi>'' = \\<pi>' @ r) \\<and>\n                               \\<pi>'_ =\n                               (if (case \\<pi>'' of [] \\<Rightarrow> 0\n                                    | a # list \\<Rightarrow>\n  snd (last \\<pi>''))\n                                   \\<le> snd tdb\n                                then \\<pi>'' @ [tdb] else []) \\<and>\n                               drop (length \\<pi>')\n                                (if (case \\<pi>'' of [] \\<Rightarrow> 0\n                                     | a # list \\<Rightarrow>\n   snd (last \\<pi>''))\n                                    \\<le> snd tdb\n                                 then \\<pi>'' @ [tdb] else []) =\n                               (if (case drop (length \\<pi>') \\<pi>'' of\n                                    [] \\<Rightarrow> 0\n                                    | a # list \\<Rightarrow>\n  snd (last (drop (length \\<pi>') \\<pi>'')))\n                                   \\<le> snd tdb\n                                then drop (length \\<pi>') \\<pi>'' @ [tdb]\n                                else []) \\<and>\n                               (case drop (length \\<pi>') \\<pi>'' of\n                                [] \\<Rightarrow> 0\n                                | a # list \\<Rightarrow>\n                                    snd (last\n    (drop (length \\<pi>') \\<pi>'')))\n                               \\<le> snd tdb \\<and>\n                               (case \\<pi>'' of [] \\<Rightarrow> 0\n                                | a # list \\<Rightarrow> snd (last \\<pi>''))\n                               \\<le> snd tdb \\<and>\n                               (\\<exists>r.\n                                   (if (case \\<pi>'' of [] \\<Rightarrow> 0\n  | a # list \\<Rightarrow> snd (last \\<pi>''))\n \\<le> snd tdb\n                                    then \\<pi>'' @ [tdb] else []) =\n                                   \\<pi>'' @ r)", "case (snoc \\<pi> tdb)"], ["proof (state)\nthis:\n  \\<pi>_tdb = \\<pi> @ [tdb]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted (map snd \\<pi>'_); sorted (map snd \\<pi>');\n     Suc x_ = length \\<pi>'_ - length \\<pi>';\n     Suc x_ = length \\<pi>'_ - length \\<pi>';\n     Suc x = plen \\<pi>'''__ - plen \\<pi>''__; \\<pi>''__ \\<le> \\<pi>'''__;\n     \\<pi>'_ = \\<pi>' @ r_; \\<pi>'_ = \\<pi>' @ \\<pi>_tdb;\n     \\<pi>_tdb = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<pi>''\\<in>{p. sorted (map snd p)}.\n                         \\<exists>tdb.\n                            x_ = length \\<pi>'' - length \\<pi>' \\<and>\n                            (\\<exists>r. \\<pi>'' = \\<pi>' @ r) \\<and>\n                            \\<pi>'_ =\n                            (if (case \\<pi>'' of [] \\<Rightarrow> 0\n                                 | a # list \\<Rightarrow>\n                                     snd (last \\<pi>''))\n                                \\<le> snd tdb\n                             then \\<pi>'' @ [tdb] else []) \\<and>\n                            drop (length \\<pi>')\n                             (if (case \\<pi>'' of [] \\<Rightarrow> 0\n                                  | a # list \\<Rightarrow>\nsnd (last \\<pi>''))\n                                 \\<le> snd tdb\n                              then \\<pi>'' @ [tdb] else []) =\n                            (if (case drop (length \\<pi>') \\<pi>'' of\n                                 [] \\<Rightarrow> 0\n                                 | a # list \\<Rightarrow>\n                                     snd\n(last (drop (length \\<pi>') \\<pi>'')))\n                                \\<le> snd tdb\n                             then drop (length \\<pi>') \\<pi>'' @ [tdb]\n                             else []) \\<and>\n                            (case drop (length \\<pi>') \\<pi>'' of\n                             [] \\<Rightarrow> 0\n                             | a # list \\<Rightarrow>\n                                 snd (last (drop (length \\<pi>') \\<pi>'')))\n                            \\<le> snd tdb \\<and>\n                            (case \\<pi>'' of [] \\<Rightarrow> 0\n                             | a # list \\<Rightarrow> snd (last \\<pi>''))\n                            \\<le> snd tdb \\<and>\n                            (\\<exists>r.\n                                (if (case \\<pi>'' of [] \\<Rightarrow> 0\n                                     | a # list \\<Rightarrow>\n   snd (last \\<pi>''))\n                                    \\<le> snd tdb\n                                 then \\<pi>'' @ [tdb] else []) =\n                                \\<pi>'' @ r)\n 2. \\<And>ys y.\n       \\<lbrakk>sorted (map snd \\<pi>'_); sorted (map snd \\<pi>');\n        Suc x_ = length \\<pi>'_ - length \\<pi>';\n        Suc x_ = length \\<pi>'_ - length \\<pi>';\n        Suc x = plen \\<pi>'''__ - plen \\<pi>''__;\n        \\<pi>''__ \\<le> \\<pi>'''__; \\<pi>'_ = \\<pi>' @ r_;\n        \\<pi>'_ = \\<pi>' @ \\<pi>_tdb; \\<pi>_tdb = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<pi>''\\<in>{p. sorted (map snd p)}.\n                            \\<exists>tdb.\n                               x_ = length \\<pi>'' - length \\<pi>' \\<and>\n                               (\\<exists>r. \\<pi>'' = \\<pi>' @ r) \\<and>\n                               \\<pi>'_ =\n                               (if (case \\<pi>'' of [] \\<Rightarrow> 0\n                                    | a # list \\<Rightarrow>\n  snd (last \\<pi>''))\n                                   \\<le> snd tdb\n                                then \\<pi>'' @ [tdb] else []) \\<and>\n                               drop (length \\<pi>')\n                                (if (case \\<pi>'' of [] \\<Rightarrow> 0\n                                     | a # list \\<Rightarrow>\n   snd (last \\<pi>''))\n                                    \\<le> snd tdb\n                                 then \\<pi>'' @ [tdb] else []) =\n                               (if (case drop (length \\<pi>') \\<pi>'' of\n                                    [] \\<Rightarrow> 0\n                                    | a # list \\<Rightarrow>\n  snd (last (drop (length \\<pi>') \\<pi>'')))\n                                   \\<le> snd tdb\n                                then drop (length \\<pi>') \\<pi>'' @ [tdb]\n                                else []) \\<and>\n                               (case drop (length \\<pi>') \\<pi>'' of\n                                [] \\<Rightarrow> 0\n                                | a # list \\<Rightarrow>\n                                    snd (last\n    (drop (length \\<pi>') \\<pi>'')))\n                               \\<le> snd tdb \\<and>\n                               (case \\<pi>'' of [] \\<Rightarrow> 0\n                                | a # list \\<Rightarrow> snd (last \\<pi>''))\n                               \\<le> snd tdb \\<and>\n                               (\\<exists>r.\n                                   (if (case \\<pi>'' of [] \\<Rightarrow> 0\n  | a # list \\<Rightarrow> snd (last \\<pi>''))\n \\<le> snd tdb\n                                    then \\<pi>'' @ [tdb] else []) =\n                                   \\<pi>'' @ r)", "with prefix"], ["proof (chain)\npicking this:\n  sorted (map snd \\<pi>'_)\n  sorted (map snd \\<pi>')\n  Suc x_ = length \\<pi>'_ - length \\<pi>'\n  Suc x_ = length \\<pi>'_ - length \\<pi>'\n  Suc x = plen \\<pi>'''__ - plen \\<pi>''__\n  \\<pi>''__ \\<le> \\<pi>'''__\n  \\<pi>'_ = \\<pi>' @ r_\n  \\<pi>'_ = \\<pi>' @ \\<pi>_tdb\n  \\<pi>_tdb = \\<pi> @ [tdb]", "show ?thesis"], ["proof (prove)\nusing this:\n  sorted (map snd \\<pi>'_)\n  sorted (map snd \\<pi>')\n  Suc x_ = length \\<pi>'_ - length \\<pi>'\n  Suc x_ = length \\<pi>'_ - length \\<pi>'\n  Suc x = plen \\<pi>'''__ - plen \\<pi>''__\n  \\<pi>''__ \\<le> \\<pi>'''__\n  \\<pi>'_ = \\<pi>' @ r_\n  \\<pi>'_ = \\<pi>' @ \\<pi>_tdb\n  \\<pi>_tdb = \\<pi> @ [tdb]\n\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>''\\<in>{p. sorted (map snd p)}.\n       \\<exists>tdb.\n          x_ = length \\<pi>'' - length \\<pi>' \\<and>\n          (\\<exists>r. \\<pi>'' = \\<pi>' @ r) \\<and>\n          \\<pi>'_ =\n          (if (case \\<pi>'' of [] \\<Rightarrow> 0\n               | a # list \\<Rightarrow> snd (last \\<pi>''))\n              \\<le> snd tdb\n           then \\<pi>'' @ [tdb] else []) \\<and>\n          drop (length \\<pi>')\n           (if (case \\<pi>'' of [] \\<Rightarrow> 0\n                | a # list \\<Rightarrow> snd (last \\<pi>''))\n               \\<le> snd tdb\n            then \\<pi>'' @ [tdb] else []) =\n          (if (case drop (length \\<pi>') \\<pi>'' of [] \\<Rightarrow> 0\n               | a # list \\<Rightarrow>\n                   snd (last (drop (length \\<pi>') \\<pi>'')))\n              \\<le> snd tdb\n           then drop (length \\<pi>') \\<pi>'' @ [tdb] else []) \\<and>\n          (case drop (length \\<pi>') \\<pi>'' of [] \\<Rightarrow> 0\n           | a # list \\<Rightarrow>\n               snd (last (drop (length \\<pi>') \\<pi>'')))\n          \\<le> snd tdb \\<and>\n          (case \\<pi>'' of [] \\<Rightarrow> 0\n           | a # list \\<Rightarrow> snd (last \\<pi>''))\n          \\<le> snd tdb \\<and>\n          (\\<exists>r.\n              (if (case \\<pi>'' of [] \\<Rightarrow> 0\n                   | a # list \\<Rightarrow> snd (last \\<pi>''))\n                  \\<le> snd tdb\n               then \\<pi>'' @ [tdb] else []) =\n              \\<pi>'' @ r)", "by (intro bexI[of _ \"\\<pi>' @ \\<pi>\"] exI[of _ tdb])\n          (force simp: sorted_append append_eq_Cons_conv split: list.splits if_splits)+"], ["proof (state)\nthis:\n  \\<exists>\\<pi>''\\<in>{p. sorted (map snd p)}.\n     \\<exists>tdb.\n        x_ = length \\<pi>'' - length \\<pi>' \\<and>\n        (\\<exists>r. \\<pi>'' = \\<pi>' @ r) \\<and>\n        \\<pi>'_ =\n        (if (case \\<pi>'' of [] \\<Rightarrow> 0\n             | a # list \\<Rightarrow> snd (last \\<pi>''))\n            \\<le> snd tdb\n         then \\<pi>'' @ [tdb] else []) \\<and>\n        drop (length \\<pi>')\n         (if (case \\<pi>'' of [] \\<Rightarrow> 0\n              | a # list \\<Rightarrow> snd (last \\<pi>''))\n             \\<le> snd tdb\n          then \\<pi>'' @ [tdb] else []) =\n        (if (case drop (length \\<pi>') \\<pi>'' of [] \\<Rightarrow> 0\n             | a # list \\<Rightarrow>\n                 snd (last (drop (length \\<pi>') \\<pi>'')))\n            \\<le> snd tdb\n         then drop (length \\<pi>') \\<pi>'' @ [tdb] else []) \\<and>\n        (case drop (length \\<pi>') \\<pi>'' of [] \\<Rightarrow> 0\n         | a # list \\<Rightarrow> snd (last (drop (length \\<pi>') \\<pi>'')))\n        \\<le> snd tdb \\<and>\n        (case \\<pi>'' of [] \\<Rightarrow> 0\n         | a # list \\<Rightarrow> snd (last \\<pi>''))\n        \\<le> snd tdb \\<and>\n        (\\<exists>r.\n            (if (case \\<pi>'' of [] \\<Rightarrow> 0\n                 | a # list \\<Rightarrow> snd (last \\<pi>''))\n                \\<le> snd tdb\n             then \\<pi>'' @ [tdb] else []) =\n            \\<pi>'' @ r)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted (map snd \\<pi>'_); sorted (map snd \\<pi>');\n     Suc x_ = length \\<pi>'_ - length \\<pi>';\n     Suc x_ = length \\<pi>'_ - length \\<pi>';\n     Suc x = plen \\<pi>'''__ - plen \\<pi>''__; \\<pi>''__ \\<le> \\<pi>'''__;\n     \\<pi>'_ = \\<pi>' @ r_; \\<pi>'_ = \\<pi>' @ \\<pi>_tdb;\n     \\<pi>_tdb = []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<pi>''\\<in>{p. sorted (map snd p)}.\n                         \\<exists>tdb.\n                            x_ = length \\<pi>'' - length \\<pi>' \\<and>\n                            (\\<exists>r. \\<pi>'' = \\<pi>' @ r) \\<and>\n                            \\<pi>'_ =\n                            (if (case \\<pi>'' of [] \\<Rightarrow> 0\n                                 | a # list \\<Rightarrow>\n                                     snd (last \\<pi>''))\n                                \\<le> snd tdb\n                             then \\<pi>'' @ [tdb] else []) \\<and>\n                            drop (length \\<pi>')\n                             (if (case \\<pi>'' of [] \\<Rightarrow> 0\n                                  | a # list \\<Rightarrow>\nsnd (last \\<pi>''))\n                                 \\<le> snd tdb\n                              then \\<pi>'' @ [tdb] else []) =\n                            (if (case drop (length \\<pi>') \\<pi>'' of\n                                 [] \\<Rightarrow> 0\n                                 | a # list \\<Rightarrow>\n                                     snd\n(last (drop (length \\<pi>') \\<pi>'')))\n                                \\<le> snd tdb\n                             then drop (length \\<pi>') \\<pi>'' @ [tdb]\n                             else []) \\<and>\n                            (case drop (length \\<pi>') \\<pi>'' of\n                             [] \\<Rightarrow> 0\n                             | a # list \\<Rightarrow>\n                                 snd (last (drop (length \\<pi>') \\<pi>'')))\n                            \\<le> snd tdb \\<and>\n                            (case \\<pi>'' of [] \\<Rightarrow> 0\n                             | a # list \\<Rightarrow> snd (last \\<pi>''))\n                            \\<le> snd tdb \\<and>\n                            (\\<exists>r.\n                                (if (case \\<pi>'' of [] \\<Rightarrow> 0\n                                     | a # list \\<Rightarrow>\n   snd (last \\<pi>''))\n                                    \\<le> snd tdb\n                                 then \\<pi>'' @ [tdb] else []) =\n                                \\<pi>'' @ r)", "qed simp"], ["proof (state)\nthis:\n  \\<exists>\\<pi>''\\<in>{p. sorted (map snd p)}.\n     \\<exists>tdb.\n        x_ = length \\<pi>'' - length \\<pi>' \\<and>\n        (\\<exists>r. \\<pi>'' = \\<pi>' @ r) \\<and>\n        \\<pi>'_ =\n        (if (case \\<pi>'' of [] \\<Rightarrow> 0\n             | a # list \\<Rightarrow> snd (last \\<pi>''))\n            \\<le> snd tdb\n         then \\<pi>'' @ [tdb] else []) \\<and>\n        drop (length \\<pi>')\n         (if (case \\<pi>'' of [] \\<Rightarrow> 0\n              | a # list \\<Rightarrow> snd (last \\<pi>''))\n             \\<le> snd tdb\n          then \\<pi>'' @ [tdb] else []) =\n        (if (case drop (length \\<pi>') \\<pi>'' of [] \\<Rightarrow> 0\n             | a # list \\<Rightarrow>\n                 snd (last (drop (length \\<pi>') \\<pi>'')))\n            \\<le> snd tdb\n         then drop (length \\<pi>') \\<pi>'' @ [tdb] else []) \\<and>\n        (case drop (length \\<pi>') \\<pi>'' of [] \\<Rightarrow> 0\n         | a # list \\<Rightarrow> snd (last (drop (length \\<pi>') \\<pi>'')))\n        \\<le> snd tdb \\<and>\n        (case \\<pi>'' of [] \\<Rightarrow> 0\n         | a # list \\<Rightarrow> snd (last \\<pi>''))\n        \\<le> snd tdb \\<and>\n        (\\<exists>r.\n            (if (case \\<pi>'' of [] \\<Rightarrow> 0\n                 | a # list \\<Rightarrow> snd (last \\<pi>''))\n                \\<le> snd tdb\n             then \\<pi>'' @ [tdb] else []) =\n            \\<pi>'' @ r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = plen \\<pi>'' - plen \\<pi>\n  \\<pi> \\<le> \\<pi>''\n  \\<pi>' = psnoc \\<pi>'' tdb\n  pdrop (plen \\<pi>) (psnoc \\<pi>'' tdb) =\n  psnoc (pdrop (plen \\<pi>) \\<pi>'') tdb\n  last_ts (pdrop (plen \\<pi>) \\<pi>'') \\<le> snd tdb\n  last_ts \\<pi>'' \\<le> snd tdb\n  \\<pi>'' \\<le> psnoc \\<pi>'' tdb\n\ngoal (1 subgoal):\n 1. \\<And>x \\<pi> \\<pi>' X st.\n       \\<lbrakk>\\<And>\\<pi> \\<pi>' X st.\n                   \\<lbrakk>x = plen \\<pi>' - plen \\<pi>;\n                    wf_mstate \\<phi> \\<pi> R st; mem_restr R v;\n                    \\<pi> \\<le> \\<pi>';\n                    X = msteps (pdrop (plen \\<pi>) \\<pi>') st\\<rbrakk>\n                   \\<Longrightarrow> wf_mstate \\<phi> \\<pi>' R\n(snd X) \\<and>\n                                     ((i, v) \\<in> fst X) =\n                                     ((i, v) \\<in> M \\<pi>' - M \\<pi>);\n        Suc x = plen \\<pi>' - plen \\<pi>; wf_mstate \\<phi> \\<pi> R st;\n        mem_restr R v; \\<pi> \\<le> \\<pi>';\n        X = msteps (pdrop (plen \\<pi>) \\<pi>') st\\<rbrakk>\n       \\<Longrightarrow> wf_mstate \\<phi> \\<pi>' R (snd X) \\<and>\n                         ((i, v) \\<in> fst X) =\n                         ((i, v) \\<in> M \\<pi>' - M \\<pi>)", "with Suc(1)[OF this(1) Suc.prems(1,2) this(2) refl] Suc.prems"], ["proof (chain)\npicking this:\n  wf_mstate \\<phi> \\<pi>'' R\n   (snd (msteps (pdrop (plen \\<pi>) \\<pi>'') st)) \\<and>\n  ((i, v) \\<in> fst (msteps (pdrop (plen \\<pi>) \\<pi>'') st)) =\n  ((i, v) \\<in> M \\<pi>'' - M \\<pi>)\n  wf_mstate \\<phi> \\<pi> R st\n  mem_restr R v\n  \\<pi> \\<le> \\<pi>'\n  X = msteps (pdrop (plen \\<pi>) \\<pi>') st\n  x = plen \\<pi>'' - plen \\<pi>\n  \\<pi> \\<le> \\<pi>''\n  \\<pi>' = psnoc \\<pi>'' tdb\n  pdrop (plen \\<pi>) (psnoc \\<pi>'' tdb) =\n  psnoc (pdrop (plen \\<pi>) \\<pi>'') tdb\n  last_ts (pdrop (plen \\<pi>) \\<pi>'') \\<le> snd tdb\n  last_ts \\<pi>'' \\<le> snd tdb\n  \\<pi>'' \\<le> psnoc \\<pi>'' tdb", "show ?case"], ["proof (prove)\nusing this:\n  wf_mstate \\<phi> \\<pi>'' R\n   (snd (msteps (pdrop (plen \\<pi>) \\<pi>'') st)) \\<and>\n  ((i, v) \\<in> fst (msteps (pdrop (plen \\<pi>) \\<pi>'') st)) =\n  ((i, v) \\<in> M \\<pi>'' - M \\<pi>)\n  wf_mstate \\<phi> \\<pi> R st\n  mem_restr R v\n  \\<pi> \\<le> \\<pi>'\n  X = msteps (pdrop (plen \\<pi>) \\<pi>') st\n  x = plen \\<pi>'' - plen \\<pi>\n  \\<pi> \\<le> \\<pi>''\n  \\<pi>' = psnoc \\<pi>'' tdb\n  pdrop (plen \\<pi>) (psnoc \\<pi>'' tdb) =\n  psnoc (pdrop (plen \\<pi>) \\<pi>'') tdb\n  last_ts (pdrop (plen \\<pi>) \\<pi>'') \\<le> snd tdb\n  last_ts \\<pi>'' \\<le> snd tdb\n  \\<pi>'' \\<le> psnoc \\<pi>'' tdb\n\ngoal (1 subgoal):\n 1. wf_mstate \\<phi> \\<pi>' R (snd X) \\<and>\n    ((i, v) \\<in> fst X) = ((i, v) \\<in> M \\<pi>' - M \\<pi>)", "unfolding msteps_msteps_stateless[symmetric]"], ["proof (prove)\nusing this:\n  wf_mstate \\<phi> \\<pi>'' R\n   (snd (msteps (pdrop (plen \\<pi>) \\<pi>'') st)) \\<and>\n  ((i, v) \\<in> fst (msteps (pdrop (plen \\<pi>) \\<pi>'') st)) =\n  ((i, v) \\<in> M \\<pi>'' - M \\<pi>)\n  wf_mstate \\<phi> \\<pi> R st\n  mem_restr R v\n  \\<pi> \\<le> \\<pi>'\n  X = msteps (pdrop (plen \\<pi>) \\<pi>') st\n  x = plen \\<pi>'' - plen \\<pi>\n  \\<pi> \\<le> \\<pi>''\n  \\<pi>' = psnoc \\<pi>'' tdb\n  pdrop (plen \\<pi>) (psnoc \\<pi>'' tdb) =\n  psnoc (pdrop (plen \\<pi>) \\<pi>'') tdb\n  last_ts (pdrop (plen \\<pi>) \\<pi>'') \\<le> snd tdb\n  last_ts \\<pi>'' \\<le> snd tdb\n  \\<pi>'' \\<le> psnoc \\<pi>'' tdb\n\ngoal (1 subgoal):\n 1. wf_mstate \\<phi> \\<pi>' R (snd X) \\<and>\n    ((i, v) \\<in> fst X) = ((i, v) \\<in> M \\<pi>' - M \\<pi>)", "by (auto simp: msteps_psnoc split_beta mstep_mverdicts\n      dest: mono_monitor[THEN set_mp, rotated] intro!: wf_mstate_mstep)"], ["proof (state)\nthis:\n  wf_mstate \\<phi> \\<pi>' R (snd X) \\<and>\n  ((i, v) \\<in> fst X) = ((i, v) \\<in> M \\<pi>' - M \\<pi>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in monitorable_mfotl) wf_mstate_msteps_stateless:\n  assumes \"wf_mstate \\<phi> \\<pi> R st\" \"mem_restr R v\" \"\\<pi> \\<le> \\<pi>'\"\n  shows \"(i, v) \\<in> msteps_stateless (pdrop (plen \\<pi>) \\<pi>') st \\<longleftrightarrow> (i, v) \\<in> M \\<pi>' - M \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((i, v) \\<in> msteps_stateless (pdrop (plen \\<pi>) \\<pi>') st) =\n    ((i, v) \\<in> M \\<pi>' - M \\<pi>)", "using wf_mstate_msteps[OF assms refl]"], ["proof (prove)\nusing this:\n  wf_mstate \\<phi> \\<pi>' R\n   (snd (msteps (pdrop (plen \\<pi>) \\<pi>') st)) \\<and>\n  ((?i, v) \\<in> fst (msteps (pdrop (plen \\<pi>) \\<pi>') st)) =\n  ((?i, v) \\<in> M \\<pi>' - M \\<pi>)\n\ngoal (1 subgoal):\n 1. ((i, v) \\<in> msteps_stateless (pdrop (plen \\<pi>) \\<pi>') st) =\n    ((i, v) \\<in> M \\<pi>' - M \\<pi>)", "unfolding msteps_msteps_stateless"], ["proof (prove)\nusing this:\n  wf_mstate \\<phi> \\<pi>' R\n   (snd (msteps (pdrop (plen \\<pi>) \\<pi>') st)) \\<and>\n  ((?i, v) \\<in> msteps_stateless (pdrop (plen \\<pi>) \\<pi>') st) =\n  ((?i, v) \\<in> M \\<pi>' - M \\<pi>)\n\ngoal (1 subgoal):\n 1. ((i, v) \\<in> msteps_stateless (pdrop (plen \\<pi>) \\<pi>') st) =\n    ((i, v) \\<in> M \\<pi>' - M \\<pi>)", "by simp"], ["", "lemma (in monitorable_mfotl) wf_mstate_msteps_stateless_UNIV: \"wf_mstate \\<phi> \\<pi> UNIV st \\<Longrightarrow> \\<pi> \\<le> \\<pi>' \\<Longrightarrow>\n  msteps_stateless (pdrop (plen \\<pi>) \\<pi>') st = M \\<pi>' - M \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_mstate \\<phi> \\<pi> UNIV st; \\<pi> \\<le> \\<pi>'\\<rbrakk>\n    \\<Longrightarrow> msteps_stateless (pdrop (plen \\<pi>) \\<pi>') st =\n                      M \\<pi>' - M \\<pi>", "by (auto dest: wf_mstate_msteps_stateless[OF _ mem_restr_UNIV])"], ["", "lemma (in monitorable_mfotl) mverdicts_Nil: \"M pnil = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M pnil = {}", "by (simp add: M_def pprogress_eq)"], ["", "lemma wf_mstate_minit_safe: \"mmonitorable \\<phi> \\<Longrightarrow> wf_mstate \\<phi> pnil R (minit_safe \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mmonitorable \\<phi> \\<Longrightarrow>\n    wf_mstate \\<phi> pnil R (minit_safe \\<phi>)", "using wf_mstate_minit minit_safe_minit mmonitorable_def"], ["proof (prove)\nusing this:\n  safe_formula ?\\<phi> \\<Longrightarrow>\n  wf_mstate ?\\<phi> pnil ?R (minit ?\\<phi>)\n  mmonitorable ?\\<phi> \\<Longrightarrow> minit_safe ?\\<phi> = minit ?\\<phi>\n  mmonitorable ?\\<phi> =\n  (safe_formula ?\\<phi> \\<and>\n   MFOTL.future_reach ?\\<phi> \\<noteq> \\<infinity>)\n\ngoal (1 subgoal):\n 1. mmonitorable \\<phi> \\<Longrightarrow>\n    wf_mstate \\<phi> pnil R (minit_safe \\<phi>)", "by metis"], ["", "lemma (in monitorable_mfotl) monitor_mverdicts: \"monitor \\<phi> \\<pi> = M \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Monitor.monitor \\<phi> \\<pi> = M \\<pi>", "unfolding monitor_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. msteps_stateless \\<pi> (minit_safe \\<phi>) = M \\<pi>", "using monitorable"], ["proof (prove)\nusing this:\n  mmonitorable \\<phi>\n\ngoal (1 subgoal):\n 1. msteps_stateless \\<pi> (minit_safe \\<phi>) = M \\<pi>", "by (subst wf_mstate_msteps_stateless_UNIV[OF wf_mstate_minit_safe, simplified])\n    (auto simp: mmonitorable_def mverdicts_Nil)"], ["", "subsection \\<open>Collected correctness results\\<close>"], ["", "context monitorable_mfotl\nbegin"], ["", "text \\<open>We summarize the main results proved above.\n\\begin{enumerate}\n\\item The term @{term M} describes semantically the monitor's expected behaviour:\n\\begin{itemize}\n\\item @{thm[source] mono_monitor}: @{thm mono_monitor[no_vars]}\n\\item @{thm[source] sound_monitor}: @{thm sound_monitor[no_vars]}\n\\item @{thm[source] complete_monitor}: @{thm complete_monitor[no_vars]}\n\\item @{thm[source] sliceable_M}: @{thm sliceable_M[no_vars]}\n\\end{itemize}\n\\item The executable monitor's online interface @{term minit_safe} and @{term mstep}\n  preserves the invariant @{term wf_mstate} and produces the the verdicts according\n  to @{term M}:\n\\begin{itemize}\n\\item @{thm[source] wf_mstate_minit_safe}: @{thm wf_mstate_minit_safe[no_vars]}\n\\item @{thm[source] wf_mstate_mstep}: @{thm wf_mstate_mstep[no_vars]}\n\\item @{thm[source] mstep_mverdicts}: @{thm mstep_mverdicts[no_vars]}\n\\end{itemize}\n\\item The executable monitor's offline interface @{term monitor} implements @{term M}:\n\\begin{itemize}\n\\item @{thm[source] monitor_mverdicts}: @{thm monitor_mverdicts[no_vars]}\n\\end{itemize}\n\\end{enumerate}\n\\<close>"], ["", "end"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}