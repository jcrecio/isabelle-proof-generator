{"file_name": "/home/qj213/afp-2021-10-22/thys/DiskPaxos/DiskPaxos_Model.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/DiskPaxos", "problem_names": ["lemma ballots_not_zero [simp]:\n  \"b \\<in> Ballot p \\<Longrightarrow> 0 < b\"", "lemma majority_nonempty [simp]: \"IsMajority(S) \\<Longrightarrow> S \\<noteq> {}\""], "translations": [["", "lemma ballots_not_zero [simp]:\n  \"b \\<in> Ballot p \\<Longrightarrow> 0 < b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> Ballot p \\<Longrightarrow> 0 < b", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> Ballot p; \\<not> 0 < b\\<rbrakk> \\<Longrightarrow> False", "assume b: \"b \\<in> Ballot p\"\n  and contr: \"\\<not> (0 < b)\""], ["proof (state)\nthis:\n  b \\<in> Ballot p\n  \\<not> 0 < b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> Ballot p; \\<not> 0 < b\\<rbrakk> \\<Longrightarrow> False", "from Ballot_nzero"], ["proof (chain)\npicking this:\n  \\<forall>p. 0 \\<notin> Ballot p", "have \"0 \\<notin> Ballot p\""], ["proof (prove)\nusing this:\n  \\<forall>p. 0 \\<notin> Ballot p\n\ngoal (1 subgoal):\n 1. 0 \\<notin> Ballot p", ".."], ["proof (state)\nthis:\n  0 \\<notin> Ballot p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<in> Ballot p; \\<not> 0 < b\\<rbrakk> \\<Longrightarrow> False", "with b contr"], ["proof (chain)\npicking this:\n  b \\<in> Ballot p\n  \\<not> 0 < b\n  0 \\<notin> Ballot p", "show \"False\""], ["proof (prove)\nusing this:\n  b \\<in> Ballot p\n  \\<not> 0 < b\n  0 \\<notin> Ballot p\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma majority_nonempty [simp]: \"IsMajority(S) \\<Longrightarrow> S \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IsMajority S \\<Longrightarrow> S \\<noteq> {}", "proof(auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>IsMajority {}; S = {}\\<rbrakk> \\<Longrightarrow> False", "from majorities_intersect"], ["proof (chain)\npicking this:\n  \\<forall>S T.\n     IsMajority S \\<and> IsMajority T \\<longrightarrow>\n     S \\<inter> T \\<noteq> {}", "have \"IsMajority({}) \\<and> IsMajority({}) \\<longrightarrow> {} \\<inter> {} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<forall>S T.\n     IsMajority S \\<and> IsMajority T \\<longrightarrow>\n     S \\<inter> T \\<noteq> {}\n\ngoal (1 subgoal):\n 1. IsMajority {} \\<and> IsMajority {} \\<longrightarrow>\n    {} \\<inter> {} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  IsMajority {} \\<and> IsMajority {} \\<longrightarrow>\n  {} \\<inter> {} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>IsMajority {}; S = {}\\<rbrakk> \\<Longrightarrow> False", "thus \"IsMajority {} \\<Longrightarrow> False\""], ["proof (prove)\nusing this:\n  IsMajority {} \\<and> IsMajority {} \\<longrightarrow>\n  {} \\<inter> {} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. IsMajority {} \\<Longrightarrow> False", "by auto"], ["proof (state)\nthis:\n  IsMajority {} \\<Longrightarrow> False\n\ngoal:\nNo subgoals!", "qed"], ["", "definition AllBallots :: \"nat set\"\n  where \"AllBallots = (UN p. Ballot p)\""], ["", "record\n  DiskBlock = \n    mbal:: nat\n    bal :: nat\n    inp :: InputsOrNi"], ["", "definition InitDB :: DiskBlock\n  where \"InitDB = \\<lparr> mbal = 0, bal = 0, inp = NotAnInput \\<rparr>\""], ["", "record\n  BlockProc =\n    block :: DiskBlock\n    proc  :: Proc"], ["", "record \n  state =\n    inpt :: \"Proc \\<Rightarrow> InputsOrNi\"\n    outpt :: \"Proc \\<Rightarrow> InputsOrNi\"\n    disk :: \"Disk \\<Rightarrow> Proc \\<Rightarrow> DiskBlock\"\n    dblock :: \"Proc \\<Rightarrow> DiskBlock\"\n    phase :: \"Proc \\<Rightarrow> nat\"\n    disksWritten :: \"Proc \\<Rightarrow> Disk set\"\n    blocksRead :: \"Proc \\<Rightarrow> Disk \\<Rightarrow> BlockProc set\"\n  (* History Variables *) \n    allInput  :: \"InputsOrNi set\"\n    chosen    :: \"InputsOrNi\""], ["", "definition hasRead :: \"state \\<Rightarrow> Proc \\<Rightarrow> Disk \\<Rightarrow> Proc \\<Rightarrow> bool\"\n  where \"hasRead s p d q = (\\<exists> br \\<in> blocksRead s p d. proc br = q)\""], ["", "definition allRdBlks :: \"state \\<Rightarrow> Proc \\<Rightarrow> BlockProc set\"\n  where \"allRdBlks s p = (UN d. blocksRead s p d)\""], ["", "definition allBlocksRead :: \"state \\<Rightarrow> Proc \\<Rightarrow> DiskBlock set\"\n  where \"allBlocksRead s p = block ` (allRdBlks s p)\""], ["", "definition Init :: \"state \\<Rightarrow> bool\"\n  where\n    \"Init s =\n      (range (inpt s) \\<subseteq> Inputs\n     & outpt s = (\\<lambda>p. NotAnInput)\n     & disk s = (\\<lambda>d p. InitDB)\n     & phase s = (\\<lambda>p. 0)\n     & dblock s = (\\<lambda>p. InitDB)\n     & disksWritten s = (\\<lambda>p. {})\n     & blocksRead s = (\\<lambda>p d. {}))\""], ["", "definition InitializePhase :: \"state \\<Rightarrow> state \\<Rightarrow> Proc \\<Rightarrow> bool\"\n  where\n  \"InitializePhase s s' p =\n    (disksWritten s' = (disksWritten s)(p := {})\n   & blocksRead s' = (blocksRead s)(p := (\\<lambda>d. {})))\""], ["", "definition StartBallot :: \"state \\<Rightarrow> state \\<Rightarrow> Proc \\<Rightarrow> bool\"\nwhere\n  \"StartBallot s s' p =\n    (phase s p \\<in> {1,2}\n   & phase s' = (phase s)(p := 1)\n   & (\\<exists>b \\<in> Ballot p. \n         mbal (dblock s p) < b\n       & dblock s' = (dblock s)(p := (dblock s p)\\<lparr> mbal := b \\<rparr>))\n   & InitializePhase s s' p\n   & inpt s' = inpt s & outpt s' = outpt s & disk s' = disk s)\""], ["", "definition Phase1or2Write :: \"state \\<Rightarrow> state \\<Rightarrow> Proc \\<Rightarrow> Disk \\<Rightarrow> bool\"\nwhere\n  \"Phase1or2Write s s' p d =\n    (phase s p \\<in> {1, 2}\n   \\<and> disk s' = (disk s) (d := (disk s d) (p := dblock s p)) \n   \\<and> disksWritten s' = (disksWritten s) (p:= (disksWritten s p) \\<union> {d})\n   \\<and> inpt s' = inpt s \\<and> outpt s'= outpt s\n   \\<and> phase s' = phase s \\<and> dblock s' = dblock s\n   \\<and> blocksRead s'= blocksRead s)\""], ["", "definition Phase1or2ReadThen :: \"state \\<Rightarrow> state \\<Rightarrow> Proc \\<Rightarrow> Disk \\<Rightarrow> Proc \\<Rightarrow> bool\"\nwhere\n  \"Phase1or2ReadThen s s' p d q =\n    (d \\<in> disksWritten s p\n   & mbal(disk s d q) < mbal(dblock s p)\n   & blocksRead s' = (blocksRead s)(p := (blocksRead s p)(d :=\n                       (blocksRead s p d) \\<union> {\\<lparr> block = disk s d q,\n                                               proc = q \\<rparr>}))\n   & inpt s' = inpt s & outpt s' = outpt s\n   & disk s' = disk s & phase s' = phase s\n   & dblock s' = dblock s & disksWritten s' = disksWritten s)\""], ["", "definition Phase1or2ReadElse :: \"state \\<Rightarrow> state \\<Rightarrow> Proc \\<Rightarrow> Disk \\<Rightarrow> Proc \\<Rightarrow> bool\"\nwhere\n  \"Phase1or2ReadElse s s' p d q =\n    (d \\<in> disksWritten s p\n   \\<and> StartBallot s s' p)\""], ["", "definition Phase1or2Read :: \"state \\<Rightarrow> state \\<Rightarrow> Proc \\<Rightarrow> Disk \\<Rightarrow> Proc \\<Rightarrow> bool\"\nwhere\n  \"Phase1or2Read s s' p d q =\n     (Phase1or2ReadThen s s' p d q\n    \\<or> Phase1or2ReadElse s s' p d q)\""], ["", "definition blocksSeen :: \"state \\<Rightarrow> Proc \\<Rightarrow> DiskBlock set\"\n  where \"blocksSeen s p = allBlocksRead s p \\<union> {dblock s p}\""], ["", "definition nonInitBlks :: \"state \\<Rightarrow> Proc \\<Rightarrow> DiskBlock set\"\n  where\"nonInitBlks s p = {bs . bs \\<in> blocksSeen s p \\<and> inp bs \\<in> Inputs}\""], ["", "definition maxBlk :: \"state \\<Rightarrow> Proc \\<Rightarrow> DiskBlock\"\nwhere\n  \"maxBlk s p =\n     (SOME b. b \\<in> nonInitBlks s p \\<and> (\\<forall>c \\<in> nonInitBlks s p. bal c \\<le> bal b))\""], ["", "definition EndPhase1 :: \"state \\<Rightarrow> state \\<Rightarrow> Proc \\<Rightarrow> bool\"\nwhere\n  \"EndPhase1 s s' p =\n    (IsMajority {d . d \\<in> disksWritten s p\n                     \\<and> (\\<forall>q \\<in> UNIV - {p}. hasRead s p d q)}\n   \\<and> phase s p = 1\n   \\<and> dblock s' = (dblock s) (p := dblock s p \n           \\<lparr> bal := mbal(dblock s p),\n             inp := \n              (if nonInitBlks s p = {}\n               then inpt s p\n               else inp (maxBlk s p))\n           \\<rparr> )\n   \\<and> outpt s' = outpt s\n   \\<and> phase s' = (phase s) (p := phase s p + 1)\n   \\<and> InitializePhase s s' p\n   \\<and> inpt s' = inpt s \\<and> disk s' = disk s)\""], ["", "definition EndPhase2 :: \"state \\<Rightarrow> state \\<Rightarrow> Proc \\<Rightarrow> bool\"\nwhere\n  \"EndPhase2 s s' p =\n    (IsMajority {d . d \\<in> disksWritten s p\n                     \\<and> (\\<forall>q \\<in> UNIV - {p}. hasRead s p d q)}\n   \\<and> phase s p = 2\n   \\<and> outpt s' = (outpt s) (p:= inp (dblock s p))\n   \\<and> dblock s' = dblock s\n   \\<and> phase s' = (phase s) (p := phase s p + 1)\n   \\<and> InitializePhase s s' p\n   \\<and> inpt s' = inpt s \\<and> disk s' = disk s)\""], ["", "definition EndPhase1or2 :: \"state \\<Rightarrow> state \\<Rightarrow> Proc \\<Rightarrow> bool\"\n  where \"EndPhase1or2 s s' p = (EndPhase1 s s' p \\<or> EndPhase2 s s' p)\""], ["", "definition Fail :: \"state \\<Rightarrow> state \\<Rightarrow> Proc \\<Rightarrow> bool\"\nwhere\n  \"Fail s s' p =\n    (\\<exists>ip \\<in> Inputs. inpt s' = (inpt s) (p := ip)\n   \\<and> phase s' = (phase s) (p := 0)\n   \\<and> dblock s'= (dblock s) (p := InitDB)\n   \\<and> outpt s' = (outpt s) (p := NotAnInput)\n   \\<and> InitializePhase s s' p\n   \\<and> disk s'= disk s)\""], ["", "definition Phase0Read :: \"state \\<Rightarrow> state \\<Rightarrow> Proc \\<Rightarrow> Disk \\<Rightarrow> bool\"\nwhere\n  \"Phase0Read s s' p d =\n    (phase s p = 0\n   \\<and> blocksRead s' = (blocksRead s) (p := (blocksRead s p) (d := blocksRead s p d \\<union> {\\<lparr> block = disk s d p, proc = p \\<rparr>}))\n   \\<and> inpt s' = inpt s & outpt s' = outpt s\n   \\<and> disk s' = disk s & phase s' = phase s\n   \\<and> dblock s' = dblock s & disksWritten s' = disksWritten s)\""], ["", "definition EndPhase0 :: \"state \\<Rightarrow> state \\<Rightarrow> Proc \\<Rightarrow> bool\"\nwhere\n  \"EndPhase0 s s' p =\n    (phase s p = 0\n   \\<and> IsMajority ({d. hasRead s p d p})\n   \\<and> (\\<exists>b \\<in> Ballot p.   \n       (\\<forall>r \\<in> allBlocksRead s p. mbal r < b)\n     \\<and> dblock s' = (dblock s) ( p:= \n                    (SOME r.   r \\<in> allBlocksRead s p \n                            \\<and> (\\<forall>s \\<in> allBlocksRead s p. bal s \\<le>  bal r)) \\<lparr> mbal := b \\<rparr> ))\n   \\<and> InitializePhase s s' p\n   \\<and> phase s' = (phase s) (p:= 1)\n   \\<and> inpt s' = inpt s \\<and> outpt s' = outpt s \\<and> disk s' = disk s)\""], ["", "definition Next :: \"state \\<Rightarrow> state \\<Rightarrow> bool\"\nwhere\n  \"Next s s' = (\\<exists>p.\n                  StartBallot s s' p\n                \\<or> (\\<exists>d.   Phase0Read s s' p d\n                       \\<or> Phase1or2Write s s' p d\n                       \\<or> (\\<exists>q. q \\<noteq> p \\<and> Phase1or2Read s s' p d q))\n                \\<or> EndPhase1or2 s s' p\n                \\<or> Fail s s' p\n                \\<or> EndPhase0 s s' p)\""], ["", "text \\<open>\n  In the following, for each action or state {\\em name} we name\n  {\\em Hname} the corresponding action that includes \n  the history part of the HNext action or state predicate that includes \n  history variables.\n\\<close>"], ["", "definition HInit :: \"state \\<Rightarrow> bool\"\nwhere\n  \"HInit s =\n    (Init s\n   & chosen s = NotAnInput\n   & allInput s = range (inpt s))\""], ["", "text \\<open>HNextPart is the part of the Next action \n        that is concerned with history variables.\n\\<close>"], ["", "definition HNextPart :: \"state \\<Rightarrow> state => bool\"\nwhere\n  \"HNextPart s s' =\n    (chosen s' = \n       (if chosen s \\<noteq> NotAnInput \\<or> (\\<forall>p. outpt s' p = NotAnInput )\n            then chosen s\n            else outpt s' (SOME p. outpt s' p \\<noteq> NotAnInput))\n   \\<and> allInput s' = allInput s \\<union> (range (inpt s')))\""], ["", "definition HNext :: \"state \\<Rightarrow> state \\<Rightarrow> bool\"\nwhere\n  \"HNext s s' =\n     (Next s s'\n   \\<and> HNextPart s s')\""], ["", "text \\<open>\n  We add HNextPart to every action (rather than proving that Next \n  maintains the HInv invariant) to make proofs easier. \n\\<close>"], ["", "definition\n  HPhase1or2ReadThen :: \"state \\<Rightarrow> state \\<Rightarrow> Proc \\<Rightarrow> Disk \\<Rightarrow> Proc \\<Rightarrow> bool\" where\n  \"HPhase1or2ReadThen s s' p d q = (Phase1or2ReadThen s s' p d q \\<and> HNextPart s s')\""], ["", "definition\n  HEndPhase1 :: \"state \\<Rightarrow> state \\<Rightarrow> Proc \\<Rightarrow> bool\" where\n  \"HEndPhase1 s s' p = (EndPhase1 s s' p \\<and> HNextPart s s')\""], ["", "definition\n  HStartBallot :: \"state \\<Rightarrow> state \\<Rightarrow> Proc \\<Rightarrow> bool\" where\n  \"HStartBallot s s' p = (StartBallot s s' p \\<and> HNextPart s s')\""], ["", "definition\n  HPhase1or2Write :: \"state \\<Rightarrow> state \\<Rightarrow> Proc \\<Rightarrow> Disk \\<Rightarrow> bool\" where\n  \"HPhase1or2Write s s' p d = (Phase1or2Write s s' p d \\<and> HNextPart s s')\""], ["", "definition\n  HPhase1or2ReadElse :: \"state \\<Rightarrow> state \\<Rightarrow> Proc \\<Rightarrow> Disk \\<Rightarrow> Proc \\<Rightarrow> bool\" where\n  \"HPhase1or2ReadElse s s' p d q = (Phase1or2ReadElse s s' p d q \\<and> HNextPart s s')\""], ["", "definition\n  HEndPhase2 :: \"state \\<Rightarrow> state \\<Rightarrow> Proc \\<Rightarrow> bool\" where\n  \"HEndPhase2 s s' p = (EndPhase2 s s' p \\<and> HNextPart s s')\""], ["", "definition\n  HFail :: \"state \\<Rightarrow> state \\<Rightarrow> Proc \\<Rightarrow> bool\" where\n  \"HFail s s' p = (Fail s s' p  \\<and> HNextPart s s')\""], ["", "definition\n  HPhase0Read :: \"state \\<Rightarrow> state \\<Rightarrow> Proc \\<Rightarrow> Disk \\<Rightarrow> bool\" where\n  \"HPhase0Read s s' p d = (Phase0Read s s' p d \\<and> HNextPart s s')\""], ["", "definition\n  HEndPhase0 :: \"state \\<Rightarrow> state \\<Rightarrow> Proc \\<Rightarrow> bool\" where\n  \"HEndPhase0 s s' p = (EndPhase0 s s' p \\<and> HNextPart s s')\""], ["", "text \\<open>\n  Since these definitions are the conjunction of two other definitions \n  declaring them as simplification rules should be harmless.\n\\<close>"], ["", "declare HPhase1or2ReadThen_def [simp]"], ["", "declare HPhase1or2ReadElse_def [simp]"], ["", "declare HEndPhase1_def  [simp]"], ["", "declare HStartBallot_def  [simp]"], ["", "declare HPhase1or2Write_def [simp]"], ["", "declare HEndPhase2_def [simp]"], ["", "declare HFail_def [simp]"], ["", "declare HPhase0Read_def [simp]"], ["", "declare HEndPhase0_def [simp]"], ["", "end"]]}