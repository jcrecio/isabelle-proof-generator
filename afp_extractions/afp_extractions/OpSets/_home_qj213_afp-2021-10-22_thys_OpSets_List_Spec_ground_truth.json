{"file_name": "/home/qj213/afp-2021-10-22/thys/OpSets/List_Spec.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/OpSets", "problem_names": ["lemma interp_ops_unfold_last:\n  shows \"interp_ops (xs @ [x]) = interp_op (interp_ops xs) x\"", "lemma map_filter_append:\n  shows \"List.map_filter P (xs @ ys) = List.map_filter P xs @ List.map_filter P ys\"", "lemma map_filter_Some:\n  assumes \"P x = Some y\"\n  shows \"List.map_filter P [x] = [y]\"", "lemma map_filter_None:\n  assumes \"P x = None\"\n  shows \"List.map_filter P [x] = []\"", "lemma insertions_last_ins:\n  shows \"insertions (xs @ [(oid, Insert ref val)]) = insertions xs @ [(oid, ref)]\"", "lemma insertions_last_del:\n  shows \"insertions (xs @ [(oid, Delete ref)]) = insertions xs\"", "lemma insertions_fst_subset:\n  shows \"set (map fst (insertions ops)) \\<subseteq> set (map fst ops)\"", "lemma insertions_subset:\n  assumes \"list_ops A\" and \"list_ops B\"\n    and \"set A \\<subseteq> set B\"\n  shows \"set (insertions A) \\<subseteq> set (insertions B)\"", "lemma list_ops_insertions:\n  assumes \"list_ops ops\"\n  shows \"insert_ops (insertions ops)\"", "lemma inserted_ids_last_ins:\n  shows \"inserted_ids (xs @ [(oid, Insert ref val)]) = inserted_ids xs @ [oid]\"", "lemma inserted_ids_last_del:\n  shows \"inserted_ids (xs @ [(oid, Delete ref)]) = inserted_ids xs\"", "lemma inserted_ids_exist:\n  shows \"oid \\<in> set (inserted_ids ops) \\<longleftrightarrow> (\\<exists>ref val. (oid, Insert ref val) \\<in> set ops)\"", "lemma deleted_ids_last_ins:\n  shows \"deleted_ids (xs @ [(oid, Insert ref val)]) = deleted_ids xs\"", "lemma deleted_ids_last_del:\n  shows \"deleted_ids (xs @ [(oid, Delete ref)]) = deleted_ids xs @ [ref]\"", "lemma deleted_ids_exist:\n  shows \"ref \\<in> set (deleted_ids ops) \\<longleftrightarrow> (\\<exists>i. (i, Delete ref) \\<in> set ops)\"", "lemma deleted_ids_refs_older:\n  assumes \"list_ops (ops @ [(oid, oper)])\"\n  shows \"\\<And>ref. ref \\<in> set (deleted_ids ops) \\<Longrightarrow> ref < oid\"", "lemma interp_ops_list_equiv:\n  shows \"fst (interp_ops ops) = interp_ins (insertions ops)\"", "lemma interp_ops_distinct:\n  assumes \"list_ops ops\"\n  shows \"distinct (fst (interp_ops ops))\"", "lemma list_order_equiv:\n  shows \"list_order ops x y \\<longleftrightarrow> Insert_Spec.list_order (insertions ops) x y\"", "lemma interp_ops_vals_domain:\n  assumes \"list_ops ops\"\n  shows \"dom (snd (interp_ops ops)) = set (inserted_ids ops) - set (deleted_ids ops)\"", "lemma insert_spec_nth_oid:\n  assumes \"distinct xs\"\n    and \"n < length xs\"\n  shows \"insert_spec xs (oid, Some (xs ! n)) ! Suc n = oid\"", "lemma insert_spec_inc_length:\n  assumes \"distinct xs\"\n    and \"n < length xs\"\n  shows \"length (insert_spec xs (oid, Some (xs ! n))) = Suc (length xs)\"", "lemma list_split_two_elems:\n  assumes \"distinct xs\"\n    and \"x \\<in> set xs\" and \"y \\<in> set xs\"\n    and \"x \\<noteq> y\"\n  shows \"\\<exists>pre mid suf. xs = pre @ x # mid @ y # suf \\<or> xs = pre @ y # mid @ x # suf\"", "theorem inserted_but_not_deleted:\n  assumes \"list_ops ops\"\n    and \"interp_ops ops = (list, vals)\"\n  shows \"a \\<in> dom (vals) \\<longleftrightarrow> (\\<exists>ref val. (a, Insert ref val) \\<in> set ops) \\<and>\n                            (\\<nexists>i. (i, Delete a) \\<in> set ops)\"", "theorem list_order_consistent:\n  assumes \"list_ops some_ops\" and \"list_ops all_ops\"\n    and \"set some_ops \\<subseteq> set all_ops\"\n    and \"list_order some_ops x y\"\n  shows \"list_order all_ops x y\"", "theorem correct_position_insert:\n  assumes \"list_ops (ops @ [(oid, ins)])\"\n    and \"ins = make_insert (fst (interp_ops ops)) val k\"\n    and \"list = fst (interp_ops (ops @ [(oid, ins)]))\"\n  shows \"list ! (min k (length list - 1)) = oid\"", "theorem list_order_trans:\n  assumes \"list_ops ops\"\n    and \"list_order ops x y\"\n    and \"list_order ops y z\"\n  shows \"list_order ops x z\"", "theorem list_order_irrefl:\n  assumes \"list_ops ops\"\n  shows \"\\<not> list_order ops x x\"", "theorem list_order_total:\n  assumes \"list_ops ops\"\n    and \"x \\<in> set (fst (interp_ops ops))\"\n    and \"y \\<in> set (fst (interp_ops ops))\"\n    and \"x \\<noteq> y\"\n  shows \"list_order ops x y \\<or> list_order ops y x\""], "translations": [["", "lemma interp_ops_unfold_last:\n  shows \"interp_ops (xs @ [x]) = interp_op (interp_ops xs) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interp_ops (xs @ [x]) = interp_op (interp_ops xs) x", "by (simp add: interp_ops_def)"], ["", "lemma map_filter_append:\n  shows \"List.map_filter P (xs @ ys) = List.map_filter P xs @ List.map_filter P ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.map_filter P (xs @ ys) =\n    List.map_filter P xs @ List.map_filter P ys", "by (auto simp add: List.map_filter_def)"], ["", "lemma map_filter_Some:\n  assumes \"P x = Some y\"\n  shows \"List.map_filter P [x] = [y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.map_filter P [x] = [y]", "by (simp add: assms map_filter_simps(1) map_filter_simps(2))"], ["", "lemma map_filter_None:\n  assumes \"P x = None\"\n  shows \"List.map_filter P [x] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.map_filter P [x] = []", "by (simp add: assms map_filter_simps(1) map_filter_simps(2))"], ["", "lemma insertions_last_ins:\n  shows \"insertions (xs @ [(oid, Insert ref val)]) = insertions xs @ [(oid, ref)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertions (xs @ [(oid, Insert ref val)]) = insertions xs @ [(oid, ref)]", "by (simp add: insertions_def map_filter_Some map_filter_append)"], ["", "lemma insertions_last_del:\n  shows \"insertions (xs @ [(oid, Delete ref)]) = insertions xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertions (xs @ [(oid, Delete ref)]) = insertions xs", "by (simp add: insertions_def map_filter_None map_filter_append)"], ["", "lemma insertions_fst_subset:\n  shows \"set (map fst (insertions ops)) \\<subseteq> set (map fst ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map fst (insertions ops)) \\<subseteq> set (map fst ops)", "proof(induction ops rule: List.rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. set (map fst (insertions [])) \\<subseteq> set (map fst [])\n 2. \\<And>x xs.\n       set (map fst (insertions xs))\n       \\<subseteq> set (map fst xs) \\<Longrightarrow>\n       set (map fst (insertions (xs @ [x])))\n       \\<subseteq> set (map fst (xs @ [x]))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. set (map fst (insertions [])) \\<subseteq> set (map fst [])\n 2. \\<And>x xs.\n       set (map fst (insertions xs))\n       \\<subseteq> set (map fst xs) \\<Longrightarrow>\n       set (map fst (insertions (xs @ [x])))\n       \\<subseteq> set (map fst (xs @ [x]))", "then"], ["proof (chain)\npicking this:", "show \"set (map fst (insertions [])) \\<subseteq> set (map fst [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map fst (insertions [])) \\<subseteq> set (map fst [])", "by (simp add: insert_ops_def spec_ops_def insertions_def map_filter_def)"], ["proof (state)\nthis:\n  set (map fst (insertions [])) \\<subseteq> set (map fst [])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       set (map fst (insertions xs))\n       \\<subseteq> set (map fst xs) \\<Longrightarrow>\n       set (map fst (insertions (xs @ [x])))\n       \\<subseteq> set (map fst (xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       set (map fst (insertions xs))\n       \\<subseteq> set (map fst xs) \\<Longrightarrow>\n       set (map fst (insertions (xs @ [x])))\n       \\<subseteq> set (map fst (xs @ [x]))", "case (snoc a ops)"], ["proof (state)\nthis:\n  set (map fst (insertions ops)) \\<subseteq> set (map fst ops)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       set (map fst (insertions xs))\n       \\<subseteq> set (map fst xs) \\<Longrightarrow>\n       set (map fst (insertions (xs @ [x])))\n       \\<subseteq> set (map fst (xs @ [x]))", "obtain oid oper where a_pair: \"a = (oid, oper)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>oid oper.\n        a = (oid, oper) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a = (oid, oper)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       set (map fst (insertions xs))\n       \\<subseteq> set (map fst xs) \\<Longrightarrow>\n       set (map fst (insertions (xs @ [x])))\n       \\<subseteq> set (map fst (xs @ [x]))", "then"], ["proof (chain)\npicking this:\n  a = (oid, oper)", "show \"set (map fst (insertions (ops @ [a]))) \\<subseteq> set (map fst (ops @ [a]))\""], ["proof (prove)\nusing this:\n  a = (oid, oper)\n\ngoal (1 subgoal):\n 1. set (map fst (insertions (ops @ [a])))\n    \\<subseteq> set (map fst (ops @ [a]))", "proof(cases oper)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>a = (oid, oper); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> set (map fst (insertions (ops @ [a])))\n                         \\<subseteq> set (map fst (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> set (map fst (insertions (ops @ [a])))\n                         \\<subseteq> set (map fst (ops @ [a]))", "case (Insert ref val)"], ["proof (state)\nthis:\n  oper = Insert ref val\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>a = (oid, oper); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> set (map fst (insertions (ops @ [a])))\n                         \\<subseteq> set (map fst (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> set (map fst (insertions (ops @ [a])))\n                         \\<subseteq> set (map fst (ops @ [a]))", "hence \"insertions (ops @ [a]) = insertions ops @ [(oid, ref)]\""], ["proof (prove)\nusing this:\n  oper = Insert ref val\n\ngoal (1 subgoal):\n 1. insertions (ops @ [a]) = insertions ops @ [(oid, ref)]", "by (simp add: a_pair insertions_last_ins)"], ["proof (state)\nthis:\n  insertions (ops @ [a]) = insertions ops @ [(oid, ref)]\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>a = (oid, oper); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> set (map fst (insertions (ops @ [a])))\n                         \\<subseteq> set (map fst (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> set (map fst (insertions (ops @ [a])))\n                         \\<subseteq> set (map fst (ops @ [a]))", "then"], ["proof (chain)\npicking this:\n  insertions (ops @ [a]) = insertions ops @ [(oid, ref)]", "show ?thesis"], ["proof (prove)\nusing this:\n  insertions (ops @ [a]) = insertions ops @ [(oid, ref)]\n\ngoal (1 subgoal):\n 1. set (map fst (insertions (ops @ [a])))\n    \\<subseteq> set (map fst (ops @ [a]))", "using snoc.IH a_pair"], ["proof (prove)\nusing this:\n  insertions (ops @ [a]) = insertions ops @ [(oid, ref)]\n  set (map fst (insertions ops)) \\<subseteq> set (map fst ops)\n  a = (oid, oper)\n\ngoal (1 subgoal):\n 1. set (map fst (insertions (ops @ [a])))\n    \\<subseteq> set (map fst (ops @ [a]))", "by auto"], ["proof (state)\nthis:\n  set (map fst (insertions (ops @ [a])))\n  \\<subseteq> set (map fst (ops @ [a]))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> set (map fst (insertions (ops @ [a])))\n                         \\<subseteq> set (map fst (ops @ [a]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> set (map fst (insertions (ops @ [a])))\n                         \\<subseteq> set (map fst (ops @ [a]))", "case (Delete ref)"], ["proof (state)\nthis:\n  oper = Delete ref\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> set (map fst (insertions (ops @ [a])))\n                         \\<subseteq> set (map fst (ops @ [a]))", "hence \"insertions (ops @ [a]) = insertions ops\""], ["proof (prove)\nusing this:\n  oper = Delete ref\n\ngoal (1 subgoal):\n 1. insertions (ops @ [a]) = insertions ops", "by (simp add: a_pair insertions_last_del)"], ["proof (state)\nthis:\n  insertions (ops @ [a]) = insertions ops\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> set (map fst (insertions (ops @ [a])))\n                         \\<subseteq> set (map fst (ops @ [a]))", "then"], ["proof (chain)\npicking this:\n  insertions (ops @ [a]) = insertions ops", "show ?thesis"], ["proof (prove)\nusing this:\n  insertions (ops @ [a]) = insertions ops\n\ngoal (1 subgoal):\n 1. set (map fst (insertions (ops @ [a])))\n    \\<subseteq> set (map fst (ops @ [a]))", "using snoc.IH"], ["proof (prove)\nusing this:\n  insertions (ops @ [a]) = insertions ops\n  set (map fst (insertions ops)) \\<subseteq> set (map fst ops)\n\ngoal (1 subgoal):\n 1. set (map fst (insertions (ops @ [a])))\n    \\<subseteq> set (map fst (ops @ [a]))", "by auto"], ["proof (state)\nthis:\n  set (map fst (insertions (ops @ [a])))\n  \\<subseteq> set (map fst (ops @ [a]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (map fst (insertions (ops @ [a])))\n  \\<subseteq> set (map fst (ops @ [a]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insertions_subset:\n  assumes \"list_ops A\" and \"list_ops B\"\n    and \"set A \\<subseteq> set B\"\n  shows \"set (insertions A) \\<subseteq> set (insertions B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (insertions A) \\<subseteq> set (insertions B)", "using assms"], ["proof (prove)\nusing this:\n  list_ops A\n  list_ops B\n  set A \\<subseteq> set B\n\ngoal (1 subgoal):\n 1. set (insertions A) \\<subseteq> set (insertions B)", "proof(induction B arbitrary: A rule: List.rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>list_ops A; list_ops []; set A \\<subseteq> set []\\<rbrakk>\n       \\<Longrightarrow> set (insertions A) \\<subseteq> set (insertions [])\n 2. \\<And>x xs A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>list_ops A; list_ops xs;\n                    set A \\<subseteq> set xs\\<rbrakk>\n                   \\<Longrightarrow> set (insertions A)\n                                     \\<subseteq> set (insertions xs);\n        list_ops A; list_ops (xs @ [x]);\n        set A \\<subseteq> set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> set (insertions A)\n                         \\<subseteq> set (insertions (xs @ [x]))", "case Nil"], ["proof (state)\nthis:\n  list_ops A\n  list_ops []\n  set A \\<subseteq> set []\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>list_ops A; list_ops []; set A \\<subseteq> set []\\<rbrakk>\n       \\<Longrightarrow> set (insertions A) \\<subseteq> set (insertions [])\n 2. \\<And>x xs A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>list_ops A; list_ops xs;\n                    set A \\<subseteq> set xs\\<rbrakk>\n                   \\<Longrightarrow> set (insertions A)\n                                     \\<subseteq> set (insertions xs);\n        list_ops A; list_ops (xs @ [x]);\n        set A \\<subseteq> set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> set (insertions A)\n                         \\<subseteq> set (insertions (xs @ [x]))", "then"], ["proof (chain)\npicking this:\n  list_ops A\n  list_ops []\n  set A \\<subseteq> set []", "show \"set (insertions A) \\<subseteq> set (insertions [])\""], ["proof (prove)\nusing this:\n  list_ops A\n  list_ops []\n  set A \\<subseteq> set []\n\ngoal (1 subgoal):\n 1. set (insertions A) \\<subseteq> set (insertions [])", "by (simp add: insertions_def map_filter_simps(2))"], ["proof (state)\nthis:\n  set (insertions A) \\<subseteq> set (insertions [])\n\ngoal (1 subgoal):\n 1. \\<And>x xs A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>list_ops A; list_ops xs;\n                    set A \\<subseteq> set xs\\<rbrakk>\n                   \\<Longrightarrow> set (insertions A)\n                                     \\<subseteq> set (insertions xs);\n        list_ops A; list_ops (xs @ [x]);\n        set A \\<subseteq> set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> set (insertions A)\n                         \\<subseteq> set (insertions (xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>list_ops A; list_ops xs;\n                    set A \\<subseteq> set xs\\<rbrakk>\n                   \\<Longrightarrow> set (insertions A)\n                                     \\<subseteq> set (insertions xs);\n        list_ops A; list_ops (xs @ [x]);\n        set A \\<subseteq> set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> set (insertions A)\n                         \\<subseteq> set (insertions (xs @ [x]))", "case (snoc a ops)"], ["proof (state)\nthis:\n  \\<lbrakk>list_ops ?A; list_ops ops; set ?A \\<subseteq> set ops\\<rbrakk>\n  \\<Longrightarrow> set (insertions ?A) \\<subseteq> set (insertions ops)\n  list_ops A\n  list_ops (ops @ [a])\n  set A \\<subseteq> set (ops @ [a])\n\ngoal (1 subgoal):\n 1. \\<And>x xs A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>list_ops A; list_ops xs;\n                    set A \\<subseteq> set xs\\<rbrakk>\n                   \\<Longrightarrow> set (insertions A)\n                                     \\<subseteq> set (insertions xs);\n        list_ops A; list_ops (xs @ [x]);\n        set A \\<subseteq> set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> set (insertions A)\n                         \\<subseteq> set (insertions (xs @ [x]))", "obtain oid oper where a_pair: \"a = (oid, oper)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>oid oper.\n        a = (oid, oper) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a = (oid, oper)\n\ngoal (1 subgoal):\n 1. \\<And>x xs A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>list_ops A; list_ops xs;\n                    set A \\<subseteq> set xs\\<rbrakk>\n                   \\<Longrightarrow> set (insertions A)\n                                     \\<subseteq> set (insertions xs);\n        list_ops A; list_ops (xs @ [x]);\n        set A \\<subseteq> set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> set (insertions A)\n                         \\<subseteq> set (insertions (xs @ [x]))", "have \"list_ops ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_ops ops", "using list_ops_def spec_ops_rem_last snoc.prems(2)"], ["proof (prove)\nusing this:\n  list_ops ?ops \\<equiv> spec_ops ?ops list_op_deps\n  spec_ops (?xs @ [?x]) ?deps \\<Longrightarrow> spec_ops ?xs ?deps\n  list_ops (ops @ [a])\n\ngoal (1 subgoal):\n 1. list_ops ops", "by blast"], ["proof (state)\nthis:\n  list_ops ops\n\ngoal (1 subgoal):\n 1. \\<And>x xs A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>list_ops A; list_ops xs;\n                    set A \\<subseteq> set xs\\<rbrakk>\n                   \\<Longrightarrow> set (insertions A)\n                                     \\<subseteq> set (insertions xs);\n        list_ops A; list_ops (xs @ [x]);\n        set A \\<subseteq> set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> set (insertions A)\n                         \\<subseteq> set (insertions (xs @ [x]))", "then"], ["proof (chain)\npicking this:\n  list_ops ops", "show \"set (insertions A) \\<subseteq> set (insertions (ops @ [a]))\""], ["proof (prove)\nusing this:\n  list_ops ops\n\ngoal (1 subgoal):\n 1. set (insertions A) \\<subseteq> set (insertions (ops @ [a]))", "proof(cases \"a \\<in> set A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>list_ops ops; a \\<in> set A\\<rbrakk>\n    \\<Longrightarrow> set (insertions A)\n                      \\<subseteq> set (insertions (ops @ [a]))\n 2. \\<lbrakk>list_ops ops; a \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> set (insertions A)\n                      \\<subseteq> set (insertions (ops @ [a]))", "case True"], ["proof (state)\nthis:\n  a \\<in> set A\n\ngoal (2 subgoals):\n 1. \\<lbrakk>list_ops ops; a \\<in> set A\\<rbrakk>\n    \\<Longrightarrow> set (insertions A)\n                      \\<subseteq> set (insertions (ops @ [a]))\n 2. \\<lbrakk>list_ops ops; a \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> set (insertions A)\n                      \\<subseteq> set (insertions (ops @ [a]))", "then"], ["proof (chain)\npicking this:\n  a \\<in> set A", "obtain as bs where A_split: \"A = as @ a # bs \\<and> a \\<notin> set as\""], ["proof (prove)\nusing this:\n  a \\<in> set A\n\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        A = as @ a # bs \\<and> a \\<notin> set as \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson split_list_first)"], ["proof (state)\nthis:\n  A = as @ a # bs \\<and> a \\<notin> set as\n\ngoal (2 subgoals):\n 1. \\<lbrakk>list_ops ops; a \\<in> set A\\<rbrakk>\n    \\<Longrightarrow> set (insertions A)\n                      \\<subseteq> set (insertions (ops @ [a]))\n 2. \\<lbrakk>list_ops ops; a \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> set (insertions A)\n                      \\<subseteq> set (insertions (ops @ [a]))", "hence \"remove1 a A = as @ bs\""], ["proof (prove)\nusing this:\n  A = as @ a # bs \\<and> a \\<notin> set as\n\ngoal (1 subgoal):\n 1. remove1 a A = as @ bs", "by (simp add: remove1_append)"], ["proof (state)\nthis:\n  remove1 a A = as @ bs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>list_ops ops; a \\<in> set A\\<rbrakk>\n    \\<Longrightarrow> set (insertions A)\n                      \\<subseteq> set (insertions (ops @ [a]))\n 2. \\<lbrakk>list_ops ops; a \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> set (insertions A)\n                      \\<subseteq> set (insertions (ops @ [a]))", "hence as_bs: \"insertions (remove1 a A) = insertions as @ insertions bs\""], ["proof (prove)\nusing this:\n  remove1 a A = as @ bs\n\ngoal (1 subgoal):\n 1. insertions (remove1 a A) = insertions as @ insertions bs", "by (simp add: insertions_def map_filter_append)"], ["proof (state)\nthis:\n  insertions (remove1 a A) = insertions as @ insertions bs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>list_ops ops; a \\<in> set A\\<rbrakk>\n    \\<Longrightarrow> set (insertions A)\n                      \\<subseteq> set (insertions (ops @ [a]))\n 2. \\<lbrakk>list_ops ops; a \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> set (insertions A)\n                      \\<subseteq> set (insertions (ops @ [a]))", "moreover"], ["proof (state)\nthis:\n  insertions (remove1 a A) = insertions as @ insertions bs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>list_ops ops; a \\<in> set A\\<rbrakk>\n    \\<Longrightarrow> set (insertions A)\n                      \\<subseteq> set (insertions (ops @ [a]))\n 2. \\<lbrakk>list_ops ops; a \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> set (insertions A)\n                      \\<subseteq> set (insertions (ops @ [a]))", "have \"A = as @ [a] @ bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = as @ [a] @ bs", "by (simp add: A_split)"], ["proof (state)\nthis:\n  A = as @ [a] @ bs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>list_ops ops; a \\<in> set A\\<rbrakk>\n    \\<Longrightarrow> set (insertions A)\n                      \\<subseteq> set (insertions (ops @ [a]))\n 2. \\<lbrakk>list_ops ops; a \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> set (insertions A)\n                      \\<subseteq> set (insertions (ops @ [a]))", "hence as_a_bs: \"insertions A = insertions as @ insertions [a] @ insertions bs\""], ["proof (prove)\nusing this:\n  A = as @ [a] @ bs\n\ngoal (1 subgoal):\n 1. insertions A = insertions as @ insertions [a] @ insertions bs", "by (metis insertions_def map_filter_append)"], ["proof (state)\nthis:\n  insertions A = insertions as @ insertions [a] @ insertions bs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>list_ops ops; a \\<in> set A\\<rbrakk>\n    \\<Longrightarrow> set (insertions A)\n                      \\<subseteq> set (insertions (ops @ [a]))\n 2. \\<lbrakk>list_ops ops; a \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> set (insertions A)\n                      \\<subseteq> set (insertions (ops @ [a]))", "moreover"], ["proof (state)\nthis:\n  insertions A = insertions as @ insertions [a] @ insertions bs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>list_ops ops; a \\<in> set A\\<rbrakk>\n    \\<Longrightarrow> set (insertions A)\n                      \\<subseteq> set (insertions (ops @ [a]))\n 2. \\<lbrakk>list_ops ops; a \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> set (insertions A)\n                      \\<subseteq> set (insertions (ops @ [a]))", "have IH: \"set (insertions (remove1 a A)) \\<subseteq> set (insertions ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (insertions (remove1 a A)) \\<subseteq> set (insertions ops)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (insertions (remove1 a A)) \\<subseteq> set (insertions ops)", "have \"list_ops (remove1 a A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_ops (remove1 a A)", "using snoc.prems(1) list_ops_def spec_ops_remove1"], ["proof (prove)\nusing this:\n  list_ops A\n  list_ops ?ops \\<equiv> spec_ops ?ops list_op_deps\n  spec_ops ?xs ?deps \\<Longrightarrow> spec_ops (remove1 ?x ?xs) ?deps\n\ngoal (1 subgoal):\n 1. list_ops (remove1 a A)", "by blast"], ["proof (state)\nthis:\n  list_ops (remove1 a A)\n\ngoal (1 subgoal):\n 1. set (insertions (remove1 a A)) \\<subseteq> set (insertions ops)", "moreover"], ["proof (state)\nthis:\n  list_ops (remove1 a A)\n\ngoal (1 subgoal):\n 1. set (insertions (remove1 a A)) \\<subseteq> set (insertions ops)", "have \"set (remove1 a A) \\<subseteq> set ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (remove1 a A) \\<subseteq> set ops", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (remove1 a A) \\<subseteq> set ops", "have \"distinct A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct A", "using snoc.prems(1) list_ops_def spec_ops_distinct"], ["proof (prove)\nusing this:\n  list_ops A\n  list_ops ?ops \\<equiv> spec_ops ?ops list_op_deps\n  spec_ops ?ops ?deps \\<Longrightarrow> distinct ?ops\n\ngoal (1 subgoal):\n 1. distinct A", "by blast"], ["proof (state)\nthis:\n  distinct A\n\ngoal (1 subgoal):\n 1. set (remove1 a A) \\<subseteq> set ops", "hence \"a \\<notin> set (remove1 a A)\""], ["proof (prove)\nusing this:\n  distinct A\n\ngoal (1 subgoal):\n 1. a \\<notin> set (remove1 a A)", "by auto"], ["proof (state)\nthis:\n  a \\<notin> set (remove1 a A)\n\ngoal (1 subgoal):\n 1. set (remove1 a A) \\<subseteq> set ops", "moreover"], ["proof (state)\nthis:\n  a \\<notin> set (remove1 a A)\n\ngoal (1 subgoal):\n 1. set (remove1 a A) \\<subseteq> set ops", "have \"set (ops @ [a]) = set ops \\<union> {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ops @ [a]) = set ops \\<union> {a}", "by auto"], ["proof (state)\nthis:\n  set (ops @ [a]) = set ops \\<union> {a}\n\ngoal (1 subgoal):\n 1. set (remove1 a A) \\<subseteq> set ops", "moreover"], ["proof (state)\nthis:\n  set (ops @ [a]) = set ops \\<union> {a}\n\ngoal (1 subgoal):\n 1. set (remove1 a A) \\<subseteq> set ops", "have \"set (remove1 a A) \\<subseteq> set A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (remove1 a A) \\<subseteq> set A", "by (simp add: set_remove1_subset)"], ["proof (state)\nthis:\n  set (remove1 a A) \\<subseteq> set A\n\ngoal (1 subgoal):\n 1. set (remove1 a A) \\<subseteq> set ops", "ultimately"], ["proof (chain)\npicking this:\n  a \\<notin> set (remove1 a A)\n  set (ops @ [a]) = set ops \\<union> {a}\n  set (remove1 a A) \\<subseteq> set A", "show \"set (remove1 a A) \\<subseteq> set ops\""], ["proof (prove)\nusing this:\n  a \\<notin> set (remove1 a A)\n  set (ops @ [a]) = set ops \\<union> {a}\n  set (remove1 a A) \\<subseteq> set A\n\ngoal (1 subgoal):\n 1. set (remove1 a A) \\<subseteq> set ops", "using snoc.prems(3)"], ["proof (prove)\nusing this:\n  a \\<notin> set (remove1 a A)\n  set (ops @ [a]) = set ops \\<union> {a}\n  set (remove1 a A) \\<subseteq> set A\n  set A \\<subseteq> set (ops @ [a])\n\ngoal (1 subgoal):\n 1. set (remove1 a A) \\<subseteq> set ops", "by blast"], ["proof (state)\nthis:\n  set (remove1 a A) \\<subseteq> set ops\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (remove1 a A) \\<subseteq> set ops\n\ngoal (1 subgoal):\n 1. set (insertions (remove1 a A)) \\<subseteq> set (insertions ops)", "ultimately"], ["proof (chain)\npicking this:\n  list_ops (remove1 a A)\n  set (remove1 a A) \\<subseteq> set ops", "show ?thesis"], ["proof (prove)\nusing this:\n  list_ops (remove1 a A)\n  set (remove1 a A) \\<subseteq> set ops\n\ngoal (1 subgoal):\n 1. set (insertions (remove1 a A)) \\<subseteq> set (insertions ops)", "by (simp add: \\<open>list_ops ops\\<close> snoc.IH)"], ["proof (state)\nthis:\n  set (insertions (remove1 a A)) \\<subseteq> set (insertions ops)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (insertions (remove1 a A)) \\<subseteq> set (insertions ops)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>list_ops ops; a \\<in> set A\\<rbrakk>\n    \\<Longrightarrow> set (insertions A)\n                      \\<subseteq> set (insertions (ops @ [a]))\n 2. \\<lbrakk>list_ops ops; a \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> set (insertions A)\n                      \\<subseteq> set (insertions (ops @ [a]))", "ultimately"], ["proof (chain)\npicking this:\n  insertions (remove1 a A) = insertions as @ insertions bs\n  insertions A = insertions as @ insertions [a] @ insertions bs\n  set (insertions (remove1 a A)) \\<subseteq> set (insertions ops)", "show ?thesis"], ["proof (prove)\nusing this:\n  insertions (remove1 a A) = insertions as @ insertions bs\n  insertions A = insertions as @ insertions [a] @ insertions bs\n  set (insertions (remove1 a A)) \\<subseteq> set (insertions ops)\n\ngoal (1 subgoal):\n 1. set (insertions A) \\<subseteq> set (insertions (ops @ [a]))", "proof(cases oper)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>insertions (remove1 a A) = insertions as @ insertions bs;\n        insertions A = insertions as @ insertions [a] @ insertions bs;\n        set (insertions (remove1 a A)) \\<subseteq> set (insertions ops);\n        oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> set (insertions A)\n                         \\<subseteq> set (insertions (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>insertions (remove1 a A) = insertions as @ insertions bs;\n        insertions A = insertions as @ insertions [a] @ insertions bs;\n        set (insertions (remove1 a A)) \\<subseteq> set (insertions ops);\n        oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> set (insertions A)\n                         \\<subseteq> set (insertions (ops @ [a]))", "case (Insert ref val)"], ["proof (state)\nthis:\n  oper = Insert ref val\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>insertions (remove1 a A) = insertions as @ insertions bs;\n        insertions A = insertions as @ insertions [a] @ insertions bs;\n        set (insertions (remove1 a A)) \\<subseteq> set (insertions ops);\n        oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> set (insertions A)\n                         \\<subseteq> set (insertions (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>insertions (remove1 a A) = insertions as @ insertions bs;\n        insertions A = insertions as @ insertions [a] @ insertions bs;\n        set (insertions (remove1 a A)) \\<subseteq> set (insertions ops);\n        oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> set (insertions A)\n                         \\<subseteq> set (insertions (ops @ [a]))", "hence \"insertions [a] = [(oid, ref)]\""], ["proof (prove)\nusing this:\n  oper = Insert ref val\n\ngoal (1 subgoal):\n 1. insertions [a] = [(oid, ref)]", "by (simp add: insertions_def map_filter_Some a_pair)"], ["proof (state)\nthis:\n  insertions [a] = [(oid, ref)]\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>insertions (remove1 a A) = insertions as @ insertions bs;\n        insertions A = insertions as @ insertions [a] @ insertions bs;\n        set (insertions (remove1 a A)) \\<subseteq> set (insertions ops);\n        oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> set (insertions A)\n                         \\<subseteq> set (insertions (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>insertions (remove1 a A) = insertions as @ insertions bs;\n        insertions A = insertions as @ insertions [a] @ insertions bs;\n        set (insertions (remove1 a A)) \\<subseteq> set (insertions ops);\n        oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> set (insertions A)\n                         \\<subseteq> set (insertions (ops @ [a]))", "hence \"set (insertions A) = set (insertions (remove1 a A)) \\<union> {(oid, ref)}\""], ["proof (prove)\nusing this:\n  insertions [a] = [(oid, ref)]\n\ngoal (1 subgoal):\n 1. set (insertions A) =\n    set (insertions (remove1 a A)) \\<union> {(oid, ref)}", "using as_a_bs as_bs"], ["proof (prove)\nusing this:\n  insertions [a] = [(oid, ref)]\n  insertions A = insertions as @ insertions [a] @ insertions bs\n  insertions (remove1 a A) = insertions as @ insertions bs\n\ngoal (1 subgoal):\n 1. set (insertions A) =\n    set (insertions (remove1 a A)) \\<union> {(oid, ref)}", "by auto"], ["proof (state)\nthis:\n  set (insertions A) = set (insertions (remove1 a A)) \\<union> {(oid, ref)}\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>insertions (remove1 a A) = insertions as @ insertions bs;\n        insertions A = insertions as @ insertions [a] @ insertions bs;\n        set (insertions (remove1 a A)) \\<subseteq> set (insertions ops);\n        oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> set (insertions A)\n                         \\<subseteq> set (insertions (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>insertions (remove1 a A) = insertions as @ insertions bs;\n        insertions A = insertions as @ insertions [a] @ insertions bs;\n        set (insertions (remove1 a A)) \\<subseteq> set (insertions ops);\n        oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> set (insertions A)\n                         \\<subseteq> set (insertions (ops @ [a]))", "moreover"], ["proof (state)\nthis:\n  set (insertions A) = set (insertions (remove1 a A)) \\<union> {(oid, ref)}\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>insertions (remove1 a A) = insertions as @ insertions bs;\n        insertions A = insertions as @ insertions [a] @ insertions bs;\n        set (insertions (remove1 a A)) \\<subseteq> set (insertions ops);\n        oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> set (insertions A)\n                         \\<subseteq> set (insertions (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>insertions (remove1 a A) = insertions as @ insertions bs;\n        insertions A = insertions as @ insertions [a] @ insertions bs;\n        set (insertions (remove1 a A)) \\<subseteq> set (insertions ops);\n        oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> set (insertions A)\n                         \\<subseteq> set (insertions (ops @ [a]))", "have \"set (insertions (ops @ [a])) = set (insertions ops) \\<union> {(oid, ref)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (insertions (ops @ [a])) =\n    set (insertions ops) \\<union> {(oid, ref)}", "by (simp add: Insert a_pair insertions_last_ins)"], ["proof (state)\nthis:\n  set (insertions (ops @ [a])) = set (insertions ops) \\<union> {(oid, ref)}\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>insertions (remove1 a A) = insertions as @ insertions bs;\n        insertions A = insertions as @ insertions [a] @ insertions bs;\n        set (insertions (remove1 a A)) \\<subseteq> set (insertions ops);\n        oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> set (insertions A)\n                         \\<subseteq> set (insertions (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>insertions (remove1 a A) = insertions as @ insertions bs;\n        insertions A = insertions as @ insertions [a] @ insertions bs;\n        set (insertions (remove1 a A)) \\<subseteq> set (insertions ops);\n        oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> set (insertions A)\n                         \\<subseteq> set (insertions (ops @ [a]))", "ultimately"], ["proof (chain)\npicking this:\n  set (insertions A) = set (insertions (remove1 a A)) \\<union> {(oid, ref)}\n  set (insertions (ops @ [a])) = set (insertions ops) \\<union> {(oid, ref)}", "show ?thesis"], ["proof (prove)\nusing this:\n  set (insertions A) = set (insertions (remove1 a A)) \\<union> {(oid, ref)}\n  set (insertions (ops @ [a])) = set (insertions ops) \\<union> {(oid, ref)}\n\ngoal (1 subgoal):\n 1. set (insertions A) \\<subseteq> set (insertions (ops @ [a]))", "using IH"], ["proof (prove)\nusing this:\n  set (insertions A) = set (insertions (remove1 a A)) \\<union> {(oid, ref)}\n  set (insertions (ops @ [a])) = set (insertions ops) \\<union> {(oid, ref)}\n  set (insertions (remove1 a A)) \\<subseteq> set (insertions ops)\n\ngoal (1 subgoal):\n 1. set (insertions A) \\<subseteq> set (insertions (ops @ [a]))", "by auto"], ["proof (state)\nthis:\n  set (insertions A) \\<subseteq> set (insertions (ops @ [a]))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>insertions (remove1 a A) = insertions as @ insertions bs;\n        insertions A = insertions as @ insertions [a] @ insertions bs;\n        set (insertions (remove1 a A)) \\<subseteq> set (insertions ops);\n        oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> set (insertions A)\n                         \\<subseteq> set (insertions (ops @ [a]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>insertions (remove1 a A) = insertions as @ insertions bs;\n        insertions A = insertions as @ insertions [a] @ insertions bs;\n        set (insertions (remove1 a A)) \\<subseteq> set (insertions ops);\n        oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> set (insertions A)\n                         \\<subseteq> set (insertions (ops @ [a]))", "case (Delete ref)"], ["proof (state)\nthis:\n  oper = Delete ref\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>insertions (remove1 a A) = insertions as @ insertions bs;\n        insertions A = insertions as @ insertions [a] @ insertions bs;\n        set (insertions (remove1 a A)) \\<subseteq> set (insertions ops);\n        oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> set (insertions A)\n                         \\<subseteq> set (insertions (ops @ [a]))", "hence \"insertions [a] = []\""], ["proof (prove)\nusing this:\n  oper = Delete ref\n\ngoal (1 subgoal):\n 1. insertions [a] = []", "by (simp add: insertions_def map_filter_None a_pair)"], ["proof (state)\nthis:\n  insertions [a] = []\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>insertions (remove1 a A) = insertions as @ insertions bs;\n        insertions A = insertions as @ insertions [a] @ insertions bs;\n        set (insertions (remove1 a A)) \\<subseteq> set (insertions ops);\n        oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> set (insertions A)\n                         \\<subseteq> set (insertions (ops @ [a]))", "hence \"set (insertions A) = set (insertions (remove1 a A))\""], ["proof (prove)\nusing this:\n  insertions [a] = []\n\ngoal (1 subgoal):\n 1. set (insertions A) = set (insertions (remove1 a A))", "using as_a_bs as_bs"], ["proof (prove)\nusing this:\n  insertions [a] = []\n  insertions A = insertions as @ insertions [a] @ insertions bs\n  insertions (remove1 a A) = insertions as @ insertions bs\n\ngoal (1 subgoal):\n 1. set (insertions A) = set (insertions (remove1 a A))", "by auto"], ["proof (state)\nthis:\n  set (insertions A) = set (insertions (remove1 a A))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>insertions (remove1 a A) = insertions as @ insertions bs;\n        insertions A = insertions as @ insertions [a] @ insertions bs;\n        set (insertions (remove1 a A)) \\<subseteq> set (insertions ops);\n        oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> set (insertions A)\n                         \\<subseteq> set (insertions (ops @ [a]))", "moreover"], ["proof (state)\nthis:\n  set (insertions A) = set (insertions (remove1 a A))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>insertions (remove1 a A) = insertions as @ insertions bs;\n        insertions A = insertions as @ insertions [a] @ insertions bs;\n        set (insertions (remove1 a A)) \\<subseteq> set (insertions ops);\n        oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> set (insertions A)\n                         \\<subseteq> set (insertions (ops @ [a]))", "have \"set (insertions (ops @ [a])) = set (insertions ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (insertions (ops @ [a])) = set (insertions ops)", "by (simp add: Delete a_pair insertions_last_del)"], ["proof (state)\nthis:\n  set (insertions (ops @ [a])) = set (insertions ops)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>insertions (remove1 a A) = insertions as @ insertions bs;\n        insertions A = insertions as @ insertions [a] @ insertions bs;\n        set (insertions (remove1 a A)) \\<subseteq> set (insertions ops);\n        oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> set (insertions A)\n                         \\<subseteq> set (insertions (ops @ [a]))", "ultimately"], ["proof (chain)\npicking this:\n  set (insertions A) = set (insertions (remove1 a A))\n  set (insertions (ops @ [a])) = set (insertions ops)", "show ?thesis"], ["proof (prove)\nusing this:\n  set (insertions A) = set (insertions (remove1 a A))\n  set (insertions (ops @ [a])) = set (insertions ops)\n\ngoal (1 subgoal):\n 1. set (insertions A) \\<subseteq> set (insertions (ops @ [a]))", "using IH"], ["proof (prove)\nusing this:\n  set (insertions A) = set (insertions (remove1 a A))\n  set (insertions (ops @ [a])) = set (insertions ops)\n  set (insertions (remove1 a A)) \\<subseteq> set (insertions ops)\n\ngoal (1 subgoal):\n 1. set (insertions A) \\<subseteq> set (insertions (ops @ [a]))", "by auto"], ["proof (state)\nthis:\n  set (insertions A) \\<subseteq> set (insertions (ops @ [a]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (insertions A) \\<subseteq> set (insertions (ops @ [a]))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>list_ops ops; a \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> set (insertions A)\n                      \\<subseteq> set (insertions (ops @ [a]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_ops ops; a \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> set (insertions A)\n                      \\<subseteq> set (insertions (ops @ [a]))", "case False"], ["proof (state)\nthis:\n  a \\<notin> set A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>list_ops ops; a \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> set (insertions A)\n                      \\<subseteq> set (insertions (ops @ [a]))", "hence \"set A \\<subseteq> set ops\""], ["proof (prove)\nusing this:\n  a \\<notin> set A\n\ngoal (1 subgoal):\n 1. set A \\<subseteq> set ops", "using DiffE snoc.prems"], ["proof (prove)\nusing this:\n  a \\<notin> set A\n  \\<lbrakk>?c \\<in> ?A - ?B;\n   \\<lbrakk>?c \\<in> ?A; ?c \\<notin> ?B\\<rbrakk>\n   \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  list_ops A\n  list_ops (ops @ [a])\n  set A \\<subseteq> set (ops @ [a])\n\ngoal (1 subgoal):\n 1. set A \\<subseteq> set ops", "by auto"], ["proof (state)\nthis:\n  set A \\<subseteq> set ops\n\ngoal (1 subgoal):\n 1. \\<lbrakk>list_ops ops; a \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> set (insertions A)\n                      \\<subseteq> set (insertions (ops @ [a]))", "hence \"set (insertions A) \\<subseteq> set (insertions ops)\""], ["proof (prove)\nusing this:\n  set A \\<subseteq> set ops\n\ngoal (1 subgoal):\n 1. set (insertions A) \\<subseteq> set (insertions ops)", "using snoc.IH snoc.prems(1) \\<open>list_ops ops\\<close>"], ["proof (prove)\nusing this:\n  set A \\<subseteq> set ops\n  \\<lbrakk>list_ops ?A; list_ops ops; set ?A \\<subseteq> set ops\\<rbrakk>\n  \\<Longrightarrow> set (insertions ?A) \\<subseteq> set (insertions ops)\n  list_ops A\n  list_ops ops\n\ngoal (1 subgoal):\n 1. set (insertions A) \\<subseteq> set (insertions ops)", "by blast"], ["proof (state)\nthis:\n  set (insertions A) \\<subseteq> set (insertions ops)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>list_ops ops; a \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> set (insertions A)\n                      \\<subseteq> set (insertions (ops @ [a]))", "moreover"], ["proof (state)\nthis:\n  set (insertions A) \\<subseteq> set (insertions ops)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>list_ops ops; a \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> set (insertions A)\n                      \\<subseteq> set (insertions (ops @ [a]))", "have \"set (insertions ops) \\<subseteq> set (insertions (ops @ [a]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (insertions ops) \\<subseteq> set (insertions (ops @ [a]))", "by (simp add: insertions_def map_filter_append)"], ["proof (state)\nthis:\n  set (insertions ops) \\<subseteq> set (insertions (ops @ [a]))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>list_ops ops; a \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> set (insertions A)\n                      \\<subseteq> set (insertions (ops @ [a]))", "ultimately"], ["proof (chain)\npicking this:\n  set (insertions A) \\<subseteq> set (insertions ops)\n  set (insertions ops) \\<subseteq> set (insertions (ops @ [a]))", "show ?thesis"], ["proof (prove)\nusing this:\n  set (insertions A) \\<subseteq> set (insertions ops)\n  set (insertions ops) \\<subseteq> set (insertions (ops @ [a]))\n\ngoal (1 subgoal):\n 1. set (insertions A) \\<subseteq> set (insertions (ops @ [a]))", "by blast"], ["proof (state)\nthis:\n  set (insertions A) \\<subseteq> set (insertions (ops @ [a]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (insertions A) \\<subseteq> set (insertions (ops @ [a]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_ops_insertions:\n  assumes \"list_ops ops\"\n  shows \"insert_ops (insertions ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_ops (insertions ops)", "using assms"], ["proof (prove)\nusing this:\n  list_ops ops\n\ngoal (1 subgoal):\n 1. insert_ops (insertions ops)", "proof(induction ops rule: List.rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. list_ops [] \\<Longrightarrow> insert_ops (insertions [])\n 2. \\<And>x xs.\n       \\<lbrakk>list_ops xs \\<Longrightarrow> insert_ops (insertions xs);\n        list_ops (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> insert_ops (insertions (xs @ [x]))", "case Nil"], ["proof (state)\nthis:\n  list_ops []\n\ngoal (2 subgoals):\n 1. list_ops [] \\<Longrightarrow> insert_ops (insertions [])\n 2. \\<And>x xs.\n       \\<lbrakk>list_ops xs \\<Longrightarrow> insert_ops (insertions xs);\n        list_ops (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> insert_ops (insertions (xs @ [x]))", "then"], ["proof (chain)\npicking this:\n  list_ops []", "show \"insert_ops (insertions [])\""], ["proof (prove)\nusing this:\n  list_ops []\n\ngoal (1 subgoal):\n 1. insert_ops (insertions [])", "by (simp add: insert_ops_def spec_ops_def insertions_def map_filter_def)"], ["proof (state)\nthis:\n  insert_ops (insertions [])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>list_ops xs \\<Longrightarrow> insert_ops (insertions xs);\n        list_ops (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> insert_ops (insertions (xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>list_ops xs \\<Longrightarrow> insert_ops (insertions xs);\n        list_ops (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> insert_ops (insertions (xs @ [x]))", "case (snoc a ops)"], ["proof (state)\nthis:\n  list_ops ops \\<Longrightarrow> insert_ops (insertions ops)\n  list_ops (ops @ [a])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>list_ops xs \\<Longrightarrow> insert_ops (insertions xs);\n        list_ops (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> insert_ops (insertions (xs @ [x]))", "hence IH: \"insert_ops (insertions ops)\""], ["proof (prove)\nusing this:\n  list_ops ops \\<Longrightarrow> insert_ops (insertions ops)\n  list_ops (ops @ [a])\n\ngoal (1 subgoal):\n 1. insert_ops (insertions ops)", "using list_ops_def spec_ops_rem_last"], ["proof (prove)\nusing this:\n  list_ops ops \\<Longrightarrow> insert_ops (insertions ops)\n  list_ops (ops @ [a])\n  list_ops ?ops \\<equiv> spec_ops ?ops list_op_deps\n  spec_ops (?xs @ [?x]) ?deps \\<Longrightarrow> spec_ops ?xs ?deps\n\ngoal (1 subgoal):\n 1. insert_ops (insertions ops)", "by blast"], ["proof (state)\nthis:\n  insert_ops (insertions ops)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>list_ops xs \\<Longrightarrow> insert_ops (insertions xs);\n        list_ops (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> insert_ops (insertions (xs @ [x]))", "obtain oid oper where a_pair: \"a = (oid, oper)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>oid oper.\n        a = (oid, oper) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a = (oid, oper)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>list_ops xs \\<Longrightarrow> insert_ops (insertions xs);\n        list_ops (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> insert_ops (insertions (xs @ [x]))", "then"], ["proof (chain)\npicking this:\n  a = (oid, oper)", "show \"insert_ops (insertions (ops @ [a]))\""], ["proof (prove)\nusing this:\n  a = (oid, oper)\n\ngoal (1 subgoal):\n 1. insert_ops (insertions (ops @ [a]))", "proof(cases oper)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>a = (oid, oper); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> insert_ops (insertions (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> insert_ops (insertions (ops @ [a]))", "case (Insert ref val)"], ["proof (state)\nthis:\n  oper = Insert ref val\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>a = (oid, oper); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> insert_ops (insertions (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> insert_ops (insertions (ops @ [a]))", "hence \"insertions (ops @ [a]) = insertions ops @ [(oid, ref)]\""], ["proof (prove)\nusing this:\n  oper = Insert ref val\n\ngoal (1 subgoal):\n 1. insertions (ops @ [a]) = insertions ops @ [(oid, ref)]", "by (simp add: a_pair insertions_last_ins)"], ["proof (state)\nthis:\n  insertions (ops @ [a]) = insertions ops @ [(oid, ref)]\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>a = (oid, oper); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> insert_ops (insertions (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> insert_ops (insertions (ops @ [a]))", "moreover"], ["proof (state)\nthis:\n  insertions (ops @ [a]) = insertions ops @ [(oid, ref)]\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>a = (oid, oper); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> insert_ops (insertions (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> insert_ops (insertions (ops @ [a]))", "have \"\\<And>i. i \\<in> set (map fst ops) \\<Longrightarrow> i < oid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> set (map fst ops) \\<Longrightarrow> i < oid", "using a_pair list_ops_def snoc.prems spec_ops_id_inc"], ["proof (prove)\nusing this:\n  a = (oid, oper)\n  list_ops ?ops \\<equiv> spec_ops ?ops list_op_deps\n  list_ops (ops @ [a])\n  \\<lbrakk>spec_ops (?xs @ [(?oid, ?oper)]) ?deps;\n   ?x \\<in> set (map fst ?xs)\\<rbrakk>\n  \\<Longrightarrow> ?x < ?oid\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> set (map fst ops) \\<Longrightarrow> i < oid", "by fastforce"], ["proof (state)\nthis:\n  ?i \\<in> set (map fst ops) \\<Longrightarrow> ?i < oid\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>a = (oid, oper); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> insert_ops (insertions (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> insert_ops (insertions (ops @ [a]))", "hence \"\\<And>i. i \\<in> set (map fst (insertions ops)) \\<Longrightarrow> i < oid\""], ["proof (prove)\nusing this:\n  ?i \\<in> set (map fst ops) \\<Longrightarrow> ?i < oid\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> set (map fst (insertions ops)) \\<Longrightarrow> i < oid", "using insertions_fst_subset"], ["proof (prove)\nusing this:\n  ?i \\<in> set (map fst ops) \\<Longrightarrow> ?i < oid\n  set (map fst (insertions ?ops)) \\<subseteq> set (map fst ?ops)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> set (map fst (insertions ops)) \\<Longrightarrow> i < oid", "by blast"], ["proof (state)\nthis:\n  ?i \\<in> set (map fst (insertions ops)) \\<Longrightarrow> ?i < oid\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>a = (oid, oper); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> insert_ops (insertions (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> insert_ops (insertions (ops @ [a]))", "moreover"], ["proof (state)\nthis:\n  ?i \\<in> set (map fst (insertions ops)) \\<Longrightarrow> ?i < oid\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>a = (oid, oper); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> insert_ops (insertions (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> insert_ops (insertions (ops @ [a]))", "have \"list_op_deps oper = set_option ref\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_op_deps oper = set_option ref", "using Insert"], ["proof (prove)\nusing this:\n  oper = Insert ref val\n\ngoal (1 subgoal):\n 1. list_op_deps oper = set_option ref", "by (cases ref, auto)"], ["proof (state)\nthis:\n  list_op_deps oper = set_option ref\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>a = (oid, oper); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> insert_ops (insertions (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> insert_ops (insertions (ops @ [a]))", "hence \"\\<And>r. r \\<in> set_option ref \\<Longrightarrow> r < oid\""], ["proof (prove)\nusing this:\n  list_op_deps oper = set_option ref\n\ngoal (1 subgoal):\n 1. \\<And>r. r \\<in> set_option ref \\<Longrightarrow> r < oid", "using list_ops_def spec_ops_ref_less"], ["proof (prove)\nusing this:\n  list_op_deps oper = set_option ref\n  list_ops ?ops \\<equiv> spec_ops ?ops list_op_deps\n  \\<lbrakk>spec_ops ?xs ?deps; (?oid, ?oper) \\<in> set ?xs;\n   ?r \\<in> ?deps ?oper\\<rbrakk>\n  \\<Longrightarrow> ?r < ?oid\n\ngoal (1 subgoal):\n 1. \\<And>r. r \\<in> set_option ref \\<Longrightarrow> r < oid", "by (metis a_pair last_in_set snoc.prems snoc_eq_iff_butlast)"], ["proof (state)\nthis:\n  ?r \\<in> set_option ref \\<Longrightarrow> ?r < oid\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>a = (oid, oper); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> insert_ops (insertions (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> insert_ops (insertions (ops @ [a]))", "ultimately"], ["proof (chain)\npicking this:\n  insertions (ops @ [a]) = insertions ops @ [(oid, ref)]\n  ?i \\<in> set (map fst (insertions ops)) \\<Longrightarrow> ?i < oid\n  ?r \\<in> set_option ref \\<Longrightarrow> ?r < oid", "show ?thesis"], ["proof (prove)\nusing this:\n  insertions (ops @ [a]) = insertions ops @ [(oid, ref)]\n  ?i \\<in> set (map fst (insertions ops)) \\<Longrightarrow> ?i < oid\n  ?r \\<in> set_option ref \\<Longrightarrow> ?r < oid\n\ngoal (1 subgoal):\n 1. insert_ops (insertions (ops @ [a]))", "using IH insert_ops_def spec_ops_add_last"], ["proof (prove)\nusing this:\n  insertions (ops @ [a]) = insertions ops @ [(oid, ref)]\n  ?i \\<in> set (map fst (insertions ops)) \\<Longrightarrow> ?i < oid\n  ?r \\<in> set_option ref \\<Longrightarrow> ?r < oid\n  insert_ops (insertions ops)\n  insert_ops ?list \\<equiv> spec_ops ?list set_option\n  \\<lbrakk>spec_ops ?xs ?deps; \\<forall>i\\<in>set (map fst ?xs). i < ?oid;\n   \\<forall>ref\\<in>?deps ?oper. ref < ?oid\\<rbrakk>\n  \\<Longrightarrow> spec_ops (?xs @ [(?oid, ?oper)]) ?deps\n\ngoal (1 subgoal):\n 1. insert_ops (insertions (ops @ [a]))", "by metis"], ["proof (state)\nthis:\n  insert_ops (insertions (ops @ [a]))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> insert_ops (insertions (ops @ [a]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> insert_ops (insertions (ops @ [a]))", "case (Delete ref)"], ["proof (state)\nthis:\n  oper = Delete ref\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> insert_ops (insertions (ops @ [a]))", "hence \"insertions (ops @ [a]) = insertions ops\""], ["proof (prove)\nusing this:\n  oper = Delete ref\n\ngoal (1 subgoal):\n 1. insertions (ops @ [a]) = insertions ops", "by (simp add: a_pair insertions_last_del)"], ["proof (state)\nthis:\n  insertions (ops @ [a]) = insertions ops\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> insert_ops (insertions (ops @ [a]))", "then"], ["proof (chain)\npicking this:\n  insertions (ops @ [a]) = insertions ops", "show ?thesis"], ["proof (prove)\nusing this:\n  insertions (ops @ [a]) = insertions ops\n\ngoal (1 subgoal):\n 1. insert_ops (insertions (ops @ [a]))", "by (simp add: IH)"], ["proof (state)\nthis:\n  insert_ops (insertions (ops @ [a]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  insert_ops (insertions (ops @ [a]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inserted_ids_last_ins:\n  shows \"inserted_ids (xs @ [(oid, Insert ref val)]) = inserted_ids xs @ [oid]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inserted_ids (xs @ [(oid, Insert ref val)]) = inserted_ids xs @ [oid]", "by (simp add: inserted_ids_def map_filter_Some map_filter_append)"], ["", "lemma inserted_ids_last_del:\n  shows \"inserted_ids (xs @ [(oid, Delete ref)]) = inserted_ids xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inserted_ids (xs @ [(oid, Delete ref)]) = inserted_ids xs", "by (simp add: inserted_ids_def map_filter_None map_filter_append)"], ["", "lemma inserted_ids_exist:\n  shows \"oid \\<in> set (inserted_ids ops) \\<longleftrightarrow> (\\<exists>ref val. (oid, Insert ref val) \\<in> set ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (oid \\<in> set (inserted_ids ops)) =\n    (\\<exists>ref val. (oid, Insert ref val) \\<in> set ops)", "proof(induction ops rule: List.rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. (oid \\<in> set (inserted_ids [])) =\n    (\\<exists>ref val. (oid, Insert ref val) \\<in> set [])\n 2. \\<And>x xs.\n       (oid \\<in> set (inserted_ids xs)) =\n       (\\<exists>ref val.\n           (oid, Insert ref val) \\<in> set xs) \\<Longrightarrow>\n       (oid \\<in> set (inserted_ids (xs @ [x]))) =\n       (\\<exists>ref val. (oid, Insert ref val) \\<in> set (xs @ [x]))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (oid \\<in> set (inserted_ids [])) =\n    (\\<exists>ref val. (oid, Insert ref val) \\<in> set [])\n 2. \\<And>x xs.\n       (oid \\<in> set (inserted_ids xs)) =\n       (\\<exists>ref val.\n           (oid, Insert ref val) \\<in> set xs) \\<Longrightarrow>\n       (oid \\<in> set (inserted_ids (xs @ [x]))) =\n       (\\<exists>ref val. (oid, Insert ref val) \\<in> set (xs @ [x]))", "then"], ["proof (chain)\npicking this:", "show \"oid \\<in> set (inserted_ids []) \\<longleftrightarrow> (\\<exists>ref val. (oid, Insert ref val) \\<in> set [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (oid \\<in> set (inserted_ids [])) =\n    (\\<exists>ref val. (oid, Insert ref val) \\<in> set [])", "by (simp add: inserted_ids_def List.map_filter_def)"], ["proof (state)\nthis:\n  (oid \\<in> set (inserted_ids [])) =\n  (\\<exists>ref val. (oid, Insert ref val) \\<in> set [])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       (oid \\<in> set (inserted_ids xs)) =\n       (\\<exists>ref val.\n           (oid, Insert ref val) \\<in> set xs) \\<Longrightarrow>\n       (oid \\<in> set (inserted_ids (xs @ [x]))) =\n       (\\<exists>ref val. (oid, Insert ref val) \\<in> set (xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       (oid \\<in> set (inserted_ids xs)) =\n       (\\<exists>ref val.\n           (oid, Insert ref val) \\<in> set xs) \\<Longrightarrow>\n       (oid \\<in> set (inserted_ids (xs @ [x]))) =\n       (\\<exists>ref val. (oid, Insert ref val) \\<in> set (xs @ [x]))", "case (snoc a ops)"], ["proof (state)\nthis:\n  (oid \\<in> set (inserted_ids ops)) =\n  (\\<exists>ref val. (oid, Insert ref val) \\<in> set ops)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       (oid \\<in> set (inserted_ids xs)) =\n       (\\<exists>ref val.\n           (oid, Insert ref val) \\<in> set xs) \\<Longrightarrow>\n       (oid \\<in> set (inserted_ids (xs @ [x]))) =\n       (\\<exists>ref val. (oid, Insert ref val) \\<in> set (xs @ [x]))", "obtain i oper where a_pair: \"a = (i, oper)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i oper. a = (i, oper) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a = (i, oper)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       (oid \\<in> set (inserted_ids xs)) =\n       (\\<exists>ref val.\n           (oid, Insert ref val) \\<in> set xs) \\<Longrightarrow>\n       (oid \\<in> set (inserted_ids (xs @ [x]))) =\n       (\\<exists>ref val. (oid, Insert ref val) \\<in> set (xs @ [x]))", "then"], ["proof (chain)\npicking this:\n  a = (i, oper)", "show \"oid \\<in> set (inserted_ids (ops @ [a])) \\<longleftrightarrow>\n             (\\<exists>ref val. (oid, Insert ref val) \\<in> set (ops @ [a]))\""], ["proof (prove)\nusing this:\n  a = (i, oper)\n\ngoal (1 subgoal):\n 1. (oid \\<in> set (inserted_ids (ops @ [a]))) =\n    (\\<exists>ref val. (oid, Insert ref val) \\<in> set (ops @ [a]))", "proof(cases oper)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>a = (i, oper); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> (oid \\<in> set (inserted_ids (ops @ [a]))) =\n                         (\\<exists>ref val.\n                             (oid, Insert ref val) \\<in> set (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>a = (i, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> (oid \\<in> set (inserted_ids (ops @ [a]))) =\n                         (\\<exists>ref val.\n                             (oid, Insert ref val) \\<in> set (ops @ [a]))", "case (Insert r v)"], ["proof (state)\nthis:\n  oper = Insert r v\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>a = (i, oper); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> (oid \\<in> set (inserted_ids (ops @ [a]))) =\n                         (\\<exists>ref val.\n                             (oid, Insert ref val) \\<in> set (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>a = (i, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> (oid \\<in> set (inserted_ids (ops @ [a]))) =\n                         (\\<exists>ref val.\n                             (oid, Insert ref val) \\<in> set (ops @ [a]))", "moreover"], ["proof (state)\nthis:\n  oper = Insert r v\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>a = (i, oper); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> (oid \\<in> set (inserted_ids (ops @ [a]))) =\n                         (\\<exists>ref val.\n                             (oid, Insert ref val) \\<in> set (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>a = (i, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> (oid \\<in> set (inserted_ids (ops @ [a]))) =\n                         (\\<exists>ref val.\n                             (oid, Insert ref val) \\<in> set (ops @ [a]))", "from this"], ["proof (chain)\npicking this:\n  oper = Insert r v", "have \"inserted_ids (ops @ [a]) = inserted_ids ops @ [i]\""], ["proof (prove)\nusing this:\n  oper = Insert r v\n\ngoal (1 subgoal):\n 1. inserted_ids (ops @ [a]) = inserted_ids ops @ [i]", "by (simp add: a_pair inserted_ids_last_ins)"], ["proof (state)\nthis:\n  inserted_ids (ops @ [a]) = inserted_ids ops @ [i]\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>a = (i, oper); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> (oid \\<in> set (inserted_ids (ops @ [a]))) =\n                         (\\<exists>ref val.\n                             (oid, Insert ref val) \\<in> set (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>a = (i, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> (oid \\<in> set (inserted_ids (ops @ [a]))) =\n                         (\\<exists>ref val.\n                             (oid, Insert ref val) \\<in> set (ops @ [a]))", "ultimately"], ["proof (chain)\npicking this:\n  oper = Insert r v\n  inserted_ids (ops @ [a]) = inserted_ids ops @ [i]", "show ?thesis"], ["proof (prove)\nusing this:\n  oper = Insert r v\n  inserted_ids (ops @ [a]) = inserted_ids ops @ [i]\n\ngoal (1 subgoal):\n 1. (oid \\<in> set (inserted_ids (ops @ [a]))) =\n    (\\<exists>ref val. (oid, Insert ref val) \\<in> set (ops @ [a]))", "using snoc.IH a_pair"], ["proof (prove)\nusing this:\n  oper = Insert r v\n  inserted_ids (ops @ [a]) = inserted_ids ops @ [i]\n  (oid \\<in> set (inserted_ids ops)) =\n  (\\<exists>ref val. (oid, Insert ref val) \\<in> set ops)\n  a = (i, oper)\n\ngoal (1 subgoal):\n 1. (oid \\<in> set (inserted_ids (ops @ [a]))) =\n    (\\<exists>ref val. (oid, Insert ref val) \\<in> set (ops @ [a]))", "by auto"], ["proof (state)\nthis:\n  (oid \\<in> set (inserted_ids (ops @ [a]))) =\n  (\\<exists>ref val. (oid, Insert ref val) \\<in> set (ops @ [a]))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>a = (i, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> (oid \\<in> set (inserted_ids (ops @ [a]))) =\n                         (\\<exists>ref val.\n                             (oid, Insert ref val) \\<in> set (ops @ [a]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>a = (i, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> (oid \\<in> set (inserted_ids (ops @ [a]))) =\n                         (\\<exists>ref val.\n                             (oid, Insert ref val) \\<in> set (ops @ [a]))", "case (Delete r)"], ["proof (state)\nthis:\n  oper = Delete r\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>a = (i, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> (oid \\<in> set (inserted_ids (ops @ [a]))) =\n                         (\\<exists>ref val.\n                             (oid, Insert ref val) \\<in> set (ops @ [a]))", "moreover"], ["proof (state)\nthis:\n  oper = Delete r\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>a = (i, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> (oid \\<in> set (inserted_ids (ops @ [a]))) =\n                         (\\<exists>ref val.\n                             (oid, Insert ref val) \\<in> set (ops @ [a]))", "from this"], ["proof (chain)\npicking this:\n  oper = Delete r", "have \"inserted_ids (ops @ [a]) = inserted_ids ops\""], ["proof (prove)\nusing this:\n  oper = Delete r\n\ngoal (1 subgoal):\n 1. inserted_ids (ops @ [a]) = inserted_ids ops", "by (simp add: a_pair inserted_ids_last_del)"], ["proof (state)\nthis:\n  inserted_ids (ops @ [a]) = inserted_ids ops\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>a = (i, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> (oid \\<in> set (inserted_ids (ops @ [a]))) =\n                         (\\<exists>ref val.\n                             (oid, Insert ref val) \\<in> set (ops @ [a]))", "ultimately"], ["proof (chain)\npicking this:\n  oper = Delete r\n  inserted_ids (ops @ [a]) = inserted_ids ops", "show ?thesis"], ["proof (prove)\nusing this:\n  oper = Delete r\n  inserted_ids (ops @ [a]) = inserted_ids ops\n\ngoal (1 subgoal):\n 1. (oid \\<in> set (inserted_ids (ops @ [a]))) =\n    (\\<exists>ref val. (oid, Insert ref val) \\<in> set (ops @ [a]))", "by (simp add: a_pair snoc.IH)"], ["proof (state)\nthis:\n  (oid \\<in> set (inserted_ids (ops @ [a]))) =\n  (\\<exists>ref val. (oid, Insert ref val) \\<in> set (ops @ [a]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (oid \\<in> set (inserted_ids (ops @ [a]))) =\n  (\\<exists>ref val. (oid, Insert ref val) \\<in> set (ops @ [a]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma deleted_ids_last_ins:\n  shows \"deleted_ids (xs @ [(oid, Insert ref val)]) = deleted_ids xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deleted_ids (xs @ [(oid, Insert ref val)]) = deleted_ids xs", "by (simp add: deleted_ids_def map_filter_None map_filter_append)"], ["", "lemma deleted_ids_last_del:\n  shows \"deleted_ids (xs @ [(oid, Delete ref)]) = deleted_ids xs @ [ref]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deleted_ids (xs @ [(oid, Delete ref)]) = deleted_ids xs @ [ref]", "by (simp add: deleted_ids_def map_filter_Some map_filter_append)"], ["", "lemma deleted_ids_exist:\n  shows \"ref \\<in> set (deleted_ids ops) \\<longleftrightarrow> (\\<exists>i. (i, Delete ref) \\<in> set ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ref \\<in> set (deleted_ids ops)) =\n    (\\<exists>i. (i, Delete ref) \\<in> set ops)", "proof(induction ops rule: List.rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. (ref \\<in> set (deleted_ids [])) =\n    (\\<exists>i. (i, Delete ref) \\<in> set [])\n 2. \\<And>x xs.\n       (ref \\<in> set (deleted_ids xs)) =\n       (\\<exists>i. (i, Delete ref) \\<in> set xs) \\<Longrightarrow>\n       (ref \\<in> set (deleted_ids (xs @ [x]))) =\n       (\\<exists>i. (i, Delete ref) \\<in> set (xs @ [x]))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (ref \\<in> set (deleted_ids [])) =\n    (\\<exists>i. (i, Delete ref) \\<in> set [])\n 2. \\<And>x xs.\n       (ref \\<in> set (deleted_ids xs)) =\n       (\\<exists>i. (i, Delete ref) \\<in> set xs) \\<Longrightarrow>\n       (ref \\<in> set (deleted_ids (xs @ [x]))) =\n       (\\<exists>i. (i, Delete ref) \\<in> set (xs @ [x]))", "then"], ["proof (chain)\npicking this:", "show \"ref \\<in> set (deleted_ids []) \\<longleftrightarrow> (\\<exists>i. (i, Delete ref) \\<in> set [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ref \\<in> set (deleted_ids [])) =\n    (\\<exists>i. (i, Delete ref) \\<in> set [])", "by (simp add: deleted_ids_def List.map_filter_def)"], ["proof (state)\nthis:\n  (ref \\<in> set (deleted_ids [])) =\n  (\\<exists>i. (i, Delete ref) \\<in> set [])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       (ref \\<in> set (deleted_ids xs)) =\n       (\\<exists>i. (i, Delete ref) \\<in> set xs) \\<Longrightarrow>\n       (ref \\<in> set (deleted_ids (xs @ [x]))) =\n       (\\<exists>i. (i, Delete ref) \\<in> set (xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       (ref \\<in> set (deleted_ids xs)) =\n       (\\<exists>i. (i, Delete ref) \\<in> set xs) \\<Longrightarrow>\n       (ref \\<in> set (deleted_ids (xs @ [x]))) =\n       (\\<exists>i. (i, Delete ref) \\<in> set (xs @ [x]))", "case (snoc a ops)"], ["proof (state)\nthis:\n  (ref \\<in> set (deleted_ids ops)) =\n  (\\<exists>i. (i, Delete ref) \\<in> set ops)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       (ref \\<in> set (deleted_ids xs)) =\n       (\\<exists>i. (i, Delete ref) \\<in> set xs) \\<Longrightarrow>\n       (ref \\<in> set (deleted_ids (xs @ [x]))) =\n       (\\<exists>i. (i, Delete ref) \\<in> set (xs @ [x]))", "obtain oid oper where a_pair: \"a = (oid, oper)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>oid oper.\n        a = (oid, oper) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a = (oid, oper)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       (ref \\<in> set (deleted_ids xs)) =\n       (\\<exists>i. (i, Delete ref) \\<in> set xs) \\<Longrightarrow>\n       (ref \\<in> set (deleted_ids (xs @ [x]))) =\n       (\\<exists>i. (i, Delete ref) \\<in> set (xs @ [x]))", "then"], ["proof (chain)\npicking this:\n  a = (oid, oper)", "show \"ref \\<in> set (deleted_ids (ops @ [a])) \\<longleftrightarrow> (\\<exists>i. (i, Delete ref) \\<in> set (ops @ [a]))\""], ["proof (prove)\nusing this:\n  a = (oid, oper)\n\ngoal (1 subgoal):\n 1. (ref \\<in> set (deleted_ids (ops @ [a]))) =\n    (\\<exists>i. (i, Delete ref) \\<in> set (ops @ [a]))", "proof(cases oper)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>a = (oid, oper); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> (ref \\<in> set (deleted_ids (ops @ [a]))) =\n                         (\\<exists>i. (i, Delete ref) \\<in> set (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> (ref \\<in> set (deleted_ids (ops @ [a]))) =\n                         (\\<exists>i. (i, Delete ref) \\<in> set (ops @ [a]))", "case (Insert r v)"], ["proof (state)\nthis:\n  oper = Insert r v\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>a = (oid, oper); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> (ref \\<in> set (deleted_ids (ops @ [a]))) =\n                         (\\<exists>i. (i, Delete ref) \\<in> set (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> (ref \\<in> set (deleted_ids (ops @ [a]))) =\n                         (\\<exists>i. (i, Delete ref) \\<in> set (ops @ [a]))", "moreover"], ["proof (state)\nthis:\n  oper = Insert r v\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>a = (oid, oper); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> (ref \\<in> set (deleted_ids (ops @ [a]))) =\n                         (\\<exists>i. (i, Delete ref) \\<in> set (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> (ref \\<in> set (deleted_ids (ops @ [a]))) =\n                         (\\<exists>i. (i, Delete ref) \\<in> set (ops @ [a]))", "from this"], ["proof (chain)\npicking this:\n  oper = Insert r v", "have \"deleted_ids (ops @ [a]) = deleted_ids ops\""], ["proof (prove)\nusing this:\n  oper = Insert r v\n\ngoal (1 subgoal):\n 1. deleted_ids (ops @ [a]) = deleted_ids ops", "by (simp add: a_pair deleted_ids_last_ins)"], ["proof (state)\nthis:\n  deleted_ids (ops @ [a]) = deleted_ids ops\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>a = (oid, oper); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> (ref \\<in> set (deleted_ids (ops @ [a]))) =\n                         (\\<exists>i. (i, Delete ref) \\<in> set (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> (ref \\<in> set (deleted_ids (ops @ [a]))) =\n                         (\\<exists>i. (i, Delete ref) \\<in> set (ops @ [a]))", "ultimately"], ["proof (chain)\npicking this:\n  oper = Insert r v\n  deleted_ids (ops @ [a]) = deleted_ids ops", "show ?thesis"], ["proof (prove)\nusing this:\n  oper = Insert r v\n  deleted_ids (ops @ [a]) = deleted_ids ops\n\ngoal (1 subgoal):\n 1. (ref \\<in> set (deleted_ids (ops @ [a]))) =\n    (\\<exists>i. (i, Delete ref) \\<in> set (ops @ [a]))", "using a_pair snoc.IH"], ["proof (prove)\nusing this:\n  oper = Insert r v\n  deleted_ids (ops @ [a]) = deleted_ids ops\n  a = (oid, oper)\n  (ref \\<in> set (deleted_ids ops)) =\n  (\\<exists>i. (i, Delete ref) \\<in> set ops)\n\ngoal (1 subgoal):\n 1. (ref \\<in> set (deleted_ids (ops @ [a]))) =\n    (\\<exists>i. (i, Delete ref) \\<in> set (ops @ [a]))", "by auto"], ["proof (state)\nthis:\n  (ref \\<in> set (deleted_ids (ops @ [a]))) =\n  (\\<exists>i. (i, Delete ref) \\<in> set (ops @ [a]))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> (ref \\<in> set (deleted_ids (ops @ [a]))) =\n                         (\\<exists>i. (i, Delete ref) \\<in> set (ops @ [a]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> (ref \\<in> set (deleted_ids (ops @ [a]))) =\n                         (\\<exists>i. (i, Delete ref) \\<in> set (ops @ [a]))", "case (Delete r)"], ["proof (state)\nthis:\n  oper = Delete r\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> (ref \\<in> set (deleted_ids (ops @ [a]))) =\n                         (\\<exists>i. (i, Delete ref) \\<in> set (ops @ [a]))", "moreover"], ["proof (state)\nthis:\n  oper = Delete r\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> (ref \\<in> set (deleted_ids (ops @ [a]))) =\n                         (\\<exists>i. (i, Delete ref) \\<in> set (ops @ [a]))", "from this"], ["proof (chain)\npicking this:\n  oper = Delete r", "have \"deleted_ids (ops @ [a]) = deleted_ids ops @ [r]\""], ["proof (prove)\nusing this:\n  oper = Delete r\n\ngoal (1 subgoal):\n 1. deleted_ids (ops @ [a]) = deleted_ids ops @ [r]", "by (simp add: a_pair deleted_ids_last_del)"], ["proof (state)\nthis:\n  deleted_ids (ops @ [a]) = deleted_ids ops @ [r]\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> (ref \\<in> set (deleted_ids (ops @ [a]))) =\n                         (\\<exists>i. (i, Delete ref) \\<in> set (ops @ [a]))", "ultimately"], ["proof (chain)\npicking this:\n  oper = Delete r\n  deleted_ids (ops @ [a]) = deleted_ids ops @ [r]", "show ?thesis"], ["proof (prove)\nusing this:\n  oper = Delete r\n  deleted_ids (ops @ [a]) = deleted_ids ops @ [r]\n\ngoal (1 subgoal):\n 1. (ref \\<in> set (deleted_ids (ops @ [a]))) =\n    (\\<exists>i. (i, Delete ref) \\<in> set (ops @ [a]))", "using a_pair snoc.IH"], ["proof (prove)\nusing this:\n  oper = Delete r\n  deleted_ids (ops @ [a]) = deleted_ids ops @ [r]\n  a = (oid, oper)\n  (ref \\<in> set (deleted_ids ops)) =\n  (\\<exists>i. (i, Delete ref) \\<in> set ops)\n\ngoal (1 subgoal):\n 1. (ref \\<in> set (deleted_ids (ops @ [a]))) =\n    (\\<exists>i. (i, Delete ref) \\<in> set (ops @ [a]))", "by auto"], ["proof (state)\nthis:\n  (ref \\<in> set (deleted_ids (ops @ [a]))) =\n  (\\<exists>i. (i, Delete ref) \\<in> set (ops @ [a]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (ref \\<in> set (deleted_ids (ops @ [a]))) =\n  (\\<exists>i. (i, Delete ref) \\<in> set (ops @ [a]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma deleted_ids_refs_older:\n  assumes \"list_ops (ops @ [(oid, oper)])\"\n  shows \"\\<And>ref. ref \\<in> set (deleted_ids ops) \\<Longrightarrow> ref < oid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ref. ref \\<in> set (deleted_ids ops) \\<Longrightarrow> ref < oid", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ref. ref \\<in> set (deleted_ids ops) \\<Longrightarrow> ref < oid", "fix ref"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ref. ref \\<in> set (deleted_ids ops) \\<Longrightarrow> ref < oid", "assume \"ref \\<in> set (deleted_ids ops)\""], ["proof (state)\nthis:\n  ref \\<in> set (deleted_ids ops)\n\ngoal (1 subgoal):\n 1. \\<And>ref. ref \\<in> set (deleted_ids ops) \\<Longrightarrow> ref < oid", "then"], ["proof (chain)\npicking this:\n  ref \\<in> set (deleted_ids ops)", "obtain i where in_ops: \"(i, Delete ref) \\<in> set ops\""], ["proof (prove)\nusing this:\n  ref \\<in> set (deleted_ids ops)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        (i, Delete ref) \\<in> set ops \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using deleted_ids_exist"], ["proof (prove)\nusing this:\n  ref \\<in> set (deleted_ids ops)\n  (?ref \\<in> set (deleted_ids ?ops)) =\n  (\\<exists>i. (i, Delete ?ref) \\<in> set ?ops)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        (i, Delete ref) \\<in> set ops \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (i, Delete ref) \\<in> set ops\n\ngoal (1 subgoal):\n 1. \\<And>ref. ref \\<in> set (deleted_ids ops) \\<Longrightarrow> ref < oid", "have \"ref < i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ref < i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ref < i", "have \"\\<And>i oper r. (i, oper) \\<in> set ops \\<Longrightarrow> r \\<in> list_op_deps oper \\<Longrightarrow> r < i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i oper r.\n       \\<lbrakk>(i, oper) \\<in> set ops; r \\<in> list_op_deps oper\\<rbrakk>\n       \\<Longrightarrow> r < i", "by (meson assms list_ops_def spec_ops_ref_less spec_ops_rem_last)"], ["proof (state)\nthis:\n  \\<lbrakk>(?i, ?oper) \\<in> set ops; ?r \\<in> list_op_deps ?oper\\<rbrakk>\n  \\<Longrightarrow> ?r < ?i\n\ngoal (1 subgoal):\n 1. ref < i", "thus \"ref < i\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?i, ?oper) \\<in> set ops; ?r \\<in> list_op_deps ?oper\\<rbrakk>\n  \\<Longrightarrow> ?r < ?i\n\ngoal (1 subgoal):\n 1. ref < i", "using in_ops"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?i, ?oper) \\<in> set ops; ?r \\<in> list_op_deps ?oper\\<rbrakk>\n  \\<Longrightarrow> ?r < ?i\n  (i, Delete ref) \\<in> set ops\n\ngoal (1 subgoal):\n 1. ref < i", "by auto"], ["proof (state)\nthis:\n  ref < i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ref < i\n\ngoal (1 subgoal):\n 1. \\<And>ref. ref \\<in> set (deleted_ids ops) \\<Longrightarrow> ref < oid", "moreover"], ["proof (state)\nthis:\n  ref < i\n\ngoal (1 subgoal):\n 1. \\<And>ref. ref \\<in> set (deleted_ids ops) \\<Longrightarrow> ref < oid", "have \"i < oid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < oid", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i < oid", "have \"\\<And>i. i \\<in> set (map fst ops) \\<Longrightarrow> i < oid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> set (map fst ops) \\<Longrightarrow> i < oid", "using assms"], ["proof (prove)\nusing this:\n  list_ops (ops @ [(oid, oper)])\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> set (map fst ops) \\<Longrightarrow> i < oid", "by (simp add: list_ops_def spec_ops_id_inc)"], ["proof (state)\nthis:\n  ?i \\<in> set (map fst ops) \\<Longrightarrow> ?i < oid\n\ngoal (1 subgoal):\n 1. i < oid", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?i \\<in> set (map fst ops) \\<Longrightarrow> ?i < oid\n\ngoal (1 subgoal):\n 1. i < oid", "by (metis in_ops in_set_zipE zip_map_fst_snd)"], ["proof (state)\nthis:\n  i < oid\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i < oid\n\ngoal (1 subgoal):\n 1. \\<And>ref. ref \\<in> set (deleted_ids ops) \\<Longrightarrow> ref < oid", "ultimately"], ["proof (chain)\npicking this:\n  ref < i\n  i < oid", "show \"ref < oid\""], ["proof (prove)\nusing this:\n  ref < i\n  i < oid\n\ngoal (1 subgoal):\n 1. ref < oid", "using order.strict_trans"], ["proof (prove)\nusing this:\n  ref < i\n  i < oid\n  \\<lbrakk>?a < ?b; ?b < ?c\\<rbrakk> \\<Longrightarrow> ?a < ?c\n\ngoal (1 subgoal):\n 1. ref < oid", "by blast"], ["proof (state)\nthis:\n  ref < oid\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Lemmas about interpreting operations\\<close>"], ["", "lemma interp_ops_list_equiv:\n  shows \"fst (interp_ops ops) = interp_ins (insertions ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (interp_ops ops) = interp_ins (insertions ops)", "proof(induction ops rule: List.rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (interp_ops []) = interp_ins (insertions [])\n 2. \\<And>x xs.\n       fst (interp_ops xs) = interp_ins (insertions xs) \\<Longrightarrow>\n       fst (interp_ops (xs @ [x])) = interp_ins (insertions (xs @ [x]))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. fst (interp_ops []) = interp_ins (insertions [])\n 2. \\<And>x xs.\n       fst (interp_ops xs) = interp_ins (insertions xs) \\<Longrightarrow>\n       fst (interp_ops (xs @ [x])) = interp_ins (insertions (xs @ [x]))", "have 1: \"fst (interp_ops []) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (interp_ops []) = []", "by (simp add: interp_ops_def)"], ["proof (state)\nthis:\n  fst (interp_ops []) = []\n\ngoal (2 subgoals):\n 1. fst (interp_ops []) = interp_ins (insertions [])\n 2. \\<And>x xs.\n       fst (interp_ops xs) = interp_ins (insertions xs) \\<Longrightarrow>\n       fst (interp_ops (xs @ [x])) = interp_ins (insertions (xs @ [x]))", "have 2: \"interp_ins (insertions []) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interp_ins (insertions []) = []", "by (simp add: insertions_def map_filter_def interp_ins_def)"], ["proof (state)\nthis:\n  interp_ins (insertions []) = []\n\ngoal (2 subgoals):\n 1. fst (interp_ops []) = interp_ins (insertions [])\n 2. \\<And>x xs.\n       fst (interp_ops xs) = interp_ins (insertions xs) \\<Longrightarrow>\n       fst (interp_ops (xs @ [x])) = interp_ins (insertions (xs @ [x]))", "show \"fst (interp_ops []) = interp_ins (insertions [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (interp_ops []) = interp_ins (insertions [])", "by (simp add: 1 2)"], ["proof (state)\nthis:\n  fst (interp_ops []) = interp_ins (insertions [])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       fst (interp_ops xs) = interp_ins (insertions xs) \\<Longrightarrow>\n       fst (interp_ops (xs @ [x])) = interp_ins (insertions (xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       fst (interp_ops xs) = interp_ins (insertions xs) \\<Longrightarrow>\n       fst (interp_ops (xs @ [x])) = interp_ins (insertions (xs @ [x]))", "case (snoc a ops)"], ["proof (state)\nthis:\n  fst (interp_ops ops) = interp_ins (insertions ops)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       fst (interp_ops xs) = interp_ins (insertions xs) \\<Longrightarrow>\n       fst (interp_ops (xs @ [x])) = interp_ins (insertions (xs @ [x]))", "obtain oid oper where a_pair: \"a = (oid, oper)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>oid oper.\n        a = (oid, oper) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  a = (oid, oper)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       fst (interp_ops xs) = interp_ins (insertions xs) \\<Longrightarrow>\n       fst (interp_ops (xs @ [x])) = interp_ins (insertions (xs @ [x]))", "then"], ["proof (chain)\npicking this:\n  a = (oid, oper)", "show \"fst (interp_ops (ops @ [a])) = interp_ins (insertions (ops @ [a]))\""], ["proof (prove)\nusing this:\n  a = (oid, oper)\n\ngoal (1 subgoal):\n 1. fst (interp_ops (ops @ [a])) = interp_ins (insertions (ops @ [a]))", "proof(cases oper)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>a = (oid, oper); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> fst (interp_ops (ops @ [a])) =\n                         interp_ins (insertions (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> fst (interp_ops (ops @ [a])) =\n                         interp_ins (insertions (ops @ [a]))", "case (Insert ref val)"], ["proof (state)\nthis:\n  oper = Insert ref val\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>a = (oid, oper); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> fst (interp_ops (ops @ [a])) =\n                         interp_ins (insertions (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> fst (interp_ops (ops @ [a])) =\n                         interp_ins (insertions (ops @ [a]))", "hence \"insertions (ops @ [a]) = insertions ops @ [(oid, ref)]\""], ["proof (prove)\nusing this:\n  oper = Insert ref val\n\ngoal (1 subgoal):\n 1. insertions (ops @ [a]) = insertions ops @ [(oid, ref)]", "by (simp add: a_pair insertions_last_ins)"], ["proof (state)\nthis:\n  insertions (ops @ [a]) = insertions ops @ [(oid, ref)]\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>a = (oid, oper); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> fst (interp_ops (ops @ [a])) =\n                         interp_ins (insertions (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> fst (interp_ops (ops @ [a])) =\n                         interp_ins (insertions (ops @ [a]))", "hence \"interp_ins (insertions (ops @ [a])) = insert_spec (interp_ins (insertions ops)) (oid, ref)\""], ["proof (prove)\nusing this:\n  insertions (ops @ [a]) = insertions ops @ [(oid, ref)]\n\ngoal (1 subgoal):\n 1. interp_ins (insertions (ops @ [a])) =\n    insert_spec (interp_ins (insertions ops)) (oid, ref)", "by (simp add: interp_ins_tail_unfold)"], ["proof (state)\nthis:\n  interp_ins (insertions (ops @ [a])) =\n  insert_spec (interp_ins (insertions ops)) (oid, ref)\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>a = (oid, oper); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> fst (interp_ops (ops @ [a])) =\n                         interp_ins (insertions (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> fst (interp_ops (ops @ [a])) =\n                         interp_ins (insertions (ops @ [a]))", "moreover"], ["proof (state)\nthis:\n  interp_ins (insertions (ops @ [a])) =\n  insert_spec (interp_ins (insertions ops)) (oid, ref)\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>a = (oid, oper); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> fst (interp_ops (ops @ [a])) =\n                         interp_ins (insertions (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> fst (interp_ops (ops @ [a])) =\n                         interp_ins (insertions (ops @ [a]))", "have \"fst (interp_ops (ops @ [a])) = insert_spec (fst (interp_ops ops)) (oid, ref)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (interp_ops (ops @ [a])) =\n    insert_spec (fst (interp_ops ops)) (oid, ref)", "by (metis Insert a_pair fst_conv interp_op.simps(1) interp_ops_unfold_last prod.collapse)"], ["proof (state)\nthis:\n  fst (interp_ops (ops @ [a])) =\n  insert_spec (fst (interp_ops ops)) (oid, ref)\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>a = (oid, oper); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> fst (interp_ops (ops @ [a])) =\n                         interp_ins (insertions (ops @ [a]))\n 2. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> fst (interp_ops (ops @ [a])) =\n                         interp_ins (insertions (ops @ [a]))", "ultimately"], ["proof (chain)\npicking this:\n  interp_ins (insertions (ops @ [a])) =\n  insert_spec (interp_ins (insertions ops)) (oid, ref)\n  fst (interp_ops (ops @ [a])) =\n  insert_spec (fst (interp_ops ops)) (oid, ref)", "show ?thesis"], ["proof (prove)\nusing this:\n  interp_ins (insertions (ops @ [a])) =\n  insert_spec (interp_ins (insertions ops)) (oid, ref)\n  fst (interp_ops (ops @ [a])) =\n  insert_spec (fst (interp_ops ops)) (oid, ref)\n\ngoal (1 subgoal):\n 1. fst (interp_ops (ops @ [a])) = interp_ins (insertions (ops @ [a]))", "using snoc.IH"], ["proof (prove)\nusing this:\n  interp_ins (insertions (ops @ [a])) =\n  insert_spec (interp_ins (insertions ops)) (oid, ref)\n  fst (interp_ops (ops @ [a])) =\n  insert_spec (fst (interp_ops ops)) (oid, ref)\n  fst (interp_ops ops) = interp_ins (insertions ops)\n\ngoal (1 subgoal):\n 1. fst (interp_ops (ops @ [a])) = interp_ins (insertions (ops @ [a]))", "by auto"], ["proof (state)\nthis:\n  fst (interp_ops (ops @ [a])) = interp_ins (insertions (ops @ [a]))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> fst (interp_ops (ops @ [a])) =\n                         interp_ins (insertions (ops @ [a]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> fst (interp_ops (ops @ [a])) =\n                         interp_ins (insertions (ops @ [a]))", "case (Delete ref)"], ["proof (state)\nthis:\n  oper = Delete ref\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> fst (interp_ops (ops @ [a])) =\n                         interp_ins (insertions (ops @ [a]))", "hence \"insertions (ops @ [a]) = insertions ops\""], ["proof (prove)\nusing this:\n  oper = Delete ref\n\ngoal (1 subgoal):\n 1. insertions (ops @ [a]) = insertions ops", "by (simp add: a_pair insertions_last_del)"], ["proof (state)\nthis:\n  insertions (ops @ [a]) = insertions ops\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> fst (interp_ops (ops @ [a])) =\n                         interp_ins (insertions (ops @ [a]))", "moreover"], ["proof (state)\nthis:\n  insertions (ops @ [a]) = insertions ops\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> fst (interp_ops (ops @ [a])) =\n                         interp_ins (insertions (ops @ [a]))", "have \"fst (interp_ops (ops @ [a])) = fst (interp_ops ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (interp_ops (ops @ [a])) = fst (interp_ops ops)", "by (metis Delete a_pair eq_fst_iff interp_op.simps(2) interp_ops_unfold_last)"], ["proof (state)\nthis:\n  fst (interp_ops (ops @ [a])) = fst (interp_ops ops)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>a = (oid, oper); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> fst (interp_ops (ops @ [a])) =\n                         interp_ins (insertions (ops @ [a]))", "ultimately"], ["proof (chain)\npicking this:\n  insertions (ops @ [a]) = insertions ops\n  fst (interp_ops (ops @ [a])) = fst (interp_ops ops)", "show ?thesis"], ["proof (prove)\nusing this:\n  insertions (ops @ [a]) = insertions ops\n  fst (interp_ops (ops @ [a])) = fst (interp_ops ops)\n\ngoal (1 subgoal):\n 1. fst (interp_ops (ops @ [a])) = interp_ins (insertions (ops @ [a]))", "using snoc.IH"], ["proof (prove)\nusing this:\n  insertions (ops @ [a]) = insertions ops\n  fst (interp_ops (ops @ [a])) = fst (interp_ops ops)\n  fst (interp_ops ops) = interp_ins (insertions ops)\n\ngoal (1 subgoal):\n 1. fst (interp_ops (ops @ [a])) = interp_ins (insertions (ops @ [a]))", "by auto"], ["proof (state)\nthis:\n  fst (interp_ops (ops @ [a])) = interp_ins (insertions (ops @ [a]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst (interp_ops (ops @ [a])) = interp_ins (insertions (ops @ [a]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma interp_ops_distinct:\n  assumes \"list_ops ops\"\n  shows \"distinct (fst (interp_ops ops))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (fst (interp_ops ops))", "by (simp add: assms interp_ins_distinct interp_ops_list_equiv list_ops_insertions)"], ["", "lemma list_order_equiv:\n  shows \"list_order ops x y \\<longleftrightarrow> Insert_Spec.list_order (insertions ops) x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List_Spec.list_order ops x y =\n    Insert_Spec.list_order (insertions ops) x y", "by (simp add: Insert_Spec.list_order_def List_Spec.list_order_def interp_ops_list_equiv)"], ["", "lemma interp_ops_vals_domain:\n  assumes \"list_ops ops\"\n  shows \"dom (snd (interp_ops ops)) = set (inserted_ids ops) - set (deleted_ids ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (snd (interp_ops ops)) =\n    set (inserted_ids ops) - set (deleted_ids ops)", "using assms"], ["proof (prove)\nusing this:\n  list_ops ops\n\ngoal (1 subgoal):\n 1. dom (snd (interp_ops ops)) =\n    set (inserted_ids ops) - set (deleted_ids ops)", "proof(induction ops rule: List.rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. list_ops [] \\<Longrightarrow>\n    dom (snd (interp_ops [])) = set (inserted_ids []) - set (deleted_ids [])\n 2. \\<And>x xs.\n       \\<lbrakk>list_ops xs \\<Longrightarrow>\n                dom (snd (interp_ops xs)) =\n                set (inserted_ids xs) - set (deleted_ids xs);\n        list_ops (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "case Nil"], ["proof (state)\nthis:\n  list_ops []\n\ngoal (2 subgoals):\n 1. list_ops [] \\<Longrightarrow>\n    dom (snd (interp_ops [])) = set (inserted_ids []) - set (deleted_ids [])\n 2. \\<And>x xs.\n       \\<lbrakk>list_ops xs \\<Longrightarrow>\n                dom (snd (interp_ops xs)) =\n                set (inserted_ids xs) - set (deleted_ids xs);\n        list_ops (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "have 1: \"interp_ops [] = ([], Map.empty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interp_ops [] = ([], Map.empty)", "by (simp add: interp_ops_def)"], ["proof (state)\nthis:\n  interp_ops [] = ([], Map.empty)\n\ngoal (2 subgoals):\n 1. list_ops [] \\<Longrightarrow>\n    dom (snd (interp_ops [])) = set (inserted_ids []) - set (deleted_ids [])\n 2. \\<And>x xs.\n       \\<lbrakk>list_ops xs \\<Longrightarrow>\n                dom (snd (interp_ops xs)) =\n                set (inserted_ids xs) - set (deleted_ids xs);\n        list_ops (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  interp_ops [] = ([], Map.empty)\n\ngoal (2 subgoals):\n 1. list_ops [] \\<Longrightarrow>\n    dom (snd (interp_ops [])) = set (inserted_ids []) - set (deleted_ids [])\n 2. \\<And>x xs.\n       \\<lbrakk>list_ops xs \\<Longrightarrow>\n                dom (snd (interp_ops xs)) =\n                set (inserted_ids xs) - set (deleted_ids xs);\n        list_ops (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "have 2: \"inserted_ids [] = []\" and \"deleted_ids [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inserted_ids [] = [] &&& deleted_ids [] = []", "by (auto simp add: inserted_ids_def deleted_ids_def map_filter_simps(2))"], ["proof (state)\nthis:\n  inserted_ids [] = []\n  deleted_ids [] = []\n\ngoal (2 subgoals):\n 1. list_ops [] \\<Longrightarrow>\n    dom (snd (interp_ops [])) = set (inserted_ids []) - set (deleted_ids [])\n 2. \\<And>x xs.\n       \\<lbrakk>list_ops xs \\<Longrightarrow>\n                dom (snd (interp_ops xs)) =\n                set (inserted_ids xs) - set (deleted_ids xs);\n        list_ops (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "ultimately"], ["proof (chain)\npicking this:\n  interp_ops [] = ([], Map.empty)\n  inserted_ids [] = []\n  deleted_ids [] = []", "show \"dom (snd (interp_ops [])) = set (inserted_ids []) - set (deleted_ids [])\""], ["proof (prove)\nusing this:\n  interp_ops [] = ([], Map.empty)\n  inserted_ids [] = []\n  deleted_ids [] = []\n\ngoal (1 subgoal):\n 1. dom (snd (interp_ops [])) = set (inserted_ids []) - set (deleted_ids [])", "by (simp add: 1 2)"], ["proof (state)\nthis:\n  dom (snd (interp_ops [])) = set (inserted_ids []) - set (deleted_ids [])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>list_ops xs \\<Longrightarrow>\n                dom (snd (interp_ops xs)) =\n                set (inserted_ids xs) - set (deleted_ids xs);\n        list_ops (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>list_ops xs \\<Longrightarrow>\n                dom (snd (interp_ops xs)) =\n                set (inserted_ids xs) - set (deleted_ids xs);\n        list_ops (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "case (snoc x xs)"], ["proof (state)\nthis:\n  list_ops xs \\<Longrightarrow>\n  dom (snd (interp_ops xs)) = set (inserted_ids xs) - set (deleted_ids xs)\n  list_ops (xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>list_ops xs \\<Longrightarrow>\n                dom (snd (interp_ops xs)) =\n                set (inserted_ids xs) - set (deleted_ids xs);\n        list_ops (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "hence IH: \"dom (snd (interp_ops xs)) = set (inserted_ids xs) - set (deleted_ids xs)\""], ["proof (prove)\nusing this:\n  list_ops xs \\<Longrightarrow>\n  dom (snd (interp_ops xs)) = set (inserted_ids xs) - set (deleted_ids xs)\n  list_ops (xs @ [x])\n\ngoal (1 subgoal):\n 1. dom (snd (interp_ops xs)) = set (inserted_ids xs) - set (deleted_ids xs)", "using list_ops_def spec_ops_rem_last"], ["proof (prove)\nusing this:\n  list_ops xs \\<Longrightarrow>\n  dom (snd (interp_ops xs)) = set (inserted_ids xs) - set (deleted_ids xs)\n  list_ops (xs @ [x])\n  list_ops ?ops \\<equiv> spec_ops ?ops list_op_deps\n  spec_ops (?xs @ [?x]) ?deps \\<Longrightarrow> spec_ops ?xs ?deps\n\ngoal (1 subgoal):\n 1. dom (snd (interp_ops xs)) = set (inserted_ids xs) - set (deleted_ids xs)", "by blast"], ["proof (state)\nthis:\n  dom (snd (interp_ops xs)) = set (inserted_ids xs) - set (deleted_ids xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>list_ops xs \\<Longrightarrow>\n                dom (snd (interp_ops xs)) =\n                set (inserted_ids xs) - set (deleted_ids xs);\n        list_ops (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "obtain oid oper where x_pair: \"x = (oid, oper)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>oid oper.\n        x = (oid, oper) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x = (oid, oper)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>list_ops xs \\<Longrightarrow>\n                dom (snd (interp_ops xs)) =\n                set (inserted_ids xs) - set (deleted_ids xs);\n        list_ops (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "obtain list vals where interp_xs: \"interp_ops xs = (list, vals)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>list vals.\n        interp_ops xs = (list, vals) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  interp_ops xs = (list, vals)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>list_ops xs \\<Longrightarrow>\n                dom (snd (interp_ops xs)) =\n                set (inserted_ids xs) - set (deleted_ids xs);\n        list_ops (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "then"], ["proof (chain)\npicking this:\n  interp_ops xs = (list, vals)", "show \"dom (snd (interp_ops (xs @ [x]))) =\n             set (inserted_ids (xs @ [x])) - set (deleted_ids (xs @ [x]))\""], ["proof (prove)\nusing this:\n  interp_ops xs = (list, vals)\n\ngoal (1 subgoal):\n 1. dom (snd (interp_ops (xs @ [x]))) =\n    set (inserted_ids (xs @ [x])) - set (deleted_ids (xs @ [x]))", "proof(cases oper)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))\n 2. \\<And>x2.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "case (Insert ref val)"], ["proof (state)\nthis:\n  oper = Insert ref val\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))\n 2. \\<And>x2.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "hence \"interp_ops (xs @ [x]) = (insert_spec list (oid, ref), vals(oid \\<mapsto> val))\""], ["proof (prove)\nusing this:\n  oper = Insert ref val\n\ngoal (1 subgoal):\n 1. interp_ops (xs @ [x]) =\n    (insert_spec list (oid, ref), vals(oid \\<mapsto> val))", "by (simp add: interp_ops_unfold_last interp_xs x_pair)"], ["proof (state)\nthis:\n  interp_ops (xs @ [x]) =\n  (insert_spec list (oid, ref), vals(oid \\<mapsto> val))\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))\n 2. \\<And>x2.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "hence \"dom (snd (interp_ops (xs @ [x]))) = (dom vals) \\<union> {oid}\""], ["proof (prove)\nusing this:\n  interp_ops (xs @ [x]) =\n  (insert_spec list (oid, ref), vals(oid \\<mapsto> val))\n\ngoal (1 subgoal):\n 1. dom (snd (interp_ops (xs @ [x]))) = dom vals \\<union> {oid}", "by simp"], ["proof (state)\nthis:\n  dom (snd (interp_ops (xs @ [x]))) = dom vals \\<union> {oid}\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))\n 2. \\<And>x2.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  dom (snd (interp_ops (xs @ [x]))) = dom vals \\<union> {oid}\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))\n 2. \\<And>x2.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "have \"set (inserted_ids xs) - set (deleted_ids xs) = dom vals\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (inserted_ids xs) - set (deleted_ids xs) = dom vals", "using IH interp_xs"], ["proof (prove)\nusing this:\n  dom (snd (interp_ops xs)) = set (inserted_ids xs) - set (deleted_ids xs)\n  interp_ops xs = (list, vals)\n\ngoal (1 subgoal):\n 1. set (inserted_ids xs) - set (deleted_ids xs) = dom vals", "by auto"], ["proof (state)\nthis:\n  set (inserted_ids xs) - set (deleted_ids xs) = dom vals\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))\n 2. \\<And>x2.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  set (inserted_ids xs) - set (deleted_ids xs) = dom vals\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))\n 2. \\<And>x2.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "have \"inserted_ids (xs @ [x]) = inserted_ids xs @ [oid]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inserted_ids (xs @ [x]) = inserted_ids xs @ [oid]", "by (simp add: Insert inserted_ids_last_ins x_pair)"], ["proof (state)\nthis:\n  inserted_ids (xs @ [x]) = inserted_ids xs @ [oid]\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))\n 2. \\<And>x2.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  inserted_ids (xs @ [x]) = inserted_ids xs @ [oid]\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))\n 2. \\<And>x2.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "have \"deleted_ids (xs @ [x]) = deleted_ids xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deleted_ids (xs @ [x]) = deleted_ids xs", "by (simp add: Insert deleted_ids_last_ins x_pair)"], ["proof (state)\nthis:\n  deleted_ids (xs @ [x]) = deleted_ids xs\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))\n 2. \\<And>x2.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "hence \"set (inserted_ids (xs @ [x])) - set (deleted_ids (xs @ [x])) =\n           {oid} \\<union> set (inserted_ids xs) - set (deleted_ids xs)\""], ["proof (prove)\nusing this:\n  deleted_ids (xs @ [x]) = deleted_ids xs\n\ngoal (1 subgoal):\n 1. set (inserted_ids (xs @ [x])) - set (deleted_ids (xs @ [x])) =\n    {oid} \\<union> set (inserted_ids xs) - set (deleted_ids xs)", "using calculation(3)"], ["proof (prove)\nusing this:\n  deleted_ids (xs @ [x]) = deleted_ids xs\n  inserted_ids (xs @ [x]) = inserted_ids xs @ [oid]\n\ngoal (1 subgoal):\n 1. set (inserted_ids (xs @ [x])) - set (deleted_ids (xs @ [x])) =\n    {oid} \\<union> set (inserted_ids xs) - set (deleted_ids xs)", "by auto"], ["proof (state)\nthis:\n  set (inserted_ids (xs @ [x])) - set (deleted_ids (xs @ [x])) =\n  {oid} \\<union> set (inserted_ids xs) - set (deleted_ids xs)\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))\n 2. \\<And>x2.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  set (inserted_ids (xs @ [x])) - set (deleted_ids (xs @ [x])) =\n  {oid} \\<union> set (inserted_ids xs) - set (deleted_ids xs)\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))\n 2. \\<And>x2.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "have \"... = {oid} \\<union> (set (inserted_ids xs) - set (deleted_ids xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {oid} \\<union> set (inserted_ids xs) - set (deleted_ids xs) =\n    {oid} \\<union> (set (inserted_ids xs) - set (deleted_ids xs))", "using deleted_ids_refs_older snoc.prems x_pair"], ["proof (prove)\nusing this:\n  \\<lbrakk>list_ops (?ops @ [(?oid, ?oper)]);\n   ?ref \\<in> set (deleted_ids ?ops)\\<rbrakk>\n  \\<Longrightarrow> ?ref < ?oid\n  list_ops (xs @ [x])\n  x = (oid, oper)\n\ngoal (1 subgoal):\n 1. {oid} \\<union> set (inserted_ids xs) - set (deleted_ids xs) =\n    {oid} \\<union> (set (inserted_ids xs) - set (deleted_ids xs))", "by blast"], ["proof (state)\nthis:\n  {oid} \\<union> set (inserted_ids xs) - set (deleted_ids xs) =\n  {oid} \\<union> (set (inserted_ids xs) - set (deleted_ids xs))\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Insert x11 x12\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))\n 2. \\<And>x2.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "ultimately"], ["proof (chain)\npicking this:\n  dom (snd (interp_ops (xs @ [x]))) = dom vals \\<union> {oid}\n  set (inserted_ids xs) - set (deleted_ids xs) = dom vals\n  inserted_ids (xs @ [x]) = inserted_ids xs @ [oid]\n  set (inserted_ids (xs @ [x])) - set (deleted_ids (xs @ [x])) =\n  {oid} \\<union> set (inserted_ids xs) - set (deleted_ids xs)\n  {oid} \\<union> set (inserted_ids xs) - set (deleted_ids xs) =\n  {oid} \\<union> (set (inserted_ids xs) - set (deleted_ids xs))", "show ?thesis"], ["proof (prove)\nusing this:\n  dom (snd (interp_ops (xs @ [x]))) = dom vals \\<union> {oid}\n  set (inserted_ids xs) - set (deleted_ids xs) = dom vals\n  inserted_ids (xs @ [x]) = inserted_ids xs @ [oid]\n  set (inserted_ids (xs @ [x])) - set (deleted_ids (xs @ [x])) =\n  {oid} \\<union> set (inserted_ids xs) - set (deleted_ids xs)\n  {oid} \\<union> set (inserted_ids xs) - set (deleted_ids xs) =\n  {oid} \\<union> (set (inserted_ids xs) - set (deleted_ids xs))\n\ngoal (1 subgoal):\n 1. dom (snd (interp_ops (xs @ [x]))) =\n    set (inserted_ids (xs @ [x])) - set (deleted_ids (xs @ [x]))", "by auto"], ["proof (state)\nthis:\n  dom (snd (interp_ops (xs @ [x]))) =\n  set (inserted_ids (xs @ [x])) - set (deleted_ids (xs @ [x]))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "case (Delete ref)"], ["proof (state)\nthis:\n  oper = Delete ref\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "hence \"interp_ops (xs @ [x]) = (list, vals(ref := None))\""], ["proof (prove)\nusing this:\n  oper = Delete ref\n\ngoal (1 subgoal):\n 1. interp_ops (xs @ [x]) = (list, vals(ref := None))", "by (simp add: interp_ops_unfold_last interp_xs x_pair)"], ["proof (state)\nthis:\n  interp_ops (xs @ [x]) = (list, vals(ref := None))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "hence \"dom (snd (interp_ops (xs @ [x]))) = (dom vals) - {ref}\""], ["proof (prove)\nusing this:\n  interp_ops (xs @ [x]) = (list, vals(ref := None))\n\ngoal (1 subgoal):\n 1. dom (snd (interp_ops (xs @ [x]))) = dom vals - {ref}", "by simp"], ["proof (state)\nthis:\n  dom (snd (interp_ops (xs @ [x]))) = dom vals - {ref}\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  dom (snd (interp_ops (xs @ [x]))) = dom vals - {ref}\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "have \"set (inserted_ids xs) - set (deleted_ids xs) = dom vals\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (inserted_ids xs) - set (deleted_ids xs) = dom vals", "using IH interp_xs"], ["proof (prove)\nusing this:\n  dom (snd (interp_ops xs)) = set (inserted_ids xs) - set (deleted_ids xs)\n  interp_ops xs = (list, vals)\n\ngoal (1 subgoal):\n 1. set (inserted_ids xs) - set (deleted_ids xs) = dom vals", "by auto"], ["proof (state)\nthis:\n  set (inserted_ids xs) - set (deleted_ids xs) = dom vals\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  set (inserted_ids xs) - set (deleted_ids xs) = dom vals\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "have \"inserted_ids (xs @ [x]) = inserted_ids xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inserted_ids (xs @ [x]) = inserted_ids xs", "by (simp add: Delete inserted_ids_last_del x_pair)"], ["proof (state)\nthis:\n  inserted_ids (xs @ [x]) = inserted_ids xs\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  inserted_ids (xs @ [x]) = inserted_ids xs\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "have \"deleted_ids (xs @ [x]) = deleted_ids xs @ [ref]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deleted_ids (xs @ [x]) = deleted_ids xs @ [ref]", "by (simp add: Delete deleted_ids_last_del x_pair)"], ["proof (state)\nthis:\n  deleted_ids (xs @ [x]) = deleted_ids xs @ [ref]\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "hence \"set (inserted_ids (xs @ [x])) - set (deleted_ids (xs @ [x])) =\n           set (inserted_ids xs) - (set (deleted_ids xs) \\<union> {ref})\""], ["proof (prove)\nusing this:\n  deleted_ids (xs @ [x]) = deleted_ids xs @ [ref]\n\ngoal (1 subgoal):\n 1. set (inserted_ids (xs @ [x])) - set (deleted_ids (xs @ [x])) =\n    set (inserted_ids xs) - (set (deleted_ids xs) \\<union> {ref})", "using calculation(3)"], ["proof (prove)\nusing this:\n  deleted_ids (xs @ [x]) = deleted_ids xs @ [ref]\n  inserted_ids (xs @ [x]) = inserted_ids xs\n\ngoal (1 subgoal):\n 1. set (inserted_ids (xs @ [x])) - set (deleted_ids (xs @ [x])) =\n    set (inserted_ids xs) - (set (deleted_ids xs) \\<union> {ref})", "by auto"], ["proof (state)\nthis:\n  set (inserted_ids (xs @ [x])) - set (deleted_ids (xs @ [x])) =\n  set (inserted_ids xs) - (set (deleted_ids xs) \\<union> {ref})\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  set (inserted_ids (xs @ [x])) - set (deleted_ids (xs @ [x])) =\n  set (inserted_ids xs) - (set (deleted_ids xs) \\<union> {ref})\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "have \"... = set (inserted_ids xs) - set (deleted_ids xs) - {ref}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (inserted_ids xs) - (set (deleted_ids xs) \\<union> {ref}) =\n    set (inserted_ids xs) - set (deleted_ids xs) - {ref}", "by blast"], ["proof (state)\nthis:\n  set (inserted_ids xs) - (set (deleted_ids xs) \\<union> {ref}) =\n  set (inserted_ids xs) - set (deleted_ids xs) - {ref}\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>interp_ops xs = (list, vals); oper = Delete x2\\<rbrakk>\n       \\<Longrightarrow> dom (snd (interp_ops (xs @ [x]))) =\n                         set (inserted_ids (xs @ [x])) -\n                         set (deleted_ids (xs @ [x]))", "ultimately"], ["proof (chain)\npicking this:\n  dom (snd (interp_ops (xs @ [x]))) = dom vals - {ref}\n  set (inserted_ids xs) - set (deleted_ids xs) = dom vals\n  inserted_ids (xs @ [x]) = inserted_ids xs\n  set (inserted_ids (xs @ [x])) - set (deleted_ids (xs @ [x])) =\n  set (inserted_ids xs) - (set (deleted_ids xs) \\<union> {ref})\n  set (inserted_ids xs) - (set (deleted_ids xs) \\<union> {ref}) =\n  set (inserted_ids xs) - set (deleted_ids xs) - {ref}", "show ?thesis"], ["proof (prove)\nusing this:\n  dom (snd (interp_ops (xs @ [x]))) = dom vals - {ref}\n  set (inserted_ids xs) - set (deleted_ids xs) = dom vals\n  inserted_ids (xs @ [x]) = inserted_ids xs\n  set (inserted_ids (xs @ [x])) - set (deleted_ids (xs @ [x])) =\n  set (inserted_ids xs) - (set (deleted_ids xs) \\<union> {ref})\n  set (inserted_ids xs) - (set (deleted_ids xs) \\<union> {ref}) =\n  set (inserted_ids xs) - set (deleted_ids xs) - {ref}\n\ngoal (1 subgoal):\n 1. dom (snd (interp_ops (xs @ [x]))) =\n    set (inserted_ids (xs @ [x])) - set (deleted_ids (xs @ [x]))", "by auto"], ["proof (state)\nthis:\n  dom (snd (interp_ops (xs @ [x]))) =\n  set (inserted_ids (xs @ [x])) - set (deleted_ids (xs @ [x]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dom (snd (interp_ops (xs @ [x]))) =\n  set (inserted_ids (xs @ [x])) - set (deleted_ids (xs @ [x]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_spec_nth_oid:\n  assumes \"distinct xs\"\n    and \"n < length xs\"\n  shows \"insert_spec xs (oid, Some (xs ! n)) ! Suc n = oid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_spec xs (oid, Some (xs ! n)) ! Suc n = oid", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n  n < length xs\n\ngoal (1 subgoal):\n 1. insert_spec xs (oid, Some (xs ! n)) ! Suc n = oid", "proof(induction xs arbitrary: n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>distinct []; n < length []\\<rbrakk>\n       \\<Longrightarrow> insert_spec [] (oid, Some ([] ! n)) ! Suc n = oid\n 2. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distinct xs; n < length xs\\<rbrakk>\n                   \\<Longrightarrow> insert_spec xs (oid, Some (xs ! n)) !\n                                     Suc n =\n                                     oid;\n        distinct (a # xs); n < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> insert_spec (a # xs) (oid, Some ((a # xs) ! n)) !\n                         Suc n =\n                         oid", "case Nil"], ["proof (state)\nthis:\n  distinct []\n  n < length []\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>distinct []; n < length []\\<rbrakk>\n       \\<Longrightarrow> insert_spec [] (oid, Some ([] ! n)) ! Suc n = oid\n 2. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distinct xs; n < length xs\\<rbrakk>\n                   \\<Longrightarrow> insert_spec xs (oid, Some (xs ! n)) !\n                                     Suc n =\n                                     oid;\n        distinct (a # xs); n < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> insert_spec (a # xs) (oid, Some ((a # xs) ! n)) !\n                         Suc n =\n                         oid", "then"], ["proof (chain)\npicking this:\n  distinct []\n  n < length []", "show \"insert_spec [] (oid, Some ([] ! n)) ! Suc n = oid\""], ["proof (prove)\nusing this:\n  distinct []\n  n < length []\n\ngoal (1 subgoal):\n 1. insert_spec [] (oid, Some ([] ! n)) ! Suc n = oid", "by simp"], ["proof (state)\nthis:\n  insert_spec [] (oid, Some ([] ! n)) ! Suc n = oid\n\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distinct xs; n < length xs\\<rbrakk>\n                   \\<Longrightarrow> insert_spec xs (oid, Some (xs ! n)) !\n                                     Suc n =\n                                     oid;\n        distinct (a # xs); n < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> insert_spec (a # xs) (oid, Some ((a # xs) ! n)) !\n                         Suc n =\n                         oid", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distinct xs; n < length xs\\<rbrakk>\n                   \\<Longrightarrow> insert_spec xs (oid, Some (xs ! n)) !\n                                     Suc n =\n                                     oid;\n        distinct (a # xs); n < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> insert_spec (a # xs) (oid, Some ((a # xs) ! n)) !\n                         Suc n =\n                         oid", "case (Cons a xs)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct xs; ?n < length xs\\<rbrakk>\n  \\<Longrightarrow> insert_spec xs (oid, Some (xs ! ?n)) ! Suc ?n = oid\n  distinct (a # xs)\n  n < length (a # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distinct xs; n < length xs\\<rbrakk>\n                   \\<Longrightarrow> insert_spec xs (oid, Some (xs ! n)) !\n                                     Suc n =\n                                     oid;\n        distinct (a # xs); n < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> insert_spec (a # xs) (oid, Some ((a # xs) ! n)) !\n                         Suc n =\n                         oid", "have \"distinct (a # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (a # xs)", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  distinct (a # xs)\n\ngoal (1 subgoal):\n 1. distinct (a # xs)", "by auto"], ["proof (state)\nthis:\n  distinct (a # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distinct xs; n < length xs\\<rbrakk>\n                   \\<Longrightarrow> insert_spec xs (oid, Some (xs ! n)) !\n                                     Suc n =\n                                     oid;\n        distinct (a # xs); n < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> insert_spec (a # xs) (oid, Some ((a # xs) ! n)) !\n                         Suc n =\n                         oid", "then"], ["proof (chain)\npicking this:\n  distinct (a # xs)", "show \"insert_spec (a # xs) (oid, Some ((a # xs) ! n)) ! Suc n = oid\""], ["proof (prove)\nusing this:\n  distinct (a # xs)\n\ngoal (1 subgoal):\n 1. insert_spec (a # xs) (oid, Some ((a # xs) ! n)) ! Suc n = oid", "proof(cases \"a = (a # xs) ! n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (a # xs); a = (a # xs) ! n\\<rbrakk>\n    \\<Longrightarrow> insert_spec (a # xs) (oid, Some ((a # xs) ! n)) !\n                      Suc n =\n                      oid\n 2. \\<lbrakk>distinct (a # xs); a \\<noteq> (a # xs) ! n\\<rbrakk>\n    \\<Longrightarrow> insert_spec (a # xs) (oid, Some ((a # xs) ! n)) !\n                      Suc n =\n                      oid", "case True"], ["proof (state)\nthis:\n  a = (a # xs) ! n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (a # xs); a = (a # xs) ! n\\<rbrakk>\n    \\<Longrightarrow> insert_spec (a # xs) (oid, Some ((a # xs) ! n)) !\n                      Suc n =\n                      oid\n 2. \\<lbrakk>distinct (a # xs); a \\<noteq> (a # xs) ! n\\<rbrakk>\n    \\<Longrightarrow> insert_spec (a # xs) (oid, Some ((a # xs) ! n)) !\n                      Suc n =\n                      oid", "then"], ["proof (chain)\npicking this:\n  a = (a # xs) ! n", "have \"n = 0\""], ["proof (prove)\nusing this:\n  a = (a # xs) ! n\n\ngoal (1 subgoal):\n 1. n = 0", "using \\<open>distinct (a # xs)\\<close> Cons.prems(2) gr_implies_not_zero"], ["proof (prove)\nusing this:\n  a = (a # xs) ! n\n  distinct (a # xs)\n  n < length (a # xs)\n  ?m < ?n \\<Longrightarrow> ?n \\<noteq> (0::?'a)\n\ngoal (1 subgoal):\n 1. n = 0", "by force"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (a # xs); a = (a # xs) ! n\\<rbrakk>\n    \\<Longrightarrow> insert_spec (a # xs) (oid, Some ((a # xs) ! n)) !\n                      Suc n =\n                      oid\n 2. \\<lbrakk>distinct (a # xs); a \\<noteq> (a # xs) ! n\\<rbrakk>\n    \\<Longrightarrow> insert_spec (a # xs) (oid, Some ((a # xs) ! n)) !\n                      Suc n =\n                      oid", "then"], ["proof (chain)\npicking this:\n  n = 0", "show \"insert_spec (a # xs) (oid, Some ((a # xs) ! n)) ! Suc n = oid\""], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. insert_spec (a # xs) (oid, Some ((a # xs) ! n)) ! Suc n = oid", "by auto"], ["proof (state)\nthis:\n  insert_spec (a # xs) (oid, Some ((a # xs) ! n)) ! Suc n = oid\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (a # xs); a \\<noteq> (a # xs) ! n\\<rbrakk>\n    \\<Longrightarrow> insert_spec (a # xs) (oid, Some ((a # xs) ! n)) !\n                      Suc n =\n                      oid", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (a # xs); a \\<noteq> (a # xs) ! n\\<rbrakk>\n    \\<Longrightarrow> insert_spec (a # xs) (oid, Some ((a # xs) ! n)) !\n                      Suc n =\n                      oid", "case False"], ["proof (state)\nthis:\n  a \\<noteq> (a # xs) ! n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (a # xs); a \\<noteq> (a # xs) ! n\\<rbrakk>\n    \\<Longrightarrow> insert_spec (a # xs) (oid, Some ((a # xs) ! n)) !\n                      Suc n =\n                      oid", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> (a # xs) ! n", "have \"n > 0\""], ["proof (prove)\nusing this:\n  a \\<noteq> (a # xs) ! n\n\ngoal (1 subgoal):\n 1. 0 < n", "using \\<open>distinct (a # xs)\\<close> Cons.prems(2) gr_implies_not_zero"], ["proof (prove)\nusing this:\n  a \\<noteq> (a # xs) ! n\n  distinct (a # xs)\n  n < length (a # xs)\n  ?m < ?n \\<Longrightarrow> ?n \\<noteq> (0::?'a)\n\ngoal (1 subgoal):\n 1. 0 < n", "by force"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (a # xs); a \\<noteq> (a # xs) ! n\\<rbrakk>\n    \\<Longrightarrow> insert_spec (a # xs) (oid, Some ((a # xs) ! n)) !\n                      Suc n =\n                      oid", "then"], ["proof (chain)\npicking this:\n  0 < n", "obtain m where \"n = Suc m\""], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. (\\<And>m. n = Suc m \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using Suc_pred'"], ["proof (prove)\nusing this:\n  0 < n\n  0 < ?n \\<Longrightarrow> ?n = Suc (?n - 1)\n\ngoal (1 subgoal):\n 1. (\\<And>m. n = Suc m \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (a # xs); a \\<noteq> (a # xs) ! n\\<rbrakk>\n    \\<Longrightarrow> insert_spec (a # xs) (oid, Some ((a # xs) ! n)) !\n                      Suc n =\n                      oid", "then"], ["proof (chain)\npicking this:\n  n = Suc m", "show \"insert_spec (a # xs) (oid, Some ((a # xs) ! n)) ! Suc n = oid\""], ["proof (prove)\nusing this:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. insert_spec (a # xs) (oid, Some ((a # xs) ! n)) ! Suc n = oid", "using Cons.IH Cons.prems"], ["proof (prove)\nusing this:\n  n = Suc m\n  \\<lbrakk>distinct xs; ?n < length xs\\<rbrakk>\n  \\<Longrightarrow> insert_spec xs (oid, Some (xs ! ?n)) ! Suc ?n = oid\n  distinct (a # xs)\n  n < length (a # xs)\n\ngoal (1 subgoal):\n 1. insert_spec (a # xs) (oid, Some ((a # xs) ! n)) ! Suc n = oid", "by auto"], ["proof (state)\nthis:\n  insert_spec (a # xs) (oid, Some ((a # xs) ! n)) ! Suc n = oid\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  insert_spec (a # xs) (oid, Some ((a # xs) ! n)) ! Suc n = oid\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_spec_inc_length:\n  assumes \"distinct xs\"\n    and \"n < length xs\"\n  shows \"length (insert_spec xs (oid, Some (xs ! n))) = Suc (length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (insert_spec xs (oid, Some (xs ! n))) = Suc (length xs)", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n  n < length xs\n\ngoal (1 subgoal):\n 1. length (insert_spec xs (oid, Some (xs ! n))) = Suc (length xs)", "proof(induction xs arbitrary: n, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distinct xs; n < length xs\\<rbrakk>\n                   \\<Longrightarrow> length\n(insert_spec xs (oid, Some (xs ! n))) =\n                                     Suc (length xs);\n        distinct (a # xs); n < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> length\n                          (insert_spec (a # xs)\n                            (oid, Some ((a # xs) ! n))) =\n                         Suc (length (a # xs))", "case (Cons a xs)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct xs; ?n < length xs\\<rbrakk>\n  \\<Longrightarrow> length (insert_spec xs (oid, Some (xs ! ?n))) =\n                    Suc (length xs)\n  distinct (a # xs)\n  n < length (a # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distinct xs; n < length xs\\<rbrakk>\n                   \\<Longrightarrow> length\n(insert_spec xs (oid, Some (xs ! n))) =\n                                     Suc (length xs);\n        distinct (a # xs); n < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> length\n                          (insert_spec (a # xs)\n                            (oid, Some ((a # xs) ! n))) =\n                         Suc (length (a # xs))", "have \"distinct (a # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (a # xs)", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  distinct (a # xs)\n\ngoal (1 subgoal):\n 1. distinct (a # xs)", "by auto"], ["proof (state)\nthis:\n  distinct (a # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distinct xs; n < length xs\\<rbrakk>\n                   \\<Longrightarrow> length\n(insert_spec xs (oid, Some (xs ! n))) =\n                                     Suc (length xs);\n        distinct (a # xs); n < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> length\n                          (insert_spec (a # xs)\n                            (oid, Some ((a # xs) ! n))) =\n                         Suc (length (a # xs))", "then"], ["proof (chain)\npicking this:\n  distinct (a # xs)", "show \"length (insert_spec (a # xs) (oid, Some ((a # xs) ! n))) = Suc (length (a # xs))\""], ["proof (prove)\nusing this:\n  distinct (a # xs)\n\ngoal (1 subgoal):\n 1. length (insert_spec (a # xs) (oid, Some ((a # xs) ! n))) =\n    Suc (length (a # xs))", "proof(cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (a # xs); n = 0\\<rbrakk>\n    \\<Longrightarrow> length\n                       (insert_spec (a # xs) (oid, Some ((a # xs) ! n))) =\n                      Suc (length (a # xs))\n 2. \\<And>nat.\n       \\<lbrakk>distinct (a # xs); n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> length\n                          (insert_spec (a # xs)\n                            (oid, Some ((a # xs) ! n))) =\n                         Suc (length (a # xs))", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (a # xs); n = 0\\<rbrakk>\n    \\<Longrightarrow> length\n                       (insert_spec (a # xs) (oid, Some ((a # xs) ! n))) =\n                      Suc (length (a # xs))\n 2. \\<And>nat.\n       \\<lbrakk>distinct (a # xs); n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> length\n                          (insert_spec (a # xs)\n                            (oid, Some ((a # xs) ! n))) =\n                         Suc (length (a # xs))", "hence \"insert_spec (a # xs) (oid, Some ((a # xs) ! n)) = a # oid # xs\""], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. insert_spec (a # xs) (oid, Some ((a # xs) ! n)) = a # oid # xs", "by simp"], ["proof (state)\nthis:\n  insert_spec (a # xs) (oid, Some ((a # xs) ! n)) = a # oid # xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (a # xs); n = 0\\<rbrakk>\n    \\<Longrightarrow> length\n                       (insert_spec (a # xs) (oid, Some ((a # xs) ! n))) =\n                      Suc (length (a # xs))\n 2. \\<And>nat.\n       \\<lbrakk>distinct (a # xs); n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> length\n                          (insert_spec (a # xs)\n                            (oid, Some ((a # xs) ! n))) =\n                         Suc (length (a # xs))", "then"], ["proof (chain)\npicking this:\n  insert_spec (a # xs) (oid, Some ((a # xs) ! n)) = a # oid # xs", "show ?thesis"], ["proof (prove)\nusing this:\n  insert_spec (a # xs) (oid, Some ((a # xs) ! n)) = a # oid # xs\n\ngoal (1 subgoal):\n 1. length (insert_spec (a # xs) (oid, Some ((a # xs) ! n))) =\n    Suc (length (a # xs))", "by simp"], ["proof (state)\nthis:\n  length (insert_spec (a # xs) (oid, Some ((a # xs) ! n))) =\n  Suc (length (a # xs))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>distinct (a # xs); n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> length\n                          (insert_spec (a # xs)\n                            (oid, Some ((a # xs) ! n))) =\n                         Suc (length (a # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>distinct (a # xs); n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> length\n                          (insert_spec (a # xs)\n                            (oid, Some ((a # xs) ! n))) =\n                         Suc (length (a # xs))", "case (Suc nat)"], ["proof (state)\nthis:\n  n = Suc nat\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>distinct (a # xs); n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> length\n                          (insert_spec (a # xs)\n                            (oid, Some ((a # xs) ! n))) =\n                         Suc (length (a # xs))", "hence \"nat < length xs\""], ["proof (prove)\nusing this:\n  n = Suc nat\n\ngoal (1 subgoal):\n 1. nat < length xs", "using Cons.prems(2)"], ["proof (prove)\nusing this:\n  n = Suc nat\n  n < length (a # xs)\n\ngoal (1 subgoal):\n 1. nat < length xs", "by auto"], ["proof (state)\nthis:\n  nat < length xs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>distinct (a # xs); n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> length\n                          (insert_spec (a # xs)\n                            (oid, Some ((a # xs) ! n))) =\n                         Suc (length (a # xs))", "hence \"length (insert_spec xs (oid, Some (xs ! nat))) = Suc (length xs)\""], ["proof (prove)\nusing this:\n  nat < length xs\n\ngoal (1 subgoal):\n 1. length (insert_spec xs (oid, Some (xs ! nat))) = Suc (length xs)", "using Cons.IH Cons.prems(1)"], ["proof (prove)\nusing this:\n  nat < length xs\n  \\<lbrakk>distinct xs; ?n < length xs\\<rbrakk>\n  \\<Longrightarrow> length (insert_spec xs (oid, Some (xs ! ?n))) =\n                    Suc (length xs)\n  distinct (a # xs)\n\ngoal (1 subgoal):\n 1. length (insert_spec xs (oid, Some (xs ! nat))) = Suc (length xs)", "by auto"], ["proof (state)\nthis:\n  length (insert_spec xs (oid, Some (xs ! nat))) = Suc (length xs)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>distinct (a # xs); n = Suc nat\\<rbrakk>\n       \\<Longrightarrow> length\n                          (insert_spec (a # xs)\n                            (oid, Some ((a # xs) ! n))) =\n                         Suc (length (a # xs))", "then"], ["proof (chain)\npicking this:\n  length (insert_spec xs (oid, Some (xs ! nat))) = Suc (length xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  length (insert_spec xs (oid, Some (xs ! nat))) = Suc (length xs)\n\ngoal (1 subgoal):\n 1. length (insert_spec (a # xs) (oid, Some ((a # xs) ! n))) =\n    Suc (length (a # xs))", "by (simp add: Suc)"], ["proof (state)\nthis:\n  length (insert_spec (a # xs) (oid, Some ((a # xs) ! n))) =\n  Suc (length (a # xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (insert_spec (a # xs) (oid, Some ((a # xs) ! n))) =\n  Suc (length (a # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_split_two_elems:\n  assumes \"distinct xs\"\n    and \"x \\<in> set xs\" and \"y \\<in> set xs\"\n    and \"x \\<noteq> y\"\n  shows \"\\<exists>pre mid suf. xs = pre @ x # mid @ y # suf \\<or> xs = pre @ y # mid @ x # suf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>pre mid suf.\n       xs = pre @ x # mid @ y # suf \\<or> xs = pre @ y # mid @ x # suf", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>pre mid suf.\n       xs = pre @ x # mid @ y # suf \\<or> xs = pre @ y # mid @ x # suf", "obtain as bs where as_bs: \"xs = as @ [x] @ bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        xs = as @ [x] @ bs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2) split_list_first"], ["proof (prove)\nusing this:\n  x \\<in> set xs\n  ?x \\<in> set ?xs \\<Longrightarrow>\n  \\<exists>ys zs. ?xs = ys @ ?x # zs \\<and> ?x \\<notin> set ys\n\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        xs = as @ [x] @ bs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs = as @ [x] @ bs\n\ngoal (1 subgoal):\n 1. \\<exists>pre mid suf.\n       xs = pre @ x # mid @ y # suf \\<or> xs = pre @ y # mid @ x # suf", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>pre mid suf.\n       xs = pre @ x # mid @ y # suf \\<or> xs = pre @ y # mid @ x # suf", "proof(cases \"y \\<in> set as\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<in> set as \\<Longrightarrow>\n    \\<exists>pre mid suf.\n       xs = pre @ x # mid @ y # suf \\<or> xs = pre @ y # mid @ x # suf\n 2. y \\<notin> set as \\<Longrightarrow>\n    \\<exists>pre mid suf.\n       xs = pre @ x # mid @ y # suf \\<or> xs = pre @ y # mid @ x # suf", "case True"], ["proof (state)\nthis:\n  y \\<in> set as\n\ngoal (2 subgoals):\n 1. y \\<in> set as \\<Longrightarrow>\n    \\<exists>pre mid suf.\n       xs = pre @ x # mid @ y # suf \\<or> xs = pre @ y # mid @ x # suf\n 2. y \\<notin> set as \\<Longrightarrow>\n    \\<exists>pre mid suf.\n       xs = pre @ x # mid @ y # suf \\<or> xs = pre @ y # mid @ x # suf", "then"], ["proof (chain)\npicking this:\n  y \\<in> set as", "obtain cs ds where \"as = cs @ [y] @ ds\""], ["proof (prove)\nusing this:\n  y \\<in> set as\n\ngoal (1 subgoal):\n 1. (\\<And>cs ds.\n        as = cs @ [y] @ ds \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(3) split_list_first"], ["proof (prove)\nusing this:\n  y \\<in> set as\n  y \\<in> set xs\n  ?x \\<in> set ?xs \\<Longrightarrow>\n  \\<exists>ys zs. ?xs = ys @ ?x # zs \\<and> ?x \\<notin> set ys\n\ngoal (1 subgoal):\n 1. (\\<And>cs ds.\n        as = cs @ [y] @ ds \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  as = cs @ [y] @ ds\n\ngoal (2 subgoals):\n 1. y \\<in> set as \\<Longrightarrow>\n    \\<exists>pre mid suf.\n       xs = pre @ x # mid @ y # suf \\<or> xs = pre @ y # mid @ x # suf\n 2. y \\<notin> set as \\<Longrightarrow>\n    \\<exists>pre mid suf.\n       xs = pre @ x # mid @ y # suf \\<or> xs = pre @ y # mid @ x # suf", "then"], ["proof (chain)\npicking this:\n  as = cs @ [y] @ ds", "show ?thesis"], ["proof (prove)\nusing this:\n  as = cs @ [y] @ ds\n\ngoal (1 subgoal):\n 1. \\<exists>pre mid suf.\n       xs = pre @ x # mid @ y # suf \\<or> xs = pre @ y # mid @ x # suf", "by (auto simp add: as_bs)"], ["proof (state)\nthis:\n  \\<exists>pre mid suf.\n     xs = pre @ x # mid @ y # suf \\<or> xs = pre @ y # mid @ x # suf\n\ngoal (1 subgoal):\n 1. y \\<notin> set as \\<Longrightarrow>\n    \\<exists>pre mid suf.\n       xs = pre @ x # mid @ y # suf \\<or> xs = pre @ y # mid @ x # suf", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<notin> set as \\<Longrightarrow>\n    \\<exists>pre mid suf.\n       xs = pre @ x # mid @ y # suf \\<or> xs = pre @ y # mid @ x # suf", "case False"], ["proof (state)\nthis:\n  y \\<notin> set as\n\ngoal (1 subgoal):\n 1. y \\<notin> set as \\<Longrightarrow>\n    \\<exists>pre mid suf.\n       xs = pre @ x # mid @ y # suf \\<or> xs = pre @ y # mid @ x # suf", "then"], ["proof (chain)\npicking this:\n  y \\<notin> set as", "have \"y \\<in> set bs\""], ["proof (prove)\nusing this:\n  y \\<notin> set as\n\ngoal (1 subgoal):\n 1. y \\<in> set bs", "using as_bs assms(3) assms(4)"], ["proof (prove)\nusing this:\n  y \\<notin> set as\n  xs = as @ [x] @ bs\n  y \\<in> set xs\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. y \\<in> set bs", "by auto"], ["proof (state)\nthis:\n  y \\<in> set bs\n\ngoal (1 subgoal):\n 1. y \\<notin> set as \\<Longrightarrow>\n    \\<exists>pre mid suf.\n       xs = pre @ x # mid @ y # suf \\<or> xs = pre @ y # mid @ x # suf", "then"], ["proof (chain)\npicking this:\n  y \\<in> set bs", "obtain cs ds where \"bs = cs @ [y] @ ds\""], ["proof (prove)\nusing this:\n  y \\<in> set bs\n\ngoal (1 subgoal):\n 1. (\\<And>cs ds.\n        bs = cs @ [y] @ ds \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(3) split_list_first"], ["proof (prove)\nusing this:\n  y \\<in> set bs\n  y \\<in> set xs\n  ?x \\<in> set ?xs \\<Longrightarrow>\n  \\<exists>ys zs. ?xs = ys @ ?x # zs \\<and> ?x \\<notin> set ys\n\ngoal (1 subgoal):\n 1. (\\<And>cs ds.\n        bs = cs @ [y] @ ds \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  bs = cs @ [y] @ ds\n\ngoal (1 subgoal):\n 1. y \\<notin> set as \\<Longrightarrow>\n    \\<exists>pre mid suf.\n       xs = pre @ x # mid @ y # suf \\<or> xs = pre @ y # mid @ x # suf", "then"], ["proof (chain)\npicking this:\n  bs = cs @ [y] @ ds", "show ?thesis"], ["proof (prove)\nusing this:\n  bs = cs @ [y] @ ds\n\ngoal (1 subgoal):\n 1. \\<exists>pre mid suf.\n       xs = pre @ x # mid @ y # suf \\<or> xs = pre @ y # mid @ x # suf", "by (auto simp add: as_bs)"], ["proof (state)\nthis:\n  \\<exists>pre mid suf.\n     xs = pre @ x # mid @ y # suf \\<or> xs = pre @ y # mid @ x # suf\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>pre mid suf.\n     xs = pre @ x # mid @ y # suf \\<or> xs = pre @ y # mid @ x # suf\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Satisfying all conditions of $\\mathcal{A}_\\textsf{strong}$\\<close>"], ["", "text\\<open>Part 1(a) of Attiya et al.'s specification states that whenever the\nlist is observed, the elements of the list are exactly those that have\nbeen inserted but not deleted. $\\mathcal{A}_\\textsf{strong}$ uses the\nvisibility relation $\\le_\\textsf{vis}$ to capture the operations known\nto a node at some arbitrary point in the execution; in the OpSet model,\nwe can simply prove the theorem for an arbitrary OpSet, since the\ncontents of the OpSet at a particular time on a particular node correspond\nexactly to the set of operations known to that node at that time.\\<close>"], ["", "theorem inserted_but_not_deleted:\n  assumes \"list_ops ops\"\n    and \"interp_ops ops = (list, vals)\"\n  shows \"a \\<in> dom (vals) \\<longleftrightarrow> (\\<exists>ref val. (a, Insert ref val) \\<in> set ops) \\<and>\n                            (\\<nexists>i. (i, Delete a) \\<in> set ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<in> dom vals) =\n    ((\\<exists>ref val. (a, Insert ref val) \\<in> set ops) \\<and>\n     (\\<nexists>i. (i, Delete a) \\<in> set ops))", "using assms deleted_ids_exist inserted_ids_exist interp_ops_vals_domain"], ["proof (prove)\nusing this:\n  list_ops ops\n  interp_ops ops = (list, vals)\n  (?ref \\<in> set (deleted_ids ?ops)) =\n  (\\<exists>i. (i, Delete ?ref) \\<in> set ?ops)\n  (?oid \\<in> set (inserted_ids ?ops)) =\n  (\\<exists>ref val. (?oid, Insert ref val) \\<in> set ?ops)\n  list_ops ?ops \\<Longrightarrow>\n  dom (snd (interp_ops ?ops)) =\n  set (inserted_ids ?ops) - set (deleted_ids ?ops)\n\ngoal (1 subgoal):\n 1. (a \\<in> dom vals) =\n    ((\\<exists>ref val. (a, Insert ref val) \\<in> set ops) \\<and>\n     (\\<nexists>i. (i, Delete a) \\<in> set ops))", "by (metis Diff_iff snd_conv)"], ["", "text\\<open>Part 1(b) states that whenever the list is observed, the order of\nlist elements is consistent with the global list order. We can define the\nglobal list order simply as the list order that arises from interpreting\nthe OpSet containing all operations in the entire execution. Then, at any\npoint in the execution, the OpSet is some subset of the set of all\noperations.\n\nWe can then rephrase condition 1(b) as follows: whenever list element \\isa{x}\nappears before list element \\isa{y} in the interpretation of \\isa{some-ops},\nthen for any OpSet \\isa{all-ops} that is a superset of \\isa{some-ops},\n\\isa{x} must also appear before \\isa{y} in the interpretation of \\isa{all-ops}.\nIn other words, adding more operations to the OpSet does not change the\nrelative order of any existing list elements.\\<close>"], ["", "theorem list_order_consistent:\n  assumes \"list_ops some_ops\" and \"list_ops all_ops\"\n    and \"set some_ops \\<subseteq> set all_ops\"\n    and \"list_order some_ops x y\"\n  shows \"list_order all_ops x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List_Spec.list_order all_ops x y", "using assms list_order_monotonic list_ops_insertions insertions_subset list_order_equiv"], ["proof (prove)\nusing this:\n  list_ops some_ops\n  list_ops all_ops\n  set some_ops \\<subseteq> set all_ops\n  List_Spec.list_order some_ops x y\n  \\<lbrakk>insert_ops ?A; insert_ops ?B; set ?A \\<subseteq> set ?B;\n   Insert_Spec.list_order ?A ?x ?y\\<rbrakk>\n  \\<Longrightarrow> Insert_Spec.list_order ?B ?x ?y\n  list_ops ?ops \\<Longrightarrow> insert_ops (insertions ?ops)\n  \\<lbrakk>list_ops ?A; list_ops ?B; set ?A \\<subseteq> set ?B\\<rbrakk>\n  \\<Longrightarrow> set (insertions ?A) \\<subseteq> set (insertions ?B)\n  List_Spec.list_order ?ops ?x ?y =\n  Insert_Spec.list_order (insertions ?ops) ?x ?y\n\ngoal (1 subgoal):\n 1. List_Spec.list_order all_ops x y", "by metis"], ["", "text\\<open>Part 1(c) states that inserted elements appear at the specified position:\nthat is, immediately after an insertion of \\isa{oid} at index \\isa{k}, the list\nindex \\isa{k} does indeed contain \\isa{oid} (provided that \\isa{k} is less than the\nlength of the list). We prove this property below.\\<close>"], ["", "theorem correct_position_insert:\n  assumes \"list_ops (ops @ [(oid, ins)])\"\n    and \"ins = make_insert (fst (interp_ops ops)) val k\"\n    and \"list = fst (interp_ops (ops @ [(oid, ins)]))\"\n  shows \"list ! (min k (length list - 1)) = oid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list ! min k (length list - 1) = oid", "proof(cases \"k = 0 \\<or> fst (interp_ops ops) = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<or> fst (interp_ops ops) = [] \\<Longrightarrow>\n    list ! min k (length list - 1) = oid\n 2. \\<not> (k = 0 \\<or> fst (interp_ops ops) = []) \\<Longrightarrow>\n    list ! min k (length list - 1) = oid", "case True"], ["proof (state)\nthis:\n  k = 0 \\<or> fst (interp_ops ops) = []\n\ngoal (2 subgoals):\n 1. k = 0 \\<or> fst (interp_ops ops) = [] \\<Longrightarrow>\n    list ! min k (length list - 1) = oid\n 2. \\<not> (k = 0 \\<or> fst (interp_ops ops) = []) \\<Longrightarrow>\n    list ! min k (length list - 1) = oid", "moreover"], ["proof (state)\nthis:\n  k = 0 \\<or> fst (interp_ops ops) = []\n\ngoal (2 subgoals):\n 1. k = 0 \\<or> fst (interp_ops ops) = [] \\<Longrightarrow>\n    list ! min k (length list - 1) = oid\n 2. \\<not> (k = 0 \\<or> fst (interp_ops ops) = []) \\<Longrightarrow>\n    list ! min k (length list - 1) = oid", "from this"], ["proof (chain)\npicking this:\n  k = 0 \\<or> fst (interp_ops ops) = []", "have \"make_insert (fst (interp_ops ops)) val k = Insert None val\"\n    and min_k: \"min k (length (fst (interp_ops ops))) = 0\""], ["proof (prove)\nusing this:\n  k = 0 \\<or> fst (interp_ops ops) = []\n\ngoal (1 subgoal):\n 1. make_insert (fst (interp_ops ops)) val k = Insert None val &&&\n    min k (length (fst (interp_ops ops))) = 0", "by (cases k, auto)"], ["proof (state)\nthis:\n  make_insert (fst (interp_ops ops)) val k = Insert None val\n  min k (length (fst (interp_ops ops))) = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<or> fst (interp_ops ops) = [] \\<Longrightarrow>\n    list ! min k (length list - 1) = oid\n 2. \\<not> (k = 0 \\<or> fst (interp_ops ops) = []) \\<Longrightarrow>\n    list ! min k (length list - 1) = oid", "hence \"fst (interp_ops (ops @ [(oid, ins)])) = oid # fst (interp_ops ops)\""], ["proof (prove)\nusing this:\n  make_insert (fst (interp_ops ops)) val k = Insert None val\n  min k (length (fst (interp_ops ops))) = 0\n\ngoal (1 subgoal):\n 1. fst (interp_ops (ops @ [(oid, ins)])) = oid # fst (interp_ops ops)", "using assms(2) interp_ops_unfold_last"], ["proof (prove)\nusing this:\n  make_insert (fst (interp_ops ops)) val k = Insert None val\n  min k (length (fst (interp_ops ops))) = 0\n  ins = make_insert (fst (interp_ops ops)) val k\n  interp_ops (?xs @ [?x]) = interp_op (interp_ops ?xs) ?x\n\ngoal (1 subgoal):\n 1. fst (interp_ops (ops @ [(oid, ins)])) = oid # fst (interp_ops ops)", "by (metis fst_conv insert_spec.simps(1) interp_op.simps(1) prod.collapse)"], ["proof (state)\nthis:\n  fst (interp_ops (ops @ [(oid, ins)])) = oid # fst (interp_ops ops)\n\ngoal (2 subgoals):\n 1. k = 0 \\<or> fst (interp_ops ops) = [] \\<Longrightarrow>\n    list ! min k (length list - 1) = oid\n 2. \\<not> (k = 0 \\<or> fst (interp_ops ops) = []) \\<Longrightarrow>\n    list ! min k (length list - 1) = oid", "ultimately"], ["proof (chain)\npicking this:\n  k = 0 \\<or> fst (interp_ops ops) = []\n  fst (interp_ops (ops @ [(oid, ins)])) = oid # fst (interp_ops ops)", "show ?thesis"], ["proof (prove)\nusing this:\n  k = 0 \\<or> fst (interp_ops ops) = []\n  fst (interp_ops (ops @ [(oid, ins)])) = oid # fst (interp_ops ops)\n\ngoal (1 subgoal):\n 1. list ! min k (length list - 1) = oid", "by (simp add: min_k assms(3))"], ["proof (state)\nthis:\n  list ! min k (length list - 1) = oid\n\ngoal (1 subgoal):\n 1. \\<not> (k = 0 \\<or> fst (interp_ops ops) = []) \\<Longrightarrow>\n    list ! min k (length list - 1) = oid", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (k = 0 \\<or> fst (interp_ops ops) = []) \\<Longrightarrow>\n    list ! min k (length list - 1) = oid", "case False"], ["proof (state)\nthis:\n  \\<not> (k = 0 \\<or> fst (interp_ops ops) = [])\n\ngoal (1 subgoal):\n 1. \\<not> (k = 0 \\<or> fst (interp_ops ops) = []) \\<Longrightarrow>\n    list ! min k (length list - 1) = oid", "moreover"], ["proof (state)\nthis:\n  \\<not> (k = 0 \\<or> fst (interp_ops ops) = [])\n\ngoal (1 subgoal):\n 1. \\<not> (k = 0 \\<or> fst (interp_ops ops) = []) \\<Longrightarrow>\n    list ! min k (length list - 1) = oid", "from this"], ["proof (chain)\npicking this:\n  \\<not> (k = 0 \\<or> fst (interp_ops ops) = [])", "have \"k > 0\" and \"fst (interp_ops ops) \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<not> (k = 0 \\<or> fst (interp_ops ops) = [])\n\ngoal (1 subgoal):\n 1. 0 < k &&& fst (interp_ops ops) \\<noteq> []", "using neq0_conv"], ["proof (prove)\nusing this:\n  \\<not> (k = 0 \\<or> fst (interp_ops ops) = [])\n  (?n \\<noteq> 0) = (0 < ?n)\n\ngoal (1 subgoal):\n 1. 0 < k &&& fst (interp_ops ops) \\<noteq> []", "by blast+"], ["proof (state)\nthis:\n  0 < k\n  fst (interp_ops ops) \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> (k = 0 \\<or> fst (interp_ops ops) = []) \\<Longrightarrow>\n    list ! min k (length list - 1) = oid", "from this"], ["proof (chain)\npicking this:\n  0 < k\n  fst (interp_ops ops) \\<noteq> []", "obtain nat where \"k = Suc nat\""], ["proof (prove)\nusing this:\n  0 < k\n  fst (interp_ops ops) \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>nat. k = Suc nat \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using gr0_implies_Suc"], ["proof (prove)\nusing this:\n  0 < k\n  fst (interp_ops ops) \\<noteq> []\n  0 < ?n \\<Longrightarrow> \\<exists>m. ?n = Suc m\n\ngoal (1 subgoal):\n 1. (\\<And>nat. k = Suc nat \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  k = Suc nat\n\ngoal (1 subgoal):\n 1. \\<not> (k = 0 \\<or> fst (interp_ops ops) = []) \\<Longrightarrow>\n    list ! min k (length list - 1) = oid", "hence \"make_insert (fst (interp_ops ops)) val k =\n      Insert (Some ((fst (interp_ops ops)) ! (min nat (length (fst (interp_ops ops)) - 1)))) val\""], ["proof (prove)\nusing this:\n  k = Suc nat\n\ngoal (1 subgoal):\n 1. make_insert (fst (interp_ops ops)) val k =\n    Insert\n     (Some\n       (fst (interp_ops ops) ! min nat (length (fst (interp_ops ops)) - 1)))\n     val", "using False"], ["proof (prove)\nusing this:\n  k = Suc nat\n  \\<not> (k = 0 \\<or> fst (interp_ops ops) = [])\n\ngoal (1 subgoal):\n 1. make_insert (fst (interp_ops ops)) val k =\n    Insert\n     (Some\n       (fst (interp_ops ops) ! min nat (length (fst (interp_ops ops)) - 1)))\n     val", "by (cases \"fst (interp_ops ops)\", auto)"], ["proof (state)\nthis:\n  make_insert (fst (interp_ops ops)) val k =\n  Insert\n   (Some\n     (fst (interp_ops ops) ! min nat (length (fst (interp_ops ops)) - 1)))\n   val\n\ngoal (1 subgoal):\n 1. \\<not> (k = 0 \\<or> fst (interp_ops ops) = []) \\<Longrightarrow>\n    list ! min k (length list - 1) = oid", "hence \"fst (interp_ops (ops @ [(oid, ins)])) =\n         insert_spec (fst (interp_ops ops)) (oid, Some ((fst (interp_ops ops)) ! (min nat (length (fst (interp_ops ops)) - 1))))\""], ["proof (prove)\nusing this:\n  make_insert (fst (interp_ops ops)) val k =\n  Insert\n   (Some\n     (fst (interp_ops ops) ! min nat (length (fst (interp_ops ops)) - 1)))\n   val\n\ngoal (1 subgoal):\n 1. fst (interp_ops (ops @ [(oid, ins)])) =\n    insert_spec (fst (interp_ops ops))\n     (oid,\n      Some\n       (fst (interp_ops ops) ! min nat (length (fst (interp_ops ops)) - 1)))", "by (metis assms(2) fst_conv interp_op.simps(1) interp_ops_unfold_last prod.collapse)"], ["proof (state)\nthis:\n  fst (interp_ops (ops @ [(oid, ins)])) =\n  insert_spec (fst (interp_ops ops))\n   (oid,\n    Some\n     (fst (interp_ops ops) ! min nat (length (fst (interp_ops ops)) - 1)))\n\ngoal (1 subgoal):\n 1. \\<not> (k = 0 \\<or> fst (interp_ops ops) = []) \\<Longrightarrow>\n    list ! min k (length list - 1) = oid", "moreover"], ["proof (state)\nthis:\n  fst (interp_ops (ops @ [(oid, ins)])) =\n  insert_spec (fst (interp_ops ops))\n   (oid,\n    Some\n     (fst (interp_ops ops) ! min nat (length (fst (interp_ops ops)) - 1)))\n\ngoal (1 subgoal):\n 1. \\<not> (k = 0 \\<or> fst (interp_ops ops) = []) \\<Longrightarrow>\n    list ! min k (length list - 1) = oid", "have \"min nat (length (fst (interp_ops ops)) - 1) < length (fst (interp_ops ops))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min nat (length (fst (interp_ops ops)) - 1)\n    < length (fst (interp_ops ops))", "by (simp add: \\<open>fst (interp_ops ops) \\<noteq> []\\<close> min.strict_coboundedI2)"], ["proof (state)\nthis:\n  min nat (length (fst (interp_ops ops)) - 1)\n  < length (fst (interp_ops ops))\n\ngoal (1 subgoal):\n 1. \\<not> (k = 0 \\<or> fst (interp_ops ops) = []) \\<Longrightarrow>\n    list ! min k (length list - 1) = oid", "moreover"], ["proof (state)\nthis:\n  min nat (length (fst (interp_ops ops)) - 1)\n  < length (fst (interp_ops ops))\n\ngoal (1 subgoal):\n 1. \\<not> (k = 0 \\<or> fst (interp_ops ops) = []) \\<Longrightarrow>\n    list ! min k (length list - 1) = oid", "have \"distinct (fst (interp_ops ops))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (fst (interp_ops ops))", "using interp_ops_distinct list_ops_def spec_ops_rem_last assms(1)"], ["proof (prove)\nusing this:\n  list_ops ?ops \\<Longrightarrow> distinct (fst (interp_ops ?ops))\n  list_ops ?ops \\<equiv> spec_ops ?ops list_op_deps\n  spec_ops (?xs @ [?x]) ?deps \\<Longrightarrow> spec_ops ?xs ?deps\n  list_ops (ops @ [(oid, ins)])\n\ngoal (1 subgoal):\n 1. distinct (fst (interp_ops ops))", "by blast"], ["proof (state)\nthis:\n  distinct (fst (interp_ops ops))\n\ngoal (1 subgoal):\n 1. \\<not> (k = 0 \\<or> fst (interp_ops ops) = []) \\<Longrightarrow>\n    list ! min k (length list - 1) = oid", "moreover"], ["proof (state)\nthis:\n  distinct (fst (interp_ops ops))\n\ngoal (1 subgoal):\n 1. \\<not> (k = 0 \\<or> fst (interp_ops ops) = []) \\<Longrightarrow>\n    list ! min k (length list - 1) = oid", "have \"length list = Suc (length (fst (interp_ops ops)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length list = Suc (length (fst (interp_ops ops)))", "using assms(3) calculation"], ["proof (prove)\nusing this:\n  list = fst (interp_ops (ops @ [(oid, ins)]))\n  \\<not> (k = 0 \\<or> fst (interp_ops ops) = [])\n  fst (interp_ops (ops @ [(oid, ins)])) =\n  insert_spec (fst (interp_ops ops))\n   (oid,\n    Some\n     (fst (interp_ops ops) ! min nat (length (fst (interp_ops ops)) - 1)))\n  min nat (length (fst (interp_ops ops)) - 1)\n  < length (fst (interp_ops ops))\n  distinct (fst (interp_ops ops))\n\ngoal (1 subgoal):\n 1. length list = Suc (length (fst (interp_ops ops)))", "by (simp add: insert_spec_inc_length)"], ["proof (state)\nthis:\n  length list = Suc (length (fst (interp_ops ops)))\n\ngoal (1 subgoal):\n 1. \\<not> (k = 0 \\<or> fst (interp_ops ops) = []) \\<Longrightarrow>\n    list ! min k (length list - 1) = oid", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (k = 0 \\<or> fst (interp_ops ops) = [])\n  fst (interp_ops (ops @ [(oid, ins)])) =\n  insert_spec (fst (interp_ops ops))\n   (oid,\n    Some\n     (fst (interp_ops ops) ! min nat (length (fst (interp_ops ops)) - 1)))\n  min nat (length (fst (interp_ops ops)) - 1)\n  < length (fst (interp_ops ops))\n  distinct (fst (interp_ops ops))\n  length list = Suc (length (fst (interp_ops ops)))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (k = 0 \\<or> fst (interp_ops ops) = [])\n  fst (interp_ops (ops @ [(oid, ins)])) =\n  insert_spec (fst (interp_ops ops))\n   (oid,\n    Some\n     (fst (interp_ops ops) ! min nat (length (fst (interp_ops ops)) - 1)))\n  min nat (length (fst (interp_ops ops)) - 1)\n  < length (fst (interp_ops ops))\n  distinct (fst (interp_ops ops))\n  length list = Suc (length (fst (interp_ops ops)))\n\ngoal (1 subgoal):\n 1. list ! min k (length list - 1) = oid", "using assms insert_spec_nth_oid"], ["proof (prove)\nusing this:\n  \\<not> (k = 0 \\<or> fst (interp_ops ops) = [])\n  fst (interp_ops (ops @ [(oid, ins)])) =\n  insert_spec (fst (interp_ops ops))\n   (oid,\n    Some\n     (fst (interp_ops ops) ! min nat (length (fst (interp_ops ops)) - 1)))\n  min nat (length (fst (interp_ops ops)) - 1)\n  < length (fst (interp_ops ops))\n  distinct (fst (interp_ops ops))\n  length list = Suc (length (fst (interp_ops ops)))\n  list_ops (ops @ [(oid, ins)])\n  ins = make_insert (fst (interp_ops ops)) val k\n  list = fst (interp_ops (ops @ [(oid, ins)]))\n  \\<lbrakk>distinct ?xs; ?n < length ?xs\\<rbrakk>\n  \\<Longrightarrow> insert_spec ?xs (?oid, Some (?xs ! ?n)) ! Suc ?n = ?oid\n\ngoal (1 subgoal):\n 1. list ! min k (length list - 1) = oid", "by (metis Suc_diff_1 \\<open>k = Suc nat\\<close> diff_Suc_1 length_greater_0_conv min_Suc_Suc)"], ["proof (state)\nthis:\n  list ! min k (length list - 1) = oid\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Part 2 states that the list order relation must be transitive, irreflexive,\nand total. These three properties are straightforward to prove, using our\ndefinition of the \\isa{list-order} predicate.\\<close>"], ["", "theorem list_order_trans:\n  assumes \"list_ops ops\"\n    and \"list_order ops x y\"\n    and \"list_order ops y z\"\n  shows \"list_order ops x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List_Spec.list_order ops x z", "using assms list_order_trans list_ops_insertions list_order_equiv"], ["proof (prove)\nusing this:\n  list_ops ops\n  List_Spec.list_order ops x y\n  List_Spec.list_order ops y z\n  \\<lbrakk>insert_ops ?op_list; Insert_Spec.list_order ?op_list ?x ?y;\n   Insert_Spec.list_order ?op_list ?y ?z\\<rbrakk>\n  \\<Longrightarrow> Insert_Spec.list_order ?op_list ?x ?z\n  list_ops ?ops \\<Longrightarrow> insert_ops (insertions ?ops)\n  List_Spec.list_order ?ops ?x ?y =\n  Insert_Spec.list_order (insertions ?ops) ?x ?y\n\ngoal (1 subgoal):\n 1. List_Spec.list_order ops x z", "by blast"], ["", "theorem list_order_irrefl:\n  assumes \"list_ops ops\"\n  shows \"\\<not> list_order ops x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> List_Spec.list_order ops x x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> List_Spec.list_order ops x x", "have \"list_order ops x x \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List_Spec.list_order ops x x \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. List_Spec.list_order ops x x \\<Longrightarrow> False", "assume \"list_order ops x x\""], ["proof (state)\nthis:\n  List_Spec.list_order ops x x\n\ngoal (1 subgoal):\n 1. List_Spec.list_order ops x x \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  List_Spec.list_order ops x x", "obtain xs ys zs where split: \"fst (interp_ops ops) = xs @ [x] @ ys @ [x] @ zs\""], ["proof (prove)\nusing this:\n  List_Spec.list_order ops x x\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys zs.\n        fst (interp_ops ops) = xs @ [x] @ ys @ [x] @ zs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson List_Spec.list_order_def)"], ["proof (state)\nthis:\n  fst (interp_ops ops) = xs @ [x] @ ys @ [x] @ zs\n\ngoal (1 subgoal):\n 1. List_Spec.list_order ops x x \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  fst (interp_ops ops) = xs @ [x] @ ys @ [x] @ zs\n\ngoal (1 subgoal):\n 1. List_Spec.list_order ops x x \\<Longrightarrow> False", "have \"distinct (fst (interp_ops ops))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (fst (interp_ops ops))", "by (simp add: assms interp_ops_distinct)"], ["proof (state)\nthis:\n  distinct (fst (interp_ops ops))\n\ngoal (1 subgoal):\n 1. List_Spec.list_order ops x x \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  fst (interp_ops ops) = xs @ [x] @ ys @ [x] @ zs\n  distinct (fst (interp_ops ops))", "show False"], ["proof (prove)\nusing this:\n  fst (interp_ops ops) = xs @ [x] @ ys @ [x] @ zs\n  distinct (fst (interp_ops ops))\n\ngoal (1 subgoal):\n 1. False", "by (simp add: split)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  List_Spec.list_order ops x x \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> List_Spec.list_order ops x x", "thus \"\\<not> list_order ops x x\""], ["proof (prove)\nusing this:\n  List_Spec.list_order ops x x \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> List_Spec.list_order ops x x", "by blast"], ["proof (state)\nthis:\n  \\<not> List_Spec.list_order ops x x\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem list_order_total:\n  assumes \"list_ops ops\"\n    and \"x \\<in> set (fst (interp_ops ops))\"\n    and \"y \\<in> set (fst (interp_ops ops))\"\n    and \"x \\<noteq> y\"\n  shows \"list_order ops x y \\<or> list_order ops y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List_Spec.list_order ops x y \\<or> List_Spec.list_order ops y x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. List_Spec.list_order ops x y \\<or> List_Spec.list_order ops y x", "have \"distinct (fst (interp_ops ops))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (fst (interp_ops ops))", "using assms(1)"], ["proof (prove)\nusing this:\n  list_ops ops\n\ngoal (1 subgoal):\n 1. distinct (fst (interp_ops ops))", "by (simp add: interp_ops_distinct)"], ["proof (state)\nthis:\n  distinct (fst (interp_ops ops))\n\ngoal (1 subgoal):\n 1. List_Spec.list_order ops x y \\<or> List_Spec.list_order ops y x", "then"], ["proof (chain)\npicking this:\n  distinct (fst (interp_ops ops))", "obtain pre mid suf\n    where \"fst (interp_ops ops) = pre @ x # mid @ y # suf \\<or>\n           fst (interp_ops ops) = pre @ y # mid @ x # suf\""], ["proof (prove)\nusing this:\n  distinct (fst (interp_ops ops))\n\ngoal (1 subgoal):\n 1. (\\<And>pre mid suf.\n        fst (interp_ops ops) = pre @ x # mid @ y # suf \\<or>\n        fst (interp_ops ops) = pre @ y # mid @ x # suf \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using list_split_two_elems assms"], ["proof (prove)\nusing this:\n  distinct (fst (interp_ops ops))\n  \\<lbrakk>distinct ?xs; ?x \\<in> set ?xs; ?y \\<in> set ?xs;\n   ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> \\<exists>pre mid suf.\n                       ?xs = pre @ ?x # mid @ ?y # suf \\<or>\n                       ?xs = pre @ ?y # mid @ ?x # suf\n  list_ops ops\n  x \\<in> set (fst (interp_ops ops))\n  y \\<in> set (fst (interp_ops ops))\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. (\\<And>pre mid suf.\n        fst (interp_ops ops) = pre @ x # mid @ y # suf \\<or>\n        fst (interp_ops ops) = pre @ y # mid @ x # suf \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  fst (interp_ops ops) = pre @ x # mid @ y # suf \\<or>\n  fst (interp_ops ops) = pre @ y # mid @ x # suf\n\ngoal (1 subgoal):\n 1. List_Spec.list_order ops x y \\<or> List_Spec.list_order ops y x", "then"], ["proof (chain)\npicking this:\n  fst (interp_ops ops) = pre @ x # mid @ y # suf \\<or>\n  fst (interp_ops ops) = pre @ y # mid @ x # suf", "show \"list_order ops x y \\<or> list_order ops y x\""], ["proof (prove)\nusing this:\n  fst (interp_ops ops) = pre @ x # mid @ y # suf \\<or>\n  fst (interp_ops ops) = pre @ y # mid @ x # suf\n\ngoal (1 subgoal):\n 1. List_Spec.list_order ops x y \\<or> List_Spec.list_order ops y x", "by (simp add: list_order_def, blast)"], ["proof (state)\nthis:\n  List_Spec.list_order ops x y \\<or> List_Spec.list_order ops y x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}