{"file_name": "/home/qj213/afp-2021-10-22/thys/OpSets/Interleaving.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/OpSets", "problem_names": ["lemma map_fst_append1:\n  assumes \"\\<forall>i \\<in> set (map fst xs). P i\"\n    and \"P x\"\n  shows \"\\<forall>i \\<in> set (map fst (xs @ [(x, y)])). P i\"", "lemma insert_ops_split:\n  assumes \"insert_ops ops\"\n    and \"(oid, ref) \\<in> set ops\"\n  shows \"\\<exists>pre suf. ops = pre @ [(oid, ref)] @ suf \\<and>\n            (\\<forall>i \\<in> set (map fst pre). i < oid) \\<and>\n            (\\<forall>i \\<in> set (map fst suf). oid < i)\"", "lemma insert_ops_split_2:\n  assumes \"insert_ops ops\"\n    and \"(xid, xr) \\<in> set ops\"\n    and \"(yid, yr) \\<in> set ops\"\n    and \"xid < yid\"\n  shows \"\\<exists>as bs cs. ops = as @ [(xid, xr)] @ bs @ [(yid, yr)] @ cs \\<and>\n           (\\<forall>i \\<in> set (map fst as). i < xid) \\<and>\n           (\\<forall>i \\<in> set (map fst bs). xid < i \\<and> i < yid) \\<and>\n           (\\<forall>i \\<in> set (map fst cs). yid < i)\"", "lemma insert_ops_sorted_oids:\n  assumes \"insert_ops (xs @ [(i1, r1)] @ ys @ [(i2, r2)])\"\n  shows \"i1 < i2\"", "lemma insert_ops_subset_last:\n  assumes \"insert_ops (xs @ [x])\"\n    and \"insert_ops ys\"\n    and \"set ys \\<subseteq> set (xs @ [x])\"\n    and \"x \\<in> set ys\"\n  shows \"x = last ys\"", "lemma subset_butlast:\n  assumes \"set xs \\<subseteq> set (ys @ [y])\"\n    and \"last xs = y\"\n    and \"distinct xs\"\n  shows \"set (butlast xs) \\<subseteq> set ys\"", "lemma distinct_append_butlast1:\n  assumes \"distinct (map fst xs @ map fst ys)\"\n  shows \"distinct (map fst (butlast xs) @ map fst ys)\"", "lemma distinct_append_butlast2:\n  assumes \"distinct (map fst xs @ map fst ys)\"\n  shows \"distinct (map fst xs @ map fst (butlast ys))\"", "lemma interp_ins_maybe_grow:\n  assumes \"insert_ops (xs @ [(oid, ref)])\"\n  shows \"set (interp_ins (xs @ [(oid, ref)])) = set (interp_ins xs) \\<or>\n         set (interp_ins (xs @ [(oid, ref)])) = (set (interp_ins xs) \\<union> {oid})\"", "lemma interp_ins_maybe_grow2:\n  assumes \"insert_ops (xs @ [x])\"\n  shows \"set (interp_ins (xs @ [x])) = set (interp_ins xs) \\<or>\n         set (interp_ins (xs @ [x])) = (set (interp_ins xs) \\<union> {fst x})\"", "lemma interp_ins_maybe_grow3:\n  assumes \"insert_ops (xs @ ys)\"\n  shows \"\\<exists>A. A \\<subseteq> set (map fst ys) \\<and> set (interp_ins (xs @ ys)) = set (interp_ins xs) \\<union> A\"", "lemma interp_ins_ref_nonex:\n  assumes \"insert_ops ops\"\n    and \"ops = xs @ [(oid, Some ref)] @ ys\"\n    and \"ref \\<notin> set (interp_ins xs)\"\n  shows \"oid \\<notin> set (interp_ins ops)\"", "lemma interp_ins_last_None:\n  shows \"oid \\<in> set (interp_ins (ops @ [(oid, None)]))\"", "lemma interp_ins_monotonic:\n  assumes \"insert_ops (pre @ suf)\"\n    and \"oid \\<in> set (interp_ins pre)\"\n  shows \"oid \\<in> set (interp_ins (pre @ suf))\"", "lemma interp_ins_append_non_memb:\n  assumes \"insert_ops (pre @ [(oid, Some ref)] @ suf)\"\n    and \"ref \\<notin> set (interp_ins pre)\"\n  shows \"ref \\<notin> set (interp_ins (pre @ [(oid, Some ref)] @ suf))\"", "lemma interp_ins_append_memb:\n  assumes \"insert_ops (pre @ [(oid, Some ref)] @ suf)\"\n    and \"ref \\<in> set (interp_ins pre)\"\n  shows \"oid \\<in> set (interp_ins (pre @ [(oid, Some ref)] @ suf))\"", "lemma interp_ins_append_forward:\n  assumes \"insert_ops (xs @ ys)\"\n    and \"oid \\<in> set (interp_ins (xs @ ys))\"\n    and \"oid \\<in> set (map fst xs)\"\n  shows \"oid \\<in> set (interp_ins xs)\"", "lemma interp_ins_find_ref:\n  assumes \"insert_ops (xs @ [(oid, Some ref)] @ ys)\"\n    and \"ref \\<in> set (interp_ins (xs @ [(oid, Some ref)] @ ys))\"\n  shows \"\\<exists>r. (ref, r) \\<in> set xs\"", "lemma list_order_append:\n  assumes \"insert_ops (pre @ suf)\"\n    and \"list_order pre x y\"\n  shows \"list_order (pre @ suf) x y\"", "lemma list_order_insert_ref:\n  assumes \"insert_ops (ops @ [(oid, Some ref)])\"\n    and \"ref \\<in> set (interp_ins ops)\"\n  shows \"list_order (ops @ [(oid, Some ref)]) ref oid\"", "lemma list_order_insert_none:\n  assumes \"insert_ops (ops @ [(oid, None)])\"\n    and \"x \\<in> set (interp_ins ops)\"\n  shows \"list_order (ops @ [(oid, None)]) oid x\"", "lemma list_order_insert_between:\n  assumes \"insert_ops (ops @ [(oid, Some ref)])\"\n    and \"list_order ops ref x\"\n  shows \"list_order (ops @ [(oid, Some ref)]) oid x\"", "lemma insert_seq_nonempty:\n  assumes \"insert_seq start xs\"\n  shows \"xs \\<noteq> []\"", "lemma insert_seq_hd:\n  assumes \"insert_seq start xs\"\n  shows \"\\<exists>oid. hd xs = (oid, start)\"", "lemma insert_seq_rem_last:\n  assumes \"insert_seq start (xs @ [x])\"\n    and \"xs \\<noteq> []\"\n  shows \"insert_seq start xs\"", "lemma insert_seq_butlast:\n  assumes \"insert_seq start xs\"\n    and \"xs \\<noteq> []\" and \"xs \\<noteq> [last xs]\"\n  shows \"insert_seq start (butlast xs)\"", "lemma insert_seq_last_ref:\n  assumes \"insert_seq start (xs @ [(xi, xr), (yi, yr)])\"\n  shows \"yr = Some xi\"", "lemma insert_seq_start_none:\n  assumes \"insert_ops ops\"\n    and \"insert_seq None xs\" and \"insert_ops xs\"\n    and \"set xs \\<subseteq> set ops\"\n  shows \"\\<forall>i \\<in> set (map fst xs). i \\<in> set (interp_ins ops)\"", "lemma insert_seq_after_start:\n  assumes \"insert_ops ops\"\n    and \"insert_seq (Some ref) xs\" and \"insert_ops xs\"\n    and \"set xs \\<subseteq> set ops\"\n    and \"ref \\<in> set (interp_ins ops)\"\n  shows \"\\<forall>i \\<in> set (map fst xs). list_order ops ref i\"", "lemma insert_seq_no_start:\n  assumes \"insert_ops ops\"\n    and \"insert_seq (Some ref) xs\" and \"insert_ops xs\"\n    and \"set xs \\<subseteq> set ops\"\n    and \"ref \\<notin> set (interp_ins ops)\"\n  shows \"\\<forall>i \\<in> set (map fst xs). i \\<notin> set (interp_ins ops)\"", "lemma no_interleaving_ordered:\n  assumes \"insert_ops ops\"\n    and \"insert_seq start xs\" and \"insert_ops xs\"\n    and \"insert_seq start ys\" and \"insert_ops ys\"\n    and \"set xs \\<subseteq> set ops\" and \"set ys \\<subseteq> set ops\"\n    and \"distinct (map fst xs @ map fst ys)\"\n    and \"fst (hd xs) < fst (hd ys)\"\n    and \"\\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)\"\n  shows \"(\\<forall>x \\<in> set (map fst xs). \\<forall>y \\<in> set (map fst ys). list_order ops y x) \\<and>\n         (\\<forall>r. start = Some r \\<longrightarrow> (\\<forall>x \\<in> set (map fst xs). list_order ops r x) \\<and>\n                                 (\\<forall>y \\<in> set (map fst ys). list_order ops r y))\"", "theorem no_interleaving:\n  assumes \"insert_ops ops\"\n    and \"insert_seq start xs\" and \"insert_ops xs\"\n    and \"insert_seq start ys\" and \"insert_ops ys\"\n    and \"set xs \\<subseteq> set ops\" and \"set ys \\<subseteq> set ops\"\n    and \"distinct (map fst xs @ map fst ys)\"\n    and \"start = None \\<or> (\\<exists>r. start = Some r \\<and> r \\<in> set (interp_ins ops))\"\n  shows \"(\\<forall>x \\<in> set (map fst xs). \\<forall>y \\<in> set (map fst ys). list_order ops x y) \\<or>\n         (\\<forall>x \\<in> set (map fst xs). \\<forall>y \\<in> set (map fst ys). list_order ops y x)\"", "theorem missing_start_no_insertion:\n  assumes \"insert_ops ops\"\n    and \"insert_seq (Some start) xs\" and \"insert_ops xs\"\n    and \"insert_seq (Some start) ys\" and \"insert_ops ys\"\n    and \"set xs \\<subseteq> set ops\" and \"set ys \\<subseteq> set ops\"\n    and \"start \\<notin> set (interp_ins ops)\"\n  shows \"\\<forall>x \\<in> set (map fst xs) \\<union> set (map fst ys). x \\<notin> set (interp_ins ops)\""], "translations": [["", "lemma map_fst_append1:\n  assumes \"\\<forall>i \\<in> set (map fst xs). P i\"\n    and \"P x\"\n  shows \"\\<forall>i \\<in> set (map fst (xs @ [(x, y)])). P i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst (xs @ [(x, y)])). P i", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>set (map fst xs). P i\n  P x\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst (xs @ [(x, y)])). P i", "by (induction xs, auto)"], ["", "lemma insert_ops_split:\n  assumes \"insert_ops ops\"\n    and \"(oid, ref) \\<in> set ops\"\n  shows \"\\<exists>pre suf. ops = pre @ [(oid, ref)] @ suf \\<and>\n            (\\<forall>i \\<in> set (map fst pre). i < oid) \\<and>\n            (\\<forall>i \\<in> set (map fst suf). oid < i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       ops = pre @ [(oid, ref)] @ suf \\<and>\n       (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n       (\\<forall>i\\<in>set (map fst suf). oid < i)", "using assms"], ["proof (prove)\nusing this:\n  insert_ops ops\n  (oid, ref) \\<in> set ops\n\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       ops = pre @ [(oid, ref)] @ suf \\<and>\n       (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n       (\\<forall>i\\<in>set (map fst suf). oid < i)", "proof(induction ops rule: List.rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>insert_ops []; (oid, ref) \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         [] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         Ball (set (map fst suf)) ((<) oid)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops xs; (oid, ref) \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pre suf.\n                                     xs = pre @ [(oid, ref)] @ suf \\<and>\n                                     (\\<forall>i\\<in>set (map fst pre).\n   i < oid) \\<and>\n                                     Ball (set (map fst suf)) ((<) oid);\n        insert_ops (xs @ [x]); (oid, ref) \\<in> set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre suf.\n                            xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                            (\\<forall>i\\<in>set (map fst pre).\n                                i < oid) \\<and>\n                            Ball (set (map fst suf)) ((<) oid)", "case Nil"], ["proof (state)\nthis:\n  insert_ops []\n  (oid, ref) \\<in> set []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>insert_ops []; (oid, ref) \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         [] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         Ball (set (map fst suf)) ((<) oid)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops xs; (oid, ref) \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pre suf.\n                                     xs = pre @ [(oid, ref)] @ suf \\<and>\n                                     (\\<forall>i\\<in>set (map fst pre).\n   i < oid) \\<and>\n                                     Ball (set (map fst suf)) ((<) oid);\n        insert_ops (xs @ [x]); (oid, ref) \\<in> set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre suf.\n                            xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                            (\\<forall>i\\<in>set (map fst pre).\n                                i < oid) \\<and>\n                            Ball (set (map fst suf)) ((<) oid)", "then"], ["proof (chain)\npicking this:\n  insert_ops []\n  (oid, ref) \\<in> set []", "show ?case"], ["proof (prove)\nusing this:\n  insert_ops []\n  (oid, ref) \\<in> set []\n\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       [] = pre @ [(oid, ref)] @ suf \\<and>\n       (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n       (\\<forall>a\\<in>set (map fst suf). oid < a)", "by auto"], ["proof (state)\nthis:\n  \\<exists>pre suf.\n     [] = pre @ [(oid, ref)] @ suf \\<and>\n     (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n     (\\<forall>a\\<in>set (map fst suf). oid < a)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops xs; (oid, ref) \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pre suf.\n                                     xs = pre @ [(oid, ref)] @ suf \\<and>\n                                     (\\<forall>i\\<in>set (map fst pre).\n   i < oid) \\<and>\n                                     Ball (set (map fst suf)) ((<) oid);\n        insert_ops (xs @ [x]); (oid, ref) \\<in> set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre suf.\n                            xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                            (\\<forall>i\\<in>set (map fst pre).\n                                i < oid) \\<and>\n                            Ball (set (map fst suf)) ((<) oid)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops xs; (oid, ref) \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pre suf.\n                                     xs = pre @ [(oid, ref)] @ suf \\<and>\n                                     (\\<forall>i\\<in>set (map fst pre).\n   i < oid) \\<and>\n                                     Ball (set (map fst suf)) ((<) oid);\n        insert_ops (xs @ [x]); (oid, ref) \\<in> set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre suf.\n                            xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                            (\\<forall>i\\<in>set (map fst pre).\n                                i < oid) \\<and>\n                            Ball (set (map fst suf)) ((<) oid)", "case (snoc x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>insert_ops xs; (oid, ref) \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>pre suf.\n                       xs = pre @ [(oid, ref)] @ suf \\<and>\n                       (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                       (\\<forall>a\\<in>set (map fst suf). oid < a)\n  insert_ops (xs @ [x])\n  (oid, ref) \\<in> set (xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops xs; (oid, ref) \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pre suf.\n                                     xs = pre @ [(oid, ref)] @ suf \\<and>\n                                     (\\<forall>i\\<in>set (map fst pre).\n   i < oid) \\<and>\n                                     Ball (set (map fst suf)) ((<) oid);\n        insert_ops (xs @ [x]); (oid, ref) \\<in> set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre suf.\n                            xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                            (\\<forall>i\\<in>set (map fst pre).\n                                i < oid) \\<and>\n                            Ball (set (map fst suf)) ((<) oid)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>insert_ops xs; (oid, ref) \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>pre suf.\n                       xs = pre @ [(oid, ref)] @ suf \\<and>\n                       (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                       (\\<forall>a\\<in>set (map fst suf). oid < a)\n  insert_ops (xs @ [x])\n  (oid, ref) \\<in> set (xs @ [x])", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>insert_ops xs; (oid, ref) \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>pre suf.\n                       xs = pre @ [(oid, ref)] @ suf \\<and>\n                       (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                       (\\<forall>a\\<in>set (map fst suf). oid < a)\n  insert_ops (xs @ [x])\n  (oid, ref) \\<in> set (xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n       (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n       (\\<forall>a\\<in>set (map fst suf). oid < a)", "proof(cases \"x = (oid, ref)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>insert_ops xs; (oid, ref) \\<in> set xs\\<rbrakk>\n             \\<Longrightarrow> \\<exists>pre suf.\n                                  xs = pre @ [(oid, ref)] @ suf \\<and>\n                                  (\\<forall>i\\<in>set (map fst pre).\ni < oid) \\<and>\n                                  (\\<forall>a\\<in>set (map fst suf).\noid < a);\n     insert_ops (xs @ [x]); (oid, ref) \\<in> set (xs @ [x]);\n     x = (oid, ref)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)\n 2. \\<lbrakk>\\<lbrakk>insert_ops xs; (oid, ref) \\<in> set xs\\<rbrakk>\n             \\<Longrightarrow> \\<exists>pre suf.\n                                  xs = pre @ [(oid, ref)] @ suf \\<and>\n                                  (\\<forall>i\\<in>set (map fst pre).\ni < oid) \\<and>\n                                  (\\<forall>a\\<in>set (map fst suf).\noid < a);\n     insert_ops (xs @ [x]); (oid, ref) \\<in> set (xs @ [x]);\n     x \\<noteq> (oid, ref)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "case True"], ["proof (state)\nthis:\n  x = (oid, ref)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>insert_ops xs; (oid, ref) \\<in> set xs\\<rbrakk>\n             \\<Longrightarrow> \\<exists>pre suf.\n                                  xs = pre @ [(oid, ref)] @ suf \\<and>\n                                  (\\<forall>i\\<in>set (map fst pre).\ni < oid) \\<and>\n                                  (\\<forall>a\\<in>set (map fst suf).\noid < a);\n     insert_ops (xs @ [x]); (oid, ref) \\<in> set (xs @ [x]);\n     x = (oid, ref)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)\n 2. \\<lbrakk>\\<lbrakk>insert_ops xs; (oid, ref) \\<in> set xs\\<rbrakk>\n             \\<Longrightarrow> \\<exists>pre suf.\n                                  xs = pre @ [(oid, ref)] @ suf \\<and>\n                                  (\\<forall>i\\<in>set (map fst pre).\ni < oid) \\<and>\n                                  (\\<forall>a\\<in>set (map fst suf).\noid < a);\n     insert_ops (xs @ [x]); (oid, ref) \\<in> set (xs @ [x]);\n     x \\<noteq> (oid, ref)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "moreover"], ["proof (state)\nthis:\n  x = (oid, ref)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>insert_ops xs; (oid, ref) \\<in> set xs\\<rbrakk>\n             \\<Longrightarrow> \\<exists>pre suf.\n                                  xs = pre @ [(oid, ref)] @ suf \\<and>\n                                  (\\<forall>i\\<in>set (map fst pre).\ni < oid) \\<and>\n                                  (\\<forall>a\\<in>set (map fst suf).\noid < a);\n     insert_ops (xs @ [x]); (oid, ref) \\<in> set (xs @ [x]);\n     x = (oid, ref)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)\n 2. \\<lbrakk>\\<lbrakk>insert_ops xs; (oid, ref) \\<in> set xs\\<rbrakk>\n             \\<Longrightarrow> \\<exists>pre suf.\n                                  xs = pre @ [(oid, ref)] @ suf \\<and>\n                                  (\\<forall>i\\<in>set (map fst pre).\ni < oid) \\<and>\n                                  (\\<forall>a\\<in>set (map fst suf).\noid < a);\n     insert_ops (xs @ [x]); (oid, ref) \\<in> set (xs @ [x]);\n     x \\<noteq> (oid, ref)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "from this"], ["proof (chain)\npicking this:\n  x = (oid, ref)", "have \"\\<forall>i \\<in> set (map fst xs). i < oid\""], ["proof (prove)\nusing this:\n  x = (oid, ref)\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst xs). i < oid", "using last_op_greatest snoc.prems(1)"], ["proof (prove)\nusing this:\n  x = (oid, ref)\n  \\<lbrakk>insert_ops (?op_list @ [(?oid, ?oper)]);\n   ?x \\<in> set (map fst ?op_list)\\<rbrakk>\n  \\<Longrightarrow> ?x < ?oid\n  insert_ops (xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst xs). i < oid", "by blast"], ["proof (state)\nthis:\n  \\<forall>i\\<in>set (map fst xs). i < oid\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>insert_ops xs; (oid, ref) \\<in> set xs\\<rbrakk>\n             \\<Longrightarrow> \\<exists>pre suf.\n                                  xs = pre @ [(oid, ref)] @ suf \\<and>\n                                  (\\<forall>i\\<in>set (map fst pre).\ni < oid) \\<and>\n                                  (\\<forall>a\\<in>set (map fst suf).\noid < a);\n     insert_ops (xs @ [x]); (oid, ref) \\<in> set (xs @ [x]);\n     x = (oid, ref)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)\n 2. \\<lbrakk>\\<lbrakk>insert_ops xs; (oid, ref) \\<in> set xs\\<rbrakk>\n             \\<Longrightarrow> \\<exists>pre suf.\n                                  xs = pre @ [(oid, ref)] @ suf \\<and>\n                                  (\\<forall>i\\<in>set (map fst pre).\ni < oid) \\<and>\n                                  (\\<forall>a\\<in>set (map fst suf).\noid < a);\n     insert_ops (xs @ [x]); (oid, ref) \\<in> set (xs @ [x]);\n     x \\<noteq> (oid, ref)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "ultimately"], ["proof (chain)\npicking this:\n  x = (oid, ref)\n  \\<forall>i\\<in>set (map fst xs). i < oid", "have \"xs @ [x] = xs @ [(oid, ref)] @ [] \\<and>\n            (\\<forall>i \\<in> set (map fst xs). i < oid) \\<and>\n            (\\<forall>i \\<in> set (map fst []). oid < i)\""], ["proof (prove)\nusing this:\n  x = (oid, ref)\n  \\<forall>i\\<in>set (map fst xs). i < oid\n\ngoal (1 subgoal):\n 1. xs @ [x] = xs @ [(oid, ref)] @ [] \\<and>\n    (\\<forall>i\\<in>set (map fst xs). i < oid) \\<and>\n    (\\<forall>i\\<in>set (map fst []). oid < i)", "by auto"], ["proof (state)\nthis:\n  xs @ [x] = xs @ [(oid, ref)] @ [] \\<and>\n  (\\<forall>i\\<in>set (map fst xs). i < oid) \\<and>\n  (\\<forall>i\\<in>set (map fst []). oid < i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>insert_ops xs; (oid, ref) \\<in> set xs\\<rbrakk>\n             \\<Longrightarrow> \\<exists>pre suf.\n                                  xs = pre @ [(oid, ref)] @ suf \\<and>\n                                  (\\<forall>i\\<in>set (map fst pre).\ni < oid) \\<and>\n                                  (\\<forall>a\\<in>set (map fst suf).\noid < a);\n     insert_ops (xs @ [x]); (oid, ref) \\<in> set (xs @ [x]);\n     x = (oid, ref)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)\n 2. \\<lbrakk>\\<lbrakk>insert_ops xs; (oid, ref) \\<in> set xs\\<rbrakk>\n             \\<Longrightarrow> \\<exists>pre suf.\n                                  xs = pre @ [(oid, ref)] @ suf \\<and>\n                                  (\\<forall>i\\<in>set (map fst pre).\ni < oid) \\<and>\n                                  (\\<forall>a\\<in>set (map fst suf).\noid < a);\n     insert_ops (xs @ [x]); (oid, ref) \\<in> set (xs @ [x]);\n     x \\<noteq> (oid, ref)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "then"], ["proof (chain)\npicking this:\n  xs @ [x] = xs @ [(oid, ref)] @ [] \\<and>\n  (\\<forall>i\\<in>set (map fst xs). i < oid) \\<and>\n  (\\<forall>i\\<in>set (map fst []). oid < i)", "show ?thesis"], ["proof (prove)\nusing this:\n  xs @ [x] = xs @ [(oid, ref)] @ [] \\<and>\n  (\\<forall>i\\<in>set (map fst xs). i < oid) \\<and>\n  (\\<forall>i\\<in>set (map fst []). oid < i)\n\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n       (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n       (\\<forall>a\\<in>set (map fst suf). oid < a)", "by force"], ["proof (state)\nthis:\n  \\<exists>pre suf.\n     xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n     (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n     (\\<forall>a\\<in>set (map fst suf). oid < a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>insert_ops xs; (oid, ref) \\<in> set xs\\<rbrakk>\n             \\<Longrightarrow> \\<exists>pre suf.\n                                  xs = pre @ [(oid, ref)] @ suf \\<and>\n                                  (\\<forall>i\\<in>set (map fst pre).\ni < oid) \\<and>\n                                  (\\<forall>a\\<in>set (map fst suf).\noid < a);\n     insert_ops (xs @ [x]); (oid, ref) \\<in> set (xs @ [x]);\n     x \\<noteq> (oid, ref)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>insert_ops xs; (oid, ref) \\<in> set xs\\<rbrakk>\n             \\<Longrightarrow> \\<exists>pre suf.\n                                  xs = pre @ [(oid, ref)] @ suf \\<and>\n                                  (\\<forall>i\\<in>set (map fst pre).\ni < oid) \\<and>\n                                  (\\<forall>a\\<in>set (map fst suf).\noid < a);\n     insert_ops (xs @ [x]); (oid, ref) \\<in> set (xs @ [x]);\n     x \\<noteq> (oid, ref)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "case False"], ["proof (state)\nthis:\n  x \\<noteq> (oid, ref)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>insert_ops xs; (oid, ref) \\<in> set xs\\<rbrakk>\n             \\<Longrightarrow> \\<exists>pre suf.\n                                  xs = pre @ [(oid, ref)] @ suf \\<and>\n                                  (\\<forall>i\\<in>set (map fst pre).\ni < oid) \\<and>\n                                  (\\<forall>a\\<in>set (map fst suf).\noid < a);\n     insert_ops (xs @ [x]); (oid, ref) \\<in> set (xs @ [x]);\n     x \\<noteq> (oid, ref)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "hence \"(oid, ref) \\<in> set xs\""], ["proof (prove)\nusing this:\n  x \\<noteq> (oid, ref)\n\ngoal (1 subgoal):\n 1. (oid, ref) \\<in> set xs", "using snoc.prems(2)"], ["proof (prove)\nusing this:\n  x \\<noteq> (oid, ref)\n  (oid, ref) \\<in> set (xs @ [x])\n\ngoal (1 subgoal):\n 1. (oid, ref) \\<in> set xs", "by auto"], ["proof (state)\nthis:\n  (oid, ref) \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>insert_ops xs; (oid, ref) \\<in> set xs\\<rbrakk>\n             \\<Longrightarrow> \\<exists>pre suf.\n                                  xs = pre @ [(oid, ref)] @ suf \\<and>\n                                  (\\<forall>i\\<in>set (map fst pre).\ni < oid) \\<and>\n                                  (\\<forall>a\\<in>set (map fst suf).\noid < a);\n     insert_ops (xs @ [x]); (oid, ref) \\<in> set (xs @ [x]);\n     x \\<noteq> (oid, ref)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "from this"], ["proof (chain)\npicking this:\n  (oid, ref) \\<in> set xs", "obtain pre suf where IH: \"xs = pre @ [(oid, ref)] @ suf \\<and>\n         (\\<forall>i \\<in> set (map fst pre). i < oid) \\<and>\n         (\\<forall>i \\<in> set (map fst suf). oid < i)\""], ["proof (prove)\nusing this:\n  (oid, ref) \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        xs = pre @ [(oid, ref)] @ suf \\<and>\n        (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n        (\\<forall>i\\<in>set (map fst suf). oid < i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using snoc.IH snoc.prems(1)"], ["proof (prove)\nusing this:\n  (oid, ref) \\<in> set xs\n  \\<lbrakk>insert_ops xs; (oid, ref) \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>pre suf.\n                       xs = pre @ [(oid, ref)] @ suf \\<and>\n                       (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                       (\\<forall>a\\<in>set (map fst suf). oid < a)\n  insert_ops (xs @ [x])\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        xs = pre @ [(oid, ref)] @ suf \\<and>\n        (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n        (\\<forall>i\\<in>set (map fst suf). oid < i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  xs = pre @ [(oid, ref)] @ suf \\<and>\n  (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n  (\\<forall>i\\<in>set (map fst suf). oid < i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>insert_ops xs; (oid, ref) \\<in> set xs\\<rbrakk>\n             \\<Longrightarrow> \\<exists>pre suf.\n                                  xs = pre @ [(oid, ref)] @ suf \\<and>\n                                  (\\<forall>i\\<in>set (map fst pre).\ni < oid) \\<and>\n                                  (\\<forall>a\\<in>set (map fst suf).\noid < a);\n     insert_ops (xs @ [x]); (oid, ref) \\<in> set (xs @ [x]);\n     x \\<noteq> (oid, ref)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "obtain xi xr where x_pair: \"x = (xi, xr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xi xr. x = (xi, xr) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  x = (xi, xr)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>insert_ops xs; (oid, ref) \\<in> set xs\\<rbrakk>\n             \\<Longrightarrow> \\<exists>pre suf.\n                                  xs = pre @ [(oid, ref)] @ suf \\<and>\n                                  (\\<forall>i\\<in>set (map fst pre).\ni < oid) \\<and>\n                                  (\\<forall>a\\<in>set (map fst suf).\noid < a);\n     insert_ops (xs @ [x]); (oid, ref) \\<in> set (xs @ [x]);\n     x \\<noteq> (oid, ref)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "hence \"distinct (map fst (pre @ [(oid, ref)] @ suf @ [(xi, xr)]))\""], ["proof (prove)\nusing this:\n  x = (xi, xr)\n\ngoal (1 subgoal):\n 1. distinct (map fst (pre @ [(oid, ref)] @ suf @ [(xi, xr)]))", "by (metis IH append.assoc insert_ops_def spec_ops_def snoc.prems(1))"], ["proof (state)\nthis:\n  distinct (map fst (pre @ [(oid, ref)] @ suf @ [(xi, xr)]))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>insert_ops xs; (oid, ref) \\<in> set xs\\<rbrakk>\n             \\<Longrightarrow> \\<exists>pre suf.\n                                  xs = pre @ [(oid, ref)] @ suf \\<and>\n                                  (\\<forall>i\\<in>set (map fst pre).\ni < oid) \\<and>\n                                  (\\<forall>a\\<in>set (map fst suf).\noid < a);\n     insert_ops (xs @ [x]); (oid, ref) \\<in> set (xs @ [x]);\n     x \\<noteq> (oid, ref)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "hence \"xi \\<noteq> oid\""], ["proof (prove)\nusing this:\n  distinct (map fst (pre @ [(oid, ref)] @ suf @ [(xi, xr)]))\n\ngoal (1 subgoal):\n 1. xi \\<noteq> oid", "by auto"], ["proof (state)\nthis:\n  xi \\<noteq> oid\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>insert_ops xs; (oid, ref) \\<in> set xs\\<rbrakk>\n             \\<Longrightarrow> \\<exists>pre suf.\n                                  xs = pre @ [(oid, ref)] @ suf \\<and>\n                                  (\\<forall>i\\<in>set (map fst pre).\ni < oid) \\<and>\n                                  (\\<forall>a\\<in>set (map fst suf).\noid < a);\n     insert_ops (xs @ [x]); (oid, ref) \\<in> set (xs @ [x]);\n     x \\<noteq> (oid, ref)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "have xi_max: \"\\<forall>x \\<in> set (map fst (pre @ [(oid, ref)] @ suf)). x < xi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map fst (pre @ [(oid, ref)] @ suf)). x < xi", "using IH last_op_greatest snoc.prems(1) x_pair"], ["proof (prove)\nusing this:\n  xs = pre @ [(oid, ref)] @ suf \\<and>\n  (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n  (\\<forall>i\\<in>set (map fst suf). oid < i)\n  \\<lbrakk>insert_ops (?op_list @ [(?oid, ?oper)]);\n   ?x \\<in> set (map fst ?op_list)\\<rbrakk>\n  \\<Longrightarrow> ?x < ?oid\n  insert_ops (xs @ [x])\n  x = (xi, xr)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map fst (pre @ [(oid, ref)] @ suf)). x < xi", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map fst (pre @ [(oid, ref)] @ suf)). x < xi\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>insert_ops xs; (oid, ref) \\<in> set xs\\<rbrakk>\n             \\<Longrightarrow> \\<exists>pre suf.\n                                  xs = pre @ [(oid, ref)] @ suf \\<and>\n                                  (\\<forall>i\\<in>set (map fst pre).\ni < oid) \\<and>\n                                  (\\<forall>a\\<in>set (map fst suf).\noid < a);\n     insert_ops (xs @ [x]); (oid, ref) \\<in> set (xs @ [x]);\n     x \\<noteq> (oid, ref)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set (map fst (pre @ [(oid, ref)] @ suf)). x < xi", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (map fst (pre @ [(oid, ref)] @ suf)). x < xi\n\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n       (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n       (\\<forall>a\\<in>set (map fst suf). oid < a)", "proof(cases \"xi < oid\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set (map fst (pre @ [(oid, ref)] @ suf)).\n                x < xi;\n     xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)\n 2. \\<lbrakk>\\<forall>x\\<in>set (map fst (pre @ [(oid, ref)] @ suf)).\n                x < xi;\n     \\<not> xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "case True"], ["proof (state)\nthis:\n  xi < oid\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set (map fst (pre @ [(oid, ref)] @ suf)).\n                x < xi;\n     xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)\n 2. \\<lbrakk>\\<forall>x\\<in>set (map fst (pre @ [(oid, ref)] @ suf)).\n                x < xi;\n     \\<not> xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "moreover"], ["proof (state)\nthis:\n  xi < oid\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set (map fst (pre @ [(oid, ref)] @ suf)).\n                x < xi;\n     xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)\n 2. \\<lbrakk>\\<forall>x\\<in>set (map fst (pre @ [(oid, ref)] @ suf)).\n                x < xi;\n     \\<not> xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "from this"], ["proof (chain)\npicking this:\n  xi < oid", "have \"\\<forall>x \\<in> set suf. fst x < oid\""], ["proof (prove)\nusing this:\n  xi < oid\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set suf. fst x < oid", "using xi_max"], ["proof (prove)\nusing this:\n  xi < oid\n  \\<forall>x\\<in>set (map fst (pre @ [(oid, ref)] @ suf)). x < xi\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set suf. fst x < oid", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set suf. fst x < oid\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set (map fst (pre @ [(oid, ref)] @ suf)).\n                x < xi;\n     xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)\n 2. \\<lbrakk>\\<forall>x\\<in>set (map fst (pre @ [(oid, ref)] @ suf)).\n                x < xi;\n     \\<not> xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "hence \"suf = []\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set suf. fst x < oid\n\ngoal (1 subgoal):\n 1. suf = []", "using IH last_in_set"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set suf. fst x < oid\n  xs = pre @ [(oid, ref)] @ suf \\<and>\n  (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n  (\\<forall>i\\<in>set (map fst suf). oid < i)\n  ?as \\<noteq> [] \\<Longrightarrow> last ?as \\<in> set ?as\n\ngoal (1 subgoal):\n 1. suf = []", "by fastforce"], ["proof (state)\nthis:\n  suf = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set (map fst (pre @ [(oid, ref)] @ suf)).\n                x < xi;\n     xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)\n 2. \\<lbrakk>\\<forall>x\\<in>set (map fst (pre @ [(oid, ref)] @ suf)).\n                x < xi;\n     \\<not> xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "ultimately"], ["proof (chain)\npicking this:\n  xi < oid\n  suf = []", "have \"xs @ [x] = (pre @ [(xi, xr)]) @ [] \\<and>\n              (\\<forall>i \\<in> set (map fst ((pre @ [(xi, xr)]))). i < oid) \\<and>\n              (\\<forall>i \\<in> set (map fst []). oid < i)\""], ["proof (prove)\nusing this:\n  xi < oid\n  suf = []\n\ngoal (1 subgoal):\n 1. xs @ [x] = (pre @ [(xi, xr)]) @ [] \\<and>\n    (\\<forall>i\\<in>set (map fst (pre @ [(xi, xr)])). i < oid) \\<and>\n    (\\<forall>i\\<in>set (map fst []). oid < i)", "using dual_order.asym xi_max"], ["proof (prove)\nusing this:\n  xi < oid\n  suf = []\n  \\<lbrakk>?b < ?a; ?a < ?b\\<rbrakk> \\<Longrightarrow> False\n  \\<forall>x\\<in>set (map fst (pre @ [(oid, ref)] @ suf)). x < xi\n\ngoal (1 subgoal):\n 1. xs @ [x] = (pre @ [(xi, xr)]) @ [] \\<and>\n    (\\<forall>i\\<in>set (map fst (pre @ [(xi, xr)])). i < oid) \\<and>\n    (\\<forall>i\\<in>set (map fst []). oid < i)", "by auto"], ["proof (state)\nthis:\n  xs @ [x] = (pre @ [(xi, xr)]) @ [] \\<and>\n  (\\<forall>i\\<in>set (map fst (pre @ [(xi, xr)])). i < oid) \\<and>\n  (\\<forall>i\\<in>set (map fst []). oid < i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set (map fst (pre @ [(oid, ref)] @ suf)).\n                x < xi;\n     xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)\n 2. \\<lbrakk>\\<forall>x\\<in>set (map fst (pre @ [(oid, ref)] @ suf)).\n                x < xi;\n     \\<not> xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "then"], ["proof (chain)\npicking this:\n  xs @ [x] = (pre @ [(xi, xr)]) @ [] \\<and>\n  (\\<forall>i\\<in>set (map fst (pre @ [(xi, xr)])). i < oid) \\<and>\n  (\\<forall>i\\<in>set (map fst []). oid < i)", "show ?thesis"], ["proof (prove)\nusing this:\n  xs @ [x] = (pre @ [(xi, xr)]) @ [] \\<and>\n  (\\<forall>i\\<in>set (map fst (pre @ [(xi, xr)])). i < oid) \\<and>\n  (\\<forall>i\\<in>set (map fst []). oid < i)\n\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n       (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n       (\\<forall>a\\<in>set (map fst suf). oid < a)", "by (simp add: IH)"], ["proof (state)\nthis:\n  \\<exists>pre suf.\n     xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n     (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n     (\\<forall>a\\<in>set (map fst suf). oid < a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set (map fst (pre @ [(oid, ref)] @ suf)).\n                x < xi;\n     \\<not> xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set (map fst (pre @ [(oid, ref)] @ suf)).\n                x < xi;\n     \\<not> xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "case False"], ["proof (state)\nthis:\n  \\<not> xi < oid\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set (map fst (pre @ [(oid, ref)] @ suf)).\n                x < xi;\n     \\<not> xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "hence \"oid < xi\""], ["proof (prove)\nusing this:\n  \\<not> xi < oid\n\ngoal (1 subgoal):\n 1. oid < xi", "using \\<open>xi \\<noteq> oid\\<close>"], ["proof (prove)\nusing this:\n  \\<not> xi < oid\n  xi \\<noteq> oid\n\ngoal (1 subgoal):\n 1. oid < xi", "by auto"], ["proof (state)\nthis:\n  oid < xi\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set (map fst (pre @ [(oid, ref)] @ suf)).\n                x < xi;\n     \\<not> xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "hence \"\\<forall>i \\<in> set (map fst (suf @ [(xi, xr)])). oid < i\""], ["proof (prove)\nusing this:\n  oid < xi\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst (suf @ [(xi, xr)])). oid < i", "using IH map_fst_append1"], ["proof (prove)\nusing this:\n  oid < xi\n  xs = pre @ [(oid, ref)] @ suf \\<and>\n  (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n  (\\<forall>i\\<in>set (map fst suf). oid < i)\n  \\<lbrakk>\\<forall>i\\<in>set (map fst ?xs). ?P i; ?P ?x\\<rbrakk>\n  \\<Longrightarrow> \\<forall>i\\<in>set (map fst (?xs @ [(?x, ?y)])). ?P i\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst (suf @ [(xi, xr)])). oid < i", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<in>set (map fst (suf @ [(xi, xr)])). oid < i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set (map fst (pre @ [(oid, ref)] @ suf)).\n                x < xi;\n     \\<not> xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "hence \"xs @ [x] = pre @ [(oid, ref)] @ (suf @ [(xi, xr)]) \\<and>\n              (\\<forall>i \\<in> set (map fst pre). i < oid) \\<and>\n              (\\<forall>i \\<in> set (map fst (suf @ [(xi, xr)])). oid < i)\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>set (map fst (suf @ [(xi, xr)])). oid < i\n\ngoal (1 subgoal):\n 1. xs @ [x] = pre @ [(oid, ref)] @ suf @ [(xi, xr)] \\<and>\n    (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n    (\\<forall>i\\<in>set (map fst (suf @ [(xi, xr)])). oid < i)", "by (simp add: IH x_pair)"], ["proof (state)\nthis:\n  xs @ [x] = pre @ [(oid, ref)] @ suf @ [(xi, xr)] \\<and>\n  (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n  (\\<forall>i\\<in>set (map fst (suf @ [(xi, xr)])). oid < i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set (map fst (pre @ [(oid, ref)] @ suf)).\n                x < xi;\n     \\<not> xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "then"], ["proof (chain)\npicking this:\n  xs @ [x] = pre @ [(oid, ref)] @ suf @ [(xi, xr)] \\<and>\n  (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n  (\\<forall>i\\<in>set (map fst (suf @ [(xi, xr)])). oid < i)", "show ?thesis"], ["proof (prove)\nusing this:\n  xs @ [x] = pre @ [(oid, ref)] @ suf @ [(xi, xr)] \\<and>\n  (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n  (\\<forall>i\\<in>set (map fst (suf @ [(xi, xr)])). oid < i)\n\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n       (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n       (\\<forall>a\\<in>set (map fst suf). oid < a)", "by blast"], ["proof (state)\nthis:\n  \\<exists>pre suf.\n     xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n     (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n     (\\<forall>a\\<in>set (map fst suf). oid < a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>pre suf.\n     xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n     (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n     (\\<forall>a\\<in>set (map fst suf). oid < a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>pre suf.\n     xs @ [x] = pre @ [(oid, ref)] @ suf \\<and>\n     (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n     (\\<forall>a\\<in>set (map fst suf). oid < a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_ops_split_2:\n  assumes \"insert_ops ops\"\n    and \"(xid, xr) \\<in> set ops\"\n    and \"(yid, yr) \\<in> set ops\"\n    and \"xid < yid\"\n  shows \"\\<exists>as bs cs. ops = as @ [(xid, xr)] @ bs @ [(yid, yr)] @ cs \\<and>\n           (\\<forall>i \\<in> set (map fst as). i < xid) \\<and>\n           (\\<forall>i \\<in> set (map fst bs). xid < i \\<and> i < yid) \\<and>\n           (\\<forall>i \\<in> set (map fst cs). yid < i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as bs cs.\n       ops = as @ [(xid, xr)] @ bs @ [(yid, yr)] @ cs \\<and>\n       (\\<forall>i\\<in>set (map fst as). i < xid) \\<and>\n       (\\<forall>i\\<in>set (map fst bs). xid < i \\<and> i < yid) \\<and>\n       (\\<forall>i\\<in>set (map fst cs). yid < i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as bs cs.\n       ops = as @ [(xid, xr)] @ bs @ [(yid, yr)] @ cs \\<and>\n       (\\<forall>i\\<in>set (map fst as). i < xid) \\<and>\n       (\\<forall>i\\<in>set (map fst bs). xid < i \\<and> i < yid) \\<and>\n       (\\<forall>i\\<in>set (map fst cs). yid < i)", "obtain as as1 where x_split: \"ops = as @ [(xid, xr)] @ as1 \\<and>\n      (\\<forall>i \\<in> set (map fst as). i < xid) \\<and> (\\<forall>i \\<in> set (map fst as1). xid < i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as as1.\n        ops = as @ [(xid, xr)] @ as1 \\<and>\n        (\\<forall>i\\<in>set (map fst as). i < xid) \\<and>\n        (\\<forall>i\\<in>set (map fst as1). xid < i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms insert_ops_split"], ["proof (prove)\nusing this:\n  insert_ops ops\n  (xid, xr) \\<in> set ops\n  (yid, yr) \\<in> set ops\n  xid < yid\n  \\<lbrakk>insert_ops ?ops; (?oid, ?ref) \\<in> set ?ops\\<rbrakk>\n  \\<Longrightarrow> \\<exists>pre suf.\n                       ?ops = pre @ [(?oid, ?ref)] @ suf \\<and>\n                       (\\<forall>i\\<in>set (map fst pre). i < ?oid) \\<and>\n                       (\\<forall>i\\<in>set (map fst suf). ?oid < i)\n\ngoal (1 subgoal):\n 1. (\\<And>as as1.\n        ops = as @ [(xid, xr)] @ as1 \\<and>\n        (\\<forall>i\\<in>set (map fst as). i < xid) \\<and>\n        (\\<forall>i\\<in>set (map fst as1). xid < i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ops = as @ [(xid, xr)] @ as1 \\<and>\n  (\\<forall>i\\<in>set (map fst as). i < xid) \\<and>\n  (\\<forall>i\\<in>set (map fst as1). xid < i)\n\ngoal (1 subgoal):\n 1. \\<exists>as bs cs.\n       ops = as @ [(xid, xr)] @ bs @ [(yid, yr)] @ cs \\<and>\n       (\\<forall>i\\<in>set (map fst as). i < xid) \\<and>\n       (\\<forall>i\\<in>set (map fst bs). xid < i \\<and> i < yid) \\<and>\n       (\\<forall>i\\<in>set (map fst cs). yid < i)", "hence \"insert_ops ((as @ [(xid, xr)]) @ as1)\""], ["proof (prove)\nusing this:\n  ops = as @ [(xid, xr)] @ as1 \\<and>\n  (\\<forall>i\\<in>set (map fst as). i < xid) \\<and>\n  (\\<forall>i\\<in>set (map fst as1). xid < i)\n\ngoal (1 subgoal):\n 1. insert_ops ((as @ [(xid, xr)]) @ as1)", "using assms(1)"], ["proof (prove)\nusing this:\n  ops = as @ [(xid, xr)] @ as1 \\<and>\n  (\\<forall>i\\<in>set (map fst as). i < xid) \\<and>\n  (\\<forall>i\\<in>set (map fst as1). xid < i)\n  insert_ops ops\n\ngoal (1 subgoal):\n 1. insert_ops ((as @ [(xid, xr)]) @ as1)", "by auto"], ["proof (state)\nthis:\n  insert_ops ((as @ [(xid, xr)]) @ as1)\n\ngoal (1 subgoal):\n 1. \\<exists>as bs cs.\n       ops = as @ [(xid, xr)] @ bs @ [(yid, yr)] @ cs \\<and>\n       (\\<forall>i\\<in>set (map fst as). i < xid) \\<and>\n       (\\<forall>i\\<in>set (map fst bs). xid < i \\<and> i < yid) \\<and>\n       (\\<forall>i\\<in>set (map fst cs). yid < i)", "hence \"insert_ops as1\""], ["proof (prove)\nusing this:\n  insert_ops ((as @ [(xid, xr)]) @ as1)\n\ngoal (1 subgoal):\n 1. insert_ops as1", "using assms(1) insert_ops_rem_prefix"], ["proof (prove)\nusing this:\n  insert_ops ((as @ [(xid, xr)]) @ as1)\n  insert_ops ops\n  insert_ops (?pre @ ?suf) \\<Longrightarrow> insert_ops ?suf\n\ngoal (1 subgoal):\n 1. insert_ops as1", "by blast"], ["proof (state)\nthis:\n  insert_ops as1\n\ngoal (1 subgoal):\n 1. \\<exists>as bs cs.\n       ops = as @ [(xid, xr)] @ bs @ [(yid, yr)] @ cs \\<and>\n       (\\<forall>i\\<in>set (map fst as). i < xid) \\<and>\n       (\\<forall>i\\<in>set (map fst bs). xid < i \\<and> i < yid) \\<and>\n       (\\<forall>i\\<in>set (map fst cs). yid < i)", "have \"(yid, yr) \\<in> set as1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (yid, yr) \\<in> set as1", "using x_split assms"], ["proof (prove)\nusing this:\n  ops = as @ [(xid, xr)] @ as1 \\<and>\n  (\\<forall>i\\<in>set (map fst as). i < xid) \\<and>\n  (\\<forall>i\\<in>set (map fst as1). xid < i)\n  insert_ops ops\n  (xid, xr) \\<in> set ops\n  (yid, yr) \\<in> set ops\n  xid < yid\n\ngoal (1 subgoal):\n 1. (yid, yr) \\<in> set as1", "by auto"], ["proof (state)\nthis:\n  (yid, yr) \\<in> set as1\n\ngoal (1 subgoal):\n 1. \\<exists>as bs cs.\n       ops = as @ [(xid, xr)] @ bs @ [(yid, yr)] @ cs \\<and>\n       (\\<forall>i\\<in>set (map fst as). i < xid) \\<and>\n       (\\<forall>i\\<in>set (map fst bs). xid < i \\<and> i < yid) \\<and>\n       (\\<forall>i\\<in>set (map fst cs). yid < i)", "from this"], ["proof (chain)\npicking this:\n  (yid, yr) \\<in> set as1", "obtain bs cs where y_split: \"as1 = bs @ [(yid, yr)] @ cs \\<and>\n      (\\<forall>i \\<in> set (map fst bs). i < yid) \\<and> (\\<forall>i \\<in> set (map fst cs). yid < i)\""], ["proof (prove)\nusing this:\n  (yid, yr) \\<in> set as1\n\ngoal (1 subgoal):\n 1. (\\<And>bs cs.\n        as1 = bs @ [(yid, yr)] @ cs \\<and>\n        (\\<forall>i\\<in>set (map fst bs). i < yid) \\<and>\n        (\\<forall>i\\<in>set (map fst cs). yid < i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms insert_ops_split \\<open>insert_ops as1\\<close>"], ["proof (prove)\nusing this:\n  (yid, yr) \\<in> set as1\n  insert_ops ops\n  (xid, xr) \\<in> set ops\n  (yid, yr) \\<in> set ops\n  xid < yid\n  \\<lbrakk>insert_ops ?ops; (?oid, ?ref) \\<in> set ?ops\\<rbrakk>\n  \\<Longrightarrow> \\<exists>pre suf.\n                       ?ops = pre @ [(?oid, ?ref)] @ suf \\<and>\n                       (\\<forall>i\\<in>set (map fst pre). i < ?oid) \\<and>\n                       (\\<forall>i\\<in>set (map fst suf). ?oid < i)\n  insert_ops as1\n\ngoal (1 subgoal):\n 1. (\\<And>bs cs.\n        as1 = bs @ [(yid, yr)] @ cs \\<and>\n        (\\<forall>i\\<in>set (map fst bs). i < yid) \\<and>\n        (\\<forall>i\\<in>set (map fst cs). yid < i) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  as1 = bs @ [(yid, yr)] @ cs \\<and>\n  (\\<forall>i\\<in>set (map fst bs). i < yid) \\<and>\n  (\\<forall>i\\<in>set (map fst cs). yid < i)\n\ngoal (1 subgoal):\n 1. \\<exists>as bs cs.\n       ops = as @ [(xid, xr)] @ bs @ [(yid, yr)] @ cs \\<and>\n       (\\<forall>i\\<in>set (map fst as). i < xid) \\<and>\n       (\\<forall>i\\<in>set (map fst bs). xid < i \\<and> i < yid) \\<and>\n       (\\<forall>i\\<in>set (map fst cs). yid < i)", "hence \"ops = as @ [(xid, xr)] @ bs @ [(yid, yr)] @ cs\""], ["proof (prove)\nusing this:\n  as1 = bs @ [(yid, yr)] @ cs \\<and>\n  (\\<forall>i\\<in>set (map fst bs). i < yid) \\<and>\n  (\\<forall>i\\<in>set (map fst cs). yid < i)\n\ngoal (1 subgoal):\n 1. ops = as @ [(xid, xr)] @ bs @ [(yid, yr)] @ cs", "using x_split"], ["proof (prove)\nusing this:\n  as1 = bs @ [(yid, yr)] @ cs \\<and>\n  (\\<forall>i\\<in>set (map fst bs). i < yid) \\<and>\n  (\\<forall>i\\<in>set (map fst cs). yid < i)\n  ops = as @ [(xid, xr)] @ as1 \\<and>\n  (\\<forall>i\\<in>set (map fst as). i < xid) \\<and>\n  (\\<forall>i\\<in>set (map fst as1). xid < i)\n\ngoal (1 subgoal):\n 1. ops = as @ [(xid, xr)] @ bs @ [(yid, yr)] @ cs", "by blast"], ["proof (state)\nthis:\n  ops = as @ [(xid, xr)] @ bs @ [(yid, yr)] @ cs\n\ngoal (1 subgoal):\n 1. \\<exists>as bs cs.\n       ops = as @ [(xid, xr)] @ bs @ [(yid, yr)] @ cs \\<and>\n       (\\<forall>i\\<in>set (map fst as). i < xid) \\<and>\n       (\\<forall>i\\<in>set (map fst bs). xid < i \\<and> i < yid) \\<and>\n       (\\<forall>i\\<in>set (map fst cs). yid < i)", "moreover"], ["proof (state)\nthis:\n  ops = as @ [(xid, xr)] @ bs @ [(yid, yr)] @ cs\n\ngoal (1 subgoal):\n 1. \\<exists>as bs cs.\n       ops = as @ [(xid, xr)] @ bs @ [(yid, yr)] @ cs \\<and>\n       (\\<forall>i\\<in>set (map fst as). i < xid) \\<and>\n       (\\<forall>i\\<in>set (map fst bs). xid < i \\<and> i < yid) \\<and>\n       (\\<forall>i\\<in>set (map fst cs). yid < i)", "have \"\\<forall>i \\<in> set (map fst bs). xid < i \\<and> i < yid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst bs). xid < i \\<and> i < yid", "by (simp add: x_split y_split)"], ["proof (state)\nthis:\n  \\<forall>i\\<in>set (map fst bs). xid < i \\<and> i < yid\n\ngoal (1 subgoal):\n 1. \\<exists>as bs cs.\n       ops = as @ [(xid, xr)] @ bs @ [(yid, yr)] @ cs \\<and>\n       (\\<forall>i\\<in>set (map fst as). i < xid) \\<and>\n       (\\<forall>i\\<in>set (map fst bs). xid < i \\<and> i < yid) \\<and>\n       (\\<forall>i\\<in>set (map fst cs). yid < i)", "ultimately"], ["proof (chain)\npicking this:\n  ops = as @ [(xid, xr)] @ bs @ [(yid, yr)] @ cs\n  \\<forall>i\\<in>set (map fst bs). xid < i \\<and> i < yid", "show ?thesis"], ["proof (prove)\nusing this:\n  ops = as @ [(xid, xr)] @ bs @ [(yid, yr)] @ cs\n  \\<forall>i\\<in>set (map fst bs). xid < i \\<and> i < yid\n\ngoal (1 subgoal):\n 1. \\<exists>as bs cs.\n       ops = as @ [(xid, xr)] @ bs @ [(yid, yr)] @ cs \\<and>\n       (\\<forall>i\\<in>set (map fst as). i < xid) \\<and>\n       (\\<forall>i\\<in>set (map fst bs). xid < i \\<and> i < yid) \\<and>\n       (\\<forall>i\\<in>set (map fst cs). yid < i)", "using x_split y_split"], ["proof (prove)\nusing this:\n  ops = as @ [(xid, xr)] @ bs @ [(yid, yr)] @ cs\n  \\<forall>i\\<in>set (map fst bs). xid < i \\<and> i < yid\n  ops = as @ [(xid, xr)] @ as1 \\<and>\n  (\\<forall>i\\<in>set (map fst as). i < xid) \\<and>\n  (\\<forall>i\\<in>set (map fst as1). xid < i)\n  as1 = bs @ [(yid, yr)] @ cs \\<and>\n  (\\<forall>i\\<in>set (map fst bs). i < yid) \\<and>\n  (\\<forall>i\\<in>set (map fst cs). yid < i)\n\ngoal (1 subgoal):\n 1. \\<exists>as bs cs.\n       ops = as @ [(xid, xr)] @ bs @ [(yid, yr)] @ cs \\<and>\n       (\\<forall>i\\<in>set (map fst as). i < xid) \\<and>\n       (\\<forall>i\\<in>set (map fst bs). xid < i \\<and> i < yid) \\<and>\n       (\\<forall>i\\<in>set (map fst cs). yid < i)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as bs cs.\n     ops = as @ [(xid, xr)] @ bs @ [(yid, yr)] @ cs \\<and>\n     (\\<forall>i\\<in>set (map fst as). i < xid) \\<and>\n     (\\<forall>i\\<in>set (map fst bs). xid < i \\<and> i < yid) \\<and>\n     (\\<forall>i\\<in>set (map fst cs). yid < i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_ops_sorted_oids:\n  assumes \"insert_ops (xs @ [(i1, r1)] @ ys @ [(i2, r2)])\"\n  shows \"i1 < i2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i1 < i2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i1 < i2", "have \"\\<And>i. i \\<in> set (map fst (xs @ [(i1, r1)] @ ys)) \\<Longrightarrow> i < i2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> set (map fst (xs @ [(i1, r1)] @ ys)) \\<Longrightarrow> i < i2", "by (metis append.assoc assms last_op_greatest)"], ["proof (state)\nthis:\n  ?i \\<in> set (map fst (xs @ [(i1, r1)] @ ys)) \\<Longrightarrow> ?i < i2\n\ngoal (1 subgoal):\n 1. i1 < i2", "moreover"], ["proof (state)\nthis:\n  ?i \\<in> set (map fst (xs @ [(i1, r1)] @ ys)) \\<Longrightarrow> ?i < i2\n\ngoal (1 subgoal):\n 1. i1 < i2", "have \"i1 \\<in> set (map fst (xs @ [(i1, r1)] @ ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i1 \\<in> set (map fst (xs @ [(i1, r1)] @ ys))", "by auto"], ["proof (state)\nthis:\n  i1 \\<in> set (map fst (xs @ [(i1, r1)] @ ys))\n\ngoal (1 subgoal):\n 1. i1 < i2", "ultimately"], ["proof (chain)\npicking this:\n  ?i \\<in> set (map fst (xs @ [(i1, r1)] @ ys)) \\<Longrightarrow> ?i < i2\n  i1 \\<in> set (map fst (xs @ [(i1, r1)] @ ys))", "show \"i1 < i2\""], ["proof (prove)\nusing this:\n  ?i \\<in> set (map fst (xs @ [(i1, r1)] @ ys)) \\<Longrightarrow> ?i < i2\n  i1 \\<in> set (map fst (xs @ [(i1, r1)] @ ys))\n\ngoal (1 subgoal):\n 1. i1 < i2", "by blast"], ["proof (state)\nthis:\n  i1 < i2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_ops_subset_last:\n  assumes \"insert_ops (xs @ [x])\"\n    and \"insert_ops ys\"\n    and \"set ys \\<subseteq> set (xs @ [x])\"\n    and \"x \\<in> set ys\"\n  shows \"x = last ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = last ys", "using assms"], ["proof (prove)\nusing this:\n  insert_ops (xs @ [x])\n  insert_ops ys\n  set ys \\<subseteq> set (xs @ [x])\n  x \\<in> set ys\n\ngoal (1 subgoal):\n 1. x = last ys", "proof(induction ys, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ys.\n       \\<lbrakk>\\<lbrakk>insert_ops (xs @ [x]); insert_ops ys;\n                 set ys \\<subseteq> set (xs @ [x]); x \\<in> set ys\\<rbrakk>\n                \\<Longrightarrow> x = last ys;\n        insert_ops (xs @ [x]); insert_ops (a # ys);\n        set (a # ys) \\<subseteq> set (xs @ [x]);\n        x \\<in> set (a # ys)\\<rbrakk>\n       \\<Longrightarrow> x = last (a # ys)", "case (Cons y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>insert_ops (xs @ [x]); insert_ops ys;\n   set ys \\<subseteq> set (xs @ [x]); x \\<in> set ys\\<rbrakk>\n  \\<Longrightarrow> x = last ys\n  insert_ops (xs @ [x])\n  insert_ops (y # ys)\n  set (y # ys) \\<subseteq> set (xs @ [x])\n  x \\<in> set (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>a ys.\n       \\<lbrakk>\\<lbrakk>insert_ops (xs @ [x]); insert_ops ys;\n                 set ys \\<subseteq> set (xs @ [x]); x \\<in> set ys\\<rbrakk>\n                \\<Longrightarrow> x = last ys;\n        insert_ops (xs @ [x]); insert_ops (a # ys);\n        set (a # ys) \\<subseteq> set (xs @ [x]);\n        x \\<in> set (a # ys)\\<rbrakk>\n       \\<Longrightarrow> x = last (a # ys)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>insert_ops (xs @ [x]); insert_ops ys;\n   set ys \\<subseteq> set (xs @ [x]); x \\<in> set ys\\<rbrakk>\n  \\<Longrightarrow> x = last ys\n  insert_ops (xs @ [x])\n  insert_ops (y # ys)\n  set (y # ys) \\<subseteq> set (xs @ [x])\n  x \\<in> set (y # ys)", "show \"x = last (y # ys)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>insert_ops (xs @ [x]); insert_ops ys;\n   set ys \\<subseteq> set (xs @ [x]); x \\<in> set ys\\<rbrakk>\n  \\<Longrightarrow> x = last ys\n  insert_ops (xs @ [x])\n  insert_ops (y # ys)\n  set (y # ys) \\<subseteq> set (xs @ [x])\n  x \\<in> set (y # ys)\n\ngoal (1 subgoal):\n 1. x = last (y # ys)", "proof(cases \"ys = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>insert_ops (xs @ [x]); insert_ops ys;\n              set ys \\<subseteq> set (xs @ [x]); x \\<in> set ys\\<rbrakk>\n             \\<Longrightarrow> x = last ys;\n     insert_ops (xs @ [x]); insert_ops (y # ys);\n     set (y # ys) \\<subseteq> set (xs @ [x]); x \\<in> set (y # ys);\n     ys = []\\<rbrakk>\n    \\<Longrightarrow> x = last (y # ys)\n 2. \\<lbrakk>\\<lbrakk>insert_ops (xs @ [x]); insert_ops ys;\n              set ys \\<subseteq> set (xs @ [x]); x \\<in> set ys\\<rbrakk>\n             \\<Longrightarrow> x = last ys;\n     insert_ops (xs @ [x]); insert_ops (y # ys);\n     set (y # ys) \\<subseteq> set (xs @ [x]); x \\<in> set (y # ys);\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> x = last (y # ys)", "case True"], ["proof (state)\nthis:\n  ys = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>insert_ops (xs @ [x]); insert_ops ys;\n              set ys \\<subseteq> set (xs @ [x]); x \\<in> set ys\\<rbrakk>\n             \\<Longrightarrow> x = last ys;\n     insert_ops (xs @ [x]); insert_ops (y # ys);\n     set (y # ys) \\<subseteq> set (xs @ [x]); x \\<in> set (y # ys);\n     ys = []\\<rbrakk>\n    \\<Longrightarrow> x = last (y # ys)\n 2. \\<lbrakk>\\<lbrakk>insert_ops (xs @ [x]); insert_ops ys;\n              set ys \\<subseteq> set (xs @ [x]); x \\<in> set ys\\<rbrakk>\n             \\<Longrightarrow> x = last ys;\n     insert_ops (xs @ [x]); insert_ops (y # ys);\n     set (y # ys) \\<subseteq> set (xs @ [x]); x \\<in> set (y # ys);\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> x = last (y # ys)", "then"], ["proof (chain)\npicking this:\n  ys = []", "show \"x = last (y # ys)\""], ["proof (prove)\nusing this:\n  ys = []\n\ngoal (1 subgoal):\n 1. x = last (y # ys)", "using Cons.prems(4)"], ["proof (prove)\nusing this:\n  ys = []\n  x \\<in> set (y # ys)\n\ngoal (1 subgoal):\n 1. x = last (y # ys)", "by auto"], ["proof (state)\nthis:\n  x = last (y # ys)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>insert_ops (xs @ [x]); insert_ops ys;\n              set ys \\<subseteq> set (xs @ [x]); x \\<in> set ys\\<rbrakk>\n             \\<Longrightarrow> x = last ys;\n     insert_ops (xs @ [x]); insert_ops (y # ys);\n     set (y # ys) \\<subseteq> set (xs @ [x]); x \\<in> set (y # ys);\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> x = last (y # ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>insert_ops (xs @ [x]); insert_ops ys;\n              set ys \\<subseteq> set (xs @ [x]); x \\<in> set ys\\<rbrakk>\n             \\<Longrightarrow> x = last ys;\n     insert_ops (xs @ [x]); insert_ops (y # ys);\n     set (y # ys) \\<subseteq> set (xs @ [x]); x \\<in> set (y # ys);\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> x = last (y # ys)", "case ys_nonempty: False"], ["proof (state)\nthis:\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>insert_ops (xs @ [x]); insert_ops ys;\n              set ys \\<subseteq> set (xs @ [x]); x \\<in> set ys\\<rbrakk>\n             \\<Longrightarrow> x = last ys;\n     insert_ops (xs @ [x]); insert_ops (y # ys);\n     set (y # ys) \\<subseteq> set (xs @ [x]); x \\<in> set (y # ys);\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> x = last (y # ys)", "have \"x \\<noteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y", "obtain mid l where \"ys = mid @ [l]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mid l. ys = mid @ [l] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using append_butlast_last_id ys_nonempty"], ["proof (prove)\nusing this:\n  ?xs \\<noteq> [] \\<Longrightarrow> butlast ?xs @ [last ?xs] = ?xs\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>mid l. ys = mid @ [l] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  ys = mid @ [l]\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "moreover"], ["proof (state)\nthis:\n  ys = mid @ [l]\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "obtain li lr where \"l = (li, lr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>li lr. l = (li, lr) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  l = (li, lr)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "moreover"], ["proof (state)\nthis:\n  l = (li, lr)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "have \"\\<And>i. i \\<in> set (map fst (y # mid)) \\<Longrightarrow> i < li\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> set (map fst (y # mid)) \\<Longrightarrow> i < li", "by (metis last_op_greatest Cons.prems(2) calculation append_Cons)"], ["proof (state)\nthis:\n  ?i \\<in> set (map fst (y # mid)) \\<Longrightarrow> ?i < li\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "hence \"fst y < li\""], ["proof (prove)\nusing this:\n  ?i \\<in> set (map fst (y # mid)) \\<Longrightarrow> ?i < li\n\ngoal (1 subgoal):\n 1. fst y < li", "by simp"], ["proof (state)\nthis:\n  fst y < li\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "moreover"], ["proof (state)\nthis:\n  fst y < li\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "have \"\\<And>i. i \\<in> set (map fst xs) \\<Longrightarrow> i < fst x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> set (map fst xs) \\<Longrightarrow> i < fst x", "using assms(1) last_op_greatest"], ["proof (prove)\nusing this:\n  insert_ops (xs @ [x])\n  \\<lbrakk>insert_ops (?op_list @ [(?oid, ?oper)]);\n   ?x \\<in> set (map fst ?op_list)\\<rbrakk>\n  \\<Longrightarrow> ?x < ?oid\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> set (map fst xs) \\<Longrightarrow> i < fst x", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  ?i \\<in> set (map fst xs) \\<Longrightarrow> ?i < fst x\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "hence \"\\<And>i. i \\<in> set (map fst (y # ys)) \\<Longrightarrow> i \\<le> fst x\""], ["proof (prove)\nusing this:\n  ?i \\<in> set (map fst xs) \\<Longrightarrow> ?i < fst x\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> set (map fst (y # ys)) \\<Longrightarrow> i \\<le> fst x", "using Cons.prems(3)"], ["proof (prove)\nusing this:\n  ?i \\<in> set (map fst xs) \\<Longrightarrow> ?i < fst x\n  set (y # ys) \\<subseteq> set (xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> set (map fst (y # ys)) \\<Longrightarrow> i \\<le> fst x", "by fastforce"], ["proof (state)\nthis:\n  ?i \\<in> set (map fst (y # ys)) \\<Longrightarrow> ?i \\<le> fst x\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "ultimately"], ["proof (chain)\npicking this:\n  ys = mid @ [l]\n  l = (li, lr)\n  fst y < li\n  ?i \\<in> set (map fst (y # ys)) \\<Longrightarrow> ?i \\<le> fst x", "show \"x \\<noteq> y\""], ["proof (prove)\nusing this:\n  ys = mid @ [l]\n  l = (li, lr)\n  fst y < li\n  ?i \\<in> set (map fst (y # ys)) \\<Longrightarrow> ?i \\<le> fst x\n\ngoal (1 subgoal):\n 1. x \\<noteq> y", "by fastforce"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>insert_ops (xs @ [x]); insert_ops ys;\n              set ys \\<subseteq> set (xs @ [x]); x \\<in> set ys\\<rbrakk>\n             \\<Longrightarrow> x = last ys;\n     insert_ops (xs @ [x]); insert_ops (y # ys);\n     set (y # ys) \\<subseteq> set (xs @ [x]); x \\<in> set (y # ys);\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> x = last (y # ys)", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> y", "show \"x = last (y # ys)\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x = last (y # ys)", "using Cons.IH Cons.prems insert_ops_rem_cons ys_nonempty"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  \\<lbrakk>insert_ops (xs @ [x]); insert_ops ys;\n   set ys \\<subseteq> set (xs @ [x]); x \\<in> set ys\\<rbrakk>\n  \\<Longrightarrow> x = last ys\n  insert_ops (xs @ [x])\n  insert_ops (y # ys)\n  set (y # ys) \\<subseteq> set (xs @ [x])\n  x \\<in> set (y # ys)\n  insert_ops (?x # ?xs) \\<Longrightarrow> insert_ops ?xs\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. x = last (y # ys)", "by (metis dual_order.trans last_ConsR set_ConsD set_subset_Cons)"], ["proof (state)\nthis:\n  x = last (y # ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = last (y # ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subset_butlast:\n  assumes \"set xs \\<subseteq> set (ys @ [y])\"\n    and \"last xs = y\"\n    and \"distinct xs\"\n  shows \"set (butlast xs) \\<subseteq> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (butlast xs) \\<subseteq> set ys", "using assms"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> set (ys @ [y])\n  last xs = y\n  distinct xs\n\ngoal (1 subgoal):\n 1. set (butlast xs) \\<subseteq> set ys", "by (induction xs, auto)"], ["", "lemma distinct_append_butlast1:\n  assumes \"distinct (map fst xs @ map fst ys)\"\n  shows \"distinct (map fst (butlast xs) @ map fst ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (butlast xs) @ map fst ys)", "using assms"], ["proof (prove)\nusing this:\n  distinct (map fst xs @ map fst ys)\n\ngoal (1 subgoal):\n 1. distinct (map fst (butlast xs) @ map fst ys)", "proof(induction xs, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs @ map fst ys) \\<Longrightarrow>\n                distinct (map fst (butlast xs) @ map fst ys);\n        distinct (map fst (a # xs) @ map fst ys)\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (butlast (a # xs)) @ map fst ys)", "case (Cons a xs)"], ["proof (state)\nthis:\n  distinct (map fst xs @ map fst ys) \\<Longrightarrow>\n  distinct (map fst (butlast xs) @ map fst ys)\n  distinct (map fst (a # xs) @ map fst ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs @ map fst ys) \\<Longrightarrow>\n                distinct (map fst (butlast xs) @ map fst ys);\n        distinct (map fst (a # xs) @ map fst ys)\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (butlast (a # xs)) @ map fst ys)", "have \"fst a \\<notin> set (map fst xs @ map fst ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst a \\<notin> set (map fst xs @ map fst ys)", "using Cons.prems"], ["proof (prove)\nusing this:\n  distinct (map fst (a # xs) @ map fst ys)\n\ngoal (1 subgoal):\n 1. fst a \\<notin> set (map fst xs @ map fst ys)", "by auto"], ["proof (state)\nthis:\n  fst a \\<notin> set (map fst xs @ map fst ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs @ map fst ys) \\<Longrightarrow>\n                distinct (map fst (butlast xs) @ map fst ys);\n        distinct (map fst (a # xs) @ map fst ys)\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (butlast (a # xs)) @ map fst ys)", "moreover"], ["proof (state)\nthis:\n  fst a \\<notin> set (map fst xs @ map fst ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs @ map fst ys) \\<Longrightarrow>\n                distinct (map fst (butlast xs) @ map fst ys);\n        distinct (map fst (a # xs) @ map fst ys)\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (butlast (a # xs)) @ map fst ys)", "have \"set (map fst (butlast xs)) \\<subseteq> set (map fst xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map fst (butlast xs)) \\<subseteq> set (map fst xs)", "by (metis in_set_butlastD map_butlast subsetI)"], ["proof (state)\nthis:\n  set (map fst (butlast xs)) \\<subseteq> set (map fst xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs @ map fst ys) \\<Longrightarrow>\n                distinct (map fst (butlast xs) @ map fst ys);\n        distinct (map fst (a # xs) @ map fst ys)\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (butlast (a # xs)) @ map fst ys)", "hence \"set (map fst (butlast xs) @ map fst ys) \\<subseteq> set (map fst xs @ map fst ys)\""], ["proof (prove)\nusing this:\n  set (map fst (butlast xs)) \\<subseteq> set (map fst xs)\n\ngoal (1 subgoal):\n 1. set (map fst (butlast xs) @ map fst ys)\n    \\<subseteq> set (map fst xs @ map fst ys)", "by auto"], ["proof (state)\nthis:\n  set (map fst (butlast xs) @ map fst ys)\n  \\<subseteq> set (map fst xs @ map fst ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs @ map fst ys) \\<Longrightarrow>\n                distinct (map fst (butlast xs) @ map fst ys);\n        distinct (map fst (a # xs) @ map fst ys)\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (butlast (a # xs)) @ map fst ys)", "ultimately"], ["proof (chain)\npicking this:\n  fst a \\<notin> set (map fst xs @ map fst ys)\n  set (map fst (butlast xs) @ map fst ys)\n  \\<subseteq> set (map fst xs @ map fst ys)", "have \"fst a \\<notin> set (map fst (butlast xs) @ map fst ys)\""], ["proof (prove)\nusing this:\n  fst a \\<notin> set (map fst xs @ map fst ys)\n  set (map fst (butlast xs) @ map fst ys)\n  \\<subseteq> set (map fst xs @ map fst ys)\n\ngoal (1 subgoal):\n 1. fst a \\<notin> set (map fst (butlast xs) @ map fst ys)", "by blast"], ["proof (state)\nthis:\n  fst a \\<notin> set (map fst (butlast xs) @ map fst ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs @ map fst ys) \\<Longrightarrow>\n                distinct (map fst (butlast xs) @ map fst ys);\n        distinct (map fst (a # xs) @ map fst ys)\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (butlast (a # xs)) @ map fst ys)", "then"], ["proof (chain)\npicking this:\n  fst a \\<notin> set (map fst (butlast xs) @ map fst ys)", "show \"distinct (map fst (butlast (a # xs)) @ map fst ys)\""], ["proof (prove)\nusing this:\n  fst a \\<notin> set (map fst (butlast xs) @ map fst ys)\n\ngoal (1 subgoal):\n 1. distinct (map fst (butlast (a # xs)) @ map fst ys)", "using Cons.IH Cons.prems"], ["proof (prove)\nusing this:\n  fst a \\<notin> set (map fst (butlast xs) @ map fst ys)\n  distinct (map fst xs @ map fst ys) \\<Longrightarrow>\n  distinct (map fst (butlast xs) @ map fst ys)\n  distinct (map fst (a # xs) @ map fst ys)\n\ngoal (1 subgoal):\n 1. distinct (map fst (butlast (a # xs)) @ map fst ys)", "by auto"], ["proof (state)\nthis:\n  distinct (map fst (butlast (a # xs)) @ map fst ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_append_butlast2:\n  assumes \"distinct (map fst xs @ map fst ys)\"\n  shows \"distinct (map fst xs @ map fst (butlast ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst xs @ map fst (butlast ys))", "using assms"], ["proof (prove)\nusing this:\n  distinct (map fst xs @ map fst ys)\n\ngoal (1 subgoal):\n 1. distinct (map fst xs @ map fst (butlast ys))", "proof(induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct (map fst [] @ map fst ys) \\<Longrightarrow>\n    distinct (map fst [] @ map fst (butlast ys))\n 2. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs @ map fst ys) \\<Longrightarrow>\n                distinct (map fst xs @ map fst (butlast ys));\n        distinct (map fst (a # xs) @ map fst ys)\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (a # xs) @ map fst (butlast ys))", "case Nil"], ["proof (state)\nthis:\n  distinct (map fst [] @ map fst ys)\n\ngoal (2 subgoals):\n 1. distinct (map fst [] @ map fst ys) \\<Longrightarrow>\n    distinct (map fst [] @ map fst (butlast ys))\n 2. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs @ map fst ys) \\<Longrightarrow>\n                distinct (map fst xs @ map fst (butlast ys));\n        distinct (map fst (a # xs) @ map fst ys)\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (a # xs) @ map fst (butlast ys))", "then"], ["proof (chain)\npicking this:\n  distinct (map fst [] @ map fst ys)", "show \"distinct (map fst [] @ map fst (butlast ys))\""], ["proof (prove)\nusing this:\n  distinct (map fst [] @ map fst ys)\n\ngoal (1 subgoal):\n 1. distinct (map fst [] @ map fst (butlast ys))", "by (simp add: distinct_butlast map_butlast)"], ["proof (state)\nthis:\n  distinct (map fst [] @ map fst (butlast ys))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs @ map fst ys) \\<Longrightarrow>\n                distinct (map fst xs @ map fst (butlast ys));\n        distinct (map fst (a # xs) @ map fst ys)\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (a # xs) @ map fst (butlast ys))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs @ map fst ys) \\<Longrightarrow>\n                distinct (map fst xs @ map fst (butlast ys));\n        distinct (map fst (a # xs) @ map fst ys)\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (a # xs) @ map fst (butlast ys))", "case (Cons a xs)"], ["proof (state)\nthis:\n  distinct (map fst xs @ map fst ys) \\<Longrightarrow>\n  distinct (map fst xs @ map fst (butlast ys))\n  distinct (map fst (a # xs) @ map fst ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs @ map fst ys) \\<Longrightarrow>\n                distinct (map fst xs @ map fst (butlast ys));\n        distinct (map fst (a # xs) @ map fst ys)\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (a # xs) @ map fst (butlast ys))", "have \"fst a \\<notin> set (map fst xs @ map fst ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst a \\<notin> set (map fst xs @ map fst ys)", "using Cons.prems"], ["proof (prove)\nusing this:\n  distinct (map fst (a # xs) @ map fst ys)\n\ngoal (1 subgoal):\n 1. fst a \\<notin> set (map fst xs @ map fst ys)", "by auto"], ["proof (state)\nthis:\n  fst a \\<notin> set (map fst xs @ map fst ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs @ map fst ys) \\<Longrightarrow>\n                distinct (map fst xs @ map fst (butlast ys));\n        distinct (map fst (a # xs) @ map fst ys)\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (a # xs) @ map fst (butlast ys))", "moreover"], ["proof (state)\nthis:\n  fst a \\<notin> set (map fst xs @ map fst ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs @ map fst ys) \\<Longrightarrow>\n                distinct (map fst xs @ map fst (butlast ys));\n        distinct (map fst (a # xs) @ map fst ys)\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (a # xs) @ map fst (butlast ys))", "have \"set (map fst (butlast ys)) \\<subseteq> set (map fst ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map fst (butlast ys)) \\<subseteq> set (map fst ys)", "by (metis in_set_butlastD map_butlast subsetI)"], ["proof (state)\nthis:\n  set (map fst (butlast ys)) \\<subseteq> set (map fst ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs @ map fst ys) \\<Longrightarrow>\n                distinct (map fst xs @ map fst (butlast ys));\n        distinct (map fst (a # xs) @ map fst ys)\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (a # xs) @ map fst (butlast ys))", "hence \"set (map fst xs @ map fst (butlast ys)) \\<subseteq> set (map fst xs @ map fst ys)\""], ["proof (prove)\nusing this:\n  set (map fst (butlast ys)) \\<subseteq> set (map fst ys)\n\ngoal (1 subgoal):\n 1. set (map fst xs @ map fst (butlast ys))\n    \\<subseteq> set (map fst xs @ map fst ys)", "by auto"], ["proof (state)\nthis:\n  set (map fst xs @ map fst (butlast ys))\n  \\<subseteq> set (map fst xs @ map fst ys)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs @ map fst ys) \\<Longrightarrow>\n                distinct (map fst xs @ map fst (butlast ys));\n        distinct (map fst (a # xs) @ map fst ys)\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (a # xs) @ map fst (butlast ys))", "ultimately"], ["proof (chain)\npicking this:\n  fst a \\<notin> set (map fst xs @ map fst ys)\n  set (map fst xs @ map fst (butlast ys))\n  \\<subseteq> set (map fst xs @ map fst ys)", "have \"fst a \\<notin> set (map fst xs @ map fst (butlast ys))\""], ["proof (prove)\nusing this:\n  fst a \\<notin> set (map fst xs @ map fst ys)\n  set (map fst xs @ map fst (butlast ys))\n  \\<subseteq> set (map fst xs @ map fst ys)\n\ngoal (1 subgoal):\n 1. fst a \\<notin> set (map fst xs @ map fst (butlast ys))", "by blast"], ["proof (state)\nthis:\n  fst a \\<notin> set (map fst xs @ map fst (butlast ys))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs @ map fst ys) \\<Longrightarrow>\n                distinct (map fst xs @ map fst (butlast ys));\n        distinct (map fst (a # xs) @ map fst ys)\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (a # xs) @ map fst (butlast ys))", "then"], ["proof (chain)\npicking this:\n  fst a \\<notin> set (map fst xs @ map fst (butlast ys))", "show ?case"], ["proof (prove)\nusing this:\n  fst a \\<notin> set (map fst xs @ map fst (butlast ys))\n\ngoal (1 subgoal):\n 1. distinct (map fst (a # xs) @ map fst (butlast ys))", "using Cons.IH Cons.prems"], ["proof (prove)\nusing this:\n  fst a \\<notin> set (map fst xs @ map fst (butlast ys))\n  distinct (map fst xs @ map fst ys) \\<Longrightarrow>\n  distinct (map fst xs @ map fst (butlast ys))\n  distinct (map fst (a # xs) @ map fst ys)\n\ngoal (1 subgoal):\n 1. distinct (map fst (a # xs) @ map fst (butlast ys))", "by auto"], ["proof (state)\nthis:\n  distinct (map fst (a # xs) @ map fst (butlast ys))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Lemmas about \\isa{interp-ins}\\<close>"], ["", "lemma interp_ins_maybe_grow:\n  assumes \"insert_ops (xs @ [(oid, ref)])\"\n  shows \"set (interp_ins (xs @ [(oid, ref)])) = set (interp_ins xs) \\<or>\n         set (interp_ins (xs @ [(oid, ref)])) = (set (interp_ins xs) \\<union> {oid})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (interp_ins (xs @ [(oid, ref)])) = set (interp_ins xs) \\<or>\n    set (interp_ins (xs @ [(oid, ref)])) =\n    set (interp_ins xs) \\<union> {oid}", "by (cases ref, simp add: interp_ins_tail_unfold,\n      metis insert_spec_nonex insert_spec_set interp_ins_tail_unfold)"], ["", "lemma interp_ins_maybe_grow2:\n  assumes \"insert_ops (xs @ [x])\"\n  shows \"set (interp_ins (xs @ [x])) = set (interp_ins xs) \\<or>\n         set (interp_ins (xs @ [x])) = (set (interp_ins xs) \\<union> {fst x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (interp_ins (xs @ [x])) = set (interp_ins xs) \\<or>\n    set (interp_ins (xs @ [x])) = set (interp_ins xs) \\<union> {fst x}", "using assms interp_ins_maybe_grow"], ["proof (prove)\nusing this:\n  insert_ops (xs @ [x])\n  insert_ops (?xs @ [(?oid, ?ref)]) \\<Longrightarrow>\n  set (interp_ins (?xs @ [(?oid, ?ref)])) = set (interp_ins ?xs) \\<or>\n  set (interp_ins (?xs @ [(?oid, ?ref)])) =\n  set (interp_ins ?xs) \\<union> {?oid}\n\ngoal (1 subgoal):\n 1. set (interp_ins (xs @ [x])) = set (interp_ins xs) \\<or>\n    set (interp_ins (xs @ [x])) = set (interp_ins xs) \\<union> {fst x}", "by (cases x, auto)"], ["", "lemma interp_ins_maybe_grow3:\n  assumes \"insert_ops (xs @ ys)\"\n  shows \"\\<exists>A. A \\<subseteq> set (map fst ys) \\<and> set (interp_ins (xs @ ys)) = set (interp_ins xs) \\<union> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A\\<subseteq>set (map fst ys).\n       set (interp_ins (xs @ ys)) = set (interp_ins xs) \\<union> A", "using assms"], ["proof (prove)\nusing this:\n  insert_ops (xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<exists>A\\<subseteq>set (map fst ys).\n       set (interp_ins (xs @ ys)) = set (interp_ins xs) \\<union> A", "proof(induction ys rule: List.rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. insert_ops (xs @ []) \\<Longrightarrow>\n    \\<exists>A\\<subseteq>set (map fst []).\n       set (interp_ins (xs @ [])) = set (interp_ins xs) \\<union> A\n 2. \\<And>x xsa.\n       \\<lbrakk>insert_ops (xs @ xsa) \\<Longrightarrow>\n                \\<exists>A\\<subseteq>set (map fst xsa).\n                   set (interp_ins (xs @ xsa)) =\n                   set (interp_ins xs) \\<union> A;\n        insert_ops (xs @ xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<subseteq>set (map fst (xsa @ [x])).\n                            set (interp_ins (xs @ xsa @ [x])) =\n                            set (interp_ins xs) \\<union> A", "case Nil"], ["proof (state)\nthis:\n  insert_ops (xs @ [])\n\ngoal (2 subgoals):\n 1. insert_ops (xs @ []) \\<Longrightarrow>\n    \\<exists>A\\<subseteq>set (map fst []).\n       set (interp_ins (xs @ [])) = set (interp_ins xs) \\<union> A\n 2. \\<And>x xsa.\n       \\<lbrakk>insert_ops (xs @ xsa) \\<Longrightarrow>\n                \\<exists>A\\<subseteq>set (map fst xsa).\n                   set (interp_ins (xs @ xsa)) =\n                   set (interp_ins xs) \\<union> A;\n        insert_ops (xs @ xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<subseteq>set (map fst (xsa @ [x])).\n                            set (interp_ins (xs @ xsa @ [x])) =\n                            set (interp_ins xs) \\<union> A", "then"], ["proof (chain)\npicking this:\n  insert_ops (xs @ [])", "show ?case"], ["proof (prove)\nusing this:\n  insert_ops (xs @ [])\n\ngoal (1 subgoal):\n 1. \\<exists>A\\<subseteq>set (map fst []).\n       set (interp_ins (xs @ [])) = set (interp_ins xs) \\<union> A", "by simp"], ["proof (state)\nthis:\n  \\<exists>A\\<subseteq>set (map fst []).\n     set (interp_ins (xs @ [])) = set (interp_ins xs) \\<union> A\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>insert_ops (xs @ xsa) \\<Longrightarrow>\n                \\<exists>A\\<subseteq>set (map fst xsa).\n                   set (interp_ins (xs @ xsa)) =\n                   set (interp_ins xs) \\<union> A;\n        insert_ops (xs @ xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<subseteq>set (map fst (xsa @ [x])).\n                            set (interp_ins (xs @ xsa @ [x])) =\n                            set (interp_ins xs) \\<union> A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>insert_ops (xs @ xsa) \\<Longrightarrow>\n                \\<exists>A\\<subseteq>set (map fst xsa).\n                   set (interp_ins (xs @ xsa)) =\n                   set (interp_ins xs) \\<union> A;\n        insert_ops (xs @ xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<subseteq>set (map fst (xsa @ [x])).\n                            set (interp_ins (xs @ xsa @ [x])) =\n                            set (interp_ins xs) \\<union> A", "case (snoc x ys)"], ["proof (state)\nthis:\n  insert_ops (xs @ ys) \\<Longrightarrow>\n  \\<exists>A\\<subseteq>set (map fst ys).\n     set (interp_ins (xs @ ys)) = set (interp_ins xs) \\<union> A\n  insert_ops (xs @ ys @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>insert_ops (xs @ xsa) \\<Longrightarrow>\n                \\<exists>A\\<subseteq>set (map fst xsa).\n                   set (interp_ins (xs @ xsa)) =\n                   set (interp_ins xs) \\<union> A;\n        insert_ops (xs @ xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<subseteq>set (map fst (xsa @ [x])).\n                            set (interp_ins (xs @ xsa @ [x])) =\n                            set (interp_ins xs) \\<union> A", "then"], ["proof (chain)\npicking this:\n  insert_ops (xs @ ys) \\<Longrightarrow>\n  \\<exists>A\\<subseteq>set (map fst ys).\n     set (interp_ins (xs @ ys)) = set (interp_ins xs) \\<union> A\n  insert_ops (xs @ ys @ [x])", "have \"insert_ops (xs @ ys)\""], ["proof (prove)\nusing this:\n  insert_ops (xs @ ys) \\<Longrightarrow>\n  \\<exists>A\\<subseteq>set (map fst ys).\n     set (interp_ins (xs @ ys)) = set (interp_ins xs) \\<union> A\n  insert_ops (xs @ ys @ [x])\n\ngoal (1 subgoal):\n 1. insert_ops (xs @ ys)", "by (metis append_assoc insert_ops_rem_last)"], ["proof (state)\nthis:\n  insert_ops (xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>insert_ops (xs @ xsa) \\<Longrightarrow>\n                \\<exists>A\\<subseteq>set (map fst xsa).\n                   set (interp_ins (xs @ xsa)) =\n                   set (interp_ins xs) \\<union> A;\n        insert_ops (xs @ xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<subseteq>set (map fst (xsa @ [x])).\n                            set (interp_ins (xs @ xsa @ [x])) =\n                            set (interp_ins xs) \\<union> A", "then"], ["proof (chain)\npicking this:\n  insert_ops (xs @ ys)", "obtain A where IH: \"A \\<subseteq> set (map fst ys) \\<and>\n            set (interp_ins (xs @ ys)) = set (interp_ins xs) \\<union> A\""], ["proof (prove)\nusing this:\n  insert_ops (xs @ ys)\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        A \\<subseteq> set (map fst ys) \\<and>\n        set (interp_ins (xs @ ys)) =\n        set (interp_ins xs) \\<union> A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using snoc.IH"], ["proof (prove)\nusing this:\n  insert_ops (xs @ ys)\n  insert_ops (xs @ ys) \\<Longrightarrow>\n  \\<exists>A\\<subseteq>set (map fst ys).\n     set (interp_ins (xs @ ys)) = set (interp_ins xs) \\<union> A\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        A \\<subseteq> set (map fst ys) \\<and>\n        set (interp_ins (xs @ ys)) =\n        set (interp_ins xs) \\<union> A \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  A \\<subseteq> set (map fst ys) \\<and>\n  set (interp_ins (xs @ ys)) = set (interp_ins xs) \\<union> A\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>insert_ops (xs @ xsa) \\<Longrightarrow>\n                \\<exists>A\\<subseteq>set (map fst xsa).\n                   set (interp_ins (xs @ xsa)) =\n                   set (interp_ins xs) \\<union> A;\n        insert_ops (xs @ xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A\\<subseteq>set (map fst (xsa @ [x])).\n                            set (interp_ins (xs @ xsa @ [x])) =\n                            set (interp_ins xs) \\<union> A", "then"], ["proof (chain)\npicking this:\n  A \\<subseteq> set (map fst ys) \\<and>\n  set (interp_ins (xs @ ys)) = set (interp_ins xs) \\<union> A", "show ?case"], ["proof (prove)\nusing this:\n  A \\<subseteq> set (map fst ys) \\<and>\n  set (interp_ins (xs @ ys)) = set (interp_ins xs) \\<union> A\n\ngoal (1 subgoal):\n 1. \\<exists>A\\<subseteq>set (map fst (ys @ [x])).\n       set (interp_ins (xs @ ys @ [x])) = set (interp_ins xs) \\<union> A", "proof(cases \"set (interp_ins (xs @ ys @ [x])) = set (interp_ins (xs @ ys))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<subseteq> set (map fst ys) \\<and>\n             set (interp_ins (xs @ ys)) = set (interp_ins xs) \\<union> A;\n     set (interp_ins (xs @ ys @ [x])) = set (interp_ins (xs @ ys))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A\\<subseteq>set (map fst (ys @ [x])).\n                         set (interp_ins (xs @ ys @ [x])) =\n                         set (interp_ins xs) \\<union> A\n 2. \\<lbrakk>A \\<subseteq> set (map fst ys) \\<and>\n             set (interp_ins (xs @ ys)) = set (interp_ins xs) \\<union> A;\n     set (interp_ins (xs @ ys @ [x])) \\<noteq>\n     set (interp_ins (xs @ ys))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A\\<subseteq>set (map fst (ys @ [x])).\n                         set (interp_ins (xs @ ys @ [x])) =\n                         set (interp_ins xs) \\<union> A", "case True"], ["proof (state)\nthis:\n  set (interp_ins (xs @ ys @ [x])) = set (interp_ins (xs @ ys))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<subseteq> set (map fst ys) \\<and>\n             set (interp_ins (xs @ ys)) = set (interp_ins xs) \\<union> A;\n     set (interp_ins (xs @ ys @ [x])) = set (interp_ins (xs @ ys))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A\\<subseteq>set (map fst (ys @ [x])).\n                         set (interp_ins (xs @ ys @ [x])) =\n                         set (interp_ins xs) \\<union> A\n 2. \\<lbrakk>A \\<subseteq> set (map fst ys) \\<and>\n             set (interp_ins (xs @ ys)) = set (interp_ins xs) \\<union> A;\n     set (interp_ins (xs @ ys @ [x])) \\<noteq>\n     set (interp_ins (xs @ ys))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A\\<subseteq>set (map fst (ys @ [x])).\n                         set (interp_ins (xs @ ys @ [x])) =\n                         set (interp_ins xs) \\<union> A", "moreover"], ["proof (state)\nthis:\n  set (interp_ins (xs @ ys @ [x])) = set (interp_ins (xs @ ys))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<subseteq> set (map fst ys) \\<and>\n             set (interp_ins (xs @ ys)) = set (interp_ins xs) \\<union> A;\n     set (interp_ins (xs @ ys @ [x])) = set (interp_ins (xs @ ys))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A\\<subseteq>set (map fst (ys @ [x])).\n                         set (interp_ins (xs @ ys @ [x])) =\n                         set (interp_ins xs) \\<union> A\n 2. \\<lbrakk>A \\<subseteq> set (map fst ys) \\<and>\n             set (interp_ins (xs @ ys)) = set (interp_ins xs) \\<union> A;\n     set (interp_ins (xs @ ys @ [x])) \\<noteq>\n     set (interp_ins (xs @ ys))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A\\<subseteq>set (map fst (ys @ [x])).\n                         set (interp_ins (xs @ ys @ [x])) =\n                         set (interp_ins xs) \\<union> A", "have \"A \\<subseteq> set (map fst (ys @ [x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> set (map fst (ys @ [x]))", "using IH"], ["proof (prove)\nusing this:\n  A \\<subseteq> set (map fst ys) \\<and>\n  set (interp_ins (xs @ ys)) = set (interp_ins xs) \\<union> A\n\ngoal (1 subgoal):\n 1. A \\<subseteq> set (map fst (ys @ [x]))", "by auto"], ["proof (state)\nthis:\n  A \\<subseteq> set (map fst (ys @ [x]))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<subseteq> set (map fst ys) \\<and>\n             set (interp_ins (xs @ ys)) = set (interp_ins xs) \\<union> A;\n     set (interp_ins (xs @ ys @ [x])) = set (interp_ins (xs @ ys))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A\\<subseteq>set (map fst (ys @ [x])).\n                         set (interp_ins (xs @ ys @ [x])) =\n                         set (interp_ins xs) \\<union> A\n 2. \\<lbrakk>A \\<subseteq> set (map fst ys) \\<and>\n             set (interp_ins (xs @ ys)) = set (interp_ins xs) \\<union> A;\n     set (interp_ins (xs @ ys @ [x])) \\<noteq>\n     set (interp_ins (xs @ ys))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A\\<subseteq>set (map fst (ys @ [x])).\n                         set (interp_ins (xs @ ys @ [x])) =\n                         set (interp_ins xs) \\<union> A", "ultimately"], ["proof (chain)\npicking this:\n  set (interp_ins (xs @ ys @ [x])) = set (interp_ins (xs @ ys))\n  A \\<subseteq> set (map fst (ys @ [x]))", "show ?thesis"], ["proof (prove)\nusing this:\n  set (interp_ins (xs @ ys @ [x])) = set (interp_ins (xs @ ys))\n  A \\<subseteq> set (map fst (ys @ [x]))\n\ngoal (1 subgoal):\n 1. \\<exists>A\\<subseteq>set (map fst (ys @ [x])).\n       set (interp_ins (xs @ ys @ [x])) = set (interp_ins xs) \\<union> A", "using IH"], ["proof (prove)\nusing this:\n  set (interp_ins (xs @ ys @ [x])) = set (interp_ins (xs @ ys))\n  A \\<subseteq> set (map fst (ys @ [x]))\n  A \\<subseteq> set (map fst ys) \\<and>\n  set (interp_ins (xs @ ys)) = set (interp_ins xs) \\<union> A\n\ngoal (1 subgoal):\n 1. \\<exists>A\\<subseteq>set (map fst (ys @ [x])).\n       set (interp_ins (xs @ ys @ [x])) = set (interp_ins xs) \\<union> A", "by auto"], ["proof (state)\nthis:\n  \\<exists>A\\<subseteq>set (map fst (ys @ [x])).\n     set (interp_ins (xs @ ys @ [x])) = set (interp_ins xs) \\<union> A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<subseteq> set (map fst ys) \\<and>\n             set (interp_ins (xs @ ys)) = set (interp_ins xs) \\<union> A;\n     set (interp_ins (xs @ ys @ [x])) \\<noteq>\n     set (interp_ins (xs @ ys))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A\\<subseteq>set (map fst (ys @ [x])).\n                         set (interp_ins (xs @ ys @ [x])) =\n                         set (interp_ins xs) \\<union> A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<subseteq> set (map fst ys) \\<and>\n             set (interp_ins (xs @ ys)) = set (interp_ins xs) \\<union> A;\n     set (interp_ins (xs @ ys @ [x])) \\<noteq>\n     set (interp_ins (xs @ ys))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A\\<subseteq>set (map fst (ys @ [x])).\n                         set (interp_ins (xs @ ys @ [x])) =\n                         set (interp_ins xs) \\<union> A", "case False"], ["proof (state)\nthis:\n  set (interp_ins (xs @ ys @ [x])) \\<noteq> set (interp_ins (xs @ ys))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<subseteq> set (map fst ys) \\<and>\n             set (interp_ins (xs @ ys)) = set (interp_ins xs) \\<union> A;\n     set (interp_ins (xs @ ys @ [x])) \\<noteq>\n     set (interp_ins (xs @ ys))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A\\<subseteq>set (map fst (ys @ [x])).\n                         set (interp_ins (xs @ ys @ [x])) =\n                         set (interp_ins xs) \\<union> A", "then"], ["proof (chain)\npicking this:\n  set (interp_ins (xs @ ys @ [x])) \\<noteq> set (interp_ins (xs @ ys))", "have \"set (interp_ins (xs @ ys @ [x])) = set (interp_ins (xs @ ys)) \\<union> {fst x}\""], ["proof (prove)\nusing this:\n  set (interp_ins (xs @ ys @ [x])) \\<noteq> set (interp_ins (xs @ ys))\n\ngoal (1 subgoal):\n 1. set (interp_ins (xs @ ys @ [x])) =\n    set (interp_ins (xs @ ys)) \\<union> {fst x}", "by (metis append_assoc interp_ins_maybe_grow2 snoc.prems)"], ["proof (state)\nthis:\n  set (interp_ins (xs @ ys @ [x])) =\n  set (interp_ins (xs @ ys)) \\<union> {fst x}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<subseteq> set (map fst ys) \\<and>\n             set (interp_ins (xs @ ys)) = set (interp_ins xs) \\<union> A;\n     set (interp_ins (xs @ ys @ [x])) \\<noteq>\n     set (interp_ins (xs @ ys))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A\\<subseteq>set (map fst (ys @ [x])).\n                         set (interp_ins (xs @ ys @ [x])) =\n                         set (interp_ins xs) \\<union> A", "moreover"], ["proof (state)\nthis:\n  set (interp_ins (xs @ ys @ [x])) =\n  set (interp_ins (xs @ ys)) \\<union> {fst x}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<subseteq> set (map fst ys) \\<and>\n             set (interp_ins (xs @ ys)) = set (interp_ins xs) \\<union> A;\n     set (interp_ins (xs @ ys @ [x])) \\<noteq>\n     set (interp_ins (xs @ ys))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A\\<subseteq>set (map fst (ys @ [x])).\n                         set (interp_ins (xs @ ys @ [x])) =\n                         set (interp_ins xs) \\<union> A", "have \"A \\<union> {fst x} \\<subseteq> set (map fst (ys @ [x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<union> {fst x} \\<subseteq> set (map fst (ys @ [x]))", "using IH"], ["proof (prove)\nusing this:\n  A \\<subseteq> set (map fst ys) \\<and>\n  set (interp_ins (xs @ ys)) = set (interp_ins xs) \\<union> A\n\ngoal (1 subgoal):\n 1. A \\<union> {fst x} \\<subseteq> set (map fst (ys @ [x]))", "by auto"], ["proof (state)\nthis:\n  A \\<union> {fst x} \\<subseteq> set (map fst (ys @ [x]))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<subseteq> set (map fst ys) \\<and>\n             set (interp_ins (xs @ ys)) = set (interp_ins xs) \\<union> A;\n     set (interp_ins (xs @ ys @ [x])) \\<noteq>\n     set (interp_ins (xs @ ys))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A\\<subseteq>set (map fst (ys @ [x])).\n                         set (interp_ins (xs @ ys @ [x])) =\n                         set (interp_ins xs) \\<union> A", "ultimately"], ["proof (chain)\npicking this:\n  set (interp_ins (xs @ ys @ [x])) =\n  set (interp_ins (xs @ ys)) \\<union> {fst x}\n  A \\<union> {fst x} \\<subseteq> set (map fst (ys @ [x]))", "show ?thesis"], ["proof (prove)\nusing this:\n  set (interp_ins (xs @ ys @ [x])) =\n  set (interp_ins (xs @ ys)) \\<union> {fst x}\n  A \\<union> {fst x} \\<subseteq> set (map fst (ys @ [x]))\n\ngoal (1 subgoal):\n 1. \\<exists>A\\<subseteq>set (map fst (ys @ [x])).\n       set (interp_ins (xs @ ys @ [x])) = set (interp_ins xs) \\<union> A", "using IH Un_assoc"], ["proof (prove)\nusing this:\n  set (interp_ins (xs @ ys @ [x])) =\n  set (interp_ins (xs @ ys)) \\<union> {fst x}\n  A \\<union> {fst x} \\<subseteq> set (map fst (ys @ [x]))\n  A \\<subseteq> set (map fst ys) \\<and>\n  set (interp_ins (xs @ ys)) = set (interp_ins xs) \\<union> A\n  ?A \\<union> ?B \\<union> ?C = ?A \\<union> (?B \\<union> ?C)\n\ngoal (1 subgoal):\n 1. \\<exists>A\\<subseteq>set (map fst (ys @ [x])).\n       set (interp_ins (xs @ ys @ [x])) = set (interp_ins xs) \\<union> A", "by metis"], ["proof (state)\nthis:\n  \\<exists>A\\<subseteq>set (map fst (ys @ [x])).\n     set (interp_ins (xs @ ys @ [x])) = set (interp_ins xs) \\<union> A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>A\\<subseteq>set (map fst (ys @ [x])).\n     set (interp_ins (xs @ ys @ [x])) = set (interp_ins xs) \\<union> A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma interp_ins_ref_nonex:\n  assumes \"insert_ops ops\"\n    and \"ops = xs @ [(oid, Some ref)] @ ys\"\n    and \"ref \\<notin> set (interp_ins xs)\"\n  shows \"oid \\<notin> set (interp_ins ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oid \\<notin> set (interp_ins ops)", "using assms"], ["proof (prove)\nusing this:\n  insert_ops ops\n  ops = xs @ [(oid, Some ref)] @ ys\n  ref \\<notin> set (interp_ins xs)\n\ngoal (1 subgoal):\n 1. oid \\<notin> set (interp_ins ops)", "proof(induction ys arbitrary: ops rule: List.rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ops.\n       \\<lbrakk>insert_ops ops; ops = xs @ [(oid, Some ref)] @ [];\n        ref \\<notin> set (interp_ins xs)\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (interp_ins ops)\n 2. \\<And>x xsa ops.\n       \\<lbrakk>\\<And>ops.\n                   \\<lbrakk>insert_ops ops;\n                    ops = xs @ [(oid, Some ref)] @ xsa;\n                    ref \\<notin> set (interp_ins xs)\\<rbrakk>\n                   \\<Longrightarrow> oid \\<notin> set (interp_ins ops);\n        insert_ops ops; ops = xs @ [(oid, Some ref)] @ xsa @ [x];\n        ref \\<notin> set (interp_ins xs)\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (interp_ins ops)", "case Nil"], ["proof (state)\nthis:\n  insert_ops ops\n  ops = xs @ [(oid, Some ref)] @ []\n  ref \\<notin> set (interp_ins xs)\n\ngoal (2 subgoals):\n 1. \\<And>ops.\n       \\<lbrakk>insert_ops ops; ops = xs @ [(oid, Some ref)] @ [];\n        ref \\<notin> set (interp_ins xs)\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (interp_ins ops)\n 2. \\<And>x xsa ops.\n       \\<lbrakk>\\<And>ops.\n                   \\<lbrakk>insert_ops ops;\n                    ops = xs @ [(oid, Some ref)] @ xsa;\n                    ref \\<notin> set (interp_ins xs)\\<rbrakk>\n                   \\<Longrightarrow> oid \\<notin> set (interp_ins ops);\n        insert_ops ops; ops = xs @ [(oid, Some ref)] @ xsa @ [x];\n        ref \\<notin> set (interp_ins xs)\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (interp_ins ops)", "then"], ["proof (chain)\npicking this:\n  insert_ops ops\n  ops = xs @ [(oid, Some ref)] @ []\n  ref \\<notin> set (interp_ins xs)", "have \"interp_ins ops = insert_spec (interp_ins xs) (oid, Some ref)\""], ["proof (prove)\nusing this:\n  insert_ops ops\n  ops = xs @ [(oid, Some ref)] @ []\n  ref \\<notin> set (interp_ins xs)\n\ngoal (1 subgoal):\n 1. interp_ins ops = insert_spec (interp_ins xs) (oid, Some ref)", "by (simp add: interp_ins_tail_unfold)"], ["proof (state)\nthis:\n  interp_ins ops = insert_spec (interp_ins xs) (oid, Some ref)\n\ngoal (2 subgoals):\n 1. \\<And>ops.\n       \\<lbrakk>insert_ops ops; ops = xs @ [(oid, Some ref)] @ [];\n        ref \\<notin> set (interp_ins xs)\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (interp_ins ops)\n 2. \\<And>x xsa ops.\n       \\<lbrakk>\\<And>ops.\n                   \\<lbrakk>insert_ops ops;\n                    ops = xs @ [(oid, Some ref)] @ xsa;\n                    ref \\<notin> set (interp_ins xs)\\<rbrakk>\n                   \\<Longrightarrow> oid \\<notin> set (interp_ins ops);\n        insert_ops ops; ops = xs @ [(oid, Some ref)] @ xsa @ [x];\n        ref \\<notin> set (interp_ins xs)\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (interp_ins ops)", "moreover"], ["proof (state)\nthis:\n  interp_ins ops = insert_spec (interp_ins xs) (oid, Some ref)\n\ngoal (2 subgoals):\n 1. \\<And>ops.\n       \\<lbrakk>insert_ops ops; ops = xs @ [(oid, Some ref)] @ [];\n        ref \\<notin> set (interp_ins xs)\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (interp_ins ops)\n 2. \\<And>x xsa ops.\n       \\<lbrakk>\\<And>ops.\n                   \\<lbrakk>insert_ops ops;\n                    ops = xs @ [(oid, Some ref)] @ xsa;\n                    ref \\<notin> set (interp_ins xs)\\<rbrakk>\n                   \\<Longrightarrow> oid \\<notin> set (interp_ins ops);\n        insert_ops ops; ops = xs @ [(oid, Some ref)] @ xsa @ [x];\n        ref \\<notin> set (interp_ins xs)\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (interp_ins ops)", "have \"\\<And>i. i \\<in> set (map fst xs) \\<Longrightarrow> i < oid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> set (map fst xs) \\<Longrightarrow> i < oid", "using Nil.prems last_op_greatest"], ["proof (prove)\nusing this:\n  insert_ops ops\n  ops = xs @ [(oid, Some ref)] @ []\n  ref \\<notin> set (interp_ins xs)\n  \\<lbrakk>insert_ops (?op_list @ [(?oid, ?oper)]);\n   ?x \\<in> set (map fst ?op_list)\\<rbrakk>\n  \\<Longrightarrow> ?x < ?oid\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> set (map fst xs) \\<Longrightarrow> i < oid", "by fastforce"], ["proof (state)\nthis:\n  ?i \\<in> set (map fst xs) \\<Longrightarrow> ?i < oid\n\ngoal (2 subgoals):\n 1. \\<And>ops.\n       \\<lbrakk>insert_ops ops; ops = xs @ [(oid, Some ref)] @ [];\n        ref \\<notin> set (interp_ins xs)\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (interp_ins ops)\n 2. \\<And>x xsa ops.\n       \\<lbrakk>\\<And>ops.\n                   \\<lbrakk>insert_ops ops;\n                    ops = xs @ [(oid, Some ref)] @ xsa;\n                    ref \\<notin> set (interp_ins xs)\\<rbrakk>\n                   \\<Longrightarrow> oid \\<notin> set (interp_ins ops);\n        insert_ops ops; ops = xs @ [(oid, Some ref)] @ xsa @ [x];\n        ref \\<notin> set (interp_ins xs)\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (interp_ins ops)", "hence \"\\<And>i. i \\<in> set (interp_ins xs) \\<Longrightarrow> i < oid\""], ["proof (prove)\nusing this:\n  ?i \\<in> set (map fst xs) \\<Longrightarrow> ?i < oid\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> set (interp_ins xs) \\<Longrightarrow> i < oid", "by (meson interp_ins_subset subsetCE)"], ["proof (state)\nthis:\n  ?i \\<in> set (interp_ins xs) \\<Longrightarrow> ?i < oid\n\ngoal (2 subgoals):\n 1. \\<And>ops.\n       \\<lbrakk>insert_ops ops; ops = xs @ [(oid, Some ref)] @ [];\n        ref \\<notin> set (interp_ins xs)\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (interp_ins ops)\n 2. \\<And>x xsa ops.\n       \\<lbrakk>\\<And>ops.\n                   \\<lbrakk>insert_ops ops;\n                    ops = xs @ [(oid, Some ref)] @ xsa;\n                    ref \\<notin> set (interp_ins xs)\\<rbrakk>\n                   \\<Longrightarrow> oid \\<notin> set (interp_ins ops);\n        insert_ops ops; ops = xs @ [(oid, Some ref)] @ xsa @ [x];\n        ref \\<notin> set (interp_ins xs)\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (interp_ins ops)", "ultimately"], ["proof (chain)\npicking this:\n  interp_ins ops = insert_spec (interp_ins xs) (oid, Some ref)\n  ?i \\<in> set (interp_ins xs) \\<Longrightarrow> ?i < oid", "show \"oid \\<notin> set (interp_ins ops)\""], ["proof (prove)\nusing this:\n  interp_ins ops = insert_spec (interp_ins xs) (oid, Some ref)\n  ?i \\<in> set (interp_ins xs) \\<Longrightarrow> ?i < oid\n\ngoal (1 subgoal):\n 1. oid \\<notin> set (interp_ins ops)", "using assms(3)"], ["proof (prove)\nusing this:\n  interp_ins ops = insert_spec (interp_ins xs) (oid, Some ref)\n  ?i \\<in> set (interp_ins xs) \\<Longrightarrow> ?i < oid\n  ref \\<notin> set (interp_ins xs)\n\ngoal (1 subgoal):\n 1. oid \\<notin> set (interp_ins ops)", "by auto"], ["proof (state)\nthis:\n  oid \\<notin> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa ops.\n       \\<lbrakk>\\<And>ops.\n                   \\<lbrakk>insert_ops ops;\n                    ops = xs @ [(oid, Some ref)] @ xsa;\n                    ref \\<notin> set (interp_ins xs)\\<rbrakk>\n                   \\<Longrightarrow> oid \\<notin> set (interp_ins ops);\n        insert_ops ops; ops = xs @ [(oid, Some ref)] @ xsa @ [x];\n        ref \\<notin> set (interp_ins xs)\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (interp_ins ops)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa ops.\n       \\<lbrakk>\\<And>ops.\n                   \\<lbrakk>insert_ops ops;\n                    ops = xs @ [(oid, Some ref)] @ xsa;\n                    ref \\<notin> set (interp_ins xs)\\<rbrakk>\n                   \\<Longrightarrow> oid \\<notin> set (interp_ins ops);\n        insert_ops ops; ops = xs @ [(oid, Some ref)] @ xsa @ [x];\n        ref \\<notin> set (interp_ins xs)\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (interp_ins ops)", "case (snoc x ys)"], ["proof (state)\nthis:\n  \\<lbrakk>insert_ops ?ops; ?ops = xs @ [(oid, Some ref)] @ ys;\n   ref \\<notin> set (interp_ins xs)\\<rbrakk>\n  \\<Longrightarrow> oid \\<notin> set (interp_ins ?ops)\n  insert_ops ops\n  ops = xs @ [(oid, Some ref)] @ ys @ [x]\n  ref \\<notin> set (interp_ins xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa ops.\n       \\<lbrakk>\\<And>ops.\n                   \\<lbrakk>insert_ops ops;\n                    ops = xs @ [(oid, Some ref)] @ xsa;\n                    ref \\<notin> set (interp_ins xs)\\<rbrakk>\n                   \\<Longrightarrow> oid \\<notin> set (interp_ins ops);\n        insert_ops ops; ops = xs @ [(oid, Some ref)] @ xsa @ [x];\n        ref \\<notin> set (interp_ins xs)\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (interp_ins ops)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>insert_ops ?ops; ?ops = xs @ [(oid, Some ref)] @ ys;\n   ref \\<notin> set (interp_ins xs)\\<rbrakk>\n  \\<Longrightarrow> oid \\<notin> set (interp_ins ?ops)\n  insert_ops ops\n  ops = xs @ [(oid, Some ref)] @ ys @ [x]\n  ref \\<notin> set (interp_ins xs)", "have \"insert_ops (xs @ (oid, Some ref) # ys)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>insert_ops ?ops; ?ops = xs @ [(oid, Some ref)] @ ys;\n   ref \\<notin> set (interp_ins xs)\\<rbrakk>\n  \\<Longrightarrow> oid \\<notin> set (interp_ins ?ops)\n  insert_ops ops\n  ops = xs @ [(oid, Some ref)] @ ys @ [x]\n  ref \\<notin> set (interp_ins xs)\n\ngoal (1 subgoal):\n 1. insert_ops (xs @ (oid, Some ref) # ys)", "by (metis append.assoc append.simps(1) append_Cons insert_ops_appendD)"], ["proof (state)\nthis:\n  insert_ops (xs @ (oid, Some ref) # ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa ops.\n       \\<lbrakk>\\<And>ops.\n                   \\<lbrakk>insert_ops ops;\n                    ops = xs @ [(oid, Some ref)] @ xsa;\n                    ref \\<notin> set (interp_ins xs)\\<rbrakk>\n                   \\<Longrightarrow> oid \\<notin> set (interp_ins ops);\n        insert_ops ops; ops = xs @ [(oid, Some ref)] @ xsa @ [x];\n        ref \\<notin> set (interp_ins xs)\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (interp_ins ops)", "hence IH: \"oid \\<notin> set (interp_ins (xs @ (oid, Some ref) # ys))\""], ["proof (prove)\nusing this:\n  insert_ops (xs @ (oid, Some ref) # ys)\n\ngoal (1 subgoal):\n 1. oid \\<notin> set (interp_ins (xs @ (oid, Some ref) # ys))", "by (simp add: snoc.IH snoc.prems(3))"], ["proof (state)\nthis:\n  oid \\<notin> set (interp_ins (xs @ (oid, Some ref) # ys))\n\ngoal (1 subgoal):\n 1. \\<And>x xsa ops.\n       \\<lbrakk>\\<And>ops.\n                   \\<lbrakk>insert_ops ops;\n                    ops = xs @ [(oid, Some ref)] @ xsa;\n                    ref \\<notin> set (interp_ins xs)\\<rbrakk>\n                   \\<Longrightarrow> oid \\<notin> set (interp_ins ops);\n        insert_ops ops; ops = xs @ [(oid, Some ref)] @ xsa @ [x];\n        ref \\<notin> set (interp_ins xs)\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (interp_ins ops)", "moreover"], ["proof (state)\nthis:\n  oid \\<notin> set (interp_ins (xs @ (oid, Some ref) # ys))\n\ngoal (1 subgoal):\n 1. \\<And>x xsa ops.\n       \\<lbrakk>\\<And>ops.\n                   \\<lbrakk>insert_ops ops;\n                    ops = xs @ [(oid, Some ref)] @ xsa;\n                    ref \\<notin> set (interp_ins xs)\\<rbrakk>\n                   \\<Longrightarrow> oid \\<notin> set (interp_ins ops);\n        insert_ops ops; ops = xs @ [(oid, Some ref)] @ xsa @ [x];\n        ref \\<notin> set (interp_ins xs)\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (interp_ins ops)", "have \"distinct (map fst (xs @ (oid, Some ref) # ys @ [x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (xs @ (oid, Some ref) # ys @ [x]))", "using snoc.prems"], ["proof (prove)\nusing this:\n  insert_ops ops\n  ops = xs @ [(oid, Some ref)] @ ys @ [x]\n  ref \\<notin> set (interp_ins xs)\n\ngoal (1 subgoal):\n 1. distinct (map fst (xs @ (oid, Some ref) # ys @ [x]))", "by (metis append_Cons append_self_conv2 insert_ops_def spec_ops_def)"], ["proof (state)\nthis:\n  distinct (map fst (xs @ (oid, Some ref) # ys @ [x]))\n\ngoal (1 subgoal):\n 1. \\<And>x xsa ops.\n       \\<lbrakk>\\<And>ops.\n                   \\<lbrakk>insert_ops ops;\n                    ops = xs @ [(oid, Some ref)] @ xsa;\n                    ref \\<notin> set (interp_ins xs)\\<rbrakk>\n                   \\<Longrightarrow> oid \\<notin> set (interp_ins ops);\n        insert_ops ops; ops = xs @ [(oid, Some ref)] @ xsa @ [x];\n        ref \\<notin> set (interp_ins xs)\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (interp_ins ops)", "hence \"fst x \\<noteq> oid\""], ["proof (prove)\nusing this:\n  distinct (map fst (xs @ (oid, Some ref) # ys @ [x]))\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> oid", "using empty_iff"], ["proof (prove)\nusing this:\n  distinct (map fst (xs @ (oid, Some ref) # ys @ [x]))\n  (?c \\<in> {}) = False\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> oid", "by auto"], ["proof (state)\nthis:\n  fst x \\<noteq> oid\n\ngoal (1 subgoal):\n 1. \\<And>x xsa ops.\n       \\<lbrakk>\\<And>ops.\n                   \\<lbrakk>insert_ops ops;\n                    ops = xs @ [(oid, Some ref)] @ xsa;\n                    ref \\<notin> set (interp_ins xs)\\<rbrakk>\n                   \\<Longrightarrow> oid \\<notin> set (interp_ins ops);\n        insert_ops ops; ops = xs @ [(oid, Some ref)] @ xsa @ [x];\n        ref \\<notin> set (interp_ins xs)\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (interp_ins ops)", "moreover"], ["proof (state)\nthis:\n  fst x \\<noteq> oid\n\ngoal (1 subgoal):\n 1. \\<And>x xsa ops.\n       \\<lbrakk>\\<And>ops.\n                   \\<lbrakk>insert_ops ops;\n                    ops = xs @ [(oid, Some ref)] @ xsa;\n                    ref \\<notin> set (interp_ins xs)\\<rbrakk>\n                   \\<Longrightarrow> oid \\<notin> set (interp_ins ops);\n        insert_ops ops; ops = xs @ [(oid, Some ref)] @ xsa @ [x];\n        ref \\<notin> set (interp_ins xs)\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (interp_ins ops)", "have \"insert_ops ((xs @ (oid, Some ref) # ys) @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_ops ((xs @ (oid, Some ref) # ys) @ [x])", "using snoc.prems"], ["proof (prove)\nusing this:\n  insert_ops ops\n  ops = xs @ [(oid, Some ref)] @ ys @ [x]\n  ref \\<notin> set (interp_ins xs)\n\ngoal (1 subgoal):\n 1. insert_ops ((xs @ (oid, Some ref) # ys) @ [x])", "by auto"], ["proof (state)\nthis:\n  insert_ops ((xs @ (oid, Some ref) # ys) @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>x xsa ops.\n       \\<lbrakk>\\<And>ops.\n                   \\<lbrakk>insert_ops ops;\n                    ops = xs @ [(oid, Some ref)] @ xsa;\n                    ref \\<notin> set (interp_ins xs)\\<rbrakk>\n                   \\<Longrightarrow> oid \\<notin> set (interp_ins ops);\n        insert_ops ops; ops = xs @ [(oid, Some ref)] @ xsa @ [x];\n        ref \\<notin> set (interp_ins xs)\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (interp_ins ops)", "hence \"set (interp_ins ((xs @ (oid, Some ref) # ys) @ [x])) =\n         set (interp_ins (xs @ (oid, Some ref) # ys)) \\<or> \n         set (interp_ins ((xs @ (oid, Some ref) # ys) @ [x])) =\n         set (interp_ins (xs @ (oid, Some ref) # ys)) \\<union> {fst x}\""], ["proof (prove)\nusing this:\n  insert_ops ((xs @ (oid, Some ref) # ys) @ [x])\n\ngoal (1 subgoal):\n 1. set (interp_ins ((xs @ (oid, Some ref) # ys) @ [x])) =\n    set (interp_ins (xs @ (oid, Some ref) # ys)) \\<or>\n    set (interp_ins ((xs @ (oid, Some ref) # ys) @ [x])) =\n    set (interp_ins (xs @ (oid, Some ref) # ys)) \\<union> {fst x}", "using interp_ins_maybe_grow2"], ["proof (prove)\nusing this:\n  insert_ops ((xs @ (oid, Some ref) # ys) @ [x])\n  insert_ops (?xs @ [?x]) \\<Longrightarrow>\n  set (interp_ins (?xs @ [?x])) = set (interp_ins ?xs) \\<or>\n  set (interp_ins (?xs @ [?x])) = set (interp_ins ?xs) \\<union> {fst ?x}\n\ngoal (1 subgoal):\n 1. set (interp_ins ((xs @ (oid, Some ref) # ys) @ [x])) =\n    set (interp_ins (xs @ (oid, Some ref) # ys)) \\<or>\n    set (interp_ins ((xs @ (oid, Some ref) # ys) @ [x])) =\n    set (interp_ins (xs @ (oid, Some ref) # ys)) \\<union> {fst x}", "by blast"], ["proof (state)\nthis:\n  set (interp_ins ((xs @ (oid, Some ref) # ys) @ [x])) =\n  set (interp_ins (xs @ (oid, Some ref) # ys)) \\<or>\n  set (interp_ins ((xs @ (oid, Some ref) # ys) @ [x])) =\n  set (interp_ins (xs @ (oid, Some ref) # ys)) \\<union> {fst x}\n\ngoal (1 subgoal):\n 1. \\<And>x xsa ops.\n       \\<lbrakk>\\<And>ops.\n                   \\<lbrakk>insert_ops ops;\n                    ops = xs @ [(oid, Some ref)] @ xsa;\n                    ref \\<notin> set (interp_ins xs)\\<rbrakk>\n                   \\<Longrightarrow> oid \\<notin> set (interp_ins ops);\n        insert_ops ops; ops = xs @ [(oid, Some ref)] @ xsa @ [x];\n        ref \\<notin> set (interp_ins xs)\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (interp_ins ops)", "ultimately"], ["proof (chain)\npicking this:\n  oid \\<notin> set (interp_ins (xs @ (oid, Some ref) # ys))\n  fst x \\<noteq> oid\n  set (interp_ins ((xs @ (oid, Some ref) # ys) @ [x])) =\n  set (interp_ins (xs @ (oid, Some ref) # ys)) \\<or>\n  set (interp_ins ((xs @ (oid, Some ref) # ys) @ [x])) =\n  set (interp_ins (xs @ (oid, Some ref) # ys)) \\<union> {fst x}", "show \"oid \\<notin> set (interp_ins ops)\""], ["proof (prove)\nusing this:\n  oid \\<notin> set (interp_ins (xs @ (oid, Some ref) # ys))\n  fst x \\<noteq> oid\n  set (interp_ins ((xs @ (oid, Some ref) # ys) @ [x])) =\n  set (interp_ins (xs @ (oid, Some ref) # ys)) \\<or>\n  set (interp_ins ((xs @ (oid, Some ref) # ys) @ [x])) =\n  set (interp_ins (xs @ (oid, Some ref) # ys)) \\<union> {fst x}\n\ngoal (1 subgoal):\n 1. oid \\<notin> set (interp_ins ops)", "using snoc.prems(2)"], ["proof (prove)\nusing this:\n  oid \\<notin> set (interp_ins (xs @ (oid, Some ref) # ys))\n  fst x \\<noteq> oid\n  set (interp_ins ((xs @ (oid, Some ref) # ys) @ [x])) =\n  set (interp_ins (xs @ (oid, Some ref) # ys)) \\<or>\n  set (interp_ins ((xs @ (oid, Some ref) # ys) @ [x])) =\n  set (interp_ins (xs @ (oid, Some ref) # ys)) \\<union> {fst x}\n  ops = xs @ [(oid, Some ref)] @ ys @ [x]\n\ngoal (1 subgoal):\n 1. oid \\<notin> set (interp_ins ops)", "by auto"], ["proof (state)\nthis:\n  oid \\<notin> set (interp_ins ops)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma interp_ins_last_None:\n  shows \"oid \\<in> set (interp_ins (ops @ [(oid, None)]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oid \\<in> set (interp_ins (ops @ [(oid, None)]))", "by (simp add: interp_ins_tail_unfold)"], ["", "lemma interp_ins_monotonic:\n  assumes \"insert_ops (pre @ suf)\"\n    and \"oid \\<in> set (interp_ins pre)\"\n  shows \"oid \\<in> set (interp_ins (pre @ suf))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oid \\<in> set (interp_ins (pre @ suf))", "using assms interp_ins_maybe_grow3"], ["proof (prove)\nusing this:\n  insert_ops (pre @ suf)\n  oid \\<in> set (interp_ins pre)\n  insert_ops (?xs @ ?ys) \\<Longrightarrow>\n  \\<exists>A\\<subseteq>set (map fst ?ys).\n     set (interp_ins (?xs @ ?ys)) = set (interp_ins ?xs) \\<union> A\n\ngoal (1 subgoal):\n 1. oid \\<in> set (interp_ins (pre @ suf))", "by auto"], ["", "lemma interp_ins_append_non_memb:\n  assumes \"insert_ops (pre @ [(oid, Some ref)] @ suf)\"\n    and \"ref \\<notin> set (interp_ins pre)\"\n  shows \"ref \\<notin> set (interp_ins (pre @ [(oid, Some ref)] @ suf))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ref \\<notin> set (interp_ins (pre @ [(oid, Some ref)] @ suf))", "using assms"], ["proof (prove)\nusing this:\n  insert_ops (pre @ [(oid, Some ref)] @ suf)\n  ref \\<notin> set (interp_ins pre)\n\ngoal (1 subgoal):\n 1. ref \\<notin> set (interp_ins (pre @ [(oid, Some ref)] @ suf))", "proof(induction suf rule: List.rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>insert_ops (pre @ [(oid, Some ref)] @ []);\n     ref \\<notin> set (interp_ins pre)\\<rbrakk>\n    \\<Longrightarrow> ref\n                      \\<notin> set (interp_ins\n                                     (pre @ [(oid, Some ref)] @ []))\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops (pre @ [(oid, Some ref)] @ xs);\n                 ref \\<notin> set (interp_ins pre)\\<rbrakk>\n                \\<Longrightarrow> ref\n                                  \\<notin> set\n      (interp_ins (pre @ [(oid, Some ref)] @ xs));\n        insert_ops (pre @ [(oid, Some ref)] @ xs @ [x]);\n        ref \\<notin> set (interp_ins pre)\\<rbrakk>\n       \\<Longrightarrow> ref\n                         \\<notin> set (interp_ins\n  (pre @ [(oid, Some ref)] @ xs @ [x]))", "case Nil"], ["proof (state)\nthis:\n  insert_ops (pre @ [(oid, Some ref)] @ [])\n  ref \\<notin> set (interp_ins pre)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>insert_ops (pre @ [(oid, Some ref)] @ []);\n     ref \\<notin> set (interp_ins pre)\\<rbrakk>\n    \\<Longrightarrow> ref\n                      \\<notin> set (interp_ins\n                                     (pre @ [(oid, Some ref)] @ []))\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops (pre @ [(oid, Some ref)] @ xs);\n                 ref \\<notin> set (interp_ins pre)\\<rbrakk>\n                \\<Longrightarrow> ref\n                                  \\<notin> set\n      (interp_ins (pre @ [(oid, Some ref)] @ xs));\n        insert_ops (pre @ [(oid, Some ref)] @ xs @ [x]);\n        ref \\<notin> set (interp_ins pre)\\<rbrakk>\n       \\<Longrightarrow> ref\n                         \\<notin> set (interp_ins\n  (pre @ [(oid, Some ref)] @ xs @ [x]))", "then"], ["proof (chain)\npicking this:\n  insert_ops (pre @ [(oid, Some ref)] @ [])\n  ref \\<notin> set (interp_ins pre)", "show \"ref \\<notin> set (interp_ins (pre @ [(oid, Some ref)] @ []))\""], ["proof (prove)\nusing this:\n  insert_ops (pre @ [(oid, Some ref)] @ [])\n  ref \\<notin> set (interp_ins pre)\n\ngoal (1 subgoal):\n 1. ref \\<notin> set (interp_ins (pre @ [(oid, Some ref)] @ []))", "by (metis append_Nil2 insert_spec_nonex interp_ins_tail_unfold)"], ["proof (state)\nthis:\n  ref \\<notin> set (interp_ins (pre @ [(oid, Some ref)] @ []))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops (pre @ [(oid, Some ref)] @ xs);\n                 ref \\<notin> set (interp_ins pre)\\<rbrakk>\n                \\<Longrightarrow> ref\n                                  \\<notin> set\n      (interp_ins (pre @ [(oid, Some ref)] @ xs));\n        insert_ops (pre @ [(oid, Some ref)] @ xs @ [x]);\n        ref \\<notin> set (interp_ins pre)\\<rbrakk>\n       \\<Longrightarrow> ref\n                         \\<notin> set (interp_ins\n  (pre @ [(oid, Some ref)] @ xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops (pre @ [(oid, Some ref)] @ xs);\n                 ref \\<notin> set (interp_ins pre)\\<rbrakk>\n                \\<Longrightarrow> ref\n                                  \\<notin> set\n      (interp_ins (pre @ [(oid, Some ref)] @ xs));\n        insert_ops (pre @ [(oid, Some ref)] @ xs @ [x]);\n        ref \\<notin> set (interp_ins pre)\\<rbrakk>\n       \\<Longrightarrow> ref\n                         \\<notin> set (interp_ins\n  (pre @ [(oid, Some ref)] @ xs @ [x]))", "case (snoc x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>insert_ops (pre @ [(oid, Some ref)] @ xs);\n   ref \\<notin> set (interp_ins pre)\\<rbrakk>\n  \\<Longrightarrow> ref\n                    \\<notin> set (interp_ins (pre @ [(oid, Some ref)] @ xs))\n  insert_ops (pre @ [(oid, Some ref)] @ xs @ [x])\n  ref \\<notin> set (interp_ins pre)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops (pre @ [(oid, Some ref)] @ xs);\n                 ref \\<notin> set (interp_ins pre)\\<rbrakk>\n                \\<Longrightarrow> ref\n                                  \\<notin> set\n      (interp_ins (pre @ [(oid, Some ref)] @ xs));\n        insert_ops (pre @ [(oid, Some ref)] @ xs @ [x]);\n        ref \\<notin> set (interp_ins pre)\\<rbrakk>\n       \\<Longrightarrow> ref\n                         \\<notin> set (interp_ins\n  (pre @ [(oid, Some ref)] @ xs @ [x]))", "hence IH: \"ref \\<notin> set (interp_ins (pre @ [(oid, Some ref)] @ xs))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>insert_ops (pre @ [(oid, Some ref)] @ xs);\n   ref \\<notin> set (interp_ins pre)\\<rbrakk>\n  \\<Longrightarrow> ref\n                    \\<notin> set (interp_ins (pre @ [(oid, Some ref)] @ xs))\n  insert_ops (pre @ [(oid, Some ref)] @ xs @ [x])\n  ref \\<notin> set (interp_ins pre)\n\ngoal (1 subgoal):\n 1. ref \\<notin> set (interp_ins (pre @ [(oid, Some ref)] @ xs))", "by (metis append_assoc insert_ops_rem_last)"], ["proof (state)\nthis:\n  ref \\<notin> set (interp_ins (pre @ [(oid, Some ref)] @ xs))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops (pre @ [(oid, Some ref)] @ xs);\n                 ref \\<notin> set (interp_ins pre)\\<rbrakk>\n                \\<Longrightarrow> ref\n                                  \\<notin> set\n      (interp_ins (pre @ [(oid, Some ref)] @ xs));\n        insert_ops (pre @ [(oid, Some ref)] @ xs @ [x]);\n        ref \\<notin> set (interp_ins pre)\\<rbrakk>\n       \\<Longrightarrow> ref\n                         \\<notin> set (interp_ins\n  (pre @ [(oid, Some ref)] @ xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  ref \\<notin> set (interp_ins (pre @ [(oid, Some ref)] @ xs))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops (pre @ [(oid, Some ref)] @ xs);\n                 ref \\<notin> set (interp_ins pre)\\<rbrakk>\n                \\<Longrightarrow> ref\n                                  \\<notin> set\n      (interp_ins (pre @ [(oid, Some ref)] @ xs));\n        insert_ops (pre @ [(oid, Some ref)] @ xs @ [x]);\n        ref \\<notin> set (interp_ins pre)\\<rbrakk>\n       \\<Longrightarrow> ref\n                         \\<notin> set (interp_ins\n  (pre @ [(oid, Some ref)] @ xs @ [x]))", "have \"ref < oid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ref < oid", "using insert_ops_ref_older snoc.prems(1)"], ["proof (prove)\nusing this:\n  insert_ops (?pre @ [(?oid, Some ?ref)] @ ?suf) \\<Longrightarrow>\n  ?ref < ?oid\n  insert_ops (pre @ [(oid, Some ref)] @ xs @ [x])\n\ngoal (1 subgoal):\n 1. ref < oid", "by auto"], ["proof (state)\nthis:\n  ref < oid\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops (pre @ [(oid, Some ref)] @ xs);\n                 ref \\<notin> set (interp_ins pre)\\<rbrakk>\n                \\<Longrightarrow> ref\n                                  \\<notin> set\n      (interp_ins (pre @ [(oid, Some ref)] @ xs));\n        insert_ops (pre @ [(oid, Some ref)] @ xs @ [x]);\n        ref \\<notin> set (interp_ins pre)\\<rbrakk>\n       \\<Longrightarrow> ref\n                         \\<notin> set (interp_ins\n  (pre @ [(oid, Some ref)] @ xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  ref < oid\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops (pre @ [(oid, Some ref)] @ xs);\n                 ref \\<notin> set (interp_ins pre)\\<rbrakk>\n                \\<Longrightarrow> ref\n                                  \\<notin> set\n      (interp_ins (pre @ [(oid, Some ref)] @ xs));\n        insert_ops (pre @ [(oid, Some ref)] @ xs @ [x]);\n        ref \\<notin> set (interp_ins pre)\\<rbrakk>\n       \\<Longrightarrow> ref\n                         \\<notin> set (interp_ins\n  (pre @ [(oid, Some ref)] @ xs @ [x]))", "have \"oid < fst x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oid < fst x", "using insert_ops_sorted_oids"], ["proof (prove)\nusing this:\n  insert_ops\n   (?xs @ [(?i1.0, ?r1.0)] @ ?ys @ [(?i2.0, ?r2.0)]) \\<Longrightarrow>\n  ?i1.0 < ?i2.0\n\ngoal (1 subgoal):\n 1. oid < fst x", "by (metis prod.collapse snoc.prems(1))"], ["proof (state)\nthis:\n  oid < fst x\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops (pre @ [(oid, Some ref)] @ xs);\n                 ref \\<notin> set (interp_ins pre)\\<rbrakk>\n                \\<Longrightarrow> ref\n                                  \\<notin> set\n      (interp_ins (pre @ [(oid, Some ref)] @ xs));\n        insert_ops (pre @ [(oid, Some ref)] @ xs @ [x]);\n        ref \\<notin> set (interp_ins pre)\\<rbrakk>\n       \\<Longrightarrow> ref\n                         \\<notin> set (interp_ins\n  (pre @ [(oid, Some ref)] @ xs @ [x]))", "have \"set (interp_ins ((pre @ [(oid, Some ref)] @ xs) @ [x])) =\n        set (interp_ins (pre @ [(oid, Some ref)] @ xs)) \\<or>\n        set (interp_ins ((pre @ [(oid, Some ref)] @ xs) @ [x])) =\n        set (interp_ins (pre @ [(oid, Some ref)] @ xs)) \\<union> {fst x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (interp_ins ((pre @ [(oid, Some ref)] @ xs) @ [x])) =\n    set (interp_ins (pre @ [(oid, Some ref)] @ xs)) \\<or>\n    set (interp_ins ((pre @ [(oid, Some ref)] @ xs) @ [x])) =\n    set (interp_ins (pre @ [(oid, Some ref)] @ xs)) \\<union> {fst x}", "by (metis (full_types) append.assoc interp_ins_maybe_grow2 snoc.prems(1))"], ["proof (state)\nthis:\n  set (interp_ins ((pre @ [(oid, Some ref)] @ xs) @ [x])) =\n  set (interp_ins (pre @ [(oid, Some ref)] @ xs)) \\<or>\n  set (interp_ins ((pre @ [(oid, Some ref)] @ xs) @ [x])) =\n  set (interp_ins (pre @ [(oid, Some ref)] @ xs)) \\<union> {fst x}\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops (pre @ [(oid, Some ref)] @ xs);\n                 ref \\<notin> set (interp_ins pre)\\<rbrakk>\n                \\<Longrightarrow> ref\n                                  \\<notin> set\n      (interp_ins (pre @ [(oid, Some ref)] @ xs));\n        insert_ops (pre @ [(oid, Some ref)] @ xs @ [x]);\n        ref \\<notin> set (interp_ins pre)\\<rbrakk>\n       \\<Longrightarrow> ref\n                         \\<notin> set (interp_ins\n  (pre @ [(oid, Some ref)] @ xs @ [x]))", "ultimately"], ["proof (chain)\npicking this:\n  ref \\<notin> set (interp_ins (pre @ [(oid, Some ref)] @ xs))\n  ref < oid\n  set (interp_ins ((pre @ [(oid, Some ref)] @ xs) @ [x])) =\n  set (interp_ins (pre @ [(oid, Some ref)] @ xs)) \\<or>\n  set (interp_ins ((pre @ [(oid, Some ref)] @ xs) @ [x])) =\n  set (interp_ins (pre @ [(oid, Some ref)] @ xs)) \\<union> {fst x}", "show \"ref \\<notin> set (interp_ins (pre @ [(oid, Some ref)] @ xs @ [x]))\""], ["proof (prove)\nusing this:\n  ref \\<notin> set (interp_ins (pre @ [(oid, Some ref)] @ xs))\n  ref < oid\n  set (interp_ins ((pre @ [(oid, Some ref)] @ xs) @ [x])) =\n  set (interp_ins (pre @ [(oid, Some ref)] @ xs)) \\<or>\n  set (interp_ins ((pre @ [(oid, Some ref)] @ xs) @ [x])) =\n  set (interp_ins (pre @ [(oid, Some ref)] @ xs)) \\<union> {fst x}\n\ngoal (1 subgoal):\n 1. ref \\<notin> set (interp_ins (pre @ [(oid, Some ref)] @ xs @ [x]))", "using \\<open>oid < fst x\\<close>"], ["proof (prove)\nusing this:\n  ref \\<notin> set (interp_ins (pre @ [(oid, Some ref)] @ xs))\n  ref < oid\n  set (interp_ins ((pre @ [(oid, Some ref)] @ xs) @ [x])) =\n  set (interp_ins (pre @ [(oid, Some ref)] @ xs)) \\<or>\n  set (interp_ins ((pre @ [(oid, Some ref)] @ xs) @ [x])) =\n  set (interp_ins (pre @ [(oid, Some ref)] @ xs)) \\<union> {fst x}\n  oid < fst x\n\ngoal (1 subgoal):\n 1. ref \\<notin> set (interp_ins (pre @ [(oid, Some ref)] @ xs @ [x]))", "by auto"], ["proof (state)\nthis:\n  ref \\<notin> set (interp_ins (pre @ [(oid, Some ref)] @ xs @ [x]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma interp_ins_append_memb:\n  assumes \"insert_ops (pre @ [(oid, Some ref)] @ suf)\"\n    and \"ref \\<in> set (interp_ins pre)\"\n  shows \"oid \\<in> set (interp_ins (pre @ [(oid, Some ref)] @ suf))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oid \\<in> set (interp_ins (pre @ [(oid, Some ref)] @ suf))", "using assms"], ["proof (prove)\nusing this:\n  insert_ops (pre @ [(oid, Some ref)] @ suf)\n  ref \\<in> set (interp_ins pre)\n\ngoal (1 subgoal):\n 1. oid \\<in> set (interp_ins (pre @ [(oid, Some ref)] @ suf))", "by (metis UnCI append_assoc insert_spec_set interp_ins_monotonic\n      interp_ins_tail_unfold singletonI)"], ["", "lemma interp_ins_append_forward:\n  assumes \"insert_ops (xs @ ys)\"\n    and \"oid \\<in> set (interp_ins (xs @ ys))\"\n    and \"oid \\<in> set (map fst xs)\"\n  shows \"oid \\<in> set (interp_ins xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oid \\<in> set (interp_ins xs)", "using assms"], ["proof (prove)\nusing this:\n  insert_ops (xs @ ys)\n  oid \\<in> set (interp_ins (xs @ ys))\n  oid \\<in> set (map fst xs)\n\ngoal (1 subgoal):\n 1. oid \\<in> set (interp_ins xs)", "proof(induction ys rule: List.rev_induct, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>insert_ops (xs @ xsa);\n                 oid \\<in> set (interp_ins (xs @ xsa));\n                 oid \\<in> set (map fst xs)\\<rbrakk>\n                \\<Longrightarrow> oid \\<in> set (interp_ins xs);\n        insert_ops (xs @ xsa @ [x]);\n        oid \\<in> set (interp_ins (xs @ xsa @ [x]));\n        oid \\<in> set (map fst xs)\\<rbrakk>\n       \\<Longrightarrow> oid \\<in> set (interp_ins xs)", "case (snoc y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>insert_ops (xs @ ys); oid \\<in> set (interp_ins (xs @ ys));\n   oid \\<in> set (map fst xs)\\<rbrakk>\n  \\<Longrightarrow> oid \\<in> set (interp_ins xs)\n  insert_ops (xs @ ys @ [y])\n  oid \\<in> set (interp_ins (xs @ ys @ [y]))\n  oid \\<in> set (map fst xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>insert_ops (xs @ xsa);\n                 oid \\<in> set (interp_ins (xs @ xsa));\n                 oid \\<in> set (map fst xs)\\<rbrakk>\n                \\<Longrightarrow> oid \\<in> set (interp_ins xs);\n        insert_ops (xs @ xsa @ [x]);\n        oid \\<in> set (interp_ins (xs @ xsa @ [x]));\n        oid \\<in> set (map fst xs)\\<rbrakk>\n       \\<Longrightarrow> oid \\<in> set (interp_ins xs)", "obtain cs ds ref where \"xs = cs @ (oid, ref) # ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cs ref ds.\n        xs = cs @ (oid, ref) # ds \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, lifting) imageE prod.collapse set_map snoc.prems(3) split_list_last)"], ["proof (state)\nthis:\n  xs = cs @ (oid, ref) # ds\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>insert_ops (xs @ xsa);\n                 oid \\<in> set (interp_ins (xs @ xsa));\n                 oid \\<in> set (map fst xs)\\<rbrakk>\n                \\<Longrightarrow> oid \\<in> set (interp_ins xs);\n        insert_ops (xs @ xsa @ [x]);\n        oid \\<in> set (interp_ins (xs @ xsa @ [x]));\n        oid \\<in> set (map fst xs)\\<rbrakk>\n       \\<Longrightarrow> oid \\<in> set (interp_ins xs)", "hence \"insert_ops (cs @ [(oid, ref)] @ (ds @ ys) @ [y])\""], ["proof (prove)\nusing this:\n  xs = cs @ (oid, ref) # ds\n\ngoal (1 subgoal):\n 1. insert_ops (cs @ [(oid, ref)] @ (ds @ ys) @ [y])", "using snoc.prems(1)"], ["proof (prove)\nusing this:\n  xs = cs @ (oid, ref) # ds\n  insert_ops (xs @ ys @ [y])\n\ngoal (1 subgoal):\n 1. insert_ops (cs @ [(oid, ref)] @ (ds @ ys) @ [y])", "by auto"], ["proof (state)\nthis:\n  insert_ops (cs @ [(oid, ref)] @ (ds @ ys) @ [y])\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>insert_ops (xs @ xsa);\n                 oid \\<in> set (interp_ins (xs @ xsa));\n                 oid \\<in> set (map fst xs)\\<rbrakk>\n                \\<Longrightarrow> oid \\<in> set (interp_ins xs);\n        insert_ops (xs @ xsa @ [x]);\n        oid \\<in> set (interp_ins (xs @ xsa @ [x]));\n        oid \\<in> set (map fst xs)\\<rbrakk>\n       \\<Longrightarrow> oid \\<in> set (interp_ins xs)", "hence \"oid < fst y\""], ["proof (prove)\nusing this:\n  insert_ops (cs @ [(oid, ref)] @ (ds @ ys) @ [y])\n\ngoal (1 subgoal):\n 1. oid < fst y", "using insert_ops_sorted_oids"], ["proof (prove)\nusing this:\n  insert_ops (cs @ [(oid, ref)] @ (ds @ ys) @ [y])\n  insert_ops\n   (?xs @ [(?i1.0, ?r1.0)] @ ?ys @ [(?i2.0, ?r2.0)]) \\<Longrightarrow>\n  ?i1.0 < ?i2.0\n\ngoal (1 subgoal):\n 1. oid < fst y", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  oid < fst y\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>insert_ops (xs @ xsa);\n                 oid \\<in> set (interp_ins (xs @ xsa));\n                 oid \\<in> set (map fst xs)\\<rbrakk>\n                \\<Longrightarrow> oid \\<in> set (interp_ins xs);\n        insert_ops (xs @ xsa @ [x]);\n        oid \\<in> set (interp_ins (xs @ xsa @ [x]));\n        oid \\<in> set (map fst xs)\\<rbrakk>\n       \\<Longrightarrow> oid \\<in> set (interp_ins xs)", "hence \"oid \\<noteq> fst y\""], ["proof (prove)\nusing this:\n  oid < fst y\n\ngoal (1 subgoal):\n 1. oid \\<noteq> fst y", "by blast"], ["proof (state)\nthis:\n  oid \\<noteq> fst y\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>insert_ops (xs @ xsa);\n                 oid \\<in> set (interp_ins (xs @ xsa));\n                 oid \\<in> set (map fst xs)\\<rbrakk>\n                \\<Longrightarrow> oid \\<in> set (interp_ins xs);\n        insert_ops (xs @ xsa @ [x]);\n        oid \\<in> set (interp_ins (xs @ xsa @ [x]));\n        oid \\<in> set (map fst xs)\\<rbrakk>\n       \\<Longrightarrow> oid \\<in> set (interp_ins xs)", "then"], ["proof (chain)\npicking this:\n  oid \\<noteq> fst y", "show ?case"], ["proof (prove)\nusing this:\n  oid \\<noteq> fst y\n\ngoal (1 subgoal):\n 1. oid \\<in> set (interp_ins xs)", "using snoc.IH snoc.prems(1) snoc.prems(2) assms(3) inserted_item_ident"], ["proof (prove)\nusing this:\n  oid \\<noteq> fst y\n  \\<lbrakk>insert_ops (xs @ ys); oid \\<in> set (interp_ins (xs @ ys));\n   oid \\<in> set (map fst xs)\\<rbrakk>\n  \\<Longrightarrow> oid \\<in> set (interp_ins xs)\n  insert_ops (xs @ ys @ [y])\n  oid \\<in> set (interp_ins (xs @ ys @ [y]))\n  oid \\<in> set (map fst xs)\n  \\<lbrakk>?a \\<in> set (insert_spec ?xs (?e, ?i));\n   ?a \\<notin> set ?xs\\<rbrakk>\n  \\<Longrightarrow> ?a = ?e\n\ngoal (1 subgoal):\n 1. oid \\<in> set (interp_ins xs)", "by (metis append_assoc insert_ops_appendD interp_ins_tail_unfold prod.collapse)"], ["proof (state)\nthis:\n  oid \\<in> set (interp_ins xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma interp_ins_find_ref:\n  assumes \"insert_ops (xs @ [(oid, Some ref)] @ ys)\"\n    and \"ref \\<in> set (interp_ins (xs @ [(oid, Some ref)] @ ys))\"\n  shows \"\\<exists>r. (ref, r) \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r. (ref, r) \\<in> set xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r. (ref, r) \\<in> set xs", "have \"ref < oid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ref < oid", "using assms(1) insert_ops_ref_older"], ["proof (prove)\nusing this:\n  insert_ops (xs @ [(oid, Some ref)] @ ys)\n  insert_ops (?pre @ [(?oid, Some ?ref)] @ ?suf) \\<Longrightarrow>\n  ?ref < ?oid\n\ngoal (1 subgoal):\n 1. ref < oid", "by blast"], ["proof (state)\nthis:\n  ref < oid\n\ngoal (1 subgoal):\n 1. \\<exists>r. (ref, r) \\<in> set xs", "have \"ref \\<in> set (map fst (xs @ [(oid, Some ref)] @ ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ref \\<in> set (map fst (xs @ [(oid, Some ref)] @ ys))", "by (meson assms(2) interp_ins_subset subsetCE)"], ["proof (state)\nthis:\n  ref \\<in> set (map fst (xs @ [(oid, Some ref)] @ ys))\n\ngoal (1 subgoal):\n 1. \\<exists>r. (ref, r) \\<in> set xs", "then"], ["proof (chain)\npicking this:\n  ref \\<in> set (map fst (xs @ [(oid, Some ref)] @ ys))", "obtain x where x_prop: \"x \\<in> set (xs @ [(oid, Some ref)] @ ys) \\<and> fst x = ref\""], ["proof (prove)\nusing this:\n  ref \\<in> set (map fst (xs @ [(oid, Some ref)] @ ys))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> set (xs @ [(oid, Some ref)] @ ys) \\<and>\n        fst x = ref \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x \\<in> set (xs @ [(oid, Some ref)] @ ys) \\<and> fst x = ref\n\ngoal (1 subgoal):\n 1. \\<exists>r. (ref, r) \\<in> set xs", "obtain xr where x_pair: \"x = (ref, xr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xr. x = (ref, xr) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust_sel x_prop"], ["proof (prove)\nusing this:\n  (?prod = (fst ?prod, snd ?prod) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n  x \\<in> set (xs @ [(oid, Some ref)] @ ys) \\<and> fst x = ref\n\ngoal (1 subgoal):\n 1. (\\<And>xr. x = (ref, xr) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = (ref, xr)\n\ngoal (1 subgoal):\n 1. \\<exists>r. (ref, r) \\<in> set xs", "show \"\\<exists>r. (ref, r) \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r. (ref, r) \\<in> set xs", "proof(cases \"x \\<in> set xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> set xs \\<Longrightarrow> \\<exists>r. (ref, r) \\<in> set xs\n 2. x \\<notin> set xs \\<Longrightarrow> \\<exists>r. (ref, r) \\<in> set xs", "case True"], ["proof (state)\nthis:\n  x \\<in> set xs\n\ngoal (2 subgoals):\n 1. x \\<in> set xs \\<Longrightarrow> \\<exists>r. (ref, r) \\<in> set xs\n 2. x \\<notin> set xs \\<Longrightarrow> \\<exists>r. (ref, r) \\<in> set xs", "then"], ["proof (chain)\npicking this:\n  x \\<in> set xs", "show \"\\<exists>r. (ref, r) \\<in> set xs\""], ["proof (prove)\nusing this:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<exists>r. (ref, r) \\<in> set xs", "by (metis x_prop prod.collapse)"], ["proof (state)\nthis:\n  \\<exists>r. (ref, r) \\<in> set xs\n\ngoal (1 subgoal):\n 1. x \\<notin> set xs \\<Longrightarrow> \\<exists>r. (ref, r) \\<in> set xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> set xs \\<Longrightarrow> \\<exists>r. (ref, r) \\<in> set xs", "case False"], ["proof (state)\nthis:\n  x \\<notin> set xs\n\ngoal (1 subgoal):\n 1. x \\<notin> set xs \\<Longrightarrow> \\<exists>r. (ref, r) \\<in> set xs", "hence \"(ref, xr) \\<in> set ([(oid, Some ref)] @ ys)\""], ["proof (prove)\nusing this:\n  x \\<notin> set xs\n\ngoal (1 subgoal):\n 1. (ref, xr) \\<in> set ([(oid, Some ref)] @ ys)", "using x_prop x_pair"], ["proof (prove)\nusing this:\n  x \\<notin> set xs\n  x \\<in> set (xs @ [(oid, Some ref)] @ ys) \\<and> fst x = ref\n  x = (ref, xr)\n\ngoal (1 subgoal):\n 1. (ref, xr) \\<in> set ([(oid, Some ref)] @ ys)", "by auto"], ["proof (state)\nthis:\n  (ref, xr) \\<in> set ([(oid, Some ref)] @ ys)\n\ngoal (1 subgoal):\n 1. x \\<notin> set xs \\<Longrightarrow> \\<exists>r. (ref, r) \\<in> set xs", "hence \"(ref, xr) \\<in> set ys\""], ["proof (prove)\nusing this:\n  (ref, xr) \\<in> set ([(oid, Some ref)] @ ys)\n\ngoal (1 subgoal):\n 1. (ref, xr) \\<in> set ys", "using \\<open>ref < oid\\<close> x_prop"], ["proof (prove)\nusing this:\n  (ref, xr) \\<in> set ([(oid, Some ref)] @ ys)\n  ref < oid\n  x \\<in> set (xs @ [(oid, Some ref)] @ ys) \\<and> fst x = ref\n\ngoal (1 subgoal):\n 1. (ref, xr) \\<in> set ys", "by (metis append_Cons append_self_conv2 fst_conv min.strict_order_iff set_ConsD)"], ["proof (state)\nthis:\n  (ref, xr) \\<in> set ys\n\ngoal (1 subgoal):\n 1. x \\<notin> set xs \\<Longrightarrow> \\<exists>r. (ref, r) \\<in> set xs", "then"], ["proof (chain)\npicking this:\n  (ref, xr) \\<in> set ys", "obtain as bs where \"ys = as @ (ref, xr) # bs\""], ["proof (prove)\nusing this:\n  (ref, xr) \\<in> set ys\n\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        ys = as @ (ref, xr) # bs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson split_list)"], ["proof (state)\nthis:\n  ys = as @ (ref, xr) # bs\n\ngoal (1 subgoal):\n 1. x \\<notin> set xs \\<Longrightarrow> \\<exists>r. (ref, r) \\<in> set xs", "hence \"insert_ops ((xs @ [(oid, Some ref)] @ as @ [(ref, xr)]) @ bs)\""], ["proof (prove)\nusing this:\n  ys = as @ (ref, xr) # bs\n\ngoal (1 subgoal):\n 1. insert_ops ((xs @ [(oid, Some ref)] @ as @ [(ref, xr)]) @ bs)", "using assms(1)"], ["proof (prove)\nusing this:\n  ys = as @ (ref, xr) # bs\n  insert_ops (xs @ [(oid, Some ref)] @ ys)\n\ngoal (1 subgoal):\n 1. insert_ops ((xs @ [(oid, Some ref)] @ as @ [(ref, xr)]) @ bs)", "by auto"], ["proof (state)\nthis:\n  insert_ops ((xs @ [(oid, Some ref)] @ as @ [(ref, xr)]) @ bs)\n\ngoal (1 subgoal):\n 1. x \\<notin> set xs \\<Longrightarrow> \\<exists>r. (ref, r) \\<in> set xs", "hence \"insert_ops (xs @ [(oid, Some ref)] @ as @ [(ref, xr)])\""], ["proof (prove)\nusing this:\n  insert_ops ((xs @ [(oid, Some ref)] @ as @ [(ref, xr)]) @ bs)\n\ngoal (1 subgoal):\n 1. insert_ops (xs @ [(oid, Some ref)] @ as @ [(ref, xr)])", "using insert_ops_appendD"], ["proof (prove)\nusing this:\n  insert_ops ((xs @ [(oid, Some ref)] @ as @ [(ref, xr)]) @ bs)\n  insert_ops (?xs @ ?ys) \\<Longrightarrow> insert_ops ?xs\n\ngoal (1 subgoal):\n 1. insert_ops (xs @ [(oid, Some ref)] @ as @ [(ref, xr)])", "by blast"], ["proof (state)\nthis:\n  insert_ops (xs @ [(oid, Some ref)] @ as @ [(ref, xr)])\n\ngoal (1 subgoal):\n 1. x \\<notin> set xs \\<Longrightarrow> \\<exists>r. (ref, r) \\<in> set xs", "hence \"oid < ref\""], ["proof (prove)\nusing this:\n  insert_ops (xs @ [(oid, Some ref)] @ as @ [(ref, xr)])\n\ngoal (1 subgoal):\n 1. oid < ref", "(* contradiction *)"], ["proof (prove)\nusing this:\n  insert_ops (xs @ [(oid, Some ref)] @ as @ [(ref, xr)])\n\ngoal (1 subgoal):\n 1. oid < ref", "using insert_ops_sorted_oids"], ["proof (prove)\nusing this:\n  insert_ops (xs @ [(oid, Some ref)] @ as @ [(ref, xr)])\n  insert_ops\n   (?xs @ [(?i1.0, ?r1.0)] @ ?ys @ [(?i2.0, ?r2.0)]) \\<Longrightarrow>\n  ?i1.0 < ?i2.0\n\ngoal (1 subgoal):\n 1. oid < ref", "by auto"], ["proof (state)\nthis:\n  oid < ref\n\ngoal (1 subgoal):\n 1. x \\<notin> set xs \\<Longrightarrow> \\<exists>r. (ref, r) \\<in> set xs", "then"], ["proof (chain)\npicking this:\n  oid < ref", "show ?thesis"], ["proof (prove)\nusing this:\n  oid < ref\n\ngoal (1 subgoal):\n 1. \\<exists>r. (ref, r) \\<in> set xs", "using \\<open>ref < oid\\<close>"], ["proof (prove)\nusing this:\n  oid < ref\n  ref < oid\n\ngoal (1 subgoal):\n 1. \\<exists>r. (ref, r) \\<in> set xs", "by force"], ["proof (state)\nthis:\n  \\<exists>r. (ref, r) \\<in> set xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>r. (ref, r) \\<in> set xs\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Lemmas about \\isa{list-order}\\<close>"], ["", "lemma list_order_append:\n  assumes \"insert_ops (pre @ suf)\"\n    and \"list_order pre x y\"\n  shows \"list_order (pre @ suf) x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_order (pre @ suf) x y", "by (metis Un_iff assms list_order_monotonic insert_ops_appendD set_append subset_code(1))"], ["", "lemma list_order_insert_ref:\n  assumes \"insert_ops (ops @ [(oid, Some ref)])\"\n    and \"ref \\<in> set (interp_ins ops)\"\n  shows \"list_order (ops @ [(oid, Some ref)]) ref oid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_order (ops @ [(oid, Some ref)]) ref oid", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_order (ops @ [(oid, Some ref)]) ref oid", "have \"interp_ins (ops @ [(oid, Some ref)]) = insert_spec (interp_ins ops) (oid, Some ref)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interp_ins (ops @ [(oid, Some ref)]) =\n    insert_spec (interp_ins ops) (oid, Some ref)", "by (simp add: interp_ins_tail_unfold)"], ["proof (state)\nthis:\n  interp_ins (ops @ [(oid, Some ref)]) =\n  insert_spec (interp_ins ops) (oid, Some ref)\n\ngoal (1 subgoal):\n 1. list_order (ops @ [(oid, Some ref)]) ref oid", "moreover"], ["proof (state)\nthis:\n  interp_ins (ops @ [(oid, Some ref)]) =\n  insert_spec (interp_ins ops) (oid, Some ref)\n\ngoal (1 subgoal):\n 1. list_order (ops @ [(oid, Some ref)]) ref oid", "obtain xs ys where \"interp_ins ops = xs @ [ref] @ ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        interp_ins ops = xs @ [ref] @ ys \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(2) split_list_first"], ["proof (prove)\nusing this:\n  ref \\<in> set (interp_ins ops)\n  ?x \\<in> set ?xs \\<Longrightarrow>\n  \\<exists>ys zs. ?xs = ys @ ?x # zs \\<and> ?x \\<notin> set ys\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        interp_ins ops = xs @ [ref] @ ys \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  interp_ins ops = xs @ [ref] @ ys\n\ngoal (1 subgoal):\n 1. list_order (ops @ [(oid, Some ref)]) ref oid", "hence \"insert_spec (interp_ins ops) (oid, Some ref) = xs @ [ref] @ [] @ [oid] @ ys\""], ["proof (prove)\nusing this:\n  interp_ins ops = xs @ [ref] @ ys\n\ngoal (1 subgoal):\n 1. insert_spec (interp_ins ops) (oid, Some ref) =\n    xs @ [ref] @ [] @ [oid] @ ys", "using assms(1) insert_after_ref interp_ins_distinct"], ["proof (prove)\nusing this:\n  interp_ins ops = xs @ [ref] @ ys\n  insert_ops (ops @ [(oid, Some ref)])\n  distinct (?xs @ ?ref # ?ys) \\<Longrightarrow>\n  insert_spec (?xs @ ?ref # ?ys) (?oid, Some ?ref) = ?xs @ ?ref # ?oid # ?ys\n  insert_ops ?op_list \\<Longrightarrow> distinct (interp_ins ?op_list)\n\ngoal (1 subgoal):\n 1. insert_spec (interp_ins ops) (oid, Some ref) =\n    xs @ [ref] @ [] @ [oid] @ ys", "by fastforce"], ["proof (state)\nthis:\n  insert_spec (interp_ins ops) (oid, Some ref) =\n  xs @ [ref] @ [] @ [oid] @ ys\n\ngoal (1 subgoal):\n 1. list_order (ops @ [(oid, Some ref)]) ref oid", "ultimately"], ["proof (chain)\npicking this:\n  interp_ins (ops @ [(oid, Some ref)]) =\n  insert_spec (interp_ins ops) (oid, Some ref)\n  insert_spec (interp_ins ops) (oid, Some ref) =\n  xs @ [ref] @ [] @ [oid] @ ys", "show \"list_order (ops @ [(oid, Some ref)]) ref oid\""], ["proof (prove)\nusing this:\n  interp_ins (ops @ [(oid, Some ref)]) =\n  insert_spec (interp_ins ops) (oid, Some ref)\n  insert_spec (interp_ins ops) (oid, Some ref) =\n  xs @ [ref] @ [] @ [oid] @ ys\n\ngoal (1 subgoal):\n 1. list_order (ops @ [(oid, Some ref)]) ref oid", "using assms(1) list_orderI"], ["proof (prove)\nusing this:\n  interp_ins (ops @ [(oid, Some ref)]) =\n  insert_spec (interp_ins ops) (oid, Some ref)\n  insert_spec (interp_ins ops) (oid, Some ref) =\n  xs @ [ref] @ [] @ [oid] @ ys\n  insert_ops (ops @ [(oid, Some ref)])\n  interp_ins ?ops = ?xs @ [?x] @ ?ys @ [?y] @ ?zs \\<Longrightarrow>\n  list_order ?ops ?x ?y\n\ngoal (1 subgoal):\n 1. list_order (ops @ [(oid, Some ref)]) ref oid", "by metis"], ["proof (state)\nthis:\n  list_order (ops @ [(oid, Some ref)]) ref oid\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_order_insert_none:\n  assumes \"insert_ops (ops @ [(oid, None)])\"\n    and \"x \\<in> set (interp_ins ops)\"\n  shows \"list_order (ops @ [(oid, None)]) oid x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_order (ops @ [(oid, None)]) oid x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_order (ops @ [(oid, None)]) oid x", "have \"interp_ins (ops @ [(oid, None)]) = insert_spec (interp_ins ops) (oid, None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interp_ins (ops @ [(oid, None)]) =\n    insert_spec (interp_ins ops) (oid, None)", "by (simp add: interp_ins_tail_unfold)"], ["proof (state)\nthis:\n  interp_ins (ops @ [(oid, None)]) =\n  insert_spec (interp_ins ops) (oid, None)\n\ngoal (1 subgoal):\n 1. list_order (ops @ [(oid, None)]) oid x", "moreover"], ["proof (state)\nthis:\n  interp_ins (ops @ [(oid, None)]) =\n  insert_spec (interp_ins ops) (oid, None)\n\ngoal (1 subgoal):\n 1. list_order (ops @ [(oid, None)]) oid x", "obtain xs ys where \"interp_ins ops = xs @ [x] @ ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        interp_ins ops = xs @ [x] @ ys \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(2) split_list_first"], ["proof (prove)\nusing this:\n  x \\<in> set (interp_ins ops)\n  ?x \\<in> set ?xs \\<Longrightarrow>\n  \\<exists>ys zs. ?xs = ys @ ?x # zs \\<and> ?x \\<notin> set ys\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        interp_ins ops = xs @ [x] @ ys \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  interp_ins ops = xs @ [x] @ ys\n\ngoal (1 subgoal):\n 1. list_order (ops @ [(oid, None)]) oid x", "hence \"insert_spec (interp_ins ops) (oid, None) = [] @ [oid] @ xs @ [x] @ ys\""], ["proof (prove)\nusing this:\n  interp_ins ops = xs @ [x] @ ys\n\ngoal (1 subgoal):\n 1. insert_spec (interp_ins ops) (oid, None) = [] @ [oid] @ xs @ [x] @ ys", "by simp"], ["proof (state)\nthis:\n  insert_spec (interp_ins ops) (oid, None) = [] @ [oid] @ xs @ [x] @ ys\n\ngoal (1 subgoal):\n 1. list_order (ops @ [(oid, None)]) oid x", "ultimately"], ["proof (chain)\npicking this:\n  interp_ins (ops @ [(oid, None)]) =\n  insert_spec (interp_ins ops) (oid, None)\n  insert_spec (interp_ins ops) (oid, None) = [] @ [oid] @ xs @ [x] @ ys", "show \"list_order (ops @ [(oid, None)]) oid x\""], ["proof (prove)\nusing this:\n  interp_ins (ops @ [(oid, None)]) =\n  insert_spec (interp_ins ops) (oid, None)\n  insert_spec (interp_ins ops) (oid, None) = [] @ [oid] @ xs @ [x] @ ys\n\ngoal (1 subgoal):\n 1. list_order (ops @ [(oid, None)]) oid x", "using assms(1) list_orderI"], ["proof (prove)\nusing this:\n  interp_ins (ops @ [(oid, None)]) =\n  insert_spec (interp_ins ops) (oid, None)\n  insert_spec (interp_ins ops) (oid, None) = [] @ [oid] @ xs @ [x] @ ys\n  insert_ops (ops @ [(oid, None)])\n  interp_ins ?ops = ?xs @ [?x] @ ?ys @ [?y] @ ?zs \\<Longrightarrow>\n  list_order ?ops ?x ?y\n\ngoal (1 subgoal):\n 1. list_order (ops @ [(oid, None)]) oid x", "by metis"], ["proof (state)\nthis:\n  list_order (ops @ [(oid, None)]) oid x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_order_insert_between:\n  assumes \"insert_ops (ops @ [(oid, Some ref)])\"\n    and \"list_order ops ref x\"\n  shows \"list_order (ops @ [(oid, Some ref)]) oid x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_order (ops @ [(oid, Some ref)]) oid x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_order (ops @ [(oid, Some ref)]) oid x", "have \"interp_ins (ops @ [(oid, Some ref)]) = insert_spec (interp_ins ops) (oid, Some ref)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interp_ins (ops @ [(oid, Some ref)]) =\n    insert_spec (interp_ins ops) (oid, Some ref)", "by (simp add: interp_ins_tail_unfold)"], ["proof (state)\nthis:\n  interp_ins (ops @ [(oid, Some ref)]) =\n  insert_spec (interp_ins ops) (oid, Some ref)\n\ngoal (1 subgoal):\n 1. list_order (ops @ [(oid, Some ref)]) oid x", "moreover"], ["proof (state)\nthis:\n  interp_ins (ops @ [(oid, Some ref)]) =\n  insert_spec (interp_ins ops) (oid, Some ref)\n\ngoal (1 subgoal):\n 1. list_order (ops @ [(oid, Some ref)]) oid x", "obtain xs ys zs where \"interp_ins ops = xs @ [ref] @ ys @ [x] @ zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs ys zs.\n        interp_ins ops = xs @ [ref] @ ys @ [x] @ zs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms list_orderE"], ["proof (prove)\nusing this:\n  insert_ops (ops @ [(oid, Some ref)])\n  list_order ops ref x\n  list_order ?ops ?x ?y \\<Longrightarrow>\n  \\<exists>xs ys zs. interp_ins ?ops = xs @ [?x] @ ys @ [?y] @ zs\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys zs.\n        interp_ins ops = xs @ [ref] @ ys @ [x] @ zs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  interp_ins ops = xs @ [ref] @ ys @ [x] @ zs\n\ngoal (1 subgoal):\n 1. list_order (ops @ [(oid, Some ref)]) oid x", "moreover"], ["proof (state)\nthis:\n  interp_ins ops = xs @ [ref] @ ys @ [x] @ zs\n\ngoal (1 subgoal):\n 1. list_order (ops @ [(oid, Some ref)]) oid x", "have \"... = xs @ ref # (ys @ [x] @ zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @ [ref] @ ys @ [x] @ zs = xs @ ref # ys @ [x] @ zs", "by simp"], ["proof (state)\nthis:\n  xs @ [ref] @ ys @ [x] @ zs = xs @ ref # ys @ [x] @ zs\n\ngoal (1 subgoal):\n 1. list_order (ops @ [(oid, Some ref)]) oid x", "moreover"], ["proof (state)\nthis:\n  xs @ [ref] @ ys @ [x] @ zs = xs @ ref # ys @ [x] @ zs\n\ngoal (1 subgoal):\n 1. list_order (ops @ [(oid, Some ref)]) oid x", "have \"distinct (xs @ ref # (ys @ [x] @ zs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (xs @ ref # ys @ [x] @ zs)", "using assms(1) calculation"], ["proof (prove)\nusing this:\n  insert_ops (ops @ [(oid, Some ref)])\n  interp_ins (ops @ [(oid, Some ref)]) =\n  insert_spec (interp_ins ops) (oid, Some ref)\n  interp_ins ops = xs @ [ref] @ ys @ [x] @ zs\n  xs @ [ref] @ ys @ [x] @ zs = xs @ ref # ys @ [x] @ zs\n\ngoal (1 subgoal):\n 1. distinct (xs @ ref # ys @ [x] @ zs)", "by (metis interp_ins_distinct insert_ops_rem_last)"], ["proof (state)\nthis:\n  distinct (xs @ ref # ys @ [x] @ zs)\n\ngoal (1 subgoal):\n 1. list_order (ops @ [(oid, Some ref)]) oid x", "hence \"insert_spec (xs @ ref # (ys @ [x] @ zs)) (oid, Some ref) = xs @ ref # oid # (ys @ [x] @ zs)\""], ["proof (prove)\nusing this:\n  distinct (xs @ ref # ys @ [x] @ zs)\n\ngoal (1 subgoal):\n 1. insert_spec (xs @ ref # ys @ [x] @ zs) (oid, Some ref) =\n    xs @ ref # oid # ys @ [x] @ zs", "using assms(1) calculation"], ["proof (prove)\nusing this:\n  distinct (xs @ ref # ys @ [x] @ zs)\n  insert_ops (ops @ [(oid, Some ref)])\n  interp_ins (ops @ [(oid, Some ref)]) =\n  insert_spec (interp_ins ops) (oid, Some ref)\n  interp_ins ops = xs @ [ref] @ ys @ [x] @ zs\n  xs @ [ref] @ ys @ [x] @ zs = xs @ ref # ys @ [x] @ zs\n\ngoal (1 subgoal):\n 1. insert_spec (xs @ ref # ys @ [x] @ zs) (oid, Some ref) =\n    xs @ ref # oid # ys @ [x] @ zs", "by (simp add: insert_after_ref)"], ["proof (state)\nthis:\n  insert_spec (xs @ ref # ys @ [x] @ zs) (oid, Some ref) =\n  xs @ ref # oid # ys @ [x] @ zs\n\ngoal (1 subgoal):\n 1. list_order (ops @ [(oid, Some ref)]) oid x", "moreover"], ["proof (state)\nthis:\n  insert_spec (xs @ ref # ys @ [x] @ zs) (oid, Some ref) =\n  xs @ ref # oid # ys @ [x] @ zs\n\ngoal (1 subgoal):\n 1. list_order (ops @ [(oid, Some ref)]) oid x", "have \"... = (xs @ [ref]) @ [oid] @ ys @ [x] @ zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @ ref # oid # ys @ [x] @ zs = (xs @ [ref]) @ [oid] @ ys @ [x] @ zs", "by simp"], ["proof (state)\nthis:\n  xs @ ref # oid # ys @ [x] @ zs = (xs @ [ref]) @ [oid] @ ys @ [x] @ zs\n\ngoal (1 subgoal):\n 1. list_order (ops @ [(oid, Some ref)]) oid x", "ultimately"], ["proof (chain)\npicking this:\n  interp_ins (ops @ [(oid, Some ref)]) =\n  insert_spec (interp_ins ops) (oid, Some ref)\n  interp_ins ops = xs @ [ref] @ ys @ [x] @ zs\n  xs @ [ref] @ ys @ [x] @ zs = xs @ ref # ys @ [x] @ zs\n  insert_spec (xs @ ref # ys @ [x] @ zs) (oid, Some ref) =\n  xs @ ref # oid # ys @ [x] @ zs\n  xs @ ref # oid # ys @ [x] @ zs = (xs @ [ref]) @ [oid] @ ys @ [x] @ zs", "show \"list_order (ops @ [(oid, Some ref)]) oid x\""], ["proof (prove)\nusing this:\n  interp_ins (ops @ [(oid, Some ref)]) =\n  insert_spec (interp_ins ops) (oid, Some ref)\n  interp_ins ops = xs @ [ref] @ ys @ [x] @ zs\n  xs @ [ref] @ ys @ [x] @ zs = xs @ ref # ys @ [x] @ zs\n  insert_spec (xs @ ref # ys @ [x] @ zs) (oid, Some ref) =\n  xs @ ref # oid # ys @ [x] @ zs\n  xs @ ref # oid # ys @ [x] @ zs = (xs @ [ref]) @ [oid] @ ys @ [x] @ zs\n\ngoal (1 subgoal):\n 1. list_order (ops @ [(oid, Some ref)]) oid x", "using assms(1) list_orderI"], ["proof (prove)\nusing this:\n  interp_ins (ops @ [(oid, Some ref)]) =\n  insert_spec (interp_ins ops) (oid, Some ref)\n  interp_ins ops = xs @ [ref] @ ys @ [x] @ zs\n  xs @ [ref] @ ys @ [x] @ zs = xs @ ref # ys @ [x] @ zs\n  insert_spec (xs @ ref # ys @ [x] @ zs) (oid, Some ref) =\n  xs @ ref # oid # ys @ [x] @ zs\n  xs @ ref # oid # ys @ [x] @ zs = (xs @ [ref]) @ [oid] @ ys @ [x] @ zs\n  insert_ops (ops @ [(oid, Some ref)])\n  interp_ins ?ops = ?xs @ [?x] @ ?ys @ [?y] @ ?zs \\<Longrightarrow>\n  list_order ?ops ?x ?y\n\ngoal (1 subgoal):\n 1. list_order (ops @ [(oid, Some ref)]) oid x", "by metis"], ["proof (state)\nthis:\n  list_order (ops @ [(oid, Some ref)]) oid x\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>The \\isa{insert-seq} predicate\\<close>"], ["", "text\\<open>The predicate \\isa{insert-seq start ops} is true iff \\isa{ops} is a list\nof insertion operations that begins by inserting after \\isa{start}, and then\ncontinues by placing each subsequent insertion directly after its predecessor.\nThis definition models the sequential insertion of text at a particular place\nin a text document.\\<close>"], ["", "inductive insert_seq :: \"'oid option \\<Rightarrow> ('oid \\<times> 'oid option) list \\<Rightarrow> bool\" where\n  \"insert_seq start [(oid, start)]\" |\n  \"\\<lbrakk>insert_seq start (list @ [(prev, ref)])\\<rbrakk>\n      \\<Longrightarrow> insert_seq start (list @ [(prev, ref), (oid, Some prev)])\""], ["", "lemma insert_seq_nonempty:\n  assumes \"insert_seq start xs\"\n  shows \"xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  insert_seq start xs\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by (induction rule: insert_seq.induct, auto)"], ["", "lemma insert_seq_hd:\n  assumes \"insert_seq start xs\"\n  shows \"\\<exists>oid. hd xs = (oid, start)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>oid. hd xs = (oid, start)", "using assms"], ["proof (prove)\nusing this:\n  insert_seq start xs\n\ngoal (1 subgoal):\n 1. \\<exists>oid. hd xs = (oid, start)", "by (induction rule: insert_seq.induct, simp,\n      metis append_self_conv2 hd_append2 list.sel(1))"], ["", "lemma insert_seq_rem_last:\n  assumes \"insert_seq start (xs @ [x])\"\n    and \"xs \\<noteq> []\"\n  shows \"insert_seq start xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_seq start xs", "using assms insert_seq.cases"], ["proof (prove)\nusing this:\n  insert_seq start (xs @ [x])\n  xs \\<noteq> []\n  \\<lbrakk>insert_seq ?a1.0 ?a2.0;\n   \\<And>start oid.\n      \\<lbrakk>?a1.0 = start; ?a2.0 = [(oid, start)]\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>start list prev ref oid.\n      \\<lbrakk>?a1.0 = start;\n       ?a2.0 = list @ [(prev, ref), (oid, Some prev)];\n       insert_seq start (list @ [(prev, ref)])\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. insert_seq start xs", "by fastforce"], ["", "lemma insert_seq_butlast:\n  assumes \"insert_seq start xs\"\n    and \"xs \\<noteq> []\" and \"xs \\<noteq> [last xs]\"\n  shows \"insert_seq start (butlast xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_seq start (butlast xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. insert_seq start (butlast xs)", "have \"length xs > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length xs", "by (metis One_nat_def Suc_lessI add_0_left append_butlast_last_id append_eq_append_conv\n        append_self_conv2 assms(2) assms(3) length_greater_0_conv list.size(3) list.size(4))"], ["proof (state)\nthis:\n  1 < length xs\n\ngoal (1 subgoal):\n 1. insert_seq start (butlast xs)", "hence \"butlast xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  1 < length xs\n\ngoal (1 subgoal):\n 1. butlast xs \\<noteq> []", "by (metis length_butlast less_numeral_extra(3) list.size(3) zero_less_diff)"], ["proof (state)\nthis:\n  butlast xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. insert_seq start (butlast xs)", "then"], ["proof (chain)\npicking this:\n  butlast xs \\<noteq> []", "show \"insert_seq start (butlast xs)\""], ["proof (prove)\nusing this:\n  butlast xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. insert_seq start (butlast xs)", "using assms"], ["proof (prove)\nusing this:\n  butlast xs \\<noteq> []\n  insert_seq start xs\n  xs \\<noteq> []\n  xs \\<noteq> [last xs]\n\ngoal (1 subgoal):\n 1. insert_seq start (butlast xs)", "by (metis append_butlast_last_id insert_seq_rem_last)"], ["proof (state)\nthis:\n  insert_seq start (butlast xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_seq_last_ref:\n  assumes \"insert_seq start (xs @ [(xi, xr), (yi, yr)])\"\n  shows \"yr = Some xi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. yr = Some xi", "using assms insert_seq.cases"], ["proof (prove)\nusing this:\n  insert_seq start (xs @ [(xi, xr), (yi, yr)])\n  \\<lbrakk>insert_seq ?a1.0 ?a2.0;\n   \\<And>start oid.\n      \\<lbrakk>?a1.0 = start; ?a2.0 = [(oid, start)]\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>start list prev ref oid.\n      \\<lbrakk>?a1.0 = start;\n       ?a2.0 = list @ [(prev, ref), (oid, Some prev)];\n       insert_seq start (list @ [(prev, ref)])\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. yr = Some xi", "by fastforce"], ["", "lemma insert_seq_start_none:\n  assumes \"insert_ops ops\"\n    and \"insert_seq None xs\" and \"insert_ops xs\"\n    and \"set xs \\<subseteq> set ops\"\n  shows \"\\<forall>i \\<in> set (map fst xs). i \\<in> set (interp_ins ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops)", "using assms"], ["proof (prove)\nusing this:\n  insert_ops ops\n  insert_seq None xs\n  insert_ops xs\n  set xs \\<subseteq> set ops\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops)", "proof(induction xs rule: List.rev_induct, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops ops; insert_seq None xs; insert_ops xs;\n                 set xs \\<subseteq> set ops\\<rbrakk>\n                \\<Longrightarrow> \\<forall>i\\<in>set (map fst xs).\n                                     i \\<in> set (interp_ins ops);\n        insert_ops ops; insert_seq None (xs @ [x]); insert_ops (xs @ [x]);\n        set (xs @ [x]) \\<subseteq> set ops\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                            i \\<in> set (interp_ins ops)", "case (snoc x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>insert_ops ops; insert_seq None xs; insert_ops xs;\n   set xs \\<subseteq> set ops\\<rbrakk>\n  \\<Longrightarrow> \\<forall>i\\<in>set (map fst xs).\n                       i \\<in> set (interp_ins ops)\n  insert_ops ops\n  insert_seq None (xs @ [x])\n  insert_ops (xs @ [x])\n  set (xs @ [x]) \\<subseteq> set ops\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops ops; insert_seq None xs; insert_ops xs;\n                 set xs \\<subseteq> set ops\\<rbrakk>\n                \\<Longrightarrow> \\<forall>i\\<in>set (map fst xs).\n                                     i \\<in> set (interp_ins ops);\n        insert_ops ops; insert_seq None (xs @ [x]); insert_ops (xs @ [x]);\n        set (xs @ [x]) \\<subseteq> set ops\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                            i \\<in> set (interp_ins ops)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>insert_ops ops; insert_seq None xs; insert_ops xs;\n   set xs \\<subseteq> set ops\\<rbrakk>\n  \\<Longrightarrow> \\<forall>i\\<in>set (map fst xs).\n                       i \\<in> set (interp_ins ops)\n  insert_ops ops\n  insert_seq None (xs @ [x])\n  insert_ops (xs @ [x])\n  set (xs @ [x]) \\<subseteq> set ops", "have IH: \"\\<forall>i \\<in> set (map fst xs). i \\<in> set (interp_ins ops)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>insert_ops ops; insert_seq None xs; insert_ops xs;\n   set xs \\<subseteq> set ops\\<rbrakk>\n  \\<Longrightarrow> \\<forall>i\\<in>set (map fst xs).\n                       i \\<in> set (interp_ins ops)\n  insert_ops ops\n  insert_seq None (xs @ [x])\n  insert_ops (xs @ [x])\n  set (xs @ [x]) \\<subseteq> set ops\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops)", "by (metis Nil_is_map_conv append_is_Nil_conv insert_ops_appendD insert_seq_rem_last\n        le_supE list.simps(3) set_append split_list)"], ["proof (state)\nthis:\n  \\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops ops; insert_seq None xs; insert_ops xs;\n                 set xs \\<subseteq> set ops\\<rbrakk>\n                \\<Longrightarrow> \\<forall>i\\<in>set (map fst xs).\n                                     i \\<in> set (interp_ins ops);\n        insert_ops ops; insert_seq None (xs @ [x]); insert_ops (xs @ [x]);\n        set (xs @ [x]) \\<subseteq> set ops\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                            i \\<in> set (interp_ins ops)", "then"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops)", "show \"\\<forall>i \\<in> set (map fst (xs @ [x])). i \\<in> set (interp_ins ops)\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst (xs @ [x])). i \\<in> set (interp_ins ops)", "proof(cases \"xs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops);\n     xs = []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                         i \\<in> set (interp_ins ops)\n 2. \\<lbrakk>\\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops);\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                         i \\<in> set (interp_ins ops)", "case True"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops);\n     xs = []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                         i \\<in> set (interp_ins ops)\n 2. \\<lbrakk>\\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops);\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                         i \\<in> set (interp_ins ops)", "then"], ["proof (chain)\npicking this:\n  xs = []", "obtain oid where \"xs @ [x] = [(oid, None)]\""], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. (\\<And>oid.\n        xs @ [x] = [(oid, None)] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using insert_seq_hd snoc.prems(2)"], ["proof (prove)\nusing this:\n  xs = []\n  insert_seq ?start ?xs \\<Longrightarrow>\n  \\<exists>oid. hd ?xs = (oid, ?start)\n  insert_seq None (xs @ [x])\n\ngoal (1 subgoal):\n 1. (\\<And>oid.\n        xs @ [x] = [(oid, None)] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs @ [x] = [(oid, None)]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops);\n     xs = []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                         i \\<in> set (interp_ins ops)\n 2. \\<lbrakk>\\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops);\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                         i \\<in> set (interp_ins ops)", "hence \"(oid, None) \\<in> set ops\""], ["proof (prove)\nusing this:\n  xs @ [x] = [(oid, None)]\n\ngoal (1 subgoal):\n 1. (oid, None) \\<in> set ops", "using snoc.prems(4)"], ["proof (prove)\nusing this:\n  xs @ [x] = [(oid, None)]\n  set (xs @ [x]) \\<subseteq> set ops\n\ngoal (1 subgoal):\n 1. (oid, None) \\<in> set ops", "by auto"], ["proof (state)\nthis:\n  (oid, None) \\<in> set ops\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops);\n     xs = []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                         i \\<in> set (interp_ins ops)\n 2. \\<lbrakk>\\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops);\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                         i \\<in> set (interp_ins ops)", "then"], ["proof (chain)\npicking this:\n  (oid, None) \\<in> set ops", "obtain as bs where \"ops = as @ (oid, None) # bs\""], ["proof (prove)\nusing this:\n  (oid, None) \\<in> set ops\n\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        ops = as @ (oid, None) # bs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson split_list)"], ["proof (state)\nthis:\n  ops = as @ (oid, None) # bs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops);\n     xs = []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                         i \\<in> set (interp_ins ops)\n 2. \\<lbrakk>\\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops);\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                         i \\<in> set (interp_ins ops)", "hence \"ops = (as @ [(oid, None)]) @ bs\""], ["proof (prove)\nusing this:\n  ops = as @ (oid, None) # bs\n\ngoal (1 subgoal):\n 1. ops = (as @ [(oid, None)]) @ bs", "by (simp add: \\<open>ops = as @ (oid, None) # bs\\<close>)"], ["proof (state)\nthis:\n  ops = (as @ [(oid, None)]) @ bs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops);\n     xs = []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                         i \\<in> set (interp_ins ops)\n 2. \\<lbrakk>\\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops);\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                         i \\<in> set (interp_ins ops)", "moreover"], ["proof (state)\nthis:\n  ops = (as @ [(oid, None)]) @ bs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops);\n     xs = []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                         i \\<in> set (interp_ins ops)\n 2. \\<lbrakk>\\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops);\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                         i \\<in> set (interp_ins ops)", "have \"oid \\<in> set (interp_ins (as @ [(oid, None)]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oid \\<in> set (interp_ins (as @ [(oid, None)]))", "by (simp add: interp_ins_last_None)"], ["proof (state)\nthis:\n  oid \\<in> set (interp_ins (as @ [(oid, None)]))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops);\n     xs = []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                         i \\<in> set (interp_ins ops)\n 2. \\<lbrakk>\\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops);\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                         i \\<in> set (interp_ins ops)", "ultimately"], ["proof (chain)\npicking this:\n  ops = (as @ [(oid, None)]) @ bs\n  oid \\<in> set (interp_ins (as @ [(oid, None)]))", "have \"oid \\<in> set (interp_ins ops)\""], ["proof (prove)\nusing this:\n  ops = (as @ [(oid, None)]) @ bs\n  oid \\<in> set (interp_ins (as @ [(oid, None)]))\n\ngoal (1 subgoal):\n 1. oid \\<in> set (interp_ins ops)", "using interp_ins_monotonic snoc.prems(1)"], ["proof (prove)\nusing this:\n  ops = (as @ [(oid, None)]) @ bs\n  oid \\<in> set (interp_ins (as @ [(oid, None)]))\n  \\<lbrakk>insert_ops (?pre @ ?suf);\n   ?oid \\<in> set (interp_ins ?pre)\\<rbrakk>\n  \\<Longrightarrow> ?oid \\<in> set (interp_ins (?pre @ ?suf))\n  insert_ops ops\n\ngoal (1 subgoal):\n 1. oid \\<in> set (interp_ins ops)", "by blast"], ["proof (state)\nthis:\n  oid \\<in> set (interp_ins ops)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops);\n     xs = []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                         i \\<in> set (interp_ins ops)\n 2. \\<lbrakk>\\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops);\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                         i \\<in> set (interp_ins ops)", "then"], ["proof (chain)\npicking this:\n  oid \\<in> set (interp_ins ops)", "show \"\\<forall>i \\<in> set (map fst (xs @ [x])). i \\<in> set (interp_ins ops)\""], ["proof (prove)\nusing this:\n  oid \\<in> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst (xs @ [x])). i \\<in> set (interp_ins ops)", "using \\<open>xs @ [x] = [(oid, None)]\\<close>"], ["proof (prove)\nusing this:\n  oid \\<in> set (interp_ins ops)\n  xs @ [x] = [(oid, None)]\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst (xs @ [x])). i \\<in> set (interp_ins ops)", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<in>set (map fst (xs @ [x])). i \\<in> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops);\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                         i \\<in> set (interp_ins ops)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops);\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                         i \\<in> set (interp_ins ops)", "case False"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops);\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                         i \\<in> set (interp_ins ops)", "then"], ["proof (chain)\npicking this:\n  xs \\<noteq> []", "obtain rest y where snoc_y: \"xs = rest @ [y]\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>rest y.\n        xs = rest @ [y] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using append_butlast_last_id"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  ?xs \\<noteq> [] \\<Longrightarrow> butlast ?xs @ [last ?xs] = ?xs\n\ngoal (1 subgoal):\n 1. (\\<And>rest y.\n        xs = rest @ [y] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  xs = rest @ [y]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops);\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                         i \\<in> set (interp_ins ops)", "obtain yi yr xi xr where yx_pairs: \"y = (yi, yr) \\<and> x = (xi, xr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>yi yr xi xr.\n        y = (yi, yr) \\<and> x = (xi, xr) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  y = (yi, yr) \\<and> x = (xi, xr)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops);\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                         i \\<in> set (interp_ins ops)", "then"], ["proof (chain)\npicking this:\n  y = (yi, yr) \\<and> x = (xi, xr)", "have \"xr = Some yi\""], ["proof (prove)\nusing this:\n  y = (yi, yr) \\<and> x = (xi, xr)\n\ngoal (1 subgoal):\n 1. xr = Some yi", "using insert_seq_last_ref snoc.prems(2) snoc_y"], ["proof (prove)\nusing this:\n  y = (yi, yr) \\<and> x = (xi, xr)\n  insert_seq ?start (?xs @ [(?xi, ?xr), (?yi, ?yr)]) \\<Longrightarrow>\n  ?yr = Some ?xi\n  insert_seq None (xs @ [x])\n  xs = rest @ [y]\n\ngoal (1 subgoal):\n 1. xr = Some yi", "by fastforce"], ["proof (state)\nthis:\n  xr = Some yi\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops);\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                         i \\<in> set (interp_ins ops)", "have \"yi < xi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. yi < xi", "using insert_ops_sorted_oids snoc_y yx_pairs snoc.prems(3)"], ["proof (prove)\nusing this:\n  insert_ops\n   (?xs @ [(?i1.0, ?r1.0)] @ ?ys @ [(?i2.0, ?r2.0)]) \\<Longrightarrow>\n  ?i1.0 < ?i2.0\n  xs = rest @ [y]\n  y = (yi, yr) \\<and> x = (xi, xr)\n  insert_ops (xs @ [x])\n\ngoal (1 subgoal):\n 1. yi < xi", "by (metis (no_types, lifting) append_eq_append_conv2)"], ["proof (state)\nthis:\n  yi < xi\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops);\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                         i \\<in> set (interp_ins ops)", "have \"(yi, yr) \\<in> set ops\" and \"(xi, Some yi) \\<in> set ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (yi, yr) \\<in> set ops &&& (xi, Some yi) \\<in> set ops", "using snoc.prems(4) snoc_y yx_pairs \\<open>xr = Some yi\\<close>"], ["proof (prove)\nusing this:\n  set (xs @ [x]) \\<subseteq> set ops\n  xs = rest @ [y]\n  y = (yi, yr) \\<and> x = (xi, xr)\n  xr = Some yi\n\ngoal (1 subgoal):\n 1. (yi, yr) \\<in> set ops &&& (xi, Some yi) \\<in> set ops", "by auto"], ["proof (state)\nthis:\n  (yi, yr) \\<in> set ops\n  (xi, Some yi) \\<in> set ops\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops);\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                         i \\<in> set (interp_ins ops)", "then"], ["proof (chain)\npicking this:\n  (yi, yr) \\<in> set ops\n  (xi, Some yi) \\<in> set ops", "obtain as bs cs where ops_split: \"ops = as @ [(yi, yr)] @ bs @ [(xi, Some yi)] @ cs\""], ["proof (prove)\nusing this:\n  (yi, yr) \\<in> set ops\n  (xi, Some yi) \\<in> set ops\n\ngoal (1 subgoal):\n 1. (\\<And>as bs cs.\n        ops = as @ [(yi, yr)] @ bs @ [(xi, Some yi)] @ cs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using insert_ops_split_2 \\<open>yi < xi\\<close> snoc.prems(1)"], ["proof (prove)\nusing this:\n  (yi, yr) \\<in> set ops\n  (xi, Some yi) \\<in> set ops\n  \\<lbrakk>insert_ops ?ops; (?xid, ?xr) \\<in> set ?ops;\n   (?yid, ?yr) \\<in> set ?ops; ?xid < ?yid\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as bs cs.\n                       ?ops =\n                       as @ [(?xid, ?xr)] @ bs @ [(?yid, ?yr)] @ cs \\<and>\n                       (\\<forall>i\\<in>set (map fst as). i < ?xid) \\<and>\n                       (\\<forall>i\\<in>set (map fst bs).\n                           ?xid < i \\<and> i < ?yid) \\<and>\n                       (\\<forall>i\\<in>set (map fst cs). ?yid < i)\n  yi < xi\n  insert_ops ops\n\ngoal (1 subgoal):\n 1. (\\<And>as bs cs.\n        ops = as @ [(yi, yr)] @ bs @ [(xi, Some yi)] @ cs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ops = as @ [(yi, yr)] @ bs @ [(xi, Some yi)] @ cs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops);\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                         i \\<in> set (interp_ins ops)", "hence \"yi \\<in> set (interp_ins (as @ [(yi, yr)] @ bs))\""], ["proof (prove)\nusing this:\n  ops = as @ [(yi, yr)] @ bs @ [(xi, Some yi)] @ cs\n\ngoal (1 subgoal):\n 1. yi \\<in> set (interp_ins (as @ [(yi, yr)] @ bs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ops = as @ [(yi, yr)] @ bs @ [(xi, Some yi)] @ cs \\<Longrightarrow>\n    yi \\<in> set (interp_ins (as @ [(yi, yr)] @ bs))", "have \"yi \\<in> set (interp_ins ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. yi \\<in> set (interp_ins ops)", "by (simp add: IH snoc_y yx_pairs)"], ["proof (state)\nthis:\n  yi \\<in> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. ops = as @ [(yi, yr)] @ bs @ [(xi, Some yi)] @ cs \\<Longrightarrow>\n    yi \\<in> set (interp_ins (as @ [(yi, yr)] @ bs))", "moreover"], ["proof (state)\nthis:\n  yi \\<in> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. ops = as @ [(yi, yr)] @ bs @ [(xi, Some yi)] @ cs \\<Longrightarrow>\n    yi \\<in> set (interp_ins (as @ [(yi, yr)] @ bs))", "have \"ops = (as @ [(yi, yr)] @ bs) @ ([(xi, Some yi)] @ cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ops = (as @ [(yi, yr)] @ bs) @ [(xi, Some yi)] @ cs", "using ops_split"], ["proof (prove)\nusing this:\n  ops = as @ [(yi, yr)] @ bs @ [(xi, Some yi)] @ cs\n\ngoal (1 subgoal):\n 1. ops = (as @ [(yi, yr)] @ bs) @ [(xi, Some yi)] @ cs", "by simp"], ["proof (state)\nthis:\n  ops = (as @ [(yi, yr)] @ bs) @ [(xi, Some yi)] @ cs\n\ngoal (1 subgoal):\n 1. ops = as @ [(yi, yr)] @ bs @ [(xi, Some yi)] @ cs \\<Longrightarrow>\n    yi \\<in> set (interp_ins (as @ [(yi, yr)] @ bs))", "moreover"], ["proof (state)\nthis:\n  ops = (as @ [(yi, yr)] @ bs) @ [(xi, Some yi)] @ cs\n\ngoal (1 subgoal):\n 1. ops = as @ [(yi, yr)] @ bs @ [(xi, Some yi)] @ cs \\<Longrightarrow>\n    yi \\<in> set (interp_ins (as @ [(yi, yr)] @ bs))", "have \"yi \\<in> set (map fst (as @ [(yi, yr)] @ bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. yi \\<in> set (map fst (as @ [(yi, yr)] @ bs))", "by simp"], ["proof (state)\nthis:\n  yi \\<in> set (map fst (as @ [(yi, yr)] @ bs))\n\ngoal (1 subgoal):\n 1. ops = as @ [(yi, yr)] @ bs @ [(xi, Some yi)] @ cs \\<Longrightarrow>\n    yi \\<in> set (interp_ins (as @ [(yi, yr)] @ bs))", "ultimately"], ["proof (chain)\npicking this:\n  yi \\<in> set (interp_ins ops)\n  ops = (as @ [(yi, yr)] @ bs) @ [(xi, Some yi)] @ cs\n  yi \\<in> set (map fst (as @ [(yi, yr)] @ bs))", "show ?thesis"], ["proof (prove)\nusing this:\n  yi \\<in> set (interp_ins ops)\n  ops = (as @ [(yi, yr)] @ bs) @ [(xi, Some yi)] @ cs\n  yi \\<in> set (map fst (as @ [(yi, yr)] @ bs))\n\ngoal (1 subgoal):\n 1. yi \\<in> set (interp_ins (as @ [(yi, yr)] @ bs))", "using snoc.prems(1) interp_ins_append_forward"], ["proof (prove)\nusing this:\n  yi \\<in> set (interp_ins ops)\n  ops = (as @ [(yi, yr)] @ bs) @ [(xi, Some yi)] @ cs\n  yi \\<in> set (map fst (as @ [(yi, yr)] @ bs))\n  insert_ops ops\n  \\<lbrakk>insert_ops (?xs @ ?ys); ?oid \\<in> set (interp_ins (?xs @ ?ys));\n   ?oid \\<in> set (map fst ?xs)\\<rbrakk>\n  \\<Longrightarrow> ?oid \\<in> set (interp_ins ?xs)\n\ngoal (1 subgoal):\n 1. yi \\<in> set (interp_ins (as @ [(yi, yr)] @ bs))", "by blast"], ["proof (state)\nthis:\n  yi \\<in> set (interp_ins (as @ [(yi, yr)] @ bs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  yi \\<in> set (interp_ins (as @ [(yi, yr)] @ bs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops);\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                         i \\<in> set (interp_ins ops)", "hence \"xi \\<in> set (interp_ins ((as @ [(yi, yr)] @ bs) @ [(xi, Some yi)] @ cs))\""], ["proof (prove)\nusing this:\n  yi \\<in> set (interp_ins (as @ [(yi, yr)] @ bs))\n\ngoal (1 subgoal):\n 1. xi \\<in> set (interp_ins\n                   ((as @ [(yi, yr)] @ bs) @ [(xi, Some yi)] @ cs))", "using snoc.prems(1) interp_ins_append_memb ops_split"], ["proof (prove)\nusing this:\n  yi \\<in> set (interp_ins (as @ [(yi, yr)] @ bs))\n  insert_ops ops\n  \\<lbrakk>insert_ops (?pre @ [(?oid, Some ?ref)] @ ?suf);\n   ?ref \\<in> set (interp_ins ?pre)\\<rbrakk>\n  \\<Longrightarrow> ?oid\n                    \\<in> set (interp_ins\n                                (?pre @ [(?oid, Some ?ref)] @ ?suf))\n  ops = as @ [(yi, yr)] @ bs @ [(xi, Some yi)] @ cs\n\ngoal (1 subgoal):\n 1. xi \\<in> set (interp_ins\n                   ((as @ [(yi, yr)] @ bs) @ [(xi, Some yi)] @ cs))", "by force"], ["proof (state)\nthis:\n  xi \\<in> set (interp_ins ((as @ [(yi, yr)] @ bs) @ [(xi, Some yi)] @ cs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops);\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                         i \\<in> set (interp_ins ops)", "hence \"xi \\<in> set (interp_ins ops)\""], ["proof (prove)\nusing this:\n  xi \\<in> set (interp_ins ((as @ [(yi, yr)] @ bs) @ [(xi, Some yi)] @ cs))\n\ngoal (1 subgoal):\n 1. xi \\<in> set (interp_ins ops)", "by (simp add: ops_split)"], ["proof (state)\nthis:\n  xi \\<in> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops);\n     xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                         i \\<in> set (interp_ins ops)", "then"], ["proof (chain)\npicking this:\n  xi \\<in> set (interp_ins ops)", "show \"\\<forall>i \\<in> set (map fst (xs @ [x])). i \\<in> set (interp_ins ops)\""], ["proof (prove)\nusing this:\n  xi \\<in> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst (xs @ [x])). i \\<in> set (interp_ins ops)", "using IH yx_pairs"], ["proof (prove)\nusing this:\n  xi \\<in> set (interp_ins ops)\n  \\<forall>i\\<in>set (map fst xs). i \\<in> set (interp_ins ops)\n  y = (yi, yr) \\<and> x = (xi, xr)\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst (xs @ [x])). i \\<in> set (interp_ins ops)", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<in>set (map fst (xs @ [x])). i \\<in> set (interp_ins ops)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i\\<in>set (map fst (xs @ [x])). i \\<in> set (interp_ins ops)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_seq_after_start:\n  assumes \"insert_ops ops\"\n    and \"insert_seq (Some ref) xs\" and \"insert_ops xs\"\n    and \"set xs \\<subseteq> set ops\"\n    and \"ref \\<in> set (interp_ins ops)\"\n  shows \"\\<forall>i \\<in> set (map fst xs). list_order ops ref i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst xs). list_order ops ref i", "using assms"], ["proof (prove)\nusing this:\n  insert_ops ops\n  insert_seq (Some ref) xs\n  insert_ops xs\n  set xs \\<subseteq> set ops\n  ref \\<in> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst xs). list_order ops ref i", "proof(induction xs rule: List.rev_induct, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops ops; insert_seq (Some ref) xs;\n                 insert_ops xs; set xs \\<subseteq> set ops;\n                 ref \\<in> set (interp_ins ops)\\<rbrakk>\n                \\<Longrightarrow> Ball (set (map fst xs))\n                                   (list_order ops ref);\n        insert_ops ops; insert_seq (Some ref) (xs @ [x]);\n        insert_ops (xs @ [x]); set (xs @ [x]) \\<subseteq> set ops;\n        ref \\<in> set (interp_ins ops)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (map fst (xs @ [x])))\n                          (list_order ops ref)", "case (snoc x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>insert_ops ops; insert_seq (Some ref) xs; insert_ops xs;\n   set xs \\<subseteq> set ops; ref \\<in> set (interp_ins ops)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>a\\<in>set (map fst xs). list_order ops ref a\n  insert_ops ops\n  insert_seq (Some ref) (xs @ [x])\n  insert_ops (xs @ [x])\n  set (xs @ [x]) \\<subseteq> set ops\n  ref \\<in> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops ops; insert_seq (Some ref) xs;\n                 insert_ops xs; set xs \\<subseteq> set ops;\n                 ref \\<in> set (interp_ins ops)\\<rbrakk>\n                \\<Longrightarrow> Ball (set (map fst xs))\n                                   (list_order ops ref);\n        insert_ops ops; insert_seq (Some ref) (xs @ [x]);\n        insert_ops (xs @ [x]); set (xs @ [x]) \\<subseteq> set ops;\n        ref \\<in> set (interp_ins ops)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (map fst (xs @ [x])))\n                          (list_order ops ref)", "have IH: \"\\<forall>i \\<in> set (map fst xs). list_order ops ref i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst xs). list_order ops ref i", "using snoc.IH snoc.prems insert_seq_rem_last insert_ops_appendD"], ["proof (prove)\nusing this:\n  \\<lbrakk>insert_ops ops; insert_seq (Some ref) xs; insert_ops xs;\n   set xs \\<subseteq> set ops; ref \\<in> set (interp_ins ops)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>a\\<in>set (map fst xs). list_order ops ref a\n  insert_ops ops\n  insert_seq (Some ref) (xs @ [x])\n  insert_ops (xs @ [x])\n  set (xs @ [x]) \\<subseteq> set ops\n  ref \\<in> set (interp_ins ops)\n  \\<lbrakk>insert_seq ?start (?xs @ [?x]); ?xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> insert_seq ?start ?xs\n  insert_ops (?xs @ ?ys) \\<Longrightarrow> insert_ops ?xs\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst xs). list_order ops ref i", "by (metis Nil_is_map_conv Un_subset_iff empty_set equals0D set_append)"], ["proof (state)\nthis:\n  \\<forall>i\\<in>set (map fst xs). list_order ops ref i\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops ops; insert_seq (Some ref) xs;\n                 insert_ops xs; set xs \\<subseteq> set ops;\n                 ref \\<in> set (interp_ins ops)\\<rbrakk>\n                \\<Longrightarrow> Ball (set (map fst xs))\n                                   (list_order ops ref);\n        insert_ops ops; insert_seq (Some ref) (xs @ [x]);\n        insert_ops (xs @ [x]); set (xs @ [x]) \\<subseteq> set ops;\n        ref \\<in> set (interp_ins ops)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (map fst (xs @ [x])))\n                          (list_order ops ref)", "moreover"], ["proof (state)\nthis:\n  \\<forall>i\\<in>set (map fst xs). list_order ops ref i\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops ops; insert_seq (Some ref) xs;\n                 insert_ops xs; set xs \\<subseteq> set ops;\n                 ref \\<in> set (interp_ins ops)\\<rbrakk>\n                \\<Longrightarrow> Ball (set (map fst xs))\n                                   (list_order ops ref);\n        insert_ops ops; insert_seq (Some ref) (xs @ [x]);\n        insert_ops (xs @ [x]); set (xs @ [x]) \\<subseteq> set ops;\n        ref \\<in> set (interp_ins ops)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (map fst (xs @ [x])))\n                          (list_order ops ref)", "have \"list_order ops ref (fst x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_order ops ref (fst x)", "proof(cases \"xs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> list_order ops ref (fst x)\n 2. xs \\<noteq> [] \\<Longrightarrow> list_order ops ref (fst x)", "case True"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> list_order ops ref (fst x)\n 2. xs \\<noteq> [] \\<Longrightarrow> list_order ops ref (fst x)", "hence \"snd x = Some ref\""], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. snd x = Some ref", "using insert_seq_hd snoc.prems(2)"], ["proof (prove)\nusing this:\n  xs = []\n  insert_seq ?start ?xs \\<Longrightarrow>\n  \\<exists>oid. hd ?xs = (oid, ?start)\n  insert_seq (Some ref) (xs @ [x])\n\ngoal (1 subgoal):\n 1. snd x = Some ref", "by fastforce"], ["proof (state)\nthis:\n  snd x = Some ref\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> list_order ops ref (fst x)\n 2. xs \\<noteq> [] \\<Longrightarrow> list_order ops ref (fst x)", "moreover"], ["proof (state)\nthis:\n  snd x = Some ref\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> list_order ops ref (fst x)\n 2. xs \\<noteq> [] \\<Longrightarrow> list_order ops ref (fst x)", "have \"x \\<in> set ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set ops", "using snoc.prems(4)"], ["proof (prove)\nusing this:\n  set (xs @ [x]) \\<subseteq> set ops\n\ngoal (1 subgoal):\n 1. x \\<in> set ops", "by auto"], ["proof (state)\nthis:\n  x \\<in> set ops\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> list_order ops ref (fst x)\n 2. xs \\<noteq> [] \\<Longrightarrow> list_order ops ref (fst x)", "then"], ["proof (chain)\npicking this:\n  x \\<in> set ops", "obtain cs ds where x_split: \"ops = cs @ x # ds\""], ["proof (prove)\nusing this:\n  x \\<in> set ops\n\ngoal (1 subgoal):\n 1. (\\<And>cs ds.\n        ops = cs @ x # ds \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson split_list)"], ["proof (state)\nthis:\n  ops = cs @ x # ds\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> list_order ops ref (fst x)\n 2. xs \\<noteq> [] \\<Longrightarrow> list_order ops ref (fst x)", "have \"list_order (cs @ [(fst x, Some ref)]) ref (fst x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_order (cs @ [(fst x, Some ref)]) ref (fst x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_order (cs @ [(fst x, Some ref)]) ref (fst x)", "have \"insert_ops (cs @ [(fst x, Some ref)] @ ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_ops (cs @ [(fst x, Some ref)] @ ds)", "using x_split \\<open>snd x = Some ref\\<close>"], ["proof (prove)\nusing this:\n  ops = cs @ x # ds\n  snd x = Some ref\n\ngoal (1 subgoal):\n 1. insert_ops (cs @ [(fst x, Some ref)] @ ds)", "by (metis append_Cons append_self_conv2 prod.collapse snoc.prems(1))"], ["proof (state)\nthis:\n  insert_ops (cs @ [(fst x, Some ref)] @ ds)\n\ngoal (1 subgoal):\n 1. list_order (cs @ [(fst x, Some ref)]) ref (fst x)", "moreover"], ["proof (state)\nthis:\n  insert_ops (cs @ [(fst x, Some ref)] @ ds)\n\ngoal (1 subgoal):\n 1. list_order (cs @ [(fst x, Some ref)]) ref (fst x)", "from this"], ["proof (chain)\npicking this:\n  insert_ops (cs @ [(fst x, Some ref)] @ ds)", "obtain rr where \"(ref, rr) \\<in> set cs\""], ["proof (prove)\nusing this:\n  insert_ops (cs @ [(fst x, Some ref)] @ ds)\n\ngoal (1 subgoal):\n 1. (\\<And>rr.\n        (ref, rr) \\<in> set cs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using interp_ins_find_ref x_split \\<open>snd x = Some ref\\<close> assms(5)"], ["proof (prove)\nusing this:\n  insert_ops (cs @ [(fst x, Some ref)] @ ds)\n  \\<lbrakk>insert_ops (?xs @ [(?oid, Some ?ref)] @ ?ys);\n   ?ref \\<in> set (interp_ins (?xs @ [(?oid, Some ?ref)] @ ?ys))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>r. (?ref, r) \\<in> set ?xs\n  ops = cs @ x # ds\n  snd x = Some ref\n  ref \\<in> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. (\\<And>rr.\n        (ref, rr) \\<in> set cs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, lifting) append_Cons append_self_conv2 prod.collapse)"], ["proof (state)\nthis:\n  (ref, rr) \\<in> set cs\n\ngoal (1 subgoal):\n 1. list_order (cs @ [(fst x, Some ref)]) ref (fst x)", "hence \"ref \\<in> set (interp_ins cs)\""], ["proof (prove)\nusing this:\n  (ref, rr) \\<in> set cs\n\ngoal (1 subgoal):\n 1. ref \\<in> set (interp_ins cs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (ref, rr) \\<in> set cs \\<Longrightarrow> ref \\<in> set (interp_ins cs)", "have \"ops = cs @ ([(fst x, Some ref)] @ ds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ops = cs @ [(fst x, Some ref)] @ ds", "by (metis x_split \\<open>snd x = Some ref\\<close> append_Cons append_self_conv2 prod.collapse)"], ["proof (state)\nthis:\n  ops = cs @ [(fst x, Some ref)] @ ds\n\ngoal (1 subgoal):\n 1. (ref, rr) \\<in> set cs \\<Longrightarrow> ref \\<in> set (interp_ins cs)", "thus \"ref \\<in> set (interp_ins cs)\""], ["proof (prove)\nusing this:\n  ops = cs @ [(fst x, Some ref)] @ ds\n\ngoal (1 subgoal):\n 1. ref \\<in> set (interp_ins cs)", "using assms(5) calculation interp_ins_append_forward interp_ins_append_non_memb"], ["proof (prove)\nusing this:\n  ops = cs @ [(fst x, Some ref)] @ ds\n  ref \\<in> set (interp_ins ops)\n  insert_ops (cs @ [(fst x, Some ref)] @ ds)\n  \\<lbrakk>insert_ops (?xs @ ?ys); ?oid \\<in> set (interp_ins (?xs @ ?ys));\n   ?oid \\<in> set (map fst ?xs)\\<rbrakk>\n  \\<Longrightarrow> ?oid \\<in> set (interp_ins ?xs)\n  \\<lbrakk>insert_ops (?pre @ [(?oid, Some ?ref)] @ ?suf);\n   ?ref \\<notin> set (interp_ins ?pre)\\<rbrakk>\n  \\<Longrightarrow> ?ref\n                    \\<notin> set (interp_ins\n                                   (?pre @ [(?oid, Some ?ref)] @ ?suf))\n\ngoal (1 subgoal):\n 1. ref \\<in> set (interp_ins cs)", "by blast"], ["proof (state)\nthis:\n  ref \\<in> set (interp_ins cs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ref \\<in> set (interp_ins cs)\n\ngoal (1 subgoal):\n 1. list_order (cs @ [(fst x, Some ref)]) ref (fst x)", "ultimately"], ["proof (chain)\npicking this:\n  insert_ops (cs @ [(fst x, Some ref)] @ ds)\n  ref \\<in> set (interp_ins cs)", "show \"list_order (cs @ [(fst x, Some ref)]) ref (fst x)\""], ["proof (prove)\nusing this:\n  insert_ops (cs @ [(fst x, Some ref)] @ ds)\n  ref \\<in> set (interp_ins cs)\n\ngoal (1 subgoal):\n 1. list_order (cs @ [(fst x, Some ref)]) ref (fst x)", "using list_order_insert_ref"], ["proof (prove)\nusing this:\n  insert_ops (cs @ [(fst x, Some ref)] @ ds)\n  ref \\<in> set (interp_ins cs)\n  \\<lbrakk>insert_ops (?ops @ [(?oid, Some ?ref)]);\n   ?ref \\<in> set (interp_ins ?ops)\\<rbrakk>\n  \\<Longrightarrow> list_order (?ops @ [(?oid, Some ?ref)]) ?ref ?oid\n\ngoal (1 subgoal):\n 1. list_order (cs @ [(fst x, Some ref)]) ref (fst x)", "by (metis append.assoc insert_ops_appendD)"], ["proof (state)\nthis:\n  list_order (cs @ [(fst x, Some ref)]) ref (fst x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_order (cs @ [(fst x, Some ref)]) ref (fst x)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> list_order ops ref (fst x)\n 2. xs \\<noteq> [] \\<Longrightarrow> list_order ops ref (fst x)", "moreover"], ["proof (state)\nthis:\n  list_order (cs @ [(fst x, Some ref)]) ref (fst x)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> list_order ops ref (fst x)\n 2. xs \\<noteq> [] \\<Longrightarrow> list_order ops ref (fst x)", "have \"ops = (cs @ [(fst x, Some ref)]) @ ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ops = (cs @ [(fst x, Some ref)]) @ ds", "using calculation x_split"], ["proof (prove)\nusing this:\n  snd x = Some ref\n  list_order (cs @ [(fst x, Some ref)]) ref (fst x)\n  ops = cs @ x # ds\n\ngoal (1 subgoal):\n 1. ops = (cs @ [(fst x, Some ref)]) @ ds", "by (metis append_eq_Cons_conv append_eq_append_conv2 append_self_conv2 prod.collapse)"], ["proof (state)\nthis:\n  ops = (cs @ [(fst x, Some ref)]) @ ds\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> list_order ops ref (fst x)\n 2. xs \\<noteq> [] \\<Longrightarrow> list_order ops ref (fst x)", "ultimately"], ["proof (chain)\npicking this:\n  snd x = Some ref\n  list_order (cs @ [(fst x, Some ref)]) ref (fst x)\n  ops = (cs @ [(fst x, Some ref)]) @ ds", "show \"list_order ops ref (fst x)\""], ["proof (prove)\nusing this:\n  snd x = Some ref\n  list_order (cs @ [(fst x, Some ref)]) ref (fst x)\n  ops = (cs @ [(fst x, Some ref)]) @ ds\n\ngoal (1 subgoal):\n 1. list_order ops ref (fst x)", "using list_order_append snoc.prems(1)"], ["proof (prove)\nusing this:\n  snd x = Some ref\n  list_order (cs @ [(fst x, Some ref)]) ref (fst x)\n  ops = (cs @ [(fst x, Some ref)]) @ ds\n  \\<lbrakk>insert_ops (?pre @ ?suf); list_order ?pre ?x ?y\\<rbrakk>\n  \\<Longrightarrow> list_order (?pre @ ?suf) ?x ?y\n  insert_ops ops\n\ngoal (1 subgoal):\n 1. list_order ops ref (fst x)", "by blast"], ["proof (state)\nthis:\n  list_order ops ref (fst x)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> list_order ops ref (fst x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> list_order ops ref (fst x)", "case False"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> list_order ops ref (fst x)", "then"], ["proof (chain)\npicking this:\n  xs \\<noteq> []", "obtain rest y where snoc_y: \"xs = rest @ [y]\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>rest y.\n        xs = rest @ [y] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using append_butlast_last_id"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  ?xs \\<noteq> [] \\<Longrightarrow> butlast ?xs @ [last ?xs] = ?xs\n\ngoal (1 subgoal):\n 1. (\\<And>rest y.\n        xs = rest @ [y] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  xs = rest @ [y]\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> list_order ops ref (fst x)", "obtain yi yr xi xr where yx_pairs: \"y = (yi, yr) \\<and> x = (xi, xr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>yi yr xi xr.\n        y = (yi, yr) \\<and> x = (xi, xr) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  y = (yi, yr) \\<and> x = (xi, xr)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> list_order ops ref (fst x)", "then"], ["proof (chain)\npicking this:\n  y = (yi, yr) \\<and> x = (xi, xr)", "have \"xr = Some yi\""], ["proof (prove)\nusing this:\n  y = (yi, yr) \\<and> x = (xi, xr)\n\ngoal (1 subgoal):\n 1. xr = Some yi", "using insert_seq_last_ref snoc.prems(2) snoc_y"], ["proof (prove)\nusing this:\n  y = (yi, yr) \\<and> x = (xi, xr)\n  insert_seq ?start (?xs @ [(?xi, ?xr), (?yi, ?yr)]) \\<Longrightarrow>\n  ?yr = Some ?xi\n  insert_seq (Some ref) (xs @ [x])\n  xs = rest @ [y]\n\ngoal (1 subgoal):\n 1. xr = Some yi", "by fastforce"], ["proof (state)\nthis:\n  xr = Some yi\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> list_order ops ref (fst x)", "have \"yi < xi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. yi < xi", "using insert_ops_sorted_oids snoc_y yx_pairs snoc.prems(3)"], ["proof (prove)\nusing this:\n  insert_ops\n   (?xs @ [(?i1.0, ?r1.0)] @ ?ys @ [(?i2.0, ?r2.0)]) \\<Longrightarrow>\n  ?i1.0 < ?i2.0\n  xs = rest @ [y]\n  y = (yi, yr) \\<and> x = (xi, xr)\n  insert_ops (xs @ [x])\n\ngoal (1 subgoal):\n 1. yi < xi", "by (metis (no_types, lifting) append_eq_append_conv2)"], ["proof (state)\nthis:\n  yi < xi\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> list_order ops ref (fst x)", "have \"(yi, yr) \\<in> set ops\" and \"(xi, Some yi) \\<in> set ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (yi, yr) \\<in> set ops &&& (xi, Some yi) \\<in> set ops", "using snoc.prems(4) snoc_y yx_pairs \\<open>xr = Some yi\\<close>"], ["proof (prove)\nusing this:\n  set (xs @ [x]) \\<subseteq> set ops\n  xs = rest @ [y]\n  y = (yi, yr) \\<and> x = (xi, xr)\n  xr = Some yi\n\ngoal (1 subgoal):\n 1. (yi, yr) \\<in> set ops &&& (xi, Some yi) \\<in> set ops", "by auto"], ["proof (state)\nthis:\n  (yi, yr) \\<in> set ops\n  (xi, Some yi) \\<in> set ops\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> list_order ops ref (fst x)", "then"], ["proof (chain)\npicking this:\n  (yi, yr) \\<in> set ops\n  (xi, Some yi) \\<in> set ops", "obtain as bs cs where ops_split: \"ops = as @ [(yi, yr)] @ bs @ [(xi, Some yi)] @ cs\""], ["proof (prove)\nusing this:\n  (yi, yr) \\<in> set ops\n  (xi, Some yi) \\<in> set ops\n\ngoal (1 subgoal):\n 1. (\\<And>as bs cs.\n        ops = as @ [(yi, yr)] @ bs @ [(xi, Some yi)] @ cs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using insert_ops_split_2 \\<open>yi < xi\\<close> snoc.prems(1)"], ["proof (prove)\nusing this:\n  (yi, yr) \\<in> set ops\n  (xi, Some yi) \\<in> set ops\n  \\<lbrakk>insert_ops ?ops; (?xid, ?xr) \\<in> set ?ops;\n   (?yid, ?yr) \\<in> set ?ops; ?xid < ?yid\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as bs cs.\n                       ?ops =\n                       as @ [(?xid, ?xr)] @ bs @ [(?yid, ?yr)] @ cs \\<and>\n                       (\\<forall>i\\<in>set (map fst as). i < ?xid) \\<and>\n                       (\\<forall>i\\<in>set (map fst bs).\n                           ?xid < i \\<and> i < ?yid) \\<and>\n                       (\\<forall>i\\<in>set (map fst cs). ?yid < i)\n  yi < xi\n  insert_ops ops\n\ngoal (1 subgoal):\n 1. (\\<And>as bs cs.\n        ops = as @ [(yi, yr)] @ bs @ [(xi, Some yi)] @ cs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ops = as @ [(yi, yr)] @ bs @ [(xi, Some yi)] @ cs\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> list_order ops ref (fst x)", "have \"list_order ops ref yi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_order ops ref yi", "by (simp add: IH snoc_y yx_pairs)"], ["proof (state)\nthis:\n  list_order ops ref yi\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> list_order ops ref (fst x)", "moreover"], ["proof (state)\nthis:\n  list_order ops ref yi\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> list_order ops ref (fst x)", "have \"list_order (as @ [(yi, yr)] @ bs @ [(xi, Some yi)]) yi xi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_order (as @ [(yi, yr)] @ bs @ [(xi, Some yi)]) yi xi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_order (as @ [(yi, yr)] @ bs @ [(xi, Some yi)]) yi xi", "have \"insert_ops ((as @ [(yi, yr)] @ bs @ [(xi, Some yi)]) @ cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_ops ((as @ [(yi, yr)] @ bs @ [(xi, Some yi)]) @ cs)", "using ops_split snoc.prems(1)"], ["proof (prove)\nusing this:\n  ops = as @ [(yi, yr)] @ bs @ [(xi, Some yi)] @ cs\n  insert_ops ops\n\ngoal (1 subgoal):\n 1. insert_ops ((as @ [(yi, yr)] @ bs @ [(xi, Some yi)]) @ cs)", "by auto"], ["proof (state)\nthis:\n  insert_ops ((as @ [(yi, yr)] @ bs @ [(xi, Some yi)]) @ cs)\n\ngoal (1 subgoal):\n 1. list_order (as @ [(yi, yr)] @ bs @ [(xi, Some yi)]) yi xi", "hence \"insert_ops ((as @ [(yi, yr)] @ bs) @ [(xi, Some yi)])\""], ["proof (prove)\nusing this:\n  insert_ops ((as @ [(yi, yr)] @ bs @ [(xi, Some yi)]) @ cs)\n\ngoal (1 subgoal):\n 1. insert_ops ((as @ [(yi, yr)] @ bs) @ [(xi, Some yi)])", "using insert_ops_appendD"], ["proof (prove)\nusing this:\n  insert_ops ((as @ [(yi, yr)] @ bs @ [(xi, Some yi)]) @ cs)\n  insert_ops (?xs @ ?ys) \\<Longrightarrow> insert_ops ?xs\n\ngoal (1 subgoal):\n 1. insert_ops ((as @ [(yi, yr)] @ bs) @ [(xi, Some yi)])", "by fastforce"], ["proof (state)\nthis:\n  insert_ops ((as @ [(yi, yr)] @ bs) @ [(xi, Some yi)])\n\ngoal (1 subgoal):\n 1. list_order (as @ [(yi, yr)] @ bs @ [(xi, Some yi)]) yi xi", "moreover"], ["proof (state)\nthis:\n  insert_ops ((as @ [(yi, yr)] @ bs) @ [(xi, Some yi)])\n\ngoal (1 subgoal):\n 1. list_order (as @ [(yi, yr)] @ bs @ [(xi, Some yi)]) yi xi", "have \"yi \\<in> set (interp_ins ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. yi \\<in> set (interp_ins ops)", "using \\<open>list_order ops ref yi\\<close> list_order_memb2"], ["proof (prove)\nusing this:\n  list_order ops ref yi\n  list_order ?ops ?x ?y \\<Longrightarrow> ?y \\<in> set (interp_ins ?ops)\n\ngoal (1 subgoal):\n 1. yi \\<in> set (interp_ins ops)", "by auto"], ["proof (state)\nthis:\n  yi \\<in> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. list_order (as @ [(yi, yr)] @ bs @ [(xi, Some yi)]) yi xi", "hence \"yi \\<in> set (interp_ins (as @ [(yi, yr)] @ bs))\""], ["proof (prove)\nusing this:\n  yi \\<in> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. yi \\<in> set (interp_ins (as @ [(yi, yr)] @ bs))", "using interp_ins_append_non_memb ops_split snoc.prems(1)"], ["proof (prove)\nusing this:\n  yi \\<in> set (interp_ins ops)\n  \\<lbrakk>insert_ops (?pre @ [(?oid, Some ?ref)] @ ?suf);\n   ?ref \\<notin> set (interp_ins ?pre)\\<rbrakk>\n  \\<Longrightarrow> ?ref\n                    \\<notin> set (interp_ins\n                                   (?pre @ [(?oid, Some ?ref)] @ ?suf))\n  ops = as @ [(yi, yr)] @ bs @ [(xi, Some yi)] @ cs\n  insert_ops ops\n\ngoal (1 subgoal):\n 1. yi \\<in> set (interp_ins (as @ [(yi, yr)] @ bs))", "by force"], ["proof (state)\nthis:\n  yi \\<in> set (interp_ins (as @ [(yi, yr)] @ bs))\n\ngoal (1 subgoal):\n 1. list_order (as @ [(yi, yr)] @ bs @ [(xi, Some yi)]) yi xi", "ultimately"], ["proof (chain)\npicking this:\n  insert_ops ((as @ [(yi, yr)] @ bs) @ [(xi, Some yi)])\n  yi \\<in> set (interp_ins (as @ [(yi, yr)] @ bs))", "show ?thesis"], ["proof (prove)\nusing this:\n  insert_ops ((as @ [(yi, yr)] @ bs) @ [(xi, Some yi)])\n  yi \\<in> set (interp_ins (as @ [(yi, yr)] @ bs))\n\ngoal (1 subgoal):\n 1. list_order (as @ [(yi, yr)] @ bs @ [(xi, Some yi)]) yi xi", "using list_order_insert_ref"], ["proof (prove)\nusing this:\n  insert_ops ((as @ [(yi, yr)] @ bs) @ [(xi, Some yi)])\n  yi \\<in> set (interp_ins (as @ [(yi, yr)] @ bs))\n  \\<lbrakk>insert_ops (?ops @ [(?oid, Some ?ref)]);\n   ?ref \\<in> set (interp_ins ?ops)\\<rbrakk>\n  \\<Longrightarrow> list_order (?ops @ [(?oid, Some ?ref)]) ?ref ?oid\n\ngoal (1 subgoal):\n 1. list_order (as @ [(yi, yr)] @ bs @ [(xi, Some yi)]) yi xi", "by force"], ["proof (state)\nthis:\n  list_order (as @ [(yi, yr)] @ bs @ [(xi, Some yi)]) yi xi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_order (as @ [(yi, yr)] @ bs @ [(xi, Some yi)]) yi xi\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> list_order ops ref (fst x)", "hence \"list_order ops yi xi\""], ["proof (prove)\nusing this:\n  list_order (as @ [(yi, yr)] @ bs @ [(xi, Some yi)]) yi xi\n\ngoal (1 subgoal):\n 1. list_order ops yi xi", "by (metis append_assoc list_order_append ops_split snoc.prems(1))"], ["proof (state)\nthis:\n  list_order ops yi xi\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> list_order ops ref (fst x)", "ultimately"], ["proof (chain)\npicking this:\n  list_order ops ref yi\n  list_order ops yi xi", "show \"list_order ops ref (fst x)\""], ["proof (prove)\nusing this:\n  list_order ops ref yi\n  list_order ops yi xi\n\ngoal (1 subgoal):\n 1. list_order ops ref (fst x)", "using list_order_trans snoc.prems(1) yx_pairs"], ["proof (prove)\nusing this:\n  list_order ops ref yi\n  list_order ops yi xi\n  \\<lbrakk>insert_ops ?op_list; list_order ?op_list ?x ?y;\n   list_order ?op_list ?y ?z\\<rbrakk>\n  \\<Longrightarrow> list_order ?op_list ?x ?z\n  insert_ops ops\n  y = (yi, yr) \\<and> x = (xi, xr)\n\ngoal (1 subgoal):\n 1. list_order ops ref (fst x)", "by auto"], ["proof (state)\nthis:\n  list_order ops ref (fst x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_order ops ref (fst x)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops ops; insert_seq (Some ref) xs;\n                 insert_ops xs; set xs \\<subseteq> set ops;\n                 ref \\<in> set (interp_ins ops)\\<rbrakk>\n                \\<Longrightarrow> Ball (set (map fst xs))\n                                   (list_order ops ref);\n        insert_ops ops; insert_seq (Some ref) (xs @ [x]);\n        insert_ops (xs @ [x]); set (xs @ [x]) \\<subseteq> set ops;\n        ref \\<in> set (interp_ins ops)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (map fst (xs @ [x])))\n                          (list_order ops ref)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>set (map fst xs). list_order ops ref i\n  list_order ops ref (fst x)", "show \"\\<forall>i \\<in> set (map fst (xs @ [x])). list_order ops ref i\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>set (map fst xs). list_order ops ref i\n  list_order ops ref (fst x)\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst (xs @ [x])). list_order ops ref i", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<in>set (map fst (xs @ [x])). list_order ops ref i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_seq_no_start:\n  assumes \"insert_ops ops\"\n    and \"insert_seq (Some ref) xs\" and \"insert_ops xs\"\n    and \"set xs \\<subseteq> set ops\"\n    and \"ref \\<notin> set (interp_ins ops)\"\n  shows \"\\<forall>i \\<in> set (map fst xs). i \\<notin> set (interp_ins ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst xs). i \\<notin> set (interp_ins ops)", "using assms"], ["proof (prove)\nusing this:\n  insert_ops ops\n  insert_seq (Some ref) xs\n  insert_ops xs\n  set xs \\<subseteq> set ops\n  ref \\<notin> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst xs). i \\<notin> set (interp_ins ops)", "proof(induction xs rule: List.rev_induct, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops ops; insert_seq (Some ref) xs;\n                 insert_ops xs; set xs \\<subseteq> set ops;\n                 ref \\<notin> set (interp_ins ops)\\<rbrakk>\n                \\<Longrightarrow> \\<forall>i\\<in>set (map fst xs).\n                                     i \\<notin> set (interp_ins ops);\n        insert_ops ops; insert_seq (Some ref) (xs @ [x]);\n        insert_ops (xs @ [x]); set (xs @ [x]) \\<subseteq> set ops;\n        ref \\<notin> set (interp_ins ops)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                            i \\<notin> set (interp_ins ops)", "case (snoc x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>insert_ops ops; insert_seq (Some ref) xs; insert_ops xs;\n   set xs \\<subseteq> set ops; ref \\<notin> set (interp_ins ops)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>i\\<in>set (map fst xs).\n                       i \\<notin> set (interp_ins ops)\n  insert_ops ops\n  insert_seq (Some ref) (xs @ [x])\n  insert_ops (xs @ [x])\n  set (xs @ [x]) \\<subseteq> set ops\n  ref \\<notin> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops ops; insert_seq (Some ref) xs;\n                 insert_ops xs; set xs \\<subseteq> set ops;\n                 ref \\<notin> set (interp_ins ops)\\<rbrakk>\n                \\<Longrightarrow> \\<forall>i\\<in>set (map fst xs).\n                                     i \\<notin> set (interp_ins ops);\n        insert_ops ops; insert_seq (Some ref) (xs @ [x]);\n        insert_ops (xs @ [x]); set (xs @ [x]) \\<subseteq> set ops;\n        ref \\<notin> set (interp_ins ops)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                            i \\<notin> set (interp_ins ops)", "have IH: \"\\<forall>i \\<in> set (map fst xs). i \\<notin> set (interp_ins ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst xs). i \\<notin> set (interp_ins ops)", "using snoc.IH snoc.prems insert_seq_rem_last insert_ops_appendD"], ["proof (prove)\nusing this:\n  \\<lbrakk>insert_ops ops; insert_seq (Some ref) xs; insert_ops xs;\n   set xs \\<subseteq> set ops; ref \\<notin> set (interp_ins ops)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>i\\<in>set (map fst xs).\n                       i \\<notin> set (interp_ins ops)\n  insert_ops ops\n  insert_seq (Some ref) (xs @ [x])\n  insert_ops (xs @ [x])\n  set (xs @ [x]) \\<subseteq> set ops\n  ref \\<notin> set (interp_ins ops)\n  \\<lbrakk>insert_seq ?start (?xs @ [?x]); ?xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> insert_seq ?start ?xs\n  insert_ops (?xs @ ?ys) \\<Longrightarrow> insert_ops ?xs\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst xs). i \\<notin> set (interp_ins ops)", "by (metis append_is_Nil_conv le_sup_iff list.map_disc_iff set_append split_list_first)"], ["proof (state)\nthis:\n  \\<forall>i\\<in>set (map fst xs). i \\<notin> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops ops; insert_seq (Some ref) xs;\n                 insert_ops xs; set xs \\<subseteq> set ops;\n                 ref \\<notin> set (interp_ins ops)\\<rbrakk>\n                \\<Longrightarrow> \\<forall>i\\<in>set (map fst xs).\n                                     i \\<notin> set (interp_ins ops);\n        insert_ops ops; insert_seq (Some ref) (xs @ [x]);\n        insert_ops (xs @ [x]); set (xs @ [x]) \\<subseteq> set ops;\n        ref \\<notin> set (interp_ins ops)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                            i \\<notin> set (interp_ins ops)", "obtain as bs where \"ops = as @ x # bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        ops = as @ x # bs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using snoc.prems(4)"], ["proof (prove)\nusing this:\n  set (xs @ [x]) \\<subseteq> set ops\n\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        ops = as @ x # bs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis split_list last_in_set snoc_eq_iff_butlast subset_code(1))"], ["proof (state)\nthis:\n  ops = as @ x # bs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops ops; insert_seq (Some ref) xs;\n                 insert_ops xs; set xs \\<subseteq> set ops;\n                 ref \\<notin> set (interp_ins ops)\\<rbrakk>\n                \\<Longrightarrow> \\<forall>i\\<in>set (map fst xs).\n                                     i \\<notin> set (interp_ins ops);\n        insert_ops ops; insert_seq (Some ref) (xs @ [x]);\n        insert_ops (xs @ [x]); set (xs @ [x]) \\<subseteq> set ops;\n        ref \\<notin> set (interp_ins ops)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                            i \\<notin> set (interp_ins ops)", "have \"fst x \\<notin> set (interp_ins ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst x \\<notin> set (interp_ins ops)", "proof(cases \"xs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> fst x \\<notin> set (interp_ins ops)\n 2. xs \\<noteq> [] \\<Longrightarrow> fst x \\<notin> set (interp_ins ops)", "case True"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> fst x \\<notin> set (interp_ins ops)\n 2. xs \\<noteq> [] \\<Longrightarrow> fst x \\<notin> set (interp_ins ops)", "then"], ["proof (chain)\npicking this:\n  xs = []", "obtain xi where \"x = (xi, Some ref)\""], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. (\\<And>xi.\n        x = (xi, Some ref) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using insert_seq_hd snoc.prems(2)"], ["proof (prove)\nusing this:\n  xs = []\n  insert_seq ?start ?xs \\<Longrightarrow>\n  \\<exists>oid. hd ?xs = (oid, ?start)\n  insert_seq (Some ref) (xs @ [x])\n\ngoal (1 subgoal):\n 1. (\\<And>xi.\n        x = (xi, Some ref) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  x = (xi, Some ref)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> fst x \\<notin> set (interp_ins ops)\n 2. xs \\<noteq> [] \\<Longrightarrow> fst x \\<notin> set (interp_ins ops)", "moreover"], ["proof (state)\nthis:\n  x = (xi, Some ref)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> fst x \\<notin> set (interp_ins ops)\n 2. xs \\<noteq> [] \\<Longrightarrow> fst x \\<notin> set (interp_ins ops)", "have \"ref \\<notin> set (interp_ins as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ref \\<notin> set (interp_ins as)", "using interp_ins_monotonic snoc.prems(1) snoc.prems(5) \\<open>ops = as @ x # bs\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>insert_ops (?pre @ ?suf);\n   ?oid \\<in> set (interp_ins ?pre)\\<rbrakk>\n  \\<Longrightarrow> ?oid \\<in> set (interp_ins (?pre @ ?suf))\n  insert_ops ops\n  ref \\<notin> set (interp_ins ops)\n  ops = as @ x # bs\n\ngoal (1 subgoal):\n 1. ref \\<notin> set (interp_ins as)", "by blast"], ["proof (state)\nthis:\n  ref \\<notin> set (interp_ins as)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> fst x \\<notin> set (interp_ins ops)\n 2. xs \\<noteq> [] \\<Longrightarrow> fst x \\<notin> set (interp_ins ops)", "ultimately"], ["proof (chain)\npicking this:\n  x = (xi, Some ref)\n  ref \\<notin> set (interp_ins as)", "have \"xi \\<notin> set (interp_ins (as @ [x] @ bs))\""], ["proof (prove)\nusing this:\n  x = (xi, Some ref)\n  ref \\<notin> set (interp_ins as)\n\ngoal (1 subgoal):\n 1. xi \\<notin> set (interp_ins (as @ [x] @ bs))", "using snoc.prems(1)"], ["proof (prove)\nusing this:\n  x = (xi, Some ref)\n  ref \\<notin> set (interp_ins as)\n  insert_ops ops\n\ngoal (1 subgoal):\n 1. xi \\<notin> set (interp_ins (as @ [x] @ bs))", "by (simp add: interp_ins_ref_nonex \\<open>ops = as @ x # bs\\<close>)"], ["proof (state)\nthis:\n  xi \\<notin> set (interp_ins (as @ [x] @ bs))\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> fst x \\<notin> set (interp_ins ops)\n 2. xs \\<noteq> [] \\<Longrightarrow> fst x \\<notin> set (interp_ins ops)", "then"], ["proof (chain)\npicking this:\n  xi \\<notin> set (interp_ins (as @ [x] @ bs))", "show \"fst x \\<notin> set (interp_ins ops)\""], ["proof (prove)\nusing this:\n  xi \\<notin> set (interp_ins (as @ [x] @ bs))\n\ngoal (1 subgoal):\n 1. fst x \\<notin> set (interp_ins ops)", "by (simp add: \\<open>ops = as @ x # bs\\<close> \\<open>x = (xi, Some ref)\\<close>)"], ["proof (state)\nthis:\n  fst x \\<notin> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> fst x \\<notin> set (interp_ins ops)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> fst x \\<notin> set (interp_ins ops)", "case xs_nonempty: False"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> fst x \\<notin> set (interp_ins ops)", "then"], ["proof (chain)\npicking this:\n  xs \\<noteq> []", "obtain y where \"xs = (butlast xs) @ [y]\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        xs = butlast xs @ [y] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis append_butlast_last_id)"], ["proof (state)\nthis:\n  xs = butlast xs @ [y]\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> fst x \\<notin> set (interp_ins ops)", "moreover"], ["proof (state)\nthis:\n  xs = butlast xs @ [y]\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> fst x \\<notin> set (interp_ins ops)", "from this"], ["proof (chain)\npicking this:\n  xs = butlast xs @ [y]", "obtain yi yr xi xr where \"y = (yi, yr) \\<and> x = (xi, xr)\""], ["proof (prove)\nusing this:\n  xs = butlast xs @ [y]\n\ngoal (1 subgoal):\n 1. (\\<And>yi yr xi xr.\n        y = (yi, yr) \\<and> x = (xi, xr) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  y = (yi, yr) \\<and> x = (xi, xr)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> fst x \\<notin> set (interp_ins ops)", "moreover"], ["proof (state)\nthis:\n  y = (yi, yr) \\<and> x = (xi, xr)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> fst x \\<notin> set (interp_ins ops)", "from this"], ["proof (chain)\npicking this:\n  y = (yi, yr) \\<and> x = (xi, xr)", "have \"xr = Some yi\""], ["proof (prove)\nusing this:\n  y = (yi, yr) \\<and> x = (xi, xr)\n\ngoal (1 subgoal):\n 1. xr = Some yi", "using insert_seq.cases snoc.prems(2) calculation"], ["proof (prove)\nusing this:\n  y = (yi, yr) \\<and> x = (xi, xr)\n  \\<lbrakk>insert_seq ?a1.0 ?a2.0;\n   \\<And>start oid.\n      \\<lbrakk>?a1.0 = start; ?a2.0 = [(oid, start)]\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>start list prev ref oid.\n      \\<lbrakk>?a1.0 = start;\n       ?a2.0 = list @ [(prev, ref), (oid, Some prev)];\n       insert_seq start (list @ [(prev, ref)])\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  insert_seq (Some ref) (xs @ [x])\n  xs = butlast xs @ [y]\n  y = (yi, yr) \\<and> x = (xi, xr)\n\ngoal (1 subgoal):\n 1. xr = Some yi", "by fastforce"], ["proof (state)\nthis:\n  xr = Some yi\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> fst x \\<notin> set (interp_ins ops)", "moreover"], ["proof (state)\nthis:\n  xr = Some yi\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> fst x \\<notin> set (interp_ins ops)", "have \"yi \\<notin> set (interp_ins ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. yi \\<notin> set (interp_ins ops)", "using IH calculation"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>set (map fst xs). i \\<notin> set (interp_ins ops)\n  xs = butlast xs @ [y]\n  y = (yi, yr) \\<and> x = (xi, xr)\n  xr = Some yi\n\ngoal (1 subgoal):\n 1. yi \\<notin> set (interp_ins ops)", "by (metis Nil_is_map_conv fst_conv last_in_set last_map snoc_eq_iff_butlast)"], ["proof (state)\nthis:\n  yi \\<notin> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> fst x \\<notin> set (interp_ins ops)", "hence \"yi \\<notin> set (interp_ins as)\""], ["proof (prove)\nusing this:\n  yi \\<notin> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. yi \\<notin> set (interp_ins as)", "using \\<open>ops = as @ x # bs\\<close> interp_ins_monotonic snoc.prems(1)"], ["proof (prove)\nusing this:\n  yi \\<notin> set (interp_ins ops)\n  ops = as @ x # bs\n  \\<lbrakk>insert_ops (?pre @ ?suf);\n   ?oid \\<in> set (interp_ins ?pre)\\<rbrakk>\n  \\<Longrightarrow> ?oid \\<in> set (interp_ins (?pre @ ?suf))\n  insert_ops ops\n\ngoal (1 subgoal):\n 1. yi \\<notin> set (interp_ins as)", "by blast"], ["proof (state)\nthis:\n  yi \\<notin> set (interp_ins as)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> fst x \\<notin> set (interp_ins ops)", "ultimately"], ["proof (chain)\npicking this:\n  xs = butlast xs @ [y]\n  y = (yi, yr) \\<and> x = (xi, xr)\n  xr = Some yi\n  yi \\<notin> set (interp_ins as)", "have \"xi \\<notin> set (interp_ins (as @ [x] @ bs))\""], ["proof (prove)\nusing this:\n  xs = butlast xs @ [y]\n  y = (yi, yr) \\<and> x = (xi, xr)\n  xr = Some yi\n  yi \\<notin> set (interp_ins as)\n\ngoal (1 subgoal):\n 1. xi \\<notin> set (interp_ins (as @ [x] @ bs))", "using interp_ins_ref_nonex snoc.prems(1) \\<open>ops = as @ x # bs\\<close>"], ["proof (prove)\nusing this:\n  xs = butlast xs @ [y]\n  y = (yi, yr) \\<and> x = (xi, xr)\n  xr = Some yi\n  yi \\<notin> set (interp_ins as)\n  \\<lbrakk>insert_ops ?ops; ?ops = ?xs @ [(?oid, Some ?ref)] @ ?ys;\n   ?ref \\<notin> set (interp_ins ?xs)\\<rbrakk>\n  \\<Longrightarrow> ?oid \\<notin> set (interp_ins ?ops)\n  insert_ops ops\n  ops = as @ x # bs\n\ngoal (1 subgoal):\n 1. xi \\<notin> set (interp_ins (as @ [x] @ bs))", "by fastforce"], ["proof (state)\nthis:\n  xi \\<notin> set (interp_ins (as @ [x] @ bs))\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> fst x \\<notin> set (interp_ins ops)", "then"], ["proof (chain)\npicking this:\n  xi \\<notin> set (interp_ins (as @ [x] @ bs))", "show \"fst x \\<notin> set (interp_ins ops)\""], ["proof (prove)\nusing this:\n  xi \\<notin> set (interp_ins (as @ [x] @ bs))\n\ngoal (1 subgoal):\n 1. fst x \\<notin> set (interp_ins ops)", "by (simp add: \\<open>ops = as @ x # bs\\<close> \\<open>y = (yi, yr) \\<and> x = (xi, xr)\\<close>)"], ["proof (state)\nthis:\n  fst x \\<notin> set (interp_ins ops)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst x \\<notin> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops ops; insert_seq (Some ref) xs;\n                 insert_ops xs; set xs \\<subseteq> set ops;\n                 ref \\<notin> set (interp_ins ops)\\<rbrakk>\n                \\<Longrightarrow> \\<forall>i\\<in>set (map fst xs).\n                                     i \\<notin> set (interp_ins ops);\n        insert_ops ops; insert_seq (Some ref) (xs @ [x]);\n        insert_ops (xs @ [x]); set (xs @ [x]) \\<subseteq> set ops;\n        ref \\<notin> set (interp_ins ops)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>set (map fst (xs @ [x])).\n                            i \\<notin> set (interp_ins ops)", "then"], ["proof (chain)\npicking this:\n  fst x \\<notin> set (interp_ins ops)", "show \"\\<forall>i \\<in> set (map fst (xs @ [x])). i \\<notin> set (interp_ins ops)\""], ["proof (prove)\nusing this:\n  fst x \\<notin> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst (xs @ [x])). i \\<notin> set (interp_ins ops)", "using IH"], ["proof (prove)\nusing this:\n  fst x \\<notin> set (interp_ins ops)\n  \\<forall>i\\<in>set (map fst xs). i \\<notin> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst (xs @ [x])). i \\<notin> set (interp_ins ops)", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<in>set (map fst (xs @ [x])). i \\<notin> set (interp_ins ops)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>The proof of no interleaving\\<close>"], ["", "lemma no_interleaving_ordered:\n  assumes \"insert_ops ops\"\n    and \"insert_seq start xs\" and \"insert_ops xs\"\n    and \"insert_seq start ys\" and \"insert_ops ys\"\n    and \"set xs \\<subseteq> set ops\" and \"set ys \\<subseteq> set ops\"\n    and \"distinct (map fst xs @ map fst ys)\"\n    and \"fst (hd xs) < fst (hd ys)\"\n    and \"\\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)\"\n  shows \"(\\<forall>x \\<in> set (map fst xs). \\<forall>y \\<in> set (map fst ys). list_order ops y x) \\<and>\n         (\\<forall>r. start = Some r \\<longrightarrow> (\\<forall>x \\<in> set (map fst xs). list_order ops r x) \\<and>\n                                 (\\<forall>y \\<in> set (map fst ys). list_order ops r y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))", "using assms"], ["proof (prove)\nusing this:\n  insert_ops ops\n  insert_seq start xs\n  insert_ops xs\n  insert_seq start ys\n  insert_ops ys\n  set xs \\<subseteq> set ops\n  set ys \\<subseteq> set ops\n  distinct (map fst xs @ map fst ys)\n  fst (hd xs) < fst (hd ys)\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))", "proof(induction ops arbitrary: xs ys rule: List.rev_induct, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs xsa ys.\n       \\<lbrakk>\\<And>xsa ys.\n                   \\<lbrakk>insert_ops xs; insert_seq start xsa;\n                    insert_ops xsa; insert_seq start ys; insert_ops ys;\n                    set xsa \\<subseteq> set xs; set ys \\<subseteq> set xs;\n                    distinct (map fst xsa @ map fst ys);\n                    fst (hd xsa) < fst (hd ys);\n                    \\<And>r.\n                       start = Some r \\<Longrightarrow>\n                       r \\<in> set (interp_ins xs)\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>x\\<in>set (map fst xsa).\n   \\<forall>y\\<in>set (map fst ys). list_order xs y x) \\<and>\n                                     (\\<forall>r.\n   start = Some r \\<longrightarrow>\n   Ball (set (map fst xsa)) (list_order xs r) \\<and>\n   Ball (set (map fst ys)) (list_order xs r));\n        insert_ops (xs @ [x]); insert_seq start xsa; insert_ops xsa;\n        insert_seq start ys; insert_ops ys;\n        set xsa \\<subseteq> set (xs @ [x]);\n        set ys \\<subseteq> set (xs @ [x]);\n        distinct (map fst xsa @ map fst ys); fst (hd xsa) < fst (hd ys);\n        \\<And>r.\n           start = Some r \\<Longrightarrow>\n           r \\<in> set (interp_ins (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>xa\\<in>set (map fst xsa).\n                             \\<forall>y\\<in>set (map fst ys).\n                                list_order (xs @ [x]) y xa) \\<and>\n                         (\\<forall>r.\n                             start = Some r \\<longrightarrow>\n                             Ball (set (map fst xsa))\n                              (list_order (xs @ [x]) r) \\<and>\n                             Ball (set (map fst ys))\n                              (list_order (xs @ [x]) r))", "case (snoc a ops)"], ["proof (state)\nthis:\n  \\<lbrakk>insert_ops ops; insert_seq start ?xs; insert_ops ?xs;\n   insert_seq start ?ys; insert_ops ?ys; set ?xs \\<subseteq> set ops;\n   set ?ys \\<subseteq> set ops; distinct (map fst ?xs @ map fst ?ys);\n   fst (hd ?xs) < fst (hd ?ys);\n   \\<And>r.\n      start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>x\\<in>set (map fst ?xs).\n                        \\<forall>y\\<in>set (map fst ?ys).\n                           list_order ops y x) \\<and>\n                    (\\<forall>r.\n                        start = Some r \\<longrightarrow>\n                        (\\<forall>a\\<in>set (map fst ?xs).\n                            list_order ops r a) \\<and>\n                        (\\<forall>a\\<in>set (map fst ?ys).\n                            list_order ops r a))\n  insert_ops (ops @ [a])\n  insert_seq start xs\n  insert_ops xs\n  insert_seq start ys\n  insert_ops ys\n  set xs \\<subseteq> set (ops @ [a])\n  set ys \\<subseteq> set (ops @ [a])\n  distinct (map fst xs @ map fst ys)\n  fst (hd xs) < fst (hd ys)\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins (ops @ [a]))\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa ys.\n       \\<lbrakk>\\<And>xsa ys.\n                   \\<lbrakk>insert_ops xs; insert_seq start xsa;\n                    insert_ops xsa; insert_seq start ys; insert_ops ys;\n                    set xsa \\<subseteq> set xs; set ys \\<subseteq> set xs;\n                    distinct (map fst xsa @ map fst ys);\n                    fst (hd xsa) < fst (hd ys);\n                    \\<And>r.\n                       start = Some r \\<Longrightarrow>\n                       r \\<in> set (interp_ins xs)\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>x\\<in>set (map fst xsa).\n   \\<forall>y\\<in>set (map fst ys). list_order xs y x) \\<and>\n                                     (\\<forall>r.\n   start = Some r \\<longrightarrow>\n   Ball (set (map fst xsa)) (list_order xs r) \\<and>\n   Ball (set (map fst ys)) (list_order xs r));\n        insert_ops (xs @ [x]); insert_seq start xsa; insert_ops xsa;\n        insert_seq start ys; insert_ops ys;\n        set xsa \\<subseteq> set (xs @ [x]);\n        set ys \\<subseteq> set (xs @ [x]);\n        distinct (map fst xsa @ map fst ys); fst (hd xsa) < fst (hd ys);\n        \\<And>r.\n           start = Some r \\<Longrightarrow>\n           r \\<in> set (interp_ins (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>xa\\<in>set (map fst xsa).\n                             \\<forall>y\\<in>set (map fst ys).\n                                list_order (xs @ [x]) y xa) \\<and>\n                         (\\<forall>r.\n                             start = Some r \\<longrightarrow>\n                             Ball (set (map fst xsa))\n                              (list_order (xs @ [x]) r) \\<and>\n                             Ball (set (map fst ys))\n                              (list_order (xs @ [x]) r))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>insert_ops ops; insert_seq start ?xs; insert_ops ?xs;\n   insert_seq start ?ys; insert_ops ?ys; set ?xs \\<subseteq> set ops;\n   set ?ys \\<subseteq> set ops; distinct (map fst ?xs @ map fst ?ys);\n   fst (hd ?xs) < fst (hd ?ys);\n   \\<And>r.\n      start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>x\\<in>set (map fst ?xs).\n                        \\<forall>y\\<in>set (map fst ?ys).\n                           list_order ops y x) \\<and>\n                    (\\<forall>r.\n                        start = Some r \\<longrightarrow>\n                        (\\<forall>a\\<in>set (map fst ?xs).\n                            list_order ops r a) \\<and>\n                        (\\<forall>a\\<in>set (map fst ?ys).\n                            list_order ops r a))\n  insert_ops (ops @ [a])\n  insert_seq start xs\n  insert_ops xs\n  insert_seq start ys\n  insert_ops ys\n  set xs \\<subseteq> set (ops @ [a])\n  set ys \\<subseteq> set (ops @ [a])\n  distinct (map fst xs @ map fst ys)\n  fst (hd xs) < fst (hd ys)\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins (ops @ [a]))", "have \"insert_ops ops\""], ["proof (prove)\nusing this:\n  \\<lbrakk>insert_ops ops; insert_seq start ?xs; insert_ops ?xs;\n   insert_seq start ?ys; insert_ops ?ys; set ?xs \\<subseteq> set ops;\n   set ?ys \\<subseteq> set ops; distinct (map fst ?xs @ map fst ?ys);\n   fst (hd ?xs) < fst (hd ?ys);\n   \\<And>r.\n      start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>x\\<in>set (map fst ?xs).\n                        \\<forall>y\\<in>set (map fst ?ys).\n                           list_order ops y x) \\<and>\n                    (\\<forall>r.\n                        start = Some r \\<longrightarrow>\n                        (\\<forall>a\\<in>set (map fst ?xs).\n                            list_order ops r a) \\<and>\n                        (\\<forall>a\\<in>set (map fst ?ys).\n                            list_order ops r a))\n  insert_ops (ops @ [a])\n  insert_seq start xs\n  insert_ops xs\n  insert_seq start ys\n  insert_ops ys\n  set xs \\<subseteq> set (ops @ [a])\n  set ys \\<subseteq> set (ops @ [a])\n  distinct (map fst xs @ map fst ys)\n  fst (hd xs) < fst (hd ys)\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins (ops @ [a]))\n\ngoal (1 subgoal):\n 1. insert_ops ops", "using insert_ops_rem_last"], ["proof (prove)\nusing this:\n  \\<lbrakk>insert_ops ops; insert_seq start ?xs; insert_ops ?xs;\n   insert_seq start ?ys; insert_ops ?ys; set ?xs \\<subseteq> set ops;\n   set ?ys \\<subseteq> set ops; distinct (map fst ?xs @ map fst ?ys);\n   fst (hd ?xs) < fst (hd ?ys);\n   \\<And>r.\n      start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>x\\<in>set (map fst ?xs).\n                        \\<forall>y\\<in>set (map fst ?ys).\n                           list_order ops y x) \\<and>\n                    (\\<forall>r.\n                        start = Some r \\<longrightarrow>\n                        (\\<forall>a\\<in>set (map fst ?xs).\n                            list_order ops r a) \\<and>\n                        (\\<forall>a\\<in>set (map fst ?ys).\n                            list_order ops r a))\n  insert_ops (ops @ [a])\n  insert_seq start xs\n  insert_ops xs\n  insert_seq start ys\n  insert_ops ys\n  set xs \\<subseteq> set (ops @ [a])\n  set ys \\<subseteq> set (ops @ [a])\n  distinct (map fst xs @ map fst ys)\n  fst (hd xs) < fst (hd ys)\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins (ops @ [a]))\n  insert_ops (?xs @ [?x]) \\<Longrightarrow> insert_ops ?xs\n\ngoal (1 subgoal):\n 1. insert_ops ops", "by auto"], ["proof (state)\nthis:\n  insert_ops ops\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa ys.\n       \\<lbrakk>\\<And>xsa ys.\n                   \\<lbrakk>insert_ops xs; insert_seq start xsa;\n                    insert_ops xsa; insert_seq start ys; insert_ops ys;\n                    set xsa \\<subseteq> set xs; set ys \\<subseteq> set xs;\n                    distinct (map fst xsa @ map fst ys);\n                    fst (hd xsa) < fst (hd ys);\n                    \\<And>r.\n                       start = Some r \\<Longrightarrow>\n                       r \\<in> set (interp_ins xs)\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>x\\<in>set (map fst xsa).\n   \\<forall>y\\<in>set (map fst ys). list_order xs y x) \\<and>\n                                     (\\<forall>r.\n   start = Some r \\<longrightarrow>\n   Ball (set (map fst xsa)) (list_order xs r) \\<and>\n   Ball (set (map fst ys)) (list_order xs r));\n        insert_ops (xs @ [x]); insert_seq start xsa; insert_ops xsa;\n        insert_seq start ys; insert_ops ys;\n        set xsa \\<subseteq> set (xs @ [x]);\n        set ys \\<subseteq> set (xs @ [x]);\n        distinct (map fst xsa @ map fst ys); fst (hd xsa) < fst (hd ys);\n        \\<And>r.\n           start = Some r \\<Longrightarrow>\n           r \\<in> set (interp_ins (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>xa\\<in>set (map fst xsa).\n                             \\<forall>y\\<in>set (map fst ys).\n                                list_order (xs @ [x]) y xa) \\<and>\n                         (\\<forall>r.\n                             start = Some r \\<longrightarrow>\n                             Ball (set (map fst xsa))\n                              (list_order (xs @ [x]) r) \\<and>\n                             Ball (set (map fst ys))\n                              (list_order (xs @ [x]) r))", "consider (a_in_xs) \"a \\<in> set xs\" | (a_in_ys) \"a \\<in> set ys\" | (neither) \"a \\<notin> set xs \\<and> a \\<notin> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> set xs \\<Longrightarrow> thesis;\n     a \\<in> set ys \\<Longrightarrow> thesis;\n     a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<in> set xs \\<Longrightarrow> ?thesis;\n   a \\<in> set ys \\<Longrightarrow> ?thesis;\n   a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa ys.\n       \\<lbrakk>\\<And>xsa ys.\n                   \\<lbrakk>insert_ops xs; insert_seq start xsa;\n                    insert_ops xsa; insert_seq start ys; insert_ops ys;\n                    set xsa \\<subseteq> set xs; set ys \\<subseteq> set xs;\n                    distinct (map fst xsa @ map fst ys);\n                    fst (hd xsa) < fst (hd ys);\n                    \\<And>r.\n                       start = Some r \\<Longrightarrow>\n                       r \\<in> set (interp_ins xs)\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>x\\<in>set (map fst xsa).\n   \\<forall>y\\<in>set (map fst ys). list_order xs y x) \\<and>\n                                     (\\<forall>r.\n   start = Some r \\<longrightarrow>\n   Ball (set (map fst xsa)) (list_order xs r) \\<and>\n   Ball (set (map fst ys)) (list_order xs r));\n        insert_ops (xs @ [x]); insert_seq start xsa; insert_ops xsa;\n        insert_seq start ys; insert_ops ys;\n        set xsa \\<subseteq> set (xs @ [x]);\n        set ys \\<subseteq> set (xs @ [x]);\n        distinct (map fst xsa @ map fst ys); fst (hd xsa) < fst (hd ys);\n        \\<And>r.\n           start = Some r \\<Longrightarrow>\n           r \\<in> set (interp_ins (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>xa\\<in>set (map fst xsa).\n                             \\<forall>y\\<in>set (map fst ys).\n                                list_order (xs @ [x]) y xa) \\<and>\n                         (\\<forall>r.\n                             start = Some r \\<longrightarrow>\n                             Ball (set (map fst xsa))\n                              (list_order (xs @ [x]) r) \\<and>\n                             Ball (set (map fst ys))\n                              (list_order (xs @ [x]) r))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>a \\<in> set xs \\<Longrightarrow> ?thesis;\n   a \\<in> set ys \\<Longrightarrow> ?thesis;\n   a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<in> set xs \\<Longrightarrow> ?thesis;\n   a \\<in> set ys \\<Longrightarrow> ?thesis;\n   a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "proof(cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 2. a \\<in> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 3. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "case a_in_xs"], ["proof (state)\nthis:\n  a \\<in> set xs\n\ngoal (3 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 2. a \\<in> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 3. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "then"], ["proof (chain)\npicking this:\n  a \\<in> set xs", "have \"a \\<notin> set ys\""], ["proof (prove)\nusing this:\n  a \\<in> set xs\n\ngoal (1 subgoal):\n 1. a \\<notin> set ys", "using snoc.prems(8)"], ["proof (prove)\nusing this:\n  a \\<in> set xs\n  distinct (map fst xs @ map fst ys)\n\ngoal (1 subgoal):\n 1. a \\<notin> set ys", "by auto"], ["proof (state)\nthis:\n  a \\<notin> set ys\n\ngoal (3 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 2. a \\<in> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 3. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "hence \"set ys \\<subseteq> set ops\""], ["proof (prove)\nusing this:\n  a \\<notin> set ys\n\ngoal (1 subgoal):\n 1. set ys \\<subseteq> set ops", "using snoc.prems(7) DiffE"], ["proof (prove)\nusing this:\n  a \\<notin> set ys\n  set ys \\<subseteq> set (ops @ [a])\n  \\<lbrakk>?c \\<in> ?A - ?B;\n   \\<lbrakk>?c \\<in> ?A; ?c \\<notin> ?B\\<rbrakk>\n   \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. set ys \\<subseteq> set ops", "by auto"], ["proof (state)\nthis:\n  set ys \\<subseteq> set ops\n\ngoal (3 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 2. a \\<in> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 3. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "from a_in_xs"], ["proof (chain)\npicking this:\n  a \\<in> set xs", "have \"a = last xs\""], ["proof (prove)\nusing this:\n  a \\<in> set xs\n\ngoal (1 subgoal):\n 1. a = last xs", "using insert_ops_subset_last snoc.prems"], ["proof (prove)\nusing this:\n  a \\<in> set xs\n  \\<lbrakk>insert_ops (?xs @ [?x]); insert_ops ?ys;\n   set ?ys \\<subseteq> set (?xs @ [?x]); ?x \\<in> set ?ys\\<rbrakk>\n  \\<Longrightarrow> ?x = last ?ys\n  insert_ops (ops @ [a])\n  insert_seq start xs\n  insert_ops xs\n  insert_seq start ys\n  insert_ops ys\n  set xs \\<subseteq> set (ops @ [a])\n  set ys \\<subseteq> set (ops @ [a])\n  distinct (map fst xs @ map fst ys)\n  fst (hd xs) < fst (hd ys)\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins (ops @ [a]))\n\ngoal (1 subgoal):\n 1. a = last xs", "by blast"], ["proof (state)\nthis:\n  a = last xs\n\ngoal (3 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 2. a \\<in> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 3. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "have IH: \"(\\<forall>x \\<in> set (map fst (butlast xs)). \\<forall>y \\<in> set (map fst ys).  list_order ops y x) \\<and>\n              (\\<forall>r. start = Some r \\<longrightarrow> (\\<forall>x \\<in> set (map fst (butlast xs)). list_order ops r x) \\<and>\n                                      (\\<forall>y \\<in> set (map fst          ys).  list_order ops r y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set (map fst (butlast xs)).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst (butlast xs)).\n            list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))", "proof(cases \"xs = [a]\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst (butlast xs)).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst (butlast xs)).\n            list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))\n 2. xs \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst (butlast xs)).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst (butlast xs)).\n            list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))", "case True"], ["proof (state)\nthis:\n  xs = [a]\n\ngoal (2 subgoals):\n 1. xs = [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst (butlast xs)).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst (butlast xs)).\n            list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))\n 2. xs \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst (butlast xs)).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst (butlast xs)).\n            list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))", "moreover"], ["proof (state)\nthis:\n  xs = [a]\n\ngoal (2 subgoals):\n 1. xs = [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst (butlast xs)).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst (butlast xs)).\n            list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))\n 2. xs \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst (butlast xs)).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst (butlast xs)).\n            list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))", "have \"\\<forall>r. start = Some r \\<longrightarrow> (\\<forall>y \\<in> set (map fst ys). list_order ops r y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r.\n       start = Some r \\<longrightarrow>\n       (\\<forall>y\\<in>set (map fst ys). list_order ops r y)", "using insert_seq_after_start \\<open>insert_ops ops\\<close> \\<open>set ys \\<subseteq> set ops\\<close> snoc.prems"], ["proof (prove)\nusing this:\n  \\<lbrakk>insert_ops ?ops; insert_seq (Some ?ref) ?xs; insert_ops ?xs;\n   set ?xs \\<subseteq> set ?ops; ?ref \\<in> set (interp_ins ?ops)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>i\\<in>set (map fst ?xs). list_order ?ops ?ref i\n  insert_ops ops\n  set ys \\<subseteq> set ops\n  insert_ops (ops @ [a])\n  insert_seq start xs\n  insert_ops xs\n  insert_seq start ys\n  insert_ops ys\n  set xs \\<subseteq> set (ops @ [a])\n  set ys \\<subseteq> set (ops @ [a])\n  distinct (map fst xs @ map fst ys)\n  fst (hd xs) < fst (hd ys)\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins (ops @ [a]))\n\ngoal (1 subgoal):\n 1. \\<forall>r.\n       start = Some r \\<longrightarrow>\n       (\\<forall>y\\<in>set (map fst ys). list_order ops r y)", "by (metis append_Nil2 calculation insert_seq_hd interp_ins_append_non_memb list.sel(1))"], ["proof (state)\nthis:\n  \\<forall>r.\n     start = Some r \\<longrightarrow>\n     (\\<forall>y\\<in>set (map fst ys). list_order ops r y)\n\ngoal (2 subgoals):\n 1. xs = [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst (butlast xs)).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst (butlast xs)).\n            list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))\n 2. xs \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst (butlast xs)).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst (butlast xs)).\n            list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))", "ultimately"], ["proof (chain)\npicking this:\n  xs = [a]\n  \\<forall>r.\n     start = Some r \\<longrightarrow>\n     (\\<forall>y\\<in>set (map fst ys). list_order ops r y)", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = [a]\n  \\<forall>r.\n     start = Some r \\<longrightarrow>\n     (\\<forall>y\\<in>set (map fst ys). list_order ops r y)\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set (map fst (butlast xs)).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst (butlast xs)).\n            list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>set (map fst (butlast xs)).\n      \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n  (\\<forall>r.\n      start = Some r \\<longrightarrow>\n      (\\<forall>x\\<in>set (map fst (butlast xs)). list_order ops r x) \\<and>\n      (\\<forall>y\\<in>set (map fst ys). list_order ops r y))\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst (butlast xs)).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst (butlast xs)).\n            list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst (butlast xs)).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst (butlast xs)).\n            list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))", "case xs_longer: False"], ["proof (state)\nthis:\n  xs \\<noteq> [a]\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst (butlast xs)).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst (butlast xs)).\n            list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))", "from \\<open>a = last xs\\<close>"], ["proof (chain)\npicking this:\n  a = last xs", "have \"set (butlast xs) \\<subseteq> set ops\""], ["proof (prove)\nusing this:\n  a = last xs\n\ngoal (1 subgoal):\n 1. set (butlast xs) \\<subseteq> set ops", "using snoc.prems"], ["proof (prove)\nusing this:\n  a = last xs\n  insert_ops (ops @ [a])\n  insert_seq start xs\n  insert_ops xs\n  insert_seq start ys\n  insert_ops ys\n  set xs \\<subseteq> set (ops @ [a])\n  set ys \\<subseteq> set (ops @ [a])\n  distinct (map fst xs @ map fst ys)\n  fst (hd xs) < fst (hd ys)\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins (ops @ [a]))\n\ngoal (1 subgoal):\n 1. set (butlast xs) \\<subseteq> set ops", "by (simp add: distinct_fst subset_butlast)"], ["proof (state)\nthis:\n  set (butlast xs) \\<subseteq> set ops\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst (butlast xs)).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst (butlast xs)).\n            list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))", "moreover"], ["proof (state)\nthis:\n  set (butlast xs) \\<subseteq> set ops\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst (butlast xs)).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst (butlast xs)).\n            list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))", "have \"insert_seq start (butlast xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_seq start (butlast xs)", "using insert_seq_butlast insert_seq_nonempty xs_longer \\<open>a = last xs\\<close> snoc.prems(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>insert_seq ?start ?xs; ?xs \\<noteq> [];\n   ?xs \\<noteq> [last ?xs]\\<rbrakk>\n  \\<Longrightarrow> insert_seq ?start (butlast ?xs)\n  insert_seq ?start ?xs \\<Longrightarrow> ?xs \\<noteq> []\n  xs \\<noteq> [a]\n  a = last xs\n  insert_seq start xs\n\ngoal (1 subgoal):\n 1. insert_seq start (butlast xs)", "by blast"], ["proof (state)\nthis:\n  insert_seq start (butlast xs)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst (butlast xs)).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst (butlast xs)).\n            list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))", "moreover"], ["proof (state)\nthis:\n  insert_seq start (butlast xs)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst (butlast xs)).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst (butlast xs)).\n            list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))", "have \"insert_ops (butlast xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_ops (butlast xs)", "using snoc.prems(2) snoc.prems(3) insert_ops_appendD"], ["proof (prove)\nusing this:\n  insert_seq start xs\n  insert_ops xs\n  insert_ops (?xs @ ?ys) \\<Longrightarrow> insert_ops ?xs\n\ngoal (1 subgoal):\n 1. insert_ops (butlast xs)", "by (metis append_butlast_last_id insert_seq_nonempty)"], ["proof (state)\nthis:\n  insert_ops (butlast xs)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst (butlast xs)).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst (butlast xs)).\n            list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))", "moreover"], ["proof (state)\nthis:\n  insert_ops (butlast xs)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst (butlast xs)).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst (butlast xs)).\n            list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))", "have \"distinct (map fst (butlast xs) @ map fst ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (butlast xs) @ map fst ys)", "using distinct_append_butlast1 snoc.prems(8)"], ["proof (prove)\nusing this:\n  distinct (map fst ?xs @ map fst ?ys) \\<Longrightarrow>\n  distinct (map fst (butlast ?xs) @ map fst ?ys)\n  distinct (map fst xs @ map fst ys)\n\ngoal (1 subgoal):\n 1. distinct (map fst (butlast xs) @ map fst ys)", "by blast"], ["proof (state)\nthis:\n  distinct (map fst (butlast xs) @ map fst ys)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst (butlast xs)).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst (butlast xs)).\n            list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))", "moreover"], ["proof (state)\nthis:\n  distinct (map fst (butlast xs) @ map fst ys)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst (butlast xs)).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst (butlast xs)).\n            list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))", "have \"set ys \\<subseteq> set ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ys \\<subseteq> set ops", "using \\<open>a \\<notin> set ys\\<close> \\<open>set ys \\<subseteq> set ops\\<close>"], ["proof (prove)\nusing this:\n  a \\<notin> set ys\n  set ys \\<subseteq> set ops\n\ngoal (1 subgoal):\n 1. set ys \\<subseteq> set ops", "by blast"], ["proof (state)\nthis:\n  set ys \\<subseteq> set ops\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst (butlast xs)).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst (butlast xs)).\n            list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))", "moreover"], ["proof (state)\nthis:\n  set ys \\<subseteq> set ops\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst (butlast xs)).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst (butlast xs)).\n            list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))", "have \"hd (butlast xs) = hd xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (butlast xs) = hd xs", "by (metis append_butlast_last_id calculation(2) hd_append2 insert_seq_nonempty snoc.prems(2))"], ["proof (state)\nthis:\n  hd (butlast xs) = hd xs\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst (butlast xs)).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst (butlast xs)).\n            list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))", "hence \"fst (hd (butlast xs)) < fst (hd ys)\""], ["proof (prove)\nusing this:\n  hd (butlast xs) = hd xs\n\ngoal (1 subgoal):\n 1. fst (hd (butlast xs)) < fst (hd ys)", "by (simp add: snoc.prems(9))"], ["proof (state)\nthis:\n  fst (hd (butlast xs)) < fst (hd ys)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst (butlast xs)).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst (butlast xs)).\n            list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))", "moreover"], ["proof (state)\nthis:\n  fst (hd (butlast xs)) < fst (hd ys)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst (butlast xs)).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst (butlast xs)).\n            list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))", "have \"\\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "assume \"start = Some r\""], ["proof (state)\nthis:\n  start = Some r\n\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "then"], ["proof (chain)\npicking this:\n  start = Some r", "obtain xid where \"hd xs = (xid, Some r)\""], ["proof (prove)\nusing this:\n  start = Some r\n\ngoal (1 subgoal):\n 1. (\\<And>xid.\n        hd xs = (xid, Some r) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using insert_seq_hd snoc.prems(2)"], ["proof (prove)\nusing this:\n  start = Some r\n  insert_seq ?start ?xs \\<Longrightarrow>\n  \\<exists>oid. hd ?xs = (oid, ?start)\n  insert_seq start xs\n\ngoal (1 subgoal):\n 1. (\\<And>xid.\n        hd xs = (xid, Some r) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  hd xs = (xid, Some r)\n\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "hence \"r < xid\""], ["proof (prove)\nusing this:\n  hd xs = (xid, Some r)\n\ngoal (1 subgoal):\n 1. r < xid", "by (metis hd_in_set insert_ops_memb_ref_older insert_seq_nonempty snoc.prems(2) snoc.prems(3))"], ["proof (state)\nthis:\n  r < xid\n\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "moreover"], ["proof (state)\nthis:\n  r < xid\n\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "have \"xid < fst a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xid < fst a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. xid < fst a", "have \"xs = (butlast xs) @ [a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = butlast xs @ [a]", "using snoc.prems(2) insert_seq_nonempty \\<open>a = last xs\\<close>"], ["proof (prove)\nusing this:\n  insert_seq start xs\n  insert_seq ?start ?xs \\<Longrightarrow> ?xs \\<noteq> []\n  a = last xs\n\ngoal (1 subgoal):\n 1. xs = butlast xs @ [a]", "by fastforce"], ["proof (state)\nthis:\n  xs = butlast xs @ [a]\n\ngoal (1 subgoal):\n 1. xid < fst a", "moreover"], ["proof (state)\nthis:\n  xs = butlast xs @ [a]\n\ngoal (1 subgoal):\n 1. xid < fst a", "have \"(xid, Some r) \\<in> set (butlast xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xid, Some r) \\<in> set (butlast xs)", "using \\<open>hd xs = (xid, Some r)\\<close> insert_seq_nonempty list.set_sel(1) snoc.prems(2)"], ["proof (prove)\nusing this:\n  hd xs = (xid, Some r)\n  insert_seq ?start ?xs \\<Longrightarrow> ?xs \\<noteq> []\n  ?a \\<noteq> [] \\<Longrightarrow> hd ?a \\<in> set ?a\n  insert_seq start xs\n\ngoal (1 subgoal):\n 1. (xid, Some r) \\<in> set (butlast xs)", "by (metis \\<open>hd (butlast xs) = hd xs\\<close> \\<open>insert_seq start (butlast xs)\\<close>)"], ["proof (state)\nthis:\n  (xid, Some r) \\<in> set (butlast xs)\n\ngoal (1 subgoal):\n 1. xid < fst a", "hence \"xid \\<in> set (map fst (butlast xs))\""], ["proof (prove)\nusing this:\n  (xid, Some r) \\<in> set (butlast xs)\n\ngoal (1 subgoal):\n 1. xid \\<in> set (map fst (butlast xs))", "by (metis in_set_zipE zip_map_fst_snd)"], ["proof (state)\nthis:\n  xid \\<in> set (map fst (butlast xs))\n\ngoal (1 subgoal):\n 1. xid < fst a", "ultimately"], ["proof (chain)\npicking this:\n  xs = butlast xs @ [a]\n  xid \\<in> set (map fst (butlast xs))", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = butlast xs @ [a]\n  xid \\<in> set (map fst (butlast xs))\n\ngoal (1 subgoal):\n 1. xid < fst a", "using snoc.prems(3) last_op_greatest"], ["proof (prove)\nusing this:\n  xs = butlast xs @ [a]\n  xid \\<in> set (map fst (butlast xs))\n  insert_ops xs\n  \\<lbrakk>insert_ops (?op_list @ [(?oid, ?oper)]);\n   ?x \\<in> set (map fst ?op_list)\\<rbrakk>\n  \\<Longrightarrow> ?x < ?oid\n\ngoal (1 subgoal):\n 1. xid < fst a", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  xid < fst a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xid < fst a\n\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "ultimately"], ["proof (chain)\npicking this:\n  r < xid\n  xid < fst a", "have \"r \\<noteq> fst a\""], ["proof (prove)\nusing this:\n  r < xid\n  xid < fst a\n\ngoal (1 subgoal):\n 1. r \\<noteq> fst a", "using dual_order.asym"], ["proof (prove)\nusing this:\n  r < xid\n  xid < fst a\n  \\<lbrakk>?b < ?a; ?a < ?b\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. r \\<noteq> fst a", "by blast"], ["proof (state)\nthis:\n  r \\<noteq> fst a\n\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "thus \"r \\<in> set (interp_ins ops)\""], ["proof (prove)\nusing this:\n  r \\<noteq> fst a\n\ngoal (1 subgoal):\n 1. r \\<in> set (interp_ins ops)", "using snoc.prems(1) snoc.prems(10) interp_ins_maybe_grow2 \\<open>start = Some r\\<close>"], ["proof (prove)\nusing this:\n  r \\<noteq> fst a\n  insert_ops (ops @ [a])\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins (ops @ [a]))\n  insert_ops (?xs @ [?x]) \\<Longrightarrow>\n  set (interp_ins (?xs @ [?x])) = set (interp_ins ?xs) \\<or>\n  set (interp_ins (?xs @ [?x])) = set (interp_ins ?xs) \\<union> {fst ?x}\n  start = Some r\n\ngoal (1 subgoal):\n 1. r \\<in> set (interp_ins ops)", "by blast"], ["proof (state)\nthis:\n  r \\<in> set (interp_ins ops)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst (butlast xs)).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst (butlast xs)).\n            list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))", "ultimately"], ["proof (chain)\npicking this:\n  set (butlast xs) \\<subseteq> set ops\n  insert_seq start (butlast xs)\n  insert_ops (butlast xs)\n  distinct (map fst (butlast xs) @ map fst ys)\n  set ys \\<subseteq> set ops\n  fst (hd (butlast xs)) < fst (hd ys)\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins ops)", "show ?thesis"], ["proof (prove)\nusing this:\n  set (butlast xs) \\<subseteq> set ops\n  insert_seq start (butlast xs)\n  insert_ops (butlast xs)\n  distinct (map fst (butlast xs) @ map fst ys)\n  set ys \\<subseteq> set ops\n  fst (hd (butlast xs)) < fst (hd ys)\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set (map fst (butlast xs)).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst (butlast xs)).\n            list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))", "using \\<open>insert_ops ops\\<close> snoc.IH snoc.prems(4) snoc.prems(5)"], ["proof (prove)\nusing this:\n  set (butlast xs) \\<subseteq> set ops\n  insert_seq start (butlast xs)\n  insert_ops (butlast xs)\n  distinct (map fst (butlast xs) @ map fst ys)\n  set ys \\<subseteq> set ops\n  fst (hd (butlast xs)) < fst (hd ys)\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins ops)\n  insert_ops ops\n  \\<lbrakk>insert_ops ops; insert_seq start ?xs; insert_ops ?xs;\n   insert_seq start ?ys; insert_ops ?ys; set ?xs \\<subseteq> set ops;\n   set ?ys \\<subseteq> set ops; distinct (map fst ?xs @ map fst ?ys);\n   fst (hd ?xs) < fst (hd ?ys);\n   \\<And>r.\n      start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>x\\<in>set (map fst ?xs).\n                        \\<forall>y\\<in>set (map fst ?ys).\n                           list_order ops y x) \\<and>\n                    (\\<forall>r.\n                        start = Some r \\<longrightarrow>\n                        (\\<forall>a\\<in>set (map fst ?xs).\n                            list_order ops r a) \\<and>\n                        (\\<forall>a\\<in>set (map fst ?ys).\n                            list_order ops r a))\n  insert_seq start ys\n  insert_ops ys\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set (map fst (butlast xs)).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst (butlast xs)).\n            list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))", "by blast"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>set (map fst (butlast xs)).\n      \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n  (\\<forall>r.\n      start = Some r \\<longrightarrow>\n      (\\<forall>x\\<in>set (map fst (butlast xs)). list_order ops r x) \\<and>\n      (\\<forall>y\\<in>set (map fst ys). list_order ops r y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>set (map fst (butlast xs)).\n      \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n  (\\<forall>r.\n      start = Some r \\<longrightarrow>\n      (\\<forall>x\\<in>set (map fst (butlast xs)). list_order ops r x) \\<and>\n      (\\<forall>y\\<in>set (map fst ys). list_order ops r y))\n\ngoal (3 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 2. a \\<in> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 3. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "moreover"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>set (map fst (butlast xs)).\n      \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n  (\\<forall>r.\n      start = Some r \\<longrightarrow>\n      (\\<forall>x\\<in>set (map fst (butlast xs)). list_order ops r x) \\<and>\n      (\\<forall>y\\<in>set (map fst ys). list_order ops r y))\n\ngoal (3 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 2. a \\<in> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 3. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "have x_exists: \"\\<forall>x \\<in> set (map fst (butlast xs)). x \\<in> set (interp_ins ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map fst (butlast xs)). x \\<in> set (interp_ins ops)", "proof(cases start)"], ["proof (state)\ngoal (2 subgoals):\n 1. start = None \\<Longrightarrow>\n    \\<forall>x\\<in>set (map fst (butlast xs)). x \\<in> set (interp_ins ops)\n 2. \\<And>a.\n       start = Some a \\<Longrightarrow>\n       \\<forall>x\\<in>set (map fst (butlast xs)).\n          x \\<in> set (interp_ins ops)", "case None"], ["proof (state)\nthis:\n  start = None\n\ngoal (2 subgoals):\n 1. start = None \\<Longrightarrow>\n    \\<forall>x\\<in>set (map fst (butlast xs)). x \\<in> set (interp_ins ops)\n 2. \\<And>a.\n       start = Some a \\<Longrightarrow>\n       \\<forall>x\\<in>set (map fst (butlast xs)).\n          x \\<in> set (interp_ins ops)", "moreover"], ["proof (state)\nthis:\n  start = None\n\ngoal (2 subgoals):\n 1. start = None \\<Longrightarrow>\n    \\<forall>x\\<in>set (map fst (butlast xs)). x \\<in> set (interp_ins ops)\n 2. \\<And>a.\n       start = Some a \\<Longrightarrow>\n       \\<forall>x\\<in>set (map fst (butlast xs)).\n          x \\<in> set (interp_ins ops)", "have \"set (butlast xs) \\<subseteq> set ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (butlast xs) \\<subseteq> set ops", "using \\<open>a = last xs\\<close> distinct_map snoc.prems(6) snoc.prems(8) subset_butlast"], ["proof (prove)\nusing this:\n  a = last xs\n  distinct (map ?f ?xs) = (distinct ?xs \\<and> inj_on ?f (set ?xs))\n  set xs \\<subseteq> set (ops @ [a])\n  distinct (map fst xs @ map fst ys)\n  \\<lbrakk>set ?xs \\<subseteq> set (?ys @ [?y]); last ?xs = ?y;\n   distinct ?xs\\<rbrakk>\n  \\<Longrightarrow> set (butlast ?xs) \\<subseteq> set ?ys\n\ngoal (1 subgoal):\n 1. set (butlast xs) \\<subseteq> set ops", "by fastforce"], ["proof (state)\nthis:\n  set (butlast xs) \\<subseteq> set ops\n\ngoal (2 subgoals):\n 1. start = None \\<Longrightarrow>\n    \\<forall>x\\<in>set (map fst (butlast xs)). x \\<in> set (interp_ins ops)\n 2. \\<And>a.\n       start = Some a \\<Longrightarrow>\n       \\<forall>x\\<in>set (map fst (butlast xs)).\n          x \\<in> set (interp_ins ops)", "ultimately"], ["proof (chain)\npicking this:\n  start = None\n  set (butlast xs) \\<subseteq> set ops", "show ?thesis"], ["proof (prove)\nusing this:\n  start = None\n  set (butlast xs) \\<subseteq> set ops\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map fst (butlast xs)). x \\<in> set (interp_ins ops)", "using insert_seq_start_none \\<open>insert_ops ops\\<close> snoc.prems"], ["proof (prove)\nusing this:\n  start = None\n  set (butlast xs) \\<subseteq> set ops\n  \\<lbrakk>insert_ops ?ops; insert_seq None ?xs; insert_ops ?xs;\n   set ?xs \\<subseteq> set ?ops\\<rbrakk>\n  \\<Longrightarrow> \\<forall>i\\<in>set (map fst ?xs).\n                       i \\<in> set (interp_ins ?ops)\n  insert_ops ops\n  insert_ops (ops @ [a])\n  insert_seq start xs\n  insert_ops xs\n  insert_seq start ys\n  insert_ops ys\n  set xs \\<subseteq> set (ops @ [a])\n  set ys \\<subseteq> set (ops @ [a])\n  distinct (map fst xs @ map fst ys)\n  fst (hd xs) < fst (hd ys)\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins (ops @ [a]))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map fst (butlast xs)). x \\<in> set (interp_ins ops)", "by (metis append_butlast_last_id butlast.simps(2) empty_iff empty_set\n            insert_ops_rem_last insert_seq_butlast insert_seq_nonempty list.simps(8))"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map fst (butlast xs)). x \\<in> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       start = Some a \\<Longrightarrow>\n       \\<forall>x\\<in>set (map fst (butlast xs)).\n          x \\<in> set (interp_ins ops)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       start = Some a \\<Longrightarrow>\n       \\<forall>x\\<in>set (map fst (butlast xs)).\n          x \\<in> set (interp_ins ops)", "case (Some a)"], ["proof (state)\nthis:\n  start = Some a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       start = Some a \\<Longrightarrow>\n       \\<forall>x\\<in>set (map fst (butlast xs)).\n          x \\<in> set (interp_ins ops)", "then"], ["proof (chain)\npicking this:\n  start = Some a", "show ?thesis"], ["proof (prove)\nusing this:\n  start = Some a\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map fst (butlast xs)). x \\<in> set (interp_ins ops)", "using IH list_order_memb2"], ["proof (prove)\nusing this:\n  start = Some a\n  (\\<forall>x\\<in>set (map fst (butlast xs)).\n      \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n  (\\<forall>r.\n      start = Some r \\<longrightarrow>\n      (\\<forall>x\\<in>set (map fst (butlast xs)). list_order ops r x) \\<and>\n      (\\<forall>y\\<in>set (map fst ys). list_order ops r y))\n  list_order ?ops ?x ?y \\<Longrightarrow> ?y \\<in> set (interp_ins ?ops)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map fst (butlast xs)). x \\<in> set (interp_ins ops)", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map fst (butlast xs)). x \\<in> set (interp_ins ops)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map fst (butlast xs)). x \\<in> set (interp_ins ops)\n\ngoal (3 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 2. a \\<in> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 3. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "moreover"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map fst (butlast xs)). x \\<in> set (interp_ins ops)\n\ngoal (3 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 2. a \\<in> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 3. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "have \"\\<forall>y \\<in> set (map fst ys). list_order (ops @ [a]) y (fst a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y (fst a)", "proof(cases \"xs = [a]\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [a] \\<Longrightarrow>\n    \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y (fst a)\n 2. xs \\<noteq> [a] \\<Longrightarrow>\n    \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y (fst a)", "case xs_a: True"], ["proof (state)\nthis:\n  xs = [a]\n\ngoal (2 subgoals):\n 1. xs = [a] \\<Longrightarrow>\n    \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y (fst a)\n 2. xs \\<noteq> [a] \\<Longrightarrow>\n    \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y (fst a)", "have \"ys \\<noteq> [] \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<noteq> [] \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ys \\<noteq> [] \\<Longrightarrow> False", "assume \"ys \\<noteq> []\""], ["proof (state)\nthis:\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [] \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  ys \\<noteq> []", "obtain yi where yi_def: \"ys = (yi, start) # (tl ys)\""], ["proof (prove)\nusing this:\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>yi.\n        ys = (yi, start) # tl ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis hd_Cons_tl insert_seq_hd snoc.prems(4))"], ["proof (state)\nthis:\n  ys = (yi, start) # tl ys\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [] \\<Longrightarrow> False", "hence \"(yi, start) \\<in> set ops\""], ["proof (prove)\nusing this:\n  ys = (yi, start) # tl ys\n\ngoal (1 subgoal):\n 1. (yi, start) \\<in> set ops", "by (metis \\<open>set ys \\<subseteq> set ops\\<close> list.set_intros(1) subsetCE)"], ["proof (state)\nthis:\n  (yi, start) \\<in> set ops\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [] \\<Longrightarrow> False", "hence \"yi \\<in> set (map fst ops)\""], ["proof (prove)\nusing this:\n  (yi, start) \\<in> set ops\n\ngoal (1 subgoal):\n 1. yi \\<in> set (map fst ops)", "by force"], ["proof (state)\nthis:\n  yi \\<in> set (map fst ops)\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [] \\<Longrightarrow> False", "hence \"yi < fst a\""], ["proof (prove)\nusing this:\n  yi \\<in> set (map fst ops)\n\ngoal (1 subgoal):\n 1. yi < fst a", "using snoc.prems(1) last_op_greatest"], ["proof (prove)\nusing this:\n  yi \\<in> set (map fst ops)\n  insert_ops (ops @ [a])\n  \\<lbrakk>insert_ops (?op_list @ [(?oid, ?oper)]);\n   ?x \\<in> set (map fst ?op_list)\\<rbrakk>\n  \\<Longrightarrow> ?x < ?oid\n\ngoal (1 subgoal):\n 1. yi < fst a", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  yi < fst a\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [] \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  yi < fst a\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [] \\<Longrightarrow> False", "have \"fst a < yi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst a < yi", "by (metis yi_def xs_a fst_conv list.sel(1) snoc.prems(9))"], ["proof (state)\nthis:\n  fst a < yi\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [] \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  yi < fst a\n  fst a < yi", "show False"], ["proof (prove)\nusing this:\n  yi < fst a\n  fst a < yi\n\ngoal (1 subgoal):\n 1. False", "using less_not_sym"], ["proof (prove)\nusing this:\n  yi < fst a\n  fst a < yi\n  ?x < ?y \\<Longrightarrow> \\<not> ?y < ?x\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ys \\<noteq> [] \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. xs = [a] \\<Longrightarrow>\n    \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y (fst a)\n 2. xs \\<noteq> [a] \\<Longrightarrow>\n    \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y (fst a)", "then"], ["proof (chain)\npicking this:\n  ys \\<noteq> [] \\<Longrightarrow> False", "show \"\\<forall>y \\<in> set (map fst ys). list_order (ops @ [a]) y (fst a)\""], ["proof (prove)\nusing this:\n  ys \\<noteq> [] \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y (fst a)", "using insert_seq_nonempty snoc.prems(4)"], ["proof (prove)\nusing this:\n  ys \\<noteq> [] \\<Longrightarrow> False\n  insert_seq ?start ?xs \\<Longrightarrow> ?xs \\<noteq> []\n  insert_seq start ys\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y (fst a)", "by blast"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y (fst a)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [a] \\<Longrightarrow>\n    \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y (fst a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> [a] \\<Longrightarrow>\n    \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y (fst a)", "case xs_longer: False"], ["proof (state)\nthis:\n  xs \\<noteq> [a]\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [a] \\<Longrightarrow>\n    \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y (fst a)", "hence butlast_split: \"butlast xs = (butlast (butlast xs)) @ [last (butlast xs)]\""], ["proof (prove)\nusing this:\n  xs \\<noteq> [a]\n\ngoal (1 subgoal):\n 1. butlast xs = butlast (butlast xs) @ [last (butlast xs)]", "using \\<open>a = last xs\\<close> insert_seq_butlast insert_seq_nonempty snoc.prems(2)"], ["proof (prove)\nusing this:\n  xs \\<noteq> [a]\n  a = last xs\n  \\<lbrakk>insert_seq ?start ?xs; ?xs \\<noteq> [];\n   ?xs \\<noteq> [last ?xs]\\<rbrakk>\n  \\<Longrightarrow> insert_seq ?start (butlast ?xs)\n  insert_seq ?start ?xs \\<Longrightarrow> ?xs \\<noteq> []\n  insert_seq start xs\n\ngoal (1 subgoal):\n 1. butlast xs = butlast (butlast xs) @ [last (butlast xs)]", "by fastforce"], ["proof (state)\nthis:\n  butlast xs = butlast (butlast xs) @ [last (butlast xs)]\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [a] \\<Longrightarrow>\n    \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y (fst a)", "hence ref_exists: \"fst (last (butlast xs)) \\<in> set (interp_ins ops)\""], ["proof (prove)\nusing this:\n  butlast xs = butlast (butlast xs) @ [last (butlast xs)]\n\ngoal (1 subgoal):\n 1. fst (last (butlast xs)) \\<in> set (interp_ins ops)", "using x_exists"], ["proof (prove)\nusing this:\n  butlast xs = butlast (butlast xs) @ [last (butlast xs)]\n  \\<forall>x\\<in>set (map fst (butlast xs)). x \\<in> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. fst (last (butlast xs)) \\<in> set (interp_ins ops)", "by (metis last_in_set last_map map_is_Nil_conv snoc_eq_iff_butlast)"], ["proof (state)\nthis:\n  fst (last (butlast xs)) \\<in> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [a] \\<Longrightarrow>\n    \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y (fst a)", "moreover"], ["proof (state)\nthis:\n  fst (last (butlast xs)) \\<in> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [a] \\<Longrightarrow>\n    \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y (fst a)", "from butlast_split"], ["proof (chain)\npicking this:\n  butlast xs = butlast (butlast xs) @ [last (butlast xs)]", "have \"xs = (butlast (butlast xs)) @ [last (butlast xs), a]\""], ["proof (prove)\nusing this:\n  butlast xs = butlast (butlast xs) @ [last (butlast xs)]\n\ngoal (1 subgoal):\n 1. xs = butlast (butlast xs) @ [last (butlast xs), a]", "by (metis \\<open>a = last xs\\<close> append.assoc append_butlast_last_id butlast.simps(2)\n            insert_seq_nonempty last_ConsL last_ConsR list.simps(3) snoc.prems(2))"], ["proof (state)\nthis:\n  xs = butlast (butlast xs) @ [last (butlast xs), a]\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [a] \\<Longrightarrow>\n    \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y (fst a)", "hence \"snd a = Some (fst (last (butlast xs)))\""], ["proof (prove)\nusing this:\n  xs = butlast (butlast xs) @ [last (butlast xs), a]\n\ngoal (1 subgoal):\n 1. snd a = Some (fst (last (butlast xs)))", "using snoc.prems(2) insert_seq_last_ref"], ["proof (prove)\nusing this:\n  xs = butlast (butlast xs) @ [last (butlast xs), a]\n  insert_seq start xs\n  insert_seq ?start (?xs @ [(?xi, ?xr), (?yi, ?yr)]) \\<Longrightarrow>\n  ?yr = Some ?xi\n\ngoal (1 subgoal):\n 1. snd a = Some (fst (last (butlast xs)))", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  snd a = Some (fst (last (butlast xs)))\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [a] \\<Longrightarrow>\n    \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y (fst a)", "hence \"list_order (ops @ [a]) (fst (last (butlast xs))) (fst a)\""], ["proof (prove)\nusing this:\n  snd a = Some (fst (last (butlast xs)))\n\ngoal (1 subgoal):\n 1. list_order (ops @ [a]) (fst (last (butlast xs))) (fst a)", "using list_order_insert_ref ref_exists snoc.prems(1)"], ["proof (prove)\nusing this:\n  snd a = Some (fst (last (butlast xs)))\n  \\<lbrakk>insert_ops (?ops @ [(?oid, Some ?ref)]);\n   ?ref \\<in> set (interp_ins ?ops)\\<rbrakk>\n  \\<Longrightarrow> list_order (?ops @ [(?oid, Some ?ref)]) ?ref ?oid\n  fst (last (butlast xs)) \\<in> set (interp_ins ops)\n  insert_ops (ops @ [a])\n\ngoal (1 subgoal):\n 1. list_order (ops @ [a]) (fst (last (butlast xs))) (fst a)", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  list_order (ops @ [a]) (fst (last (butlast xs))) (fst a)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [a] \\<Longrightarrow>\n    \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y (fst a)", "moreover"], ["proof (state)\nthis:\n  list_order (ops @ [a]) (fst (last (butlast xs))) (fst a)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [a] \\<Longrightarrow>\n    \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y (fst a)", "have \"\\<forall>y \\<in> set (map fst ys). list_order ops y (fst (last (butlast xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set (map fst ys).\n       list_order ops y (fst (last (butlast xs)))", "by (metis IH butlast_split last_in_set last_map map_is_Nil_conv snoc_eq_iff_butlast)"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set (map fst ys).\n     list_order ops y (fst (last (butlast xs)))\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [a] \\<Longrightarrow>\n    \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y (fst a)", "hence \"\\<forall>y \\<in> set (map fst ys). list_order (ops @ [a]) y (fst (last (butlast xs)))\""], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>set (map fst ys).\n     list_order ops y (fst (last (butlast xs)))\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set (map fst ys).\n       list_order (ops @ [a]) y (fst (last (butlast xs)))", "using list_order_append snoc.prems(1)"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>set (map fst ys).\n     list_order ops y (fst (last (butlast xs)))\n  \\<lbrakk>insert_ops (?pre @ ?suf); list_order ?pre ?x ?y\\<rbrakk>\n  \\<Longrightarrow> list_order (?pre @ ?suf) ?x ?y\n  insert_ops (ops @ [a])\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set (map fst ys).\n       list_order (ops @ [a]) y (fst (last (butlast xs)))", "by blast"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set (map fst ys).\n     list_order (ops @ [a]) y (fst (last (butlast xs)))\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [a] \\<Longrightarrow>\n    \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y (fst a)", "ultimately"], ["proof (chain)\npicking this:\n  fst (last (butlast xs)) \\<in> set (interp_ins ops)\n  list_order (ops @ [a]) (fst (last (butlast xs))) (fst a)\n  \\<forall>y\\<in>set (map fst ys).\n     list_order (ops @ [a]) y (fst (last (butlast xs)))", "show \"\\<forall>y \\<in> set (map fst ys). list_order (ops @ [a]) y (fst a)\""], ["proof (prove)\nusing this:\n  fst (last (butlast xs)) \\<in> set (interp_ins ops)\n  list_order (ops @ [a]) (fst (last (butlast xs))) (fst a)\n  \\<forall>y\\<in>set (map fst ys).\n     list_order (ops @ [a]) y (fst (last (butlast xs)))\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y (fst a)", "using list_order_trans snoc.prems(1)"], ["proof (prove)\nusing this:\n  fst (last (butlast xs)) \\<in> set (interp_ins ops)\n  list_order (ops @ [a]) (fst (last (butlast xs))) (fst a)\n  \\<forall>y\\<in>set (map fst ys).\n     list_order (ops @ [a]) y (fst (last (butlast xs)))\n  \\<lbrakk>insert_ops ?op_list; list_order ?op_list ?x ?y;\n   list_order ?op_list ?y ?z\\<rbrakk>\n  \\<Longrightarrow> list_order ?op_list ?x ?z\n  insert_ops (ops @ [a])\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y (fst a)", "by blast"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y (fst a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y (fst a)\n\ngoal (3 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 2. a \\<in> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 3. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "moreover"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y (fst a)\n\ngoal (3 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 2. a \\<in> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 3. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "have map_fst_xs: \"map fst xs = map fst (butlast xs) @ map fst [last xs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst xs = map fst (butlast xs) @ map fst [last xs]", "by (metis append_butlast_last_id insert_seq_nonempty map_append snoc.prems(2))"], ["proof (state)\nthis:\n  map fst xs = map fst (butlast xs) @ map fst [last xs]\n\ngoal (3 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 2. a \\<in> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 3. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "hence \"set (map fst xs) = set (map fst (butlast xs)) \\<union> {fst a}\""], ["proof (prove)\nusing this:\n  map fst xs = map fst (butlast xs) @ map fst [last xs]\n\ngoal (1 subgoal):\n 1. set (map fst xs) = set (map fst (butlast xs)) \\<union> {fst a}", "by (simp add: \\<open>a = last xs\\<close>)"], ["proof (state)\nthis:\n  set (map fst xs) = set (map fst (butlast xs)) \\<union> {fst a}\n\ngoal (3 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 2. a \\<in> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 3. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "moreover"], ["proof (state)\nthis:\n  set (map fst xs) = set (map fst (butlast xs)) \\<union> {fst a}\n\ngoal (3 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 2. a \\<in> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 3. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "have \"\\<forall>r. start = Some r \\<longrightarrow> list_order (ops @ [a]) r (fst a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r.\n       start = Some r \\<longrightarrow> list_order (ops @ [a]) r (fst a)", "using snoc.prems"], ["proof (prove)\nusing this:\n  insert_ops (ops @ [a])\n  insert_seq start xs\n  insert_ops xs\n  insert_seq start ys\n  insert_ops ys\n  set xs \\<subseteq> set (ops @ [a])\n  set ys \\<subseteq> set (ops @ [a])\n  distinct (map fst xs @ map fst ys)\n  fst (hd xs) < fst (hd ys)\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins (ops @ [a]))\n\ngoal (1 subgoal):\n 1. \\<forall>r.\n       start = Some r \\<longrightarrow> list_order (ops @ [a]) r (fst a)", "by (cases start, auto simp add: insert_seq_after_start \\<open>a = last xs\\<close> map_fst_xs)"], ["proof (state)\nthis:\n  \\<forall>r.\n     start = Some r \\<longrightarrow> list_order (ops @ [a]) r (fst a)\n\ngoal (3 subgoals):\n 1. a \\<in> set xs \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 2. a \\<in> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 3. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "ultimately"], ["proof (chain)\npicking this:\n  (\\<forall>x\\<in>set (map fst (butlast xs)).\n      \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n  (\\<forall>r.\n      start = Some r \\<longrightarrow>\n      (\\<forall>x\\<in>set (map fst (butlast xs)). list_order ops r x) \\<and>\n      (\\<forall>y\\<in>set (map fst ys). list_order ops r y))\n  \\<forall>x\\<in>set (map fst (butlast xs)). x \\<in> set (interp_ins ops)\n  \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y (fst a)\n  set (map fst xs) = set (map fst (butlast xs)) \\<union> {fst a}\n  \\<forall>r.\n     start = Some r \\<longrightarrow> list_order (ops @ [a]) r (fst a)", "show \"(\\<forall>x \\<in> set (map fst xs). \\<forall>y \\<in> set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n          (\\<forall>r. start = Some r \\<longrightarrow> (\\<forall>x \\<in> set (map fst xs). list_order (ops @ [a]) r x) \\<and>\n                                  (\\<forall>y \\<in> set (map fst ys). list_order (ops @ [a]) r y))\""], ["proof (prove)\nusing this:\n  (\\<forall>x\\<in>set (map fst (butlast xs)).\n      \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n  (\\<forall>r.\n      start = Some r \\<longrightarrow>\n      (\\<forall>x\\<in>set (map fst (butlast xs)). list_order ops r x) \\<and>\n      (\\<forall>y\\<in>set (map fst ys). list_order ops r y))\n  \\<forall>x\\<in>set (map fst (butlast xs)). x \\<in> set (interp_ins ops)\n  \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y (fst a)\n  set (map fst xs) = set (map fst (butlast xs)) \\<union> {fst a}\n  \\<forall>r.\n     start = Some r \\<longrightarrow> list_order (ops @ [a]) r (fst a)\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) r y))", "using snoc.prems(1)"], ["proof (prove)\nusing this:\n  (\\<forall>x\\<in>set (map fst (butlast xs)).\n      \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n  (\\<forall>r.\n      start = Some r \\<longrightarrow>\n      (\\<forall>x\\<in>set (map fst (butlast xs)). list_order ops r x) \\<and>\n      (\\<forall>y\\<in>set (map fst ys). list_order ops r y))\n  \\<forall>x\\<in>set (map fst (butlast xs)). x \\<in> set (interp_ins ops)\n  \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y (fst a)\n  set (map fst xs) = set (map fst (butlast xs)) \\<union> {fst a}\n  \\<forall>r.\n     start = Some r \\<longrightarrow> list_order (ops @ [a]) r (fst a)\n  insert_ops (ops @ [a])\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) r y))", "by (simp add: list_order_append)"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>set (map fst xs).\n      \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n  (\\<forall>r.\n      start = Some r \\<longrightarrow>\n      (\\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) r x) \\<and>\n      (\\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) r y))\n\ngoal (2 subgoals):\n 1. a \\<in> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 2. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<in> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 2. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "case a_in_ys"], ["proof (state)\nthis:\n  a \\<in> set ys\n\ngoal (2 subgoals):\n 1. a \\<in> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 2. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "then"], ["proof (chain)\npicking this:\n  a \\<in> set ys", "have \"a \\<notin> set xs\""], ["proof (prove)\nusing this:\n  a \\<in> set ys\n\ngoal (1 subgoal):\n 1. a \\<notin> set xs", "using snoc.prems(8)"], ["proof (prove)\nusing this:\n  a \\<in> set ys\n  distinct (map fst xs @ map fst ys)\n\ngoal (1 subgoal):\n 1. a \\<notin> set xs", "by auto"], ["proof (state)\nthis:\n  a \\<notin> set xs\n\ngoal (2 subgoals):\n 1. a \\<in> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 2. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "hence \"set xs \\<subseteq> set ops\""], ["proof (prove)\nusing this:\n  a \\<notin> set xs\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> set ops", "using snoc.prems(6) DiffE"], ["proof (prove)\nusing this:\n  a \\<notin> set xs\n  set xs \\<subseteq> set (ops @ [a])\n  \\<lbrakk>?c \\<in> ?A - ?B;\n   \\<lbrakk>?c \\<in> ?A; ?c \\<notin> ?B\\<rbrakk>\n   \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> set ops", "by auto"], ["proof (state)\nthis:\n  set xs \\<subseteq> set ops\n\ngoal (2 subgoals):\n 1. a \\<in> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 2. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "from a_in_ys"], ["proof (chain)\npicking this:\n  a \\<in> set ys", "have \"a = last ys\""], ["proof (prove)\nusing this:\n  a \\<in> set ys\n\ngoal (1 subgoal):\n 1. a = last ys", "using insert_ops_subset_last snoc.prems"], ["proof (prove)\nusing this:\n  a \\<in> set ys\n  \\<lbrakk>insert_ops (?xs @ [?x]); insert_ops ?ys;\n   set ?ys \\<subseteq> set (?xs @ [?x]); ?x \\<in> set ?ys\\<rbrakk>\n  \\<Longrightarrow> ?x = last ?ys\n  insert_ops (ops @ [a])\n  insert_seq start xs\n  insert_ops xs\n  insert_seq start ys\n  insert_ops ys\n  set xs \\<subseteq> set (ops @ [a])\n  set ys \\<subseteq> set (ops @ [a])\n  distinct (map fst xs @ map fst ys)\n  fst (hd xs) < fst (hd ys)\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins (ops @ [a]))\n\ngoal (1 subgoal):\n 1. a = last ys", "by blast"], ["proof (state)\nthis:\n  a = last ys\n\ngoal (2 subgoals):\n 1. a \\<in> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 2. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "have IH: \"(\\<forall>x \\<in> set (map fst xs). \\<forall>y \\<in> set (map fst (butlast ys)).  list_order ops y x) \\<and>\n              (\\<forall>r. start = Some r \\<longrightarrow> (\\<forall>x \\<in> set (map fst          xs).  list_order ops r x) \\<and>\n                                      (\\<forall>y \\<in> set (map fst (butlast ys)). list_order ops r y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst (butlast ys)).\n           list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))", "proof(cases \"ys = [a]\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ys = [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst (butlast ys)).\n           list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))\n 2. ys \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst (butlast ys)).\n           list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))", "case True"], ["proof (state)\nthis:\n  ys = [a]\n\ngoal (2 subgoals):\n 1. ys = [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst (butlast ys)).\n           list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))\n 2. ys \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst (butlast ys)).\n           list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))", "moreover"], ["proof (state)\nthis:\n  ys = [a]\n\ngoal (2 subgoals):\n 1. ys = [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst (butlast ys)).\n           list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))\n 2. ys \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst (butlast ys)).\n           list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))", "have \"\\<forall>r. start = Some r \\<longrightarrow> (\\<forall>y \\<in> set (map fst xs). list_order ops r y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r.\n       start = Some r \\<longrightarrow>\n       (\\<forall>y\\<in>set (map fst xs). list_order ops r y)", "using insert_seq_after_start \\<open>insert_ops ops\\<close> \\<open>set xs \\<subseteq> set ops\\<close> snoc.prems"], ["proof (prove)\nusing this:\n  \\<lbrakk>insert_ops ?ops; insert_seq (Some ?ref) ?xs; insert_ops ?xs;\n   set ?xs \\<subseteq> set ?ops; ?ref \\<in> set (interp_ins ?ops)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>i\\<in>set (map fst ?xs). list_order ?ops ?ref i\n  insert_ops ops\n  set xs \\<subseteq> set ops\n  insert_ops (ops @ [a])\n  insert_seq start xs\n  insert_ops xs\n  insert_seq start ys\n  insert_ops ys\n  set xs \\<subseteq> set (ops @ [a])\n  set ys \\<subseteq> set (ops @ [a])\n  distinct (map fst xs @ map fst ys)\n  fst (hd xs) < fst (hd ys)\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins (ops @ [a]))\n\ngoal (1 subgoal):\n 1. \\<forall>r.\n       start = Some r \\<longrightarrow>\n       (\\<forall>y\\<in>set (map fst xs). list_order ops r y)", "by (metis append_Nil2 calculation insert_seq_hd interp_ins_append_non_memb list.sel(1))"], ["proof (state)\nthis:\n  \\<forall>r.\n     start = Some r \\<longrightarrow>\n     (\\<forall>y\\<in>set (map fst xs). list_order ops r y)\n\ngoal (2 subgoals):\n 1. ys = [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst (butlast ys)).\n           list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))\n 2. ys \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst (butlast ys)).\n           list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))", "ultimately"], ["proof (chain)\npicking this:\n  ys = [a]\n  \\<forall>r.\n     start = Some r \\<longrightarrow>\n     (\\<forall>y\\<in>set (map fst xs). list_order ops r y)", "show ?thesis"], ["proof (prove)\nusing this:\n  ys = [a]\n  \\<forall>r.\n     start = Some r \\<longrightarrow>\n     (\\<forall>y\\<in>set (map fst xs). list_order ops r y)\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst (butlast ys)).\n           list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))", "by auto"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>set (map fst xs).\n      \\<forall>y\\<in>set (map fst (butlast ys)). list_order ops y x) \\<and>\n  (\\<forall>r.\n      start = Some r \\<longrightarrow>\n      (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n      (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst (butlast ys)).\n           list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ys \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst (butlast ys)).\n           list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))", "case ys_longer: False"], ["proof (state)\nthis:\n  ys \\<noteq> [a]\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst (butlast ys)).\n           list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))", "from \\<open>a = last ys\\<close>"], ["proof (chain)\npicking this:\n  a = last ys", "have \"set (butlast ys) \\<subseteq> set ops\""], ["proof (prove)\nusing this:\n  a = last ys\n\ngoal (1 subgoal):\n 1. set (butlast ys) \\<subseteq> set ops", "using snoc.prems"], ["proof (prove)\nusing this:\n  a = last ys\n  insert_ops (ops @ [a])\n  insert_seq start xs\n  insert_ops xs\n  insert_seq start ys\n  insert_ops ys\n  set xs \\<subseteq> set (ops @ [a])\n  set ys \\<subseteq> set (ops @ [a])\n  distinct (map fst xs @ map fst ys)\n  fst (hd xs) < fst (hd ys)\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins (ops @ [a]))\n\ngoal (1 subgoal):\n 1. set (butlast ys) \\<subseteq> set ops", "by (simp add: distinct_fst subset_butlast)"], ["proof (state)\nthis:\n  set (butlast ys) \\<subseteq> set ops\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst (butlast ys)).\n           list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))", "moreover"], ["proof (state)\nthis:\n  set (butlast ys) \\<subseteq> set ops\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst (butlast ys)).\n           list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))", "have \"insert_seq start (butlast ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_seq start (butlast ys)", "using insert_seq_butlast insert_seq_nonempty ys_longer \\<open>a = last ys\\<close> snoc.prems(4)"], ["proof (prove)\nusing this:\n  \\<lbrakk>insert_seq ?start ?xs; ?xs \\<noteq> [];\n   ?xs \\<noteq> [last ?xs]\\<rbrakk>\n  \\<Longrightarrow> insert_seq ?start (butlast ?xs)\n  insert_seq ?start ?xs \\<Longrightarrow> ?xs \\<noteq> []\n  ys \\<noteq> [a]\n  a = last ys\n  insert_seq start ys\n\ngoal (1 subgoal):\n 1. insert_seq start (butlast ys)", "by blast"], ["proof (state)\nthis:\n  insert_seq start (butlast ys)\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst (butlast ys)).\n           list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))", "moreover"], ["proof (state)\nthis:\n  insert_seq start (butlast ys)\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst (butlast ys)).\n           list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))", "have \"insert_ops (butlast ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_ops (butlast ys)", "using snoc.prems(4) snoc.prems(5) insert_ops_appendD"], ["proof (prove)\nusing this:\n  insert_seq start ys\n  insert_ops ys\n  insert_ops (?xs @ ?ys) \\<Longrightarrow> insert_ops ?xs\n\ngoal (1 subgoal):\n 1. insert_ops (butlast ys)", "by (metis append_butlast_last_id insert_seq_nonempty)"], ["proof (state)\nthis:\n  insert_ops (butlast ys)\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst (butlast ys)).\n           list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))", "moreover"], ["proof (state)\nthis:\n  insert_ops (butlast ys)\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst (butlast ys)).\n           list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))", "have \"distinct (map fst xs @ map fst (butlast ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst xs @ map fst (butlast ys))", "using distinct_append_butlast2 snoc.prems(8)"], ["proof (prove)\nusing this:\n  distinct (map fst ?xs @ map fst ?ys) \\<Longrightarrow>\n  distinct (map fst ?xs @ map fst (butlast ?ys))\n  distinct (map fst xs @ map fst ys)\n\ngoal (1 subgoal):\n 1. distinct (map fst xs @ map fst (butlast ys))", "by blast"], ["proof (state)\nthis:\n  distinct (map fst xs @ map fst (butlast ys))\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst (butlast ys)).\n           list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))", "moreover"], ["proof (state)\nthis:\n  distinct (map fst xs @ map fst (butlast ys))\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst (butlast ys)).\n           list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))", "have \"set xs \\<subseteq> set ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<subseteq> set ops", "using \\<open>a \\<notin> set xs\\<close> \\<open>set xs \\<subseteq> set ops\\<close>"], ["proof (prove)\nusing this:\n  a \\<notin> set xs\n  set xs \\<subseteq> set ops\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> set ops", "by blast"], ["proof (state)\nthis:\n  set xs \\<subseteq> set ops\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst (butlast ys)).\n           list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))", "moreover"], ["proof (state)\nthis:\n  set xs \\<subseteq> set ops\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst (butlast ys)).\n           list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))", "have \"hd (butlast ys) = hd ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (butlast ys) = hd ys", "by (metis append_butlast_last_id calculation(2) hd_append2 insert_seq_nonempty snoc.prems(4))"], ["proof (state)\nthis:\n  hd (butlast ys) = hd ys\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst (butlast ys)).\n           list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))", "hence \"fst (hd xs) < fst (hd (butlast ys))\""], ["proof (prove)\nusing this:\n  hd (butlast ys) = hd ys\n\ngoal (1 subgoal):\n 1. fst (hd xs) < fst (hd (butlast ys))", "by (simp add: snoc.prems(9))"], ["proof (state)\nthis:\n  fst (hd xs) < fst (hd (butlast ys))\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst (butlast ys)).\n           list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))", "moreover"], ["proof (state)\nthis:\n  fst (hd xs) < fst (hd (butlast ys))\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst (butlast ys)).\n           list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))", "have \"\\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "assume \"start = Some r\""], ["proof (state)\nthis:\n  start = Some r\n\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "then"], ["proof (chain)\npicking this:\n  start = Some r", "obtain yid where \"hd ys = (yid, Some r)\""], ["proof (prove)\nusing this:\n  start = Some r\n\ngoal (1 subgoal):\n 1. (\\<And>yid.\n        hd ys = (yid, Some r) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using insert_seq_hd snoc.prems(4)"], ["proof (prove)\nusing this:\n  start = Some r\n  insert_seq ?start ?xs \\<Longrightarrow>\n  \\<exists>oid. hd ?xs = (oid, ?start)\n  insert_seq start ys\n\ngoal (1 subgoal):\n 1. (\\<And>yid.\n        hd ys = (yid, Some r) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  hd ys = (yid, Some r)\n\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "hence \"r < yid\""], ["proof (prove)\nusing this:\n  hd ys = (yid, Some r)\n\ngoal (1 subgoal):\n 1. r < yid", "by (metis hd_in_set insert_ops_memb_ref_older insert_seq_nonempty snoc.prems(4) snoc.prems(5))"], ["proof (state)\nthis:\n  r < yid\n\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "moreover"], ["proof (state)\nthis:\n  r < yid\n\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "have \"yid < fst a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. yid < fst a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. yid < fst a", "have \"ys = (butlast ys) @ [a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys = butlast ys @ [a]", "using snoc.prems(4) insert_seq_nonempty \\<open>a = last ys\\<close>"], ["proof (prove)\nusing this:\n  insert_seq start ys\n  insert_seq ?start ?xs \\<Longrightarrow> ?xs \\<noteq> []\n  a = last ys\n\ngoal (1 subgoal):\n 1. ys = butlast ys @ [a]", "by fastforce"], ["proof (state)\nthis:\n  ys = butlast ys @ [a]\n\ngoal (1 subgoal):\n 1. yid < fst a", "moreover"], ["proof (state)\nthis:\n  ys = butlast ys @ [a]\n\ngoal (1 subgoal):\n 1. yid < fst a", "have \"(yid, Some r) \\<in> set (butlast ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (yid, Some r) \\<in> set (butlast ys)", "using \\<open>hd ys = (yid, Some r)\\<close> insert_seq_nonempty list.set_sel(1) snoc.prems(2)"], ["proof (prove)\nusing this:\n  hd ys = (yid, Some r)\n  insert_seq ?start ?xs \\<Longrightarrow> ?xs \\<noteq> []\n  ?a \\<noteq> [] \\<Longrightarrow> hd ?a \\<in> set ?a\n  insert_seq start xs\n\ngoal (1 subgoal):\n 1. (yid, Some r) \\<in> set (butlast ys)", "by (metis \\<open>hd (butlast ys) = hd ys\\<close> \\<open>insert_seq start (butlast ys)\\<close>)"], ["proof (state)\nthis:\n  (yid, Some r) \\<in> set (butlast ys)\n\ngoal (1 subgoal):\n 1. yid < fst a", "hence \"yid \\<in> set (map fst (butlast ys))\""], ["proof (prove)\nusing this:\n  (yid, Some r) \\<in> set (butlast ys)\n\ngoal (1 subgoal):\n 1. yid \\<in> set (map fst (butlast ys))", "by (metis in_set_zipE zip_map_fst_snd)"], ["proof (state)\nthis:\n  yid \\<in> set (map fst (butlast ys))\n\ngoal (1 subgoal):\n 1. yid < fst a", "ultimately"], ["proof (chain)\npicking this:\n  ys = butlast ys @ [a]\n  yid \\<in> set (map fst (butlast ys))", "show ?thesis"], ["proof (prove)\nusing this:\n  ys = butlast ys @ [a]\n  yid \\<in> set (map fst (butlast ys))\n\ngoal (1 subgoal):\n 1. yid < fst a", "using snoc.prems(5) last_op_greatest"], ["proof (prove)\nusing this:\n  ys = butlast ys @ [a]\n  yid \\<in> set (map fst (butlast ys))\n  insert_ops ys\n  \\<lbrakk>insert_ops (?op_list @ [(?oid, ?oper)]);\n   ?x \\<in> set (map fst ?op_list)\\<rbrakk>\n  \\<Longrightarrow> ?x < ?oid\n\ngoal (1 subgoal):\n 1. yid < fst a", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  yid < fst a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  yid < fst a\n\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "ultimately"], ["proof (chain)\npicking this:\n  r < yid\n  yid < fst a", "have \"r \\<noteq> fst a\""], ["proof (prove)\nusing this:\n  r < yid\n  yid < fst a\n\ngoal (1 subgoal):\n 1. r \\<noteq> fst a", "using dual_order.asym"], ["proof (prove)\nusing this:\n  r < yid\n  yid < fst a\n  \\<lbrakk>?b < ?a; ?a < ?b\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. r \\<noteq> fst a", "by blast"], ["proof (state)\nthis:\n  r \\<noteq> fst a\n\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "thus \"r \\<in> set (interp_ins ops)\""], ["proof (prove)\nusing this:\n  r \\<noteq> fst a\n\ngoal (1 subgoal):\n 1. r \\<in> set (interp_ins ops)", "using snoc.prems(1) snoc.prems(10) interp_ins_maybe_grow2 \\<open>start = Some r\\<close>"], ["proof (prove)\nusing this:\n  r \\<noteq> fst a\n  insert_ops (ops @ [a])\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins (ops @ [a]))\n  insert_ops (?xs @ [?x]) \\<Longrightarrow>\n  set (interp_ins (?xs @ [?x])) = set (interp_ins ?xs) \\<or>\n  set (interp_ins (?xs @ [?x])) = set (interp_ins ?xs) \\<union> {fst ?x}\n  start = Some r\n\ngoal (1 subgoal):\n 1. r \\<in> set (interp_ins ops)", "by blast"], ["proof (state)\nthis:\n  r \\<in> set (interp_ins ops)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [a] \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst (butlast ys)).\n           list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))", "ultimately"], ["proof (chain)\npicking this:\n  set (butlast ys) \\<subseteq> set ops\n  insert_seq start (butlast ys)\n  insert_ops (butlast ys)\n  distinct (map fst xs @ map fst (butlast ys))\n  set xs \\<subseteq> set ops\n  fst (hd xs) < fst (hd (butlast ys))\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins ops)", "show ?thesis"], ["proof (prove)\nusing this:\n  set (butlast ys) \\<subseteq> set ops\n  insert_seq start (butlast ys)\n  insert_ops (butlast ys)\n  distinct (map fst xs @ map fst (butlast ys))\n  set xs \\<subseteq> set ops\n  fst (hd xs) < fst (hd (butlast ys))\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst (butlast ys)).\n           list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))", "using \\<open>insert_ops ops\\<close> snoc.IH snoc.prems(2) snoc.prems(3)"], ["proof (prove)\nusing this:\n  set (butlast ys) \\<subseteq> set ops\n  insert_seq start (butlast ys)\n  insert_ops (butlast ys)\n  distinct (map fst xs @ map fst (butlast ys))\n  set xs \\<subseteq> set ops\n  fst (hd xs) < fst (hd (butlast ys))\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins ops)\n  insert_ops ops\n  \\<lbrakk>insert_ops ops; insert_seq start ?xs; insert_ops ?xs;\n   insert_seq start ?ys; insert_ops ?ys; set ?xs \\<subseteq> set ops;\n   set ?ys \\<subseteq> set ops; distinct (map fst ?xs @ map fst ?ys);\n   fst (hd ?xs) < fst (hd ?ys);\n   \\<And>r.\n      start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>x\\<in>set (map fst ?xs).\n                        \\<forall>y\\<in>set (map fst ?ys).\n                           list_order ops y x) \\<and>\n                    (\\<forall>r.\n                        start = Some r \\<longrightarrow>\n                        (\\<forall>a\\<in>set (map fst ?xs).\n                            list_order ops r a) \\<and>\n                        (\\<forall>a\\<in>set (map fst ?ys).\n                            list_order ops r a))\n  insert_seq start xs\n  insert_ops xs\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst (butlast ys)).\n           list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))", "by blast"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>set (map fst xs).\n      \\<forall>y\\<in>set (map fst (butlast ys)). list_order ops y x) \\<and>\n  (\\<forall>r.\n      start = Some r \\<longrightarrow>\n      (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n      (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>set (map fst xs).\n      \\<forall>y\\<in>set (map fst (butlast ys)). list_order ops y x) \\<and>\n  (\\<forall>r.\n      start = Some r \\<longrightarrow>\n      (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n      (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))\n\ngoal (2 subgoals):\n 1. a \\<in> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 2. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "moreover"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>set (map fst xs).\n      \\<forall>y\\<in>set (map fst (butlast ys)). list_order ops y x) \\<and>\n  (\\<forall>r.\n      start = Some r \\<longrightarrow>\n      (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n      (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))\n\ngoal (2 subgoals):\n 1. a \\<in> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 2. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "have \"\\<forall>x \\<in> set (map fst xs). list_order (ops @ [a]) (fst a) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) (fst a) x", "proof(cases \"ys = [a]\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ys = [a] \\<Longrightarrow>\n    \\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) (fst a) x\n 2. ys \\<noteq> [a] \\<Longrightarrow>\n    \\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) (fst a) x", "case ys_a: True"], ["proof (state)\nthis:\n  ys = [a]\n\ngoal (2 subgoals):\n 1. ys = [a] \\<Longrightarrow>\n    \\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) (fst a) x\n 2. ys \\<noteq> [a] \\<Longrightarrow>\n    \\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) (fst a) x", "then"], ["proof (chain)\npicking this:\n  ys = [a]", "show \"\\<forall>x \\<in> set (map fst xs). list_order (ops @ [a]) (fst a) x\""], ["proof (prove)\nusing this:\n  ys = [a]\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) (fst a) x", "proof(cases start)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ys = [a]; start = None\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set (map fst xs).\n                         list_order (ops @ [a]) (fst a) x\n 2. \\<And>aa.\n       \\<lbrakk>ys = [a]; start = Some aa\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set (map fst xs).\n                            list_order (ops @ [a]) (fst a) x", "case None"], ["proof (state)\nthis:\n  start = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ys = [a]; start = None\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set (map fst xs).\n                         list_order (ops @ [a]) (fst a) x\n 2. \\<And>aa.\n       \\<lbrakk>ys = [a]; start = Some aa\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set (map fst xs).\n                            list_order (ops @ [a]) (fst a) x", "then"], ["proof (chain)\npicking this:\n  start = None", "show ?thesis"], ["proof (prove)\nusing this:\n  start = None\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) (fst a) x", "using insert_seq_start_none list_order_insert_none snoc.prems"], ["proof (prove)\nusing this:\n  start = None\n  \\<lbrakk>insert_ops ?ops; insert_seq None ?xs; insert_ops ?xs;\n   set ?xs \\<subseteq> set ?ops\\<rbrakk>\n  \\<Longrightarrow> \\<forall>i\\<in>set (map fst ?xs).\n                       i \\<in> set (interp_ins ?ops)\n  \\<lbrakk>insert_ops (?ops @ [(?oid, None)]);\n   ?x \\<in> set (interp_ins ?ops)\\<rbrakk>\n  \\<Longrightarrow> list_order (?ops @ [(?oid, None)]) ?oid ?x\n  insert_ops (ops @ [a])\n  insert_seq start xs\n  insert_ops xs\n  insert_seq start ys\n  insert_ops ys\n  set xs \\<subseteq> set (ops @ [a])\n  set ys \\<subseteq> set (ops @ [a])\n  distinct (map fst xs @ map fst ys)\n  fst (hd xs) < fst (hd ys)\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins (ops @ [a]))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) (fst a) x", "by (metis \\<open>insert_ops ops\\<close> \\<open>set xs \\<subseteq> set ops\\<close> fst_conv insert_seq_hd list.sel(1) ys_a)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) (fst a) x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>ys = [a]; start = Some aa\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set (map fst xs).\n                            list_order (ops @ [a]) (fst a) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>ys = [a]; start = Some aa\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set (map fst xs).\n                            list_order (ops @ [a]) (fst a) x", "case (Some r)"], ["proof (state)\nthis:\n  start = Some r\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>ys = [a]; start = Some aa\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set (map fst xs).\n                            list_order (ops @ [a]) (fst a) x", "moreover"], ["proof (state)\nthis:\n  start = Some r\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>ys = [a]; start = Some aa\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set (map fst xs).\n                            list_order (ops @ [a]) (fst a) x", "from this"], ["proof (chain)\npicking this:\n  start = Some r", "have \"\\<forall>x \\<in> set (map fst xs). list_order ops r x\""], ["proof (prove)\nusing this:\n  start = Some r\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map fst xs). list_order ops r x", "using IH"], ["proof (prove)\nusing this:\n  start = Some r\n  (\\<forall>x\\<in>set (map fst xs).\n      \\<forall>y\\<in>set (map fst (butlast ys)). list_order ops y x) \\<and>\n  (\\<forall>r.\n      start = Some r \\<longrightarrow>\n      (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n      (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map fst xs). list_order ops r x", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map fst xs). list_order ops r x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>ys = [a]; start = Some aa\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set (map fst xs).\n                            list_order (ops @ [a]) (fst a) x", "ultimately"], ["proof (chain)\npicking this:\n  start = Some r\n  \\<forall>x\\<in>set (map fst xs). list_order ops r x", "show ?thesis"], ["proof (prove)\nusing this:\n  start = Some r\n  \\<forall>x\\<in>set (map fst xs). list_order ops r x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) (fst a) x", "using snoc.prems(1) snoc.prems(4) list_order_insert_between"], ["proof (prove)\nusing this:\n  start = Some r\n  \\<forall>x\\<in>set (map fst xs). list_order ops r x\n  insert_ops (ops @ [a])\n  insert_seq start ys\n  \\<lbrakk>insert_ops (?ops @ [(?oid, Some ?ref)]);\n   list_order ?ops ?ref ?x\\<rbrakk>\n  \\<Longrightarrow> list_order (?ops @ [(?oid, Some ?ref)]) ?oid ?x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) (fst a) x", "by (metis fst_conv insert_seq_hd list.sel(1) ys_a)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) (fst a) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) (fst a) x\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [a] \\<Longrightarrow>\n    \\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) (fst a) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ys \\<noteq> [a] \\<Longrightarrow>\n    \\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) (fst a) x", "case ys_longer: False"], ["proof (state)\nthis:\n  ys \\<noteq> [a]\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [a] \\<Longrightarrow>\n    \\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) (fst a) x", "hence butlast_split: \"butlast ys = (butlast (butlast ys)) @ [last (butlast ys)]\""], ["proof (prove)\nusing this:\n  ys \\<noteq> [a]\n\ngoal (1 subgoal):\n 1. butlast ys = butlast (butlast ys) @ [last (butlast ys)]", "using \\<open>a = last ys\\<close> insert_seq_butlast insert_seq_nonempty snoc.prems(4)"], ["proof (prove)\nusing this:\n  ys \\<noteq> [a]\n  a = last ys\n  \\<lbrakk>insert_seq ?start ?xs; ?xs \\<noteq> [];\n   ?xs \\<noteq> [last ?xs]\\<rbrakk>\n  \\<Longrightarrow> insert_seq ?start (butlast ?xs)\n  insert_seq ?start ?xs \\<Longrightarrow> ?xs \\<noteq> []\n  insert_seq start ys\n\ngoal (1 subgoal):\n 1. butlast ys = butlast (butlast ys) @ [last (butlast ys)]", "by fastforce"], ["proof (state)\nthis:\n  butlast ys = butlast (butlast ys) @ [last (butlast ys)]\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [a] \\<Longrightarrow>\n    \\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) (fst a) x", "moreover"], ["proof (state)\nthis:\n  butlast ys = butlast (butlast ys) @ [last (butlast ys)]\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [a] \\<Longrightarrow>\n    \\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) (fst a) x", "from this"], ["proof (chain)\npicking this:\n  butlast ys = butlast (butlast ys) @ [last (butlast ys)]", "have \"ys = (butlast (butlast ys)) @ [last (butlast ys), a]\""], ["proof (prove)\nusing this:\n  butlast ys = butlast (butlast ys) @ [last (butlast ys)]\n\ngoal (1 subgoal):\n 1. ys = butlast (butlast ys) @ [last (butlast ys), a]", "by (metis \\<open>a = last ys\\<close> append.assoc append_butlast_last_id butlast.simps(2)\n            insert_seq_nonempty last_ConsL last_ConsR list.simps(3) snoc.prems(4))"], ["proof (state)\nthis:\n  ys = butlast (butlast ys) @ [last (butlast ys), a]\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [a] \\<Longrightarrow>\n    \\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) (fst a) x", "hence \"snd a = Some (fst (last (butlast ys)))\""], ["proof (prove)\nusing this:\n  ys = butlast (butlast ys) @ [last (butlast ys), a]\n\ngoal (1 subgoal):\n 1. snd a = Some (fst (last (butlast ys)))", "using snoc.prems(4) insert_seq_last_ref"], ["proof (prove)\nusing this:\n  ys = butlast (butlast ys) @ [last (butlast ys), a]\n  insert_seq start ys\n  insert_seq ?start (?xs @ [(?xi, ?xr), (?yi, ?yr)]) \\<Longrightarrow>\n  ?yr = Some ?xi\n\ngoal (1 subgoal):\n 1. snd a = Some (fst (last (butlast ys)))", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  snd a = Some (fst (last (butlast ys)))\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [a] \\<Longrightarrow>\n    \\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) (fst a) x", "moreover"], ["proof (state)\nthis:\n  snd a = Some (fst (last (butlast ys)))\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [a] \\<Longrightarrow>\n    \\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) (fst a) x", "have \"\\<forall>x \\<in> set (map fst xs). list_order ops (fst (last (butlast ys))) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map fst xs).\n       list_order ops (fst (last (butlast ys))) x", "by (metis IH butlast_split last_in_set last_map map_is_Nil_conv snoc_eq_iff_butlast)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map fst xs).\n     list_order ops (fst (last (butlast ys))) x\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [a] \\<Longrightarrow>\n    \\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) (fst a) x", "ultimately"], ["proof (chain)\npicking this:\n  butlast ys = butlast (butlast ys) @ [last (butlast ys)]\n  snd a = Some (fst (last (butlast ys)))\n  \\<forall>x\\<in>set (map fst xs).\n     list_order ops (fst (last (butlast ys))) x", "show \"\\<forall>x \\<in> set (map fst xs). list_order (ops @ [a]) (fst a) x\""], ["proof (prove)\nusing this:\n  butlast ys = butlast (butlast ys) @ [last (butlast ys)]\n  snd a = Some (fst (last (butlast ys)))\n  \\<forall>x\\<in>set (map fst xs).\n     list_order ops (fst (last (butlast ys))) x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) (fst a) x", "using list_order_insert_between snoc.prems(1)"], ["proof (prove)\nusing this:\n  butlast ys = butlast (butlast ys) @ [last (butlast ys)]\n  snd a = Some (fst (last (butlast ys)))\n  \\<forall>x\\<in>set (map fst xs).\n     list_order ops (fst (last (butlast ys))) x\n  \\<lbrakk>insert_ops (?ops @ [(?oid, Some ?ref)]);\n   list_order ?ops ?ref ?x\\<rbrakk>\n  \\<Longrightarrow> list_order (?ops @ [(?oid, Some ?ref)]) ?oid ?x\n  insert_ops (ops @ [a])\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) (fst a) x", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) (fst a) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) (fst a) x\n\ngoal (2 subgoals):\n 1. a \\<in> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 2. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "moreover"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) (fst a) x\n\ngoal (2 subgoals):\n 1. a \\<in> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 2. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "have map_fst_xs: \"map fst ys = map fst (butlast ys) @ map fst [last ys]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst ys = map fst (butlast ys) @ map fst [last ys]", "by (metis append_butlast_last_id insert_seq_nonempty map_append snoc.prems(4))"], ["proof (state)\nthis:\n  map fst ys = map fst (butlast ys) @ map fst [last ys]\n\ngoal (2 subgoals):\n 1. a \\<in> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 2. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "hence \"set (map fst ys) = set (map fst (butlast ys)) \\<union> {fst a}\""], ["proof (prove)\nusing this:\n  map fst ys = map fst (butlast ys) @ map fst [last ys]\n\ngoal (1 subgoal):\n 1. set (map fst ys) = set (map fst (butlast ys)) \\<union> {fst a}", "by (simp add: \\<open>a = last ys\\<close>)"], ["proof (state)\nthis:\n  set (map fst ys) = set (map fst (butlast ys)) \\<union> {fst a}\n\ngoal (2 subgoals):\n 1. a \\<in> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 2. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "moreover"], ["proof (state)\nthis:\n  set (map fst ys) = set (map fst (butlast ys)) \\<union> {fst a}\n\ngoal (2 subgoals):\n 1. a \\<in> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 2. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "have \"\\<forall>r. start = Some r \\<longrightarrow> list_order (ops @ [a]) r (fst a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r.\n       start = Some r \\<longrightarrow> list_order (ops @ [a]) r (fst a)", "using snoc.prems"], ["proof (prove)\nusing this:\n  insert_ops (ops @ [a])\n  insert_seq start xs\n  insert_ops xs\n  insert_seq start ys\n  insert_ops ys\n  set xs \\<subseteq> set (ops @ [a])\n  set ys \\<subseteq> set (ops @ [a])\n  distinct (map fst xs @ map fst ys)\n  fst (hd xs) < fst (hd ys)\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins (ops @ [a]))\n\ngoal (1 subgoal):\n 1. \\<forall>r.\n       start = Some r \\<longrightarrow> list_order (ops @ [a]) r (fst a)", "by (cases start, auto simp add: insert_seq_after_start \\<open>a = last ys\\<close> map_fst_xs)"], ["proof (state)\nthis:\n  \\<forall>r.\n     start = Some r \\<longrightarrow> list_order (ops @ [a]) r (fst a)\n\ngoal (2 subgoals):\n 1. a \\<in> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n 2. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "ultimately"], ["proof (chain)\npicking this:\n  (\\<forall>x\\<in>set (map fst xs).\n      \\<forall>y\\<in>set (map fst (butlast ys)). list_order ops y x) \\<and>\n  (\\<forall>r.\n      start = Some r \\<longrightarrow>\n      (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n      (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))\n  \\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) (fst a) x\n  set (map fst ys) = set (map fst (butlast ys)) \\<union> {fst a}\n  \\<forall>r.\n     start = Some r \\<longrightarrow> list_order (ops @ [a]) r (fst a)", "show \"(\\<forall>x \\<in> set (map fst xs). \\<forall>y \\<in> set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n          (\\<forall>r. start = Some r \\<longrightarrow> (\\<forall>x \\<in> set (map fst xs). list_order (ops @ [a]) r x) \\<and>\n                                  (\\<forall>y \\<in> set (map fst ys). list_order (ops @ [a]) r y))\""], ["proof (prove)\nusing this:\n  (\\<forall>x\\<in>set (map fst xs).\n      \\<forall>y\\<in>set (map fst (butlast ys)). list_order ops y x) \\<and>\n  (\\<forall>r.\n      start = Some r \\<longrightarrow>\n      (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n      (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))\n  \\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) (fst a) x\n  set (map fst ys) = set (map fst (butlast ys)) \\<union> {fst a}\n  \\<forall>r.\n     start = Some r \\<longrightarrow> list_order (ops @ [a]) r (fst a)\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) r y))", "using snoc.prems(1)"], ["proof (prove)\nusing this:\n  (\\<forall>x\\<in>set (map fst xs).\n      \\<forall>y\\<in>set (map fst (butlast ys)). list_order ops y x) \\<and>\n  (\\<forall>r.\n      start = Some r \\<longrightarrow>\n      (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n      (\\<forall>y\\<in>set (map fst (butlast ys)). list_order ops r y))\n  \\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) (fst a) x\n  set (map fst ys) = set (map fst (butlast ys)) \\<union> {fst a}\n  \\<forall>r.\n     start = Some r \\<longrightarrow> list_order (ops @ [a]) r (fst a)\n  insert_ops (ops @ [a])\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) r y))", "by (simp add: list_order_append)"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>set (map fst xs).\n      \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n  (\\<forall>r.\n      start = Some r \\<longrightarrow>\n      (\\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) r x) \\<and>\n      (\\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) r y))\n\ngoal (1 subgoal):\n 1. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "case neither"], ["proof (state)\nthis:\n  a \\<notin> set xs \\<and> a \\<notin> set ys\n\ngoal (1 subgoal):\n 1. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "hence \"set xs \\<subseteq> set ops\" and \"set ys \\<subseteq> set ops\""], ["proof (prove)\nusing this:\n  a \\<notin> set xs \\<and> a \\<notin> set ys\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> set ops &&& set ys \\<subseteq> set ops", "using snoc.prems(6) snoc.prems(7) DiffE"], ["proof (prove)\nusing this:\n  a \\<notin> set xs \\<and> a \\<notin> set ys\n  set xs \\<subseteq> set (ops @ [a])\n  set ys \\<subseteq> set (ops @ [a])\n  \\<lbrakk>?c \\<in> ?A - ?B;\n   \\<lbrakk>?c \\<in> ?A; ?c \\<notin> ?B\\<rbrakk>\n   \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> set ops &&& set ys \\<subseteq> set ops", "by auto"], ["proof (state)\nthis:\n  set xs \\<subseteq> set ops\n  set ys \\<subseteq> set ops\n\ngoal (1 subgoal):\n 1. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "have \"(\\<forall>r. start = Some r \\<longrightarrow> r \\<in> set (interp_ins ops)) \\<or> (xs = [] \\<and> ys = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>r.\n        start = Some r \\<longrightarrow> r \\<in> set (interp_ins ops)) \\<or>\n    xs = [] \\<and> ys = []", "proof(cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow> r \\<in> set (interp_ins ops)) \\<or>\n    xs = [] \\<and> ys = []\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       (\\<forall>r.\n           start = Some r \\<longrightarrow>\n           r \\<in> set (interp_ins ops)) \\<or>\n       xs = [] \\<and> ys = []", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow> r \\<in> set (interp_ins ops)) \\<or>\n    xs = [] \\<and> ys = []\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       (\\<forall>r.\n           start = Some r \\<longrightarrow>\n           r \\<in> set (interp_ins ops)) \\<or>\n       xs = [] \\<and> ys = []", "then"], ["proof (chain)\npicking this:\n  xs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. (\\<forall>r.\n        start = Some r \\<longrightarrow> r \\<in> set (interp_ins ops)) \\<or>\n    xs = [] \\<and> ys = []", "using insert_seq_nonempty snoc.prems(2)"], ["proof (prove)\nusing this:\n  xs = []\n  insert_seq ?start ?xs \\<Longrightarrow> ?xs \\<noteq> []\n  insert_seq start xs\n\ngoal (1 subgoal):\n 1. (\\<forall>r.\n        start = Some r \\<longrightarrow> r \\<in> set (interp_ins ops)) \\<or>\n    xs = [] \\<and> ys = []", "by blast"], ["proof (state)\nthis:\n  (\\<forall>r.\n      start = Some r \\<longrightarrow> r \\<in> set (interp_ins ops)) \\<or>\n  xs = [] \\<and> ys = []\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       (\\<forall>r.\n           start = Some r \\<longrightarrow>\n           r \\<in> set (interp_ins ops)) \\<or>\n       xs = [] \\<and> ys = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       (\\<forall>r.\n           start = Some r \\<longrightarrow>\n           r \\<in> set (interp_ins ops)) \\<or>\n       xs = [] \\<and> ys = []", "case xs_nonempty: (Cons x xsa)"], ["proof (state)\nthis:\n  xs = x # xsa\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       (\\<forall>r.\n           start = Some r \\<longrightarrow>\n           r \\<in> set (interp_ins ops)) \\<or>\n       xs = [] \\<and> ys = []", "have \"\\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "assume \"start = Some r\""], ["proof (state)\nthis:\n  start = Some r\n\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "then"], ["proof (chain)\npicking this:\n  start = Some r", "obtain xi where \"x = (xi, Some r)\""], ["proof (prove)\nusing this:\n  start = Some r\n\ngoal (1 subgoal):\n 1. (\\<And>xi. x = (xi, Some r) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using insert_seq_hd xs_nonempty snoc.prems(2)"], ["proof (prove)\nusing this:\n  start = Some r\n  insert_seq ?start ?xs \\<Longrightarrow>\n  \\<exists>oid. hd ?xs = (oid, ?start)\n  xs = x # xsa\n  insert_seq start xs\n\ngoal (1 subgoal):\n 1. (\\<And>xi. x = (xi, Some r) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x = (xi, Some r)\n\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "hence \"(xi, Some r) \\<in> set ops\""], ["proof (prove)\nusing this:\n  x = (xi, Some r)\n\ngoal (1 subgoal):\n 1. (xi, Some r) \\<in> set ops", "using \\<open>set xs \\<subseteq> set ops\\<close> xs_nonempty"], ["proof (prove)\nusing this:\n  x = (xi, Some r)\n  set xs \\<subseteq> set ops\n  xs = x # xsa\n\ngoal (1 subgoal):\n 1. (xi, Some r) \\<in> set ops", "by auto"], ["proof (state)\nthis:\n  (xi, Some r) \\<in> set ops\n\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "hence \"r < xi\""], ["proof (prove)\nusing this:\n  (xi, Some r) \\<in> set ops\n\ngoal (1 subgoal):\n 1. r < xi", "using \\<open>insert_ops ops\\<close> insert_ops_memb_ref_older"], ["proof (prove)\nusing this:\n  (xi, Some r) \\<in> set ops\n  insert_ops ops\n  \\<lbrakk>insert_ops ?op_list;\n   (?oid, Some ?ref) \\<in> set ?op_list\\<rbrakk>\n  \\<Longrightarrow> ?ref < ?oid\n\ngoal (1 subgoal):\n 1. r < xi", "by blast"], ["proof (state)\nthis:\n  r < xi\n\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "moreover"], ["proof (state)\nthis:\n  r < xi\n\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "have \"xi \\<in> set (map fst ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xi \\<in> set (map fst ops)", "using \\<open>(xi, Some r) \\<in> set ops\\<close>"], ["proof (prove)\nusing this:\n  (xi, Some r) \\<in> set ops\n\ngoal (1 subgoal):\n 1. xi \\<in> set (map fst ops)", "by force"], ["proof (state)\nthis:\n  xi \\<in> set (map fst ops)\n\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "hence \"xi < fst a\""], ["proof (prove)\nusing this:\n  xi \\<in> set (map fst ops)\n\ngoal (1 subgoal):\n 1. xi < fst a", "using last_op_greatest snoc.prems(1)"], ["proof (prove)\nusing this:\n  xi \\<in> set (map fst ops)\n  \\<lbrakk>insert_ops (?op_list @ [(?oid, ?oper)]);\n   ?x \\<in> set (map fst ?op_list)\\<rbrakk>\n  \\<Longrightarrow> ?x < ?oid\n  insert_ops (ops @ [a])\n\ngoal (1 subgoal):\n 1. xi < fst a", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  xi < fst a\n\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "ultimately"], ["proof (chain)\npicking this:\n  r < xi\n  xi < fst a", "have \"fst a \\<noteq> r\""], ["proof (prove)\nusing this:\n  r < xi\n  xi < fst a\n\ngoal (1 subgoal):\n 1. fst a \\<noteq> r", "using order.asym"], ["proof (prove)\nusing this:\n  r < xi\n  xi < fst a\n  \\<lbrakk>?a < ?b; ?b < ?a\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. fst a \\<noteq> r", "by blast"], ["proof (state)\nthis:\n  fst a \\<noteq> r\n\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "then"], ["proof (chain)\npicking this:\n  fst a \\<noteq> r", "show \"r \\<in> set (interp_ins ops)\""], ["proof (prove)\nusing this:\n  fst a \\<noteq> r\n\ngoal (1 subgoal):\n 1. r \\<in> set (interp_ins ops)", "using snoc.prems(1) snoc.prems(10) interp_ins_maybe_grow2 \\<open>start = Some r\\<close>"], ["proof (prove)\nusing this:\n  fst a \\<noteq> r\n  insert_ops (ops @ [a])\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins (ops @ [a]))\n  insert_ops (?xs @ [?x]) \\<Longrightarrow>\n  set (interp_ins (?xs @ [?x])) = set (interp_ins ?xs) \\<or>\n  set (interp_ins (?xs @ [?x])) = set (interp_ins ?xs) \\<union> {fst ?x}\n  start = Some r\n\ngoal (1 subgoal):\n 1. r \\<in> set (interp_ins ops)", "by blast"], ["proof (state)\nthis:\n  r \\<in> set (interp_ins ops)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       (\\<forall>r.\n           start = Some r \\<longrightarrow>\n           r \\<in> set (interp_ins ops)) \\<or>\n       xs = [] \\<and> ys = []", "then"], ["proof (chain)\npicking this:\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins ops)", "show ?thesis"], ["proof (prove)\nusing this:\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. (\\<forall>r.\n        start = Some r \\<longrightarrow> r \\<in> set (interp_ins ops)) \\<or>\n    xs = [] \\<and> ys = []", "by blast"], ["proof (state)\nthis:\n  (\\<forall>r.\n      start = Some r \\<longrightarrow> r \\<in> set (interp_ins ops)) \\<or>\n  xs = [] \\<and> ys = []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>r.\n      start = Some r \\<longrightarrow> r \\<in> set (interp_ins ops)) \\<or>\n  xs = [] \\<and> ys = []\n\ngoal (1 subgoal):\n 1. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "hence \"(\\<forall>x \\<in> set (map fst xs). \\<forall>y \\<in> set (map fst ys). list_order ops y x) \\<and>\n           (\\<forall>r. start = Some r \\<longrightarrow> (\\<forall>x \\<in> set (map fst xs). list_order ops r x) \\<and>\n                                   (\\<forall>y \\<in> set (map fst ys). list_order ops r y))\""], ["proof (prove)\nusing this:\n  (\\<forall>r.\n      start = Some r \\<longrightarrow> r \\<in> set (interp_ins ops)) \\<or>\n  xs = [] \\<and> ys = []\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))", "using snoc.prems snoc.IH \\<open>set xs \\<subseteq> set ops\\<close> \\<open>set ys \\<subseteq> set ops\\<close>"], ["proof (prove)\nusing this:\n  (\\<forall>r.\n      start = Some r \\<longrightarrow> r \\<in> set (interp_ins ops)) \\<or>\n  xs = [] \\<and> ys = []\n  insert_ops (ops @ [a])\n  insert_seq start xs\n  insert_ops xs\n  insert_seq start ys\n  insert_ops ys\n  set xs \\<subseteq> set (ops @ [a])\n  set ys \\<subseteq> set (ops @ [a])\n  distinct (map fst xs @ map fst ys)\n  fst (hd xs) < fst (hd ys)\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins (ops @ [a]))\n  \\<lbrakk>insert_ops ops; insert_seq start ?xs; insert_ops ?xs;\n   insert_seq start ?ys; insert_ops ?ys; set ?xs \\<subseteq> set ops;\n   set ?ys \\<subseteq> set ops; distinct (map fst ?xs @ map fst ?ys);\n   fst (hd ?xs) < fst (hd ?ys);\n   \\<And>r.\n      start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>x\\<in>set (map fst ?xs).\n                        \\<forall>y\\<in>set (map fst ?ys).\n                           list_order ops y x) \\<and>\n                    (\\<forall>r.\n                        start = Some r \\<longrightarrow>\n                        (\\<forall>a\\<in>set (map fst ?xs).\n                            list_order ops r a) \\<and>\n                        (\\<forall>a\\<in>set (map fst ?ys).\n                            list_order ops r a))\n  set xs \\<subseteq> set ops\n  set ys \\<subseteq> set ops\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order ops r y))", "by blast"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>set (map fst xs).\n      \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n  (\\<forall>r.\n      start = Some r \\<longrightarrow>\n      (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n      (\\<forall>y\\<in>set (map fst ys). list_order ops r y))\n\ngoal (1 subgoal):\n 1. a \\<notin> set xs \\<and> a \\<notin> set ys \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n        (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))", "then"], ["proof (chain)\npicking this:\n  (\\<forall>x\\<in>set (map fst xs).\n      \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n  (\\<forall>r.\n      start = Some r \\<longrightarrow>\n      (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n      (\\<forall>y\\<in>set (map fst ys). list_order ops r y))", "show \"(\\<forall>x \\<in> set (map fst xs). \\<forall>y \\<in> set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n          (\\<forall>r. start = Some r \\<longrightarrow> (\\<forall>x \\<in> set (map fst xs). list_order (ops @ [a]) r x) \\<and>\n                                  (\\<forall>y \\<in> set (map fst ys). list_order (ops @ [a]) r y))\""], ["proof (prove)\nusing this:\n  (\\<forall>x\\<in>set (map fst xs).\n      \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n  (\\<forall>r.\n      start = Some r \\<longrightarrow>\n      (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n      (\\<forall>y\\<in>set (map fst ys). list_order ops r y))\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) r y))", "using snoc.prems(1)"], ["proof (prove)\nusing this:\n  (\\<forall>x\\<in>set (map fst xs).\n      \\<forall>y\\<in>set (map fst ys). list_order ops y x) \\<and>\n  (\\<forall>r.\n      start = Some r \\<longrightarrow>\n      (\\<forall>x\\<in>set (map fst xs). list_order ops r x) \\<and>\n      (\\<forall>y\\<in>set (map fst ys). list_order ops r y))\n  insert_ops (ops @ [a])\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n    (\\<forall>r.\n        start = Some r \\<longrightarrow>\n        (\\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) r x) \\<and>\n        (\\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) r y))", "by (simp add: list_order_append)"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>set (map fst xs).\n      \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n  (\\<forall>r.\n      start = Some r \\<longrightarrow>\n      (\\<forall>x\\<in>set (map fst xs). list_order (ops @ [a]) r x) \\<and>\n      (\\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) r y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>set (map fst xs).\n      \\<forall>y\\<in>set (map fst ys). list_order (ops @ [a]) y x) \\<and>\n  (\\<forall>r.\n      start = Some r \\<longrightarrow>\n      (\\<forall>b\\<in>set (map fst xs). list_order (ops @ [a]) r b) \\<and>\n      (\\<forall>b\\<in>set (map fst ys). list_order (ops @ [a]) r b))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Consider an execution that contains two distinct insertion sequences,\n\\isa{xs} and \\isa{ys}, that both begin at the same initial position \\isa{start}.\nWe prove that, provided the starting element exists, the two insertion sequences\nare not interleaved. That is, in the final list order, either all insertions by\n\\isa{xs} appear before all insertions by \\isa{ys}, or vice versa.\\<close>"], ["", "theorem no_interleaving:\n  assumes \"insert_ops ops\"\n    and \"insert_seq start xs\" and \"insert_ops xs\"\n    and \"insert_seq start ys\" and \"insert_ops ys\"\n    and \"set xs \\<subseteq> set ops\" and \"set ys \\<subseteq> set ops\"\n    and \"distinct (map fst xs @ map fst ys)\"\n    and \"start = None \\<or> (\\<exists>r. start = Some r \\<and> r \\<in> set (interp_ins ops))\"\n  shows \"(\\<forall>x \\<in> set (map fst xs). \\<forall>y \\<in> set (map fst ys). list_order ops x y) \\<or>\n         (\\<forall>x \\<in> set (map fst xs). \\<forall>y \\<in> set (map fst ys). list_order ops y x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops x y) \\<or>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x)", "proof(cases \"fst (hd xs) < fst (hd ys)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (hd xs) < fst (hd ys) \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops x y) \\<or>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x)\n 2. \\<not> fst (hd xs) < fst (hd ys) \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops x y) \\<or>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x)", "case True"], ["proof (state)\nthis:\n  fst (hd xs) < fst (hd ys)\n\ngoal (2 subgoals):\n 1. fst (hd xs) < fst (hd ys) \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops x y) \\<or>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x)\n 2. \\<not> fst (hd xs) < fst (hd ys) \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops x y) \\<or>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x)", "moreover"], ["proof (state)\nthis:\n  fst (hd xs) < fst (hd ys)\n\ngoal (2 subgoals):\n 1. fst (hd xs) < fst (hd ys) \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops x y) \\<or>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x)\n 2. \\<not> fst (hd xs) < fst (hd ys) \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops x y) \\<or>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x)", "have \"\\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "using assms(9)"], ["proof (prove)\nusing this:\n  start = None \\<or>\n  (\\<exists>r. start = Some r \\<and> r \\<in> set (interp_ins ops))\n\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "by blast"], ["proof (state)\nthis:\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins ops)\n\ngoal (2 subgoals):\n 1. fst (hd xs) < fst (hd ys) \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops x y) \\<or>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x)\n 2. \\<not> fst (hd xs) < fst (hd ys) \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops x y) \\<or>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x)", "ultimately"], ["proof (chain)\npicking this:\n  fst (hd xs) < fst (hd ys)\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins ops)", "have \"\\<forall>x\\<in>set (map fst xs). \\<forall>y\\<in>set (map fst ys). list_order ops y x\""], ["proof (prove)\nusing this:\n  fst (hd xs) < fst (hd ys)\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map fst xs).\n       \\<forall>y\\<in>set (map fst ys). list_order ops y x", "using assms no_interleaving_ordered"], ["proof (prove)\nusing this:\n  fst (hd xs) < fst (hd ys)\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins ops)\n  insert_ops ops\n  insert_seq start xs\n  insert_ops xs\n  insert_seq start ys\n  insert_ops ys\n  set xs \\<subseteq> set ops\n  set ys \\<subseteq> set ops\n  distinct (map fst xs @ map fst ys)\n  start = None \\<or>\n  (\\<exists>r. start = Some r \\<and> r \\<in> set (interp_ins ops))\n  \\<lbrakk>insert_ops ?ops; insert_seq ?start ?xs; insert_ops ?xs;\n   insert_seq ?start ?ys; insert_ops ?ys; set ?xs \\<subseteq> set ?ops;\n   set ?ys \\<subseteq> set ?ops; distinct (map fst ?xs @ map fst ?ys);\n   fst (hd ?xs) < fst (hd ?ys);\n   \\<And>r.\n      ?start = Some r \\<Longrightarrow>\n      r \\<in> set (interp_ins ?ops)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>x\\<in>set (map fst ?xs).\n                        \\<forall>y\\<in>set (map fst ?ys).\n                           list_order ?ops y x) \\<and>\n                    (\\<forall>r.\n                        ?start = Some r \\<longrightarrow>\n                        (\\<forall>x\\<in>set (map fst ?xs).\n                            list_order ?ops r x) \\<and>\n                        (\\<forall>y\\<in>set (map fst ?ys).\n                            list_order ?ops r y))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map fst xs).\n       \\<forall>y\\<in>set (map fst ys). list_order ops y x", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map fst xs).\n     \\<forall>y\\<in>set (map fst ys). list_order ops y x\n\ngoal (2 subgoals):\n 1. fst (hd xs) < fst (hd ys) \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops x y) \\<or>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x)\n 2. \\<not> fst (hd xs) < fst (hd ys) \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops x y) \\<or>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x)", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set (map fst xs).\n     \\<forall>y\\<in>set (map fst ys). list_order ops y x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (map fst xs).\n     \\<forall>y\\<in>set (map fst ys). list_order ops y x\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops x y) \\<or>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x)", "by blast"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>set (map fst xs).\n      \\<forall>y\\<in>set (map fst ys). list_order ops x y) \\<or>\n  (\\<forall>x\\<in>set (map fst xs).\n      \\<forall>y\\<in>set (map fst ys). list_order ops y x)\n\ngoal (1 subgoal):\n 1. \\<not> fst (hd xs) < fst (hd ys) \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops x y) \\<or>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> fst (hd xs) < fst (hd ys) \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops x y) \\<or>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x)", "case False"], ["proof (state)\nthis:\n  \\<not> fst (hd xs) < fst (hd ys)\n\ngoal (1 subgoal):\n 1. \\<not> fst (hd xs) < fst (hd ys) \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops x y) \\<or>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x)", "hence \"fst (hd ys) < fst (hd xs)\""], ["proof (prove)\nusing this:\n  \\<not> fst (hd xs) < fst (hd ys)\n\ngoal (1 subgoal):\n 1. fst (hd ys) < fst (hd xs)", "using assms(2) assms(4) assms(8) insert_seq_nonempty distinct_fst_append"], ["proof (prove)\nusing this:\n  \\<not> fst (hd xs) < fst (hd ys)\n  insert_seq start xs\n  insert_seq start ys\n  distinct (map fst xs @ map fst ys)\n  insert_seq ?start ?xs \\<Longrightarrow> ?xs \\<noteq> []\n  \\<lbrakk>?x \\<in> set (map fst ?xs);\n   distinct (map fst (?xs @ ?ys))\\<rbrakk>\n  \\<Longrightarrow> ?x \\<notin> set (map fst ?ys)\n\ngoal (1 subgoal):\n 1. fst (hd ys) < fst (hd xs)", "by (metis (no_types, lifting) hd_in_set hd_map list.map_disc_iff map_append neqE)"], ["proof (state)\nthis:\n  fst (hd ys) < fst (hd xs)\n\ngoal (1 subgoal):\n 1. \\<not> fst (hd xs) < fst (hd ys) \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops x y) \\<or>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x)", "moreover"], ["proof (state)\nthis:\n  fst (hd ys) < fst (hd xs)\n\ngoal (1 subgoal):\n 1. \\<not> fst (hd xs) < fst (hd ys) \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops x y) \\<or>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x)", "have \"distinct (map fst ys @ map fst xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst ys @ map fst xs)", "using assms(8) distinct_append_swap"], ["proof (prove)\nusing this:\n  distinct (map fst xs @ map fst ys)\n  distinct (?xs @ ?ys) \\<Longrightarrow> distinct (?ys @ ?xs)\n\ngoal (1 subgoal):\n 1. distinct (map fst ys @ map fst xs)", "by blast"], ["proof (state)\nthis:\n  distinct (map fst ys @ map fst xs)\n\ngoal (1 subgoal):\n 1. \\<not> fst (hd xs) < fst (hd ys) \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops x y) \\<or>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x)", "moreover"], ["proof (state)\nthis:\n  distinct (map fst ys @ map fst xs)\n\ngoal (1 subgoal):\n 1. \\<not> fst (hd xs) < fst (hd ys) \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops x y) \\<or>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x)", "have \"\\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "using assms(9)"], ["proof (prove)\nusing this:\n  start = None \\<or>\n  (\\<exists>r. start = Some r \\<and> r \\<in> set (interp_ins ops))\n\ngoal (1 subgoal):\n 1. \\<And>r. start = Some r \\<Longrightarrow> r \\<in> set (interp_ins ops)", "by blast"], ["proof (state)\nthis:\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. \\<not> fst (hd xs) < fst (hd ys) \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops x y) \\<or>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x)", "ultimately"], ["proof (chain)\npicking this:\n  fst (hd ys) < fst (hd xs)\n  distinct (map fst ys @ map fst xs)\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins ops)", "have \"\\<forall>x\\<in>set (map fst ys). \\<forall>y\\<in>set (map fst xs). list_order ops y x\""], ["proof (prove)\nusing this:\n  fst (hd ys) < fst (hd xs)\n  distinct (map fst ys @ map fst xs)\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins ops)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map fst ys).\n       \\<forall>y\\<in>set (map fst xs). list_order ops y x", "using assms no_interleaving_ordered"], ["proof (prove)\nusing this:\n  fst (hd ys) < fst (hd xs)\n  distinct (map fst ys @ map fst xs)\n  start = Some ?r \\<Longrightarrow> ?r \\<in> set (interp_ins ops)\n  insert_ops ops\n  insert_seq start xs\n  insert_ops xs\n  insert_seq start ys\n  insert_ops ys\n  set xs \\<subseteq> set ops\n  set ys \\<subseteq> set ops\n  distinct (map fst xs @ map fst ys)\n  start = None \\<or>\n  (\\<exists>r. start = Some r \\<and> r \\<in> set (interp_ins ops))\n  \\<lbrakk>insert_ops ?ops; insert_seq ?start ?xs; insert_ops ?xs;\n   insert_seq ?start ?ys; insert_ops ?ys; set ?xs \\<subseteq> set ?ops;\n   set ?ys \\<subseteq> set ?ops; distinct (map fst ?xs @ map fst ?ys);\n   fst (hd ?xs) < fst (hd ?ys);\n   \\<And>r.\n      ?start = Some r \\<Longrightarrow>\n      r \\<in> set (interp_ins ?ops)\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>x\\<in>set (map fst ?xs).\n                        \\<forall>y\\<in>set (map fst ?ys).\n                           list_order ?ops y x) \\<and>\n                    (\\<forall>r.\n                        ?start = Some r \\<longrightarrow>\n                        (\\<forall>x\\<in>set (map fst ?xs).\n                            list_order ?ops r x) \\<and>\n                        (\\<forall>y\\<in>set (map fst ?ys).\n                            list_order ?ops r y))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map fst ys).\n       \\<forall>y\\<in>set (map fst xs). list_order ops y x", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map fst ys).\n     \\<forall>y\\<in>set (map fst xs). list_order ops y x\n\ngoal (1 subgoal):\n 1. \\<not> fst (hd xs) < fst (hd ys) \\<Longrightarrow>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops x y) \\<or>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x)", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set (map fst ys).\n     \\<forall>y\\<in>set (map fst xs). list_order ops y x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (map fst ys).\n     \\<forall>y\\<in>set (map fst xs). list_order ops y x\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops x y) \\<or>\n    (\\<forall>x\\<in>set (map fst xs).\n        \\<forall>y\\<in>set (map fst ys). list_order ops y x)", "by blast"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>set (map fst xs).\n      \\<forall>y\\<in>set (map fst ys). list_order ops x y) \\<or>\n  (\\<forall>x\\<in>set (map fst xs).\n      \\<forall>y\\<in>set (map fst ys). list_order ops y x)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>For completeness, we also prove what happens if there are two insertion\nsequences, \\isa{xs} and \\isa{ys}, but their initial position \\isa{start} does\nnot exist. In that case, none of the insertions in \\isa{xs} or \\isa{ys} take\neffect.\\<close>"], ["", "theorem missing_start_no_insertion:\n  assumes \"insert_ops ops\"\n    and \"insert_seq (Some start) xs\" and \"insert_ops xs\"\n    and \"insert_seq (Some start) ys\" and \"insert_ops ys\"\n    and \"set xs \\<subseteq> set ops\" and \"set ys \\<subseteq> set ops\"\n    and \"start \\<notin> set (interp_ins ops)\"\n  shows \"\\<forall>x \\<in> set (map fst xs) \\<union> set (map fst ys). x \\<notin> set (interp_ins ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map fst xs) \\<union> set (map fst ys).\n       x \\<notin> set (interp_ins ops)", "using assms insert_seq_no_start"], ["proof (prove)\nusing this:\n  insert_ops ops\n  insert_seq (Some start) xs\n  insert_ops xs\n  insert_seq (Some start) ys\n  insert_ops ys\n  set xs \\<subseteq> set ops\n  set ys \\<subseteq> set ops\n  start \\<notin> set (interp_ins ops)\n  \\<lbrakk>insert_ops ?ops; insert_seq (Some ?ref) ?xs; insert_ops ?xs;\n   set ?xs \\<subseteq> set ?ops;\n   ?ref \\<notin> set (interp_ins ?ops)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>i\\<in>set (map fst ?xs).\n                       i \\<notin> set (interp_ins ?ops)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map fst xs) \\<union> set (map fst ys).\n       x \\<notin> set (interp_ins ops)", "by (metis UnE)"], ["", "end"]]}