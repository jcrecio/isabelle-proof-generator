{"file_name": "/home/qj213/afp-2021-10-22/thys/OpSets/OpSet.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/OpSets", "problem_names": ["lemma opset_subset:\n  assumes \"opset Y deps\"\n    and \"X \\<subseteq> Y\"\n  shows \"opset X deps\"", "lemma opset_insert:\n  assumes \"opset (insert x ops) deps\"\n  shows \"opset ops deps\"", "lemma opset_sublist:\n  assumes \"opset (set (xs @ ys @ zs)) deps\"\n  shows \"opset (set (xs @ zs)) deps\"", "lemma distinct_rem_mid:\n  assumes \"distinct (xs @ [x] @ ys)\"\n  shows \"distinct (xs @ ys)\"", "lemma distinct_fst_append:\n  assumes \"x \\<in> set (map fst xs)\"\n    and \"distinct (map fst (xs @ ys))\"\n  shows \"x \\<notin> set (map fst ys)\"", "lemma distinct_set_remove_last:\n  assumes \"distinct (xs @ [x])\"\n  shows \"set xs = set (xs @ [x]) - {x}\"", "lemma distinct_set_remove_mid:\n  assumes \"distinct (xs @ [x] @ ys)\"\n  shows \"set (xs @ ys) = set (xs @ [x] @ ys) - {x}\"", "lemma distinct_list_split:\n  assumes \"distinct xs\"\n    and \"xs = xa @ x # ya\"\n    and \"xs = xb @ x # yb\"\n  shows \"xa = xb \\<and> ya = yb\"", "lemma distinct_append_swap:\n  assumes \"distinct (xs @ ys)\"\n  shows \"distinct (ys @ xs)\"", "lemma append_subset:\n  assumes \"set xs = set (ys @ zs)\"\n  shows \"set ys \\<subseteq> set xs\" and \"set zs \\<subseteq> set xs\"", "lemma append_set_rem_last:\n  assumes \"set (xs @ [x]) = set (ys @ [x] @ zs)\"\n    and \"distinct (xs @ [x])\" and \"distinct (ys @ [x] @ zs)\"\n  shows \"set xs = set (ys @ zs)\"", "lemma distinct_map_fst_remove1:\n  assumes \"distinct (map fst xs)\"\n  shows \"distinct (map fst (remove1 x xs))\"", "lemma spec_ops_empty:\n  shows \"spec_ops [] deps\"", "lemma spec_ops_distinct:\n  assumes \"spec_ops ops deps\"\n  shows \"distinct ops\"", "lemma spec_ops_distinct_fst:\n  assumes \"spec_ops ops deps\"\n  shows \"distinct (map fst ops)\"", "lemma spec_ops_sorted:\n  assumes \"spec_ops ops deps\"\n  shows \"sorted (map fst ops)\"", "lemma spec_ops_rem_cons:\n  assumes \"spec_ops (x # xs) deps\"\n  shows \"spec_ops xs deps\"", "lemma spec_ops_rem_last:\n  assumes \"spec_ops (xs @ [x]) deps\"\n  shows \"spec_ops xs deps\"", "lemma spec_ops_remove1:\n  assumes \"spec_ops xs deps\"\n  shows \"spec_ops (remove1 x xs) deps\"", "lemma spec_ops_ref_less:\n  assumes \"spec_ops xs deps\"\n    and \"(oid, oper) \\<in> set xs\"\n    and \"r \\<in> deps oper\"\n  shows \"r < oid\"", "lemma spec_ops_ref_less_last:\n  assumes \"spec_ops (xs @ [(oid, oper)]) deps\"\n    and \"r \\<in> deps oper\"\n  shows \"r < oid\"", "lemma spec_ops_id_inc:\n  assumes \"spec_ops (xs @ [(oid, oper)]) deps\"\n    and \"x \\<in> set (map fst xs)\"\n  shows \"x < oid\"", "lemma spec_ops_add_last:\n  assumes \"spec_ops xs deps\"\n    and \"\\<forall>i \\<in> set (map fst xs). i < oid\"\n    and \"\\<forall>ref \\<in> deps oper. ref < oid\"\n  shows \"spec_ops (xs @ [(oid, oper)]) deps\"", "lemma spec_ops_add_any:\n  assumes \"spec_ops (xs @ ys) deps\"\n    and \"\\<forall>i \\<in> set (map fst xs). i < oid\"\n    and \"\\<forall>i \\<in> set (map fst ys). oid < i\"\n    and \"\\<forall>ref \\<in> deps oper. ref < oid\"\n  shows \"spec_ops (xs @ [(oid, oper)] @ ys) deps\"", "lemma spec_ops_split:\n  assumes \"spec_ops xs deps\"\n    and \"oid \\<notin> set (map fst xs)\"\n  shows \"\\<exists>pre suf. xs = pre @ suf \\<and>\n            (\\<forall>i \\<in> set (map fst pre). i < oid) \\<and>\n            (\\<forall>i \\<in> set (map fst suf). oid < i)\"", "lemma spec_ops_exists_base:\n  assumes \"finite ops\"\n    and \"\\<And>oid op1 op2. (oid, op1) \\<in> ops \\<Longrightarrow> (oid, op2) \\<in> ops \\<Longrightarrow> op1 = op2\"\n    and \"\\<And>oid oper ref. (oid, oper) \\<in> ops \\<Longrightarrow> ref \\<in> deps oper \\<Longrightarrow> ref < oid\"\n  shows \"\\<exists>op_list. set op_list = ops \\<and> spec_ops op_list deps\"", "lemma spec_ops_exists:\n  assumes \"opset ops deps\"\n  shows \"\\<exists>op_list. set op_list = ops \\<and> spec_ops op_list deps\"", "lemma spec_ops_oid_unique:\n  assumes \"spec_ops op_list deps\"\n    and \"(oid, op1) \\<in> set op_list\"\n    and \"(oid, op2) \\<in> set op_list\"\n  shows \"op1 = op2\"", "lemma spec_ops_is_opset:\n  assumes \"spec_ops op_list deps\"\n  shows \"opset (set op_list) deps\"", "lemma crdt_ops_intro:\n  assumes \"\\<And>r. r \\<in> deps oper \\<Longrightarrow> r \\<in> fst ` set xs \\<and> r < oid\"\n    and \"oid \\<notin> fst ` set xs\"\n    and \"crdt_ops xs deps\"\n  shows \"crdt_ops (xs @ [(oid, oper)]) deps\"", "lemma crdt_ops_rem_last:\n  assumes \"crdt_ops (xs @ [x]) deps\"\n  shows \"crdt_ops xs deps\"", "lemma crdt_ops_ref_less:\n  assumes \"crdt_ops xs deps\"\n    and \"(oid, oper) \\<in> set xs\"\n    and \"r \\<in> deps oper\"\n  shows \"r < oid\"", "lemma crdt_ops_ref_less_last:\n  assumes \"crdt_ops (xs @ [(oid, oper)]) deps\"\n    and \"r \\<in> deps oper\"\n  shows \"r < oid\"", "lemma crdt_ops_distinct_fst:\n  assumes \"crdt_ops xs deps\"\n  shows \"distinct (map fst xs)\"", "lemma crdt_ops_distinct:\n  assumes \"crdt_ops xs deps\"\n  shows \"distinct xs\"", "lemma crdt_ops_unique_last:\n  assumes \"crdt_ops (xs @ [(oid, oper)]) deps\"\n  shows \"oid \\<notin> set (map fst xs)\"", "lemma crdt_ops_unique_mid:\n  assumes \"crdt_ops (xs @ [(oid, oper)] @ ys) deps\"\n  shows \"oid \\<notin> set (map fst xs) \\<and> oid \\<notin> set (map fst ys)\"", "lemma crdt_ops_ref_exists:\n  assumes \"crdt_ops (pre @ (oid, oper) # suf) deps\"\n    and \"ref \\<in> deps oper\"\n  shows \"ref \\<in> fst ` set pre\"", "lemma crdt_ops_no_future_ref:\n  assumes \"crdt_ops (xs @ [(oid, oper)] @ ys) deps\"\n  shows \"\\<And>ref. ref \\<in> deps oper \\<Longrightarrow> ref \\<notin> fst ` set ys\"", "lemma crdt_ops_reorder:\n  assumes \"crdt_ops (xs @ [(oid, oper)] @ ys) deps\"\n    and \"\\<And>op2 r. op2 \\<in> snd ` set ys \\<Longrightarrow> r \\<in> deps op2 \\<Longrightarrow> r \\<noteq> oid\"\n  shows \"crdt_ops (xs @ ys @ [(oid, oper)]) deps\"", "lemma crdt_ops_rem_middle:\n  assumes \"crdt_ops (xs @ [(oid, ref)] @ ys) deps\"\n    and \"\\<And>op2 r. op2 \\<in> snd ` set ys \\<Longrightarrow> r \\<in> deps op2 \\<Longrightarrow> r \\<noteq> oid\"\n  shows \"crdt_ops (xs @ ys) deps\"", "lemma crdt_ops_independent_suf:\n  assumes \"spec_ops (xs @ [(oid, oper)]) deps\"\n    and \"crdt_ops (ys @ [(oid, oper)] @ zs) deps\"\n    and \"set (xs @ [(oid, oper)]) = set (ys @ [(oid, oper)] @ zs)\"\n  shows \"\\<And>op2 r. op2 \\<in> snd ` set zs \\<Longrightarrow> r \\<in> deps op2 \\<Longrightarrow> r \\<noteq> oid\"", "lemma crdt_ops_reorder_spec:\n  assumes \"spec_ops (xs @ [x]) deps\"\n    and \"crdt_ops (ys @ [x] @ zs) deps\"\n    and \"set (xs @ [x]) = set (ys @ [x] @ zs)\"\n  shows \"crdt_ops (ys @ zs @ [x]) deps\"", "lemma crdt_ops_rem_spec:\n  assumes \"spec_ops (xs @ [x]) deps\"\n    and \"crdt_ops (ys @ [x] @ zs) deps\"\n    and \"set (xs @ [x]) = set (ys @ [x] @ zs)\"\n  shows \"crdt_ops (ys @ zs) deps\"", "lemma crdt_ops_rem_penultimate:\n  assumes \"crdt_ops (xs @ [(i1, r1)] @ [(i2, r2)]) deps\"\n    and \"\\<And>r. r \\<in> deps r2 \\<Longrightarrow> r \\<noteq> i1\"\n  shows \"crdt_ops (xs @ [(i2, r2)]) deps\"", "lemma crdt_ops_spec_ops_exist:\n  assumes \"crdt_ops xs deps\"\n  shows \"\\<exists>ys. set xs = set ys \\<and> spec_ops ys deps\""], "translations": [["", "lemma opset_subset:\n  assumes \"opset Y deps\"\n    and \"X \\<subseteq> Y\"\n  shows \"opset X deps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. opset X deps", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>oid op1 op2.\n       \\<lbrakk>(oid, op1) \\<in> X; (oid, op2) \\<in> X\\<rbrakk>\n       \\<Longrightarrow> op1 = op2\n 2. \\<And>oid oper ref.\n       \\<lbrakk>(oid, oper) \\<in> X; ref \\<in> deps oper\\<rbrakk>\n       \\<Longrightarrow> ref < oid\n 3. finite X", "fix oid op1 op2"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>oid op1 op2.\n       \\<lbrakk>(oid, op1) \\<in> X; (oid, op2) \\<in> X\\<rbrakk>\n       \\<Longrightarrow> op1 = op2\n 2. \\<And>oid oper ref.\n       \\<lbrakk>(oid, oper) \\<in> X; ref \\<in> deps oper\\<rbrakk>\n       \\<Longrightarrow> ref < oid\n 3. finite X", "assume \"(oid, op1) \\<in> X\" and \"(oid, op2) \\<in> X\""], ["proof (state)\nthis:\n  (oid, op1) \\<in> X\n  (oid, op2) \\<in> X\n\ngoal (3 subgoals):\n 1. \\<And>oid op1 op2.\n       \\<lbrakk>(oid, op1) \\<in> X; (oid, op2) \\<in> X\\<rbrakk>\n       \\<Longrightarrow> op1 = op2\n 2. \\<And>oid oper ref.\n       \\<lbrakk>(oid, oper) \\<in> X; ref \\<in> deps oper\\<rbrakk>\n       \\<Longrightarrow> ref < oid\n 3. finite X", "thus \"op1 = op2\""], ["proof (prove)\nusing this:\n  (oid, op1) \\<in> X\n  (oid, op2) \\<in> X\n\ngoal (1 subgoal):\n 1. op1 = op2", "using assms"], ["proof (prove)\nusing this:\n  (oid, op1) \\<in> X\n  (oid, op2) \\<in> X\n  opset Y deps\n  X \\<subseteq> Y\n\ngoal (1 subgoal):\n 1. op1 = op2", "by (meson opset.unique_oid subsetD)"], ["proof (state)\nthis:\n  op1 = op2\n\ngoal (2 subgoals):\n 1. \\<And>oid oper ref.\n       \\<lbrakk>(oid, oper) \\<in> X; ref \\<in> deps oper\\<rbrakk>\n       \\<Longrightarrow> ref < oid\n 2. finite X", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>oid oper ref.\n       \\<lbrakk>(oid, oper) \\<in> X; ref \\<in> deps oper\\<rbrakk>\n       \\<Longrightarrow> ref < oid\n 2. finite X", "fix oid oper ref"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>oid oper ref.\n       \\<lbrakk>(oid, oper) \\<in> X; ref \\<in> deps oper\\<rbrakk>\n       \\<Longrightarrow> ref < oid\n 2. finite X", "assume \"(oid, oper) \\<in> X\" and \"ref \\<in> deps oper\""], ["proof (state)\nthis:\n  (oid, oper) \\<in> X\n  ref \\<in> deps oper\n\ngoal (2 subgoals):\n 1. \\<And>oid oper ref.\n       \\<lbrakk>(oid, oper) \\<in> X; ref \\<in> deps oper\\<rbrakk>\n       \\<Longrightarrow> ref < oid\n 2. finite X", "thus \"ref < oid\""], ["proof (prove)\nusing this:\n  (oid, oper) \\<in> X\n  ref \\<in> deps oper\n\ngoal (1 subgoal):\n 1. ref < oid", "using assms"], ["proof (prove)\nusing this:\n  (oid, oper) \\<in> X\n  ref \\<in> deps oper\n  opset Y deps\n  X \\<subseteq> Y\n\ngoal (1 subgoal):\n 1. ref < oid", "by (meson opset.ref_older rev_subsetD)"], ["proof (state)\nthis:\n  ref < oid\n\ngoal (1 subgoal):\n 1. finite X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. finite X", "show \"finite X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite X", "using assms opset.finite_opset finite_subset"], ["proof (prove)\nusing this:\n  opset Y deps\n  X \\<subseteq> Y\n  opset ?opset ?deps \\<Longrightarrow> finite ?opset\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite X", "by blast"], ["proof (state)\nthis:\n  finite X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma opset_insert:\n  assumes \"opset (insert x ops) deps\"\n  shows \"opset ops deps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. opset ops deps", "using assms opset_subset"], ["proof (prove)\nusing this:\n  opset (insert x ops) deps\n  \\<lbrakk>opset ?Y ?deps; ?X \\<subseteq> ?Y\\<rbrakk>\n  \\<Longrightarrow> opset ?X ?deps\n\ngoal (1 subgoal):\n 1. opset ops deps", "by blast"], ["", "lemma opset_sublist:\n  assumes \"opset (set (xs @ ys @ zs)) deps\"\n  shows \"opset (set (xs @ zs)) deps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. opset (set (xs @ zs)) deps", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. opset (set (xs @ zs)) deps", "have \"set (xs @ zs) \\<subseteq> set (xs @ ys @ zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (xs @ zs) \\<subseteq> set (xs @ ys @ zs)", "by auto"], ["proof (state)\nthis:\n  set (xs @ zs) \\<subseteq> set (xs @ ys @ zs)\n\ngoal (1 subgoal):\n 1. opset (set (xs @ zs)) deps", "thus \"opset (set (xs @ zs)) deps\""], ["proof (prove)\nusing this:\n  set (xs @ zs) \\<subseteq> set (xs @ ys @ zs)\n\ngoal (1 subgoal):\n 1. opset (set (xs @ zs)) deps", "using assms opset_subset"], ["proof (prove)\nusing this:\n  set (xs @ zs) \\<subseteq> set (xs @ ys @ zs)\n  opset (set (xs @ ys @ zs)) deps\n  \\<lbrakk>opset ?Y ?deps; ?X \\<subseteq> ?Y\\<rbrakk>\n  \\<Longrightarrow> opset ?X ?deps\n\ngoal (1 subgoal):\n 1. opset (set (xs @ zs)) deps", "by blast"], ["proof (state)\nthis:\n  opset (set (xs @ zs)) deps\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Helper lemmas about lists\\<close>"], ["", "text\\<open>Some general-purpose lemas about lists and sets that are helpful for\nsubsequent proofs.\\<close>"], ["", "lemma distinct_rem_mid:\n  assumes \"distinct (xs @ [x] @ ys)\"\n  shows \"distinct (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (xs @ ys)", "using assms"], ["proof (prove)\nusing this:\n  distinct (xs @ [x] @ ys)\n\ngoal (1 subgoal):\n 1. distinct (xs @ ys)", "by (induction ys rule: rev_induct, simp_all)"], ["", "lemma distinct_fst_append:\n  assumes \"x \\<in> set (map fst xs)\"\n    and \"distinct (map fst (xs @ ys))\"\n  shows \"x \\<notin> set (map fst ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set (map fst ys)", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> set (map fst xs)\n  distinct (map fst (xs @ ys))\n\ngoal (1 subgoal):\n 1. x \\<notin> set (map fst ys)", "by (induction ys, force+)"], ["", "lemma distinct_set_remove_last:\n  assumes \"distinct (xs @ [x])\"\n  shows \"set xs = set (xs @ [x]) - {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs = set (xs @ [x]) - {x}", "using assms"], ["proof (prove)\nusing this:\n  distinct (xs @ [x])\n\ngoal (1 subgoal):\n 1. set xs = set (xs @ [x]) - {x}", "by force"], ["", "lemma distinct_set_remove_mid:\n  assumes \"distinct (xs @ [x] @ ys)\"\n  shows \"set (xs @ ys) = set (xs @ [x] @ ys) - {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (xs @ ys) = set (xs @ [x] @ ys) - {x}", "using assms"], ["proof (prove)\nusing this:\n  distinct (xs @ [x] @ ys)\n\ngoal (1 subgoal):\n 1. set (xs @ ys) = set (xs @ [x] @ ys) - {x}", "by force"], ["", "lemma distinct_list_split:\n  assumes \"distinct xs\"\n    and \"xs = xa @ x # ya\"\n    and \"xs = xb @ x # yb\"\n  shows \"xa = xb \\<and> ya = yb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xa = xb \\<and> ya = yb", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n  xs = xa @ x # ya\n  xs = xb @ x # yb\n\ngoal (1 subgoal):\n 1. xa = xb \\<and> ya = yb", "proof(induction xs arbitrary: xa xb x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa xb x.\n       \\<lbrakk>distinct []; [] = xa @ x # ya; [] = xb @ x # yb\\<rbrakk>\n       \\<Longrightarrow> xa = xb \\<and> ya = yb\n 2. \\<And>a xs xa xb x.\n       \\<lbrakk>\\<And>xa xb x.\n                   \\<lbrakk>distinct xs; xs = xa @ x # ya;\n                    xs = xb @ x # yb\\<rbrakk>\n                   \\<Longrightarrow> xa = xb \\<and> ya = yb;\n        distinct (a # xs); a # xs = xa @ x # ya;\n        a # xs = xb @ x # yb\\<rbrakk>\n       \\<Longrightarrow> xa = xb \\<and> ya = yb", "fix xa xb x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa xb x.\n       \\<lbrakk>distinct []; [] = xa @ x # ya; [] = xb @ x # yb\\<rbrakk>\n       \\<Longrightarrow> xa = xb \\<and> ya = yb\n 2. \\<And>a xs xa xb x.\n       \\<lbrakk>\\<And>xa xb x.\n                   \\<lbrakk>distinct xs; xs = xa @ x # ya;\n                    xs = xb @ x # yb\\<rbrakk>\n                   \\<Longrightarrow> xa = xb \\<and> ya = yb;\n        distinct (a # xs); a # xs = xa @ x # ya;\n        a # xs = xb @ x # yb\\<rbrakk>\n       \\<Longrightarrow> xa = xb \\<and> ya = yb", "assume \"[] = xa @ x # ya\""], ["proof (state)\nthis:\n  [] = xa @ x # ya\n\ngoal (2 subgoals):\n 1. \\<And>xa xb x.\n       \\<lbrakk>distinct []; [] = xa @ x # ya; [] = xb @ x # yb\\<rbrakk>\n       \\<Longrightarrow> xa = xb \\<and> ya = yb\n 2. \\<And>a xs xa xb x.\n       \\<lbrakk>\\<And>xa xb x.\n                   \\<lbrakk>distinct xs; xs = xa @ x # ya;\n                    xs = xb @ x # yb\\<rbrakk>\n                   \\<Longrightarrow> xa = xb \\<and> ya = yb;\n        distinct (a # xs); a # xs = xa @ x # ya;\n        a # xs = xb @ x # yb\\<rbrakk>\n       \\<Longrightarrow> xa = xb \\<and> ya = yb", "thus \"xa = xb \\<and> ya = yb\""], ["proof (prove)\nusing this:\n  [] = xa @ x # ya\n\ngoal (1 subgoal):\n 1. xa = xb \\<and> ya = yb", "by auto"], ["proof (state)\nthis:\n  xa = xb \\<and> ya = yb\n\ngoal (1 subgoal):\n 1. \\<And>a xs xa xb x.\n       \\<lbrakk>\\<And>xa xb x.\n                   \\<lbrakk>distinct xs; xs = xa @ x # ya;\n                    xs = xb @ x # yb\\<rbrakk>\n                   \\<Longrightarrow> xa = xb \\<and> ya = yb;\n        distinct (a # xs); a # xs = xa @ x # ya;\n        a # xs = xb @ x # yb\\<rbrakk>\n       \\<Longrightarrow> xa = xb \\<and> ya = yb", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs xa xb x.\n       \\<lbrakk>\\<And>xa xb x.\n                   \\<lbrakk>distinct xs; xs = xa @ x # ya;\n                    xs = xb @ x # yb\\<rbrakk>\n                   \\<Longrightarrow> xa = xb \\<and> ya = yb;\n        distinct (a # xs); a # xs = xa @ x # ya;\n        a # xs = xb @ x # yb\\<rbrakk>\n       \\<Longrightarrow> xa = xb \\<and> ya = yb", "fix a xs xa xb x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs xa xb x.\n       \\<lbrakk>\\<And>xa xb x.\n                   \\<lbrakk>distinct xs; xs = xa @ x # ya;\n                    xs = xb @ x # yb\\<rbrakk>\n                   \\<Longrightarrow> xa = xb \\<and> ya = yb;\n        distinct (a # xs); a # xs = xa @ x # ya;\n        a # xs = xb @ x # yb\\<rbrakk>\n       \\<Longrightarrow> xa = xb \\<and> ya = yb", "assume IH: \"\\<And>xa xb x. distinct xs \\<Longrightarrow> xs = xa @ x # ya \\<Longrightarrow> xs = xb @ x # yb \\<Longrightarrow> xa = xb \\<and> ya = yb\"\n    and \"distinct (a # xs)\" and \"a # xs = xa @ x # ya\" and \"a # xs = xb @ x # yb\""], ["proof (state)\nthis:\n  \\<lbrakk>distinct xs; xs = ?xa @ ?x # ya; xs = ?xb @ ?x # yb\\<rbrakk>\n  \\<Longrightarrow> ?xa = ?xb \\<and> ya = yb\n  distinct (a # xs)\n  a # xs = xa @ x # ya\n  a # xs = xb @ x # yb\n\ngoal (1 subgoal):\n 1. \\<And>a xs xa xb x.\n       \\<lbrakk>\\<And>xa xb x.\n                   \\<lbrakk>distinct xs; xs = xa @ x # ya;\n                    xs = xb @ x # yb\\<rbrakk>\n                   \\<Longrightarrow> xa = xb \\<and> ya = yb;\n        distinct (a # xs); a # xs = xa @ x # ya;\n        a # xs = xb @ x # yb\\<rbrakk>\n       \\<Longrightarrow> xa = xb \\<and> ya = yb", "thus \"xa = xb \\<and> ya = yb\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct xs; xs = ?xa @ ?x # ya; xs = ?xb @ ?x # yb\\<rbrakk>\n  \\<Longrightarrow> ?xa = ?xb \\<and> ya = yb\n  distinct (a # xs)\n  a # xs = xa @ x # ya\n  a # xs = xb @ x # yb\n\ngoal (1 subgoal):\n 1. xa = xb \\<and> ya = yb", "by(case_tac xa; case_tac xb) auto"], ["proof (state)\nthis:\n  xa = xb \\<and> ya = yb\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_append_swap:\n  assumes \"distinct (xs @ ys)\"\n  shows \"distinct (ys @ xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (ys @ xs)", "using assms"], ["proof (prove)\nusing this:\n  distinct (xs @ ys)\n\ngoal (1 subgoal):\n 1. distinct (ys @ xs)", "by (induction ys, auto)"], ["", "lemma append_subset:\n  assumes \"set xs = set (ys @ zs)\"\n  shows \"set ys \\<subseteq> set xs\" and \"set zs \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ys \\<subseteq> set xs &&& set zs \\<subseteq> set xs", "by (metis Un_iff assms set_append subsetI)+"], ["", "lemma append_set_rem_last:\n  assumes \"set (xs @ [x]) = set (ys @ [x] @ zs)\"\n    and \"distinct (xs @ [x])\" and \"distinct (ys @ [x] @ zs)\"\n  shows \"set xs = set (ys @ zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs = set (ys @ zs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set xs = set (ys @ zs)", "have \"distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs", "using assms distinct_append"], ["proof (prove)\nusing this:\n  set (xs @ [x]) = set (ys @ [x] @ zs)\n  distinct (xs @ [x])\n  distinct (ys @ [x] @ zs)\n  distinct (?xs @ ?ys) =\n  (distinct ?xs \\<and> distinct ?ys \\<and> set ?xs \\<inter> set ?ys = {})\n\ngoal (1 subgoal):\n 1. distinct xs", "by blast"], ["proof (state)\nthis:\n  distinct xs\n\ngoal (1 subgoal):\n 1. set xs = set (ys @ zs)", "moreover"], ["proof (state)\nthis:\n  distinct xs\n\ngoal (1 subgoal):\n 1. set xs = set (ys @ zs)", "from this"], ["proof (chain)\npicking this:\n  distinct xs", "have \"set xs = set (xs @ [x]) - {x}\""], ["proof (prove)\nusing this:\n  distinct xs\n\ngoal (1 subgoal):\n 1. set xs = set (xs @ [x]) - {x}", "by (meson assms distinct_set_remove_last)"], ["proof (state)\nthis:\n  set xs = set (xs @ [x]) - {x}\n\ngoal (1 subgoal):\n 1. set xs = set (ys @ zs)", "moreover"], ["proof (state)\nthis:\n  set xs = set (xs @ [x]) - {x}\n\ngoal (1 subgoal):\n 1. set xs = set (ys @ zs)", "have \"distinct (ys @ zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (ys @ zs)", "using assms distinct_rem_mid"], ["proof (prove)\nusing this:\n  set (xs @ [x]) = set (ys @ [x] @ zs)\n  distinct (xs @ [x])\n  distinct (ys @ [x] @ zs)\n  distinct (?xs @ [?x] @ ?ys) \\<Longrightarrow> distinct (?xs @ ?ys)\n\ngoal (1 subgoal):\n 1. distinct (ys @ zs)", "by simp"], ["proof (state)\nthis:\n  distinct (ys @ zs)\n\ngoal (1 subgoal):\n 1. set xs = set (ys @ zs)", "ultimately"], ["proof (chain)\npicking this:\n  distinct xs\n  set xs = set (xs @ [x]) - {x}\n  distinct (ys @ zs)", "show \"set xs = set (ys @ zs)\""], ["proof (prove)\nusing this:\n  distinct xs\n  set xs = set (xs @ [x]) - {x}\n  distinct (ys @ zs)\n\ngoal (1 subgoal):\n 1. set xs = set (ys @ zs)", "using assms distinct_set_remove_mid"], ["proof (prove)\nusing this:\n  distinct xs\n  set xs = set (xs @ [x]) - {x}\n  distinct (ys @ zs)\n  set (xs @ [x]) = set (ys @ [x] @ zs)\n  distinct (xs @ [x])\n  distinct (ys @ [x] @ zs)\n  distinct (?xs @ [?x] @ ?ys) \\<Longrightarrow>\n  set (?xs @ ?ys) = set (?xs @ [?x] @ ?ys) - {?x}\n\ngoal (1 subgoal):\n 1. set xs = set (ys @ zs)", "by metis"], ["proof (state)\nthis:\n  set xs = set (ys @ zs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_map_fst_remove1:\n  assumes \"distinct (map fst xs)\"\n  shows \"distinct (map fst (remove1 x xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (remove1 x xs))", "using assms"], ["proof (prove)\nusing this:\n  distinct (map fst xs)\n\ngoal (1 subgoal):\n 1. distinct (map fst (remove1 x xs))", "proof(induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct (map fst []) \\<Longrightarrow>\n    distinct (map fst (remove1 x []))\n 2. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                distinct (map fst (remove1 x xs));\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (remove1 x (a # xs)))", "case Nil"], ["proof (state)\nthis:\n  distinct (map fst [])\n\ngoal (2 subgoals):\n 1. distinct (map fst []) \\<Longrightarrow>\n    distinct (map fst (remove1 x []))\n 2. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                distinct (map fst (remove1 x xs));\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (remove1 x (a # xs)))", "then"], ["proof (chain)\npicking this:\n  distinct (map fst [])", "show \"distinct (map fst (remove1 x []))\""], ["proof (prove)\nusing this:\n  distinct (map fst [])\n\ngoal (1 subgoal):\n 1. distinct (map fst (remove1 x []))", "by simp"], ["proof (state)\nthis:\n  distinct (map fst (remove1 x []))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                distinct (map fst (remove1 x xs));\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (remove1 x (a # xs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                distinct (map fst (remove1 x xs));\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (remove1 x (a # xs)))", "case (Cons a xs)"], ["proof (state)\nthis:\n  distinct (map fst xs) \\<Longrightarrow> distinct (map fst (remove1 x xs))\n  distinct (map fst (a # xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                distinct (map fst (remove1 x xs));\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (remove1 x (a # xs)))", "hence IH: \"distinct (map fst (remove1 x xs))\""], ["proof (prove)\nusing this:\n  distinct (map fst xs) \\<Longrightarrow> distinct (map fst (remove1 x xs))\n  distinct (map fst (a # xs))\n\ngoal (1 subgoal):\n 1. distinct (map fst (remove1 x xs))", "by simp"], ["proof (state)\nthis:\n  distinct (map fst (remove1 x xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct (map fst xs) \\<Longrightarrow>\n                distinct (map fst (remove1 x xs));\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (remove1 x (a # xs)))", "then"], ["proof (chain)\npicking this:\n  distinct (map fst (remove1 x xs))", "show \"distinct (map fst (remove1 x (a # xs)))\""], ["proof (prove)\nusing this:\n  distinct (map fst (remove1 x xs))\n\ngoal (1 subgoal):\n 1. distinct (map fst (remove1 x (a # xs)))", "proof(cases \"a = x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst (remove1 x xs)); a = x\\<rbrakk>\n    \\<Longrightarrow> distinct (map fst (remove1 x (a # xs)))\n 2. \\<lbrakk>distinct (map fst (remove1 x xs)); a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> distinct (map fst (remove1 x (a # xs)))", "case True"], ["proof (state)\nthis:\n  a = x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst (remove1 x xs)); a = x\\<rbrakk>\n    \\<Longrightarrow> distinct (map fst (remove1 x (a # xs)))\n 2. \\<lbrakk>distinct (map fst (remove1 x xs)); a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> distinct (map fst (remove1 x (a # xs)))", "then"], ["proof (chain)\npicking this:\n  a = x", "show ?thesis"], ["proof (prove)\nusing this:\n  a = x\n\ngoal (1 subgoal):\n 1. distinct (map fst (remove1 x (a # xs)))", "using Cons.prems"], ["proof (prove)\nusing this:\n  a = x\n  distinct (map fst (a # xs))\n\ngoal (1 subgoal):\n 1. distinct (map fst (remove1 x (a # xs)))", "by auto"], ["proof (state)\nthis:\n  distinct (map fst (remove1 x (a # xs)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst (remove1 x xs)); a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> distinct (map fst (remove1 x (a # xs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst (remove1 x xs)); a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> distinct (map fst (remove1 x (a # xs)))", "case False"], ["proof (state)\nthis:\n  a \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst (remove1 x xs)); a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> distinct (map fst (remove1 x (a # xs)))", "moreover"], ["proof (state)\nthis:\n  a \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst (remove1 x xs)); a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> distinct (map fst (remove1 x (a # xs)))", "have \"fst a \\<notin> fst ` set (remove1 x xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst a \\<notin> fst ` set (remove1 x xs)", "by (metis (no_types, lifting) Cons.prems distinct.simps(2) image_iff\n          list.simps(9) notin_set_remove1 set_map)"], ["proof (state)\nthis:\n  fst a \\<notin> fst ` set (remove1 x xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst (remove1 x xs)); a \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> distinct (map fst (remove1 x (a # xs)))", "ultimately"], ["proof (chain)\npicking this:\n  a \\<noteq> x\n  fst a \\<notin> fst ` set (remove1 x xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<noteq> x\n  fst a \\<notin> fst ` set (remove1 x xs)\n\ngoal (1 subgoal):\n 1. distinct (map fst (remove1 x (a # xs)))", "using IH"], ["proof (prove)\nusing this:\n  a \\<noteq> x\n  fst a \\<notin> fst ` set (remove1 x xs)\n  distinct (map fst (remove1 x xs))\n\ngoal (1 subgoal):\n 1. distinct (map fst (remove1 x (a # xs)))", "by auto"], ["proof (state)\nthis:\n  distinct (map fst (remove1 x (a # xs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (map fst (remove1 x (a # xs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>The \\isa{spec-ops} predicate\\<close>"], ["", "text\\<open>The \\isa{spec-ops} predicate describes a list of (ID, operation) pairs that\ncorresponds to the linearisation of an OpSet, and which we use for sequentially\ninterpreting the OpSet. A list satisfies \\isa{spec-ops} iff it is sorted in ascending\norder of IDs, if the IDs are unique, and if every operation's dependencies have\nlower IDs than the operation itself. A list is implicitly finite in Isabelle/HOL.\nThese requirements correspond to the OpSet definition above, and indeed we prove\nlater that every OpSet has a linearisation that satisfies \\isa{spec-ops}.\\<close>"], ["", "definition spec_ops :: \"('oid::{linorder} \\<times> 'oper) list \\<Rightarrow> ('oper \\<Rightarrow> 'oid set) \\<Rightarrow> bool\" where\n  \"spec_ops ops deps \\<equiv> (sorted (map fst ops) \\<and> distinct (map fst ops) \\<and>\n           (\\<forall>oid oper ref. (oid, oper) \\<in> set ops \\<and> ref \\<in> deps oper \\<longrightarrow> ref < oid))\""], ["", "lemma spec_ops_empty:\n  shows \"spec_ops [] deps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec_ops [] deps", "by (simp add: spec_ops_def)"], ["", "lemma spec_ops_distinct:\n  assumes \"spec_ops ops deps\"\n  shows \"distinct ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct ops", "using assms distinct_map spec_ops_def"], ["proof (prove)\nusing this:\n  spec_ops ops deps\n  distinct (map ?f ?xs) = (distinct ?xs \\<and> inj_on ?f (set ?xs))\n  spec_ops ?ops ?deps \\<equiv>\n  sorted (map fst ?ops) \\<and>\n  distinct (map fst ?ops) \\<and>\n  (\\<forall>oid oper ref.\n      (oid, oper) \\<in> set ?ops \\<and>\n      ref \\<in> ?deps oper \\<longrightarrow>\n      ref < oid)\n\ngoal (1 subgoal):\n 1. distinct ops", "by blast"], ["", "lemma spec_ops_distinct_fst:\n  assumes \"spec_ops ops deps\"\n  shows \"distinct (map fst ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst ops)", "using assms"], ["proof (prove)\nusing this:\n  spec_ops ops deps\n\ngoal (1 subgoal):\n 1. distinct (map fst ops)", "by (simp add: spec_ops_def)"], ["", "lemma spec_ops_sorted:\n  assumes \"spec_ops ops deps\"\n  shows \"sorted (map fst ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (map fst ops)", "using assms"], ["proof (prove)\nusing this:\n  spec_ops ops deps\n\ngoal (1 subgoal):\n 1. sorted (map fst ops)", "by (simp add: spec_ops_def)"], ["", "lemma spec_ops_rem_cons:\n  assumes \"spec_ops (x # xs) deps\"\n  shows \"spec_ops xs deps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec_ops xs deps", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. spec_ops xs deps", "have \"sorted (map fst (x # xs))\" and \"distinct (map fst (x # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (map fst (x # xs)) &&& distinct (map fst (x # xs))", "using assms spec_ops_def"], ["proof (prove)\nusing this:\n  spec_ops (x # xs) deps\n  spec_ops ?ops ?deps \\<equiv>\n  sorted (map fst ?ops) \\<and>\n  distinct (map fst ?ops) \\<and>\n  (\\<forall>oid oper ref.\n      (oid, oper) \\<in> set ?ops \\<and>\n      ref \\<in> ?deps oper \\<longrightarrow>\n      ref < oid)\n\ngoal (1 subgoal):\n 1. sorted (map fst (x # xs)) &&& distinct (map fst (x # xs))", "by blast+"], ["proof (state)\nthis:\n  sorted (map fst (x # xs))\n  distinct (map fst (x # xs))\n\ngoal (1 subgoal):\n 1. spec_ops xs deps", "moreover"], ["proof (state)\nthis:\n  sorted (map fst (x # xs))\n  distinct (map fst (x # xs))\n\ngoal (1 subgoal):\n 1. spec_ops xs deps", "from this"], ["proof (chain)\npicking this:\n  sorted (map fst (x # xs))\n  distinct (map fst (x # xs))", "have \"sorted (map fst xs)\""], ["proof (prove)\nusing this:\n  sorted (map fst (x # xs))\n  distinct (map fst (x # xs))\n\ngoal (1 subgoal):\n 1. sorted (map fst xs)", "by simp"], ["proof (state)\nthis:\n  sorted (map fst xs)\n\ngoal (1 subgoal):\n 1. spec_ops xs deps", "moreover"], ["proof (state)\nthis:\n  sorted (map fst xs)\n\ngoal (1 subgoal):\n 1. spec_ops xs deps", "have \"\\<forall>oid oper ref. (oid, oper) \\<in> set xs \\<and> ref \\<in> deps oper \\<longrightarrow> ref < oid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>oid oper ref.\n       (oid, oper) \\<in> set xs \\<and> ref \\<in> deps oper \\<longrightarrow>\n       ref < oid", "by (meson assms set_subset_Cons spec_ops_def subsetCE)"], ["proof (state)\nthis:\n  \\<forall>oid oper ref.\n     (oid, oper) \\<in> set xs \\<and> ref \\<in> deps oper \\<longrightarrow>\n     ref < oid\n\ngoal (1 subgoal):\n 1. spec_ops xs deps", "ultimately"], ["proof (chain)\npicking this:\n  sorted (map fst (x # xs))\n  distinct (map fst (x # xs))\n  sorted (map fst xs)\n  \\<forall>oid oper ref.\n     (oid, oper) \\<in> set xs \\<and> ref \\<in> deps oper \\<longrightarrow>\n     ref < oid", "show \"spec_ops xs deps\""], ["proof (prove)\nusing this:\n  sorted (map fst (x # xs))\n  distinct (map fst (x # xs))\n  sorted (map fst xs)\n  \\<forall>oid oper ref.\n     (oid, oper) \\<in> set xs \\<and> ref \\<in> deps oper \\<longrightarrow>\n     ref < oid\n\ngoal (1 subgoal):\n 1. spec_ops xs deps", "by (simp add: spec_ops_def)"], ["proof (state)\nthis:\n  spec_ops xs deps\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma spec_ops_rem_last:\n  assumes \"spec_ops (xs @ [x]) deps\"\n  shows \"spec_ops xs deps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec_ops xs deps", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. spec_ops xs deps", "have \"sorted (map fst (xs @ [x]))\" and \"distinct (map fst (xs @ [x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (map fst (xs @ [x])) &&& distinct (map fst (xs @ [x]))", "using assms spec_ops_def"], ["proof (prove)\nusing this:\n  spec_ops (xs @ [x]) deps\n  spec_ops ?ops ?deps \\<equiv>\n  sorted (map fst ?ops) \\<and>\n  distinct (map fst ?ops) \\<and>\n  (\\<forall>oid oper ref.\n      (oid, oper) \\<in> set ?ops \\<and>\n      ref \\<in> ?deps oper \\<longrightarrow>\n      ref < oid)\n\ngoal (1 subgoal):\n 1. sorted (map fst (xs @ [x])) &&& distinct (map fst (xs @ [x]))", "by blast+"], ["proof (state)\nthis:\n  sorted (map fst (xs @ [x]))\n  distinct (map fst (xs @ [x]))\n\ngoal (1 subgoal):\n 1. spec_ops xs deps", "moreover"], ["proof (state)\nthis:\n  sorted (map fst (xs @ [x]))\n  distinct (map fst (xs @ [x]))\n\ngoal (1 subgoal):\n 1. spec_ops xs deps", "from this"], ["proof (chain)\npicking this:\n  sorted (map fst (xs @ [x]))\n  distinct (map fst (xs @ [x]))", "have \"sorted (map fst xs)\" and \"distinct xs\""], ["proof (prove)\nusing this:\n  sorted (map fst (xs @ [x]))\n  distinct (map fst (xs @ [x]))\n\ngoal (1 subgoal):\n 1. sorted (map fst xs) &&& distinct xs", "by (auto simp add: sorted_append distinct_butlast distinct_map)"], ["proof (state)\nthis:\n  sorted (map fst xs)\n  distinct xs\n\ngoal (1 subgoal):\n 1. spec_ops xs deps", "moreover"], ["proof (state)\nthis:\n  sorted (map fst xs)\n  distinct xs\n\ngoal (1 subgoal):\n 1. spec_ops xs deps", "have \"\\<forall>oid oper ref. (oid, oper) \\<in> set xs \\<and> ref \\<in> deps oper \\<longrightarrow> ref < oid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>oid oper ref.\n       (oid, oper) \\<in> set xs \\<and> ref \\<in> deps oper \\<longrightarrow>\n       ref < oid", "by (metis assms butlast_snoc in_set_butlastD spec_ops_def)"], ["proof (state)\nthis:\n  \\<forall>oid oper ref.\n     (oid, oper) \\<in> set xs \\<and> ref \\<in> deps oper \\<longrightarrow>\n     ref < oid\n\ngoal (1 subgoal):\n 1. spec_ops xs deps", "ultimately"], ["proof (chain)\npicking this:\n  sorted (map fst (xs @ [x]))\n  distinct (map fst (xs @ [x]))\n  sorted (map fst xs)\n  distinct xs\n  \\<forall>oid oper ref.\n     (oid, oper) \\<in> set xs \\<and> ref \\<in> deps oper \\<longrightarrow>\n     ref < oid", "show \"spec_ops xs deps\""], ["proof (prove)\nusing this:\n  sorted (map fst (xs @ [x]))\n  distinct (map fst (xs @ [x]))\n  sorted (map fst xs)\n  distinct xs\n  \\<forall>oid oper ref.\n     (oid, oper) \\<in> set xs \\<and> ref \\<in> deps oper \\<longrightarrow>\n     ref < oid\n\ngoal (1 subgoal):\n 1. spec_ops xs deps", "by (simp add: spec_ops_def)"], ["proof (state)\nthis:\n  spec_ops xs deps\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma spec_ops_remove1:\n  assumes \"spec_ops xs deps\"\n  shows \"spec_ops (remove1 x xs) deps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec_ops (remove1 x xs) deps", "using assms distinct_map_fst_remove1 spec_ops_def"], ["proof (prove)\nusing this:\n  spec_ops xs deps\n  distinct (map fst ?xs) \\<Longrightarrow>\n  distinct (map fst (remove1 ?x ?xs))\n  spec_ops ?ops ?deps \\<equiv>\n  sorted (map fst ?ops) \\<and>\n  distinct (map fst ?ops) \\<and>\n  (\\<forall>oid oper ref.\n      (oid, oper) \\<in> set ?ops \\<and>\n      ref \\<in> ?deps oper \\<longrightarrow>\n      ref < oid)\n\ngoal (1 subgoal):\n 1. spec_ops (remove1 x xs) deps", "by (metis notin_set_remove1 sorted_map_remove1 spec_ops_def)"], ["", "lemma spec_ops_ref_less:\n  assumes \"spec_ops xs deps\"\n    and \"(oid, oper) \\<in> set xs\"\n    and \"r \\<in> deps oper\"\n  shows \"r < oid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < oid", "using assms spec_ops_def"], ["proof (prove)\nusing this:\n  spec_ops xs deps\n  (oid, oper) \\<in> set xs\n  r \\<in> deps oper\n  spec_ops ?ops ?deps \\<equiv>\n  sorted (map fst ?ops) \\<and>\n  distinct (map fst ?ops) \\<and>\n  (\\<forall>oid oper ref.\n      (oid, oper) \\<in> set ?ops \\<and>\n      ref \\<in> ?deps oper \\<longrightarrow>\n      ref < oid)\n\ngoal (1 subgoal):\n 1. r < oid", "by force"], ["", "lemma spec_ops_ref_less_last:\n  assumes \"spec_ops (xs @ [(oid, oper)]) deps\"\n    and \"r \\<in> deps oper\"\n  shows \"r < oid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < oid", "using assms spec_ops_ref_less"], ["proof (prove)\nusing this:\n  spec_ops (xs @ [(oid, oper)]) deps\n  r \\<in> deps oper\n  \\<lbrakk>spec_ops ?xs ?deps; (?oid, ?oper) \\<in> set ?xs;\n   ?r \\<in> ?deps ?oper\\<rbrakk>\n  \\<Longrightarrow> ?r < ?oid\n\ngoal (1 subgoal):\n 1. r < oid", "by fastforce"], ["", "lemma spec_ops_id_inc:\n  assumes \"spec_ops (xs @ [(oid, oper)]) deps\"\n    and \"x \\<in> set (map fst xs)\"\n  shows \"x < oid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < oid", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x < oid", "have \"sorted ((map fst xs) @ (map fst [(oid, oper)]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (map fst xs @ map fst [(oid, oper)])", "using assms(1)"], ["proof (prove)\nusing this:\n  spec_ops (xs @ [(oid, oper)]) deps\n\ngoal (1 subgoal):\n 1. sorted (map fst xs @ map fst [(oid, oper)])", "by (simp add: spec_ops_def)"], ["proof (state)\nthis:\n  sorted (map fst xs @ map fst [(oid, oper)])\n\ngoal (1 subgoal):\n 1. x < oid", "hence \"\\<forall>i \\<in> set (map fst xs). i \\<le> oid\""], ["proof (prove)\nusing this:\n  sorted (map fst xs @ map fst [(oid, oper)])\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst xs). i \\<le> oid", "by (simp add: sorted_append)"], ["proof (state)\nthis:\n  \\<forall>i\\<in>set (map fst xs). i \\<le> oid\n\ngoal (1 subgoal):\n 1. x < oid", "moreover"], ["proof (state)\nthis:\n  \\<forall>i\\<in>set (map fst xs). i \\<le> oid\n\ngoal (1 subgoal):\n 1. x < oid", "have \"distinct ((map fst xs) @ (map fst [(oid, oper)]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst xs @ map fst [(oid, oper)])", "using assms(1)"], ["proof (prove)\nusing this:\n  spec_ops (xs @ [(oid, oper)]) deps\n\ngoal (1 subgoal):\n 1. distinct (map fst xs @ map fst [(oid, oper)])", "by (simp add: spec_ops_def)"], ["proof (state)\nthis:\n  distinct (map fst xs @ map fst [(oid, oper)])\n\ngoal (1 subgoal):\n 1. x < oid", "hence \"\\<forall>i \\<in> set (map fst xs). i \\<noteq> oid\""], ["proof (prove)\nusing this:\n  distinct (map fst xs @ map fst [(oid, oper)])\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst xs). i \\<noteq> oid", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<in>set (map fst xs). i \\<noteq> oid\n\ngoal (1 subgoal):\n 1. x < oid", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>set (map fst xs). i \\<le> oid\n  \\<forall>i\\<in>set (map fst xs). i \\<noteq> oid", "show \"x < oid\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>set (map fst xs). i \\<le> oid\n  \\<forall>i\\<in>set (map fst xs). i \\<noteq> oid\n\ngoal (1 subgoal):\n 1. x < oid", "using assms(2) le_neq_trans"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>set (map fst xs). i \\<le> oid\n  \\<forall>i\\<in>set (map fst xs). i \\<noteq> oid\n  x \\<in> set (map fst xs)\n  \\<lbrakk>?a \\<le> ?b; ?a \\<noteq> ?b\\<rbrakk> \\<Longrightarrow> ?a < ?b\n\ngoal (1 subgoal):\n 1. x < oid", "by auto"], ["proof (state)\nthis:\n  x < oid\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma spec_ops_add_last:\n  assumes \"spec_ops xs deps\"\n    and \"\\<forall>i \\<in> set (map fst xs). i < oid\"\n    and \"\\<forall>ref \\<in> deps oper. ref < oid\"\n  shows \"spec_ops (xs @ [(oid, oper)]) deps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec_ops (xs @ [(oid, oper)]) deps", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. spec_ops (xs @ [(oid, oper)]) deps", "have \"sorted ((map fst xs) @ [oid])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (map fst xs @ [oid])", "using assms sorted_append spec_ops_sorted"], ["proof (prove)\nusing this:\n  spec_ops xs deps\n  \\<forall>i\\<in>set (map fst xs). i < oid\n  \\<forall>ref\\<in>deps oper. ref < oid\n  sorted (?xs @ ?ys) =\n  (sorted ?xs \\<and>\n   sorted ?ys \\<and>\n   (\\<forall>x\\<in>set ?xs. \\<forall>y\\<in>set ?ys. x \\<le> y))\n  spec_ops ?ops ?deps \\<Longrightarrow> sorted (map fst ?ops)\n\ngoal (1 subgoal):\n 1. sorted (map fst xs @ [oid])", "by fastforce"], ["proof (state)\nthis:\n  sorted (map fst xs @ [oid])\n\ngoal (1 subgoal):\n 1. spec_ops (xs @ [(oid, oper)]) deps", "moreover"], ["proof (state)\nthis:\n  sorted (map fst xs @ [oid])\n\ngoal (1 subgoal):\n 1. spec_ops (xs @ [(oid, oper)]) deps", "have \"distinct ((map fst xs) @ [oid])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst xs @ [oid])", "using assms spec_ops_distinct_fst"], ["proof (prove)\nusing this:\n  spec_ops xs deps\n  \\<forall>i\\<in>set (map fst xs). i < oid\n  \\<forall>ref\\<in>deps oper. ref < oid\n  spec_ops ?ops ?deps \\<Longrightarrow> distinct (map fst ?ops)\n\ngoal (1 subgoal):\n 1. distinct (map fst xs @ [oid])", "by fastforce"], ["proof (state)\nthis:\n  distinct (map fst xs @ [oid])\n\ngoal (1 subgoal):\n 1. spec_ops (xs @ [(oid, oper)]) deps", "moreover"], ["proof (state)\nthis:\n  distinct (map fst xs @ [oid])\n\ngoal (1 subgoal):\n 1. spec_ops (xs @ [(oid, oper)]) deps", "have \"\\<forall>oid oper ref. (oid, oper) \\<in> set xs \\<and> ref \\<in> deps oper \\<longrightarrow> ref < oid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>oid oper ref.\n       (oid, oper) \\<in> set xs \\<and> ref \\<in> deps oper \\<longrightarrow>\n       ref < oid", "using assms(1) spec_ops_def"], ["proof (prove)\nusing this:\n  spec_ops xs deps\n  spec_ops ?ops ?deps \\<equiv>\n  sorted (map fst ?ops) \\<and>\n  distinct (map fst ?ops) \\<and>\n  (\\<forall>oid oper ref.\n      (oid, oper) \\<in> set ?ops \\<and>\n      ref \\<in> ?deps oper \\<longrightarrow>\n      ref < oid)\n\ngoal (1 subgoal):\n 1. \\<forall>oid oper ref.\n       (oid, oper) \\<in> set xs \\<and> ref \\<in> deps oper \\<longrightarrow>\n       ref < oid", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>oid oper ref.\n     (oid, oper) \\<in> set xs \\<and> ref \\<in> deps oper \\<longrightarrow>\n     ref < oid\n\ngoal (1 subgoal):\n 1. spec_ops (xs @ [(oid, oper)]) deps", "hence \"\\<forall>i opr r. (i, opr) \\<in> set (xs @ [(oid, oper)]) \\<and> r \\<in> deps opr \\<longrightarrow> r < i\""], ["proof (prove)\nusing this:\n  \\<forall>oid oper ref.\n     (oid, oper) \\<in> set xs \\<and> ref \\<in> deps oper \\<longrightarrow>\n     ref < oid\n\ngoal (1 subgoal):\n 1. \\<forall>i opr r.\n       (i, opr) \\<in> set (xs @ [(oid, oper)]) \\<and>\n       r \\<in> deps opr \\<longrightarrow>\n       r < i", "using assms(3)"], ["proof (prove)\nusing this:\n  \\<forall>oid oper ref.\n     (oid, oper) \\<in> set xs \\<and> ref \\<in> deps oper \\<longrightarrow>\n     ref < oid\n  \\<forall>ref\\<in>deps oper. ref < oid\n\ngoal (1 subgoal):\n 1. \\<forall>i opr r.\n       (i, opr) \\<in> set (xs @ [(oid, oper)]) \\<and>\n       r \\<in> deps opr \\<longrightarrow>\n       r < i", "by auto"], ["proof (state)\nthis:\n  \\<forall>i opr r.\n     (i, opr) \\<in> set (xs @ [(oid, oper)]) \\<and>\n     r \\<in> deps opr \\<longrightarrow>\n     r < i\n\ngoal (1 subgoal):\n 1. spec_ops (xs @ [(oid, oper)]) deps", "ultimately"], ["proof (chain)\npicking this:\n  sorted (map fst xs @ [oid])\n  distinct (map fst xs @ [oid])\n  \\<forall>i opr r.\n     (i, opr) \\<in> set (xs @ [(oid, oper)]) \\<and>\n     r \\<in> deps opr \\<longrightarrow>\n     r < i", "show \"spec_ops (xs @ [(oid, oper)]) deps\""], ["proof (prove)\nusing this:\n  sorted (map fst xs @ [oid])\n  distinct (map fst xs @ [oid])\n  \\<forall>i opr r.\n     (i, opr) \\<in> set (xs @ [(oid, oper)]) \\<and>\n     r \\<in> deps opr \\<longrightarrow>\n     r < i\n\ngoal (1 subgoal):\n 1. spec_ops (xs @ [(oid, oper)]) deps", "by (simp add: spec_ops_def)"], ["proof (state)\nthis:\n  spec_ops (xs @ [(oid, oper)]) deps\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma spec_ops_add_any:\n  assumes \"spec_ops (xs @ ys) deps\"\n    and \"\\<forall>i \\<in> set (map fst xs). i < oid\"\n    and \"\\<forall>i \\<in> set (map fst ys). oid < i\"\n    and \"\\<forall>ref \\<in> deps oper. ref < oid\"\n  shows \"spec_ops (xs @ [(oid, oper)] @ ys) deps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec_ops (xs @ [(oid, oper)] @ ys) deps", "using assms"], ["proof (prove)\nusing this:\n  spec_ops (xs @ ys) deps\n  \\<forall>i\\<in>set (map fst xs). i < oid\n  \\<forall>i\\<in>set (map fst ys). oid < i\n  \\<forall>ref\\<in>deps oper. ref < oid\n\ngoal (1 subgoal):\n 1. spec_ops (xs @ [(oid, oper)] @ ys) deps", "proof(induction ys rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>spec_ops (xs @ []) deps;\n     \\<forall>i\\<in>set (map fst xs). i < oid;\n     Ball (set (map fst [])) ((<) oid);\n     \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n    \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ []) deps\n 2. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>spec_ops (xs @ xsa) deps;\n                 \\<forall>i\\<in>set (map fst xs). i < oid;\n                 Ball (set (map fst xsa)) ((<) oid);\n                 \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n                \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ xsa) deps;\n        spec_ops (xs @ xsa @ [x]) deps;\n        \\<forall>i\\<in>set (map fst xs). i < oid;\n        Ball (set (map fst (xsa @ [x]))) ((<) oid);\n        \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n       \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps", "case Nil"], ["proof (state)\nthis:\n  spec_ops (xs @ []) deps\n  \\<forall>i\\<in>set (map fst xs). i < oid\n  \\<forall>a\\<in>set (map fst []). oid < a\n  \\<forall>ref\\<in>deps oper. ref < oid\n\ngoal (2 subgoals):\n 1. \\<lbrakk>spec_ops (xs @ []) deps;\n     \\<forall>i\\<in>set (map fst xs). i < oid;\n     Ball (set (map fst [])) ((<) oid);\n     \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n    \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ []) deps\n 2. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>spec_ops (xs @ xsa) deps;\n                 \\<forall>i\\<in>set (map fst xs). i < oid;\n                 Ball (set (map fst xsa)) ((<) oid);\n                 \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n                \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ xsa) deps;\n        spec_ops (xs @ xsa @ [x]) deps;\n        \\<forall>i\\<in>set (map fst xs). i < oid;\n        Ball (set (map fst (xsa @ [x]))) ((<) oid);\n        \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n       \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps", "then"], ["proof (chain)\npicking this:\n  spec_ops (xs @ []) deps\n  \\<forall>i\\<in>set (map fst xs). i < oid\n  \\<forall>a\\<in>set (map fst []). oid < a\n  \\<forall>ref\\<in>deps oper. ref < oid", "show \"spec_ops (xs @ [(oid, oper)] @ []) deps\""], ["proof (prove)\nusing this:\n  spec_ops (xs @ []) deps\n  \\<forall>i\\<in>set (map fst xs). i < oid\n  \\<forall>a\\<in>set (map fst []). oid < a\n  \\<forall>ref\\<in>deps oper. ref < oid\n\ngoal (1 subgoal):\n 1. spec_ops (xs @ [(oid, oper)] @ []) deps", "by (simp add: spec_ops_add_last)"], ["proof (state)\nthis:\n  spec_ops (xs @ [(oid, oper)] @ []) deps\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>spec_ops (xs @ xsa) deps;\n                 \\<forall>i\\<in>set (map fst xs). i < oid;\n                 Ball (set (map fst xsa)) ((<) oid);\n                 \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n                \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ xsa) deps;\n        spec_ops (xs @ xsa @ [x]) deps;\n        \\<forall>i\\<in>set (map fst xs). i < oid;\n        Ball (set (map fst (xsa @ [x]))) ((<) oid);\n        \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n       \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>spec_ops (xs @ xsa) deps;\n                 \\<forall>i\\<in>set (map fst xs). i < oid;\n                 Ball (set (map fst xsa)) ((<) oid);\n                 \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n                \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ xsa) deps;\n        spec_ops (xs @ xsa @ [x]) deps;\n        \\<forall>i\\<in>set (map fst xs). i < oid;\n        Ball (set (map fst (xsa @ [x]))) ((<) oid);\n        \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n       \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps", "case (snoc y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>spec_ops (xs @ ys) deps;\n   \\<forall>i\\<in>set (map fst xs). i < oid;\n   \\<forall>a\\<in>set (map fst ys). oid < a;\n   \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n  \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ ys) deps\n  spec_ops (xs @ ys @ [y]) deps\n  \\<forall>i\\<in>set (map fst xs). i < oid\n  \\<forall>a\\<in>set (map fst (ys @ [y])). oid < a\n  \\<forall>ref\\<in>deps oper. ref < oid\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>spec_ops (xs @ xsa) deps;\n                 \\<forall>i\\<in>set (map fst xs). i < oid;\n                 Ball (set (map fst xsa)) ((<) oid);\n                 \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n                \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ xsa) deps;\n        spec_ops (xs @ xsa @ [x]) deps;\n        \\<forall>i\\<in>set (map fst xs). i < oid;\n        Ball (set (map fst (xsa @ [x]))) ((<) oid);\n        \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n       \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps", "have IH: \"spec_ops (xs @ [(oid, oper)] @ ys) deps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec_ops (xs @ [(oid, oper)] @ ys) deps", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. spec_ops (xs @ [(oid, oper)] @ ys) deps", "from snoc"], ["proof (chain)\npicking this:\n  \\<lbrakk>spec_ops (xs @ ys) deps;\n   \\<forall>i\\<in>set (map fst xs). i < oid;\n   \\<forall>a\\<in>set (map fst ys). oid < a;\n   \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n  \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ ys) deps\n  spec_ops (xs @ ys @ [y]) deps\n  \\<forall>i\\<in>set (map fst xs). i < oid\n  \\<forall>a\\<in>set (map fst (ys @ [y])). oid < a\n  \\<forall>ref\\<in>deps oper. ref < oid", "have \"spec_ops (xs @ ys) deps\""], ["proof (prove)\nusing this:\n  \\<lbrakk>spec_ops (xs @ ys) deps;\n   \\<forall>i\\<in>set (map fst xs). i < oid;\n   \\<forall>a\\<in>set (map fst ys). oid < a;\n   \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n  \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ ys) deps\n  spec_ops (xs @ ys @ [y]) deps\n  \\<forall>i\\<in>set (map fst xs). i < oid\n  \\<forall>a\\<in>set (map fst (ys @ [y])). oid < a\n  \\<forall>ref\\<in>deps oper. ref < oid\n\ngoal (1 subgoal):\n 1. spec_ops (xs @ ys) deps", "by (metis append_assoc spec_ops_rem_last)"], ["proof (state)\nthis:\n  spec_ops (xs @ ys) deps\n\ngoal (1 subgoal):\n 1. spec_ops (xs @ [(oid, oper)] @ ys) deps", "thus \"spec_ops (xs @ [(oid, oper)] @ ys) deps\""], ["proof (prove)\nusing this:\n  spec_ops (xs @ ys) deps\n\ngoal (1 subgoal):\n 1. spec_ops (xs @ [(oid, oper)] @ ys) deps", "using assms(2) snoc"], ["proof (prove)\nusing this:\n  spec_ops (xs @ ys) deps\n  \\<forall>i\\<in>set (map fst xs). i < oid\n  \\<lbrakk>spec_ops (xs @ ys) deps;\n   \\<forall>i\\<in>set (map fst xs). i < oid;\n   \\<forall>a\\<in>set (map fst ys). oid < a;\n   \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n  \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ ys) deps\n  spec_ops (xs @ ys @ [y]) deps\n  \\<forall>i\\<in>set (map fst xs). i < oid\n  \\<forall>a\\<in>set (map fst (ys @ [y])). oid < a\n  \\<forall>ref\\<in>deps oper. ref < oid\n\ngoal (1 subgoal):\n 1. spec_ops (xs @ [(oid, oper)] @ ys) deps", "by auto"], ["proof (state)\nthis:\n  spec_ops (xs @ [(oid, oper)] @ ys) deps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  spec_ops (xs @ [(oid, oper)] @ ys) deps\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>spec_ops (xs @ xsa) deps;\n                 \\<forall>i\\<in>set (map fst xs). i < oid;\n                 Ball (set (map fst xsa)) ((<) oid);\n                 \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n                \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ xsa) deps;\n        spec_ops (xs @ xsa @ [x]) deps;\n        \\<forall>i\\<in>set (map fst xs). i < oid;\n        Ball (set (map fst (xsa @ [x]))) ((<) oid);\n        \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n       \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps", "obtain yi yo where y_pair: \"y = (yi, yo)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>yi yo. y = (yi, yo) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  y = (yi, yo)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>spec_ops (xs @ xsa) deps;\n                 \\<forall>i\\<in>set (map fst xs). i < oid;\n                 Ball (set (map fst xsa)) ((<) oid);\n                 \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n                \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ xsa) deps;\n        spec_ops (xs @ xsa @ [x]) deps;\n        \\<forall>i\\<in>set (map fst xs). i < oid;\n        Ball (set (map fst (xsa @ [x]))) ((<) oid);\n        \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n       \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps", "have oid_yi: \"oid < yi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oid < yi", "by (simp add: snoc.prems(3) y_pair)"], ["proof (state)\nthis:\n  oid < yi\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>spec_ops (xs @ xsa) deps;\n                 \\<forall>i\\<in>set (map fst xs). i < oid;\n                 Ball (set (map fst xsa)) ((<) oid);\n                 \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n                \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ xsa) deps;\n        spec_ops (xs @ xsa @ [x]) deps;\n        \\<forall>i\\<in>set (map fst xs). i < oid;\n        Ball (set (map fst (xsa @ [x]))) ((<) oid);\n        \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n       \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps", "have yi_biggest: \"\\<forall>i \\<in> set (map fst (xs @ [(oid, oper)] @ ys)). i < yi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst (xs @ [(oid, oper)] @ ys)). i < yi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst (xs @ [(oid, oper)] @ ys)). i < yi", "have \"\\<forall>i \\<in> set (map fst xs). i < yi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst xs). i < yi", "using oid_yi assms(2) less_trans"], ["proof (prove)\nusing this:\n  oid < yi\n  \\<forall>i\\<in>set (map fst xs). i < oid\n  \\<lbrakk>?x < ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst xs). i < yi", "by blast"], ["proof (state)\nthis:\n  \\<forall>i\\<in>set (map fst xs). i < yi\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst (xs @ [(oid, oper)] @ ys)). i < yi", "moreover"], ["proof (state)\nthis:\n  \\<forall>i\\<in>set (map fst xs). i < yi\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst (xs @ [(oid, oper)] @ ys)). i < yi", "have \"\\<forall>i \\<in> set (map fst ys). i < yi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst ys). i < yi", "by (metis UnCI append_assoc map_append set_append snoc.prems(1) spec_ops_id_inc y_pair)"], ["proof (state)\nthis:\n  \\<forall>i\\<in>set (map fst ys). i < yi\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst (xs @ [(oid, oper)] @ ys)). i < yi", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>set (map fst xs). i < yi\n  \\<forall>i\\<in>set (map fst ys). i < yi", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>set (map fst xs). i < yi\n  \\<forall>i\\<in>set (map fst ys). i < yi\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst (xs @ [(oid, oper)] @ ys)). i < yi", "using oid_yi"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>set (map fst xs). i < yi\n  \\<forall>i\\<in>set (map fst ys). i < yi\n  oid < yi\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (map fst (xs @ [(oid, oper)] @ ys)). i < yi", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<in>set (map fst (xs @ [(oid, oper)] @ ys)). i < yi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i\\<in>set (map fst (xs @ [(oid, oper)] @ ys)). i < yi\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>spec_ops (xs @ xsa) deps;\n                 \\<forall>i\\<in>set (map fst xs). i < oid;\n                 Ball (set (map fst xsa)) ((<) oid);\n                 \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n                \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ xsa) deps;\n        spec_ops (xs @ xsa @ [x]) deps;\n        \\<forall>i\\<in>set (map fst xs). i < oid;\n        Ball (set (map fst (xsa @ [x]))) ((<) oid);\n        \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n       \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps", "have \"sorted (map fst (xs @ [(oid, oper)] @ ys @ [y]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (map fst (xs @ [(oid, oper)] @ ys @ [y]))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted (map fst (xs @ [(oid, oper)] @ ys @ [y]))", "from IH"], ["proof (chain)\npicking this:\n  spec_ops (xs @ [(oid, oper)] @ ys) deps", "have \"sorted (map fst (xs @ [(oid, oper)] @ ys))\""], ["proof (prove)\nusing this:\n  spec_ops (xs @ [(oid, oper)] @ ys) deps\n\ngoal (1 subgoal):\n 1. sorted (map fst (xs @ [(oid, oper)] @ ys))", "using spec_ops_def"], ["proof (prove)\nusing this:\n  spec_ops (xs @ [(oid, oper)] @ ys) deps\n  spec_ops ?ops ?deps \\<equiv>\n  sorted (map fst ?ops) \\<and>\n  distinct (map fst ?ops) \\<and>\n  (\\<forall>oid oper ref.\n      (oid, oper) \\<in> set ?ops \\<and>\n      ref \\<in> ?deps oper \\<longrightarrow>\n      ref < oid)\n\ngoal (1 subgoal):\n 1. sorted (map fst (xs @ [(oid, oper)] @ ys))", "by blast"], ["proof (state)\nthis:\n  sorted (map fst (xs @ [(oid, oper)] @ ys))\n\ngoal (1 subgoal):\n 1. sorted (map fst (xs @ [(oid, oper)] @ ys @ [y]))", "hence \"sorted (map fst (xs @ [(oid, oper)] @ ys) @ [yi])\""], ["proof (prove)\nusing this:\n  sorted (map fst (xs @ [(oid, oper)] @ ys))\n\ngoal (1 subgoal):\n 1. sorted (map fst (xs @ [(oid, oper)] @ ys) @ [yi])", "using yi_biggest"], ["proof (prove)\nusing this:\n  sorted (map fst (xs @ [(oid, oper)] @ ys))\n  \\<forall>i\\<in>set (map fst (xs @ [(oid, oper)] @ ys)). i < yi\n\ngoal (1 subgoal):\n 1. sorted (map fst (xs @ [(oid, oper)] @ ys) @ [yi])", "by (simp add: sorted_append dual_order.strict_implies_order)"], ["proof (state)\nthis:\n  sorted (map fst (xs @ [(oid, oper)] @ ys) @ [yi])\n\ngoal (1 subgoal):\n 1. sorted (map fst (xs @ [(oid, oper)] @ ys @ [y]))", "thus \"sorted (map fst (xs @ [(oid, oper)] @ ys @ [y]))\""], ["proof (prove)\nusing this:\n  sorted (map fst (xs @ [(oid, oper)] @ ys) @ [yi])\n\ngoal (1 subgoal):\n 1. sorted (map fst (xs @ [(oid, oper)] @ ys @ [y]))", "by (simp add: y_pair)"], ["proof (state)\nthis:\n  sorted (map fst (xs @ [(oid, oper)] @ ys @ [y]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted (map fst (xs @ [(oid, oper)] @ ys @ [y]))\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>spec_ops (xs @ xsa) deps;\n                 \\<forall>i\\<in>set (map fst xs). i < oid;\n                 Ball (set (map fst xsa)) ((<) oid);\n                 \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n                \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ xsa) deps;\n        spec_ops (xs @ xsa @ [x]) deps;\n        \\<forall>i\\<in>set (map fst xs). i < oid;\n        Ball (set (map fst (xsa @ [x]))) ((<) oid);\n        \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n       \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps", "moreover"], ["proof (state)\nthis:\n  sorted (map fst (xs @ [(oid, oper)] @ ys @ [y]))\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>spec_ops (xs @ xsa) deps;\n                 \\<forall>i\\<in>set (map fst xs). i < oid;\n                 Ball (set (map fst xsa)) ((<) oid);\n                 \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n                \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ xsa) deps;\n        spec_ops (xs @ xsa @ [x]) deps;\n        \\<forall>i\\<in>set (map fst xs). i < oid;\n        Ball (set (map fst (xsa @ [x]))) ((<) oid);\n        \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n       \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps", "have \"distinct (map fst (xs @ [(oid, oper)] @ ys @ [y]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (xs @ [(oid, oper)] @ ys @ [y]))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (map fst (xs @ [(oid, oper)] @ ys @ [y]))", "have \"distinct (map fst (xs @ [(oid, oper)] @ ys) @ [yi])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (xs @ [(oid, oper)] @ ys) @ [yi])", "using IH yi_biggest spec_ops_def"], ["proof (prove)\nusing this:\n  spec_ops (xs @ [(oid, oper)] @ ys) deps\n  \\<forall>i\\<in>set (map fst (xs @ [(oid, oper)] @ ys)). i < yi\n  spec_ops ?ops ?deps \\<equiv>\n  sorted (map fst ?ops) \\<and>\n  distinct (map fst ?ops) \\<and>\n  (\\<forall>oid oper ref.\n      (oid, oper) \\<in> set ?ops \\<and>\n      ref \\<in> ?deps oper \\<longrightarrow>\n      ref < oid)\n\ngoal (1 subgoal):\n 1. distinct (map fst (xs @ [(oid, oper)] @ ys) @ [yi])", "by (metis distinct.simps(2) distinct1_rotate order_less_irrefl rotate1.simps(2))"], ["proof (state)\nthis:\n  distinct (map fst (xs @ [(oid, oper)] @ ys) @ [yi])\n\ngoal (1 subgoal):\n 1. distinct (map fst (xs @ [(oid, oper)] @ ys @ [y]))", "thus \"distinct (map fst (xs @ [(oid, oper)] @ ys @ [y]))\""], ["proof (prove)\nusing this:\n  distinct (map fst (xs @ [(oid, oper)] @ ys) @ [yi])\n\ngoal (1 subgoal):\n 1. distinct (map fst (xs @ [(oid, oper)] @ ys @ [y]))", "by (simp add: y_pair)"], ["proof (state)\nthis:\n  distinct (map fst (xs @ [(oid, oper)] @ ys @ [y]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (map fst (xs @ [(oid, oper)] @ ys @ [y]))\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>spec_ops (xs @ xsa) deps;\n                 \\<forall>i\\<in>set (map fst xs). i < oid;\n                 Ball (set (map fst xsa)) ((<) oid);\n                 \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n                \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ xsa) deps;\n        spec_ops (xs @ xsa @ [x]) deps;\n        \\<forall>i\\<in>set (map fst xs). i < oid;\n        Ball (set (map fst (xsa @ [x]))) ((<) oid);\n        \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n       \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps", "moreover"], ["proof (state)\nthis:\n  distinct (map fst (xs @ [(oid, oper)] @ ys @ [y]))\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>spec_ops (xs @ xsa) deps;\n                 \\<forall>i\\<in>set (map fst xs). i < oid;\n                 Ball (set (map fst xsa)) ((<) oid);\n                 \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n                \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ xsa) deps;\n        spec_ops (xs @ xsa @ [x]) deps;\n        \\<forall>i\\<in>set (map fst xs). i < oid;\n        Ball (set (map fst (xsa @ [x]))) ((<) oid);\n        \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n       \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps", "have \"\\<forall>i opr r. (i, opr) \\<in> set (xs @ [(oid, oper)] @ ys @ [y])\n                     \\<and> r \\<in> deps opr \\<longrightarrow> r < i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i opr r.\n       (i, opr) \\<in> set (xs @ [(oid, oper)] @ ys @ [y]) \\<and>\n       r \\<in> deps opr \\<longrightarrow>\n       r < i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i opr r.\n       (i, opr) \\<in> set (xs @ [(oid, oper)] @ ys @ [y]) \\<and>\n       r \\<in> deps opr \\<longrightarrow>\n       r < i", "have \"\\<forall>i opr r. (i, opr) \\<in> set (xs @ [(oid, oper)] @ ys) \\<and> r \\<in> deps opr \\<longrightarrow> r < i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i opr r.\n       (i, opr) \\<in> set (xs @ [(oid, oper)] @ ys) \\<and>\n       r \\<in> deps opr \\<longrightarrow>\n       r < i", "by (meson IH spec_ops_def)"], ["proof (state)\nthis:\n  \\<forall>i opr r.\n     (i, opr) \\<in> set (xs @ [(oid, oper)] @ ys) \\<and>\n     r \\<in> deps opr \\<longrightarrow>\n     r < i\n\ngoal (1 subgoal):\n 1. \\<forall>i opr r.\n       (i, opr) \\<in> set (xs @ [(oid, oper)] @ ys @ [y]) \\<and>\n       r \\<in> deps opr \\<longrightarrow>\n       r < i", "moreover"], ["proof (state)\nthis:\n  \\<forall>i opr r.\n     (i, opr) \\<in> set (xs @ [(oid, oper)] @ ys) \\<and>\n     r \\<in> deps opr \\<longrightarrow>\n     r < i\n\ngoal (1 subgoal):\n 1. \\<forall>i opr r.\n       (i, opr) \\<in> set (xs @ [(oid, oper)] @ ys @ [y]) \\<and>\n       r \\<in> deps opr \\<longrightarrow>\n       r < i", "have \"\\<forall>ref. ref \\<in> deps yo \\<longrightarrow> ref < yi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ref. ref \\<in> deps yo \\<longrightarrow> ref < yi", "by (metis spec_ops_ref_less append_is_Nil_conv last_appendR last_in_set last_snoc\n          list.simps(3) snoc.prems(1) y_pair)"], ["proof (state)\nthis:\n  \\<forall>ref. ref \\<in> deps yo \\<longrightarrow> ref < yi\n\ngoal (1 subgoal):\n 1. \\<forall>i opr r.\n       (i, opr) \\<in> set (xs @ [(oid, oper)] @ ys @ [y]) \\<and>\n       r \\<in> deps opr \\<longrightarrow>\n       r < i", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>i opr r.\n     (i, opr) \\<in> set (xs @ [(oid, oper)] @ ys) \\<and>\n     r \\<in> deps opr \\<longrightarrow>\n     r < i\n  \\<forall>ref. ref \\<in> deps yo \\<longrightarrow> ref < yi", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i opr r.\n     (i, opr) \\<in> set (xs @ [(oid, oper)] @ ys) \\<and>\n     r \\<in> deps opr \\<longrightarrow>\n     r < i\n  \\<forall>ref. ref \\<in> deps yo \\<longrightarrow> ref < yi\n\ngoal (1 subgoal):\n 1. \\<forall>i opr r.\n       (i, opr) \\<in> set (xs @ [(oid, oper)] @ ys @ [y]) \\<and>\n       r \\<in> deps opr \\<longrightarrow>\n       r < i", "using y_pair"], ["proof (prove)\nusing this:\n  \\<forall>i opr r.\n     (i, opr) \\<in> set (xs @ [(oid, oper)] @ ys) \\<and>\n     r \\<in> deps opr \\<longrightarrow>\n     r < i\n  \\<forall>ref. ref \\<in> deps yo \\<longrightarrow> ref < yi\n  y = (yi, yo)\n\ngoal (1 subgoal):\n 1. \\<forall>i opr r.\n       (i, opr) \\<in> set (xs @ [(oid, oper)] @ ys @ [y]) \\<and>\n       r \\<in> deps opr \\<longrightarrow>\n       r < i", "by auto"], ["proof (state)\nthis:\n  \\<forall>i opr r.\n     (i, opr) \\<in> set (xs @ [(oid, oper)] @ ys @ [y]) \\<and>\n     r \\<in> deps opr \\<longrightarrow>\n     r < i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i opr r.\n     (i, opr) \\<in> set (xs @ [(oid, oper)] @ ys @ [y]) \\<and>\n     r \\<in> deps opr \\<longrightarrow>\n     r < i\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>spec_ops (xs @ xsa) deps;\n                 \\<forall>i\\<in>set (map fst xs). i < oid;\n                 Ball (set (map fst xsa)) ((<) oid);\n                 \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n                \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ xsa) deps;\n        spec_ops (xs @ xsa @ [x]) deps;\n        \\<forall>i\\<in>set (map fst xs). i < oid;\n        Ball (set (map fst (xsa @ [x]))) ((<) oid);\n        \\<forall>ref\\<in>deps oper. ref < oid\\<rbrakk>\n       \\<Longrightarrow> spec_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps", "ultimately"], ["proof (chain)\npicking this:\n  sorted (map fst (xs @ [(oid, oper)] @ ys @ [y]))\n  distinct (map fst (xs @ [(oid, oper)] @ ys @ [y]))\n  \\<forall>i opr r.\n     (i, opr) \\<in> set (xs @ [(oid, oper)] @ ys @ [y]) \\<and>\n     r \\<in> deps opr \\<longrightarrow>\n     r < i", "show \"spec_ops (xs @ [(oid, oper)] @ ys @ [y]) deps\""], ["proof (prove)\nusing this:\n  sorted (map fst (xs @ [(oid, oper)] @ ys @ [y]))\n  distinct (map fst (xs @ [(oid, oper)] @ ys @ [y]))\n  \\<forall>i opr r.\n     (i, opr) \\<in> set (xs @ [(oid, oper)] @ ys @ [y]) \\<and>\n     r \\<in> deps opr \\<longrightarrow>\n     r < i\n\ngoal (1 subgoal):\n 1. spec_ops (xs @ [(oid, oper)] @ ys @ [y]) deps", "using spec_ops_def"], ["proof (prove)\nusing this:\n  sorted (map fst (xs @ [(oid, oper)] @ ys @ [y]))\n  distinct (map fst (xs @ [(oid, oper)] @ ys @ [y]))\n  \\<forall>i opr r.\n     (i, opr) \\<in> set (xs @ [(oid, oper)] @ ys @ [y]) \\<and>\n     r \\<in> deps opr \\<longrightarrow>\n     r < i\n  spec_ops ?ops ?deps \\<equiv>\n  sorted (map fst ?ops) \\<and>\n  distinct (map fst ?ops) \\<and>\n  (\\<forall>oid oper ref.\n      (oid, oper) \\<in> set ?ops \\<and>\n      ref \\<in> ?deps oper \\<longrightarrow>\n      ref < oid)\n\ngoal (1 subgoal):\n 1. spec_ops (xs @ [(oid, oper)] @ ys @ [y]) deps", "by blast"], ["proof (state)\nthis:\n  spec_ops (xs @ [(oid, oper)] @ ys @ [y]) deps\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma spec_ops_split:\n  assumes \"spec_ops xs deps\"\n    and \"oid \\<notin> set (map fst xs)\"\n  shows \"\\<exists>pre suf. xs = pre @ suf \\<and>\n            (\\<forall>i \\<in> set (map fst pre). i < oid) \\<and>\n            (\\<forall>i \\<in> set (map fst suf). oid < i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       xs = pre @ suf \\<and>\n       (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n       (\\<forall>i\\<in>set (map fst suf). oid < i)", "using assms"], ["proof (prove)\nusing this:\n  spec_ops xs deps\n  oid \\<notin> set (map fst xs)\n\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       xs = pre @ suf \\<and>\n       (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n       (\\<forall>i\\<in>set (map fst suf). oid < i)", "proof(induction xs rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>spec_ops [] deps; oid \\<notin> set (map fst [])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         [] = pre @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         Ball (set (map fst suf)) ((<) oid)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>spec_ops xs deps;\n                 oid \\<notin> set (map fst xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pre suf.\n                                     xs = pre @ suf \\<and>\n                                     (\\<forall>i\\<in>set (map fst pre).\n   i < oid) \\<and>\n                                     Ball (set (map fst suf)) ((<) oid);\n        spec_ops (xs @ [x]) deps;\n        oid \\<notin> set (map fst (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre suf.\n                            xs @ [x] = pre @ suf \\<and>\n                            (\\<forall>i\\<in>set (map fst pre).\n                                i < oid) \\<and>\n                            Ball (set (map fst suf)) ((<) oid)", "case Nil"], ["proof (state)\nthis:\n  spec_ops [] deps\n  oid \\<notin> set (map fst [])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>spec_ops [] deps; oid \\<notin> set (map fst [])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         [] = pre @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         Ball (set (map fst suf)) ((<) oid)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>spec_ops xs deps;\n                 oid \\<notin> set (map fst xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pre suf.\n                                     xs = pre @ suf \\<and>\n                                     (\\<forall>i\\<in>set (map fst pre).\n   i < oid) \\<and>\n                                     Ball (set (map fst suf)) ((<) oid);\n        spec_ops (xs @ [x]) deps;\n        oid \\<notin> set (map fst (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre suf.\n                            xs @ [x] = pre @ suf \\<and>\n                            (\\<forall>i\\<in>set (map fst pre).\n                                i < oid) \\<and>\n                            Ball (set (map fst suf)) ((<) oid)", "then"], ["proof (chain)\npicking this:\n  spec_ops [] deps\n  oid \\<notin> set (map fst [])", "show ?case"], ["proof (prove)\nusing this:\n  spec_ops [] deps\n  oid \\<notin> set (map fst [])\n\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       [] = pre @ suf \\<and>\n       (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n       (\\<forall>a\\<in>set (map fst suf). oid < a)", "by force"], ["proof (state)\nthis:\n  \\<exists>pre suf.\n     [] = pre @ suf \\<and>\n     (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n     (\\<forall>a\\<in>set (map fst suf). oid < a)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>spec_ops xs deps;\n                 oid \\<notin> set (map fst xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pre suf.\n                                     xs = pre @ suf \\<and>\n                                     (\\<forall>i\\<in>set (map fst pre).\n   i < oid) \\<and>\n                                     Ball (set (map fst suf)) ((<) oid);\n        spec_ops (xs @ [x]) deps;\n        oid \\<notin> set (map fst (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre suf.\n                            xs @ [x] = pre @ suf \\<and>\n                            (\\<forall>i\\<in>set (map fst pre).\n                                i < oid) \\<and>\n                            Ball (set (map fst suf)) ((<) oid)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>spec_ops xs deps;\n                 oid \\<notin> set (map fst xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pre suf.\n                                     xs = pre @ suf \\<and>\n                                     (\\<forall>i\\<in>set (map fst pre).\n   i < oid) \\<and>\n                                     Ball (set (map fst suf)) ((<) oid);\n        spec_ops (xs @ [x]) deps;\n        oid \\<notin> set (map fst (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre suf.\n                            xs @ [x] = pre @ suf \\<and>\n                            (\\<forall>i\\<in>set (map fst pre).\n                                i < oid) \\<and>\n                            Ball (set (map fst suf)) ((<) oid)", "case (snoc x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>spec_ops xs deps; oid \\<notin> set (map fst xs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>pre suf.\n                       xs = pre @ suf \\<and>\n                       (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                       (\\<forall>a\\<in>set (map fst suf). oid < a)\n  spec_ops (xs @ [x]) deps\n  oid \\<notin> set (map fst (xs @ [x]))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>spec_ops xs deps;\n                 oid \\<notin> set (map fst xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pre suf.\n                                     xs = pre @ suf \\<and>\n                                     (\\<forall>i\\<in>set (map fst pre).\n   i < oid) \\<and>\n                                     Ball (set (map fst suf)) ((<) oid);\n        spec_ops (xs @ [x]) deps;\n        oid \\<notin> set (map fst (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre suf.\n                            xs @ [x] = pre @ suf \\<and>\n                            (\\<forall>i\\<in>set (map fst pre).\n                                i < oid) \\<and>\n                            Ball (set (map fst suf)) ((<) oid)", "obtain xi xr where y_pair: \"x = (xi, xr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xi xr. x = (xi, xr) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  x = (xi, xr)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>spec_ops xs deps;\n                 oid \\<notin> set (map fst xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pre suf.\n                                     xs = pre @ suf \\<and>\n                                     (\\<forall>i\\<in>set (map fst pre).\n   i < oid) \\<and>\n                                     Ball (set (map fst suf)) ((<) oid);\n        spec_ops (xs @ [x]) deps;\n        oid \\<notin> set (map fst (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre suf.\n                            xs @ [x] = pre @ suf \\<and>\n                            (\\<forall>i\\<in>set (map fst pre).\n                                i < oid) \\<and>\n                            Ball (set (map fst suf)) ((<) oid)", "obtain pre suf where IH: \"xs = pre @ suf \\<and>\n               (\\<forall>a\\<in>set (map fst pre). a < oid) \\<and>\n               (\\<forall>a\\<in>set (map fst suf). oid < a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        xs = pre @ suf \\<and>\n        (\\<forall>a\\<in>set (map fst pre). a < oid) \\<and>\n        (\\<forall>a\\<in>set (map fst suf). oid < a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis UnCI map_append set_append snoc spec_ops_rem_last)"], ["proof (state)\nthis:\n  xs = pre @ suf \\<and>\n  (\\<forall>a\\<in>set (map fst pre). a < oid) \\<and>\n  (\\<forall>a\\<in>set (map fst suf). oid < a)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>spec_ops xs deps;\n                 oid \\<notin> set (map fst xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>pre suf.\n                                     xs = pre @ suf \\<and>\n                                     (\\<forall>i\\<in>set (map fst pre).\n   i < oid) \\<and>\n                                     Ball (set (map fst suf)) ((<) oid);\n        spec_ops (xs @ [x]) deps;\n        oid \\<notin> set (map fst (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pre suf.\n                            xs @ [x] = pre @ suf \\<and>\n                            (\\<forall>i\\<in>set (map fst pre).\n                                i < oid) \\<and>\n                            Ball (set (map fst suf)) ((<) oid)", "then"], ["proof (chain)\npicking this:\n  xs = pre @ suf \\<and>\n  (\\<forall>a\\<in>set (map fst pre). a < oid) \\<and>\n  (\\<forall>a\\<in>set (map fst suf). oid < a)", "show ?case"], ["proof (prove)\nusing this:\n  xs = pre @ suf \\<and>\n  (\\<forall>a\\<in>set (map fst pre). a < oid) \\<and>\n  (\\<forall>a\\<in>set (map fst suf). oid < a)\n\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       xs @ [x] = pre @ suf \\<and>\n       (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n       (\\<forall>a\\<in>set (map fst suf). oid < a)", "proof(cases \"xi < oid\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = pre @ suf \\<and>\n             (\\<forall>a\\<in>set (map fst pre). a < oid) \\<and>\n             (\\<forall>a\\<in>set (map fst suf). oid < a);\n     xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)\n 2. \\<lbrakk>xs = pre @ suf \\<and>\n             (\\<forall>a\\<in>set (map fst pre). a < oid) \\<and>\n             (\\<forall>a\\<in>set (map fst suf). oid < a);\n     \\<not> xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "case xi_less: True"], ["proof (state)\nthis:\n  xi < oid\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = pre @ suf \\<and>\n             (\\<forall>a\\<in>set (map fst pre). a < oid) \\<and>\n             (\\<forall>a\\<in>set (map fst suf). oid < a);\n     xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)\n 2. \\<lbrakk>xs = pre @ suf \\<and>\n             (\\<forall>a\\<in>set (map fst pre). a < oid) \\<and>\n             (\\<forall>a\\<in>set (map fst suf). oid < a);\n     \\<not> xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "have \"\\<forall>x \\<in> set (map fst (pre @ suf)). x < xi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map fst (pre @ suf)). x < xi", "using IH spec_ops_id_inc snoc.prems(1) y_pair"], ["proof (prove)\nusing this:\n  xs = pre @ suf \\<and>\n  (\\<forall>a\\<in>set (map fst pre). a < oid) \\<and>\n  (\\<forall>a\\<in>set (map fst suf). oid < a)\n  \\<lbrakk>spec_ops (?xs @ [(?oid, ?oper)]) ?deps;\n   ?x \\<in> set (map fst ?xs)\\<rbrakk>\n  \\<Longrightarrow> ?x < ?oid\n  spec_ops (xs @ [x]) deps\n  x = (xi, xr)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map fst (pre @ suf)). x < xi", "by metis"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map fst (pre @ suf)). x < xi\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = pre @ suf \\<and>\n             (\\<forall>a\\<in>set (map fst pre). a < oid) \\<and>\n             (\\<forall>a\\<in>set (map fst suf). oid < a);\n     xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)\n 2. \\<lbrakk>xs = pre @ suf \\<and>\n             (\\<forall>a\\<in>set (map fst pre). a < oid) \\<and>\n             (\\<forall>a\\<in>set (map fst suf). oid < a);\n     \\<not> xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "hence \"\\<forall>x \\<in> set suf. fst x < xi\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (map fst (pre @ suf)). x < xi\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set suf. fst x < xi", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set suf. fst x < xi\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = pre @ suf \\<and>\n             (\\<forall>a\\<in>set (map fst pre). a < oid) \\<and>\n             (\\<forall>a\\<in>set (map fst suf). oid < a);\n     xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)\n 2. \\<lbrakk>xs = pre @ suf \\<and>\n             (\\<forall>a\\<in>set (map fst pre). a < oid) \\<and>\n             (\\<forall>a\\<in>set (map fst suf). oid < a);\n     \\<not> xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "hence \"\\<forall>x \\<in> set suf. fst x < oid\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set suf. fst x < xi\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set suf. fst x < oid", "using xi_less"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set suf. fst x < xi\n  xi < oid\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set suf. fst x < oid", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set suf. fst x < oid\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = pre @ suf \\<and>\n             (\\<forall>a\\<in>set (map fst pre). a < oid) \\<and>\n             (\\<forall>a\\<in>set (map fst suf). oid < a);\n     xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)\n 2. \\<lbrakk>xs = pre @ suf \\<and>\n             (\\<forall>a\\<in>set (map fst pre). a < oid) \\<and>\n             (\\<forall>a\\<in>set (map fst suf). oid < a);\n     \\<not> xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "hence \"suf = []\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set suf. fst x < oid\n\ngoal (1 subgoal):\n 1. suf = []", "using IH last_in_set"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set suf. fst x < oid\n  xs = pre @ suf \\<and>\n  (\\<forall>a\\<in>set (map fst pre). a < oid) \\<and>\n  (\\<forall>a\\<in>set (map fst suf). oid < a)\n  ?as \\<noteq> [] \\<Longrightarrow> last ?as \\<in> set ?as\n\ngoal (1 subgoal):\n 1. suf = []", "by fastforce"], ["proof (state)\nthis:\n  suf = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = pre @ suf \\<and>\n             (\\<forall>a\\<in>set (map fst pre). a < oid) \\<and>\n             (\\<forall>a\\<in>set (map fst suf). oid < a);\n     xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)\n 2. \\<lbrakk>xs = pre @ suf \\<and>\n             (\\<forall>a\\<in>set (map fst pre). a < oid) \\<and>\n             (\\<forall>a\\<in>set (map fst suf). oid < a);\n     \\<not> xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "hence \"xs @ [x] = (pre @ [(xi, xr)]) @ [] \\<and>\n              (\\<forall>a\\<in>set (map fst ((pre @ [(xi, xr)]))). a < oid) \\<and>\n              (\\<forall>a\\<in>set (map fst []). oid < a)\""], ["proof (prove)\nusing this:\n  suf = []\n\ngoal (1 subgoal):\n 1. xs @ [x] = (pre @ [(xi, xr)]) @ [] \\<and>\n    (\\<forall>a\\<in>set (map fst (pre @ [(xi, xr)])). a < oid) \\<and>\n    (\\<forall>a\\<in>set (map fst []). oid < a)", "by (simp add: IH xi_less y_pair)"], ["proof (state)\nthis:\n  xs @ [x] = (pre @ [(xi, xr)]) @ [] \\<and>\n  (\\<forall>a\\<in>set (map fst (pre @ [(xi, xr)])). a < oid) \\<and>\n  (\\<forall>a\\<in>set (map fst []). oid < a)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = pre @ suf \\<and>\n             (\\<forall>a\\<in>set (map fst pre). a < oid) \\<and>\n             (\\<forall>a\\<in>set (map fst suf). oid < a);\n     xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)\n 2. \\<lbrakk>xs = pre @ suf \\<and>\n             (\\<forall>a\\<in>set (map fst pre). a < oid) \\<and>\n             (\\<forall>a\\<in>set (map fst suf). oid < a);\n     \\<not> xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "then"], ["proof (chain)\npicking this:\n  xs @ [x] = (pre @ [(xi, xr)]) @ [] \\<and>\n  (\\<forall>a\\<in>set (map fst (pre @ [(xi, xr)])). a < oid) \\<and>\n  (\\<forall>a\\<in>set (map fst []). oid < a)", "show ?thesis"], ["proof (prove)\nusing this:\n  xs @ [x] = (pre @ [(xi, xr)]) @ [] \\<and>\n  (\\<forall>a\\<in>set (map fst (pre @ [(xi, xr)])). a < oid) \\<and>\n  (\\<forall>a\\<in>set (map fst []). oid < a)\n\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       xs @ [x] = pre @ suf \\<and>\n       (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n       (\\<forall>a\\<in>set (map fst suf). oid < a)", "by force"], ["proof (state)\nthis:\n  \\<exists>pre suf.\n     xs @ [x] = pre @ suf \\<and>\n     (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n     (\\<forall>a\\<in>set (map fst suf). oid < a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xs = pre @ suf \\<and>\n             (\\<forall>a\\<in>set (map fst pre). a < oid) \\<and>\n             (\\<forall>a\\<in>set (map fst suf). oid < a);\n     \\<not> xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs = pre @ suf \\<and>\n             (\\<forall>a\\<in>set (map fst pre). a < oid) \\<and>\n             (\\<forall>a\\<in>set (map fst suf). oid < a);\n     \\<not> xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "case False"], ["proof (state)\nthis:\n  \\<not> xi < oid\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xs = pre @ suf \\<and>\n             (\\<forall>a\\<in>set (map fst pre). a < oid) \\<and>\n             (\\<forall>a\\<in>set (map fst suf). oid < a);\n     \\<not> xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "hence \"oid < xi\""], ["proof (prove)\nusing this:\n  \\<not> xi < oid\n\ngoal (1 subgoal):\n 1. oid < xi", "using snoc.prems(2) y_pair"], ["proof (prove)\nusing this:\n  \\<not> xi < oid\n  oid \\<notin> set (map fst (xs @ [x]))\n  x = (xi, xr)\n\ngoal (1 subgoal):\n 1. oid < xi", "by auto"], ["proof (state)\nthis:\n  oid < xi\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xs = pre @ suf \\<and>\n             (\\<forall>a\\<in>set (map fst pre). a < oid) \\<and>\n             (\\<forall>a\\<in>set (map fst suf). oid < a);\n     \\<not> xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "hence \"xs @ [x] = pre @ (suf @ [(xi, xr)]) \\<and>\n              (\\<forall>i \\<in> set (map fst pre). i < oid) \\<and>\n              (\\<forall>i \\<in> set (map fst (suf @ [(xi, xr)])). oid < i)\""], ["proof (prove)\nusing this:\n  oid < xi\n\ngoal (1 subgoal):\n 1. xs @ [x] = pre @ suf @ [(xi, xr)] \\<and>\n    (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n    (\\<forall>i\\<in>set (map fst (suf @ [(xi, xr)])). oid < i)", "by (simp add: IH y_pair)"], ["proof (state)\nthis:\n  xs @ [x] = pre @ suf @ [(xi, xr)] \\<and>\n  (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n  (\\<forall>i\\<in>set (map fst (suf @ [(xi, xr)])). oid < i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xs = pre @ suf \\<and>\n             (\\<forall>a\\<in>set (map fst pre). a < oid) \\<and>\n             (\\<forall>a\\<in>set (map fst suf). oid < a);\n     \\<not> xi < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pre suf.\n                         xs @ [x] = pre @ suf \\<and>\n                         (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n                         (\\<forall>a\\<in>set (map fst suf). oid < a)", "then"], ["proof (chain)\npicking this:\n  xs @ [x] = pre @ suf @ [(xi, xr)] \\<and>\n  (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n  (\\<forall>i\\<in>set (map fst (suf @ [(xi, xr)])). oid < i)", "show ?thesis"], ["proof (prove)\nusing this:\n  xs @ [x] = pre @ suf @ [(xi, xr)] \\<and>\n  (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n  (\\<forall>i\\<in>set (map fst (suf @ [(xi, xr)])). oid < i)\n\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       xs @ [x] = pre @ suf \\<and>\n       (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n       (\\<forall>a\\<in>set (map fst suf). oid < a)", "by blast"], ["proof (state)\nthis:\n  \\<exists>pre suf.\n     xs @ [x] = pre @ suf \\<and>\n     (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n     (\\<forall>a\\<in>set (map fst suf). oid < a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>pre suf.\n     xs @ [x] = pre @ suf \\<and>\n     (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n     (\\<forall>a\\<in>set (map fst suf). oid < a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma spec_ops_exists_base:\n  assumes \"finite ops\"\n    and \"\\<And>oid op1 op2. (oid, op1) \\<in> ops \\<Longrightarrow> (oid, op2) \\<in> ops \\<Longrightarrow> op1 = op2\"\n    and \"\\<And>oid oper ref. (oid, oper) \\<in> ops \\<Longrightarrow> ref \\<in> deps oper \\<Longrightarrow> ref < oid\"\n  shows \"\\<exists>op_list. set op_list = ops \\<and> spec_ops op_list deps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>op_list. set op_list = ops \\<and> spec_ops op_list deps", "using assms"], ["proof (prove)\nusing this:\n  finite ops\n  \\<lbrakk>(?oid, ?op1.0) \\<in> ops; (?oid, ?op2.0) \\<in> ops\\<rbrakk>\n  \\<Longrightarrow> ?op1.0 = ?op2.0\n  \\<lbrakk>(?oid, ?oper) \\<in> ops; ?ref \\<in> deps ?oper\\<rbrakk>\n  \\<Longrightarrow> ?ref < ?oid\n\ngoal (1 subgoal):\n 1. \\<exists>op_list. set op_list = ops \\<and> spec_ops op_list deps", "proof(induct ops rule: Finite_Set.finite_induct_select)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>oid op1 op2.\n                \\<lbrakk>(oid, op1) \\<in> {}; (oid, op2) \\<in> {}\\<rbrakk>\n                \\<Longrightarrow> op1 = op2;\n     \\<And>oid oper ref.\n        \\<lbrakk>(oid, oper) \\<in> {}; ref \\<in> deps oper\\<rbrakk>\n        \\<Longrightarrow> ref < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>op_list.\n                         set op_list = {} \\<and> spec_ops op_list deps\n 2. \\<And>T.\n       \\<lbrakk>T \\<subset> ops;\n        \\<lbrakk>\\<And>oid op1 op2.\n                    \\<lbrakk>(oid, op1) \\<in> T; (oid, op2) \\<in> T\\<rbrakk>\n                    \\<Longrightarrow> op1 = op2;\n         \\<And>oid oper ref.\n            \\<lbrakk>(oid, oper) \\<in> T; ref \\<in> deps oper\\<rbrakk>\n            \\<Longrightarrow> ref < oid\\<rbrakk>\n        \\<Longrightarrow> \\<exists>op_list.\n                             set op_list = T \\<and>\n                             spec_ops op_list deps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<in>ops - T.\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                (x, xb) \\<in> insert s T \\<longrightarrow>\n                                xa = xb) \\<longrightarrow>\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                xb \\<in> deps xa \\<longrightarrow>\n                                xb < x) \\<longrightarrow>\n                            (\\<exists>op_list.\n                                set op_list = insert s T \\<and>\n                                spec_ops op_list deps)", "case empty"], ["proof (state)\nthis:\n  \\<lbrakk>(?oid, ?op1.0) \\<in> {}; (?oid, ?op2.0) \\<in> {}\\<rbrakk>\n  \\<Longrightarrow> ?op1.0 = ?op2.0\n  \\<lbrakk>(?oid, ?oper) \\<in> {}; ?ref \\<in> deps ?oper\\<rbrakk>\n  \\<Longrightarrow> ?ref < ?oid\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>oid op1 op2.\n                \\<lbrakk>(oid, op1) \\<in> {}; (oid, op2) \\<in> {}\\<rbrakk>\n                \\<Longrightarrow> op1 = op2;\n     \\<And>oid oper ref.\n        \\<lbrakk>(oid, oper) \\<in> {}; ref \\<in> deps oper\\<rbrakk>\n        \\<Longrightarrow> ref < oid\\<rbrakk>\n    \\<Longrightarrow> \\<exists>op_list.\n                         set op_list = {} \\<and> spec_ops op_list deps\n 2. \\<And>T.\n       \\<lbrakk>T \\<subset> ops;\n        \\<lbrakk>\\<And>oid op1 op2.\n                    \\<lbrakk>(oid, op1) \\<in> T; (oid, op2) \\<in> T\\<rbrakk>\n                    \\<Longrightarrow> op1 = op2;\n         \\<And>oid oper ref.\n            \\<lbrakk>(oid, oper) \\<in> T; ref \\<in> deps oper\\<rbrakk>\n            \\<Longrightarrow> ref < oid\\<rbrakk>\n        \\<Longrightarrow> \\<exists>op_list.\n                             set op_list = T \\<and>\n                             spec_ops op_list deps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<in>ops - T.\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                (x, xb) \\<in> insert s T \\<longrightarrow>\n                                xa = xb) \\<longrightarrow>\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                xb \\<in> deps xa \\<longrightarrow>\n                                xb < x) \\<longrightarrow>\n                            (\\<exists>op_list.\n                                set op_list = insert s T \\<and>\n                                spec_ops op_list deps)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?oid, ?op1.0) \\<in> {}; (?oid, ?op2.0) \\<in> {}\\<rbrakk>\n  \\<Longrightarrow> ?op1.0 = ?op2.0\n  \\<lbrakk>(?oid, ?oper) \\<in> {}; ?ref \\<in> deps ?oper\\<rbrakk>\n  \\<Longrightarrow> ?ref < ?oid", "show \"\\<exists>op_list. set op_list = {} \\<and> spec_ops op_list deps\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?oid, ?op1.0) \\<in> {}; (?oid, ?op2.0) \\<in> {}\\<rbrakk>\n  \\<Longrightarrow> ?op1.0 = ?op2.0\n  \\<lbrakk>(?oid, ?oper) \\<in> {}; ?ref \\<in> deps ?oper\\<rbrakk>\n  \\<Longrightarrow> ?ref < ?oid\n\ngoal (1 subgoal):\n 1. \\<exists>op_list. set op_list = {} \\<and> spec_ops op_list deps", "by (simp add: spec_ops_empty)"], ["proof (state)\nthis:\n  \\<exists>op_list. set op_list = {} \\<and> spec_ops op_list deps\n\ngoal (1 subgoal):\n 1. \\<And>T.\n       \\<lbrakk>T \\<subset> ops;\n        \\<lbrakk>\\<And>oid op1 op2.\n                    \\<lbrakk>(oid, op1) \\<in> T; (oid, op2) \\<in> T\\<rbrakk>\n                    \\<Longrightarrow> op1 = op2;\n         \\<And>oid oper ref.\n            \\<lbrakk>(oid, oper) \\<in> T; ref \\<in> deps oper\\<rbrakk>\n            \\<Longrightarrow> ref < oid\\<rbrakk>\n        \\<Longrightarrow> \\<exists>op_list.\n                             set op_list = T \\<and>\n                             spec_ops op_list deps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<in>ops - T.\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                (x, xb) \\<in> insert s T \\<longrightarrow>\n                                xa = xb) \\<longrightarrow>\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                xb \\<in> deps xa \\<longrightarrow>\n                                xb < x) \\<longrightarrow>\n                            (\\<exists>op_list.\n                                set op_list = insert s T \\<and>\n                                spec_ops op_list deps)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T.\n       \\<lbrakk>T \\<subset> ops;\n        \\<lbrakk>\\<And>oid op1 op2.\n                    \\<lbrakk>(oid, op1) \\<in> T; (oid, op2) \\<in> T\\<rbrakk>\n                    \\<Longrightarrow> op1 = op2;\n         \\<And>oid oper ref.\n            \\<lbrakk>(oid, oper) \\<in> T; ref \\<in> deps oper\\<rbrakk>\n            \\<Longrightarrow> ref < oid\\<rbrakk>\n        \\<Longrightarrow> \\<exists>op_list.\n                             set op_list = T \\<and>\n                             spec_ops op_list deps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<in>ops - T.\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                (x, xb) \\<in> insert s T \\<longrightarrow>\n                                xa = xb) \\<longrightarrow>\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                xb \\<in> deps xa \\<longrightarrow>\n                                xb < x) \\<longrightarrow>\n                            (\\<exists>op_list.\n                                set op_list = insert s T \\<and>\n                                spec_ops op_list deps)", "case (select subset)"], ["proof (state)\nthis:\n  subset \\<subset> ops\n  \\<lbrakk>\\<And>oid op1 op2.\n              \\<lbrakk>(oid, op1) \\<in> subset;\n               (oid, op2) \\<in> subset\\<rbrakk>\n              \\<Longrightarrow> op1 = op2;\n   \\<And>oid oper ref.\n      \\<lbrakk>(oid, oper) \\<in> subset; ref \\<in> deps oper\\<rbrakk>\n      \\<Longrightarrow> ref < oid\\<rbrakk>\n  \\<Longrightarrow> \\<exists>op_list.\n                       set op_list = subset \\<and> spec_ops op_list deps\n\ngoal (1 subgoal):\n 1. \\<And>T.\n       \\<lbrakk>T \\<subset> ops;\n        \\<lbrakk>\\<And>oid op1 op2.\n                    \\<lbrakk>(oid, op1) \\<in> T; (oid, op2) \\<in> T\\<rbrakk>\n                    \\<Longrightarrow> op1 = op2;\n         \\<And>oid oper ref.\n            \\<lbrakk>(oid, oper) \\<in> T; ref \\<in> deps oper\\<rbrakk>\n            \\<Longrightarrow> ref < oid\\<rbrakk>\n        \\<Longrightarrow> \\<exists>op_list.\n                             set op_list = T \\<and>\n                             spec_ops op_list deps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<in>ops - T.\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                (x, xb) \\<in> insert s T \\<longrightarrow>\n                                xa = xb) \\<longrightarrow>\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                xb \\<in> deps xa \\<longrightarrow>\n                                xb < x) \\<longrightarrow>\n                            (\\<exists>op_list.\n                                set op_list = insert s T \\<and>\n                                spec_ops op_list deps)", "from this"], ["proof (chain)\npicking this:\n  subset \\<subset> ops\n  \\<lbrakk>\\<And>oid op1 op2.\n              \\<lbrakk>(oid, op1) \\<in> subset;\n               (oid, op2) \\<in> subset\\<rbrakk>\n              \\<Longrightarrow> op1 = op2;\n   \\<And>oid oper ref.\n      \\<lbrakk>(oid, oper) \\<in> subset; ref \\<in> deps oper\\<rbrakk>\n      \\<Longrightarrow> ref < oid\\<rbrakk>\n  \\<Longrightarrow> \\<exists>op_list.\n                       set op_list = subset \\<and> spec_ops op_list deps", "obtain op_list where \"set op_list = subset\" and \"spec_ops op_list deps\""], ["proof (prove)\nusing this:\n  subset \\<subset> ops\n  \\<lbrakk>\\<And>oid op1 op2.\n              \\<lbrakk>(oid, op1) \\<in> subset;\n               (oid, op2) \\<in> subset\\<rbrakk>\n              \\<Longrightarrow> op1 = op2;\n   \\<And>oid oper ref.\n      \\<lbrakk>(oid, oper) \\<in> subset; ref \\<in> deps oper\\<rbrakk>\n      \\<Longrightarrow> ref < oid\\<rbrakk>\n  \\<Longrightarrow> \\<exists>op_list.\n                       set op_list = subset \\<and> spec_ops op_list deps\n\ngoal (1 subgoal):\n 1. (\\<And>op_list.\n        \\<lbrakk>set op_list = subset; spec_ops op_list deps\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  subset \\<subset> ops\n  \\<lbrakk>\\<And>oid op1 op2.\n              \\<lbrakk>(oid, op1) \\<in> subset;\n               (oid, op2) \\<in> subset\\<rbrakk>\n              \\<Longrightarrow> op1 = op2;\n   \\<And>oid oper ref.\n      \\<lbrakk>(oid, oper) \\<in> subset; ref \\<in> deps oper\\<rbrakk>\n      \\<Longrightarrow> ref < oid\\<rbrakk>\n  \\<Longrightarrow> \\<exists>op_list.\n                       set op_list = subset \\<and> spec_ops op_list deps\n  finite ops\n  \\<lbrakk>(?oid, ?op1.0) \\<in> ops; (?oid, ?op2.0) \\<in> ops\\<rbrakk>\n  \\<Longrightarrow> ?op1.0 = ?op2.0\n  \\<lbrakk>(?oid, ?oper) \\<in> ops; ?ref \\<in> deps ?oper\\<rbrakk>\n  \\<Longrightarrow> ?ref < ?oid\n\ngoal (1 subgoal):\n 1. (\\<And>op_list.\n        \\<lbrakk>set op_list = subset; spec_ops op_list deps\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  set op_list = subset\n  spec_ops op_list deps\n\ngoal (1 subgoal):\n 1. \\<And>T.\n       \\<lbrakk>T \\<subset> ops;\n        \\<lbrakk>\\<And>oid op1 op2.\n                    \\<lbrakk>(oid, op1) \\<in> T; (oid, op2) \\<in> T\\<rbrakk>\n                    \\<Longrightarrow> op1 = op2;\n         \\<And>oid oper ref.\n            \\<lbrakk>(oid, oper) \\<in> T; ref \\<in> deps oper\\<rbrakk>\n            \\<Longrightarrow> ref < oid\\<rbrakk>\n        \\<Longrightarrow> \\<exists>op_list.\n                             set op_list = T \\<and>\n                             spec_ops op_list deps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<in>ops - T.\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                (x, xb) \\<in> insert s T \\<longrightarrow>\n                                xa = xb) \\<longrightarrow>\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                xb \\<in> deps xa \\<longrightarrow>\n                                xb < x) \\<longrightarrow>\n                            (\\<exists>op_list.\n                                set op_list = insert s T \\<and>\n                                spec_ops op_list deps)", "moreover"], ["proof (state)\nthis:\n  set op_list = subset\n  spec_ops op_list deps\n\ngoal (1 subgoal):\n 1. \\<And>T.\n       \\<lbrakk>T \\<subset> ops;\n        \\<lbrakk>\\<And>oid op1 op2.\n                    \\<lbrakk>(oid, op1) \\<in> T; (oid, op2) \\<in> T\\<rbrakk>\n                    \\<Longrightarrow> op1 = op2;\n         \\<And>oid oper ref.\n            \\<lbrakk>(oid, oper) \\<in> T; ref \\<in> deps oper\\<rbrakk>\n            \\<Longrightarrow> ref < oid\\<rbrakk>\n        \\<Longrightarrow> \\<exists>op_list.\n                             set op_list = T \\<and>\n                             spec_ops op_list deps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<in>ops - T.\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                (x, xb) \\<in> insert s T \\<longrightarrow>\n                                xa = xb) \\<longrightarrow>\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                xb \\<in> deps xa \\<longrightarrow>\n                                xb < x) \\<longrightarrow>\n                            (\\<exists>op_list.\n                                set op_list = insert s T \\<and>\n                                spec_ops op_list deps)", "obtain oid oper where select: \"(oid, oper) \\<in> ops - subset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>oid oper.\n        (oid, oper) \\<in> ops - subset \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using select.hyps(1)"], ["proof (prove)\nusing this:\n  subset \\<subset> ops\n\ngoal (1 subgoal):\n 1. (\\<And>oid oper.\n        (oid, oper) \\<in> ops - subset \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (oid, oper) \\<in> ops - subset\n\ngoal (1 subgoal):\n 1. \\<And>T.\n       \\<lbrakk>T \\<subset> ops;\n        \\<lbrakk>\\<And>oid op1 op2.\n                    \\<lbrakk>(oid, op1) \\<in> T; (oid, op2) \\<in> T\\<rbrakk>\n                    \\<Longrightarrow> op1 = op2;\n         \\<And>oid oper ref.\n            \\<lbrakk>(oid, oper) \\<in> T; ref \\<in> deps oper\\<rbrakk>\n            \\<Longrightarrow> ref < oid\\<rbrakk>\n        \\<Longrightarrow> \\<exists>op_list.\n                             set op_list = T \\<and>\n                             spec_ops op_list deps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<in>ops - T.\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                (x, xb) \\<in> insert s T \\<longrightarrow>\n                                xa = xb) \\<longrightarrow>\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                xb \\<in> deps xa \\<longrightarrow>\n                                xb < x) \\<longrightarrow>\n                            (\\<exists>op_list.\n                                set op_list = insert s T \\<and>\n                                spec_ops op_list deps)", "moreover"], ["proof (state)\nthis:\n  (oid, oper) \\<in> ops - subset\n\ngoal (1 subgoal):\n 1. \\<And>T.\n       \\<lbrakk>T \\<subset> ops;\n        \\<lbrakk>\\<And>oid op1 op2.\n                    \\<lbrakk>(oid, op1) \\<in> T; (oid, op2) \\<in> T\\<rbrakk>\n                    \\<Longrightarrow> op1 = op2;\n         \\<And>oid oper ref.\n            \\<lbrakk>(oid, oper) \\<in> T; ref \\<in> deps oper\\<rbrakk>\n            \\<Longrightarrow> ref < oid\\<rbrakk>\n        \\<Longrightarrow> \\<exists>op_list.\n                             set op_list = T \\<and>\n                             spec_ops op_list deps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<in>ops - T.\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                (x, xb) \\<in> insert s T \\<longrightarrow>\n                                xa = xb) \\<longrightarrow>\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                xb \\<in> deps xa \\<longrightarrow>\n                                xb < x) \\<longrightarrow>\n                            (\\<exists>op_list.\n                                set op_list = insert s T \\<and>\n                                spec_ops op_list deps)", "from this"], ["proof (chain)\npicking this:\n  (oid, oper) \\<in> ops - subset", "have \"\\<And>op2. (oid, op2) \\<in> ops \\<Longrightarrow> op2 = oper\""], ["proof (prove)\nusing this:\n  (oid, oper) \\<in> ops - subset\n\ngoal (1 subgoal):\n 1. \\<And>op2. (oid, op2) \\<in> ops \\<Longrightarrow> op2 = oper", "using assms(2)"], ["proof (prove)\nusing this:\n  (oid, oper) \\<in> ops - subset\n  \\<lbrakk>(?oid, ?op1.0) \\<in> ops; (?oid, ?op2.0) \\<in> ops\\<rbrakk>\n  \\<Longrightarrow> ?op1.0 = ?op2.0\n\ngoal (1 subgoal):\n 1. \\<And>op2. (oid, op2) \\<in> ops \\<Longrightarrow> op2 = oper", "by auto"], ["proof (state)\nthis:\n  (oid, ?op2.0) \\<in> ops \\<Longrightarrow> ?op2.0 = oper\n\ngoal (1 subgoal):\n 1. \\<And>T.\n       \\<lbrakk>T \\<subset> ops;\n        \\<lbrakk>\\<And>oid op1 op2.\n                    \\<lbrakk>(oid, op1) \\<in> T; (oid, op2) \\<in> T\\<rbrakk>\n                    \\<Longrightarrow> op1 = op2;\n         \\<And>oid oper ref.\n            \\<lbrakk>(oid, oper) \\<in> T; ref \\<in> deps oper\\<rbrakk>\n            \\<Longrightarrow> ref < oid\\<rbrakk>\n        \\<Longrightarrow> \\<exists>op_list.\n                             set op_list = T \\<and>\n                             spec_ops op_list deps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<in>ops - T.\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                (x, xb) \\<in> insert s T \\<longrightarrow>\n                                xa = xb) \\<longrightarrow>\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                xb \\<in> deps xa \\<longrightarrow>\n                                xb < x) \\<longrightarrow>\n                            (\\<exists>op_list.\n                                set op_list = insert s T \\<and>\n                                spec_ops op_list deps)", "hence \"oid \\<notin> fst ` subset\""], ["proof (prove)\nusing this:\n  (oid, ?op2.0) \\<in> ops \\<Longrightarrow> ?op2.0 = oper\n\ngoal (1 subgoal):\n 1. oid \\<notin> fst ` subset", "by (metis (no_types, lifting) DiffD2 select image_iff prod.collapse psubsetD select.hyps(1))"], ["proof (state)\nthis:\n  oid \\<notin> fst ` subset\n\ngoal (1 subgoal):\n 1. \\<And>T.\n       \\<lbrakk>T \\<subset> ops;\n        \\<lbrakk>\\<And>oid op1 op2.\n                    \\<lbrakk>(oid, op1) \\<in> T; (oid, op2) \\<in> T\\<rbrakk>\n                    \\<Longrightarrow> op1 = op2;\n         \\<And>oid oper ref.\n            \\<lbrakk>(oid, oper) \\<in> T; ref \\<in> deps oper\\<rbrakk>\n            \\<Longrightarrow> ref < oid\\<rbrakk>\n        \\<Longrightarrow> \\<exists>op_list.\n                             set op_list = T \\<and>\n                             spec_ops op_list deps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<in>ops - T.\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                (x, xb) \\<in> insert s T \\<longrightarrow>\n                                xa = xb) \\<longrightarrow>\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                xb \\<in> deps xa \\<longrightarrow>\n                                xb < x) \\<longrightarrow>\n                            (\\<exists>op_list.\n                                set op_list = insert s T \\<and>\n                                spec_ops op_list deps)", "from this"], ["proof (chain)\npicking this:\n  oid \\<notin> fst ` subset", "obtain pre suf\n    where \"op_list = pre @ suf\"\n      and \"\\<forall>i \\<in> set (map fst pre). i < oid\"\n      and \"\\<forall>i \\<in> set (map fst suf). oid < i\""], ["proof (prove)\nusing this:\n  oid \\<notin> fst ` subset\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>op_list = pre @ suf;\n         \\<forall>i\\<in>set (map fst pre). i < oid;\n         \\<forall>i\\<in>set (map fst suf). oid < i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using spec_ops_split calculation"], ["proof (prove)\nusing this:\n  oid \\<notin> fst ` subset\n  \\<lbrakk>spec_ops ?xs ?deps; ?oid \\<notin> set (map fst ?xs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>pre suf.\n                       ?xs = pre @ suf \\<and>\n                       (\\<forall>i\\<in>set (map fst pre). i < ?oid) \\<and>\n                       (\\<forall>i\\<in>set (map fst suf). ?oid < i)\n  set op_list = subset\n  spec_ops op_list deps\n  (oid, oper) \\<in> ops - subset\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>op_list = pre @ suf;\n         \\<forall>i\\<in>set (map fst pre). i < oid;\n         \\<forall>i\\<in>set (map fst suf). oid < i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, lifting) set_map)"], ["proof (state)\nthis:\n  op_list = pre @ suf\n  \\<forall>i\\<in>set (map fst pre). i < oid\n  \\<forall>i\\<in>set (map fst suf). oid < i\n\ngoal (1 subgoal):\n 1. \\<And>T.\n       \\<lbrakk>T \\<subset> ops;\n        \\<lbrakk>\\<And>oid op1 op2.\n                    \\<lbrakk>(oid, op1) \\<in> T; (oid, op2) \\<in> T\\<rbrakk>\n                    \\<Longrightarrow> op1 = op2;\n         \\<And>oid oper ref.\n            \\<lbrakk>(oid, oper) \\<in> T; ref \\<in> deps oper\\<rbrakk>\n            \\<Longrightarrow> ref < oid\\<rbrakk>\n        \\<Longrightarrow> \\<exists>op_list.\n                             set op_list = T \\<and>\n                             spec_ops op_list deps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<in>ops - T.\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                (x, xb) \\<in> insert s T \\<longrightarrow>\n                                xa = xb) \\<longrightarrow>\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                xb \\<in> deps xa \\<longrightarrow>\n                                xb < x) \\<longrightarrow>\n                            (\\<exists>op_list.\n                                set op_list = insert s T \\<and>\n                                spec_ops op_list deps)", "moreover"], ["proof (state)\nthis:\n  op_list = pre @ suf\n  \\<forall>i\\<in>set (map fst pre). i < oid\n  \\<forall>i\\<in>set (map fst suf). oid < i\n\ngoal (1 subgoal):\n 1. \\<And>T.\n       \\<lbrakk>T \\<subset> ops;\n        \\<lbrakk>\\<And>oid op1 op2.\n                    \\<lbrakk>(oid, op1) \\<in> T; (oid, op2) \\<in> T\\<rbrakk>\n                    \\<Longrightarrow> op1 = op2;\n         \\<And>oid oper ref.\n            \\<lbrakk>(oid, oper) \\<in> T; ref \\<in> deps oper\\<rbrakk>\n            \\<Longrightarrow> ref < oid\\<rbrakk>\n        \\<Longrightarrow> \\<exists>op_list.\n                             set op_list = T \\<and>\n                             spec_ops op_list deps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<in>ops - T.\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                (x, xb) \\<in> insert s T \\<longrightarrow>\n                                xa = xb) \\<longrightarrow>\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                xb \\<in> deps xa \\<longrightarrow>\n                                xb < x) \\<longrightarrow>\n                            (\\<exists>op_list.\n                                set op_list = insert s T \\<and>\n                                spec_ops op_list deps)", "have \"set (pre @ [(oid, oper)] @ suf) = insert (oid, oper) subset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (pre @ [(oid, oper)] @ suf) = insert (oid, oper) subset", "using calculation"], ["proof (prove)\nusing this:\n  set op_list = subset\n  spec_ops op_list deps\n  (oid, oper) \\<in> ops - subset\n  op_list = pre @ suf\n  \\<forall>i\\<in>set (map fst pre). i < oid\n  \\<forall>i\\<in>set (map fst suf). oid < i\n\ngoal (1 subgoal):\n 1. set (pre @ [(oid, oper)] @ suf) = insert (oid, oper) subset", "by auto"], ["proof (state)\nthis:\n  set (pre @ [(oid, oper)] @ suf) = insert (oid, oper) subset\n\ngoal (1 subgoal):\n 1. \\<And>T.\n       \\<lbrakk>T \\<subset> ops;\n        \\<lbrakk>\\<And>oid op1 op2.\n                    \\<lbrakk>(oid, op1) \\<in> T; (oid, op2) \\<in> T\\<rbrakk>\n                    \\<Longrightarrow> op1 = op2;\n         \\<And>oid oper ref.\n            \\<lbrakk>(oid, oper) \\<in> T; ref \\<in> deps oper\\<rbrakk>\n            \\<Longrightarrow> ref < oid\\<rbrakk>\n        \\<Longrightarrow> \\<exists>op_list.\n                             set op_list = T \\<and>\n                             spec_ops op_list deps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<in>ops - T.\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                (x, xb) \\<in> insert s T \\<longrightarrow>\n                                xa = xb) \\<longrightarrow>\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                xb \\<in> deps xa \\<longrightarrow>\n                                xb < x) \\<longrightarrow>\n                            (\\<exists>op_list.\n                                set op_list = insert s T \\<and>\n                                spec_ops op_list deps)", "moreover"], ["proof (state)\nthis:\n  set (pre @ [(oid, oper)] @ suf) = insert (oid, oper) subset\n\ngoal (1 subgoal):\n 1. \\<And>T.\n       \\<lbrakk>T \\<subset> ops;\n        \\<lbrakk>\\<And>oid op1 op2.\n                    \\<lbrakk>(oid, op1) \\<in> T; (oid, op2) \\<in> T\\<rbrakk>\n                    \\<Longrightarrow> op1 = op2;\n         \\<And>oid oper ref.\n            \\<lbrakk>(oid, oper) \\<in> T; ref \\<in> deps oper\\<rbrakk>\n            \\<Longrightarrow> ref < oid\\<rbrakk>\n        \\<Longrightarrow> \\<exists>op_list.\n                             set op_list = T \\<and>\n                             spec_ops op_list deps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<in>ops - T.\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                (x, xb) \\<in> insert s T \\<longrightarrow>\n                                xa = xb) \\<longrightarrow>\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                xb \\<in> deps xa \\<longrightarrow>\n                                xb < x) \\<longrightarrow>\n                            (\\<exists>op_list.\n                                set op_list = insert s T \\<and>\n                                spec_ops op_list deps)", "have \"spec_ops (pre @ [(oid, oper)] @ suf) deps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec_ops (pre @ [(oid, oper)] @ suf) deps", "using calculation spec_ops_add_any assms(3)"], ["proof (prove)\nusing this:\n  set op_list = subset\n  spec_ops op_list deps\n  (oid, oper) \\<in> ops - subset\n  op_list = pre @ suf\n  \\<forall>i\\<in>set (map fst pre). i < oid\n  \\<forall>i\\<in>set (map fst suf). oid < i\n  set (pre @ [(oid, oper)] @ suf) = insert (oid, oper) subset\n  \\<lbrakk>spec_ops (?xs @ ?ys) ?deps;\n   \\<forall>i\\<in>set (map fst ?xs). i < ?oid;\n   \\<forall>i\\<in>set (map fst ?ys). ?oid < i;\n   \\<forall>ref\\<in>?deps ?oper. ref < ?oid\\<rbrakk>\n  \\<Longrightarrow> spec_ops (?xs @ [(?oid, ?oper)] @ ?ys) ?deps\n  \\<lbrakk>(?oid, ?oper) \\<in> ops; ?ref \\<in> deps ?oper\\<rbrakk>\n  \\<Longrightarrow> ?ref < ?oid\n\ngoal (1 subgoal):\n 1. spec_ops (pre @ [(oid, oper)] @ suf) deps", "by (metis DiffD1)"], ["proof (state)\nthis:\n  spec_ops (pre @ [(oid, oper)] @ suf) deps\n\ngoal (1 subgoal):\n 1. \\<And>T.\n       \\<lbrakk>T \\<subset> ops;\n        \\<lbrakk>\\<And>oid op1 op2.\n                    \\<lbrakk>(oid, op1) \\<in> T; (oid, op2) \\<in> T\\<rbrakk>\n                    \\<Longrightarrow> op1 = op2;\n         \\<And>oid oper ref.\n            \\<lbrakk>(oid, oper) \\<in> T; ref \\<in> deps oper\\<rbrakk>\n            \\<Longrightarrow> ref < oid\\<rbrakk>\n        \\<Longrightarrow> \\<exists>op_list.\n                             set op_list = T \\<and>\n                             spec_ops op_list deps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s\\<in>ops - T.\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                (x, xb) \\<in> insert s T \\<longrightarrow>\n                                xa = xb) \\<longrightarrow>\n                            (\\<forall>x xa xb.\n                                (x, xa) \\<in> insert s T \\<longrightarrow>\n                                xb \\<in> deps xa \\<longrightarrow>\n                                xb < x) \\<longrightarrow>\n                            (\\<exists>op_list.\n                                set op_list = insert s T \\<and>\n                                spec_ops op_list deps)", "ultimately"], ["proof (chain)\npicking this:\n  set op_list = subset\n  spec_ops op_list deps\n  (oid, oper) \\<in> ops - subset\n  op_list = pre @ suf\n  \\<forall>i\\<in>set (map fst pre). i < oid\n  \\<forall>i\\<in>set (map fst suf). oid < i\n  set (pre @ [(oid, oper)] @ suf) = insert (oid, oper) subset\n  spec_ops (pre @ [(oid, oper)] @ suf) deps", "show ?case"], ["proof (prove)\nusing this:\n  set op_list = subset\n  spec_ops op_list deps\n  (oid, oper) \\<in> ops - subset\n  op_list = pre @ suf\n  \\<forall>i\\<in>set (map fst pre). i < oid\n  \\<forall>i\\<in>set (map fst suf). oid < i\n  set (pre @ [(oid, oper)] @ suf) = insert (oid, oper) subset\n  spec_ops (pre @ [(oid, oper)] @ suf) deps\n\ngoal (1 subgoal):\n 1. \\<exists>s\\<in>ops - subset.\n       (\\<forall>x xa xb.\n           (x, xa) \\<in> insert s subset \\<longrightarrow>\n           (x, xb) \\<in> insert s subset \\<longrightarrow>\n           xa = xb) \\<longrightarrow>\n       (\\<forall>x xa xb.\n           (x, xa) \\<in> insert s subset \\<longrightarrow>\n           xb \\<in> deps xa \\<longrightarrow> xb < x) \\<longrightarrow>\n       (\\<exists>op_list.\n           set op_list = insert s subset \\<and> spec_ops op_list deps)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s\\<in>ops - subset.\n     (\\<forall>x xa xb.\n         (x, xa) \\<in> insert s subset \\<longrightarrow>\n         (x, xb) \\<in> insert s subset \\<longrightarrow>\n         xa = xb) \\<longrightarrow>\n     (\\<forall>x xa xb.\n         (x, xa) \\<in> insert s subset \\<longrightarrow>\n         xb \\<in> deps xa \\<longrightarrow> xb < x) \\<longrightarrow>\n     (\\<exists>op_list.\n         set op_list = insert s subset \\<and> spec_ops op_list deps)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>We prove that for any given OpSet, a \\isa{spec-ops} linearisation exists:\\<close>"], ["", "lemma spec_ops_exists:\n  assumes \"opset ops deps\"\n  shows \"\\<exists>op_list. set op_list = ops \\<and> spec_ops op_list deps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>op_list. set op_list = ops \\<and> spec_ops op_list deps", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>op_list. set op_list = ops \\<and> spec_ops op_list deps", "have \"finite ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ops", "using assms opset.finite_opset"], ["proof (prove)\nusing this:\n  opset ops deps\n  opset ?opset ?deps \\<Longrightarrow> finite ?opset\n\ngoal (1 subgoal):\n 1. finite ops", "by force"], ["proof (state)\nthis:\n  finite ops\n\ngoal (1 subgoal):\n 1. \\<exists>op_list. set op_list = ops \\<and> spec_ops op_list deps", "moreover"], ["proof (state)\nthis:\n  finite ops\n\ngoal (1 subgoal):\n 1. \\<exists>op_list. set op_list = ops \\<and> spec_ops op_list deps", "have \"\\<And>oid op1 op2. (oid, op1) \\<in> ops \\<Longrightarrow> (oid, op2) \\<in> ops \\<Longrightarrow> op1 = op2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>oid op1 op2.\n       \\<lbrakk>(oid, op1) \\<in> ops; (oid, op2) \\<in> ops\\<rbrakk>\n       \\<Longrightarrow> op1 = op2", "using assms opset.unique_oid"], ["proof (prove)\nusing this:\n  opset ops deps\n  \\<lbrakk>opset ?opset ?deps; (?oid, ?op1.0) \\<in> ?opset;\n   (?oid, ?op2.0) \\<in> ?opset\\<rbrakk>\n  \\<Longrightarrow> ?op1.0 = ?op2.0\n\ngoal (1 subgoal):\n 1. \\<And>oid op1 op2.\n       \\<lbrakk>(oid, op1) \\<in> ops; (oid, op2) \\<in> ops\\<rbrakk>\n       \\<Longrightarrow> op1 = op2", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>(?oid, ?op1.0) \\<in> ops; (?oid, ?op2.0) \\<in> ops\\<rbrakk>\n  \\<Longrightarrow> ?op1.0 = ?op2.0\n\ngoal (1 subgoal):\n 1. \\<exists>op_list. set op_list = ops \\<and> spec_ops op_list deps", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>(?oid, ?op1.0) \\<in> ops; (?oid, ?op2.0) \\<in> ops\\<rbrakk>\n  \\<Longrightarrow> ?op1.0 = ?op2.0\n\ngoal (1 subgoal):\n 1. \\<exists>op_list. set op_list = ops \\<and> spec_ops op_list deps", "have \"\\<And>oid oper ref. (oid, oper) \\<in> ops \\<Longrightarrow> ref \\<in> deps oper \\<Longrightarrow> ref < oid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>oid oper ref.\n       \\<lbrakk>(oid, oper) \\<in> ops; ref \\<in> deps oper\\<rbrakk>\n       \\<Longrightarrow> ref < oid", "using assms opset.ref_older"], ["proof (prove)\nusing this:\n  opset ops deps\n  \\<lbrakk>opset ?opset ?deps; (?oid, ?oper) \\<in> ?opset;\n   ?ref \\<in> ?deps ?oper\\<rbrakk>\n  \\<Longrightarrow> ?ref < ?oid\n\ngoal (1 subgoal):\n 1. \\<And>oid oper ref.\n       \\<lbrakk>(oid, oper) \\<in> ops; ref \\<in> deps oper\\<rbrakk>\n       \\<Longrightarrow> ref < oid", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>(?oid, ?oper) \\<in> ops; ?ref \\<in> deps ?oper\\<rbrakk>\n  \\<Longrightarrow> ?ref < ?oid\n\ngoal (1 subgoal):\n 1. \\<exists>op_list. set op_list = ops \\<and> spec_ops op_list deps", "ultimately"], ["proof (chain)\npicking this:\n  finite ops\n  \\<lbrakk>(?oid, ?op1.0) \\<in> ops; (?oid, ?op2.0) \\<in> ops\\<rbrakk>\n  \\<Longrightarrow> ?op1.0 = ?op2.0\n  \\<lbrakk>(?oid, ?oper) \\<in> ops; ?ref \\<in> deps ?oper\\<rbrakk>\n  \\<Longrightarrow> ?ref < ?oid", "show \"\\<exists>op_list. set op_list = ops \\<and> spec_ops op_list deps\""], ["proof (prove)\nusing this:\n  finite ops\n  \\<lbrakk>(?oid, ?op1.0) \\<in> ops; (?oid, ?op2.0) \\<in> ops\\<rbrakk>\n  \\<Longrightarrow> ?op1.0 = ?op2.0\n  \\<lbrakk>(?oid, ?oper) \\<in> ops; ?ref \\<in> deps ?oper\\<rbrakk>\n  \\<Longrightarrow> ?ref < ?oid\n\ngoal (1 subgoal):\n 1. \\<exists>op_list. set op_list = ops \\<and> spec_ops op_list deps", "by (simp add: spec_ops_exists_base)"], ["proof (state)\nthis:\n  \\<exists>op_list. set op_list = ops \\<and> spec_ops op_list deps\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma spec_ops_oid_unique:\n  assumes \"spec_ops op_list deps\"\n    and \"(oid, op1) \\<in> set op_list\"\n    and \"(oid, op2) \\<in> set op_list\"\n  shows \"op1 = op2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op1 = op2", "using assms"], ["proof (prove)\nusing this:\n  spec_ops op_list deps\n  (oid, op1) \\<in> set op_list\n  (oid, op2) \\<in> set op_list\n\ngoal (1 subgoal):\n 1. op1 = op2", "proof(induction op_list, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a op_list.\n       \\<lbrakk>\\<lbrakk>spec_ops op_list deps;\n                 (oid, op1) \\<in> set op_list;\n                 (oid, op2) \\<in> set op_list\\<rbrakk>\n                \\<Longrightarrow> op1 = op2;\n        spec_ops (a # op_list) deps; (oid, op1) \\<in> set (a # op_list);\n        (oid, op2) \\<in> set (a # op_list)\\<rbrakk>\n       \\<Longrightarrow> op1 = op2", "case (Cons x op_list)"], ["proof (state)\nthis:\n  \\<lbrakk>spec_ops op_list deps; (oid, op1) \\<in> set op_list;\n   (oid, op2) \\<in> set op_list\\<rbrakk>\n  \\<Longrightarrow> op1 = op2\n  spec_ops (x # op_list) deps\n  (oid, op1) \\<in> set (x # op_list)\n  (oid, op2) \\<in> set (x # op_list)\n\ngoal (1 subgoal):\n 1. \\<And>a op_list.\n       \\<lbrakk>\\<lbrakk>spec_ops op_list deps;\n                 (oid, op1) \\<in> set op_list;\n                 (oid, op2) \\<in> set op_list\\<rbrakk>\n                \\<Longrightarrow> op1 = op2;\n        spec_ops (a # op_list) deps; (oid, op1) \\<in> set (a # op_list);\n        (oid, op2) \\<in> set (a # op_list)\\<rbrakk>\n       \\<Longrightarrow> op1 = op2", "have \"distinct (map fst (x # op_list))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (x # op_list))", "using Cons.prems(1) spec_ops_def"], ["proof (prove)\nusing this:\n  spec_ops (x # op_list) deps\n  spec_ops ?ops ?deps \\<equiv>\n  sorted (map fst ?ops) \\<and>\n  distinct (map fst ?ops) \\<and>\n  (\\<forall>oid oper ref.\n      (oid, oper) \\<in> set ?ops \\<and>\n      ref \\<in> ?deps oper \\<longrightarrow>\n      ref < oid)\n\ngoal (1 subgoal):\n 1. distinct (map fst (x # op_list))", "by blast"], ["proof (state)\nthis:\n  distinct (map fst (x # op_list))\n\ngoal (1 subgoal):\n 1. \\<And>a op_list.\n       \\<lbrakk>\\<lbrakk>spec_ops op_list deps;\n                 (oid, op1) \\<in> set op_list;\n                 (oid, op2) \\<in> set op_list\\<rbrakk>\n                \\<Longrightarrow> op1 = op2;\n        spec_ops (a # op_list) deps; (oid, op1) \\<in> set (a # op_list);\n        (oid, op2) \\<in> set (a # op_list)\\<rbrakk>\n       \\<Longrightarrow> op1 = op2", "hence notin: \"fst x \\<notin> set (map fst op_list)\""], ["proof (prove)\nusing this:\n  distinct (map fst (x # op_list))\n\ngoal (1 subgoal):\n 1. fst x \\<notin> set (map fst op_list)", "by simp"], ["proof (state)\nthis:\n  fst x \\<notin> set (map fst op_list)\n\ngoal (1 subgoal):\n 1. \\<And>a op_list.\n       \\<lbrakk>\\<lbrakk>spec_ops op_list deps;\n                 (oid, op1) \\<in> set op_list;\n                 (oid, op2) \\<in> set op_list\\<rbrakk>\n                \\<Longrightarrow> op1 = op2;\n        spec_ops (a # op_list) deps; (oid, op1) \\<in> set (a # op_list);\n        (oid, op2) \\<in> set (a # op_list)\\<rbrakk>\n       \\<Longrightarrow> op1 = op2", "then"], ["proof (chain)\npicking this:\n  fst x \\<notin> set (map fst op_list)", "show \"op1 = op2\""], ["proof (prove)\nusing this:\n  fst x \\<notin> set (map fst op_list)\n\ngoal (1 subgoal):\n 1. op1 = op2", "proof(cases \"fst x = oid\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>fst x \\<notin> set (map fst op_list); fst x = oid\\<rbrakk>\n    \\<Longrightarrow> op1 = op2\n 2. \\<lbrakk>fst x \\<notin> set (map fst op_list);\n     fst x \\<noteq> oid\\<rbrakk>\n    \\<Longrightarrow> op1 = op2", "case True"], ["proof (state)\nthis:\n  fst x = oid\n\ngoal (2 subgoals):\n 1. \\<lbrakk>fst x \\<notin> set (map fst op_list); fst x = oid\\<rbrakk>\n    \\<Longrightarrow> op1 = op2\n 2. \\<lbrakk>fst x \\<notin> set (map fst op_list);\n     fst x \\<noteq> oid\\<rbrakk>\n    \\<Longrightarrow> op1 = op2", "then"], ["proof (chain)\npicking this:\n  fst x = oid", "show \"op1 = op2\""], ["proof (prove)\nusing this:\n  fst x = oid\n\ngoal (1 subgoal):\n 1. op1 = op2", "using Cons.prems notin"], ["proof (prove)\nusing this:\n  fst x = oid\n  spec_ops (x # op_list) deps\n  (oid, op1) \\<in> set (x # op_list)\n  (oid, op2) \\<in> set (x # op_list)\n  fst x \\<notin> set (map fst op_list)\n\ngoal (1 subgoal):\n 1. op1 = op2", "by (metis Pair_inject in_set_zipE set_ConsD zip_map_fst_snd)"], ["proof (state)\nthis:\n  op1 = op2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst x \\<notin> set (map fst op_list);\n     fst x \\<noteq> oid\\<rbrakk>\n    \\<Longrightarrow> op1 = op2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst x \\<notin> set (map fst op_list);\n     fst x \\<noteq> oid\\<rbrakk>\n    \\<Longrightarrow> op1 = op2", "case False"], ["proof (state)\nthis:\n  fst x \\<noteq> oid\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst x \\<notin> set (map fst op_list);\n     fst x \\<noteq> oid\\<rbrakk>\n    \\<Longrightarrow> op1 = op2", "then"], ["proof (chain)\npicking this:\n  fst x \\<noteq> oid", "have \"(oid, op1) \\<in> set op_list\" and \"(oid, op2) \\<in> set op_list\""], ["proof (prove)\nusing this:\n  fst x \\<noteq> oid\n\ngoal (1 subgoal):\n 1. (oid, op1) \\<in> set op_list &&& (oid, op2) \\<in> set op_list", "using Cons.prems"], ["proof (prove)\nusing this:\n  fst x \\<noteq> oid\n  spec_ops (x # op_list) deps\n  (oid, op1) \\<in> set (x # op_list)\n  (oid, op2) \\<in> set (x # op_list)\n\ngoal (1 subgoal):\n 1. (oid, op1) \\<in> set op_list &&& (oid, op2) \\<in> set op_list", "by auto"], ["proof (state)\nthis:\n  (oid, op1) \\<in> set op_list\n  (oid, op2) \\<in> set op_list\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst x \\<notin> set (map fst op_list);\n     fst x \\<noteq> oid\\<rbrakk>\n    \\<Longrightarrow> op1 = op2", "then"], ["proof (chain)\npicking this:\n  (oid, op1) \\<in> set op_list\n  (oid, op2) \\<in> set op_list", "show \"op1 = op2\""], ["proof (prove)\nusing this:\n  (oid, op1) \\<in> set op_list\n  (oid, op2) \\<in> set op_list\n\ngoal (1 subgoal):\n 1. op1 = op2", "using Cons.IH Cons.prems(1) spec_ops_rem_cons"], ["proof (prove)\nusing this:\n  (oid, op1) \\<in> set op_list\n  (oid, op2) \\<in> set op_list\n  \\<lbrakk>spec_ops op_list deps; (oid, op1) \\<in> set op_list;\n   (oid, op2) \\<in> set op_list\\<rbrakk>\n  \\<Longrightarrow> op1 = op2\n  spec_ops (x # op_list) deps\n  spec_ops (?x # ?xs) ?deps \\<Longrightarrow> spec_ops ?xs ?deps\n\ngoal (1 subgoal):\n 1. op1 = op2", "by blast"], ["proof (state)\nthis:\n  op1 = op2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  op1 = op2\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Conversely, for any given \\isa{spec-ops} list, the set of pairs in the\nlist is an OpSet:\\<close>"], ["", "lemma spec_ops_is_opset:\n  assumes \"spec_ops op_list deps\"\n  shows \"opset (set op_list) deps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. opset (set op_list) deps", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. opset (set op_list) deps", "have \"\\<And>oid op1 op2. (oid, op1) \\<in> set op_list \\<Longrightarrow> (oid, op2) \\<in> set op_list \\<Longrightarrow> op1 = op2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>oid op1 op2.\n       \\<lbrakk>(oid, op1) \\<in> set op_list;\n        (oid, op2) \\<in> set op_list\\<rbrakk>\n       \\<Longrightarrow> op1 = op2", "using assms spec_ops_oid_unique"], ["proof (prove)\nusing this:\n  spec_ops op_list deps\n  \\<lbrakk>spec_ops ?op_list ?deps; (?oid, ?op1.0) \\<in> set ?op_list;\n   (?oid, ?op2.0) \\<in> set ?op_list\\<rbrakk>\n  \\<Longrightarrow> ?op1.0 = ?op2.0\n\ngoal (1 subgoal):\n 1. \\<And>oid op1 op2.\n       \\<lbrakk>(oid, op1) \\<in> set op_list;\n        (oid, op2) \\<in> set op_list\\<rbrakk>\n       \\<Longrightarrow> op1 = op2", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>(?oid, ?op1.0) \\<in> set op_list;\n   (?oid, ?op2.0) \\<in> set op_list\\<rbrakk>\n  \\<Longrightarrow> ?op1.0 = ?op2.0\n\ngoal (1 subgoal):\n 1. opset (set op_list) deps", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>(?oid, ?op1.0) \\<in> set op_list;\n   (?oid, ?op2.0) \\<in> set op_list\\<rbrakk>\n  \\<Longrightarrow> ?op1.0 = ?op2.0\n\ngoal (1 subgoal):\n 1. opset (set op_list) deps", "have \"\\<And>oid oper ref. (oid, oper) \\<in> set op_list \\<Longrightarrow> ref \\<in> deps oper \\<Longrightarrow> ref < oid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>oid oper ref.\n       \\<lbrakk>(oid, oper) \\<in> set op_list; ref \\<in> deps oper\\<rbrakk>\n       \\<Longrightarrow> ref < oid", "by (meson assms spec_ops_ref_less)"], ["proof (state)\nthis:\n  \\<lbrakk>(?oid, ?oper) \\<in> set op_list; ?ref \\<in> deps ?oper\\<rbrakk>\n  \\<Longrightarrow> ?ref < ?oid\n\ngoal (1 subgoal):\n 1. opset (set op_list) deps", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>(?oid, ?oper) \\<in> set op_list; ?ref \\<in> deps ?oper\\<rbrakk>\n  \\<Longrightarrow> ?ref < ?oid\n\ngoal (1 subgoal):\n 1. opset (set op_list) deps", "have \"finite (set op_list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set op_list)", "by simp"], ["proof (state)\nthis:\n  finite (set op_list)\n\ngoal (1 subgoal):\n 1. opset (set op_list) deps", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?oid, ?op1.0) \\<in> set op_list;\n   (?oid, ?op2.0) \\<in> set op_list\\<rbrakk>\n  \\<Longrightarrow> ?op1.0 = ?op2.0\n  \\<lbrakk>(?oid, ?oper) \\<in> set op_list; ?ref \\<in> deps ?oper\\<rbrakk>\n  \\<Longrightarrow> ?ref < ?oid\n  finite (set op_list)", "show \"opset (set op_list) deps\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?oid, ?op1.0) \\<in> set op_list;\n   (?oid, ?op2.0) \\<in> set op_list\\<rbrakk>\n  \\<Longrightarrow> ?op1.0 = ?op2.0\n  \\<lbrakk>(?oid, ?oper) \\<in> set op_list; ?ref \\<in> deps ?oper\\<rbrakk>\n  \\<Longrightarrow> ?ref < ?oid\n  finite (set op_list)\n\ngoal (1 subgoal):\n 1. opset (set op_list) deps", "by (simp add: opset_def)"], ["proof (state)\nthis:\n  opset (set op_list) deps\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>The \\isa{crdt-ops} predicate\\<close>"], ["", "text\\<open>Like \\isa{spec-ops}, the \\isa{crdt-ops} predicate describes the linearisation of\nan OpSet into a list. Like \\isa{spec-ops}, it requires IDs to be unique. However,\nits other properties are different: \\isa{crdt-ops} does not require operations to\nappear in sorted order, but instead, whenever any operation references the\nID of a prior operation, that prior operation must appear previously in the\n\\isa{crdt-ops} list. Thus, the order of operations is partially constrained:\noperations must appear in causal order, but concurrent operations can be\nordered arbitrarily.\n\nThis list describes the operation sequence in the order it is typically applied to\nan operation-based CRDT. Applying operations in the order they appear in\n\\isa{crdt-ops} requires that concurrent operations commute. For any \\isa{crdt-ops}\noperation sequence, there is a permutation that satisfies the \\isa{spec-ops}\npredicate. Thus, to check whether a CRDT satisfies its sequential specification,\nwe can prove that interpreting any \\isa{crdt-ops} operation sequence with the\ncommutative operation interpretation results in the same end result as\ninterpreting the \\isa{spec-ops} permutation of that operation sequence with the\nsequential operation interpretation.\\<close>"], ["", "inductive crdt_ops :: \"('oid::{linorder} \\<times> 'oper) list \\<Rightarrow> ('oper \\<Rightarrow> 'oid set) \\<Rightarrow> bool\" where\n  \"crdt_ops [] deps\" |\n  \"\\<lbrakk>crdt_ops xs deps;\n    oid \\<notin> set (map fst xs);\n    \\<forall>ref \\<in> deps oper. ref \\<in> set (map fst xs) \\<and> ref < oid\n   \\<rbrakk> \\<Longrightarrow> crdt_ops (xs @ [(oid, oper)]) deps\""], ["", "inductive_cases crdt_ops_last: \"crdt_ops (xs @ [x]) deps\""], ["", "lemma crdt_ops_intro:\n  assumes \"\\<And>r. r \\<in> deps oper \\<Longrightarrow> r \\<in> fst ` set xs \\<and> r < oid\"\n    and \"oid \\<notin> fst ` set xs\"\n    and \"crdt_ops xs deps\"\n  shows \"crdt_ops (xs @ [(oid, oper)]) deps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crdt_ops (xs @ [(oid, oper)]) deps", "using assms crdt_ops.simps"], ["proof (prove)\nusing this:\n  ?r \\<in> deps oper \\<Longrightarrow> ?r \\<in> fst ` set xs \\<and> ?r < oid\n  oid \\<notin> fst ` set xs\n  crdt_ops xs deps\n  crdt_ops ?a1.0 ?a2.0 =\n  ((\\<exists>deps. ?a1.0 = [] \\<and> ?a2.0 = deps) \\<or>\n   (\\<exists>xs deps oid oper.\n       ?a1.0 = xs @ [(oid, oper)] \\<and>\n       ?a2.0 = deps \\<and>\n       crdt_ops xs deps \\<and>\n       oid \\<notin> set (map fst xs) \\<and>\n       (\\<forall>ref\\<in>deps oper.\n           ref \\<in> set (map fst xs) \\<and> ref < oid)))\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ [(oid, oper)]) deps", "by force"], ["", "lemma crdt_ops_rem_last:\n  assumes \"crdt_ops (xs @ [x]) deps\"\n  shows \"crdt_ops xs deps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crdt_ops xs deps", "using assms crdt_ops.cases snoc_eq_iff_butlast"], ["proof (prove)\nusing this:\n  crdt_ops (xs @ [x]) deps\n  \\<lbrakk>crdt_ops ?a1.0 ?a2.0;\n   \\<And>deps.\n      \\<lbrakk>?a1.0 = []; ?a2.0 = deps\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>xs deps oid oper.\n      \\<lbrakk>?a1.0 = xs @ [(oid, oper)]; ?a2.0 = deps; crdt_ops xs deps;\n       oid \\<notin> set (map fst xs);\n       \\<forall>ref\\<in>deps oper.\n          ref \\<in> set (map fst xs) \\<and> ref < oid\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  (?xs @ [?x] = ?ys) =\n  (?ys \\<noteq> [] \\<and> butlast ?ys = ?xs \\<and> last ?ys = ?x)\n\ngoal (1 subgoal):\n 1. crdt_ops xs deps", "by blast"], ["", "lemma crdt_ops_ref_less:\n  assumes \"crdt_ops xs deps\"\n    and \"(oid, oper) \\<in> set xs\"\n    and \"r \\<in> deps oper\"\n  shows \"r < oid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < oid", "using assms"], ["proof (prove)\nusing this:\n  crdt_ops xs deps\n  (oid, oper) \\<in> set xs\n  r \\<in> deps oper\n\ngoal (1 subgoal):\n 1. r < oid", "by (induction rule: crdt_ops.induct, auto)"], ["", "lemma crdt_ops_ref_less_last:\n  assumes \"crdt_ops (xs @ [(oid, oper)]) deps\"\n    and \"r \\<in> deps oper\"\n  shows \"r < oid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < oid", "using assms crdt_ops_ref_less"], ["proof (prove)\nusing this:\n  crdt_ops (xs @ [(oid, oper)]) deps\n  r \\<in> deps oper\n  \\<lbrakk>crdt_ops ?xs ?deps; (?oid, ?oper) \\<in> set ?xs;\n   ?r \\<in> ?deps ?oper\\<rbrakk>\n  \\<Longrightarrow> ?r < ?oid\n\ngoal (1 subgoal):\n 1. r < oid", "by fastforce"], ["", "lemma crdt_ops_distinct_fst:\n  assumes \"crdt_ops xs deps\"\n  shows \"distinct (map fst xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst xs)", "using assms"], ["proof (prove)\nusing this:\n  crdt_ops xs deps\n\ngoal (1 subgoal):\n 1. distinct (map fst xs)", "proof (induction xs rule: List.rev_induct, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>crdt_ops xs deps \\<Longrightarrow> distinct (map fst xs);\n        crdt_ops (xs @ [x]) deps\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (xs @ [x]))", "case (snoc x xs)"], ["proof (state)\nthis:\n  crdt_ops xs deps \\<Longrightarrow> distinct (map fst xs)\n  crdt_ops (xs @ [x]) deps\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>crdt_ops xs deps \\<Longrightarrow> distinct (map fst xs);\n        crdt_ops (xs @ [x]) deps\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (xs @ [x]))", "hence \"distinct (map fst xs)\""], ["proof (prove)\nusing this:\n  crdt_ops xs deps \\<Longrightarrow> distinct (map fst xs)\n  crdt_ops (xs @ [x]) deps\n\ngoal (1 subgoal):\n 1. distinct (map fst xs)", "using crdt_ops_last"], ["proof (prove)\nusing this:\n  crdt_ops xs deps \\<Longrightarrow> distinct (map fst xs)\n  crdt_ops (xs @ [x]) deps\n  \\<lbrakk>crdt_ops (?xs @ [?x]) ?deps;\n   \\<And>oid oper.\n      \\<lbrakk>?x = (oid, oper); crdt_ops ?xs ?deps;\n       oid \\<notin> fst ` set ?xs;\n       \\<forall>ref\\<in>?deps oper.\n          ref \\<in> fst ` set ?xs \\<and> ref < oid\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. distinct (map fst xs)", "by blast"], ["proof (state)\nthis:\n  distinct (map fst xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>crdt_ops xs deps \\<Longrightarrow> distinct (map fst xs);\n        crdt_ops (xs @ [x]) deps\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (xs @ [x]))", "moreover"], ["proof (state)\nthis:\n  distinct (map fst xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>crdt_ops xs deps \\<Longrightarrow> distinct (map fst xs);\n        crdt_ops (xs @ [x]) deps\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (xs @ [x]))", "have \"fst x \\<notin> set (map fst xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst x \\<notin> set (map fst xs)", "using snoc"], ["proof (prove)\nusing this:\n  crdt_ops xs deps \\<Longrightarrow> distinct (map fst xs)\n  crdt_ops (xs @ [x]) deps\n\ngoal (1 subgoal):\n 1. fst x \\<notin> set (map fst xs)", "by (metis crdt_ops_last fstI image_set)"], ["proof (state)\nthis:\n  fst x \\<notin> set (map fst xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>crdt_ops xs deps \\<Longrightarrow> distinct (map fst xs);\n        crdt_ops (xs @ [x]) deps\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (xs @ [x]))", "ultimately"], ["proof (chain)\npicking this:\n  distinct (map fst xs)\n  fst x \\<notin> set (map fst xs)", "show \"distinct (map fst (xs @ [x]))\""], ["proof (prove)\nusing this:\n  distinct (map fst xs)\n  fst x \\<notin> set (map fst xs)\n\ngoal (1 subgoal):\n 1. distinct (map fst (xs @ [x]))", "by simp"], ["proof (state)\nthis:\n  distinct (map fst (xs @ [x]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma crdt_ops_distinct:\n  assumes \"crdt_ops xs deps\"\n  shows \"distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs", "using assms crdt_ops_distinct_fst distinct_map"], ["proof (prove)\nusing this:\n  crdt_ops xs deps\n  crdt_ops ?xs ?deps \\<Longrightarrow> distinct (map fst ?xs)\n  distinct (map ?f ?xs) = (distinct ?xs \\<and> inj_on ?f (set ?xs))\n\ngoal (1 subgoal):\n 1. distinct xs", "by blast"], ["", "lemma crdt_ops_unique_last:\n  assumes \"crdt_ops (xs @ [(oid, oper)]) deps\"\n  shows \"oid \\<notin> set (map fst xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oid \\<notin> set (map fst xs)", "using assms crdt_ops.cases"], ["proof (prove)\nusing this:\n  crdt_ops (xs @ [(oid, oper)]) deps\n  \\<lbrakk>crdt_ops ?a1.0 ?a2.0;\n   \\<And>deps.\n      \\<lbrakk>?a1.0 = []; ?a2.0 = deps\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>xs deps oid oper.\n      \\<lbrakk>?a1.0 = xs @ [(oid, oper)]; ?a2.0 = deps; crdt_ops xs deps;\n       oid \\<notin> set (map fst xs);\n       \\<forall>ref\\<in>deps oper.\n          ref \\<in> set (map fst xs) \\<and> ref < oid\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. oid \\<notin> set (map fst xs)", "by blast"], ["", "lemma crdt_ops_unique_mid:\n  assumes \"crdt_ops (xs @ [(oid, oper)] @ ys) deps\"\n  shows \"oid \\<notin> set (map fst xs) \\<and> oid \\<notin> set (map fst ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oid \\<notin> set (map fst xs) \\<and> oid \\<notin> set (map fst ys)", "using assms"], ["proof (prove)\nusing this:\n  crdt_ops (xs @ [(oid, oper)] @ ys) deps\n\ngoal (1 subgoal):\n 1. oid \\<notin> set (map fst xs) \\<and> oid \\<notin> set (map fst ys)", "proof(induction ys rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. crdt_ops (xs @ [(oid, oper)] @ []) deps \\<Longrightarrow>\n    oid \\<notin> set (map fst xs) \\<and> oid \\<notin> set (map fst [])\n 2. \\<And>x xsa.\n       \\<lbrakk>crdt_ops (xs @ [(oid, oper)] @ xsa) deps \\<Longrightarrow>\n                oid \\<notin> set (map fst xs) \\<and>\n                oid \\<notin> set (map fst xsa);\n        crdt_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (map fst xs) \\<and>\n                         oid \\<notin> set (map fst (xsa @ [x]))", "case Nil"], ["proof (state)\nthis:\n  crdt_ops (xs @ [(oid, oper)] @ []) deps\n\ngoal (2 subgoals):\n 1. crdt_ops (xs @ [(oid, oper)] @ []) deps \\<Longrightarrow>\n    oid \\<notin> set (map fst xs) \\<and> oid \\<notin> set (map fst [])\n 2. \\<And>x xsa.\n       \\<lbrakk>crdt_ops (xs @ [(oid, oper)] @ xsa) deps \\<Longrightarrow>\n                oid \\<notin> set (map fst xs) \\<and>\n                oid \\<notin> set (map fst xsa);\n        crdt_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (map fst xs) \\<and>\n                         oid \\<notin> set (map fst (xsa @ [x]))", "then"], ["proof (chain)\npicking this:\n  crdt_ops (xs @ [(oid, oper)] @ []) deps", "show \"oid \\<notin> set (map fst xs) \\<and> oid \\<notin> set (map fst [])\""], ["proof (prove)\nusing this:\n  crdt_ops (xs @ [(oid, oper)] @ []) deps\n\ngoal (1 subgoal):\n 1. oid \\<notin> set (map fst xs) \\<and> oid \\<notin> set (map fst [])", "by (metis crdt_ops_unique_last Nil_is_map_conv append_Nil2 empty_iff empty_set)"], ["proof (state)\nthis:\n  oid \\<notin> set (map fst xs) \\<and> oid \\<notin> set (map fst [])\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>crdt_ops (xs @ [(oid, oper)] @ xsa) deps \\<Longrightarrow>\n                oid \\<notin> set (map fst xs) \\<and>\n                oid \\<notin> set (map fst xsa);\n        crdt_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (map fst xs) \\<and>\n                         oid \\<notin> set (map fst (xsa @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>crdt_ops (xs @ [(oid, oper)] @ xsa) deps \\<Longrightarrow>\n                oid \\<notin> set (map fst xs) \\<and>\n                oid \\<notin> set (map fst xsa);\n        crdt_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (map fst xs) \\<and>\n                         oid \\<notin> set (map fst (xsa @ [x]))", "case (snoc y ys)"], ["proof (state)\nthis:\n  crdt_ops (xs @ [(oid, oper)] @ ys) deps \\<Longrightarrow>\n  oid \\<notin> set (map fst xs) \\<and> oid \\<notin> set (map fst ys)\n  crdt_ops (xs @ [(oid, oper)] @ ys @ [y]) deps\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>crdt_ops (xs @ [(oid, oper)] @ xsa) deps \\<Longrightarrow>\n                oid \\<notin> set (map fst xs) \\<and>\n                oid \\<notin> set (map fst xsa);\n        crdt_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (map fst xs) \\<and>\n                         oid \\<notin> set (map fst (xsa @ [x]))", "obtain yi yr where y_pair: \"y = (yi, yr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>yi yr. y = (yi, yr) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  y = (yi, yr)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>crdt_ops (xs @ [(oid, oper)] @ xsa) deps \\<Longrightarrow>\n                oid \\<notin> set (map fst xs) \\<and>\n                oid \\<notin> set (map fst xsa);\n        crdt_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (map fst xs) \\<and>\n                         oid \\<notin> set (map fst (xsa @ [x]))", "have IH: \"oid \\<notin> set (map fst xs) \\<and> oid \\<notin> set (map fst ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oid \\<notin> set (map fst xs) \\<and> oid \\<notin> set (map fst ys)", "using crdt_ops_rem_last snoc"], ["proof (prove)\nusing this:\n  crdt_ops (?xs @ [?x]) ?deps \\<Longrightarrow> crdt_ops ?xs ?deps\n  crdt_ops (xs @ [(oid, oper)] @ ys) deps \\<Longrightarrow>\n  oid \\<notin> set (map fst xs) \\<and> oid \\<notin> set (map fst ys)\n  crdt_ops (xs @ [(oid, oper)] @ ys @ [y]) deps\n\ngoal (1 subgoal):\n 1. oid \\<notin> set (map fst xs) \\<and> oid \\<notin> set (map fst ys)", "by (metis append_assoc)"], ["proof (state)\nthis:\n  oid \\<notin> set (map fst xs) \\<and> oid \\<notin> set (map fst ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>crdt_ops (xs @ [(oid, oper)] @ xsa) deps \\<Longrightarrow>\n                oid \\<notin> set (map fst xs) \\<and>\n                oid \\<notin> set (map fst xsa);\n        crdt_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (map fst xs) \\<and>\n                         oid \\<notin> set (map fst (xsa @ [x]))", "have \"(xs @ (oid, oper) # ys) @ [(yi, yr)] = xs @ (oid, oper) # ys @ [(yi, yr)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ (oid, oper) # ys) @ [(yi, yr)] =\n    xs @ (oid, oper) # ys @ [(yi, yr)]", "by simp"], ["proof (state)\nthis:\n  (xs @ (oid, oper) # ys) @ [(yi, yr)] = xs @ (oid, oper) # ys @ [(yi, yr)]\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>crdt_ops (xs @ [(oid, oper)] @ xsa) deps \\<Longrightarrow>\n                oid \\<notin> set (map fst xs) \\<and>\n                oid \\<notin> set (map fst xsa);\n        crdt_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (map fst xs) \\<and>\n                         oid \\<notin> set (map fst (xsa @ [x]))", "hence \"yi \\<notin> set (map fst (xs @ (oid, oper) # ys))\""], ["proof (prove)\nusing this:\n  (xs @ (oid, oper) # ys) @ [(yi, yr)] = xs @ (oid, oper) # ys @ [(yi, yr)]\n\ngoal (1 subgoal):\n 1. yi \\<notin> set (map fst (xs @ (oid, oper) # ys))", "using crdt_ops_unique_last"], ["proof (prove)\nusing this:\n  (xs @ (oid, oper) # ys) @ [(yi, yr)] = xs @ (oid, oper) # ys @ [(yi, yr)]\n  crdt_ops (?xs @ [(?oid, ?oper)]) ?deps \\<Longrightarrow>\n  ?oid \\<notin> set (map fst ?xs)\n\ngoal (1 subgoal):\n 1. yi \\<notin> set (map fst (xs @ (oid, oper) # ys))", "by (metis append_Cons append_self_conv2 snoc.prems y_pair)"], ["proof (state)\nthis:\n  yi \\<notin> set (map fst (xs @ (oid, oper) # ys))\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>crdt_ops (xs @ [(oid, oper)] @ xsa) deps \\<Longrightarrow>\n                oid \\<notin> set (map fst xs) \\<and>\n                oid \\<notin> set (map fst xsa);\n        crdt_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps\\<rbrakk>\n       \\<Longrightarrow> oid \\<notin> set (map fst xs) \\<and>\n                         oid \\<notin> set (map fst (xsa @ [x]))", "thus \"oid \\<notin> set (map fst xs) \\<and> oid \\<notin> set (map fst (ys @ [y]))\""], ["proof (prove)\nusing this:\n  yi \\<notin> set (map fst (xs @ (oid, oper) # ys))\n\ngoal (1 subgoal):\n 1. oid \\<notin> set (map fst xs) \\<and>\n    oid \\<notin> set (map fst (ys @ [y]))", "using IH y_pair"], ["proof (prove)\nusing this:\n  yi \\<notin> set (map fst (xs @ (oid, oper) # ys))\n  oid \\<notin> set (map fst xs) \\<and> oid \\<notin> set (map fst ys)\n  y = (yi, yr)\n\ngoal (1 subgoal):\n 1. oid \\<notin> set (map fst xs) \\<and>\n    oid \\<notin> set (map fst (ys @ [y]))", "by auto"], ["proof (state)\nthis:\n  oid \\<notin> set (map fst xs) \\<and> oid \\<notin> set (map fst (ys @ [y]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma crdt_ops_ref_exists:\n  assumes \"crdt_ops (pre @ (oid, oper) # suf) deps\"\n    and \"ref \\<in> deps oper\"\n  shows \"ref \\<in> fst ` set pre\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ref \\<in> fst ` set pre", "using assms"], ["proof (prove)\nusing this:\n  crdt_ops (pre @ (oid, oper) # suf) deps\n  ref \\<in> deps oper\n\ngoal (1 subgoal):\n 1. ref \\<in> fst ` set pre", "proof(induction suf rule: List.rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>crdt_ops (pre @ [(oid, oper)]) deps;\n     ref \\<in> deps oper\\<rbrakk>\n    \\<Longrightarrow> ref \\<in> fst ` set pre\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>crdt_ops (pre @ (oid, oper) # xs) deps;\n                 ref \\<in> deps oper\\<rbrakk>\n                \\<Longrightarrow> ref \\<in> fst ` set pre;\n        crdt_ops (pre @ (oid, oper) # xs @ [x]) deps;\n        ref \\<in> deps oper\\<rbrakk>\n       \\<Longrightarrow> ref \\<in> fst ` set pre", "case Nil"], ["proof (state)\nthis:\n  crdt_ops (pre @ [(oid, oper)]) deps\n  ref \\<in> deps oper\n\ngoal (2 subgoals):\n 1. \\<lbrakk>crdt_ops (pre @ [(oid, oper)]) deps;\n     ref \\<in> deps oper\\<rbrakk>\n    \\<Longrightarrow> ref \\<in> fst ` set pre\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>crdt_ops (pre @ (oid, oper) # xs) deps;\n                 ref \\<in> deps oper\\<rbrakk>\n                \\<Longrightarrow> ref \\<in> fst ` set pre;\n        crdt_ops (pre @ (oid, oper) # xs @ [x]) deps;\n        ref \\<in> deps oper\\<rbrakk>\n       \\<Longrightarrow> ref \\<in> fst ` set pre", "thus ?case"], ["proof (prove)\nusing this:\n  crdt_ops (pre @ [(oid, oper)]) deps\n  ref \\<in> deps oper\n\ngoal (1 subgoal):\n 1. ref \\<in> fst ` set pre", "by (metis crdt_ops_last prod.sel(2))"], ["proof (state)\nthis:\n  ref \\<in> fst ` set pre\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>crdt_ops (pre @ (oid, oper) # xs) deps;\n                 ref \\<in> deps oper\\<rbrakk>\n                \\<Longrightarrow> ref \\<in> fst ` set pre;\n        crdt_ops (pre @ (oid, oper) # xs @ [x]) deps;\n        ref \\<in> deps oper\\<rbrakk>\n       \\<Longrightarrow> ref \\<in> fst ` set pre", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>crdt_ops (pre @ (oid, oper) # xs) deps;\n                 ref \\<in> deps oper\\<rbrakk>\n                \\<Longrightarrow> ref \\<in> fst ` set pre;\n        crdt_ops (pre @ (oid, oper) # xs @ [x]) deps;\n        ref \\<in> deps oper\\<rbrakk>\n       \\<Longrightarrow> ref \\<in> fst ` set pre", "case (snoc x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>crdt_ops (pre @ (oid, oper) # xs) deps;\n   ref \\<in> deps oper\\<rbrakk>\n  \\<Longrightarrow> ref \\<in> fst ` set pre\n  crdt_ops (pre @ (oid, oper) # xs @ [x]) deps\n  ref \\<in> deps oper\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>crdt_ops (pre @ (oid, oper) # xs) deps;\n                 ref \\<in> deps oper\\<rbrakk>\n                \\<Longrightarrow> ref \\<in> fst ` set pre;\n        crdt_ops (pre @ (oid, oper) # xs @ [x]) deps;\n        ref \\<in> deps oper\\<rbrakk>\n       \\<Longrightarrow> ref \\<in> fst ` set pre", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>crdt_ops (pre @ (oid, oper) # xs) deps;\n   ref \\<in> deps oper\\<rbrakk>\n  \\<Longrightarrow> ref \\<in> fst ` set pre\n  crdt_ops (pre @ (oid, oper) # xs @ [x]) deps\n  ref \\<in> deps oper\n\ngoal (1 subgoal):\n 1. ref \\<in> fst ` set pre", "using crdt_ops.cases"], ["proof (prove)\nusing this:\n  \\<lbrakk>crdt_ops (pre @ (oid, oper) # xs) deps;\n   ref \\<in> deps oper\\<rbrakk>\n  \\<Longrightarrow> ref \\<in> fst ` set pre\n  crdt_ops (pre @ (oid, oper) # xs @ [x]) deps\n  ref \\<in> deps oper\n  \\<lbrakk>crdt_ops ?a1.0 ?a2.0;\n   \\<And>deps.\n      \\<lbrakk>?a1.0 = []; ?a2.0 = deps\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>xs deps oid oper.\n      \\<lbrakk>?a1.0 = xs @ [(oid, oper)]; ?a2.0 = deps; crdt_ops xs deps;\n       oid \\<notin> set (map fst xs);\n       \\<forall>ref\\<in>deps oper.\n          ref \\<in> set (map fst xs) \\<and> ref < oid\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. ref \\<in> fst ` set pre", "by force"], ["proof (state)\nthis:\n  ref \\<in> fst ` set pre\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma crdt_ops_no_future_ref:\n  assumes \"crdt_ops (xs @ [(oid, oper)] @ ys) deps\"\n  shows \"\\<And>ref. ref \\<in> deps oper \\<Longrightarrow> ref \\<notin> fst ` set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ref.\n       ref \\<in> deps oper \\<Longrightarrow> ref \\<notin> fst ` set ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ref.\n       ref \\<in> deps oper \\<Longrightarrow> ref \\<notin> fst ` set ys", "from assms(1)"], ["proof (chain)\npicking this:\n  crdt_ops (xs @ [(oid, oper)] @ ys) deps", "have \"\\<And>ref. ref \\<in> deps oper \\<Longrightarrow> ref \\<in> set (map fst xs)\""], ["proof (prove)\nusing this:\n  crdt_ops (xs @ [(oid, oper)] @ ys) deps\n\ngoal (1 subgoal):\n 1. \\<And>ref.\n       ref \\<in> deps oper \\<Longrightarrow> ref \\<in> set (map fst xs)", "by (simp add: crdt_ops_ref_exists)"], ["proof (state)\nthis:\n  ?ref \\<in> deps oper \\<Longrightarrow> ?ref \\<in> set (map fst xs)\n\ngoal (1 subgoal):\n 1. \\<And>ref.\n       ref \\<in> deps oper \\<Longrightarrow> ref \\<notin> fst ` set ys", "moreover"], ["proof (state)\nthis:\n  ?ref \\<in> deps oper \\<Longrightarrow> ?ref \\<in> set (map fst xs)\n\ngoal (1 subgoal):\n 1. \\<And>ref.\n       ref \\<in> deps oper \\<Longrightarrow> ref \\<notin> fst ` set ys", "have \"distinct (map fst (xs @ [(oid, oper)] @ ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (xs @ [(oid, oper)] @ ys))", "using assms crdt_ops_distinct_fst"], ["proof (prove)\nusing this:\n  crdt_ops (xs @ [(oid, oper)] @ ys) deps\n  crdt_ops ?xs ?deps \\<Longrightarrow> distinct (map fst ?xs)\n\ngoal (1 subgoal):\n 1. distinct (map fst (xs @ [(oid, oper)] @ ys))", "by blast"], ["proof (state)\nthis:\n  distinct (map fst (xs @ [(oid, oper)] @ ys))\n\ngoal (1 subgoal):\n 1. \\<And>ref.\n       ref \\<in> deps oper \\<Longrightarrow> ref \\<notin> fst ` set ys", "ultimately"], ["proof (chain)\npicking this:\n  ?ref \\<in> deps oper \\<Longrightarrow> ?ref \\<in> set (map fst xs)\n  distinct (map fst (xs @ [(oid, oper)] @ ys))", "have \"\\<And>ref. ref \\<in> deps oper \\<Longrightarrow> ref \\<notin> set (map fst ([(oid, oper)] @ ys))\""], ["proof (prove)\nusing this:\n  ?ref \\<in> deps oper \\<Longrightarrow> ?ref \\<in> set (map fst xs)\n  distinct (map fst (xs @ [(oid, oper)] @ ys))\n\ngoal (1 subgoal):\n 1. \\<And>ref.\n       ref \\<in> deps oper \\<Longrightarrow>\n       ref \\<notin> set (map fst ([(oid, oper)] @ ys))", "using distinct_fst_append"], ["proof (prove)\nusing this:\n  ?ref \\<in> deps oper \\<Longrightarrow> ?ref \\<in> set (map fst xs)\n  distinct (map fst (xs @ [(oid, oper)] @ ys))\n  \\<lbrakk>?x \\<in> set (map fst ?xs);\n   distinct (map fst (?xs @ ?ys))\\<rbrakk>\n  \\<Longrightarrow> ?x \\<notin> set (map fst ?ys)\n\ngoal (1 subgoal):\n 1. \\<And>ref.\n       ref \\<in> deps oper \\<Longrightarrow>\n       ref \\<notin> set (map fst ([(oid, oper)] @ ys))", "by metis"], ["proof (state)\nthis:\n  ?ref \\<in> deps oper \\<Longrightarrow>\n  ?ref \\<notin> set (map fst ([(oid, oper)] @ ys))\n\ngoal (1 subgoal):\n 1. \\<And>ref.\n       ref \\<in> deps oper \\<Longrightarrow> ref \\<notin> fst ` set ys", "thus \"\\<And>ref. ref \\<in> deps oper \\<Longrightarrow> ref \\<notin> fst ` set ys\""], ["proof (prove)\nusing this:\n  ?ref \\<in> deps oper \\<Longrightarrow>\n  ?ref \\<notin> set (map fst ([(oid, oper)] @ ys))\n\ngoal (1 subgoal):\n 1. \\<And>ref.\n       ref \\<in> deps oper \\<Longrightarrow> ref \\<notin> fst ` set ys", "by simp"], ["proof (state)\nthis:\n  ?ref \\<in> deps oper \\<Longrightarrow> ?ref \\<notin> fst ` set ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma crdt_ops_reorder:\n  assumes \"crdt_ops (xs @ [(oid, oper)] @ ys) deps\"\n    and \"\\<And>op2 r. op2 \\<in> snd ` set ys \\<Longrightarrow> r \\<in> deps op2 \\<Longrightarrow> r \\<noteq> oid\"\n  shows \"crdt_ops (xs @ ys @ [(oid, oper)]) deps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crdt_ops (xs @ ys @ [(oid, oper)]) deps", "using assms"], ["proof (prove)\nusing this:\n  crdt_ops (xs @ [(oid, oper)] @ ys) deps\n  \\<lbrakk>?op2.0 \\<in> snd ` set ys; ?r \\<in> deps ?op2.0\\<rbrakk>\n  \\<Longrightarrow> ?r \\<noteq> oid\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ ys @ [(oid, oper)]) deps", "proof(induction ys rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>crdt_ops (xs @ [(oid, oper)] @ []) deps;\n     \\<And>op2 r.\n        \\<lbrakk>op2 \\<in> snd ` set []; r \\<in> deps op2\\<rbrakk>\n        \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n    \\<Longrightarrow> crdt_ops (xs @ [] @ [(oid, oper)]) deps\n 2. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>crdt_ops (xs @ [(oid, oper)] @ xsa) deps;\n                 \\<And>op2 r.\n                    \\<lbrakk>op2 \\<in> snd ` set xsa;\n                     r \\<in> deps op2\\<rbrakk>\n                    \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n                \\<Longrightarrow> crdt_ops (xs @ xsa @ [(oid, oper)]) deps;\n        crdt_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps;\n        \\<And>op2 r.\n           \\<lbrakk>op2 \\<in> snd ` set (xsa @ [x]);\n            r \\<in> deps op2\\<rbrakk>\n           \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n       \\<Longrightarrow> crdt_ops (xs @ (xsa @ [x]) @ [(oid, oper)]) deps", "case Nil"], ["proof (state)\nthis:\n  crdt_ops (xs @ [(oid, oper)] @ []) deps\n  \\<lbrakk>?op2.0 \\<in> snd ` set []; ?r \\<in> deps ?op2.0\\<rbrakk>\n  \\<Longrightarrow> ?r \\<noteq> oid\n\ngoal (2 subgoals):\n 1. \\<lbrakk>crdt_ops (xs @ [(oid, oper)] @ []) deps;\n     \\<And>op2 r.\n        \\<lbrakk>op2 \\<in> snd ` set []; r \\<in> deps op2\\<rbrakk>\n        \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n    \\<Longrightarrow> crdt_ops (xs @ [] @ [(oid, oper)]) deps\n 2. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>crdt_ops (xs @ [(oid, oper)] @ xsa) deps;\n                 \\<And>op2 r.\n                    \\<lbrakk>op2 \\<in> snd ` set xsa;\n                     r \\<in> deps op2\\<rbrakk>\n                    \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n                \\<Longrightarrow> crdt_ops (xs @ xsa @ [(oid, oper)]) deps;\n        crdt_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps;\n        \\<And>op2 r.\n           \\<lbrakk>op2 \\<in> snd ` set (xsa @ [x]);\n            r \\<in> deps op2\\<rbrakk>\n           \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n       \\<Longrightarrow> crdt_ops (xs @ (xsa @ [x]) @ [(oid, oper)]) deps", "then"], ["proof (chain)\npicking this:\n  crdt_ops (xs @ [(oid, oper)] @ []) deps\n  \\<lbrakk>?op2.0 \\<in> snd ` set []; ?r \\<in> deps ?op2.0\\<rbrakk>\n  \\<Longrightarrow> ?r \\<noteq> oid", "show \"crdt_ops (xs @ [] @ [(oid, oper)]) deps\""], ["proof (prove)\nusing this:\n  crdt_ops (xs @ [(oid, oper)] @ []) deps\n  \\<lbrakk>?op2.0 \\<in> snd ` set []; ?r \\<in> deps ?op2.0\\<rbrakk>\n  \\<Longrightarrow> ?r \\<noteq> oid\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ [] @ [(oid, oper)]) deps", "using crdt_ops_rem_last"], ["proof (prove)\nusing this:\n  crdt_ops (xs @ [(oid, oper)] @ []) deps\n  \\<lbrakk>?op2.0 \\<in> snd ` set []; ?r \\<in> deps ?op2.0\\<rbrakk>\n  \\<Longrightarrow> ?r \\<noteq> oid\n  crdt_ops (?xs @ [?x]) ?deps \\<Longrightarrow> crdt_ops ?xs ?deps\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ [] @ [(oid, oper)]) deps", "by auto"], ["proof (state)\nthis:\n  crdt_ops (xs @ [] @ [(oid, oper)]) deps\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>crdt_ops (xs @ [(oid, oper)] @ xsa) deps;\n                 \\<And>op2 r.\n                    \\<lbrakk>op2 \\<in> snd ` set xsa;\n                     r \\<in> deps op2\\<rbrakk>\n                    \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n                \\<Longrightarrow> crdt_ops (xs @ xsa @ [(oid, oper)]) deps;\n        crdt_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps;\n        \\<And>op2 r.\n           \\<lbrakk>op2 \\<in> snd ` set (xsa @ [x]);\n            r \\<in> deps op2\\<rbrakk>\n           \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n       \\<Longrightarrow> crdt_ops (xs @ (xsa @ [x]) @ [(oid, oper)]) deps", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>crdt_ops (xs @ [(oid, oper)] @ xsa) deps;\n                 \\<And>op2 r.\n                    \\<lbrakk>op2 \\<in> snd ` set xsa;\n                     r \\<in> deps op2\\<rbrakk>\n                    \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n                \\<Longrightarrow> crdt_ops (xs @ xsa @ [(oid, oper)]) deps;\n        crdt_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps;\n        \\<And>op2 r.\n           \\<lbrakk>op2 \\<in> snd ` set (xsa @ [x]);\n            r \\<in> deps op2\\<rbrakk>\n           \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n       \\<Longrightarrow> crdt_ops (xs @ (xsa @ [x]) @ [(oid, oper)]) deps", "case (snoc y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>crdt_ops (xs @ [(oid, oper)] @ ys) deps;\n   \\<And>op2 r.\n      \\<lbrakk>op2 \\<in> snd ` set ys; r \\<in> deps op2\\<rbrakk>\n      \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n  \\<Longrightarrow> crdt_ops (xs @ ys @ [(oid, oper)]) deps\n  crdt_ops (xs @ [(oid, oper)] @ ys @ [y]) deps\n  \\<lbrakk>?op2.0 \\<in> snd ` set (ys @ [y]); ?r \\<in> deps ?op2.0\\<rbrakk>\n  \\<Longrightarrow> ?r \\<noteq> oid\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>crdt_ops (xs @ [(oid, oper)] @ xsa) deps;\n                 \\<And>op2 r.\n                    \\<lbrakk>op2 \\<in> snd ` set xsa;\n                     r \\<in> deps op2\\<rbrakk>\n                    \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n                \\<Longrightarrow> crdt_ops (xs @ xsa @ [(oid, oper)]) deps;\n        crdt_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps;\n        \\<And>op2 r.\n           \\<lbrakk>op2 \\<in> snd ` set (xsa @ [x]);\n            r \\<in> deps op2\\<rbrakk>\n           \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n       \\<Longrightarrow> crdt_ops (xs @ (xsa @ [x]) @ [(oid, oper)]) deps", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>crdt_ops (xs @ [(oid, oper)] @ ys) deps;\n   \\<And>op2 r.\n      \\<lbrakk>op2 \\<in> snd ` set ys; r \\<in> deps op2\\<rbrakk>\n      \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n  \\<Longrightarrow> crdt_ops (xs @ ys @ [(oid, oper)]) deps\n  crdt_ops (xs @ [(oid, oper)] @ ys @ [y]) deps\n  \\<lbrakk>?op2.0 \\<in> snd ` set (ys @ [y]); ?r \\<in> deps ?op2.0\\<rbrakk>\n  \\<Longrightarrow> ?r \\<noteq> oid", "obtain yi yo where y_pair: \"y = (yi, yo)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>crdt_ops (xs @ [(oid, oper)] @ ys) deps;\n   \\<And>op2 r.\n      \\<lbrakk>op2 \\<in> snd ` set ys; r \\<in> deps op2\\<rbrakk>\n      \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n  \\<Longrightarrow> crdt_ops (xs @ ys @ [(oid, oper)]) deps\n  crdt_ops (xs @ [(oid, oper)] @ ys @ [y]) deps\n  \\<lbrakk>?op2.0 \\<in> snd ` set (ys @ [y]); ?r \\<in> deps ?op2.0\\<rbrakk>\n  \\<Longrightarrow> ?r \\<noteq> oid\n\ngoal (1 subgoal):\n 1. (\\<And>yi yo. y = (yi, yo) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  y = (yi, yo)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>crdt_ops (xs @ [(oid, oper)] @ xsa) deps;\n                 \\<And>op2 r.\n                    \\<lbrakk>op2 \\<in> snd ` set xsa;\n                     r \\<in> deps op2\\<rbrakk>\n                    \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n                \\<Longrightarrow> crdt_ops (xs @ xsa @ [(oid, oper)]) deps;\n        crdt_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps;\n        \\<And>op2 r.\n           \\<lbrakk>op2 \\<in> snd ` set (xsa @ [x]);\n            r \\<in> deps op2\\<rbrakk>\n           \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n       \\<Longrightarrow> crdt_ops (xs @ (xsa @ [x]) @ [(oid, oper)]) deps", "have IH: \"crdt_ops (xs @ ys @ [(oid, oper)]) deps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crdt_ops (xs @ ys @ [(oid, oper)]) deps", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. crdt_ops (xs @ ys @ [(oid, oper)]) deps", "have \"crdt_ops (xs @ [(oid, oper)] @ ys) deps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crdt_ops (xs @ [(oid, oper)] @ ys) deps", "by (metis snoc(2) append.assoc crdt_ops_rem_last)"], ["proof (state)\nthis:\n  crdt_ops (xs @ [(oid, oper)] @ ys) deps\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ ys @ [(oid, oper)]) deps", "thus \"crdt_ops (xs @ ys @ [(oid, oper)]) deps\""], ["proof (prove)\nusing this:\n  crdt_ops (xs @ [(oid, oper)] @ ys) deps\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ ys @ [(oid, oper)]) deps", "using snoc.IH snoc.prems(2)"], ["proof (prove)\nusing this:\n  crdt_ops (xs @ [(oid, oper)] @ ys) deps\n  \\<lbrakk>crdt_ops (xs @ [(oid, oper)] @ ys) deps;\n   \\<And>op2 r.\n      \\<lbrakk>op2 \\<in> snd ` set ys; r \\<in> deps op2\\<rbrakk>\n      \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n  \\<Longrightarrow> crdt_ops (xs @ ys @ [(oid, oper)]) deps\n  \\<lbrakk>?op2.0 \\<in> snd ` set (ys @ [y]); ?r \\<in> deps ?op2.0\\<rbrakk>\n  \\<Longrightarrow> ?r \\<noteq> oid\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ ys @ [(oid, oper)]) deps", "by auto"], ["proof (state)\nthis:\n  crdt_ops (xs @ ys @ [(oid, oper)]) deps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  crdt_ops (xs @ ys @ [(oid, oper)]) deps\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>crdt_ops (xs @ [(oid, oper)] @ xsa) deps;\n                 \\<And>op2 r.\n                    \\<lbrakk>op2 \\<in> snd ` set xsa;\n                     r \\<in> deps op2\\<rbrakk>\n                    \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n                \\<Longrightarrow> crdt_ops (xs @ xsa @ [(oid, oper)]) deps;\n        crdt_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps;\n        \\<And>op2 r.\n           \\<lbrakk>op2 \\<in> snd ` set (xsa @ [x]);\n            r \\<in> deps op2\\<rbrakk>\n           \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n       \\<Longrightarrow> crdt_ops (xs @ (xsa @ [x]) @ [(oid, oper)]) deps", "have \"crdt_ops (xs @ ys @ [y]) deps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crdt_ops (xs @ ys @ [y]) deps", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. crdt_ops (xs @ ys @ [y]) deps", "have \"yi \\<notin> fst ` set (xs @ [(oid, oper)] @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. yi \\<notin> fst ` set (xs @ [(oid, oper)] @ ys)", "by (metis y_pair append_assoc crdt_ops_unique_last set_map snoc.prems(1))"], ["proof (state)\nthis:\n  yi \\<notin> fst ` set (xs @ [(oid, oper)] @ ys)\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ ys @ [y]) deps", "hence \"yi \\<notin> fst ` set (xs @ ys)\""], ["proof (prove)\nusing this:\n  yi \\<notin> fst ` set (xs @ [(oid, oper)] @ ys)\n\ngoal (1 subgoal):\n 1. yi \\<notin> fst ` set (xs @ ys)", "by auto"], ["proof (state)\nthis:\n  yi \\<notin> fst ` set (xs @ ys)\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ ys @ [y]) deps", "moreover"], ["proof (state)\nthis:\n  yi \\<notin> fst ` set (xs @ ys)\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ ys @ [y]) deps", "have \"\\<And>r. r \\<in> deps yo \\<Longrightarrow> r \\<in> fst ` set (xs @ ys) \\<and> r < yi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> deps yo \\<Longrightarrow>\n       r \\<in> fst ` set (xs @ ys) \\<and> r < yi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> deps yo \\<Longrightarrow>\n       r \\<in> fst ` set (xs @ ys) \\<and> r < yi", "have \"\\<And>r. r \\<in> deps yo \\<Longrightarrow> r \\<noteq> oid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r. r \\<in> deps yo \\<Longrightarrow> r \\<noteq> oid", "using snoc.prems(2) y_pair"], ["proof (prove)\nusing this:\n  \\<lbrakk>?op2.0 \\<in> snd ` set (ys @ [y]); ?r \\<in> deps ?op2.0\\<rbrakk>\n  \\<Longrightarrow> ?r \\<noteq> oid\n  y = (yi, yo)\n\ngoal (1 subgoal):\n 1. \\<And>r. r \\<in> deps yo \\<Longrightarrow> r \\<noteq> oid", "by fastforce"], ["proof (state)\nthis:\n  ?r \\<in> deps yo \\<Longrightarrow> ?r \\<noteq> oid\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> deps yo \\<Longrightarrow>\n       r \\<in> fst ` set (xs @ ys) \\<and> r < yi", "moreover"], ["proof (state)\nthis:\n  ?r \\<in> deps yo \\<Longrightarrow> ?r \\<noteq> oid\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> deps yo \\<Longrightarrow>\n       r \\<in> fst ` set (xs @ ys) \\<and> r < yi", "have \"\\<And>r. r \\<in> deps yo \\<Longrightarrow> r \\<in> fst ` set (xs @ [(oid, oper)] @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> deps yo \\<Longrightarrow>\n       r \\<in> fst ` set (xs @ [(oid, oper)] @ ys)", "by (metis y_pair append_assoc snoc.prems(1) crdt_ops_ref_exists)"], ["proof (state)\nthis:\n  ?r \\<in> deps yo \\<Longrightarrow>\n  ?r \\<in> fst ` set (xs @ [(oid, oper)] @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> deps yo \\<Longrightarrow>\n       r \\<in> fst ` set (xs @ ys) \\<and> r < yi", "moreover"], ["proof (state)\nthis:\n  ?r \\<in> deps yo \\<Longrightarrow>\n  ?r \\<in> fst ` set (xs @ [(oid, oper)] @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> deps yo \\<Longrightarrow>\n       r \\<in> fst ` set (xs @ ys) \\<and> r < yi", "have \"\\<And>r. r \\<in> deps yo \\<Longrightarrow> r < yi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r. r \\<in> deps yo \\<Longrightarrow> r < yi", "using crdt_ops_ref_less snoc.prems(1) y_pair"], ["proof (prove)\nusing this:\n  \\<lbrakk>crdt_ops ?xs ?deps; (?oid, ?oper) \\<in> set ?xs;\n   ?r \\<in> ?deps ?oper\\<rbrakk>\n  \\<Longrightarrow> ?r < ?oid\n  crdt_ops (xs @ [(oid, oper)] @ ys @ [y]) deps\n  y = (yi, yo)\n\ngoal (1 subgoal):\n 1. \\<And>r. r \\<in> deps yo \\<Longrightarrow> r < yi", "by fastforce"], ["proof (state)\nthis:\n  ?r \\<in> deps yo \\<Longrightarrow> ?r < yi\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> deps yo \\<Longrightarrow>\n       r \\<in> fst ` set (xs @ ys) \\<and> r < yi", "ultimately"], ["proof (chain)\npicking this:\n  ?r \\<in> deps yo \\<Longrightarrow> ?r \\<noteq> oid\n  ?r \\<in> deps yo \\<Longrightarrow>\n  ?r \\<in> fst ` set (xs @ [(oid, oper)] @ ys)\n  ?r \\<in> deps yo \\<Longrightarrow> ?r < yi", "show \"\\<And>r. r \\<in> deps yo \\<Longrightarrow> r \\<in> fst ` set (xs @ ys) \\<and> r < yi\""], ["proof (prove)\nusing this:\n  ?r \\<in> deps yo \\<Longrightarrow> ?r \\<noteq> oid\n  ?r \\<in> deps yo \\<Longrightarrow>\n  ?r \\<in> fst ` set (xs @ [(oid, oper)] @ ys)\n  ?r \\<in> deps yo \\<Longrightarrow> ?r < yi\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> deps yo \\<Longrightarrow>\n       r \\<in> fst ` set (xs @ ys) \\<and> r < yi", "by simp"], ["proof (state)\nthis:\n  ?r \\<in> deps yo \\<Longrightarrow>\n  ?r \\<in> fst ` set (xs @ ys) \\<and> ?r < yi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?r \\<in> deps yo \\<Longrightarrow>\n  ?r \\<in> fst ` set (xs @ ys) \\<and> ?r < yi\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ ys @ [y]) deps", "moreover"], ["proof (state)\nthis:\n  ?r \\<in> deps yo \\<Longrightarrow>\n  ?r \\<in> fst ` set (xs @ ys) \\<and> ?r < yi\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ ys @ [y]) deps", "from IH"], ["proof (chain)\npicking this:\n  crdt_ops (xs @ ys @ [(oid, oper)]) deps", "have \"crdt_ops (xs @ ys) deps\""], ["proof (prove)\nusing this:\n  crdt_ops (xs @ ys @ [(oid, oper)]) deps\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ ys) deps", "using crdt_ops_rem_last"], ["proof (prove)\nusing this:\n  crdt_ops (xs @ ys @ [(oid, oper)]) deps\n  crdt_ops (?xs @ [?x]) ?deps \\<Longrightarrow> crdt_ops ?xs ?deps\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ ys) deps", "by force"], ["proof (state)\nthis:\n  crdt_ops (xs @ ys) deps\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ ys @ [y]) deps", "ultimately"], ["proof (chain)\npicking this:\n  yi \\<notin> fst ` set (xs @ ys)\n  ?r \\<in> deps yo \\<Longrightarrow>\n  ?r \\<in> fst ` set (xs @ ys) \\<and> ?r < yi\n  crdt_ops (xs @ ys) deps", "show \"crdt_ops (xs @ ys @ [y]) deps\""], ["proof (prove)\nusing this:\n  yi \\<notin> fst ` set (xs @ ys)\n  ?r \\<in> deps yo \\<Longrightarrow>\n  ?r \\<in> fst ` set (xs @ ys) \\<and> ?r < yi\n  crdt_ops (xs @ ys) deps\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ ys @ [y]) deps", "using y_pair crdt_ops_intro"], ["proof (prove)\nusing this:\n  yi \\<notin> fst ` set (xs @ ys)\n  ?r \\<in> deps yo \\<Longrightarrow>\n  ?r \\<in> fst ` set (xs @ ys) \\<and> ?r < yi\n  crdt_ops (xs @ ys) deps\n  y = (yi, yo)\n  \\<lbrakk>\\<And>r.\n              r \\<in> ?deps ?oper \\<Longrightarrow>\n              r \\<in> fst ` set ?xs \\<and> r < ?oid;\n   ?oid \\<notin> fst ` set ?xs; crdt_ops ?xs ?deps\\<rbrakk>\n  \\<Longrightarrow> crdt_ops (?xs @ [(?oid, ?oper)]) ?deps\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ ys @ [y]) deps", "by (metis append.assoc)"], ["proof (state)\nthis:\n  crdt_ops (xs @ ys @ [y]) deps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  crdt_ops (xs @ ys @ [y]) deps\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>crdt_ops (xs @ [(oid, oper)] @ xsa) deps;\n                 \\<And>op2 r.\n                    \\<lbrakk>op2 \\<in> snd ` set xsa;\n                     r \\<in> deps op2\\<rbrakk>\n                    \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n                \\<Longrightarrow> crdt_ops (xs @ xsa @ [(oid, oper)]) deps;\n        crdt_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps;\n        \\<And>op2 r.\n           \\<lbrakk>op2 \\<in> snd ` set (xsa @ [x]);\n            r \\<in> deps op2\\<rbrakk>\n           \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n       \\<Longrightarrow> crdt_ops (xs @ (xsa @ [x]) @ [(oid, oper)]) deps", "moreover"], ["proof (state)\nthis:\n  crdt_ops (xs @ ys @ [y]) deps\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>crdt_ops (xs @ [(oid, oper)] @ xsa) deps;\n                 \\<And>op2 r.\n                    \\<lbrakk>op2 \\<in> snd ` set xsa;\n                     r \\<in> deps op2\\<rbrakk>\n                    \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n                \\<Longrightarrow> crdt_ops (xs @ xsa @ [(oid, oper)]) deps;\n        crdt_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps;\n        \\<And>op2 r.\n           \\<lbrakk>op2 \\<in> snd ` set (xsa @ [x]);\n            r \\<in> deps op2\\<rbrakk>\n           \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n       \\<Longrightarrow> crdt_ops (xs @ (xsa @ [x]) @ [(oid, oper)]) deps", "have \"oid \\<notin> fst ` set (xs @ ys @ [y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oid \\<notin> fst ` set (xs @ ys @ [y])", "using crdt_ops_unique_mid"], ["proof (prove)\nusing this:\n  crdt_ops (?xs @ [(?oid, ?oper)] @ ?ys) ?deps \\<Longrightarrow>\n  ?oid \\<notin> set (map fst ?xs) \\<and> ?oid \\<notin> set (map fst ?ys)\n\ngoal (1 subgoal):\n 1. oid \\<notin> fst ` set (xs @ ys @ [y])", "by (metis (no_types, lifting) UnE image_Un\n        image_set set_append snoc.prems(1))"], ["proof (state)\nthis:\n  oid \\<notin> fst ` set (xs @ ys @ [y])\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>crdt_ops (xs @ [(oid, oper)] @ xsa) deps;\n                 \\<And>op2 r.\n                    \\<lbrakk>op2 \\<in> snd ` set xsa;\n                     r \\<in> deps op2\\<rbrakk>\n                    \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n                \\<Longrightarrow> crdt_ops (xs @ xsa @ [(oid, oper)]) deps;\n        crdt_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps;\n        \\<And>op2 r.\n           \\<lbrakk>op2 \\<in> snd ` set (xsa @ [x]);\n            r \\<in> deps op2\\<rbrakk>\n           \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n       \\<Longrightarrow> crdt_ops (xs @ (xsa @ [x]) @ [(oid, oper)]) deps", "moreover"], ["proof (state)\nthis:\n  oid \\<notin> fst ` set (xs @ ys @ [y])\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>crdt_ops (xs @ [(oid, oper)] @ xsa) deps;\n                 \\<And>op2 r.\n                    \\<lbrakk>op2 \\<in> snd ` set xsa;\n                     r \\<in> deps op2\\<rbrakk>\n                    \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n                \\<Longrightarrow> crdt_ops (xs @ xsa @ [(oid, oper)]) deps;\n        crdt_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps;\n        \\<And>op2 r.\n           \\<lbrakk>op2 \\<in> snd ` set (xsa @ [x]);\n            r \\<in> deps op2\\<rbrakk>\n           \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n       \\<Longrightarrow> crdt_ops (xs @ (xsa @ [x]) @ [(oid, oper)]) deps", "have \"\\<And>r. r \\<in> deps oper \\<Longrightarrow> r \\<in> fst ` set (xs @ ys @ [y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> deps oper \\<Longrightarrow> r \\<in> fst ` set (xs @ ys @ [y])", "using crdt_ops_ref_exists"], ["proof (prove)\nusing this:\n  \\<lbrakk>crdt_ops (?pre @ (?oid, ?oper) # ?suf) ?deps;\n   ?ref \\<in> ?deps ?oper\\<rbrakk>\n  \\<Longrightarrow> ?ref \\<in> fst ` set ?pre\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> deps oper \\<Longrightarrow> r \\<in> fst ` set (xs @ ys @ [y])", "by (metis UnCI append_Cons image_Un set_append snoc.prems(1))"], ["proof (state)\nthis:\n  ?r \\<in> deps oper \\<Longrightarrow> ?r \\<in> fst ` set (xs @ ys @ [y])\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>crdt_ops (xs @ [(oid, oper)] @ xsa) deps;\n                 \\<And>op2 r.\n                    \\<lbrakk>op2 \\<in> snd ` set xsa;\n                     r \\<in> deps op2\\<rbrakk>\n                    \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n                \\<Longrightarrow> crdt_ops (xs @ xsa @ [(oid, oper)]) deps;\n        crdt_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps;\n        \\<And>op2 r.\n           \\<lbrakk>op2 \\<in> snd ` set (xsa @ [x]);\n            r \\<in> deps op2\\<rbrakk>\n           \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n       \\<Longrightarrow> crdt_ops (xs @ (xsa @ [x]) @ [(oid, oper)]) deps", "moreover"], ["proof (state)\nthis:\n  ?r \\<in> deps oper \\<Longrightarrow> ?r \\<in> fst ` set (xs @ ys @ [y])\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>crdt_ops (xs @ [(oid, oper)] @ xsa) deps;\n                 \\<And>op2 r.\n                    \\<lbrakk>op2 \\<in> snd ` set xsa;\n                     r \\<in> deps op2\\<rbrakk>\n                    \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n                \\<Longrightarrow> crdt_ops (xs @ xsa @ [(oid, oper)]) deps;\n        crdt_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps;\n        \\<And>op2 r.\n           \\<lbrakk>op2 \\<in> snd ` set (xsa @ [x]);\n            r \\<in> deps op2\\<rbrakk>\n           \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n       \\<Longrightarrow> crdt_ops (xs @ (xsa @ [x]) @ [(oid, oper)]) deps", "have \"\\<And>r. r \\<in> deps oper \\<Longrightarrow> r < oid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r. r \\<in> deps oper \\<Longrightarrow> r < oid", "using IH crdt_ops_ref_less"], ["proof (prove)\nusing this:\n  crdt_ops (xs @ ys @ [(oid, oper)]) deps\n  \\<lbrakk>crdt_ops ?xs ?deps; (?oid, ?oper) \\<in> set ?xs;\n   ?r \\<in> ?deps ?oper\\<rbrakk>\n  \\<Longrightarrow> ?r < ?oid\n\ngoal (1 subgoal):\n 1. \\<And>r. r \\<in> deps oper \\<Longrightarrow> r < oid", "by fastforce"], ["proof (state)\nthis:\n  ?r \\<in> deps oper \\<Longrightarrow> ?r < oid\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>\\<lbrakk>crdt_ops (xs @ [(oid, oper)] @ xsa) deps;\n                 \\<And>op2 r.\n                    \\<lbrakk>op2 \\<in> snd ` set xsa;\n                     r \\<in> deps op2\\<rbrakk>\n                    \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n                \\<Longrightarrow> crdt_ops (xs @ xsa @ [(oid, oper)]) deps;\n        crdt_ops (xs @ [(oid, oper)] @ xsa @ [x]) deps;\n        \\<And>op2 r.\n           \\<lbrakk>op2 \\<in> snd ` set (xsa @ [x]);\n            r \\<in> deps op2\\<rbrakk>\n           \\<Longrightarrow> r \\<noteq> oid\\<rbrakk>\n       \\<Longrightarrow> crdt_ops (xs @ (xsa @ [x]) @ [(oid, oper)]) deps", "ultimately"], ["proof (chain)\npicking this:\n  crdt_ops (xs @ ys @ [y]) deps\n  oid \\<notin> fst ` set (xs @ ys @ [y])\n  ?r \\<in> deps oper \\<Longrightarrow> ?r \\<in> fst ` set (xs @ ys @ [y])\n  ?r \\<in> deps oper \\<Longrightarrow> ?r < oid", "show \"crdt_ops (xs @ (ys @ [y]) @ [(oid, oper)]) deps\""], ["proof (prove)\nusing this:\n  crdt_ops (xs @ ys @ [y]) deps\n  oid \\<notin> fst ` set (xs @ ys @ [y])\n  ?r \\<in> deps oper \\<Longrightarrow> ?r \\<in> fst ` set (xs @ ys @ [y])\n  ?r \\<in> deps oper \\<Longrightarrow> ?r < oid\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ (ys @ [y]) @ [(oid, oper)]) deps", "using crdt_ops_intro"], ["proof (prove)\nusing this:\n  crdt_ops (xs @ ys @ [y]) deps\n  oid \\<notin> fst ` set (xs @ ys @ [y])\n  ?r \\<in> deps oper \\<Longrightarrow> ?r \\<in> fst ` set (xs @ ys @ [y])\n  ?r \\<in> deps oper \\<Longrightarrow> ?r < oid\n  \\<lbrakk>\\<And>r.\n              r \\<in> ?deps ?oper \\<Longrightarrow>\n              r \\<in> fst ` set ?xs \\<and> r < ?oid;\n   ?oid \\<notin> fst ` set ?xs; crdt_ops ?xs ?deps\\<rbrakk>\n  \\<Longrightarrow> crdt_ops (?xs @ [(?oid, ?oper)]) ?deps\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ (ys @ [y]) @ [(oid, oper)]) deps", "by (metis append_assoc)"], ["proof (state)\nthis:\n  crdt_ops (xs @ (ys @ [y]) @ [(oid, oper)]) deps\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma crdt_ops_rem_middle:\n  assumes \"crdt_ops (xs @ [(oid, ref)] @ ys) deps\"\n    and \"\\<And>op2 r. op2 \\<in> snd ` set ys \\<Longrightarrow> r \\<in> deps op2 \\<Longrightarrow> r \\<noteq> oid\"\n  shows \"crdt_ops (xs @ ys) deps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crdt_ops (xs @ ys) deps", "using assms crdt_ops_rem_last crdt_ops_reorder append_assoc"], ["proof (prove)\nusing this:\n  crdt_ops (xs @ [(oid, ref)] @ ys) deps\n  \\<lbrakk>?op2.0 \\<in> snd ` set ys; ?r \\<in> deps ?op2.0\\<rbrakk>\n  \\<Longrightarrow> ?r \\<noteq> oid\n  crdt_ops (?xs @ [?x]) ?deps \\<Longrightarrow> crdt_ops ?xs ?deps\n  \\<lbrakk>crdt_ops (?xs @ [(?oid, ?oper)] @ ?ys) ?deps;\n   \\<And>op2 r.\n      \\<lbrakk>op2 \\<in> snd ` set ?ys; r \\<in> ?deps op2\\<rbrakk>\n      \\<Longrightarrow> r \\<noteq> ?oid\\<rbrakk>\n  \\<Longrightarrow> crdt_ops (?xs @ ?ys @ [(?oid, ?oper)]) ?deps\n  (?xs @ ?ys) @ ?zs = ?xs @ ?ys @ ?zs\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ ys) deps", "by metis"], ["", "lemma crdt_ops_independent_suf:\n  assumes \"spec_ops (xs @ [(oid, oper)]) deps\"\n    and \"crdt_ops (ys @ [(oid, oper)] @ zs) deps\"\n    and \"set (xs @ [(oid, oper)]) = set (ys @ [(oid, oper)] @ zs)\"\n  shows \"\\<And>op2 r. op2 \\<in> snd ` set zs \\<Longrightarrow> r \\<in> deps op2 \\<Longrightarrow> r \\<noteq> oid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>op2 r.\n       \\<lbrakk>op2 \\<in> snd ` set zs; r \\<in> deps op2\\<rbrakk>\n       \\<Longrightarrow> r \\<noteq> oid", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>op2 r.\n       \\<lbrakk>op2 \\<in> snd ` set zs; r \\<in> deps op2\\<rbrakk>\n       \\<Longrightarrow> r \\<noteq> oid", "have \"\\<And>op2 r. op2 \\<in> snd ` set xs \\<Longrightarrow> r \\<in> deps op2 \\<Longrightarrow> r < oid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>op2 r.\n       \\<lbrakk>op2 \\<in> snd ` set xs; r \\<in> deps op2\\<rbrakk>\n       \\<Longrightarrow> r < oid", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>op2 r.\n       \\<lbrakk>op2 \\<in> snd ` set xs; r \\<in> deps op2\\<rbrakk>\n       \\<Longrightarrow> r < oid", "from assms(1)"], ["proof (chain)\npicking this:\n  spec_ops (xs @ [(oid, oper)]) deps", "have \"\\<And>i. i \\<in> fst ` set xs \\<Longrightarrow> i < oid\""], ["proof (prove)\nusing this:\n  spec_ops (xs @ [(oid, oper)]) deps\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> fst ` set xs \\<Longrightarrow> i < oid", "using spec_ops_id_inc"], ["proof (prove)\nusing this:\n  spec_ops (xs @ [(oid, oper)]) deps\n  \\<lbrakk>spec_ops (?xs @ [(?oid, ?oper)]) ?deps;\n   ?x \\<in> set (map fst ?xs)\\<rbrakk>\n  \\<Longrightarrow> ?x < ?oid\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> fst ` set xs \\<Longrightarrow> i < oid", "by fastforce"], ["proof (state)\nthis:\n  ?i \\<in> fst ` set xs \\<Longrightarrow> ?i < oid\n\ngoal (1 subgoal):\n 1. \\<And>op2 r.\n       \\<lbrakk>op2 \\<in> snd ` set xs; r \\<in> deps op2\\<rbrakk>\n       \\<Longrightarrow> r < oid", "moreover"], ["proof (state)\nthis:\n  ?i \\<in> fst ` set xs \\<Longrightarrow> ?i < oid\n\ngoal (1 subgoal):\n 1. \\<And>op2 r.\n       \\<lbrakk>op2 \\<in> snd ` set xs; r \\<in> deps op2\\<rbrakk>\n       \\<Longrightarrow> r < oid", "have \"\\<And>i2 op2 r. (i2, op2) \\<in> set xs \\<Longrightarrow> r \\<in> deps op2 \\<Longrightarrow> r < i2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i2 op2 r.\n       \\<lbrakk>(i2, op2) \\<in> set xs; r \\<in> deps op2\\<rbrakk>\n       \\<Longrightarrow> r < i2", "using assms(1) spec_ops_ref_less spec_ops_rem_last"], ["proof (prove)\nusing this:\n  spec_ops (xs @ [(oid, oper)]) deps\n  \\<lbrakk>spec_ops ?xs ?deps; (?oid, ?oper) \\<in> set ?xs;\n   ?r \\<in> ?deps ?oper\\<rbrakk>\n  \\<Longrightarrow> ?r < ?oid\n  spec_ops (?xs @ [?x]) ?deps \\<Longrightarrow> spec_ops ?xs ?deps\n\ngoal (1 subgoal):\n 1. \\<And>i2 op2 r.\n       \\<lbrakk>(i2, op2) \\<in> set xs; r \\<in> deps op2\\<rbrakk>\n       \\<Longrightarrow> r < i2", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>(?i2.0, ?op2.0) \\<in> set xs; ?r \\<in> deps ?op2.0\\<rbrakk>\n  \\<Longrightarrow> ?r < ?i2.0\n\ngoal (1 subgoal):\n 1. \\<And>op2 r.\n       \\<lbrakk>op2 \\<in> snd ` set xs; r \\<in> deps op2\\<rbrakk>\n       \\<Longrightarrow> r < oid", "ultimately"], ["proof (chain)\npicking this:\n  ?i \\<in> fst ` set xs \\<Longrightarrow> ?i < oid\n  \\<lbrakk>(?i2.0, ?op2.0) \\<in> set xs; ?r \\<in> deps ?op2.0\\<rbrakk>\n  \\<Longrightarrow> ?r < ?i2.0", "show \"\\<And>op2 r. op2 \\<in> snd ` set xs \\<Longrightarrow> r \\<in> deps op2 \\<Longrightarrow> r < oid\""], ["proof (prove)\nusing this:\n  ?i \\<in> fst ` set xs \\<Longrightarrow> ?i < oid\n  \\<lbrakk>(?i2.0, ?op2.0) \\<in> set xs; ?r \\<in> deps ?op2.0\\<rbrakk>\n  \\<Longrightarrow> ?r < ?i2.0\n\ngoal (1 subgoal):\n 1. \\<And>op2 r.\n       \\<lbrakk>op2 \\<in> snd ` set xs; r \\<in> deps op2\\<rbrakk>\n       \\<Longrightarrow> r < oid", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>?op2.0 \\<in> snd ` set xs; ?r \\<in> deps ?op2.0\\<rbrakk>\n  \\<Longrightarrow> ?r < oid\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?op2.0 \\<in> snd ` set xs; ?r \\<in> deps ?op2.0\\<rbrakk>\n  \\<Longrightarrow> ?r < oid\n\ngoal (1 subgoal):\n 1. \\<And>op2 r.\n       \\<lbrakk>op2 \\<in> snd ` set zs; r \\<in> deps op2\\<rbrakk>\n       \\<Longrightarrow> r \\<noteq> oid", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?op2.0 \\<in> snd ` set xs; ?r \\<in> deps ?op2.0\\<rbrakk>\n  \\<Longrightarrow> ?r < oid\n\ngoal (1 subgoal):\n 1. \\<And>op2 r.\n       \\<lbrakk>op2 \\<in> snd ` set zs; r \\<in> deps op2\\<rbrakk>\n       \\<Longrightarrow> r \\<noteq> oid", "have \"set zs \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set zs \\<subseteq> set xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set zs \\<subseteq> set xs", "have \"distinct (xs @ [(oid, oper)])\" and \"distinct (ys @ [(oid, oper)] @ zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (xs @ [(oid, oper)]) &&& distinct (ys @ [(oid, oper)] @ zs)", "using assms spec_ops_distinct crdt_ops_distinct"], ["proof (prove)\nusing this:\n  spec_ops (xs @ [(oid, oper)]) deps\n  crdt_ops (ys @ [(oid, oper)] @ zs) deps\n  set (xs @ [(oid, oper)]) = set (ys @ [(oid, oper)] @ zs)\n  spec_ops ?ops ?deps \\<Longrightarrow> distinct ?ops\n  crdt_ops ?xs ?deps \\<Longrightarrow> distinct ?xs\n\ngoal (1 subgoal):\n 1. distinct (xs @ [(oid, oper)]) &&& distinct (ys @ [(oid, oper)] @ zs)", "by blast+"], ["proof (state)\nthis:\n  distinct (xs @ [(oid, oper)])\n  distinct (ys @ [(oid, oper)] @ zs)\n\ngoal (1 subgoal):\n 1. set zs \\<subseteq> set xs", "hence \"set xs = set (ys @ zs)\""], ["proof (prove)\nusing this:\n  distinct (xs @ [(oid, oper)])\n  distinct (ys @ [(oid, oper)] @ zs)\n\ngoal (1 subgoal):\n 1. set xs = set (ys @ zs)", "by (meson append_set_rem_last assms(3))"], ["proof (state)\nthis:\n  set xs = set (ys @ zs)\n\ngoal (1 subgoal):\n 1. set zs \\<subseteq> set xs", "then"], ["proof (chain)\npicking this:\n  set xs = set (ys @ zs)", "show \"set zs \\<subseteq> set xs\""], ["proof (prove)\nusing this:\n  set xs = set (ys @ zs)\n\ngoal (1 subgoal):\n 1. set zs \\<subseteq> set xs", "using append_subset(2)"], ["proof (prove)\nusing this:\n  set xs = set (ys @ zs)\n  set ?xs = set (?ys @ ?zs) \\<Longrightarrow> set ?zs \\<subseteq> set ?xs\n\ngoal (1 subgoal):\n 1. set zs \\<subseteq> set xs", "by simp"], ["proof (state)\nthis:\n  set zs \\<subseteq> set xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set zs \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. \\<And>op2 r.\n       \\<lbrakk>op2 \\<in> snd ` set zs; r \\<in> deps op2\\<rbrakk>\n       \\<Longrightarrow> r \\<noteq> oid", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?op2.0 \\<in> snd ` set xs; ?r \\<in> deps ?op2.0\\<rbrakk>\n  \\<Longrightarrow> ?r < oid\n  set zs \\<subseteq> set xs", "show \"\\<And>op2 r. op2 \\<in> snd ` set zs \\<Longrightarrow> r \\<in> deps op2 \\<Longrightarrow> r \\<noteq> oid\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?op2.0 \\<in> snd ` set xs; ?r \\<in> deps ?op2.0\\<rbrakk>\n  \\<Longrightarrow> ?r < oid\n  set zs \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. \\<And>op2 r.\n       \\<lbrakk>op2 \\<in> snd ` set zs; r \\<in> deps op2\\<rbrakk>\n       \\<Longrightarrow> r \\<noteq> oid", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>?op2.0 \\<in> snd ` set zs; ?r \\<in> deps ?op2.0\\<rbrakk>\n  \\<Longrightarrow> ?r \\<noteq> oid\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma crdt_ops_reorder_spec:\n  assumes \"spec_ops (xs @ [x]) deps\"\n    and \"crdt_ops (ys @ [x] @ zs) deps\"\n    and \"set (xs @ [x]) = set (ys @ [x] @ zs)\"\n  shows \"crdt_ops (ys @ zs @ [x]) deps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crdt_ops (ys @ zs @ [x]) deps", "using assms"], ["proof (prove)\nusing this:\n  spec_ops (xs @ [x]) deps\n  crdt_ops (ys @ [x] @ zs) deps\n  set (xs @ [x]) = set (ys @ [x] @ zs)\n\ngoal (1 subgoal):\n 1. crdt_ops (ys @ zs @ [x]) deps", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>spec_ops (xs @ [x]) deps; crdt_ops (ys @ [x] @ zs) deps;\n     set (xs @ [x]) = set (ys @ [x] @ zs)\\<rbrakk>\n    \\<Longrightarrow> crdt_ops (ys @ zs @ [x]) deps", "obtain oid oper where x_pair: \"x = (oid, oper)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>oid oper.\n        x = (oid, oper) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  x = (oid, oper)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>spec_ops (xs @ [x]) deps; crdt_ops (ys @ [x] @ zs) deps;\n     set (xs @ [x]) = set (ys @ [x] @ zs)\\<rbrakk>\n    \\<Longrightarrow> crdt_ops (ys @ zs @ [x]) deps", "hence \"\\<And>op2 r. op2 \\<in> snd ` set zs \\<Longrightarrow> r \\<in> deps op2 \\<Longrightarrow> r \\<noteq> oid\""], ["proof (prove)\nusing this:\n  x = (oid, oper)\n\ngoal (1 subgoal):\n 1. \\<And>op2 r.\n       \\<lbrakk>op2 \\<in> snd ` set zs; r \\<in> deps op2\\<rbrakk>\n       \\<Longrightarrow> r \\<noteq> oid", "using assms crdt_ops_independent_suf"], ["proof (prove)\nusing this:\n  x = (oid, oper)\n  spec_ops (xs @ [x]) deps\n  crdt_ops (ys @ [x] @ zs) deps\n  set (xs @ [x]) = set (ys @ [x] @ zs)\n  \\<lbrakk>spec_ops (?xs @ [(?oid, ?oper)]) ?deps;\n   crdt_ops (?ys @ [(?oid, ?oper)] @ ?zs) ?deps;\n   set (?xs @ [(?oid, ?oper)]) = set (?ys @ [(?oid, ?oper)] @ ?zs);\n   ?op2.0 \\<in> snd ` set ?zs; ?r \\<in> ?deps ?op2.0\\<rbrakk>\n  \\<Longrightarrow> ?r \\<noteq> ?oid\n\ngoal (1 subgoal):\n 1. \\<And>op2 r.\n       \\<lbrakk>op2 \\<in> snd ` set zs; r \\<in> deps op2\\<rbrakk>\n       \\<Longrightarrow> r \\<noteq> oid", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>?op2.0 \\<in> snd ` set zs; ?r \\<in> deps ?op2.0\\<rbrakk>\n  \\<Longrightarrow> ?r \\<noteq> oid\n\ngoal (1 subgoal):\n 1. \\<lbrakk>spec_ops (xs @ [x]) deps; crdt_ops (ys @ [x] @ zs) deps;\n     set (xs @ [x]) = set (ys @ [x] @ zs)\\<rbrakk>\n    \\<Longrightarrow> crdt_ops (ys @ zs @ [x]) deps", "thus \"crdt_ops (ys @ zs @ [x]) deps\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?op2.0 \\<in> snd ` set zs; ?r \\<in> deps ?op2.0\\<rbrakk>\n  \\<Longrightarrow> ?r \\<noteq> oid\n\ngoal (1 subgoal):\n 1. crdt_ops (ys @ zs @ [x]) deps", "using assms(2) crdt_ops_reorder x_pair"], ["proof (prove)\nusing this:\n  \\<lbrakk>?op2.0 \\<in> snd ` set zs; ?r \\<in> deps ?op2.0\\<rbrakk>\n  \\<Longrightarrow> ?r \\<noteq> oid\n  crdt_ops (ys @ [x] @ zs) deps\n  \\<lbrakk>crdt_ops (?xs @ [(?oid, ?oper)] @ ?ys) ?deps;\n   \\<And>op2 r.\n      \\<lbrakk>op2 \\<in> snd ` set ?ys; r \\<in> ?deps op2\\<rbrakk>\n      \\<Longrightarrow> r \\<noteq> ?oid\\<rbrakk>\n  \\<Longrightarrow> crdt_ops (?xs @ ?ys @ [(?oid, ?oper)]) ?deps\n  x = (oid, oper)\n\ngoal (1 subgoal):\n 1. crdt_ops (ys @ zs @ [x]) deps", "by metis"], ["proof (state)\nthis:\n  crdt_ops (ys @ zs @ [x]) deps\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma crdt_ops_rem_spec:\n  assumes \"spec_ops (xs @ [x]) deps\"\n    and \"crdt_ops (ys @ [x] @ zs) deps\"\n    and \"set (xs @ [x]) = set (ys @ [x] @ zs)\"\n  shows \"crdt_ops (ys @ zs) deps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crdt_ops (ys @ zs) deps", "using assms crdt_ops_rem_last crdt_ops_reorder_spec append_assoc"], ["proof (prove)\nusing this:\n  spec_ops (xs @ [x]) deps\n  crdt_ops (ys @ [x] @ zs) deps\n  set (xs @ [x]) = set (ys @ [x] @ zs)\n  crdt_ops (?xs @ [?x]) ?deps \\<Longrightarrow> crdt_ops ?xs ?deps\n  \\<lbrakk>spec_ops (?xs @ [?x]) ?deps; crdt_ops (?ys @ [?x] @ ?zs) ?deps;\n   set (?xs @ [?x]) = set (?ys @ [?x] @ ?zs)\\<rbrakk>\n  \\<Longrightarrow> crdt_ops (?ys @ ?zs @ [?x]) ?deps\n  (?xs @ ?ys) @ ?zs = ?xs @ ?ys @ ?zs\n\ngoal (1 subgoal):\n 1. crdt_ops (ys @ zs) deps", "by metis"], ["", "lemma crdt_ops_rem_penultimate:\n  assumes \"crdt_ops (xs @ [(i1, r1)] @ [(i2, r2)]) deps\"\n    and \"\\<And>r. r \\<in> deps r2 \\<Longrightarrow> r \\<noteq> i1\"\n  shows \"crdt_ops (xs @ [(i2, r2)]) deps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crdt_ops (xs @ [(i2, r2)]) deps", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. crdt_ops (xs @ [(i2, r2)]) deps", "have \"crdt_ops (xs @ [(i1, r1)]) deps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crdt_ops (xs @ [(i1, r1)]) deps", "using assms(1) crdt_ops_rem_last"], ["proof (prove)\nusing this:\n  crdt_ops (xs @ [(i1, r1)] @ [(i2, r2)]) deps\n  crdt_ops (?xs @ [?x]) ?deps \\<Longrightarrow> crdt_ops ?xs ?deps\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ [(i1, r1)]) deps", "by force"], ["proof (state)\nthis:\n  crdt_ops (xs @ [(i1, r1)]) deps\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ [(i2, r2)]) deps", "hence \"crdt_ops xs deps\""], ["proof (prove)\nusing this:\n  crdt_ops (xs @ [(i1, r1)]) deps\n\ngoal (1 subgoal):\n 1. crdt_ops xs deps", "using crdt_ops_rem_last"], ["proof (prove)\nusing this:\n  crdt_ops (xs @ [(i1, r1)]) deps\n  crdt_ops (?xs @ [?x]) ?deps \\<Longrightarrow> crdt_ops ?xs ?deps\n\ngoal (1 subgoal):\n 1. crdt_ops xs deps", "by force"], ["proof (state)\nthis:\n  crdt_ops xs deps\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ [(i2, r2)]) deps", "moreover"], ["proof (state)\nthis:\n  crdt_ops xs deps\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ [(i2, r2)]) deps", "have \"distinct (map fst (xs @ [(i1, r1)] @ [(i2, r2)]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (xs @ [(i1, r1)] @ [(i2, r2)]))", "using assms(1) crdt_ops_distinct_fst"], ["proof (prove)\nusing this:\n  crdt_ops (xs @ [(i1, r1)] @ [(i2, r2)]) deps\n  crdt_ops ?xs ?deps \\<Longrightarrow> distinct (map fst ?xs)\n\ngoal (1 subgoal):\n 1. distinct (map fst (xs @ [(i1, r1)] @ [(i2, r2)]))", "by blast"], ["proof (state)\nthis:\n  distinct (map fst (xs @ [(i1, r1)] @ [(i2, r2)]))\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ [(i2, r2)]) deps", "hence \"i2 \\<notin> set (map fst xs)\""], ["proof (prove)\nusing this:\n  distinct (map fst (xs @ [(i1, r1)] @ [(i2, r2)]))\n\ngoal (1 subgoal):\n 1. i2 \\<notin> set (map fst xs)", "by auto"], ["proof (state)\nthis:\n  i2 \\<notin> set (map fst xs)\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ [(i2, r2)]) deps", "moreover"], ["proof (state)\nthis:\n  i2 \\<notin> set (map fst xs)\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ [(i2, r2)]) deps", "have \"crdt_ops ((xs @ [(i1, r1)]) @ [(i2, r2)]) deps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crdt_ops ((xs @ [(i1, r1)]) @ [(i2, r2)]) deps", "using assms(1)"], ["proof (prove)\nusing this:\n  crdt_ops (xs @ [(i1, r1)] @ [(i2, r2)]) deps\n\ngoal (1 subgoal):\n 1. crdt_ops ((xs @ [(i1, r1)]) @ [(i2, r2)]) deps", "by auto"], ["proof (state)\nthis:\n  crdt_ops ((xs @ [(i1, r1)]) @ [(i2, r2)]) deps\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ [(i2, r2)]) deps", "hence \"\\<And>r. r \\<in> deps r2 \\<Longrightarrow> r \\<in> fst ` set (xs @ [(i1, r1)])\""], ["proof (prove)\nusing this:\n  crdt_ops ((xs @ [(i1, r1)]) @ [(i2, r2)]) deps\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> deps r2 \\<Longrightarrow> r \\<in> fst ` set (xs @ [(i1, r1)])", "using crdt_ops_ref_exists"], ["proof (prove)\nusing this:\n  crdt_ops ((xs @ [(i1, r1)]) @ [(i2, r2)]) deps\n  \\<lbrakk>crdt_ops (?pre @ (?oid, ?oper) # ?suf) ?deps;\n   ?ref \\<in> ?deps ?oper\\<rbrakk>\n  \\<Longrightarrow> ?ref \\<in> fst ` set ?pre\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       r \\<in> deps r2 \\<Longrightarrow> r \\<in> fst ` set (xs @ [(i1, r1)])", "by metis"], ["proof (state)\nthis:\n  ?r \\<in> deps r2 \\<Longrightarrow> ?r \\<in> fst ` set (xs @ [(i1, r1)])\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ [(i2, r2)]) deps", "hence \"\\<And>r. r \\<in> deps r2 \\<Longrightarrow> r \\<in> set (map fst xs)\""], ["proof (prove)\nusing this:\n  ?r \\<in> deps r2 \\<Longrightarrow> ?r \\<in> fst ` set (xs @ [(i1, r1)])\n\ngoal (1 subgoal):\n 1. \\<And>r. r \\<in> deps r2 \\<Longrightarrow> r \\<in> set (map fst xs)", "using assms(2)"], ["proof (prove)\nusing this:\n  ?r \\<in> deps r2 \\<Longrightarrow> ?r \\<in> fst ` set (xs @ [(i1, r1)])\n  ?r \\<in> deps r2 \\<Longrightarrow> ?r \\<noteq> i1\n\ngoal (1 subgoal):\n 1. \\<And>r. r \\<in> deps r2 \\<Longrightarrow> r \\<in> set (map fst xs)", "by auto"], ["proof (state)\nthis:\n  ?r \\<in> deps r2 \\<Longrightarrow> ?r \\<in> set (map fst xs)\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ [(i2, r2)]) deps", "moreover"], ["proof (state)\nthis:\n  ?r \\<in> deps r2 \\<Longrightarrow> ?r \\<in> set (map fst xs)\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ [(i2, r2)]) deps", "have \"\\<And>r. r \\<in> deps r2 \\<Longrightarrow> r < i2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r. r \\<in> deps r2 \\<Longrightarrow> r < i2", "using assms(1) crdt_ops_ref_less"], ["proof (prove)\nusing this:\n  crdt_ops (xs @ [(i1, r1)] @ [(i2, r2)]) deps\n  \\<lbrakk>crdt_ops ?xs ?deps; (?oid, ?oper) \\<in> set ?xs;\n   ?r \\<in> ?deps ?oper\\<rbrakk>\n  \\<Longrightarrow> ?r < ?oid\n\ngoal (1 subgoal):\n 1. \\<And>r. r \\<in> deps r2 \\<Longrightarrow> r < i2", "by fastforce"], ["proof (state)\nthis:\n  ?r \\<in> deps r2 \\<Longrightarrow> ?r < i2\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ [(i2, r2)]) deps", "ultimately"], ["proof (chain)\npicking this:\n  crdt_ops xs deps\n  i2 \\<notin> set (map fst xs)\n  ?r \\<in> deps r2 \\<Longrightarrow> ?r \\<in> set (map fst xs)\n  ?r \\<in> deps r2 \\<Longrightarrow> ?r < i2", "show \"crdt_ops (xs @ [(i2, r2)]) deps\""], ["proof (prove)\nusing this:\n  crdt_ops xs deps\n  i2 \\<notin> set (map fst xs)\n  ?r \\<in> deps r2 \\<Longrightarrow> ?r \\<in> set (map fst xs)\n  ?r \\<in> deps r2 \\<Longrightarrow> ?r < i2\n\ngoal (1 subgoal):\n 1. crdt_ops (xs @ [(i2, r2)]) deps", "by (simp add: crdt_ops_intro)"], ["proof (state)\nthis:\n  crdt_ops (xs @ [(i2, r2)]) deps\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma crdt_ops_spec_ops_exist:\n  assumes \"crdt_ops xs deps\"\n  shows \"\\<exists>ys. set xs = set ys \\<and> spec_ops ys deps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ys. set xs = set ys \\<and> spec_ops ys deps", "using assms"], ["proof (prove)\nusing this:\n  crdt_ops xs deps\n\ngoal (1 subgoal):\n 1. \\<exists>ys. set xs = set ys \\<and> spec_ops ys deps", "proof(induction xs rule: List.rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. crdt_ops [] deps \\<Longrightarrow>\n    \\<exists>ys. set [] = set ys \\<and> spec_ops ys deps\n 2. \\<And>x xs.\n       \\<lbrakk>crdt_ops xs deps \\<Longrightarrow>\n                \\<exists>ys. set xs = set ys \\<and> spec_ops ys deps;\n        crdt_ops (xs @ [x]) deps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            set (xs @ [x]) = set ys \\<and> spec_ops ys deps", "case Nil"], ["proof (state)\nthis:\n  crdt_ops [] deps\n\ngoal (2 subgoals):\n 1. crdt_ops [] deps \\<Longrightarrow>\n    \\<exists>ys. set [] = set ys \\<and> spec_ops ys deps\n 2. \\<And>x xs.\n       \\<lbrakk>crdt_ops xs deps \\<Longrightarrow>\n                \\<exists>ys. set xs = set ys \\<and> spec_ops ys deps;\n        crdt_ops (xs @ [x]) deps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            set (xs @ [x]) = set ys \\<and> spec_ops ys deps", "then"], ["proof (chain)\npicking this:\n  crdt_ops [] deps", "show \"\\<exists>ys. set [] = set ys \\<and> spec_ops ys deps\""], ["proof (prove)\nusing this:\n  crdt_ops [] deps\n\ngoal (1 subgoal):\n 1. \\<exists>ys. set [] = set ys \\<and> spec_ops ys deps", "by (simp add: spec_ops_empty)"], ["proof (state)\nthis:\n  \\<exists>ys. set [] = set ys \\<and> spec_ops ys deps\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>crdt_ops xs deps \\<Longrightarrow>\n                \\<exists>ys. set xs = set ys \\<and> spec_ops ys deps;\n        crdt_ops (xs @ [x]) deps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            set (xs @ [x]) = set ys \\<and> spec_ops ys deps", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>crdt_ops xs deps \\<Longrightarrow>\n                \\<exists>ys. set xs = set ys \\<and> spec_ops ys deps;\n        crdt_ops (xs @ [x]) deps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            set (xs @ [x]) = set ys \\<and> spec_ops ys deps", "case (snoc x xs)"], ["proof (state)\nthis:\n  crdt_ops xs deps \\<Longrightarrow>\n  \\<exists>ys. set xs = set ys \\<and> spec_ops ys deps\n  crdt_ops (xs @ [x]) deps\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>crdt_ops xs deps \\<Longrightarrow>\n                \\<exists>ys. set xs = set ys \\<and> spec_ops ys deps;\n        crdt_ops (xs @ [x]) deps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            set (xs @ [x]) = set ys \\<and> spec_ops ys deps", "hence IH: \"\\<exists>ys. set xs = set ys \\<and> spec_ops ys deps\""], ["proof (prove)\nusing this:\n  crdt_ops xs deps \\<Longrightarrow>\n  \\<exists>ys. set xs = set ys \\<and> spec_ops ys deps\n  crdt_ops (xs @ [x]) deps\n\ngoal (1 subgoal):\n 1. \\<exists>ys. set xs = set ys \\<and> spec_ops ys deps", "using crdt_ops_rem_last"], ["proof (prove)\nusing this:\n  crdt_ops xs deps \\<Longrightarrow>\n  \\<exists>ys. set xs = set ys \\<and> spec_ops ys deps\n  crdt_ops (xs @ [x]) deps\n  crdt_ops (?xs @ [?x]) ?deps \\<Longrightarrow> crdt_ops ?xs ?deps\n\ngoal (1 subgoal):\n 1. \\<exists>ys. set xs = set ys \\<and> spec_ops ys deps", "by blast"], ["proof (state)\nthis:\n  \\<exists>ys. set xs = set ys \\<and> spec_ops ys deps\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>crdt_ops xs deps \\<Longrightarrow>\n                \\<exists>ys. set xs = set ys \\<and> spec_ops ys deps;\n        crdt_ops (xs @ [x]) deps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            set (xs @ [x]) = set ys \\<and> spec_ops ys deps", "then"], ["proof (chain)\npicking this:\n  \\<exists>ys. set xs = set ys \\<and> spec_ops ys deps", "obtain ys oid ref\n    where \"set xs = set ys\" and \"spec_ops ys deps\" and \"x = (oid, ref)\""], ["proof (prove)\nusing this:\n  \\<exists>ys. set xs = set ys \\<and> spec_ops ys deps\n\ngoal (1 subgoal):\n 1. (\\<And>ys oid ref.\n        \\<lbrakk>set xs = set ys; spec_ops ys deps; x = (oid, ref)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  set xs = set ys\n  spec_ops ys deps\n  x = (oid, ref)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>crdt_ops xs deps \\<Longrightarrow>\n                \\<exists>ys. set xs = set ys \\<and> spec_ops ys deps;\n        crdt_ops (xs @ [x]) deps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            set (xs @ [x]) = set ys \\<and> spec_ops ys deps", "moreover"], ["proof (state)\nthis:\n  set xs = set ys\n  spec_ops ys deps\n  x = (oid, ref)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>crdt_ops xs deps \\<Longrightarrow>\n                \\<exists>ys. set xs = set ys \\<and> spec_ops ys deps;\n        crdt_ops (xs @ [x]) deps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            set (xs @ [x]) = set ys \\<and> spec_ops ys deps", "have \"\\<exists>pre suf. ys = pre@suf \\<and>\n                       (\\<forall>i \\<in> set (map fst pre). i < oid) \\<and>\n                       (\\<forall>i \\<in> set (map fst suf). oid < i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       ys = pre @ suf \\<and>\n       (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n       (\\<forall>i\\<in>set (map fst suf). oid < i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       ys = pre @ suf \\<and>\n       (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n       (\\<forall>i\\<in>set (map fst suf). oid < i)", "have \"oid \\<notin> set (map fst xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oid \\<notin> set (map fst xs)", "using calculation(3) crdt_ops_unique_last snoc.prems"], ["proof (prove)\nusing this:\n  x = (oid, ref)\n  crdt_ops (?xs @ [(?oid, ?oper)]) ?deps \\<Longrightarrow>\n  ?oid \\<notin> set (map fst ?xs)\n  crdt_ops (xs @ [x]) deps\n\ngoal (1 subgoal):\n 1. oid \\<notin> set (map fst xs)", "by force"], ["proof (state)\nthis:\n  oid \\<notin> set (map fst xs)\n\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       ys = pre @ suf \\<and>\n       (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n       (\\<forall>i\\<in>set (map fst suf). oid < i)", "hence \"oid \\<notin> set (map fst ys)\""], ["proof (prove)\nusing this:\n  oid \\<notin> set (map fst xs)\n\ngoal (1 subgoal):\n 1. oid \\<notin> set (map fst ys)", "by (simp add: calculation(1))"], ["proof (state)\nthis:\n  oid \\<notin> set (map fst ys)\n\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       ys = pre @ suf \\<and>\n       (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n       (\\<forall>i\\<in>set (map fst suf). oid < i)", "thus ?thesis"], ["proof (prove)\nusing this:\n  oid \\<notin> set (map fst ys)\n\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       ys = pre @ suf \\<and>\n       (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n       (\\<forall>i\\<in>set (map fst suf). oid < i)", "using spec_ops_split \\<open>spec_ops ys deps\\<close>"], ["proof (prove)\nusing this:\n  oid \\<notin> set (map fst ys)\n  \\<lbrakk>spec_ops ?xs ?deps; ?oid \\<notin> set (map fst ?xs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>pre suf.\n                       ?xs = pre @ suf \\<and>\n                       (\\<forall>i\\<in>set (map fst pre). i < ?oid) \\<and>\n                       (\\<forall>i\\<in>set (map fst suf). ?oid < i)\n  spec_ops ys deps\n\ngoal (1 subgoal):\n 1. \\<exists>pre suf.\n       ys = pre @ suf \\<and>\n       (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n       (\\<forall>i\\<in>set (map fst suf). oid < i)", "by blast"], ["proof (state)\nthis:\n  \\<exists>pre suf.\n     ys = pre @ suf \\<and>\n     (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n     (\\<forall>i\\<in>set (map fst suf). oid < i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>pre suf.\n     ys = pre @ suf \\<and>\n     (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n     (\\<forall>i\\<in>set (map fst suf). oid < i)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>crdt_ops xs deps \\<Longrightarrow>\n                \\<exists>ys. set xs = set ys \\<and> spec_ops ys deps;\n        crdt_ops (xs @ [x]) deps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            set (xs @ [x]) = set ys \\<and> spec_ops ys deps", "from this"], ["proof (chain)\npicking this:\n  \\<exists>pre suf.\n     ys = pre @ suf \\<and>\n     (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n     (\\<forall>i\\<in>set (map fst suf). oid < i)", "obtain pre suf where \"ys = pre @ suf\" and\n    \"\\<forall>i \\<in> set (map fst pre). i < oid\" and\n    \"\\<forall>i \\<in> set (map fst suf). oid < i\""], ["proof (prove)\nusing this:\n  \\<exists>pre suf.\n     ys = pre @ suf \\<and>\n     (\\<forall>i\\<in>set (map fst pre). i < oid) \\<and>\n     (\\<forall>i\\<in>set (map fst suf). oid < i)\n\ngoal (1 subgoal):\n 1. (\\<And>pre suf.\n        \\<lbrakk>ys = pre @ suf; \\<forall>i\\<in>set (map fst pre). i < oid;\n         \\<forall>i\\<in>set (map fst suf). oid < i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  ys = pre @ suf\n  \\<forall>i\\<in>set (map fst pre). i < oid\n  \\<forall>i\\<in>set (map fst suf). oid < i\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>crdt_ops xs deps \\<Longrightarrow>\n                \\<exists>ys. set xs = set ys \\<and> spec_ops ys deps;\n        crdt_ops (xs @ [x]) deps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            set (xs @ [x]) = set ys \\<and> spec_ops ys deps", "moreover"], ["proof (state)\nthis:\n  ys = pre @ suf\n  \\<forall>i\\<in>set (map fst pre). i < oid\n  \\<forall>i\\<in>set (map fst suf). oid < i\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>crdt_ops xs deps \\<Longrightarrow>\n                \\<exists>ys. set xs = set ys \\<and> spec_ops ys deps;\n        crdt_ops (xs @ [x]) deps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            set (xs @ [x]) = set ys \\<and> spec_ops ys deps", "have \"set (xs @ [(oid, ref)]) = set (pre @ [(oid, ref)] @ suf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (xs @ [(oid, ref)]) = set (pre @ [(oid, ref)] @ suf)", "using crdt_ops_distinct calculation snoc.prems"], ["proof (prove)\nusing this:\n  crdt_ops ?xs ?deps \\<Longrightarrow> distinct ?xs\n  set xs = set ys\n  spec_ops ys deps\n  x = (oid, ref)\n  ys = pre @ suf\n  \\<forall>i\\<in>set (map fst pre). i < oid\n  \\<forall>i\\<in>set (map fst suf). oid < i\n  crdt_ops (xs @ [x]) deps\n\ngoal (1 subgoal):\n 1. set (xs @ [(oid, ref)]) = set (pre @ [(oid, ref)] @ suf)", "by simp"], ["proof (state)\nthis:\n  set (xs @ [(oid, ref)]) = set (pre @ [(oid, ref)] @ suf)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>crdt_ops xs deps \\<Longrightarrow>\n                \\<exists>ys. set xs = set ys \\<and> spec_ops ys deps;\n        crdt_ops (xs @ [x]) deps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            set (xs @ [x]) = set ys \\<and> spec_ops ys deps", "moreover"], ["proof (state)\nthis:\n  set (xs @ [(oid, ref)]) = set (pre @ [(oid, ref)] @ suf)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>crdt_ops xs deps \\<Longrightarrow>\n                \\<exists>ys. set xs = set ys \\<and> spec_ops ys deps;\n        crdt_ops (xs @ [x]) deps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            set (xs @ [x]) = set ys \\<and> spec_ops ys deps", "have \"spec_ops (pre @ [(oid, ref)] @ suf) deps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spec_ops (pre @ [(oid, ref)] @ suf) deps", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. spec_ops (pre @ [(oid, ref)] @ suf) deps", "have \"\\<forall>r \\<in> deps ref. r < oid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>deps ref. r < oid", "using calculation(3) crdt_ops_ref_less_last snoc.prems"], ["proof (prove)\nusing this:\n  x = (oid, ref)\n  \\<lbrakk>crdt_ops (?xs @ [(?oid, ?oper)]) ?deps;\n   ?r \\<in> ?deps ?oper\\<rbrakk>\n  \\<Longrightarrow> ?r < ?oid\n  crdt_ops (xs @ [x]) deps\n\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>deps ref. r < oid", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>r\\<in>deps ref. r < oid\n\ngoal (1 subgoal):\n 1. spec_ops (pre @ [(oid, ref)] @ suf) deps", "hence \"spec_ops (pre @ [(oid, ref)] @ suf) deps\""], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>deps ref. r < oid\n\ngoal (1 subgoal):\n 1. spec_ops (pre @ [(oid, ref)] @ suf) deps", "using spec_ops_add_any calculation"], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>deps ref. r < oid\n  \\<lbrakk>spec_ops (?xs @ ?ys) ?deps;\n   \\<forall>i\\<in>set (map fst ?xs). i < ?oid;\n   \\<forall>i\\<in>set (map fst ?ys). ?oid < i;\n   \\<forall>ref\\<in>?deps ?oper. ref < ?oid\\<rbrakk>\n  \\<Longrightarrow> spec_ops (?xs @ [(?oid, ?oper)] @ ?ys) ?deps\n  set xs = set ys\n  spec_ops ys deps\n  x = (oid, ref)\n  ys = pre @ suf\n  \\<forall>i\\<in>set (map fst pre). i < oid\n  \\<forall>i\\<in>set (map fst suf). oid < i\n  set (xs @ [(oid, ref)]) = set (pre @ [(oid, ref)] @ suf)\n\ngoal (1 subgoal):\n 1. spec_ops (pre @ [(oid, ref)] @ suf) deps", "by metis"], ["proof (state)\nthis:\n  spec_ops (pre @ [(oid, ref)] @ suf) deps\n\ngoal (1 subgoal):\n 1. spec_ops (pre @ [(oid, ref)] @ suf) deps", "thus ?thesis"], ["proof (prove)\nusing this:\n  spec_ops (pre @ [(oid, ref)] @ suf) deps\n\ngoal (1 subgoal):\n 1. spec_ops (pre @ [(oid, ref)] @ suf) deps", "by simp"], ["proof (state)\nthis:\n  spec_ops (pre @ [(oid, ref)] @ suf) deps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  spec_ops (pre @ [(oid, ref)] @ suf) deps\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>crdt_ops xs deps \\<Longrightarrow>\n                \\<exists>ys. set xs = set ys \\<and> spec_ops ys deps;\n        crdt_ops (xs @ [x]) deps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            set (xs @ [x]) = set ys \\<and> spec_ops ys deps", "ultimately"], ["proof (chain)\npicking this:\n  set xs = set ys\n  spec_ops ys deps\n  x = (oid, ref)\n  ys = pre @ suf\n  \\<forall>i\\<in>set (map fst pre). i < oid\n  \\<forall>i\\<in>set (map fst suf). oid < i\n  set (xs @ [(oid, ref)]) = set (pre @ [(oid, ref)] @ suf)\n  spec_ops (pre @ [(oid, ref)] @ suf) deps", "show \"\\<exists>ys. set (xs @ [x]) = set ys \\<and> spec_ops ys deps\""], ["proof (prove)\nusing this:\n  set xs = set ys\n  spec_ops ys deps\n  x = (oid, ref)\n  ys = pre @ suf\n  \\<forall>i\\<in>set (map fst pre). i < oid\n  \\<forall>i\\<in>set (map fst suf). oid < i\n  set (xs @ [(oid, ref)]) = set (pre @ [(oid, ref)] @ suf)\n  spec_ops (pre @ [(oid, ref)] @ suf) deps\n\ngoal (1 subgoal):\n 1. \\<exists>ys. set (xs @ [x]) = set ys \\<and> spec_ops ys deps", "by blast"], ["proof (state)\nthis:\n  \\<exists>ys. set (xs @ [x]) = set ys \\<and> spec_ops ys deps\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}