{"file_name": "/home/qj213/afp-2021-10-22/thys/OpSets/Insert_Spec.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/OpSets", "problem_names": ["lemma insert_ops_NilI [intro!]:\n  shows \"insert_ops []\"", "lemma insert_ops_rem_last [dest]:\n  assumes \"insert_ops (xs @ [x])\"\n  shows \"insert_ops xs\"", "lemma insert_ops_rem_cons:\n  assumes \"insert_ops (x # xs)\"\n  shows \"insert_ops xs\"", "lemma insert_ops_appendD:\n  assumes \"insert_ops (xs @ ys)\"\n  shows \"insert_ops xs\"", "lemma insert_ops_rem_prefix:\n  assumes \"insert_ops (pre @ suf)\"\n  shows \"insert_ops suf\"", "lemma insert_ops_remove1:\n  assumes \"insert_ops xs\"\n  shows \"insert_ops (remove1 x xs)\"", "lemma last_op_greatest:\n  assumes \"insert_ops (op_list @ [(oid, oper)])\"\n    and \"x \\<in> set (map fst op_list)\"\n  shows \"x < oid\"", "lemma insert_ops_ref_older:\n  assumes \"insert_ops (pre @ [(oid, Some ref)] @ suf)\"\n  shows \"ref < oid\"", "lemma insert_ops_memb_ref_older:\n  assumes \"insert_ops op_list\"\n    and \"(oid, Some ref) \\<in> set op_list\"\n  shows \"ref < oid\"", "lemma insert_spec_none [simp]:\n  shows \"set (insert_spec xs (oid, None)) = set xs \\<union> {oid}\"", "lemma insert_spec_set [simp]:\n  assumes \"ref \\<in> set xs\"\n  shows \"set (insert_spec xs (oid, Some ref)) = set xs \\<union> {oid}\"", "lemma insert_spec_nonex [simp]:\n  assumes \"ref \\<notin> set xs\"\n  shows \"insert_spec xs (oid, Some ref) = xs\"", "lemma list_greater_non_memb:\n  fixes oid :: \"'oid::{linorder}\"\n  assumes \"\\<And>x. x \\<in> set xs \\<Longrightarrow> x < oid\"\n    and \"oid \\<in> set xs\"\n  shows \"False\"", "lemma inserted_item_ident:\n  assumes \"a \\<in> set (insert_spec xs (e, i))\"\n    and \"a \\<notin> set xs\"\n  shows \"a = e\"", "lemma insert_spec_distinct [intro]:\n  fixes oid :: \"'oid::{linorder}\"\n  assumes \"distinct xs\"\n    and \"\\<And>x. x \\<in> set xs \\<Longrightarrow> x < oid\"\n    and \"ref = Some r \\<longrightarrow> r < oid\"\n  shows \"distinct (insert_spec xs (oid, ref))\"", "lemma insert_after_ref:\n  assumes \"distinct (xs @ ref # ys)\"\n  shows \"insert_spec (xs @ ref # ys) (oid, Some ref) = xs @ ref # oid # ys\"", "lemma insert_somewhere:\n  assumes \"ref = None \\<or> (ref = Some r \\<and> r \\<in> set list)\"\n  shows \"\\<exists>xs ys. list = xs @ ys \\<and> insert_spec list (oid, ref) = xs @ oid # ys\"", "lemma insert_first_part:\n  assumes \"ref = None \\<or> (ref = Some r \\<and> r \\<in> set xs)\"\n  shows \"insert_spec (xs @ ys) (oid, ref) = (insert_spec xs (oid, ref)) @ ys\"", "lemma insert_second_part:\n  assumes \"ref = Some r\"\n    and \"r \\<notin> set xs\"\n    and \"r \\<in> set ys\"\n  shows \"insert_spec (xs @ ys) (oid, ref) = xs @ (insert_spec ys (oid, ref))\"", "lemma interp_ins_empty [simp]:\n  shows \"interp_ins [] = []\"", "lemma interp_ins_tail_unfold:\n  shows \"interp_ins (xs @ [x]) = insert_spec (interp_ins xs) x\"", "lemma interp_ins_subset [simp]:\n  shows \"set (interp_ins op_list) \\<subseteq> set (map fst op_list)\"", "lemma interp_ins_distinct:\n  assumes \"insert_ops op_list\"\n  shows \"distinct (interp_ins op_list)\"", "lemma succ_rel_set_fst:\n  shows \"fst ` (succ_rel xs) = set xs\"", "lemma succ_rel_functional:\n  assumes \"(a, b1) \\<in> succ_rel xs\"\n    and \"(a, b2) \\<in> succ_rel xs\"\n    and \"distinct xs\"\n  shows \"b1 = b2\"", "lemma succ_rel_rem_head:\n  assumes \"distinct (x # xs)\"\n  shows \"{(p, n) \\<in> succ_rel (x # xs). p \\<noteq> x} = succ_rel xs\"", "lemma succ_rel_swap_head:\n  assumes \"distinct (ref # list)\"\n    and \"(ref, n) \\<in> succ_rel (ref # list)\"\n  shows \"succ_rel (oid # list) = {(oid, n)} \\<union> succ_rel list\"", "lemma succ_rel_insert_alt:\n  assumes \"a \\<noteq> ref\"\n    and \"distinct (oid # a # b # list)\"\n  shows \"insert_alt (succ_rel (a # b # list)) (oid, ref) =\n         {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)\"", "lemma succ_rel_insert_head:\n  assumes \"distinct (ref # list)\"\n  shows \"succ_rel (insert_spec (ref # list) (oid, Some ref)) =\n         insert_alt (succ_rel (ref # list)) (oid, ref)\"", "lemma succ_rel_insert_later:\n  assumes \"succ_rel (insert_spec (b # list) (oid, Some ref)) =\n           insert_alt (succ_rel (b # list)) (oid, ref)\"\n    and \"a \\<noteq> ref\"\n    and \"distinct (a # b # list)\"\n  shows \"succ_rel (insert_spec (a # b # list) (oid, Some ref)) =\n         insert_alt (succ_rel (a # b # list)) (oid, ref)\"", "lemma succ_rel_insert_Some:\n  assumes \"distinct list\"\n  shows \"succ_rel (insert_spec list (oid, Some ref)) = insert_alt (succ_rel list) (oid, ref)\"", "theorem insert_alt_equivalent:\n  assumes \"insert_ops ops\"\n    and \"head \\<notin> fst ` set ops\"\n    and \"\\<And>r. Some r \\<in> snd ` set ops \\<Longrightarrow> r \\<noteq> head\"\n  shows \"succ_rel (head # interp_ins ops) = interp_alt head ops\"", "lemma list_orderI:\n  assumes \"interp_ins ops = xs @ [x] @ ys @ [y] @ zs\"\n  shows \"list_order ops x y\"", "lemma list_orderE:\n  assumes \"list_order ops x y\"\n  shows \"\\<exists>xs ys zs. interp_ins ops = xs @ [x] @ ys @ [y] @ zs\"", "lemma list_order_memb1:\n  assumes \"list_order ops x y\"\n  shows \"x \\<in> set (interp_ins ops)\"", "lemma list_order_memb2:\n  assumes \"list_order ops x y\"\n  shows \"y \\<in> set (interp_ins ops)\"", "lemma list_order_trans:\n  assumes \"insert_ops op_list\"\n    and \"list_order op_list x y\"\n    and \"list_order op_list y z\"\n  shows \"list_order op_list x z\"", "lemma insert_preserves_order:\n  assumes \"insert_ops ops\" and \"insert_ops rest\"\n    and \"rest = before @ after\"\n    and \"ops  = before @ (oid, ref) # after\"\n  shows \"\\<exists>xs ys zs. interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\"", "lemma distinct_fst:\n  assumes \"distinct (map fst A)\"\n  shows \"distinct A\"", "lemma subset_distinct_le:\n  assumes \"set A \\<subseteq> set B\" and \"distinct A\" and \"distinct B\"\n  shows \"length A \\<le> length B\"", "lemma set_subset_length_eq:\n  assumes \"set A \\<subseteq> set B\" and \"length B \\<le> length A\"\n    and \"distinct A\" and \"distinct B\"\n  shows \"set A = set B\"", "lemma length_diff_Suc_exists:\n  assumes \"length xs - length ys = Suc m\"\n    and \"set ys \\<subseteq> set xs\"\n    and \"distinct ys\" and \"distinct xs\"\n  shows \"\\<exists>e. e \\<in> set xs \\<and> e \\<notin> set ys\"", "lemma app_length_lt_exists:\n  assumes \"xsa @ zsa = xs @ ys\"\n    and \"length xsa \\<le> length xs\"\n  shows \"xsa @ (drop (length xsa) xs) = xs\"", "lemma list_order_monotonic:\n  assumes \"insert_ops A\" and \"insert_ops B\"\n    and \"set A \\<subseteq> set B\"\n    and \"list_order A x y\"\n  shows \"list_order B x y\""], "translations": [["", "lemma insert_ops_NilI [intro!]:\n  shows \"insert_ops []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_ops []", "by (auto simp add: insert_ops_def spec_ops_def)"], ["", "lemma insert_ops_rem_last [dest]:\n  assumes \"insert_ops (xs @ [x])\"\n  shows \"insert_ops xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_ops xs", "using assms insert_ops_def spec_ops_rem_last"], ["proof (prove)\nusing this:\n  insert_ops (xs @ [x])\n  insert_ops ?list \\<equiv> spec_ops ?list set_option\n  spec_ops (?xs @ [?x]) ?deps \\<Longrightarrow> spec_ops ?xs ?deps\n\ngoal (1 subgoal):\n 1. insert_ops xs", "by blast"], ["", "lemma insert_ops_rem_cons:\n  assumes \"insert_ops (x # xs)\"\n  shows \"insert_ops xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_ops xs", "using assms insert_ops_def spec_ops_rem_cons"], ["proof (prove)\nusing this:\n  insert_ops (x # xs)\n  insert_ops ?list \\<equiv> spec_ops ?list set_option\n  spec_ops (?x # ?xs) ?deps \\<Longrightarrow> spec_ops ?xs ?deps\n\ngoal (1 subgoal):\n 1. insert_ops xs", "by blast"], ["", "lemma insert_ops_appendD:\n  assumes \"insert_ops (xs @ ys)\"\n  shows \"insert_ops xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_ops xs", "using assms"], ["proof (prove)\nusing this:\n  insert_ops (xs @ ys)\n\ngoal (1 subgoal):\n 1. insert_ops xs", "by (induction ys rule: List.rev_induct,\n      auto, metis insert_ops_rem_last append_assoc)"], ["", "lemma insert_ops_rem_prefix:\n  assumes \"insert_ops (pre @ suf)\"\n  shows \"insert_ops suf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_ops suf", "using assms"], ["proof (prove)\nusing this:\n  insert_ops (pre @ suf)\n\ngoal (1 subgoal):\n 1. insert_ops suf", "proof(induction pre)"], ["proof (state)\ngoal (2 subgoals):\n 1. insert_ops ([] @ suf) \\<Longrightarrow> insert_ops suf\n 2. \\<And>a pre.\n       \\<lbrakk>insert_ops (pre @ suf) \\<Longrightarrow> insert_ops suf;\n        insert_ops ((a # pre) @ suf)\\<rbrakk>\n       \\<Longrightarrow> insert_ops suf", "case Nil"], ["proof (state)\nthis:\n  insert_ops ([] @ suf)\n\ngoal (2 subgoals):\n 1. insert_ops ([] @ suf) \\<Longrightarrow> insert_ops suf\n 2. \\<And>a pre.\n       \\<lbrakk>insert_ops (pre @ suf) \\<Longrightarrow> insert_ops suf;\n        insert_ops ((a # pre) @ suf)\\<rbrakk>\n       \\<Longrightarrow> insert_ops suf", "then"], ["proof (chain)\npicking this:\n  insert_ops ([] @ suf)", "show \"insert_ops ([] @ suf) \\<Longrightarrow> insert_ops suf\""], ["proof (prove)\nusing this:\n  insert_ops ([] @ suf)\n\ngoal (1 subgoal):\n 1. insert_ops ([] @ suf) \\<Longrightarrow> insert_ops suf", "by auto"], ["proof (state)\nthis:\n  insert_ops ([] @ suf) \\<Longrightarrow> insert_ops suf\n\ngoal (1 subgoal):\n 1. \\<And>a pre.\n       \\<lbrakk>insert_ops (pre @ suf) \\<Longrightarrow> insert_ops suf;\n        insert_ops ((a # pre) @ suf)\\<rbrakk>\n       \\<Longrightarrow> insert_ops suf", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a pre.\n       \\<lbrakk>insert_ops (pre @ suf) \\<Longrightarrow> insert_ops suf;\n        insert_ops ((a # pre) @ suf)\\<rbrakk>\n       \\<Longrightarrow> insert_ops suf", "case (Cons a pre)"], ["proof (state)\nthis:\n  insert_ops (pre @ suf) \\<Longrightarrow> insert_ops suf\n  insert_ops ((a # pre) @ suf)\n\ngoal (1 subgoal):\n 1. \\<And>a pre.\n       \\<lbrakk>insert_ops (pre @ suf) \\<Longrightarrow> insert_ops suf;\n        insert_ops ((a # pre) @ suf)\\<rbrakk>\n       \\<Longrightarrow> insert_ops suf", "have \"sorted (map fst suf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (map fst suf)", "using assms"], ["proof (prove)\nusing this:\n  insert_ops (pre @ suf)\n\ngoal (1 subgoal):\n 1. sorted (map fst suf)", "by (simp add: insert_ops_def sorted_append spec_ops_def)"], ["proof (state)\nthis:\n  sorted (map fst suf)\n\ngoal (1 subgoal):\n 1. \\<And>a pre.\n       \\<lbrakk>insert_ops (pre @ suf) \\<Longrightarrow> insert_ops suf;\n        insert_ops ((a # pre) @ suf)\\<rbrakk>\n       \\<Longrightarrow> insert_ops suf", "moreover"], ["proof (state)\nthis:\n  sorted (map fst suf)\n\ngoal (1 subgoal):\n 1. \\<And>a pre.\n       \\<lbrakk>insert_ops (pre @ suf) \\<Longrightarrow> insert_ops suf;\n        insert_ops ((a # pre) @ suf)\\<rbrakk>\n       \\<Longrightarrow> insert_ops suf", "have \"distinct (map fst suf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst suf)", "using assms"], ["proof (prove)\nusing this:\n  insert_ops (pre @ suf)\n\ngoal (1 subgoal):\n 1. distinct (map fst suf)", "by (simp add: insert_ops_def spec_ops_def)"], ["proof (state)\nthis:\n  distinct (map fst suf)\n\ngoal (1 subgoal):\n 1. \\<And>a pre.\n       \\<lbrakk>insert_ops (pre @ suf) \\<Longrightarrow> insert_ops suf;\n        insert_ops ((a # pre) @ suf)\\<rbrakk>\n       \\<Longrightarrow> insert_ops suf", "ultimately"], ["proof (chain)\npicking this:\n  sorted (map fst suf)\n  distinct (map fst suf)", "show \"insert_ops ((a # pre) @ suf) \\<Longrightarrow> insert_ops suf\""], ["proof (prove)\nusing this:\n  sorted (map fst suf)\n  distinct (map fst suf)\n\ngoal (1 subgoal):\n 1. insert_ops ((a # pre) @ suf) \\<Longrightarrow> insert_ops suf", "by (simp add: insert_ops_def spec_ops_def)"], ["proof (state)\nthis:\n  insert_ops ((a # pre) @ suf) \\<Longrightarrow> insert_ops suf\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_ops_remove1:\n  assumes \"insert_ops xs\"\n  shows \"insert_ops (remove1 x xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_ops (remove1 x xs)", "using assms insert_ops_def spec_ops_remove1"], ["proof (prove)\nusing this:\n  insert_ops xs\n  insert_ops ?list \\<equiv> spec_ops ?list set_option\n  spec_ops ?xs ?deps \\<Longrightarrow> spec_ops (remove1 ?x ?xs) ?deps\n\ngoal (1 subgoal):\n 1. insert_ops (remove1 x xs)", "by blast"], ["", "lemma last_op_greatest:\n  assumes \"insert_ops (op_list @ [(oid, oper)])\"\n    and \"x \\<in> set (map fst op_list)\"\n  shows \"x < oid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < oid", "using assms spec_ops_id_inc insert_ops_def"], ["proof (prove)\nusing this:\n  insert_ops (op_list @ [(oid, oper)])\n  x \\<in> set (map fst op_list)\n  \\<lbrakk>spec_ops (?xs @ [(?oid, ?oper)]) ?deps;\n   ?x \\<in> set (map fst ?xs)\\<rbrakk>\n  \\<Longrightarrow> ?x < ?oid\n  insert_ops ?list \\<equiv> spec_ops ?list set_option\n\ngoal (1 subgoal):\n 1. x < oid", "by metis"], ["", "lemma insert_ops_ref_older:\n  assumes \"insert_ops (pre @ [(oid, Some ref)] @ suf)\"\n  shows \"ref < oid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ref < oid", "using assms"], ["proof (prove)\nusing this:\n  insert_ops (pre @ [(oid, Some ref)] @ suf)\n\ngoal (1 subgoal):\n 1. ref < oid", "by (auto simp add: insert_ops_def spec_ops_def)"], ["", "lemma insert_ops_memb_ref_older:\n  assumes \"insert_ops op_list\"\n    and \"(oid, Some ref) \\<in> set op_list\"\n  shows \"ref < oid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ref < oid", "using assms insert_ops_ref_older split_list_first"], ["proof (prove)\nusing this:\n  insert_ops op_list\n  (oid, Some ref) \\<in> set op_list\n  insert_ops (?pre @ [(?oid, Some ?ref)] @ ?suf) \\<Longrightarrow>\n  ?ref < ?oid\n  ?x \\<in> set ?xs \\<Longrightarrow>\n  \\<exists>ys zs. ?xs = ys @ ?x # zs \\<and> ?x \\<notin> set ys\n\ngoal (1 subgoal):\n 1. ref < oid", "by fastforce"], ["", "subsection \\<open>Properties of the \\isa{insert-spec} function\\<close>"], ["", "lemma insert_spec_none [simp]:\n  shows \"set (insert_spec xs (oid, None)) = set xs \\<union> {oid}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (insert_spec xs (oid, None)) = set xs \\<union> {oid}", "by (induction xs, auto simp add: insert_commute sup_commute)"], ["", "lemma insert_spec_set [simp]:\n  assumes \"ref \\<in> set xs\"\n  shows \"set (insert_spec xs (oid, Some ref)) = set xs \\<union> {oid}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (insert_spec xs (oid, Some ref)) = set xs \\<union> {oid}", "using assms"], ["proof (prove)\nusing this:\n  ref \\<in> set xs\n\ngoal (1 subgoal):\n 1. set (insert_spec xs (oid, Some ref)) = set xs \\<union> {oid}", "proof(induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. ref \\<in> set [] \\<Longrightarrow>\n    set (insert_spec [] (oid, Some ref)) = set [] \\<union> {oid}\n 2. \\<And>a xs.\n       \\<lbrakk>ref \\<in> set xs \\<Longrightarrow>\n                set (insert_spec xs (oid, Some ref)) =\n                set xs \\<union> {oid};\n        ref \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (insert_spec (a # xs) (oid, Some ref)) =\n                         set (a # xs) \\<union> {oid}", "assume \"ref \\<in> set []\""], ["proof (state)\nthis:\n  ref \\<in> set []\n\ngoal (2 subgoals):\n 1. ref \\<in> set [] \\<Longrightarrow>\n    set (insert_spec [] (oid, Some ref)) = set [] \\<union> {oid}\n 2. \\<And>a xs.\n       \\<lbrakk>ref \\<in> set xs \\<Longrightarrow>\n                set (insert_spec xs (oid, Some ref)) =\n                set xs \\<union> {oid};\n        ref \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (insert_spec (a # xs) (oid, Some ref)) =\n                         set (a # xs) \\<union> {oid}", "thus \"set (insert_spec [] (oid, Some ref)) = set [] \\<union> {oid}\""], ["proof (prove)\nusing this:\n  ref \\<in> set []\n\ngoal (1 subgoal):\n 1. set (insert_spec [] (oid, Some ref)) = set [] \\<union> {oid}", "by auto"], ["proof (state)\nthis:\n  set (insert_spec [] (oid, Some ref)) = set [] \\<union> {oid}\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>ref \\<in> set xs \\<Longrightarrow>\n                set (insert_spec xs (oid, Some ref)) =\n                set xs \\<union> {oid};\n        ref \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (insert_spec (a # xs) (oid, Some ref)) =\n                         set (a # xs) \\<union> {oid}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>ref \\<in> set xs \\<Longrightarrow>\n                set (insert_spec xs (oid, Some ref)) =\n                set xs \\<union> {oid};\n        ref \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (insert_spec (a # xs) (oid, Some ref)) =\n                         set (a # xs) \\<union> {oid}", "fix a xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>ref \\<in> set xs \\<Longrightarrow>\n                set (insert_spec xs (oid, Some ref)) =\n                set xs \\<union> {oid};\n        ref \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (insert_spec (a # xs) (oid, Some ref)) =\n                         set (a # xs) \\<union> {oid}", "assume \"ref \\<in> set xs \\<Longrightarrow> set (insert_spec xs (oid, Some ref)) = set xs \\<union> {oid}\"\n    and \"ref \\<in> set (a#xs)\""], ["proof (state)\nthis:\n  ref \\<in> set xs \\<Longrightarrow>\n  set (insert_spec xs (oid, Some ref)) = set xs \\<union> {oid}\n  ref \\<in> set (a # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>ref \\<in> set xs \\<Longrightarrow>\n                set (insert_spec xs (oid, Some ref)) =\n                set xs \\<union> {oid};\n        ref \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> set (insert_spec (a # xs) (oid, Some ref)) =\n                         set (a # xs) \\<union> {oid}", "thus \"set (insert_spec (a#xs) (oid, Some ref)) = set (a#xs) \\<union> {oid}\""], ["proof (prove)\nusing this:\n  ref \\<in> set xs \\<Longrightarrow>\n  set (insert_spec xs (oid, Some ref)) = set xs \\<union> {oid}\n  ref \\<in> set (a # xs)\n\ngoal (1 subgoal):\n 1. set (insert_spec (a # xs) (oid, Some ref)) = set (a # xs) \\<union> {oid}", "by(cases \"a = ref\", auto simp add: insert_commute sup_commute)"], ["proof (state)\nthis:\n  set (insert_spec (a # xs) (oid, Some ref)) = set (a # xs) \\<union> {oid}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_spec_nonex [simp]:\n  assumes \"ref \\<notin> set xs\"\n  shows \"insert_spec xs (oid, Some ref) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_spec xs (oid, Some ref) = xs", "using assms"], ["proof (prove)\nusing this:\n  ref \\<notin> set xs\n\ngoal (1 subgoal):\n 1. insert_spec xs (oid, Some ref) = xs", "proof(induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. ref \\<notin> set [] \\<Longrightarrow>\n    insert_spec [] (oid, Some ref) = []\n 2. \\<And>a xs.\n       \\<lbrakk>ref \\<notin> set xs \\<Longrightarrow>\n                insert_spec xs (oid, Some ref) = xs;\n        ref \\<notin> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> insert_spec (a # xs) (oid, Some ref) = a # xs", "show \"insert_spec [] (oid, Some ref) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_spec [] (oid, Some ref) = []", "by simp"], ["proof (state)\nthis:\n  insert_spec [] (oid, Some ref) = []\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>ref \\<notin> set xs \\<Longrightarrow>\n                insert_spec xs (oid, Some ref) = xs;\n        ref \\<notin> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> insert_spec (a # xs) (oid, Some ref) = a # xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>ref \\<notin> set xs \\<Longrightarrow>\n                insert_spec xs (oid, Some ref) = xs;\n        ref \\<notin> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> insert_spec (a # xs) (oid, Some ref) = a # xs", "fix a xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>ref \\<notin> set xs \\<Longrightarrow>\n                insert_spec xs (oid, Some ref) = xs;\n        ref \\<notin> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> insert_spec (a # xs) (oid, Some ref) = a # xs", "assume \"ref \\<notin> set xs \\<Longrightarrow> insert_spec xs (oid, Some ref) = xs\"\n    and \"ref \\<notin> set (a#xs)\""], ["proof (state)\nthis:\n  ref \\<notin> set xs \\<Longrightarrow> insert_spec xs (oid, Some ref) = xs\n  ref \\<notin> set (a # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>ref \\<notin> set xs \\<Longrightarrow>\n                insert_spec xs (oid, Some ref) = xs;\n        ref \\<notin> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> insert_spec (a # xs) (oid, Some ref) = a # xs", "thus \"insert_spec (a#xs) (oid, Some ref) = a#xs\""], ["proof (prove)\nusing this:\n  ref \\<notin> set xs \\<Longrightarrow> insert_spec xs (oid, Some ref) = xs\n  ref \\<notin> set (a # xs)\n\ngoal (1 subgoal):\n 1. insert_spec (a # xs) (oid, Some ref) = a # xs", "by(cases \"a = ref\", auto simp add: insert_commute sup_commute)"], ["proof (state)\nthis:\n  insert_spec (a # xs) (oid, Some ref) = a # xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_greater_non_memb:\n  fixes oid :: \"'oid::{linorder}\"\n  assumes \"\\<And>x. x \\<in> set xs \\<Longrightarrow> x < oid\"\n    and \"oid \\<in> set xs\"\n  shows \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> set xs \\<Longrightarrow> ?x < oid\n  oid \\<in> set xs\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["", "lemma inserted_item_ident:\n  assumes \"a \\<in> set (insert_spec xs (e, i))\"\n    and \"a \\<notin> set xs\"\n  shows \"a = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = e", "using assms"], ["proof (prove)\nusing this:\n  a \\<in> set (insert_spec xs (e, i))\n  a \\<notin> set xs\n\ngoal (1 subgoal):\n 1. a = e", "proof(induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> set (insert_spec [] (e, i)); a \\<notin> set []\\<rbrakk>\n    \\<Longrightarrow> a = e\n 2. \\<And>aa xs.\n       \\<lbrakk>\\<lbrakk>a \\<in> set (insert_spec xs (e, i));\n                 a \\<notin> set xs\\<rbrakk>\n                \\<Longrightarrow> a = e;\n        a \\<in> set (insert_spec (aa # xs) (e, i));\n        a \\<notin> set (aa # xs)\\<rbrakk>\n       \\<Longrightarrow> a = e", "case Nil"], ["proof (state)\nthis:\n  a \\<in> set (insert_spec [] (e, i))\n  a \\<notin> set []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a \\<in> set (insert_spec [] (e, i)); a \\<notin> set []\\<rbrakk>\n    \\<Longrightarrow> a = e\n 2. \\<And>aa xs.\n       \\<lbrakk>\\<lbrakk>a \\<in> set (insert_spec xs (e, i));\n                 a \\<notin> set xs\\<rbrakk>\n                \\<Longrightarrow> a = e;\n        a \\<in> set (insert_spec (aa # xs) (e, i));\n        a \\<notin> set (aa # xs)\\<rbrakk>\n       \\<Longrightarrow> a = e", "then"], ["proof (chain)\npicking this:\n  a \\<in> set (insert_spec [] (e, i))\n  a \\<notin> set []", "show \"a = e\""], ["proof (prove)\nusing this:\n  a \\<in> set (insert_spec [] (e, i))\n  a \\<notin> set []\n\ngoal (1 subgoal):\n 1. a = e", "by (cases i, auto)"], ["proof (state)\nthis:\n  a = e\n\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       \\<lbrakk>\\<lbrakk>a \\<in> set (insert_spec xs (e, i));\n                 a \\<notin> set xs\\<rbrakk>\n                \\<Longrightarrow> a = e;\n        a \\<in> set (insert_spec (aa # xs) (e, i));\n        a \\<notin> set (aa # xs)\\<rbrakk>\n       \\<Longrightarrow> a = e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       \\<lbrakk>\\<lbrakk>a \\<in> set (insert_spec xs (e, i));\n                 a \\<notin> set xs\\<rbrakk>\n                \\<Longrightarrow> a = e;\n        a \\<in> set (insert_spec (aa # xs) (e, i));\n        a \\<notin> set (aa # xs)\\<rbrakk>\n       \\<Longrightarrow> a = e", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<in> set (insert_spec xs (e, i)); a \\<notin> set xs\\<rbrakk>\n  \\<Longrightarrow> a = e\n  a \\<in> set (insert_spec (x # xs) (e, i))\n  a \\<notin> set (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>aa xs.\n       \\<lbrakk>\\<lbrakk>a \\<in> set (insert_spec xs (e, i));\n                 a \\<notin> set xs\\<rbrakk>\n                \\<Longrightarrow> a = e;\n        a \\<in> set (insert_spec (aa # xs) (e, i));\n        a \\<notin> set (aa # xs)\\<rbrakk>\n       \\<Longrightarrow> a = e", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>a \\<in> set (insert_spec xs (e, i)); a \\<notin> set xs\\<rbrakk>\n  \\<Longrightarrow> a = e\n  a \\<in> set (insert_spec (x # xs) (e, i))\n  a \\<notin> set (x # xs)", "show \"a = e\""], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<in> set (insert_spec xs (e, i)); a \\<notin> set xs\\<rbrakk>\n  \\<Longrightarrow> a = e\n  a \\<in> set (insert_spec (x # xs) (e, i))\n  a \\<notin> set (x # xs)\n\ngoal (1 subgoal):\n 1. a = e", "proof(cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>a \\<in> set (insert_spec xs (e, i));\n              a \\<notin> set xs\\<rbrakk>\n             \\<Longrightarrow> a = e;\n     a \\<in> set (insert_spec (x # xs) (e, i)); a \\<notin> set (x # xs);\n     i = None\\<rbrakk>\n    \\<Longrightarrow> a = e\n 2. \\<And>aa.\n       \\<lbrakk>\\<lbrakk>a \\<in> set (insert_spec xs (e, i));\n                 a \\<notin> set xs\\<rbrakk>\n                \\<Longrightarrow> a = e;\n        a \\<in> set (insert_spec (x # xs) (e, i)); a \\<notin> set (x # xs);\n        i = Some aa\\<rbrakk>\n       \\<Longrightarrow> a = e", "case None"], ["proof (state)\nthis:\n  i = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>a \\<in> set (insert_spec xs (e, i));\n              a \\<notin> set xs\\<rbrakk>\n             \\<Longrightarrow> a = e;\n     a \\<in> set (insert_spec (x # xs) (e, i)); a \\<notin> set (x # xs);\n     i = None\\<rbrakk>\n    \\<Longrightarrow> a = e\n 2. \\<And>aa.\n       \\<lbrakk>\\<lbrakk>a \\<in> set (insert_spec xs (e, i));\n                 a \\<notin> set xs\\<rbrakk>\n                \\<Longrightarrow> a = e;\n        a \\<in> set (insert_spec (x # xs) (e, i)); a \\<notin> set (x # xs);\n        i = Some aa\\<rbrakk>\n       \\<Longrightarrow> a = e", "then"], ["proof (chain)\npicking this:\n  i = None", "show \"a = e\""], ["proof (prove)\nusing this:\n  i = None\n\ngoal (1 subgoal):\n 1. a = e", "using assms"], ["proof (prove)\nusing this:\n  i = None\n  a \\<in> set (insert_spec xs (e, i))\n  a \\<notin> set xs\n\ngoal (1 subgoal):\n 1. a = e", "by auto"], ["proof (state)\nthis:\n  a = e\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>\\<lbrakk>a \\<in> set (insert_spec xs (e, i));\n                 a \\<notin> set xs\\<rbrakk>\n                \\<Longrightarrow> a = e;\n        a \\<in> set (insert_spec (x # xs) (e, i)); a \\<notin> set (x # xs);\n        i = Some aa\\<rbrakk>\n       \\<Longrightarrow> a = e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>\\<lbrakk>a \\<in> set (insert_spec xs (e, i));\n                 a \\<notin> set xs\\<rbrakk>\n                \\<Longrightarrow> a = e;\n        a \\<in> set (insert_spec (x # xs) (e, i)); a \\<notin> set (x # xs);\n        i = Some aa\\<rbrakk>\n       \\<Longrightarrow> a = e", "case (Some ref)"], ["proof (state)\nthis:\n  i = Some ref\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>\\<lbrakk>a \\<in> set (insert_spec xs (e, i));\n                 a \\<notin> set xs\\<rbrakk>\n                \\<Longrightarrow> a = e;\n        a \\<in> set (insert_spec (x # xs) (e, i)); a \\<notin> set (x # xs);\n        i = Some aa\\<rbrakk>\n       \\<Longrightarrow> a = e", "then"], ["proof (chain)\npicking this:\n  i = Some ref", "show \"a = e\""], ["proof (prove)\nusing this:\n  i = Some ref\n\ngoal (1 subgoal):\n 1. a = e", "using Cons"], ["proof (prove)\nusing this:\n  i = Some ref\n  \\<lbrakk>a \\<in> set (insert_spec xs (e, i)); a \\<notin> set xs\\<rbrakk>\n  \\<Longrightarrow> a = e\n  a \\<in> set (insert_spec (x # xs) (e, i))\n  a \\<notin> set (x # xs)\n\ngoal (1 subgoal):\n 1. a = e", "by (case_tac \"x = ref\", auto)"], ["proof (state)\nthis:\n  a = e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a = e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_spec_distinct [intro]:\n  fixes oid :: \"'oid::{linorder}\"\n  assumes \"distinct xs\"\n    and \"\\<And>x. x \\<in> set xs \\<Longrightarrow> x < oid\"\n    and \"ref = Some r \\<longrightarrow> r < oid\"\n  shows \"distinct (insert_spec xs (oid, ref))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (insert_spec xs (oid, ref))", "using assms(1) assms(2)"], ["proof (prove)\nusing this:\n  distinct xs\n  ?x \\<in> set xs \\<Longrightarrow> ?x < oid\n\ngoal (1 subgoal):\n 1. distinct (insert_spec xs (oid, ref))", "proof(induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct [];\n     \\<And>x. x \\<in> set [] \\<Longrightarrow> x < oid\\<rbrakk>\n    \\<Longrightarrow> distinct (insert_spec [] (oid, ref))\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct xs;\n                 \\<And>x. x \\<in> set xs \\<Longrightarrow> x < oid\\<rbrakk>\n                \\<Longrightarrow> distinct (insert_spec xs (oid, ref));\n        distinct (a # xs);\n        \\<And>x. x \\<in> set (a # xs) \\<Longrightarrow> x < oid\\<rbrakk>\n       \\<Longrightarrow> distinct (insert_spec (a # xs) (oid, ref))", "show \"distinct (insert_spec [] (oid, ref))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (insert_spec [] (oid, ref))", "by(cases ref, auto)"], ["proof (state)\nthis:\n  distinct (insert_spec [] (oid, ref))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct xs;\n                 \\<And>x. x \\<in> set xs \\<Longrightarrow> x < oid\\<rbrakk>\n                \\<Longrightarrow> distinct (insert_spec xs (oid, ref));\n        distinct (a # xs);\n        \\<And>x. x \\<in> set (a # xs) \\<Longrightarrow> x < oid\\<rbrakk>\n       \\<Longrightarrow> distinct (insert_spec (a # xs) (oid, ref))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct xs;\n                 \\<And>x. x \\<in> set xs \\<Longrightarrow> x < oid\\<rbrakk>\n                \\<Longrightarrow> distinct (insert_spec xs (oid, ref));\n        distinct (a # xs);\n        \\<And>x. x \\<in> set (a # xs) \\<Longrightarrow> x < oid\\<rbrakk>\n       \\<Longrightarrow> distinct (insert_spec (a # xs) (oid, ref))", "fix a xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct xs;\n                 \\<And>x. x \\<in> set xs \\<Longrightarrow> x < oid\\<rbrakk>\n                \\<Longrightarrow> distinct (insert_spec xs (oid, ref));\n        distinct (a # xs);\n        \\<And>x. x \\<in> set (a # xs) \\<Longrightarrow> x < oid\\<rbrakk>\n       \\<Longrightarrow> distinct (insert_spec (a # xs) (oid, ref))", "assume IH: \"distinct xs \\<Longrightarrow> (\\<And>x. x \\<in> set xs \\<Longrightarrow> x < oid) \\<Longrightarrow> distinct (insert_spec xs (oid, ref))\"\n    and D: \"distinct (a#xs)\"\n    and L: \"\\<And>x. x \\<in> set (a#xs) \\<Longrightarrow> x < oid\""], ["proof (state)\nthis:\n  \\<lbrakk>distinct xs;\n   \\<And>x. x \\<in> set xs \\<Longrightarrow> x < oid\\<rbrakk>\n  \\<Longrightarrow> distinct (insert_spec xs (oid, ref))\n  distinct (a # xs)\n  ?x \\<in> set (a # xs) \\<Longrightarrow> ?x < oid\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct xs;\n                 \\<And>x. x \\<in> set xs \\<Longrightarrow> x < oid\\<rbrakk>\n                \\<Longrightarrow> distinct (insert_spec xs (oid, ref));\n        distinct (a # xs);\n        \\<And>x. x \\<in> set (a # xs) \\<Longrightarrow> x < oid\\<rbrakk>\n       \\<Longrightarrow> distinct (insert_spec (a # xs) (oid, ref))", "show \"distinct (insert_spec (a#xs) (oid, ref))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (insert_spec (a # xs) (oid, ref))", "proof(cases \"ref\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ref = None \\<Longrightarrow> distinct (insert_spec (a # xs) (oid, ref))\n 2. \\<And>aa.\n       ref = Some aa \\<Longrightarrow>\n       distinct (insert_spec (a # xs) (oid, ref))", "assume \"ref = None\""], ["proof (state)\nthis:\n  ref = None\n\ngoal (2 subgoals):\n 1. ref = None \\<Longrightarrow> distinct (insert_spec (a # xs) (oid, ref))\n 2. \\<And>aa.\n       ref = Some aa \\<Longrightarrow>\n       distinct (insert_spec (a # xs) (oid, ref))", "thus \"distinct (insert_spec (a#xs) (oid, ref))\""], ["proof (prove)\nusing this:\n  ref = None\n\ngoal (1 subgoal):\n 1. distinct (insert_spec (a # xs) (oid, ref))", "using D L"], ["proof (prove)\nusing this:\n  ref = None\n  distinct (a # xs)\n  ?x \\<in> set (a # xs) \\<Longrightarrow> ?x < oid\n\ngoal (1 subgoal):\n 1. distinct (insert_spec (a # xs) (oid, ref))", "by auto"], ["proof (state)\nthis:\n  distinct (insert_spec (a # xs) (oid, ref))\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       ref = Some aa \\<Longrightarrow>\n       distinct (insert_spec (a # xs) (oid, ref))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       ref = Some aa \\<Longrightarrow>\n       distinct (insert_spec (a # xs) (oid, ref))", "fix id"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       ref = Some aa \\<Longrightarrow>\n       distinct (insert_spec (a # xs) (oid, ref))", "assume S: \"ref = Some id\""], ["proof (state)\nthis:\n  ref = Some id\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       ref = Some aa \\<Longrightarrow>\n       distinct (insert_spec (a # xs) (oid, ref))", "{"], ["proof (state)\nthis:\n  ref = Some id\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       ref = Some aa \\<Longrightarrow>\n       distinct (insert_spec (a # xs) (oid, ref))", "assume EQ: \"a = id\""], ["proof (state)\nthis:\n  a = id\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       ref = Some aa \\<Longrightarrow>\n       distinct (insert_spec (a # xs) (oid, ref))", "hence \"id \\<noteq> oid\""], ["proof (prove)\nusing this:\n  a = id\n\ngoal (1 subgoal):\n 1. id \\<noteq> oid", "using D L"], ["proof (prove)\nusing this:\n  a = id\n  distinct (a # xs)\n  ?x \\<in> set (a # xs) \\<Longrightarrow> ?x < oid\n\ngoal (1 subgoal):\n 1. id \\<noteq> oid", "by auto"], ["proof (state)\nthis:\n  id \\<noteq> oid\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       ref = Some aa \\<Longrightarrow>\n       distinct (insert_spec (a # xs) (oid, ref))", "moreover"], ["proof (state)\nthis:\n  id \\<noteq> oid\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       ref = Some aa \\<Longrightarrow>\n       distinct (insert_spec (a # xs) (oid, ref))", "have \"id \\<notin> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id \\<notin> set xs", "using D EQ"], ["proof (prove)\nusing this:\n  distinct (a # xs)\n  a = id\n\ngoal (1 subgoal):\n 1. id \\<notin> set xs", "by auto"], ["proof (state)\nthis:\n  id \\<notin> set xs\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       ref = Some aa \\<Longrightarrow>\n       distinct (insert_spec (a # xs) (oid, ref))", "moreover"], ["proof (state)\nthis:\n  id \\<notin> set xs\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       ref = Some aa \\<Longrightarrow>\n       distinct (insert_spec (a # xs) (oid, ref))", "have \"oid \\<notin> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oid \\<notin> set xs", "using L"], ["proof (prove)\nusing this:\n  ?x \\<in> set (a # xs) \\<Longrightarrow> ?x < oid\n\ngoal (1 subgoal):\n 1. oid \\<notin> set xs", "by auto"], ["proof (state)\nthis:\n  oid \\<notin> set xs\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       ref = Some aa \\<Longrightarrow>\n       distinct (insert_spec (a # xs) (oid, ref))", "ultimately"], ["proof (chain)\npicking this:\n  id \\<noteq> oid\n  id \\<notin> set xs\n  oid \\<notin> set xs", "have \"id \\<noteq> oid \\<and> id \\<notin> set xs \\<and> oid \\<notin> set xs \\<and> distinct xs\""], ["proof (prove)\nusing this:\n  id \\<noteq> oid\n  id \\<notin> set xs\n  oid \\<notin> set xs\n\ngoal (1 subgoal):\n 1. id \\<noteq> oid \\<and>\n    id \\<notin> set xs \\<and> oid \\<notin> set xs \\<and> distinct xs", "using D"], ["proof (prove)\nusing this:\n  id \\<noteq> oid\n  id \\<notin> set xs\n  oid \\<notin> set xs\n  distinct (a # xs)\n\ngoal (1 subgoal):\n 1. id \\<noteq> oid \\<and>\n    id \\<notin> set xs \\<and> oid \\<notin> set xs \\<and> distinct xs", "by auto"], ["proof (state)\nthis:\n  id \\<noteq> oid \\<and>\n  id \\<notin> set xs \\<and> oid \\<notin> set xs \\<and> distinct xs\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       ref = Some aa \\<Longrightarrow>\n       distinct (insert_spec (a # xs) (oid, ref))", "}"], ["proof (state)\nthis:\n  a = id \\<Longrightarrow>\n  id \\<noteq> oid \\<and>\n  id \\<notin> set xs \\<and> oid \\<notin> set xs \\<and> distinct xs\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       ref = Some aa \\<Longrightarrow>\n       distinct (insert_spec (a # xs) (oid, ref))", "note T = this"], ["proof (state)\nthis:\n  a = id \\<Longrightarrow>\n  id \\<noteq> oid \\<and>\n  id \\<notin> set xs \\<and> oid \\<notin> set xs \\<and> distinct xs\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       ref = Some aa \\<Longrightarrow>\n       distinct (insert_spec (a # xs) (oid, ref))", "{"], ["proof (state)\nthis:\n  a = id \\<Longrightarrow>\n  id \\<noteq> oid \\<and>\n  id \\<notin> set xs \\<and> oid \\<notin> set xs \\<and> distinct xs\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       ref = Some aa \\<Longrightarrow>\n       distinct (insert_spec (a # xs) (oid, ref))", "assume NEQ: \"a \\<noteq> id\""], ["proof (state)\nthis:\n  a \\<noteq> id\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       ref = Some aa \\<Longrightarrow>\n       distinct (insert_spec (a # xs) (oid, ref))", "have 0: \"a \\<notin> set (insert_spec xs (oid, Some id))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> set (insert_spec xs (oid, Some id))", "using D L"], ["proof (prove)\nusing this:\n  distinct (a # xs)\n  ?x \\<in> set (a # xs) \\<Longrightarrow> ?x < oid\n\ngoal (1 subgoal):\n 1. a \\<notin> set (insert_spec xs (oid, Some id))", "by(metis distinct.simps(2) insert_spec.simps(1) insert_spec_none insert_spec_nonex\n            insert_spec_set insert_iff list.set(2) not_less_iff_gr_or_eq)"], ["proof (state)\nthis:\n  a \\<notin> set (insert_spec xs (oid, Some id))\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       ref = Some aa \\<Longrightarrow>\n       distinct (insert_spec (a # xs) (oid, ref))", "have 1: \"distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs", "using D"], ["proof (prove)\nusing this:\n  distinct (a # xs)\n\ngoal (1 subgoal):\n 1. distinct xs", "by auto"], ["proof (state)\nthis:\n  distinct xs\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       ref = Some aa \\<Longrightarrow>\n       distinct (insert_spec (a # xs) (oid, ref))", "have \"\\<And>x. x \\<in> set xs \\<Longrightarrow> x < oid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x < oid", "using L"], ["proof (prove)\nusing this:\n  ?x \\<in> set (a # xs) \\<Longrightarrow> ?x < oid\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set xs \\<Longrightarrow> x < oid", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> set xs \\<Longrightarrow> ?x < oid\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       ref = Some aa \\<Longrightarrow>\n       distinct (insert_spec (a # xs) (oid, ref))", "hence \"distinct (insert_spec xs (oid, Some id))\""], ["proof (prove)\nusing this:\n  ?x \\<in> set xs \\<Longrightarrow> ?x < oid\n\ngoal (1 subgoal):\n 1. distinct (insert_spec xs (oid, Some id))", "using S IH[OF 1]"], ["proof (prove)\nusing this:\n  ?x \\<in> set xs \\<Longrightarrow> ?x < oid\n  ref = Some id\n  (\\<And>x. x \\<in> set xs \\<Longrightarrow> x < oid) \\<Longrightarrow>\n  distinct (insert_spec xs (oid, ref))\n\ngoal (1 subgoal):\n 1. distinct (insert_spec xs (oid, Some id))", "by blast"], ["proof (state)\nthis:\n  distinct (insert_spec xs (oid, Some id))\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       ref = Some aa \\<Longrightarrow>\n       distinct (insert_spec (a # xs) (oid, ref))", "hence \"a \\<notin> set (insert_spec xs (oid, Some id)) \\<and> distinct (insert_spec xs (oid, Some id))\""], ["proof (prove)\nusing this:\n  distinct (insert_spec xs (oid, Some id))\n\ngoal (1 subgoal):\n 1. a \\<notin> set (insert_spec xs (oid, Some id)) \\<and>\n    distinct (insert_spec xs (oid, Some id))", "using 0"], ["proof (prove)\nusing this:\n  distinct (insert_spec xs (oid, Some id))\n  a \\<notin> set (insert_spec xs (oid, Some id))\n\ngoal (1 subgoal):\n 1. a \\<notin> set (insert_spec xs (oid, Some id)) \\<and>\n    distinct (insert_spec xs (oid, Some id))", "by auto"], ["proof (state)\nthis:\n  a \\<notin> set (insert_spec xs (oid, Some id)) \\<and>\n  distinct (insert_spec xs (oid, Some id))\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       ref = Some aa \\<Longrightarrow>\n       distinct (insert_spec (a # xs) (oid, ref))", "}"], ["proof (state)\nthis:\n  a \\<noteq> id \\<Longrightarrow>\n  a \\<notin> set (insert_spec xs (oid, Some id)) \\<and>\n  distinct (insert_spec xs (oid, Some id))\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       ref = Some aa \\<Longrightarrow>\n       distinct (insert_spec (a # xs) (oid, ref))", "from this S T"], ["proof (chain)\npicking this:\n  a \\<noteq> id \\<Longrightarrow>\n  a \\<notin> set (insert_spec xs (oid, Some id)) \\<and>\n  distinct (insert_spec xs (oid, Some id))\n  ref = Some id\n  a = id \\<Longrightarrow>\n  id \\<noteq> oid \\<and>\n  id \\<notin> set xs \\<and> oid \\<notin> set xs \\<and> distinct xs", "show \"distinct (insert_spec (a # xs) (oid, ref))\""], ["proof (prove)\nusing this:\n  a \\<noteq> id \\<Longrightarrow>\n  a \\<notin> set (insert_spec xs (oid, Some id)) \\<and>\n  distinct (insert_spec xs (oid, Some id))\n  ref = Some id\n  a = id \\<Longrightarrow>\n  id \\<noteq> oid \\<and>\n  id \\<notin> set xs \\<and> oid \\<notin> set xs \\<and> distinct xs\n\ngoal (1 subgoal):\n 1. distinct (insert_spec (a # xs) (oid, ref))", "by clarsimp"], ["proof (state)\nthis:\n  distinct (insert_spec (a # xs) (oid, ref))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (insert_spec (a # xs) (oid, ref))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_after_ref:\n  assumes \"distinct (xs @ ref # ys)\"\n  shows \"insert_spec (xs @ ref # ys) (oid, Some ref) = xs @ ref # oid # ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_spec (xs @ ref # ys) (oid, Some ref) = xs @ ref # oid # ys", "using assms"], ["proof (prove)\nusing this:\n  distinct (xs @ ref # ys)\n\ngoal (1 subgoal):\n 1. insert_spec (xs @ ref # ys) (oid, Some ref) = xs @ ref # oid # ys", "by (induction xs, auto)"], ["", "lemma insert_somewhere:\n  assumes \"ref = None \\<or> (ref = Some r \\<and> r \\<in> set list)\"\n  shows \"\\<exists>xs ys. list = xs @ ys \\<and> insert_spec list (oid, ref) = xs @ oid # ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       list = xs @ ys \\<and> insert_spec list (oid, ref) = xs @ oid # ys", "using assms"], ["proof (prove)\nusing this:\n  ref = None \\<or> ref = Some r \\<and> r \\<in> set list\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       list = xs @ ys \\<and> insert_spec list (oid, ref) = xs @ oid # ys", "proof(induction list)"], ["proof (state)\ngoal (2 subgoals):\n 1. ref = None \\<or> ref = Some r \\<and> r \\<in> set [] \\<Longrightarrow>\n    \\<exists>xs ys.\n       [] = xs @ ys \\<and> insert_spec [] (oid, ref) = xs @ oid # ys\n 2. \\<And>a list.\n       \\<lbrakk>ref = None \\<or>\n                ref = Some r \\<and> r \\<in> set list \\<Longrightarrow>\n                \\<exists>xs ys.\n                   list = xs @ ys \\<and>\n                   insert_spec list (oid, ref) = xs @ oid # ys;\n        ref = None \\<or> ref = Some r \\<and> r \\<in> set (a # list)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys.\n                            a # list = xs @ ys \\<and>\n                            insert_spec (a # list) (oid, ref) =\n                            xs @ oid # ys", "assume \"ref = None \\<or> ref = Some r \\<and> r \\<in> set []\""], ["proof (state)\nthis:\n  ref = None \\<or> ref = Some r \\<and> r \\<in> set []\n\ngoal (2 subgoals):\n 1. ref = None \\<or> ref = Some r \\<and> r \\<in> set [] \\<Longrightarrow>\n    \\<exists>xs ys.\n       [] = xs @ ys \\<and> insert_spec [] (oid, ref) = xs @ oid # ys\n 2. \\<And>a list.\n       \\<lbrakk>ref = None \\<or>\n                ref = Some r \\<and> r \\<in> set list \\<Longrightarrow>\n                \\<exists>xs ys.\n                   list = xs @ ys \\<and>\n                   insert_spec list (oid, ref) = xs @ oid # ys;\n        ref = None \\<or> ref = Some r \\<and> r \\<in> set (a # list)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys.\n                            a # list = xs @ ys \\<and>\n                            insert_spec (a # list) (oid, ref) =\n                            xs @ oid # ys", "thus \"\\<exists>xs ys. [] = xs @ ys \\<and> insert_spec [] (oid, ref) = xs @ oid # ys\""], ["proof (prove)\nusing this:\n  ref = None \\<or> ref = Some r \\<and> r \\<in> set []\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       [] = xs @ ys \\<and> insert_spec [] (oid, ref) = xs @ oid # ys", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ref = None \\<Longrightarrow>\n    \\<exists>xs ys.\n       [] = xs @ ys \\<and> insert_spec [] (oid, ref) = xs @ oid # ys\n 2. ref = Some r \\<and> r \\<in> set [] \\<Longrightarrow>\n    \\<exists>xs ys.\n       [] = xs @ ys \\<and> insert_spec [] (oid, ref) = xs @ oid # ys", "assume \"ref = None\""], ["proof (state)\nthis:\n  ref = None\n\ngoal (2 subgoals):\n 1. ref = None \\<Longrightarrow>\n    \\<exists>xs ys.\n       [] = xs @ ys \\<and> insert_spec [] (oid, ref) = xs @ oid # ys\n 2. ref = Some r \\<and> r \\<in> set [] \\<Longrightarrow>\n    \\<exists>xs ys.\n       [] = xs @ ys \\<and> insert_spec [] (oid, ref) = xs @ oid # ys", "thus \"\\<exists>xs ys. [] = xs @ ys \\<and> insert_spec [] (oid, ref) = xs @ oid # ys\""], ["proof (prove)\nusing this:\n  ref = None\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       [] = xs @ ys \\<and> insert_spec [] (oid, ref) = xs @ oid # ys", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs ys.\n     [] = xs @ ys \\<and> insert_spec [] (oid, ref) = xs @ oid # ys\n\ngoal (1 subgoal):\n 1. ref = Some r \\<and> r \\<in> set [] \\<Longrightarrow>\n    \\<exists>xs ys.\n       [] = xs @ ys \\<and> insert_spec [] (oid, ref) = xs @ oid # ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ref = Some r \\<and> r \\<in> set [] \\<Longrightarrow>\n    \\<exists>xs ys.\n       [] = xs @ ys \\<and> insert_spec [] (oid, ref) = xs @ oid # ys", "assume \"ref = Some r \\<and> r \\<in> set []\""], ["proof (state)\nthis:\n  ref = Some r \\<and> r \\<in> set []\n\ngoal (1 subgoal):\n 1. ref = Some r \\<and> r \\<in> set [] \\<Longrightarrow>\n    \\<exists>xs ys.\n       [] = xs @ ys \\<and> insert_spec [] (oid, ref) = xs @ oid # ys", "thus \"\\<exists>xs ys. [] = xs @ ys \\<and> insert_spec [] (oid, ref) = xs @ oid # ys\""], ["proof (prove)\nusing this:\n  ref = Some r \\<and> r \\<in> set []\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       [] = xs @ ys \\<and> insert_spec [] (oid, ref) = xs @ oid # ys", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs ys.\n     [] = xs @ ys \\<and> insert_spec [] (oid, ref) = xs @ oid # ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs ys.\n     [] = xs @ ys \\<and> insert_spec [] (oid, ref) = xs @ oid # ys\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ref = None \\<or>\n                ref = Some r \\<and> r \\<in> set list \\<Longrightarrow>\n                \\<exists>xs ys.\n                   list = xs @ ys \\<and>\n                   insert_spec list (oid, ref) = xs @ oid # ys;\n        ref = None \\<or> ref = Some r \\<and> r \\<in> set (a # list)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys.\n                            a # list = xs @ ys \\<and>\n                            insert_spec (a # list) (oid, ref) =\n                            xs @ oid # ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ref = None \\<or>\n                ref = Some r \\<and> r \\<in> set list \\<Longrightarrow>\n                \\<exists>xs ys.\n                   list = xs @ ys \\<and>\n                   insert_spec list (oid, ref) = xs @ oid # ys;\n        ref = None \\<or> ref = Some r \\<and> r \\<in> set (a # list)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys.\n                            a # list = xs @ ys \\<and>\n                            insert_spec (a # list) (oid, ref) =\n                            xs @ oid # ys", "fix a list"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ref = None \\<or>\n                ref = Some r \\<and> r \\<in> set list \\<Longrightarrow>\n                \\<exists>xs ys.\n                   list = xs @ ys \\<and>\n                   insert_spec list (oid, ref) = xs @ oid # ys;\n        ref = None \\<or> ref = Some r \\<and> r \\<in> set (a # list)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys.\n                            a # list = xs @ ys \\<and>\n                            insert_spec (a # list) (oid, ref) =\n                            xs @ oid # ys", "assume 1: \"ref = None \\<or> ref = Some r \\<and> r \\<in> set (a#list)\"\n    and IH: \"ref = None \\<or> ref = Some r \\<and> r \\<in> set list \\<Longrightarrow>\n         \\<exists>xs ys. list = xs @ ys \\<and> insert_spec list (oid, ref) = xs @ oid # ys\""], ["proof (state)\nthis:\n  ref = None \\<or> ref = Some r \\<and> r \\<in> set (a # list)\n  ref = None \\<or> ref = Some r \\<and> r \\<in> set list \\<Longrightarrow>\n  \\<exists>xs ys.\n     list = xs @ ys \\<and> insert_spec list (oid, ref) = xs @ oid # ys\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ref = None \\<or>\n                ref = Some r \\<and> r \\<in> set list \\<Longrightarrow>\n                \\<exists>xs ys.\n                   list = xs @ ys \\<and>\n                   insert_spec list (oid, ref) = xs @ oid # ys;\n        ref = None \\<or> ref = Some r \\<and> r \\<in> set (a # list)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys.\n                            a # list = xs @ ys \\<and>\n                            insert_spec (a # list) (oid, ref) =\n                            xs @ oid # ys", "show \"\\<exists>xs ys. a # list = xs @ ys \\<and> insert_spec (a # list) (oid, ref) = xs @ oid # ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       a # list = xs @ ys \\<and>\n       insert_spec (a # list) (oid, ref) = xs @ oid # ys", "proof(rule disjE[OF 1])"], ["proof (state)\ngoal (2 subgoals):\n 1. ref = None \\<Longrightarrow>\n    \\<exists>xs ys.\n       a # list = xs @ ys \\<and>\n       insert_spec (a # list) (oid, ref) = xs @ oid # ys\n 2. ref = Some r \\<and> r \\<in> set (a # list) \\<Longrightarrow>\n    \\<exists>xs ys.\n       a # list = xs @ ys \\<and>\n       insert_spec (a # list) (oid, ref) = xs @ oid # ys", "assume \"ref = None\""], ["proof (state)\nthis:\n  ref = None\n\ngoal (2 subgoals):\n 1. ref = None \\<Longrightarrow>\n    \\<exists>xs ys.\n       a # list = xs @ ys \\<and>\n       insert_spec (a # list) (oid, ref) = xs @ oid # ys\n 2. ref = Some r \\<and> r \\<in> set (a # list) \\<Longrightarrow>\n    \\<exists>xs ys.\n       a # list = xs @ ys \\<and>\n       insert_spec (a # list) (oid, ref) = xs @ oid # ys", "thus \"\\<exists>xs ys. a # list = xs @ ys \\<and> insert_spec (a # list) (oid, ref) = xs @ oid # ys\""], ["proof (prove)\nusing this:\n  ref = None\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       a # list = xs @ ys \\<and>\n       insert_spec (a # list) (oid, ref) = xs @ oid # ys", "by force"], ["proof (state)\nthis:\n  \\<exists>xs ys.\n     a # list = xs @ ys \\<and>\n     insert_spec (a # list) (oid, ref) = xs @ oid # ys\n\ngoal (1 subgoal):\n 1. ref = Some r \\<and> r \\<in> set (a # list) \\<Longrightarrow>\n    \\<exists>xs ys.\n       a # list = xs @ ys \\<and>\n       insert_spec (a # list) (oid, ref) = xs @ oid # ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ref = Some r \\<and> r \\<in> set (a # list) \\<Longrightarrow>\n    \\<exists>xs ys.\n       a # list = xs @ ys \\<and>\n       insert_spec (a # list) (oid, ref) = xs @ oid # ys", "assume \"ref = Some r \\<and> r \\<in> set (a # list)\""], ["proof (state)\nthis:\n  ref = Some r \\<and> r \\<in> set (a # list)\n\ngoal (1 subgoal):\n 1. ref = Some r \\<and> r \\<in> set (a # list) \\<Longrightarrow>\n    \\<exists>xs ys.\n       a # list = xs @ ys \\<and>\n       insert_spec (a # list) (oid, ref) = xs @ oid # ys", "hence 2: \"r = a \\<or> r \\<in> set list\" and 3: \"ref = Some r\""], ["proof (prove)\nusing this:\n  ref = Some r \\<and> r \\<in> set (a # list)\n\ngoal (1 subgoal):\n 1. r = a \\<or> r \\<in> set list &&& ref = Some r", "by auto"], ["proof (state)\nthis:\n  r = a \\<or> r \\<in> set list\n  ref = Some r\n\ngoal (1 subgoal):\n 1. ref = Some r \\<and> r \\<in> set (a # list) \\<Longrightarrow>\n    \\<exists>xs ys.\n       a # list = xs @ ys \\<and>\n       insert_spec (a # list) (oid, ref) = xs @ oid # ys", "show \"\\<exists>xs ys. a # list = xs @ ys \\<and> insert_spec (a # list) (oid, ref) = xs @ oid # ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       a # list = xs @ ys \\<and>\n       insert_spec (a # list) (oid, ref) = xs @ oid # ys", "proof(rule disjE[OF 2])"], ["proof (state)\ngoal (2 subgoals):\n 1. r = a \\<Longrightarrow>\n    \\<exists>xs ys.\n       a # list = xs @ ys \\<and>\n       insert_spec (a # list) (oid, ref) = xs @ oid # ys\n 2. r \\<in> set list \\<Longrightarrow>\n    \\<exists>xs ys.\n       a # list = xs @ ys \\<and>\n       insert_spec (a # list) (oid, ref) = xs @ oid # ys", "assume \"r = a\""], ["proof (state)\nthis:\n  r = a\n\ngoal (2 subgoals):\n 1. r = a \\<Longrightarrow>\n    \\<exists>xs ys.\n       a # list = xs @ ys \\<and>\n       insert_spec (a # list) (oid, ref) = xs @ oid # ys\n 2. r \\<in> set list \\<Longrightarrow>\n    \\<exists>xs ys.\n       a # list = xs @ ys \\<and>\n       insert_spec (a # list) (oid, ref) = xs @ oid # ys", "thus \"\\<exists>xs ys. a # list = xs @ ys \\<and> insert_spec (a # list) (oid, ref) = xs @ oid # ys\""], ["proof (prove)\nusing this:\n  r = a\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       a # list = xs @ ys \\<and>\n       insert_spec (a # list) (oid, ref) = xs @ oid # ys", "using 3"], ["proof (prove)\nusing this:\n  r = a\n  ref = Some r\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       a # list = xs @ ys \\<and>\n       insert_spec (a # list) (oid, ref) = xs @ oid # ys", "by(metis append_Cons append_Nil insert_spec.simps(3))"], ["proof (state)\nthis:\n  \\<exists>xs ys.\n     a # list = xs @ ys \\<and>\n     insert_spec (a # list) (oid, ref) = xs @ oid # ys\n\ngoal (1 subgoal):\n 1. r \\<in> set list \\<Longrightarrow>\n    \\<exists>xs ys.\n       a # list = xs @ ys \\<and>\n       insert_spec (a # list) (oid, ref) = xs @ oid # ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<in> set list \\<Longrightarrow>\n    \\<exists>xs ys.\n       a # list = xs @ ys \\<and>\n       insert_spec (a # list) (oid, ref) = xs @ oid # ys", "assume \"r \\<in> set list\""], ["proof (state)\nthis:\n  r \\<in> set list\n\ngoal (1 subgoal):\n 1. r \\<in> set list \\<Longrightarrow>\n    \\<exists>xs ys.\n       a # list = xs @ ys \\<and>\n       insert_spec (a # list) (oid, ref) = xs @ oid # ys", "from this"], ["proof (chain)\npicking this:\n  r \\<in> set list", "obtain xs ys\n        where \"list = xs @ ys \\<and> insert_spec list (oid, ref) = xs @ oid # ys\""], ["proof (prove)\nusing this:\n  r \\<in> set list\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        list = xs @ ys \\<and>\n        insert_spec list (oid, ref) = xs @ oid # ys \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using IH 3"], ["proof (prove)\nusing this:\n  r \\<in> set list\n  ref = None \\<or> ref = Some r \\<and> r \\<in> set list \\<Longrightarrow>\n  \\<exists>xs ys.\n     list = xs @ ys \\<and> insert_spec list (oid, ref) = xs @ oid # ys\n  ref = Some r\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        list = xs @ ys \\<and>\n        insert_spec list (oid, ref) = xs @ oid # ys \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  list = xs @ ys \\<and> insert_spec list (oid, ref) = xs @ oid # ys\n\ngoal (1 subgoal):\n 1. r \\<in> set list \\<Longrightarrow>\n    \\<exists>xs ys.\n       a # list = xs @ ys \\<and>\n       insert_spec (a # list) (oid, ref) = xs @ oid # ys", "thus \"\\<exists>xs ys. a # list = xs @ ys \\<and> insert_spec (a # list) (oid, ref) = xs @ oid # ys\""], ["proof (prove)\nusing this:\n  list = xs @ ys \\<and> insert_spec list (oid, ref) = xs @ oid # ys\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       a # list = xs @ ys \\<and>\n       insert_spec (a # list) (oid, ref) = xs @ oid # ys", "using 3"], ["proof (prove)\nusing this:\n  list = xs @ ys \\<and> insert_spec list (oid, ref) = xs @ oid # ys\n  ref = Some r\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys.\n       a # list = xs @ ys \\<and>\n       insert_spec (a # list) (oid, ref) = xs @ oid # ys", "by clarsimp (metis append_Cons append_Nil)"], ["proof (state)\nthis:\n  \\<exists>xs ys.\n     a # list = xs @ ys \\<and>\n     insert_spec (a # list) (oid, ref) = xs @ oid # ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs ys.\n     a # list = xs @ ys \\<and>\n     insert_spec (a # list) (oid, ref) = xs @ oid # ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs ys.\n     a # list = xs @ ys \\<and>\n     insert_spec (a # list) (oid, ref) = xs @ oid # ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_first_part:\n  assumes \"ref = None \\<or> (ref = Some r \\<and> r \\<in> set xs)\"\n  shows \"insert_spec (xs @ ys) (oid, ref) = (insert_spec xs (oid, ref)) @ ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_spec (xs @ ys) (oid, ref) = insert_spec xs (oid, ref) @ ys", "using assms"], ["proof (prove)\nusing this:\n  ref = None \\<or> ref = Some r \\<and> r \\<in> set xs\n\ngoal (1 subgoal):\n 1. insert_spec (xs @ ys) (oid, ref) = insert_spec xs (oid, ref) @ ys", "proof(induction ys rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. ref = None \\<or> ref = Some r \\<and> r \\<in> set xs \\<Longrightarrow>\n    insert_spec (xs @ []) (oid, ref) = insert_spec xs (oid, ref) @ []\n 2. \\<And>x xsa.\n       \\<lbrakk>ref = None \\<or>\n                ref = Some r \\<and> r \\<in> set xs \\<Longrightarrow>\n                insert_spec (xs @ xsa) (oid, ref) =\n                insert_spec xs (oid, ref) @ xsa;\n        ref = None \\<or> ref = Some r \\<and> r \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> insert_spec (xs @ xsa @ [x]) (oid, ref) =\n                         insert_spec xs (oid, ref) @ xsa @ [x]", "assume \"ref = None \\<or> ref = Some r \\<and> r \\<in> set xs\""], ["proof (state)\nthis:\n  ref = None \\<or> ref = Some r \\<and> r \\<in> set xs\n\ngoal (2 subgoals):\n 1. ref = None \\<or> ref = Some r \\<and> r \\<in> set xs \\<Longrightarrow>\n    insert_spec (xs @ []) (oid, ref) = insert_spec xs (oid, ref) @ []\n 2. \\<And>x xsa.\n       \\<lbrakk>ref = None \\<or>\n                ref = Some r \\<and> r \\<in> set xs \\<Longrightarrow>\n                insert_spec (xs @ xsa) (oid, ref) =\n                insert_spec xs (oid, ref) @ xsa;\n        ref = None \\<or> ref = Some r \\<and> r \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> insert_spec (xs @ xsa @ [x]) (oid, ref) =\n                         insert_spec xs (oid, ref) @ xsa @ [x]", "thus \"insert_spec (xs @ []) (oid, ref) = insert_spec xs (oid, ref) @ []\""], ["proof (prove)\nusing this:\n  ref = None \\<or> ref = Some r \\<and> r \\<in> set xs\n\ngoal (1 subgoal):\n 1. insert_spec (xs @ []) (oid, ref) = insert_spec xs (oid, ref) @ []", "by auto"], ["proof (state)\nthis:\n  insert_spec (xs @ []) (oid, ref) = insert_spec xs (oid, ref) @ []\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>ref = None \\<or>\n                ref = Some r \\<and> r \\<in> set xs \\<Longrightarrow>\n                insert_spec (xs @ xsa) (oid, ref) =\n                insert_spec xs (oid, ref) @ xsa;\n        ref = None \\<or> ref = Some r \\<and> r \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> insert_spec (xs @ xsa @ [x]) (oid, ref) =\n                         insert_spec xs (oid, ref) @ xsa @ [x]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>ref = None \\<or>\n                ref = Some r \\<and> r \\<in> set xs \\<Longrightarrow>\n                insert_spec (xs @ xsa) (oid, ref) =\n                insert_spec xs (oid, ref) @ xsa;\n        ref = None \\<or> ref = Some r \\<and> r \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> insert_spec (xs @ xsa @ [x]) (oid, ref) =\n                         insert_spec xs (oid, ref) @ xsa @ [x]", "fix x xsa"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>ref = None \\<or>\n                ref = Some r \\<and> r \\<in> set xs \\<Longrightarrow>\n                insert_spec (xs @ xsa) (oid, ref) =\n                insert_spec xs (oid, ref) @ xsa;\n        ref = None \\<or> ref = Some r \\<and> r \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> insert_spec (xs @ xsa @ [x]) (oid, ref) =\n                         insert_spec xs (oid, ref) @ xsa @ [x]", "assume IH: \"ref = None \\<or> ref = Some r \\<and> r \\<in> set xs \\<Longrightarrow> insert_spec (xs @ xsa) (oid, ref) = insert_spec xs (oid, ref) @ xsa\"\n    and \"ref = None \\<or> ref = Some r \\<and> r \\<in> set xs\""], ["proof (state)\nthis:\n  ref = None \\<or> ref = Some r \\<and> r \\<in> set xs \\<Longrightarrow>\n  insert_spec (xs @ xsa) (oid, ref) = insert_spec xs (oid, ref) @ xsa\n  ref = None \\<or> ref = Some r \\<and> r \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>ref = None \\<or>\n                ref = Some r \\<and> r \\<in> set xs \\<Longrightarrow>\n                insert_spec (xs @ xsa) (oid, ref) =\n                insert_spec xs (oid, ref) @ xsa;\n        ref = None \\<or> ref = Some r \\<and> r \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> insert_spec (xs @ xsa @ [x]) (oid, ref) =\n                         insert_spec xs (oid, ref) @ xsa @ [x]", "thus \"insert_spec (xs @ xsa @ [x]) (oid, ref) = insert_spec xs (oid, ref) @ xsa @ [x]\""], ["proof (prove)\nusing this:\n  ref = None \\<or> ref = Some r \\<and> r \\<in> set xs \\<Longrightarrow>\n  insert_spec (xs @ xsa) (oid, ref) = insert_spec xs (oid, ref) @ xsa\n  ref = None \\<or> ref = Some r \\<and> r \\<in> set xs\n\ngoal (1 subgoal):\n 1. insert_spec (xs @ xsa @ [x]) (oid, ref) =\n    insert_spec xs (oid, ref) @ xsa @ [x]", "proof(induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ref = None \\<or>\n             ref = Some r \\<and> r \\<in> set [] \\<Longrightarrow>\n             insert_spec ([] @ xsa) (oid, ref) =\n             insert_spec [] (oid, ref) @ xsa;\n     ref = None \\<or> ref = Some r \\<and> r \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> insert_spec ([] @ xsa @ [x]) (oid, ref) =\n                      insert_spec [] (oid, ref) @ xsa @ [x]\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>ref = None \\<or>\n                         ref = Some r \\<and>\n                         r \\<in> set xs \\<Longrightarrow>\n                         insert_spec (xs @ xsa) (oid, ref) =\n                         insert_spec xs (oid, ref) @ xsa;\n                 ref = None \\<or>\n                 ref = Some r \\<and> r \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> insert_spec (xs @ xsa @ [x]) (oid, ref) =\n                                  insert_spec xs (oid, ref) @ xsa @ [x];\n        ref = None \\<or>\n        ref = Some r \\<and> r \\<in> set (a # xs) \\<Longrightarrow>\n        insert_spec ((a # xs) @ xsa) (oid, ref) =\n        insert_spec (a # xs) (oid, ref) @ xsa;\n        ref = None \\<or> ref = Some r \\<and> r \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> insert_spec ((a # xs) @ xsa @ [x]) (oid, ref) =\n                         insert_spec (a # xs) (oid, ref) @ xsa @ [x]", "assume \"ref = None \\<or> ref = Some r \\<and> r \\<in> set []\""], ["proof (state)\nthis:\n  ref = None \\<or> ref = Some r \\<and> r \\<in> set []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ref = None \\<or>\n             ref = Some r \\<and> r \\<in> set [] \\<Longrightarrow>\n             insert_spec ([] @ xsa) (oid, ref) =\n             insert_spec [] (oid, ref) @ xsa;\n     ref = None \\<or> ref = Some r \\<and> r \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> insert_spec ([] @ xsa @ [x]) (oid, ref) =\n                      insert_spec [] (oid, ref) @ xsa @ [x]\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>ref = None \\<or>\n                         ref = Some r \\<and>\n                         r \\<in> set xs \\<Longrightarrow>\n                         insert_spec (xs @ xsa) (oid, ref) =\n                         insert_spec xs (oid, ref) @ xsa;\n                 ref = None \\<or>\n                 ref = Some r \\<and> r \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> insert_spec (xs @ xsa @ [x]) (oid, ref) =\n                                  insert_spec xs (oid, ref) @ xsa @ [x];\n        ref = None \\<or>\n        ref = Some r \\<and> r \\<in> set (a # xs) \\<Longrightarrow>\n        insert_spec ((a # xs) @ xsa) (oid, ref) =\n        insert_spec (a # xs) (oid, ref) @ xsa;\n        ref = None \\<or> ref = Some r \\<and> r \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> insert_spec ((a # xs) @ xsa @ [x]) (oid, ref) =\n                         insert_spec (a # xs) (oid, ref) @ xsa @ [x]", "thus \"insert_spec ([] @ xsa @ [x]) (oid, ref) = insert_spec [] (oid, ref) @ xsa @ [x]\""], ["proof (prove)\nusing this:\n  ref = None \\<or> ref = Some r \\<and> r \\<in> set []\n\ngoal (1 subgoal):\n 1. insert_spec ([] @ xsa @ [x]) (oid, ref) =\n    insert_spec [] (oid, ref) @ xsa @ [x]", "by auto"], ["proof (state)\nthis:\n  insert_spec ([] @ xsa @ [x]) (oid, ref) =\n  insert_spec [] (oid, ref) @ xsa @ [x]\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>ref = None \\<or>\n                         ref = Some r \\<and>\n                         r \\<in> set xs \\<Longrightarrow>\n                         insert_spec (xs @ xsa) (oid, ref) =\n                         insert_spec xs (oid, ref) @ xsa;\n                 ref = None \\<or>\n                 ref = Some r \\<and> r \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> insert_spec (xs @ xsa @ [x]) (oid, ref) =\n                                  insert_spec xs (oid, ref) @ xsa @ [x];\n        ref = None \\<or>\n        ref = Some r \\<and> r \\<in> set (a # xs) \\<Longrightarrow>\n        insert_spec ((a # xs) @ xsa) (oid, ref) =\n        insert_spec (a # xs) (oid, ref) @ xsa;\n        ref = None \\<or> ref = Some r \\<and> r \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> insert_spec ((a # xs) @ xsa @ [x]) (oid, ref) =\n                         insert_spec (a # xs) (oid, ref) @ xsa @ [x]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>ref = None \\<or>\n                         ref = Some r \\<and>\n                         r \\<in> set xs \\<Longrightarrow>\n                         insert_spec (xs @ xsa) (oid, ref) =\n                         insert_spec xs (oid, ref) @ xsa;\n                 ref = None \\<or>\n                 ref = Some r \\<and> r \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> insert_spec (xs @ xsa @ [x]) (oid, ref) =\n                                  insert_spec xs (oid, ref) @ xsa @ [x];\n        ref = None \\<or>\n        ref = Some r \\<and> r \\<in> set (a # xs) \\<Longrightarrow>\n        insert_spec ((a # xs) @ xsa) (oid, ref) =\n        insert_spec (a # xs) (oid, ref) @ xsa;\n        ref = None \\<or> ref = Some r \\<and> r \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> insert_spec ((a # xs) @ xsa @ [x]) (oid, ref) =\n                         insert_spec (a # xs) (oid, ref) @ xsa @ [x]", "fix a xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>ref = None \\<or>\n                         ref = Some r \\<and>\n                         r \\<in> set xs \\<Longrightarrow>\n                         insert_spec (xs @ xsa) (oid, ref) =\n                         insert_spec xs (oid, ref) @ xsa;\n                 ref = None \\<or>\n                 ref = Some r \\<and> r \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> insert_spec (xs @ xsa @ [x]) (oid, ref) =\n                                  insert_spec xs (oid, ref) @ xsa @ [x];\n        ref = None \\<or>\n        ref = Some r \\<and> r \\<in> set (a # xs) \\<Longrightarrow>\n        insert_spec ((a # xs) @ xsa) (oid, ref) =\n        insert_spec (a # xs) (oid, ref) @ xsa;\n        ref = None \\<or> ref = Some r \\<and> r \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> insert_spec ((a # xs) @ xsa @ [x]) (oid, ref) =\n                         insert_spec (a # xs) (oid, ref) @ xsa @ [x]", "assume 1: \"ref = None \\<or> ref = Some r \\<and> r \\<in> set (a # xs)\"\n      and 2: \"((ref = None \\<or> ref = Some r \\<and> r \\<in> set xs \\<Longrightarrow> insert_spec (xs @ xsa) (oid, ref) = insert_spec xs (oid, ref) @ xsa) \\<Longrightarrow>\n             ref = None \\<or> ref = Some r \\<and> r \\<in> set xs \\<Longrightarrow> insert_spec (xs @ xsa @ [x]) (oid, ref) = insert_spec xs (oid, ref) @ xsa @ [x])\"\n      and 3: \"(ref = None \\<or> ref = Some r \\<and> r \\<in> set (a # xs) \\<Longrightarrow> insert_spec ((a # xs) @ xsa) (oid, ref) = insert_spec (a # xs) (oid, ref) @ xsa)\""], ["proof (state)\nthis:\n  ref = None \\<or> ref = Some r \\<and> r \\<in> set (a # xs)\n  \\<lbrakk>ref = None \\<or>\n           ref = Some r \\<and> r \\<in> set xs \\<Longrightarrow>\n           insert_spec (xs @ xsa) (oid, ref) =\n           insert_spec xs (oid, ref) @ xsa;\n   ref = None \\<or> ref = Some r \\<and> r \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> insert_spec (xs @ xsa @ [x]) (oid, ref) =\n                    insert_spec xs (oid, ref) @ xsa @ [x]\n  ref = None \\<or>\n  ref = Some r \\<and> r \\<in> set (a # xs) \\<Longrightarrow>\n  insert_spec ((a # xs) @ xsa) (oid, ref) =\n  insert_spec (a # xs) (oid, ref) @ xsa\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>ref = None \\<or>\n                         ref = Some r \\<and>\n                         r \\<in> set xs \\<Longrightarrow>\n                         insert_spec (xs @ xsa) (oid, ref) =\n                         insert_spec xs (oid, ref) @ xsa;\n                 ref = None \\<or>\n                 ref = Some r \\<and> r \\<in> set xs\\<rbrakk>\n                \\<Longrightarrow> insert_spec (xs @ xsa @ [x]) (oid, ref) =\n                                  insert_spec xs (oid, ref) @ xsa @ [x];\n        ref = None \\<or>\n        ref = Some r \\<and> r \\<in> set (a # xs) \\<Longrightarrow>\n        insert_spec ((a # xs) @ xsa) (oid, ref) =\n        insert_spec (a # xs) (oid, ref) @ xsa;\n        ref = None \\<or> ref = Some r \\<and> r \\<in> set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> insert_spec ((a # xs) @ xsa @ [x]) (oid, ref) =\n                         insert_spec (a # xs) (oid, ref) @ xsa @ [x]", "show \"insert_spec ((a # xs) @ xsa @ [x]) (oid, ref) = insert_spec (a # xs) (oid, ref) @ xsa @ [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_spec ((a # xs) @ xsa @ [x]) (oid, ref) =\n    insert_spec (a # xs) (oid, ref) @ xsa @ [x]", "proof(rule disjE[OF 1])"], ["proof (state)\ngoal (2 subgoals):\n 1. ref = None \\<Longrightarrow>\n    insert_spec ((a # xs) @ xsa @ [x]) (oid, ref) =\n    insert_spec (a # xs) (oid, ref) @ xsa @ [x]\n 2. ref = Some r \\<and> r \\<in> set (a # xs) \\<Longrightarrow>\n    insert_spec ((a # xs) @ xsa @ [x]) (oid, ref) =\n    insert_spec (a # xs) (oid, ref) @ xsa @ [x]", "assume \"ref = None\""], ["proof (state)\nthis:\n  ref = None\n\ngoal (2 subgoals):\n 1. ref = None \\<Longrightarrow>\n    insert_spec ((a # xs) @ xsa @ [x]) (oid, ref) =\n    insert_spec (a # xs) (oid, ref) @ xsa @ [x]\n 2. ref = Some r \\<and> r \\<in> set (a # xs) \\<Longrightarrow>\n    insert_spec ((a # xs) @ xsa @ [x]) (oid, ref) =\n    insert_spec (a # xs) (oid, ref) @ xsa @ [x]", "thus \"insert_spec ((a # xs) @ xsa @ [x]) (oid, ref) = insert_spec (a # xs) (oid, ref) @ xsa @ [x]\""], ["proof (prove)\nusing this:\n  ref = None\n\ngoal (1 subgoal):\n 1. insert_spec ((a # xs) @ xsa @ [x]) (oid, ref) =\n    insert_spec (a # xs) (oid, ref) @ xsa @ [x]", "by auto"], ["proof (state)\nthis:\n  insert_spec ((a # xs) @ xsa @ [x]) (oid, ref) =\n  insert_spec (a # xs) (oid, ref) @ xsa @ [x]\n\ngoal (1 subgoal):\n 1. ref = Some r \\<and> r \\<in> set (a # xs) \\<Longrightarrow>\n    insert_spec ((a # xs) @ xsa @ [x]) (oid, ref) =\n    insert_spec (a # xs) (oid, ref) @ xsa @ [x]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ref = Some r \\<and> r \\<in> set (a # xs) \\<Longrightarrow>\n    insert_spec ((a # xs) @ xsa @ [x]) (oid, ref) =\n    insert_spec (a # xs) (oid, ref) @ xsa @ [x]", "assume \"ref = Some r \\<and> r \\<in> set (a # xs)\""], ["proof (state)\nthis:\n  ref = Some r \\<and> r \\<in> set (a # xs)\n\ngoal (1 subgoal):\n 1. ref = Some r \\<and> r \\<in> set (a # xs) \\<Longrightarrow>\n    insert_spec ((a # xs) @ xsa @ [x]) (oid, ref) =\n    insert_spec (a # xs) (oid, ref) @ xsa @ [x]", "thus \"insert_spec ((a # xs) @ xsa @ [x]) (oid, ref) = insert_spec (a # xs) (oid, ref) @ xsa @ [x]\""], ["proof (prove)\nusing this:\n  ref = Some r \\<and> r \\<in> set (a # xs)\n\ngoal (1 subgoal):\n 1. insert_spec ((a # xs) @ xsa @ [x]) (oid, ref) =\n    insert_spec (a # xs) (oid, ref) @ xsa @ [x]", "using 2 3"], ["proof (prove)\nusing this:\n  ref = Some r \\<and> r \\<in> set (a # xs)\n  \\<lbrakk>ref = None \\<or>\n           ref = Some r \\<and> r \\<in> set xs \\<Longrightarrow>\n           insert_spec (xs @ xsa) (oid, ref) =\n           insert_spec xs (oid, ref) @ xsa;\n   ref = None \\<or> ref = Some r \\<and> r \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> insert_spec (xs @ xsa @ [x]) (oid, ref) =\n                    insert_spec xs (oid, ref) @ xsa @ [x]\n  ref = None \\<or>\n  ref = Some r \\<and> r \\<in> set (a # xs) \\<Longrightarrow>\n  insert_spec ((a # xs) @ xsa) (oid, ref) =\n  insert_spec (a # xs) (oid, ref) @ xsa\n\ngoal (1 subgoal):\n 1. insert_spec ((a # xs) @ xsa @ [x]) (oid, ref) =\n    insert_spec (a # xs) (oid, ref) @ xsa @ [x]", "by auto"], ["proof (state)\nthis:\n  insert_spec ((a # xs) @ xsa @ [x]) (oid, ref) =\n  insert_spec (a # xs) (oid, ref) @ xsa @ [x]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  insert_spec ((a # xs) @ xsa @ [x]) (oid, ref) =\n  insert_spec (a # xs) (oid, ref) @ xsa @ [x]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  insert_spec (xs @ xsa @ [x]) (oid, ref) =\n  insert_spec xs (oid, ref) @ xsa @ [x]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_second_part:\n  assumes \"ref = Some r\"\n    and \"r \\<notin> set xs\"\n    and \"r \\<in> set ys\"\n  shows \"insert_spec (xs @ ys) (oid, ref) = xs @ (insert_spec ys (oid, ref))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_spec (xs @ ys) (oid, ref) = xs @ insert_spec ys (oid, ref)", "using assms"], ["proof (prove)\nusing this:\n  ref = Some r\n  r \\<notin> set xs\n  r \\<in> set ys\n\ngoal (1 subgoal):\n 1. insert_spec (xs @ ys) (oid, ref) = xs @ insert_spec ys (oid, ref)", "proof(induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ref = Some r; r \\<notin> set []; r \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> insert_spec ([] @ ys) (oid, ref) =\n                      [] @ insert_spec ys (oid, ref)\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>ref = Some r; r \\<notin> set xs;\n                 r \\<in> set ys\\<rbrakk>\n                \\<Longrightarrow> insert_spec (xs @ ys) (oid, ref) =\n                                  xs @ insert_spec ys (oid, ref);\n        ref = Some r; r \\<notin> set (a # xs); r \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> insert_spec ((a # xs) @ ys) (oid, ref) =\n                         (a # xs) @ insert_spec ys (oid, ref)", "assume \"ref = Some r\""], ["proof (state)\nthis:\n  ref = Some r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ref = Some r; r \\<notin> set []; r \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> insert_spec ([] @ ys) (oid, ref) =\n                      [] @ insert_spec ys (oid, ref)\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>ref = Some r; r \\<notin> set xs;\n                 r \\<in> set ys\\<rbrakk>\n                \\<Longrightarrow> insert_spec (xs @ ys) (oid, ref) =\n                                  xs @ insert_spec ys (oid, ref);\n        ref = Some r; r \\<notin> set (a # xs); r \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> insert_spec ((a # xs) @ ys) (oid, ref) =\n                         (a # xs) @ insert_spec ys (oid, ref)", "thus \"insert_spec ([] @ ys) (oid, ref) = [] @ insert_spec ys (oid, ref)\""], ["proof (prove)\nusing this:\n  ref = Some r\n\ngoal (1 subgoal):\n 1. insert_spec ([] @ ys) (oid, ref) = [] @ insert_spec ys (oid, ref)", "by auto"], ["proof (state)\nthis:\n  insert_spec ([] @ ys) (oid, ref) = [] @ insert_spec ys (oid, ref)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>ref = Some r; r \\<notin> set xs;\n                 r \\<in> set ys\\<rbrakk>\n                \\<Longrightarrow> insert_spec (xs @ ys) (oid, ref) =\n                                  xs @ insert_spec ys (oid, ref);\n        ref = Some r; r \\<notin> set (a # xs); r \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> insert_spec ((a # xs) @ ys) (oid, ref) =\n                         (a # xs) @ insert_spec ys (oid, ref)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>ref = Some r; r \\<notin> set xs;\n                 r \\<in> set ys\\<rbrakk>\n                \\<Longrightarrow> insert_spec (xs @ ys) (oid, ref) =\n                                  xs @ insert_spec ys (oid, ref);\n        ref = Some r; r \\<notin> set (a # xs); r \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> insert_spec ((a # xs) @ ys) (oid, ref) =\n                         (a # xs) @ insert_spec ys (oid, ref)", "fix a xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>ref = Some r; r \\<notin> set xs;\n                 r \\<in> set ys\\<rbrakk>\n                \\<Longrightarrow> insert_spec (xs @ ys) (oid, ref) =\n                                  xs @ insert_spec ys (oid, ref);\n        ref = Some r; r \\<notin> set (a # xs); r \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> insert_spec ((a # xs) @ ys) (oid, ref) =\n                         (a # xs) @ insert_spec ys (oid, ref)", "assume \"ref = Some r\" and \"r \\<notin> set (a # xs)\" and \"r \\<in> set ys\"\n    and \"ref = Some r \\<Longrightarrow> r \\<notin> set xs \\<Longrightarrow> r \\<in> set ys \\<Longrightarrow> insert_spec (xs @ ys) (oid, ref) = xs @ insert_spec ys (oid, ref)\""], ["proof (state)\nthis:\n  ref = Some r\n  r \\<notin> set (a # xs)\n  r \\<in> set ys\n  \\<lbrakk>ref = Some r; r \\<notin> set xs; r \\<in> set ys\\<rbrakk>\n  \\<Longrightarrow> insert_spec (xs @ ys) (oid, ref) =\n                    xs @ insert_spec ys (oid, ref)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>ref = Some r; r \\<notin> set xs;\n                 r \\<in> set ys\\<rbrakk>\n                \\<Longrightarrow> insert_spec (xs @ ys) (oid, ref) =\n                                  xs @ insert_spec ys (oid, ref);\n        ref = Some r; r \\<notin> set (a # xs); r \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> insert_spec ((a # xs) @ ys) (oid, ref) =\n                         (a # xs) @ insert_spec ys (oid, ref)", "thus \"insert_spec ((a # xs) @ ys) (oid, ref) = (a # xs) @ insert_spec ys (oid, ref)\""], ["proof (prove)\nusing this:\n  ref = Some r\n  r \\<notin> set (a # xs)\n  r \\<in> set ys\n  \\<lbrakk>ref = Some r; r \\<notin> set xs; r \\<in> set ys\\<rbrakk>\n  \\<Longrightarrow> insert_spec (xs @ ys) (oid, ref) =\n                    xs @ insert_spec ys (oid, ref)\n\ngoal (1 subgoal):\n 1. insert_spec ((a # xs) @ ys) (oid, ref) =\n    (a # xs) @ insert_spec ys (oid, ref)", "by auto"], ["proof (state)\nthis:\n  insert_spec ((a # xs) @ ys) (oid, ref) =\n  (a # xs) @ insert_spec ys (oid, ref)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Properties of the \\isa{interp-ins} function\\<close>"], ["", "lemma interp_ins_empty [simp]:\n  shows \"interp_ins [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interp_ins [] = []", "by (simp add: interp_ins_def)"], ["", "lemma interp_ins_tail_unfold:\n  shows \"interp_ins (xs @ [x]) = insert_spec (interp_ins xs) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interp_ins (xs @ [x]) = insert_spec (interp_ins xs) x", "by (clarsimp simp add: interp_ins_def)"], ["", "lemma interp_ins_subset [simp]:\n  shows \"set (interp_ins op_list) \\<subseteq> set (map fst op_list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (interp_ins op_list) \\<subseteq> set (map fst op_list)", "proof(induction op_list rule: List.rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. set (interp_ins []) \\<subseteq> set (map fst [])\n 2. \\<And>x xs.\n       set (interp_ins xs) \\<subseteq> set (map fst xs) \\<Longrightarrow>\n       set (interp_ins (xs @ [x])) \\<subseteq> set (map fst (xs @ [x]))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. set (interp_ins []) \\<subseteq> set (map fst [])\n 2. \\<And>x xs.\n       set (interp_ins xs) \\<subseteq> set (map fst xs) \\<Longrightarrow>\n       set (interp_ins (xs @ [x])) \\<subseteq> set (map fst (xs @ [x]))", "then"], ["proof (chain)\npicking this:", "show \"set (interp_ins []) \\<subseteq> set (map fst [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (interp_ins []) \\<subseteq> set (map fst [])", "by (simp add: interp_ins_def)"], ["proof (state)\nthis:\n  set (interp_ins []) \\<subseteq> set (map fst [])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       set (interp_ins xs) \\<subseteq> set (map fst xs) \\<Longrightarrow>\n       set (interp_ins (xs @ [x])) \\<subseteq> set (map fst (xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       set (interp_ins xs) \\<subseteq> set (map fst xs) \\<Longrightarrow>\n       set (interp_ins (xs @ [x])) \\<subseteq> set (map fst (xs @ [x]))", "case (snoc x xs)"], ["proof (state)\nthis:\n  set (interp_ins xs) \\<subseteq> set (map fst xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       set (interp_ins xs) \\<subseteq> set (map fst xs) \\<Longrightarrow>\n       set (interp_ins (xs @ [x])) \\<subseteq> set (map fst (xs @ [x]))", "hence IH: \"set (interp_ins xs) \\<subseteq> set (map fst xs)\""], ["proof (prove)\nusing this:\n  set (interp_ins xs) \\<subseteq> set (map fst xs)\n\ngoal (1 subgoal):\n 1. set (interp_ins xs) \\<subseteq> set (map fst xs)", "using interp_ins_def"], ["proof (prove)\nusing this:\n  set (interp_ins xs) \\<subseteq> set (map fst xs)\n  interp_ins ?ops \\<equiv> foldl insert_spec [] ?ops\n\ngoal (1 subgoal):\n 1. set (interp_ins xs) \\<subseteq> set (map fst xs)", "by blast"], ["proof (state)\nthis:\n  set (interp_ins xs) \\<subseteq> set (map fst xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       set (interp_ins xs) \\<subseteq> set (map fst xs) \\<Longrightarrow>\n       set (interp_ins (xs @ [x])) \\<subseteq> set (map fst (xs @ [x]))", "obtain oid ref where x_pair: \"x = (oid, ref)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>oid ref.\n        x = (oid, ref) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x = (oid, ref)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       set (interp_ins xs) \\<subseteq> set (map fst xs) \\<Longrightarrow>\n       set (interp_ins (xs @ [x])) \\<subseteq> set (map fst (xs @ [x]))", "hence spec: \"interp_ins (xs @ [x]) = insert_spec (interp_ins xs) (oid, ref)\""], ["proof (prove)\nusing this:\n  x = (oid, ref)\n\ngoal (1 subgoal):\n 1. interp_ins (xs @ [x]) = insert_spec (interp_ins xs) (oid, ref)", "by (simp add: interp_ins_def)"], ["proof (state)\nthis:\n  interp_ins (xs @ [x]) = insert_spec (interp_ins xs) (oid, ref)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       set (interp_ins xs) \\<subseteq> set (map fst xs) \\<Longrightarrow>\n       set (interp_ins (xs @ [x])) \\<subseteq> set (map fst (xs @ [x]))", "then"], ["proof (chain)\npicking this:\n  interp_ins (xs @ [x]) = insert_spec (interp_ins xs) (oid, ref)", "show \"set (interp_ins (xs @ [x])) \\<subseteq> set (map fst (xs @ [x]))\""], ["proof (prove)\nusing this:\n  interp_ins (xs @ [x]) = insert_spec (interp_ins xs) (oid, ref)\n\ngoal (1 subgoal):\n 1. set (interp_ins (xs @ [x])) \\<subseteq> set (map fst (xs @ [x]))", "proof(cases ref)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>interp_ins (xs @ [x]) = insert_spec (interp_ins xs) (oid, ref);\n     ref = None\\<rbrakk>\n    \\<Longrightarrow> set (interp_ins (xs @ [x]))\n                      \\<subseteq> set (map fst (xs @ [x]))\n 2. \\<And>a.\n       \\<lbrakk>interp_ins (xs @ [x]) =\n                insert_spec (interp_ins xs) (oid, ref);\n        ref = Some a\\<rbrakk>\n       \\<Longrightarrow> set (interp_ins (xs @ [x]))\n                         \\<subseteq> set (map fst (xs @ [x]))", "case None"], ["proof (state)\nthis:\n  ref = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>interp_ins (xs @ [x]) = insert_spec (interp_ins xs) (oid, ref);\n     ref = None\\<rbrakk>\n    \\<Longrightarrow> set (interp_ins (xs @ [x]))\n                      \\<subseteq> set (map fst (xs @ [x]))\n 2. \\<And>a.\n       \\<lbrakk>interp_ins (xs @ [x]) =\n                insert_spec (interp_ins xs) (oid, ref);\n        ref = Some a\\<rbrakk>\n       \\<Longrightarrow> set (interp_ins (xs @ [x]))\n                         \\<subseteq> set (map fst (xs @ [x]))", "then"], ["proof (chain)\npicking this:\n  ref = None", "show \"set (interp_ins (xs @ [x])) \\<subseteq> set (map fst (xs @ [x]))\""], ["proof (prove)\nusing this:\n  ref = None\n\ngoal (1 subgoal):\n 1. set (interp_ins (xs @ [x])) \\<subseteq> set (map fst (xs @ [x]))", "using IH spec x_pair"], ["proof (prove)\nusing this:\n  ref = None\n  set (interp_ins xs) \\<subseteq> set (map fst xs)\n  interp_ins (xs @ [x]) = insert_spec (interp_ins xs) (oid, ref)\n  x = (oid, ref)\n\ngoal (1 subgoal):\n 1. set (interp_ins (xs @ [x])) \\<subseteq> set (map fst (xs @ [x]))", "by auto"], ["proof (state)\nthis:\n  set (interp_ins (xs @ [x])) \\<subseteq> set (map fst (xs @ [x]))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>interp_ins (xs @ [x]) =\n                insert_spec (interp_ins xs) (oid, ref);\n        ref = Some a\\<rbrakk>\n       \\<Longrightarrow> set (interp_ins (xs @ [x]))\n                         \\<subseteq> set (map fst (xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>interp_ins (xs @ [x]) =\n                insert_spec (interp_ins xs) (oid, ref);\n        ref = Some a\\<rbrakk>\n       \\<Longrightarrow> set (interp_ins (xs @ [x]))\n                         \\<subseteq> set (map fst (xs @ [x]))", "case (Some a)"], ["proof (state)\nthis:\n  ref = Some a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>interp_ins (xs @ [x]) =\n                insert_spec (interp_ins xs) (oid, ref);\n        ref = Some a\\<rbrakk>\n       \\<Longrightarrow> set (interp_ins (xs @ [x]))\n                         \\<subseteq> set (map fst (xs @ [x]))", "then"], ["proof (chain)\npicking this:\n  ref = Some a", "show \"set (interp_ins (xs @ [x])) \\<subseteq> set (map fst (xs @ [x]))\""], ["proof (prove)\nusing this:\n  ref = Some a\n\ngoal (1 subgoal):\n 1. set (interp_ins (xs @ [x])) \\<subseteq> set (map fst (xs @ [x]))", "using IH spec x_pair"], ["proof (prove)\nusing this:\n  ref = Some a\n  set (interp_ins xs) \\<subseteq> set (map fst xs)\n  interp_ins (xs @ [x]) = insert_spec (interp_ins xs) (oid, ref)\n  x = (oid, ref)\n\ngoal (1 subgoal):\n 1. set (interp_ins (xs @ [x])) \\<subseteq> set (map fst (xs @ [x]))", "by (cases \"a \\<in> set (interp_ins xs)\", auto)"], ["proof (state)\nthis:\n  set (interp_ins (xs @ [x])) \\<subseteq> set (map fst (xs @ [x]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (interp_ins (xs @ [x])) \\<subseteq> set (map fst (xs @ [x]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma interp_ins_distinct:\n  assumes \"insert_ops op_list\"\n  shows \"distinct (interp_ins op_list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (interp_ins op_list)", "using assms"], ["proof (prove)\nusing this:\n  insert_ops op_list\n\ngoal (1 subgoal):\n 1. distinct (interp_ins op_list)", "proof(induction op_list rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. insert_ops [] \\<Longrightarrow> distinct (interp_ins [])\n 2. \\<And>x xs.\n       \\<lbrakk>insert_ops xs \\<Longrightarrow> distinct (interp_ins xs);\n        insert_ops (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> distinct (interp_ins (xs @ [x]))", "case Nil"], ["proof (state)\nthis:\n  insert_ops []\n\ngoal (2 subgoals):\n 1. insert_ops [] \\<Longrightarrow> distinct (interp_ins [])\n 2. \\<And>x xs.\n       \\<lbrakk>insert_ops xs \\<Longrightarrow> distinct (interp_ins xs);\n        insert_ops (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> distinct (interp_ins (xs @ [x]))", "then"], ["proof (chain)\npicking this:\n  insert_ops []", "show \"distinct (interp_ins [])\""], ["proof (prove)\nusing this:\n  insert_ops []\n\ngoal (1 subgoal):\n 1. distinct (interp_ins [])", "by (simp add: interp_ins_def)"], ["proof (state)\nthis:\n  distinct (interp_ins [])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>insert_ops xs \\<Longrightarrow> distinct (interp_ins xs);\n        insert_ops (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> distinct (interp_ins (xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>insert_ops xs \\<Longrightarrow> distinct (interp_ins xs);\n        insert_ops (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> distinct (interp_ins (xs @ [x]))", "case (snoc x xs)"], ["proof (state)\nthis:\n  insert_ops xs \\<Longrightarrow> distinct (interp_ins xs)\n  insert_ops (xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>insert_ops xs \\<Longrightarrow> distinct (interp_ins xs);\n        insert_ops (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> distinct (interp_ins (xs @ [x]))", "hence IH: \"distinct (interp_ins xs)\""], ["proof (prove)\nusing this:\n  insert_ops xs \\<Longrightarrow> distinct (interp_ins xs)\n  insert_ops (xs @ [x])\n\ngoal (1 subgoal):\n 1. distinct (interp_ins xs)", "by blast"], ["proof (state)\nthis:\n  distinct (interp_ins xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>insert_ops xs \\<Longrightarrow> distinct (interp_ins xs);\n        insert_ops (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> distinct (interp_ins (xs @ [x]))", "obtain oid ref where x_pair: \"x = (oid, ref)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>oid ref.\n        x = (oid, ref) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  x = (oid, ref)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>insert_ops xs \\<Longrightarrow> distinct (interp_ins xs);\n        insert_ops (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> distinct (interp_ins (xs @ [x]))", "hence \"\\<forall>x \\<in> set (map fst xs). x < oid\""], ["proof (prove)\nusing this:\n  x = (oid, ref)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map fst xs). x < oid", "using last_op_greatest snoc.prems"], ["proof (prove)\nusing this:\n  x = (oid, ref)\n  \\<lbrakk>insert_ops (?op_list @ [(?oid, ?oper)]);\n   ?x \\<in> set (map fst ?op_list)\\<rbrakk>\n  \\<Longrightarrow> ?x < ?oid\n  insert_ops (xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map fst xs). x < oid", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map fst xs). x < oid\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>insert_ops xs \\<Longrightarrow> distinct (interp_ins xs);\n        insert_ops (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> distinct (interp_ins (xs @ [x]))", "hence \"\\<forall>x \\<in> set (interp_ins xs). x < oid\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (map fst xs). x < oid\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (interp_ins xs). x < oid", "using interp_ins_subset"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (map fst xs). x < oid\n  set (interp_ins ?op_list) \\<subseteq> set (map fst ?op_list)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (interp_ins xs). x < oid", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (interp_ins xs). x < oid\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>insert_ops xs \\<Longrightarrow> distinct (interp_ins xs);\n        insert_ops (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> distinct (interp_ins (xs @ [x]))", "hence \"distinct (insert_spec (interp_ins xs) (oid, ref))\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (interp_ins xs). x < oid\n\ngoal (1 subgoal):\n 1. distinct (insert_spec (interp_ins xs) (oid, ref))", "using IH insert_spec_distinct insert_spec_nonex"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (interp_ins xs). x < oid\n  distinct (interp_ins xs)\n  \\<lbrakk>distinct ?xs;\n   \\<And>x. x \\<in> set ?xs \\<Longrightarrow> x < ?oid;\n   ?ref = Some ?r \\<longrightarrow> ?r < ?oid\\<rbrakk>\n  \\<Longrightarrow> distinct (insert_spec ?xs (?oid, ?ref))\n  ?ref \\<notin> set ?xs \\<Longrightarrow>\n  insert_spec ?xs (?oid, Some ?ref) = ?xs\n\ngoal (1 subgoal):\n 1. distinct (insert_spec (interp_ins xs) (oid, ref))", "by metis"], ["proof (state)\nthis:\n  distinct (insert_spec (interp_ins xs) (oid, ref))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>insert_ops xs \\<Longrightarrow> distinct (interp_ins xs);\n        insert_ops (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> distinct (interp_ins (xs @ [x]))", "then"], ["proof (chain)\npicking this:\n  distinct (insert_spec (interp_ins xs) (oid, ref))", "show \"distinct (interp_ins (xs @ [x]))\""], ["proof (prove)\nusing this:\n  distinct (insert_spec (interp_ins xs) (oid, ref))\n\ngoal (1 subgoal):\n 1. distinct (interp_ins (xs @ [x]))", "by (simp add: x_pair interp_ins_tail_unfold)"], ["proof (state)\nthis:\n  distinct (interp_ins (xs @ [x]))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Equivalence of the two definitions of insertion\\<close>"], ["", "text\\<open>At the beginning of this section we gave two different definitions of\ninterpretation functions for list insertion: \\isa{insert-spec} and\n\\isa{insert-alt}. In this section we prove that the two are equivalent.\n\nWe first define how to derive the successor relation from an Isabelle list.\nThis relation contains (\\isa{id}, \\isa{None}) if \\isa{id} is the last element\nof the list, and (\\isa{id1}, \\isa{id2}) if \\isa{id1} is immediately\nfollowed by \\isa{id2} in the list.\\<close>"], ["", "fun succ_rel :: \"'oid list \\<Rightarrow> ('oid \\<times> 'oid option) set\" where\n  \"succ_rel [] = {}\" |\n  \"succ_rel [head] = {(head, None)}\" |\n  \"succ_rel (head#x#xs) = {(head, Some x)} \\<union> succ_rel (x#xs)\""], ["", "text\\<open>\\isa{interp-alt} is the equivalent of \\isa{interp-ins}, but using\n\\isa{insert-alt} instead of \\isa{insert-spec}. To match the paper, it uses a\ndistinct head element to refer to the beginning of the list.\\<close>"], ["", "definition interp_alt :: \"'oid \\<Rightarrow> ('oid \\<times> 'oid option) list \\<Rightarrow> ('oid \\<times> 'oid option) set\" where\n  \"interp_alt head ops \\<equiv> foldl insert_alt {(head, None)}\n     (map (\\<lambda>x. case x of\n            (oid, None)     \\<Rightarrow> (oid, head) |\n            (oid, Some ref) \\<Rightarrow> (oid, ref)) \n      ops)\""], ["", "lemma succ_rel_set_fst:\n  shows \"fst ` (succ_rel xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` succ_rel xs = set xs", "by (induction xs rule: succ_rel.induct, auto)"], ["", "lemma succ_rel_functional:\n  assumes \"(a, b1) \\<in> succ_rel xs\"\n    and \"(a, b2) \\<in> succ_rel xs\"\n    and \"distinct xs\"\n  shows \"b1 = b2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b1 = b2", "using assms"], ["proof (prove)\nusing this:\n  (a, b1) \\<in> succ_rel xs\n  (a, b2) \\<in> succ_rel xs\n  distinct xs\n\ngoal (1 subgoal):\n 1. b1 = b2", "proof(induction xs rule: succ_rel.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>(a, b1) \\<in> succ_rel []; (a, b2) \\<in> succ_rel [];\n     distinct []\\<rbrakk>\n    \\<Longrightarrow> b1 = b2\n 2. \\<And>head.\n       \\<lbrakk>(a, b1) \\<in> succ_rel [head];\n        (a, b2) \\<in> succ_rel [head]; distinct [head]\\<rbrakk>\n       \\<Longrightarrow> b1 = b2\n 3. \\<And>head x xs.\n       \\<lbrakk>\\<lbrakk>(a, b1) \\<in> succ_rel (x # xs);\n                 (a, b2) \\<in> succ_rel (x # xs); distinct (x # xs)\\<rbrakk>\n                \\<Longrightarrow> b1 = b2;\n        (a, b1) \\<in> succ_rel (head # x # xs);\n        (a, b2) \\<in> succ_rel (head # x # xs);\n        distinct (head # x # xs)\\<rbrakk>\n       \\<Longrightarrow> b1 = b2", "case 1"], ["proof (state)\nthis:\n  (a, b1) \\<in> succ_rel []\n  (a, b2) \\<in> succ_rel []\n  distinct []\n\ngoal (3 subgoals):\n 1. \\<lbrakk>(a, b1) \\<in> succ_rel []; (a, b2) \\<in> succ_rel [];\n     distinct []\\<rbrakk>\n    \\<Longrightarrow> b1 = b2\n 2. \\<And>head.\n       \\<lbrakk>(a, b1) \\<in> succ_rel [head];\n        (a, b2) \\<in> succ_rel [head]; distinct [head]\\<rbrakk>\n       \\<Longrightarrow> b1 = b2\n 3. \\<And>head x xs.\n       \\<lbrakk>\\<lbrakk>(a, b1) \\<in> succ_rel (x # xs);\n                 (a, b2) \\<in> succ_rel (x # xs); distinct (x # xs)\\<rbrakk>\n                \\<Longrightarrow> b1 = b2;\n        (a, b1) \\<in> succ_rel (head # x # xs);\n        (a, b2) \\<in> succ_rel (head # x # xs);\n        distinct (head # x # xs)\\<rbrakk>\n       \\<Longrightarrow> b1 = b2", "then"], ["proof (chain)\npicking this:\n  (a, b1) \\<in> succ_rel []\n  (a, b2) \\<in> succ_rel []\n  distinct []", "show ?case"], ["proof (prove)\nusing this:\n  (a, b1) \\<in> succ_rel []\n  (a, b2) \\<in> succ_rel []\n  distinct []\n\ngoal (1 subgoal):\n 1. b1 = b2", "by simp"], ["proof (state)\nthis:\n  b1 = b2\n\ngoal (2 subgoals):\n 1. \\<And>head.\n       \\<lbrakk>(a, b1) \\<in> succ_rel [head];\n        (a, b2) \\<in> succ_rel [head]; distinct [head]\\<rbrakk>\n       \\<Longrightarrow> b1 = b2\n 2. \\<And>head x xs.\n       \\<lbrakk>\\<lbrakk>(a, b1) \\<in> succ_rel (x # xs);\n                 (a, b2) \\<in> succ_rel (x # xs); distinct (x # xs)\\<rbrakk>\n                \\<Longrightarrow> b1 = b2;\n        (a, b1) \\<in> succ_rel (head # x # xs);\n        (a, b2) \\<in> succ_rel (head # x # xs);\n        distinct (head # x # xs)\\<rbrakk>\n       \\<Longrightarrow> b1 = b2", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>head.\n       \\<lbrakk>(a, b1) \\<in> succ_rel [head];\n        (a, b2) \\<in> succ_rel [head]; distinct [head]\\<rbrakk>\n       \\<Longrightarrow> b1 = b2\n 2. \\<And>head x xs.\n       \\<lbrakk>\\<lbrakk>(a, b1) \\<in> succ_rel (x # xs);\n                 (a, b2) \\<in> succ_rel (x # xs); distinct (x # xs)\\<rbrakk>\n                \\<Longrightarrow> b1 = b2;\n        (a, b1) \\<in> succ_rel (head # x # xs);\n        (a, b2) \\<in> succ_rel (head # x # xs);\n        distinct (head # x # xs)\\<rbrakk>\n       \\<Longrightarrow> b1 = b2", "case (2 head)"], ["proof (state)\nthis:\n  (a, b1) \\<in> succ_rel [head]\n  (a, b2) \\<in> succ_rel [head]\n  distinct [head]\n\ngoal (2 subgoals):\n 1. \\<And>head.\n       \\<lbrakk>(a, b1) \\<in> succ_rel [head];\n        (a, b2) \\<in> succ_rel [head]; distinct [head]\\<rbrakk>\n       \\<Longrightarrow> b1 = b2\n 2. \\<And>head x xs.\n       \\<lbrakk>\\<lbrakk>(a, b1) \\<in> succ_rel (x # xs);\n                 (a, b2) \\<in> succ_rel (x # xs); distinct (x # xs)\\<rbrakk>\n                \\<Longrightarrow> b1 = b2;\n        (a, b1) \\<in> succ_rel (head # x # xs);\n        (a, b2) \\<in> succ_rel (head # x # xs);\n        distinct (head # x # xs)\\<rbrakk>\n       \\<Longrightarrow> b1 = b2", "then"], ["proof (chain)\npicking this:\n  (a, b1) \\<in> succ_rel [head]\n  (a, b2) \\<in> succ_rel [head]\n  distinct [head]", "show ?case"], ["proof (prove)\nusing this:\n  (a, b1) \\<in> succ_rel [head]\n  (a, b2) \\<in> succ_rel [head]\n  distinct [head]\n\ngoal (1 subgoal):\n 1. b1 = b2", "by simp"], ["proof (state)\nthis:\n  b1 = b2\n\ngoal (1 subgoal):\n 1. \\<And>head x xs.\n       \\<lbrakk>\\<lbrakk>(a, b1) \\<in> succ_rel (x # xs);\n                 (a, b2) \\<in> succ_rel (x # xs); distinct (x # xs)\\<rbrakk>\n                \\<Longrightarrow> b1 = b2;\n        (a, b1) \\<in> succ_rel (head # x # xs);\n        (a, b2) \\<in> succ_rel (head # x # xs);\n        distinct (head # x # xs)\\<rbrakk>\n       \\<Longrightarrow> b1 = b2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>head x xs.\n       \\<lbrakk>\\<lbrakk>(a, b1) \\<in> succ_rel (x # xs);\n                 (a, b2) \\<in> succ_rel (x # xs); distinct (x # xs)\\<rbrakk>\n                \\<Longrightarrow> b1 = b2;\n        (a, b1) \\<in> succ_rel (head # x # xs);\n        (a, b2) \\<in> succ_rel (head # x # xs);\n        distinct (head # x # xs)\\<rbrakk>\n       \\<Longrightarrow> b1 = b2", "case (3 head x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>(a, b1) \\<in> succ_rel (x # xs); (a, b2) \\<in> succ_rel (x # xs);\n   distinct (x # xs)\\<rbrakk>\n  \\<Longrightarrow> b1 = b2\n  (a, b1) \\<in> succ_rel (head # x # xs)\n  (a, b2) \\<in> succ_rel (head # x # xs)\n  distinct (head # x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>head x xs.\n       \\<lbrakk>\\<lbrakk>(a, b1) \\<in> succ_rel (x # xs);\n                 (a, b2) \\<in> succ_rel (x # xs); distinct (x # xs)\\<rbrakk>\n                \\<Longrightarrow> b1 = b2;\n        (a, b1) \\<in> succ_rel (head # x # xs);\n        (a, b2) \\<in> succ_rel (head # x # xs);\n        distinct (head # x # xs)\\<rbrakk>\n       \\<Longrightarrow> b1 = b2", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(a, b1) \\<in> succ_rel (x # xs); (a, b2) \\<in> succ_rel (x # xs);\n   distinct (x # xs)\\<rbrakk>\n  \\<Longrightarrow> b1 = b2\n  (a, b1) \\<in> succ_rel (head # x # xs)\n  (a, b2) \\<in> succ_rel (head # x # xs)\n  distinct (head # x # xs)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>(a, b1) \\<in> succ_rel (x # xs); (a, b2) \\<in> succ_rel (x # xs);\n   distinct (x # xs)\\<rbrakk>\n  \\<Longrightarrow> b1 = b2\n  (a, b1) \\<in> succ_rel (head # x # xs)\n  (a, b2) \\<in> succ_rel (head # x # xs)\n  distinct (head # x # xs)\n\ngoal (1 subgoal):\n 1. b1 = b2", "proof(cases \"a = head\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>(a, b1) \\<in> succ_rel (x # xs);\n              (a, b2) \\<in> succ_rel (x # xs); distinct (x # xs)\\<rbrakk>\n             \\<Longrightarrow> b1 = b2;\n     (a, b1) \\<in> succ_rel (head # x # xs);\n     (a, b2) \\<in> succ_rel (head # x # xs); distinct (head # x # xs);\n     a = head\\<rbrakk>\n    \\<Longrightarrow> b1 = b2\n 2. \\<lbrakk>\\<lbrakk>(a, b1) \\<in> succ_rel (x # xs);\n              (a, b2) \\<in> succ_rel (x # xs); distinct (x # xs)\\<rbrakk>\n             \\<Longrightarrow> b1 = b2;\n     (a, b1) \\<in> succ_rel (head # x # xs);\n     (a, b2) \\<in> succ_rel (head # x # xs); distinct (head # x # xs);\n     a \\<noteq> head\\<rbrakk>\n    \\<Longrightarrow> b1 = b2", "case True"], ["proof (state)\nthis:\n  a = head\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>(a, b1) \\<in> succ_rel (x # xs);\n              (a, b2) \\<in> succ_rel (x # xs); distinct (x # xs)\\<rbrakk>\n             \\<Longrightarrow> b1 = b2;\n     (a, b1) \\<in> succ_rel (head # x # xs);\n     (a, b2) \\<in> succ_rel (head # x # xs); distinct (head # x # xs);\n     a = head\\<rbrakk>\n    \\<Longrightarrow> b1 = b2\n 2. \\<lbrakk>\\<lbrakk>(a, b1) \\<in> succ_rel (x # xs);\n              (a, b2) \\<in> succ_rel (x # xs); distinct (x # xs)\\<rbrakk>\n             \\<Longrightarrow> b1 = b2;\n     (a, b1) \\<in> succ_rel (head # x # xs);\n     (a, b2) \\<in> succ_rel (head # x # xs); distinct (head # x # xs);\n     a \\<noteq> head\\<rbrakk>\n    \\<Longrightarrow> b1 = b2", "hence \"a \\<notin> set (x#xs)\""], ["proof (prove)\nusing this:\n  a = head\n\ngoal (1 subgoal):\n 1. a \\<notin> set (x # xs)", "using 3"], ["proof (prove)\nusing this:\n  a = head\n  \\<lbrakk>(a, b1) \\<in> succ_rel (x # xs); (a, b2) \\<in> succ_rel (x # xs);\n   distinct (x # xs)\\<rbrakk>\n  \\<Longrightarrow> b1 = b2\n  (a, b1) \\<in> succ_rel (head # x # xs)\n  (a, b2) \\<in> succ_rel (head # x # xs)\n  distinct (head # x # xs)\n\ngoal (1 subgoal):\n 1. a \\<notin> set (x # xs)", "by auto"], ["proof (state)\nthis:\n  a \\<notin> set (x # xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>(a, b1) \\<in> succ_rel (x # xs);\n              (a, b2) \\<in> succ_rel (x # xs); distinct (x # xs)\\<rbrakk>\n             \\<Longrightarrow> b1 = b2;\n     (a, b1) \\<in> succ_rel (head # x # xs);\n     (a, b2) \\<in> succ_rel (head # x # xs); distinct (head # x # xs);\n     a = head\\<rbrakk>\n    \\<Longrightarrow> b1 = b2\n 2. \\<lbrakk>\\<lbrakk>(a, b1) \\<in> succ_rel (x # xs);\n              (a, b2) \\<in> succ_rel (x # xs); distinct (x # xs)\\<rbrakk>\n             \\<Longrightarrow> b1 = b2;\n     (a, b1) \\<in> succ_rel (head # x # xs);\n     (a, b2) \\<in> succ_rel (head # x # xs); distinct (head # x # xs);\n     a \\<noteq> head\\<rbrakk>\n    \\<Longrightarrow> b1 = b2", "hence \"a \\<notin> fst ` (succ_rel (x#xs))\""], ["proof (prove)\nusing this:\n  a \\<notin> set (x # xs)\n\ngoal (1 subgoal):\n 1. a \\<notin> fst ` succ_rel (x # xs)", "using succ_rel_set_fst"], ["proof (prove)\nusing this:\n  a \\<notin> set (x # xs)\n  fst ` succ_rel ?xs = set ?xs\n\ngoal (1 subgoal):\n 1. a \\<notin> fst ` succ_rel (x # xs)", "by metis"], ["proof (state)\nthis:\n  a \\<notin> fst ` succ_rel (x # xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>(a, b1) \\<in> succ_rel (x # xs);\n              (a, b2) \\<in> succ_rel (x # xs); distinct (x # xs)\\<rbrakk>\n             \\<Longrightarrow> b1 = b2;\n     (a, b1) \\<in> succ_rel (head # x # xs);\n     (a, b2) \\<in> succ_rel (head # x # xs); distinct (head # x # xs);\n     a = head\\<rbrakk>\n    \\<Longrightarrow> b1 = b2\n 2. \\<lbrakk>\\<lbrakk>(a, b1) \\<in> succ_rel (x # xs);\n              (a, b2) \\<in> succ_rel (x # xs); distinct (x # xs)\\<rbrakk>\n             \\<Longrightarrow> b1 = b2;\n     (a, b1) \\<in> succ_rel (head # x # xs);\n     (a, b2) \\<in> succ_rel (head # x # xs); distinct (head # x # xs);\n     a \\<noteq> head\\<rbrakk>\n    \\<Longrightarrow> b1 = b2", "then"], ["proof (chain)\npicking this:\n  a \\<notin> fst ` succ_rel (x # xs)", "show \"b1 = b2\""], ["proof (prove)\nusing this:\n  a \\<notin> fst ` succ_rel (x # xs)\n\ngoal (1 subgoal):\n 1. b1 = b2", "using 3 image_iff"], ["proof (prove)\nusing this:\n  a \\<notin> fst ` succ_rel (x # xs)\n  \\<lbrakk>(a, b1) \\<in> succ_rel (x # xs); (a, b2) \\<in> succ_rel (x # xs);\n   distinct (x # xs)\\<rbrakk>\n  \\<Longrightarrow> b1 = b2\n  (a, b1) \\<in> succ_rel (head # x # xs)\n  (a, b2) \\<in> succ_rel (head # x # xs)\n  distinct (head # x # xs)\n  (?z \\<in> ?f ` ?A) = (\\<exists>x\\<in>?A. ?z = ?f x)\n\ngoal (1 subgoal):\n 1. b1 = b2", "by fastforce"], ["proof (state)\nthis:\n  b1 = b2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>(a, b1) \\<in> succ_rel (x # xs);\n              (a, b2) \\<in> succ_rel (x # xs); distinct (x # xs)\\<rbrakk>\n             \\<Longrightarrow> b1 = b2;\n     (a, b1) \\<in> succ_rel (head # x # xs);\n     (a, b2) \\<in> succ_rel (head # x # xs); distinct (head # x # xs);\n     a \\<noteq> head\\<rbrakk>\n    \\<Longrightarrow> b1 = b2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>(a, b1) \\<in> succ_rel (x # xs);\n              (a, b2) \\<in> succ_rel (x # xs); distinct (x # xs)\\<rbrakk>\n             \\<Longrightarrow> b1 = b2;\n     (a, b1) \\<in> succ_rel (head # x # xs);\n     (a, b2) \\<in> succ_rel (head # x # xs); distinct (head # x # xs);\n     a \\<noteq> head\\<rbrakk>\n    \\<Longrightarrow> b1 = b2", "case False"], ["proof (state)\nthis:\n  a \\<noteq> head\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>(a, b1) \\<in> succ_rel (x # xs);\n              (a, b2) \\<in> succ_rel (x # xs); distinct (x # xs)\\<rbrakk>\n             \\<Longrightarrow> b1 = b2;\n     (a, b1) \\<in> succ_rel (head # x # xs);\n     (a, b2) \\<in> succ_rel (head # x # xs); distinct (head # x # xs);\n     a \\<noteq> head\\<rbrakk>\n    \\<Longrightarrow> b1 = b2", "hence \"{(a, b1), (a, b2)} \\<subseteq> succ_rel (x#xs)\""], ["proof (prove)\nusing this:\n  a \\<noteq> head\n\ngoal (1 subgoal):\n 1. {(a, b1), (a, b2)} \\<subseteq> succ_rel (x # xs)", "using 3"], ["proof (prove)\nusing this:\n  a \\<noteq> head\n  \\<lbrakk>(a, b1) \\<in> succ_rel (x # xs); (a, b2) \\<in> succ_rel (x # xs);\n   distinct (x # xs)\\<rbrakk>\n  \\<Longrightarrow> b1 = b2\n  (a, b1) \\<in> succ_rel (head # x # xs)\n  (a, b2) \\<in> succ_rel (head # x # xs)\n  distinct (head # x # xs)\n\ngoal (1 subgoal):\n 1. {(a, b1), (a, b2)} \\<subseteq> succ_rel (x # xs)", "by auto"], ["proof (state)\nthis:\n  {(a, b1), (a, b2)} \\<subseteq> succ_rel (x # xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>(a, b1) \\<in> succ_rel (x # xs);\n              (a, b2) \\<in> succ_rel (x # xs); distinct (x # xs)\\<rbrakk>\n             \\<Longrightarrow> b1 = b2;\n     (a, b1) \\<in> succ_rel (head # x # xs);\n     (a, b2) \\<in> succ_rel (head # x # xs); distinct (head # x # xs);\n     a \\<noteq> head\\<rbrakk>\n    \\<Longrightarrow> b1 = b2", "moreover"], ["proof (state)\nthis:\n  {(a, b1), (a, b2)} \\<subseteq> succ_rel (x # xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>(a, b1) \\<in> succ_rel (x # xs);\n              (a, b2) \\<in> succ_rel (x # xs); distinct (x # xs)\\<rbrakk>\n             \\<Longrightarrow> b1 = b2;\n     (a, b1) \\<in> succ_rel (head # x # xs);\n     (a, b2) \\<in> succ_rel (head # x # xs); distinct (head # x # xs);\n     a \\<noteq> head\\<rbrakk>\n    \\<Longrightarrow> b1 = b2", "have \"distinct (x#xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (x # xs)", "using 3"], ["proof (prove)\nusing this:\n  \\<lbrakk>(a, b1) \\<in> succ_rel (x # xs); (a, b2) \\<in> succ_rel (x # xs);\n   distinct (x # xs)\\<rbrakk>\n  \\<Longrightarrow> b1 = b2\n  (a, b1) \\<in> succ_rel (head # x # xs)\n  (a, b2) \\<in> succ_rel (head # x # xs)\n  distinct (head # x # xs)\n\ngoal (1 subgoal):\n 1. distinct (x # xs)", "by auto"], ["proof (state)\nthis:\n  distinct (x # xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>(a, b1) \\<in> succ_rel (x # xs);\n              (a, b2) \\<in> succ_rel (x # xs); distinct (x # xs)\\<rbrakk>\n             \\<Longrightarrow> b1 = b2;\n     (a, b1) \\<in> succ_rel (head # x # xs);\n     (a, b2) \\<in> succ_rel (head # x # xs); distinct (head # x # xs);\n     a \\<noteq> head\\<rbrakk>\n    \\<Longrightarrow> b1 = b2", "ultimately"], ["proof (chain)\npicking this:\n  {(a, b1), (a, b2)} \\<subseteq> succ_rel (x # xs)\n  distinct (x # xs)", "show \"b1 = b2\""], ["proof (prove)\nusing this:\n  {(a, b1), (a, b2)} \\<subseteq> succ_rel (x # xs)\n  distinct (x # xs)\n\ngoal (1 subgoal):\n 1. b1 = b2", "using \"3.IH\""], ["proof (prove)\nusing this:\n  {(a, b1), (a, b2)} \\<subseteq> succ_rel (x # xs)\n  distinct (x # xs)\n  \\<lbrakk>(a, b1) \\<in> succ_rel (x # xs); (a, b2) \\<in> succ_rel (x # xs);\n   distinct (x # xs)\\<rbrakk>\n  \\<Longrightarrow> b1 = b2\n\ngoal (1 subgoal):\n 1. b1 = b2", "by auto"], ["proof (state)\nthis:\n  b1 = b2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b1 = b2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma succ_rel_rem_head:\n  assumes \"distinct (x # xs)\"\n  shows \"{(p, n) \\<in> succ_rel (x # xs). p \\<noteq> x} = succ_rel xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(p, n). (p, n) \\<in> succ_rel (x # xs) \\<and> p \\<noteq> x} =\n    succ_rel xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {(p, n). (p, n) \\<in> succ_rel (x # xs) \\<and> p \\<noteq> x} =\n    succ_rel xs", "have head_notin: \"x \\<notin> fst ` succ_rel xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> fst ` succ_rel xs", "using assms"], ["proof (prove)\nusing this:\n  distinct (x # xs)\n\ngoal (1 subgoal):\n 1. x \\<notin> fst ` succ_rel xs", "by (simp add: succ_rel_set_fst)"], ["proof (state)\nthis:\n  x \\<notin> fst ` succ_rel xs\n\ngoal (1 subgoal):\n 1. {(p, n). (p, n) \\<in> succ_rel (x # xs) \\<and> p \\<noteq> x} =\n    succ_rel xs", "moreover"], ["proof (state)\nthis:\n  x \\<notin> fst ` succ_rel xs\n\ngoal (1 subgoal):\n 1. {(p, n). (p, n) \\<in> succ_rel (x # xs) \\<and> p \\<noteq> x} =\n    succ_rel xs", "obtain y where \"(x, y) \\<in> succ_rel (x # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        (x, y) \\<in> succ_rel (x # xs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases xs, auto)"], ["proof (state)\nthis:\n  (x, y) \\<in> succ_rel (x # xs)\n\ngoal (1 subgoal):\n 1. {(p, n). (p, n) \\<in> succ_rel (x # xs) \\<and> p \\<noteq> x} =\n    succ_rel xs", "moreover"], ["proof (state)\nthis:\n  (x, y) \\<in> succ_rel (x # xs)\n\ngoal (1 subgoal):\n 1. {(p, n). (p, n) \\<in> succ_rel (x # xs) \\<and> p \\<noteq> x} =\n    succ_rel xs", "have \"succ_rel (x # xs) = {(x, y)} \\<union> succ_rel xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ_rel (x # xs) = {(x, y)} \\<union> succ_rel xs", "using calculation head_notin image_iff"], ["proof (prove)\nusing this:\n  x \\<notin> fst ` succ_rel xs\n  (x, y) \\<in> succ_rel (x # xs)\n  x \\<notin> fst ` succ_rel xs\n  (?z \\<in> ?f ` ?A) = (\\<exists>x\\<in>?A. ?z = ?f x)\n\ngoal (1 subgoal):\n 1. succ_rel (x # xs) = {(x, y)} \\<union> succ_rel xs", "by (cases xs, fastforce+)"], ["proof (state)\nthis:\n  succ_rel (x # xs) = {(x, y)} \\<union> succ_rel xs\n\ngoal (1 subgoal):\n 1. {(p, n). (p, n) \\<in> succ_rel (x # xs) \\<and> p \\<noteq> x} =\n    succ_rel xs", "moreover"], ["proof (state)\nthis:\n  succ_rel (x # xs) = {(x, y)} \\<union> succ_rel xs\n\ngoal (1 subgoal):\n 1. {(p, n). (p, n) \\<in> succ_rel (x # xs) \\<and> p \\<noteq> x} =\n    succ_rel xs", "from this"], ["proof (chain)\npicking this:\n  succ_rel (x # xs) = {(x, y)} \\<union> succ_rel xs", "have \"\\<And>n. (x, n) \\<in> succ_rel (x # xs) \\<Longrightarrow> n = y\""], ["proof (prove)\nusing this:\n  succ_rel (x # xs) = {(x, y)} \\<union> succ_rel xs\n\ngoal (1 subgoal):\n 1. \\<And>n. (x, n) \\<in> succ_rel (x # xs) \\<Longrightarrow> n = y", "by (metis Pair_inject fst_conv head_notin image_eqI insertE insert_is_Un)"], ["proof (state)\nthis:\n  (x, ?n) \\<in> succ_rel (x # xs) \\<Longrightarrow> ?n = y\n\ngoal (1 subgoal):\n 1. {(p, n). (p, n) \\<in> succ_rel (x # xs) \\<and> p \\<noteq> x} =\n    succ_rel xs", "hence \"{(p, n) \\<in> succ_rel (x # xs). p \\<noteq> x} = succ_rel (x # xs) - {(x, y)}\""], ["proof (prove)\nusing this:\n  (x, ?n) \\<in> succ_rel (x # xs) \\<Longrightarrow> ?n = y\n\ngoal (1 subgoal):\n 1. {(p, n). (p, n) \\<in> succ_rel (x # xs) \\<and> p \\<noteq> x} =\n    succ_rel (x # xs) - {(x, y)}", "by blast"], ["proof (state)\nthis:\n  {(p, n). (p, n) \\<in> succ_rel (x # xs) \\<and> p \\<noteq> x} =\n  succ_rel (x # xs) - {(x, y)}\n\ngoal (1 subgoal):\n 1. {(p, n). (p, n) \\<in> succ_rel (x # xs) \\<and> p \\<noteq> x} =\n    succ_rel xs", "moreover"], ["proof (state)\nthis:\n  {(p, n). (p, n) \\<in> succ_rel (x # xs) \\<and> p \\<noteq> x} =\n  succ_rel (x # xs) - {(x, y)}\n\ngoal (1 subgoal):\n 1. {(p, n). (p, n) \\<in> succ_rel (x # xs) \\<and> p \\<noteq> x} =\n    succ_rel xs", "have \"succ_rel (x # xs) - {(x, y)} = succ_rel xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ_rel (x # xs) - {(x, y)} = succ_rel xs", "using image_iff calculation"], ["proof (prove)\nusing this:\n  (?z \\<in> ?f ` ?A) = (\\<exists>x\\<in>?A. ?z = ?f x)\n  x \\<notin> fst ` succ_rel xs\n  (x, y) \\<in> succ_rel (x # xs)\n  succ_rel (x # xs) = {(x, y)} \\<union> succ_rel xs\n  {(p, n). (p, n) \\<in> succ_rel (x # xs) \\<and> p \\<noteq> x} =\n  succ_rel (x # xs) - {(x, y)}\n\ngoal (1 subgoal):\n 1. succ_rel (x # xs) - {(x, y)} = succ_rel xs", "by fastforce"], ["proof (state)\nthis:\n  succ_rel (x # xs) - {(x, y)} = succ_rel xs\n\ngoal (1 subgoal):\n 1. {(p, n). (p, n) \\<in> succ_rel (x # xs) \\<and> p \\<noteq> x} =\n    succ_rel xs", "ultimately"], ["proof (chain)\npicking this:\n  x \\<notin> fst ` succ_rel xs\n  (x, y) \\<in> succ_rel (x # xs)\n  succ_rel (x # xs) = {(x, y)} \\<union> succ_rel xs\n  {(p, n). (p, n) \\<in> succ_rel (x # xs) \\<and> p \\<noteq> x} =\n  succ_rel (x # xs) - {(x, y)}\n  succ_rel (x # xs) - {(x, y)} = succ_rel xs", "show \"{(p, n) \\<in> succ_rel (x # xs). p \\<noteq> x} = succ_rel xs\""], ["proof (prove)\nusing this:\n  x \\<notin> fst ` succ_rel xs\n  (x, y) \\<in> succ_rel (x # xs)\n  succ_rel (x # xs) = {(x, y)} \\<union> succ_rel xs\n  {(p, n). (p, n) \\<in> succ_rel (x # xs) \\<and> p \\<noteq> x} =\n  succ_rel (x # xs) - {(x, y)}\n  succ_rel (x # xs) - {(x, y)} = succ_rel xs\n\ngoal (1 subgoal):\n 1. {(p, n). (p, n) \\<in> succ_rel (x # xs) \\<and> p \\<noteq> x} =\n    succ_rel xs", "by simp"], ["proof (state)\nthis:\n  {(p, n). (p, n) \\<in> succ_rel (x # xs) \\<and> p \\<noteq> x} = succ_rel xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma succ_rel_swap_head:\n  assumes \"distinct (ref # list)\"\n    and \"(ref, n) \\<in> succ_rel (ref # list)\"\n  shows \"succ_rel (oid # list) = {(oid, n)} \\<union> succ_rel list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ_rel (oid # list) = {(oid, n)} \\<union> succ_rel list", "proof(cases list)"], ["proof (state)\ngoal (2 subgoals):\n 1. list = [] \\<Longrightarrow>\n    succ_rel (oid # list) = {(oid, n)} \\<union> succ_rel list\n 2. \\<And>a lista.\n       list = a # lista \\<Longrightarrow>\n       succ_rel (oid # list) = {(oid, n)} \\<union> succ_rel list", "case Nil"], ["proof (state)\nthis:\n  list = []\n\ngoal (2 subgoals):\n 1. list = [] \\<Longrightarrow>\n    succ_rel (oid # list) = {(oid, n)} \\<union> succ_rel list\n 2. \\<And>a lista.\n       list = a # lista \\<Longrightarrow>\n       succ_rel (oid # list) = {(oid, n)} \\<union> succ_rel list", "then"], ["proof (chain)\npicking this:\n  list = []", "show ?thesis"], ["proof (prove)\nusing this:\n  list = []\n\ngoal (1 subgoal):\n 1. succ_rel (oid # list) = {(oid, n)} \\<union> succ_rel list", "using assms"], ["proof (prove)\nusing this:\n  list = []\n  distinct (ref # list)\n  (ref, n) \\<in> succ_rel (ref # list)\n\ngoal (1 subgoal):\n 1. succ_rel (oid # list) = {(oid, n)} \\<union> succ_rel list", "by auto"], ["proof (state)\nthis:\n  succ_rel (oid # list) = {(oid, n)} \\<union> succ_rel list\n\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       list = a # lista \\<Longrightarrow>\n       succ_rel (oid # list) = {(oid, n)} \\<union> succ_rel list", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       list = a # lista \\<Longrightarrow>\n       succ_rel (oid # list) = {(oid, n)} \\<union> succ_rel list", "case (Cons a list)"], ["proof (state)\nthis:\n  list = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       list = a # lista \\<Longrightarrow>\n       succ_rel (oid # list) = {(oid, n)} \\<union> succ_rel list", "moreover"], ["proof (state)\nthis:\n  list = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       list = a # lista \\<Longrightarrow>\n       succ_rel (oid # list) = {(oid, n)} \\<union> succ_rel list", "from this"], ["proof (chain)\npicking this:\n  list = a # list", "have \"n = Some a\""], ["proof (prove)\nusing this:\n  list = a # list\n\ngoal (1 subgoal):\n 1. n = Some a", "by (metis Un_iff assms singletonI succ_rel.simps(3) succ_rel_functional)"], ["proof (state)\nthis:\n  n = Some a\n\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       list = a # lista \\<Longrightarrow>\n       succ_rel (oid # list) = {(oid, n)} \\<union> succ_rel list", "ultimately"], ["proof (chain)\npicking this:\n  list = a # list\n  n = Some a", "show ?thesis"], ["proof (prove)\nusing this:\n  list = a # list\n  n = Some a\n\ngoal (1 subgoal):\n 1. succ_rel (oid # list) = {(oid, n)} \\<union> succ_rel list", "by simp"], ["proof (state)\nthis:\n  succ_rel (oid # list) = {(oid, n)} \\<union> succ_rel list\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma succ_rel_insert_alt:\n  assumes \"a \\<noteq> ref\"\n    and \"distinct (oid # a # b # list)\"\n  shows \"insert_alt (succ_rel (a # b # list)) (oid, ref) =\n         {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_alt (succ_rel (a # b # list)) (oid, ref) =\n    {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)", "proof(cases \"\\<exists>n. (ref, n) \\<in> succ_rel (a # b # list)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>n. (ref, n) \\<in> succ_rel (a # b # list) \\<Longrightarrow>\n    insert_alt (succ_rel (a # b # list)) (oid, ref) =\n    {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)\n 2. \\<nexists>n. (ref, n) \\<in> succ_rel (a # b # list) \\<Longrightarrow>\n    insert_alt (succ_rel (a # b # list)) (oid, ref) =\n    {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)", "case True"], ["proof (state)\nthis:\n  \\<exists>n. (ref, n) \\<in> succ_rel (a # b # list)\n\ngoal (2 subgoals):\n 1. \\<exists>n. (ref, n) \\<in> succ_rel (a # b # list) \\<Longrightarrow>\n    insert_alt (succ_rel (a # b # list)) (oid, ref) =\n    {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)\n 2. \\<nexists>n. (ref, n) \\<in> succ_rel (a # b # list) \\<Longrightarrow>\n    insert_alt (succ_rel (a # b # list)) (oid, ref) =\n    {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)", "hence \"insert_alt (succ_rel (a # b # list)) (oid, ref) =\n           {(p, n) \\<in> succ_rel (a # b # list). p \\<noteq> ref} \\<union> {(ref, Some oid)} \\<union>\n           {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (a # b # list)}\""], ["proof (prove)\nusing this:\n  \\<exists>n. (ref, n) \\<in> succ_rel (a # b # list)\n\ngoal (1 subgoal):\n 1. insert_alt (succ_rel (a # b # list)) (oid, ref) =\n    {(p, n).\n     (p, n) \\<in> succ_rel (a # b # list) \\<and> p \\<noteq> ref} \\<union>\n    {(ref, Some oid)} \\<union>\n    {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (a # b # list)}", "by simp"], ["proof (state)\nthis:\n  insert_alt (succ_rel (a # b # list)) (oid, ref) =\n  {(p, n).\n   (p, n) \\<in> succ_rel (a # b # list) \\<and> p \\<noteq> ref} \\<union>\n  {(ref, Some oid)} \\<union>\n  {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (a # b # list)}\n\ngoal (2 subgoals):\n 1. \\<exists>n. (ref, n) \\<in> succ_rel (a # b # list) \\<Longrightarrow>\n    insert_alt (succ_rel (a # b # list)) (oid, ref) =\n    {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)\n 2. \\<nexists>n. (ref, n) \\<in> succ_rel (a # b # list) \\<Longrightarrow>\n    insert_alt (succ_rel (a # b # list)) (oid, ref) =\n    {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)", "moreover"], ["proof (state)\nthis:\n  insert_alt (succ_rel (a # b # list)) (oid, ref) =\n  {(p, n).\n   (p, n) \\<in> succ_rel (a # b # list) \\<and> p \\<noteq> ref} \\<union>\n  {(ref, Some oid)} \\<union>\n  {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (a # b # list)}\n\ngoal (2 subgoals):\n 1. \\<exists>n. (ref, n) \\<in> succ_rel (a # b # list) \\<Longrightarrow>\n    insert_alt (succ_rel (a # b # list)) (oid, ref) =\n    {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)\n 2. \\<nexists>n. (ref, n) \\<in> succ_rel (a # b # list) \\<Longrightarrow>\n    insert_alt (succ_rel (a # b # list)) (oid, ref) =\n    {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)", "have \"{(p, n) \\<in> succ_rel (a # b # list). p \\<noteq> ref} =\n                 {(a, Some b)} \\<union> {(p, n) \\<in> succ_rel (b # list). p \\<noteq> ref}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(p, n). (p, n) \\<in> succ_rel (a # b # list) \\<and> p \\<noteq> ref} =\n    {(a, Some b)} \\<union>\n    {(p, n). (p, n) \\<in> succ_rel (b # list) \\<and> p \\<noteq> ref}", "using assms(1)"], ["proof (prove)\nusing this:\n  a \\<noteq> ref\n\ngoal (1 subgoal):\n 1. {(p, n). (p, n) \\<in> succ_rel (a # b # list) \\<and> p \\<noteq> ref} =\n    {(a, Some b)} \\<union>\n    {(p, n). (p, n) \\<in> succ_rel (b # list) \\<and> p \\<noteq> ref}", "by auto"], ["proof (state)\nthis:\n  {(p, n). (p, n) \\<in> succ_rel (a # b # list) \\<and> p \\<noteq> ref} =\n  {(a, Some b)} \\<union>\n  {(p, n). (p, n) \\<in> succ_rel (b # list) \\<and> p \\<noteq> ref}\n\ngoal (2 subgoals):\n 1. \\<exists>n. (ref, n) \\<in> succ_rel (a # b # list) \\<Longrightarrow>\n    insert_alt (succ_rel (a # b # list)) (oid, ref) =\n    {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)\n 2. \\<nexists>n. (ref, n) \\<in> succ_rel (a # b # list) \\<Longrightarrow>\n    insert_alt (succ_rel (a # b # list)) (oid, ref) =\n    {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)", "moreover"], ["proof (state)\nthis:\n  {(p, n). (p, n) \\<in> succ_rel (a # b # list) \\<and> p \\<noteq> ref} =\n  {(a, Some b)} \\<union>\n  {(p, n). (p, n) \\<in> succ_rel (b # list) \\<and> p \\<noteq> ref}\n\ngoal (2 subgoals):\n 1. \\<exists>n. (ref, n) \\<in> succ_rel (a # b # list) \\<Longrightarrow>\n    insert_alt (succ_rel (a # b # list)) (oid, ref) =\n    {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)\n 2. \\<nexists>n. (ref, n) \\<in> succ_rel (a # b # list) \\<Longrightarrow>\n    insert_alt (succ_rel (a # b # list)) (oid, ref) =\n    {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)", "have \"insert_alt (succ_rel (b # list)) (oid, ref) =\n           {(p, n) \\<in> succ_rel (b # list). p \\<noteq> ref} \\<union> {(ref, Some oid)} \\<union>\n           {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (b # list)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_alt (succ_rel (b # list)) (oid, ref) =\n    {(p, n).\n     (p, n) \\<in> succ_rel (b # list) \\<and> p \\<noteq> ref} \\<union>\n    {(ref, Some oid)} \\<union>\n    {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (b # list)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. insert_alt (succ_rel (b # list)) (oid, ref) =\n    {(p, n).\n     (p, n) \\<in> succ_rel (b # list) \\<and> p \\<noteq> ref} \\<union>\n    {(ref, Some oid)} \\<union>\n    {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (b # list)}", "have \"\\<exists>n. (ref, n) \\<in> succ_rel (b # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. (ref, n) \\<in> succ_rel (b # list)", "using assms(1) True"], ["proof (prove)\nusing this:\n  a \\<noteq> ref\n  \\<exists>n. (ref, n) \\<in> succ_rel (a # b # list)\n\ngoal (1 subgoal):\n 1. \\<exists>n. (ref, n) \\<in> succ_rel (b # list)", "by auto"], ["proof (state)\nthis:\n  \\<exists>n. (ref, n) \\<in> succ_rel (b # list)\n\ngoal (1 subgoal):\n 1. insert_alt (succ_rel (b # list)) (oid, ref) =\n    {(p, n).\n     (p, n) \\<in> succ_rel (b # list) \\<and> p \\<noteq> ref} \\<union>\n    {(ref, Some oid)} \\<union>\n    {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (b # list)}", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>n. (ref, n) \\<in> succ_rel (b # list)\n\ngoal (1 subgoal):\n 1. insert_alt (succ_rel (b # list)) (oid, ref) =\n    {(p, n).\n     (p, n) \\<in> succ_rel (b # list) \\<and> p \\<noteq> ref} \\<union>\n    {(ref, Some oid)} \\<union>\n    {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (b # list)}", "by simp"], ["proof (state)\nthis:\n  insert_alt (succ_rel (b # list)) (oid, ref) =\n  {(p, n). (p, n) \\<in> succ_rel (b # list) \\<and> p \\<noteq> ref} \\<union>\n  {(ref, Some oid)} \\<union>\n  {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (b # list)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  insert_alt (succ_rel (b # list)) (oid, ref) =\n  {(p, n). (p, n) \\<in> succ_rel (b # list) \\<and> p \\<noteq> ref} \\<union>\n  {(ref, Some oid)} \\<union>\n  {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (b # list)}\n\ngoal (2 subgoals):\n 1. \\<exists>n. (ref, n) \\<in> succ_rel (a # b # list) \\<Longrightarrow>\n    insert_alt (succ_rel (a # b # list)) (oid, ref) =\n    {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)\n 2. \\<nexists>n. (ref, n) \\<in> succ_rel (a # b # list) \\<Longrightarrow>\n    insert_alt (succ_rel (a # b # list)) (oid, ref) =\n    {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)", "moreover"], ["proof (state)\nthis:\n  insert_alt (succ_rel (b # list)) (oid, ref) =\n  {(p, n). (p, n) \\<in> succ_rel (b # list) \\<and> p \\<noteq> ref} \\<union>\n  {(ref, Some oid)} \\<union>\n  {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (b # list)}\n\ngoal (2 subgoals):\n 1. \\<exists>n. (ref, n) \\<in> succ_rel (a # b # list) \\<Longrightarrow>\n    insert_alt (succ_rel (a # b # list)) (oid, ref) =\n    {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)\n 2. \\<nexists>n. (ref, n) \\<in> succ_rel (a # b # list) \\<Longrightarrow>\n    insert_alt (succ_rel (a # b # list)) (oid, ref) =\n    {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)", "have \"{(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (a # b # list)} =\n                 {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (b # list)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (a # b # list)} =\n    {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (b # list)}", "using assms(1)"], ["proof (prove)\nusing this:\n  a \\<noteq> ref\n\ngoal (1 subgoal):\n 1. {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (a # b # list)} =\n    {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (b # list)}", "by auto"], ["proof (state)\nthis:\n  {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (a # b # list)} =\n  {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (b # list)}\n\ngoal (2 subgoals):\n 1. \\<exists>n. (ref, n) \\<in> succ_rel (a # b # list) \\<Longrightarrow>\n    insert_alt (succ_rel (a # b # list)) (oid, ref) =\n    {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)\n 2. \\<nexists>n. (ref, n) \\<in> succ_rel (a # b # list) \\<Longrightarrow>\n    insert_alt (succ_rel (a # b # list)) (oid, ref) =\n    {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)", "ultimately"], ["proof (chain)\npicking this:\n  insert_alt (succ_rel (a # b # list)) (oid, ref) =\n  {(p, n).\n   (p, n) \\<in> succ_rel (a # b # list) \\<and> p \\<noteq> ref} \\<union>\n  {(ref, Some oid)} \\<union>\n  {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (a # b # list)}\n  {(p, n). (p, n) \\<in> succ_rel (a # b # list) \\<and> p \\<noteq> ref} =\n  {(a, Some b)} \\<union>\n  {(p, n). (p, n) \\<in> succ_rel (b # list) \\<and> p \\<noteq> ref}\n  insert_alt (succ_rel (b # list)) (oid, ref) =\n  {(p, n). (p, n) \\<in> succ_rel (b # list) \\<and> p \\<noteq> ref} \\<union>\n  {(ref, Some oid)} \\<union>\n  {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (b # list)}\n  {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (a # b # list)} =\n  {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (b # list)}", "show ?thesis"], ["proof (prove)\nusing this:\n  insert_alt (succ_rel (a # b # list)) (oid, ref) =\n  {(p, n).\n   (p, n) \\<in> succ_rel (a # b # list) \\<and> p \\<noteq> ref} \\<union>\n  {(ref, Some oid)} \\<union>\n  {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (a # b # list)}\n  {(p, n). (p, n) \\<in> succ_rel (a # b # list) \\<and> p \\<noteq> ref} =\n  {(a, Some b)} \\<union>\n  {(p, n). (p, n) \\<in> succ_rel (b # list) \\<and> p \\<noteq> ref}\n  insert_alt (succ_rel (b # list)) (oid, ref) =\n  {(p, n). (p, n) \\<in> succ_rel (b # list) \\<and> p \\<noteq> ref} \\<union>\n  {(ref, Some oid)} \\<union>\n  {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (b # list)}\n  {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (a # b # list)} =\n  {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (b # list)}\n\ngoal (1 subgoal):\n 1. insert_alt (succ_rel (a # b # list)) (oid, ref) =\n    {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)", "by simp"], ["proof (state)\nthis:\n  insert_alt (succ_rel (a # b # list)) (oid, ref) =\n  {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)\n\ngoal (1 subgoal):\n 1. \\<nexists>n. (ref, n) \\<in> succ_rel (a # b # list) \\<Longrightarrow>\n    insert_alt (succ_rel (a # b # list)) (oid, ref) =\n    {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>n. (ref, n) \\<in> succ_rel (a # b # list) \\<Longrightarrow>\n    insert_alt (succ_rel (a # b # list)) (oid, ref) =\n    {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)", "case False"], ["proof (state)\nthis:\n  \\<nexists>n. (ref, n) \\<in> succ_rel (a # b # list)\n\ngoal (1 subgoal):\n 1. \\<nexists>n. (ref, n) \\<in> succ_rel (a # b # list) \\<Longrightarrow>\n    insert_alt (succ_rel (a # b # list)) (oid, ref) =\n    {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)", "then"], ["proof (chain)\npicking this:\n  \\<nexists>n. (ref, n) \\<in> succ_rel (a # b # list)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<nexists>n. (ref, n) \\<in> succ_rel (a # b # list)\n\ngoal (1 subgoal):\n 1. insert_alt (succ_rel (a # b # list)) (oid, ref) =\n    {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)", "by auto"], ["proof (state)\nthis:\n  insert_alt (succ_rel (a # b # list)) (oid, ref) =\n  {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma succ_rel_insert_head:\n  assumes \"distinct (ref # list)\"\n  shows \"succ_rel (insert_spec (ref # list) (oid, Some ref)) =\n         insert_alt (succ_rel (ref # list)) (oid, ref)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (ref # list) (oid, Some ref)) =\n    insert_alt (succ_rel (ref # list)) (oid, ref)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (ref # list) (oid, Some ref)) =\n    insert_alt (succ_rel (ref # list)) (oid, ref)", "obtain n where ref_in_rel: \"(ref, n) \\<in> succ_rel (ref # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        (ref, n) \\<in> succ_rel (ref # list) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases list, auto)"], ["proof (state)\nthis:\n  (ref, n) \\<in> succ_rel (ref # list)\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (ref # list) (oid, Some ref)) =\n    insert_alt (succ_rel (ref # list)) (oid, ref)", "moreover"], ["proof (state)\nthis:\n  (ref, n) \\<in> succ_rel (ref # list)\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (ref # list) (oid, Some ref)) =\n    insert_alt (succ_rel (ref # list)) (oid, ref)", "from this"], ["proof (chain)\npicking this:\n  (ref, n) \\<in> succ_rel (ref # list)", "have \"{(p, n) \\<in> succ_rel (ref # list). p \\<noteq> ref} = succ_rel list\""], ["proof (prove)\nusing this:\n  (ref, n) \\<in> succ_rel (ref # list)\n\ngoal (1 subgoal):\n 1. {(p, n). (p, n) \\<in> succ_rel (ref # list) \\<and> p \\<noteq> ref} =\n    succ_rel list", "using assms succ_rel_rem_head"], ["proof (prove)\nusing this:\n  (ref, n) \\<in> succ_rel (ref # list)\n  distinct (ref # list)\n  distinct (?x # ?xs) \\<Longrightarrow>\n  {(p, n). (p, n) \\<in> succ_rel (?x # ?xs) \\<and> p \\<noteq> ?x} =\n  succ_rel ?xs\n\ngoal (1 subgoal):\n 1. {(p, n). (p, n) \\<in> succ_rel (ref # list) \\<and> p \\<noteq> ref} =\n    succ_rel list", "by (metis (mono_tags, lifting))"], ["proof (state)\nthis:\n  {(p, n). (p, n) \\<in> succ_rel (ref # list) \\<and> p \\<noteq> ref} =\n  succ_rel list\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (ref # list) (oid, Some ref)) =\n    insert_alt (succ_rel (ref # list)) (oid, ref)", "moreover"], ["proof (state)\nthis:\n  {(p, n). (p, n) \\<in> succ_rel (ref # list) \\<and> p \\<noteq> ref} =\n  succ_rel list\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (ref # list) (oid, Some ref)) =\n    insert_alt (succ_rel (ref # list)) (oid, ref)", "have \"{(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (ref # list)} = {(oid, n)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (ref # list)} =\n    {(oid, n)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (ref # list)} =\n    {(oid, n)}", "have \"\\<And>nx. (ref, nx) \\<in> succ_rel (ref # list) \\<Longrightarrow> nx = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nx. (ref, nx) \\<in> succ_rel (ref # list) \\<Longrightarrow> nx = n", "using assms"], ["proof (prove)\nusing this:\n  distinct (ref # list)\n\ngoal (1 subgoal):\n 1. \\<And>nx. (ref, nx) \\<in> succ_rel (ref # list) \\<Longrightarrow> nx = n", "by (simp add: succ_rel_functional ref_in_rel)"], ["proof (state)\nthis:\n  (ref, ?nx) \\<in> succ_rel (ref # list) \\<Longrightarrow> ?nx = n\n\ngoal (1 subgoal):\n 1. {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (ref # list)} =\n    {(oid, n)}", "hence \"{(i, n) \\<in> succ_rel (ref # list). i = ref} \\<subseteq> {(ref, n)}\""], ["proof (prove)\nusing this:\n  (ref, ?nx) \\<in> succ_rel (ref # list) \\<Longrightarrow> ?nx = n\n\ngoal (1 subgoal):\n 1. {(i, n). (i, n) \\<in> succ_rel (ref # list) \\<and> i = ref}\n    \\<subseteq> {(ref, n)}", "by blast"], ["proof (state)\nthis:\n  {(i, n). (i, n) \\<in> succ_rel (ref # list) \\<and> i = ref}\n  \\<subseteq> {(ref, n)}\n\ngoal (1 subgoal):\n 1. {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (ref # list)} =\n    {(oid, n)}", "moreover"], ["proof (state)\nthis:\n  {(i, n). (i, n) \\<in> succ_rel (ref # list) \\<and> i = ref}\n  \\<subseteq> {(ref, n)}\n\ngoal (1 subgoal):\n 1. {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (ref # list)} =\n    {(oid, n)}", "have \"{(ref, n)} \\<subseteq> {(i, n) \\<in> succ_rel (ref # list). i = ref}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(ref, n)}\n    \\<subseteq> {(i, n). (i, n) \\<in> succ_rel (ref # list) \\<and> i = ref}", "by (simp add: ref_in_rel)"], ["proof (state)\nthis:\n  {(ref, n)}\n  \\<subseteq> {(i, n). (i, n) \\<in> succ_rel (ref # list) \\<and> i = ref}\n\ngoal (1 subgoal):\n 1. {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (ref # list)} =\n    {(oid, n)}", "ultimately"], ["proof (chain)\npicking this:\n  {(i, n). (i, n) \\<in> succ_rel (ref # list) \\<and> i = ref}\n  \\<subseteq> {(ref, n)}\n  {(ref, n)}\n  \\<subseteq> {(i, n). (i, n) \\<in> succ_rel (ref # list) \\<and> i = ref}", "show ?thesis"], ["proof (prove)\nusing this:\n  {(i, n). (i, n) \\<in> succ_rel (ref # list) \\<and> i = ref}\n  \\<subseteq> {(ref, n)}\n  {(ref, n)}\n  \\<subseteq> {(i, n). (i, n) \\<in> succ_rel (ref # list) \\<and> i = ref}\n\ngoal (1 subgoal):\n 1. {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (ref # list)} =\n    {(oid, n)}", "by blast"], ["proof (state)\nthis:\n  {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (ref # list)} = {(oid, n)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (ref # list)} = {(oid, n)}\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (ref # list) (oid, Some ref)) =\n    insert_alt (succ_rel (ref # list)) (oid, ref)", "moreover"], ["proof (state)\nthis:\n  {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (ref # list)} = {(oid, n)}\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (ref # list) (oid, Some ref)) =\n    insert_alt (succ_rel (ref # list)) (oid, ref)", "have \"insert_alt (succ_rel (ref # list)) (oid, ref) =\n                   {(p, n) \\<in> succ_rel (ref # list). p \\<noteq> ref} \\<union> {(ref, Some oid)} \\<union>\n                   {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (ref # list)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_alt (succ_rel (ref # list)) (oid, ref) =\n    {(p, n).\n     (p, n) \\<in> succ_rel (ref # list) \\<and> p \\<noteq> ref} \\<union>\n    {(ref, Some oid)} \\<union>\n    {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (ref # list)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. insert_alt (succ_rel (ref # list)) (oid, ref) =\n    {(p, n).\n     (p, n) \\<in> succ_rel (ref # list) \\<and> p \\<noteq> ref} \\<union>\n    {(ref, Some oid)} \\<union>\n    {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (ref # list)}", "have \"\\<exists>n. (ref, n) \\<in> succ_rel (ref # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. (ref, n) \\<in> succ_rel (ref # list)", "using ref_in_rel"], ["proof (prove)\nusing this:\n  (ref, n) \\<in> succ_rel (ref # list)\n\ngoal (1 subgoal):\n 1. \\<exists>n. (ref, n) \\<in> succ_rel (ref # list)", "by blast"], ["proof (state)\nthis:\n  \\<exists>n. (ref, n) \\<in> succ_rel (ref # list)\n\ngoal (1 subgoal):\n 1. insert_alt (succ_rel (ref # list)) (oid, ref) =\n    {(p, n).\n     (p, n) \\<in> succ_rel (ref # list) \\<and> p \\<noteq> ref} \\<union>\n    {(ref, Some oid)} \\<union>\n    {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (ref # list)}", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>n. (ref, n) \\<in> succ_rel (ref # list)\n\ngoal (1 subgoal):\n 1. insert_alt (succ_rel (ref # list)) (oid, ref) =\n    {(p, n).\n     (p, n) \\<in> succ_rel (ref # list) \\<and> p \\<noteq> ref} \\<union>\n    {(ref, Some oid)} \\<union>\n    {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (ref # list)}", "by simp"], ["proof (state)\nthis:\n  insert_alt (succ_rel (ref # list)) (oid, ref) =\n  {(p, n).\n   (p, n) \\<in> succ_rel (ref # list) \\<and> p \\<noteq> ref} \\<union>\n  {(ref, Some oid)} \\<union>\n  {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (ref # list)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  insert_alt (succ_rel (ref # list)) (oid, ref) =\n  {(p, n).\n   (p, n) \\<in> succ_rel (ref # list) \\<and> p \\<noteq> ref} \\<union>\n  {(ref, Some oid)} \\<union>\n  {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (ref # list)}\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (ref # list) (oid, Some ref)) =\n    insert_alt (succ_rel (ref # list)) (oid, ref)", "ultimately"], ["proof (chain)\npicking this:\n  (ref, n) \\<in> succ_rel (ref # list)\n  {(p, n). (p, n) \\<in> succ_rel (ref # list) \\<and> p \\<noteq> ref} =\n  succ_rel list\n  {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (ref # list)} = {(oid, n)}\n  insert_alt (succ_rel (ref # list)) (oid, ref) =\n  {(p, n).\n   (p, n) \\<in> succ_rel (ref # list) \\<and> p \\<noteq> ref} \\<union>\n  {(ref, Some oid)} \\<union>\n  {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (ref # list)}", "have \"insert_alt (succ_rel (ref # list)) (oid, ref) =\n                   succ_rel list \\<union> {(ref, Some oid)} \\<union> {(oid, n)}\""], ["proof (prove)\nusing this:\n  (ref, n) \\<in> succ_rel (ref # list)\n  {(p, n). (p, n) \\<in> succ_rel (ref # list) \\<and> p \\<noteq> ref} =\n  succ_rel list\n  {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (ref # list)} = {(oid, n)}\n  insert_alt (succ_rel (ref # list)) (oid, ref) =\n  {(p, n).\n   (p, n) \\<in> succ_rel (ref # list) \\<and> p \\<noteq> ref} \\<union>\n  {(ref, Some oid)} \\<union>\n  {(i, n). i = oid \\<and> (ref, n) \\<in> succ_rel (ref # list)}\n\ngoal (1 subgoal):\n 1. insert_alt (succ_rel (ref # list)) (oid, ref) =\n    succ_rel list \\<union> {(ref, Some oid)} \\<union> {(oid, n)}", "by simp"], ["proof (state)\nthis:\n  insert_alt (succ_rel (ref # list)) (oid, ref) =\n  succ_rel list \\<union> {(ref, Some oid)} \\<union> {(oid, n)}\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (ref # list) (oid, Some ref)) =\n    insert_alt (succ_rel (ref # list)) (oid, ref)", "moreover"], ["proof (state)\nthis:\n  insert_alt (succ_rel (ref # list)) (oid, ref) =\n  succ_rel list \\<union> {(ref, Some oid)} \\<union> {(oid, n)}\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (ref # list) (oid, Some ref)) =\n    insert_alt (succ_rel (ref # list)) (oid, ref)", "have \"succ_rel (oid # list) = {(oid, n)} \\<union> succ_rel list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ_rel (oid # list) = {(oid, n)} \\<union> succ_rel list", "using assms ref_in_rel succ_rel_swap_head"], ["proof (prove)\nusing this:\n  distinct (ref # list)\n  (ref, n) \\<in> succ_rel (ref # list)\n  \\<lbrakk>distinct (?ref # ?list);\n   (?ref, ?n) \\<in> succ_rel (?ref # ?list)\\<rbrakk>\n  \\<Longrightarrow> succ_rel (?oid # ?list) =\n                    {(?oid, ?n)} \\<union> succ_rel ?list\n\ngoal (1 subgoal):\n 1. succ_rel (oid # list) = {(oid, n)} \\<union> succ_rel list", "by metis"], ["proof (state)\nthis:\n  succ_rel (oid # list) = {(oid, n)} \\<union> succ_rel list\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (ref # list) (oid, Some ref)) =\n    insert_alt (succ_rel (ref # list)) (oid, ref)", "hence \"succ_rel (ref # oid # list) = {(ref, Some oid), (oid, n)} \\<union> succ_rel list\""], ["proof (prove)\nusing this:\n  succ_rel (oid # list) = {(oid, n)} \\<union> succ_rel list\n\ngoal (1 subgoal):\n 1. succ_rel (ref # oid # list) =\n    {(ref, Some oid), (oid, n)} \\<union> succ_rel list", "by auto"], ["proof (state)\nthis:\n  succ_rel (ref # oid # list) =\n  {(ref, Some oid), (oid, n)} \\<union> succ_rel list\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (ref # list) (oid, Some ref)) =\n    insert_alt (succ_rel (ref # list)) (oid, ref)", "ultimately"], ["proof (chain)\npicking this:\n  insert_alt (succ_rel (ref # list)) (oid, ref) =\n  succ_rel list \\<union> {(ref, Some oid)} \\<union> {(oid, n)}\n  succ_rel (ref # oid # list) =\n  {(ref, Some oid), (oid, n)} \\<union> succ_rel list", "show \"succ_rel (insert_spec (ref # list) (oid, Some ref)) =\n                   insert_alt (succ_rel (ref # list)) (oid, ref)\""], ["proof (prove)\nusing this:\n  insert_alt (succ_rel (ref # list)) (oid, ref) =\n  succ_rel list \\<union> {(ref, Some oid)} \\<union> {(oid, n)}\n  succ_rel (ref # oid # list) =\n  {(ref, Some oid), (oid, n)} \\<union> succ_rel list\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (ref # list) (oid, Some ref)) =\n    insert_alt (succ_rel (ref # list)) (oid, ref)", "by auto"], ["proof (state)\nthis:\n  succ_rel (insert_spec (ref # list) (oid, Some ref)) =\n  insert_alt (succ_rel (ref # list)) (oid, ref)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma succ_rel_insert_later:\n  assumes \"succ_rel (insert_spec (b # list) (oid, Some ref)) =\n           insert_alt (succ_rel (b # list)) (oid, ref)\"\n    and \"a \\<noteq> ref\"\n    and \"distinct (a # b # list)\"\n  shows \"succ_rel (insert_spec (a # b # list) (oid, Some ref)) =\n         insert_alt (succ_rel (a # b # list)) (oid, ref)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (a # b # list) (oid, Some ref)) =\n    insert_alt (succ_rel (a # b # list)) (oid, ref)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (a # b # list) (oid, Some ref)) =\n    insert_alt (succ_rel (a # b # list)) (oid, ref)", "have \"succ_rel (a # b # list) = {(a, Some b)} \\<union> succ_rel (b # list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ_rel (a # b # list) = {(a, Some b)} \\<union> succ_rel (b # list)", "by simp"], ["proof (state)\nthis:\n  succ_rel (a # b # list) = {(a, Some b)} \\<union> succ_rel (b # list)\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (a # b # list) (oid, Some ref)) =\n    insert_alt (succ_rel (a # b # list)) (oid, ref)", "moreover"], ["proof (state)\nthis:\n  succ_rel (a # b # list) = {(a, Some b)} \\<union> succ_rel (b # list)\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (a # b # list) (oid, Some ref)) =\n    insert_alt (succ_rel (a # b # list)) (oid, ref)", "have \"insert_spec (a # b # list) (oid, Some ref) =\n                 a # (insert_spec (b # list) (oid, Some ref))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_spec (a # b # list) (oid, Some ref) =\n    a # insert_spec (b # list) (oid, Some ref)", "using assms(2)"], ["proof (prove)\nusing this:\n  a \\<noteq> ref\n\ngoal (1 subgoal):\n 1. insert_spec (a # b # list) (oid, Some ref) =\n    a # insert_spec (b # list) (oid, Some ref)", "by simp"], ["proof (state)\nthis:\n  insert_spec (a # b # list) (oid, Some ref) =\n  a # insert_spec (b # list) (oid, Some ref)\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (a # b # list) (oid, Some ref)) =\n    insert_alt (succ_rel (a # b # list)) (oid, ref)", "hence \"succ_rel (insert_spec (a # b # list) (oid, Some ref)) =\n         {(a, Some b)} \\<union> succ_rel (insert_spec (b # list) (oid, Some ref))\""], ["proof (prove)\nusing this:\n  insert_spec (a # b # list) (oid, Some ref) =\n  a # insert_spec (b # list) (oid, Some ref)\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (a # b # list) (oid, Some ref)) =\n    {(a, Some b)} \\<union> succ_rel (insert_spec (b # list) (oid, Some ref))", "by auto"], ["proof (state)\nthis:\n  succ_rel (insert_spec (a # b # list) (oid, Some ref)) =\n  {(a, Some b)} \\<union> succ_rel (insert_spec (b # list) (oid, Some ref))\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (a # b # list) (oid, Some ref)) =\n    insert_alt (succ_rel (a # b # list)) (oid, ref)", "hence \"succ_rel (insert_spec (a # b # list) (oid, Some ref)) =\n         {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)\""], ["proof (prove)\nusing this:\n  succ_rel (insert_spec (a # b # list) (oid, Some ref)) =\n  {(a, Some b)} \\<union> succ_rel (insert_spec (b # list) (oid, Some ref))\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (a # b # list) (oid, Some ref)) =\n    {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)", "using assms(1)"], ["proof (prove)\nusing this:\n  succ_rel (insert_spec (a # b # list) (oid, Some ref)) =\n  {(a, Some b)} \\<union> succ_rel (insert_spec (b # list) (oid, Some ref))\n  succ_rel (insert_spec (b # list) (oid, Some ref)) =\n  insert_alt (succ_rel (b # list)) (oid, ref)\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (a # b # list) (oid, Some ref)) =\n    {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)", "by auto"], ["proof (state)\nthis:\n  succ_rel (insert_spec (a # b # list) (oid, Some ref)) =\n  {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (a # b # list) (oid, Some ref)) =\n    insert_alt (succ_rel (a # b # list)) (oid, ref)", "moreover"], ["proof (state)\nthis:\n  succ_rel (insert_spec (a # b # list) (oid, Some ref)) =\n  {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (a # b # list) (oid, Some ref)) =\n    insert_alt (succ_rel (a # b # list)) (oid, ref)", "have \"insert_alt (succ_rel (a # b # list)) (oid, ref) =\n                 {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_alt (succ_rel (a # b # list)) (oid, ref) =\n    {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)", "using succ_rel_insert_alt assms(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<noteq> ?ref; distinct (?oid # ?a # ?b # ?list)\\<rbrakk>\n  \\<Longrightarrow> insert_alt (succ_rel (?a # ?b # ?list)) (?oid, ?ref) =\n                    {(?a, Some ?b)} \\<union>\n                    insert_alt (succ_rel (?b # ?list)) (?oid, ?ref)\n  a \\<noteq> ref\n\ngoal (1 subgoal):\n 1. insert_alt (succ_rel (a # b # list)) (oid, ref) =\n    {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)", "by auto"], ["proof (state)\nthis:\n  insert_alt (succ_rel (a # b # list)) (oid, ref) =\n  {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (a # b # list) (oid, Some ref)) =\n    insert_alt (succ_rel (a # b # list)) (oid, ref)", "ultimately"], ["proof (chain)\npicking this:\n  succ_rel (a # b # list) = {(a, Some b)} \\<union> succ_rel (b # list)\n  succ_rel (insert_spec (a # b # list) (oid, Some ref)) =\n  {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)\n  insert_alt (succ_rel (a # b # list)) (oid, ref) =\n  {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)", "show ?thesis"], ["proof (prove)\nusing this:\n  succ_rel (a # b # list) = {(a, Some b)} \\<union> succ_rel (b # list)\n  succ_rel (insert_spec (a # b # list) (oid, Some ref)) =\n  {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)\n  insert_alt (succ_rel (a # b # list)) (oid, ref) =\n  {(a, Some b)} \\<union> insert_alt (succ_rel (b # list)) (oid, ref)\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (a # b # list) (oid, Some ref)) =\n    insert_alt (succ_rel (a # b # list)) (oid, ref)", "by blast"], ["proof (state)\nthis:\n  succ_rel (insert_spec (a # b # list) (oid, Some ref)) =\n  insert_alt (succ_rel (a # b # list)) (oid, ref)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma succ_rel_insert_Some:\n  assumes \"distinct list\"\n  shows \"succ_rel (insert_spec list (oid, Some ref)) = insert_alt (succ_rel list) (oid, ref)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ_rel (insert_spec list (oid, Some ref)) =\n    insert_alt (succ_rel list) (oid, ref)", "using assms"], ["proof (prove)\nusing this:\n  distinct list\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec list (oid, Some ref)) =\n    insert_alt (succ_rel list) (oid, ref)", "proof(induction list)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    succ_rel (insert_spec [] (oid, Some ref)) =\n    insert_alt (succ_rel []) (oid, ref)\n 2. \\<And>a list.\n       \\<lbrakk>distinct list \\<Longrightarrow>\n                succ_rel (insert_spec list (oid, Some ref)) =\n                insert_alt (succ_rel list) (oid, ref);\n        distinct (a # list)\\<rbrakk>\n       \\<Longrightarrow> succ_rel (insert_spec (a # list) (oid, Some ref)) =\n                         insert_alt (succ_rel (a # list)) (oid, ref)", "case Nil"], ["proof (state)\nthis:\n  distinct []\n\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow>\n    succ_rel (insert_spec [] (oid, Some ref)) =\n    insert_alt (succ_rel []) (oid, ref)\n 2. \\<And>a list.\n       \\<lbrakk>distinct list \\<Longrightarrow>\n                succ_rel (insert_spec list (oid, Some ref)) =\n                insert_alt (succ_rel list) (oid, ref);\n        distinct (a # list)\\<rbrakk>\n       \\<Longrightarrow> succ_rel (insert_spec (a # list) (oid, Some ref)) =\n                         insert_alt (succ_rel (a # list)) (oid, ref)", "then"], ["proof (chain)\npicking this:\n  distinct []", "show \"succ_rel (insert_spec [] (oid, Some ref)) = insert_alt (succ_rel []) (oid, ref)\""], ["proof (prove)\nusing this:\n  distinct []\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec [] (oid, Some ref)) =\n    insert_alt (succ_rel []) (oid, ref)", "by simp"], ["proof (state)\nthis:\n  succ_rel (insert_spec [] (oid, Some ref)) =\n  insert_alt (succ_rel []) (oid, ref)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>distinct list \\<Longrightarrow>\n                succ_rel (insert_spec list (oid, Some ref)) =\n                insert_alt (succ_rel list) (oid, ref);\n        distinct (a # list)\\<rbrakk>\n       \\<Longrightarrow> succ_rel (insert_spec (a # list) (oid, Some ref)) =\n                         insert_alt (succ_rel (a # list)) (oid, ref)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>distinct list \\<Longrightarrow>\n                succ_rel (insert_spec list (oid, Some ref)) =\n                insert_alt (succ_rel list) (oid, ref);\n        distinct (a # list)\\<rbrakk>\n       \\<Longrightarrow> succ_rel (insert_spec (a # list) (oid, Some ref)) =\n                         insert_alt (succ_rel (a # list)) (oid, ref)", "case (Cons a list)"], ["proof (state)\nthis:\n  distinct list \\<Longrightarrow>\n  succ_rel (insert_spec list (oid, Some ref)) =\n  insert_alt (succ_rel list) (oid, ref)\n  distinct (a # list)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>distinct list \\<Longrightarrow>\n                succ_rel (insert_spec list (oid, Some ref)) =\n                insert_alt (succ_rel list) (oid, ref);\n        distinct (a # list)\\<rbrakk>\n       \\<Longrightarrow> succ_rel (insert_spec (a # list) (oid, Some ref)) =\n                         insert_alt (succ_rel (a # list)) (oid, ref)", "hence \"distinct (a # list)\""], ["proof (prove)\nusing this:\n  distinct list \\<Longrightarrow>\n  succ_rel (insert_spec list (oid, Some ref)) =\n  insert_alt (succ_rel list) (oid, ref)\n  distinct (a # list)\n\ngoal (1 subgoal):\n 1. distinct (a # list)", "by simp"], ["proof (state)\nthis:\n  distinct (a # list)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>distinct list \\<Longrightarrow>\n                succ_rel (insert_spec list (oid, Some ref)) =\n                insert_alt (succ_rel list) (oid, ref);\n        distinct (a # list)\\<rbrakk>\n       \\<Longrightarrow> succ_rel (insert_spec (a # list) (oid, Some ref)) =\n                         insert_alt (succ_rel (a # list)) (oid, ref)", "then"], ["proof (chain)\npicking this:\n  distinct (a # list)", "show \"succ_rel (insert_spec (a # list) (oid, Some ref)) =\n             insert_alt (succ_rel (a # list)) (oid, ref)\""], ["proof (prove)\nusing this:\n  distinct (a # list)\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (a # list) (oid, Some ref)) =\n    insert_alt (succ_rel (a # list)) (oid, ref)", "proof(cases \"a = ref\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (a # list); a = ref\\<rbrakk>\n    \\<Longrightarrow> succ_rel (insert_spec (a # list) (oid, Some ref)) =\n                      insert_alt (succ_rel (a # list)) (oid, ref)\n 2. \\<lbrakk>distinct (a # list); a \\<noteq> ref\\<rbrakk>\n    \\<Longrightarrow> succ_rel (insert_spec (a # list) (oid, Some ref)) =\n                      insert_alt (succ_rel (a # list)) (oid, ref)", "case True"], ["proof (state)\nthis:\n  a = ref\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (a # list); a = ref\\<rbrakk>\n    \\<Longrightarrow> succ_rel (insert_spec (a # list) (oid, Some ref)) =\n                      insert_alt (succ_rel (a # list)) (oid, ref)\n 2. \\<lbrakk>distinct (a # list); a \\<noteq> ref\\<rbrakk>\n    \\<Longrightarrow> succ_rel (insert_spec (a # list) (oid, Some ref)) =\n                      insert_alt (succ_rel (a # list)) (oid, ref)", "then"], ["proof (chain)\npicking this:\n  a = ref", "show ?thesis"], ["proof (prove)\nusing this:\n  a = ref\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (a # list) (oid, Some ref)) =\n    insert_alt (succ_rel (a # list)) (oid, ref)", "using succ_rel_insert_head \\<open>distinct (a # list)\\<close>"], ["proof (prove)\nusing this:\n  a = ref\n  distinct (?ref # ?list) \\<Longrightarrow>\n  succ_rel (insert_spec (?ref # ?list) (?oid, Some ?ref)) =\n  insert_alt (succ_rel (?ref # ?list)) (?oid, ?ref)\n  distinct (a # list)\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (a # list) (oid, Some ref)) =\n    insert_alt (succ_rel (a # list)) (oid, ref)", "by metis"], ["proof (state)\nthis:\n  succ_rel (insert_spec (a # list) (oid, Some ref)) =\n  insert_alt (succ_rel (a # list)) (oid, ref)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (a # list); a \\<noteq> ref\\<rbrakk>\n    \\<Longrightarrow> succ_rel (insert_spec (a # list) (oid, Some ref)) =\n                      insert_alt (succ_rel (a # list)) (oid, ref)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (a # list); a \\<noteq> ref\\<rbrakk>\n    \\<Longrightarrow> succ_rel (insert_spec (a # list) (oid, Some ref)) =\n                      insert_alt (succ_rel (a # list)) (oid, ref)", "case False"], ["proof (state)\nthis:\n  a \\<noteq> ref\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (a # list); a \\<noteq> ref\\<rbrakk>\n    \\<Longrightarrow> succ_rel (insert_spec (a # list) (oid, Some ref)) =\n                      insert_alt (succ_rel (a # list)) (oid, ref)", "hence \"a \\<noteq> ref\""], ["proof (prove)\nusing this:\n  a \\<noteq> ref\n\ngoal (1 subgoal):\n 1. a \\<noteq> ref", "by simp"], ["proof (state)\nthis:\n  a \\<noteq> ref\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (a # list); a \\<noteq> ref\\<rbrakk>\n    \\<Longrightarrow> succ_rel (insert_spec (a # list) (oid, Some ref)) =\n                      insert_alt (succ_rel (a # list)) (oid, ref)", "moreover"], ["proof (state)\nthis:\n  a \\<noteq> ref\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (a # list); a \\<noteq> ref\\<rbrakk>\n    \\<Longrightarrow> succ_rel (insert_spec (a # list) (oid, Some ref)) =\n                      insert_alt (succ_rel (a # list)) (oid, ref)", "have \"succ_rel (insert_spec list (oid, Some ref)) =\n                   insert_alt (succ_rel list) (oid, ref)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ_rel (insert_spec list (oid, Some ref)) =\n    insert_alt (succ_rel list) (oid, ref)", "using Cons.IH Cons.prems"], ["proof (prove)\nusing this:\n  distinct list \\<Longrightarrow>\n  succ_rel (insert_spec list (oid, Some ref)) =\n  insert_alt (succ_rel list) (oid, ref)\n  distinct (a # list)\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec list (oid, Some ref)) =\n    insert_alt (succ_rel list) (oid, ref)", "by auto"], ["proof (state)\nthis:\n  succ_rel (insert_spec list (oid, Some ref)) =\n  insert_alt (succ_rel list) (oid, ref)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (a # list); a \\<noteq> ref\\<rbrakk>\n    \\<Longrightarrow> succ_rel (insert_spec (a # list) (oid, Some ref)) =\n                      insert_alt (succ_rel (a # list)) (oid, ref)", "ultimately"], ["proof (chain)\npicking this:\n  a \\<noteq> ref\n  succ_rel (insert_spec list (oid, Some ref)) =\n  insert_alt (succ_rel list) (oid, ref)", "show \"succ_rel (insert_spec (a # list) (oid, Some ref)) =\n                     insert_alt (succ_rel (a # list)) (oid, ref)\""], ["proof (prove)\nusing this:\n  a \\<noteq> ref\n  succ_rel (insert_spec list (oid, Some ref)) =\n  insert_alt (succ_rel list) (oid, ref)\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (a # list) (oid, Some ref)) =\n    insert_alt (succ_rel (a # list)) (oid, ref)", "by (cases list, force, metis Cons.prems succ_rel_insert_later)"], ["proof (state)\nthis:\n  succ_rel (insert_spec (a # list) (oid, Some ref)) =\n  insert_alt (succ_rel (a # list)) (oid, ref)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  succ_rel (insert_spec (a # list) (oid, Some ref)) =\n  insert_alt (succ_rel (a # list)) (oid, ref)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The main result of this section, that \\isa{insert-spec} and \\isa{insert-alt}\nare equivalent.\\<close>"], ["", "theorem insert_alt_equivalent:\n  assumes \"insert_ops ops\"\n    and \"head \\<notin> fst ` set ops\"\n    and \"\\<And>r. Some r \\<in> snd ` set ops \\<Longrightarrow> r \\<noteq> head\"\n  shows \"succ_rel (head # interp_ins ops) = interp_alt head ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ_rel (head # interp_ins ops) = interp_alt head ops", "using assms"], ["proof (prove)\nusing this:\n  insert_ops ops\n  head \\<notin> fst ` set ops\n  Some ?r \\<in> snd ` set ops \\<Longrightarrow> ?r \\<noteq> head\n\ngoal (1 subgoal):\n 1. succ_rel (head # interp_ins ops) = interp_alt head ops", "proof(induction ops rule: List.rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>insert_ops []; head \\<notin> fst ` set [];\n     \\<And>r.\n        Some r \\<in> snd ` set [] \\<Longrightarrow> r \\<noteq> head\\<rbrakk>\n    \\<Longrightarrow> succ_rel (head # interp_ins []) = interp_alt head []\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops xs; head \\<notin> fst ` set xs;\n                 \\<And>r.\n                    Some r \\<in> snd ` set xs \\<Longrightarrow>\n                    r \\<noteq> head\\<rbrakk>\n                \\<Longrightarrow> succ_rel (head # interp_ins xs) =\n                                  interp_alt head xs;\n        insert_ops (xs @ [x]); head \\<notin> fst ` set (xs @ [x]);\n        \\<And>r.\n           Some r \\<in> snd ` set (xs @ [x]) \\<Longrightarrow>\n           r \\<noteq> head\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "case Nil"], ["proof (state)\nthis:\n  insert_ops []\n  head \\<notin> fst ` set []\n  Some ?r \\<in> snd ` set [] \\<Longrightarrow> ?r \\<noteq> head\n\ngoal (2 subgoals):\n 1. \\<lbrakk>insert_ops []; head \\<notin> fst ` set [];\n     \\<And>r.\n        Some r \\<in> snd ` set [] \\<Longrightarrow> r \\<noteq> head\\<rbrakk>\n    \\<Longrightarrow> succ_rel (head # interp_ins []) = interp_alt head []\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops xs; head \\<notin> fst ` set xs;\n                 \\<And>r.\n                    Some r \\<in> snd ` set xs \\<Longrightarrow>\n                    r \\<noteq> head\\<rbrakk>\n                \\<Longrightarrow> succ_rel (head # interp_ins xs) =\n                                  interp_alt head xs;\n        insert_ops (xs @ [x]); head \\<notin> fst ` set (xs @ [x]);\n        \\<And>r.\n           Some r \\<in> snd ` set (xs @ [x]) \\<Longrightarrow>\n           r \\<noteq> head\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "then"], ["proof (chain)\npicking this:\n  insert_ops []\n  head \\<notin> fst ` set []\n  Some ?r \\<in> snd ` set [] \\<Longrightarrow> ?r \\<noteq> head", "show \"succ_rel (head # interp_ins []) = interp_alt head []\""], ["proof (prove)\nusing this:\n  insert_ops []\n  head \\<notin> fst ` set []\n  Some ?r \\<in> snd ` set [] \\<Longrightarrow> ?r \\<noteq> head\n\ngoal (1 subgoal):\n 1. succ_rel (head # interp_ins []) = interp_alt head []", "by (simp add: interp_ins_def interp_alt_def)"], ["proof (state)\nthis:\n  succ_rel (head # interp_ins []) = interp_alt head []\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops xs; head \\<notin> fst ` set xs;\n                 \\<And>r.\n                    Some r \\<in> snd ` set xs \\<Longrightarrow>\n                    r \\<noteq> head\\<rbrakk>\n                \\<Longrightarrow> succ_rel (head # interp_ins xs) =\n                                  interp_alt head xs;\n        insert_ops (xs @ [x]); head \\<notin> fst ` set (xs @ [x]);\n        \\<And>r.\n           Some r \\<in> snd ` set (xs @ [x]) \\<Longrightarrow>\n           r \\<noteq> head\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops xs; head \\<notin> fst ` set xs;\n                 \\<And>r.\n                    Some r \\<in> snd ` set xs \\<Longrightarrow>\n                    r \\<noteq> head\\<rbrakk>\n                \\<Longrightarrow> succ_rel (head # interp_ins xs) =\n                                  interp_alt head xs;\n        insert_ops (xs @ [x]); head \\<notin> fst ` set (xs @ [x]);\n        \\<And>r.\n           Some r \\<in> snd ` set (xs @ [x]) \\<Longrightarrow>\n           r \\<noteq> head\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "case (snoc x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>insert_ops xs; head \\<notin> fst ` set xs;\n   \\<And>r.\n      Some r \\<in> snd ` set xs \\<Longrightarrow> r \\<noteq> head\\<rbrakk>\n  \\<Longrightarrow> succ_rel (head # interp_ins xs) = interp_alt head xs\n  insert_ops (xs @ [x])\n  head \\<notin> fst ` set (xs @ [x])\n  Some ?r \\<in> snd ` set (xs @ [x]) \\<Longrightarrow> ?r \\<noteq> head\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops xs; head \\<notin> fst ` set xs;\n                 \\<And>r.\n                    Some r \\<in> snd ` set xs \\<Longrightarrow>\n                    r \\<noteq> head\\<rbrakk>\n                \\<Longrightarrow> succ_rel (head # interp_ins xs) =\n                                  interp_alt head xs;\n        insert_ops (xs @ [x]); head \\<notin> fst ` set (xs @ [x]);\n        \\<And>r.\n           Some r \\<in> snd ` set (xs @ [x]) \\<Longrightarrow>\n           r \\<noteq> head\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "have IH: \"succ_rel (head # interp_ins xs) = interp_alt head xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ_rel (head # interp_ins xs) = interp_alt head xs", "using snoc"], ["proof (prove)\nusing this:\n  \\<lbrakk>insert_ops xs; head \\<notin> fst ` set xs;\n   \\<And>r.\n      Some r \\<in> snd ` set xs \\<Longrightarrow> r \\<noteq> head\\<rbrakk>\n  \\<Longrightarrow> succ_rel (head # interp_ins xs) = interp_alt head xs\n  insert_ops (xs @ [x])\n  head \\<notin> fst ` set (xs @ [x])\n  Some ?r \\<in> snd ` set (xs @ [x]) \\<Longrightarrow> ?r \\<noteq> head\n\ngoal (1 subgoal):\n 1. succ_rel (head # interp_ins xs) = interp_alt head xs", "by auto"], ["proof (state)\nthis:\n  succ_rel (head # interp_ins xs) = interp_alt head xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops xs; head \\<notin> fst ` set xs;\n                 \\<And>r.\n                    Some r \\<in> snd ` set xs \\<Longrightarrow>\n                    r \\<noteq> head\\<rbrakk>\n                \\<Longrightarrow> succ_rel (head # interp_ins xs) =\n                                  interp_alt head xs;\n        insert_ops (xs @ [x]); head \\<notin> fst ` set (xs @ [x]);\n        \\<And>r.\n           Some r \\<in> snd ` set (xs @ [x]) \\<Longrightarrow>\n           r \\<noteq> head\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "have distinct_list: \"distinct (head # interp_ins xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (head # interp_ins xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (head # interp_ins xs)", "have \"distinct (interp_ins xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (interp_ins xs)", "using interp_ins_distinct snoc.prems(1)"], ["proof (prove)\nusing this:\n  insert_ops ?op_list \\<Longrightarrow> distinct (interp_ins ?op_list)\n  insert_ops (xs @ [x])\n\ngoal (1 subgoal):\n 1. distinct (interp_ins xs)", "by blast"], ["proof (state)\nthis:\n  distinct (interp_ins xs)\n\ngoal (1 subgoal):\n 1. distinct (head # interp_ins xs)", "moreover"], ["proof (state)\nthis:\n  distinct (interp_ins xs)\n\ngoal (1 subgoal):\n 1. distinct (head # interp_ins xs)", "have \"set (interp_ins xs) \\<subseteq> fst ` set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (interp_ins xs) \\<subseteq> fst ` set xs", "using interp_ins_subset snoc.prems(1)"], ["proof (prove)\nusing this:\n  set (interp_ins ?op_list) \\<subseteq> set (map fst ?op_list)\n  insert_ops (xs @ [x])\n\ngoal (1 subgoal):\n 1. set (interp_ins xs) \\<subseteq> fst ` set xs", "by fastforce"], ["proof (state)\nthis:\n  set (interp_ins xs) \\<subseteq> fst ` set xs\n\ngoal (1 subgoal):\n 1. distinct (head # interp_ins xs)", "ultimately"], ["proof (chain)\npicking this:\n  distinct (interp_ins xs)\n  set (interp_ins xs) \\<subseteq> fst ` set xs", "show \"distinct (head # interp_ins xs)\""], ["proof (prove)\nusing this:\n  distinct (interp_ins xs)\n  set (interp_ins xs) \\<subseteq> fst ` set xs\n\ngoal (1 subgoal):\n 1. distinct (head # interp_ins xs)", "using snoc.prems(2)"], ["proof (prove)\nusing this:\n  distinct (interp_ins xs)\n  set (interp_ins xs) \\<subseteq> fst ` set xs\n  head \\<notin> fst ` set (xs @ [x])\n\ngoal (1 subgoal):\n 1. distinct (head # interp_ins xs)", "by auto"], ["proof (state)\nthis:\n  distinct (head # interp_ins xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (head # interp_ins xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops xs; head \\<notin> fst ` set xs;\n                 \\<And>r.\n                    Some r \\<in> snd ` set xs \\<Longrightarrow>\n                    r \\<noteq> head\\<rbrakk>\n                \\<Longrightarrow> succ_rel (head # interp_ins xs) =\n                                  interp_alt head xs;\n        insert_ops (xs @ [x]); head \\<notin> fst ` set (xs @ [x]);\n        \\<And>r.\n           Some r \\<in> snd ` set (xs @ [x]) \\<Longrightarrow>\n           r \\<noteq> head\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "obtain oid r where x_pair: \"x = (oid, r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>oid r. x = (oid, r) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  x = (oid, r)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>insert_ops xs; head \\<notin> fst ` set xs;\n                 \\<And>r.\n                    Some r \\<in> snd ` set xs \\<Longrightarrow>\n                    r \\<noteq> head\\<rbrakk>\n                \\<Longrightarrow> succ_rel (head # interp_ins xs) =\n                                  interp_alt head xs;\n        insert_ops (xs @ [x]); head \\<notin> fst ` set (xs @ [x]);\n        \\<And>r.\n           Some r \\<in> snd ` set (xs @ [x]) \\<Longrightarrow>\n           r \\<noteq> head\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "then"], ["proof (chain)\npicking this:\n  x = (oid, r)", "show \"succ_rel (head # interp_ins (xs @ [x])) = interp_alt head (xs @ [x])\""], ["proof (prove)\nusing this:\n  x = (oid, r)\n\ngoal (1 subgoal):\n 1. succ_rel (head # interp_ins (xs @ [x])) = interp_alt head (xs @ [x])", "proof(cases r)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = (oid, r); r = None\\<rbrakk>\n    \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                      interp_alt head (xs @ [x])\n 2. \\<And>a.\n       \\<lbrakk>x = (oid, r); r = Some a\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "case None"], ["proof (state)\nthis:\n  r = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = (oid, r); r = None\\<rbrakk>\n    \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                      interp_alt head (xs @ [x])\n 2. \\<And>a.\n       \\<lbrakk>x = (oid, r); r = Some a\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "have \"interp_alt head (xs @ [x]) = insert_alt (interp_alt head xs) (oid, head)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interp_alt head (xs @ [x]) = insert_alt (interp_alt head xs) (oid, head)", "by (simp add: interp_alt_def None x_pair)"], ["proof (state)\nthis:\n  interp_alt head (xs @ [x]) = insert_alt (interp_alt head xs) (oid, head)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = (oid, r); r = None\\<rbrakk>\n    \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                      interp_alt head (xs @ [x])\n 2. \\<And>a.\n       \\<lbrakk>x = (oid, r); r = Some a\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "moreover"], ["proof (state)\nthis:\n  interp_alt head (xs @ [x]) = insert_alt (interp_alt head xs) (oid, head)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = (oid, r); r = None\\<rbrakk>\n    \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                      interp_alt head (xs @ [x])\n 2. \\<And>a.\n       \\<lbrakk>x = (oid, r); r = Some a\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "have \"... = insert_alt (succ_rel (head # interp_ins xs)) (oid, head)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_alt (interp_alt head xs) (oid, head) =\n    insert_alt (succ_rel (head # interp_ins xs)) (oid, head)", "by (simp add: IH)"], ["proof (state)\nthis:\n  insert_alt (interp_alt head xs) (oid, head) =\n  insert_alt (succ_rel (head # interp_ins xs)) (oid, head)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = (oid, r); r = None\\<rbrakk>\n    \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                      interp_alt head (xs @ [x])\n 2. \\<And>a.\n       \\<lbrakk>x = (oid, r); r = Some a\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "moreover"], ["proof (state)\nthis:\n  insert_alt (interp_alt head xs) (oid, head) =\n  insert_alt (succ_rel (head # interp_ins xs)) (oid, head)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = (oid, r); r = None\\<rbrakk>\n    \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                      interp_alt head (xs @ [x])\n 2. \\<And>a.\n       \\<lbrakk>x = (oid, r); r = Some a\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "have \"... = succ_rel (insert_spec (head # interp_ins xs) (oid, Some head))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_alt (succ_rel (head # interp_ins xs)) (oid, head) =\n    succ_rel (insert_spec (head # interp_ins xs) (oid, Some head))", "using distinct_list succ_rel_insert_Some"], ["proof (prove)\nusing this:\n  distinct (head # interp_ins xs)\n  distinct ?list \\<Longrightarrow>\n  succ_rel (insert_spec ?list (?oid, Some ?ref)) =\n  insert_alt (succ_rel ?list) (?oid, ?ref)\n\ngoal (1 subgoal):\n 1. insert_alt (succ_rel (head # interp_ins xs)) (oid, head) =\n    succ_rel (insert_spec (head # interp_ins xs) (oid, Some head))", "by metis"], ["proof (state)\nthis:\n  insert_alt (succ_rel (head # interp_ins xs)) (oid, head) =\n  succ_rel (insert_spec (head # interp_ins xs) (oid, Some head))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = (oid, r); r = None\\<rbrakk>\n    \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                      interp_alt head (xs @ [x])\n 2. \\<And>a.\n       \\<lbrakk>x = (oid, r); r = Some a\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "moreover"], ["proof (state)\nthis:\n  insert_alt (succ_rel (head # interp_ins xs)) (oid, head) =\n  succ_rel (insert_spec (head # interp_ins xs) (oid, Some head))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = (oid, r); r = None\\<rbrakk>\n    \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                      interp_alt head (xs @ [x])\n 2. \\<And>a.\n       \\<lbrakk>x = (oid, r); r = Some a\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "have \"... = succ_rel (head # (insert_spec (interp_ins xs) (oid, None)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (head # interp_ins xs) (oid, Some head)) =\n    succ_rel (head # insert_spec (interp_ins xs) (oid, None))", "by auto"], ["proof (state)\nthis:\n  succ_rel (insert_spec (head # interp_ins xs) (oid, Some head)) =\n  succ_rel (head # insert_spec (interp_ins xs) (oid, None))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = (oid, r); r = None\\<rbrakk>\n    \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                      interp_alt head (xs @ [x])\n 2. \\<And>a.\n       \\<lbrakk>x = (oid, r); r = Some a\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "moreover"], ["proof (state)\nthis:\n  succ_rel (insert_spec (head # interp_ins xs) (oid, Some head)) =\n  succ_rel (head # insert_spec (interp_ins xs) (oid, None))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = (oid, r); r = None\\<rbrakk>\n    \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                      interp_alt head (xs @ [x])\n 2. \\<And>a.\n       \\<lbrakk>x = (oid, r); r = Some a\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "have \"... = succ_rel (head # (interp_ins (xs @ [x])))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ_rel (head # insert_spec (interp_ins xs) (oid, None)) =\n    succ_rel (head # interp_ins (xs @ [x]))", "by (simp add: interp_ins_tail_unfold None x_pair)"], ["proof (state)\nthis:\n  succ_rel (head # insert_spec (interp_ins xs) (oid, None)) =\n  succ_rel (head # interp_ins (xs @ [x]))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = (oid, r); r = None\\<rbrakk>\n    \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                      interp_alt head (xs @ [x])\n 2. \\<And>a.\n       \\<lbrakk>x = (oid, r); r = Some a\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "ultimately"], ["proof (chain)\npicking this:\n  interp_alt head (xs @ [x]) = insert_alt (interp_alt head xs) (oid, head)\n  insert_alt (interp_alt head xs) (oid, head) =\n  insert_alt (succ_rel (head # interp_ins xs)) (oid, head)\n  insert_alt (succ_rel (head # interp_ins xs)) (oid, head) =\n  succ_rel (insert_spec (head # interp_ins xs) (oid, Some head))\n  succ_rel (insert_spec (head # interp_ins xs) (oid, Some head)) =\n  succ_rel (head # insert_spec (interp_ins xs) (oid, None))\n  succ_rel (head # insert_spec (interp_ins xs) (oid, None)) =\n  succ_rel (head # interp_ins (xs @ [x]))", "show ?thesis"], ["proof (prove)\nusing this:\n  interp_alt head (xs @ [x]) = insert_alt (interp_alt head xs) (oid, head)\n  insert_alt (interp_alt head xs) (oid, head) =\n  insert_alt (succ_rel (head # interp_ins xs)) (oid, head)\n  insert_alt (succ_rel (head # interp_ins xs)) (oid, head) =\n  succ_rel (insert_spec (head # interp_ins xs) (oid, Some head))\n  succ_rel (insert_spec (head # interp_ins xs) (oid, Some head)) =\n  succ_rel (head # insert_spec (interp_ins xs) (oid, None))\n  succ_rel (head # insert_spec (interp_ins xs) (oid, None)) =\n  succ_rel (head # interp_ins (xs @ [x]))\n\ngoal (1 subgoal):\n 1. succ_rel (head # interp_ins (xs @ [x])) = interp_alt head (xs @ [x])", "by simp"], ["proof (state)\nthis:\n  succ_rel (head # interp_ins (xs @ [x])) = interp_alt head (xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>x = (oid, r); r = Some a\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>x = (oid, r); r = Some a\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "case (Some ref)"], ["proof (state)\nthis:\n  r = Some ref\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>x = (oid, r); r = Some a\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "have \"ref \\<noteq> head\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ref \\<noteq> head", "by (simp add: Some snoc.prems(3) x_pair)"], ["proof (state)\nthis:\n  ref \\<noteq> head\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>x = (oid, r); r = Some a\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "have \"interp_alt head (xs @ [x]) = insert_alt (interp_alt head xs) (oid, ref)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interp_alt head (xs @ [x]) = insert_alt (interp_alt head xs) (oid, ref)", "by (simp add: interp_alt_def Some x_pair)"], ["proof (state)\nthis:\n  interp_alt head (xs @ [x]) = insert_alt (interp_alt head xs) (oid, ref)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>x = (oid, r); r = Some a\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "moreover"], ["proof (state)\nthis:\n  interp_alt head (xs @ [x]) = insert_alt (interp_alt head xs) (oid, ref)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>x = (oid, r); r = Some a\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "have \"... = insert_alt (succ_rel (head # interp_ins xs)) (oid, ref)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_alt (interp_alt head xs) (oid, ref) =\n    insert_alt (succ_rel (head # interp_ins xs)) (oid, ref)", "by (simp add: IH)"], ["proof (state)\nthis:\n  insert_alt (interp_alt head xs) (oid, ref) =\n  insert_alt (succ_rel (head # interp_ins xs)) (oid, ref)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>x = (oid, r); r = Some a\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "moreover"], ["proof (state)\nthis:\n  insert_alt (interp_alt head xs) (oid, ref) =\n  insert_alt (succ_rel (head # interp_ins xs)) (oid, ref)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>x = (oid, r); r = Some a\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "have \"... = succ_rel (insert_spec (head # interp_ins xs) (oid, Some ref))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_alt (succ_rel (head # interp_ins xs)) (oid, ref) =\n    succ_rel (insert_spec (head # interp_ins xs) (oid, Some ref))", "using distinct_list succ_rel_insert_Some"], ["proof (prove)\nusing this:\n  distinct (head # interp_ins xs)\n  distinct ?list \\<Longrightarrow>\n  succ_rel (insert_spec ?list (?oid, Some ?ref)) =\n  insert_alt (succ_rel ?list) (?oid, ?ref)\n\ngoal (1 subgoal):\n 1. insert_alt (succ_rel (head # interp_ins xs)) (oid, ref) =\n    succ_rel (insert_spec (head # interp_ins xs) (oid, Some ref))", "by metis"], ["proof (state)\nthis:\n  insert_alt (succ_rel (head # interp_ins xs)) (oid, ref) =\n  succ_rel (insert_spec (head # interp_ins xs) (oid, Some ref))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>x = (oid, r); r = Some a\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "moreover"], ["proof (state)\nthis:\n  insert_alt (succ_rel (head # interp_ins xs)) (oid, ref) =\n  succ_rel (insert_spec (head # interp_ins xs) (oid, Some ref))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>x = (oid, r); r = Some a\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "have \"... = succ_rel (head # (insert_spec (interp_ins xs) (oid, Some ref)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (head # interp_ins xs) (oid, Some ref)) =\n    succ_rel (head # insert_spec (interp_ins xs) (oid, Some ref))", "using \\<open>ref \\<noteq> head\\<close>"], ["proof (prove)\nusing this:\n  ref \\<noteq> head\n\ngoal (1 subgoal):\n 1. succ_rel (insert_spec (head # interp_ins xs) (oid, Some ref)) =\n    succ_rel (head # insert_spec (interp_ins xs) (oid, Some ref))", "by auto"], ["proof (state)\nthis:\n  succ_rel (insert_spec (head # interp_ins xs) (oid, Some ref)) =\n  succ_rel (head # insert_spec (interp_ins xs) (oid, Some ref))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>x = (oid, r); r = Some a\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "moreover"], ["proof (state)\nthis:\n  succ_rel (insert_spec (head # interp_ins xs) (oid, Some ref)) =\n  succ_rel (head # insert_spec (interp_ins xs) (oid, Some ref))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>x = (oid, r); r = Some a\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "have \"... = succ_rel (head # (interp_ins (xs @ [x])))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ_rel (head # insert_spec (interp_ins xs) (oid, Some ref)) =\n    succ_rel (head # interp_ins (xs @ [x]))", "by (simp add: interp_ins_tail_unfold Some x_pair)"], ["proof (state)\nthis:\n  succ_rel (head # insert_spec (interp_ins xs) (oid, Some ref)) =\n  succ_rel (head # interp_ins (xs @ [x]))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>x = (oid, r); r = Some a\\<rbrakk>\n       \\<Longrightarrow> succ_rel (head # interp_ins (xs @ [x])) =\n                         interp_alt head (xs @ [x])", "ultimately"], ["proof (chain)\npicking this:\n  interp_alt head (xs @ [x]) = insert_alt (interp_alt head xs) (oid, ref)\n  insert_alt (interp_alt head xs) (oid, ref) =\n  insert_alt (succ_rel (head # interp_ins xs)) (oid, ref)\n  insert_alt (succ_rel (head # interp_ins xs)) (oid, ref) =\n  succ_rel (insert_spec (head # interp_ins xs) (oid, Some ref))\n  succ_rel (insert_spec (head # interp_ins xs) (oid, Some ref)) =\n  succ_rel (head # insert_spec (interp_ins xs) (oid, Some ref))\n  succ_rel (head # insert_spec (interp_ins xs) (oid, Some ref)) =\n  succ_rel (head # interp_ins (xs @ [x]))", "show ?thesis"], ["proof (prove)\nusing this:\n  interp_alt head (xs @ [x]) = insert_alt (interp_alt head xs) (oid, ref)\n  insert_alt (interp_alt head xs) (oid, ref) =\n  insert_alt (succ_rel (head # interp_ins xs)) (oid, ref)\n  insert_alt (succ_rel (head # interp_ins xs)) (oid, ref) =\n  succ_rel (insert_spec (head # interp_ins xs) (oid, Some ref))\n  succ_rel (insert_spec (head # interp_ins xs) (oid, Some ref)) =\n  succ_rel (head # insert_spec (interp_ins xs) (oid, Some ref))\n  succ_rel (head # insert_spec (interp_ins xs) (oid, Some ref)) =\n  succ_rel (head # interp_ins (xs @ [x]))\n\ngoal (1 subgoal):\n 1. succ_rel (head # interp_ins (xs @ [x])) = interp_alt head (xs @ [x])", "by simp"], ["proof (state)\nthis:\n  succ_rel (head # interp_ins (xs @ [x])) = interp_alt head (xs @ [x])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  succ_rel (head # interp_ins (xs @ [x])) = interp_alt head (xs @ [x])\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The \\isa{list-order} predicate\\<close>"], ["", "text\\<open>\\isa{list-order ops x y} holds iff, after interpreting the list of\ninsertion operations \\isa{ops}, the list element with ID \\isa{x} appears\nbefore the list element with ID \\isa{y} in the resulting list. We prove several\nlemmas about this predicate; in particular, that executing additional insertion\noperations does not change the relative ordering of existing list elements.\\<close>"], ["", "definition list_order :: \"('oid::{linorder} \\<times> 'oid option) list \\<Rightarrow> 'oid \\<Rightarrow> 'oid \\<Rightarrow> bool\" where\n  \"list_order ops x y \\<equiv> \\<exists>xs ys zs. interp_ins ops = xs @ [x] @ ys @ [y] @ zs\""], ["", "lemma list_orderI:\n  assumes \"interp_ins ops = xs @ [x] @ ys @ [y] @ zs\"\n  shows \"list_order ops x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_order ops x y", "using assms"], ["proof (prove)\nusing this:\n  interp_ins ops = xs @ [x] @ ys @ [y] @ zs\n\ngoal (1 subgoal):\n 1. list_order ops x y", "by (auto simp add: list_order_def)"], ["", "lemma list_orderE:\n  assumes \"list_order ops x y\"\n  shows \"\\<exists>xs ys zs. interp_ins ops = xs @ [x] @ ys @ [y] @ zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs. interp_ins ops = xs @ [x] @ ys @ [y] @ zs", "using assms"], ["proof (prove)\nusing this:\n  list_order ops x y\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs. interp_ins ops = xs @ [x] @ ys @ [y] @ zs", "by (auto simp add: list_order_def)"], ["", "lemma list_order_memb1:\n  assumes \"list_order ops x y\"\n  shows \"x \\<in> set (interp_ins ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (interp_ins ops)", "using assms"], ["proof (prove)\nusing this:\n  list_order ops x y\n\ngoal (1 subgoal):\n 1. x \\<in> set (interp_ins ops)", "by (auto simp add: list_order_def)"], ["", "lemma list_order_memb2:\n  assumes \"list_order ops x y\"\n  shows \"y \\<in> set (interp_ins ops)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> set (interp_ins ops)", "using assms"], ["proof (prove)\nusing this:\n  list_order ops x y\n\ngoal (1 subgoal):\n 1. y \\<in> set (interp_ins ops)", "by (auto simp add: list_order_def)"], ["", "lemma list_order_trans:\n  assumes \"insert_ops op_list\"\n    and \"list_order op_list x y\"\n    and \"list_order op_list y z\"\n  shows \"list_order op_list x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_order op_list x z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_order op_list x z", "obtain xxs xys xzs where 1: \"interp_ins op_list = (xxs@[x]@xys)@(y#xzs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xxs xys xzs.\n        interp_ins op_list = (xxs @ [x] @ xys) @ y # xzs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  insert_ops op_list\n  list_order op_list x y\n  list_order op_list y z\n\ngoal (1 subgoal):\n 1. (\\<And>xxs xys xzs.\n        interp_ins op_list = (xxs @ [x] @ xys) @ y # xzs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: list_order_def interp_ins_def)"], ["proof (state)\nthis:\n  interp_ins op_list = (xxs @ [x] @ xys) @ y # xzs\n\ngoal (1 subgoal):\n 1. list_order op_list x z", "obtain yxs yys yzs where 2: \"interp_ins op_list = yxs@y#(yys@[z]@yzs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>yxs yys yzs.\n        interp_ins op_list = yxs @ y # yys @ [z] @ yzs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  insert_ops op_list\n  list_order op_list x y\n  list_order op_list y z\n\ngoal (1 subgoal):\n 1. (\\<And>yxs yys yzs.\n        interp_ins op_list = yxs @ y # yys @ [z] @ yzs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: list_order_def interp_ins_def)"], ["proof (state)\nthis:\n  interp_ins op_list = yxs @ y # yys @ [z] @ yzs\n\ngoal (1 subgoal):\n 1. list_order op_list x z", "have 3: \"distinct (interp_ins op_list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (interp_ins op_list)", "using assms interp_ins_distinct"], ["proof (prove)\nusing this:\n  insert_ops op_list\n  list_order op_list x y\n  list_order op_list y z\n  insert_ops ?op_list \\<Longrightarrow> distinct (interp_ins ?op_list)\n\ngoal (1 subgoal):\n 1. distinct (interp_ins op_list)", "by blast"], ["proof (state)\nthis:\n  distinct (interp_ins op_list)\n\ngoal (1 subgoal):\n 1. list_order op_list x z", "hence \"xzs = yys@[z]@yzs\""], ["proof (prove)\nusing this:\n  distinct (interp_ins op_list)\n\ngoal (1 subgoal):\n 1. xzs = yys @ [z] @ yzs", "using distinct_list_split[OF 3, OF 2, OF 1]"], ["proof (prove)\nusing this:\n  distinct (interp_ins op_list)\n  yxs = xxs @ [x] @ xys \\<and> yys @ [z] @ yzs = xzs\n\ngoal (1 subgoal):\n 1. xzs = yys @ [z] @ yzs", "by auto"], ["proof (state)\nthis:\n  xzs = yys @ [z] @ yzs\n\ngoal (1 subgoal):\n 1. list_order op_list x z", "hence \"interp_ins op_list = xxs@[x]@xys@[y]@yys@[z]@yzs\""], ["proof (prove)\nusing this:\n  xzs = yys @ [z] @ yzs\n\ngoal (1 subgoal):\n 1. interp_ins op_list = xxs @ [x] @ xys @ [y] @ yys @ [z] @ yzs", "using 1 2 3"], ["proof (prove)\nusing this:\n  xzs = yys @ [z] @ yzs\n  interp_ins op_list = (xxs @ [x] @ xys) @ y # xzs\n  interp_ins op_list = yxs @ y # yys @ [z] @ yzs\n  distinct (interp_ins op_list)\n\ngoal (1 subgoal):\n 1. interp_ins op_list = xxs @ [x] @ xys @ [y] @ yys @ [z] @ yzs", "by clarsimp"], ["proof (state)\nthis:\n  interp_ins op_list = xxs @ [x] @ xys @ [y] @ yys @ [z] @ yzs\n\ngoal (1 subgoal):\n 1. list_order op_list x z", "thus \"list_order op_list x z\""], ["proof (prove)\nusing this:\n  interp_ins op_list = xxs @ [x] @ xys @ [y] @ yys @ [z] @ yzs\n\ngoal (1 subgoal):\n 1. list_order op_list x z", "using assms"], ["proof (prove)\nusing this:\n  interp_ins op_list = xxs @ [x] @ xys @ [y] @ yys @ [z] @ yzs\n  insert_ops op_list\n  list_order op_list x y\n  list_order op_list y z\n\ngoal (1 subgoal):\n 1. list_order op_list x z", "by (metis append.assoc list_orderI)"], ["proof (state)\nthis:\n  list_order op_list x z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma insert_preserves_order:\n  assumes \"insert_ops ops\" and \"insert_ops rest\"\n    and \"rest = before @ after\"\n    and \"ops  = before @ (oid, ref) # after\"\n  shows \"\\<exists>xs ys zs. interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "using assms"], ["proof (prove)\nusing this:\n  insert_ops ops\n  insert_ops rest\n  rest = before @ after\n  ops = before @ (oid, ref) # after\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "proof(induction after arbitrary: rest ops rule: List.rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>rest ops.\n       \\<lbrakk>insert_ops ops; insert_ops rest; rest = before @ [];\n        ops = before @ [(oid, ref)]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            interp_ins rest = xs @ zs \\<and>\n                            interp_ins ops = xs @ ys @ zs\n 2. \\<And>x xs rest ops.\n       \\<lbrakk>\\<And>rest ops.\n                   \\<lbrakk>insert_ops ops; insert_ops rest;\n                    rest = before @ xs;\n                    ops = before @ (oid, ref) # xs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs ys zs.\n  interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs;\n        insert_ops ops; insert_ops rest; rest = before @ xs @ [x];\n        ops = before @ (oid, ref) # xs @ [x]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            interp_ins rest = xs @ zs \\<and>\n                            interp_ins ops = xs @ ys @ zs", "case Nil"], ["proof (state)\nthis:\n  insert_ops ops\n  insert_ops rest\n  rest = before @ []\n  ops = before @ [(oid, ref)]\n\ngoal (2 subgoals):\n 1. \\<And>rest ops.\n       \\<lbrakk>insert_ops ops; insert_ops rest; rest = before @ [];\n        ops = before @ [(oid, ref)]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            interp_ins rest = xs @ zs \\<and>\n                            interp_ins ops = xs @ ys @ zs\n 2. \\<And>x xs rest ops.\n       \\<lbrakk>\\<And>rest ops.\n                   \\<lbrakk>insert_ops ops; insert_ops rest;\n                    rest = before @ xs;\n                    ops = before @ (oid, ref) # xs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs ys zs.\n  interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs;\n        insert_ops ops; insert_ops rest; rest = before @ xs @ [x];\n        ops = before @ (oid, ref) # xs @ [x]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            interp_ins rest = xs @ zs \\<and>\n                            interp_ins ops = xs @ ys @ zs", "then"], ["proof (chain)\npicking this:\n  insert_ops ops\n  insert_ops rest\n  rest = before @ []\n  ops = before @ [(oid, ref)]", "have 1: \"interp_ins ops = insert_spec (interp_ins before) (oid, ref)\""], ["proof (prove)\nusing this:\n  insert_ops ops\n  insert_ops rest\n  rest = before @ []\n  ops = before @ [(oid, ref)]\n\ngoal (1 subgoal):\n 1. interp_ins ops = insert_spec (interp_ins before) (oid, ref)", "by (simp add: interp_ins_tail_unfold)"], ["proof (state)\nthis:\n  interp_ins ops = insert_spec (interp_ins before) (oid, ref)\n\ngoal (2 subgoals):\n 1. \\<And>rest ops.\n       \\<lbrakk>insert_ops ops; insert_ops rest; rest = before @ [];\n        ops = before @ [(oid, ref)]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            interp_ins rest = xs @ zs \\<and>\n                            interp_ins ops = xs @ ys @ zs\n 2. \\<And>x xs rest ops.\n       \\<lbrakk>\\<And>rest ops.\n                   \\<lbrakk>insert_ops ops; insert_ops rest;\n                    rest = before @ xs;\n                    ops = before @ (oid, ref) # xs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs ys zs.\n  interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs;\n        insert_ops ops; insert_ops rest; rest = before @ xs @ [x];\n        ops = before @ (oid, ref) # xs @ [x]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            interp_ins rest = xs @ zs \\<and>\n                            interp_ins ops = xs @ ys @ zs", "then"], ["proof (chain)\npicking this:\n  interp_ins ops = insert_spec (interp_ins before) (oid, ref)", "show \"\\<exists>xs ys zs. interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\""], ["proof (prove)\nusing this:\n  interp_ins ops = insert_spec (interp_ins before) (oid, ref)\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "proof(cases ref)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>interp_ins ops = insert_spec (interp_ins before) (oid, ref);\n     ref = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs ys zs.\n                         interp_ins rest = xs @ zs \\<and>\n                         interp_ins ops = xs @ ys @ zs\n 2. \\<And>a.\n       \\<lbrakk>interp_ins ops = insert_spec (interp_ins before) (oid, ref);\n        ref = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            interp_ins rest = xs @ zs \\<and>\n                            interp_ins ops = xs @ ys @ zs", "case None"], ["proof (state)\nthis:\n  ref = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>interp_ins ops = insert_spec (interp_ins before) (oid, ref);\n     ref = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs ys zs.\n                         interp_ins rest = xs @ zs \\<and>\n                         interp_ins ops = xs @ ys @ zs\n 2. \\<And>a.\n       \\<lbrakk>interp_ins ops = insert_spec (interp_ins before) (oid, ref);\n        ref = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            interp_ins rest = xs @ zs \\<and>\n                            interp_ins ops = xs @ ys @ zs", "hence \"interp_ins rest = [] @ (interp_ins before) \\<and>\n           interp_ins ops = [] @ [oid] @ (interp_ins before)\""], ["proof (prove)\nusing this:\n  ref = None\n\ngoal (1 subgoal):\n 1. interp_ins rest = [] @ interp_ins before \\<and>\n    interp_ins ops = [] @ [oid] @ interp_ins before", "using 1 Nil.prems(3)"], ["proof (prove)\nusing this:\n  ref = None\n  interp_ins ops = insert_spec (interp_ins before) (oid, ref)\n  rest = before @ []\n\ngoal (1 subgoal):\n 1. interp_ins rest = [] @ interp_ins before \\<and>\n    interp_ins ops = [] @ [oid] @ interp_ins before", "by simp"], ["proof (state)\nthis:\n  interp_ins rest = [] @ interp_ins before \\<and>\n  interp_ins ops = [] @ [oid] @ interp_ins before\n\ngoal (2 subgoals):\n 1. \\<lbrakk>interp_ins ops = insert_spec (interp_ins before) (oid, ref);\n     ref = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs ys zs.\n                         interp_ins rest = xs @ zs \\<and>\n                         interp_ins ops = xs @ ys @ zs\n 2. \\<And>a.\n       \\<lbrakk>interp_ins ops = insert_spec (interp_ins before) (oid, ref);\n        ref = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            interp_ins rest = xs @ zs \\<and>\n                            interp_ins ops = xs @ ys @ zs", "then"], ["proof (chain)\npicking this:\n  interp_ins rest = [] @ interp_ins before \\<and>\n  interp_ins ops = [] @ [oid] @ interp_ins before", "show ?thesis"], ["proof (prove)\nusing this:\n  interp_ins rest = [] @ interp_ins before \\<and>\n  interp_ins ops = [] @ [oid] @ interp_ins before\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "by blast"], ["proof (state)\nthis:\n  \\<exists>xs ys zs.\n     interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>interp_ins ops = insert_spec (interp_ins before) (oid, ref);\n        ref = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            interp_ins rest = xs @ zs \\<and>\n                            interp_ins ops = xs @ ys @ zs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>interp_ins ops = insert_spec (interp_ins before) (oid, ref);\n        ref = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            interp_ins rest = xs @ zs \\<and>\n                            interp_ins ops = xs @ ys @ zs", "case (Some a)"], ["proof (state)\nthis:\n  ref = Some a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>interp_ins ops = insert_spec (interp_ins before) (oid, ref);\n        ref = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            interp_ins rest = xs @ zs \\<and>\n                            interp_ins ops = xs @ ys @ zs", "then"], ["proof (chain)\npicking this:\n  ref = Some a", "show ?thesis"], ["proof (prove)\nusing this:\n  ref = Some a\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "proof(cases \"a \\<in> set (interp_ins before)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ref = Some a; a \\<in> set (interp_ins before)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs ys zs.\n                         interp_ins rest = xs @ zs \\<and>\n                         interp_ins ops = xs @ ys @ zs\n 2. \\<lbrakk>ref = Some a; a \\<notin> set (interp_ins before)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs ys zs.\n                         interp_ins rest = xs @ zs \\<and>\n                         interp_ins ops = xs @ ys @ zs", "case True"], ["proof (state)\nthis:\n  a \\<in> set (interp_ins before)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ref = Some a; a \\<in> set (interp_ins before)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs ys zs.\n                         interp_ins rest = xs @ zs \\<and>\n                         interp_ins ops = xs @ ys @ zs\n 2. \\<lbrakk>ref = Some a; a \\<notin> set (interp_ins before)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs ys zs.\n                         interp_ins rest = xs @ zs \\<and>\n                         interp_ins ops = xs @ ys @ zs", "then"], ["proof (chain)\npicking this:\n  a \\<in> set (interp_ins before)", "obtain xs ys where \"interp_ins before = xs @ ys \\<and>\n          insert_spec (interp_ins before) (oid, ref) = xs @ oid # ys\""], ["proof (prove)\nusing this:\n  a \\<in> set (interp_ins before)\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        interp_ins before = xs @ ys \\<and>\n        insert_spec (interp_ins before) (oid, ref) =\n        xs @ oid # ys \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using insert_somewhere Some"], ["proof (prove)\nusing this:\n  a \\<in> set (interp_ins before)\n  ?ref = None \\<or>\n  ?ref = Some ?r \\<and> ?r \\<in> set ?list \\<Longrightarrow>\n  \\<exists>xs ys.\n     ?list = xs @ ys \\<and> insert_spec ?list (?oid, ?ref) = xs @ ?oid # ys\n  ref = Some a\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        interp_ins before = xs @ ys \\<and>\n        insert_spec (interp_ins before) (oid, ref) =\n        xs @ oid # ys \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  interp_ins before = xs @ ys \\<and>\n  insert_spec (interp_ins before) (oid, ref) = xs @ oid # ys\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ref = Some a; a \\<in> set (interp_ins before)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs ys zs.\n                         interp_ins rest = xs @ zs \\<and>\n                         interp_ins ops = xs @ ys @ zs\n 2. \\<lbrakk>ref = Some a; a \\<notin> set (interp_ins before)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs ys zs.\n                         interp_ins rest = xs @ zs \\<and>\n                         interp_ins ops = xs @ ys @ zs", "hence \"interp_ins rest = xs @ ys \\<and> interp_ins ops = xs @ [oid] @ ys\""], ["proof (prove)\nusing this:\n  interp_ins before = xs @ ys \\<and>\n  insert_spec (interp_ins before) (oid, ref) = xs @ oid # ys\n\ngoal (1 subgoal):\n 1. interp_ins rest = xs @ ys \\<and> interp_ins ops = xs @ [oid] @ ys", "using 1 Nil.prems(3)"], ["proof (prove)\nusing this:\n  interp_ins before = xs @ ys \\<and>\n  insert_spec (interp_ins before) (oid, ref) = xs @ oid # ys\n  interp_ins ops = insert_spec (interp_ins before) (oid, ref)\n  rest = before @ []\n\ngoal (1 subgoal):\n 1. interp_ins rest = xs @ ys \\<and> interp_ins ops = xs @ [oid] @ ys", "by auto"], ["proof (state)\nthis:\n  interp_ins rest = xs @ ys \\<and> interp_ins ops = xs @ [oid] @ ys\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ref = Some a; a \\<in> set (interp_ins before)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs ys zs.\n                         interp_ins rest = xs @ zs \\<and>\n                         interp_ins ops = xs @ ys @ zs\n 2. \\<lbrakk>ref = Some a; a \\<notin> set (interp_ins before)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs ys zs.\n                         interp_ins rest = xs @ zs \\<and>\n                         interp_ins ops = xs @ ys @ zs", "then"], ["proof (chain)\npicking this:\n  interp_ins rest = xs @ ys \\<and> interp_ins ops = xs @ [oid] @ ys", "show ?thesis"], ["proof (prove)\nusing this:\n  interp_ins rest = xs @ ys \\<and> interp_ins ops = xs @ [oid] @ ys\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "by blast"], ["proof (state)\nthis:\n  \\<exists>xs ys zs.\n     interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ref = Some a; a \\<notin> set (interp_ins before)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs ys zs.\n                         interp_ins rest = xs @ zs \\<and>\n                         interp_ins ops = xs @ ys @ zs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ref = Some a; a \\<notin> set (interp_ins before)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs ys zs.\n                         interp_ins rest = xs @ zs \\<and>\n                         interp_ins ops = xs @ ys @ zs", "case False"], ["proof (state)\nthis:\n  a \\<notin> set (interp_ins before)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ref = Some a; a \\<notin> set (interp_ins before)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs ys zs.\n                         interp_ins rest = xs @ zs \\<and>\n                         interp_ins ops = xs @ ys @ zs", "hence \"interp_ins ops = (interp_ins rest) @ [] @ []\""], ["proof (prove)\nusing this:\n  a \\<notin> set (interp_ins before)\n\ngoal (1 subgoal):\n 1. interp_ins ops = interp_ins rest @ [] @ []", "using insert_spec_nonex 1 Nil.prems(3) Some"], ["proof (prove)\nusing this:\n  a \\<notin> set (interp_ins before)\n  ?ref \\<notin> set ?xs \\<Longrightarrow>\n  insert_spec ?xs (?oid, Some ?ref) = ?xs\n  interp_ins ops = insert_spec (interp_ins before) (oid, ref)\n  rest = before @ []\n  ref = Some a\n\ngoal (1 subgoal):\n 1. interp_ins ops = interp_ins rest @ [] @ []", "by simp"], ["proof (state)\nthis:\n  interp_ins ops = interp_ins rest @ [] @ []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ref = Some a; a \\<notin> set (interp_ins before)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs ys zs.\n                         interp_ins rest = xs @ zs \\<and>\n                         interp_ins ops = xs @ ys @ zs", "then"], ["proof (chain)\npicking this:\n  interp_ins ops = interp_ins rest @ [] @ []", "show ?thesis"], ["proof (prove)\nusing this:\n  interp_ins ops = interp_ins rest @ [] @ []\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "by blast"], ["proof (state)\nthis:\n  \\<exists>xs ys zs.\n     interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs ys zs.\n     interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs ys zs.\n     interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n\ngoal (1 subgoal):\n 1. \\<And>x xs rest ops.\n       \\<lbrakk>\\<And>rest ops.\n                   \\<lbrakk>insert_ops ops; insert_ops rest;\n                    rest = before @ xs;\n                    ops = before @ (oid, ref) # xs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs ys zs.\n  interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs;\n        insert_ops ops; insert_ops rest; rest = before @ xs @ [x];\n        ops = before @ (oid, ref) # xs @ [x]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            interp_ins rest = xs @ zs \\<and>\n                            interp_ins ops = xs @ ys @ zs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs rest ops.\n       \\<lbrakk>\\<And>rest ops.\n                   \\<lbrakk>insert_ops ops; insert_ops rest;\n                    rest = before @ xs;\n                    ops = before @ (oid, ref) # xs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs ys zs.\n  interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs;\n        insert_ops ops; insert_ops rest; rest = before @ xs @ [x];\n        ops = before @ (oid, ref) # xs @ [x]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            interp_ins rest = xs @ zs \\<and>\n                            interp_ins ops = xs @ ys @ zs", "case (snoc oper op_list)"], ["proof (state)\nthis:\n  \\<lbrakk>insert_ops ?ops; insert_ops ?rest; ?rest = before @ op_list;\n   ?ops = before @ (oid, ref) # op_list\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs ys zs.\n                       interp_ins ?rest = xs @ zs \\<and>\n                       interp_ins ?ops = xs @ ys @ zs\n  insert_ops ops\n  insert_ops rest\n  rest = before @ op_list @ [oper]\n  ops = before @ (oid, ref) # op_list @ [oper]\n\ngoal (1 subgoal):\n 1. \\<And>x xs rest ops.\n       \\<lbrakk>\\<And>rest ops.\n                   \\<lbrakk>insert_ops ops; insert_ops rest;\n                    rest = before @ xs;\n                    ops = before @ (oid, ref) # xs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs ys zs.\n  interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs;\n        insert_ops ops; insert_ops rest; rest = before @ xs @ [x];\n        ops = before @ (oid, ref) # xs @ [x]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            interp_ins rest = xs @ zs \\<and>\n                            interp_ins ops = xs @ ys @ zs", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>insert_ops ?ops; insert_ops ?rest; ?rest = before @ op_list;\n   ?ops = before @ (oid, ref) # op_list\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs ys zs.\n                       interp_ins ?rest = xs @ zs \\<and>\n                       interp_ins ?ops = xs @ ys @ zs\n  insert_ops ops\n  insert_ops rest\n  rest = before @ op_list @ [oper]\n  ops = before @ (oid, ref) # op_list @ [oper]", "have \"insert_ops ((before @ (oid, ref) # op_list) @ [oper])\"\n    and \"insert_ops ((before @ op_list) @ [oper])\""], ["proof (prove)\nusing this:\n  \\<lbrakk>insert_ops ?ops; insert_ops ?rest; ?rest = before @ op_list;\n   ?ops = before @ (oid, ref) # op_list\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs ys zs.\n                       interp_ins ?rest = xs @ zs \\<and>\n                       interp_ins ?ops = xs @ ys @ zs\n  insert_ops ops\n  insert_ops rest\n  rest = before @ op_list @ [oper]\n  ops = before @ (oid, ref) # op_list @ [oper]\n\ngoal (1 subgoal):\n 1. insert_ops ((before @ (oid, ref) # op_list) @ [oper]) &&&\n    insert_ops ((before @ op_list) @ [oper])", "by auto"], ["proof (state)\nthis:\n  insert_ops ((before @ (oid, ref) # op_list) @ [oper])\n  insert_ops ((before @ op_list) @ [oper])\n\ngoal (1 subgoal):\n 1. \\<And>x xs rest ops.\n       \\<lbrakk>\\<And>rest ops.\n                   \\<lbrakk>insert_ops ops; insert_ops rest;\n                    rest = before @ xs;\n                    ops = before @ (oid, ref) # xs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs ys zs.\n  interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs;\n        insert_ops ops; insert_ops rest; rest = before @ xs @ [x];\n        ops = before @ (oid, ref) # xs @ [x]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            interp_ins rest = xs @ zs \\<and>\n                            interp_ins ops = xs @ ys @ zs", "then"], ["proof (chain)\npicking this:\n  insert_ops ((before @ (oid, ref) # op_list) @ [oper])\n  insert_ops ((before @ op_list) @ [oper])", "have ops1: \"insert_ops (before @ op_list)\"\n    and ops2: \"insert_ops (before @ (oid, ref) # op_list)\""], ["proof (prove)\nusing this:\n  insert_ops ((before @ (oid, ref) # op_list) @ [oper])\n  insert_ops ((before @ op_list) @ [oper])\n\ngoal (1 subgoal):\n 1. insert_ops (before @ op_list) &&&\n    insert_ops (before @ (oid, ref) # op_list)", "using insert_ops_appendD"], ["proof (prove)\nusing this:\n  insert_ops ((before @ (oid, ref) # op_list) @ [oper])\n  insert_ops ((before @ op_list) @ [oper])\n  insert_ops (?xs @ ?ys) \\<Longrightarrow> insert_ops ?xs\n\ngoal (1 subgoal):\n 1. insert_ops (before @ op_list) &&&\n    insert_ops (before @ (oid, ref) # op_list)", "by blast+"], ["proof (state)\nthis:\n  insert_ops (before @ op_list)\n  insert_ops (before @ (oid, ref) # op_list)\n\ngoal (1 subgoal):\n 1. \\<And>x xs rest ops.\n       \\<lbrakk>\\<And>rest ops.\n                   \\<lbrakk>insert_ops ops; insert_ops rest;\n                    rest = before @ xs;\n                    ops = before @ (oid, ref) # xs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs ys zs.\n  interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs;\n        insert_ops ops; insert_ops rest; rest = before @ xs @ [x];\n        ops = before @ (oid, ref) # xs @ [x]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            interp_ins rest = xs @ zs \\<and>\n                            interp_ins ops = xs @ ys @ zs", "then"], ["proof (chain)\npicking this:\n  insert_ops (before @ op_list)\n  insert_ops (before @ (oid, ref) # op_list)", "obtain xs ys zs where IH1: \"interp_ins (before @ op_list) = xs @ zs\"\n    and IH2: \"interp_ins (before @ (oid, ref) # op_list) = xs @ ys @ zs\""], ["proof (prove)\nusing this:\n  insert_ops (before @ op_list)\n  insert_ops (before @ (oid, ref) # op_list)\n\ngoal (1 subgoal):\n 1. (\\<And>xs zs ys.\n        \\<lbrakk>interp_ins (before @ op_list) = xs @ zs;\n         interp_ins (before @ (oid, ref) # op_list) = xs @ ys @ zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using snoc.IH"], ["proof (prove)\nusing this:\n  insert_ops (before @ op_list)\n  insert_ops (before @ (oid, ref) # op_list)\n  \\<lbrakk>insert_ops ?ops; insert_ops ?rest; ?rest = before @ op_list;\n   ?ops = before @ (oid, ref) # op_list\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs ys zs.\n                       interp_ins ?rest = xs @ zs \\<and>\n                       interp_ins ?ops = xs @ ys @ zs\n\ngoal (1 subgoal):\n 1. (\\<And>xs zs ys.\n        \\<lbrakk>interp_ins (before @ op_list) = xs @ zs;\n         interp_ins (before @ (oid, ref) # op_list) = xs @ ys @ zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  interp_ins (before @ op_list) = xs @ zs\n  interp_ins (before @ (oid, ref) # op_list) = xs @ ys @ zs\n\ngoal (1 subgoal):\n 1. \\<And>x xs rest ops.\n       \\<lbrakk>\\<And>rest ops.\n                   \\<lbrakk>insert_ops ops; insert_ops rest;\n                    rest = before @ xs;\n                    ops = before @ (oid, ref) # xs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs ys zs.\n  interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs;\n        insert_ops ops; insert_ops rest; rest = before @ xs @ [x];\n        ops = before @ (oid, ref) # xs @ [x]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            interp_ins rest = xs @ zs \\<and>\n                            interp_ins ops = xs @ ys @ zs", "obtain i2 r2 where \"oper = (i2, r2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i2 r2.\n        oper = (i2, r2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  oper = (i2, r2)\n\ngoal (1 subgoal):\n 1. \\<And>x xs rest ops.\n       \\<lbrakk>\\<And>rest ops.\n                   \\<lbrakk>insert_ops ops; insert_ops rest;\n                    rest = before @ xs;\n                    ops = before @ (oid, ref) # xs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs ys zs.\n  interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs;\n        insert_ops ops; insert_ops rest; rest = before @ xs @ [x];\n        ops = before @ (oid, ref) # xs @ [x]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            interp_ins rest = xs @ zs \\<and>\n                            interp_ins ops = xs @ ys @ zs", "then"], ["proof (chain)\npicking this:\n  oper = (i2, r2)", "show \"\\<exists>xs ys zs. interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\""], ["proof (prove)\nusing this:\n  oper = (i2, r2)\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "proof(cases r2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>oper = (i2, r2); r2 = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs ys zs.\n                         interp_ins rest = xs @ zs \\<and>\n                         interp_ins ops = xs @ ys @ zs\n 2. \\<And>a.\n       \\<lbrakk>oper = (i2, r2); r2 = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            interp_ins rest = xs @ zs \\<and>\n                            interp_ins ops = xs @ ys @ zs", "case None"], ["proof (state)\nthis:\n  r2 = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>oper = (i2, r2); r2 = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs ys zs.\n                         interp_ins rest = xs @ zs \\<and>\n                         interp_ins ops = xs @ ys @ zs\n 2. \\<And>a.\n       \\<lbrakk>oper = (i2, r2); r2 = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            interp_ins rest = xs @ zs \\<and>\n                            interp_ins ops = xs @ ys @ zs", "hence \"interp_ins (before @ op_list @ [oper]) = (i2 # xs) @ zs\""], ["proof (prove)\nusing this:\n  r2 = None\n\ngoal (1 subgoal):\n 1. interp_ins (before @ op_list @ [oper]) = (i2 # xs) @ zs", "by (metis IH1 \\<open>oper = (i2, r2)\\<close> append.assoc append_Cons insert_spec.simps(1)\n          interp_ins_tail_unfold)"], ["proof (state)\nthis:\n  interp_ins (before @ op_list @ [oper]) = (i2 # xs) @ zs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>oper = (i2, r2); r2 = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs ys zs.\n                         interp_ins rest = xs @ zs \\<and>\n                         interp_ins ops = xs @ ys @ zs\n 2. \\<And>a.\n       \\<lbrakk>oper = (i2, r2); r2 = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            interp_ins rest = xs @ zs \\<and>\n                            interp_ins ops = xs @ ys @ zs", "moreover"], ["proof (state)\nthis:\n  interp_ins (before @ op_list @ [oper]) = (i2 # xs) @ zs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>oper = (i2, r2); r2 = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs ys zs.\n                         interp_ins rest = xs @ zs \\<and>\n                         interp_ins ops = xs @ ys @ zs\n 2. \\<And>a.\n       \\<lbrakk>oper = (i2, r2); r2 = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            interp_ins rest = xs @ zs \\<and>\n                            interp_ins ops = xs @ ys @ zs", "have \"interp_ins (before @ (oid, ref) # op_list @ [oper]) = (i2 # xs) @ ys @ zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interp_ins (before @ (oid, ref) # op_list @ [oper]) =\n    (i2 # xs) @ ys @ zs", "by (metis IH2 None \\<open>oper = (i2, r2)\\<close> append.assoc append_Cons insert_spec.simps(1)\n          interp_ins_tail_unfold)"], ["proof (state)\nthis:\n  interp_ins (before @ (oid, ref) # op_list @ [oper]) = (i2 # xs) @ ys @ zs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>oper = (i2, r2); r2 = None\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs ys zs.\n                         interp_ins rest = xs @ zs \\<and>\n                         interp_ins ops = xs @ ys @ zs\n 2. \\<And>a.\n       \\<lbrakk>oper = (i2, r2); r2 = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            interp_ins rest = xs @ zs \\<and>\n                            interp_ins ops = xs @ ys @ zs", "ultimately"], ["proof (chain)\npicking this:\n  interp_ins (before @ op_list @ [oper]) = (i2 # xs) @ zs\n  interp_ins (before @ (oid, ref) # op_list @ [oper]) = (i2 # xs) @ ys @ zs", "show ?thesis"], ["proof (prove)\nusing this:\n  interp_ins (before @ op_list @ [oper]) = (i2 # xs) @ zs\n  interp_ins (before @ (oid, ref) # op_list @ [oper]) = (i2 # xs) @ ys @ zs\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "using snoc.prems(3) snoc.prems(4)"], ["proof (prove)\nusing this:\n  interp_ins (before @ op_list @ [oper]) = (i2 # xs) @ zs\n  interp_ins (before @ (oid, ref) # op_list @ [oper]) = (i2 # xs) @ ys @ zs\n  rest = before @ op_list @ [oper]\n  ops = before @ (oid, ref) # op_list @ [oper]\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "by blast"], ["proof (state)\nthis:\n  \\<exists>xs ys zs.\n     interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>oper = (i2, r2); r2 = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            interp_ins rest = xs @ zs \\<and>\n                            interp_ins ops = xs @ ys @ zs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>oper = (i2, r2); r2 = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            interp_ins rest = xs @ zs \\<and>\n                            interp_ins ops = xs @ ys @ zs", "case (Some r)"], ["proof (state)\nthis:\n  r2 = Some r\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>oper = (i2, r2); r2 = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            interp_ins rest = xs @ zs \\<and>\n                            interp_ins ops = xs @ ys @ zs", "then"], ["proof (chain)\npicking this:\n  r2 = Some r", "have 1: \"interp_ins (before @ (oid, ref) # op_list @ [(i2, r2)]) =\n                  insert_spec (xs @ ys @ zs) (i2, Some r)\""], ["proof (prove)\nusing this:\n  r2 = Some r\n\ngoal (1 subgoal):\n 1. interp_ins (before @ (oid, ref) # op_list @ [(i2, r2)]) =\n    insert_spec (xs @ ys @ zs) (i2, Some r)", "by (metis IH2 append.assoc append_Cons interp_ins_tail_unfold)"], ["proof (state)\nthis:\n  interp_ins (before @ (oid, ref) # op_list @ [(i2, r2)]) =\n  insert_spec (xs @ ys @ zs) (i2, Some r)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>oper = (i2, r2); r2 = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            interp_ins rest = xs @ zs \\<and>\n                            interp_ins ops = xs @ ys @ zs", "have 2: \"interp_ins (before @ op_list @ [(i2, r2)]) = insert_spec (xs @ zs) (i2, Some r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. interp_ins (before @ op_list @ [(i2, r2)]) =\n    insert_spec (xs @ zs) (i2, Some r)", "by (metis IH1 append.assoc interp_ins_tail_unfold Some)"], ["proof (state)\nthis:\n  interp_ins (before @ op_list @ [(i2, r2)]) =\n  insert_spec (xs @ zs) (i2, Some r)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>oper = (i2, r2); r2 = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            interp_ins rest = xs @ zs \\<and>\n                            interp_ins ops = xs @ ys @ zs", "consider (r_xs) \"r \\<in> set xs\" | (r_ys) \"r \\<in> set ys\" | (r_zs) \"r \\<in> set zs\" |\n      (r_nonex) \"r \\<notin> set (xs @ ys @ zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<in> set xs \\<Longrightarrow> thesis;\n     r \\<in> set ys \\<Longrightarrow> thesis;\n     r \\<in> set zs \\<Longrightarrow> thesis;\n     r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>r \\<in> set xs \\<Longrightarrow> ?thesis;\n   r \\<in> set ys \\<Longrightarrow> ?thesis;\n   r \\<in> set zs \\<Longrightarrow> ?thesis;\n   r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>oper = (i2, r2); r2 = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs ys zs.\n                            interp_ins rest = xs @ zs \\<and>\n                            interp_ins ops = xs @ ys @ zs", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>r \\<in> set xs \\<Longrightarrow> ?thesis;\n   r \\<in> set ys \\<Longrightarrow> ?thesis;\n   r \\<in> set zs \\<Longrightarrow> ?thesis;\n   r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show \"\\<exists>xs ys zs. interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>r \\<in> set xs \\<Longrightarrow> ?thesis;\n   r \\<in> set ys \\<Longrightarrow> ?thesis;\n   r \\<in> set zs \\<Longrightarrow> ?thesis;\n   r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "proof(cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. r \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 2. r \\<in> set ys \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 3. r \\<in> set zs \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 4. r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "case r_xs"], ["proof (state)\nthis:\n  r \\<in> set xs\n\ngoal (4 subgoals):\n 1. r \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 2. r \\<in> set ys \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 3. r \\<in> set zs \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 4. r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "from this"], ["proof (chain)\npicking this:\n  r \\<in> set xs", "have \"insert_spec (xs @ ys @ zs) (i2, Some r) =\n                      (insert_spec xs (i2, Some r)) @ ys @ zs\""], ["proof (prove)\nusing this:\n  r \\<in> set xs\n\ngoal (1 subgoal):\n 1. insert_spec (xs @ ys @ zs) (i2, Some r) =\n    insert_spec xs (i2, Some r) @ ys @ zs", "by (meson insert_first_part)"], ["proof (state)\nthis:\n  insert_spec (xs @ ys @ zs) (i2, Some r) =\n  insert_spec xs (i2, Some r) @ ys @ zs\n\ngoal (4 subgoals):\n 1. r \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 2. r \\<in> set ys \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 3. r \\<in> set zs \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 4. r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "moreover"], ["proof (state)\nthis:\n  insert_spec (xs @ ys @ zs) (i2, Some r) =\n  insert_spec xs (i2, Some r) @ ys @ zs\n\ngoal (4 subgoals):\n 1. r \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 2. r \\<in> set ys \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 3. r \\<in> set zs \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 4. r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "have \"insert_spec (xs @ zs) (i2, Some r) = (insert_spec xs (i2, Some r)) @ zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_spec (xs @ zs) (i2, Some r) = insert_spec xs (i2, Some r) @ zs", "by (meson r_xs insert_first_part)"], ["proof (state)\nthis:\n  insert_spec (xs @ zs) (i2, Some r) = insert_spec xs (i2, Some r) @ zs\n\ngoal (4 subgoals):\n 1. r \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 2. r \\<in> set ys \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 3. r \\<in> set zs \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 4. r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "ultimately"], ["proof (chain)\npicking this:\n  insert_spec (xs @ ys @ zs) (i2, Some r) =\n  insert_spec xs (i2, Some r) @ ys @ zs\n  insert_spec (xs @ zs) (i2, Some r) = insert_spec xs (i2, Some r) @ zs", "show ?thesis"], ["proof (prove)\nusing this:\n  insert_spec (xs @ ys @ zs) (i2, Some r) =\n  insert_spec xs (i2, Some r) @ ys @ zs\n  insert_spec (xs @ zs) (i2, Some r) = insert_spec xs (i2, Some r) @ zs\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "using 1 2 \\<open>oper = (i2, r2)\\<close> snoc.prems"], ["proof (prove)\nusing this:\n  insert_spec (xs @ ys @ zs) (i2, Some r) =\n  insert_spec xs (i2, Some r) @ ys @ zs\n  insert_spec (xs @ zs) (i2, Some r) = insert_spec xs (i2, Some r) @ zs\n  interp_ins (before @ (oid, ref) # op_list @ [(i2, r2)]) =\n  insert_spec (xs @ ys @ zs) (i2, Some r)\n  interp_ins (before @ op_list @ [(i2, r2)]) =\n  insert_spec (xs @ zs) (i2, Some r)\n  oper = (i2, r2)\n  insert_ops ops\n  insert_ops rest\n  rest = before @ op_list @ [oper]\n  ops = before @ (oid, ref) # op_list @ [oper]\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs ys zs.\n     interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n\ngoal (3 subgoals):\n 1. r \\<in> set ys \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 2. r \\<in> set zs \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 3. r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. r \\<in> set ys \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 2. r \\<in> set zs \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 3. r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "case r_ys"], ["proof (state)\nthis:\n  r \\<in> set ys\n\ngoal (3 subgoals):\n 1. r \\<in> set ys \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 2. r \\<in> set zs \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 3. r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "hence \"r \\<notin> set xs\" and \"r \\<notin> set zs\""], ["proof (prove)\nusing this:\n  r \\<in> set ys\n\ngoal (1 subgoal):\n 1. r \\<notin> set xs &&& r \\<notin> set zs", "using IH2 ops2 interp_ins_distinct"], ["proof (prove)\nusing this:\n  r \\<in> set ys\n  interp_ins (before @ (oid, ref) # op_list) = xs @ ys @ zs\n  insert_ops (before @ (oid, ref) # op_list)\n  insert_ops ?op_list \\<Longrightarrow> distinct (interp_ins ?op_list)\n\ngoal (1 subgoal):\n 1. r \\<notin> set xs &&& r \\<notin> set zs", "by force+"], ["proof (state)\nthis:\n  r \\<notin> set xs\n  r \\<notin> set zs\n\ngoal (3 subgoals):\n 1. r \\<in> set ys \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 2. r \\<in> set zs \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 3. r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "moreover"], ["proof (state)\nthis:\n  r \\<notin> set xs\n  r \\<notin> set zs\n\ngoal (3 subgoals):\n 1. r \\<in> set ys \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 2. r \\<in> set zs \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 3. r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "from this"], ["proof (chain)\npicking this:\n  r \\<notin> set xs\n  r \\<notin> set zs", "have \"insert_spec (xs @ ys @ zs) (i2, Some r) =\n                               xs @ (insert_spec ys (i2, Some r)) @ zs\""], ["proof (prove)\nusing this:\n  r \\<notin> set xs\n  r \\<notin> set zs\n\ngoal (1 subgoal):\n 1. insert_spec (xs @ ys @ zs) (i2, Some r) =\n    xs @ insert_spec ys (i2, Some r) @ zs", "using insert_first_part insert_second_part insert_spec_nonex"], ["proof (prove)\nusing this:\n  r \\<notin> set xs\n  r \\<notin> set zs\n  ?ref = None \\<or> ?ref = Some ?r \\<and> ?r \\<in> set ?xs \\<Longrightarrow>\n  insert_spec (?xs @ ?ys) (?oid, ?ref) = insert_spec ?xs (?oid, ?ref) @ ?ys\n  \\<lbrakk>?ref = Some ?r; ?r \\<notin> set ?xs; ?r \\<in> set ?ys\\<rbrakk>\n  \\<Longrightarrow> insert_spec (?xs @ ?ys) (?oid, ?ref) =\n                    ?xs @ insert_spec ?ys (?oid, ?ref)\n  ?ref \\<notin> set ?xs \\<Longrightarrow>\n  insert_spec ?xs (?oid, Some ?ref) = ?xs\n\ngoal (1 subgoal):\n 1. insert_spec (xs @ ys @ zs) (i2, Some r) =\n    xs @ insert_spec ys (i2, Some r) @ zs", "by (metis Some UnE r_ys set_append)"], ["proof (state)\nthis:\n  insert_spec (xs @ ys @ zs) (i2, Some r) =\n  xs @ insert_spec ys (i2, Some r) @ zs\n\ngoal (3 subgoals):\n 1. r \\<in> set ys \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 2. r \\<in> set zs \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 3. r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "moreover"], ["proof (state)\nthis:\n  insert_spec (xs @ ys @ zs) (i2, Some r) =\n  xs @ insert_spec ys (i2, Some r) @ zs\n\ngoal (3 subgoals):\n 1. r \\<in> set ys \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 2. r \\<in> set zs \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 3. r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "have \"insert_spec (xs @ zs) (i2, Some r) = xs @ zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_spec (xs @ zs) (i2, Some r) = xs @ zs", "by (simp add: Some calculation(1) calculation(2))"], ["proof (state)\nthis:\n  insert_spec (xs @ zs) (i2, Some r) = xs @ zs\n\ngoal (3 subgoals):\n 1. r \\<in> set ys \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 2. r \\<in> set zs \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 3. r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "ultimately"], ["proof (chain)\npicking this:\n  r \\<notin> set xs\n  r \\<notin> set zs\n  insert_spec (xs @ ys @ zs) (i2, Some r) =\n  xs @ insert_spec ys (i2, Some r) @ zs\n  insert_spec (xs @ zs) (i2, Some r) = xs @ zs", "show ?thesis"], ["proof (prove)\nusing this:\n  r \\<notin> set xs\n  r \\<notin> set zs\n  insert_spec (xs @ ys @ zs) (i2, Some r) =\n  xs @ insert_spec ys (i2, Some r) @ zs\n  insert_spec (xs @ zs) (i2, Some r) = xs @ zs\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "using 1 2 \\<open>oper = (i2, r2)\\<close> snoc.prems"], ["proof (prove)\nusing this:\n  r \\<notin> set xs\n  r \\<notin> set zs\n  insert_spec (xs @ ys @ zs) (i2, Some r) =\n  xs @ insert_spec ys (i2, Some r) @ zs\n  insert_spec (xs @ zs) (i2, Some r) = xs @ zs\n  interp_ins (before @ (oid, ref) # op_list @ [(i2, r2)]) =\n  insert_spec (xs @ ys @ zs) (i2, Some r)\n  interp_ins (before @ op_list @ [(i2, r2)]) =\n  insert_spec (xs @ zs) (i2, Some r)\n  oper = (i2, r2)\n  insert_ops ops\n  insert_ops rest\n  rest = before @ op_list @ [oper]\n  ops = before @ (oid, ref) # op_list @ [oper]\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs ys zs.\n     interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n\ngoal (2 subgoals):\n 1. r \\<in> set zs \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 2. r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. r \\<in> set zs \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 2. r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "case r_zs"], ["proof (state)\nthis:\n  r \\<in> set zs\n\ngoal (2 subgoals):\n 1. r \\<in> set zs \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 2. r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "hence \"r \\<notin> set xs\" and \"r \\<notin> set ys\""], ["proof (prove)\nusing this:\n  r \\<in> set zs\n\ngoal (1 subgoal):\n 1. r \\<notin> set xs &&& r \\<notin> set ys", "using IH2 ops2 interp_ins_distinct"], ["proof (prove)\nusing this:\n  r \\<in> set zs\n  interp_ins (before @ (oid, ref) # op_list) = xs @ ys @ zs\n  insert_ops (before @ (oid, ref) # op_list)\n  insert_ops ?op_list \\<Longrightarrow> distinct (interp_ins ?op_list)\n\ngoal (1 subgoal):\n 1. r \\<notin> set xs &&& r \\<notin> set ys", "by force+"], ["proof (state)\nthis:\n  r \\<notin> set xs\n  r \\<notin> set ys\n\ngoal (2 subgoals):\n 1. r \\<in> set zs \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 2. r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "moreover"], ["proof (state)\nthis:\n  r \\<notin> set xs\n  r \\<notin> set ys\n\ngoal (2 subgoals):\n 1. r \\<in> set zs \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 2. r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "from this"], ["proof (chain)\npicking this:\n  r \\<notin> set xs\n  r \\<notin> set ys", "have \"insert_spec (xs @ ys @ zs) (i2, Some r) =\n                               xs @ ys @ (insert_spec zs (i2, Some r))\""], ["proof (prove)\nusing this:\n  r \\<notin> set xs\n  r \\<notin> set ys\n\ngoal (1 subgoal):\n 1. insert_spec (xs @ ys @ zs) (i2, Some r) =\n    xs @ ys @ insert_spec zs (i2, Some r)", "by (metis Some UnE insert_second_part insert_spec_nonex set_append)"], ["proof (state)\nthis:\n  insert_spec (xs @ ys @ zs) (i2, Some r) =\n  xs @ ys @ insert_spec zs (i2, Some r)\n\ngoal (2 subgoals):\n 1. r \\<in> set zs \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 2. r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "moreover"], ["proof (state)\nthis:\n  insert_spec (xs @ ys @ zs) (i2, Some r) =\n  xs @ ys @ insert_spec zs (i2, Some r)\n\ngoal (2 subgoals):\n 1. r \\<in> set zs \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 2. r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "have \"insert_spec (xs @ zs) (i2, Some r) = xs @ (insert_spec zs (i2, Some r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_spec (xs @ zs) (i2, Some r) = xs @ insert_spec zs (i2, Some r)", "by (simp add: r_zs calculation(1) insert_second_part)"], ["proof (state)\nthis:\n  insert_spec (xs @ zs) (i2, Some r) = xs @ insert_spec zs (i2, Some r)\n\ngoal (2 subgoals):\n 1. r \\<in> set zs \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n 2. r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "ultimately"], ["proof (chain)\npicking this:\n  r \\<notin> set xs\n  r \\<notin> set ys\n  insert_spec (xs @ ys @ zs) (i2, Some r) =\n  xs @ ys @ insert_spec zs (i2, Some r)\n  insert_spec (xs @ zs) (i2, Some r) = xs @ insert_spec zs (i2, Some r)", "show ?thesis"], ["proof (prove)\nusing this:\n  r \\<notin> set xs\n  r \\<notin> set ys\n  insert_spec (xs @ ys @ zs) (i2, Some r) =\n  xs @ ys @ insert_spec zs (i2, Some r)\n  insert_spec (xs @ zs) (i2, Some r) = xs @ insert_spec zs (i2, Some r)\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "using 1 2 \\<open>oper = (i2, r2)\\<close> snoc.prems"], ["proof (prove)\nusing this:\n  r \\<notin> set xs\n  r \\<notin> set ys\n  insert_spec (xs @ ys @ zs) (i2, Some r) =\n  xs @ ys @ insert_spec zs (i2, Some r)\n  insert_spec (xs @ zs) (i2, Some r) = xs @ insert_spec zs (i2, Some r)\n  interp_ins (before @ (oid, ref) # op_list @ [(i2, r2)]) =\n  insert_spec (xs @ ys @ zs) (i2, Some r)\n  interp_ins (before @ op_list @ [(i2, r2)]) =\n  insert_spec (xs @ zs) (i2, Some r)\n  oper = (i2, r2)\n  insert_ops ops\n  insert_ops rest\n  rest = before @ op_list @ [oper]\n  ops = before @ (oid, ref) # op_list @ [oper]\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs ys zs.\n     interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n\ngoal (1 subgoal):\n 1. r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "case r_nonex"], ["proof (state)\nthis:\n  r \\<notin> set (xs @ ys @ zs)\n\ngoal (1 subgoal):\n 1. r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "then"], ["proof (chain)\npicking this:\n  r \\<notin> set (xs @ ys @ zs)", "have \"insert_spec (xs @ ys @ zs) (i2, Some r) = xs @ ys @ zs\""], ["proof (prove)\nusing this:\n  r \\<notin> set (xs @ ys @ zs)\n\ngoal (1 subgoal):\n 1. insert_spec (xs @ ys @ zs) (i2, Some r) = xs @ ys @ zs", "by simp"], ["proof (state)\nthis:\n  insert_spec (xs @ ys @ zs) (i2, Some r) = xs @ ys @ zs\n\ngoal (1 subgoal):\n 1. r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "moreover"], ["proof (state)\nthis:\n  insert_spec (xs @ ys @ zs) (i2, Some r) = xs @ ys @ zs\n\ngoal (1 subgoal):\n 1. r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "have \"insert_spec (xs @ zs) (i2, Some r) = xs @ zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_spec (xs @ zs) (i2, Some r) = xs @ zs", "using r_nonex"], ["proof (prove)\nusing this:\n  r \\<notin> set (xs @ ys @ zs)\n\ngoal (1 subgoal):\n 1. insert_spec (xs @ zs) (i2, Some r) = xs @ zs", "by simp"], ["proof (state)\nthis:\n  insert_spec (xs @ zs) (i2, Some r) = xs @ zs\n\ngoal (1 subgoal):\n 1. r \\<notin> set (xs @ ys @ zs) \\<Longrightarrow>\n    \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "ultimately"], ["proof (chain)\npicking this:\n  insert_spec (xs @ ys @ zs) (i2, Some r) = xs @ ys @ zs\n  insert_spec (xs @ zs) (i2, Some r) = xs @ zs", "show ?thesis"], ["proof (prove)\nusing this:\n  insert_spec (xs @ ys @ zs) (i2, Some r) = xs @ ys @ zs\n  insert_spec (xs @ zs) (i2, Some r) = xs @ zs\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "using 1 2 \\<open>oper = (i2, r2)\\<close> snoc.prems"], ["proof (prove)\nusing this:\n  insert_spec (xs @ ys @ zs) (i2, Some r) = xs @ ys @ zs\n  insert_spec (xs @ zs) (i2, Some r) = xs @ zs\n  interp_ins (before @ (oid, ref) # op_list @ [(i2, r2)]) =\n  insert_spec (xs @ ys @ zs) (i2, Some r)\n  interp_ins (before @ op_list @ [(i2, r2)]) =\n  insert_spec (xs @ zs) (i2, Some r)\n  oper = (i2, r2)\n  insert_ops ops\n  insert_ops rest\n  rest = before @ op_list @ [oper]\n  ops = before @ (oid, ref) # op_list @ [oper]\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs.\n       interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs ys zs.\n     interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs ys zs.\n     interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs ys zs.\n     interp_ins rest = xs @ zs \\<and> interp_ins ops = xs @ ys @ zs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_fst:\n  assumes \"distinct (map fst A)\"\n  shows \"distinct A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct A", "using assms"], ["proof (prove)\nusing this:\n  distinct (map fst A)\n\ngoal (1 subgoal):\n 1. distinct A", "by (induction A) auto"], ["", "lemma subset_distinct_le:\n  assumes \"set A \\<subseteq> set B\" and \"distinct A\" and \"distinct B\"\n  shows \"length A \\<le> length B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length A \\<le> length B", "using assms"], ["proof (prove)\nusing this:\n  set A \\<subseteq> set B\n  distinct A\n  distinct B\n\ngoal (1 subgoal):\n 1. length A \\<le> length B", "proof(induction B arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>set A \\<subseteq> set []; distinct A; distinct []\\<rbrakk>\n       \\<Longrightarrow> length A \\<le> length []\n 2. \\<And>a B A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>set A \\<subseteq> set B; distinct A;\n                    distinct B\\<rbrakk>\n                   \\<Longrightarrow> length A \\<le> length B;\n        set A \\<subseteq> set (a # B); distinct A; distinct (a # B)\\<rbrakk>\n       \\<Longrightarrow> length A \\<le> length (a # B)", "case Nil"], ["proof (state)\nthis:\n  set A \\<subseteq> set []\n  distinct A\n  distinct []\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>set A \\<subseteq> set []; distinct A; distinct []\\<rbrakk>\n       \\<Longrightarrow> length A \\<le> length []\n 2. \\<And>a B A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>set A \\<subseteq> set B; distinct A;\n                    distinct B\\<rbrakk>\n                   \\<Longrightarrow> length A \\<le> length B;\n        set A \\<subseteq> set (a # B); distinct A; distinct (a # B)\\<rbrakk>\n       \\<Longrightarrow> length A \\<le> length (a # B)", "then"], ["proof (chain)\npicking this:\n  set A \\<subseteq> set []\n  distinct A\n  distinct []", "show \"length A \\<le> length []\""], ["proof (prove)\nusing this:\n  set A \\<subseteq> set []\n  distinct A\n  distinct []\n\ngoal (1 subgoal):\n 1. length A \\<le> length []", "by simp"], ["proof (state)\nthis:\n  length A \\<le> length []\n\ngoal (1 subgoal):\n 1. \\<And>a B A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>set A \\<subseteq> set B; distinct A;\n                    distinct B\\<rbrakk>\n                   \\<Longrightarrow> length A \\<le> length B;\n        set A \\<subseteq> set (a # B); distinct A; distinct (a # B)\\<rbrakk>\n       \\<Longrightarrow> length A \\<le> length (a # B)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a B A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>set A \\<subseteq> set B; distinct A;\n                    distinct B\\<rbrakk>\n                   \\<Longrightarrow> length A \\<le> length B;\n        set A \\<subseteq> set (a # B); distinct A; distinct (a # B)\\<rbrakk>\n       \\<Longrightarrow> length A \\<le> length (a # B)", "case (Cons a B)"], ["proof (state)\nthis:\n  \\<lbrakk>set ?A \\<subseteq> set B; distinct ?A; distinct B\\<rbrakk>\n  \\<Longrightarrow> length ?A \\<le> length B\n  set A \\<subseteq> set (a # B)\n  distinct A\n  distinct (a # B)\n\ngoal (1 subgoal):\n 1. \\<And>a B A.\n       \\<lbrakk>\\<And>A.\n                   \\<lbrakk>set A \\<subseteq> set B; distinct A;\n                    distinct B\\<rbrakk>\n                   \\<Longrightarrow> length A \\<le> length B;\n        set A \\<subseteq> set (a # B); distinct A; distinct (a # B)\\<rbrakk>\n       \\<Longrightarrow> length A \\<le> length (a # B)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>set ?A \\<subseteq> set B; distinct ?A; distinct B\\<rbrakk>\n  \\<Longrightarrow> length ?A \\<le> length B\n  set A \\<subseteq> set (a # B)\n  distinct A\n  distinct (a # B)", "show \"length A \\<le> length (a # B)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?A \\<subseteq> set B; distinct ?A; distinct B\\<rbrakk>\n  \\<Longrightarrow> length ?A \\<le> length B\n  set A \\<subseteq> set (a # B)\n  distinct A\n  distinct (a # B)\n\ngoal (1 subgoal):\n 1. length A \\<le> length (a # B)", "proof(cases \"a \\<in> set A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>A.\n                \\<lbrakk>set A \\<subseteq> set B; distinct A;\n                 distinct B\\<rbrakk>\n                \\<Longrightarrow> length A \\<le> length B;\n     set A \\<subseteq> set (a # B); distinct A; distinct (a # B);\n     a \\<in> set A\\<rbrakk>\n    \\<Longrightarrow> length A \\<le> length (a # B)\n 2. \\<lbrakk>\\<And>A.\n                \\<lbrakk>set A \\<subseteq> set B; distinct A;\n                 distinct B\\<rbrakk>\n                \\<Longrightarrow> length A \\<le> length B;\n     set A \\<subseteq> set (a # B); distinct A; distinct (a # B);\n     a \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> length A \\<le> length (a # B)", "case True"], ["proof (state)\nthis:\n  a \\<in> set A\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>A.\n                \\<lbrakk>set A \\<subseteq> set B; distinct A;\n                 distinct B\\<rbrakk>\n                \\<Longrightarrow> length A \\<le> length B;\n     set A \\<subseteq> set (a # B); distinct A; distinct (a # B);\n     a \\<in> set A\\<rbrakk>\n    \\<Longrightarrow> length A \\<le> length (a # B)\n 2. \\<lbrakk>\\<And>A.\n                \\<lbrakk>set A \\<subseteq> set B; distinct A;\n                 distinct B\\<rbrakk>\n                \\<Longrightarrow> length A \\<le> length B;\n     set A \\<subseteq> set (a # B); distinct A; distinct (a # B);\n     a \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> length A \\<le> length (a # B)", "have \"set (remove1 a A) \\<subseteq> set B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (remove1 a A) \\<subseteq> set B", "using Cons.prems"], ["proof (prove)\nusing this:\n  set A \\<subseteq> set (a # B)\n  distinct A\n  distinct (a # B)\n\ngoal (1 subgoal):\n 1. set (remove1 a A) \\<subseteq> set B", "by auto"], ["proof (state)\nthis:\n  set (remove1 a A) \\<subseteq> set B\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>A.\n                \\<lbrakk>set A \\<subseteq> set B; distinct A;\n                 distinct B\\<rbrakk>\n                \\<Longrightarrow> length A \\<le> length B;\n     set A \\<subseteq> set (a # B); distinct A; distinct (a # B);\n     a \\<in> set A\\<rbrakk>\n    \\<Longrightarrow> length A \\<le> length (a # B)\n 2. \\<lbrakk>\\<And>A.\n                \\<lbrakk>set A \\<subseteq> set B; distinct A;\n                 distinct B\\<rbrakk>\n                \\<Longrightarrow> length A \\<le> length B;\n     set A \\<subseteq> set (a # B); distinct A; distinct (a # B);\n     a \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> length A \\<le> length (a # B)", "hence \"length (remove1 a A) \\<le> length B\""], ["proof (prove)\nusing this:\n  set (remove1 a A) \\<subseteq> set B\n\ngoal (1 subgoal):\n 1. length (remove1 a A) \\<le> length B", "using Cons.IH Cons.prems"], ["proof (prove)\nusing this:\n  set (remove1 a A) \\<subseteq> set B\n  \\<lbrakk>set ?A \\<subseteq> set B; distinct ?A; distinct B\\<rbrakk>\n  \\<Longrightarrow> length ?A \\<le> length B\n  set A \\<subseteq> set (a # B)\n  distinct A\n  distinct (a # B)\n\ngoal (1 subgoal):\n 1. length (remove1 a A) \\<le> length B", "by auto"], ["proof (state)\nthis:\n  length (remove1 a A) \\<le> length B\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>A.\n                \\<lbrakk>set A \\<subseteq> set B; distinct A;\n                 distinct B\\<rbrakk>\n                \\<Longrightarrow> length A \\<le> length B;\n     set A \\<subseteq> set (a # B); distinct A; distinct (a # B);\n     a \\<in> set A\\<rbrakk>\n    \\<Longrightarrow> length A \\<le> length (a # B)\n 2. \\<lbrakk>\\<And>A.\n                \\<lbrakk>set A \\<subseteq> set B; distinct A;\n                 distinct B\\<rbrakk>\n                \\<Longrightarrow> length A \\<le> length B;\n     set A \\<subseteq> set (a # B); distinct A; distinct (a # B);\n     a \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> length A \\<le> length (a # B)", "then"], ["proof (chain)\npicking this:\n  length (remove1 a A) \\<le> length B", "show \"length A \\<le> length (a # B)\""], ["proof (prove)\nusing this:\n  length (remove1 a A) \\<le> length B\n\ngoal (1 subgoal):\n 1. length A \\<le> length (a # B)", "by (simp add: True length_remove1)"], ["proof (state)\nthis:\n  length A \\<le> length (a # B)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>A.\n                \\<lbrakk>set A \\<subseteq> set B; distinct A;\n                 distinct B\\<rbrakk>\n                \\<Longrightarrow> length A \\<le> length B;\n     set A \\<subseteq> set (a # B); distinct A; distinct (a # B);\n     a \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> length A \\<le> length (a # B)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>A.\n                \\<lbrakk>set A \\<subseteq> set B; distinct A;\n                 distinct B\\<rbrakk>\n                \\<Longrightarrow> length A \\<le> length B;\n     set A \\<subseteq> set (a # B); distinct A; distinct (a # B);\n     a \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> length A \\<le> length (a # B)", "case False"], ["proof (state)\nthis:\n  a \\<notin> set A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>A.\n                \\<lbrakk>set A \\<subseteq> set B; distinct A;\n                 distinct B\\<rbrakk>\n                \\<Longrightarrow> length A \\<le> length B;\n     set A \\<subseteq> set (a # B); distinct A; distinct (a # B);\n     a \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> length A \\<le> length (a # B)", "hence \"set A \\<subseteq> set B\""], ["proof (prove)\nusing this:\n  a \\<notin> set A\n\ngoal (1 subgoal):\n 1. set A \\<subseteq> set B", "using Cons.prems"], ["proof (prove)\nusing this:\n  a \\<notin> set A\n  set A \\<subseteq> set (a # B)\n  distinct A\n  distinct (a # B)\n\ngoal (1 subgoal):\n 1. set A \\<subseteq> set B", "by auto"], ["proof (state)\nthis:\n  set A \\<subseteq> set B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>A.\n                \\<lbrakk>set A \\<subseteq> set B; distinct A;\n                 distinct B\\<rbrakk>\n                \\<Longrightarrow> length A \\<le> length B;\n     set A \\<subseteq> set (a # B); distinct A; distinct (a # B);\n     a \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> length A \\<le> length (a # B)", "hence \"length A \\<le> length B\""], ["proof (prove)\nusing this:\n  set A \\<subseteq> set B\n\ngoal (1 subgoal):\n 1. length A \\<le> length B", "using Cons.IH Cons.prems"], ["proof (prove)\nusing this:\n  set A \\<subseteq> set B\n  \\<lbrakk>set ?A \\<subseteq> set B; distinct ?A; distinct B\\<rbrakk>\n  \\<Longrightarrow> length ?A \\<le> length B\n  set A \\<subseteq> set (a # B)\n  distinct A\n  distinct (a # B)\n\ngoal (1 subgoal):\n 1. length A \\<le> length B", "by auto"], ["proof (state)\nthis:\n  length A \\<le> length B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>A.\n                \\<lbrakk>set A \\<subseteq> set B; distinct A;\n                 distinct B\\<rbrakk>\n                \\<Longrightarrow> length A \\<le> length B;\n     set A \\<subseteq> set (a # B); distinct A; distinct (a # B);\n     a \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> length A \\<le> length (a # B)", "then"], ["proof (chain)\npicking this:\n  length A \\<le> length B", "show \"length A \\<le> length (a # B)\""], ["proof (prove)\nusing this:\n  length A \\<le> length B\n\ngoal (1 subgoal):\n 1. length A \\<le> length (a # B)", "by simp"], ["proof (state)\nthis:\n  length A \\<le> length (a # B)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length A \\<le> length (a # B)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_subset_length_eq:\n  assumes \"set A \\<subseteq> set B\" and \"length B \\<le> length A\"\n    and \"distinct A\" and \"distinct B\"\n  shows \"set A = set B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set A = set B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set A = set B", "have \"length A \\<le> length B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length A \\<le> length B", "using assms"], ["proof (prove)\nusing this:\n  set A \\<subseteq> set B\n  length B \\<le> length A\n  distinct A\n  distinct B\n\ngoal (1 subgoal):\n 1. length A \\<le> length B", "by (simp add: subset_distinct_le)"], ["proof (state)\nthis:\n  length A \\<le> length B\n\ngoal (1 subgoal):\n 1. set A = set B", "moreover"], ["proof (state)\nthis:\n  length A \\<le> length B\n\ngoal (1 subgoal):\n 1. set A = set B", "from this"], ["proof (chain)\npicking this:\n  length A \\<le> length B", "have \"card (set A) = card (set B)\""], ["proof (prove)\nusing this:\n  length A \\<le> length B\n\ngoal (1 subgoal):\n 1. card (set A) = card (set B)", "using assms"], ["proof (prove)\nusing this:\n  length A \\<le> length B\n  set A \\<subseteq> set B\n  length B \\<le> length A\n  distinct A\n  distinct B\n\ngoal (1 subgoal):\n 1. card (set A) = card (set B)", "by (simp add: distinct_card le_antisym)"], ["proof (state)\nthis:\n  card (set A) = card (set B)\n\ngoal (1 subgoal):\n 1. set A = set B", "ultimately"], ["proof (chain)\npicking this:\n  length A \\<le> length B\n  card (set A) = card (set B)", "show \"set A = set B\""], ["proof (prove)\nusing this:\n  length A \\<le> length B\n  card (set A) = card (set B)\n\ngoal (1 subgoal):\n 1. set A = set B", "using assms(1)"], ["proof (prove)\nusing this:\n  length A \\<le> length B\n  card (set A) = card (set B)\n  set A \\<subseteq> set B\n\ngoal (1 subgoal):\n 1. set A = set B", "by (simp add: card_subset_eq)"], ["proof (state)\nthis:\n  set A = set B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_diff_Suc_exists:\n  assumes \"length xs - length ys = Suc m\"\n    and \"set ys \\<subseteq> set xs\"\n    and \"distinct ys\" and \"distinct xs\"\n  shows \"\\<exists>e. e \\<in> set xs \\<and> e \\<notin> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e. e \\<in> set xs \\<and> e \\<notin> set ys", "using assms"], ["proof (prove)\nusing this:\n  length xs - length ys = Suc m\n  set ys \\<subseteq> set xs\n  distinct ys\n  distinct xs\n\ngoal (1 subgoal):\n 1. \\<exists>e. e \\<in> set xs \\<and> e \\<notin> set ys", "proof(induction xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>length [] - length ys = Suc m; set ys \\<subseteq> set [];\n        distinct ys; distinct []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e. e \\<in> set [] \\<and> e \\<notin> set ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>length xs - length ys = Suc m;\n                    set ys \\<subseteq> set xs; distinct ys;\n                    distinct xs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e.\n  e \\<in> set xs \\<and> e \\<notin> set ys;\n        length (a # xs) - length ys = Suc m;\n        set ys \\<subseteq> set (a # xs); distinct ys;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e.\n                            e \\<in> set (a # xs) \\<and> e \\<notin> set ys", "case Nil"], ["proof (state)\nthis:\n  length [] - length ys = Suc m\n  set ys \\<subseteq> set []\n  distinct ys\n  distinct []\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>length [] - length ys = Suc m; set ys \\<subseteq> set [];\n        distinct ys; distinct []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e. e \\<in> set [] \\<and> e \\<notin> set ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>length xs - length ys = Suc m;\n                    set ys \\<subseteq> set xs; distinct ys;\n                    distinct xs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e.\n  e \\<in> set xs \\<and> e \\<notin> set ys;\n        length (a # xs) - length ys = Suc m;\n        set ys \\<subseteq> set (a # xs); distinct ys;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e.\n                            e \\<in> set (a # xs) \\<and> e \\<notin> set ys", "then"], ["proof (chain)\npicking this:\n  length [] - length ys = Suc m\n  set ys \\<subseteq> set []\n  distinct ys\n  distinct []", "show \"\\<exists>e. e \\<in> set [] \\<and> e \\<notin> set ys\""], ["proof (prove)\nusing this:\n  length [] - length ys = Suc m\n  set ys \\<subseteq> set []\n  distinct ys\n  distinct []\n\ngoal (1 subgoal):\n 1. \\<exists>e. e \\<in> set [] \\<and> e \\<notin> set ys", "by simp"], ["proof (state)\nthis:\n  \\<exists>e. e \\<in> set [] \\<and> e \\<notin> set ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>length xs - length ys = Suc m;\n                    set ys \\<subseteq> set xs; distinct ys;\n                    distinct xs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e.\n  e \\<in> set xs \\<and> e \\<notin> set ys;\n        length (a # xs) - length ys = Suc m;\n        set ys \\<subseteq> set (a # xs); distinct ys;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e.\n                            e \\<in> set (a # xs) \\<and> e \\<notin> set ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>length xs - length ys = Suc m;\n                    set ys \\<subseteq> set xs; distinct ys;\n                    distinct xs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e.\n  e \\<in> set xs \\<and> e \\<notin> set ys;\n        length (a # xs) - length ys = Suc m;\n        set ys \\<subseteq> set (a # xs); distinct ys;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e.\n                            e \\<in> set (a # xs) \\<and> e \\<notin> set ys", "case (Cons a xs)"], ["proof (state)\nthis:\n  \\<lbrakk>length xs - length ?ys = Suc m; set ?ys \\<subseteq> set xs;\n   distinct ?ys; distinct xs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e. e \\<in> set xs \\<and> e \\<notin> set ?ys\n  length (a # xs) - length ys = Suc m\n  set ys \\<subseteq> set (a # xs)\n  distinct ys\n  distinct (a # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>length xs - length ys = Suc m;\n                    set ys \\<subseteq> set xs; distinct ys;\n                    distinct xs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>e.\n  e \\<in> set xs \\<and> e \\<notin> set ys;\n        length (a # xs) - length ys = Suc m;\n        set ys \\<subseteq> set (a # xs); distinct ys;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e.\n                            e \\<in> set (a # xs) \\<and> e \\<notin> set ys", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>length xs - length ?ys = Suc m; set ?ys \\<subseteq> set xs;\n   distinct ?ys; distinct xs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e. e \\<in> set xs \\<and> e \\<notin> set ?ys\n  length (a # xs) - length ys = Suc m\n  set ys \\<subseteq> set (a # xs)\n  distinct ys\n  distinct (a # xs)", "show \"\\<exists>e. e \\<in> set (a # xs) \\<and> e \\<notin> set ys\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length xs - length ?ys = Suc m; set ?ys \\<subseteq> set xs;\n   distinct ?ys; distinct xs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e. e \\<in> set xs \\<and> e \\<notin> set ?ys\n  length (a # xs) - length ys = Suc m\n  set ys \\<subseteq> set (a # xs)\n  distinct ys\n  distinct (a # xs)\n\ngoal (1 subgoal):\n 1. \\<exists>e. e \\<in> set (a # xs) \\<and> e \\<notin> set ys", "proof(cases \"a \\<in> set ys\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ys.\n                \\<lbrakk>length xs - length ys = Suc m;\n                 set ys \\<subseteq> set xs; distinct ys;\n                 distinct xs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>e.\n                                     e \\<in> set xs \\<and>\n                                     e \\<notin> set ys;\n     length (a # xs) - length ys = Suc m; set ys \\<subseteq> set (a # xs);\n     distinct ys; distinct (a # xs); a \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         e \\<in> set (a # xs) \\<and> e \\<notin> set ys\n 2. \\<lbrakk>\\<And>ys.\n                \\<lbrakk>length xs - length ys = Suc m;\n                 set ys \\<subseteq> set xs; distinct ys;\n                 distinct xs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>e.\n                                     e \\<in> set xs \\<and>\n                                     e \\<notin> set ys;\n     length (a # xs) - length ys = Suc m; set ys \\<subseteq> set (a # xs);\n     distinct ys; distinct (a # xs); a \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         e \\<in> set (a # xs) \\<and> e \\<notin> set ys", "case True"], ["proof (state)\nthis:\n  a \\<in> set ys\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ys.\n                \\<lbrakk>length xs - length ys = Suc m;\n                 set ys \\<subseteq> set xs; distinct ys;\n                 distinct xs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>e.\n                                     e \\<in> set xs \\<and>\n                                     e \\<notin> set ys;\n     length (a # xs) - length ys = Suc m; set ys \\<subseteq> set (a # xs);\n     distinct ys; distinct (a # xs); a \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         e \\<in> set (a # xs) \\<and> e \\<notin> set ys\n 2. \\<lbrakk>\\<And>ys.\n                \\<lbrakk>length xs - length ys = Suc m;\n                 set ys \\<subseteq> set xs; distinct ys;\n                 distinct xs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>e.\n                                     e \\<in> set xs \\<and>\n                                     e \\<notin> set ys;\n     length (a # xs) - length ys = Suc m; set ys \\<subseteq> set (a # xs);\n     distinct ys; distinct (a # xs); a \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         e \\<in> set (a # xs) \\<and> e \\<notin> set ys", "have IH: \"\\<exists>e. e \\<in> set xs \\<and> e \\<notin> set (remove1 a ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e. e \\<in> set xs \\<and> e \\<notin> set (remove1 a ys)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>e. e \\<in> set xs \\<and> e \\<notin> set (remove1 a ys)", "have \"length xs - length (remove1 a ys) = Suc m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs - length (remove1 a ys) = Suc m", "by (metis Cons.prems(1) One_nat_def Suc_pred True diff_Suc_Suc length_Cons\n            length_pos_if_in_set length_remove1)"], ["proof (state)\nthis:\n  length xs - length (remove1 a ys) = Suc m\n\ngoal (1 subgoal):\n 1. \\<exists>e. e \\<in> set xs \\<and> e \\<notin> set (remove1 a ys)", "moreover"], ["proof (state)\nthis:\n  length xs - length (remove1 a ys) = Suc m\n\ngoal (1 subgoal):\n 1. \\<exists>e. e \\<in> set xs \\<and> e \\<notin> set (remove1 a ys)", "have \"set (remove1 a ys) \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (remove1 a ys) \\<subseteq> set xs", "using Cons.prems"], ["proof (prove)\nusing this:\n  length (a # xs) - length ys = Suc m\n  set ys \\<subseteq> set (a # xs)\n  distinct ys\n  distinct (a # xs)\n\ngoal (1 subgoal):\n 1. set (remove1 a ys) \\<subseteq> set xs", "by auto"], ["proof (state)\nthis:\n  set (remove1 a ys) \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. \\<exists>e. e \\<in> set xs \\<and> e \\<notin> set (remove1 a ys)", "ultimately"], ["proof (chain)\npicking this:\n  length xs - length (remove1 a ys) = Suc m\n  set (remove1 a ys) \\<subseteq> set xs", "show ?thesis"], ["proof (prove)\nusing this:\n  length xs - length (remove1 a ys) = Suc m\n  set (remove1 a ys) \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. \\<exists>e. e \\<in> set xs \\<and> e \\<notin> set (remove1 a ys)", "by (meson Cons.IH Cons.prems distinct.simps(2) distinct_remove1)"], ["proof (state)\nthis:\n  \\<exists>e. e \\<in> set xs \\<and> e \\<notin> set (remove1 a ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>e. e \\<in> set xs \\<and> e \\<notin> set (remove1 a ys)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ys.\n                \\<lbrakk>length xs - length ys = Suc m;\n                 set ys \\<subseteq> set xs; distinct ys;\n                 distinct xs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>e.\n                                     e \\<in> set xs \\<and>\n                                     e \\<notin> set ys;\n     length (a # xs) - length ys = Suc m; set ys \\<subseteq> set (a # xs);\n     distinct ys; distinct (a # xs); a \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         e \\<in> set (a # xs) \\<and> e \\<notin> set ys\n 2. \\<lbrakk>\\<And>ys.\n                \\<lbrakk>length xs - length ys = Suc m;\n                 set ys \\<subseteq> set xs; distinct ys;\n                 distinct xs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>e.\n                                     e \\<in> set xs \\<and>\n                                     e \\<notin> set ys;\n     length (a # xs) - length ys = Suc m; set ys \\<subseteq> set (a # xs);\n     distinct ys; distinct (a # xs); a \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         e \\<in> set (a # xs) \\<and> e \\<notin> set ys", "moreover"], ["proof (state)\nthis:\n  \\<exists>e. e \\<in> set xs \\<and> e \\<notin> set (remove1 a ys)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ys.\n                \\<lbrakk>length xs - length ys = Suc m;\n                 set ys \\<subseteq> set xs; distinct ys;\n                 distinct xs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>e.\n                                     e \\<in> set xs \\<and>\n                                     e \\<notin> set ys;\n     length (a # xs) - length ys = Suc m; set ys \\<subseteq> set (a # xs);\n     distinct ys; distinct (a # xs); a \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         e \\<in> set (a # xs) \\<and> e \\<notin> set ys\n 2. \\<lbrakk>\\<And>ys.\n                \\<lbrakk>length xs - length ys = Suc m;\n                 set ys \\<subseteq> set xs; distinct ys;\n                 distinct xs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>e.\n                                     e \\<in> set xs \\<and>\n                                     e \\<notin> set ys;\n     length (a # xs) - length ys = Suc m; set ys \\<subseteq> set (a # xs);\n     distinct ys; distinct (a # xs); a \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         e \\<in> set (a # xs) \\<and> e \\<notin> set ys", "have \"set ys - {a} \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ys - {a} \\<subseteq> set xs", "using Cons.prems(2)"], ["proof (prove)\nusing this:\n  set ys \\<subseteq> set (a # xs)\n\ngoal (1 subgoal):\n 1. set ys - {a} \\<subseteq> set xs", "by auto"], ["proof (state)\nthis:\n  set ys - {a} \\<subseteq> set xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ys.\n                \\<lbrakk>length xs - length ys = Suc m;\n                 set ys \\<subseteq> set xs; distinct ys;\n                 distinct xs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>e.\n                                     e \\<in> set xs \\<and>\n                                     e \\<notin> set ys;\n     length (a # xs) - length ys = Suc m; set ys \\<subseteq> set (a # xs);\n     distinct ys; distinct (a # xs); a \\<in> set ys\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         e \\<in> set (a # xs) \\<and> e \\<notin> set ys\n 2. \\<lbrakk>\\<And>ys.\n                \\<lbrakk>length xs - length ys = Suc m;\n                 set ys \\<subseteq> set xs; distinct ys;\n                 distinct xs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>e.\n                                     e \\<in> set xs \\<and>\n                                     e \\<notin> set ys;\n     length (a # xs) - length ys = Suc m; set ys \\<subseteq> set (a # xs);\n     distinct ys; distinct (a # xs); a \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         e \\<in> set (a # xs) \\<and> e \\<notin> set ys", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>e. e \\<in> set xs \\<and> e \\<notin> set (remove1 a ys)\n  set ys - {a} \\<subseteq> set xs", "show \"\\<exists>e. e \\<in> set (a # xs) \\<and> e \\<notin> set ys\""], ["proof (prove)\nusing this:\n  \\<exists>e. e \\<in> set xs \\<and> e \\<notin> set (remove1 a ys)\n  set ys - {a} \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. \\<exists>e. e \\<in> set (a # xs) \\<and> e \\<notin> set ys", "by (metis Cons.prems(4) distinct.simps(2) in_set_remove1 set_subset_Cons subsetCE)"], ["proof (state)\nthis:\n  \\<exists>e. e \\<in> set (a # xs) \\<and> e \\<notin> set ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ys.\n                \\<lbrakk>length xs - length ys = Suc m;\n                 set ys \\<subseteq> set xs; distinct ys;\n                 distinct xs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>e.\n                                     e \\<in> set xs \\<and>\n                                     e \\<notin> set ys;\n     length (a # xs) - length ys = Suc m; set ys \\<subseteq> set (a # xs);\n     distinct ys; distinct (a # xs); a \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         e \\<in> set (a # xs) \\<and> e \\<notin> set ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ys.\n                \\<lbrakk>length xs - length ys = Suc m;\n                 set ys \\<subseteq> set xs; distinct ys;\n                 distinct xs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>e.\n                                     e \\<in> set xs \\<and>\n                                     e \\<notin> set ys;\n     length (a # xs) - length ys = Suc m; set ys \\<subseteq> set (a # xs);\n     distinct ys; distinct (a # xs); a \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         e \\<in> set (a # xs) \\<and> e \\<notin> set ys", "case False"], ["proof (state)\nthis:\n  a \\<notin> set ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ys.\n                \\<lbrakk>length xs - length ys = Suc m;\n                 set ys \\<subseteq> set xs; distinct ys;\n                 distinct xs\\<rbrakk>\n                \\<Longrightarrow> \\<exists>e.\n                                     e \\<in> set xs \\<and>\n                                     e \\<notin> set ys;\n     length (a # xs) - length ys = Suc m; set ys \\<subseteq> set (a # xs);\n     distinct ys; distinct (a # xs); a \\<notin> set ys\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         e \\<in> set (a # xs) \\<and> e \\<notin> set ys", "then"], ["proof (chain)\npicking this:\n  a \\<notin> set ys", "show \"\\<exists>e. e \\<in> set (a # xs) \\<and> e \\<notin> set ys\""], ["proof (prove)\nusing this:\n  a \\<notin> set ys\n\ngoal (1 subgoal):\n 1. \\<exists>e. e \\<in> set (a # xs) \\<and> e \\<notin> set ys", "by auto"], ["proof (state)\nthis:\n  \\<exists>e. e \\<in> set (a # xs) \\<and> e \\<notin> set ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>e. e \\<in> set (a # xs) \\<and> e \\<notin> set ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma app_length_lt_exists:\n  assumes \"xsa @ zsa = xs @ ys\"\n    and \"length xsa \\<le> length xs\"\n  shows \"xsa @ (drop (length xsa) xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xsa @ drop (length xsa) xs = xs", "using assms"], ["proof (prove)\nusing this:\n  xsa @ zsa = xs @ ys\n  length xsa \\<le> length xs\n\ngoal (1 subgoal):\n 1. xsa @ drop (length xsa) xs = xs", "by (induction xsa arbitrary: xs zsa ys, simp,\n      metis append_eq_append_conv_if append_take_drop_id)"], ["", "lemma list_order_monotonic:\n  assumes \"insert_ops A\" and \"insert_ops B\"\n    and \"set A \\<subseteq> set B\"\n    and \"list_order A x y\"\n  shows \"list_order B x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_order B x y", "using assms"], ["proof (prove)\nusing this:\n  insert_ops A\n  insert_ops B\n  set A \\<subseteq> set B\n  list_order A x y\n\ngoal (1 subgoal):\n 1. list_order B x y", "proof(induction rule: measure_induct_rule[where f=\"\\<lambda>x. (length x - length A)\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>ya.\n                   \\<lbrakk>length ya - length A < length xa - length A;\n                    insert_ops A; insert_ops ya; set A \\<subseteq> set ya;\n                    list_order A x y\\<rbrakk>\n                   \\<Longrightarrow> list_order ya x y;\n        insert_ops A; insert_ops xa; set A \\<subseteq> set xa;\n        list_order A x y\\<rbrakk>\n       \\<Longrightarrow> list_order xa x y", "case (less xa)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?y - length A < length xa - length A; insert_ops A;\n   insert_ops ?y; set A \\<subseteq> set ?y; list_order A x y\\<rbrakk>\n  \\<Longrightarrow> list_order ?y x y\n  insert_ops A\n  insert_ops xa\n  set A \\<subseteq> set xa\n  list_order A x y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>ya.\n                   \\<lbrakk>length ya - length A < length xa - length A;\n                    insert_ops A; insert_ops ya; set A \\<subseteq> set ya;\n                    list_order A x y\\<rbrakk>\n                   \\<Longrightarrow> list_order ya x y;\n        insert_ops A; insert_ops xa; set A \\<subseteq> set xa;\n        list_order A x y\\<rbrakk>\n       \\<Longrightarrow> list_order xa x y", "have \"distinct (map fst A)\" and \"distinct (map fst xa)\" and\n    \"sorted (map fst A)\" and \"sorted (map fst xa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (distinct (map fst A) &&& distinct (map fst xa)) &&&\n    sorted (map fst A) &&& sorted (map fst xa)", "using less.prems"], ["proof (prove)\nusing this:\n  insert_ops A\n  insert_ops xa\n  set A \\<subseteq> set xa\n  list_order A x y\n\ngoal (1 subgoal):\n 1. (distinct (map fst A) &&& distinct (map fst xa)) &&&\n    sorted (map fst A) &&& sorted (map fst xa)", "by (auto simp add: insert_ops_def spec_ops_def)"], ["proof (state)\nthis:\n  distinct (map fst A)\n  distinct (map fst xa)\n  sorted (map fst A)\n  sorted (map fst xa)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>ya.\n                   \\<lbrakk>length ya - length A < length xa - length A;\n                    insert_ops A; insert_ops ya; set A \\<subseteq> set ya;\n                    list_order A x y\\<rbrakk>\n                   \\<Longrightarrow> list_order ya x y;\n        insert_ops A; insert_ops xa; set A \\<subseteq> set xa;\n        list_order A x y\\<rbrakk>\n       \\<Longrightarrow> list_order xa x y", "hence \"distinct A\" and \"distinct xa\""], ["proof (prove)\nusing this:\n  distinct (map fst A)\n  distinct (map fst xa)\n  sorted (map fst A)\n  sorted (map fst xa)\n\ngoal (1 subgoal):\n 1. distinct A &&& distinct xa", "by (auto simp add: distinct_fst)"], ["proof (state)\nthis:\n  distinct A\n  distinct xa\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>ya.\n                   \\<lbrakk>length ya - length A < length xa - length A;\n                    insert_ops A; insert_ops ya; set A \\<subseteq> set ya;\n                    list_order A x y\\<rbrakk>\n                   \\<Longrightarrow> list_order ya x y;\n        insert_ops A; insert_ops xa; set A \\<subseteq> set xa;\n        list_order A x y\\<rbrakk>\n       \\<Longrightarrow> list_order xa x y", "then"], ["proof (chain)\npicking this:\n  distinct A\n  distinct xa", "show \"list_order xa x y\""], ["proof (prove)\nusing this:\n  distinct A\n  distinct xa\n\ngoal (1 subgoal):\n 1. list_order xa x y", "proof(cases \"length xa - length A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct A; distinct xa; length xa - length A = 0\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y\n 2. \\<And>nat.\n       \\<lbrakk>distinct A; distinct xa;\n        length xa - length A = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list_order xa x y", "case 0"], ["proof (state)\nthis:\n  length xa - length A = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct A; distinct xa; length xa - length A = 0\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y\n 2. \\<And>nat.\n       \\<lbrakk>distinct A; distinct xa;\n        length xa - length A = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list_order xa x y", "hence \"set A = set xa\""], ["proof (prove)\nusing this:\n  length xa - length A = 0\n\ngoal (1 subgoal):\n 1. set A = set xa", "using set_subset_length_eq less.prems(3) \\<open>distinct A\\<close> \\<open>distinct xa\\<close> diff_is_0_eq"], ["proof (prove)\nusing this:\n  length xa - length A = 0\n  \\<lbrakk>set ?A \\<subseteq> set ?B; length ?B \\<le> length ?A;\n   distinct ?A; distinct ?B\\<rbrakk>\n  \\<Longrightarrow> set ?A = set ?B\n  set A \\<subseteq> set xa\n  distinct A\n  distinct xa\n  (?m - ?n = 0) = (?m \\<le> ?n)\n\ngoal (1 subgoal):\n 1. set A = set xa", "by blast"], ["proof (state)\nthis:\n  set A = set xa\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct A; distinct xa; length xa - length A = 0\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y\n 2. \\<And>nat.\n       \\<lbrakk>distinct A; distinct xa;\n        length xa - length A = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list_order xa x y", "hence \"A = xa\""], ["proof (prove)\nusing this:\n  set A = set xa\n\ngoal (1 subgoal):\n 1. A = xa", "using \\<open>distinct (map fst A)\\<close> \\<open>distinct (map fst xa)\\<close>\n        \\<open>sorted (map fst A)\\<close> \\<open>sorted (map fst xa)\\<close> map_sorted_distinct_set_unique"], ["proof (prove)\nusing this:\n  set A = set xa\n  distinct (map fst A)\n  distinct (map fst xa)\n  sorted (map fst A)\n  sorted (map fst xa)\n  \\<lbrakk>inj_on ?f (set ?xs \\<union> set ?ys); sorted (map ?f ?xs);\n   distinct (map ?f ?xs); sorted (map ?f ?ys); distinct (map ?f ?ys);\n   set ?xs = set ?ys\\<rbrakk>\n  \\<Longrightarrow> ?xs = ?ys\n\ngoal (1 subgoal):\n 1. A = xa", "by (metis distinct_map less.prems(3) subset_Un_eq)"], ["proof (state)\nthis:\n  A = xa\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct A; distinct xa; length xa - length A = 0\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y\n 2. \\<And>nat.\n       \\<lbrakk>distinct A; distinct xa;\n        length xa - length A = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list_order xa x y", "then"], ["proof (chain)\npicking this:\n  A = xa", "show \"list_order xa x y\""], ["proof (prove)\nusing this:\n  A = xa\n\ngoal (1 subgoal):\n 1. list_order xa x y", "using less.prems(4)"], ["proof (prove)\nusing this:\n  A = xa\n  list_order A x y\n\ngoal (1 subgoal):\n 1. list_order xa x y", "by blast"], ["proof (state)\nthis:\n  list_order xa x y\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>distinct A; distinct xa;\n        length xa - length A = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list_order xa x y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>distinct A; distinct xa;\n        length xa - length A = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list_order xa x y", "case (Suc nat)"], ["proof (state)\nthis:\n  length xa - length A = Suc nat\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>distinct A; distinct xa;\n        length xa - length A = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list_order xa x y", "then"], ["proof (chain)\npicking this:\n  length xa - length A = Suc nat", "obtain e where \"e \\<in> set xa\" and \"e \\<notin> set A\""], ["proof (prove)\nusing this:\n  length xa - length A = Suc nat\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>e \\<in> set xa; e \\<notin> set A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using length_diff_Suc_exists \\<open>distinct A\\<close> \\<open>distinct xa\\<close> less.prems(3)"], ["proof (prove)\nusing this:\n  length xa - length A = Suc nat\n  \\<lbrakk>length ?xs - length ?ys = Suc ?m; set ?ys \\<subseteq> set ?xs;\n   distinct ?ys; distinct ?xs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e. e \\<in> set ?xs \\<and> e \\<notin> set ?ys\n  distinct A\n  distinct xa\n  set A \\<subseteq> set xa\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>e \\<in> set xa; e \\<notin> set A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  e \\<in> set xa\n  e \\<notin> set A\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>distinct A; distinct xa;\n        length xa - length A = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list_order xa x y", "hence IH: \"list_order (remove1 e xa) x y\""], ["proof (prove)\nusing this:\n  e \\<in> set xa\n  e \\<notin> set A\n\ngoal (1 subgoal):\n 1. list_order (remove1 e xa) x y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> set xa; e \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> list_order (remove1 e xa) x y", "have \"length (remove1 e xa) - length A < Suc nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (remove1 e xa) - length A < Suc nat", "using diff_Suc_1 diff_commute length_remove1 less_Suc_eq Suc \\<open>e \\<in> set xa\\<close>"], ["proof (prove)\nusing this:\n  Suc ?n - 1 = ?n\n  ?i - ?j - ?k = ?i - ?k - ?j\n  length (remove1 ?x ?xs) =\n  (if ?x \\<in> set ?xs then length ?xs - 1 else length ?xs)\n  (?m < Suc ?n) = (?m < ?n \\<or> ?m = ?n)\n  length xa - length A = Suc nat\n  e \\<in> set xa\n\ngoal (1 subgoal):\n 1. length (remove1 e xa) - length A < Suc nat", "by metis"], ["proof (state)\nthis:\n  length (remove1 e xa) - length A < Suc nat\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> set xa; e \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> list_order (remove1 e xa) x y", "moreover"], ["proof (state)\nthis:\n  length (remove1 e xa) - length A < Suc nat\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> set xa; e \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> list_order (remove1 e xa) x y", "have \"insert_ops (remove1 e xa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert_ops (remove1 e xa)", "by (simp add: insert_ops_remove1 less.prems(2))"], ["proof (state)\nthis:\n  insert_ops (remove1 e xa)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> set xa; e \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> list_order (remove1 e xa) x y", "moreover"], ["proof (state)\nthis:\n  insert_ops (remove1 e xa)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> set xa; e \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> list_order (remove1 e xa) x y", "have \"set A \\<subseteq> set (remove1 e xa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set A \\<subseteq> set (remove1 e xa)", "by (metis (no_types, lifting) \\<open>e \\<notin> set A\\<close> in_set_remove1 less.prems(3) rev_subsetD subsetI)"], ["proof (state)\nthis:\n  set A \\<subseteq> set (remove1 e xa)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<in> set xa; e \\<notin> set A\\<rbrakk>\n    \\<Longrightarrow> list_order (remove1 e xa) x y", "ultimately"], ["proof (chain)\npicking this:\n  length (remove1 e xa) - length A < Suc nat\n  insert_ops (remove1 e xa)\n  set A \\<subseteq> set (remove1 e xa)", "show ?thesis"], ["proof (prove)\nusing this:\n  length (remove1 e xa) - length A < Suc nat\n  insert_ops (remove1 e xa)\n  set A \\<subseteq> set (remove1 e xa)\n\ngoal (1 subgoal):\n 1. list_order (remove1 e xa) x y", "by (simp add: Suc less.IH less.prems(1) less.prems(4))"], ["proof (state)\nthis:\n  list_order (remove1 e xa) x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_order (remove1 e xa) x y\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>distinct A; distinct xa;\n        length xa - length A = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list_order xa x y", "then"], ["proof (chain)\npicking this:\n  list_order (remove1 e xa) x y", "obtain xs ys zs where \"interp_ins (remove1 e xa) = xs @ x # ys @ y # zs\""], ["proof (prove)\nusing this:\n  list_order (remove1 e xa) x y\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys zs.\n        interp_ins (remove1 e xa) = xs @ x # ys @ y # zs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using list_order_def"], ["proof (prove)\nusing this:\n  list_order (remove1 e xa) x y\n  list_order ?ops ?x ?y \\<equiv>\n  \\<exists>xs ys zs. interp_ins ?ops = xs @ [?x] @ ys @ [?y] @ zs\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys zs.\n        interp_ins (remove1 e xa) = xs @ x # ys @ y # zs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  interp_ins (remove1 e xa) = xs @ x # ys @ y # zs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>distinct A; distinct xa;\n        length xa - length A = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list_order xa x y", "moreover"], ["proof (state)\nthis:\n  interp_ins (remove1 e xa) = xs @ x # ys @ y # zs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>distinct A; distinct xa;\n        length xa - length A = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list_order xa x y", "obtain oid ref where e_pair: \"e = (oid, ref)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>oid ref.\n        e = (oid, ref) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  e = (oid, ref)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>distinct A; distinct xa;\n        length xa - length A = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list_order xa x y", "moreover"], ["proof (state)\nthis:\n  e = (oid, ref)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>distinct A; distinct xa;\n        length xa - length A = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list_order xa x y", "obtain ps ss where xa_split: \"xa = ps @ [e] @ ss\" and \"e \\<notin> set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps ss.\n        \\<lbrakk>xa = ps @ [e] @ ss; e \\<notin> set ps\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using split_list_first \\<open>e \\<in> set xa\\<close>"], ["proof (prove)\nusing this:\n  ?x \\<in> set ?xs \\<Longrightarrow>\n  \\<exists>ys zs. ?xs = ys @ ?x # zs \\<and> ?x \\<notin> set ys\n  e \\<in> set xa\n\ngoal (1 subgoal):\n 1. (\\<And>ps ss.\n        \\<lbrakk>xa = ps @ [e] @ ss; e \\<notin> set ps\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xa = ps @ [e] @ ss\n  e \\<notin> set ps\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>distinct A; distinct xa;\n        length xa - length A = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list_order xa x y", "hence \"remove1 e (ps @ e # ss) = ps @ ss\""], ["proof (prove)\nusing this:\n  xa = ps @ [e] @ ss\n  e \\<notin> set ps\n\ngoal (1 subgoal):\n 1. remove1 e (ps @ e # ss) = ps @ ss", "by (simp add: remove1_append)"], ["proof (state)\nthis:\n  remove1 e (ps @ e # ss) = ps @ ss\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>distinct A; distinct xa;\n        length xa - length A = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list_order xa x y", "moreover"], ["proof (state)\nthis:\n  remove1 e (ps @ e # ss) = ps @ ss\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>distinct A; distinct xa;\n        length xa - length A = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list_order xa x y", "from this"], ["proof (chain)\npicking this:\n  remove1 e (ps @ e # ss) = ps @ ss", "have \"insert_ops (ps @ ss)\" and \"insert_ops (ps @ e # ss)\""], ["proof (prove)\nusing this:\n  remove1 e (ps @ e # ss) = ps @ ss\n\ngoal (1 subgoal):\n 1. insert_ops (ps @ ss) &&& insert_ops (ps @ e # ss)", "using xa_split less.prems(2)"], ["proof (prove)\nusing this:\n  remove1 e (ps @ e # ss) = ps @ ss\n  xa = ps @ [e] @ ss\n  insert_ops xa\n\ngoal (1 subgoal):\n 1. insert_ops (ps @ ss) &&& insert_ops (ps @ e # ss)", "by (metis append_Cons append_Nil insert_ops_remove1, auto)"], ["proof (state)\nthis:\n  insert_ops (ps @ ss)\n  insert_ops (ps @ e # ss)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>distinct A; distinct xa;\n        length xa - length A = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list_order xa x y", "then"], ["proof (chain)\npicking this:\n  insert_ops (ps @ ss)\n  insert_ops (ps @ e # ss)", "obtain xsa ysa zsa where \"interp_ins (ps @ ss) = xsa @ zsa\"\n      and interp_xa: \"interp_ins (ps @ (oid, ref) # ss) = xsa @ ysa @ zsa\""], ["proof (prove)\nusing this:\n  insert_ops (ps @ ss)\n  insert_ops (ps @ e # ss)\n\ngoal (1 subgoal):\n 1. (\\<And>xsa zsa ysa.\n        \\<lbrakk>interp_ins (ps @ ss) = xsa @ zsa;\n         interp_ins (ps @ (oid, ref) # ss) = xsa @ ysa @ zsa\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using insert_preserves_order e_pair"], ["proof (prove)\nusing this:\n  insert_ops (ps @ ss)\n  insert_ops (ps @ e # ss)\n  \\<lbrakk>insert_ops ?ops; insert_ops ?rest; ?rest = ?before @ ?after;\n   ?ops = ?before @ (?oid, ?ref) # ?after\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs ys zs.\n                       interp_ins ?rest = xs @ zs \\<and>\n                       interp_ins ?ops = xs @ ys @ zs\n  e = (oid, ref)\n\ngoal (1 subgoal):\n 1. (\\<And>xsa zsa ysa.\n        \\<lbrakk>interp_ins (ps @ ss) = xsa @ zsa;\n         interp_ins (ps @ (oid, ref) # ss) = xsa @ ysa @ zsa\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  interp_ins (ps @ ss) = xsa @ zsa\n  interp_ins (ps @ (oid, ref) # ss) = xsa @ ysa @ zsa\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>distinct A; distinct xa;\n        length xa - length A = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list_order xa x y", "moreover"], ["proof (state)\nthis:\n  interp_ins (ps @ ss) = xsa @ zsa\n  interp_ins (ps @ (oid, ref) # ss) = xsa @ ysa @ zsa\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>distinct A; distinct xa;\n        length xa - length A = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list_order xa x y", "have xsa_zsa: \"xsa @ zsa = xs @ x # ys @ y # zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xsa @ zsa = xs @ x # ys @ y # zs", "using interp_ins_def remove1_append calculation xa_split"], ["proof (prove)\nusing this:\n  interp_ins ?ops \\<equiv> foldl insert_spec [] ?ops\n  remove1 ?x (?xs @ ?ys) =\n  (if ?x \\<in> set ?xs then remove1 ?x ?xs @ ?ys else ?xs @ remove1 ?x ?ys)\n  interp_ins (remove1 e xa) = xs @ x # ys @ y # zs\n  e = (oid, ref)\n  remove1 e (ps @ e # ss) = ps @ ss\n  interp_ins (ps @ ss) = xsa @ zsa\n  interp_ins (ps @ (oid, ref) # ss) = xsa @ ysa @ zsa\n  xa = ps @ [e] @ ss\n\ngoal (1 subgoal):\n 1. xsa @ zsa = xs @ x # ys @ y # zs", "by auto"], ["proof (state)\nthis:\n  xsa @ zsa = xs @ x # ys @ y # zs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>distinct A; distinct xa;\n        length xa - length A = Suc nat\\<rbrakk>\n       \\<Longrightarrow> list_order xa x y", "then"], ["proof (chain)\npicking this:\n  xsa @ zsa = xs @ x # ys @ y # zs", "show \"list_order xa x y\""], ["proof (prove)\nusing this:\n  xsa @ zsa = xs @ x # ys @ y # zs\n\ngoal (1 subgoal):\n 1. list_order xa x y", "proof(cases \"length xsa \\<le> length xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>xsa @ zsa = xs @ x # ys @ y # zs;\n     length xsa \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y\n 2. \\<lbrakk>xsa @ zsa = xs @ x # ys @ y # zs;\n     \\<not> length xsa \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y", "case True"], ["proof (state)\nthis:\n  length xsa \\<le> length xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xsa @ zsa = xs @ x # ys @ y # zs;\n     length xsa \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y\n 2. \\<lbrakk>xsa @ zsa = xs @ x # ys @ y # zs;\n     \\<not> length xsa \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y", "then"], ["proof (chain)\npicking this:\n  length xsa \\<le> length xs", "obtain ts where \"xsa@ts = xs\""], ["proof (prove)\nusing this:\n  length xsa \\<le> length xs\n\ngoal (1 subgoal):\n 1. (\\<And>ts. xsa @ ts = xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using app_length_lt_exists xsa_zsa"], ["proof (prove)\nusing this:\n  length xsa \\<le> length xs\n  \\<lbrakk>?xsa @ ?zsa = ?xs @ ?ys; length ?xsa \\<le> length ?xs\\<rbrakk>\n  \\<Longrightarrow> ?xsa @ drop (length ?xsa) ?xs = ?xs\n  xsa @ zsa = xs @ x # ys @ y # zs\n\ngoal (1 subgoal):\n 1. (\\<And>ts. xsa @ ts = xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  xsa @ ts = xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xsa @ zsa = xs @ x # ys @ y # zs;\n     length xsa \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y\n 2. \\<lbrakk>xsa @ zsa = xs @ x # ys @ y # zs;\n     \\<not> length xsa \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y", "hence \"interp_ins xa = (xsa @ ysa @ ts) @ [x] @ ys @ [y] @ zs\""], ["proof (prove)\nusing this:\n  xsa @ ts = xs\n\ngoal (1 subgoal):\n 1. interp_ins xa = (xsa @ ysa @ ts) @ [x] @ ys @ [y] @ zs", "using calculation xa_split"], ["proof (prove)\nusing this:\n  xsa @ ts = xs\n  interp_ins (remove1 e xa) = xs @ x # ys @ y # zs\n  e = (oid, ref)\n  remove1 e (ps @ e # ss) = ps @ ss\n  interp_ins (ps @ ss) = xsa @ zsa\n  interp_ins (ps @ (oid, ref) # ss) = xsa @ ysa @ zsa\n  xa = ps @ [e] @ ss\n\ngoal (1 subgoal):\n 1. interp_ins xa = (xsa @ ysa @ ts) @ [x] @ ys @ [y] @ zs", "by auto"], ["proof (state)\nthis:\n  interp_ins xa = (xsa @ ysa @ ts) @ [x] @ ys @ [y] @ zs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xsa @ zsa = xs @ x # ys @ y # zs;\n     length xsa \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y\n 2. \\<lbrakk>xsa @ zsa = xs @ x # ys @ y # zs;\n     \\<not> length xsa \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y", "then"], ["proof (chain)\npicking this:\n  interp_ins xa = (xsa @ ysa @ ts) @ [x] @ ys @ [y] @ zs", "show \"list_order xa x y\""], ["proof (prove)\nusing this:\n  interp_ins xa = (xsa @ ysa @ ts) @ [x] @ ys @ [y] @ zs\n\ngoal (1 subgoal):\n 1. list_order xa x y", "using list_order_def"], ["proof (prove)\nusing this:\n  interp_ins xa = (xsa @ ysa @ ts) @ [x] @ ys @ [y] @ zs\n  list_order ?ops ?x ?y \\<equiv>\n  \\<exists>xs ys zs. interp_ins ?ops = xs @ [?x] @ ys @ [?y] @ zs\n\ngoal (1 subgoal):\n 1. list_order xa x y", "by blast"], ["proof (state)\nthis:\n  list_order xa x y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xsa @ zsa = xs @ x # ys @ y # zs;\n     \\<not> length xsa \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>xsa @ zsa = xs @ x # ys @ y # zs;\n     \\<not> length xsa \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y", "case False"], ["proof (state)\nthis:\n  \\<not> length xsa \\<le> length xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xsa @ zsa = xs @ x # ys @ y # zs;\n     \\<not> length xsa \\<le> length xs\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y", "then"], ["proof (chain)\npicking this:\n  \\<not> length xsa \\<le> length xs", "show \"list_order xa x y\""], ["proof (prove)\nusing this:\n  \\<not> length xsa \\<le> length xs\n\ngoal (1 subgoal):\n 1. list_order xa x y", "proof(cases \"length xsa \\<le> length (xs @ x # ys)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> length xsa \\<le> length xs;\n     length xsa \\<le> length (xs @ x # ys)\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y\n 2. \\<lbrakk>\\<not> length xsa \\<le> length xs;\n     \\<not> length xsa \\<le> length (xs @ x # ys)\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y", "case True"], ["proof (state)\nthis:\n  length xsa \\<le> length (xs @ x # ys)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> length xsa \\<le> length xs;\n     length xsa \\<le> length (xs @ x # ys)\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y\n 2. \\<lbrakk>\\<not> length xsa \\<le> length xs;\n     \\<not> length xsa \\<le> length (xs @ x # ys)\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y", "have xsa_zsa1: \"xsa @ zsa = (xs @ x # ys) @ (y # zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xsa @ zsa = (xs @ x # ys) @ y # zs", "by (simp add: xsa_zsa)"], ["proof (state)\nthis:\n  xsa @ zsa = (xs @ x # ys) @ y # zs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> length xsa \\<le> length xs;\n     length xsa \\<le> length (xs @ x # ys)\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y\n 2. \\<lbrakk>\\<not> length xsa \\<le> length xs;\n     \\<not> length xsa \\<le> length (xs @ x # ys)\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y", "then"], ["proof (chain)\npicking this:\n  xsa @ zsa = (xs @ x # ys) @ y # zs", "obtain us where \"xsa @ us = xs @ x # ys\""], ["proof (prove)\nusing this:\n  xsa @ zsa = (xs @ x # ys) @ y # zs\n\ngoal (1 subgoal):\n 1. (\\<And>us.\n        xsa @ us = xs @ x # ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using app_length_lt_exists True"], ["proof (prove)\nusing this:\n  xsa @ zsa = (xs @ x # ys) @ y # zs\n  \\<lbrakk>?xsa @ ?zsa = ?xs @ ?ys; length ?xsa \\<le> length ?xs\\<rbrakk>\n  \\<Longrightarrow> ?xsa @ drop (length ?xsa) ?xs = ?xs\n  length xsa \\<le> length (xs @ x # ys)\n\ngoal (1 subgoal):\n 1. (\\<And>us.\n        xsa @ us = xs @ x # ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  xsa @ us = xs @ x # ys\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> length xsa \\<le> length xs;\n     length xsa \\<le> length (xs @ x # ys)\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y\n 2. \\<lbrakk>\\<not> length xsa \\<le> length xs;\n     \\<not> length xsa \\<le> length (xs @ x # ys)\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y", "moreover"], ["proof (state)\nthis:\n  xsa @ us = xs @ x # ys\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> length xsa \\<le> length xs;\n     length xsa \\<le> length (xs @ x # ys)\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y\n 2. \\<lbrakk>\\<not> length xsa \\<le> length xs;\n     \\<not> length xsa \\<le> length (xs @ x # ys)\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y", "from this"], ["proof (chain)\npicking this:\n  xsa @ us = xs @ x # ys", "have \"xs @ x # (drop (Suc (length xs)) xsa) = xsa\""], ["proof (prove)\nusing this:\n  xsa @ us = xs @ x # ys\n\ngoal (1 subgoal):\n 1. xs @ x # drop (Suc (length xs)) xsa = xsa", "using append_eq_append_conv_if id_take_nth_drop linorder_not_less\n            nth_append nth_append_length False"], ["proof (prove)\nusing this:\n  xsa @ us = xs @ x # ys\n  (?xs\\<^sub>1 @ ?xs\\<^sub>2 = ?ys\\<^sub>1 @ ?ys\\<^sub>2) =\n  (if length ?xs\\<^sub>1 \\<le> length ?ys\\<^sub>1\n   then ?xs\\<^sub>1 = take (length ?xs\\<^sub>1) ?ys\\<^sub>1 \\<and>\n        ?xs\\<^sub>2 = drop (length ?xs\\<^sub>1) ?ys\\<^sub>1 @ ?ys\\<^sub>2\n   else take (length ?ys\\<^sub>1) ?xs\\<^sub>1 = ?ys\\<^sub>1 \\<and>\n        drop (length ?ys\\<^sub>1) ?xs\\<^sub>1 @ ?xs\\<^sub>2 = ?ys\\<^sub>2)\n  ?i < length ?xs \\<Longrightarrow>\n  ?xs = take ?i ?xs @ ?xs ! ?i # drop (Suc ?i) ?xs\n  (\\<not> ?x < ?y) = (?y \\<le> ?x)\n  (?xs @ ?ys) ! ?n =\n  (if ?n < length ?xs then ?xs ! ?n else ?ys ! (?n - length ?xs))\n  (?xs @ ?x # ?ys) ! length ?xs = ?x\n  \\<not> length xsa \\<le> length xs\n\ngoal (1 subgoal):\n 1. xs @ x # drop (Suc (length xs)) xsa = xsa", "by metis"], ["proof (state)\nthis:\n  xs @ x # drop (Suc (length xs)) xsa = xsa\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> length xsa \\<le> length xs;\n     length xsa \\<le> length (xs @ x # ys)\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y\n 2. \\<lbrakk>\\<not> length xsa \\<le> length xs;\n     \\<not> length xsa \\<le> length (xs @ x # ys)\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y", "moreover"], ["proof (state)\nthis:\n  xs @ x # drop (Suc (length xs)) xsa = xsa\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> length xsa \\<le> length xs;\n     length xsa \\<le> length (xs @ x # ys)\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y\n 2. \\<lbrakk>\\<not> length xsa \\<le> length xs;\n     \\<not> length xsa \\<le> length (xs @ x # ys)\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y", "have \"us @ y # zs = zsa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. us @ y # zs = zsa", "by (metis True xsa_zsa1 append_eq_append_conv_if append_eq_conv_conj calculation(1))"], ["proof (state)\nthis:\n  us @ y # zs = zsa\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> length xsa \\<le> length xs;\n     length xsa \\<le> length (xs @ x # ys)\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y\n 2. \\<lbrakk>\\<not> length xsa \\<le> length xs;\n     \\<not> length xsa \\<le> length (xs @ x # ys)\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y", "ultimately"], ["proof (chain)\npicking this:\n  xsa @ us = xs @ x # ys\n  xs @ x # drop (Suc (length xs)) xsa = xsa\n  us @ y # zs = zsa", "have \"interp_ins xa = xs @ [x] @\n              ((drop (Suc (length xs)) xsa) @ ysa @ us) @ [y] @ zs\""], ["proof (prove)\nusing this:\n  xsa @ us = xs @ x # ys\n  xs @ x # drop (Suc (length xs)) xsa = xsa\n  us @ y # zs = zsa\n\ngoal (1 subgoal):\n 1. interp_ins xa =\n    xs @ [x] @ (drop (Suc (length xs)) xsa @ ysa @ us) @ [y] @ zs", "by (simp add: e_pair interp_xa xa_split)"], ["proof (state)\nthis:\n  interp_ins xa =\n  xs @ [x] @ (drop (Suc (length xs)) xsa @ ysa @ us) @ [y] @ zs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> length xsa \\<le> length xs;\n     length xsa \\<le> length (xs @ x # ys)\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y\n 2. \\<lbrakk>\\<not> length xsa \\<le> length xs;\n     \\<not> length xsa \\<le> length (xs @ x # ys)\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y", "then"], ["proof (chain)\npicking this:\n  interp_ins xa =\n  xs @ [x] @ (drop (Suc (length xs)) xsa @ ysa @ us) @ [y] @ zs", "show \"list_order xa x y\""], ["proof (prove)\nusing this:\n  interp_ins xa =\n  xs @ [x] @ (drop (Suc (length xs)) xsa @ ysa @ us) @ [y] @ zs\n\ngoal (1 subgoal):\n 1. list_order xa x y", "using list_order_def"], ["proof (prove)\nusing this:\n  interp_ins xa =\n  xs @ [x] @ (drop (Suc (length xs)) xsa @ ysa @ us) @ [y] @ zs\n  list_order ?ops ?x ?y \\<equiv>\n  \\<exists>xs ys zs. interp_ins ?ops = xs @ [?x] @ ys @ [?y] @ zs\n\ngoal (1 subgoal):\n 1. list_order xa x y", "by blast"], ["proof (state)\nthis:\n  list_order xa x y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> length xsa \\<le> length xs;\n     \\<not> length xsa \\<le> length (xs @ x # ys)\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> length xsa \\<le> length xs;\n     \\<not> length xsa \\<le> length (xs @ x # ys)\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y", "case False"], ["proof (state)\nthis:\n  \\<not> length xsa \\<le> length (xs @ x # ys)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> length xsa \\<le> length xs;\n     \\<not> length xsa \\<le> length (xs @ x # ys)\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y", "hence \"length (xs @ x # ys) < length xsa\""], ["proof (prove)\nusing this:\n  \\<not> length xsa \\<le> length (xs @ x # ys)\n\ngoal (1 subgoal):\n 1. length (xs @ x # ys) < length xsa", "using not_less"], ["proof (prove)\nusing this:\n  \\<not> length xsa \\<le> length (xs @ x # ys)\n  (\\<not> ?x < ?y) = (?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. length (xs @ x # ys) < length xsa", "by blast"], ["proof (state)\nthis:\n  length (xs @ x # ys) < length xsa\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> length xsa \\<le> length xs;\n     \\<not> length xsa \\<le> length (xs @ x # ys)\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y", "hence \"length (xs @ x # ys @ [y]) \\<le> length xsa\""], ["proof (prove)\nusing this:\n  length (xs @ x # ys) < length xsa\n\ngoal (1 subgoal):\n 1. length (xs @ x # ys @ [y]) \\<le> length xsa", "by simp"], ["proof (state)\nthis:\n  length (xs @ x # ys @ [y]) \\<le> length xsa\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> length xsa \\<le> length xs;\n     \\<not> length xsa \\<le> length (xs @ x # ys)\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y", "moreover"], ["proof (state)\nthis:\n  length (xs @ x # ys @ [y]) \\<le> length xsa\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> length xsa \\<le> length xs;\n     \\<not> length xsa \\<le> length (xs @ x # ys)\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y", "have \"(xs @ x # ys @ [y]) @ zs = xsa @ zsa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ x # ys @ [y]) @ zs = xsa @ zsa", "by (simp add: xsa_zsa)"], ["proof (state)\nthis:\n  (xs @ x # ys @ [y]) @ zs = xsa @ zsa\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> length xsa \\<le> length xs;\n     \\<not> length xsa \\<le> length (xs @ x # ys)\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y", "ultimately"], ["proof (chain)\npicking this:\n  length (xs @ x # ys @ [y]) \\<le> length xsa\n  (xs @ x # ys @ [y]) @ zs = xsa @ zsa", "obtain vs where \"(xs @ x # ys @ [y]) @ vs = xsa\""], ["proof (prove)\nusing this:\n  length (xs @ x # ys @ [y]) \\<le> length xsa\n  (xs @ x # ys @ [y]) @ zs = xsa @ zsa\n\ngoal (1 subgoal):\n 1. (\\<And>vs.\n        (xs @ x # ys @ [y]) @ vs = xsa \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using app_length_lt_exists"], ["proof (prove)\nusing this:\n  length (xs @ x # ys @ [y]) \\<le> length xsa\n  (xs @ x # ys @ [y]) @ zs = xsa @ zsa\n  \\<lbrakk>?xsa @ ?zsa = ?xs @ ?ys; length ?xsa \\<le> length ?xs\\<rbrakk>\n  \\<Longrightarrow> ?xsa @ drop (length ?xsa) ?xs = ?xs\n\ngoal (1 subgoal):\n 1. (\\<And>vs.\n        (xs @ x # ys @ [y]) @ vs = xsa \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (xs @ x # ys @ [y]) @ vs = xsa\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> length xsa \\<le> length xs;\n     \\<not> length xsa \\<le> length (xs @ x # ys)\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y", "hence \"xsa @ ysa @ zsa = xs @ [x] @ ys @ [y] @ vs @ ysa @ zsa\""], ["proof (prove)\nusing this:\n  (xs @ x # ys @ [y]) @ vs = xsa\n\ngoal (1 subgoal):\n 1. xsa @ ysa @ zsa = xs @ [x] @ ys @ [y] @ vs @ ysa @ zsa", "by simp"], ["proof (state)\nthis:\n  xsa @ ysa @ zsa = xs @ [x] @ ys @ [y] @ vs @ ysa @ zsa\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> length xsa \\<le> length xs;\n     \\<not> length xsa \\<le> length (xs @ x # ys)\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y", "hence \"interp_ins xa = xs @ [x] @ ys @ [y] @ (vs @ ysa @ zsa)\""], ["proof (prove)\nusing this:\n  xsa @ ysa @ zsa = xs @ [x] @ ys @ [y] @ vs @ ysa @ zsa\n\ngoal (1 subgoal):\n 1. interp_ins xa = xs @ [x] @ ys @ [y] @ vs @ ysa @ zsa", "using e_pair interp_xa xa_split"], ["proof (prove)\nusing this:\n  xsa @ ysa @ zsa = xs @ [x] @ ys @ [y] @ vs @ ysa @ zsa\n  e = (oid, ref)\n  interp_ins (ps @ (oid, ref) # ss) = xsa @ ysa @ zsa\n  xa = ps @ [e] @ ss\n\ngoal (1 subgoal):\n 1. interp_ins xa = xs @ [x] @ ys @ [y] @ vs @ ysa @ zsa", "by auto"], ["proof (state)\nthis:\n  interp_ins xa = xs @ [x] @ ys @ [y] @ vs @ ysa @ zsa\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> length xsa \\<le> length xs;\n     \\<not> length xsa \\<le> length (xs @ x # ys)\\<rbrakk>\n    \\<Longrightarrow> list_order xa x y", "then"], ["proof (chain)\npicking this:\n  interp_ins xa = xs @ [x] @ ys @ [y] @ vs @ ysa @ zsa", "show \"list_order xa x y\""], ["proof (prove)\nusing this:\n  interp_ins xa = xs @ [x] @ ys @ [y] @ vs @ ysa @ zsa\n\ngoal (1 subgoal):\n 1. list_order xa x y", "using list_order_def"], ["proof (prove)\nusing this:\n  interp_ins xa = xs @ [x] @ ys @ [y] @ vs @ ysa @ zsa\n  list_order ?ops ?x ?y \\<equiv>\n  \\<exists>xs ys zs. interp_ins ?ops = xs @ [?x] @ ys @ [?y] @ zs\n\ngoal (1 subgoal):\n 1. list_order xa x y", "by blast"], ["proof (state)\nthis:\n  list_order xa x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_order xa x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_order xa x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_order xa x y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}