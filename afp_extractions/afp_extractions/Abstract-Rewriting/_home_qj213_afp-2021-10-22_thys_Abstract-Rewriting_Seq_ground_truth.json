{"file_name": "/home/qj213/afp-2021-10-22/thys/Abstract-Rewriting/Seq.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Abstract-Rewriting", "problem_names": ["lemma cons_chainp:\n  assumes \"P x (S 0)\" and \"chainp P S\"\n  shows \"chainp P (case_nat x S)\" (is \"chainp P ?S\")", "lemma cons_chain:\n  assumes \"(x, S 0) \\<in> r\" and \"chain r S\" shows \"chain r (case_nat x S)\"", "lemma chainp_imp_relpowp:\n  assumes \"chainp P S\" shows \"(P^^j) (S i) (S (i + j))\"", "lemma chain_imp_relpow:\n  assumes \"chain r S\" shows \"(S i, S (i + j)) \\<in> r^^j\"", "lemma chainp_imp_tranclp:\n  assumes \"chainp P S\" and \"i < j\" shows \"P^++ (S i) (S j)\"", "lemma chain_imp_trancl:\n  assumes \"chain r S\" and \"i < j\" shows \"(S i, S j) \\<in> r^+\"", "lemma chainp_imp_rtranclp:\n  assumes \"chainp P S\" and \"i \\<le> j\" shows \"P^** (S i) (S j)\"", "lemma chain_imp_rtrancl:\n  assumes \"chain r S\" and \"i \\<le> j\" shows \"(S i, S j) \\<in> r^*\"", "lemma stepfun_imp_chainp':\n  assumes \"\\<forall>i\\<ge>n::nat. f i \\<ge> i \\<and> P (S i) (S (f i))\"\n  shows \"chainp P (\\<lambda>i. S ((f ^^ i) n))\" (is \"chainp P ?T\")", "lemma stepfun_imp_chainp:\n  assumes \"\\<forall>i\\<ge>n::nat. f i > i \\<and> P (S i) (S (f i))\"\n  shows \"chainp P (\\<lambda>i. S ((f ^^ i) n))\" (is \"chainp P ?T\")", "lemma subchain:\n  assumes \"\\<forall>i::nat>n. \\<exists>j>i. P (f i) (f j)\"\n  shows \"\\<exists>\\<phi>. (\\<forall>i j. i < j \\<longrightarrow> \\<phi> i < \\<phi> j) \\<and> (\\<forall>i. P (f (\\<phi> i)) (f (\\<phi> (Suc i))))\"", "lemma steps_imp_chainp':\n  assumes \"\\<forall>i\\<ge>n::nat. \\<exists>j\\<ge>i. P (S i) (S j)\" shows \"\\<exists>T. chainp P T\"", "lemma steps_imp_chainp:\n  assumes \"\\<forall>i\\<ge>n::nat. \\<exists>j>i. P (S i) (S j)\" shows \"\\<exists>T. chainp P T\"", "lemma inf: \"\\<exists>j\\<ge>i. p j\"", "lemma index_p: \"p (index n)\"", "lemma index_ordered: \"index n < index (Suc n)\"", "lemma index_not_p_between:\n  assumes i1: \"index n < i\"\n    and i2: \"i < index (Suc n)\"\n  shows \"\\<not> p i\"", "lemma index_ordered_le:\n  assumes \"i \\<le> j\" shows \"index i \\<le> index j\"", "lemma index_surj:\n  assumes \"k \\<ge> index l\"\n  shows \"\\<exists>i j. k = index i + j \\<and> index i + j < index (Suc i)\"", "lemma index_ordered_less:\n  assumes \"i < j\" shows \"index i < index j\"", "lemma index_not_p_start: assumes i: \"i < index 0\" shows \"\\<not> p i\"", "lemma inf_concat_simple_add:\n  assumes ck: \"inf_concat_simple f k = (i, j)\"\n    and jl: \"j + l < f i\"\n  shows \"inf_concat_simple f (k + l) = (i,j + l)\"", "lemma inf_concat_simple_surj_zero: \"\\<exists> k. inf_concat_simple f k = (i,0)\"", "lemma inf_concat_simple_surj:\n  assumes \"j < f i\"\n  shows \"\\<exists> k. inf_concat_simple f k = (i,j)\"", "lemma inf_concat_simple_mono:\n  assumes \"k \\<le> k'\" shows \"fst (inf_concat_simple f k) \\<le> fst (inf_concat_simple f k')\"", "lemma inf_concat_bounds:\n  assumes inf: \"INFM i. n i > 0\"\n    and res: \"inf_concat n k = (i,j)\"\n  shows \"j < n i\"", "lemma inf_concat_add:\n  assumes res: \"inf_concat n k = (i,j)\"\n    and j: \"j + m < n i\"\n  shows \"inf_concat n (k + m) = (i,j+m)\"", "lemma inf_concat_step:\n  assumes res: \"inf_concat n k = (i,j)\"\n    and j: \"Suc (j + m) = n i\"\n  shows \"inf_concat n (k + Suc m) = (LEAST i'. i' > i \\<and> 0 < n i', 0)\"", "lemma inf_concat_surj_zero:\n  assumes \"0 < n i\"\n  shows \"\\<exists>k. inf_concat n k = (i, 0)\"", "lemma inf_concat_surj:\n  assumes j: \"j < n i\"\n  shows \"\\<exists>k. inf_concat n k = (i, j)\"", "lemma inf_concat_mono:\n  assumes inf: \"INFM i. n i > 0\"\n    and resk: \"inf_concat n k = (i, j)\"\n    and reskp: \"inf_concat n k' = (i', j')\"\n    and lt: \"i < i'\"\n  shows \"k < k'\"", "lemma inf_concat_Suc:\n  assumes inf: \"INFM i. n i > 0\"\n    and f: \"\\<And> i. f i (n i) = f (Suc i) 0\"\n    and resk: \"inf_concat n k = (i, j)\"\n    and ressk: \"inf_concat n (Suc k) = (i', j')\"\n  shows \"f i' j' = f i (Suc j)\""], "translations": [["", "lemma cons_chainp:\n  assumes \"P x (S 0)\" and \"chainp P S\"\n  shows \"chainp P (case_nat x S)\" (is \"chainp P ?S\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       P (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> S x)\n        (case Suc i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> S x)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       P (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> S x)\n        (case Suc i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> S x)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       P (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> S x)\n        (case Suc i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> S x)", "show \"P (?S i) (?S (Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> S x)\n     (case Suc i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> S x)", "using assms"], ["proof (prove)\nusing this:\n  P x (S 0)\n  \\<forall>i. P (S i) (S (Suc i))\n\ngoal (1 subgoal):\n 1. P (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> S x)\n     (case Suc i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> S x)", "by (cases i) simp_all"], ["proof (state)\nthis:\n  P (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> S x)\n   (case Suc i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> S x)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Special version for relations.\\<close>"], ["", "lemma cons_chain:\n  assumes \"(x, S 0) \\<in> r\" and \"chain r S\" shows \"chain r (case_nat x S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> S x,\n        case Suc i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> S x)\n       \\<in> r", "using cons_chainp[of \"\\<lambda>x y. (x, y) \\<in> r\", OF assms]"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     (case i of 0 \\<Rightarrow> x | Suc i \\<Rightarrow> S i,\n      case Suc i of 0 \\<Rightarrow> x | Suc i \\<Rightarrow> S i)\n     \\<in> r\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (case i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> S x,\n        case Suc i of 0 \\<Rightarrow> x | Suc x \\<Rightarrow> S x)\n       \\<in> r", "."], ["", "text \\<open>A chain admits arbitrary transitive steps.\\<close>"], ["", "lemma chainp_imp_relpowp:\n  assumes \"chainp P S\" shows \"(P^^j) (S i) (S (i + j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P ^^ j) (S i) (S (i + j))", "proof (induct \"i + j\" arbitrary: j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>j. 0 = i + j \\<Longrightarrow> (P ^^ j) (S i) (S (i + j))\n 2. \\<And>x j.\n       \\<lbrakk>\\<And>j.\n                   x = i + j \\<Longrightarrow> (P ^^ j) (S i) (S (i + j));\n        Suc x = i + j\\<rbrakk>\n       \\<Longrightarrow> (P ^^ j) (S i) (S (i + j))", "case (Suc n)"], ["proof (state)\nthis:\n  n = i + ?j \\<Longrightarrow> (P ^^ ?j) (S i) (S (i + ?j))\n  Suc n = i + j\n\ngoal (2 subgoals):\n 1. \\<And>j. 0 = i + j \\<Longrightarrow> (P ^^ j) (S i) (S (i + j))\n 2. \\<And>x j.\n       \\<lbrakk>\\<And>j.\n                   x = i + j \\<Longrightarrow> (P ^^ j) (S i) (S (i + j));\n        Suc x = i + j\\<rbrakk>\n       \\<Longrightarrow> (P ^^ j) (S i) (S (i + j))", "thus ?case"], ["proof (prove)\nusing this:\n  n = i + ?j \\<Longrightarrow> (P ^^ ?j) (S i) (S (i + ?j))\n  Suc n = i + j\n\ngoal (1 subgoal):\n 1. (P ^^ j) (S i) (S (i + j))", "using assms"], ["proof (prove)\nusing this:\n  n = i + ?j \\<Longrightarrow> (P ^^ ?j) (S i) (S (i + ?j))\n  Suc n = i + j\n  \\<forall>i. P (S i) (S (Suc i))\n\ngoal (1 subgoal):\n 1. (P ^^ j) (S i) (S (i + j))", "by (cases j) auto"], ["proof (state)\nthis:\n  (P ^^ j) (S i) (S (i + j))\n\ngoal (1 subgoal):\n 1. \\<And>j. 0 = i + j \\<Longrightarrow> (P ^^ j) (S i) (S (i + j))", "qed simp"], ["", "lemma chain_imp_relpow:\n  assumes \"chain r S\" shows \"(S i, S (i + j)) \\<in> r^^j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S i, S (i + j)) \\<in> r ^^ j", "proof (induct \"i + j\" arbitrary: j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>j. 0 = i + j \\<Longrightarrow> (S i, S (i + j)) \\<in> r ^^ j\n 2. \\<And>x j.\n       \\<lbrakk>\\<And>j.\n                   x = i + j \\<Longrightarrow>\n                   (S i, S (i + j)) \\<in> r ^^ j;\n        Suc x = i + j\\<rbrakk>\n       \\<Longrightarrow> (S i, S (i + j)) \\<in> r ^^ j", "case (Suc n)"], ["proof (state)\nthis:\n  n = i + ?j \\<Longrightarrow> (S i, S (i + ?j)) \\<in> r ^^ ?j\n  Suc n = i + j\n\ngoal (2 subgoals):\n 1. \\<And>j. 0 = i + j \\<Longrightarrow> (S i, S (i + j)) \\<in> r ^^ j\n 2. \\<And>x j.\n       \\<lbrakk>\\<And>j.\n                   x = i + j \\<Longrightarrow>\n                   (S i, S (i + j)) \\<in> r ^^ j;\n        Suc x = i + j\\<rbrakk>\n       \\<Longrightarrow> (S i, S (i + j)) \\<in> r ^^ j", "thus ?case"], ["proof (prove)\nusing this:\n  n = i + ?j \\<Longrightarrow> (S i, S (i + ?j)) \\<in> r ^^ ?j\n  Suc n = i + j\n\ngoal (1 subgoal):\n 1. (S i, S (i + j)) \\<in> r ^^ j", "using assms"], ["proof (prove)\nusing this:\n  n = i + ?j \\<Longrightarrow> (S i, S (i + ?j)) \\<in> r ^^ ?j\n  Suc n = i + j\n  \\<forall>i. (S i, S (Suc i)) \\<in> r\n\ngoal (1 subgoal):\n 1. (S i, S (i + j)) \\<in> r ^^ j", "by (cases j) auto"], ["proof (state)\nthis:\n  (S i, S (i + j)) \\<in> r ^^ j\n\ngoal (1 subgoal):\n 1. \\<And>j. 0 = i + j \\<Longrightarrow> (S i, S (i + j)) \\<in> r ^^ j", "qed simp"], ["", "lemma chainp_imp_tranclp:\n  assumes \"chainp P S\" and \"i < j\" shows \"P^++ (S i) (S j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P\\<^sup>+\\<^sup>+ (S i) (S j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P\\<^sup>+\\<^sup>+ (S i) (S j)", "from less_imp_Suc_add[OF assms(2)]"], ["proof (chain)\npicking this:\n  \\<exists>k. j = Suc (i + k)", "obtain n where \"j = i + Suc n\""], ["proof (prove)\nusing this:\n  \\<exists>k. j = Suc (i + k)\n\ngoal (1 subgoal):\n 1. (\\<And>n. j = i + Suc n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j = i + Suc n\n\ngoal (1 subgoal):\n 1. P\\<^sup>+\\<^sup>+ (S i) (S j)", "with chainp_imp_relpowp[of P S \"Suc n\" i, OF assms(1)]"], ["proof (chain)\npicking this:\n  (P ^^ Suc n) (S i) (S (i + Suc n))\n  j = i + Suc n", "show ?thesis"], ["proof (prove)\nusing this:\n  (P ^^ Suc n) (S i) (S (i + Suc n))\n  j = i + Suc n\n\ngoal (1 subgoal):\n 1. P\\<^sup>+\\<^sup>+ (S i) (S j)", "unfolding trancl_power[of \"(S i, S j)\", to_pred]"], ["proof (prove)\nusing this:\n  (P ^^ Suc n) (S i) (S (i + Suc n))\n  j = i + Suc n\n\ngoal (1 subgoal):\n 1. \\<exists>n>0. (P ^^ n) (S i) (S j)", "by force"], ["proof (state)\nthis:\n  P\\<^sup>+\\<^sup>+ (S i) (S j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chain_imp_trancl:\n  assumes \"chain r S\" and \"i < j\" shows \"(S i, S j) \\<in> r^+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S i, S j) \\<in> r\\<^sup>+", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (S i, S j) \\<in> r\\<^sup>+", "from less_imp_Suc_add[OF assms(2)]"], ["proof (chain)\npicking this:\n  \\<exists>k. j = Suc (i + k)", "obtain n where \"j = i + Suc n\""], ["proof (prove)\nusing this:\n  \\<exists>k. j = Suc (i + k)\n\ngoal (1 subgoal):\n 1. (\\<And>n. j = i + Suc n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j = i + Suc n\n\ngoal (1 subgoal):\n 1. (S i, S j) \\<in> r\\<^sup>+", "with chain_imp_relpow[OF assms(1), of i \"Suc n\"]"], ["proof (chain)\npicking this:\n  (S i, S (i + Suc n)) \\<in> r ^^ Suc n\n  j = i + Suc n", "show ?thesis"], ["proof (prove)\nusing this:\n  (S i, S (i + Suc n)) \\<in> r ^^ Suc n\n  j = i + Suc n\n\ngoal (1 subgoal):\n 1. (S i, S j) \\<in> r\\<^sup>+", "unfolding trancl_power"], ["proof (prove)\nusing this:\n  (S i, S (i + Suc n)) \\<in> r ^^ Suc n\n  j = i + Suc n\n\ngoal (1 subgoal):\n 1. \\<exists>n>0. (S i, S j) \\<in> r ^^ n", "by force"], ["proof (state)\nthis:\n  (S i, S j) \\<in> r\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>A chain admits arbitrary reflexive and transitive steps.\\<close>"], ["", "lemma chainp_imp_rtranclp:\n  assumes \"chainp P S\" and \"i \\<le> j\" shows \"P^** (S i) (S j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P\\<^sup>*\\<^sup>* (S i) (S j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P\\<^sup>*\\<^sup>* (S i) (S j)", "from assms(2)"], ["proof (chain)\npicking this:\n  i \\<le> j", "obtain n where \"j = i + n\""], ["proof (prove)\nusing this:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. (\\<And>n. j = i + n \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (induct \"j - i\" arbitrary: j) force+"], ["proof (state)\nthis:\n  j = i + n\n\ngoal (1 subgoal):\n 1. P\\<^sup>*\\<^sup>* (S i) (S j)", "with chainp_imp_relpowp[of P S, OF assms(1), of n i]"], ["proof (chain)\npicking this:\n  (P ^^ n) (S i) (S (i + n))\n  j = i + n", "show ?thesis"], ["proof (prove)\nusing this:\n  (P ^^ n) (S i) (S (i + n))\n  j = i + n\n\ngoal (1 subgoal):\n 1. P\\<^sup>*\\<^sup>* (S i) (S j)", "by (simp add: relpow_imp_rtrancl[of \"(S i, S (i + n))\", to_pred])"], ["proof (state)\nthis:\n  P\\<^sup>*\\<^sup>* (S i) (S j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chain_imp_rtrancl:\n  assumes \"chain r S\" and \"i \\<le> j\" shows \"(S i, S j) \\<in> r^*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S i, S j) \\<in> r\\<^sup>*", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (S i, S j) \\<in> r\\<^sup>*", "from assms(2)"], ["proof (chain)\npicking this:\n  i \\<le> j", "obtain n where \"j = i + n\""], ["proof (prove)\nusing this:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. (\\<And>n. j = i + n \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (induct \"j - i\" arbitrary: j) force+"], ["proof (state)\nthis:\n  j = i + n\n\ngoal (1 subgoal):\n 1. (S i, S j) \\<in> r\\<^sup>*", "with chain_imp_relpow[OF assms(1), of i n]"], ["proof (chain)\npicking this:\n  (S i, S (i + n)) \\<in> r ^^ n\n  j = i + n", "show ?thesis"], ["proof (prove)\nusing this:\n  (S i, S (i + n)) \\<in> r ^^ n\n  j = i + n\n\ngoal (1 subgoal):\n 1. (S i, S j) \\<in> r\\<^sup>*", "by (simp add: relpow_imp_rtrancl)"], ["proof (state)\nthis:\n  (S i, S j) \\<in> r\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>If for every @{term i} there is a later index @{term \"f i\"} such that the\ncorresponding elements satisfy the predicate @{term P}, then there is a @{term P}-chain.\\<close>"], ["", "lemma stepfun_imp_chainp':\n  assumes \"\\<forall>i\\<ge>n::nat. f i \\<ge> i \\<and> P (S i) (S (f i))\"\n  shows \"chainp P (\\<lambda>i. S ((f ^^ i) n))\" (is \"chainp P ?T\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. P (S ((f ^^ i) n)) (S ((f ^^ Suc i) n))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. P (S ((f ^^ i) n)) (S ((f ^^ Suc i) n))", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. P (S ((f ^^ i) n)) (S ((f ^^ Suc i) n))", "from assms"], ["proof (chain)\npicking this:\n  \\<forall>i\\<ge>n. i \\<le> f i \\<and> P (S i) (S (f i))", "have \"(f ^^ i) n \\<ge> n\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<ge>n. i \\<le> f i \\<and> P (S i) (S (f i))\n\ngoal (1 subgoal):\n 1. n \\<le> (f ^^ i) n", "by (induct i) auto"], ["proof (state)\nthis:\n  n \\<le> (f ^^ i) n\n\ngoal (1 subgoal):\n 1. \\<And>i. P (S ((f ^^ i) n)) (S ((f ^^ Suc i) n))", "with assms[THEN spec[of _ \"(f ^^ i) n\"]]"], ["proof (chain)\npicking this:\n  n \\<le> (f ^^ i) n \\<longrightarrow>\n  (f ^^ i) n \\<le> f ((f ^^ i) n) \\<and>\n  P (S ((f ^^ i) n)) (S (f ((f ^^ i) n)))\n  n \\<le> (f ^^ i) n", "show \"P (?T i) (?T (Suc i))\""], ["proof (prove)\nusing this:\n  n \\<le> (f ^^ i) n \\<longrightarrow>\n  (f ^^ i) n \\<le> f ((f ^^ i) n) \\<and>\n  P (S ((f ^^ i) n)) (S (f ((f ^^ i) n)))\n  n \\<le> (f ^^ i) n\n\ngoal (1 subgoal):\n 1. P (S ((f ^^ i) n)) (S ((f ^^ Suc i) n))", "by simp"], ["proof (state)\nthis:\n  P (S ((f ^^ i) n)) (S ((f ^^ Suc i) n))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma stepfun_imp_chainp:\n  assumes \"\\<forall>i\\<ge>n::nat. f i > i \\<and> P (S i) (S (f i))\"\n  shows \"chainp P (\\<lambda>i. S ((f ^^ i) n))\" (is \"chainp P ?T\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. P (S ((f ^^ i) n)) (S ((f ^^ Suc i) n))", "using stepfun_imp_chainp'[of n f P S] and assms"], ["proof (prove)\nusing this:\n  \\<forall>i\\<ge>n. i \\<le> f i \\<and> P (S i) (S (f i)) \\<Longrightarrow>\n  \\<forall>i. P (S ((f ^^ i) n)) (S ((f ^^ Suc i) n))\n  \\<forall>i\\<ge>n. i < f i \\<and> P (S i) (S (f i))\n\ngoal (1 subgoal):\n 1. \\<forall>i. P (S ((f ^^ i) n)) (S ((f ^^ Suc i) n))", "by force"], ["", "lemma subchain:\n  assumes \"\\<forall>i::nat>n. \\<exists>j>i. P (f i) (f j)\"\n  shows \"\\<exists>\\<phi>. (\\<forall>i j. i < j \\<longrightarrow> \\<phi> i < \\<phi> j) \\<and> (\\<forall>i. P (f (\\<phi> i)) (f (\\<phi> (Suc i))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>.\n       (\\<forall>i j. i < j \\<longrightarrow> \\<phi> i < \\<phi> j) \\<and>\n       (\\<forall>i. P (f (\\<phi> i)) (f (\\<phi> (Suc i))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>.\n       (\\<forall>i j. i < j \\<longrightarrow> \\<phi> i < \\<phi> j) \\<and>\n       (\\<forall>i. P (f (\\<phi> i)) (f (\\<phi> (Suc i))))", "from assms"], ["proof (chain)\npicking this:\n  \\<forall>i>n. \\<exists>j>i. P (f i) (f j)", "have \"\\<forall>i\\<in>{i. i > n}. \\<exists>j>i. P (f i) (f j)\""], ["proof (prove)\nusing this:\n  \\<forall>i>n. \\<exists>j>i. P (f i) (f j)\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{i. n < i}. \\<exists>j>i. P (f i) (f j)", "by simp"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{i. n < i}. \\<exists>j>i. P (f i) (f j)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>.\n       (\\<forall>i j. i < j \\<longrightarrow> \\<phi> i < \\<phi> j) \\<and>\n       (\\<forall>i. P (f (\\<phi> i)) (f (\\<phi> (Suc i))))", "from bchoice [OF this]"], ["proof (chain)\npicking this:\n  \\<exists>fa. \\<forall>x\\<in>{i. n < i}. x < fa x \\<and> P (f x) (f (fa x))", "obtain g\n    where *: \"\\<forall>i>n. g i > i\"\n    and **: \"\\<forall>i>n. P (f i) (f (g i))\""], ["proof (prove)\nusing this:\n  \\<exists>fa. \\<forall>x\\<in>{i. n < i}. x < fa x \\<and> P (f x) (f (fa x))\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>\\<forall>i>n. i < g i;\n         \\<forall>i>n. P (f i) (f (g i))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>i>n. i < g i\n  \\<forall>i>n. P (f i) (f (g i))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>.\n       (\\<forall>i j. i < j \\<longrightarrow> \\<phi> i < \\<phi> j) \\<and>\n       (\\<forall>i. P (f (\\<phi> i)) (f (\\<phi> (Suc i))))", "define \\<phi> where [simp]: \"\\<phi> i = (g ^^ i) (Suc n)\" for i"], ["proof (state)\nthis:\n  \\<phi> ?i = (g ^^ ?i) (Suc n)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>.\n       (\\<forall>i j. i < j \\<longrightarrow> \\<phi> i < \\<phi> j) \\<and>\n       (\\<forall>i. P (f (\\<phi> i)) (f (\\<phi> (Suc i))))", "from *"], ["proof (chain)\npicking this:\n  \\<forall>i>n. i < g i", "have ***: \"\\<And>i. \\<phi> i > n\""], ["proof (prove)\nusing this:\n  \\<forall>i>n. i < g i\n\ngoal (1 subgoal):\n 1. \\<And>i. n < \\<phi> i", "by (induct_tac i) auto"], ["proof (state)\nthis:\n  n < \\<phi> ?i\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>.\n       (\\<forall>i j. i < j \\<longrightarrow> \\<phi> i < \\<phi> j) \\<and>\n       (\\<forall>i. P (f (\\<phi> i)) (f (\\<phi> (Suc i))))", "then"], ["proof (chain)\npicking this:\n  n < \\<phi> ?i", "have \"\\<And>i. \\<phi> i < \\<phi> (Suc i)\""], ["proof (prove)\nusing this:\n  n < \\<phi> ?i\n\ngoal (1 subgoal):\n 1. \\<And>i. \\<phi> i < \\<phi> (Suc i)", "using *"], ["proof (prove)\nusing this:\n  n < \\<phi> ?i\n  \\<forall>i>n. i < g i\n\ngoal (1 subgoal):\n 1. \\<And>i. \\<phi> i < \\<phi> (Suc i)", "by (induct_tac i) auto"], ["proof (state)\nthis:\n  \\<phi> ?i < \\<phi> (Suc ?i)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>.\n       (\\<forall>i j. i < j \\<longrightarrow> \\<phi> i < \\<phi> j) \\<and>\n       (\\<forall>i. P (f (\\<phi> i)) (f (\\<phi> (Suc i))))", "then"], ["proof (chain)\npicking this:\n  \\<phi> ?i < \\<phi> (Suc ?i)", "have \"\\<And>i j. i < j \\<Longrightarrow> \\<phi> i < \\<phi> j\""], ["proof (prove)\nusing this:\n  \\<phi> ?i < \\<phi> (Suc ?i)\n\ngoal (1 subgoal):\n 1. \\<And>i j. i < j \\<Longrightarrow> \\<phi> i < \\<phi> j", "by (rule lift_Suc_mono_less)"], ["proof (state)\nthis:\n  ?i < ?j \\<Longrightarrow> \\<phi> ?i < \\<phi> ?j\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>.\n       (\\<forall>i j. i < j \\<longrightarrow> \\<phi> i < \\<phi> j) \\<and>\n       (\\<forall>i. P (f (\\<phi> i)) (f (\\<phi> (Suc i))))", "moreover"], ["proof (state)\nthis:\n  ?i < ?j \\<Longrightarrow> \\<phi> ?i < \\<phi> ?j\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>.\n       (\\<forall>i j. i < j \\<longrightarrow> \\<phi> i < \\<phi> j) \\<and>\n       (\\<forall>i. P (f (\\<phi> i)) (f (\\<phi> (Suc i))))", "have \"\\<And>i. P (f (\\<phi> i)) (f (\\<phi> (Suc i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. P (f (\\<phi> i)) (f (\\<phi> (Suc i)))", "using ** and ***"], ["proof (prove)\nusing this:\n  \\<forall>i>n. P (f i) (f (g i))\n  n < \\<phi> ?i\n\ngoal (1 subgoal):\n 1. \\<And>i. P (f (\\<phi> i)) (f (\\<phi> (Suc i)))", "by simp"], ["proof (state)\nthis:\n  P (f (\\<phi> ?i)) (f (\\<phi> (Suc ?i)))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>.\n       (\\<forall>i j. i < j \\<longrightarrow> \\<phi> i < \\<phi> j) \\<and>\n       (\\<forall>i. P (f (\\<phi> i)) (f (\\<phi> (Suc i))))", "ultimately"], ["proof (chain)\npicking this:\n  ?i < ?j \\<Longrightarrow> \\<phi> ?i < \\<phi> ?j\n  P (f (\\<phi> ?i)) (f (\\<phi> (Suc ?i)))", "show ?thesis"], ["proof (prove)\nusing this:\n  ?i < ?j \\<Longrightarrow> \\<phi> ?i < \\<phi> ?j\n  P (f (\\<phi> ?i)) (f (\\<phi> (Suc ?i)))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<phi>.\n       (\\<forall>i j. i < j \\<longrightarrow> \\<phi> i < \\<phi> j) \\<and>\n       (\\<forall>i. P (f (\\<phi> i)) (f (\\<phi> (Suc i))))", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<phi>.\n     (\\<forall>i j. i < j \\<longrightarrow> \\<phi> i < \\<phi> j) \\<and>\n     (\\<forall>i. P (f (\\<phi> i)) (f (\\<phi> (Suc i))))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>If for every @{term i} there is a later index @{term j} such that the\ncorresponding elements satisfy the predicate @{term P}, then there is a @{term P}-chain.\\<close>"], ["", "lemma steps_imp_chainp':\n  assumes \"\\<forall>i\\<ge>n::nat. \\<exists>j\\<ge>i. P (S i) (S j)\" shows \"\\<exists>T. chainp P T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T. \\<forall>i. P (T i) (T (Suc i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>T. \\<forall>i. P (T i) (T (Suc i))", "from assms"], ["proof (chain)\npicking this:\n  \\<forall>i\\<ge>n. \\<exists>j\\<ge>i. P (S i) (S j)", "have \"\\<forall>i\\<in>{i. i \\<ge> n}. \\<exists>j\\<ge>i. P (S i) (S j)\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<ge>n. \\<exists>j\\<ge>i. P (S i) (S j)\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{i. n \\<le> i}. \\<exists>j\\<ge>i. P (S i) (S j)", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{i. n \\<le> i}. \\<exists>j\\<ge>i. P (S i) (S j)\n\ngoal (1 subgoal):\n 1. \\<exists>T. \\<forall>i. P (T i) (T (Suc i))", "from bchoice [OF this]"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     \\<forall>x\\<in>{i. n \\<le> i}. x \\<le> f x \\<and> P (S x) (S (f x))", "(*choice could be replaced by an application of Least_Enum.infinitely_many2*)"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     \\<forall>x\\<in>{i. n \\<le> i}. x \\<le> f x \\<and> P (S x) (S (f x))", "obtain f where \"\\<forall>i\\<ge>n. f i \\<ge> i \\<and> P (S i) (S (f i))\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     \\<forall>x\\<in>{i. n \\<le> i}. x \\<le> f x \\<and> P (S x) (S (f x))\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<forall>i\\<ge>n.\n           i \\<le> f i \\<and> P (S i) (S (f i)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<ge>n. i \\<le> f i \\<and> P (S i) (S (f i))\n\ngoal (1 subgoal):\n 1. \\<exists>T. \\<forall>i. P (T i) (T (Suc i))", "from stepfun_imp_chainp'[of n f P S, OF this]"], ["proof (chain)\npicking this:\n  \\<forall>i. P (S ((f ^^ i) n)) (S ((f ^^ Suc i) n))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i. P (S ((f ^^ i) n)) (S ((f ^^ Suc i) n))\n\ngoal (1 subgoal):\n 1. \\<exists>T. \\<forall>i. P (T i) (T (Suc i))", "by fast"], ["proof (state)\nthis:\n  \\<exists>T. \\<forall>i. P (T i) (T (Suc i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma steps_imp_chainp:\n  assumes \"\\<forall>i\\<ge>n::nat. \\<exists>j>i. P (S i) (S j)\" shows \"\\<exists>T. chainp P T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T. \\<forall>i. P (T i) (T (Suc i))", "using steps_imp_chainp' [of n P S] and assms"], ["proof (prove)\nusing this:\n  \\<forall>i\\<ge>n. \\<exists>j\\<ge>i. P (S i) (S j) \\<Longrightarrow>\n  \\<exists>T. \\<forall>i. P (T i) (T (Suc i))\n  \\<forall>i\\<ge>n. \\<exists>j>i. P (S i) (S j)\n\ngoal (1 subgoal):\n 1. \\<exists>T. \\<forall>i. P (T i) (T (Suc i))", "by force"], ["", "subsection \\<open>Predicates on Natural Numbers\\<close>"], ["", "text \\<open>If some property holds for infinitely many natural numbers, obtain\nan index function that points to these numbers in increasing order.\\<close>"], ["", "locale infinitely_many =\n  fixes p :: \"nat \\<Rightarrow> bool\"\n  assumes infinite: \"INFM j. p j\"\nbegin"], ["", "lemma inf: \"\\<exists>j\\<ge>i. p j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i. p j", "using infinite[unfolded INFM_nat_le]"], ["proof (prove)\nusing this:\n  \\<forall>m. \\<exists>n\\<ge>m. p n\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<ge>i. p j", "by auto"], ["", "fun index :: \"nat seq\" where\n  \"index 0 = (LEAST n. p n)\"\n| \"index (Suc n) = (LEAST k. p k \\<and> k > index n)\""], ["", "lemma index_p: \"p (index n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p (index n)", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. p (index 0)\n 2. \\<And>n. p (index n) \\<Longrightarrow> p (index (Suc n))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. p (index 0)\n 2. \\<And>n. p (index n) \\<Longrightarrow> p (index (Suc n))", "from inf"], ["proof (chain)\npicking this:\n  \\<exists>j\\<ge>?i. p j", "obtain j where \"p j\""], ["proof (prove)\nusing this:\n  \\<exists>j\\<ge>?i. p j\n\ngoal (1 subgoal):\n 1. (\\<And>j. p j \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  p j\n\ngoal (2 subgoals):\n 1. p (index 0)\n 2. \\<And>n. p (index n) \\<Longrightarrow> p (index (Suc n))", "with LeastI[of p j]"], ["proof (chain)\npicking this:\n  p j \\<Longrightarrow> p (LEAST x. p x)\n  p j", "show ?case"], ["proof (prove)\nusing this:\n  p j \\<Longrightarrow> p (LEAST x. p x)\n  p j\n\ngoal (1 subgoal):\n 1. p (index 0)", "by auto"], ["proof (state)\nthis:\n  p (index 0)\n\ngoal (1 subgoal):\n 1. \\<And>n. p (index n) \\<Longrightarrow> p (index (Suc n))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. p (index n) \\<Longrightarrow> p (index (Suc n))", "case (Suc n)"], ["proof (state)\nthis:\n  p (index n)\n\ngoal (1 subgoal):\n 1. \\<And>n. p (index n) \\<Longrightarrow> p (index (Suc n))", "from inf"], ["proof (chain)\npicking this:\n  \\<exists>j\\<ge>?i. p j", "obtain k where \"k \\<ge> Suc (index n) \\<and> p k\""], ["proof (prove)\nusing this:\n  \\<exists>j\\<ge>?i. p j\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        Suc (index n) \\<le> k \\<and> p k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Suc (index n) \\<le> k \\<and> p k\n\ngoal (1 subgoal):\n 1. \\<And>n. p (index n) \\<Longrightarrow> p (index (Suc n))", "with LeastI[of \"\\<lambda> k. p k \\<and> k > index n\" k]"], ["proof (chain)\npicking this:\n  p k \\<and> index n < k \\<Longrightarrow>\n  p (LEAST x. p x \\<and> index n < x) \\<and>\n  index n < (LEAST x. p x \\<and> index n < x)\n  Suc (index n) \\<le> k \\<and> p k", "show ?case"], ["proof (prove)\nusing this:\n  p k \\<and> index n < k \\<Longrightarrow>\n  p (LEAST x. p x \\<and> index n < x) \\<and>\n  index n < (LEAST x. p x \\<and> index n < x)\n  Suc (index n) \\<le> k \\<and> p k\n\ngoal (1 subgoal):\n 1. p (index (Suc n))", "by auto"], ["proof (state)\nthis:\n  p (index (Suc n))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma index_ordered: \"index n < index (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index n < index (Suc n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. index n < index (Suc n)", "from inf"], ["proof (chain)\npicking this:\n  \\<exists>j\\<ge>?i. p j", "obtain k where \"k \\<ge> Suc (index n) \\<and> p k\""], ["proof (prove)\nusing this:\n  \\<exists>j\\<ge>?i. p j\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        Suc (index n) \\<le> k \\<and> p k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Suc (index n) \\<le> k \\<and> p k\n\ngoal (1 subgoal):\n 1. index n < index (Suc n)", "with LeastI[of \"\\<lambda> k. p k \\<and> k > index n\" k]"], ["proof (chain)\npicking this:\n  p k \\<and> index n < k \\<Longrightarrow>\n  p (LEAST x. p x \\<and> index n < x) \\<and>\n  index n < (LEAST x. p x \\<and> index n < x)\n  Suc (index n) \\<le> k \\<and> p k", "show ?thesis"], ["proof (prove)\nusing this:\n  p k \\<and> index n < k \\<Longrightarrow>\n  p (LEAST x. p x \\<and> index n < x) \\<and>\n  index n < (LEAST x. p x \\<and> index n < x)\n  Suc (index n) \\<le> k \\<and> p k\n\ngoal (1 subgoal):\n 1. index n < index (Suc n)", "by auto"], ["proof (state)\nthis:\n  index n < index (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma index_not_p_between:\n  assumes i1: \"index n < i\"\n    and i2: \"i < index (Suc n)\"\n  shows \"\\<not> p i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> p i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> p i", "from not_less_Least[OF i2[simplified]] i1"], ["proof (chain)\npicking this:\n  \\<not> (p i \\<and> index n < i)\n  index n < i", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (p i \\<and> index n < i)\n  index n < i\n\ngoal (1 subgoal):\n 1. \\<not> p i", "by auto"], ["proof (state)\nthis:\n  \\<not> p i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma index_ordered_le:\n  assumes \"i \\<le> j\" shows \"index i \\<le> index j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index i \\<le> index j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. index i \\<le> index j", "from assms"], ["proof (chain)\npicking this:\n  i \\<le> j", "have \"j = i + (j - i)\""], ["proof (prove)\nusing this:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. j = i + (j - i)", "by auto"], ["proof (state)\nthis:\n  j = i + (j - i)\n\ngoal (1 subgoal):\n 1. index i \\<le> index j", "then"], ["proof (chain)\npicking this:\n  j = i + (j - i)", "obtain k where j: \"j = i + k\""], ["proof (prove)\nusing this:\n  j = i + (j - i)\n\ngoal (1 subgoal):\n 1. (\\<And>k. j = i + k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  j = i + k\n\ngoal (1 subgoal):\n 1. index i \\<le> index j", "have \"index i \\<le> index (i + k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index i \\<le> index (i + k)", "proof (induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. index i \\<le> index (i + 0)\n 2. \\<And>k.\n       index i \\<le> index (i + k) \\<Longrightarrow>\n       index i \\<le> index (i + Suc k)", "case (Suc k)"], ["proof (state)\nthis:\n  index i \\<le> index (i + k)\n\ngoal (2 subgoals):\n 1. index i \\<le> index (i + 0)\n 2. \\<And>k.\n       index i \\<le> index (i + k) \\<Longrightarrow>\n       index i \\<le> index (i + Suc k)", "with index_ordered[of \"i + k\"]"], ["proof (chain)\npicking this:\n  index (i + k) < index (Suc (i + k))\n  index i \\<le> index (i + k)", "show ?case"], ["proof (prove)\nusing this:\n  index (i + k) < index (Suc (i + k))\n  index i \\<le> index (i + k)\n\ngoal (1 subgoal):\n 1. index i \\<le> index (i + Suc k)", "by auto"], ["proof (state)\nthis:\n  index i \\<le> index (i + Suc k)\n\ngoal (1 subgoal):\n 1. index i \\<le> index (i + 0)", "qed simp"], ["proof (state)\nthis:\n  index i \\<le> index (i + k)\n\ngoal (1 subgoal):\n 1. index i \\<le> index j", "thus ?thesis"], ["proof (prove)\nusing this:\n  index i \\<le> index (i + k)\n\ngoal (1 subgoal):\n 1. index i \\<le> index j", "unfolding j"], ["proof (prove)\nusing this:\n  index i \\<le> index (i + k)\n\ngoal (1 subgoal):\n 1. index i \\<le> index (i + k)", "."], ["proof (state)\nthis:\n  index i \\<le> index j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma index_surj:\n  assumes \"k \\<ge> index l\"\n  shows \"\\<exists>i j. k = index i + j \\<and> index i + j < index (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i j. k = index i + j \\<and> index i + j < index (Suc i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i j. k = index i + j \\<and> index i + j < index (Suc i)", "from assms"], ["proof (chain)\npicking this:\n  index l \\<le> k", "have \"k = index l + (k - index l)\""], ["proof (prove)\nusing this:\n  index l \\<le> k\n\ngoal (1 subgoal):\n 1. k = index l + (k - index l)", "by auto"], ["proof (state)\nthis:\n  k = index l + (k - index l)\n\ngoal (1 subgoal):\n 1. \\<exists>i j. k = index i + j \\<and> index i + j < index (Suc i)", "then"], ["proof (chain)\npicking this:\n  k = index l + (k - index l)", "obtain u where k: \"k = index l + u\""], ["proof (prove)\nusing this:\n  k = index l + (k - index l)\n\ngoal (1 subgoal):\n 1. (\\<And>u. k = index l + u \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k = index l + u\n\ngoal (1 subgoal):\n 1. \\<exists>i j. k = index i + j \\<and> index i + j < index (Suc i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i j. k = index i + j \\<and> index i + j < index (Suc i)", "unfolding k"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i j.\n       index l + u = index i + j \\<and> index i + j < index (Suc i)", "proof (induct u)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>i j.\n       index l + 0 = index i + j \\<and> index i + j < index (Suc i)\n 2. \\<And>u.\n       \\<exists>i j.\n          index l + u = index i + j \\<and>\n          index i + j < index (Suc i) \\<Longrightarrow>\n       \\<exists>i j.\n          index l + Suc u = index i + j \\<and> index i + j < index (Suc i)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<exists>i j.\n       index l + 0 = index i + j \\<and> index i + j < index (Suc i)\n 2. \\<And>u.\n       \\<exists>i j.\n          index l + u = index i + j \\<and>\n          index i + j < index (Suc i) \\<Longrightarrow>\n       \\<exists>i j.\n          index l + Suc u = index i + j \\<and> index i + j < index (Suc i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i j.\n       index l + 0 = index i + j \\<and> index i + j < index (Suc i)", "by (intro exI conjI, rule refl, insert index_ordered[of l], simp)"], ["proof (state)\nthis:\n  \\<exists>i j. index l + 0 = index i + j \\<and> index i + j < index (Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<exists>i j.\n          index l + u = index i + j \\<and>\n          index i + j < index (Suc i) \\<Longrightarrow>\n       \\<exists>i j.\n          index l + Suc u = index i + j \\<and> index i + j < index (Suc i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<exists>i j.\n          index l + u = index i + j \\<and>\n          index i + j < index (Suc i) \\<Longrightarrow>\n       \\<exists>i j.\n          index l + Suc u = index i + j \\<and> index i + j < index (Suc i)", "case (Suc u)"], ["proof (state)\nthis:\n  \\<exists>i j. index l + u = index i + j \\<and> index i + j < index (Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<exists>i j.\n          index l + u = index i + j \\<and>\n          index i + j < index (Suc i) \\<Longrightarrow>\n       \\<exists>i j.\n          index l + Suc u = index i + j \\<and> index i + j < index (Suc i)", "then"], ["proof (chain)\npicking this:\n  \\<exists>i j. index l + u = index i + j \\<and> index i + j < index (Suc i)", "obtain i j\n      where lu: \"index l + u = index i + j\" and lt: \"index i + j < index (Suc i)\""], ["proof (prove)\nusing this:\n  \\<exists>i j. index l + u = index i + j \\<and> index i + j < index (Suc i)\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>index l + u = index i + j;\n         index i + j < index (Suc i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  index l + u = index i + j\n  index i + j < index (Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<exists>i j.\n          index l + u = index i + j \\<and>\n          index i + j < index (Suc i) \\<Longrightarrow>\n       \\<exists>i j.\n          index l + Suc u = index i + j \\<and> index i + j < index (Suc i)", "hence \"index l + u < index (Suc i)\""], ["proof (prove)\nusing this:\n  index l + u = index i + j\n  index i + j < index (Suc i)\n\ngoal (1 subgoal):\n 1. index l + u < index (Suc i)", "by auto"], ["proof (state)\nthis:\n  index l + u < index (Suc i)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<exists>i j.\n          index l + u = index i + j \\<and>\n          index i + j < index (Suc i) \\<Longrightarrow>\n       \\<exists>i j.\n          index l + Suc u = index i + j \\<and> index i + j < index (Suc i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i j.\n       index l + Suc u = index i + j \\<and> index i + j < index (Suc i)", "proof (cases \"index l + (Suc u) = index (Suc i)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. index l + Suc u = index (Suc i) \\<Longrightarrow>\n    \\<exists>i j.\n       index l + Suc u = index i + j \\<and> index i + j < index (Suc i)\n 2. index l + Suc u \\<noteq> index (Suc i) \\<Longrightarrow>\n    \\<exists>i j.\n       index l + Suc u = index i + j \\<and> index i + j < index (Suc i)", "case False"], ["proof (state)\nthis:\n  index l + Suc u \\<noteq> index (Suc i)\n\ngoal (2 subgoals):\n 1. index l + Suc u = index (Suc i) \\<Longrightarrow>\n    \\<exists>i j.\n       index l + Suc u = index i + j \\<and> index i + j < index (Suc i)\n 2. index l + Suc u \\<noteq> index (Suc i) \\<Longrightarrow>\n    \\<exists>i j.\n       index l + Suc u = index i + j \\<and> index i + j < index (Suc i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i j.\n       index l + Suc u = index i + j \\<and> index i + j < index (Suc i)", "by (rule exI[of _ i], rule exI[of _ \"Suc j\"], insert lu lt False, auto)"], ["proof (state)\nthis:\n  \\<exists>i j.\n     index l + Suc u = index i + j \\<and> index i + j < index (Suc i)\n\ngoal (1 subgoal):\n 1. index l + Suc u = index (Suc i) \\<Longrightarrow>\n    \\<exists>i j.\n       index l + Suc u = index i + j \\<and> index i + j < index (Suc i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. index l + Suc u = index (Suc i) \\<Longrightarrow>\n    \\<exists>i j.\n       index l + Suc u = index i + j \\<and> index i + j < index (Suc i)", "case True"], ["proof (state)\nthis:\n  index l + Suc u = index (Suc i)\n\ngoal (1 subgoal):\n 1. index l + Suc u = index (Suc i) \\<Longrightarrow>\n    \\<exists>i j.\n       index l + Suc u = index i + j \\<and> index i + j < index (Suc i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i j.\n       index l + Suc u = index i + j \\<and> index i + j < index (Suc i)", "by (rule exI[of _ \"Suc i\"], rule exI[of _ 0], insert True index_ordered[of \"Suc i\"], auto)"], ["proof (state)\nthis:\n  \\<exists>i j.\n     index l + Suc u = index i + j \\<and> index i + j < index (Suc i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i j.\n     index l + Suc u = index i + j \\<and> index i + j < index (Suc i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i j. k = index i + j \\<and> index i + j < index (Suc i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma index_ordered_less:\n  assumes \"i < j\" shows \"index i < index j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index i < index j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. index i < index j", "from assms"], ["proof (chain)\npicking this:\n  i < j", "have \"Suc i \\<le> j\""], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. Suc i \\<le> j", "by auto"], ["proof (state)\nthis:\n  Suc i \\<le> j\n\ngoal (1 subgoal):\n 1. index i < index j", "from index_ordered_le[OF this]"], ["proof (chain)\npicking this:\n  index (Suc i) \\<le> index j", "have \"index (Suc i) \\<le> index j\""], ["proof (prove)\nusing this:\n  index (Suc i) \\<le> index j\n\ngoal (1 subgoal):\n 1. index (Suc i) \\<le> index j", "."], ["proof (state)\nthis:\n  index (Suc i) \\<le> index j\n\ngoal (1 subgoal):\n 1. index i < index j", "with index_ordered[of i]"], ["proof (chain)\npicking this:\n  index i < index (Suc i)\n  index (Suc i) \\<le> index j", "show ?thesis"], ["proof (prove)\nusing this:\n  index i < index (Suc i)\n  index (Suc i) \\<le> index j\n\ngoal (1 subgoal):\n 1. index i < index j", "by auto"], ["proof (state)\nthis:\n  index i < index j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma index_not_p_start: assumes i: \"i < index 0\" shows \"\\<not> p i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> p i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> p i", "from i[simplified index.simps]"], ["proof (chain)\npicking this:\n  i < Least p", "have \"i < Least p\""], ["proof (prove)\nusing this:\n  i < Least p\n\ngoal (1 subgoal):\n 1. i < Least p", "."], ["proof (state)\nthis:\n  i < Least p\n\ngoal (1 subgoal):\n 1. \\<not> p i", "from not_less_Least[OF this]"], ["proof (chain)\npicking this:\n  \\<not> p i", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> p i\n\ngoal (1 subgoal):\n 1. \\<not> p i", "."], ["proof (state)\nthis:\n  \\<not> p i\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Assembling Infinite Words from Finite Words\\<close>"], ["", "text \\<open>Concatenate infinitely many non-empty words to an infinite word.\\<close>"], ["", "fun inf_concat_simple :: \"(nat \\<Rightarrow> nat) \\<Rightarrow> nat \\<Rightarrow> (nat \\<times> nat)\" where\n  \"inf_concat_simple f 0 = (0, 0)\"\n| \"inf_concat_simple f (Suc n) = (\n    let (i, j) = inf_concat_simple f n in \n    if Suc j < f i then (i, Suc j)\n    else (Suc i, 0))\""], ["", "lemma inf_concat_simple_add:\n  assumes ck: \"inf_concat_simple f k = (i, j)\"\n    and jl: \"j + l < f i\"\n  shows \"inf_concat_simple f (k + l) = (i,j + l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_concat_simple f (k + l) = (i, j + l)", "using jl"], ["proof (prove)\nusing this:\n  j + l < f i\n\ngoal (1 subgoal):\n 1. inf_concat_simple f (k + l) = (i, j + l)", "proof (induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. j + 0 < f i \\<Longrightarrow> inf_concat_simple f (k + 0) = (i, j + 0)\n 2. \\<And>l.\n       \\<lbrakk>j + l < f i \\<Longrightarrow>\n                inf_concat_simple f (k + l) = (i, j + l);\n        j + Suc l < f i\\<rbrakk>\n       \\<Longrightarrow> inf_concat_simple f (k + Suc l) = (i, j + Suc l)", "case 0"], ["proof (state)\nthis:\n  j + 0 < f i\n\ngoal (2 subgoals):\n 1. j + 0 < f i \\<Longrightarrow> inf_concat_simple f (k + 0) = (i, j + 0)\n 2. \\<And>l.\n       \\<lbrakk>j + l < f i \\<Longrightarrow>\n                inf_concat_simple f (k + l) = (i, j + l);\n        j + Suc l < f i\\<rbrakk>\n       \\<Longrightarrow> inf_concat_simple f (k + Suc l) = (i, j + Suc l)", "thus ?case"], ["proof (prove)\nusing this:\n  j + 0 < f i\n\ngoal (1 subgoal):\n 1. inf_concat_simple f (k + 0) = (i, j + 0)", "using ck"], ["proof (prove)\nusing this:\n  j + 0 < f i\n  inf_concat_simple f k = (i, j)\n\ngoal (1 subgoal):\n 1. inf_concat_simple f (k + 0) = (i, j + 0)", "by simp"], ["proof (state)\nthis:\n  inf_concat_simple f (k + 0) = (i, j + 0)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>j + l < f i \\<Longrightarrow>\n                inf_concat_simple f (k + l) = (i, j + l);\n        j + Suc l < f i\\<rbrakk>\n       \\<Longrightarrow> inf_concat_simple f (k + Suc l) = (i, j + Suc l)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>j + l < f i \\<Longrightarrow>\n                inf_concat_simple f (k + l) = (i, j + l);\n        j + Suc l < f i\\<rbrakk>\n       \\<Longrightarrow> inf_concat_simple f (k + Suc l) = (i, j + Suc l)", "case (Suc l)"], ["proof (state)\nthis:\n  j + l < f i \\<Longrightarrow> inf_concat_simple f (k + l) = (i, j + l)\n  j + Suc l < f i\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>j + l < f i \\<Longrightarrow>\n                inf_concat_simple f (k + l) = (i, j + l);\n        j + Suc l < f i\\<rbrakk>\n       \\<Longrightarrow> inf_concat_simple f (k + Suc l) = (i, j + Suc l)", "hence c: \"inf_concat_simple f (k + l) = (i, j+ l)\""], ["proof (prove)\nusing this:\n  j + l < f i \\<Longrightarrow> inf_concat_simple f (k + l) = (i, j + l)\n  j + Suc l < f i\n\ngoal (1 subgoal):\n 1. inf_concat_simple f (k + l) = (i, j + l)", "by auto"], ["proof (state)\nthis:\n  inf_concat_simple f (k + l) = (i, j + l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>j + l < f i \\<Longrightarrow>\n                inf_concat_simple f (k + l) = (i, j + l);\n        j + Suc l < f i\\<rbrakk>\n       \\<Longrightarrow> inf_concat_simple f (k + Suc l) = (i, j + Suc l)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_concat_simple f (k + Suc l) = (i, j + Suc l)", "by (simp add: c, insert Suc(2), auto)"], ["proof (state)\nthis:\n  inf_concat_simple f (k + Suc l) = (i, j + Suc l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inf_concat_simple_surj_zero: \"\\<exists> k. inf_concat_simple f k = (i,0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. inf_concat_simple f k = (i, 0)", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>k. inf_concat_simple f k = (0, 0)\n 2. \\<And>i.\n       \\<exists>k. inf_concat_simple f k = (i, 0) \\<Longrightarrow>\n       \\<exists>k. inf_concat_simple f k = (Suc i, 0)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<exists>k. inf_concat_simple f k = (0, 0)\n 2. \\<And>i.\n       \\<exists>k. inf_concat_simple f k = (i, 0) \\<Longrightarrow>\n       \\<exists>k. inf_concat_simple f k = (Suc i, 0)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. inf_concat_simple f k = (0, 0)", "by (rule exI[of _ 0], simp)"], ["proof (state)\nthis:\n  \\<exists>k. inf_concat_simple f k = (0, 0)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>k. inf_concat_simple f k = (i, 0) \\<Longrightarrow>\n       \\<exists>k. inf_concat_simple f k = (Suc i, 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>k. inf_concat_simple f k = (i, 0) \\<Longrightarrow>\n       \\<exists>k. inf_concat_simple f k = (Suc i, 0)", "case (Suc i)"], ["proof (state)\nthis:\n  \\<exists>k. inf_concat_simple f k = (i, 0)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>k. inf_concat_simple f k = (i, 0) \\<Longrightarrow>\n       \\<exists>k. inf_concat_simple f k = (Suc i, 0)", "then"], ["proof (chain)\npicking this:\n  \\<exists>k. inf_concat_simple f k = (i, 0)", "obtain k where ck: \"inf_concat_simple f k = (i,0)\""], ["proof (prove)\nusing this:\n  \\<exists>k. inf_concat_simple f k = (i, 0)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        inf_concat_simple f k = (i, 0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  inf_concat_simple f k = (i, 0)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<exists>k. inf_concat_simple f k = (i, 0) \\<Longrightarrow>\n       \\<exists>k. inf_concat_simple f k = (Suc i, 0)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. inf_concat_simple f k = (Suc i, 0)", "proof (cases \"f i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f i = 0 \\<Longrightarrow> \\<exists>k. inf_concat_simple f k = (Suc i, 0)\n 2. \\<And>nat.\n       f i = Suc nat \\<Longrightarrow>\n       \\<exists>k. inf_concat_simple f k = (Suc i, 0)", "case 0"], ["proof (state)\nthis:\n  f i = 0\n\ngoal (2 subgoals):\n 1. f i = 0 \\<Longrightarrow> \\<exists>k. inf_concat_simple f k = (Suc i, 0)\n 2. \\<And>nat.\n       f i = Suc nat \\<Longrightarrow>\n       \\<exists>k. inf_concat_simple f k = (Suc i, 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. inf_concat_simple f k = (Suc i, 0)", "by (rule exI[of _ \"Suc k\"], simp add: ck 0)"], ["proof (state)\nthis:\n  \\<exists>k. inf_concat_simple f k = (Suc i, 0)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       f i = Suc nat \\<Longrightarrow>\n       \\<exists>k. inf_concat_simple f k = (Suc i, 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       f i = Suc nat \\<Longrightarrow>\n       \\<exists>k. inf_concat_simple f k = (Suc i, 0)", "case (Suc n)"], ["proof (state)\nthis:\n  f i = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       f i = Suc nat \\<Longrightarrow>\n       \\<exists>k. inf_concat_simple f k = (Suc i, 0)", "hence \"0 + n < f i\""], ["proof (prove)\nusing this:\n  f i = Suc n\n\ngoal (1 subgoal):\n 1. 0 + n < f i", "by auto"], ["proof (state)\nthis:\n  0 + n < f i\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       f i = Suc nat \\<Longrightarrow>\n       \\<exists>k. inf_concat_simple f k = (Suc i, 0)", "from inf_concat_simple_add[OF ck, OF this] Suc"], ["proof (chain)\npicking this:\n  inf_concat_simple f (k + n) = (i, 0 + n)\n  f i = Suc n", "show ?thesis"], ["proof (prove)\nusing this:\n  inf_concat_simple f (k + n) = (i, 0 + n)\n  f i = Suc n\n\ngoal (1 subgoal):\n 1. \\<exists>k. inf_concat_simple f k = (Suc i, 0)", "by (intro exI[of _ \"k + Suc n\"], auto)"], ["proof (state)\nthis:\n  \\<exists>k. inf_concat_simple f k = (Suc i, 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k. inf_concat_simple f k = (Suc i, 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inf_concat_simple_surj:\n  assumes \"j < f i\"\n  shows \"\\<exists> k. inf_concat_simple f k = (i,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. inf_concat_simple f k = (i, j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k. inf_concat_simple f k = (i, j)", "from assms"], ["proof (chain)\npicking this:\n  j < f i", "have j: \"0 + j < f i\""], ["proof (prove)\nusing this:\n  j < f i\n\ngoal (1 subgoal):\n 1. 0 + j < f i", "by auto"], ["proof (state)\nthis:\n  0 + j < f i\n\ngoal (1 subgoal):\n 1. \\<exists>k. inf_concat_simple f k = (i, j)", "from inf_concat_simple_surj_zero"], ["proof (chain)\npicking this:\n  \\<exists>k. inf_concat_simple ?f k = (?i, 0)", "obtain k where \"inf_concat_simple f k = (i,0)\""], ["proof (prove)\nusing this:\n  \\<exists>k. inf_concat_simple ?f k = (?i, 0)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        inf_concat_simple f k = (i, 0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  inf_concat_simple f k = (i, 0)\n\ngoal (1 subgoal):\n 1. \\<exists>k. inf_concat_simple f k = (i, j)", "from inf_concat_simple_add[OF this, OF j]"], ["proof (chain)\npicking this:\n  inf_concat_simple f (k + j) = (i, 0 + j)", "show ?thesis"], ["proof (prove)\nusing this:\n  inf_concat_simple f (k + j) = (i, 0 + j)\n\ngoal (1 subgoal):\n 1. \\<exists>k. inf_concat_simple f k = (i, j)", "by auto"], ["proof (state)\nthis:\n  \\<exists>k. inf_concat_simple f k = (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inf_concat_simple_mono:\n  assumes \"k \\<le> k'\" shows \"fst (inf_concat_simple f k) \\<le> fst (inf_concat_simple f k')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (inf_concat_simple f k) \\<le> fst (inf_concat_simple f k')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (inf_concat_simple f k) \\<le> fst (inf_concat_simple f k')", "from assms"], ["proof (chain)\npicking this:\n  k \\<le> k'", "have \"k' = k + (k' - k)\""], ["proof (prove)\nusing this:\n  k \\<le> k'\n\ngoal (1 subgoal):\n 1. k' = k + (k' - k)", "by auto"], ["proof (state)\nthis:\n  k' = k + (k' - k)\n\ngoal (1 subgoal):\n 1. fst (inf_concat_simple f k) \\<le> fst (inf_concat_simple f k')", "then"], ["proof (chain)\npicking this:\n  k' = k + (k' - k)", "obtain l where k': \"k' = k + l\""], ["proof (prove)\nusing this:\n  k' = k + (k' - k)\n\ngoal (1 subgoal):\n 1. (\\<And>l. k' = k + l \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  k' = k + l\n\ngoal (1 subgoal):\n 1. fst (inf_concat_simple f k) \\<le> fst (inf_concat_simple f k')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (inf_concat_simple f k) \\<le> fst (inf_concat_simple f k')", "unfolding k'"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (inf_concat_simple f k) \\<le> fst (inf_concat_simple f (k + l))", "proof (induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (inf_concat_simple f k) \\<le> fst (inf_concat_simple f (k + 0))\n 2. \\<And>l.\n       fst (inf_concat_simple f k)\n       \\<le> fst (inf_concat_simple f (k + l)) \\<Longrightarrow>\n       fst (inf_concat_simple f k)\n       \\<le> fst (inf_concat_simple f (k + Suc l))", "case (Suc l)"], ["proof (state)\nthis:\n  fst (inf_concat_simple f k) \\<le> fst (inf_concat_simple f (k + l))\n\ngoal (2 subgoals):\n 1. fst (inf_concat_simple f k) \\<le> fst (inf_concat_simple f (k + 0))\n 2. \\<And>l.\n       fst (inf_concat_simple f k)\n       \\<le> fst (inf_concat_simple f (k + l)) \\<Longrightarrow>\n       fst (inf_concat_simple f k)\n       \\<le> fst (inf_concat_simple f (k + Suc l))", "obtain i j where ckl: \"inf_concat_simple f (k+l) = (i,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        inf_concat_simple f (k + l) = (i, j) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"inf_concat_simple f (k+l)\", auto)"], ["proof (state)\nthis:\n  inf_concat_simple f (k + l) = (i, j)\n\ngoal (2 subgoals):\n 1. fst (inf_concat_simple f k) \\<le> fst (inf_concat_simple f (k + 0))\n 2. \\<And>l.\n       fst (inf_concat_simple f k)\n       \\<le> fst (inf_concat_simple f (k + l)) \\<Longrightarrow>\n       fst (inf_concat_simple f k)\n       \\<le> fst (inf_concat_simple f (k + Suc l))", "with Suc"], ["proof (chain)\npicking this:\n  fst (inf_concat_simple f k) \\<le> fst (inf_concat_simple f (k + l))\n  inf_concat_simple f (k + l) = (i, j)", "have \"fst (inf_concat_simple f k) \\<le> i\""], ["proof (prove)\nusing this:\n  fst (inf_concat_simple f k) \\<le> fst (inf_concat_simple f (k + l))\n  inf_concat_simple f (k + l) = (i, j)\n\ngoal (1 subgoal):\n 1. fst (inf_concat_simple f k) \\<le> i", "by auto"], ["proof (state)\nthis:\n  fst (inf_concat_simple f k) \\<le> i\n\ngoal (2 subgoals):\n 1. fst (inf_concat_simple f k) \\<le> fst (inf_concat_simple f (k + 0))\n 2. \\<And>l.\n       fst (inf_concat_simple f k)\n       \\<le> fst (inf_concat_simple f (k + l)) \\<Longrightarrow>\n       fst (inf_concat_simple f k)\n       \\<le> fst (inf_concat_simple f (k + Suc l))", "also"], ["proof (state)\nthis:\n  fst (inf_concat_simple f k) \\<le> i\n\ngoal (2 subgoals):\n 1. fst (inf_concat_simple f k) \\<le> fst (inf_concat_simple f (k + 0))\n 2. \\<And>l.\n       fst (inf_concat_simple f k)\n       \\<le> fst (inf_concat_simple f (k + l)) \\<Longrightarrow>\n       fst (inf_concat_simple f k)\n       \\<le> fst (inf_concat_simple f (k + Suc l))", "have \"... \\<le> fst (inf_concat_simple f (k + Suc l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> fst (inf_concat_simple f (k + Suc l))", "by (simp add: ckl)"], ["proof (state)\nthis:\n  i \\<le> fst (inf_concat_simple f (k + Suc l))\n\ngoal (2 subgoals):\n 1. fst (inf_concat_simple f k) \\<le> fst (inf_concat_simple f (k + 0))\n 2. \\<And>l.\n       fst (inf_concat_simple f k)\n       \\<le> fst (inf_concat_simple f (k + l)) \\<Longrightarrow>\n       fst (inf_concat_simple f k)\n       \\<le> fst (inf_concat_simple f (k + Suc l))", "finally"], ["proof (chain)\npicking this:\n  fst (inf_concat_simple f k) \\<le> fst (inf_concat_simple f (k + Suc l))", "show ?case"], ["proof (prove)\nusing this:\n  fst (inf_concat_simple f k) \\<le> fst (inf_concat_simple f (k + Suc l))\n\ngoal (1 subgoal):\n 1. fst (inf_concat_simple f k) \\<le> fst (inf_concat_simple f (k + Suc l))", "."], ["proof (state)\nthis:\n  fst (inf_concat_simple f k) \\<le> fst (inf_concat_simple f (k + Suc l))\n\ngoal (1 subgoal):\n 1. fst (inf_concat_simple f k) \\<le> fst (inf_concat_simple f (k + 0))", "qed simp"], ["proof (state)\nthis:\n  fst (inf_concat_simple f k) \\<le> fst (inf_concat_simple f k')\n\ngoal:\nNo subgoals!", "qed"], ["", "(* inf_concat assembles infinitely many (possibly empty) words to an infinite word *)"], ["", "fun inf_concat :: \"(nat \\<Rightarrow> nat) \\<Rightarrow> nat \\<Rightarrow> nat \\<times> nat\" where\n  \"inf_concat n 0 = (LEAST j. n j > 0, 0)\"\n| \"inf_concat n (Suc k) = (let (i, j) = inf_concat n k in (if Suc j < n i then (i, Suc j) else (LEAST i'. i' > i \\<and> n i' > 0, 0)))\""], ["", "lemma inf_concat_bounds:\n  assumes inf: \"INFM i. n i > 0\"\n    and res: \"inf_concat n k = (i,j)\"\n  shows \"j < n i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < n i", "proof (cases k)"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> j < n i\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> j < n i", "case 0"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> j < n i\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> j < n i", "with res"], ["proof (chain)\npicking this:\n  inf_concat n k = (i, j)\n  k = 0", "have i: \"i = (LEAST i. n i > 0)\" and j: \"j = 0\""], ["proof (prove)\nusing this:\n  inf_concat n k = (i, j)\n  k = 0\n\ngoal (1 subgoal):\n 1. i = (LEAST i. 0 < n i) &&& j = 0", "by auto"], ["proof (state)\nthis:\n  i = (LEAST i. 0 < n i)\n  j = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> j < n i\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> j < n i", "from inf[unfolded INFM_nat_le]"], ["proof (chain)\npicking this:\n  \\<forall>m. \\<exists>na\\<ge>m. 0 < n na", "obtain i' where i': \"0 < n i'\""], ["proof (prove)\nusing this:\n  \\<forall>m. \\<exists>na\\<ge>m. 0 < n na\n\ngoal (1 subgoal):\n 1. (\\<And>i'. 0 < n i' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  0 < n i'\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> j < n i\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> j < n i", "have \"0 < n (LEAST i. n i > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n (LEAST i. 0 < n i)", "by (rule LeastI, rule i')"], ["proof (state)\nthis:\n  0 < n (LEAST i. 0 < n i)\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> j < n i\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> j < n i", "with i j"], ["proof (chain)\npicking this:\n  i = (LEAST i. 0 < n i)\n  j = 0\n  0 < n (LEAST i. 0 < n i)", "show ?thesis"], ["proof (prove)\nusing this:\n  i = (LEAST i. 0 < n i)\n  j = 0\n  0 < n (LEAST i. 0 < n i)\n\ngoal (1 subgoal):\n 1. j < n i", "by auto"], ["proof (state)\nthis:\n  j < n i\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> j < n i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> j < n i", "case (Suc k')"], ["proof (state)\nthis:\n  k = Suc k'\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> j < n i", "obtain i' j' where res': \"inf_concat n k' = (i',j')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i' j'.\n        inf_concat n k' = (i', j') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  inf_concat n k' = (i', j')\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> j < n i", "note res = res[unfolded Suc inf_concat.simps res' Let_def split]"], ["proof (state)\nthis:\n  (if Suc j' < n i' then (i', Suc j')\n   else (LEAST i'a. i' < i'a \\<and> 0 < n i'a, 0)) =\n  (i, j)\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> j < n i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. j < n i", "proof (cases \"Suc j' < n i'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc j' < n i' \\<Longrightarrow> j < n i\n 2. \\<not> Suc j' < n i' \\<Longrightarrow> j < n i", "case True"], ["proof (state)\nthis:\n  Suc j' < n i'\n\ngoal (2 subgoals):\n 1. Suc j' < n i' \\<Longrightarrow> j < n i\n 2. \\<not> Suc j' < n i' \\<Longrightarrow> j < n i", "with res"], ["proof (chain)\npicking this:\n  (if Suc j' < n i' then (i', Suc j')\n   else (LEAST i'a. i' < i'a \\<and> 0 < n i'a, 0)) =\n  (i, j)\n  Suc j' < n i'", "show ?thesis"], ["proof (prove)\nusing this:\n  (if Suc j' < n i' then (i', Suc j')\n   else (LEAST i'a. i' < i'a \\<and> 0 < n i'a, 0)) =\n  (i, j)\n  Suc j' < n i'\n\ngoal (1 subgoal):\n 1. j < n i", "by auto"], ["proof (state)\nthis:\n  j < n i\n\ngoal (1 subgoal):\n 1. \\<not> Suc j' < n i' \\<Longrightarrow> j < n i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Suc j' < n i' \\<Longrightarrow> j < n i", "case False"], ["proof (state)\nthis:\n  \\<not> Suc j' < n i'\n\ngoal (1 subgoal):\n 1. \\<not> Suc j' < n i' \\<Longrightarrow> j < n i", "with res"], ["proof (chain)\npicking this:\n  (if Suc j' < n i' then (i', Suc j')\n   else (LEAST i'a. i' < i'a \\<and> 0 < n i'a, 0)) =\n  (i, j)\n  \\<not> Suc j' < n i'", "have i: \"i = (LEAST f. i' < f \\<and> 0 < n f)\" and j: \"j = 0\""], ["proof (prove)\nusing this:\n  (if Suc j' < n i' then (i', Suc j')\n   else (LEAST i'a. i' < i'a \\<and> 0 < n i'a, 0)) =\n  (i, j)\n  \\<not> Suc j' < n i'\n\ngoal (1 subgoal):\n 1. i = (LEAST f. i' < f \\<and> 0 < n f) &&& j = 0", "by auto"], ["proof (state)\nthis:\n  i = (LEAST f. i' < f \\<and> 0 < n f)\n  j = 0\n\ngoal (1 subgoal):\n 1. \\<not> Suc j' < n i' \\<Longrightarrow> j < n i", "from inf[unfolded INFM_nat]"], ["proof (chain)\npicking this:\n  \\<forall>m. \\<exists>na>m. 0 < n na", "obtain f where f: \"i' < f \\<and> 0 < n f\""], ["proof (prove)\nusing this:\n  \\<forall>m. \\<exists>na>m. 0 < n na\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        i' < f \\<and> 0 < n f \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i' < f \\<and> 0 < n f\n\ngoal (1 subgoal):\n 1. \\<not> Suc j' < n i' \\<Longrightarrow> j < n i", "have \"0 < n (LEAST f. i' < f \\<and> 0 < n f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n (LEAST f. i' < f \\<and> 0 < n f)", "using LeastI[of \"\\<lambda> f. i' < f \\<and> 0 < n f\", OF f]"], ["proof (prove)\nusing this:\n  i' < (LEAST x. i' < x \\<and> 0 < n x) \\<and>\n  0 < n (LEAST x. i' < x \\<and> 0 < n x)\n\ngoal (1 subgoal):\n 1. 0 < n (LEAST f. i' < f \\<and> 0 < n f)", "by auto"], ["proof (state)\nthis:\n  0 < n (LEAST f. i' < f \\<and> 0 < n f)\n\ngoal (1 subgoal):\n 1. \\<not> Suc j' < n i' \\<Longrightarrow> j < n i", "with i j"], ["proof (chain)\npicking this:\n  i = (LEAST f. i' < f \\<and> 0 < n f)\n  j = 0\n  0 < n (LEAST f. i' < f \\<and> 0 < n f)", "show ?thesis"], ["proof (prove)\nusing this:\n  i = (LEAST f. i' < f \\<and> 0 < n f)\n  j = 0\n  0 < n (LEAST f. i' < f \\<and> 0 < n f)\n\ngoal (1 subgoal):\n 1. j < n i", "by auto"], ["proof (state)\nthis:\n  j < n i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  j < n i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inf_concat_add:\n  assumes res: \"inf_concat n k = (i,j)\"\n    and j: \"j + m < n i\"\n  shows \"inf_concat n (k + m) = (i,j+m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_concat n (k + m) = (i, j + m)", "using j"], ["proof (prove)\nusing this:\n  j + m < n i\n\ngoal (1 subgoal):\n 1. inf_concat n (k + m) = (i, j + m)", "proof (induct m)"], ["proof (state)\ngoal (2 subgoals):\n 1. j + 0 < n i \\<Longrightarrow> inf_concat n (k + 0) = (i, j + 0)\n 2. \\<And>m.\n       \\<lbrakk>j + m < n i \\<Longrightarrow>\n                inf_concat n (k + m) = (i, j + m);\n        j + Suc m < n i\\<rbrakk>\n       \\<Longrightarrow> inf_concat n (k + Suc m) = (i, j + Suc m)", "case 0"], ["proof (state)\nthis:\n  j + 0 < n i\n\ngoal (2 subgoals):\n 1. j + 0 < n i \\<Longrightarrow> inf_concat n (k + 0) = (i, j + 0)\n 2. \\<And>m.\n       \\<lbrakk>j + m < n i \\<Longrightarrow>\n                inf_concat n (k + m) = (i, j + m);\n        j + Suc m < n i\\<rbrakk>\n       \\<Longrightarrow> inf_concat n (k + Suc m) = (i, j + Suc m)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_concat n (k + 0) = (i, j + 0)", "using res"], ["proof (prove)\nusing this:\n  inf_concat n k = (i, j)\n\ngoal (1 subgoal):\n 1. inf_concat n (k + 0) = (i, j + 0)", "by auto"], ["proof (state)\nthis:\n  inf_concat n (k + 0) = (i, j + 0)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>j + m < n i \\<Longrightarrow>\n                inf_concat n (k + m) = (i, j + m);\n        j + Suc m < n i\\<rbrakk>\n       \\<Longrightarrow> inf_concat n (k + Suc m) = (i, j + Suc m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>j + m < n i \\<Longrightarrow>\n                inf_concat n (k + m) = (i, j + m);\n        j + Suc m < n i\\<rbrakk>\n       \\<Longrightarrow> inf_concat n (k + Suc m) = (i, j + Suc m)", "case (Suc m)"], ["proof (state)\nthis:\n  j + m < n i \\<Longrightarrow> inf_concat n (k + m) = (i, j + m)\n  j + Suc m < n i\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>j + m < n i \\<Longrightarrow>\n                inf_concat n (k + m) = (i, j + m);\n        j + Suc m < n i\\<rbrakk>\n       \\<Longrightarrow> inf_concat n (k + Suc m) = (i, j + Suc m)", "hence \"inf_concat n (k + m) = (i, j+m)\""], ["proof (prove)\nusing this:\n  j + m < n i \\<Longrightarrow> inf_concat n (k + m) = (i, j + m)\n  j + Suc m < n i\n\ngoal (1 subgoal):\n 1. inf_concat n (k + m) = (i, j + m)", "by auto"], ["proof (state)\nthis:\n  inf_concat n (k + m) = (i, j + m)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>j + m < n i \\<Longrightarrow>\n                inf_concat n (k + m) = (i, j + m);\n        j + Suc m < n i\\<rbrakk>\n       \\<Longrightarrow> inf_concat n (k + Suc m) = (i, j + Suc m)", "with Suc(2)"], ["proof (chain)\npicking this:\n  j + Suc m < n i\n  inf_concat n (k + m) = (i, j + m)", "show ?case"], ["proof (prove)\nusing this:\n  j + Suc m < n i\n  inf_concat n (k + m) = (i, j + m)\n\ngoal (1 subgoal):\n 1. inf_concat n (k + Suc m) = (i, j + Suc m)", "by auto"], ["proof (state)\nthis:\n  inf_concat n (k + Suc m) = (i, j + Suc m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inf_concat_step:\n  assumes res: \"inf_concat n k = (i,j)\"\n    and j: \"Suc (j + m) = n i\"\n  shows \"inf_concat n (k + Suc m) = (LEAST i'. i' > i \\<and> 0 < n i', 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_concat n (k + Suc m) = (LEAST i'. i < i' \\<and> 0 < n i', 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inf_concat n (k + Suc m) = (LEAST i'. i < i' \\<and> 0 < n i', 0)", "from j"], ["proof (chain)\npicking this:\n  Suc (j + m) = n i", "have \"j + m < n i\""], ["proof (prove)\nusing this:\n  Suc (j + m) = n i\n\ngoal (1 subgoal):\n 1. j + m < n i", "by auto"], ["proof (state)\nthis:\n  j + m < n i\n\ngoal (1 subgoal):\n 1. inf_concat n (k + Suc m) = (LEAST i'. i < i' \\<and> 0 < n i', 0)", "note res = inf_concat_add[OF res, OF this]"], ["proof (state)\nthis:\n  inf_concat n (k + m) = (i, j + m)\n\ngoal (1 subgoal):\n 1. inf_concat n (k + Suc m) = (LEAST i'. i < i' \\<and> 0 < n i', 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_concat n (k + Suc m) = (LEAST i'. i < i' \\<and> 0 < n i', 0)", "by (simp add: res j)"], ["proof (state)\nthis:\n  inf_concat n (k + Suc m) = (LEAST i'. i < i' \\<and> 0 < n i', 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inf_concat_surj_zero:\n  assumes \"0 < n i\"\n  shows \"\\<exists>k. inf_concat n k = (i, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. inf_concat n k = (i, 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k. inf_concat n k = (i, 0)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k. inf_concat n k = (i, 0)", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k. inf_concat n k = (i, 0)", "have \"\\<forall> j. j < l \\<and> 0 < n j \\<longrightarrow> (\\<exists> k. inf_concat n k = (j,0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j.\n       j < l \\<and> 0 < n j \\<longrightarrow>\n       (\\<exists>k. inf_concat n k = (j, 0))", "proof (induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>j.\n       j < 0 \\<and> 0 < n j \\<longrightarrow>\n       (\\<exists>k. inf_concat n k = (j, 0))\n 2. \\<And>l.\n       \\<forall>j.\n          j < l \\<and> 0 < n j \\<longrightarrow>\n          (\\<exists>k. inf_concat n k = (j, 0)) \\<Longrightarrow>\n       \\<forall>j.\n          j < Suc l \\<and> 0 < n j \\<longrightarrow>\n          (\\<exists>k. inf_concat n k = (j, 0))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<forall>j.\n       j < 0 \\<and> 0 < n j \\<longrightarrow>\n       (\\<exists>k. inf_concat n k = (j, 0))\n 2. \\<And>l.\n       \\<forall>j.\n          j < l \\<and> 0 < n j \\<longrightarrow>\n          (\\<exists>k. inf_concat n k = (j, 0)) \\<Longrightarrow>\n       \\<forall>j.\n          j < Suc l \\<and> 0 < n j \\<longrightarrow>\n          (\\<exists>k. inf_concat n k = (j, 0))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j.\n       j < 0 \\<and> 0 < n j \\<longrightarrow>\n       (\\<exists>k. inf_concat n k = (j, 0))", "by auto"], ["proof (state)\nthis:\n  \\<forall>j.\n     j < 0 \\<and> 0 < n j \\<longrightarrow>\n     (\\<exists>k. inf_concat n k = (j, 0))\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<forall>j.\n          j < l \\<and> 0 < n j \\<longrightarrow>\n          (\\<exists>k. inf_concat n k = (j, 0)) \\<Longrightarrow>\n       \\<forall>j.\n          j < Suc l \\<and> 0 < n j \\<longrightarrow>\n          (\\<exists>k. inf_concat n k = (j, 0))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<forall>j.\n          j < l \\<and> 0 < n j \\<longrightarrow>\n          (\\<exists>k. inf_concat n k = (j, 0)) \\<Longrightarrow>\n       \\<forall>j.\n          j < Suc l \\<and> 0 < n j \\<longrightarrow>\n          (\\<exists>k. inf_concat n k = (j, 0))", "case (Suc l)"], ["proof (state)\nthis:\n  \\<forall>j.\n     j < l \\<and> 0 < n j \\<longrightarrow>\n     (\\<exists>k. inf_concat n k = (j, 0))\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<forall>j.\n          j < l \\<and> 0 < n j \\<longrightarrow>\n          (\\<exists>k. inf_concat n k = (j, 0)) \\<Longrightarrow>\n       \\<forall>j.\n          j < Suc l \\<and> 0 < n j \\<longrightarrow>\n          (\\<exists>k. inf_concat n k = (j, 0))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j.\n       j < Suc l \\<and> 0 < n j \\<longrightarrow>\n       (\\<exists>k. inf_concat n k = (j, 0))", "proof (intro allI impI, elim conjE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < Suc l; 0 < n j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k. inf_concat n k = (j, 0)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < Suc l; 0 < n j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k. inf_concat n k = (j, 0)", "assume j: \"j < Suc l\" and nj: \"0 < n j\""], ["proof (state)\nthis:\n  j < Suc l\n  0 < n j\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j < Suc l; 0 < n j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k. inf_concat n k = (j, 0)", "show \"\\<exists> k. inf_concat n k = (j, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. inf_concat n k = (j, 0)", "proof (cases \"j < l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j < l \\<Longrightarrow> \\<exists>k. inf_concat n k = (j, 0)\n 2. \\<not> j < l \\<Longrightarrow> \\<exists>k. inf_concat n k = (j, 0)", "case True"], ["proof (state)\nthis:\n  j < l\n\ngoal (2 subgoals):\n 1. j < l \\<Longrightarrow> \\<exists>k. inf_concat n k = (j, 0)\n 2. \\<not> j < l \\<Longrightarrow> \\<exists>k. inf_concat n k = (j, 0)", "from Suc[THEN spec[of _ j]] True nj"], ["proof (chain)\npicking this:\n  j < l \\<and> 0 < n j \\<longrightarrow>\n  (\\<exists>k. inf_concat n k = (j, 0))\n  j < l\n  0 < n j", "show ?thesis"], ["proof (prove)\nusing this:\n  j < l \\<and> 0 < n j \\<longrightarrow>\n  (\\<exists>k. inf_concat n k = (j, 0))\n  j < l\n  0 < n j\n\ngoal (1 subgoal):\n 1. \\<exists>k. inf_concat n k = (j, 0)", "by auto"], ["proof (state)\nthis:\n  \\<exists>k. inf_concat n k = (j, 0)\n\ngoal (1 subgoal):\n 1. \\<not> j < l \\<Longrightarrow> \\<exists>k. inf_concat n k = (j, 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < l \\<Longrightarrow> \\<exists>k. inf_concat n k = (j, 0)", "case False"], ["proof (state)\nthis:\n  \\<not> j < l\n\ngoal (1 subgoal):\n 1. \\<not> j < l \\<Longrightarrow> \\<exists>k. inf_concat n k = (j, 0)", "with j"], ["proof (chain)\npicking this:\n  j < Suc l\n  \\<not> j < l", "have j: \"j = l\""], ["proof (prove)\nusing this:\n  j < Suc l\n  \\<not> j < l\n\ngoal (1 subgoal):\n 1. j = l", "by auto"], ["proof (state)\nthis:\n  j = l\n\ngoal (1 subgoal):\n 1. \\<not> j < l \\<Longrightarrow> \\<exists>k. inf_concat n k = (j, 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. inf_concat n k = (j, 0)", "proof (cases \"\\<exists> j'. j' < l \\<and> 0 < n j'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>j'<l. 0 < n j' \\<Longrightarrow>\n    \\<exists>k. inf_concat n k = (j, 0)\n 2. \\<not> (\\<exists>j'<l. 0 < n j') \\<Longrightarrow>\n    \\<exists>k. inf_concat n k = (j, 0)", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>j'<l. 0 < n j')\n\ngoal (2 subgoals):\n 1. \\<exists>j'<l. 0 < n j' \\<Longrightarrow>\n    \\<exists>k. inf_concat n k = (j, 0)\n 2. \\<not> (\\<exists>j'<l. 0 < n j') \\<Longrightarrow>\n    \\<exists>k. inf_concat n k = (j, 0)", "have l: \"(LEAST i. 0 < n i) = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST i. 0 < n i) = l", "proof (rule Least_equality, rule nj[unfolded j])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. 0 < n y \\<Longrightarrow> l \\<le> y", "fix l'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. 0 < n y \\<Longrightarrow> l \\<le> y", "assume \"0 < n l'\""], ["proof (state)\nthis:\n  0 < n l'\n\ngoal (1 subgoal):\n 1. \\<And>y. 0 < n y \\<Longrightarrow> l \\<le> y", "with False"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>j'<l. 0 < n j')\n  0 < n l'", "have \"\\<not> l' < l\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>j'<l. 0 < n j')\n  0 < n l'\n\ngoal (1 subgoal):\n 1. \\<not> l' < l", "by auto"], ["proof (state)\nthis:\n  \\<not> l' < l\n\ngoal (1 subgoal):\n 1. \\<And>y. 0 < n y \\<Longrightarrow> l \\<le> y", "thus \"l \\<le> l'\""], ["proof (prove)\nusing this:\n  \\<not> l' < l\n\ngoal (1 subgoal):\n 1. l \\<le> l'", "by auto"], ["proof (state)\nthis:\n  l \\<le> l'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST i. 0 < n i) = l\n\ngoal (2 subgoals):\n 1. \\<exists>j'<l. 0 < n j' \\<Longrightarrow>\n    \\<exists>k. inf_concat n k = (j, 0)\n 2. \\<not> (\\<exists>j'<l. 0 < n j') \\<Longrightarrow>\n    \\<exists>k. inf_concat n k = (j, 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. inf_concat n k = (j, 0)", "by (rule exI[of _ 0], simp add: l j)"], ["proof (state)\nthis:\n  \\<exists>k. inf_concat n k = (j, 0)\n\ngoal (1 subgoal):\n 1. \\<exists>j'<l. 0 < n j' \\<Longrightarrow>\n    \\<exists>k. inf_concat n k = (j, 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>j'<l. 0 < n j' \\<Longrightarrow>\n    \\<exists>k. inf_concat n k = (j, 0)", "case True"], ["proof (state)\nthis:\n  \\<exists>j'<l. 0 < n j'\n\ngoal (1 subgoal):\n 1. \\<exists>j'<l. 0 < n j' \\<Longrightarrow>\n    \\<exists>k. inf_concat n k = (j, 0)", "then"], ["proof (chain)\npicking this:\n  \\<exists>j'<l. 0 < n j'", "obtain lll where lll: \"lll < l\" and nlll: \"0 < n lll\""], ["proof (prove)\nusing this:\n  \\<exists>j'<l. 0 < n j'\n\ngoal (1 subgoal):\n 1. (\\<And>lll.\n        \\<lbrakk>lll < l; 0 < n lll\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  lll < l\n  0 < n lll\n\ngoal (1 subgoal):\n 1. \\<exists>j'<l. 0 < n j' \\<Longrightarrow>\n    \\<exists>k. inf_concat n k = (j, 0)", "then"], ["proof (chain)\npicking this:\n  lll < l\n  0 < n lll", "obtain ll where l: \"l = Suc ll\""], ["proof (prove)\nusing this:\n  lll < l\n  0 < n lll\n\ngoal (1 subgoal):\n 1. (\\<And>ll. l = Suc ll \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases l, auto)"], ["proof (state)\nthis:\n  l = Suc ll\n\ngoal (1 subgoal):\n 1. \\<exists>j'<l. 0 < n j' \\<Longrightarrow>\n    \\<exists>k. inf_concat n k = (j, 0)", "from lll l"], ["proof (chain)\npicking this:\n  lll < l\n  l = Suc ll", "have lll: \"lll = ll - (ll - lll)\""], ["proof (prove)\nusing this:\n  lll < l\n  l = Suc ll\n\ngoal (1 subgoal):\n 1. lll = ll - (ll - lll)", "by auto"], ["proof (state)\nthis:\n  lll = ll - (ll - lll)\n\ngoal (1 subgoal):\n 1. \\<exists>j'<l. 0 < n j' \\<Longrightarrow>\n    \\<exists>k. inf_concat n k = (j, 0)", "let ?l' = \"LEAST d. 0 < n (ll - d)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>j'<l. 0 < n j' \\<Longrightarrow>\n    \\<exists>k. inf_concat n k = (j, 0)", "have nl': \"0 < n (ll - ?l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n (ll - (LEAST d. 0 < n (ll - d)))", "proof (rule LeastI)"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < n (ll - ?k)", "show \"0 < n (ll - (ll - lll))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n (ll - (ll - lll))", "using lll nlll"], ["proof (prove)\nusing this:\n  lll = ll - (ll - lll)\n  0 < n lll\n\ngoal (1 subgoal):\n 1. 0 < n (ll - (ll - lll))", "by auto"], ["proof (state)\nthis:\n  0 < n (ll - (ll - lll))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < n (ll - (LEAST d. 0 < n (ll - d)))\n\ngoal (1 subgoal):\n 1. \\<exists>j'<l. 0 < n j' \\<Longrightarrow>\n    \\<exists>k. inf_concat n k = (j, 0)", "with Suc[THEN spec[of _ \"ll - ?l'\"]]"], ["proof (chain)\npicking this:\n  ll - (LEAST d. 0 < n (ll - d)) < l \\<and>\n  0 < n (ll - (LEAST d. 0 < n (ll - d))) \\<longrightarrow>\n  (\\<exists>k. inf_concat n k = (ll - (LEAST d. 0 < n (ll - d)), 0))\n  0 < n (ll - (LEAST d. 0 < n (ll - d)))", "obtain k where k:\n              \"inf_concat n k = (ll - ?l',0)\""], ["proof (prove)\nusing this:\n  ll - (LEAST d. 0 < n (ll - d)) < l \\<and>\n  0 < n (ll - (LEAST d. 0 < n (ll - d))) \\<longrightarrow>\n  (\\<exists>k. inf_concat n k = (ll - (LEAST d. 0 < n (ll - d)), 0))\n  0 < n (ll - (LEAST d. 0 < n (ll - d)))\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        inf_concat n k =\n        (ll - (LEAST d. 0 < n (ll - d)), 0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding l"], ["proof (prove)\nusing this:\n  ll - (LEAST d. 0 < n (ll - d)) < Suc ll \\<and>\n  0 < n (ll - (LEAST d. 0 < n (ll - d))) \\<longrightarrow>\n  (\\<exists>k. inf_concat n k = (ll - (LEAST d. 0 < n (ll - d)), 0))\n  0 < n (ll - (LEAST d. 0 < n (ll - d)))\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        inf_concat n k =\n        (ll - (LEAST d. 0 < n (ll - d)), 0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  inf_concat n k = (ll - (LEAST d. 0 < n (ll - d)), 0)\n\ngoal (1 subgoal):\n 1. \\<exists>j'<l. 0 < n j' \\<Longrightarrow>\n    \\<exists>k. inf_concat n k = (j, 0)", "from nl'"], ["proof (chain)\npicking this:\n  0 < n (ll - (LEAST d. 0 < n (ll - d)))", "obtain off where off: \"Suc (0 + off) = n (ll - ?l')\""], ["proof (prove)\nusing this:\n  0 < n (ll - (LEAST d. 0 < n (ll - d)))\n\ngoal (1 subgoal):\n 1. (\\<And>off.\n        Suc (0 + off) = n (ll - (LEAST d. 0 < n (ll - d))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"n (ll - ?l')\", auto)"], ["proof (state)\nthis:\n  Suc (0 + off) = n (ll - (LEAST d. 0 < n (ll - d)))\n\ngoal (1 subgoal):\n 1. \\<exists>j'<l. 0 < n j' \\<Longrightarrow>\n    \\<exists>k. inf_concat n k = (j, 0)", "from inf_concat_step[OF k, OF off]"], ["proof (chain)\npicking this:\n  inf_concat n (k + Suc off) =\n  (LEAST i'. ll - (LEAST d. 0 < n (ll - d)) < i' \\<and> 0 < n i', 0)", "have id: \"inf_concat n (k + Suc off) = (LEAST i'. ll - ?l' < i' \\<and> 0 < n i',0)\" (is \"_ = (?l,0)\")"], ["proof (prove)\nusing this:\n  inf_concat n (k + Suc off) =\n  (LEAST i'. ll - (LEAST d. 0 < n (ll - d)) < i' \\<and> 0 < n i', 0)\n\ngoal (1 subgoal):\n 1. inf_concat n (k + Suc off) =\n    (LEAST i'. ll - (LEAST d. 0 < n (ll - d)) < i' \\<and> 0 < n i', 0)", "."], ["proof (state)\nthis:\n  inf_concat n (k + Suc off) =\n  (LEAST i'. ll - (LEAST d. 0 < n (ll - d)) < i' \\<and> 0 < n i', 0)\n\ngoal (1 subgoal):\n 1. \\<exists>j'<l. 0 < n j' \\<Longrightarrow>\n    \\<exists>k. inf_concat n k = (j, 0)", "have ll: \"?l = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST i'. ll - (LEAST d. 0 < n (ll - d)) < i' \\<and> 0 < n i') = l", "unfolding l"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST i'. ll - (LEAST d. 0 < n (ll - d)) < i' \\<and> 0 < n i') = Suc ll", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. ll - (LEAST d. 0 < n (ll - d)) < Suc ll \\<and> 0 < n (Suc ll)\n 2. \\<And>y.\n       ll - (LEAST d. 0 < n (ll - d)) < y \\<and> 0 < n y \\<Longrightarrow>\n       Suc ll \\<le> y", "show \"ll - ?l' < Suc ll \\<and> 0 < n (Suc ll)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ll - (LEAST d. 0 < n (ll - d)) < Suc ll \\<and> 0 < n (Suc ll)", "using nj[unfolded j l]"], ["proof (prove)\nusing this:\n  0 < n (Suc ll)\n\ngoal (1 subgoal):\n 1. ll - (LEAST d. 0 < n (ll - d)) < Suc ll \\<and> 0 < n (Suc ll)", "by simp"], ["proof (state)\nthis:\n  ll - (LEAST d. 0 < n (ll - d)) < Suc ll \\<and> 0 < n (Suc ll)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       ll - (LEAST d. 0 < n (ll - d)) < y \\<and> 0 < n y \\<Longrightarrow>\n       Suc ll \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       ll - (LEAST d. 0 < n (ll - d)) < y \\<and> 0 < n y \\<Longrightarrow>\n       Suc ll \\<le> y", "fix l'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       ll - (LEAST d. 0 < n (ll - d)) < y \\<and> 0 < n y \\<Longrightarrow>\n       Suc ll \\<le> y", "assume ass: \"ll - ?l' < l' \\<and> 0 < n l'\""], ["proof (state)\nthis:\n  ll - (LEAST d. 0 < n (ll - d)) < l' \\<and> 0 < n l'\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       ll - (LEAST d. 0 < n (ll - d)) < y \\<and> 0 < n y \\<Longrightarrow>\n       Suc ll \\<le> y", "show \"Suc ll \\<le> l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc ll \\<le> l'", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Suc ll \\<le> l' \\<Longrightarrow> False", "assume not: \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> Suc ll \\<le> l'\n\ngoal (1 subgoal):\n 1. \\<not> Suc ll \\<le> l' \\<Longrightarrow> False", "hence \"l' \\<le> ll\""], ["proof (prove)\nusing this:\n  \\<not> Suc ll \\<le> l'\n\ngoal (1 subgoal):\n 1. l' \\<le> ll", "by auto"], ["proof (state)\nthis:\n  l' \\<le> ll\n\ngoal (1 subgoal):\n 1. \\<not> Suc ll \\<le> l' \\<Longrightarrow> False", "hence \"ll = l' + (ll - l')\""], ["proof (prove)\nusing this:\n  l' \\<le> ll\n\ngoal (1 subgoal):\n 1. ll = l' + (ll - l')", "by auto"], ["proof (state)\nthis:\n  ll = l' + (ll - l')\n\ngoal (1 subgoal):\n 1. \\<not> Suc ll \\<le> l' \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  ll = l' + (ll - l')", "obtain k where ll: \"ll = l' + k\""], ["proof (prove)\nusing this:\n  ll = l' + (ll - l')\n\ngoal (1 subgoal):\n 1. (\\<And>k. ll = l' + k \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  ll = l' + k\n\ngoal (1 subgoal):\n 1. \\<not> Suc ll \\<le> l' \\<Longrightarrow> False", "from ass"], ["proof (chain)\npicking this:\n  ll - (LEAST d. 0 < n (ll - d)) < l' \\<and> 0 < n l'", "have \"l' + k - ?l' < l'\""], ["proof (prove)\nusing this:\n  ll - (LEAST d. 0 < n (ll - d)) < l' \\<and> 0 < n l'\n\ngoal (1 subgoal):\n 1. l' + k - (LEAST d. 0 < n (ll - d)) < l'", "unfolding ll"], ["proof (prove)\nusing this:\n  l' + k - (LEAST d. 0 < n (l' + k - d)) < l' \\<and> 0 < n l'\n\ngoal (1 subgoal):\n 1. l' + k - (LEAST d. 0 < n (l' + k - d)) < l'", "by auto"], ["proof (state)\nthis:\n  l' + k - (LEAST d. 0 < n (ll - d)) < l'\n\ngoal (1 subgoal):\n 1. \\<not> Suc ll \\<le> l' \\<Longrightarrow> False", "hence kl': \"k < ?l'\""], ["proof (prove)\nusing this:\n  l' + k - (LEAST d. 0 < n (ll - d)) < l'\n\ngoal (1 subgoal):\n 1. k < (LEAST d. 0 < n (ll - d))", "by auto"], ["proof (state)\nthis:\n  k < (LEAST d. 0 < n (ll - d))\n\ngoal (1 subgoal):\n 1. \\<not> Suc ll \\<le> l' \\<Longrightarrow> False", "have \"0 < n (ll - k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n (ll - k)", "using ass"], ["proof (prove)\nusing this:\n  ll - (LEAST d. 0 < n (ll - d)) < l' \\<and> 0 < n l'\n\ngoal (1 subgoal):\n 1. 0 < n (ll - k)", "unfolding ll"], ["proof (prove)\nusing this:\n  l' + k - (LEAST d. 0 < n (l' + k - d)) < l' \\<and> 0 < n l'\n\ngoal (1 subgoal):\n 1. 0 < n (l' + k - k)", "by simp"], ["proof (state)\nthis:\n  0 < n (ll - k)\n\ngoal (1 subgoal):\n 1. \\<not> Suc ll \\<le> l' \\<Longrightarrow> False", "from Least_le[of \"\\<lambda> k. 0 < n (ll - k)\", OF this] kl'"], ["proof (chain)\npicking this:\n  (LEAST x. 0 < n (ll - x)) \\<le> k\n  k < (LEAST d. 0 < n (ll - d))", "show False"], ["proof (prove)\nusing this:\n  (LEAST x. 0 < n (ll - x)) \\<le> k\n  k < (LEAST d. 0 < n (ll - d))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Suc ll \\<le> l'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST i'. ll - (LEAST d. 0 < n (ll - d)) < i' \\<and> 0 < n i') = l\n\ngoal (1 subgoal):\n 1. \\<exists>j'<l. 0 < n j' \\<Longrightarrow>\n    \\<exists>k. inf_concat n k = (j, 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. inf_concat n k = (j, 0)", "unfolding j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. inf_concat n k = (l, 0)", "by (rule exI[of _ \"k + Suc off\"], unfold id ll, simp)"], ["proof (state)\nthis:\n  \\<exists>k. inf_concat n k = (j, 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k. inf_concat n k = (j, 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k. inf_concat n k = (j, 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>j.\n     j < Suc l \\<and> 0 < n j \\<longrightarrow>\n     (\\<exists>k. inf_concat n k = (j, 0))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>j.\n     j < l \\<and> 0 < n j \\<longrightarrow>\n     (\\<exists>k. inf_concat n k = (j, 0))\n\ngoal (1 subgoal):\n 1. \\<exists>k. inf_concat n k = (i, 0)", "}"], ["proof (state)\nthis:\n  \\<forall>j.\n     j < ?l2 \\<and> 0 < n j \\<longrightarrow>\n     (\\<exists>k. inf_concat n k = (j, 0))\n\ngoal (1 subgoal):\n 1. \\<exists>k. inf_concat n k = (i, 0)", "with assms"], ["proof (chain)\npicking this:\n  0 < n i\n  \\<forall>j.\n     j < ?l2 \\<and> 0 < n j \\<longrightarrow>\n     (\\<exists>k. inf_concat n k = (j, 0))", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < n i\n  \\<forall>j.\n     j < ?l2 \\<and> 0 < n j \\<longrightarrow>\n     (\\<exists>k. inf_concat n k = (j, 0))\n\ngoal (1 subgoal):\n 1. \\<exists>k. inf_concat n k = (i, 0)", "by auto"], ["proof (state)\nthis:\n  \\<exists>k. inf_concat n k = (i, 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inf_concat_surj:\n  assumes j: \"j < n i\"\n  shows \"\\<exists>k. inf_concat n k = (i, j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. inf_concat n k = (i, j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k. inf_concat n k = (i, j)", "from j"], ["proof (chain)\npicking this:\n  j < n i", "have \"0 < n i\""], ["proof (prove)\nusing this:\n  j < n i\n\ngoal (1 subgoal):\n 1. 0 < n i", "by auto"], ["proof (state)\nthis:\n  0 < n i\n\ngoal (1 subgoal):\n 1. \\<exists>k. inf_concat n k = (i, j)", "from inf_concat_surj_zero[of n, OF this]"], ["proof (chain)\npicking this:\n  \\<exists>k. inf_concat n k = (i, 0)", "obtain k where \"inf_concat n k = (i,0)\""], ["proof (prove)\nusing this:\n  \\<exists>k. inf_concat n k = (i, 0)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        inf_concat n k = (i, 0) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  inf_concat n k = (i, 0)\n\ngoal (1 subgoal):\n 1. \\<exists>k. inf_concat n k = (i, j)", "from inf_concat_add[OF this, of j] j"], ["proof (chain)\npicking this:\n  0 + j < n i \\<Longrightarrow> inf_concat n (k + j) = (i, 0 + j)\n  j < n i", "show ?thesis"], ["proof (prove)\nusing this:\n  0 + j < n i \\<Longrightarrow> inf_concat n (k + j) = (i, 0 + j)\n  j < n i\n\ngoal (1 subgoal):\n 1. \\<exists>k. inf_concat n k = (i, j)", "by auto"], ["proof (state)\nthis:\n  \\<exists>k. inf_concat n k = (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inf_concat_mono:\n  assumes inf: \"INFM i. n i > 0\"\n    and resk: \"inf_concat n k = (i, j)\"\n    and reskp: \"inf_concat n k' = (i', j')\"\n    and lt: \"i < i'\"\n  shows \"k < k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < k'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. k < k'", "note bounds = inf_concat_bounds[OF inf]"], ["proof (state)\nthis:\n  inf_concat n ?k = (?i, ?j) \\<Longrightarrow> ?j < n ?i\n\ngoal (1 subgoal):\n 1. k < k'", "{"], ["proof (state)\nthis:\n  inf_concat n ?k = (?i, ?j) \\<Longrightarrow> ?j < n ?i\n\ngoal (1 subgoal):\n 1. k < k'", "assume \"k' \\<le> k\""], ["proof (state)\nthis:\n  k' \\<le> k\n\ngoal (1 subgoal):\n 1. k < k'", "hence \"k = k' + (k - k')\""], ["proof (prove)\nusing this:\n  k' \\<le> k\n\ngoal (1 subgoal):\n 1. k = k' + (k - k')", "by auto"], ["proof (state)\nthis:\n  k = k' + (k - k')\n\ngoal (1 subgoal):\n 1. k < k'", "then"], ["proof (chain)\npicking this:\n  k = k' + (k - k')", "obtain l where k: \"k = k' + l\""], ["proof (prove)\nusing this:\n  k = k' + (k - k')\n\ngoal (1 subgoal):\n 1. (\\<And>l. k = k' + l \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  k = k' + l\n\ngoal (1 subgoal):\n 1. k < k'", "have \"i' \\<le> fst (inf_concat n (k' + l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i' \\<le> fst (inf_concat n (k' + l))", "proof (induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. i' \\<le> fst (inf_concat n (k' + 0))\n 2. \\<And>l.\n       i' \\<le> fst (inf_concat n (k' + l)) \\<Longrightarrow>\n       i' \\<le> fst (inf_concat n (k' + Suc l))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. i' \\<le> fst (inf_concat n (k' + 0))\n 2. \\<And>l.\n       i' \\<le> fst (inf_concat n (k' + l)) \\<Longrightarrow>\n       i' \\<le> fst (inf_concat n (k' + Suc l))", "with reskp"], ["proof (chain)\npicking this:\n  inf_concat n k' = (i', j')", "show ?case"], ["proof (prove)\nusing this:\n  inf_concat n k' = (i', j')\n\ngoal (1 subgoal):\n 1. i' \\<le> fst (inf_concat n (k' + 0))", "by auto"], ["proof (state)\nthis:\n  i' \\<le> fst (inf_concat n (k' + 0))\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       i' \\<le> fst (inf_concat n (k' + l)) \\<Longrightarrow>\n       i' \\<le> fst (inf_concat n (k' + Suc l))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       i' \\<le> fst (inf_concat n (k' + l)) \\<Longrightarrow>\n       i' \\<le> fst (inf_concat n (k' + Suc l))", "case (Suc l)"], ["proof (state)\nthis:\n  i' \\<le> fst (inf_concat n (k' + l))\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       i' \\<le> fst (inf_concat n (k' + l)) \\<Longrightarrow>\n       i' \\<le> fst (inf_concat n (k' + Suc l))", "obtain i'' j'' where l: \"inf_concat n (k' + l) = (i'',j'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i'' j''.\n        inf_concat n (k' + l) = (i'', j'') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  inf_concat n (k' + l) = (i'', j'')\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       i' \\<le> fst (inf_concat n (k' + l)) \\<Longrightarrow>\n       i' \\<le> fst (inf_concat n (k' + Suc l))", "with Suc"], ["proof (chain)\npicking this:\n  i' \\<le> fst (inf_concat n (k' + l))\n  inf_concat n (k' + l) = (i'', j'')", "have one: \"i' \\<le> i''\""], ["proof (prove)\nusing this:\n  i' \\<le> fst (inf_concat n (k' + l))\n  inf_concat n (k' + l) = (i'', j'')\n\ngoal (1 subgoal):\n 1. i' \\<le> i''", "by auto"], ["proof (state)\nthis:\n  i' \\<le> i''\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       i' \\<le> fst (inf_concat n (k' + l)) \\<Longrightarrow>\n       i' \\<le> fst (inf_concat n (k' + Suc l))", "from bounds[OF l]"], ["proof (chain)\npicking this:\n  j'' < n i''", "have j'': \"j'' < n i''\""], ["proof (prove)\nusing this:\n  j'' < n i''\n\ngoal (1 subgoal):\n 1. j'' < n i''", "by auto"], ["proof (state)\nthis:\n  j'' < n i''\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       i' \\<le> fst (inf_concat n (k' + l)) \\<Longrightarrow>\n       i' \\<le> fst (inf_concat n (k' + Suc l))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. i' \\<le> fst (inf_concat n (k' + Suc l))", "proof (cases \"Suc j'' < n i''\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc j'' < n i'' \\<Longrightarrow>\n    i' \\<le> fst (inf_concat n (k' + Suc l))\n 2. \\<not> Suc j'' < n i'' \\<Longrightarrow>\n    i' \\<le> fst (inf_concat n (k' + Suc l))", "case True"], ["proof (state)\nthis:\n  Suc j'' < n i''\n\ngoal (2 subgoals):\n 1. Suc j'' < n i'' \\<Longrightarrow>\n    i' \\<le> fst (inf_concat n (k' + Suc l))\n 2. \\<not> Suc j'' < n i'' \\<Longrightarrow>\n    i' \\<le> fst (inf_concat n (k' + Suc l))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. i' \\<le> fst (inf_concat n (k' + Suc l))", "by (simp add: l True one)"], ["proof (state)\nthis:\n  i' \\<le> fst (inf_concat n (k' + Suc l))\n\ngoal (1 subgoal):\n 1. \\<not> Suc j'' < n i'' \\<Longrightarrow>\n    i' \\<le> fst (inf_concat n (k' + Suc l))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Suc j'' < n i'' \\<Longrightarrow>\n    i' \\<le> fst (inf_concat n (k' + Suc l))", "case False"], ["proof (state)\nthis:\n  \\<not> Suc j'' < n i''\n\ngoal (1 subgoal):\n 1. \\<not> Suc j'' < n i'' \\<Longrightarrow>\n    i' \\<le> fst (inf_concat n (k' + Suc l))", "let ?i = \"LEAST i'. i'' < i' \\<and> 0 < n i'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Suc j'' < n i'' \\<Longrightarrow>\n    i' \\<le> fst (inf_concat n (k' + Suc l))", "from inf[unfolded INFM_nat]"], ["proof (chain)\npicking this:\n  \\<forall>m. \\<exists>na>m. 0 < n na", "obtain k where \"i'' < k \\<and> 0 < n k\""], ["proof (prove)\nusing this:\n  \\<forall>m. \\<exists>na>m. 0 < n na\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        i'' < k \\<and> 0 < n k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i'' < k \\<and> 0 < n k\n\ngoal (1 subgoal):\n 1. \\<not> Suc j'' < n i'' \\<Longrightarrow>\n    i' \\<le> fst (inf_concat n (k' + Suc l))", "from LeastI[of \"\\<lambda> k. i'' < k \\<and> 0 < n k\", OF this]"], ["proof (chain)\npicking this:\n  i'' < (LEAST x. i'' < x \\<and> 0 < n x) \\<and>\n  0 < n (LEAST x. i'' < x \\<and> 0 < n x)", "have \"i'' < ?i\""], ["proof (prove)\nusing this:\n  i'' < (LEAST x. i'' < x \\<and> 0 < n x) \\<and>\n  0 < n (LEAST x. i'' < x \\<and> 0 < n x)\n\ngoal (1 subgoal):\n 1. i'' < (LEAST i'. i'' < i' \\<and> 0 < n i')", "by auto"], ["proof (state)\nthis:\n  i'' < (LEAST i'. i'' < i' \\<and> 0 < n i')\n\ngoal (1 subgoal):\n 1. \\<not> Suc j'' < n i'' \\<Longrightarrow>\n    i' \\<le> fst (inf_concat n (k' + Suc l))", "with one"], ["proof (chain)\npicking this:\n  i' \\<le> i''\n  i'' < (LEAST i'. i'' < i' \\<and> 0 < n i')", "show ?thesis"], ["proof (prove)\nusing this:\n  i' \\<le> i''\n  i'' < (LEAST i'. i'' < i' \\<and> 0 < n i')\n\ngoal (1 subgoal):\n 1. i' \\<le> fst (inf_concat n (k' + Suc l))", "by (simp add: l False)"], ["proof (state)\nthis:\n  i' \\<le> fst (inf_concat n (k' + Suc l))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i' \\<le> fst (inf_concat n (k' + Suc l))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i' \\<le> fst (inf_concat n (k' + l))\n\ngoal (1 subgoal):\n 1. k < k'", "with resk k lt"], ["proof (chain)\npicking this:\n  inf_concat n k = (i, j)\n  k = k' + l\n  i < i'\n  i' \\<le> fst (inf_concat n (k' + l))", "have False"], ["proof (prove)\nusing this:\n  inf_concat n k = (i, j)\n  k = k' + l\n  i < i'\n  i' \\<le> fst (inf_concat n (k' + l))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. k < k'", "}"], ["proof (state)\nthis:\n  k' \\<le> k \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. k < k'", "thus ?thesis"], ["proof (prove)\nusing this:\n  k' \\<le> k \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. k < k'", "by arith"], ["proof (state)\nthis:\n  k < k'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inf_concat_Suc:\n  assumes inf: \"INFM i. n i > 0\"\n    and f: \"\\<And> i. f i (n i) = f (Suc i) 0\"\n    and resk: \"inf_concat n k = (i, j)\"\n    and ressk: \"inf_concat n (Suc k) = (i', j')\"\n  shows \"f i' j' = f i (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f i' j' = f i (Suc j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f i' j' = f i (Suc j)", "note bounds = inf_concat_bounds[OF inf]"], ["proof (state)\nthis:\n  inf_concat n ?k = (?i, ?j) \\<Longrightarrow> ?j < n ?i\n\ngoal (1 subgoal):\n 1. f i' j' = f i (Suc j)", "from bounds[OF resk]"], ["proof (chain)\npicking this:\n  j < n i", "have j: \"j < n i\""], ["proof (prove)\nusing this:\n  j < n i\n\ngoal (1 subgoal):\n 1. j < n i", "."], ["proof (state)\nthis:\n  j < n i\n\ngoal (1 subgoal):\n 1. f i' j' = f i (Suc j)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f i' j' = f i (Suc j)", "proof (cases \"Suc j < n i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc j < n i \\<Longrightarrow> f i' j' = f i (Suc j)\n 2. \\<not> Suc j < n i \\<Longrightarrow> f i' j' = f i (Suc j)", "case True"], ["proof (state)\nthis:\n  Suc j < n i\n\ngoal (2 subgoals):\n 1. Suc j < n i \\<Longrightarrow> f i' j' = f i (Suc j)\n 2. \\<not> Suc j < n i \\<Longrightarrow> f i' j' = f i (Suc j)", "with ressk resk"], ["proof (chain)\npicking this:\n  inf_concat n (Suc k) = (i', j')\n  inf_concat n k = (i, j)\n  Suc j < n i", "show ?thesis"], ["proof (prove)\nusing this:\n  inf_concat n (Suc k) = (i', j')\n  inf_concat n k = (i, j)\n  Suc j < n i\n\ngoal (1 subgoal):\n 1. f i' j' = f i (Suc j)", "by simp"], ["proof (state)\nthis:\n  f i' j' = f i (Suc j)\n\ngoal (1 subgoal):\n 1. \\<not> Suc j < n i \\<Longrightarrow> f i' j' = f i (Suc j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Suc j < n i \\<Longrightarrow> f i' j' = f i (Suc j)", "case False"], ["proof (state)\nthis:\n  \\<not> Suc j < n i\n\ngoal (1 subgoal):\n 1. \\<not> Suc j < n i \\<Longrightarrow> f i' j' = f i (Suc j)", "let ?p = \"\\<lambda> i'. i < i' \\<and> 0 < n i'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Suc j < n i \\<Longrightarrow> f i' j' = f i (Suc j)", "let ?i' = \"LEAST i'. ?p i'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Suc j < n i \\<Longrightarrow> f i' j' = f i (Suc j)", "from False j"], ["proof (chain)\npicking this:\n  \\<not> Suc j < n i\n  j < n i", "have id: \"Suc (j + 0) = n i\""], ["proof (prove)\nusing this:\n  \\<not> Suc j < n i\n  j < n i\n\ngoal (1 subgoal):\n 1. Suc (j + 0) = n i", "by auto"], ["proof (state)\nthis:\n  Suc (j + 0) = n i\n\ngoal (1 subgoal):\n 1. \\<not> Suc j < n i \\<Longrightarrow> f i' j' = f i (Suc j)", "from inf_concat_step[OF resk, OF id] ressk"], ["proof (chain)\npicking this:\n  inf_concat n (k + Suc 0) = (LEAST i'. i < i' \\<and> 0 < n i', 0)\n  inf_concat n (Suc k) = (i', j')", "have i': \"i' = ?i'\" and j': \"j' = 0\""], ["proof (prove)\nusing this:\n  inf_concat n (k + Suc 0) = (LEAST i'. i < i' \\<and> 0 < n i', 0)\n  inf_concat n (Suc k) = (i', j')\n\ngoal (1 subgoal):\n 1. i' = (LEAST i'. i < i' \\<and> 0 < n i') &&& j' = 0", "by auto"], ["proof (state)\nthis:\n  i' = (LEAST i'. i < i' \\<and> 0 < n i')\n  j' = 0\n\ngoal (1 subgoal):\n 1. \\<not> Suc j < n i \\<Longrightarrow> f i' j' = f i (Suc j)", "from id"], ["proof (chain)\npicking this:\n  Suc (j + 0) = n i", "have j: \"Suc j = n i\""], ["proof (prove)\nusing this:\n  Suc (j + 0) = n i\n\ngoal (1 subgoal):\n 1. Suc j = n i", "by simp"], ["proof (state)\nthis:\n  Suc j = n i\n\ngoal (1 subgoal):\n 1. \\<not> Suc j < n i \\<Longrightarrow> f i' j' = f i (Suc j)", "from inf[unfolded INFM_nat]"], ["proof (chain)\npicking this:\n  \\<forall>m. \\<exists>na>m. 0 < n na", "obtain k where \"?p k\""], ["proof (prove)\nusing this:\n  \\<forall>m. \\<exists>na>m. 0 < n na\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        i < k \\<and> 0 < n k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < k \\<and> 0 < n k\n\ngoal (1 subgoal):\n 1. \\<not> Suc j < n i \\<Longrightarrow> f i' j' = f i (Suc j)", "from LeastI[of ?p, OF this]"], ["proof (chain)\npicking this:\n  i < (LEAST x. i < x \\<and> 0 < n x) \\<and>\n  0 < n (LEAST x. i < x \\<and> 0 < n x)", "have \"?p ?i'\""], ["proof (prove)\nusing this:\n  i < (LEAST x. i < x \\<and> 0 < n x) \\<and>\n  0 < n (LEAST x. i < x \\<and> 0 < n x)\n\ngoal (1 subgoal):\n 1. i < (LEAST i'. i < i' \\<and> 0 < n i') \\<and>\n    0 < n (LEAST i'. i < i' \\<and> 0 < n i')", "."], ["proof (state)\nthis:\n  i < (LEAST i'. i < i' \\<and> 0 < n i') \\<and>\n  0 < n (LEAST i'. i < i' \\<and> 0 < n i')\n\ngoal (1 subgoal):\n 1. \\<not> Suc j < n i \\<Longrightarrow> f i' j' = f i (Suc j)", "hence \"?i' = Suc i + (?i' - Suc i)\""], ["proof (prove)\nusing this:\n  i < (LEAST i'. i < i' \\<and> 0 < n i') \\<and>\n  0 < n (LEAST i'. i < i' \\<and> 0 < n i')\n\ngoal (1 subgoal):\n 1. (LEAST i'. i < i' \\<and> 0 < n i') =\n    Suc i + ((LEAST i'. i < i' \\<and> 0 < n i') - Suc i)", "by simp"], ["proof (state)\nthis:\n  (LEAST i'. i < i' \\<and> 0 < n i') =\n  Suc i + ((LEAST i'. i < i' \\<and> 0 < n i') - Suc i)\n\ngoal (1 subgoal):\n 1. \\<not> Suc j < n i \\<Longrightarrow> f i' j' = f i (Suc j)", "then"], ["proof (chain)\npicking this:\n  (LEAST i'. i < i' \\<and> 0 < n i') =\n  Suc i + ((LEAST i'. i < i' \\<and> 0 < n i') - Suc i)", "obtain d where ii': \"?i' = Suc i + d\""], ["proof (prove)\nusing this:\n  (LEAST i'. i < i' \\<and> 0 < n i') =\n  Suc i + ((LEAST i'. i < i' \\<and> 0 < n i') - Suc i)\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        (LEAST i'. i < i' \\<and> 0 < n i') = Suc i + d \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (LEAST i'. i < i' \\<and> 0 < n i') = Suc i + d\n\ngoal (1 subgoal):\n 1. \\<not> Suc j < n i \\<Longrightarrow> f i' j' = f i (Suc j)", "from not_less_Least[of _ ?p, unfolded ii']"], ["proof (chain)\npicking this:\n  ?k < Suc i + d \\<Longrightarrow> \\<not> (i < ?k \\<and> 0 < n ?k)", "have d': \"\\<And> d'. d' < d \\<Longrightarrow> n (Suc i + d') = 0\""], ["proof (prove)\nusing this:\n  ?k < Suc i + d \\<Longrightarrow> \\<not> (i < ?k \\<and> 0 < n ?k)\n\ngoal (1 subgoal):\n 1. \\<And>d'. d' < d \\<Longrightarrow> n (Suc i + d') = 0", "by auto"], ["proof (state)\nthis:\n  ?d' < d \\<Longrightarrow> n (Suc i + ?d') = 0\n\ngoal (1 subgoal):\n 1. \\<not> Suc j < n i \\<Longrightarrow> f i' j' = f i (Suc j)", "have \"f (Suc i) 0 = f ?i' 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (Suc i) 0 = f (LEAST i'. i < i' \\<and> 0 < n i') 0", "unfolding ii'"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (Suc i) 0 = f (Suc i + d) 0", "using d'"], ["proof (prove)\nusing this:\n  ?d' < d \\<Longrightarrow> n (Suc i + ?d') = 0\n\ngoal (1 subgoal):\n 1. f (Suc i) 0 = f (Suc i + d) 0", "proof (induct d)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>d'.\n        d' < 0 \\<Longrightarrow> n (Suc i + d') = 0) \\<Longrightarrow>\n    f (Suc i) 0 = f (Suc i + 0) 0\n 2. \\<And>d.\n       \\<lbrakk>(\\<And>d'.\n                    d' < d \\<Longrightarrow>\n                    n (Suc i + d') = 0) \\<Longrightarrow>\n                f (Suc i) 0 = f (Suc i + d) 0;\n        \\<And>d'. d' < Suc d \\<Longrightarrow> n (Suc i + d') = 0\\<rbrakk>\n       \\<Longrightarrow> f (Suc i) 0 = f (Suc i + Suc d) 0", "case 0"], ["proof (state)\nthis:\n  ?d' < 0 \\<Longrightarrow> n (Suc i + ?d') = 0\n\ngoal (2 subgoals):\n 1. (\\<And>d'.\n        d' < 0 \\<Longrightarrow> n (Suc i + d') = 0) \\<Longrightarrow>\n    f (Suc i) 0 = f (Suc i + 0) 0\n 2. \\<And>d.\n       \\<lbrakk>(\\<And>d'.\n                    d' < d \\<Longrightarrow>\n                    n (Suc i + d') = 0) \\<Longrightarrow>\n                f (Suc i) 0 = f (Suc i + d) 0;\n        \\<And>d'. d' < Suc d \\<Longrightarrow> n (Suc i + d') = 0\\<rbrakk>\n       \\<Longrightarrow> f (Suc i) 0 = f (Suc i + Suc d) 0", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (Suc i) 0 = f (Suc i + 0) 0", "by simp"], ["proof (state)\nthis:\n  f (Suc i) 0 = f (Suc i + 0) 0\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>(\\<And>d'.\n                    d' < d \\<Longrightarrow>\n                    n (Suc i + d') = 0) \\<Longrightarrow>\n                f (Suc i) 0 = f (Suc i + d) 0;\n        \\<And>d'. d' < Suc d \\<Longrightarrow> n (Suc i + d') = 0\\<rbrakk>\n       \\<Longrightarrow> f (Suc i) 0 = f (Suc i + Suc d) 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>(\\<And>d'.\n                    d' < d \\<Longrightarrow>\n                    n (Suc i + d') = 0) \\<Longrightarrow>\n                f (Suc i) 0 = f (Suc i + d) 0;\n        \\<And>d'. d' < Suc d \\<Longrightarrow> n (Suc i + d') = 0\\<rbrakk>\n       \\<Longrightarrow> f (Suc i) 0 = f (Suc i + Suc d) 0", "case (Suc d)"], ["proof (state)\nthis:\n  (\\<And>d'. d' < d \\<Longrightarrow> n (Suc i + d') = 0) \\<Longrightarrow>\n  f (Suc i) 0 = f (Suc i + d) 0\n  ?d' < Suc d \\<Longrightarrow> n (Suc i + ?d') = 0\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>(\\<And>d'.\n                    d' < d \\<Longrightarrow>\n                    n (Suc i + d') = 0) \\<Longrightarrow>\n                f (Suc i) 0 = f (Suc i + d) 0;\n        \\<And>d'. d' < Suc d \\<Longrightarrow> n (Suc i + d') = 0\\<rbrakk>\n       \\<Longrightarrow> f (Suc i) 0 = f (Suc i + Suc d) 0", "hence \"f (Suc i) 0 = f (Suc i + d) 0\""], ["proof (prove)\nusing this:\n  (\\<And>d'. d' < d \\<Longrightarrow> n (Suc i + d') = 0) \\<Longrightarrow>\n  f (Suc i) 0 = f (Suc i + d) 0\n  ?d' < Suc d \\<Longrightarrow> n (Suc i + ?d') = 0\n\ngoal (1 subgoal):\n 1. f (Suc i) 0 = f (Suc i + d) 0", "by auto"], ["proof (state)\nthis:\n  f (Suc i) 0 = f (Suc i + d) 0\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>(\\<And>d'.\n                    d' < d \\<Longrightarrow>\n                    n (Suc i + d') = 0) \\<Longrightarrow>\n                f (Suc i) 0 = f (Suc i + d) 0;\n        \\<And>d'. d' < Suc d \\<Longrightarrow> n (Suc i + d') = 0\\<rbrakk>\n       \\<Longrightarrow> f (Suc i) 0 = f (Suc i + Suc d) 0", "also"], ["proof (state)\nthis:\n  f (Suc i) 0 = f (Suc i + d) 0\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>(\\<And>d'.\n                    d' < d \\<Longrightarrow>\n                    n (Suc i + d') = 0) \\<Longrightarrow>\n                f (Suc i) 0 = f (Suc i + d) 0;\n        \\<And>d'. d' < Suc d \\<Longrightarrow> n (Suc i + d') = 0\\<rbrakk>\n       \\<Longrightarrow> f (Suc i) 0 = f (Suc i + Suc d) 0", "have \"... = f (Suc (Suc i + d)) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (Suc i + d) 0 = f (Suc (Suc i + d)) 0", "unfolding f[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (Suc i + d) 0 = f (Suc i + d) (n (Suc i + d))", "using Suc(2)[of d]"], ["proof (prove)\nusing this:\n  d < Suc d \\<Longrightarrow> n (Suc i + d) = 0\n\ngoal (1 subgoal):\n 1. f (Suc i + d) 0 = f (Suc i + d) (n (Suc i + d))", "by simp"], ["proof (state)\nthis:\n  f (Suc i + d) 0 = f (Suc (Suc i + d)) 0\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       \\<lbrakk>(\\<And>d'.\n                    d' < d \\<Longrightarrow>\n                    n (Suc i + d') = 0) \\<Longrightarrow>\n                f (Suc i) 0 = f (Suc i + d) 0;\n        \\<And>d'. d' < Suc d \\<Longrightarrow> n (Suc i + d') = 0\\<rbrakk>\n       \\<Longrightarrow> f (Suc i) 0 = f (Suc i + Suc d) 0", "finally"], ["proof (chain)\npicking this:\n  f (Suc i) 0 = f (Suc (Suc i + d)) 0", "show ?case"], ["proof (prove)\nusing this:\n  f (Suc i) 0 = f (Suc (Suc i + d)) 0\n\ngoal (1 subgoal):\n 1. f (Suc i) 0 = f (Suc i + Suc d) 0", "by simp"], ["proof (state)\nthis:\n  f (Suc i) 0 = f (Suc i + Suc d) 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f (Suc i) 0 = f (LEAST i'. i < i' \\<and> 0 < n i') 0\n\ngoal (1 subgoal):\n 1. \\<not> Suc j < n i \\<Longrightarrow> f i' j' = f i (Suc j)", "thus ?thesis"], ["proof (prove)\nusing this:\n  f (Suc i) 0 = f (LEAST i'. i < i' \\<and> 0 < n i') 0\n\ngoal (1 subgoal):\n 1. f i' j' = f i (Suc j)", "unfolding i' j' j f"], ["proof (prove)\nusing this:\n  f (Suc i) 0 = f (LEAST i'. i < i' \\<and> 0 < n i') 0\n\ngoal (1 subgoal):\n 1. f (LEAST i'. i < i' \\<and> 0 < n i') 0 = f (Suc i) 0", "by simp"], ["proof (state)\nthis:\n  f i' j' = f i (Suc j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f i' j' = f i (Suc j)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}