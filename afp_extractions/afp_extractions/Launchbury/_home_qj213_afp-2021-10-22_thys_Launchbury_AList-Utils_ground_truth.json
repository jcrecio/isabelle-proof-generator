{"file_name": "/home/qj213/afp-2021-10-22/thys/Launchbury/AList-Utils.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Launchbury", "problem_names": ["lemmas restrict_eq = AList.restrict_eq\n  and delete_eq = AList.delete_eq", "lemma restrictA_append: \"restrictA S (a@b) = restrictA S a @ restrictA S b\"", "lemma length_restrictA_le: \"length (restrictA S a) \\<le> length a\"", "lemma domA_append[simp]:\"domA (a @ b) = domA a \\<union> domA b\"\n  and [simp]:\"domA ((v,e) # h) = insert v (domA h)\"\n  and [simp]:\"domA (p # h) = insert (fst p) (domA h)\"\n  and [simp]:\"domA [] = {}\"", "lemma domA_from_set:\n  \"(x, e) \\<in> set h \\<Longrightarrow> x \\<in> domA h\"", "lemma finite_domA[simp]:\n  \"finite (domA \\<Gamma>)\"", "lemma domA_delete[simp]:\n  \"domA (delete x \\<Gamma>) = domA \\<Gamma> - {x}\"", "lemma domA_restrictA[simp]:\n  \"domA (restrictA S \\<Gamma>) = domA \\<Gamma> \\<inter> S\"", "lemma delete_not_domA[simp]:\n  \"x \\<notin> domA \\<Gamma> \\<Longrightarrow>  delete x \\<Gamma> = \\<Gamma>\"", "lemma deleted_not_domA: \"x \\<notin> domA (delete x \\<Gamma>)\"", "lemma dom_map_of_conv_domA:\n  \"dom (map_of \\<Gamma>) = domA \\<Gamma>\"", "lemma domA_map_of_Some_the:\n  \"x \\<in> domA \\<Gamma> \\<Longrightarrow> map_of \\<Gamma> x = Some (the (map_of \\<Gamma> x))\"", "lemma domA_clearjunk[simp]: \"domA (clearjunk \\<Gamma>) = domA \\<Gamma>\"", "lemma the_map_option_domA[simp]: \"x \\<in> domA \\<Gamma> \\<Longrightarrow> the (map_option f (map_of \\<Gamma> x)) = f (the (map_of \\<Gamma> x))\"", "lemma map_of_domAD: \"map_of \\<Gamma> x = Some e \\<Longrightarrow> x \\<in> domA \\<Gamma>\"", "lemma restrictA_noop: \"domA \\<Gamma> \\<subseteq> S \\<Longrightarrow> restrictA S \\<Gamma> = \\<Gamma>\"", "lemma restrictA_cong:\n  \"(\\<And>x. x \\<in> domA m1 \\<Longrightarrow> x \\<in> V \\<longleftrightarrow> x \\<in> V') \\<Longrightarrow> m1 = m2 \\<Longrightarrow> restrictA V m1 = restrictA V' m2\"", "lemma delete_set_none: \"(map_of l)(x := None) = map_of (delete x l)\"", "lemma list_size_delete[simp]: \"size_list size (delete x l) < Suc (size_list size l)\"", "lemma delete_append[simp]: \"delete x (l1 @ l2) = delete x l1 @ delete x l2\"", "lemma map_of_delete_insert:\n  assumes \"map_of \\<Gamma> x = Some e\"\n  shows \"map_of ((x,e) # delete x \\<Gamma>) = map_of \\<Gamma>\"", "lemma map_of_delete_iff[simp]: \"map_of (delete x \\<Gamma>) xa = Some e \\<longleftrightarrow> (map_of \\<Gamma> xa = Some e) \\<and> xa \\<noteq> x\"", "lemma map_add_domA[simp]: \n  \"x \\<in> domA \\<Gamma> \\<Longrightarrow> (map_of \\<Delta> ++ map_of \\<Gamma>) x = map_of \\<Gamma> x\"\n  \"x \\<notin> domA \\<Gamma> \\<Longrightarrow> (map_of \\<Delta> ++ map_of \\<Gamma>) x = map_of \\<Delta> x\"", "lemma set_delete_subset: \"set (delete k al) \\<subseteq> set al\"", "lemma dom_delete_subset: \"snd ` set (delete k al) \\<subseteq> snd ` set al\"", "lemma map_ran_cong[fundef_cong]:\n  \"\\<lbrakk> \\<And> x . x \\<in> set m1 \\<Longrightarrow> f1 (fst x) (snd x) = f2 (fst x) (snd x) ; m1 = m2 \\<rbrakk>\n      \\<Longrightarrow> map_ran f1 m1 = map_ran f2 m2\"", "lemma domA_map_ran[simp]: \"domA (map_ran f m) = domA m\"", "lemma map_ran_delete:\n  \"map_ran f (delete x \\<Gamma>) = delete x (map_ran f \\<Gamma>)\"", "lemma map_ran_restrictA:\n  \"map_ran f (restrictA V \\<Gamma>) = restrictA V (map_ran f \\<Gamma>)\"", "lemma map_ran_append:\n  \"map_ran f (\\<Gamma>@\\<Delta>) = map_ran f \\<Gamma> @ map_ran f \\<Delta>\"", "lemma mapCollect_empty[simp]: \"{f k v | k \\<mapsto> v \\<in> Map.empty} = {}\"", "lemma mapCollect_const[simp]:\n  \"m \\<noteq> Map.empty \\<Longrightarrow> {e | k\\<mapsto>v\\<in>m} = {e}\"", "lemma mapCollect_cong[fundef_cong]:\n  \"(\\<And> k v. m1 k = Some v \\<Longrightarrow> f1 k v = f2 k v) \\<Longrightarrow> m1 = m2 \\<Longrightarrow> mapCollect f1 m1 = mapCollect f2 m2\"", "lemma mapCollectE[elim!]:\n  assumes \"x \\<in> {f k v | k \\<mapsto> v \\<in> m}\"\n  obtains k v where \"m k = Some v\" and \"x = f k v\"", "lemma mapCollectI[intro]:\n  assumes  \"m k = Some v\"\n  shows \"f k v \\<in> {f k v | k \\<mapsto> v \\<in> m}\"", "lemma ball_mapCollect[simp]:\n  \"(\\<forall> x \\<in> {f k v | k \\<mapsto> v \\<in> m}. P x) \\<longleftrightarrow> (\\<forall> k v. m k = Some v \\<longrightarrow> P (f k v))\"", "lemma image_mapCollect[simp]: \n  \"g ` {f k v | k \\<mapsto> v \\<in> m} = { g (f k v) | k \\<mapsto> v \\<in> m}\"", "lemma mapCollect_map_upd[simp]:\n  \"mapCollect f (m(k\\<mapsto>v)) = insert (f k v) (mapCollect f (m(k := None)))\"", "lemma mapCollectFilter_const_False[simp]:\n  \"{e | k\\<mapsto>v \\<in> m . False } = {}\"", "lemma mapCollectFilter_const_True[simp]:\n  \"{e | k\\<mapsto>v \\<in> m . True } = {e | k\\<mapsto>v \\<in> m}\""], "translations": [["", "lemmas restrict_eq = AList.restrict_eq\n  and delete_eq = AList.delete_eq"], ["", "lemma restrictA_append: \"restrictA S (a@b) = restrictA S a @ restrictA S b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrictA S (a @ b) = restrictA S a @ restrictA S b", "unfolding restrict_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>(k, v). k \\<in> S) (a @ b) =\n    filter (\\<lambda>(k, v). k \\<in> S) a @\n    filter (\\<lambda>(k, v). k \\<in> S) b", "by (rule filter_append)"], ["", "lemma length_restrictA_le: \"length (restrictA S a) \\<le> length a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (restrictA S a) \\<le> length a", "by (metis length_filter_le restrict_eq)"], ["", "subsubsection \\<open>The domain of an associative list\\<close>"], ["", "definition domA\n  where \"domA h = fst ` set h\""], ["", "lemma domA_append[simp]:\"domA (a @ b) = domA a \\<union> domA b\"\n  and [simp]:\"domA ((v,e) # h) = insert v (domA h)\"\n  and [simp]:\"domA (p # h) = insert (fst p) (domA h)\"\n  and [simp]:\"domA [] = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (domA (a @ b) = domA a \\<union> domA b &&&\n     domA ((v, e) # h) = insert v (domA h)) &&&\n    domA (p # h) = insert (fst p) (domA h) &&& domA [] = {}", "by (auto simp add: domA_def)"], ["", "lemma domA_from_set:\n  \"(x, e) \\<in> set h \\<Longrightarrow> x \\<in> domA h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, e) \\<in> set h \\<Longrightarrow> x \\<in> domA h", "by (induct h, auto)"], ["", "lemma finite_domA[simp]:\n  \"finite (domA \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (domA \\<Gamma>)", "by (auto simp add: domA_def)"], ["", "lemma domA_delete[simp]:\n  \"domA (delete x \\<Gamma>) = domA \\<Gamma> - {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domA (delete x \\<Gamma>) = domA \\<Gamma> - {x}", "by (induct \\<Gamma>) auto"], ["", "lemma domA_restrictA[simp]:\n  \"domA (restrictA S \\<Gamma>) = domA \\<Gamma> \\<inter> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domA (restrictA S \\<Gamma>) = domA \\<Gamma> \\<inter> S", "by (induct \\<Gamma>) auto"], ["", "lemma delete_not_domA[simp]:\n  \"x \\<notin> domA \\<Gamma> \\<Longrightarrow>  delete x \\<Gamma> = \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> domA \\<Gamma> \\<Longrightarrow> delete x \\<Gamma> = \\<Gamma>", "by (induct \\<Gamma>) auto"], ["", "lemma deleted_not_domA: \"x \\<notin> domA (delete x \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> domA (delete x \\<Gamma>)", "by (induct \\<Gamma>) auto"], ["", "lemma dom_map_of_conv_domA:\n  \"dom (map_of \\<Gamma>) = domA \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (map_of \\<Gamma>) = domA \\<Gamma>", "by (induct \\<Gamma>) (auto simp add: dom_if)"], ["", "lemma domA_map_of_Some_the:\n  \"x \\<in> domA \\<Gamma> \\<Longrightarrow> map_of \\<Gamma> x = Some (the (map_of \\<Gamma> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> domA \\<Gamma> \\<Longrightarrow>\n    map_of \\<Gamma> x = Some (the (map_of \\<Gamma> x))", "by (induct \\<Gamma>) (auto simp add: dom_if)"], ["", "lemma domA_clearjunk[simp]: \"domA (clearjunk \\<Gamma>) = domA \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domA (clearjunk \\<Gamma>) = domA \\<Gamma>", "unfolding domA_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set (clearjunk \\<Gamma>) = fst ` set \\<Gamma>", "using dom_clearjunk"], ["proof (prove)\nusing this:\n  fst ` set (clearjunk ?al) = fst ` set ?al\n\ngoal (1 subgoal):\n 1. fst ` set (clearjunk \\<Gamma>) = fst ` set \\<Gamma>", "."], ["", "lemma the_map_option_domA[simp]: \"x \\<in> domA \\<Gamma> \\<Longrightarrow> the (map_option f (map_of \\<Gamma> x)) = f (the (map_of \\<Gamma> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> domA \\<Gamma> \\<Longrightarrow>\n    the (map_option f (map_of \\<Gamma> x)) = f (the (map_of \\<Gamma> x))", "by (induction \\<Gamma>) auto"], ["", "lemma map_of_domAD: \"map_of \\<Gamma> x = Some e \\<Longrightarrow> x \\<in> domA \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of \\<Gamma> x = Some e \\<Longrightarrow> x \\<in> domA \\<Gamma>", "using dom_map_of_conv_domA"], ["proof (prove)\nusing this:\n  dom (map_of ?\\<Gamma>) = domA ?\\<Gamma>\n\ngoal (1 subgoal):\n 1. map_of \\<Gamma> x = Some e \\<Longrightarrow> x \\<in> domA \\<Gamma>", "by fastforce"], ["", "lemma restrictA_noop: \"domA \\<Gamma> \\<subseteq> S \\<Longrightarrow> restrictA S \\<Gamma> = \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domA \\<Gamma> \\<subseteq> S \\<Longrightarrow>\n    restrictA S \\<Gamma> = \\<Gamma>", "unfolding restrict_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. domA \\<Gamma> \\<subseteq> S \\<Longrightarrow>\n    filter (\\<lambda>(k, v). k \\<in> S) \\<Gamma> = \\<Gamma>", "by (induction \\<Gamma>) auto"], ["", "lemma restrictA_cong:\n  \"(\\<And>x. x \\<in> domA m1 \\<Longrightarrow> x \\<in> V \\<longleftrightarrow> x \\<in> V') \\<Longrightarrow> m1 = m2 \\<Longrightarrow> restrictA V m1 = restrictA V' m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                x \\<in> domA m1 \\<Longrightarrow>\n                (x \\<in> V) = (x \\<in> V');\n     m1 = m2\\<rbrakk>\n    \\<Longrightarrow> restrictA V m1 = restrictA V' m2", "unfolding restrict_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                x \\<in> domA m1 \\<Longrightarrow>\n                (x \\<in> V) = (x \\<in> V');\n     m1 = m2\\<rbrakk>\n    \\<Longrightarrow> filter (\\<lambda>(k, v). k \\<in> V) m1 =\n                      filter (\\<lambda>(k, v). k \\<in> V') m2", "by (induction m1 arbitrary: m2) auto"], ["", "subsubsection \\<open>Other lemmas about associative lists\\<close>"], ["", "lemma delete_set_none: \"(map_of l)(x := None) = map_of (delete x l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_of l)(x := None) = map_of (delete x l)", "proof (induct l)"], ["proof (state)\ngoal (2 subgoals):\n 1. (map_of [])(x := None) = map_of (delete x [])\n 2. \\<And>a l.\n       (map_of l)(x := None) = map_of (delete x l) \\<Longrightarrow>\n       (map_of (a # l))(x := None) = map_of (delete x (a # l))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (map_of [])(x := None) = map_of (delete x [])\n 2. \\<And>a l.\n       (map_of l)(x := None) = map_of (delete x l) \\<Longrightarrow>\n       (map_of (a # l))(x := None) = map_of (delete x (a # l))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_of [])(x := None) = map_of (delete x [])", "by simp"], ["proof (state)\nthis:\n  (map_of [])(x := None) = map_of (delete x [])\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       (map_of l)(x := None) = map_of (delete x l) \\<Longrightarrow>\n       (map_of (a # l))(x := None) = map_of (delete x (a # l))", "case (Cons l ls)"], ["proof (state)\nthis:\n  (map_of ls)(x := None) = map_of (delete x ls)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       (map_of l)(x := None) = map_of (delete x l) \\<Longrightarrow>\n       (map_of (a # l))(x := None) = map_of (delete x (a # l))", "from this[symmetric]"], ["proof (chain)\npicking this:\n  map_of (delete x ls) = (map_of ls)(x := None)", "show ?case"], ["proof (prove)\nusing this:\n  map_of (delete x ls) = (map_of ls)(x := None)\n\ngoal (1 subgoal):\n 1. (map_of (l # ls))(x := None) = map_of (delete x (l # ls))", "by (cases \"fst l = x\") auto"], ["proof (state)\nthis:\n  (map_of (l # ls))(x := None) = map_of (delete x (l # ls))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_size_delete[simp]: \"size_list size (delete x l) < Suc (size_list size l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size_list size (delete x l) < Suc (size_list size l)", "by (induct l) auto"], ["", "lemma delete_append[simp]: \"delete x (l1 @ l2) = delete x l1 @ delete x l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete x (l1 @ l2) = delete x l1 @ delete x l2", "unfolding AList.delete_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>(k', uu_). x \\<noteq> k') (l1 @ l2) =\n    filter (\\<lambda>(k', uu_). x \\<noteq> k') l1 @\n    filter (\\<lambda>(k', uu_). x \\<noteq> k') l2", "by simp"], ["", "lemma map_of_delete_insert:\n  assumes \"map_of \\<Gamma> x = Some e\"\n  shows \"map_of ((x,e) # delete x \\<Gamma>) = map_of \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of ((x, e) # delete x \\<Gamma>) = map_of \\<Gamma>", "using assms"], ["proof (prove)\nusing this:\n  map_of \\<Gamma> x = Some e\n\ngoal (1 subgoal):\n 1. map_of ((x, e) # delete x \\<Gamma>) = map_of \\<Gamma>", "by (induct \\<Gamma>) (auto split:prod.split)"], ["", "lemma map_of_delete_iff[simp]: \"map_of (delete x \\<Gamma>) xa = Some e \\<longleftrightarrow> (map_of \\<Gamma> xa = Some e) \\<and> xa \\<noteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_of (delete x \\<Gamma>) xa = Some e) =\n    (map_of \\<Gamma> xa = Some e \\<and> xa \\<noteq> x)", "by (metis delete_conv fun_upd_same map_of_delete option.distinct(1))"], ["", "lemma map_add_domA[simp]: \n  \"x \\<in> domA \\<Gamma> \\<Longrightarrow> (map_of \\<Delta> ++ map_of \\<Gamma>) x = map_of \\<Gamma> x\"\n  \"x \\<notin> domA \\<Gamma> \\<Longrightarrow> (map_of \\<Delta> ++ map_of \\<Gamma>) x = map_of \\<Delta> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> domA \\<Gamma> \\<Longrightarrow>\n     (map_of \\<Delta> ++ map_of \\<Gamma>) x = map_of \\<Gamma> x) &&&\n    (x \\<notin> domA \\<Gamma> \\<Longrightarrow>\n     (map_of \\<Delta> ++ map_of \\<Gamma>) x = map_of \\<Delta> x)", "apply (metis dom_map_of_conv_domA map_add_dom_app_simps(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> domA \\<Gamma> \\<Longrightarrow>\n    (map_of \\<Delta> ++ map_of \\<Gamma>) x = map_of \\<Delta> x", "apply (metis dom_map_of_conv_domA map_add_dom_app_simps(3))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_delete_subset: \"set (delete k al) \\<subseteq> set al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (delete k al) \\<subseteq> set al", "by (auto simp add: delete_eq)"], ["", "lemma dom_delete_subset: \"snd ` set (delete k al) \\<subseteq> snd ` set al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` set (delete k al) \\<subseteq> snd ` set al", "by (auto simp add: delete_eq)"], ["", "(*\nlemma ran_map_cong[fundef_cong]:\n  \"\\<lbrakk> list_all2 (\\<lambda> x y. fst x = fst y \\<and> f1 (fst x) (snd x) = f2 (fst y) (snd y)) m1 m2 \\<rbrakk>\n      \\<Longrightarrow> map_ran f1 m1 = map_ran f2 m2\"    \n  by (induction rule: list_all2_induct) auto\n*)"], ["", "lemma map_ran_cong[fundef_cong]:\n  \"\\<lbrakk> \\<And> x . x \\<in> set m1 \\<Longrightarrow> f1 (fst x) (snd x) = f2 (fst x) (snd x) ; m1 = m2 \\<rbrakk>\n      \\<Longrightarrow> map_ran f1 m1 = map_ran f2 m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                x \\<in> set m1 \\<Longrightarrow>\n                f1 (fst x) (snd x) = f2 (fst x) (snd x);\n     m1 = m2\\<rbrakk>\n    \\<Longrightarrow> map_ran f1 m1 = map_ran f2 m2", "by (induction m1 arbitrary: m2) auto"], ["", "lemma domA_map_ran[simp]: \"domA (map_ran f m) = domA m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domA (map_ran f m) = domA m", "unfolding domA_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set (map_ran f m) = fst ` set m", "by (rule dom_map_ran)"], ["", "lemma map_ran_delete:\n  \"map_ran f (delete x \\<Gamma>) = delete x (map_ran f \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_ran f (delete x \\<Gamma>) = delete x (map_ran f \\<Gamma>)", "by (induction \\<Gamma>)  auto"], ["", "lemma map_ran_restrictA:\n  \"map_ran f (restrictA V \\<Gamma>) = restrictA V (map_ran f \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_ran f (restrictA V \\<Gamma>) = restrictA V (map_ran f \\<Gamma>)", "by (induction \\<Gamma>)  auto"], ["", "lemma map_ran_append:\n  \"map_ran f (\\<Gamma>@\\<Delta>) = map_ran f \\<Gamma> @ map_ran f \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_ran f (\\<Gamma> @ \\<Delta>) =\n    map_ran f \\<Gamma> @ map_ran f \\<Delta>", "by (induction \\<Gamma>)  auto"], ["", "subsubsection \\<open>Syntax for map comprehensions\\<close>"], ["", "definition mapCollect :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'c) \\<Rightarrow> ('a \\<rightharpoonup> 'b) \\<Rightarrow> 'c set\"\n  where \"mapCollect f m = {f k v | k v . m k = Some v}\""], ["", "syntax\n \"_MapCollect\" :: \"'c \\<Rightarrow> pttrn => pttrn \\<Rightarrow> 'a \\<rightharpoonup> 'b => 'c set\"    (\"(1{_ |/_/\\<mapsto>/_/\\<in>/_/})\")"], ["", "translations\n  \"{e | k\\<mapsto>v \\<in> m}\" == \"CONST mapCollect (\\<lambda>k v. e) m\""], ["", "lemma mapCollect_empty[simp]: \"{f k v | k \\<mapsto> v \\<in> Map.empty} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mapCollect f Map.empty = {}", "unfolding mapCollect_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {f k v |k v. None = Some v} = {}", "by simp"], ["", "lemma mapCollect_const[simp]:\n  \"m \\<noteq> Map.empty \\<Longrightarrow> {e | k\\<mapsto>v\\<in>m} = {e}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> Map.empty \\<Longrightarrow> {e |k\\<mapsto>v\\<in>m} = {e}", "unfolding mapCollect_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> Map.empty \\<Longrightarrow>\n    {uu_. \\<exists>k v. uu_ = e \\<and> m k = Some v} = {e}", "by auto"], ["", "lemma mapCollect_cong[fundef_cong]:\n  \"(\\<And> k v. m1 k = Some v \\<Longrightarrow> f1 k v = f2 k v) \\<Longrightarrow> m1 = m2 \\<Longrightarrow> mapCollect f1 m1 = mapCollect f2 m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k v. m1 k = Some v \\<Longrightarrow> f1 k v = f2 k v;\n     m1 = m2\\<rbrakk>\n    \\<Longrightarrow> mapCollect f1 m1 = mapCollect f2 m2", "unfolding mapCollect_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k v. m1 k = Some v \\<Longrightarrow> f1 k v = f2 k v;\n     m1 = m2\\<rbrakk>\n    \\<Longrightarrow> {f1 k v |k v. m1 k = Some v} =\n                      {f2 k v |k v. m2 k = Some v}", "by force"], ["", "lemma mapCollectE[elim!]:\n  assumes \"x \\<in> {f k v | k \\<mapsto> v \\<in> m}\"\n  obtains k v where \"m k = Some v\" and \"x = f k v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k v.\n        \\<lbrakk>m k = Some v; x = f k v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> mapCollect f m\n\ngoal (1 subgoal):\n 1. (\\<And>k v.\n        \\<lbrakk>m k = Some v; x = f k v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: mapCollect_def)"], ["", "lemma mapCollectI[intro]:\n  assumes  \"m k = Some v\"\n  shows \"f k v \\<in> {f k v | k \\<mapsto> v \\<in> m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f k v \\<in> mapCollect f m", "using assms"], ["proof (prove)\nusing this:\n  m k = Some v\n\ngoal (1 subgoal):\n 1. f k v \\<in> mapCollect f m", "by (auto simp add: mapCollect_def)"], ["", "lemma ball_mapCollect[simp]:\n  \"(\\<forall> x \\<in> {f k v | k \\<mapsto> v \\<in> m}. P x) \\<longleftrightarrow> (\\<forall> k v. m k = Some v \\<longrightarrow> P (f k v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>mapCollect f m. P x) =\n    (\\<forall>k v. m k = Some v \\<longrightarrow> P (f k v))", "by (auto simp add: mapCollect_def)"], ["", "lemma image_mapCollect[simp]: \n  \"g ` {f k v | k \\<mapsto> v \\<in> m} = { g (f k v) | k \\<mapsto> v \\<in> m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g ` mapCollect f m = {g (f k v) |k\\<mapsto>v\\<in>m}", "by (auto simp add: mapCollect_def)"], ["", "lemma mapCollect_map_upd[simp]:\n  \"mapCollect f (m(k\\<mapsto>v)) = insert (f k v) (mapCollect f (m(k := None)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mapCollect f (m(k \\<mapsto> v)) =\n    insert (f k v) (mapCollect f (m(k := None)))", "unfolding mapCollect_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {f ka va |ka va. (m(k \\<mapsto> v)) ka = Some va} =\n    insert (f k v) {f ka v |ka v. (m(k := None)) ka = Some v}", "by auto"], ["", "definition mapCollectFilter :: \"('a \\<Rightarrow> 'b \\<Rightarrow> (bool \\<times> 'c)) \\<Rightarrow> ('a \\<rightharpoonup> 'b) \\<Rightarrow> 'c set\"\n  where \"mapCollectFilter f m = {snd (f k v) | k v . m k = Some v \\<and> fst (f k v)}\""], ["", "syntax\n \"_MapCollectFilter\" :: \"'c \\<Rightarrow> pttrn \\<Rightarrow> pttrn \\<Rightarrow> ('a \\<rightharpoonup> 'b) \\<Rightarrow> bool \\<Rightarrow> 'c set\"    (\"(1{_ |/_/\\<mapsto>/_/\\<in>/_/./ _})\")"], ["", "translations\n  \"{e | k\\<mapsto>v \\<in> m . P }\" == \"CONST mapCollectFilter (\\<lambda>k v. (P,e)) m\""], ["", "lemma mapCollectFilter_const_False[simp]:\n  \"{e | k\\<mapsto>v \\<in> m . False } = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {e |k\\<mapsto>v\\<in>m. False} = {}", "unfolding mapCollect_def mapCollectFilter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>k v.\n        uu_ = snd (False, e) \\<and> m k = Some v \\<and> fst (False, e)} =\n    {}", "by simp"], ["", "lemma mapCollectFilter_const_True[simp]:\n  \"{e | k\\<mapsto>v \\<in> m . True } = {e | k\\<mapsto>v \\<in> m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {e |k\\<mapsto>v\\<in>m. True} = {e |k\\<mapsto>v\\<in>m}", "unfolding mapCollect_def mapCollectFilter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>k v.\n        uu_ = snd (True, e) \\<and> m k = Some v \\<and> fst (True, e)} =\n    {uu_. \\<exists>k v. uu_ = e \\<and> m k = Some v}", "by simp"], ["", "end"]]}