{"file_name": "/home/qj213/afp-2021-10-22/thys/Launchbury/HOLCF-Utils.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Launchbury", "problem_names": ["lemmas cont_fun[simp]", "lemmas cont2cont_fun[simp]", "lemma cont_compose2:\n  assumes \"\\<And> y. cont (\\<lambda> x. c x y)\"\n  assumes \"\\<And> x. cont (\\<lambda> y. c x y)\"\n  assumes \"cont f\"\n  assumes \"cont g\"\n  shows \"cont (\\<lambda>x. c (f x) (g x))\"", "lemma pointwise_adm:\n  fixes P :: \"'a::pcpo \\<Rightarrow> 'b::pcpo \\<Rightarrow> bool\"\n  assumes \"adm (\\<lambda> x. P (fst x) (snd x))\"\n  shows \"adm (\\<lambda> m. pointwise P (fst m) (snd m))\"", "lemma cfun_beta_Pair:\n  assumes \"cont (\\<lambda> p. f (fst p) (snd p))\"\n  shows \"csplit\\<cdot>(\\<Lambda> a b . f a b)\\<cdot>(x, y) = f x y\"", "lemma fun_upd_mono:\n  \"\\<rho>1 \\<sqsubseteq> \\<rho>2 \\<Longrightarrow> v1 \\<sqsubseteq> v2 \\<Longrightarrow> \\<rho>1(x := v1) \\<sqsubseteq> \\<rho>2(x := v2)\"", "lemma fun_upd_cont[simp,cont2cont]:\n  assumes \"cont f\" and \"cont h\"\n  shows \"cont (\\<lambda> x. (f x)(v := h x) :: 'a \\<Rightarrow> 'b::pcpo)\"", "lemma fun_upd_belowI:\n  assumes \"\\<And> z . z \\<noteq> x \\<Longrightarrow> \\<rho> z \\<sqsubseteq> \\<rho>' z\" \n  assumes \"y \\<sqsubseteq> \\<rho>' x\"\n  shows  \"\\<rho>(x := y) \\<sqsubseteq> \\<rho>'\"", "lemma cont_if_else_above: \n  assumes \"cont f\"\n  assumes \"cont g\"\n  assumes \"\\<And> x. f x \\<sqsubseteq> g x\"\n  assumes \"\\<And> x y. x \\<sqsubseteq> y \\<Longrightarrow> P y \\<Longrightarrow> P x\"\n  assumes \"adm P\"\n  shows \"cont (\\<lambda>x. if P x then f x else g x)\" (is \"cont ?I\")", "lemma up2option_simps[simp]:\n  \"up2option \\<bottom> = None\"\n  \"up2option (up\\<cdot>x) = Some x\"", "lemma option2up_up2option[simp]:\n  \"option2up (up2option x) = x\"", "lemma up2option_option2up[simp]:\n  \"up2option (option2up x) = x\"", "lemma adm_subst2: \"cont f \\<Longrightarrow> cont g \\<Longrightarrow> adm (\\<lambda>x. f (fst x) = g (snd x))\"", "lemma cont2cont_comp [simp, cont2cont]:\n  assumes \"cont f\"\n  assumes \"\\<And> x. cont (f x)\"\n  assumes \"cont g\"\n  shows \"cont (\\<lambda> x. (f x) \\<circ> (g x))\"", "lemma [simp]: \"cfun_comp\\<cdot>f\\<cdot>(\\<rho>(x := v)) = (cfun_comp\\<cdot>f\\<cdot>\\<rho>)(x := f\\<cdot>v)\"", "lemma cfun_comp_app[simp]: \"(cfun_comp\\<cdot>f\\<cdot>\\<rho>) x = f\\<cdot>(\\<rho> x)\"", "lemma fix_eq_fix:\n  \"f\\<cdot>(fix\\<cdot>g) \\<sqsubseteq> fix\\<cdot>g \\<Longrightarrow> g\\<cdot>(fix\\<cdot>f) \\<sqsubseteq> fix\\<cdot>f \\<Longrightarrow> fix\\<cdot>f = fix\\<cdot>g\"", "lemma below_trans_cong[trans]:\n  \"a \\<sqsubseteq> f x \\<Longrightarrow> x \\<sqsubseteq> y \\<Longrightarrow> cont f \\<Longrightarrow> a \\<sqsubseteq> f y \"", "lemma not_bot_below_trans[trans]:\n  \"a \\<noteq> \\<bottom> \\<Longrightarrow> a \\<sqsubseteq> b \\<Longrightarrow> b \\<noteq> \\<bottom>\"", "lemma not_bot_below_trans_cong[trans]:\n  \"f a \\<noteq> \\<bottom> \\<Longrightarrow> a \\<sqsubseteq> b \\<Longrightarrow> cont f \\<Longrightarrow> f b \\<noteq> \\<bottom>\""], "translations": [["", "lemmas cont_fun[simp]"], ["", "lemmas cont2cont_fun[simp]"], ["", "lemma cont_compose2:\n  assumes \"\\<And> y. cont (\\<lambda> x. c x y)\"\n  assumes \"\\<And> x. cont (\\<lambda> y. c x y)\"\n  assumes \"cont f\"\n  assumes \"cont g\"\n  shows \"cont (\\<lambda>x. c (f x) (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. c (f x) (g x))", "by (intro cont_apply[OF assms(4) assms(2)]\n            cont2cont_fun[OF cont_compose[OF _ assms(3)]]\n            cont2cont_lambda[OF assms(1)])"], ["", "lemma pointwise_adm:\n  fixes P :: \"'a::pcpo \\<Rightarrow> 'b::pcpo \\<Rightarrow> bool\"\n  assumes \"adm (\\<lambda> x. P (fst x) (snd x))\"\n  shows \"adm (\\<lambda> m. pointwise P (fst m) (snd m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adm (\\<lambda>m. pointwise P (fst m) (snd m))", "proof (rule admI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y;\n        \\<forall>i. pointwise P (fst (Y i)) (snd (Y i))\\<rbrakk>\n       \\<Longrightarrow> pointwise P (fst (\\<Squnion>i. Y i))\n                          (snd (\\<Squnion>i. Y i))", "case prems: (1 Y)"], ["proof (state)\nthis:\n  chain Y\n  \\<forall>i. pointwise P (fst (Y i)) (snd (Y i))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y;\n        \\<forall>i. pointwise P (fst (Y i)) (snd (Y i))\\<rbrakk>\n       \\<Longrightarrow> pointwise P (fst (\\<Squnion>i. Y i))\n                          (snd (\\<Squnion>i. Y i))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. pointwise P (fst (\\<Squnion>i. Y i)) (snd (\\<Squnion>i. Y i))", "apply (rule pointwiseI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. P (fst (\\<Squnion>i. Y i) x) (snd (\\<Squnion>i. Y i) x)", "apply (rule admD[OF adm_subst[where t = \"\\<lambda>p . (fst p x, snd p x)\" for x, OF _ assms, simplified] \\<open>chain Y\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x i. P (fst (Y i) x) (snd (Y i) x)", "using prems(2)"], ["proof (prove)\nusing this:\n  \\<forall>i. pointwise P (fst (Y i)) (snd (Y i))\n\ngoal (1 subgoal):\n 1. \\<And>x i. P (fst (Y i) x) (snd (Y i) x)", "unfolding pointwise_def"], ["proof (prove)\nusing this:\n  \\<forall>i x. P (fst (Y i) x) (snd (Y i) x)\n\ngoal (1 subgoal):\n 1. \\<And>x i. P (fst (Y i) x) (snd (Y i) x)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  pointwise P (fst (\\<Squnion>i. Y i)) (snd (\\<Squnion>i. Y i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cfun_beta_Pair:\n  assumes \"cont (\\<lambda> p. f (fst p) (snd p))\"\n  shows \"csplit\\<cdot>(\\<Lambda> a b . f a b)\\<cdot>(x, y) = f x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> (a, b). f a b)\\<cdot>(x, y) = f x y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> a. Abs_cfun (f a))\\<cdot>x\\<cdot>y = f x y", "apply (subst beta_cfun)"], ["proof (prove)\ngoal (2 subgoals):\n 1. cont (\\<lambda>a. Abs_cfun (f a))\n 2. Abs_cfun (f x)\\<cdot>y = f x y", "apply (rule cont2cont_LAM')"], ["proof (prove)\ngoal (2 subgoals):\n 1. cont (\\<lambda>p. f (fst p) (snd p))\n 2. Abs_cfun (f x)\\<cdot>y = f x y", "apply (rule assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_cfun (f x)\\<cdot>y = f x y", "apply (rule beta_cfun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (f x)", "apply (rule cont2cont_fun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>a b. f b a)", "using assms"], ["proof (prove)\nusing this:\n  cont (\\<lambda>p. f (fst p) (snd p))\n\ngoal (1 subgoal):\n 1. cont (\\<lambda>a b. f b a)", "unfolding prod_cont_iff"], ["proof (prove)\nusing this:\n  (\\<forall>y. cont (\\<lambda>x. f (fst (x, y)) (snd (x, y)))) \\<and>\n  (\\<forall>x. cont (\\<lambda>y. f (fst (x, y)) (snd (x, y))))\n\ngoal (1 subgoal):\n 1. cont (\\<lambda>a b. f b a)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fun_upd_mono:\n  \"\\<rho>1 \\<sqsubseteq> \\<rho>2 \\<Longrightarrow> v1 \\<sqsubseteq> v2 \\<Longrightarrow> \\<rho>1(x := v1) \\<sqsubseteq> \\<rho>2(x := v2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<rho>1 \\<sqsubseteq> \\<rho>2; v1 \\<sqsubseteq> v2\\<rbrakk>\n    \\<Longrightarrow> \\<rho>1(x := v1) \\<sqsubseteq> \\<rho>2(x := v2)", "apply (rule fun_belowI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<rho>1 \\<sqsubseteq> \\<rho>2; v1 \\<sqsubseteq> v2\\<rbrakk>\n       \\<Longrightarrow> (\\<rho>1(x := v1)) xa \\<sqsubseteq>\n                         (\\<rho>2(x := v2)) xa", "apply (case_tac \"xa = x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>\\<rho>1 \\<sqsubseteq> \\<rho>2; v1 \\<sqsubseteq> v2;\n        xa = x\\<rbrakk>\n       \\<Longrightarrow> (\\<rho>1(x := v1)) xa \\<sqsubseteq>\n                         (\\<rho>2(x := v2)) xa\n 2. \\<And>xa.\n       \\<lbrakk>\\<rho>1 \\<sqsubseteq> \\<rho>2; v1 \\<sqsubseteq> v2;\n        xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> (\\<rho>1(x := v1)) xa \\<sqsubseteq>\n                         (\\<rho>2(x := v2)) xa", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<rho>1 \\<sqsubseteq> \\<rho>2; v1 \\<sqsubseteq> v2;\n        xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> (\\<rho>1(x := v1)) xa \\<sqsubseteq>\n                         (\\<rho>2(x := v2)) xa", "apply (auto elim:fun_belowD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fun_upd_cont[simp,cont2cont]:\n  assumes \"cont f\" and \"cont h\"\n  shows \"cont (\\<lambda> x. (f x)(v := h x) :: 'a \\<Rightarrow> 'b::pcpo)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. (f x)(v := h x))", "by (rule cont2cont_lambda)(auto simp add: assms)"], ["", "lemma fun_upd_belowI:\n  assumes \"\\<And> z . z \\<noteq> x \\<Longrightarrow> \\<rho> z \\<sqsubseteq> \\<rho>' z\" \n  assumes \"y \\<sqsubseteq> \\<rho>' x\"\n  shows  \"\\<rho>(x := y) \\<sqsubseteq> \\<rho>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<rho>(x := y) \\<sqsubseteq> \\<rho>'", "apply (rule fun_belowI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa. (\\<rho>(x := y)) xa \\<sqsubseteq> \\<rho>' xa", "using assms"], ["proof (prove)\nusing this:\n  ?z \\<noteq> x \\<Longrightarrow> \\<rho> ?z \\<sqsubseteq> \\<rho>' ?z\n  y \\<sqsubseteq> \\<rho>' x\n\ngoal (1 subgoal):\n 1. \\<And>xa. (\\<rho>(x := y)) xa \\<sqsubseteq> \\<rho>' xa", "apply (case_tac \"xa = x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>z.\n                   z \\<noteq> x \\<Longrightarrow>\n                   \\<rho> z \\<sqsubseteq> \\<rho>' z;\n        y \\<sqsubseteq> \\<rho>' x; xa = x\\<rbrakk>\n       \\<Longrightarrow> (\\<rho>(x := y)) xa \\<sqsubseteq> \\<rho>' xa\n 2. \\<And>xa.\n       \\<lbrakk>\\<And>z.\n                   z \\<noteq> x \\<Longrightarrow>\n                   \\<rho> z \\<sqsubseteq> \\<rho>' z;\n        y \\<sqsubseteq> \\<rho>' x; xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> (\\<rho>(x := y)) xa \\<sqsubseteq> \\<rho>' xa", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cont_if_else_above: \n  assumes \"cont f\"\n  assumes \"cont g\"\n  assumes \"\\<And> x. f x \\<sqsubseteq> g x\"\n  assumes \"\\<And> x y. x \\<sqsubseteq> y \\<Longrightarrow> P y \\<Longrightarrow> P x\"\n  assumes \"adm P\"\n  shows \"cont (\\<lambda>x. if P x then f x else g x)\" (is \"cont ?I\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. if P x then f x else g x)", "proof(intro contI2 monofunI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       (if P x then f x else g x) \\<sqsubseteq> (if P y then f y else g y)\n 2. \\<And>Y.\n       \\<lbrakk>chain Y;\n        chain (\\<lambda>i. if P (Y i) then f (Y i) else g (Y i))\\<rbrakk>\n       \\<Longrightarrow> (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n                          else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n                         (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "fix x y :: 'a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       (if P x then f x else g x) \\<sqsubseteq> (if P y then f y else g y)\n 2. \\<And>Y.\n       \\<lbrakk>chain Y;\n        chain (\\<lambda>i. if P (Y i) then f (Y i) else g (Y i))\\<rbrakk>\n       \\<Longrightarrow> (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n                          else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n                         (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "assume \"x \\<sqsubseteq> y\""], ["proof (state)\nthis:\n  x \\<sqsubseteq> y\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       x \\<sqsubseteq> y \\<Longrightarrow>\n       (if P x then f x else g x) \\<sqsubseteq> (if P y then f y else g y)\n 2. \\<And>Y.\n       \\<lbrakk>chain Y;\n        chain (\\<lambda>i. if P (Y i) then f (Y i) else g (Y i))\\<rbrakk>\n       \\<Longrightarrow> (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n                          else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n                         (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "with assms(4)[OF this]"], ["proof (chain)\npicking this:\n  P y \\<Longrightarrow> P x\n  x \\<sqsubseteq> y", "show \"?I x \\<sqsubseteq> ?I y\""], ["proof (prove)\nusing this:\n  P y \\<Longrightarrow> P x\n  x \\<sqsubseteq> y\n\ngoal (1 subgoal):\n 1. (if P x then f x else g x) \\<sqsubseteq> (if P y then f y else g y)", "apply (auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<sqsubseteq> y; P x; P y\\<rbrakk>\n    \\<Longrightarrow> f x \\<sqsubseteq> f y\n 2. \\<lbrakk>x \\<sqsubseteq> y; P x; \\<not> P y\\<rbrakk>\n    \\<Longrightarrow> f x \\<sqsubseteq> g y\n 3. \\<lbrakk>x \\<sqsubseteq> y; \\<not> P x; \\<not> P y\\<rbrakk>\n    \\<Longrightarrow> g x \\<sqsubseteq> g y", "apply (rule cont2monofunE[OF assms(1)], assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<sqsubseteq> y; P x; \\<not> P y\\<rbrakk>\n    \\<Longrightarrow> f x \\<sqsubseteq> g y\n 2. \\<lbrakk>x \\<sqsubseteq> y; \\<not> P x; \\<not> P y\\<rbrakk>\n    \\<Longrightarrow> g x \\<sqsubseteq> g y", "apply (rule below_trans[OF cont2monofunE[OF assms(1)] assms(3)], assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sqsubseteq> y; \\<not> P x; \\<not> P y\\<rbrakk>\n    \\<Longrightarrow> g x \\<sqsubseteq> g y", "apply (rule cont2monofunE[OF assms(2)], assumption)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (if P x then f x else g x) \\<sqsubseteq> (if P y then f y else g y)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y;\n        chain (\\<lambda>i. if P (Y i) then f (Y i) else g (Y i))\\<rbrakk>\n       \\<Longrightarrow> (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n                          else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n                         (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y;\n        chain (\\<lambda>i. if P (Y i) then f (Y i) else g (Y i))\\<rbrakk>\n       \\<Longrightarrow> (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n                          else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n                         (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "fix Y :: \"nat \\<Rightarrow> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y;\n        chain (\\<lambda>i. if P (Y i) then f (Y i) else g (Y i))\\<rbrakk>\n       \\<Longrightarrow> (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n                          else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n                         (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "assume \"chain Y\""], ["proof (state)\nthis:\n  chain Y\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y;\n        chain (\\<lambda>i. if P (Y i) then f (Y i) else g (Y i))\\<rbrakk>\n       \\<Longrightarrow> (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n                          else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n                         (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "assume \"chain (\\<lambda>i . ?I (Y i))\""], ["proof (state)\nthis:\n  chain (\\<lambda>i. if P (Y i) then f (Y i) else g (Y i))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y;\n        chain (\\<lambda>i. if P (Y i) then f (Y i) else g (Y i))\\<rbrakk>\n       \\<Longrightarrow> (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n                          else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n                         (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "have ch_f: \"f (\\<Squnion> i. Y i) \\<sqsubseteq> (\\<Squnion> i. f (Y i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (\\<Squnion>i. Y i) \\<sqsubseteq> (\\<Squnion>i. f (Y i))", "by (metis \\<open>chain Y\\<close> assms(1) below_refl cont2contlubE)"], ["proof (state)\nthis:\n  f (\\<Squnion>i. Y i) \\<sqsubseteq> (\\<Squnion>i. f (Y i))\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y;\n        chain (\\<lambda>i. if P (Y i) then f (Y i) else g (Y i))\\<rbrakk>\n       \\<Longrightarrow> (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n                          else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n                         (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "show \"?I (\\<Squnion> i. Y i) \\<sqsubseteq> (\\<Squnion> i. ?I (Y i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n     else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n    (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "proof(cases \"\\<forall> i. P (Y i)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i. P (Y i) \\<Longrightarrow>\n    (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n     else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n    (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))\n 2. \\<not> (\\<forall>i. P (Y i)) \\<Longrightarrow>\n    (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n     else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n    (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "case True"], ["proof (state)\nthis:\n  \\<forall>i. P (Y i)\n\ngoal (2 subgoals):\n 1. \\<forall>i. P (Y i) \\<Longrightarrow>\n    (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n     else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n    (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))\n 2. \\<not> (\\<forall>i. P (Y i)) \\<Longrightarrow>\n    (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n     else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n    (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "hence \"P (\\<Squnion> i. Y i)\""], ["proof (prove)\nusing this:\n  \\<forall>i. P (Y i)\n\ngoal (1 subgoal):\n 1. P (\\<Squnion>i. Y i)", "by (metis \\<open>chain Y\\<close> adm_def assms(5))"], ["proof (state)\nthis:\n  P (\\<Squnion>i. Y i)\n\ngoal (2 subgoals):\n 1. \\<forall>i. P (Y i) \\<Longrightarrow>\n    (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n     else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n    (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))\n 2. \\<not> (\\<forall>i. P (Y i)) \\<Longrightarrow>\n    (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n     else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n    (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "with True ch_f"], ["proof (chain)\npicking this:\n  \\<forall>i. P (Y i)\n  f (\\<Squnion>i. Y i) \\<sqsubseteq> (\\<Squnion>i. f (Y i))\n  P (\\<Squnion>i. Y i)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i. P (Y i)\n  f (\\<Squnion>i. Y i) \\<sqsubseteq> (\\<Squnion>i. f (Y i))\n  P (\\<Squnion>i. Y i)\n\ngoal (1 subgoal):\n 1. (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n     else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n    (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "by auto"], ["proof (state)\nthis:\n  (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n   else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n  (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. P (Y i)) \\<Longrightarrow>\n    (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n     else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n    (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. P (Y i)) \\<Longrightarrow>\n    (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n     else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n    (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>i. P (Y i))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. P (Y i)) \\<Longrightarrow>\n    (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n     else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n    (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>i. P (Y i))", "obtain j where \"\\<not> P (Y j)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i. P (Y i))\n\ngoal (1 subgoal):\n 1. (\\<And>j. \\<not> P (Y j) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<not> P (Y j)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. P (Y i)) \\<Longrightarrow>\n    (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n     else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n    (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "hence *:  \"\\<forall> i \\<ge> j. \\<not> P (Y i)\" \"\\<not> P (\\<Squnion> i. Y i)\""], ["proof (prove)\nusing this:\n  \\<not> P (Y j)\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<ge>j. \\<not> P (Y i) &&& \\<not> P (\\<Squnion>i. Y i)", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<not> P (Y j); j \\<le> i; P (Y i)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>\\<not> P (Y j); P (\\<Squnion>i. Y i)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (metis assms(4) chain_mono[OF \\<open>chain Y\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> P (Y j); P (\\<Squnion>i. Y i)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (metis assms(4) is_ub_thelub[OF \\<open>chain Y\\<close>])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>i\\<ge>j. \\<not> P (Y i)\n  \\<not> P (\\<Squnion>i. Y i)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. P (Y i)) \\<Longrightarrow>\n    (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n     else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n    (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "have \"?I (\\<Squnion> i. Y i) = g (\\<Squnion> i. Y i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n     else g (\\<Squnion>i. Y i)) =\n    g (\\<Squnion>i. Y i)", "using *"], ["proof (prove)\nusing this:\n  \\<forall>i\\<ge>j. \\<not> P (Y i)\n  \\<not> P (\\<Squnion>i. Y i)\n\ngoal (1 subgoal):\n 1. (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n     else g (\\<Squnion>i. Y i)) =\n    g (\\<Squnion>i. Y i)", "by simp"], ["proof (state)\nthis:\n  (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n   else g (\\<Squnion>i. Y i)) =\n  g (\\<Squnion>i. Y i)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. P (Y i)) \\<Longrightarrow>\n    (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n     else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n    (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "also"], ["proof (state)\nthis:\n  (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n   else g (\\<Squnion>i. Y i)) =\n  g (\\<Squnion>i. Y i)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. P (Y i)) \\<Longrightarrow>\n    (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n     else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n    (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "have \"\\<dots> = g (\\<Squnion> i. Y (i + j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (\\<Squnion>i. Y i) = g (\\<Squnion>i. Y (i + j))", "by (metis lub_range_shift[OF \\<open>chain Y\\<close>])"], ["proof (state)\nthis:\n  g (\\<Squnion>i. Y i) = g (\\<Squnion>i. Y (i + j))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. P (Y i)) \\<Longrightarrow>\n    (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n     else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n    (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "also"], ["proof (state)\nthis:\n  g (\\<Squnion>i. Y i) = g (\\<Squnion>i. Y (i + j))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. P (Y i)) \\<Longrightarrow>\n    (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n     else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n    (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "have \"\\<dots> = (\\<Squnion> i. (g (Y (i + j))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (\\<Squnion>i. Y (i + j)) = (\\<Squnion>i. g (Y (i + j)))", "by (rule cont2contlubE[OF assms(2) chain_shift[OF \\<open>chain Y\\<close>]] )"], ["proof (state)\nthis:\n  g (\\<Squnion>i. Y (i + j)) = (\\<Squnion>i. g (Y (i + j)))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. P (Y i)) \\<Longrightarrow>\n    (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n     else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n    (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "also"], ["proof (state)\nthis:\n  g (\\<Squnion>i. Y (i + j)) = (\\<Squnion>i. g (Y (i + j)))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. P (Y i)) \\<Longrightarrow>\n    (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n     else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n    (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "have \"\\<dots> = (\\<Squnion> i. (?I (Y (i + j))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>i. g (Y (i + j))) =\n    (\\<Squnion>i. if P (Y (i + j)) then f (Y (i + j)) else g (Y (i + j)))", "using *"], ["proof (prove)\nusing this:\n  \\<forall>i\\<ge>j. \\<not> P (Y i)\n  \\<not> P (\\<Squnion>i. Y i)\n\ngoal (1 subgoal):\n 1. (\\<Squnion>i. g (Y (i + j))) =\n    (\\<Squnion>i. if P (Y (i + j)) then f (Y (i + j)) else g (Y (i + j)))", "by auto"], ["proof (state)\nthis:\n  (\\<Squnion>i. g (Y (i + j))) =\n  (\\<Squnion>i. if P (Y (i + j)) then f (Y (i + j)) else g (Y (i + j)))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. P (Y i)) \\<Longrightarrow>\n    (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n     else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n    (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "also"], ["proof (state)\nthis:\n  (\\<Squnion>i. g (Y (i + j))) =\n  (\\<Squnion>i. if P (Y (i + j)) then f (Y (i + j)) else g (Y (i + j)))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. P (Y i)) \\<Longrightarrow>\n    (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n     else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n    (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "have \"\\<dots> = (\\<Squnion> i. (?I (Y i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>i. if P (Y (i + j)) then f (Y (i + j)) else g (Y (i + j))) =\n    (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "by (metis lub_range_shift[OF \\<open>chain (\\<lambda>i . ?I (Y i))\\<close>])"], ["proof (state)\nthis:\n  (\\<Squnion>i. if P (Y (i + j)) then f (Y (i + j)) else g (Y (i + j))) =\n  (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. P (Y i)) \\<Longrightarrow>\n    (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n     else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n    (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "finally"], ["proof (chain)\npicking this:\n  (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n   else g (\\<Squnion>i. Y i)) =\n  (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "show ?thesis"], ["proof (prove)\nusing this:\n  (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n   else g (\\<Squnion>i. Y i)) =\n  (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))\n\ngoal (1 subgoal):\n 1. (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n     else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n    (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))", "by simp"], ["proof (state)\nthis:\n  (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n   else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n  (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if P (\\<Squnion>i. Y i) then f (\\<Squnion>i. Y i)\n   else g (\\<Squnion>i. Y i)) \\<sqsubseteq>\n  (\\<Squnion>i. if P (Y i) then f (Y i) else g (Y i))\n\ngoal:\nNo subgoals!", "qed"], ["", "fun up2option :: \"'a::cpo\\<^sub>\\<bottom> \\<Rightarrow> 'a option\"\n  where \"up2option Ibottom = None\"\n  |     \"up2option (Iup a) = Some a\""], ["", "lemma up2option_simps[simp]:\n  \"up2option \\<bottom> = None\"\n  \"up2option (up\\<cdot>x) = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up2option \\<bottom> = None &&& up2option (up\\<cdot>x) = Some x", "unfolding up_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. up2option \\<bottom> = None &&& up2option (Abs_cfun Iup\\<cdot>x) = Some x", "by (simp_all add: cont_Iup inst_up_pcpo)"], ["", "fun option2up :: \"'a option \\<Rightarrow> 'a::cpo\\<^sub>\\<bottom>\"\n  where \"option2up None = \\<bottom>\"\n  |     \"option2up (Some a) = up\\<cdot>a\""], ["", "lemma option2up_up2option[simp]:\n  \"option2up (up2option x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. option2up (up2option x) = x", "by (cases x) auto"], ["", "lemma up2option_option2up[simp]:\n  \"up2option (option2up x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. up2option (option2up x) = x", "by (cases x) auto"], ["", "lemma adm_subst2: \"cont f \\<Longrightarrow> cont g \\<Longrightarrow> adm (\\<lambda>x. f (fst x) = g (snd x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cont f; cont g\\<rbrakk>\n    \\<Longrightarrow> adm (\\<lambda>x. f (fst x) = g (snd x))", "apply (rule admI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>cont f; cont g; chain Y;\n        \\<forall>i. f (fst (Y i)) = g (snd (Y i))\\<rbrakk>\n       \\<Longrightarrow> f (fst (\\<Squnion>i. Y i)) =\n                         g (snd (\\<Squnion>i. Y i))", "apply (simp add:\n      cont2contlubE[where f = f]  cont2contlubE[where f = g]\n      cont2contlubE[where f = snd]  cont2contlubE[where f = fst]\n      )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Composition of fun and cfun\\<close>"], ["", "lemma cont2cont_comp [simp, cont2cont]:\n  assumes \"cont f\"\n  assumes \"\\<And> x. cont (f x)\"\n  assumes \"cont g\"\n  shows \"cont (\\<lambda> x. (f x) \\<circ> (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. f x \\<circ> g x)", "unfolding comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x xa. f x (g x xa))", "by (rule cont2cont_lambda)\n     (intro cont2cont  \\<open>cont g\\<close> \\<open>cont f\\<close> cont_compose2[OF cont2cont_fun[OF assms(1)] assms(2)] cont2cont_fun)"], ["", "definition cfun_comp :: \"('a::pcpo \\<rightarrow> 'b::pcpo) \\<rightarrow> ('c::type \\<Rightarrow> 'a) \\<rightarrow> ('c::type \\<Rightarrow> 'b)\"\n  where  \"cfun_comp = (\\<Lambda> f \\<rho>. (\\<lambda> x. f\\<cdot>x) \\<circ> \\<rho>)\""], ["", "lemma [simp]: \"cfun_comp\\<cdot>f\\<cdot>(\\<rho>(x := v)) = (cfun_comp\\<cdot>f\\<cdot>\\<rho>)(x := f\\<cdot>v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfun_comp\\<cdot>f\\<cdot>(\\<rho>(x := v)) =\n    (cfun_comp\\<cdot>f\\<cdot>\\<rho>)(x := f\\<cdot>v)", "unfolding cfun_comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> f. Abs_cfun ((\\<circ>) (Rep_cfun f)))\\<cdot>f\\<cdot>\n    (\\<rho>(x := v)) =\n    ((\\<Lambda> f. Abs_cfun ((\\<circ>) (Rep_cfun f)))\\<cdot>f\\<cdot>\\<rho>)\n    (x := f\\<cdot>v)", "by auto"], ["", "lemma cfun_comp_app[simp]: \"(cfun_comp\\<cdot>f\\<cdot>\\<rho>) x = f\\<cdot>(\\<rho> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cfun_comp\\<cdot>f\\<cdot>\\<rho>) x = f\\<cdot>(\\<rho> x)", "unfolding cfun_comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Lambda> f. Abs_cfun ((\\<circ>) (Rep_cfun f)))\\<cdot>f\\<cdot>\\<rho>)\n     x =\n    f\\<cdot>(\\<rho> x)", "by auto"], ["", "lemma fix_eq_fix:\n  \"f\\<cdot>(fix\\<cdot>g) \\<sqsubseteq> fix\\<cdot>g \\<Longrightarrow> g\\<cdot>(fix\\<cdot>f) \\<sqsubseteq> fix\\<cdot>f \\<Longrightarrow> fix\\<cdot>f = fix\\<cdot>g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f\\<cdot>(fix\\<cdot>g) \\<sqsubseteq> fix\\<cdot>g;\n     g\\<cdot>(fix\\<cdot>f) \\<sqsubseteq> fix\\<cdot>f\\<rbrakk>\n    \\<Longrightarrow> fix\\<cdot>f = fix\\<cdot>g", "by (metis fix_least_below below_antisym)"], ["", "subsubsection \\<open>Additional transitivity rules\\<close>"], ["", "text \\<open>\nThese collect side-conditions of the form @{term \"cont f\"}, so the usual way to discharge them\nis to write @{text[source] \"by this (intro cont2cont)+\"} at the end.\n\\<close>"], ["", "lemma below_trans_cong[trans]:\n  \"a \\<sqsubseteq> f x \\<Longrightarrow> x \\<sqsubseteq> y \\<Longrightarrow> cont f \\<Longrightarrow> a \\<sqsubseteq> f y \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<sqsubseteq> f x; x \\<sqsubseteq> y; cont f\\<rbrakk>\n    \\<Longrightarrow> a \\<sqsubseteq> f y", "by (metis below_trans cont2monofunE)"], ["", "lemma not_bot_below_trans[trans]:\n  \"a \\<noteq> \\<bottom> \\<Longrightarrow> a \\<sqsubseteq> b \\<Longrightarrow> b \\<noteq> \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> \\<bottom>; a \\<sqsubseteq> b\\<rbrakk>\n    \\<Longrightarrow> b \\<noteq> \\<bottom>", "by (metis below_bottom_iff)"], ["", "lemma not_bot_below_trans_cong[trans]:\n  \"f a \\<noteq> \\<bottom> \\<Longrightarrow> a \\<sqsubseteq> b \\<Longrightarrow> cont f \\<Longrightarrow> f b \\<noteq> \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f a \\<noteq> \\<bottom>; a \\<sqsubseteq> b; cont f\\<rbrakk>\n    \\<Longrightarrow> f b \\<noteq> \\<bottom>", "by (metis below_bottom_iff cont2monofunE)"], ["", "end"]]}