{"file_name": "/home/qj213/afp-2021-10-22/thys/Launchbury/Nominal-HOLCF.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Launchbury", "problem_names": ["lemma (in cont_pt) perm_cont_simp[simp]: \"\\<pi> \\<bullet> x \\<sqsubseteq> \\<pi> \\<bullet> y \\<longleftrightarrow> x \\<sqsubseteq> y\"", "lemma (in cont_pt) perm_below_to_right: \"\\<pi> \\<bullet> x \\<sqsubseteq> y \\<longleftrightarrow> x \\<sqsubseteq> - \\<pi> \\<bullet>  y\"", "lemma perm_is_ub_simp[simp]: \"\\<pi> \\<bullet> S <| \\<pi> \\<bullet> (x::'a::cont_pt) \\<longleftrightarrow> S <| x\"", "lemma perm_is_ub_eqvt[simp,eqvt]: \"S <| (x::'a::cont_pt) \\<Longrightarrow> \\<pi> \\<bullet> S <| \\<pi> \\<bullet> x\"", "lemma perm_is_lub_simp[simp]: \"\\<pi> \\<bullet> S <<| \\<pi> \\<bullet> (x::'a::cont_pt) \\<longleftrightarrow> S <<| x\"", "lemma perm_is_lub_eqvt[simp,eqvt]: \"S <<| (x::'a::cont_pt) ==> \\<pi> \\<bullet> S <<| \\<pi> \\<bullet> x\"", "lemmas perm_cont2cont[simp,cont2cont] = cont_compose[OF perm_cont]", "lemma perm_still_cont: \"cont (\\<pi> \\<bullet> f) = cont (f :: ('a :: cont_pt) \\<Rightarrow> ('b :: cont_pt))\"", "lemma perm_bottom[simp,eqvt]: \"\\<pi> \\<bullet> \\<bottom> = (\\<bottom>::'a::{cont_pt,pcpo})\"", "lemma bot_supp[simp]: \"supp (\\<bottom> :: 'a :: pcpo_pt) = {}\"", "lemma bot_fresh[simp]: \"a \\<sharp> (\\<bottom> :: 'a :: pcpo_pt)\"", "lemma bot_fresh_star[simp]: \"a \\<sharp>* (\\<bottom> :: 'a :: pcpo_pt)\"", "lemma below_eqvt [eqvt]:\n    \"\\<pi> \\<bullet> (x \\<sqsubseteq> y) = (\\<pi> \\<bullet> x \\<sqsubseteq> \\<pi> \\<bullet> (y::'a::cont_pt))\"", "lemma lub_eqvt[simp]:\n  \"(\\<exists> z. S <<| (z::'a::{cont_pt})) \\<Longrightarrow> \\<pi> \\<bullet> lub S = lub (\\<pi> \\<bullet> S)\"", "lemma chain_eqvt[eqvt]:\n  fixes F :: \"nat \\<Rightarrow> 'a::cont_pt\"\n  shows \"chain F \\<Longrightarrow> chain (\\<pi> \\<bullet> F)\"", "lemma permute_cfun_eq: \"permute p = (\\<lambda> f. (Abs_cfun (permute p)) oo f oo (Abs_cfun (permute (-p))))\"", "lemma Cfun_app_eqvt[eqvt]:\n  \"\\<pi> \\<bullet> (f \\<cdot> x) = (\\<pi> \\<bullet> f) \\<cdot> (\\<pi> \\<bullet> x)\"", "lemma permute_Lam: \"cont f \\<Longrightarrow> p \\<bullet> (\\<Lambda> x. f x) = (\\<Lambda> x. (p \\<bullet> f) x)\"", "lemma Abs_cfun_eqvt: \"cont f \\<Longrightarrow> (p \\<bullet> Abs_cfun) f = Abs_cfun f\"", "lemma cfun_eqvtI: \"(\\<And>x. p \\<bullet> (f \\<cdot> x) = f' \\<cdot> (p \\<bullet> x)) \\<Longrightarrow> p \\<bullet> f = f'\"", "lemma ID_eqvt[eqvt]: \"\\<pi> \\<bullet> ID = ID\"", "lemma permute_fun_eq: \"permute p = (\\<lambda> f. (permute p) \\<circ> f \\<circ> (permute (-p)))\"", "lemma fix_eqvt[eqvt]:\n  \"\\<pi> \\<bullet> fix = (fix :: ('a \\<rightarrow> 'a) \\<rightarrow> 'a::{cont_pt,pcpo})\"", "lemma up_eqvt[eqvt]: \"\\<pi> \\<bullet> up = up\"", "lemma fup_eqvt[eqvt]: \"\\<pi> \\<bullet> fup = fup\"", "lemma Def_eqvt[eqvt]: \"\\<pi> \\<bullet> (Def x) = Def (\\<pi> \\<bullet> x)\"", "lemma case_lift_eqvt[eqvt]: \"\\<pi> \\<bullet> case_lift d f x = case_lift (\\<pi> \\<bullet> d) (\\<pi> \\<bullet> f) (\\<pi> \\<bullet> x)\""], "translations": [["", "lemma (in cont_pt) perm_cont_simp[simp]: \"\\<pi> \\<bullet> x \\<sqsubseteq> \\<pi> \\<bullet> y \\<longleftrightarrow> x \\<sqsubseteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<pi> \\<bullet> x \\<sqsubseteq> \\<pi> \\<bullet> y) =\n    (x \\<sqsubseteq> y)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<pi> \\<bullet> x \\<sqsubseteq> \\<pi> \\<bullet> y \\<Longrightarrow>\n    x \\<sqsubseteq> y\n 2. x \\<sqsubseteq> y \\<Longrightarrow>\n    \\<pi> \\<bullet> x \\<sqsubseteq> \\<pi> \\<bullet> y", "apply (drule cont2monofunE[OF perm_cont, of _ _ \"-\\<pi>\"], simp)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> y \\<Longrightarrow>\n    \\<pi> \\<bullet> x \\<sqsubseteq> \\<pi> \\<bullet> y", "apply (erule cont2monofunE[OF perm_cont, of _ _ \"\\<pi>\"])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in cont_pt) perm_below_to_right: \"\\<pi> \\<bullet> x \\<sqsubseteq> y \\<longleftrightarrow> x \\<sqsubseteq> - \\<pi> \\<bullet>  y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<pi> \\<bullet> x \\<sqsubseteq> y) =\n    (x \\<sqsubseteq> - \\<pi> \\<bullet> y)", "by (metis perm_cont_simp pt_class.permute_minus_cancel(2))"], ["", "lemma perm_is_ub_simp[simp]: \"\\<pi> \\<bullet> S <| \\<pi> \\<bullet> (x::'a::cont_pt) \\<longleftrightarrow> S <| x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> S <| \\<pi> \\<bullet> x = S <| x", "by (auto simp add: is_ub_def permute_set_def)"], ["", "lemma perm_is_ub_eqvt[simp,eqvt]: \"S <| (x::'a::cont_pt) \\<Longrightarrow> \\<pi> \\<bullet> S <| \\<pi> \\<bullet> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S <| x \\<Longrightarrow> \\<pi> \\<bullet> S <| \\<pi> \\<bullet> x", "by simp"], ["", "lemma perm_is_lub_simp[simp]: \"\\<pi> \\<bullet> S <<| \\<pi> \\<bullet> (x::'a::cont_pt) \\<longleftrightarrow> S <<| x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> S <<| \\<pi> \\<bullet> x = S <<| x", "apply (rule perm_rel_lemma)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<pi> x y.\n       \\<pi> \\<bullet> x <<| \\<pi> \\<bullet> y \\<Longrightarrow> x <<| y", "by (metis is_lubI is_lubD1 is_lubD2 perm_cont_simp perm_is_ub_simp)"], ["", "lemma perm_is_lub_eqvt[simp,eqvt]: \"S <<| (x::'a::cont_pt) ==> \\<pi> \\<bullet> S <<| \\<pi> \\<bullet> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S <<| x \\<Longrightarrow> \\<pi> \\<bullet> S <<| \\<pi> \\<bullet> x", "by simp"], ["", "lemmas perm_cont2cont[simp,cont2cont] = cont_compose[OF perm_cont]"], ["", "lemma perm_still_cont: \"cont (\\<pi> \\<bullet> f) = cont (f :: ('a :: cont_pt) \\<Rightarrow> ('b :: cont_pt))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<pi> \\<bullet> f) = cont f", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. cont (\\<pi> \\<bullet> f) \\<Longrightarrow> cont f\n 2. cont f \\<Longrightarrow> cont (\\<pi> \\<bullet> f)", "have imp:\"\\<And> (f :: 'a \\<Rightarrow> 'b) \\<pi>. cont f \\<Longrightarrow> cont (\\<pi> \\<bullet> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f \\<pi>. cont f \\<Longrightarrow> cont (\\<pi> \\<bullet> f)", "unfolding permute_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f \\<pi>.\n       cont f \\<Longrightarrow>\n       cont (\\<lambda>x. \\<pi> \\<bullet> f (- \\<pi> \\<bullet> x))", "by (metis cont_compose perm_cont)"], ["proof (state)\nthis:\n  cont ?f \\<Longrightarrow> cont (?\\<pi> \\<bullet> ?f)\n\ngoal (2 subgoals):\n 1. cont (\\<pi> \\<bullet> f) \\<Longrightarrow> cont f\n 2. cont f \\<Longrightarrow> cont (\\<pi> \\<bullet> f)", "show \"cont f \\<Longrightarrow> cont (\\<pi> \\<bullet> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont f \\<Longrightarrow> cont (\\<pi> \\<bullet> f)", "using imp[of \"f\" \"\\<pi>\"]"], ["proof (prove)\nusing this:\n  cont f \\<Longrightarrow> cont (\\<pi> \\<bullet> f)\n\ngoal (1 subgoal):\n 1. cont f \\<Longrightarrow> cont (\\<pi> \\<bullet> f)", "."], ["proof (state)\nthis:\n  cont f \\<Longrightarrow> cont (\\<pi> \\<bullet> f)\n\ngoal (1 subgoal):\n 1. cont (\\<pi> \\<bullet> f) \\<Longrightarrow> cont f", "show \"cont (\\<pi> \\<bullet> f) \\<Longrightarrow> cont (f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<pi> \\<bullet> f) \\<Longrightarrow> cont f", "using imp[of \"\\<pi> \\<bullet> f\" \"-\\<pi>\"]"], ["proof (prove)\nusing this:\n  cont (\\<pi> \\<bullet> f) \\<Longrightarrow>\n  cont (- \\<pi> \\<bullet> \\<pi> \\<bullet> f)\n\ngoal (1 subgoal):\n 1. cont (\\<pi> \\<bullet> f) \\<Longrightarrow> cont f", "by simp"], ["proof (state)\nthis:\n  cont (\\<pi> \\<bullet> f) \\<Longrightarrow> cont f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma perm_bottom[simp,eqvt]: \"\\<pi> \\<bullet> \\<bottom> = (\\<bottom>::'a::{cont_pt,pcpo})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> \\<bottom> = \\<bottom>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> \\<bottom> = \\<bottom>", "have \"\\<bottom> \\<sqsubseteq> -\\<pi> \\<bullet> (\\<bottom>::'a::{cont_pt,pcpo})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> \\<sqsubseteq> - \\<pi> \\<bullet> \\<bottom>", "by simp"], ["proof (state)\nthis:\n  \\<bottom> \\<sqsubseteq> - \\<pi> \\<bullet> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> \\<bottom> = \\<bottom>", "hence \"\\<pi> \\<bullet> \\<bottom> \\<sqsubseteq> \\<pi> \\<bullet> (-\\<pi> \\<bullet> (\\<bottom>::'a::{cont_pt,pcpo}))\""], ["proof (prove)\nusing this:\n  \\<bottom> \\<sqsubseteq> - \\<pi> \\<bullet> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> \\<bottom> \\<sqsubseteq>\n    \\<pi> \\<bullet> - \\<pi> \\<bullet> \\<bottom>", "by(rule cont2monofunE[OF perm_cont])"], ["proof (state)\nthis:\n  \\<pi> \\<bullet> \\<bottom> \\<sqsubseteq>\n  \\<pi> \\<bullet> - \\<pi> \\<bullet> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> \\<bottom> = \\<bottom>", "hence \"\\<pi> \\<bullet> \\<bottom> \\<sqsubseteq> (\\<bottom>::'a::{cont_pt,pcpo})\""], ["proof (prove)\nusing this:\n  \\<pi> \\<bullet> \\<bottom> \\<sqsubseteq>\n  \\<pi> \\<bullet> - \\<pi> \\<bullet> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> \\<bottom> \\<sqsubseteq> \\<bottom>", "by simp"], ["proof (state)\nthis:\n  \\<pi> \\<bullet> \\<bottom> \\<sqsubseteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> \\<bottom> = \\<bottom>", "thus \"\\<pi> \\<bullet> \\<bottom> = (\\<bottom>::'a::{cont_pt,pcpo})\""], ["proof (prove)\nusing this:\n  \\<pi> \\<bullet> \\<bottom> \\<sqsubseteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> \\<bottom> = \\<bottom>", "by simp"], ["proof (state)\nthis:\n  \\<pi> \\<bullet> \\<bottom> = \\<bottom>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bot_supp[simp]: \"supp (\\<bottom> :: 'a :: pcpo_pt) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp \\<bottom> = {}", "by (rule supp_fun_eqvt) (simp add: eqvt_def)"], ["", "lemma bot_fresh[simp]: \"a \\<sharp> (\\<bottom> :: 'a :: pcpo_pt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> \\<bottom>", "by (simp add: fresh_def)"], ["", "lemma bot_fresh_star[simp]: \"a \\<sharp>* (\\<bottom> :: 'a :: pcpo_pt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp>* \\<bottom>", "by (simp add: fresh_star_def)"], ["", "lemma below_eqvt [eqvt]:\n    \"\\<pi> \\<bullet> (x \\<sqsubseteq> y) = (\\<pi> \\<bullet> x \\<sqsubseteq> \\<pi> \\<bullet> (y::'a::cont_pt))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> (x \\<sqsubseteq> y) =\n    (\\<pi> \\<bullet> x \\<sqsubseteq> \\<pi> \\<bullet> y)", "by (auto simp add: permute_pure)"], ["", "lemma lub_eqvt[simp]:\n  \"(\\<exists> z. S <<| (z::'a::{cont_pt})) \\<Longrightarrow> \\<pi> \\<bullet> lub S = lub (\\<pi> \\<bullet> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z. S <<| z \\<Longrightarrow>\n    \\<pi> \\<bullet> lub S = lub (\\<pi> \\<bullet> S)", "by (metis lub_eqI perm_is_lub_simp)"], ["", "lemma chain_eqvt[eqvt]:\n  fixes F :: \"nat \\<Rightarrow> 'a::cont_pt\"\n  shows \"chain F \\<Longrightarrow> chain (\\<pi> \\<bullet> F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain F \\<Longrightarrow> chain (\\<pi> \\<bullet> F)", "apply (rule chainI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       chain F \\<Longrightarrow>\n       (\\<pi> \\<bullet> F) i \\<sqsubseteq> (\\<pi> \\<bullet> F) (Suc i)", "apply (drule_tac i = i in chainE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       F i \\<sqsubseteq> F (Suc i) \\<Longrightarrow>\n       (\\<pi> \\<bullet> F) i \\<sqsubseteq> (\\<pi> \\<bullet> F) (Suc i)", "apply (subst (asm) perm_cont_simp[symmetric, where \\<pi> = \\<pi>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<pi> \\<bullet> F i \\<sqsubseteq>\n       \\<pi> \\<bullet> F (Suc i) \\<Longrightarrow>\n       (\\<pi> \\<bullet> F) i \\<sqsubseteq> (\\<pi> \\<bullet> F) (Suc i)", "by (metis permute_fun_app_eq permute_pure)"], ["", "subsubsection \\<open>Instance for @{type cfun}\\<close>"], ["", "instantiation \"cfun\" :: (cont_pt, cont_pt) pt\nbegin"], ["", "definition \"p \\<bullet> (f :: 'a  \\<rightarrow> 'b) = (\\<Lambda> x. p \\<bullet> (f \\<cdot> (- p \\<bullet> x)))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<rightarrow> 'b, pt_class)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. 0 \\<bullet> x = x\n 2. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x", "apply (simp add: permute_cfun_def eta_cfun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x", "apply (simp add: permute_cfun_def cfun_eqI minus_add)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma permute_cfun_eq: \"permute p = (\\<lambda> f. (Abs_cfun (permute p)) oo f oo (Abs_cfun (permute (-p))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permute p =\n    (\\<lambda>f. Abs_cfun (permute p) oo f oo Abs_cfun (permute (- p)))", "by (rule, rule cfun_eqI, auto simp add: permute_cfun_def)"], ["", "lemma Cfun_app_eqvt[eqvt]:\n  \"\\<pi> \\<bullet> (f \\<cdot> x) = (\\<pi> \\<bullet> f) \\<cdot> (\\<pi> \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> f\\<cdot>x =\n    (\\<pi> \\<bullet> f)\\<cdot>(\\<pi> \\<bullet> x)", "unfolding permute_cfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> f\\<cdot>x =\n    (\\<Lambda> x. \\<pi> \\<bullet> f\\<cdot>(- \\<pi> \\<bullet> x))\\<cdot>\n    (\\<pi> \\<bullet> x)", "by auto"], ["", "lemma permute_Lam: \"cont f \\<Longrightarrow> p \\<bullet> (\\<Lambda> x. f x) = (\\<Lambda> x. (p \\<bullet> f) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont f \\<Longrightarrow>\n    p \\<bullet> (\\<Lambda> x. f x) = (\\<Lambda> x. (p \\<bullet> f) x)", "apply (rule cfun_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       cont f \\<Longrightarrow>\n       (p \\<bullet> (\\<Lambda> x. f x))\\<cdot>x =\n       (\\<Lambda> x. (p \\<bullet> f) x)\\<cdot>x", "unfolding permute_cfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       cont f \\<Longrightarrow>\n       (\\<Lambda> x. p \\<bullet> Abs_cfun f\\<cdot>(- p \\<bullet> x))\\<cdot>\n       x =\n       (\\<Lambda> x. (p \\<bullet> f) x)\\<cdot>x", "by (metis Abs_cfun_inverse2 eqvt_lambda unpermute_def )"], ["", "lemma Abs_cfun_eqvt: \"cont f \\<Longrightarrow> (p \\<bullet> Abs_cfun) f = Abs_cfun f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont f \\<Longrightarrow> (p \\<bullet> Abs_cfun) f = Abs_cfun f", "apply (subst permute_fun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cont f \\<Longrightarrow>\n    p \\<bullet> Abs_cfun (- p \\<bullet> f) = Abs_cfun f", "by (metis permute_Lam perm_still_cont permute_minus_cancel(1))"], ["", "lemma cfun_eqvtI: \"(\\<And>x. p \\<bullet> (f \\<cdot> x) = f' \\<cdot> (p \\<bullet> x)) \\<Longrightarrow> p \\<bullet> f = f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        p \\<bullet> f\\<cdot>x = f'\\<cdot>(p \\<bullet> x)) \\<Longrightarrow>\n    p \\<bullet> f = f'", "by (metis Cfun_app_eqvt cfun_eqI permute_minus_cancel(1))"], ["", "lemma ID_eqvt[eqvt]: \"\\<pi> \\<bullet> ID = ID\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> ID = ID", "unfolding ID_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> (\\<Lambda> x. x) = (\\<Lambda> x. x)", "apply perm_simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<pi> \\<bullet> Abs_cfun) (\\<lambda>x. x) = (\\<Lambda> x. x)", "apply (simp add: Abs_cfun_eqvt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "instance \"cfun\" :: (cont_pt, cont_pt) cont_pt"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<rightarrow> 'b, cont_pt_class)", "by standard (subst permute_cfun_eq, auto)"], ["", "instance \"cfun\" :: (\"{pure,cont_pt}\", \"{pure,cont_pt}\") pure"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<rightarrow> 'b, pure_class)", "by standard (auto  simp add: permute_cfun_def permute_pure Cfun.cfun.Rep_cfun_inverse)"], ["", "instance \"cfun\" :: (cont_pt, pcpo_pt) pcpo_pt"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<rightarrow> 'b, pcpo_pt_class)", "by standard"], ["", "subsubsection \\<open>Instance for @{type fun}\\<close>"], ["", "lemma permute_fun_eq: \"permute p = (\\<lambda> f. (permute p) \\<circ> f \\<circ> (permute (-p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permute p = (\\<lambda>f. permute p \\<circ> f \\<circ> permute (- p))", "by (rule, rule, metis comp_apply eqvt_lambda unpermute_def)"], ["", "instance \"fun\" :: (pt, cont_pt) cont_pt"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, cont_pt_class)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p. cont (permute p)", "apply (rule cont2cont_lambda)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p y. cont (\\<lambda>x. (p \\<bullet> x) y)", "apply (subst permute_fun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p y. cont (\\<lambda>x. p \\<bullet> x (- p \\<bullet> y))", "apply (rule perm_cont2cont)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p y. cont (\\<lambda>x. x (- p \\<bullet> y))", "apply (rule cont_fun)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fix_eqvt[eqvt]:\n  \"\\<pi> \\<bullet> fix = (fix :: ('a \\<rightarrow> 'a) \\<rightarrow> 'a::{cont_pt,pcpo})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> fix = fix", "apply (rule cfun_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (\\<pi> \\<bullet> fix)\\<cdot>x = fix\\<cdot>x", "apply (subst permute_cfun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<Lambda> x. \\<pi> \\<bullet> fix\\<cdot>(- \\<pi> \\<bullet> x))\\<cdot>\n       x =\n       fix\\<cdot>x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. \\<pi> \\<bullet> fix\\<cdot>(- \\<pi> \\<bullet> x) = fix\\<cdot>x", "apply (rule parallel_fix_ind[OF adm_subst2])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x. cont (permute \\<pi>)\n 2. \\<And>x. cont (\\<lambda>a. a)\n 3. \\<And>x. \\<pi> \\<bullet> \\<bottom> = \\<bottom>\n 4. \\<And>x xa y.\n       \\<pi> \\<bullet> xa = y \\<Longrightarrow>\n       \\<pi> \\<bullet> (- \\<pi> \\<bullet> x)\\<cdot>xa = x\\<cdot>y", "apply (auto simp add: permute_self)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Instance for @{type u}\\<close>"], ["", "(* Everything very pure. Does this work?\ninstantiation u :: (cpo) pt\nbegin\n  definition \"p \\<bullet> (x :: 'a u) = x\"\n  instance by standard (auto simp add: permute_u_def)\nend\ninstance u :: (cpo) pure by standard (simp add: permute_u_def)\ninstance u :: (cpo) cont_pt by standard (simp add: pure_permute_id)\ninstance u :: (cpo) pcpo_pt ..\n*)"], ["", "instantiation u :: (cont_pt) pt\nbegin"], ["", "definition \"p \\<bullet> (x :: 'a u) = fup\\<cdot>(\\<Lambda> x. up\\<cdot>(p \\<bullet> x))\\<cdot>x\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a\\<^sub>\\<bottom>, pt_class)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. 0 \\<bullet> x = x\n 2. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x", "apply (case_tac x)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x = \\<bottom> \\<Longrightarrow> 0 \\<bullet> x = x\n 2. \\<And>x xa. x = up\\<cdot>xa \\<Longrightarrow> 0 \\<bullet> x = x\n 3. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x", "apply (auto simp add: permute_u_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q x.\n       (case x of\n        up\\<cdot>x \\<Rightarrow> up\\<cdot>(p \\<bullet> q \\<bullet> x)) =\n       (case case x of up\\<cdot>x \\<Rightarrow> up\\<cdot>(q \\<bullet> x) of\n        up\\<cdot>x \\<Rightarrow> up\\<cdot>(p \\<bullet> x))", "apply (case_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p q x.\n       x = \\<bottom> \\<Longrightarrow>\n       (case x of\n        up\\<cdot>x \\<Rightarrow> up\\<cdot>(p \\<bullet> q \\<bullet> x)) =\n       (case case x of up\\<cdot>x \\<Rightarrow> up\\<cdot>(q \\<bullet> x) of\n        up\\<cdot>x \\<Rightarrow> up\\<cdot>(p \\<bullet> x))\n 2. \\<And>p q x xa.\n       x = up\\<cdot>xa \\<Longrightarrow>\n       (case x of\n        up\\<cdot>x \\<Rightarrow> up\\<cdot>(p \\<bullet> q \\<bullet> x)) =\n       (case case x of up\\<cdot>x \\<Rightarrow> up\\<cdot>(q \\<bullet> x) of\n        up\\<cdot>x \\<Rightarrow> up\\<cdot>(p \\<bullet> x))", "apply (auto simp add: permute_u_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "instance u :: (cont_pt) cont_pt"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a\\<^sub>\\<bottom>, cont_pt_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. cont (permute p)", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. cont (permute p)", "(* Fighting eta contraction... *)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. cont (permute p)", "have \"permute p = (\\<lambda> x. fup\\<cdot>(\\<Lambda> x. up\\<cdot>(p \\<bullet> x))\\<cdot>(x:: 'a u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permute p = Rep_cfun (\\<Lambda> (up\\<cdot>x). up\\<cdot>(p \\<bullet> x))", "by (rule ext, rule permute_u_def)"], ["proof (state)\nthis:\n  permute p = Rep_cfun (\\<Lambda> (up\\<cdot>x). up\\<cdot>(p \\<bullet> x))\n\ngoal (1 subgoal):\n 1. \\<And>p. cont (permute p)", "moreover"], ["proof (state)\nthis:\n  permute p = Rep_cfun (\\<Lambda> (up\\<cdot>x). up\\<cdot>(p \\<bullet> x))\n\ngoal (1 subgoal):\n 1. \\<And>p. cont (permute p)", "have \"cont (\\<lambda> x. fup\\<cdot>(\\<Lambda> x. up\\<cdot>(p \\<bullet> x))\\<cdot>(x:: 'a u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (Rep_cfun (\\<Lambda> (up\\<cdot>x). up\\<cdot>(p \\<bullet> x)))", "by simp"], ["proof (state)\nthis:\n  cont (Rep_cfun (\\<Lambda> (up\\<cdot>x). up\\<cdot>(p \\<bullet> x)))\n\ngoal (1 subgoal):\n 1. \\<And>p. cont (permute p)", "ultimately"], ["proof (chain)\npicking this:\n  permute p = Rep_cfun (\\<Lambda> (up\\<cdot>x). up\\<cdot>(p \\<bullet> x))\n  cont (Rep_cfun (\\<Lambda> (up\\<cdot>x). up\\<cdot>(p \\<bullet> x)))", "show \"cont (permute p :: 'a u \\<Rightarrow> 'a u)\""], ["proof (prove)\nusing this:\n  permute p = Rep_cfun (\\<Lambda> (up\\<cdot>x). up\\<cdot>(p \\<bullet> x))\n  cont (Rep_cfun (\\<Lambda> (up\\<cdot>x). up\\<cdot>(p \\<bullet> x)))\n\ngoal (1 subgoal):\n 1. cont (permute p)", "by simp"], ["proof (state)\nthis:\n  cont (permute p)\n\ngoal:\nNo subgoals!", "qed"], ["", "instance u :: (cont_pt) pcpo_pt"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a\\<^sub>\\<bottom>, pcpo_pt_class)", ".."], ["", "class pure_cont_pt = pure + cont_pt"], ["", "instance u :: (pure_cont_pt) pure"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a\\<^sub>\\<bottom>, pure_class)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p x. p \\<bullet> x = x", "apply (case_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p x. x = \\<bottom> \\<Longrightarrow> p \\<bullet> x = x\n 2. \\<And>p x xa. x = up\\<cdot>xa \\<Longrightarrow> p \\<bullet> x = x", "apply (auto simp add: permute_u_def permute_pure)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma up_eqvt[eqvt]: \"\\<pi> \\<bullet> up = up\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> up = up", "apply (rule cfun_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (\\<pi> \\<bullet> up)\\<cdot>x = up\\<cdot>x", "apply (subst permute_cfun_def, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. \\<pi> \\<bullet> up\\<cdot>(- \\<pi> \\<bullet> x) = up\\<cdot>x", "apply (simp add: permute_u_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fup_eqvt[eqvt]: \"\\<pi> \\<bullet> fup = fup\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> fup = fup", "apply (rule cfun_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (\\<pi> \\<bullet> fup)\\<cdot>x = fup\\<cdot>x", "apply (rule cfun_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (\\<pi> \\<bullet> fup)\\<cdot>x\\<cdot>xa = fup\\<cdot>x\\<cdot>xa", "apply (subst permute_cfun_def, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (\\<pi> \\<bullet> fup\\<cdot>(- \\<pi> \\<bullet> x))\\<cdot>xa =\n       fup\\<cdot>x\\<cdot>xa", "apply (subst permute_cfun_def, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<pi> \\<bullet> fup\\<cdot>(- \\<pi> \\<bullet> x)\\<cdot>\n                       (- \\<pi> \\<bullet> xa) =\n       fup\\<cdot>x\\<cdot>xa", "apply (case_tac xa)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       xa = \\<bottom> \\<Longrightarrow>\n       \\<pi> \\<bullet> fup\\<cdot>(- \\<pi> \\<bullet> x)\\<cdot>\n                       (- \\<pi> \\<bullet> xa) =\n       fup\\<cdot>x\\<cdot>xa\n 2. \\<And>x xa xb.\n       xa = up\\<cdot>xb \\<Longrightarrow>\n       \\<pi> \\<bullet> fup\\<cdot>(- \\<pi> \\<bullet> x)\\<cdot>\n                       (- \\<pi> \\<bullet> xa) =\n       fup\\<cdot>x\\<cdot>xa", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       xa = up\\<cdot>xb \\<Longrightarrow>\n       \\<pi> \\<bullet> fup\\<cdot>(- \\<pi> \\<bullet> x)\\<cdot>\n                       (- \\<pi> \\<bullet> xa) =\n       fup\\<cdot>x\\<cdot>xa", "apply (simp add: permute_self)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Instance for @{type lift}\\<close>"], ["", "instantiation lift :: (pt) pt\nbegin"], ["", "definition \"p \\<bullet> (x :: 'a lift) = case_lift \\<bottom> (\\<lambda> x. Def (p \\<bullet> x)) x\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a lift, pt_class)", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. 0 \\<bullet> x = x\n 2. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x", "apply (case_tac x)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x = \\<bottom> \\<Longrightarrow> 0 \\<bullet> x = x\n 2. \\<And>x a. x = Def a \\<Longrightarrow> 0 \\<bullet> x = x\n 3. \\<And>p q x. (p + q) \\<bullet> x = p \\<bullet> q \\<bullet> x", "apply (auto simp add: permute_lift_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q x.\n       (case x of \\<bottom> \\<Rightarrow> \\<bottom>\n        | Def x \\<Rightarrow> Def ((p + q) \\<bullet> x)) =\n       (case case x of \\<bottom> \\<Rightarrow> \\<bottom>\n             | Def x \\<Rightarrow> Def (q \\<bullet> x) of\n        \\<bottom> \\<Rightarrow> \\<bottom>\n        | Def x \\<Rightarrow> Def (p \\<bullet> x))", "apply (case_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p q x.\n       x = \\<bottom> \\<Longrightarrow>\n       (case x of \\<bottom> \\<Rightarrow> \\<bottom>\n        | Def x \\<Rightarrow> Def ((p + q) \\<bullet> x)) =\n       (case case x of \\<bottom> \\<Rightarrow> \\<bottom>\n             | Def x \\<Rightarrow> Def (q \\<bullet> x) of\n        \\<bottom> \\<Rightarrow> \\<bottom>\n        | Def x \\<Rightarrow> Def (p \\<bullet> x))\n 2. \\<And>p q x a.\n       x = Def a \\<Longrightarrow>\n       (case x of \\<bottom> \\<Rightarrow> \\<bottom>\n        | Def x \\<Rightarrow> Def ((p + q) \\<bullet> x)) =\n       (case case x of \\<bottom> \\<Rightarrow> \\<bottom>\n             | Def x \\<Rightarrow> Def (q \\<bullet> x) of\n        \\<bottom> \\<Rightarrow> \\<bottom>\n        | Def x \\<Rightarrow> Def (p \\<bullet> x))", "apply (auto simp add: permute_lift_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "instance lift :: (pt) cont_pt"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a lift, cont_pt_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. cont (permute p)", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. cont (permute p)", "(* Fighting eta contraction... *)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. cont (permute p)", "have \"permute p = (\\<lambda> x. case_lift \\<bottom> (\\<lambda> x. Def (p \\<bullet> x)) (x::'a lift))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permute p =\n    (\\<lambda>x.\n        case x of \\<bottom> \\<Rightarrow> \\<bottom>\n        | Def x \\<Rightarrow> Def (p \\<bullet> x))", "by (rule ext, rule permute_lift_def)"], ["proof (state)\nthis:\n  permute p =\n  (\\<lambda>x.\n      case x of \\<bottom> \\<Rightarrow> \\<bottom>\n      | Def x \\<Rightarrow> Def (p \\<bullet> x))\n\ngoal (1 subgoal):\n 1. \\<And>p. cont (permute p)", "moreover"], ["proof (state)\nthis:\n  permute p =\n  (\\<lambda>x.\n      case x of \\<bottom> \\<Rightarrow> \\<bottom>\n      | Def x \\<Rightarrow> Def (p \\<bullet> x))\n\ngoal (1 subgoal):\n 1. \\<And>p. cont (permute p)", "have \"cont (\\<lambda> x. case_lift \\<bottom> (\\<lambda> x. Def (p \\<bullet> x)) (x::'a lift))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont\n     (\\<lambda>x.\n         case x of \\<bottom> \\<Rightarrow> \\<bottom>\n         | Def x \\<Rightarrow> Def (p \\<bullet> x))", "by simp"], ["proof (state)\nthis:\n  cont\n   (\\<lambda>x.\n       case x of \\<bottom> \\<Rightarrow> \\<bottom>\n       | Def x \\<Rightarrow> Def (p \\<bullet> x))\n\ngoal (1 subgoal):\n 1. \\<And>p. cont (permute p)", "ultimately"], ["proof (chain)\npicking this:\n  permute p =\n  (\\<lambda>x.\n      case x of \\<bottom> \\<Rightarrow> \\<bottom>\n      | Def x \\<Rightarrow> Def (p \\<bullet> x))\n  cont\n   (\\<lambda>x.\n       case x of \\<bottom> \\<Rightarrow> \\<bottom>\n       | Def x \\<Rightarrow> Def (p \\<bullet> x))", "show \"cont (permute p :: 'a lift \\<Rightarrow> 'a lift)\""], ["proof (prove)\nusing this:\n  permute p =\n  (\\<lambda>x.\n      case x of \\<bottom> \\<Rightarrow> \\<bottom>\n      | Def x \\<Rightarrow> Def (p \\<bullet> x))\n  cont\n   (\\<lambda>x.\n       case x of \\<bottom> \\<Rightarrow> \\<bottom>\n       | Def x \\<Rightarrow> Def (p \\<bullet> x))\n\ngoal (1 subgoal):\n 1. cont (permute p)", "by simp"], ["proof (state)\nthis:\n  cont (permute p)\n\ngoal:\nNo subgoals!", "qed"], ["", "instance lift :: (pt) pcpo_pt"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a lift, pcpo_pt_class)", ".."], ["", "instance lift :: (pure) pure"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a lift, pure_class)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p x. p \\<bullet> x = x", "apply (case_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p x. x = \\<bottom> \\<Longrightarrow> p \\<bullet> x = x\n 2. \\<And>p x a. x = Def a \\<Longrightarrow> p \\<bullet> x = x", "apply (auto simp add: permute_lift_def permute_pure)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Def_eqvt[eqvt]: \"\\<pi> \\<bullet> (Def x) = Def (\\<pi> \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> Def x = Def (\\<pi> \\<bullet> x)", "by (simp add: permute_lift_def)"], ["", "lemma case_lift_eqvt[eqvt]: \"\\<pi> \\<bullet> case_lift d f x = case_lift (\\<pi> \\<bullet> d) (\\<pi> \\<bullet> f) (\\<pi> \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> (case x of \\<bottom> \\<Rightarrow> d\n                     | Def x \\<Rightarrow> f x) =\n    (case \\<pi> \\<bullet> x of \\<bottom> \\<Rightarrow> \\<pi> \\<bullet> d\n     | Def x \\<Rightarrow> (\\<pi> \\<bullet> f) x)", "by (cases x) (auto simp add: permute_self)"], ["", "subsubsection \\<open>Instance for @{type prod}\\<close>"], ["", "instance prod :: (cont_pt, cont_pt) cont_pt"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, cont_pt_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. cont (permute p)", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. cont (permute p)", "(* Fighting eta contraction... *)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. cont (permute p)", "have \"permute p = (\\<lambda> (x :: ('a, 'b) prod). (p \\<bullet> fst x, p \\<bullet> snd x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permute p = (\\<lambda>x. (p \\<bullet> fst x, p \\<bullet> snd x))", "by auto"], ["proof (state)\nthis:\n  permute p = (\\<lambda>x. (p \\<bullet> fst x, p \\<bullet> snd x))\n\ngoal (1 subgoal):\n 1. \\<And>p. cont (permute p)", "moreover"], ["proof (state)\nthis:\n  permute p = (\\<lambda>x. (p \\<bullet> fst x, p \\<bullet> snd x))\n\ngoal (1 subgoal):\n 1. \\<And>p. cont (permute p)", "have \"cont ...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. (p \\<bullet> fst x, p \\<bullet> snd x))", "by (intro cont2cont)"], ["proof (state)\nthis:\n  cont (\\<lambda>x. (p \\<bullet> fst x, p \\<bullet> snd x))\n\ngoal (1 subgoal):\n 1. \\<And>p. cont (permute p)", "ultimately"], ["proof (chain)\npicking this:\n  permute p = (\\<lambda>x. (p \\<bullet> fst x, p \\<bullet> snd x))\n  cont (\\<lambda>x. (p \\<bullet> fst x, p \\<bullet> snd x))", "show \"cont (permute p :: ('a,'b) prod  \\<Rightarrow> ('a,'b) prod)\""], ["proof (prove)\nusing this:\n  permute p = (\\<lambda>x. (p \\<bullet> fst x, p \\<bullet> snd x))\n  cont (\\<lambda>x. (p \\<bullet> fst x, p \\<bullet> snd x))\n\ngoal (1 subgoal):\n 1. cont (permute p)", "by simp"], ["proof (state)\nthis:\n  cont (permute p)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}