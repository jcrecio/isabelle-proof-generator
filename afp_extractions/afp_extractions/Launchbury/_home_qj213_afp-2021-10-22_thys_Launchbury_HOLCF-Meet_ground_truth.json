{"file_name": "/home/qj213/afp-2021-10-22/thys/Launchbury/HOLCF-Meet.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Launchbury", "problem_names": ["lemma is_lbI: \"(!!x. x \\<in> S ==> l \\<sqsubseteq> x) ==> S >| l\"", "lemma is_lbD: \"[|S >| l; x \\<in> S|] ==> l \\<sqsubseteq> x\"", "lemma is_lb_empty [simp]: \"{} >| l\"", "lemma is_lb_insert [simp]: \"(insert x A) >| y = (y \\<sqsubseteq> x \\<and> A >| y)\"", "lemma is_lb_downward: \"[|S >| l; y \\<sqsubseteq> l|] ==> S >| y\"", "lemma is_glbD1: \"S >>| x ==> S >| x\"", "lemma is_glbD2: \"[|S >>| x; S >| u|] ==> u \\<sqsubseteq> x\"", "lemma (in po) is_glbI: \"[|S >| x; !!u. S >| u ==> u \\<sqsubseteq> x|] ==> S >>| x\"", "lemma is_glb_above_iff: \"S >>| x ==> u \\<sqsubseteq> x \\<longleftrightarrow> S >| u\"", "lemma is_glb_unique: \"[|S >>| x; S >>| y|] ==> x = y\"", "lemma is_glb_glb: \"M >>| x ==> M >>| glb M\"", "lemma glb_eqI: \"M >>| l ==> glb M = l\"", "lemma is_glb_singleton: \"{x} >>| x\"", "lemma glb_singleton [simp]: \"glb {x} = x\"", "lemma is_glb_bin: \"x \\<sqsubseteq> y ==> {x, y} >>| x\"", "lemma glb_bin: \"x \\<sqsubseteq> y ==> glb {x, y} = x\"", "lemma is_glb_maximal: \"[|S >| x; x \\<in> S|] ==> S >>| x\"", "lemma glb_maximal: \"[|S >| x; x \\<in> S|] ==> glb S = x\"", "lemma glb_above: \"S >>| z \\<Longrightarrow> x \\<sqsubseteq> glb S \\<longleftrightarrow> S >| x\"", "lemma (in cpo) Meet_insert: \"S >>| l \\<Longrightarrow> {x, l} >>| l2 \\<Longrightarrow> insert x S >>| l2\"", "lemma binary_meet_exists': \"\\<exists>l. {x, y} >>| l\"", "lemma finite_meet_exists:\n    assumes \"S \\<noteq> {}\"\n    and \"finite S\"\n    shows \"\\<exists>x. S >>| x\"", "lemma meet_def': \"(x::'a::Finite_Meet_cpo) \\<sqinter> y = glb {x, y}\"", "lemma meet_comm: \"(x::'a::Finite_Meet_cpo) \\<sqinter> y = y \\<sqinter> x\"", "lemma meet_bot1[simp]:\n  fixes y :: \"'a :: {Finite_Meet_cpo,pcpo}\"\n  shows \"(\\<bottom> \\<sqinter> y) = \\<bottom>\"", "lemma meet_bot2[simp]:\n  fixes x :: \"'a :: {Finite_Meet_cpo,pcpo}\"\n  shows \"(x \\<sqinter> \\<bottom>) = \\<bottom>\"", "lemma meet_below1[intro]:\n  fixes x y :: \"'a :: Finite_Meet_cpo\"\n  assumes \"x \\<sqsubseteq> z\"\n  shows \"(x \\<sqinter> y) \\<sqsubseteq> z\"", "lemma meet_below2[intro]:\n  fixes x y :: \"'a :: Finite_Meet_cpo\"\n  assumes \"y \\<sqsubseteq> z\"\n  shows \"(x \\<sqinter> y) \\<sqsubseteq> z\"", "lemma meet_above_iff:\n  fixes x y z :: \"'a :: Finite_Meet_cpo\"\n  shows \"z \\<sqsubseteq> x \\<sqinter> y \\<longleftrightarrow> z \\<sqsubseteq> x \\<and> z \\<sqsubseteq> y\"", "lemma below_meet[simp]:\n  fixes x y :: \"'a :: Finite_Meet_cpo\"\n  assumes \"x \\<sqsubseteq> z\"\n  shows \"(x \\<sqinter> z) = x\"", "lemma below_meet2[simp]:\n  fixes x y :: \"'a :: Finite_Meet_cpo\"\n  assumes \"z \\<sqsubseteq> x\"\n  shows \"(x \\<sqinter> z) = z\"", "lemma meet_aboveI:\n  fixes x y z :: \"'a :: Finite_Meet_cpo\"\n  shows \"z \\<sqsubseteq> x \\<Longrightarrow> z \\<sqsubseteq> y \\<Longrightarrow> z \\<sqsubseteq> x \\<sqinter> y\"", "lemma is_meetI:\n  fixes x y z :: \"'a :: Finite_Meet_cpo\"\n  assumes \"z \\<sqsubseteq> x\"\n  assumes \"z \\<sqsubseteq> y\"\n  assumes \"\\<And> a. \\<lbrakk> a \\<sqsubseteq> x ; a \\<sqsubseteq> y \\<rbrakk> \\<Longrightarrow> a \\<sqsubseteq> z\"\n  shows \"x \\<sqinter> y = z\"", "lemma meet_assoc[simp]: \"((x::'a::Finite_Meet_cpo) \\<sqinter> y) \\<sqinter> z = x \\<sqinter> (y \\<sqinter> z)\"", "lemma meet_self[simp]: \"r \\<sqinter> r = (r::'a::Finite_Meet_cpo)\"", "lemma [simp]: \"(r::'a::Finite_Meet_cpo) \\<sqinter> (r \\<sqinter> x) = r \\<sqinter> x\"", "lemma meet_monofun1:\n  fixes y :: \"'a :: Finite_Meet_cpo\"\n  shows \"monofun (\\<lambda>x. (x \\<sqinter> y))\"", "lemma chain_meet1:\n  fixes y :: \"'a :: Finite_Meet_cpo\"\n  assumes \"chain Y\"\n  shows \"chain (\\<lambda> i. Y i \\<sqinter> y)\"", "lemma meet_cont1:\n  fixes y :: \"'a :: cont_binary_meet\"\n  shows \"cont (\\<lambda>x. (x \\<sqinter> y))\"", "lemma meet_cont2: \n  fixes x :: \"'a :: cont_binary_meet\"\n  shows \"cont (\\<lambda>y. (x \\<sqinter> y))\"", "lemma meet_cont[cont2cont,simp]:\"cont f \\<Longrightarrow> cont g \\<Longrightarrow> cont (\\<lambda>x. (f x \\<sqinter> (g x::'a::cont_binary_meet)))\""], "translations": [["", "lemma is_lbI: \"(!!x. x \\<in> S ==> l \\<sqsubseteq> x) ==> S >| l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> S \\<Longrightarrow> l \\<sqsubseteq> x) \\<Longrightarrow>\n    S >| l", "by (simp add: is_lb_def)"], ["", "lemma is_lbD: \"[|S >| l; x \\<in> S|] ==> l \\<sqsubseteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S >| l; x \\<in> S\\<rbrakk> \\<Longrightarrow> l \\<sqsubseteq> x", "by (simp add: is_lb_def)"], ["", "lemma is_lb_empty [simp]: \"{} >| l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} >| l", "unfolding is_lb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball {} ((\\<sqsubseteq>) l)", "by fast"], ["", "lemma is_lb_insert [simp]: \"(insert x A) >| y = (y \\<sqsubseteq> x \\<and> A >| y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert x A >| y = (y \\<sqsubseteq> x \\<and> A >| y)", "unfolding is_lb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (insert x A) ((\\<sqsubseteq>) y) =\n    (y \\<sqsubseteq> x \\<and> Ball A ((\\<sqsubseteq>) y))", "by fast"], ["", "lemma is_lb_downward: \"[|S >| l; y \\<sqsubseteq> l|] ==> S >| y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S >| l; y \\<sqsubseteq> l\\<rbrakk> \\<Longrightarrow> S >| y", "unfolding is_lb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ball S ((\\<sqsubseteq>) l); y \\<sqsubseteq> l\\<rbrakk>\n    \\<Longrightarrow> Ball S ((\\<sqsubseteq>) y)", "by (fast intro: below_trans)"], ["", "subsubsection \\<open>Greatest lower bounds\\<close>"], ["", "definition is_glb :: \"'a set \\<Rightarrow> 'a \\<Rightarrow> bool\" (infix \">>|\" 55) where\n  \"S >>| x \\<longleftrightarrow> S >| x \\<and> (\\<forall>u. S >| u --> u \\<sqsubseteq> x)\""], ["", "definition glb :: \"'a set \\<Rightarrow> 'a\" (\"\\<Sqinter>_\" [60]60) where\n  \"glb S = (THE x. S >>| x)\""], ["", "text \\<open>Access to the definition as inference rule\\<close>"], ["", "lemma is_glbD1: \"S >>| x ==> S >| x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S >>| x \\<Longrightarrow> S >| x", "unfolding is_glb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. S >| x \\<and>\n    (\\<forall>u.\n        S >| u \\<longrightarrow> u \\<sqsubseteq> x) \\<Longrightarrow>\n    S >| x", "by fast"], ["", "lemma is_glbD2: \"[|S >>| x; S >| u|] ==> u \\<sqsubseteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S >>| x; S >| u\\<rbrakk> \\<Longrightarrow> u \\<sqsubseteq> x", "unfolding is_glb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S >| x \\<and>\n             (\\<forall>u. S >| u \\<longrightarrow> u \\<sqsubseteq> x);\n     S >| u\\<rbrakk>\n    \\<Longrightarrow> u \\<sqsubseteq> x", "by fast"], ["", "lemma (in po) is_glbI: \"[|S >| x; !!u. S >| u ==> u \\<sqsubseteq> x|] ==> S >>| x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S >| x;\n     \\<And>u. S >| u \\<Longrightarrow> u \\<sqsubseteq> x\\<rbrakk>\n    \\<Longrightarrow> S >>| x", "unfolding is_glb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S >| x;\n     \\<And>u. S >| u \\<Longrightarrow> u \\<sqsubseteq> x\\<rbrakk>\n    \\<Longrightarrow> S >| x \\<and>\n                      (\\<forall>u.\n                          S >| u \\<longrightarrow> u \\<sqsubseteq> x)", "by fast"], ["", "lemma is_glb_above_iff: \"S >>| x ==> u \\<sqsubseteq> x \\<longleftrightarrow> S >| u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S >>| x \\<Longrightarrow> (u \\<sqsubseteq> x) = S >| u", "unfolding is_glb_def is_lb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball S ((\\<sqsubseteq>) x) \\<and>\n    (\\<forall>u.\n        Ball S ((\\<sqsubseteq>) u) \\<longrightarrow>\n        u \\<sqsubseteq> x) \\<Longrightarrow>\n    (u \\<sqsubseteq> x) = Ball S ((\\<sqsubseteq>) u)", "by (metis below_trans)"], ["", "text \\<open>glbs are unique\\<close>"], ["", "lemma is_glb_unique: \"[|S >>| x; S >>| y|] ==> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S >>| x; S >>| y\\<rbrakk> \\<Longrightarrow> x = y", "unfolding is_glb_def is_lb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ball S ((\\<sqsubseteq>) x) \\<and>\n             (\\<forall>u.\n                 Ball S ((\\<sqsubseteq>) u) \\<longrightarrow>\n                 u \\<sqsubseteq> x);\n     Ball S ((\\<sqsubseteq>) y) \\<and>\n     (\\<forall>u.\n         Ball S ((\\<sqsubseteq>) u) \\<longrightarrow>\n         u \\<sqsubseteq> y)\\<rbrakk>\n    \\<Longrightarrow> x = y", "by (blast intro: below_antisym)"], ["", "text \\<open>technical lemmas about @{term glb} and @{term is_glb}\\<close>"], ["", "lemma is_glb_glb: \"M >>| x ==> M >>| glb M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M >>| x \\<Longrightarrow> M >>| \\<Sqinter>M", "unfolding glb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. M >>| x \\<Longrightarrow> M >>| The ((>>|) M)", "by (rule theI [OF _ is_glb_unique])"], ["", "lemma glb_eqI: \"M >>| l ==> glb M = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M >>| l \\<Longrightarrow> \\<Sqinter>M = l", "by (rule is_glb_unique [OF is_glb_glb])"], ["", "lemma is_glb_singleton: \"{x} >>| x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x} >>| x", "by (simp add: is_glb_def)"], ["", "lemma glb_singleton [simp]: \"glb {x} = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter>{x} = x", "by (rule is_glb_singleton [THEN glb_eqI])"], ["", "lemma is_glb_bin: \"x \\<sqsubseteq> y ==> {x, y} >>| x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> y \\<Longrightarrow> {x, y} >>| x", "by (simp add: is_glb_def)"], ["", "lemma glb_bin: \"x \\<sqsubseteq> y ==> glb {x, y} = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> y \\<Longrightarrow> \\<Sqinter>{x, y} = x", "by (rule is_glb_bin [THEN glb_eqI])"], ["", "lemma is_glb_maximal: \"[|S >| x; x \\<in> S|] ==> S >>| x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S >| x; x \\<in> S\\<rbrakk> \\<Longrightarrow> S >>| x", "by (erule is_glbI, erule (1) is_lbD)"], ["", "lemma glb_maximal: \"[|S >| x; x \\<in> S|] ==> glb S = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S >| x; x \\<in> S\\<rbrakk> \\<Longrightarrow> \\<Sqinter>S = x", "by (rule is_glb_maximal [THEN glb_eqI])"], ["", "lemma glb_above: \"S >>| z \\<Longrightarrow> x \\<sqsubseteq> glb S \\<longleftrightarrow> S >| x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S >>| z \\<Longrightarrow> (x \\<sqsubseteq> \\<Sqinter>S) = S >| x", "by (metis glb_eqI is_glb_above_iff)"], ["", "end"], ["", "lemma (in cpo) Meet_insert: \"S >>| l \\<Longrightarrow> {x, l} >>| l2 \\<Longrightarrow> insert x S >>| l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S >>| l; {x, l} >>| l2\\<rbrakk>\n    \\<Longrightarrow> insert x S >>| l2", "apply (rule is_glbI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>S >>| l; {x, l} >>| l2\\<rbrakk>\n    \\<Longrightarrow> insert x S >| l2\n 2. \\<And>u.\n       \\<lbrakk>S >>| l; {x, l} >>| l2; insert x S >| u\\<rbrakk>\n       \\<Longrightarrow> u \\<sqsubseteq> l2", "apply (metis is_glb_above_iff is_glb_def is_lb_insert)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>S >>| l; {x, l} >>| l2; insert x S >| u\\<rbrakk>\n       \\<Longrightarrow> u \\<sqsubseteq> l2", "by (metis is_glb_above_iff is_glb_def is_glb_singleton is_lb_insert)"], ["", "text \\<open>Binary, hence finite meets.\\<close>"], ["", "class Finite_Meet_cpo = cpo +\n  assumes binary_meet_exists: \"\\<exists> l. l \\<sqsubseteq> x \\<and> l \\<sqsubseteq> y \\<and> (\\<forall> z. z \\<sqsubseteq> x \\<longrightarrow> z \\<sqsubseteq> y \\<longrightarrow> z \\<sqsubseteq> l)\"\nbegin"], ["", "lemma binary_meet_exists': \"\\<exists>l. {x, y} >>| l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l. {x, y} >>| l", "using binary_meet_exists[of x y]"], ["proof (prove)\nusing this:\n  \\<exists>l.\n     l \\<sqsubseteq> x \\<and>\n     l \\<sqsubseteq> y \\<and>\n     (\\<forall>z.\n         z \\<sqsubseteq> x \\<longrightarrow>\n         z \\<sqsubseteq> y \\<longrightarrow> z \\<sqsubseteq> l)\n\ngoal (1 subgoal):\n 1. \\<exists>l. {x, y} >>| l", "unfolding is_glb_def is_lb_def"], ["proof (prove)\nusing this:\n  \\<exists>l.\n     l \\<sqsubseteq> x \\<and>\n     l \\<sqsubseteq> y \\<and>\n     (\\<forall>z.\n         z \\<sqsubseteq> x \\<longrightarrow>\n         z \\<sqsubseteq> y \\<longrightarrow> z \\<sqsubseteq> l)\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       Ball {x, y} ((\\<sqsubseteq>) l) \\<and>\n       (\\<forall>u.\n           Ball {x, y} ((\\<sqsubseteq>) u) \\<longrightarrow>\n           u \\<sqsubseteq> l)", "by auto"], ["", "lemma finite_meet_exists:\n    assumes \"S \\<noteq> {}\"\n    and \"finite S\"\n    shows \"\\<exists>x. S >>| x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. S >>| x", "using \\<open>S \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>x. S >>| x", "apply (induct rule: finite_induct[OF \\<open>finite S\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. {} \\<noteq> {} \\<Longrightarrow> Ex ((>>|) {})\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow> Ex ((>>|) F);\n        insert x F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> Ex ((>>|) (insert x F))", "apply (erule notE, rule refl)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow> Ex ((>>|) F);\n        insert x F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> Ex ((>>|) (insert x F))", "apply (case_tac \"F = {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow> Ex ((>>|) F);\n        insert x F \\<noteq> {}; F = {}\\<rbrakk>\n       \\<Longrightarrow> Ex ((>>|) (insert x F))\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow> Ex ((>>|) F);\n        insert x F \\<noteq> {}; F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> Ex ((>>|) (insert x F))", "apply (metis is_glb_singleton)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow> Ex ((>>|) F);\n        insert x F \\<noteq> {}; F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> Ex ((>>|) (insert x F))", "apply (metis Meet_insert binary_meet_exists')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "definition meet :: \"'a::cpo \\<Rightarrow> 'a \\<Rightarrow> 'a\" (infix \"\\<sqinter>\" 80) where\n  \"x \\<sqinter> y = (if \\<exists> z. {x, y} >>| z then glb {x, y} else x)\""], ["", "lemma meet_def': \"(x::'a::Finite_Meet_cpo) \\<sqinter> y = glb {x, y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> y = \\<Sqinter>{x, y}", "unfolding meet_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Ex ((>>|) {x, y}) then \\<Sqinter>{x, y} else x) = \\<Sqinter>{x, y}", "by (metis binary_meet_exists')"], ["", "lemma meet_comm: \"(x::'a::Finite_Meet_cpo) \\<sqinter> y = y \\<sqinter> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> y = y \\<sqinter> x", "unfolding meet_def'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter>{x, y} = \\<Sqinter>{y, x}", "by (metis insert_commute)"], ["", "lemma meet_bot1[simp]:\n  fixes y :: \"'a :: {Finite_Meet_cpo,pcpo}\"\n  shows \"(\\<bottom> \\<sqinter> y) = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> \\<sqinter> y = \\<bottom>", "unfolding meet_def'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter>{\\<bottom>, y} = \\<bottom>", "by (metis minimal po_class.glb_bin)"], ["", "lemma meet_bot2[simp]:\n  fixes x :: \"'a :: {Finite_Meet_cpo,pcpo}\"\n  shows \"(x \\<sqinter> \\<bottom>) = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> \\<bottom> = \\<bottom>", "by (metis meet_bot1 meet_comm)"], ["", "lemma meet_below1[intro]:\n  fixes x y :: \"'a :: Finite_Meet_cpo\"\n  assumes \"x \\<sqsubseteq> z\"\n  shows \"(x \\<sqinter> y) \\<sqsubseteq> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> y \\<sqsubseteq> z", "unfolding meet_def'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter>{x, y} \\<sqsubseteq> z", "by (metis assms binary_meet_exists' below_trans glb_eqI is_glbD1 is_lb_insert)"], ["", "lemma meet_below2[intro]:\n  fixes x y :: \"'a :: Finite_Meet_cpo\"\n  assumes \"y \\<sqsubseteq> z\"\n  shows \"(x \\<sqinter> y) \\<sqsubseteq> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> y \\<sqsubseteq> z", "unfolding meet_def'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter>{x, y} \\<sqsubseteq> z", "by (metis assms binary_meet_exists' below_trans glb_eqI is_glbD1 is_lb_insert)"], ["", "lemma meet_above_iff:\n  fixes x y z :: \"'a :: Finite_Meet_cpo\"\n  shows \"z \\<sqsubseteq> x \\<sqinter> y \\<longleftrightarrow> z \\<sqsubseteq> x \\<and> z \\<sqsubseteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z \\<sqsubseteq> x \\<sqinter> y) =\n    (z \\<sqsubseteq> x \\<and> z \\<sqsubseteq> y)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (z \\<sqsubseteq> x \\<sqinter> y) =\n    (z \\<sqsubseteq> x \\<and> z \\<sqsubseteq> y)", "obtain g where \"{x,y} >>| g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g. {x, y} >>| g \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis binary_meet_exists')"], ["proof (state)\nthis:\n  {x, y} >>| g\n\ngoal (1 subgoal):\n 1. (z \\<sqsubseteq> x \\<sqinter> y) =\n    (z \\<sqsubseteq> x \\<and> z \\<sqsubseteq> y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  {x, y} >>| g\n\ngoal (1 subgoal):\n 1. (z \\<sqsubseteq> x \\<sqinter> y) =\n    (z \\<sqsubseteq> x \\<and> z \\<sqsubseteq> y)", "unfolding meet_def'"], ["proof (prove)\nusing this:\n  {x, y} >>| g\n\ngoal (1 subgoal):\n 1. (z \\<sqsubseteq> \\<Sqinter>{x, y}) =\n    (z \\<sqsubseteq> x \\<and> z \\<sqsubseteq> y)", "by (simp add: glb_above)"], ["proof (state)\nthis:\n  (z \\<sqsubseteq> x \\<sqinter> y) =\n  (z \\<sqsubseteq> x \\<and> z \\<sqsubseteq> y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma below_meet[simp]:\n  fixes x y :: \"'a :: Finite_Meet_cpo\"\n  assumes \"x \\<sqsubseteq> z\"\n  shows \"(x \\<sqinter> z) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> z = x", "by (metis assms glb_bin meet_def')"], ["", "lemma below_meet2[simp]:\n  fixes x y :: \"'a :: Finite_Meet_cpo\"\n  assumes \"z \\<sqsubseteq> x\"\n  shows \"(x \\<sqinter> z) = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> z = z", "by (metis assms below_meet meet_comm)"], ["", "lemma meet_aboveI:\n  fixes x y z :: \"'a :: Finite_Meet_cpo\"\n  shows \"z \\<sqsubseteq> x \\<Longrightarrow> z \\<sqsubseteq> y \\<Longrightarrow> z \\<sqsubseteq> x \\<sqinter> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<sqsubseteq> x; z \\<sqsubseteq> y\\<rbrakk>\n    \\<Longrightarrow> z \\<sqsubseteq> x \\<sqinter> y", "by (simp add: meet_above_iff)"], ["", "lemma is_meetI:\n  fixes x y z :: \"'a :: Finite_Meet_cpo\"\n  assumes \"z \\<sqsubseteq> x\"\n  assumes \"z \\<sqsubseteq> y\"\n  assumes \"\\<And> a. \\<lbrakk> a \\<sqsubseteq> x ; a \\<sqsubseteq> y \\<rbrakk> \\<Longrightarrow> a \\<sqsubseteq> z\"\n  shows \"x \\<sqinter> y = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> y = z", "by (metis assms below_antisym meet_above_iff below_refl)"], ["", "lemma meet_assoc[simp]: \"((x::'a::Finite_Meet_cpo) \\<sqinter> y) \\<sqinter> z = x \\<sqinter> (y \\<sqinter> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> y) \\<sqinter> z = x \\<sqinter> (y \\<sqinter> z)", "apply (rule is_meetI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<sqinter> (y \\<sqinter> z) \\<sqsubseteq> x \\<sqinter> y\n 2. x \\<sqinter> (y \\<sqinter> z) \\<sqsubseteq> z\n 3. \\<And>a.\n       \\<lbrakk>a \\<sqsubseteq> x \\<sqinter> y; a \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> a \\<sqsubseteq> x \\<sqinter> (y \\<sqinter> z)", "apply (metis below_refl meet_above_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<sqinter> (y \\<sqinter> z) \\<sqsubseteq> z\n 2. \\<And>a.\n       \\<lbrakk>a \\<sqsubseteq> x \\<sqinter> y; a \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> a \\<sqsubseteq> x \\<sqinter> (y \\<sqinter> z)", "apply (metis below_refl meet_below2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<sqsubseteq> x \\<sqinter> y; a \\<sqsubseteq> z\\<rbrakk>\n       \\<Longrightarrow> a \\<sqsubseteq> x \\<sqinter> (y \\<sqinter> z)", "apply (metis meet_above_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma meet_self[simp]: \"r \\<sqinter> r = (r::'a::Finite_Meet_cpo)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<sqinter> r = r", "by (metis below_refl is_meetI)"], ["", "lemma [simp]: \"(r::'a::Finite_Meet_cpo) \\<sqinter> (r \\<sqinter> x) = r \\<sqinter> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<sqinter> (r \\<sqinter> x) = r \\<sqinter> x", "by (metis below_refl is_meetI meet_below1)"], ["", "lemma meet_monofun1:\n  fixes y :: \"'a :: Finite_Meet_cpo\"\n  shows \"monofun (\\<lambda>x. (x \\<sqinter> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monofun (\\<lambda>x. x \\<sqinter> y)", "by (rule monofunI)(auto simp add: meet_above_iff)"], ["", "lemma chain_meet1:\n  fixes y :: \"'a :: Finite_Meet_cpo\"\n  assumes \"chain Y\"\n  shows \"chain (\\<lambda> i. Y i \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain (\\<lambda>i. Y i \\<sqinter> y)", "by (rule chainI) (auto simp add: meet_above_iff intro: chainI chainE[OF assms])"], ["", "class cont_binary_meet = Finite_Meet_cpo +\n  assumes meet_cont': \"chain Y \\<Longrightarrow> (\\<Squnion> i. Y i) \\<sqinter> y = (\\<Squnion> i. Y i \\<sqinter> y)\""], ["", "lemma meet_cont1:\n  fixes y :: \"'a :: cont_binary_meet\"\n  shows \"cont (\\<lambda>x. (x \\<sqinter> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. x \\<sqinter> y)", "by (rule contI2[OF meet_monofun1]) (simp add: meet_cont')"], ["", "lemma meet_cont2: \n  fixes x :: \"'a :: cont_binary_meet\"\n  shows \"cont (\\<lambda>y. (x \\<sqinter> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont ((\\<sqinter>) x)", "by (subst meet_comm, rule meet_cont1)"], ["", "lemma meet_cont[cont2cont,simp]:\"cont f \\<Longrightarrow> cont g \\<Longrightarrow> cont (\\<lambda>x. (f x \\<sqinter> (g x::'a::cont_binary_meet)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cont f; cont g\\<rbrakk>\n    \\<Longrightarrow> cont (\\<lambda>x. f x \\<sqinter> g x)", "apply (rule cont2cont_case_prod[where g = \"\\<lambda> x. (f x, g x)\" and f = \"\\<lambda> p x y . x \\<sqinter> y\", simplified])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>cont f; cont g\\<rbrakk>\n       \\<Longrightarrow> cont (\\<lambda>a. a \\<sqinter> b)\n 2. \\<And>a.\n       \\<lbrakk>cont f; cont g\\<rbrakk>\n       \\<Longrightarrow> cont ((\\<sqinter>) a)\n 3. \\<lbrakk>cont f; cont g\\<rbrakk>\n    \\<Longrightarrow> cont (\\<lambda>x. (f x, g x))", "apply (rule meet_cont1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>cont f; cont g\\<rbrakk>\n       \\<Longrightarrow> cont ((\\<sqinter>) a)\n 2. \\<lbrakk>cont f; cont g\\<rbrakk>\n    \\<Longrightarrow> cont (\\<lambda>x. (f x, g x))", "apply (rule meet_cont2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cont f; cont g\\<rbrakk>\n    \\<Longrightarrow> cont (\\<lambda>x. (f x, g x))", "apply (metis cont2cont_Pair)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}