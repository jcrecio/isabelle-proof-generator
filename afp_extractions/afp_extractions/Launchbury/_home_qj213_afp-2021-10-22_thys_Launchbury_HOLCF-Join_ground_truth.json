{"file_name": "/home/qj213/afp-2021-10-22/thys/Launchbury/HOLCF-Join.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Launchbury", "problem_names": ["lemma compatibleI:\n  assumes \"x \\<sqsubseteq> z\"\n  assumes \"y \\<sqsubseteq> z\"\n  assumes \"\\<And> a. \\<lbrakk> x \\<sqsubseteq> a ; y \\<sqsubseteq> a \\<rbrakk> \\<Longrightarrow> z \\<sqsubseteq> a\"\n  shows \"compatible x y\"", "lemma is_joinI:\n  assumes \"x \\<sqsubseteq> z\"\n  assumes \"y \\<sqsubseteq> z\"\n  assumes \"\\<And> a. \\<lbrakk> x \\<sqsubseteq> a ; y \\<sqsubseteq> a \\<rbrakk> \\<Longrightarrow> z \\<sqsubseteq> a\"\n  shows \"x \\<squnion> y = z\"", "lemma is_join_and_compatible:\n  assumes \"x \\<sqsubseteq> z\"\n  assumes \"y \\<sqsubseteq> z\"\n  assumes \"\\<And> a. \\<lbrakk> x \\<sqsubseteq> a ; y \\<sqsubseteq> a \\<rbrakk> \\<Longrightarrow> z \\<sqsubseteq> a\"\n  shows \"compatible x y \\<and> x \\<squnion> y = z\"", "lemma compatible_sym: \"compatible x y \\<Longrightarrow> compatible y x\"", "lemma compatible_sym_iff: \"compatible x y \\<longleftrightarrow> compatible y x\"", "lemma join_above1: \"compatible x y \\<Longrightarrow> x \\<sqsubseteq> x \\<squnion> y\"", "lemma join_above2: \"compatible x y \\<Longrightarrow> y \\<sqsubseteq> x \\<squnion> y\"", "lemma larger_is_join1: \"y \\<sqsubseteq> x \\<Longrightarrow> x \\<squnion> y = x\"", "lemma larger_is_join2: \"x \\<sqsubseteq> y \\<Longrightarrow> x \\<squnion> y = y\"", "lemma join_self[simp]: \"x \\<squnion> x = x\"", "lemma join_commute:  \"compatible x y \\<Longrightarrow> x \\<squnion> y = y \\<squnion> x\"", "lemma lub_is_join:\n  \"{x, y} <<| z \\<Longrightarrow> x \\<squnion> y = z\"", "lemma compatible_refl[simp]: \"compatible x x\"", "lemma join_mono:\n  assumes \"compatible a b\"\n  and \"compatible c d\"\n  and \"a \\<sqsubseteq> c\"\n  and \"b \\<sqsubseteq> d\"\n  shows \"a \\<squnion> b \\<sqsubseteq> c \\<squnion> d\"", "lemma\n  assumes \"compatible x y\"\n  shows join_above1: \"x \\<sqsubseteq> x \\<squnion> y\" and join_above2: \"y \\<sqsubseteq> x \\<squnion> y\"", "lemma\n  assumes \"compatible x y\"\n  shows compatible_above1: \"compatible x (x \\<squnion> y)\" and compatible_above2: \"compatible y (x \\<squnion> y)\"", "lemma join_below:\n  assumes \"compatible x y\"\n  and \"x \\<sqsubseteq> a\" and \"y \\<sqsubseteq> a\"\n  shows \"x \\<squnion> y \\<sqsubseteq> a\"", "lemma join_below_iff:\n  assumes \"compatible x y\"\n  shows \"x \\<squnion> y \\<sqsubseteq> a \\<longleftrightarrow> (x \\<sqsubseteq> a \\<and> y \\<sqsubseteq> a)\"", "lemma join_assoc:\n  assumes \"compatible x y\"\n  assumes \"compatible x (y \\<squnion> z)\"\n  assumes \"compatible y z\"\n  shows \"(x \\<squnion> y) \\<squnion> z = x \\<squnion> (y \\<squnion> z)\"", "lemma join_idem[simp]: \"compatible x y \\<Longrightarrow> x \\<squnion> (x \\<squnion> y) = x \\<squnion> y\"", "lemma join_bottom[simp]: \"x \\<squnion> \\<bottom> = x\" \"\\<bottom> \\<squnion> x = x\"", "lemma compatible_adm2:\n  shows \"adm (\\<lambda> y. compatible x y)\"", "lemma compatible_adm1: \"adm (\\<lambda> x. compatible x y)\"", "lemma join_cont1:\n  assumes \"chain Y\"\n  assumes compat: \"\\<And> i. compatible (Y i) y\"\n  shows \"(\\<Squnion>i. Y i) \\<squnion> y = (\\<Squnion> i. Y i \\<squnion> y)\"", "lemma join_cont2:\n  assumes \"chain Y\"\n  assumes compat: \"\\<And> i. compatible x (Y i)\"\n  shows \"x \\<squnion> (\\<Squnion>i. Y i) = (\\<Squnion> i. x \\<squnion> Y i)\"", "lemma join_cont12:\n  assumes \"chain Y\" and \"chain Z\"\n  assumes compat: \"\\<And> i j. compatible (Y i) (Z j)\"\n  shows \"(\\<Squnion>i. Y i) \\<squnion> (\\<Squnion>i. Z i) = (\\<Squnion> i. Y i  \\<squnion> Z i)\"", "lemma bot_compatible[simp]:\n    \"compatible x \\<bottom>\" \"compatible \\<bottom> x\""], "translations": [["", "lemma compatibleI:\n  assumes \"x \\<sqsubseteq> z\"\n  assumes \"y \\<sqsubseteq> z\"\n  assumes \"\\<And> a. \\<lbrakk> x \\<sqsubseteq> a ; y \\<sqsubseteq> a \\<rbrakk> \\<Longrightarrow> z \\<sqsubseteq> a\"\n  shows \"compatible x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compatible x y", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. compatible x y", "from assms"], ["proof (chain)\npicking this:\n  x \\<sqsubseteq> z\n  y \\<sqsubseteq> z\n  \\<lbrakk>x \\<sqsubseteq> ?a; y \\<sqsubseteq> ?a\\<rbrakk>\n  \\<Longrightarrow> z \\<sqsubseteq> ?a", "have \"{x,y} <<| z\""], ["proof (prove)\nusing this:\n  x \\<sqsubseteq> z\n  y \\<sqsubseteq> z\n  \\<lbrakk>x \\<sqsubseteq> ?a; y \\<sqsubseteq> ?a\\<rbrakk>\n  \\<Longrightarrow> z \\<sqsubseteq> ?a\n\ngoal (1 subgoal):\n 1. {x, y} <<| z", "by (auto intro: is_lubI)"], ["proof (state)\nthis:\n  {x, y} <<| z\n\ngoal (1 subgoal):\n 1. compatible x y", "thus ?thesis"], ["proof (prove)\nusing this:\n  {x, y} <<| z\n\ngoal (1 subgoal):\n 1. compatible x y", "unfolding compatible_def"], ["proof (prove)\nusing this:\n  {x, y} <<| z\n\ngoal (1 subgoal):\n 1. Ex ((<<|) {x, y})", "by (metis)"], ["proof (state)\nthis:\n  compatible x y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_joinI:\n  assumes \"x \\<sqsubseteq> z\"\n  assumes \"y \\<sqsubseteq> z\"\n  assumes \"\\<And> a. \\<lbrakk> x \\<sqsubseteq> a ; y \\<sqsubseteq> a \\<rbrakk> \\<Longrightarrow> z \\<sqsubseteq> a\"\n  shows \"x \\<squnion> y = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> y = z", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<squnion> y = z", "from assms"], ["proof (chain)\npicking this:\n  x \\<sqsubseteq> z\n  y \\<sqsubseteq> z\n  \\<lbrakk>x \\<sqsubseteq> ?a; y \\<sqsubseteq> ?a\\<rbrakk>\n  \\<Longrightarrow> z \\<sqsubseteq> ?a", "have \"{x,y} <<| z\""], ["proof (prove)\nusing this:\n  x \\<sqsubseteq> z\n  y \\<sqsubseteq> z\n  \\<lbrakk>x \\<sqsubseteq> ?a; y \\<sqsubseteq> ?a\\<rbrakk>\n  \\<Longrightarrow> z \\<sqsubseteq> ?a\n\ngoal (1 subgoal):\n 1. {x, y} <<| z", "by (auto intro: is_lubI)"], ["proof (state)\nthis:\n  {x, y} <<| z\n\ngoal (1 subgoal):\n 1. x \\<squnion> y = z", "thus ?thesis"], ["proof (prove)\nusing this:\n  {x, y} <<| z\n\ngoal (1 subgoal):\n 1. x \\<squnion> y = z", "unfolding join_def"], ["proof (prove)\nusing this:\n  {x, y} <<| z\n\ngoal (1 subgoal):\n 1. (if Ex ((<<|) {x, y}) then lub {x, y} else x) = z", "by (metis lub_eqI)"], ["proof (state)\nthis:\n  x \\<squnion> y = z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_join_and_compatible:\n  assumes \"x \\<sqsubseteq> z\"\n  assumes \"y \\<sqsubseteq> z\"\n  assumes \"\\<And> a. \\<lbrakk> x \\<sqsubseteq> a ; y \\<sqsubseteq> a \\<rbrakk> \\<Longrightarrow> z \\<sqsubseteq> a\"\n  shows \"compatible x y \\<and> x \\<squnion> y = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compatible x y \\<and> x \\<squnion> y = z", "by (metis compatibleI is_joinI assms)"], ["", "lemma compatible_sym: \"compatible x y \\<Longrightarrow> compatible y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compatible x y \\<Longrightarrow> compatible y x", "unfolding compatible_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex ((<<|) {x, y}) \\<Longrightarrow> Ex ((<<|) {y, x})", "by (metis insert_commute)"], ["", "lemma compatible_sym_iff: \"compatible x y \\<longleftrightarrow> compatible y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compatible x y = compatible y x", "unfolding compatible_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex ((<<|) {x, y}) = Ex ((<<|) {y, x})", "by (metis insert_commute)"], ["", "lemma join_above1: \"compatible x y \\<Longrightarrow> x \\<sqsubseteq> x \\<squnion> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compatible x y \\<Longrightarrow> x \\<sqsubseteq> x \\<squnion> y", "unfolding compatible_def join_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex ((<<|) {x, y}) \\<Longrightarrow>\n    x \\<sqsubseteq> (if Ex ((<<|) {x, y}) then lub {x, y} else x)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa. {x, y} <<| xa \\<Longrightarrow> x \\<sqsubseteq> lub {x, y}", "by (metis is_lubD1 is_ub_insert lub_eqI)"], ["", "lemma join_above2: \"compatible x y \\<Longrightarrow> y \\<sqsubseteq> x \\<squnion> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compatible x y \\<Longrightarrow> y \\<sqsubseteq> x \\<squnion> y", "unfolding compatible_def join_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex ((<<|) {x, y}) \\<Longrightarrow>\n    y \\<sqsubseteq> (if Ex ((<<|) {x, y}) then lub {x, y} else x)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa. {x, y} <<| xa \\<Longrightarrow> y \\<sqsubseteq> lub {x, y}", "by (metis is_lubD1 is_ub_insert lub_eqI)"], ["", "lemma larger_is_join1: \"y \\<sqsubseteq> x \\<Longrightarrow> x \\<squnion> y = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sqsubseteq> x \\<Longrightarrow> x \\<squnion> y = x", "unfolding join_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sqsubseteq> x \\<Longrightarrow>\n    (if Ex ((<<|) {x, y}) then lub {x, y} else x) = x", "by (metis doubleton_eq_iff lub_bin)"], ["", "lemma larger_is_join2: \"x \\<sqsubseteq> y \\<Longrightarrow> x \\<squnion> y = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> y \\<Longrightarrow> x \\<squnion> y = y", "unfolding join_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> y \\<Longrightarrow>\n    (if Ex ((<<|) {x, y}) then lub {x, y} else x) = y", "by (metis is_lub_bin lub_bin)"], ["", "lemma join_self[simp]: \"x \\<squnion> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> x = x", "unfolding join_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Ex ((<<|) {x, x}) then lub {x, x} else x) = x", "by auto"], ["", "end"], ["", "lemma join_commute:  \"compatible x y \\<Longrightarrow> x \\<squnion> y = y \\<squnion> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compatible x y \\<Longrightarrow> x \\<squnion> y = y \\<squnion> x", "unfolding compatible_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex ((<<|) {x, y}) \\<Longrightarrow> x \\<squnion> y = y \\<squnion> x", "unfolding join_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex ((<<|) {x, y}) \\<Longrightarrow>\n    (if Ex ((<<|) {x, y}) then lub {x, y} else x) =\n    (if Ex ((<<|) {y, x}) then lub {y, x} else y)", "by (metis insert_commute)"], ["", "lemma lub_is_join:\n  \"{x, y} <<| z \\<Longrightarrow> x \\<squnion> y = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x, y} <<| z \\<Longrightarrow> x \\<squnion> y = z", "unfolding join_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x, y} <<| z \\<Longrightarrow>\n    (if Ex ((<<|) {x, y}) then lub {x, y} else x) = z", "by (metis lub_eqI)"], ["", "lemma compatible_refl[simp]: \"compatible x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compatible x x", "by (rule compatibleI[OF below_refl below_refl])"], ["", "lemma join_mono:\n  assumes \"compatible a b\"\n  and \"compatible c d\"\n  and \"a \\<sqsubseteq> c\"\n  and \"b \\<sqsubseteq> d\"\n  shows \"a \\<squnion> b \\<sqsubseteq> c \\<squnion> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<squnion> b \\<sqsubseteq> c \\<squnion> d", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<squnion> b \\<sqsubseteq> c \\<squnion> d", "from assms"], ["proof (chain)\npicking this:\n  compatible a b\n  compatible c d\n  a \\<sqsubseteq> c\n  b \\<sqsubseteq> d", "obtain x y where \"{a, b} <<| x\" \"{c, d} <<| y\""], ["proof (prove)\nusing this:\n  compatible a b\n  compatible c d\n  a \\<sqsubseteq> c\n  b \\<sqsubseteq> d\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>{a, b} <<| x; {c, d} <<| y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding compatible_def"], ["proof (prove)\nusing this:\n  Ex ((<<|) {a, b})\n  Ex ((<<|) {c, d})\n  a \\<sqsubseteq> c\n  b \\<sqsubseteq> d\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>{a, b} <<| x; {c, d} <<| y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  {a, b} <<| x\n  {c, d} <<| y\n\ngoal (1 subgoal):\n 1. a \\<squnion> b \\<sqsubseteq> c \\<squnion> d", "with assms"], ["proof (chain)\npicking this:\n  compatible a b\n  compatible c d\n  a \\<sqsubseteq> c\n  b \\<sqsubseteq> d\n  {a, b} <<| x\n  {c, d} <<| y", "have \"a \\<sqsubseteq> y\" \"b \\<sqsubseteq> y\""], ["proof (prove)\nusing this:\n  compatible a b\n  compatible c d\n  a \\<sqsubseteq> c\n  b \\<sqsubseteq> d\n  {a, b} <<| x\n  {c, d} <<| y\n\ngoal (1 subgoal):\n 1. a \\<sqsubseteq> y &&& b \\<sqsubseteq> y", "by (metis below.r_trans is_lubD1 is_ub_insert)+"], ["proof (state)\nthis:\n  a \\<sqsubseteq> y\n  b \\<sqsubseteq> y\n\ngoal (1 subgoal):\n 1. a \\<squnion> b \\<sqsubseteq> c \\<squnion> d", "with \\<open>{a, b} <<| x\\<close>"], ["proof (chain)\npicking this:\n  {a, b} <<| x\n  a \\<sqsubseteq> y\n  b \\<sqsubseteq> y", "have \"x \\<sqsubseteq> y\""], ["proof (prove)\nusing this:\n  {a, b} <<| x\n  a \\<sqsubseteq> y\n  b \\<sqsubseteq> y\n\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> y", "by (metis is_lub_below_iff is_lub_singleton is_ub_insert)"], ["proof (state)\nthis:\n  x \\<sqsubseteq> y\n\ngoal (1 subgoal):\n 1. a \\<squnion> b \\<sqsubseteq> c \\<squnion> d", "moreover"], ["proof (state)\nthis:\n  x \\<sqsubseteq> y\n\ngoal (1 subgoal):\n 1. a \\<squnion> b \\<sqsubseteq> c \\<squnion> d", "from \\<open>{a, b} <<| x\\<close> \\<open>{c, d} <<| y\\<close>"], ["proof (chain)\npicking this:\n  {a, b} <<| x\n  {c, d} <<| y", "have \"a \\<squnion> b = x\" \"c \\<squnion> d = y\""], ["proof (prove)\nusing this:\n  {a, b} <<| x\n  {c, d} <<| y\n\ngoal (1 subgoal):\n 1. a \\<squnion> b = x &&& c \\<squnion> d = y", "by (metis lub_is_join)+"], ["proof (state)\nthis:\n  a \\<squnion> b = x\n  c \\<squnion> d = y\n\ngoal (1 subgoal):\n 1. a \\<squnion> b \\<sqsubseteq> c \\<squnion> d", "ultimately"], ["proof (chain)\npicking this:\n  x \\<sqsubseteq> y\n  a \\<squnion> b = x\n  c \\<squnion> d = y", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<sqsubseteq> y\n  a \\<squnion> b = x\n  c \\<squnion> d = y\n\ngoal (1 subgoal):\n 1. a \\<squnion> b \\<sqsubseteq> c \\<squnion> d", "by simp"], ["proof (state)\nthis:\n  a \\<squnion> b \\<sqsubseteq> c \\<squnion> d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  assumes \"compatible x y\"\n  shows join_above1: \"x \\<sqsubseteq> x \\<squnion> y\" and join_above2: \"y \\<sqsubseteq> x \\<squnion> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> x \\<squnion> y &&& y \\<sqsubseteq> x \\<squnion> y", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<sqsubseteq> x \\<squnion> y\n 2. y \\<sqsubseteq> x \\<squnion> y", "from assms"], ["proof (chain)\npicking this:\n  compatible x y", "obtain z where \"{x,y} <<| z\""], ["proof (prove)\nusing this:\n  compatible x y\n\ngoal (1 subgoal):\n 1. (\\<And>z. {x, y} <<| z \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding compatible_def"], ["proof (prove)\nusing this:\n  Ex ((<<|) {x, y})\n\ngoal (1 subgoal):\n 1. (\\<And>z. {x, y} <<| z \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  {x, y} <<| z\n\ngoal (2 subgoals):\n 1. x \\<sqsubseteq> x \\<squnion> y\n 2. y \\<sqsubseteq> x \\<squnion> y", "hence  \"x \\<squnion> y = z\" and \"x \\<sqsubseteq> z\" and \"y \\<sqsubseteq> z\""], ["proof (prove)\nusing this:\n  {x, y} <<| z\n\ngoal (1 subgoal):\n 1. x \\<squnion> y = z &&& x \\<sqsubseteq> z &&& y \\<sqsubseteq> z", "apply (auto intro: lub_is_join)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {x, y} <<| z \\<Longrightarrow> x \\<sqsubseteq> z\n 2. {x, y} <<| z \\<Longrightarrow> y \\<sqsubseteq> z", "by (metis is_lubD1 is_ub_insert)+"], ["proof (state)\nthis:\n  x \\<squnion> y = z\n  x \\<sqsubseteq> z\n  y \\<sqsubseteq> z\n\ngoal (2 subgoals):\n 1. x \\<sqsubseteq> x \\<squnion> y\n 2. y \\<sqsubseteq> x \\<squnion> y", "thus \"x \\<sqsubseteq> x \\<squnion> y\" and \"y \\<sqsubseteq> x \\<squnion> y\""], ["proof (prove)\nusing this:\n  x \\<squnion> y = z\n  x \\<sqsubseteq> z\n  y \\<sqsubseteq> z\n\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> x \\<squnion> y &&& y \\<sqsubseteq> x \\<squnion> y", "by simp_all"], ["proof (state)\nthis:\n  x \\<sqsubseteq> x \\<squnion> y\n  y \\<sqsubseteq> x \\<squnion> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  assumes \"compatible x y\"\n  shows compatible_above1: \"compatible x (x \\<squnion> y)\" and compatible_above2: \"compatible y (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compatible x (x \\<squnion> y) &&& compatible y (x \\<squnion> y)", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. compatible x (x \\<squnion> y)\n 2. compatible y (x \\<squnion> y)", "from assms"], ["proof (chain)\npicking this:\n  compatible x y", "obtain z where \"{x,y} <<| z\""], ["proof (prove)\nusing this:\n  compatible x y\n\ngoal (1 subgoal):\n 1. (\\<And>z. {x, y} <<| z \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding compatible_def"], ["proof (prove)\nusing this:\n  Ex ((<<|) {x, y})\n\ngoal (1 subgoal):\n 1. (\\<And>z. {x, y} <<| z \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  {x, y} <<| z\n\ngoal (2 subgoals):\n 1. compatible x (x \\<squnion> y)\n 2. compatible y (x \\<squnion> y)", "hence  \"x \\<squnion> y = z\" and \"x \\<sqsubseteq> z\" and \"y \\<sqsubseteq> z\""], ["proof (prove)\nusing this:\n  {x, y} <<| z\n\ngoal (1 subgoal):\n 1. x \\<squnion> y = z &&& x \\<sqsubseteq> z &&& y \\<sqsubseteq> z", "apply (auto intro: lub_is_join)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {x, y} <<| z \\<Longrightarrow> x \\<sqsubseteq> z\n 2. {x, y} <<| z \\<Longrightarrow> y \\<sqsubseteq> z", "by (metis is_lubD1 is_ub_insert)+"], ["proof (state)\nthis:\n  x \\<squnion> y = z\n  x \\<sqsubseteq> z\n  y \\<sqsubseteq> z\n\ngoal (2 subgoals):\n 1. compatible x (x \\<squnion> y)\n 2. compatible y (x \\<squnion> y)", "thus  \"compatible x (x \\<squnion> y)\" and  \"compatible y (x \\<squnion> y)\""], ["proof (prove)\nusing this:\n  x \\<squnion> y = z\n  x \\<sqsubseteq> z\n  y \\<sqsubseteq> z\n\ngoal (1 subgoal):\n 1. compatible x (x \\<squnion> y) &&& compatible y (x \\<squnion> y)", "by (metis below.r_refl compatibleI)+"], ["proof (state)\nthis:\n  compatible x (x \\<squnion> y)\n  compatible y (x \\<squnion> y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma join_below:\n  assumes \"compatible x y\"\n  and \"x \\<sqsubseteq> a\" and \"y \\<sqsubseteq> a\"\n  shows \"x \\<squnion> y \\<sqsubseteq> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> y \\<sqsubseteq> a", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<squnion> y \\<sqsubseteq> a", "from assms"], ["proof (chain)\npicking this:\n  compatible x y\n  x \\<sqsubseteq> a\n  y \\<sqsubseteq> a", "obtain z where z: \"{x,y} <<| z\""], ["proof (prove)\nusing this:\n  compatible x y\n  x \\<sqsubseteq> a\n  y \\<sqsubseteq> a\n\ngoal (1 subgoal):\n 1. (\\<And>z. {x, y} <<| z \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding compatible_def"], ["proof (prove)\nusing this:\n  Ex ((<<|) {x, y})\n  x \\<sqsubseteq> a\n  y \\<sqsubseteq> a\n\ngoal (1 subgoal):\n 1. (\\<And>z. {x, y} <<| z \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  {x, y} <<| z\n\ngoal (1 subgoal):\n 1. x \\<squnion> y \\<sqsubseteq> a", "with assms"], ["proof (chain)\npicking this:\n  compatible x y\n  x \\<sqsubseteq> a\n  y \\<sqsubseteq> a\n  {x, y} <<| z", "have \"z \\<sqsubseteq> a\""], ["proof (prove)\nusing this:\n  compatible x y\n  x \\<sqsubseteq> a\n  y \\<sqsubseteq> a\n  {x, y} <<| z\n\ngoal (1 subgoal):\n 1. z \\<sqsubseteq> a", "by (metis is_lub_below_iff is_ub_empty is_ub_insert)"], ["proof (state)\nthis:\n  z \\<sqsubseteq> a\n\ngoal (1 subgoal):\n 1. x \\<squnion> y \\<sqsubseteq> a", "moreover"], ["proof (state)\nthis:\n  z \\<sqsubseteq> a\n\ngoal (1 subgoal):\n 1. x \\<squnion> y \\<sqsubseteq> a", "from z"], ["proof (chain)\npicking this:\n  {x, y} <<| z", "have \"x \\<squnion> y = z\""], ["proof (prove)\nusing this:\n  {x, y} <<| z\n\ngoal (1 subgoal):\n 1. x \\<squnion> y = z", "by (rule lub_is_join)"], ["proof (state)\nthis:\n  x \\<squnion> y = z\n\ngoal (1 subgoal):\n 1. x \\<squnion> y \\<sqsubseteq> a", "ultimately"], ["proof (chain)\npicking this:\n  z \\<sqsubseteq> a\n  x \\<squnion> y = z", "show ?thesis"], ["proof (prove)\nusing this:\n  z \\<sqsubseteq> a\n  x \\<squnion> y = z\n\ngoal (1 subgoal):\n 1. x \\<squnion> y \\<sqsubseteq> a", "by simp"], ["proof (state)\nthis:\n  x \\<squnion> y \\<sqsubseteq> a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma join_below_iff:\n  assumes \"compatible x y\"\n  shows \"x \\<squnion> y \\<sqsubseteq> a \\<longleftrightarrow> (x \\<sqsubseteq> a \\<and> y \\<sqsubseteq> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y \\<sqsubseteq> a) =\n    (x \\<sqsubseteq> a \\<and> y \\<sqsubseteq> a)", "by (metis assms below_trans cpo_class.join_above1 cpo_class.join_above2 join_below)"], ["", "lemma join_assoc:\n  assumes \"compatible x y\"\n  assumes \"compatible x (y \\<squnion> z)\"\n  assumes \"compatible y z\"\n  shows \"(x \\<squnion> y) \\<squnion> z = x \\<squnion> (y \\<squnion> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> y \\<squnion> z = x \\<squnion> (y \\<squnion> z)", "apply (rule is_joinI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<squnion> y \\<sqsubseteq> x \\<squnion> (y \\<squnion> z)\n 2. z \\<sqsubseteq> x \\<squnion> (y \\<squnion> z)\n 3. \\<And>a.\n       \\<lbrakk>x \\<squnion> y \\<sqsubseteq> a; z \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> (y \\<squnion> z) \\<sqsubseteq> a", "apply (rule join_mono[OF assms(1) assms(2) below_refl join_above1[OF assms(3)]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. z \\<sqsubseteq> x \\<squnion> (y \\<squnion> z)\n 2. \\<And>a.\n       \\<lbrakk>x \\<squnion> y \\<sqsubseteq> a; z \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> (y \\<squnion> z) \\<sqsubseteq> a", "apply (rule below_trans[OF join_above2[OF assms(3)] join_above2[OF assms(2)]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>x \\<squnion> y \\<sqsubseteq> a; z \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> (y \\<squnion> z) \\<sqsubseteq> a", "apply (rule join_below[OF assms(2)])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>x \\<squnion> y \\<sqsubseteq> a; z \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> a\n 2. \\<And>a.\n       \\<lbrakk>x \\<squnion> y \\<sqsubseteq> a; z \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<sqsubseteq> a", "apply (erule rev_below_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       z \\<sqsubseteq> a \\<Longrightarrow> x \\<sqsubseteq> x \\<squnion> y\n 2. \\<And>a.\n       \\<lbrakk>x \\<squnion> y \\<sqsubseteq> a; z \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<sqsubseteq> a", "apply (rule join_above1[OF assms(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>x \\<squnion> y \\<sqsubseteq> a; z \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<sqsubseteq> a", "apply (rule join_below[OF assms(3)])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>x \\<squnion> y \\<sqsubseteq> a; z \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> y \\<sqsubseteq> a\n 2. \\<And>a.\n       \\<lbrakk>x \\<squnion> y \\<sqsubseteq> a; z \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> z \\<sqsubseteq> a", "apply (erule rev_below_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       z \\<sqsubseteq> a \\<Longrightarrow> y \\<sqsubseteq> x \\<squnion> y\n 2. \\<And>a.\n       \\<lbrakk>x \\<squnion> y \\<sqsubseteq> a; z \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> z \\<sqsubseteq> a", "apply (rule join_above2[OF assms(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>x \\<squnion> y \\<sqsubseteq> a; z \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> z \\<sqsubseteq> a", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma join_idem[simp]: \"compatible x y \\<Longrightarrow> x \\<squnion> (x \\<squnion> y) = x \\<squnion> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compatible x y \\<Longrightarrow>\n    x \\<squnion> (x \\<squnion> y) = x \\<squnion> y", "apply (subst join_assoc[symmetric])"], ["proof (prove)\ngoal (4 subgoals):\n 1. compatible x y \\<Longrightarrow> compatible x x\n 2. compatible x y \\<Longrightarrow> compatible x (x \\<squnion> y)\n 3. compatible x y \\<Longrightarrow> compatible x y\n 4. compatible x y \\<Longrightarrow>\n    x \\<squnion> x \\<squnion> y = x \\<squnion> y", "apply (rule compatible_refl)"], ["proof (prove)\ngoal (3 subgoals):\n 1. compatible x y \\<Longrightarrow> compatible x (x \\<squnion> y)\n 2. compatible x y \\<Longrightarrow> compatible x y\n 3. compatible x y \\<Longrightarrow>\n    x \\<squnion> x \\<squnion> y = x \\<squnion> y", "apply (erule compatible_above1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. compatible x y \\<Longrightarrow> compatible x y\n 2. compatible x y \\<Longrightarrow>\n    x \\<squnion> x \\<squnion> y = x \\<squnion> y", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. compatible x y \\<Longrightarrow>\n    x \\<squnion> x \\<squnion> y = x \\<squnion> y", "apply (subst join_self)"], ["proof (prove)\ngoal (1 subgoal):\n 1. compatible x y \\<Longrightarrow> x \\<squnion> y = x \\<squnion> y", "apply rule"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma join_bottom[simp]: \"x \\<squnion> \\<bottom> = x\" \"\\<bottom> \\<squnion> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> \\<bottom> = x &&& \\<bottom> \\<squnion> x = x", "by (auto intro: is_joinI)"], ["", "lemma compatible_adm2:\n  shows \"adm (\\<lambda> y. compatible x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adm (compatible x)", "proof(rule admI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; \\<forall>i. compatible x (Y i)\\<rbrakk>\n       \\<Longrightarrow> compatible x (\\<Squnion>i. Y i)", "fix Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; \\<forall>i. compatible x (Y i)\\<rbrakk>\n       \\<Longrightarrow> compatible x (\\<Squnion>i. Y i)", "assume c: \"chain Y\" and \"\\<forall>i.  compatible x (Y i)\""], ["proof (state)\nthis:\n  chain Y\n  \\<forall>i. compatible x (Y i)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; \\<forall>i. compatible x (Y i)\\<rbrakk>\n       \\<Longrightarrow> compatible x (\\<Squnion>i. Y i)", "hence a: \"\\<And> i. compatible x (Y i)\""], ["proof (prove)\nusing this:\n  chain Y\n  \\<forall>i. compatible x (Y i)\n\ngoal (1 subgoal):\n 1. \\<And>i. compatible x (Y i)", "by auto"], ["proof (state)\nthis:\n  compatible x (Y ?i)\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; \\<forall>i. compatible x (Y i)\\<rbrakk>\n       \\<Longrightarrow> compatible x (\\<Squnion>i. Y i)", "show \"compatible x (\\<Squnion> i. Y i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compatible x (\\<Squnion>i. Y i)", "proof(rule compatibleI)"], ["proof (state)\ngoal (3 subgoals):\n 1. x \\<sqsubseteq> ?z\n 2. (\\<Squnion>i. Y i) \\<sqsubseteq> ?z\n 3. \\<And>a.\n       \\<lbrakk>x \\<sqsubseteq> a;\n        (\\<Squnion>i. Y i) \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> ?z \\<sqsubseteq> a", "have c2: \"chain (\\<lambda>i. x \\<squnion> Y i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain (\\<lambda>i. x \\<squnion> Y i)", "apply (rule chainI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. x \\<squnion> Y i \\<sqsubseteq> x \\<squnion> Y (Suc i)", "apply (rule join_mono[OF a a below_refl chainE[OF \\<open>chain Y\\<close>]])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  chain (\\<lambda>i. x \\<squnion> Y i)\n\ngoal (3 subgoals):\n 1. x \\<sqsubseteq> ?z\n 2. (\\<Squnion>i. Y i) \\<sqsubseteq> ?z\n 3. \\<And>a.\n       \\<lbrakk>x \\<sqsubseteq> a;\n        (\\<Squnion>i. Y i) \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> ?z \\<sqsubseteq> a", "show \"x \\<sqsubseteq> (\\<Squnion> i. x \\<squnion> Y i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> (\\<Squnion>i. x \\<squnion> Y i)", "by (auto intro: admD[OF _ c2] join_above1[OF a])"], ["proof (state)\nthis:\n  x \\<sqsubseteq> (\\<Squnion>i. x \\<squnion> Y i)\n\ngoal (2 subgoals):\n 1. (\\<Squnion>i. Y i) \\<sqsubseteq> (\\<Squnion>i. x \\<squnion> Y i)\n 2. \\<And>a.\n       \\<lbrakk>x \\<sqsubseteq> a;\n        (\\<Squnion>i. Y i) \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>i. x \\<squnion> Y i) \\<sqsubseteq> a", "show \"(\\<Squnion> i. Y i) \\<sqsubseteq> (\\<Squnion> i. x \\<squnion> Y i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>i. Y i) \\<sqsubseteq> (\\<Squnion>i. x \\<squnion> Y i)", "by (auto intro: admD[OF _ c] below_lub[OF c2 join_above2[OF a]])"], ["proof (state)\nthis:\n  (\\<Squnion>i. Y i) \\<sqsubseteq> (\\<Squnion>i. x \\<squnion> Y i)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>x \\<sqsubseteq> a;\n        (\\<Squnion>i. Y i) \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>i. x \\<squnion> Y i) \\<sqsubseteq> a", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>x \\<sqsubseteq> a;\n        (\\<Squnion>i. Y i) \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>i. x \\<squnion> Y i) \\<sqsubseteq> a", "assume \"x \\<sqsubseteq> a\" and \"(\\<Squnion> i. Y i) \\<sqsubseteq> a\""], ["proof (state)\nthis:\n  x \\<sqsubseteq> a\n  (\\<Squnion>i. Y i) \\<sqsubseteq> a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>x \\<sqsubseteq> a;\n        (\\<Squnion>i. Y i) \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>i. x \\<squnion> Y i) \\<sqsubseteq> a", "show \"(\\<Squnion> i. x \\<squnion> Y i) \\<sqsubseteq> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>i. x \\<squnion> Y i) \\<sqsubseteq> a", "apply (rule lub_below[OF c2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. x \\<squnion> Y i \\<sqsubseteq> a", "apply (rule join_below[OF a \\<open>x \\<sqsubseteq> a\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. Y i \\<sqsubseteq> a", "apply (rule below_trans[OF is_ub_thelub[OF c] \\<open>(\\<Squnion> i. Y i) \\<sqsubseteq> a\\<close>])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Squnion>i. x \\<squnion> Y i) \\<sqsubseteq> a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  compatible x (\\<Squnion>i. Y i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compatible_adm1: \"adm (\\<lambda> x. compatible x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adm (\\<lambda>x. compatible x y)", "by (subst compatible_sym_iff, rule compatible_adm2)"], ["", "lemma join_cont1:\n  assumes \"chain Y\"\n  assumes compat: \"\\<And> i. compatible (Y i) y\"\n  shows \"(\\<Squnion>i. Y i) \\<squnion> y = (\\<Squnion> i. Y i \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>i. Y i) \\<squnion> y = (\\<Squnion>i. Y i \\<squnion> y)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Squnion>i. Y i) \\<squnion> y = (\\<Squnion>i. Y i \\<squnion> y)", "have c: \"chain (\\<lambda>i. Y i \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain (\\<lambda>i. Y i \\<squnion> y)", "apply (rule chainI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. Y i \\<squnion> y \\<sqsubseteq> Y (Suc i) \\<squnion> y", "apply (rule join_mono[OF compat compat chainE[OF \\<open>chain Y\\<close>] below_refl])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  chain (\\<lambda>i. Y i \\<squnion> y)\n\ngoal (1 subgoal):\n 1. (\\<Squnion>i. Y i) \\<squnion> y = (\\<Squnion>i. Y i \\<squnion> y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>i. Y i) \\<squnion> y = (\\<Squnion>i. Y i \\<squnion> y)", "apply (rule is_joinI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<Squnion>i. Y i) \\<sqsubseteq> (\\<Squnion>i. Y i \\<squnion> y)\n 2. y \\<sqsubseteq> (\\<Squnion>i. Y i \\<squnion> y)\n 3. \\<And>a.\n       \\<lbrakk>(\\<Squnion>i. Y i) \\<sqsubseteq> a;\n        y \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>i. Y i \\<squnion> y) \\<sqsubseteq> a", "apply (rule lub_mono[OF \\<open>chain Y\\<close> c join_above1[OF compat]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. y \\<sqsubseteq> (\\<Squnion>i. Y i \\<squnion> y)\n 2. \\<And>a.\n       \\<lbrakk>(\\<Squnion>i. Y i) \\<sqsubseteq> a;\n        y \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>i. Y i \\<squnion> y) \\<sqsubseteq> a", "apply (rule below_lub[OF c join_above2[OF compat]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>(\\<Squnion>i. Y i) \\<sqsubseteq> a;\n        y \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>i. Y i \\<squnion> y) \\<sqsubseteq> a", "apply (rule lub_below[OF c])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a i.\n       \\<lbrakk>(\\<Squnion>i. Y i) \\<sqsubseteq> a;\n        y \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> Y i \\<squnion> y \\<sqsubseteq> a", "apply (rule join_below[OF compat])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a i.\n       \\<lbrakk>(\\<Squnion>i. Y i) \\<sqsubseteq> a;\n        y \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> Y i \\<sqsubseteq> a\n 2. \\<And>a i.\n       \\<lbrakk>(\\<Squnion>i. Y i) \\<sqsubseteq> a;\n        y \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> y \\<sqsubseteq> a", "apply (metis lub_below_iff[OF \\<open>chain Y\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a i.\n       \\<lbrakk>(\\<Squnion>i. Y i) \\<sqsubseteq> a;\n        y \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> y \\<sqsubseteq> a", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Squnion>i. Y i) \\<squnion> y = (\\<Squnion>i. Y i \\<squnion> y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma join_cont2:\n  assumes \"chain Y\"\n  assumes compat: \"\\<And> i. compatible x (Y i)\"\n  shows \"x \\<squnion> (\\<Squnion>i. Y i) = (\\<Squnion> i. x \\<squnion> Y i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> (\\<Squnion>i. Y i) = (\\<Squnion>i. x \\<squnion> Y i)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<squnion> (\\<Squnion>i. Y i) = (\\<Squnion>i. x \\<squnion> Y i)", "have c: \"chain (\\<lambda>i. x \\<squnion> Y i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain (\\<lambda>i. x \\<squnion> Y i)", "apply (rule chainI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. x \\<squnion> Y i \\<sqsubseteq> x \\<squnion> Y (Suc i)", "apply (rule join_mono[OF compat compat below_refl chainE[OF \\<open>chain Y\\<close>]])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  chain (\\<lambda>i. x \\<squnion> Y i)\n\ngoal (1 subgoal):\n 1. x \\<squnion> (\\<Squnion>i. Y i) = (\\<Squnion>i. x \\<squnion> Y i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> (\\<Squnion>i. Y i) = (\\<Squnion>i. x \\<squnion> Y i)", "apply (rule is_joinI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<sqsubseteq> (\\<Squnion>i. x \\<squnion> Y i)\n 2. (\\<Squnion>i. Y i) \\<sqsubseteq> (\\<Squnion>i. x \\<squnion> Y i)\n 3. \\<And>a.\n       \\<lbrakk>x \\<sqsubseteq> a;\n        (\\<Squnion>i. Y i) \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>i. x \\<squnion> Y i) \\<sqsubseteq> a", "apply (rule below_lub[OF c join_above1[OF compat]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<Squnion>i. Y i) \\<sqsubseteq> (\\<Squnion>i. x \\<squnion> Y i)\n 2. \\<And>a.\n       \\<lbrakk>x \\<sqsubseteq> a;\n        (\\<Squnion>i. Y i) \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>i. x \\<squnion> Y i) \\<sqsubseteq> a", "apply (rule lub_mono[OF \\<open>chain Y\\<close> c join_above2[OF compat]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>x \\<sqsubseteq> a;\n        (\\<Squnion>i. Y i) \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>i. x \\<squnion> Y i) \\<sqsubseteq> a", "apply (rule lub_below[OF c])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a i.\n       \\<lbrakk>x \\<sqsubseteq> a;\n        (\\<Squnion>i. Y i) \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> x \\<squnion> Y i \\<sqsubseteq> a", "apply (rule join_below[OF compat])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a i.\n       \\<lbrakk>x \\<sqsubseteq> a;\n        (\\<Squnion>i. Y i) \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> x \\<sqsubseteq> a\n 2. \\<And>a i.\n       \\<lbrakk>x \\<sqsubseteq> a;\n        (\\<Squnion>i. Y i) \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> Y i \\<sqsubseteq> a", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a i.\n       \\<lbrakk>x \\<sqsubseteq> a;\n        (\\<Squnion>i. Y i) \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> Y i \\<sqsubseteq> a", "apply (metis lub_below_iff[OF \\<open>chain Y\\<close>])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x \\<squnion> (\\<Squnion>i. Y i) = (\\<Squnion>i. x \\<squnion> Y i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma join_cont12:\n  assumes \"chain Y\" and \"chain Z\"\n  assumes compat: \"\\<And> i j. compatible (Y i) (Z j)\"\n  shows \"(\\<Squnion>i. Y i) \\<squnion> (\\<Squnion>i. Z i) = (\\<Squnion> i. Y i  \\<squnion> Z i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>i. Y i) \\<squnion> (\\<Squnion>i. Z i) =\n    (\\<Squnion>i. Y i \\<squnion> Z i)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Squnion>i. Y i) \\<squnion> (\\<Squnion>i. Z i) =\n    (\\<Squnion>i. Y i \\<squnion> Z i)", "have \"(\\<Squnion>i. Y i) \\<squnion> (\\<Squnion>i. Z i) = (\\<Squnion>i. Y i \\<squnion> (\\<Squnion>j. Z j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>i. Y i) \\<squnion> (\\<Squnion>i. Z i) =\n    (\\<Squnion>i. Y i \\<squnion> (\\<Squnion>j. Z j))", "by (rule join_cont1[OF \\<open>chain Y\\<close> admD[OF compatible_adm2 \\<open>chain Z\\<close> compat]])"], ["proof (state)\nthis:\n  (\\<Squnion>i. Y i) \\<squnion> (\\<Squnion>i. Z i) =\n  (\\<Squnion>i. Y i \\<squnion> (\\<Squnion>j. Z j))\n\ngoal (1 subgoal):\n 1. (\\<Squnion>i. Y i) \\<squnion> (\\<Squnion>i. Z i) =\n    (\\<Squnion>i. Y i \\<squnion> Z i)", "also"], ["proof (state)\nthis:\n  (\\<Squnion>i. Y i) \\<squnion> (\\<Squnion>i. Z i) =\n  (\\<Squnion>i. Y i \\<squnion> (\\<Squnion>j. Z j))\n\ngoal (1 subgoal):\n 1. (\\<Squnion>i. Y i) \\<squnion> (\\<Squnion>i. Z i) =\n    (\\<Squnion>i. Y i \\<squnion> Z i)", "have \"... = (\\<Squnion>i j. Y i \\<squnion> Z j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>i. Y i \\<squnion> (\\<Squnion>j. Z j)) =\n    (\\<Squnion>i j. Y i \\<squnion> Z j)", "by (subst join_cont2[OF \\<open>chain Z\\<close> compat], rule)"], ["proof (state)\nthis:\n  (\\<Squnion>i. Y i \\<squnion> (\\<Squnion>j. Z j)) =\n  (\\<Squnion>i j. Y i \\<squnion> Z j)\n\ngoal (1 subgoal):\n 1. (\\<Squnion>i. Y i) \\<squnion> (\\<Squnion>i. Z i) =\n    (\\<Squnion>i. Y i \\<squnion> Z i)", "also"], ["proof (state)\nthis:\n  (\\<Squnion>i. Y i \\<squnion> (\\<Squnion>j. Z j)) =\n  (\\<Squnion>i j. Y i \\<squnion> Z j)\n\ngoal (1 subgoal):\n 1. (\\<Squnion>i. Y i) \\<squnion> (\\<Squnion>i. Z i) =\n    (\\<Squnion>i. Y i \\<squnion> Z i)", "have \"... = (\\<Squnion>i. Y i \\<squnion> Z i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>i j. Y i \\<squnion> Z j) = (\\<Squnion>i. Y i \\<squnion> Z i)", "apply (rule diag_lub)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>j. chain (\\<lambda>i. Y i \\<squnion> Z j)\n 2. \\<And>i. chain (\\<lambda>j. Y i \\<squnion> Z j)", "apply (rule chainI, rule join_mono[OF compat compat chainE[OF \\<open>chain Y\\<close>] below_refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. chain (\\<lambda>j. Y i \\<squnion> Z j)", "apply (rule chainI, rule join_mono[OF compat compat below_refl chainE[OF \\<open>chain Z\\<close>]])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Squnion>i j. Y i \\<squnion> Z j) = (\\<Squnion>i. Y i \\<squnion> Z i)\n\ngoal (1 subgoal):\n 1. (\\<Squnion>i. Y i) \\<squnion> (\\<Squnion>i. Z i) =\n    (\\<Squnion>i. Y i \\<squnion> Z i)", "finally"], ["proof (chain)\npicking this:\n  (\\<Squnion>i. Y i) \\<squnion> (\\<Squnion>i. Z i) =\n  (\\<Squnion>i. Y i \\<squnion> Z i)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Squnion>i. Y i) \\<squnion> (\\<Squnion>i. Z i) =\n  (\\<Squnion>i. Y i \\<squnion> Z i)\n\ngoal (1 subgoal):\n 1. (\\<Squnion>i. Y i) \\<squnion> (\\<Squnion>i. Z i) =\n    (\\<Squnion>i. Y i \\<squnion> Z i)", "."], ["proof (state)\nthis:\n  (\\<Squnion>i. Y i) \\<squnion> (\\<Squnion>i. Z i) =\n  (\\<Squnion>i. Y i \\<squnion> Z i)\n\ngoal:\nNo subgoals!", "qed"], ["", "context pcpo\nbegin"], ["", "lemma bot_compatible[simp]:\n    \"compatible x \\<bottom>\" \"compatible \\<bottom> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compatible x \\<bottom> &&& compatible \\<bottom> x", "unfolding compatible_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex ((<<|) {x, \\<bottom>}) &&& Ex ((<<|) {\\<bottom>, x})", "by (metis insert_commute is_lub_bin minimal)+"], ["", "end"], ["", "end"]]}