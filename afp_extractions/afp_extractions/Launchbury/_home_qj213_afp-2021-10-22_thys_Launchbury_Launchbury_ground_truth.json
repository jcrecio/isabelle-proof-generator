{"file_name": "/home/qj213/afp-2021-10-22/thys/Launchbury/Launchbury.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Launchbury", "problem_names": ["lemma eval_test:\n  \"[] : (Let [(x, Lam [y]. Var y)] (Var x)) \\<Down>\\<^bsub>[]\\<^esub> [(x, Lam [y]. Var y)] : (Lam [y]. Var y)\"", "lemma eval_test2:\n  \"y \\<noteq> x \\<Longrightarrow> n \\<noteq> y \\<Longrightarrow> n \\<noteq> x \\<Longrightarrow>[] : (Let [(x, Lam [y]. Var y)] (App (Var x) x)) \\<Down>\\<^bsub>[]\\<^esub> [(x, Lam [y]. Var y)] : (Lam [y]. Var y)\"", "lemma reds_ApplicationI:\n  assumes \"\\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e'\"\n  assumes \"\\<Delta> : e'[y::=x] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z\"\n  shows \"\\<Gamma> : App e x \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z\"", "lemma reds_SmartLet: \"\\<lbrakk>\n    atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n    \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z\n  \\<rbrakk> \\<Longrightarrow>\n    \\<Gamma> : SmartLet \\<Delta> body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z\"", "lemma reds_isValI:\n  \"isVal z \\<Longrightarrow> \\<Gamma> : z \\<Down>\\<^bsub>L\\<^esub> \\<Gamma> : z\"", "lemma reds_doesnt_forget:\n  \"\\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z \\<Longrightarrow> domA \\<Gamma> \\<subseteq> domA \\<Delta>\"", "lemma reds_avoids_live':\n assumes \"\\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z\"\n shows \"(domA \\<Delta> - domA \\<Gamma>) \\<inter> set L = {}\"", "lemma reds_avoids_live:\n  \"\\<lbrakk> \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z;\n   x \\<in> set L;\n   x \\<notin> domA \\<Gamma>\n  \\<rbrakk> \\<Longrightarrow> x \\<notin> domA \\<Delta>\"", "lemma reds_fresh:\" \\<lbrakk> \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z;\n   atom (x::var) \\<sharp> (\\<Gamma>, e)\n  \\<rbrakk> \\<Longrightarrow> atom x \\<sharp> (\\<Delta>, z) \\<or> x \\<in> (domA \\<Delta> - set L)\"", "lemma reds_fresh_fv: \"\\<lbrakk> \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z;\n   x \\<in> fv (\\<Delta>, z) \\<and> (x \\<notin> domA \\<Delta> \\<or>  x \\<in> set L)\n  \\<rbrakk> \\<Longrightarrow> x \\<in> fv (\\<Gamma>, e)\"", "lemma new_free_vars_on_heap:\n  assumes \"\\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z\"\n  shows \"fv (\\<Delta>, z) - domA \\<Delta> \\<subseteq> fv (\\<Gamma>, e) - domA \\<Gamma>\"", "lemma reds_pres_closed:\n  assumes \"\\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z\"\n  and     \"fv (\\<Gamma>, e) \\<subseteq> set L \\<union> domA \\<Gamma>\"\n  shows   \"fv (\\<Delta>, z) \\<subseteq> set L \\<union> domA \\<Delta>\"", "lemma reds_smaller_L: \"\\<lbrakk> \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z;\n   set L' \\<subseteq> set L\n  \\<rbrakk> \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>L'\\<^esub> \\<Delta> : z\"", "lemma result_evaluated:\n  \"\\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z \\<Longrightarrow> isVal z\"", "lemma result_evaluated_fresh:\n  assumes \"\\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z\"\n  obtains y e'\n  where \"z = (Lam [y]. e')\" and \"atom y \\<sharp> (c::'a::fs)\" | b where \"z = Bool b\""], "translations": [["", "lemma eval_test:\n  \"[] : (Let [(x, Lam [y]. Var y)] (Var x)) \\<Down>\\<^bsub>[]\\<^esub> [(x, Lam [y]. Var y)] : (Lam [y]. Var y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] : let x be Lam [y]. Var y in Var x  \\<Down>\\<^bsub>[]\\<^esub> [(x,\n                                 Lam [y]. Var y)] : Lam [y]. Var y", "apply(auto intro!: Lambda Application Variable Let\n simp add: fresh_Pair fresh_Cons fresh_Nil fresh_star_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma eval_test2:\n  \"y \\<noteq> x \\<Longrightarrow> n \\<noteq> y \\<Longrightarrow> n \\<noteq> x \\<Longrightarrow>[] : (Let [(x, Lam [y]. Var y)] (App (Var x) x)) \\<Down>\\<^bsub>[]\\<^esub> [(x, Lam [y]. Var y)] : (Lam [y]. Var y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<noteq> x; n \\<noteq> y; n \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> [] : let x be Lam [y]. Var\n        y in App (Var x)\n              x  \\<Down>\\<^bsub>[]\\<^esub> [(x,\n       Lam [y]. Var y)] : Lam [y]. Var y", "by (auto intro!: Lambda Application Variable Let simp add: fresh_Pair fresh_at_base fresh_Cons fresh_Nil fresh_star_def pure_fresh)"], ["", "subsubsection \\<open>Better introduction rules\\<close>"], ["", "text \\<open>\nThis variant do not require freshness.\n\\<close>"], ["", "lemma reds_ApplicationI:\n  assumes \"\\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e'\"\n  assumes \"\\<Delta> : e'[y::=x] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z\"\n  shows \"\\<Gamma> : App e x \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> : App e x \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma> : App e x \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z", "obtain y' :: var where \"atom y' \\<sharp> (\\<Gamma>, e, x, L, \\<Delta>, \\<Theta>, z, e')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y'.\n        atom\n         y' \\<sharp> (\\<Gamma>, e, x, L, \\<Delta>, \\<Theta>, z,\n                      e') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule obtain_fresh)"], ["proof (state)\nthis:\n  atom y' \\<sharp> (\\<Gamma>, e, x, L, \\<Delta>, \\<Theta>, z, e')\n\ngoal (1 subgoal):\n 1. \\<Gamma> : App e x \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z", "have a: \"Lam [y']. ((y' \\<leftrightarrow> y) \\<bullet> e') = Lam [y]. e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lam [y']. ((y' \\<leftrightarrow> y) \\<bullet> e') = Lam [y]. e'", "using \\<open>atom y' \\<sharp> _\\<close>"], ["proof (prove)\nusing this:\n  atom y' \\<sharp> (\\<Gamma>, e, x, L, \\<Delta>, \\<Theta>, z, e')\n\ngoal (1 subgoal):\n 1. Lam [y']. ((y' \\<leftrightarrow> y) \\<bullet> e') = Lam [y]. e'", "by (auto simp add: Abs1_eq_iff fresh_Pair fresh_at_base)"], ["proof (state)\nthis:\n  Lam [y']. ((y' \\<leftrightarrow> y) \\<bullet> e') = Lam [y]. e'\n\ngoal (1 subgoal):\n 1. \\<Gamma> : App e x \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z", "have b: \"((y' \\<leftrightarrow> y) \\<bullet> e')[y'::=x] = e'[y::=x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((y' \\<leftrightarrow> y) \\<bullet> e')[y'::=x] = e'[y::=x]", "proof(cases \"x = y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    ((y' \\<leftrightarrow> y) \\<bullet> e')[y'::=x] = e'[y::=x]\n 2. x \\<noteq> y \\<Longrightarrow>\n    ((y' \\<leftrightarrow> y) \\<bullet> e')[y'::=x] = e'[y::=x]", "case True"], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    ((y' \\<leftrightarrow> y) \\<bullet> e')[y'::=x] = e'[y::=x]\n 2. x \\<noteq> y \\<Longrightarrow>\n    ((y' \\<leftrightarrow> y) \\<bullet> e')[y'::=x] = e'[y::=x]", "have \"atom y' \\<sharp> e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom y' \\<sharp> e'", "using \\<open>atom y' \\<sharp> _\\<close>"], ["proof (prove)\nusing this:\n  atom y' \\<sharp> (\\<Gamma>, e, x, L, \\<Delta>, \\<Theta>, z, e')\n\ngoal (1 subgoal):\n 1. atom y' \\<sharp> e'", "by simp"], ["proof (state)\nthis:\n  atom y' \\<sharp> e'\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    ((y' \\<leftrightarrow> y) \\<bullet> e')[y'::=x] = e'[y::=x]\n 2. x \\<noteq> y \\<Longrightarrow>\n    ((y' \\<leftrightarrow> y) \\<bullet> e')[y'::=x] = e'[y::=x]", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom y' \\<sharp> e'\n\ngoal (1 subgoal):\n 1. ((y' \\<leftrightarrow> y) \\<bullet> e')[y'::=x] = e'[y::=x]", "by (simp add: True subst_swap_same  subst_subst_back)"], ["proof (state)\nthis:\n  ((y' \\<leftrightarrow> y) \\<bullet> e')[y'::=x] = e'[y::=x]\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    ((y' \\<leftrightarrow> y) \\<bullet> e')[y'::=x] = e'[y::=x]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    ((y' \\<leftrightarrow> y) \\<bullet> e')[y'::=x] = e'[y::=x]", "case False"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    ((y' \\<leftrightarrow> y) \\<bullet> e')[y'::=x] = e'[y::=x]", "hence \"atom y \\<sharp> x\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. atom y \\<sharp> x", "by simp"], ["proof (state)\nthis:\n  atom y \\<sharp> x\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    ((y' \\<leftrightarrow> y) \\<bullet> e')[y'::=x] = e'[y::=x]", "have [simp]: \"(y' \\<leftrightarrow> y) \\<bullet> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y' \\<leftrightarrow> y) \\<bullet> x = x", "using \\<open>atom y \\<sharp> _\\<close>  \\<open>atom y' \\<sharp> _\\<close>"], ["proof (prove)\nusing this:\n  atom y \\<sharp> x\n  atom y' \\<sharp> (\\<Gamma>, e, x, L, \\<Delta>, \\<Theta>, z, e')\n\ngoal (1 subgoal):\n 1. (y' \\<leftrightarrow> y) \\<bullet> x = x", "by (simp add: flip_fresh_fresh fresh_Pair fresh_at_base)"], ["proof (state)\nthis:\n  (y' \\<leftrightarrow> y) \\<bullet> x = x\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    ((y' \\<leftrightarrow> y) \\<bullet> e')[y'::=x] = e'[y::=x]", "have \"((y' \\<leftrightarrow> y) \\<bullet> e')[y'::=x] = (y' \\<leftrightarrow> y) \\<bullet> (e'[y::=x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((y' \\<leftrightarrow> y) \\<bullet> e')[y'::=x] =\n    (y' \\<leftrightarrow> y) \\<bullet> e'[y::=x]", "by simp"], ["proof (state)\nthis:\n  ((y' \\<leftrightarrow> y) \\<bullet> e')[y'::=x] =\n  (y' \\<leftrightarrow> y) \\<bullet> e'[y::=x]\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    ((y' \\<leftrightarrow> y) \\<bullet> e')[y'::=x] = e'[y::=x]", "also"], ["proof (state)\nthis:\n  ((y' \\<leftrightarrow> y) \\<bullet> e')[y'::=x] =\n  (y' \\<leftrightarrow> y) \\<bullet> e'[y::=x]\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    ((y' \\<leftrightarrow> y) \\<bullet> e')[y'::=x] = e'[y::=x]", "have \"\\<dots> = e'[y::=x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y' \\<leftrightarrow> y) \\<bullet> e'[y::=x] = e'[y::=x]", "using \\<open>atom y \\<sharp> _\\<close>  \\<open>atom y' \\<sharp> _\\<close>"], ["proof (prove)\nusing this:\n  atom y \\<sharp> x\n  atom y' \\<sharp> (\\<Gamma>, e, x, L, \\<Delta>, \\<Theta>, z, e')\n\ngoal (1 subgoal):\n 1. (y' \\<leftrightarrow> y) \\<bullet> e'[y::=x] = e'[y::=x]", "by (simp add: flip_fresh_fresh fresh_Pair fresh_at_base subst_pres_fresh)"], ["proof (state)\nthis:\n  (y' \\<leftrightarrow> y) \\<bullet> e'[y::=x] = e'[y::=x]\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    ((y' \\<leftrightarrow> y) \\<bullet> e')[y'::=x] = e'[y::=x]", "finally"], ["proof (chain)\npicking this:\n  ((y' \\<leftrightarrow> y) \\<bullet> e')[y'::=x] = e'[y::=x]", "show ?thesis"], ["proof (prove)\nusing this:\n  ((y' \\<leftrightarrow> y) \\<bullet> e')[y'::=x] = e'[y::=x]\n\ngoal (1 subgoal):\n 1. ((y' \\<leftrightarrow> y) \\<bullet> e')[y'::=x] = e'[y::=x]", "."], ["proof (state)\nthis:\n  ((y' \\<leftrightarrow> y) \\<bullet> e')[y'::=x] = e'[y::=x]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((y' \\<leftrightarrow> y) \\<bullet> e')[y'::=x] = e'[y::=x]\n\ngoal (1 subgoal):\n 1. \\<Gamma> : App e x \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z", "have \"atom y' \\<sharp> (\\<Gamma>, e, x, L, \\<Delta>, \\<Theta>, z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom y' \\<sharp> (\\<Gamma>, e, x, L, \\<Delta>, \\<Theta>, z)", "using  \\<open>atom y' \\<sharp> _\\<close>"], ["proof (prove)\nusing this:\n  atom y' \\<sharp> (\\<Gamma>, e, x, L, \\<Delta>, \\<Theta>, z, e')\n\ngoal (1 subgoal):\n 1. atom y' \\<sharp> (\\<Gamma>, e, x, L, \\<Delta>, \\<Theta>, z)", "by (simp add: fresh_Pair)"], ["proof (state)\nthis:\n  atom y' \\<sharp> (\\<Gamma>, e, x, L, \\<Delta>, \\<Theta>, z)\n\ngoal (1 subgoal):\n 1. \\<Gamma> : App e x \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z", "from this assms[folded a b]"], ["proof (chain)\npicking this:\n  atom y' \\<sharp> (\\<Gamma>, e, x, L, \\<Delta>, \\<Theta>, z)\n  \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y']. ((y' \\<leftrightarrow> y) \\<bullet> e')\n  \\<Delta> : ((y' \\<leftrightarrow> y) \\<bullet> e')[y'::=x] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z", "show ?thesis"], ["proof (prove)\nusing this:\n  atom y' \\<sharp> (\\<Gamma>, e, x, L, \\<Delta>, \\<Theta>, z)\n  \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y']. ((y' \\<leftrightarrow> y) \\<bullet> e')\n  \\<Delta> : ((y' \\<leftrightarrow> y) \\<bullet> e')[y'::=x] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z\n\ngoal (1 subgoal):\n 1. \\<Gamma> : App e x \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z", ".."], ["proof (state)\nthis:\n  \\<Gamma> : App e x \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reds_SmartLet: \"\\<lbrakk>\n    atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n    \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z\n  \\<rbrakk> \\<Longrightarrow>\n    \\<Gamma> : SmartLet \\<Delta> body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n     \\<Delta> @\n     \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> : SmartLet \\<Delta>\n                                  body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z", "unfolding SmartLet_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n     \\<Delta> @\n     \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> : (if \\<Delta> = [] then body\n                                  else Let \\<Delta>\n  body) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z", "by (auto intro: reds.Let)"], ["", "text \\<open>\nA single rule for values\n\\<close>"], ["", "lemma reds_isValI:\n  \"isVal z \\<Longrightarrow> \\<Gamma> : z \\<Down>\\<^bsub>L\\<^esub> \\<Gamma> : z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isVal z \\<Longrightarrow>\n    \\<Gamma> : z \\<Down>\\<^bsub>L\\<^esub> \\<Gamma> : z", "by (cases z rule:isVal.cases) (auto intro: reds.intros)"], ["", "subsubsection \\<open>Properties of the semantics\\<close>"], ["", "text \\<open>\nHeap entries are never removed.\n\\<close>"], ["", "lemma reds_doesnt_forget:\n  \"\\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z \\<Longrightarrow> domA \\<Gamma> \\<subseteq> domA \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z \\<Longrightarrow>\n    domA \\<Gamma> \\<subseteq> domA \\<Delta>", "by(induct rule: reds.induct) auto"], ["", "text \\<open>\nLive variables are not added to the heap.\n\\<close>"], ["", "lemma reds_avoids_live':\n assumes \"\\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z\"\n shows \"(domA \\<Delta> - domA \\<Gamma>) \\<inter> set L = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (domA \\<Delta> - domA \\<Gamma>) \\<inter> set L = {}", "using assms"], ["proof (prove)\nusing this:\n  \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z\n\ngoal (1 subgoal):\n 1. (domA \\<Delta> - domA \\<Gamma>) \\<inter> set L = {}", "by(induct rule:reds.induct)\n  (auto dest: map_of_domAD fresh_distinct_list simp add: fresh_star_Pair)"], ["", "lemma reds_avoids_live:\n  \"\\<lbrakk> \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z;\n   x \\<in> set L;\n   x \\<notin> domA \\<Gamma>\n  \\<rbrakk> \\<Longrightarrow> x \\<notin> domA \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z;\n     x \\<in> set L; x \\<notin> domA \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> domA \\<Delta>", "using reds_avoids_live'"], ["proof (prove)\nusing this:\n  ?\\<Gamma> : ?e \\<Down>\\<^bsub>?L\\<^esub> ?\\<Delta> : ?z \\<Longrightarrow>\n  (domA ?\\<Delta> - domA ?\\<Gamma>) \\<inter> set ?L = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z;\n     x \\<in> set L; x \\<notin> domA \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> domA \\<Delta>", "by blast"], ["", "text \\<open>\nFresh variables either stay fresh or are added to the heap.\n\\<close>"], ["", "lemma reds_fresh:\" \\<lbrakk> \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z;\n   atom (x::var) \\<sharp> (\\<Gamma>, e)\n  \\<rbrakk> \\<Longrightarrow> atom x \\<sharp> (\\<Delta>, z) \\<or> x \\<in> (domA \\<Delta> - set L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z;\n     atom x \\<sharp> (\\<Gamma>, e)\\<rbrakk>\n    \\<Longrightarrow> atom x \\<sharp> (\\<Delta>, z) \\<or>\n                      x \\<in> domA \\<Delta> - set L", "proof(induct rule: reds.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> xa e L.\n       atom x \\<sharp> (\\<Gamma>, Lam [xa]. e) \\<Longrightarrow>\n       atom x \\<sharp> (\\<Gamma>, Lam [xa]. e) \\<or>\n       x \\<in> domA \\<Gamma> - set L\n 2. \\<And>y \\<Gamma> e xa L \\<Delta> \\<Theta> z e'.\n       \\<lbrakk>atom y \\<sharp> (\\<Gamma>, e, xa, L, \\<Delta>, \\<Theta>, z);\n        \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e';\n        atom x \\<sharp> (\\<Gamma>, e) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, Lam [y]. e') \\<or>\n        x \\<in> domA \\<Delta> - set L;\n        \\<Delta> : e'[y::=xa] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta>, e'[y::=xa]) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, App e xa)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L\n 3. \\<And>\\<Gamma> xa e L \\<Delta> z.\n       \\<lbrakk>map_of \\<Gamma> xa = Some e;\n        delete xa \\<Gamma> : e \\<Down>\\<^bsub>xa # L\\<^esub> \\<Delta> : z;\n        atom x \\<sharp> (delete xa \\<Gamma>, e) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, z) \\<or>\n        x \\<in> domA \\<Delta> - set (xa # L);\n        atom x \\<sharp> (\\<Gamma>, Var xa)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> ((xa, z) # \\<Delta>, z) \\<or>\n                         x \\<in> domA ((xa, z) # \\<Delta>) - set L\n 4. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta> @ \\<Gamma>, body) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, Let \\<Delta> body)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L\n 5. \\<And>\\<Gamma> b L.\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<Longrightarrow>\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<or>\n       x \\<in> domA \\<Gamma> - set L\n 6. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        atom x \\<sharp> (\\<Gamma>, scrut) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, Bool b) \\<or>\n        x \\<in> domA \\<Delta> - set L;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom\n         x \\<sharp> (\\<Delta>,\n                     if b then e\\<^sub>1 else e\\<^sub>2) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L", "case (Lambda \\<Gamma> x e)"], ["proof (state)\nthis:\n  atom x \\<sharp> (\\<Gamma>, Lam [x]. e)\n\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> xa e L.\n       atom x \\<sharp> (\\<Gamma>, Lam [xa]. e) \\<Longrightarrow>\n       atom x \\<sharp> (\\<Gamma>, Lam [xa]. e) \\<or>\n       x \\<in> domA \\<Gamma> - set L\n 2. \\<And>y \\<Gamma> e xa L \\<Delta> \\<Theta> z e'.\n       \\<lbrakk>atom y \\<sharp> (\\<Gamma>, e, xa, L, \\<Delta>, \\<Theta>, z);\n        \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e';\n        atom x \\<sharp> (\\<Gamma>, e) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, Lam [y]. e') \\<or>\n        x \\<in> domA \\<Delta> - set L;\n        \\<Delta> : e'[y::=xa] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta>, e'[y::=xa]) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, App e xa)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L\n 3. \\<And>\\<Gamma> xa e L \\<Delta> z.\n       \\<lbrakk>map_of \\<Gamma> xa = Some e;\n        delete xa \\<Gamma> : e \\<Down>\\<^bsub>xa # L\\<^esub> \\<Delta> : z;\n        atom x \\<sharp> (delete xa \\<Gamma>, e) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, z) \\<or>\n        x \\<in> domA \\<Delta> - set (xa # L);\n        atom x \\<sharp> (\\<Gamma>, Var xa)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> ((xa, z) # \\<Delta>, z) \\<or>\n                         x \\<in> domA ((xa, z) # \\<Delta>) - set L\n 4. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta> @ \\<Gamma>, body) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, Let \\<Delta> body)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L\n 5. \\<And>\\<Gamma> b L.\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<Longrightarrow>\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<or>\n       x \\<in> domA \\<Gamma> - set L\n 6. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        atom x \\<sharp> (\\<Gamma>, scrut) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, Bool b) \\<or>\n        x \\<in> domA \\<Delta> - set L;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom\n         x \\<sharp> (\\<Delta>,\n                     if b then e\\<^sub>1 else e\\<^sub>2) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L", "thus ?case"], ["proof (prove)\nusing this:\n  atom x \\<sharp> (\\<Gamma>, Lam [x]. e)\n\ngoal (1 subgoal):\n 1. atom x \\<sharp> (\\<Gamma>, Lam [x]. e) \\<or>\n    x \\<in> domA \\<Gamma> - set L_", "by auto"], ["proof (state)\nthis:\n  atom x \\<sharp> (\\<Gamma>, Lam [x]. e) \\<or>\n  x \\<in> domA \\<Gamma> - set L_\n\ngoal (5 subgoals):\n 1. \\<And>y \\<Gamma> e xa L \\<Delta> \\<Theta> z e'.\n       \\<lbrakk>atom y \\<sharp> (\\<Gamma>, e, xa, L, \\<Delta>, \\<Theta>, z);\n        \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e';\n        atom x \\<sharp> (\\<Gamma>, e) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, Lam [y]. e') \\<or>\n        x \\<in> domA \\<Delta> - set L;\n        \\<Delta> : e'[y::=xa] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta>, e'[y::=xa]) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, App e xa)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L\n 2. \\<And>\\<Gamma> xa e L \\<Delta> z.\n       \\<lbrakk>map_of \\<Gamma> xa = Some e;\n        delete xa \\<Gamma> : e \\<Down>\\<^bsub>xa # L\\<^esub> \\<Delta> : z;\n        atom x \\<sharp> (delete xa \\<Gamma>, e) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, z) \\<or>\n        x \\<in> domA \\<Delta> - set (xa # L);\n        atom x \\<sharp> (\\<Gamma>, Var xa)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> ((xa, z) # \\<Delta>, z) \\<or>\n                         x \\<in> domA ((xa, z) # \\<Delta>) - set L\n 3. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta> @ \\<Gamma>, body) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, Let \\<Delta> body)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L\n 4. \\<And>\\<Gamma> b L.\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<Longrightarrow>\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<or>\n       x \\<in> domA \\<Gamma> - set L\n 5. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        atom x \\<sharp> (\\<Gamma>, scrut) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, Bool b) \\<or>\n        x \\<in> domA \\<Delta> - set L;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom\n         x \\<sharp> (\\<Delta>,\n                     if b then e\\<^sub>1 else e\\<^sub>2) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>y \\<Gamma> e xa L \\<Delta> \\<Theta> z e'.\n       \\<lbrakk>atom y \\<sharp> (\\<Gamma>, e, xa, L, \\<Delta>, \\<Theta>, z);\n        \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e';\n        atom x \\<sharp> (\\<Gamma>, e) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, Lam [y]. e') \\<or>\n        x \\<in> domA \\<Delta> - set L;\n        \\<Delta> : e'[y::=xa] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta>, e'[y::=xa]) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, App e xa)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L\n 2. \\<And>\\<Gamma> xa e L \\<Delta> z.\n       \\<lbrakk>map_of \\<Gamma> xa = Some e;\n        delete xa \\<Gamma> : e \\<Down>\\<^bsub>xa # L\\<^esub> \\<Delta> : z;\n        atom x \\<sharp> (delete xa \\<Gamma>, e) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, z) \\<or>\n        x \\<in> domA \\<Delta> - set (xa # L);\n        atom x \\<sharp> (\\<Gamma>, Var xa)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> ((xa, z) # \\<Delta>, z) \\<or>\n                         x \\<in> domA ((xa, z) # \\<Delta>) - set L\n 3. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta> @ \\<Gamma>, body) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, Let \\<Delta> body)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L\n 4. \\<And>\\<Gamma> b L.\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<Longrightarrow>\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<or>\n       x \\<in> domA \\<Gamma> - set L\n 5. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        atom x \\<sharp> (\\<Gamma>, scrut) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, Bool b) \\<or>\n        x \\<in> domA \\<Delta> - set L;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom\n         x \\<sharp> (\\<Delta>,\n                     if b then e\\<^sub>1 else e\\<^sub>2) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L", "case (Application y \\<Gamma> e x' L \\<Delta> \\<Theta> z e')"], ["proof (state)\nthis:\n  atom y \\<sharp> (\\<Gamma>, e, x', L, \\<Delta>, \\<Theta>, z)\n  \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e'\n  atom x \\<sharp> (\\<Gamma>, e) \\<Longrightarrow>\n  atom x \\<sharp> (\\<Delta>, Lam [y]. e') \\<or>\n  x \\<in> domA \\<Delta> - set L\n  \\<Delta> : e'[y::=x'] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z\n  atom x \\<sharp> (\\<Delta>, e'[y::=x']) \\<Longrightarrow>\n  atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L\n  atom x \\<sharp> (\\<Gamma>, App e x')\n\ngoal (5 subgoals):\n 1. \\<And>y \\<Gamma> e xa L \\<Delta> \\<Theta> z e'.\n       \\<lbrakk>atom y \\<sharp> (\\<Gamma>, e, xa, L, \\<Delta>, \\<Theta>, z);\n        \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e';\n        atom x \\<sharp> (\\<Gamma>, e) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, Lam [y]. e') \\<or>\n        x \\<in> domA \\<Delta> - set L;\n        \\<Delta> : e'[y::=xa] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta>, e'[y::=xa]) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, App e xa)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L\n 2. \\<And>\\<Gamma> xa e L \\<Delta> z.\n       \\<lbrakk>map_of \\<Gamma> xa = Some e;\n        delete xa \\<Gamma> : e \\<Down>\\<^bsub>xa # L\\<^esub> \\<Delta> : z;\n        atom x \\<sharp> (delete xa \\<Gamma>, e) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, z) \\<or>\n        x \\<in> domA \\<Delta> - set (xa # L);\n        atom x \\<sharp> (\\<Gamma>, Var xa)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> ((xa, z) # \\<Delta>, z) \\<or>\n                         x \\<in> domA ((xa, z) # \\<Delta>) - set L\n 3. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta> @ \\<Gamma>, body) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, Let \\<Delta> body)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L\n 4. \\<And>\\<Gamma> b L.\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<Longrightarrow>\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<or>\n       x \\<in> domA \\<Gamma> - set L\n 5. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        atom x \\<sharp> (\\<Gamma>, scrut) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, Bool b) \\<or>\n        x \\<in> domA \\<Delta> - set L;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom\n         x \\<sharp> (\\<Delta>,\n                     if b then e\\<^sub>1 else e\\<^sub>2) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L", "hence \"atom x \\<sharp> (\\<Delta>, Lam [y]. e') \\<or> x \\<in> domA \\<Delta> - set (x' # L)\""], ["proof (prove)\nusing this:\n  atom y \\<sharp> (\\<Gamma>, e, x', L, \\<Delta>, \\<Theta>, z)\n  \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e'\n  atom x \\<sharp> (\\<Gamma>, e) \\<Longrightarrow>\n  atom x \\<sharp> (\\<Delta>, Lam [y]. e') \\<or>\n  x \\<in> domA \\<Delta> - set L\n  \\<Delta> : e'[y::=x'] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z\n  atom x \\<sharp> (\\<Delta>, e'[y::=x']) \\<Longrightarrow>\n  atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L\n  atom x \\<sharp> (\\<Gamma>, App e x')\n\ngoal (1 subgoal):\n 1. atom x \\<sharp> (\\<Delta>, Lam [y]. e') \\<or>\n    x \\<in> domA \\<Delta> - set (x' # L)", "by (auto simp add: fresh_Pair)"], ["proof (state)\nthis:\n  atom x \\<sharp> (\\<Delta>, Lam [y]. e') \\<or>\n  x \\<in> domA \\<Delta> - set (x' # L)\n\ngoal (5 subgoals):\n 1. \\<And>y \\<Gamma> e xa L \\<Delta> \\<Theta> z e'.\n       \\<lbrakk>atom y \\<sharp> (\\<Gamma>, e, xa, L, \\<Delta>, \\<Theta>, z);\n        \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e';\n        atom x \\<sharp> (\\<Gamma>, e) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, Lam [y]. e') \\<or>\n        x \\<in> domA \\<Delta> - set L;\n        \\<Delta> : e'[y::=xa] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta>, e'[y::=xa]) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, App e xa)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L\n 2. \\<And>\\<Gamma> xa e L \\<Delta> z.\n       \\<lbrakk>map_of \\<Gamma> xa = Some e;\n        delete xa \\<Gamma> : e \\<Down>\\<^bsub>xa # L\\<^esub> \\<Delta> : z;\n        atom x \\<sharp> (delete xa \\<Gamma>, e) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, z) \\<or>\n        x \\<in> domA \\<Delta> - set (xa # L);\n        atom x \\<sharp> (\\<Gamma>, Var xa)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> ((xa, z) # \\<Delta>, z) \\<or>\n                         x \\<in> domA ((xa, z) # \\<Delta>) - set L\n 3. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta> @ \\<Gamma>, body) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, Let \\<Delta> body)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L\n 4. \\<And>\\<Gamma> b L.\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<Longrightarrow>\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<or>\n       x \\<in> domA \\<Gamma> - set L\n 5. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        atom x \\<sharp> (\\<Gamma>, scrut) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, Bool b) \\<or>\n        x \\<in> domA \\<Delta> - set L;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom\n         x \\<sharp> (\\<Delta>,\n                     if b then e\\<^sub>1 else e\\<^sub>2) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L", "thus ?case"], ["proof (prove)\nusing this:\n  atom x \\<sharp> (\\<Delta>, Lam [y]. e') \\<or>\n  x \\<in> domA \\<Delta> - set (x' # L)\n\ngoal (1 subgoal):\n 1. atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. atom x \\<sharp> (\\<Delta>, Lam [y]. e') \\<Longrightarrow>\n    atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L\n 2. x \\<in> domA \\<Delta> - set (x' # L) \\<Longrightarrow>\n    atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "assume  \"atom x \\<sharp> (\\<Delta>, Lam [y]. e')\""], ["proof (state)\nthis:\n  atom x \\<sharp> (\\<Delta>, Lam [y]. e')\n\ngoal (2 subgoals):\n 1. atom x \\<sharp> (\\<Delta>, Lam [y]. e') \\<Longrightarrow>\n    atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L\n 2. x \\<in> domA \\<Delta> - set (x' # L) \\<Longrightarrow>\n    atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "hence \"atom x \\<sharp> e'[y ::= x']\""], ["proof (prove)\nusing this:\n  atom x \\<sharp> (\\<Delta>, Lam [y]. e')\n\ngoal (1 subgoal):\n 1. atom x \\<sharp> e'[y::=x']", "using Application.prems"], ["proof (prove)\nusing this:\n  atom x \\<sharp> (\\<Delta>, Lam [y]. e')\n  atom x \\<sharp> (\\<Gamma>, App e x')\n\ngoal (1 subgoal):\n 1. atom x \\<sharp> e'[y::=x']", "by (auto intro: subst_pres_fresh simp add: fresh_Pair)"], ["proof (state)\nthis:\n  atom x \\<sharp> e'[y::=x']\n\ngoal (2 subgoals):\n 1. atom x \\<sharp> (\\<Delta>, Lam [y]. e') \\<Longrightarrow>\n    atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L\n 2. x \\<in> domA \\<Delta> - set (x' # L) \\<Longrightarrow>\n    atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "thus ?thesis"], ["proof (prove)\nusing this:\n  atom x \\<sharp> e'[y::=x']\n\ngoal (1 subgoal):\n 1. atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "using Application.hyps(5) \\<open>atom x \\<sharp> (\\<Delta>, Lam [y]. e')\\<close>"], ["proof (prove)\nusing this:\n  atom x \\<sharp> e'[y::=x']\n  atom x \\<sharp> (\\<Delta>, e'[y::=x']) \\<Longrightarrow>\n  atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L\n  atom x \\<sharp> (\\<Delta>, Lam [y]. e')\n\ngoal (1 subgoal):\n 1. atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "by auto"], ["proof (state)\nthis:\n  atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L\n\ngoal (1 subgoal):\n 1. x \\<in> domA \\<Delta> - set (x' # L) \\<Longrightarrow>\n    atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> domA \\<Delta> - set (x' # L) \\<Longrightarrow>\n    atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "assume \"x \\<in> domA \\<Delta> - set (x' # L)\""], ["proof (state)\nthis:\n  x \\<in> domA \\<Delta> - set (x' # L)\n\ngoal (1 subgoal):\n 1. x \\<in> domA \\<Delta> - set (x' # L) \\<Longrightarrow>\n    atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> domA \\<Delta> - set (x' # L)\n\ngoal (1 subgoal):\n 1. atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "using reds_doesnt_forget[OF Application.hyps(4)]"], ["proof (prove)\nusing this:\n  x \\<in> domA \\<Delta> - set (x' # L)\n  domA \\<Delta> \\<subseteq> domA \\<Theta>\n\ngoal (1 subgoal):\n 1. atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "by auto"], ["proof (state)\nthis:\n  atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> xa e L \\<Delta> z.\n       \\<lbrakk>map_of \\<Gamma> xa = Some e;\n        delete xa \\<Gamma> : e \\<Down>\\<^bsub>xa # L\\<^esub> \\<Delta> : z;\n        atom x \\<sharp> (delete xa \\<Gamma>, e) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, z) \\<or>\n        x \\<in> domA \\<Delta> - set (xa # L);\n        atom x \\<sharp> (\\<Gamma>, Var xa)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> ((xa, z) # \\<Delta>, z) \\<or>\n                         x \\<in> domA ((xa, z) # \\<Delta>) - set L\n 2. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta> @ \\<Gamma>, body) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, Let \\<Delta> body)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L\n 3. \\<And>\\<Gamma> b L.\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<Longrightarrow>\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<or>\n       x \\<in> domA \\<Gamma> - set L\n 4. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        atom x \\<sharp> (\\<Gamma>, scrut) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, Bool b) \\<or>\n        x \\<in> domA \\<Delta> - set L;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom\n         x \\<sharp> (\\<Delta>,\n                     if b then e\\<^sub>1 else e\\<^sub>2) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> xa e L \\<Delta> z.\n       \\<lbrakk>map_of \\<Gamma> xa = Some e;\n        delete xa \\<Gamma> : e \\<Down>\\<^bsub>xa # L\\<^esub> \\<Delta> : z;\n        atom x \\<sharp> (delete xa \\<Gamma>, e) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, z) \\<or>\n        x \\<in> domA \\<Delta> - set (xa # L);\n        atom x \\<sharp> (\\<Gamma>, Var xa)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> ((xa, z) # \\<Delta>, z) \\<or>\n                         x \\<in> domA ((xa, z) # \\<Delta>) - set L\n 2. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta> @ \\<Gamma>, body) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, Let \\<Delta> body)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L\n 3. \\<And>\\<Gamma> b L.\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<Longrightarrow>\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<or>\n       x \\<in> domA \\<Gamma> - set L\n 4. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        atom x \\<sharp> (\\<Gamma>, scrut) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, Bool b) \\<or>\n        x \\<in> domA \\<Delta> - set L;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom\n         x \\<sharp> (\\<Delta>,\n                     if b then e\\<^sub>1 else e\\<^sub>2) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L", "case(Variable \\<Gamma> v e L \\<Delta> z)"], ["proof (state)\nthis:\n  map_of \\<Gamma> v = Some e\n  delete v \\<Gamma> : e \\<Down>\\<^bsub>v # L\\<^esub> \\<Delta> : z\n  atom x \\<sharp> (delete v \\<Gamma>, e) \\<Longrightarrow>\n  atom x \\<sharp> (\\<Delta>, z) \\<or> x \\<in> domA \\<Delta> - set (v # L)\n  atom x \\<sharp> (\\<Gamma>, Var v)\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> xa e L \\<Delta> z.\n       \\<lbrakk>map_of \\<Gamma> xa = Some e;\n        delete xa \\<Gamma> : e \\<Down>\\<^bsub>xa # L\\<^esub> \\<Delta> : z;\n        atom x \\<sharp> (delete xa \\<Gamma>, e) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, z) \\<or>\n        x \\<in> domA \\<Delta> - set (xa # L);\n        atom x \\<sharp> (\\<Gamma>, Var xa)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> ((xa, z) # \\<Delta>, z) \\<or>\n                         x \\<in> domA ((xa, z) # \\<Delta>) - set L\n 2. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta> @ \\<Gamma>, body) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, Let \\<Delta> body)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L\n 3. \\<And>\\<Gamma> b L.\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<Longrightarrow>\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<or>\n       x \\<in> domA \\<Gamma> - set L\n 4. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        atom x \\<sharp> (\\<Gamma>, scrut) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, Bool b) \\<or>\n        x \\<in> domA \\<Delta> - set L;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom\n         x \\<sharp> (\\<Delta>,\n                     if b then e\\<^sub>1 else e\\<^sub>2) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L", "have \"atom x \\<sharp> \\<Gamma>\" and \"atom x \\<sharp> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom x \\<sharp> \\<Gamma> &&& atom x \\<sharp> v", "using Variable.prems(1)"], ["proof (prove)\nusing this:\n  atom x \\<sharp> (\\<Gamma>, Var v)\n\ngoal (1 subgoal):\n 1. atom x \\<sharp> \\<Gamma> &&& atom x \\<sharp> v", "by (auto simp add: fresh_Pair)"], ["proof (state)\nthis:\n  atom x \\<sharp> \\<Gamma>\n  atom x \\<sharp> v\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> xa e L \\<Delta> z.\n       \\<lbrakk>map_of \\<Gamma> xa = Some e;\n        delete xa \\<Gamma> : e \\<Down>\\<^bsub>xa # L\\<^esub> \\<Delta> : z;\n        atom x \\<sharp> (delete xa \\<Gamma>, e) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, z) \\<or>\n        x \\<in> domA \\<Delta> - set (xa # L);\n        atom x \\<sharp> (\\<Gamma>, Var xa)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> ((xa, z) # \\<Delta>, z) \\<or>\n                         x \\<in> domA ((xa, z) # \\<Delta>) - set L\n 2. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta> @ \\<Gamma>, body) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, Let \\<Delta> body)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L\n 3. \\<And>\\<Gamma> b L.\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<Longrightarrow>\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<or>\n       x \\<in> domA \\<Gamma> - set L\n 4. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        atom x \\<sharp> (\\<Gamma>, scrut) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, Bool b) \\<or>\n        x \\<in> domA \\<Delta> - set L;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom\n         x \\<sharp> (\\<Delta>,\n                     if b then e\\<^sub>1 else e\\<^sub>2) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L", "from fresh_delete[OF this(1)]"], ["proof (chain)\npicking this:\n  atom x \\<sharp> delete ?v \\<Gamma>", "have \"atom x \\<sharp> delete v \\<Gamma>\""], ["proof (prove)\nusing this:\n  atom x \\<sharp> delete ?v \\<Gamma>\n\ngoal (1 subgoal):\n 1. atom x \\<sharp> delete v \\<Gamma>", "."], ["proof (state)\nthis:\n  atom x \\<sharp> delete v \\<Gamma>\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> xa e L \\<Delta> z.\n       \\<lbrakk>map_of \\<Gamma> xa = Some e;\n        delete xa \\<Gamma> : e \\<Down>\\<^bsub>xa # L\\<^esub> \\<Delta> : z;\n        atom x \\<sharp> (delete xa \\<Gamma>, e) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, z) \\<or>\n        x \\<in> domA \\<Delta> - set (xa # L);\n        atom x \\<sharp> (\\<Gamma>, Var xa)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> ((xa, z) # \\<Delta>, z) \\<or>\n                         x \\<in> domA ((xa, z) # \\<Delta>) - set L\n 2. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta> @ \\<Gamma>, body) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, Let \\<Delta> body)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L\n 3. \\<And>\\<Gamma> b L.\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<Longrightarrow>\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<or>\n       x \\<in> domA \\<Gamma> - set L\n 4. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        atom x \\<sharp> (\\<Gamma>, scrut) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, Bool b) \\<or>\n        x \\<in> domA \\<Delta> - set L;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom\n         x \\<sharp> (\\<Delta>,\n                     if b then e\\<^sub>1 else e\\<^sub>2) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L", "moreover"], ["proof (state)\nthis:\n  atom x \\<sharp> delete v \\<Gamma>\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> xa e L \\<Delta> z.\n       \\<lbrakk>map_of \\<Gamma> xa = Some e;\n        delete xa \\<Gamma> : e \\<Down>\\<^bsub>xa # L\\<^esub> \\<Delta> : z;\n        atom x \\<sharp> (delete xa \\<Gamma>, e) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, z) \\<or>\n        x \\<in> domA \\<Delta> - set (xa # L);\n        atom x \\<sharp> (\\<Gamma>, Var xa)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> ((xa, z) # \\<Delta>, z) \\<or>\n                         x \\<in> domA ((xa, z) # \\<Delta>) - set L\n 2. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta> @ \\<Gamma>, body) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, Let \\<Delta> body)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L\n 3. \\<And>\\<Gamma> b L.\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<Longrightarrow>\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<or>\n       x \\<in> domA \\<Gamma> - set L\n 4. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        atom x \\<sharp> (\\<Gamma>, scrut) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, Bool b) \\<or>\n        x \\<in> domA \\<Delta> - set L;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom\n         x \\<sharp> (\\<Delta>,\n                     if b then e\\<^sub>1 else e\\<^sub>2) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L", "have \"v \\<in> domA \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> domA \\<Gamma>", "using Variable.hyps(1)"], ["proof (prove)\nusing this:\n  map_of \\<Gamma> v = Some e\n\ngoal (1 subgoal):\n 1. v \\<in> domA \\<Gamma>", "by (metis domA_from_set map_of_SomeD)"], ["proof (state)\nthis:\n  v \\<in> domA \\<Gamma>\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> xa e L \\<Delta> z.\n       \\<lbrakk>map_of \\<Gamma> xa = Some e;\n        delete xa \\<Gamma> : e \\<Down>\\<^bsub>xa # L\\<^esub> \\<Delta> : z;\n        atom x \\<sharp> (delete xa \\<Gamma>, e) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, z) \\<or>\n        x \\<in> domA \\<Delta> - set (xa # L);\n        atom x \\<sharp> (\\<Gamma>, Var xa)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> ((xa, z) # \\<Delta>, z) \\<or>\n                         x \\<in> domA ((xa, z) # \\<Delta>) - set L\n 2. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta> @ \\<Gamma>, body) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, Let \\<Delta> body)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L\n 3. \\<And>\\<Gamma> b L.\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<Longrightarrow>\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<or>\n       x \\<in> domA \\<Gamma> - set L\n 4. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        atom x \\<sharp> (\\<Gamma>, scrut) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, Bool b) \\<or>\n        x \\<in> domA \\<Delta> - set L;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom\n         x \\<sharp> (\\<Delta>,\n                     if b then e\\<^sub>1 else e\\<^sub>2) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L", "from fresh_map_of[OF this  \\<open>atom x \\<sharp> \\<Gamma>\\<close>]"], ["proof (chain)\npicking this:\n  atom x \\<sharp> the (map_of \\<Gamma> v)", "have \"atom x \\<sharp> the (map_of \\<Gamma> v)\""], ["proof (prove)\nusing this:\n  atom x \\<sharp> the (map_of \\<Gamma> v)\n\ngoal (1 subgoal):\n 1. atom x \\<sharp> the (map_of \\<Gamma> v)", "."], ["proof (state)\nthis:\n  atom x \\<sharp> the (map_of \\<Gamma> v)\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> xa e L \\<Delta> z.\n       \\<lbrakk>map_of \\<Gamma> xa = Some e;\n        delete xa \\<Gamma> : e \\<Down>\\<^bsub>xa # L\\<^esub> \\<Delta> : z;\n        atom x \\<sharp> (delete xa \\<Gamma>, e) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, z) \\<or>\n        x \\<in> domA \\<Delta> - set (xa # L);\n        atom x \\<sharp> (\\<Gamma>, Var xa)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> ((xa, z) # \\<Delta>, z) \\<or>\n                         x \\<in> domA ((xa, z) # \\<Delta>) - set L\n 2. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta> @ \\<Gamma>, body) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, Let \\<Delta> body)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L\n 3. \\<And>\\<Gamma> b L.\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<Longrightarrow>\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<or>\n       x \\<in> domA \\<Gamma> - set L\n 4. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        atom x \\<sharp> (\\<Gamma>, scrut) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, Bool b) \\<or>\n        x \\<in> domA \\<Delta> - set L;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom\n         x \\<sharp> (\\<Delta>,\n                     if b then e\\<^sub>1 else e\\<^sub>2) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L", "hence \"atom x \\<sharp> e\""], ["proof (prove)\nusing this:\n  atom x \\<sharp> the (map_of \\<Gamma> v)\n\ngoal (1 subgoal):\n 1. atom x \\<sharp> e", "using \\<open>map_of \\<Gamma> v = Some e\\<close>"], ["proof (prove)\nusing this:\n  atom x \\<sharp> the (map_of \\<Gamma> v)\n  map_of \\<Gamma> v = Some e\n\ngoal (1 subgoal):\n 1. atom x \\<sharp> e", "by simp"], ["proof (state)\nthis:\n  atom x \\<sharp> e\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> xa e L \\<Delta> z.\n       \\<lbrakk>map_of \\<Gamma> xa = Some e;\n        delete xa \\<Gamma> : e \\<Down>\\<^bsub>xa # L\\<^esub> \\<Delta> : z;\n        atom x \\<sharp> (delete xa \\<Gamma>, e) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, z) \\<or>\n        x \\<in> domA \\<Delta> - set (xa # L);\n        atom x \\<sharp> (\\<Gamma>, Var xa)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> ((xa, z) # \\<Delta>, z) \\<or>\n                         x \\<in> domA ((xa, z) # \\<Delta>) - set L\n 2. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta> @ \\<Gamma>, body) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, Let \\<Delta> body)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L\n 3. \\<And>\\<Gamma> b L.\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<Longrightarrow>\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<or>\n       x \\<in> domA \\<Gamma> - set L\n 4. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        atom x \\<sharp> (\\<Gamma>, scrut) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, Bool b) \\<or>\n        x \\<in> domA \\<Delta> - set L;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom\n         x \\<sharp> (\\<Delta>,\n                     if b then e\\<^sub>1 else e\\<^sub>2) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L", "ultimately"], ["proof (chain)\npicking this:\n  atom x \\<sharp> delete v \\<Gamma>\n  atom x \\<sharp> e", "have \"atom x \\<sharp> (\\<Delta>, z) \\<or> x \\<in> domA \\<Delta> - set (v # L)\""], ["proof (prove)\nusing this:\n  atom x \\<sharp> delete v \\<Gamma>\n  atom x \\<sharp> e\n\ngoal (1 subgoal):\n 1. atom x \\<sharp> (\\<Delta>, z) \\<or> x \\<in> domA \\<Delta> - set (v # L)", "using Variable.hyps(3)"], ["proof (prove)\nusing this:\n  atom x \\<sharp> delete v \\<Gamma>\n  atom x \\<sharp> e\n  atom x \\<sharp> (delete v \\<Gamma>, e) \\<Longrightarrow>\n  atom x \\<sharp> (\\<Delta>, z) \\<or> x \\<in> domA \\<Delta> - set (v # L)\n\ngoal (1 subgoal):\n 1. atom x \\<sharp> (\\<Delta>, z) \\<or> x \\<in> domA \\<Delta> - set (v # L)", "by (auto simp add: fresh_Pair)"], ["proof (state)\nthis:\n  atom x \\<sharp> (\\<Delta>, z) \\<or> x \\<in> domA \\<Delta> - set (v # L)\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> xa e L \\<Delta> z.\n       \\<lbrakk>map_of \\<Gamma> xa = Some e;\n        delete xa \\<Gamma> : e \\<Down>\\<^bsub>xa # L\\<^esub> \\<Delta> : z;\n        atom x \\<sharp> (delete xa \\<Gamma>, e) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, z) \\<or>\n        x \\<in> domA \\<Delta> - set (xa # L);\n        atom x \\<sharp> (\\<Gamma>, Var xa)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> ((xa, z) # \\<Delta>, z) \\<or>\n                         x \\<in> domA ((xa, z) # \\<Delta>) - set L\n 2. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta> @ \\<Gamma>, body) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, Let \\<Delta> body)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L\n 3. \\<And>\\<Gamma> b L.\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<Longrightarrow>\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<or>\n       x \\<in> domA \\<Gamma> - set L\n 4. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        atom x \\<sharp> (\\<Gamma>, scrut) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, Bool b) \\<or>\n        x \\<in> domA \\<Delta> - set L;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom\n         x \\<sharp> (\\<Delta>,\n                     if b then e\\<^sub>1 else e\\<^sub>2) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L", "thus ?case"], ["proof (prove)\nusing this:\n  atom x \\<sharp> (\\<Delta>, z) \\<or> x \\<in> domA \\<Delta> - set (v # L)\n\ngoal (1 subgoal):\n 1. atom x \\<sharp> ((v, z) # \\<Delta>, z) \\<or>\n    x \\<in> domA ((v, z) # \\<Delta>) - set L", "using \\<open>atom x \\<sharp> v\\<close>"], ["proof (prove)\nusing this:\n  atom x \\<sharp> (\\<Delta>, z) \\<or> x \\<in> domA \\<Delta> - set (v # L)\n  atom x \\<sharp> v\n\ngoal (1 subgoal):\n 1. atom x \\<sharp> ((v, z) # \\<Delta>, z) \\<or>\n    x \\<in> domA ((v, z) # \\<Delta>) - set L", "by (auto simp add: fresh_Pair fresh_Cons fresh_at_base)"], ["proof (state)\nthis:\n  atom x \\<sharp> ((v, z) # \\<Delta>, z) \\<or>\n  x \\<in> domA ((v, z) # \\<Delta>) - set L\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta> @ \\<Gamma>, body) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, Let \\<Delta> body)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L\n 2. \\<And>\\<Gamma> b L.\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<Longrightarrow>\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<or>\n       x \\<in> domA \\<Gamma> - set L\n 3. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        atom x \\<sharp> (\\<Gamma>, scrut) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, Bool b) \\<or>\n        x \\<in> domA \\<Delta> - set L;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom\n         x \\<sharp> (\\<Delta>,\n                     if b then e\\<^sub>1 else e\\<^sub>2) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta> @ \\<Gamma>, body) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, Let \\<Delta> body)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L\n 2. \\<And>\\<Gamma> b L.\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<Longrightarrow>\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<or>\n       x \\<in> domA \\<Gamma> - set L\n 3. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        atom x \\<sharp> (\\<Gamma>, scrut) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, Bool b) \\<or>\n        x \\<in> domA \\<Delta> - set L;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom\n         x \\<sharp> (\\<Delta>,\n                     if b then e\\<^sub>1 else e\\<^sub>2) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L", "case (Bool \\<Gamma> b L)"], ["proof (state)\nthis:\n  atom x \\<sharp> (\\<Gamma>, Bool b)\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta> @ \\<Gamma>, body) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, Let \\<Delta> body)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L\n 2. \\<And>\\<Gamma> b L.\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<Longrightarrow>\n       atom x \\<sharp> (\\<Gamma>, Bool b) \\<or>\n       x \\<in> domA \\<Gamma> - set L\n 3. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        atom x \\<sharp> (\\<Gamma>, scrut) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, Bool b) \\<or>\n        x \\<in> domA \\<Delta> - set L;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom\n         x \\<sharp> (\\<Delta>,\n                     if b then e\\<^sub>1 else e\\<^sub>2) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L", "thus ?case"], ["proof (prove)\nusing this:\n  atom x \\<sharp> (\\<Gamma>, Bool b)\n\ngoal (1 subgoal):\n 1. atom x \\<sharp> (\\<Gamma>, Bool b) \\<or> x \\<in> domA \\<Gamma> - set L", "by auto"], ["proof (state)\nthis:\n  atom x \\<sharp> (\\<Gamma>, Bool b) \\<or> x \\<in> domA \\<Gamma> - set L\n\ngoal (2 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta> @ \\<Gamma>, body) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, Let \\<Delta> body)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L\n 2. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        atom x \\<sharp> (\\<Gamma>, scrut) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, Bool b) \\<or>\n        x \\<in> domA \\<Delta> - set L;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom\n         x \\<sharp> (\\<Delta>,\n                     if b then e\\<^sub>1 else e\\<^sub>2) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta> @ \\<Gamma>, body) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, Let \\<Delta> body)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L\n 2. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        atom x \\<sharp> (\\<Gamma>, scrut) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, Bool b) \\<or>\n        x \\<in> domA \\<Delta> - set L;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom\n         x \\<sharp> (\\<Delta>,\n                     if b then e\\<^sub>1 else e\\<^sub>2) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L", "case (IfThenElse \\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z)"], ["proof (state)\nthis:\n  \\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b\n  atom x \\<sharp> (\\<Gamma>, scrut) \\<Longrightarrow>\n  atom x \\<sharp> (\\<Delta>, Bool b) \\<or> x \\<in> domA \\<Delta> - set L\n  \\<Delta> : (if b then e\\<^sub>1\n              else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z\n  atom\n   x \\<sharp> (\\<Delta>,\n               if b then e\\<^sub>1 else e\\<^sub>2) \\<Longrightarrow>\n  atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L\n  atom x \\<sharp> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta> @ \\<Gamma>, body) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, Let \\<Delta> body)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L\n 2. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        atom x \\<sharp> (\\<Gamma>, scrut) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, Bool b) \\<or>\n        x \\<in> domA \\<Delta> - set L;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom\n         x \\<sharp> (\\<Delta>,\n                     if b then e\\<^sub>1 else e\\<^sub>2) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L", "from \\<open>atom x \\<sharp> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2)\\<close>"], ["proof (chain)\npicking this:\n  atom x \\<sharp> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2)", "have \"atom x \\<sharp> (\\<Gamma>, scrut)\" and \"atom x \\<sharp> (e\\<^sub>1, e\\<^sub>2)\""], ["proof (prove)\nusing this:\n  atom x \\<sharp> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2)\n\ngoal (1 subgoal):\n 1. atom x \\<sharp> (\\<Gamma>, scrut) &&&\n    atom x \\<sharp> (e\\<^sub>1, e\\<^sub>2)", "by (auto simp add: fresh_Pair)"], ["proof (state)\nthis:\n  atom x \\<sharp> (\\<Gamma>, scrut)\n  atom x \\<sharp> (e\\<^sub>1, e\\<^sub>2)\n\ngoal (2 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta> @ \\<Gamma>, body) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, Let \\<Delta> body)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L\n 2. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        atom x \\<sharp> (\\<Gamma>, scrut) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Delta>, Bool b) \\<or>\n        x \\<in> domA \\<Delta> - set L;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom\n         x \\<sharp> (\\<Delta>,\n                     if b then e\\<^sub>1 else e\\<^sub>2) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, scrut ? e\\<^sub>1 : e\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L", "from IfThenElse.hyps(2)[OF this(1)]"], ["proof (chain)\npicking this:\n  atom x \\<sharp> (\\<Delta>, Bool b) \\<or> x \\<in> domA \\<Delta> - set L", "show ?case"], ["proof (prove)\nusing this:\n  atom x \\<sharp> (\\<Delta>, Bool b) \\<or> x \\<in> domA \\<Delta> - set L\n\ngoal (1 subgoal):\n 1. atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. atom x \\<sharp> (\\<Delta>, Bool b) \\<Longrightarrow>\n    atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L\n 2. x \\<in> domA \\<Delta> - set L \\<Longrightarrow>\n    atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "assume \"atom x \\<sharp> (\\<Delta>, Bool b)\""], ["proof (state)\nthis:\n  atom x \\<sharp> (\\<Delta>, Bool b)\n\ngoal (2 subgoals):\n 1. atom x \\<sharp> (\\<Delta>, Bool b) \\<Longrightarrow>\n    atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L\n 2. x \\<in> domA \\<Delta> - set L \\<Longrightarrow>\n    atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "with \\<open>atom x \\<sharp> (e\\<^sub>1, e\\<^sub>2)\\<close>"], ["proof (chain)\npicking this:\n  atom x \\<sharp> (e\\<^sub>1, e\\<^sub>2)\n  atom x \\<sharp> (\\<Delta>, Bool b)", "have \"atom x \\<sharp> (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2)\""], ["proof (prove)\nusing this:\n  atom x \\<sharp> (e\\<^sub>1, e\\<^sub>2)\n  atom x \\<sharp> (\\<Delta>, Bool b)\n\ngoal (1 subgoal):\n 1. atom x \\<sharp> (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2)", "by auto"], ["proof (state)\nthis:\n  atom x \\<sharp> (\\<Delta>, if b then e\\<^sub>1 else e\\<^sub>2)\n\ngoal (2 subgoals):\n 1. atom x \\<sharp> (\\<Delta>, Bool b) \\<Longrightarrow>\n    atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L\n 2. x \\<in> domA \\<Delta> - set L \\<Longrightarrow>\n    atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "from IfThenElse.hyps(4)[OF this]"], ["proof (chain)\npicking this:\n  atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "show ?thesis"], ["proof (prove)\nusing this:\n  atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L\n\ngoal (1 subgoal):\n 1. atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "."], ["proof (state)\nthis:\n  atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L\n\ngoal (1 subgoal):\n 1. x \\<in> domA \\<Delta> - set L \\<Longrightarrow>\n    atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> domA \\<Delta> - set L \\<Longrightarrow>\n    atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "assume \"x \\<in> domA \\<Delta> - set L\""], ["proof (state)\nthis:\n  x \\<in> domA \\<Delta> - set L\n\ngoal (1 subgoal):\n 1. x \\<in> domA \\<Delta> - set L \\<Longrightarrow>\n    atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "with reds_doesnt_forget[OF \\<open>\\<Delta> : (if b then e\\<^sub>1 else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z\\<close>]"], ["proof (chain)\npicking this:\n  domA \\<Delta> \\<subseteq> domA \\<Theta>\n  x \\<in> domA \\<Delta> - set L", "show ?thesis"], ["proof (prove)\nusing this:\n  domA \\<Delta> \\<subseteq> domA \\<Theta>\n  x \\<in> domA \\<Delta> - set L\n\ngoal (1 subgoal):\n 1. atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "by auto"], ["proof (state)\nthis:\n  atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L\n\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta> @ \\<Gamma>, body) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, Let \\<Delta> body)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta> @ \\<Gamma>, body) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, Let \\<Delta> body)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L", "case (Let \\<Delta> \\<Gamma> L body \\<Theta> z)"], ["proof (state)\nthis:\n  atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L)\n  \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z\n  atom x \\<sharp> (\\<Delta> @ \\<Gamma>, body) \\<Longrightarrow>\n  atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L\n  atom x \\<sharp> (\\<Gamma>, Let \\<Delta> body)\n\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L);\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        atom x \\<sharp> (\\<Delta> @ \\<Gamma>, body) \\<Longrightarrow>\n        atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L;\n        atom x \\<sharp> (\\<Gamma>, Let \\<Delta> body)\\<rbrakk>\n       \\<Longrightarrow> atom x \\<sharp> (\\<Theta>, z) \\<or>\n                         x \\<in> domA \\<Theta> - set L", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "proof (cases \"x \\<in> domA \\<Delta>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> domA \\<Delta> \\<Longrightarrow>\n    atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L\n 2. x \\<notin> domA \\<Delta> \\<Longrightarrow>\n    atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "case False"], ["proof (state)\nthis:\n  x \\<notin> domA \\<Delta>\n\ngoal (2 subgoals):\n 1. x \\<in> domA \\<Delta> \\<Longrightarrow>\n    atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L\n 2. x \\<notin> domA \\<Delta> \\<Longrightarrow>\n    atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "hence \"atom x \\<sharp> \\<Delta>\""], ["proof (prove)\nusing this:\n  x \\<notin> domA \\<Delta>\n\ngoal (1 subgoal):\n 1. atom x \\<sharp> \\<Delta>", "using Let.prems"], ["proof (prove)\nusing this:\n  x \\<notin> domA \\<Delta>\n  atom x \\<sharp> (\\<Gamma>, Let \\<Delta> body)\n\ngoal (1 subgoal):\n 1. atom x \\<sharp> \\<Delta>", "by(auto simp add: fresh_Pair)"], ["proof (state)\nthis:\n  atom x \\<sharp> \\<Delta>\n\ngoal (2 subgoals):\n 1. x \\<in> domA \\<Delta> \\<Longrightarrow>\n    atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L\n 2. x \\<notin> domA \\<Delta> \\<Longrightarrow>\n    atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "apply(rule Let.hyps(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. atom x \\<sharp> (\\<Delta> @ \\<Gamma>, body)", "using Let.prems \\<open>atom x \\<sharp> \\<Delta>\\<close> False"], ["proof (prove)\nusing this:\n  atom x \\<sharp> (\\<Gamma>, Let \\<Delta> body)\n  atom x \\<sharp> \\<Delta>\n  x \\<notin> domA \\<Delta>\n\ngoal (1 subgoal):\n 1. atom x \\<sharp> (\\<Delta> @ \\<Gamma>, body)", "by (auto simp add: fresh_Pair fresh_append)"], ["proof (state)\nthis:\n  atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L\n\ngoal (1 subgoal):\n 1. x \\<in> domA \\<Delta> \\<Longrightarrow>\n    atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> domA \\<Delta> \\<Longrightarrow>\n    atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "case True"], ["proof (state)\nthis:\n  x \\<in> domA \\<Delta>\n\ngoal (1 subgoal):\n 1. x \\<in> domA \\<Delta> \\<Longrightarrow>\n    atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "hence \"x \\<notin> set L\""], ["proof (prove)\nusing this:\n  x \\<in> domA \\<Delta>\n\ngoal (1 subgoal):\n 1. x \\<notin> set L", "using Let(1)"], ["proof (prove)\nusing this:\n  x \\<in> domA \\<Delta>\n  atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L)\n\ngoal (1 subgoal):\n 1. x \\<notin> set L", "by (metis fresh_PairD(2) fresh_star_def image_eqI set_not_fresh)"], ["proof (state)\nthis:\n  x \\<notin> set L\n\ngoal (1 subgoal):\n 1. x \\<in> domA \\<Delta> \\<Longrightarrow>\n    atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "with True"], ["proof (chain)\npicking this:\n  x \\<in> domA \\<Delta>\n  x \\<notin> set L", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> domA \\<Delta>\n  x \\<notin> set L\n\ngoal (1 subgoal):\n 1. atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "using reds_doesnt_forget[OF Let.hyps(2)]"], ["proof (prove)\nusing this:\n  x \\<in> domA \\<Delta>\n  x \\<notin> set L\n  domA (\\<Delta> @ \\<Gamma>) \\<subseteq> domA \\<Theta>\n\ngoal (1 subgoal):\n 1. atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L", "by auto"], ["proof (state)\nthis:\n  atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  atom x \\<sharp> (\\<Theta>, z) \\<or> x \\<in> domA \\<Theta> - set L\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reds_fresh_fv: \"\\<lbrakk> \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z;\n   x \\<in> fv (\\<Delta>, z) \\<and> (x \\<notin> domA \\<Delta> \\<or>  x \\<in> set L)\n  \\<rbrakk> \\<Longrightarrow> x \\<in> fv (\\<Gamma>, e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z;\n     x \\<in> fv (\\<Delta>, z) \\<and>\n     (x \\<notin> domA \\<Delta> \\<or> x \\<in> set L)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> fv (\\<Gamma>, e)", "using reds_fresh"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<Gamma> : ?e \\<Down>\\<^bsub>?L\\<^esub> ?\\<Delta> : ?z;\n   atom ?x \\<sharp> (?\\<Gamma>, ?e)\\<rbrakk>\n  \\<Longrightarrow> atom ?x \\<sharp> (?\\<Delta>, ?z) \\<or>\n                    ?x \\<in> domA ?\\<Delta> - set ?L\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z;\n     x \\<in> fv (\\<Delta>, z) \\<and>\n     (x \\<notin> domA \\<Delta> \\<or> x \\<in> set L)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> fv (\\<Gamma>, e)", "unfolding fv_def fresh_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<Gamma> : ?e \\<Down>\\<^bsub>?L\\<^esub> ?\\<Delta> : ?z;\n   atom ?x \\<notin> supp (?\\<Gamma>, ?e)\\<rbrakk>\n  \\<Longrightarrow> atom ?x \\<notin> supp (?\\<Delta>, ?z) \\<or>\n                    ?x \\<in> domA ?\\<Delta> - set ?L\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z;\n     x \\<in> {v. atom v \\<in> supp (\\<Delta>, z)} \\<and>\n     (x \\<notin> domA \\<Delta> \\<or> x \\<in> set L)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> {v. atom v \\<in> supp (\\<Gamma>, e)}", "by blast"], ["", "lemma new_free_vars_on_heap:\n  assumes \"\\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z\"\n  shows \"fv (\\<Delta>, z) - domA \\<Delta> \\<subseteq> fv (\\<Gamma>, e) - domA \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (\\<Delta>, z) - domA \\<Delta>\n    \\<subseteq> fv (\\<Gamma>, e) - domA \\<Gamma>", "using reds_fresh_fv[OF assms(1)] reds_doesnt_forget[OF assms(1)]"], ["proof (prove)\nusing this:\n  ?x \\<in> fv (\\<Delta>, z) \\<and>\n  (?x \\<notin> domA \\<Delta> \\<or> ?x \\<in> set L) \\<Longrightarrow>\n  ?x \\<in> fv (\\<Gamma>, e)\n  domA \\<Gamma> \\<subseteq> domA \\<Delta>\n\ngoal (1 subgoal):\n 1. fv (\\<Delta>, z) - domA \\<Delta>\n    \\<subseteq> fv (\\<Gamma>, e) - domA \\<Gamma>", "by auto"], ["", "lemma reds_pres_closed:\n  assumes \"\\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z\"\n  and     \"fv (\\<Gamma>, e) \\<subseteq> set L \\<union> domA \\<Gamma>\"\n  shows   \"fv (\\<Delta>, z) \\<subseteq> set L \\<union> domA \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (\\<Delta>, z) \\<subseteq> set L \\<union> domA \\<Delta>", "using new_free_vars_on_heap[OF assms(1)] assms(2)"], ["proof (prove)\nusing this:\n  fv (\\<Delta>, z) - domA \\<Delta>\n  \\<subseteq> fv (\\<Gamma>, e) - domA \\<Gamma>\n  fv (\\<Gamma>, e) \\<subseteq> set L \\<union> domA \\<Gamma>\n\ngoal (1 subgoal):\n 1. fv (\\<Delta>, z) \\<subseteq> set L \\<union> domA \\<Delta>", "by auto"], ["", "text \\<open>\nReducing the set of variables to avoid is always possible.\n\\<close>"], ["", "lemma reds_smaller_L: \"\\<lbrakk> \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z;\n   set L' \\<subseteq> set L\n  \\<rbrakk> \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>L'\\<^esub> \\<Delta> : z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z;\n     set L' \\<subseteq> set L\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> : e \\<Down>\\<^bsub>L'\\<^esub> \\<Delta> : z", "proof(nominal_induct avoiding : L' rule: reds.strong_induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> x e L L'.\n       set L' \\<subseteq> set L \\<Longrightarrow>\n       \\<Gamma> : Lam [x]. e \\<Down>\\<^bsub>L'\\<^esub> \\<Gamma> : Lam [x]. e\n 2. \\<And>y \\<Gamma> e x L \\<Delta> \\<Theta> z e' L'.\n       \\<lbrakk>atom y \\<sharp> L'; atom y \\<sharp> \\<Gamma>;\n        atom y \\<sharp> e; atom y \\<sharp> x; atom y \\<sharp> L;\n        atom y \\<sharp> \\<Delta>; atom y \\<sharp> \\<Theta>;\n        atom y \\<sharp> z;\n        \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e';\n        \\<And>b.\n           set b \\<subseteq> set L \\<Longrightarrow>\n           \\<Gamma> : e \\<Down>\\<^bsub>b\\<^esub> \\<Delta> : Lam [y]. e';\n        \\<Delta> : e'[y::=x] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>b.\n           set b \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> : e'[y::=x] \\<Down>\\<^bsub>b\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : App e\n                                     x \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z\n 3. \\<And>\\<Gamma> x e L \\<Delta> z L'.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>b.\n           set b \\<subseteq> set (x # L) \\<Longrightarrow>\n           delete x \\<Gamma> : e \\<Down>\\<^bsub>b\\<^esub> \\<Delta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : Var x \\<Down>\\<^bsub>L'\\<^esub> (x, z) #\n                              \\<Delta> : z\n 4. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z L'.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* L;\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>b.\n           set b \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>b\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : Let \\<Delta>\n                                     body \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z\n 5. \\<And>\\<Gamma> b L L'.\n       set L' \\<subseteq> set L \\<Longrightarrow>\n       \\<Gamma> : Bool b \\<Down>\\<^bsub>L'\\<^esub> \\<Gamma> : Bool b\n 6. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z L'.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>ba.\n           set ba \\<subseteq> set L \\<Longrightarrow>\n           \\<Gamma> : scrut \\<Down>\\<^bsub>ba\\<^esub> \\<Delta> : Bool b;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>ba.\n           set ba \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> : (if b then e\\<^sub>1\n                       else e\\<^sub>2) \\<Down>\\<^bsub>ba\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : (scrut ? e\\<^sub>1\n                                     : e\\<^sub>2) \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z", "case (Lambda \\<Gamma> x e L L')"], ["proof (state)\nthis:\n  set L' \\<subseteq> set L\n\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> x e L L'.\n       set L' \\<subseteq> set L \\<Longrightarrow>\n       \\<Gamma> : Lam [x]. e \\<Down>\\<^bsub>L'\\<^esub> \\<Gamma> : Lam [x]. e\n 2. \\<And>y \\<Gamma> e x L \\<Delta> \\<Theta> z e' L'.\n       \\<lbrakk>atom y \\<sharp> L'; atom y \\<sharp> \\<Gamma>;\n        atom y \\<sharp> e; atom y \\<sharp> x; atom y \\<sharp> L;\n        atom y \\<sharp> \\<Delta>; atom y \\<sharp> \\<Theta>;\n        atom y \\<sharp> z;\n        \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e';\n        \\<And>b.\n           set b \\<subseteq> set L \\<Longrightarrow>\n           \\<Gamma> : e \\<Down>\\<^bsub>b\\<^esub> \\<Delta> : Lam [y]. e';\n        \\<Delta> : e'[y::=x] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>b.\n           set b \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> : e'[y::=x] \\<Down>\\<^bsub>b\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : App e\n                                     x \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z\n 3. \\<And>\\<Gamma> x e L \\<Delta> z L'.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>b.\n           set b \\<subseteq> set (x # L) \\<Longrightarrow>\n           delete x \\<Gamma> : e \\<Down>\\<^bsub>b\\<^esub> \\<Delta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : Var x \\<Down>\\<^bsub>L'\\<^esub> (x, z) #\n                              \\<Delta> : z\n 4. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z L'.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* L;\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>b.\n           set b \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>b\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : Let \\<Delta>\n                                     body \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z\n 5. \\<And>\\<Gamma> b L L'.\n       set L' \\<subseteq> set L \\<Longrightarrow>\n       \\<Gamma> : Bool b \\<Down>\\<^bsub>L'\\<^esub> \\<Gamma> : Bool b\n 6. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z L'.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>ba.\n           set ba \\<subseteq> set L \\<Longrightarrow>\n           \\<Gamma> : scrut \\<Down>\\<^bsub>ba\\<^esub> \\<Delta> : Bool b;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>ba.\n           set ba \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> : (if b then e\\<^sub>1\n                       else e\\<^sub>2) \\<Down>\\<^bsub>ba\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : (scrut ? e\\<^sub>1\n                                     : e\\<^sub>2) \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> : Lam [x]. e \\<Down>\\<^bsub>L'\\<^esub> \\<Gamma> : Lam [x]. e", "by (rule reds.Lambda)"], ["proof (state)\nthis:\n  \\<Gamma> : Lam [x]. e \\<Down>\\<^bsub>L'\\<^esub> \\<Gamma> : Lam [x]. e\n\ngoal (5 subgoals):\n 1. \\<And>y \\<Gamma> e x L \\<Delta> \\<Theta> z e' L'.\n       \\<lbrakk>atom y \\<sharp> L'; atom y \\<sharp> \\<Gamma>;\n        atom y \\<sharp> e; atom y \\<sharp> x; atom y \\<sharp> L;\n        atom y \\<sharp> \\<Delta>; atom y \\<sharp> \\<Theta>;\n        atom y \\<sharp> z;\n        \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e';\n        \\<And>b.\n           set b \\<subseteq> set L \\<Longrightarrow>\n           \\<Gamma> : e \\<Down>\\<^bsub>b\\<^esub> \\<Delta> : Lam [y]. e';\n        \\<Delta> : e'[y::=x] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>b.\n           set b \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> : e'[y::=x] \\<Down>\\<^bsub>b\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : App e\n                                     x \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z\n 2. \\<And>\\<Gamma> x e L \\<Delta> z L'.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>b.\n           set b \\<subseteq> set (x # L) \\<Longrightarrow>\n           delete x \\<Gamma> : e \\<Down>\\<^bsub>b\\<^esub> \\<Delta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : Var x \\<Down>\\<^bsub>L'\\<^esub> (x, z) #\n                              \\<Delta> : z\n 3. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z L'.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* L;\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>b.\n           set b \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>b\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : Let \\<Delta>\n                                     body \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z\n 4. \\<And>\\<Gamma> b L L'.\n       set L' \\<subseteq> set L \\<Longrightarrow>\n       \\<Gamma> : Bool b \\<Down>\\<^bsub>L'\\<^esub> \\<Gamma> : Bool b\n 5. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z L'.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>ba.\n           set ba \\<subseteq> set L \\<Longrightarrow>\n           \\<Gamma> : scrut \\<Down>\\<^bsub>ba\\<^esub> \\<Delta> : Bool b;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>ba.\n           set ba \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> : (if b then e\\<^sub>1\n                       else e\\<^sub>2) \\<Down>\\<^bsub>ba\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : (scrut ? e\\<^sub>1\n                                     : e\\<^sub>2) \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>y \\<Gamma> e x L \\<Delta> \\<Theta> z e' L'.\n       \\<lbrakk>atom y \\<sharp> L'; atom y \\<sharp> \\<Gamma>;\n        atom y \\<sharp> e; atom y \\<sharp> x; atom y \\<sharp> L;\n        atom y \\<sharp> \\<Delta>; atom y \\<sharp> \\<Theta>;\n        atom y \\<sharp> z;\n        \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e';\n        \\<And>b.\n           set b \\<subseteq> set L \\<Longrightarrow>\n           \\<Gamma> : e \\<Down>\\<^bsub>b\\<^esub> \\<Delta> : Lam [y]. e';\n        \\<Delta> : e'[y::=x] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>b.\n           set b \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> : e'[y::=x] \\<Down>\\<^bsub>b\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : App e\n                                     x \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z\n 2. \\<And>\\<Gamma> x e L \\<Delta> z L'.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>b.\n           set b \\<subseteq> set (x # L) \\<Longrightarrow>\n           delete x \\<Gamma> : e \\<Down>\\<^bsub>b\\<^esub> \\<Delta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : Var x \\<Down>\\<^bsub>L'\\<^esub> (x, z) #\n                              \\<Delta> : z\n 3. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z L'.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* L;\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>b.\n           set b \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>b\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : Let \\<Delta>\n                                     body \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z\n 4. \\<And>\\<Gamma> b L L'.\n       set L' \\<subseteq> set L \\<Longrightarrow>\n       \\<Gamma> : Bool b \\<Down>\\<^bsub>L'\\<^esub> \\<Gamma> : Bool b\n 5. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z L'.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>ba.\n           set ba \\<subseteq> set L \\<Longrightarrow>\n           \\<Gamma> : scrut \\<Down>\\<^bsub>ba\\<^esub> \\<Delta> : Bool b;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>ba.\n           set ba \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> : (if b then e\\<^sub>1\n                       else e\\<^sub>2) \\<Down>\\<^bsub>ba\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : (scrut ? e\\<^sub>1\n                                     : e\\<^sub>2) \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z", "case (Application y \\<Gamma> e xa L \\<Delta> \\<Theta> z e' L')"], ["proof (state)\nthis:\n  atom y \\<sharp> L'\n  atom y \\<sharp> \\<Gamma>\n  atom y \\<sharp> e\n  atom y \\<sharp> xa\n  atom y \\<sharp> L\n  atom y \\<sharp> \\<Delta>\n  atom y \\<sharp> \\<Theta>\n  atom y \\<sharp> z\n  \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e'\n  set ?b \\<subseteq> set L \\<Longrightarrow>\n  \\<Gamma> : e \\<Down>\\<^bsub>?b\\<^esub> \\<Delta> : Lam [y]. e'\n  \\<Delta> : e'[y::=xa] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z\n  set ?b \\<subseteq> set L \\<Longrightarrow>\n  \\<Delta> : e'[y::=xa] \\<Down>\\<^bsub>?b\\<^esub> \\<Theta> : z\n  set L' \\<subseteq> set L\n\ngoal (5 subgoals):\n 1. \\<And>y \\<Gamma> e x L \\<Delta> \\<Theta> z e' L'.\n       \\<lbrakk>atom y \\<sharp> L'; atom y \\<sharp> \\<Gamma>;\n        atom y \\<sharp> e; atom y \\<sharp> x; atom y \\<sharp> L;\n        atom y \\<sharp> \\<Delta>; atom y \\<sharp> \\<Theta>;\n        atom y \\<sharp> z;\n        \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Lam [y]. e';\n        \\<And>b.\n           set b \\<subseteq> set L \\<Longrightarrow>\n           \\<Gamma> : e \\<Down>\\<^bsub>b\\<^esub> \\<Delta> : Lam [y]. e';\n        \\<Delta> : e'[y::=x] \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>b.\n           set b \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> : e'[y::=x] \\<Down>\\<^bsub>b\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : App e\n                                     x \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z\n 2. \\<And>\\<Gamma> x e L \\<Delta> z L'.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>b.\n           set b \\<subseteq> set (x # L) \\<Longrightarrow>\n           delete x \\<Gamma> : e \\<Down>\\<^bsub>b\\<^esub> \\<Delta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : Var x \\<Down>\\<^bsub>L'\\<^esub> (x, z) #\n                              \\<Delta> : z\n 3. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z L'.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* L;\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>b.\n           set b \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>b\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : Let \\<Delta>\n                                     body \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z\n 4. \\<And>\\<Gamma> b L L'.\n       set L' \\<subseteq> set L \\<Longrightarrow>\n       \\<Gamma> : Bool b \\<Down>\\<^bsub>L'\\<^esub> \\<Gamma> : Bool b\n 5. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z L'.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>ba.\n           set ba \\<subseteq> set L \\<Longrightarrow>\n           \\<Gamma> : scrut \\<Down>\\<^bsub>ba\\<^esub> \\<Delta> : Bool b;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>ba.\n           set ba \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> : (if b then e\\<^sub>1\n                       else e\\<^sub>2) \\<Down>\\<^bsub>ba\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : (scrut ? e\\<^sub>1\n                                     : e\\<^sub>2) \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z", "from Application.hyps(10)[OF Application.prems] Application.hyps(12)[OF Application.prems]"], ["proof (chain)\npicking this:\n  \\<Gamma> : e \\<Down>\\<^bsub>L'\\<^esub> \\<Delta> : Lam [y]. e'\n  \\<Delta> : e'[y::=xa] \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z", "show ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> : e \\<Down>\\<^bsub>L'\\<^esub> \\<Delta> : Lam [y]. e'\n  \\<Delta> : e'[y::=xa] \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z\n\ngoal (1 subgoal):\n 1. \\<Gamma> : App e xa \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z", "by (rule reds_ApplicationI)"], ["proof (state)\nthis:\n  \\<Gamma> : App e xa \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> x e L \\<Delta> z L'.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>b.\n           set b \\<subseteq> set (x # L) \\<Longrightarrow>\n           delete x \\<Gamma> : e \\<Down>\\<^bsub>b\\<^esub> \\<Delta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : Var x \\<Down>\\<^bsub>L'\\<^esub> (x, z) #\n                              \\<Delta> : z\n 2. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z L'.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* L;\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>b.\n           set b \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>b\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : Let \\<Delta>\n                                     body \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z\n 3. \\<And>\\<Gamma> b L L'.\n       set L' \\<subseteq> set L \\<Longrightarrow>\n       \\<Gamma> : Bool b \\<Down>\\<^bsub>L'\\<^esub> \\<Gamma> : Bool b\n 4. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z L'.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>ba.\n           set ba \\<subseteq> set L \\<Longrightarrow>\n           \\<Gamma> : scrut \\<Down>\\<^bsub>ba\\<^esub> \\<Delta> : Bool b;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>ba.\n           set ba \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> : (if b then e\\<^sub>1\n                       else e\\<^sub>2) \\<Down>\\<^bsub>ba\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : (scrut ? e\\<^sub>1\n                                     : e\\<^sub>2) \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> x e L \\<Delta> z L'.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>b.\n           set b \\<subseteq> set (x # L) \\<Longrightarrow>\n           delete x \\<Gamma> : e \\<Down>\\<^bsub>b\\<^esub> \\<Delta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : Var x \\<Down>\\<^bsub>L'\\<^esub> (x, z) #\n                              \\<Delta> : z\n 2. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z L'.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* L;\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>b.\n           set b \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>b\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : Let \\<Delta>\n                                     body \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z\n 3. \\<And>\\<Gamma> b L L'.\n       set L' \\<subseteq> set L \\<Longrightarrow>\n       \\<Gamma> : Bool b \\<Down>\\<^bsub>L'\\<^esub> \\<Gamma> : Bool b\n 4. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z L'.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>ba.\n           set ba \\<subseteq> set L \\<Longrightarrow>\n           \\<Gamma> : scrut \\<Down>\\<^bsub>ba\\<^esub> \\<Delta> : Bool b;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>ba.\n           set ba \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> : (if b then e\\<^sub>1\n                       else e\\<^sub>2) \\<Down>\\<^bsub>ba\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : (scrut ? e\\<^sub>1\n                                     : e\\<^sub>2) \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z", "case (Variable \\<Gamma> xa e L \\<Delta> z L')"], ["proof (state)\nthis:\n  map_of \\<Gamma> xa = Some e\n  delete xa \\<Gamma> : e \\<Down>\\<^bsub>xa # L\\<^esub> \\<Delta> : z\n  set ?b \\<subseteq> set (xa # L) \\<Longrightarrow>\n  delete xa \\<Gamma> : e \\<Down>\\<^bsub>?b\\<^esub> \\<Delta> : z\n  set L' \\<subseteq> set L\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> x e L \\<Delta> z L'.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>b.\n           set b \\<subseteq> set (x # L) \\<Longrightarrow>\n           delete x \\<Gamma> : e \\<Down>\\<^bsub>b\\<^esub> \\<Delta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : Var x \\<Down>\\<^bsub>L'\\<^esub> (x, z) #\n                              \\<Delta> : z\n 2. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z L'.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* L;\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>b.\n           set b \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>b\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : Let \\<Delta>\n                                     body \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z\n 3. \\<And>\\<Gamma> b L L'.\n       set L' \\<subseteq> set L \\<Longrightarrow>\n       \\<Gamma> : Bool b \\<Down>\\<^bsub>L'\\<^esub> \\<Gamma> : Bool b\n 4. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z L'.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>ba.\n           set ba \\<subseteq> set L \\<Longrightarrow>\n           \\<Gamma> : scrut \\<Down>\\<^bsub>ba\\<^esub> \\<Delta> : Bool b;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>ba.\n           set ba \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> : (if b then e\\<^sub>1\n                       else e\\<^sub>2) \\<Down>\\<^bsub>ba\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : (scrut ? e\\<^sub>1\n                                     : e\\<^sub>2) \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z", "have \"set (xa # L') \\<subseteq> set (xa # L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (xa # L') \\<subseteq> set (xa # L)", "using Variable.prems"], ["proof (prove)\nusing this:\n  set L' \\<subseteq> set L\n\ngoal (1 subgoal):\n 1. set (xa # L') \\<subseteq> set (xa # L)", "by auto"], ["proof (state)\nthis:\n  set (xa # L') \\<subseteq> set (xa # L)\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> x e L \\<Delta> z L'.\n       \\<lbrakk>map_of \\<Gamma> x = Some e;\n        delete x \\<Gamma> : e \\<Down>\\<^bsub>x # L\\<^esub> \\<Delta> : z;\n        \\<And>b.\n           set b \\<subseteq> set (x # L) \\<Longrightarrow>\n           delete x \\<Gamma> : e \\<Down>\\<^bsub>b\\<^esub> \\<Delta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : Var x \\<Down>\\<^bsub>L'\\<^esub> (x, z) #\n                              \\<Delta> : z\n 2. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z L'.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* L;\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>b.\n           set b \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>b\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : Let \\<Delta>\n                                     body \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z\n 3. \\<And>\\<Gamma> b L L'.\n       set L' \\<subseteq> set L \\<Longrightarrow>\n       \\<Gamma> : Bool b \\<Down>\\<^bsub>L'\\<^esub> \\<Gamma> : Bool b\n 4. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z L'.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>ba.\n           set ba \\<subseteq> set L \\<Longrightarrow>\n           \\<Gamma> : scrut \\<Down>\\<^bsub>ba\\<^esub> \\<Delta> : Bool b;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>ba.\n           set ba \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> : (if b then e\\<^sub>1\n                       else e\\<^sub>2) \\<Down>\\<^bsub>ba\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : (scrut ? e\\<^sub>1\n                                     : e\\<^sub>2) \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z", "thus ?case"], ["proof (prove)\nusing this:\n  set (xa # L') \\<subseteq> set (xa # L)\n\ngoal (1 subgoal):\n 1. \\<Gamma> : Var xa \\<Down>\\<^bsub>L'\\<^esub> (xa, z) # \\<Delta> : z", "by (rule reds.Variable[OF Variable(1) Variable.hyps(3)])"], ["proof (state)\nthis:\n  \\<Gamma> : Var xa \\<Down>\\<^bsub>L'\\<^esub> (xa, z) # \\<Delta> : z\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z L'.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* L;\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>b.\n           set b \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>b\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : Let \\<Delta>\n                                     body \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z\n 2. \\<And>\\<Gamma> b L L'.\n       set L' \\<subseteq> set L \\<Longrightarrow>\n       \\<Gamma> : Bool b \\<Down>\\<^bsub>L'\\<^esub> \\<Gamma> : Bool b\n 3. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z L'.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>ba.\n           set ba \\<subseteq> set L \\<Longrightarrow>\n           \\<Gamma> : scrut \\<Down>\\<^bsub>ba\\<^esub> \\<Delta> : Bool b;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>ba.\n           set ba \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> : (if b then e\\<^sub>1\n                       else e\\<^sub>2) \\<Down>\\<^bsub>ba\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : (scrut ? e\\<^sub>1\n                                     : e\\<^sub>2) \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z L'.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* L;\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>b.\n           set b \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>b\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : Let \\<Delta>\n                                     body \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z\n 2. \\<And>\\<Gamma> b L L'.\n       set L' \\<subseteq> set L \\<Longrightarrow>\n       \\<Gamma> : Bool b \\<Down>\\<^bsub>L'\\<^esub> \\<Gamma> : Bool b\n 3. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z L'.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>ba.\n           set ba \\<subseteq> set L \\<Longrightarrow>\n           \\<Gamma> : scrut \\<Down>\\<^bsub>ba\\<^esub> \\<Delta> : Bool b;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>ba.\n           set ba \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> : (if b then e\\<^sub>1\n                       else e\\<^sub>2) \\<Down>\\<^bsub>ba\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : (scrut ? e\\<^sub>1\n                                     : e\\<^sub>2) \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z", "case (Bool b)"], ["proof (state)\nthis:\n  set L' \\<subseteq> set L_\n\ngoal (3 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z L'.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* L;\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>b.\n           set b \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>b\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : Let \\<Delta>\n                                     body \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z\n 2. \\<And>\\<Gamma> b L L'.\n       set L' \\<subseteq> set L \\<Longrightarrow>\n       \\<Gamma> : Bool b \\<Down>\\<^bsub>L'\\<^esub> \\<Gamma> : Bool b\n 3. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z L'.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>ba.\n           set ba \\<subseteq> set L \\<Longrightarrow>\n           \\<Gamma> : scrut \\<Down>\\<^bsub>ba\\<^esub> \\<Delta> : Bool b;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>ba.\n           set ba \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> : (if b then e\\<^sub>1\n                       else e\\<^sub>2) \\<Down>\\<^bsub>ba\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : (scrut ? e\\<^sub>1\n                                     : e\\<^sub>2) \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. b : Bool b_ \\<Down>\\<^bsub>L'\\<^esub> b : Bool b_", ".."], ["proof (state)\nthis:\n  b : Bool b_ \\<Down>\\<^bsub>L'\\<^esub> b : Bool b_\n\ngoal (2 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z L'.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* L;\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>b.\n           set b \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>b\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : Let \\<Delta>\n                                     body \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z\n 2. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z L'.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>ba.\n           set ba \\<subseteq> set L \\<Longrightarrow>\n           \\<Gamma> : scrut \\<Down>\\<^bsub>ba\\<^esub> \\<Delta> : Bool b;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>ba.\n           set ba \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> : (if b then e\\<^sub>1\n                       else e\\<^sub>2) \\<Down>\\<^bsub>ba\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : (scrut ? e\\<^sub>1\n                                     : e\\<^sub>2) \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z L'.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* L;\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>b.\n           set b \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>b\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : Let \\<Delta>\n                                     body \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z\n 2. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z L'.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>ba.\n           set ba \\<subseteq> set L \\<Longrightarrow>\n           \\<Gamma> : scrut \\<Down>\\<^bsub>ba\\<^esub> \\<Delta> : Bool b;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>ba.\n           set ba \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> : (if b then e\\<^sub>1\n                       else e\\<^sub>2) \\<Down>\\<^bsub>ba\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : (scrut ? e\\<^sub>1\n                                     : e\\<^sub>2) \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z", "case (IfThenElse \\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z L')"], ["proof (state)\nthis:\n  \\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b\n  set ?b \\<subseteq> set L \\<Longrightarrow>\n  \\<Gamma> : scrut \\<Down>\\<^bsub>?b\\<^esub> \\<Delta> : Bool b\n  \\<Delta> : (if b then e\\<^sub>1\n              else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z\n  set ?b \\<subseteq> set L \\<Longrightarrow>\n  \\<Delta> : (if b then e\\<^sub>1\n              else e\\<^sub>2) \\<Down>\\<^bsub>?b\\<^esub> \\<Theta> : z\n  set L' \\<subseteq> set L\n\ngoal (2 subgoals):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z L'.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* L;\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>b.\n           set b \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>b\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : Let \\<Delta>\n                                     body \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z\n 2. \\<And>\\<Gamma> scrut L \\<Delta> b e\\<^sub>1 e\\<^sub>2 \\<Theta> z L'.\n       \\<lbrakk>\\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b;\n        \\<And>ba.\n           set ba \\<subseteq> set L \\<Longrightarrow>\n           \\<Gamma> : scrut \\<Down>\\<^bsub>ba\\<^esub> \\<Delta> : Bool b;\n        \\<Delta> : (if b then e\\<^sub>1\n                    else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>ba.\n           set ba \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> : (if b then e\\<^sub>1\n                       else e\\<^sub>2) \\<Down>\\<^bsub>ba\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : (scrut ? e\\<^sub>1\n                                     : e\\<^sub>2) \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Gamma> : scrut \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : Bool b\n  set ?b \\<subseteq> set L \\<Longrightarrow>\n  \\<Gamma> : scrut \\<Down>\\<^bsub>?b\\<^esub> \\<Delta> : Bool b\n  \\<Delta> : (if b then e\\<^sub>1\n              else e\\<^sub>2) \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z\n  set ?b \\<subseteq> set L \\<Longrightarrow>\n  \\<Delta> : (if b then e\\<^sub>1\n              else e\\<^sub>2) \\<Down>\\<^bsub>?b\\<^esub> \\<Theta> : z\n  set L' \\<subseteq> set L\n\ngoal (1 subgoal):\n 1. \\<Gamma> : (scrut ? e\\<^sub>1\n                : e\\<^sub>2) \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z", "by (metis  reds.IfThenElse)"], ["proof (state)\nthis:\n  \\<Gamma> : (scrut ? e\\<^sub>1\n              : e\\<^sub>2) \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z\n\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z L'.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* L;\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>b.\n           set b \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>b\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : Let \\<Delta>\n                                     body \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z L'.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* L;\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>b.\n           set b \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>b\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : Let \\<Delta>\n                                     body \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z", "case (Let \\<Delta> \\<Gamma>  L body \\<Theta> z L')"], ["proof (state)\nthis:\n  atom ` domA \\<Delta> \\<sharp>* \\<Gamma>\n  atom ` domA \\<Delta> \\<sharp>* L\n  \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z\n  set ?b \\<subseteq> set L \\<Longrightarrow>\n  \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>?b\\<^esub> \\<Theta> : z\n  set L' \\<subseteq> set L\n\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z L'.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* L;\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>b.\n           set b \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>b\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : Let \\<Delta>\n                                     body \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z", "have \"atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L')", "using Let(1-3) Let.prems"], ["proof (prove)\nusing this:\n  atom ` domA \\<Delta> \\<sharp>* \\<Gamma>\n  atom ` domA \\<Delta> \\<sharp>* L\n  \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z\n  set L' \\<subseteq> set L\n\ngoal (1 subgoal):\n 1. atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L')", "by (auto simp add: fresh_star_Pair  fresh_star_set_subset)"], ["proof (state)\nthis:\n  atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L')\n\ngoal (1 subgoal):\n 1. \\<And>\\<Delta> \\<Gamma> L body \\<Theta> z L'.\n       \\<lbrakk>atom ` domA \\<Delta> \\<sharp>* \\<Gamma>;\n        atom ` domA \\<Delta> \\<sharp>* L;\n        \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>L\\<^esub> \\<Theta> : z;\n        \\<And>b.\n           set b \\<subseteq> set L \\<Longrightarrow>\n           \\<Delta> @ \\<Gamma> : body \\<Down>\\<^bsub>b\\<^esub> \\<Theta> : z;\n        set L' \\<subseteq> set L\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> : Let \\<Delta>\n                                     body \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z", "thus ?case"], ["proof (prove)\nusing this:\n  atom ` domA \\<Delta> \\<sharp>* (\\<Gamma>, L')\n\ngoal (1 subgoal):\n 1. \\<Gamma> : Let \\<Delta> body \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z", "by (rule reds.Let[OF _ Let.hyps(4)[OF Let.prems]])"], ["proof (state)\nthis:\n  \\<Gamma> : Let \\<Delta> body \\<Down>\\<^bsub>L'\\<^esub> \\<Theta> : z\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Things are evaluated to a lambda expression, and the variable can be freely chose.\\<close>"], ["", "lemma result_evaluated:\n  \"\\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z \\<Longrightarrow> isVal z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z \\<Longrightarrow>\n    isVal z", "by (induct \\<Gamma> e L \\<Delta> z rule:reds.induct) (auto dest: reds_doesnt_forget)"], ["", "lemma result_evaluated_fresh:\n  assumes \"\\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z\"\n  obtains y e'\n  where \"z = (Lam [y]. e')\" and \"atom y \\<sharp> (c::'a::fs)\" | b where \"z = Bool b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>y e'.\n                \\<lbrakk>z = Lam [y]. e'; atom y \\<sharp> c\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>b. z = Bool b \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>y e'.\n                \\<lbrakk>z = Lam [y]. e'; atom y \\<sharp> c\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>b. z = Bool b \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "from assms"], ["proof (chain)\npicking this:\n  \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z", "have \"isVal z\""], ["proof (prove)\nusing this:\n  \\<Gamma> : e \\<Down>\\<^bsub>L\\<^esub> \\<Delta> : z\n\ngoal (1 subgoal):\n 1. isVal z", "by (rule result_evaluated)"], ["proof (state)\nthis:\n  isVal z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>y e'.\n                \\<lbrakk>z = Lam [y]. e'; atom y \\<sharp> c\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>b. z = Bool b \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"(\\<exists> y e'. z = Lam [y]. e' \\<and> atom y \\<sharp> c) \\<or> (\\<exists> b. z = Bool b)\""], ["proof (prove)\nusing this:\n  isVal z\n\ngoal (1 subgoal):\n 1. (\\<exists>y e'. z = Lam [y]. e' \\<and> atom y \\<sharp> c) \\<or>\n    (\\<exists>b. z = Bool b)", "by (nominal_induct z avoiding: c rule:exp_strong_induct) auto"], ["proof (state)\nthis:\n  (\\<exists>y e'. z = Lam [y]. e' \\<and> atom y \\<sharp> c) \\<or>\n  (\\<exists>b. z = Bool b)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>y e'.\n                \\<lbrakk>z = Lam [y]. e'; atom y \\<sharp> c\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>b. z = Bool b \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus thesis"], ["proof (prove)\nusing this:\n  (\\<exists>y e'. z = Lam [y]. e' \\<and> atom y \\<sharp> c) \\<or>\n  (\\<exists>b. z = Bool b)\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  (\\<exists>y e'. z = Lam [y]. e' \\<and> atom y \\<sharp> c) \\<or>\n  (\\<exists>b. z = Bool b)\n  \\<lbrakk>z = Lam [?y]. ?e'; atom ?y \\<sharp> c\\<rbrakk>\n  \\<Longrightarrow> thesis\n  z = Bool ?b \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}