{"file_name": "/home/qj213/afp-2021-10-22/thys/Launchbury/Substitution.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Launchbury", "problem_names": ["lemma shows\n  True and bn_subst[simp]: \"domA (subst_heap \\<Gamma> y z) = domA \\<Gamma>\"", "lemma subst_noop[simp]:\nshows \"e[y ::= y] = e\" and \"\\<Gamma>[y::h=y]= \\<Gamma>\"", "lemma subst_is_fresh[simp]:\nassumes \"atom y \\<sharp> z\"\nshows\n  \"atom y \\<sharp> e[y ::= z]\"\nand\n \"atom ` domA \\<Gamma> \\<sharp>* y \\<Longrightarrow> atom y \\<sharp> \\<Gamma>[y::h=z]\"", "lemma\n subst_pres_fresh: \"atom x \\<sharp> e \\<or> x = y \\<Longrightarrow> atom x \\<sharp> z \\<Longrightarrow> atom x \\<sharp> e[y ::= z]\"\nand\n \"atom x \\<sharp> \\<Gamma> \\<or> x = y \\<Longrightarrow> atom x \\<sharp> z \\<Longrightarrow> x \\<notin> domA \\<Gamma> \\<Longrightarrow> atom x \\<sharp> (\\<Gamma>[y ::h= z])\"", "lemma subst_fresh_noop: \"atom x \\<sharp> e \\<Longrightarrow> e[x ::= y] = e\"\n  and subst_heap_fresh_noop: \"atom x \\<sharp> \\<Gamma> \\<Longrightarrow>  \\<Gamma>[x ::h= y] = \\<Gamma>\"", "lemma supp_subst_eq: \"supp (e[y::=x]) = (supp e - {atom y}) \\<union> (if atom y \\<in> supp e then {atom x} else {})\"\n  and  \"atom ` domA \\<Gamma> \\<sharp>* y \\<Longrightarrow> supp (\\<Gamma>[y::h=x]) = (supp \\<Gamma> - {atom y}) \\<union> (if atom y \\<in> supp \\<Gamma> then {atom x} else {})\"", "lemma supp_subst: \"supp (e[y::=x]) \\<subseteq> (supp e - {atom y}) \\<union> {atom x}\"", "lemma fv_subst_eq: \"fv (e[y::=x]) = (fv e - {y}) \\<union> (if y \\<in> fv e then {x} else {})\"\n  and  \"atom ` domA \\<Gamma> \\<sharp>* y \\<Longrightarrow> fv (\\<Gamma>[y::h=x]) = (fv \\<Gamma> - {y}) \\<union> (if y \\<in> fv \\<Gamma> then {x} else {})\"", "lemma fv_subst_subset: \"fv (e[y ::= x]) \\<subseteq> (fv e - {y}) \\<union> {x}\"", "lemma fv_subst_int: \"x \\<notin> S \\<Longrightarrow> y \\<notin> S \\<Longrightarrow> fv (e[y ::= x]) \\<inter> S = fv e \\<inter> S\"", "lemma fv_subst_int2: \"x \\<notin> S \\<Longrightarrow> y \\<notin> S \\<Longrightarrow> S \\<inter> fv (e[y ::= x]) = S \\<inter> fv e\"", "lemma subst_swap_same: \"atom x \\<sharp> e \\<Longrightarrow>  (x \\<leftrightarrow> y) \\<bullet> e = e[y ::=x]\"\n  and \"atom x \\<sharp> \\<Gamma> \\<Longrightarrow> atom `domA \\<Gamma> \\<sharp>* y \\<Longrightarrow> (x \\<leftrightarrow> y) \\<bullet> \\<Gamma> = \\<Gamma>[y ::h= x]\"", "lemma subst_subst_back: \"atom x \\<sharp> e \\<Longrightarrow>  e[y::=x][x::=y] = e\" \n  and \"atom x \\<sharp> \\<Gamma> \\<Longrightarrow> atom `domA \\<Gamma> \\<sharp>* y  \\<Longrightarrow> \\<Gamma>[y::h=x][x::h=y] = \\<Gamma>\"", "lemma subst_heap_delete[simp]: \"(delete x \\<Gamma>)[y ::h= z] = delete x (\\<Gamma>[y ::h= z])\"", "lemma subst_nil_iff[simp]: \"\\<Gamma>[x ::h= z] = [] \\<longleftrightarrow> \\<Gamma> = []\"", "lemma subst_SmartLet[simp]:\n  \"atom ` domA \\<Gamma> \\<sharp>* (y,z) \\<Longrightarrow> (SmartLet \\<Gamma> body)[y ::= z] = SmartLet (\\<Gamma>[y ::h= z]) (body[y ::= z])\"", "lemma subst_let_be[simp]:\n  \"atom x'  \\<sharp> y \\<Longrightarrow> atom x' \\<sharp> x \\<Longrightarrow> (let x' be e in exp )[y::=x] = (let x' be e[y::=x] in exp[y::=x])\"", "lemma isLam_subst[simp]: \"isLam e[x::=y] = isLam e\"", "lemma isVal_subst[simp]: \"isVal e[x::=y] = isVal e\"", "lemma thunks_subst[simp]:\n  \"thunks \\<Gamma>[y::h=x] = thunks \\<Gamma>\"", "lemma map_of_subst:\n  \"map_of (\\<Gamma>[x::h=y]) k = map_option (\\<lambda> e . e[x::=y]) (map_of \\<Gamma> k)\"", "lemma mapCollect_subst[simp]:\n  \"{e k v | k\\<mapsto>v\\<in>map_of \\<Gamma>[x::h=y]} = {e k v[x::=y] | k\\<mapsto>v\\<in>map_of \\<Gamma>}\"", "lemma subst_eq_Cons:\n  \"\\<Gamma>[x::h=y] = (x', e)#\\<Delta> \\<longleftrightarrow> (\\<exists> e' \\<Gamma>'. \\<Gamma> = (x',e')#\\<Gamma>' \\<and> e'[x::=y] = e \\<and> \\<Gamma>'[x::h=y] = \\<Delta>)\"", "lemma nonrec_subst:\n  \"atom ` domA \\<Gamma> \\<sharp>* x \\<Longrightarrow> atom ` domA \\<Gamma> \\<sharp>* y \\<Longrightarrow> nonrec \\<Gamma>[x::h=y] \\<longleftrightarrow> nonrec \\<Gamma>\""], "translations": [["", "lemma shows\n  True and bn_subst[simp]: \"domA (subst_heap \\<Gamma> y z) = domA \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. True &&& domA \\<Gamma>[y::h=z] = domA \\<Gamma>", "by(induct rule:subst_subst_heap.induct)\n  (auto simp add: exp_assn.bn_defs fresh_star_insert)"], ["", "lemma subst_noop[simp]:\nshows \"e[y ::= y] = e\" and \"\\<Gamma>[y::h=y]= \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e[y::=y] = e &&& \\<Gamma>[y::h=y] = \\<Gamma>", "by(induct e y y and \\<Gamma> y y rule:subst_subst_heap.induct)\n  (auto simp add:fresh_star_Pair exp_assn.bn_defs)"], ["", "lemma subst_is_fresh[simp]:\nassumes \"atom y \\<sharp> z\"\nshows\n  \"atom y \\<sharp> e[y ::= z]\"\nand\n \"atom ` domA \\<Gamma> \\<sharp>* y \\<Longrightarrow> atom y \\<sharp> \\<Gamma>[y::h=z]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom y \\<sharp> e[y::=z] &&&\n    (atom ` domA \\<Gamma> \\<sharp>* y \\<Longrightarrow>\n     atom y \\<sharp> \\<Gamma>[y::h=z])", "using assms"], ["proof (prove)\nusing this:\n  atom y \\<sharp> z\n\ngoal (1 subgoal):\n 1. atom y \\<sharp> e[y::=z] &&&\n    (atom ` domA \\<Gamma> \\<sharp>* y \\<Longrightarrow>\n     atom y \\<sharp> \\<Gamma>[y::h=z])", "by(induct e y z and \\<Gamma> y z rule:subst_subst_heap.induct)\n  (auto simp add:fresh_at_base fresh_star_Pair fresh_star_insert fresh_Nil fresh_Cons pure_fresh)"], ["", "lemma\n subst_pres_fresh: \"atom x \\<sharp> e \\<or> x = y \\<Longrightarrow> atom x \\<sharp> z \\<Longrightarrow> atom x \\<sharp> e[y ::= z]\"\nand\n \"atom x \\<sharp> \\<Gamma> \\<or> x = y \\<Longrightarrow> atom x \\<sharp> z \\<Longrightarrow> x \\<notin> domA \\<Gamma> \\<Longrightarrow> atom x \\<sharp> (\\<Gamma>[y ::h= z])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>atom x \\<sharp> e \\<or> x = y; atom x \\<sharp> z\\<rbrakk>\n     \\<Longrightarrow> atom x \\<sharp> e[y::=z]) &&&\n    (\\<lbrakk>atom x \\<sharp> \\<Gamma> \\<or> x = y; atom x \\<sharp> z;\n      x \\<notin> domA \\<Gamma>\\<rbrakk>\n     \\<Longrightarrow> atom x \\<sharp> \\<Gamma>[y::h=z])", "by(induct e y z and \\<Gamma> y z rule:subst_subst_heap.induct)\n  (auto simp add:fresh_star_Pair exp_assn.bn_defs fresh_Cons fresh_Nil pure_fresh)"], ["", "lemma subst_fresh_noop: \"atom x \\<sharp> e \\<Longrightarrow> e[x ::= y] = e\"\n  and subst_heap_fresh_noop: \"atom x \\<sharp> \\<Gamma> \\<Longrightarrow>  \\<Gamma>[x ::h= y] = \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (atom x \\<sharp> e \\<Longrightarrow> e[x::=y] = e) &&&\n    (atom x \\<sharp> \\<Gamma> \\<Longrightarrow> \\<Gamma>[x::h=y] = \\<Gamma>)", "by (nominal_induct  e and \\<Gamma> avoiding: x y rule:exp_heap_strong_induct)\n  (auto simp add: fresh_star_def fresh_Pair fresh_at_base fresh_Cons simp del: exp_assn.eq_iff)"], ["", "lemma supp_subst_eq: \"supp (e[y::=x]) = (supp e - {atom y}) \\<union> (if atom y \\<in> supp e then {atom x} else {})\"\n  and  \"atom ` domA \\<Gamma> \\<sharp>* y \\<Longrightarrow> supp (\\<Gamma>[y::h=x]) = (supp \\<Gamma> - {atom y}) \\<union> (if atom y \\<in> supp \\<Gamma> then {atom x} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp e[y::=x] =\n    supp e - {atom y} \\<union>\n    (if atom y \\<in> supp e then {atom x} else {}) &&&\n    (atom ` domA \\<Gamma> \\<sharp>* y \\<Longrightarrow>\n     supp \\<Gamma>[y::h=x] =\n     supp \\<Gamma> - {atom y} \\<union>\n     (if atom y \\<in> supp \\<Gamma> then {atom x} else {}))", "by (nominal_induct  e  and \\<Gamma> avoiding: x y rule:exp_heap_strong_induct)\n   (auto simp add: fresh_star_def fresh_Pair supp_Nil supp_Cons supp_Pair fresh_Cons exp_assn.supp Let_supp supp_at_base pure_supp simp del: exp_assn.eq_iff)"], ["", "lemma supp_subst: \"supp (e[y::=x]) \\<subseteq> (supp e - {atom y}) \\<union> {atom x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp e[y::=x] \\<subseteq> supp e - {atom y} \\<union> {atom x}", "using supp_subst_eq"], ["proof (prove)\nusing this:\n  supp ?e[?y::=?x] =\n  supp ?e - {atom ?y} \\<union>\n  (if atom ?y \\<in> supp ?e then {atom ?x} else {})\n\ngoal (1 subgoal):\n 1. supp e[y::=x] \\<subseteq> supp e - {atom y} \\<union> {atom x}", "by auto"], ["", "lemma fv_subst_eq: \"fv (e[y::=x]) = (fv e - {y}) \\<union> (if y \\<in> fv e then {x} else {})\"\n  and  \"atom ` domA \\<Gamma> \\<sharp>* y \\<Longrightarrow> fv (\\<Gamma>[y::h=x]) = (fv \\<Gamma> - {y}) \\<union> (if y \\<in> fv \\<Gamma> then {x} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv e[y::=x] = fv e - {y} \\<union> (if y \\<in> fv e then {x} else {}) &&&\n    (atom ` domA \\<Gamma> \\<sharp>* y \\<Longrightarrow>\n     fv \\<Gamma>[y::h=x] =\n     fv \\<Gamma> - {y} \\<union> (if y \\<in> fv \\<Gamma> then {x} else {}))", "by (nominal_induct  e  and \\<Gamma> avoiding: x y rule:exp_heap_strong_induct)\n   (auto simp add: fresh_star_def fresh_Pair supp_Nil supp_Cons supp_Pair fresh_Cons exp_assn.supp Let_supp supp_at_base simp del: exp_assn.eq_iff)"], ["", "lemma fv_subst_subset: \"fv (e[y ::= x]) \\<subseteq> (fv e - {y}) \\<union> {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv e[y::=x] \\<subseteq> fv e - {y} \\<union> {x}", "using fv_subst_eq"], ["proof (prove)\nusing this:\n  fv ?e[?y::=?x] =\n  fv ?e - {?y} \\<union> (if ?y \\<in> fv ?e then {?x} else {})\n\ngoal (1 subgoal):\n 1. fv e[y::=x] \\<subseteq> fv e - {y} \\<union> {x}", "by auto"], ["", "lemma fv_subst_int: \"x \\<notin> S \\<Longrightarrow> y \\<notin> S \\<Longrightarrow> fv (e[y ::= x]) \\<inter> S = fv e \\<inter> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> S; y \\<notin> S\\<rbrakk>\n    \\<Longrightarrow> fv e[y::=x] \\<inter> S = fv e \\<inter> S", "by (auto simp add: fv_subst_eq)"], ["", "lemma fv_subst_int2: \"x \\<notin> S \\<Longrightarrow> y \\<notin> S \\<Longrightarrow> S \\<inter> fv (e[y ::= x]) = S \\<inter> fv e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> S; y \\<notin> S\\<rbrakk>\n    \\<Longrightarrow> S \\<inter> fv e[y::=x] = S \\<inter> fv e", "by (auto simp add: fv_subst_eq)"], ["", "lemma subst_swap_same: \"atom x \\<sharp> e \\<Longrightarrow>  (x \\<leftrightarrow> y) \\<bullet> e = e[y ::=x]\"\n  and \"atom x \\<sharp> \\<Gamma> \\<Longrightarrow> atom `domA \\<Gamma> \\<sharp>* y \\<Longrightarrow> (x \\<leftrightarrow> y) \\<bullet> \\<Gamma> = \\<Gamma>[y ::h= x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (atom x \\<sharp> e \\<Longrightarrow>\n     (x \\<leftrightarrow> y) \\<bullet> e = e[y::=x]) &&&\n    (\\<lbrakk>atom x \\<sharp> \\<Gamma>;\n      atom ` domA \\<Gamma> \\<sharp>* y\\<rbrakk>\n     \\<Longrightarrow> (x \\<leftrightarrow> y) \\<bullet> \\<Gamma> =\n                       \\<Gamma>[y::h=x])", "by (nominal_induct  e and \\<Gamma> avoiding: x y rule:exp_heap_strong_induct)\n   (auto simp add: fresh_star_Pair fresh_star_at_base fresh_Cons pure_fresh permute_pure simp del: exp_assn.eq_iff)"], ["", "lemma subst_subst_back: \"atom x \\<sharp> e \\<Longrightarrow>  e[y::=x][x::=y] = e\" \n  and \"atom x \\<sharp> \\<Gamma> \\<Longrightarrow> atom `domA \\<Gamma> \\<sharp>* y  \\<Longrightarrow> \\<Gamma>[y::h=x][x::h=y] = \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (atom x \\<sharp> e \\<Longrightarrow> e[y::=x][x::=y] = e) &&&\n    (\\<lbrakk>atom x \\<sharp> \\<Gamma>;\n      atom ` domA \\<Gamma> \\<sharp>* y\\<rbrakk>\n     \\<Longrightarrow> \\<Gamma>[y::h=x][x::h=y] = \\<Gamma>)", "by(nominal_induct  e and \\<Gamma> avoiding: x y rule:exp_heap_strong_induct)\n  (auto simp add: fresh_star_Pair fresh_star_at_base fresh_star_Cons fresh_Cons  exp_assn.bn_defs simp del: exp_assn.eq_iff)"], ["", "lemma subst_heap_delete[simp]: \"(delete x \\<Gamma>)[y ::h= z] = delete x (\\<Gamma>[y ::h= z])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (delete x \\<Gamma>)[y::h=z] = delete x \\<Gamma>[y::h=z]", "by (induction \\<Gamma>) auto"], ["", "lemma subst_nil_iff[simp]: \"\\<Gamma>[x ::h= z] = [] \\<longleftrightarrow> \\<Gamma> = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Gamma>[x::h=z] = []) = (\\<Gamma> = [])", "by (cases \\<Gamma>) auto"], ["", "lemma subst_SmartLet[simp]:\n  \"atom ` domA \\<Gamma> \\<sharp>* (y,z) \\<Longrightarrow> (SmartLet \\<Gamma> body)[y ::= z] = SmartLet (\\<Gamma>[y ::h= z]) (body[y ::= z])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom ` domA \\<Gamma> \\<sharp>* (y, z) \\<Longrightarrow>\n    (SmartLet \\<Gamma> body)[y::=z] = SmartLet \\<Gamma>[y::h=z] body[y::=z]", "unfolding SmartLet_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. atom ` domA \\<Gamma> \\<sharp>* (y, z) \\<Longrightarrow>\n    (if \\<Gamma> = [] then body else Let \\<Gamma> body)[y::=z] =\n    (if \\<Gamma>[y::h=z] = [] then body[y::=z]\n     else Let \\<Gamma>[y::h=z] body[y::=z])", "by auto"], ["", "lemma subst_let_be[simp]:\n  \"atom x'  \\<sharp> y \\<Longrightarrow> atom x' \\<sharp> x \\<Longrightarrow> (let x' be e in exp )[y::=x] = (let x' be e[y::=x] in exp[y::=x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom x' \\<sharp> y; atom x' \\<sharp> x\\<rbrakk>\n    \\<Longrightarrow> (let x' be e in exp )[y::=x] =\n                      let x' be e[y::=x] in exp[y::=x]", "by (simp add: fresh_star_def fresh_Pair)"], ["", "lemma isLam_subst[simp]: \"isLam e[x::=y] = isLam e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isLam e[x::=y] = isLam e", "by (nominal_induct e avoiding: x y  rule: exp_strong_induct)\n     (auto simp add: fresh_star_Pair)"], ["", "lemma isVal_subst[simp]: \"isVal e[x::=y] = isVal e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isVal e[x::=y] = isVal e", "by (nominal_induct e avoiding: x y  rule: exp_strong_induct)\n     (auto simp add: fresh_star_Pair)"], ["", "lemma thunks_subst[simp]:\n  \"thunks \\<Gamma>[y::h=x] = thunks \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thunks \\<Gamma>[y::h=x] = thunks \\<Gamma>", "by (induction \\<Gamma>) (auto simp add: thunks_Cons)"], ["", "lemma map_of_subst:\n  \"map_of (\\<Gamma>[x::h=y]) k = map_option (\\<lambda> e . e[x::=y]) (map_of \\<Gamma> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of \\<Gamma>[x::h=y] k =\n    map_option (\\<lambda>e. e[x::=y]) (map_of \\<Gamma> k)", "by (induction \\<Gamma> ) auto"], ["", "lemma mapCollect_subst[simp]:\n  \"{e k v | k\\<mapsto>v\\<in>map_of \\<Gamma>[x::h=y]} = {e k v[x::=y] | k\\<mapsto>v\\<in>map_of \\<Gamma>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mapCollect e (map_of \\<Gamma>[x::h=y]) =\n    {e k v[x::=y] |k\\<mapsto>v\\<in>map_of \\<Gamma>}", "by (auto simp add: map_of_subst)"], ["", "lemma subst_eq_Cons:\n  \"\\<Gamma>[x::h=y] = (x', e)#\\<Delta> \\<longleftrightarrow> (\\<exists> e' \\<Gamma>'. \\<Gamma> = (x',e')#\\<Gamma>' \\<and> e'[x::=y] = e \\<and> \\<Gamma>'[x::h=y] = \\<Delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Gamma>[x::h=y] = (x', e) # \\<Delta>) =\n    (\\<exists>e' \\<Gamma>'.\n        \\<Gamma> = (x', e') # \\<Gamma>' \\<and>\n        e'[x::=y] = e \\<and> \\<Gamma>'[x::h=y] = \\<Delta>)", "by (cases \\<Gamma>) auto"], ["", "lemma nonrec_subst:\n  \"atom ` domA \\<Gamma> \\<sharp>* x \\<Longrightarrow> atom ` domA \\<Gamma> \\<sharp>* y \\<Longrightarrow> nonrec \\<Gamma>[x::h=y] \\<longleftrightarrow> nonrec \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atom ` domA \\<Gamma> \\<sharp>* x;\n     atom ` domA \\<Gamma> \\<sharp>* y\\<rbrakk>\n    \\<Longrightarrow> nonrec \\<Gamma>[x::h=y] = nonrec \\<Gamma>", "by (auto simp add: nonrec_def  fresh_star_def subst_eq_Cons fv_subst_eq)"], ["", "end"]]}