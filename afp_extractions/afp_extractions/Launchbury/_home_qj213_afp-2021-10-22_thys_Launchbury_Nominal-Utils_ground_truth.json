{"file_name": "/home/qj213/afp-2021-10-22/thys/Launchbury/Nominal-Utils.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Launchbury", "problem_names": ["lemma perm_rel_lemma:\n  assumes \"\\<And> \\<pi> x y. r (\\<pi> \\<bullet> x) (\\<pi> \\<bullet> y) \\<Longrightarrow> r x y\"\n  shows \"r (\\<pi> \\<bullet> x) (\\<pi> \\<bullet> y) \\<longleftrightarrow> r x y\" (is \"?l \\<longleftrightarrow> ?r\")", "lemma perm_rel_lemma2:\n  assumes \"\\<And> \\<pi> x y. r x y \\<Longrightarrow> r (\\<pi> \\<bullet> x) (\\<pi> \\<bullet> y)\"\n  shows \"r x y \\<longleftrightarrow> r (\\<pi> \\<bullet> x) (\\<pi> \\<bullet> y)\" (is \"?l \\<longleftrightarrow> ?r\")", "lemma fun_eqvtI:\n  assumes f_eqvt[eqvt]: \"(\\<And> p x. p \\<bullet> (f x) = f (p \\<bullet> x))\"\n  shows \"p \\<bullet> f = f\"", "lemma eqvt_at_apply:\n  assumes \"eqvt_at f x\"\n  shows \"(p \\<bullet> f) x = f x\"", "lemma eqvt_at_apply':\n  assumes \"eqvt_at f x\"\n  shows \"p \\<bullet> f x = f (p \\<bullet> x)\"", "lemma eqvt_at_apply'':\n  assumes \"eqvt_at f x\"\n  shows \"(p \\<bullet> f) (p \\<bullet> x) = f (p \\<bullet> x)\"", "lemma size_list_eqvt[eqvt]: \"p \\<bullet> size_list f x = size_list (p \\<bullet> f) (p \\<bullet> x)\"", "lemma eqvt_fresh_cong1: \"(\\<And>p x. p \\<bullet> (f x) = f (p \\<bullet> x)) \\<Longrightarrow> a \\<sharp> x \\<Longrightarrow> a \\<sharp> f x \"", "lemma eqvt_fresh_cong2:\n  assumes eqvt: \"(\\<And>p x y. p \\<bullet> (f x y) = f (p \\<bullet> x) (p \\<bullet> y))\"\n  and fresh1: \"a \\<sharp> x\" and fresh2: \"a \\<sharp> y\"\n  shows \"a \\<sharp> f x y\"", "lemma eqvt_fresh_star_cong1:\n  assumes eqvt: \"(\\<And>p x. p \\<bullet> (f x) = f (p \\<bullet> x))\"\n  and fresh1: \"a \\<sharp>* x\"\n  shows \"a \\<sharp>* f x\"", "lemma eqvt_fresh_star_cong2:\n  assumes eqvt: \"(\\<And>p x y. p \\<bullet> (f x y) = f (p \\<bullet> x) (p \\<bullet> y))\"\n  and fresh1: \"a \\<sharp>* x\" and fresh2: \"a \\<sharp>* y\"\n  shows \"a \\<sharp>* f x y\"", "lemma eqvt_fresh_cong3:\n  assumes eqvt: \"(\\<And>p x y z. p \\<bullet> (f x y z) = f (p \\<bullet> x) (p \\<bullet> y) (p \\<bullet> z))\"\n  and fresh1: \"a \\<sharp> x\" and fresh2: \"a \\<sharp> y\" and fresh3: \"a \\<sharp> z\"\n  shows \"a \\<sharp> f x y z\"", "lemma eqvt_fresh_star_cong3:\n  assumes eqvt: \"(\\<And>p x y z. p \\<bullet> (f x y z) = f (p \\<bullet> x) (p \\<bullet> y) (p \\<bullet> z))\"\n  and fresh1: \"a \\<sharp>* x\" and fresh2: \"a \\<sharp>* y\" and fresh3: \"a \\<sharp>* z\"\n  shows \"a \\<sharp>* f x y z\"", "lemma not_self_fresh[simp]: \"atom x \\<sharp> x \\<longleftrightarrow> False\"", "lemma fresh_star_singleton: \"{ x } \\<sharp>* e \\<longleftrightarrow> x \\<sharp> e\"", "lemma eqvt_cases:\n  fixes f x \\<pi>\n  assumes eqvt: \"\\<And>x. \\<pi> \\<bullet> f x = f (\\<pi> \\<bullet> x)\"\n  obtains \"f x\" \"f (\\<pi> \\<bullet> x)\" | \"\\<not> f x \" \" \\<not> f (\\<pi> \\<bullet> x)\"", "lemma range_eqvt: \"\\<pi> \\<bullet> range Y = range (\\<pi> \\<bullet> Y)\"", "lemma case_option_eqvt[eqvt]:\n  \"\\<pi> \\<bullet> case_option d f x = case_option (\\<pi> \\<bullet> d) (\\<pi> \\<bullet> f) (\\<pi> \\<bullet> x)\"", "lemma supp_option_eqvt:\n  \"supp (case_option d f x) \\<subseteq> supp d \\<union> supp f \\<union> supp x\"", "lemma funpow_eqvt[simp,eqvt]:\n  \"\\<pi> \\<bullet> ((f :: 'a \\<Rightarrow> 'a::pt) ^^ n) = (\\<pi> \\<bullet> f) ^^ (\\<pi> \\<bullet> n)\"", "lemma delete_eqvt[eqvt]:\n  \"\\<pi> \\<bullet> AList.delete x \\<Gamma> = AList.delete (\\<pi> \\<bullet> x) (\\<pi> \\<bullet> \\<Gamma>)\"", "lemma restrict_eqvt[eqvt]:\n  \"\\<pi> \\<bullet> AList.restrict S \\<Gamma> = AList.restrict (\\<pi> \\<bullet> S) (\\<pi> \\<bullet> \\<Gamma>)\"", "lemma supp_restrict:\n  \"supp (AList.restrict S \\<Gamma>) \\<subseteq> supp \\<Gamma>\"", "lemma clearjunk_eqvt[eqvt]:\n  \"\\<pi> \\<bullet> AList.clearjunk \\<Gamma> = AList.clearjunk (\\<pi> \\<bullet> \\<Gamma>)\"", "lemma map_ran_eqvt[eqvt]:\n  \"\\<pi> \\<bullet> map_ran f \\<Gamma> = map_ran (\\<pi> \\<bullet> f) (\\<pi> \\<bullet> \\<Gamma>)\"", "lemma dom_perm:\n  \"dom (\\<pi> \\<bullet> f) = \\<pi> \\<bullet> (dom f)\"", "lemmas dom_perm_rev[simp,eqvt] = dom_perm[symmetric]", "lemma ran_perm[simp]:\n  \"\\<pi> \\<bullet> (ran f) = ran (\\<pi> \\<bullet> f)\"", "lemma map_add_eqvt[eqvt]:\n  \"\\<pi> \\<bullet> (m1 ++ m2) = (\\<pi> \\<bullet> m1) ++ (\\<pi> \\<bullet> m2)\"", "lemma map_of_eqvt[eqvt]:\n  \"\\<pi> \\<bullet> map_of l = map_of (\\<pi> \\<bullet> l)\"", "lemma concat_eqvt[eqvt]: \"\\<pi> \\<bullet> concat l = concat (\\<pi> \\<bullet> l)\"", "lemma tranclp_eqvt[eqvt]: \"\\<pi> \\<bullet> tranclp P v\\<^sub>1 v\\<^sub>2 = tranclp (\\<pi> \\<bullet> P) (\\<pi> \\<bullet> v\\<^sub>1) (\\<pi> \\<bullet> v\\<^sub>2)\"", "lemma rtranclp_eqvt[eqvt]: \"\\<pi> \\<bullet> rtranclp P v\\<^sub>1 v\\<^sub>2 = rtranclp (\\<pi> \\<bullet> P) (\\<pi> \\<bullet> v\\<^sub>1) (\\<pi> \\<bullet> v\\<^sub>2)\"", "lemma Set_filter_eqvt[eqvt]: \"\\<pi> \\<bullet> Set.filter P S = Set.filter (\\<pi> \\<bullet> P) (\\<pi> \\<bullet> S)\"", "lemma Sigma_eqvt'[eqvt]: \"\\<pi> \\<bullet> Sigma = Sigma\"", "lemma override_on_eqvt[eqvt]:\n  \"\\<pi> \\<bullet> (override_on m1 m2 S) = override_on (\\<pi> \\<bullet> m1) (\\<pi> \\<bullet> m2) (\\<pi> \\<bullet> S)\"", "lemma card_eqvt[eqvt]:\n  \"\\<pi> \\<bullet> (card S) = card (\\<pi> \\<bullet> S)\"", "lemma Projl_permute:\n  assumes a: \"\\<exists>y. f = Inl y\"\n  shows \"(p \\<bullet> (Sum_Type.projl f)) = Sum_Type.projl (p \\<bullet> f)\"", "lemma Projr_permute:\n  assumes a: \"\\<exists>y. f = Inr y\"\n  shows \"(p \\<bullet> (Sum_Type.projr f)) = Sum_Type.projr (p \\<bullet> f)\"", "lemma fresh_list_elem:\n  assumes \"a \\<sharp> \\<Gamma>\"\n  and \"e \\<in> set \\<Gamma>\"\n  shows \"a \\<sharp> e\"", "lemma set_not_fresh:\n  \"x \\<in> set L \\<Longrightarrow> \\<not>(atom x \\<sharp> L)\"", "lemma pure_fresh_star[simp]: \"a \\<sharp>* (x :: 'a :: pure)\"", "lemma supp_set_mem: \"x \\<in> set L \\<Longrightarrow> supp x \\<subseteq> supp L\"", "lemma set_supp_mono: \"set L \\<subseteq> set L2 \\<Longrightarrow> supp L \\<subseteq> supp L2\"", "lemma fresh_star_at_base:\n  fixes x :: \"'a :: at_base\"\n  shows \"S \\<sharp>* x \\<longleftrightarrow> atom x \\<notin> S\"", "lemma supp_mono: \"finite (B::'a::fs set) \\<Longrightarrow> A \\<subseteq> B \\<Longrightarrow> supp A \\<subseteq> supp B\"", "lemma fresh_subset:\n  \"finite B \\<Longrightarrow> x \\<sharp> (B :: 'a::at_base set) \\<Longrightarrow> A \\<subseteq> B \\<Longrightarrow> x \\<sharp> A\"", "lemma fresh_star_subset:\n  \"finite B \\<Longrightarrow> x \\<sharp>* (B :: 'a::at_base set) \\<Longrightarrow> A \\<subseteq> B \\<Longrightarrow> x \\<sharp>* A\"", "lemma fresh_star_set_subset:\n  \"x \\<sharp>* (B :: 'a::at_base list) \\<Longrightarrow> set A \\<subseteq> set B \\<Longrightarrow> x \\<sharp>* A\"", "lemma fv_eqvt[simp,eqvt]: \"\\<pi> \\<bullet> (fv e) = fv (\\<pi> \\<bullet> e)\"", "lemma fv_Nil[simp]: \"fv [] = {}\"", "lemma fv_Cons[simp]: \"fv (x # xs) = fv x \\<union> fv xs\"", "lemma fv_Pair[simp]: \"fv (x, y) = fv x \\<union> fv y\"", "lemma fv_append[simp]: \"fv (x @ y) = fv x \\<union> fv y\"", "lemma fv_at_base[simp]: \"fv a = {a::'a::at_base}\"", "lemma fv_pure[simp]: \"fv (a::'a::pure) = {}\"", "lemma fv_set_at_base[simp]: \"fv (l :: ('a :: at_base) list) = set l\"", "lemma flip_not_fv: \"a \\<notin> fv x \\<Longrightarrow> b \\<notin> fv x \\<Longrightarrow> (a \\<leftrightarrow> b) \\<bullet> x = x\"", "lemma fv_not_fresh: \"atom x \\<sharp> e \\<longleftrightarrow> x \\<notin> fv e\"", "lemma fresh_fv: \"finite (fv e :: 'a set) \\<Longrightarrow>  atom (x :: ('a::at_base)) \\<sharp> (fv e :: 'a set) \\<longleftrightarrow> atom x \\<sharp> e\"", "lemma finite_fv[simp]: \"finite (fv (e::'a::fs) :: ('b::at_base) set)\"", "lemma set_fv_list[simp]: \"set (fv_list e) = (fv e :: ('b::at_base) set)\"", "lemma fresh_fv_list[simp]:\n  \"a \\<sharp> (fv_list e :: 'b::at_base list) \\<longleftrightarrow> a \\<sharp> (fv e :: 'b::at_base set)\"", "lemma pure_permute_id: \"permute p = (\\<lambda> x. (x::'a::pure))\"", "lemma supp_set_elem_finite:\n  assumes \"finite S\"\n  and \"(m::'a::fs) \\<in> S\"\n  and \"y \\<in> supp m\"\n  shows \"y \\<in> supp S\"", "lemmas fresh_star_Cons = fresh_star_list(2)", "lemma mem_permute_set: \n  shows \"x \\<in> p \\<bullet> S \\<longleftrightarrow> (- p \\<bullet> x) \\<in> S\"", "lemma flip_set_both_not_in:\n  assumes \"x \\<notin> S\" and \"x' \\<notin> S\"\n  shows \"((x' \\<leftrightarrow> x) \\<bullet> S) = S\"", "lemma inj_atom: \"inj atom\"", "lemmas image_Int[OF inj_atom, simp]", "lemma eqvt_uncurry: \"eqvt f \\<Longrightarrow> eqvt (case_prod f)\"", "lemma supp_fun_app_eqvt2:\n  assumes a: \"eqvt f\"\n  shows \"supp (f x y) \\<subseteq> supp x \\<union> supp y\"", "lemma supp_fun_app_eqvt3:\n  assumes a: \"eqvt f\"\n  shows \"supp (f x y z) \\<subseteq> supp x \\<union> supp y \\<union> supp z\"", "lemma permute_0[simp]: \"permute 0 = (\\<lambda> x. x)\"", "lemma permute_comp[simp]: \"permute x \\<circ> permute y = permute (x + y)\"", "lemma map_permute: \"map (permute p) = permute p\"", "lemma fresh_star_restrictA[intro]: \"a \\<sharp>* \\<Gamma> \\<Longrightarrow> a \\<sharp>* AList.restrict V \\<Gamma>\"", "lemma Abs_lst_Nil_eq[simp]: \"[[]]lst. (x::'a::fs) = [xs]lst. x' \\<longleftrightarrow> (([],x) = (xs, x'))\"", "lemma Abs_lst_Nil_eq2[simp]: \"[xs]lst. (x::'a::fs) = [[]]lst. x' \\<longleftrightarrow> ((xs,x) = ([], x'))\""], "translations": [["", "lemma perm_rel_lemma:\n  assumes \"\\<And> \\<pi> x y. r (\\<pi> \\<bullet> x) (\\<pi> \\<bullet> y) \\<Longrightarrow> r x y\"\n  shows \"r (\\<pi> \\<bullet> x) (\\<pi> \\<bullet> y) \\<longleftrightarrow> r x y\" (is \"?l \\<longleftrightarrow> ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. r (\\<pi> \\<bullet> x) (\\<pi> \\<bullet> y) = r x y", "by (metis (full_types) assms permute_minus_cancel(2))"], ["", "lemma perm_rel_lemma2:\n  assumes \"\\<And> \\<pi> x y. r x y \\<Longrightarrow> r (\\<pi> \\<bullet> x) (\\<pi> \\<bullet> y)\"\n  shows \"r x y \\<longleftrightarrow> r (\\<pi> \\<bullet> x) (\\<pi> \\<bullet> y)\" (is \"?l \\<longleftrightarrow> ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. r x y = r (\\<pi> \\<bullet> x) (\\<pi> \\<bullet> y)", "by (metis (full_types) assms permute_minus_cancel(2))"], ["", "lemma fun_eqvtI:\n  assumes f_eqvt[eqvt]: \"(\\<And> p x. p \\<bullet> (f x) = f (p \\<bullet> x))\"\n  shows \"p \\<bullet> f = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> f = f", "by perm_simp rule"], ["", "lemma eqvt_at_apply:\n  assumes \"eqvt_at f x\"\n  shows \"(p \\<bullet> f) x = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<bullet> f) x = f x", "by (metis (hide_lams, no_types) assms eqvt_at_def permute_fun_def permute_minus_cancel(1))"], ["", "lemma eqvt_at_apply':\n  assumes \"eqvt_at f x\"\n  shows \"p \\<bullet> f x = f (p \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> f x = f (p \\<bullet> x)", "by (metis (hide_lams, no_types) assms eqvt_at_def)"], ["", "lemma eqvt_at_apply'':\n  assumes \"eqvt_at f x\"\n  shows \"(p \\<bullet> f) (p \\<bullet> x) = f (p \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<bullet> f) (p \\<bullet> x) = f (p \\<bullet> x)", "by (metis (hide_lams, no_types) assms eqvt_at_def permute_fun_def permute_minus_cancel(1))"], ["", "lemma size_list_eqvt[eqvt]: \"p \\<bullet> size_list f x = size_list (p \\<bullet> f) (p \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> size_list f x = size_list (p \\<bullet> f) (p \\<bullet> x)", "proof (induction x)"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<bullet> size_list f [] = size_list (p \\<bullet> f) (p \\<bullet> [])\n 2. \\<And>a x.\n       p \\<bullet> size_list f x =\n       size_list (p \\<bullet> f) (p \\<bullet> x) \\<Longrightarrow>\n       p \\<bullet> size_list f (a # x) =\n       size_list (p \\<bullet> f) (p \\<bullet> (a # x))", "case (Cons x xs)"], ["proof (state)\nthis:\n  p \\<bullet> size_list f xs = size_list (p \\<bullet> f) (p \\<bullet> xs)\n\ngoal (2 subgoals):\n 1. p \\<bullet> size_list f [] = size_list (p \\<bullet> f) (p \\<bullet> [])\n 2. \\<And>a x.\n       p \\<bullet> size_list f x =\n       size_list (p \\<bullet> f) (p \\<bullet> x) \\<Longrightarrow>\n       p \\<bullet> size_list f (a # x) =\n       size_list (p \\<bullet> f) (p \\<bullet> (a # x))", "have \"f x = p \\<bullet> (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x = p \\<bullet> f x", "by (simp add: permute_pure)"], ["proof (state)\nthis:\n  f x = p \\<bullet> f x\n\ngoal (2 subgoals):\n 1. p \\<bullet> size_list f [] = size_list (p \\<bullet> f) (p \\<bullet> [])\n 2. \\<And>a x.\n       p \\<bullet> size_list f x =\n       size_list (p \\<bullet> f) (p \\<bullet> x) \\<Longrightarrow>\n       p \\<bullet> size_list f (a # x) =\n       size_list (p \\<bullet> f) (p \\<bullet> (a # x))", "also"], ["proof (state)\nthis:\n  f x = p \\<bullet> f x\n\ngoal (2 subgoals):\n 1. p \\<bullet> size_list f [] = size_list (p \\<bullet> f) (p \\<bullet> [])\n 2. \\<And>a x.\n       p \\<bullet> size_list f x =\n       size_list (p \\<bullet> f) (p \\<bullet> x) \\<Longrightarrow>\n       p \\<bullet> size_list f (a # x) =\n       size_list (p \\<bullet> f) (p \\<bullet> (a # x))", "have \"... = (p \\<bullet> f) (p \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> f x = (p \\<bullet> f) (p \\<bullet> x)", "by simp"], ["proof (state)\nthis:\n  p \\<bullet> f x = (p \\<bullet> f) (p \\<bullet> x)\n\ngoal (2 subgoals):\n 1. p \\<bullet> size_list f [] = size_list (p \\<bullet> f) (p \\<bullet> [])\n 2. \\<And>a x.\n       p \\<bullet> size_list f x =\n       size_list (p \\<bullet> f) (p \\<bullet> x) \\<Longrightarrow>\n       p \\<bullet> size_list f (a # x) =\n       size_list (p \\<bullet> f) (p \\<bullet> (a # x))", "with Cons"], ["proof (chain)\npicking this:\n  p \\<bullet> size_list f xs = size_list (p \\<bullet> f) (p \\<bullet> xs)\n  p \\<bullet> f x = (p \\<bullet> f) (p \\<bullet> x)", "show ?case"], ["proof (prove)\nusing this:\n  p \\<bullet> size_list f xs = size_list (p \\<bullet> f) (p \\<bullet> xs)\n  p \\<bullet> f x = (p \\<bullet> f) (p \\<bullet> x)\n\ngoal (1 subgoal):\n 1. p \\<bullet> size_list f (x # xs) =\n    size_list (p \\<bullet> f) (p \\<bullet> (x # xs))", "by (auto simp add: permute_pure)"], ["proof (state)\nthis:\n  p \\<bullet> size_list f (x # xs) =\n  size_list (p \\<bullet> f) (p \\<bullet> (x # xs))\n\ngoal (1 subgoal):\n 1. p \\<bullet> size_list f [] = size_list (p \\<bullet> f) (p \\<bullet> [])", "qed simp"], ["", "subsubsection \\<open>Freshness via equivariance\\<close>"], ["", "lemma eqvt_fresh_cong1: \"(\\<And>p x. p \\<bullet> (f x) = f (p \\<bullet> x)) \\<Longrightarrow> a \\<sharp> x \\<Longrightarrow> a \\<sharp> f x \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p x. p \\<bullet> f x = f (p \\<bullet> x);\n     a \\<sharp> x\\<rbrakk>\n    \\<Longrightarrow> a \\<sharp> f x", "apply (rule fresh_fun_eqvt_app[of f])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p x. p \\<bullet> f x = f (p \\<bullet> x);\n     a \\<sharp> x\\<rbrakk>\n    \\<Longrightarrow> eqvt f\n 2. \\<lbrakk>\\<And>p x. p \\<bullet> f x = f (p \\<bullet> x);\n     a \\<sharp> x\\<rbrakk>\n    \\<Longrightarrow> a \\<sharp> x", "apply (rule eqvtI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>p x. p \\<bullet> f x = f (p \\<bullet> x);\n        a \\<sharp> x\\<rbrakk>\n       \\<Longrightarrow> p \\<bullet> f \\<equiv> f\n 2. \\<lbrakk>\\<And>p x. p \\<bullet> f x = f (p \\<bullet> x);\n     a \\<sharp> x\\<rbrakk>\n    \\<Longrightarrow> a \\<sharp> x", "apply (rule eq_reflection)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>p x. p \\<bullet> f x = f (p \\<bullet> x);\n        a \\<sharp> x\\<rbrakk>\n       \\<Longrightarrow> p \\<bullet> f = f\n 2. \\<lbrakk>\\<And>p x. p \\<bullet> f x = f (p \\<bullet> x);\n     a \\<sharp> x\\<rbrakk>\n    \\<Longrightarrow> a \\<sharp> x", "apply (rule ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p xa.\n       \\<lbrakk>\\<And>p x. p \\<bullet> f x = f (p \\<bullet> x);\n        a \\<sharp> x\\<rbrakk>\n       \\<Longrightarrow> (p \\<bullet> f) xa = f xa\n 2. \\<lbrakk>\\<And>p x. p \\<bullet> f x = f (p \\<bullet> x);\n     a \\<sharp> x\\<rbrakk>\n    \\<Longrightarrow> a \\<sharp> x", "apply (metis permute_fun_def permute_minus_cancel(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p x. p \\<bullet> f x = f (p \\<bullet> x);\n     a \\<sharp> x\\<rbrakk>\n    \\<Longrightarrow> a \\<sharp> x", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma eqvt_fresh_cong2:\n  assumes eqvt: \"(\\<And>p x y. p \\<bullet> (f x y) = f (p \\<bullet> x) (p \\<bullet> y))\"\n  and fresh1: \"a \\<sharp> x\" and fresh2: \"a \\<sharp> y\"\n  shows \"a \\<sharp> f x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> f x y", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<sharp> f x y", "have \"eqvt (\\<lambda> (x,y). f x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eqvt (\\<lambda>(x, y). f x y)", "using eqvt"], ["proof (prove)\nusing this:\n  ?p \\<bullet> f ?x ?y = f (?p \\<bullet> ?x) (?p \\<bullet> ?y)\n\ngoal (1 subgoal):\n 1. eqvt (\\<lambda>(x, y). f x y)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p x y.\n        p \\<bullet> f x y =\n        f (p \\<bullet> x) (p \\<bullet> y)) \\<Longrightarrow>\n    eqvt (\\<lambda>(x, y). f x y)", "apply (auto simp add: eqvt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       (\\<And>p x y.\n           (p \\<bullet> f) (p \\<bullet> x) (p \\<bullet> y) =\n           f (p \\<bullet> x) (p \\<bullet> y)) \\<Longrightarrow>\n       (\\<lambda>(x, y). (p \\<bullet> f) x y) = (\\<lambda>(x, y). f x y)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p x.\n       (\\<And>p x y.\n           (p \\<bullet> f) (p \\<bullet> x) (p \\<bullet> y) =\n           f (p \\<bullet> x) (p \\<bullet> y)) \\<Longrightarrow>\n       (case x of (x, xa) \\<Rightarrow> (p \\<bullet> f) x xa) =\n       (case x of (x, xa) \\<Rightarrow> f x xa)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p a b.\n       (\\<And>p x y.\n           (p \\<bullet> f) (p \\<bullet> x) (p \\<bullet> y) =\n           f (p \\<bullet> x) (p \\<bullet> y)) \\<Longrightarrow>\n       (p \\<bullet> f) a b = f a b", "by (metis permute_minus_cancel(1))"], ["proof (state)\nthis:\n  eqvt (\\<lambda>(x, y). f x y)\n\ngoal (1 subgoal):\n 1. a \\<sharp> f x y", "moreover"], ["proof (state)\nthis:\n  eqvt (\\<lambda>(x, y). f x y)\n\ngoal (1 subgoal):\n 1. a \\<sharp> f x y", "have \"a \\<sharp> (x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> (x, y)", "using fresh1 fresh2"], ["proof (prove)\nusing this:\n  a \\<sharp> x\n  a \\<sharp> y\n\ngoal (1 subgoal):\n 1. a \\<sharp> (x, y)", "by auto"], ["proof (state)\nthis:\n  a \\<sharp> (x, y)\n\ngoal (1 subgoal):\n 1. a \\<sharp> f x y", "ultimately"], ["proof (chain)\npicking this:\n  eqvt (\\<lambda>(x, y). f x y)\n  a \\<sharp> (x, y)", "have \"a \\<sharp> (\\<lambda> (x,y). f x y) (x, y)\""], ["proof (prove)\nusing this:\n  eqvt (\\<lambda>(x, y). f x y)\n  a \\<sharp> (x, y)\n\ngoal (1 subgoal):\n 1. a \\<sharp> (case (x, y) of (x, y) \\<Rightarrow> f x y)", "by (rule fresh_fun_eqvt_app)"], ["proof (state)\nthis:\n  a \\<sharp> (case (x, y) of (x, y) \\<Rightarrow> f x y)\n\ngoal (1 subgoal):\n 1. a \\<sharp> f x y", "thus ?thesis"], ["proof (prove)\nusing this:\n  a \\<sharp> (case (x, y) of (x, y) \\<Rightarrow> f x y)\n\ngoal (1 subgoal):\n 1. a \\<sharp> f x y", "by simp"], ["proof (state)\nthis:\n  a \\<sharp> f x y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eqvt_fresh_star_cong1:\n  assumes eqvt: \"(\\<And>p x. p \\<bullet> (f x) = f (p \\<bullet> x))\"\n  and fresh1: \"a \\<sharp>* x\"\n  shows \"a \\<sharp>* f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp>* f x", "by (metis fresh_star_def eqvt_fresh_cong1 assms)"], ["", "lemma eqvt_fresh_star_cong2:\n  assumes eqvt: \"(\\<And>p x y. p \\<bullet> (f x y) = f (p \\<bullet> x) (p \\<bullet> y))\"\n  and fresh1: \"a \\<sharp>* x\" and fresh2: \"a \\<sharp>* y\"\n  shows \"a \\<sharp>* f x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp>* f x y", "by (metis fresh_star_def eqvt_fresh_cong2 assms)"], ["", "lemma eqvt_fresh_cong3:\n  assumes eqvt: \"(\\<And>p x y z. p \\<bullet> (f x y z) = f (p \\<bullet> x) (p \\<bullet> y) (p \\<bullet> z))\"\n  and fresh1: \"a \\<sharp> x\" and fresh2: \"a \\<sharp> y\" and fresh3: \"a \\<sharp> z\"\n  shows \"a \\<sharp> f x y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> f x y z", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<sharp> f x y z", "have \"eqvt (\\<lambda> (x,y,z). f x y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eqvt (\\<lambda>(x, y, z). f x y z)", "using eqvt"], ["proof (prove)\nusing this:\n  ?p \\<bullet> f ?x ?y ?z =\n  f (?p \\<bullet> ?x) (?p \\<bullet> ?y) (?p \\<bullet> ?z)\n\ngoal (1 subgoal):\n 1. eqvt (\\<lambda>(x, y, z). f x y z)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p x y z.\n        p \\<bullet> f x y z =\n        f (p \\<bullet> x) (p \\<bullet> y) (p \\<bullet> z)) \\<Longrightarrow>\n    eqvt (\\<lambda>(x, y, z). f x y z)", "apply (auto simp add: eqvt_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       (\\<And>p x y z.\n           (p \\<bullet> f) (p \\<bullet> x) (p \\<bullet> y) (p \\<bullet> z) =\n           f (p \\<bullet> x) (p \\<bullet> y)\n            (p \\<bullet> z)) \\<Longrightarrow>\n       (\\<lambda>(x, xa, y). (p \\<bullet> f) x xa y) =\n       (\\<lambda>(x, xa, y). f x xa y)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p x.\n       (\\<And>p x y z.\n           (p \\<bullet> f) (p \\<bullet> x) (p \\<bullet> y) (p \\<bullet> z) =\n           f (p \\<bullet> x) (p \\<bullet> y)\n            (p \\<bullet> z)) \\<Longrightarrow>\n       (case x of (x, xb, xc) \\<Rightarrow> (p \\<bullet> f) x xb xc) =\n       (case x of (x, xb, xc) \\<Rightarrow> f x xb xc)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p a aa b.\n       (\\<And>p x y z.\n           (p \\<bullet> f) (p \\<bullet> x) (p \\<bullet> y) (p \\<bullet> z) =\n           f (p \\<bullet> x) (p \\<bullet> y)\n            (p \\<bullet> z)) \\<Longrightarrow>\n       (p \\<bullet> f) a aa b = f a aa b", "by (metis permute_minus_cancel(1))"], ["proof (state)\nthis:\n  eqvt (\\<lambda>(x, y, z). f x y z)\n\ngoal (1 subgoal):\n 1. a \\<sharp> f x y z", "moreover"], ["proof (state)\nthis:\n  eqvt (\\<lambda>(x, y, z). f x y z)\n\ngoal (1 subgoal):\n 1. a \\<sharp> f x y z", "have \"a \\<sharp> (x, y, z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> (x, y, z)", "using fresh1 fresh2 fresh3"], ["proof (prove)\nusing this:\n  a \\<sharp> x\n  a \\<sharp> y\n  a \\<sharp> z\n\ngoal (1 subgoal):\n 1. a \\<sharp> (x, y, z)", "by auto"], ["proof (state)\nthis:\n  a \\<sharp> (x, y, z)\n\ngoal (1 subgoal):\n 1. a \\<sharp> f x y z", "ultimately"], ["proof (chain)\npicking this:\n  eqvt (\\<lambda>(x, y, z). f x y z)\n  a \\<sharp> (x, y, z)", "have \"a \\<sharp> (\\<lambda> (x,y,z). f x y z) (x, y, z)\""], ["proof (prove)\nusing this:\n  eqvt (\\<lambda>(x, y, z). f x y z)\n  a \\<sharp> (x, y, z)\n\ngoal (1 subgoal):\n 1. a \\<sharp> (case (x, y, z) of (x, y, z) \\<Rightarrow> f x y z)", "by (rule fresh_fun_eqvt_app)"], ["proof (state)\nthis:\n  a \\<sharp> (case (x, y, z) of (x, y, z) \\<Rightarrow> f x y z)\n\ngoal (1 subgoal):\n 1. a \\<sharp> f x y z", "thus ?thesis"], ["proof (prove)\nusing this:\n  a \\<sharp> (case (x, y, z) of (x, y, z) \\<Rightarrow> f x y z)\n\ngoal (1 subgoal):\n 1. a \\<sharp> f x y z", "by simp"], ["proof (state)\nthis:\n  a \\<sharp> f x y z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eqvt_fresh_star_cong3:\n  assumes eqvt: \"(\\<And>p x y z. p \\<bullet> (f x y z) = f (p \\<bullet> x) (p \\<bullet> y) (p \\<bullet> z))\"\n  and fresh1: \"a \\<sharp>* x\" and fresh2: \"a \\<sharp>* y\" and fresh3: \"a \\<sharp>* z\"\n  shows \"a \\<sharp>* f x y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp>* f x y z", "by (metis fresh_star_def eqvt_fresh_cong3 assms)"], ["", "subsubsection \\<open>Additional simplification rules\\<close>"], ["", "lemma not_self_fresh[simp]: \"atom x \\<sharp> x \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom x \\<sharp> x = False", "by (metis fresh_at_base(2))"], ["", "lemma fresh_star_singleton: \"{ x } \\<sharp>* e \\<longleftrightarrow> x \\<sharp> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x} \\<sharp>* e = x \\<sharp> e", "by (simp add: fresh_star_def)"], ["", "subsubsection \\<open>Additional equivariance lemmas\\<close>"], ["", "lemma eqvt_cases:\n  fixes f x \\<pi>\n  assumes eqvt: \"\\<And>x. \\<pi> \\<bullet> f x = f (\\<pi> \\<bullet> x)\"\n  obtains \"f x\" \"f (\\<pi> \\<bullet> x)\" | \"\\<not> f x \" \" \\<not> f (\\<pi> \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>f x; f (\\<pi> \\<bullet> x)\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>\\<not> f x; \\<not> f (\\<pi> \\<bullet> x)\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms[symmetric]"], ["proof (prove)\nusing this:\n  f (\\<pi> \\<bullet> ?x) = \\<pi> \\<bullet> f ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>f x; f (\\<pi> \\<bullet> x)\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>\\<not> f x; \\<not> f (\\<pi> \\<bullet> x)\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (cases \"f x\") auto"], ["", "lemma range_eqvt: \"\\<pi> \\<bullet> range Y = range (\\<pi> \\<bullet> Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> range Y = range (\\<pi> \\<bullet> Y)", "unfolding image_eqvt UNIV_eqvt"], ["proof (prove)\ngoal (1 subgoal):\n 1. range (\\<pi> \\<bullet> Y) = range (\\<pi> \\<bullet> Y)", ".."], ["", "lemma case_option_eqvt[eqvt]:\n  \"\\<pi> \\<bullet> case_option d f x = case_option (\\<pi> \\<bullet> d) (\\<pi> \\<bullet> f) (\\<pi> \\<bullet> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> (case x of None \\<Rightarrow> d\n                     | Some x \\<Rightarrow> f x) =\n    (case \\<pi> \\<bullet> x of None \\<Rightarrow> \\<pi> \\<bullet> d\n     | Some x \\<Rightarrow> (\\<pi> \\<bullet> f) x)", "by(cases x)(simp_all)"], ["", "lemma supp_option_eqvt:\n  \"supp (case_option d f x) \\<subseteq> supp d \\<union> supp f \\<union> supp x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (case x of None \\<Rightarrow> d | Some x \\<Rightarrow> f x)\n    \\<subseteq> supp d \\<union> supp f \\<union> supp x", "apply (cases x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x = None \\<Longrightarrow>\n    supp (case x of None \\<Rightarrow> d | Some x \\<Rightarrow> f x)\n    \\<subseteq> supp d \\<union> supp f \\<union> supp x\n 2. \\<And>a.\n       x = Some a \\<Longrightarrow>\n       supp (case x of None \\<Rightarrow> d | Some x \\<Rightarrow> f x)\n       \\<subseteq> supp d \\<union> supp f \\<union> supp x", "apply (auto simp add: supp_Some )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xa.\n       \\<lbrakk>x = Some a; xa \\<in> supp (f a); xa \\<notin> supp a;\n        xa \\<notin> supp f\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> supp d", "apply (metis (mono_tags) Un_iff subsetCE supp_fun_app)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma funpow_eqvt[simp,eqvt]:\n  \"\\<pi> \\<bullet> ((f :: 'a \\<Rightarrow> 'a::pt) ^^ n) = (\\<pi> \\<bullet> f) ^^ (\\<pi> \\<bullet> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> f ^^ n = (\\<pi> \\<bullet> f) ^^ (\\<pi> \\<bullet> n)", "apply (induct n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<pi> \\<bullet> f ^^ 0 = (\\<pi> \\<bullet> f) ^^ (\\<pi> \\<bullet> 0)\n 2. \\<And>n.\n       \\<pi> \\<bullet> f ^^ n =\n       (\\<pi> \\<bullet> f) ^^ (\\<pi> \\<bullet> n) \\<Longrightarrow>\n       \\<pi> \\<bullet> f ^^ Suc n =\n       (\\<pi> \\<bullet> f) ^^ (\\<pi> \\<bullet> Suc n)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<pi> \\<bullet> f ^^ n =\n       (\\<pi> \\<bullet> f) ^^ (\\<pi> \\<bullet> n) \\<Longrightarrow>\n       \\<pi> \\<bullet> f ^^ Suc n =\n       (\\<pi> \\<bullet> f) ^^ (\\<pi> \\<bullet> Suc n)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n x.\n       \\<pi> \\<bullet> f ^^ n =\n       (\\<pi> \\<bullet> f) ^^ (\\<pi> \\<bullet> n) \\<Longrightarrow>\n       (\\<pi> \\<bullet> f ^^ Suc n) x =\n       ((\\<pi> \\<bullet> f) ^^ (\\<pi> \\<bullet> Suc n)) x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n x.\n       \\<pi> \\<bullet> f ^^ n =\n       (\\<pi> \\<bullet> f) ^^ (\\<pi> \\<bullet> n) \\<Longrightarrow>\n       (\\<pi> \\<bullet> (\\<lambda>a. f ((f ^^ n) a))) x =\n       (\\<pi> \\<bullet> f) (((\\<pi> \\<bullet> f) ^^ n) x)", "apply perm_simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<pi> \\<bullet> compow) n (\\<pi> \\<bullet> f) =\n       (\\<pi> \\<bullet> f) ^^ n \\<Longrightarrow>\n       (\\<pi> \\<bullet> f)\n        ((\\<pi> \\<bullet> compow) n (\\<pi> \\<bullet> f) x) =\n       (\\<pi> \\<bullet> f) (((\\<pi> \\<bullet> f) ^^ n) x)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma delete_eqvt[eqvt]:\n  \"\\<pi> \\<bullet> AList.delete x \\<Gamma> = AList.delete (\\<pi> \\<bullet> x) (\\<pi> \\<bullet> \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> AList.delete x \\<Gamma> =\n    AList.delete (\\<pi> \\<bullet> x) (\\<pi> \\<bullet> \\<Gamma>)", "by (induct \\<Gamma>, auto)"], ["", "lemma restrict_eqvt[eqvt]:\n  \"\\<pi> \\<bullet> AList.restrict S \\<Gamma> = AList.restrict (\\<pi> \\<bullet> S) (\\<pi> \\<bullet> \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> AList.restrict S \\<Gamma> =\n    AList.restrict (\\<pi> \\<bullet> S) (\\<pi> \\<bullet> \\<Gamma>)", "unfolding AList.restrict_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> filter (\\<lambda>(k, v). k \\<in> S) \\<Gamma> =\n    filter (\\<lambda>(k, v). k \\<in> \\<pi> \\<bullet> S)\n     (\\<pi> \\<bullet> \\<Gamma>)", "by perm_simp rule"], ["", "lemma supp_restrict:\n  \"supp (AList.restrict S \\<Gamma>) \\<subseteq> supp \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (AList.restrict S \\<Gamma>) \\<subseteq> supp \\<Gamma>", "by (induction \\<Gamma>) (auto simp add: supp_Pair supp_Cons)"], ["", "lemma clearjunk_eqvt[eqvt]:\n  \"\\<pi> \\<bullet> AList.clearjunk \\<Gamma> = AList.clearjunk (\\<pi> \\<bullet> \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> AList.clearjunk \\<Gamma> =\n    AList.clearjunk (\\<pi> \\<bullet> \\<Gamma>)", "by (induction \\<Gamma> rule: clearjunk.induct) auto"], ["", "lemma map_ran_eqvt[eqvt]:\n  \"\\<pi> \\<bullet> map_ran f \\<Gamma> = map_ran (\\<pi> \\<bullet> f) (\\<pi> \\<bullet> \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> map_ran f \\<Gamma> =\n    map_ran (\\<pi> \\<bullet> f) (\\<pi> \\<bullet> \\<Gamma>)", "by (induct \\<Gamma>, auto)"], ["", "lemma dom_perm:\n  \"dom (\\<pi> \\<bullet> f) = \\<pi> \\<bullet> (dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<pi> \\<bullet> f) = \\<pi> \\<bullet> dom f", "unfolding dom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. (\\<pi> \\<bullet> f) a \\<noteq> None} =\n    \\<pi> \\<bullet> {a. f a \\<noteq> None}", "by (perm_simp) (simp)"], ["", "lemmas dom_perm_rev[simp,eqvt] = dom_perm[symmetric]"], ["", "lemma ran_perm[simp]:\n  \"\\<pi> \\<bullet> (ran f) = ran (\\<pi> \\<bullet> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> ran f = ran (\\<pi> \\<bullet> f)", "unfolding ran_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> {b. \\<exists>a. f a = Some b} =\n    {b. \\<exists>a. (\\<pi> \\<bullet> f) a = Some b}", "by (perm_simp) (simp)"], ["", "lemma map_add_eqvt[eqvt]:\n  \"\\<pi> \\<bullet> (m1 ++ m2) = (\\<pi> \\<bullet> m1) ++ (\\<pi> \\<bullet> m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> m1 ++ m2 = (\\<pi> \\<bullet> m1) ++ (\\<pi> \\<bullet> m2)", "unfolding map_add_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> (\\<lambda>x.\n                        case m2 x of None \\<Rightarrow> m1 x\n                        | Some x \\<Rightarrow> Some x) =\n    (\\<lambda>x.\n        case (\\<pi> \\<bullet> m2) x of\n        None \\<Rightarrow> (\\<pi> \\<bullet> m1) x\n        | Some x \\<Rightarrow> Some x)", "by (perm_simp, rule)"], ["", "lemma map_of_eqvt[eqvt]:\n  \"\\<pi> \\<bullet> map_of l = map_of (\\<pi> \\<bullet> l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> map_of l = map_of (\\<pi> \\<bullet> l)", "apply (induct l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<pi> \\<bullet> map_of [] = map_of (\\<pi> \\<bullet> [])\n 2. \\<And>a l.\n       \\<pi> \\<bullet> map_of l =\n       map_of (\\<pi> \\<bullet> l) \\<Longrightarrow>\n       \\<pi> \\<bullet> map_of (a # l) = map_of (\\<pi> \\<bullet> (a # l))", "apply (simp add: permute_fun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<pi> \\<bullet> map_of l =\n       map_of (\\<pi> \\<bullet> l) \\<Longrightarrow>\n       \\<pi> \\<bullet> map_of (a # l) = map_of (\\<pi> \\<bullet> (a # l))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<pi> \\<bullet> map_of l =\n       map_of (\\<pi> \\<bullet> l) \\<Longrightarrow>\n       \\<pi> \\<bullet> (\\<lambda>b.\n                           if b = fst a then Some (snd a) else map_of l b) =\n       (\\<lambda>b.\n           if b = fst (\\<pi> \\<bullet> a)\n           then Some (snd (\\<pi> \\<bullet> a))\n           else map_of (\\<pi> \\<bullet> l) b)", "apply perm_simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       (\\<pi> \\<bullet> map_of) (\\<pi> \\<bullet> l) =\n       map_of (\\<pi> \\<bullet> l) \\<Longrightarrow>\n       (\\<lambda>x.\n           if x = fst (\\<pi> \\<bullet> a)\n           then Some (snd (\\<pi> \\<bullet> a))\n           else (\\<pi> \\<bullet> map_of) (\\<pi> \\<bullet> l) x) =\n       (\\<lambda>b.\n           if b = fst (\\<pi> \\<bullet> a)\n           then Some (snd (\\<pi> \\<bullet> a))\n           else map_of (\\<pi> \\<bullet> l) b)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma concat_eqvt[eqvt]: \"\\<pi> \\<bullet> concat l = concat (\\<pi> \\<bullet> l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> concat l = concat (\\<pi> \\<bullet> l)", "by (induction l)(auto simp add: append_eqvt)"], ["", "lemma tranclp_eqvt[eqvt]: \"\\<pi> \\<bullet> tranclp P v\\<^sub>1 v\\<^sub>2 = tranclp (\\<pi> \\<bullet> P) (\\<pi> \\<bullet> v\\<^sub>1) (\\<pi> \\<bullet> v\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> P\\<^sup>+\\<^sup>+ v\\<^sub>1 v\\<^sub>2 =\n    (\\<pi> \\<bullet> P)\\<^sup>+\\<^sup>+ (\\<pi> \\<bullet> v\\<^sub>1)\n     (\\<pi> \\<bullet> v\\<^sub>2)", "unfolding tranclp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> lfp (\\<lambda>p x1 x2.\n                            (\\<exists>a b.\n                                x1 = a \\<and> x2 = b \\<and> P a b) \\<or>\n                            (\\<exists>a b c.\n                                x1 = a \\<and>\n                                x2 = c \\<and> p a b \\<and> P b c))\n                     v\\<^sub>1 v\\<^sub>2 =\n    lfp (\\<lambda>p x1 x2.\n            (\\<exists>a b.\n                x1 = a \\<and> x2 = b \\<and> (\\<pi> \\<bullet> P) a b) \\<or>\n            (\\<exists>a b c.\n                x1 = a \\<and>\n                x2 = c \\<and> p a b \\<and> (\\<pi> \\<bullet> P) b c))\n     (\\<pi> \\<bullet> v\\<^sub>1) (\\<pi> \\<bullet> v\\<^sub>2)", "by perm_simp rule"], ["", "lemma rtranclp_eqvt[eqvt]: \"\\<pi> \\<bullet> rtranclp P v\\<^sub>1 v\\<^sub>2 = rtranclp (\\<pi> \\<bullet> P) (\\<pi> \\<bullet> v\\<^sub>1) (\\<pi> \\<bullet> v\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> P\\<^sup>*\\<^sup>* v\\<^sub>1 v\\<^sub>2 =\n    (\\<pi> \\<bullet> P)\\<^sup>*\\<^sup>* (\\<pi> \\<bullet> v\\<^sub>1)\n     (\\<pi> \\<bullet> v\\<^sub>2)", "unfolding rtranclp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> lfp (\\<lambda>p x1 x2.\n                            (\\<exists>a. x1 = a \\<and> x2 = a) \\<or>\n                            (\\<exists>a b c.\n                                x1 = a \\<and>\n                                x2 = c \\<and> p a b \\<and> P b c))\n                     v\\<^sub>1 v\\<^sub>2 =\n    lfp (\\<lambda>p x1 x2.\n            (\\<exists>a. x1 = a \\<and> x2 = a) \\<or>\n            (\\<exists>a b c.\n                x1 = a \\<and>\n                x2 = c \\<and> p a b \\<and> (\\<pi> \\<bullet> P) b c))\n     (\\<pi> \\<bullet> v\\<^sub>1) (\\<pi> \\<bullet> v\\<^sub>2)", "by perm_simp rule"], ["", "lemma Set_filter_eqvt[eqvt]: \"\\<pi> \\<bullet> Set.filter P S = Set.filter (\\<pi> \\<bullet> P) (\\<pi> \\<bullet> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> Set.filter P S =\n    Set.filter (\\<pi> \\<bullet> P) (\\<pi> \\<bullet> S)", "unfolding Set.filter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> {a \\<in> S. P a} =\n    {a \\<in> \\<pi> \\<bullet> S. (\\<pi> \\<bullet> P) a}", "by perm_simp rule"], ["", "lemma Sigma_eqvt'[eqvt]: \"\\<pi> \\<bullet> Sigma = Sigma\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> Sigma = Sigma", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (\\<pi> \\<bullet> Sigma) x = Sigma x", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa. (\\<pi> \\<bullet> Sigma) x xa = Sigma x xa", "apply (subst permute_fun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (\\<pi> \\<bullet> Sigma (- \\<pi> \\<bullet> x)) xa = Sigma x xa", "apply (subst permute_fun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<pi> \\<bullet> Sigma (- \\<pi> \\<bullet> x) (- \\<pi> \\<bullet> xa) =\n       Sigma x xa", "unfolding Sigma_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<pi> \\<bullet> (\\<Union>x\\<in>- \\<pi> \\<bullet> x.\n                           \\<Union>y\\<in>(- \\<pi> \\<bullet> xa) x.\n                              {(x, y)}) =\n       (\\<Union>x\\<in>x. \\<Union>y\\<in>xa x. {(x, y)})", "apply perm_simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (\\<Union>x\\<in>- (\\<pi> \\<bullet> \\<pi>) \\<bullet> \\<pi> \\<bullet> x.\n           \\<Union>xa\\<in>(- (\\<pi> \\<bullet> \\<pi>) \\<bullet> \\<pi> \\<bullet> xa)\n                           x.\n              {(x, xa)}) =\n       (\\<Union>x\\<in>x. \\<Union>y\\<in>xa x. {(x, y)})", "apply (simp add: permute_self)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma override_on_eqvt[eqvt]:\n  \"\\<pi> \\<bullet> (override_on m1 m2 S) = override_on (\\<pi> \\<bullet> m1) (\\<pi> \\<bullet> m2) (\\<pi> \\<bullet> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> override_on m1 m2 S =\n    override_on (\\<pi> \\<bullet> m1) (\\<pi> \\<bullet> m2)\n     (\\<pi> \\<bullet> S)", "by (auto simp add: override_on_def )"], ["", "lemma card_eqvt[eqvt]:\n  \"\\<pi> \\<bullet> (card S) = card (\\<pi> \\<bullet> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> card S = card (\\<pi> \\<bullet> S)", "by (cases \"finite S\", induct rule: finite_induct) (auto simp add: card_insert_if mem_permute_iff permute_pure)"], ["", "(* Helper lemmas provided by Christian Urban *)"], ["", "lemma Projl_permute:\n  assumes a: \"\\<exists>y. f = Inl y\"\n  shows \"(p \\<bullet> (Sum_Type.projl f)) = Sum_Type.projl (p \\<bullet> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> projl f = projl (p \\<bullet> f)", "using a"], ["proof (prove)\nusing this:\n  \\<exists>y. f = Inl y\n\ngoal (1 subgoal):\n 1. p \\<bullet> projl f = projl (p \\<bullet> f)", "by auto"], ["", "lemma Projr_permute:\n  assumes a: \"\\<exists>y. f = Inr y\"\n  shows \"(p \\<bullet> (Sum_Type.projr f)) = Sum_Type.projr (p \\<bullet> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> projr f = projr (p \\<bullet> f)", "using a"], ["proof (prove)\nusing this:\n  \\<exists>y. f = Inr y\n\ngoal (1 subgoal):\n 1. p \\<bullet> projr f = projr (p \\<bullet> f)", "by auto"], ["", "subsubsection \\<open>Freshness lemmas\\<close>"], ["", "lemma fresh_list_elem:\n  assumes \"a \\<sharp> \\<Gamma>\"\n  and \"e \\<in> set \\<Gamma>\"\n  shows \"a \\<sharp> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> e", "using assms"], ["proof (prove)\nusing this:\n  a \\<sharp> \\<Gamma>\n  e \\<in> set \\<Gamma>\n\ngoal (1 subgoal):\n 1. a \\<sharp> e", "by(induct \\<Gamma>)(auto simp add: fresh_Cons)"], ["", "lemma set_not_fresh:\n  \"x \\<in> set L \\<Longrightarrow> \\<not>(atom x \\<sharp> L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set L \\<Longrightarrow> \\<not> atom x \\<sharp> L", "by (metis fresh_list_elem not_self_fresh)"], ["", "lemma pure_fresh_star[simp]: \"a \\<sharp>* (x :: 'a :: pure)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp>* x", "by (simp add: fresh_star_def pure_fresh)"], ["", "lemma supp_set_mem: \"x \\<in> set L \\<Longrightarrow> supp x \\<subseteq> supp L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set L \\<Longrightarrow> supp x \\<subseteq> supp L", "by (induct L) (auto simp add: supp_Cons)"], ["", "lemma set_supp_mono: \"set L \\<subseteq> set L2 \\<Longrightarrow> supp L \\<subseteq> supp L2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set L \\<subseteq> set L2 \\<Longrightarrow> supp L \\<subseteq> supp L2", "by (induct L)(auto simp add: supp_Cons supp_Nil dest:supp_set_mem)"], ["", "lemma fresh_star_at_base:\n  fixes x :: \"'a :: at_base\"\n  shows \"S \\<sharp>* x \\<longleftrightarrow> atom x \\<notin> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<sharp>* x = (atom x \\<notin> S)", "by (metis fresh_at_base(2) fresh_star_def)"], ["", "subsubsection \\<open>Freshness and support for subsets of variables\\<close>"], ["", "lemma supp_mono: \"finite (B::'a::fs set) \\<Longrightarrow> A \\<subseteq> B \\<Longrightarrow> supp A \\<subseteq> supp B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite B; A \\<subseteq> B\\<rbrakk>\n    \\<Longrightarrow> supp A \\<subseteq> supp B", "by (metis infinite_super subset_Un_eq supp_of_finite_union)"], ["", "lemma fresh_subset:\n  \"finite B \\<Longrightarrow> x \\<sharp> (B :: 'a::at_base set) \\<Longrightarrow> A \\<subseteq> B \\<Longrightarrow> x \\<sharp> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite B; x \\<sharp> B; A \\<subseteq> B\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp> A", "by (auto dest:supp_mono simp add: fresh_def)"], ["", "lemma fresh_star_subset:\n  \"finite B \\<Longrightarrow> x \\<sharp>* (B :: 'a::at_base set) \\<Longrightarrow> A \\<subseteq> B \\<Longrightarrow> x \\<sharp>* A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite B; x \\<sharp>* B; A \\<subseteq> B\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp>* A", "by (metis fresh_star_def fresh_subset)"], ["", "lemma fresh_star_set_subset:\n  \"x \\<sharp>* (B :: 'a::at_base list) \\<Longrightarrow> set A \\<subseteq> set B \\<Longrightarrow> x \\<sharp>* A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<sharp>* B; set A \\<subseteq> set B\\<rbrakk>\n    \\<Longrightarrow> x \\<sharp>* A", "by (metis fresh_star_set fresh_star_subset[OF finite_set])"], ["", "subsubsection \\<open>The set of free variables of an expression\\<close>"], ["", "definition fv :: \"'a::pt \\<Rightarrow> 'b::at_base set\"\n  where \"fv e = {v. atom v \\<in> supp e}\""], ["", "lemma fv_eqvt[simp,eqvt]: \"\\<pi> \\<bullet> (fv e) = fv (\\<pi> \\<bullet> e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> fv e = fv (\\<pi> \\<bullet> e)", "unfolding fv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> {v. atom v \\<in> supp e} =\n    {v. atom v \\<in> supp (\\<pi> \\<bullet> e)}", "by simp"], ["", "lemma fv_Nil[simp]: \"fv [] = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv [] = {}", "by (auto simp add: fv_def supp_Nil)"], ["", "lemma fv_Cons[simp]: \"fv (x # xs) = fv x \\<union> fv xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (x # xs) = fv x \\<union> fv xs", "by (auto simp add: fv_def supp_Cons)"], ["", "lemma fv_Pair[simp]: \"fv (x, y) = fv x \\<union> fv y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (x, y) = fv x \\<union> fv y", "by (auto simp add: fv_def supp_Pair)"], ["", "lemma fv_append[simp]: \"fv (x @ y) = fv x \\<union> fv y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (x @ y) = fv x \\<union> fv y", "by (auto simp add: fv_def supp_append)"], ["", "lemma fv_at_base[simp]: \"fv a = {a::'a::at_base}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv a = {a}", "by (auto simp add: fv_def supp_at_base)"], ["", "lemma fv_pure[simp]: \"fv (a::'a::pure) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv a = {}", "by (auto simp add: fv_def pure_supp)"], ["", "lemma fv_set_at_base[simp]: \"fv (l :: ('a :: at_base) list) = set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv l = set l", "by (induction l) auto"], ["", "lemma flip_not_fv: \"a \\<notin> fv x \\<Longrightarrow> b \\<notin> fv x \\<Longrightarrow> (a \\<leftrightarrow> b) \\<bullet> x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<notin> fv x; b \\<notin> fv x\\<rbrakk>\n    \\<Longrightarrow> (a \\<leftrightarrow> b) \\<bullet> x = x", "by (metis flip_def fresh_def fv_def mem_Collect_eq swap_fresh_fresh)"], ["", "lemma fv_not_fresh: \"atom x \\<sharp> e \\<longleftrightarrow> x \\<notin> fv e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom x \\<sharp> e = (x \\<notin> fv e)", "unfolding fv_def fresh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (atom x \\<notin> supp e) = (x \\<notin> {v. atom v \\<in> supp e})", "by blast"], ["", "lemma fresh_fv: \"finite (fv e :: 'a set) \\<Longrightarrow>  atom (x :: ('a::at_base)) \\<sharp> (fv e :: 'a set) \\<longleftrightarrow> atom x \\<sharp> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (fv e) \\<Longrightarrow> atom x \\<sharp> fv e = atom x \\<sharp> e", "unfolding fv_def fresh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {v. atom v \\<in> supp e} \\<Longrightarrow>\n    (atom x \\<notin> supp {v. atom v \\<in> supp e}) =\n    (atom x \\<notin> supp e)", "by (auto simp add: supp_finite_set_at_base)"], ["", "lemma finite_fv[simp]: \"finite (fv (e::'a::fs) :: ('b::at_base) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (fv e)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (fv e)", "have \"finite (supp e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (supp e)", "by (metis finite_supp)"], ["proof (state)\nthis:\n  finite (supp e)\n\ngoal (1 subgoal):\n 1. finite (fv e)", "hence \"finite (atom -` supp e :: 'b set)\""], ["proof (prove)\nusing this:\n  finite (supp e)\n\ngoal (1 subgoal):\n 1. finite (atom -` supp e)", "apply (rule finite_vimageI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj atom", "apply (rule inj_onI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV; atom x = atom y\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  finite (atom -` supp e)\n\ngoal (1 subgoal):\n 1. finite (fv e)", "moreover"], ["proof (state)\nthis:\n  finite (atom -` supp e)\n\ngoal (1 subgoal):\n 1. finite (fv e)", "have \"(atom -` supp e  :: 'b set) = fv e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atom -` supp e = fv e", "unfolding fv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. atom -` supp e = {v. atom v \\<in> supp e}", "by auto"], ["proof (state)\nthis:\n  atom -` supp e = fv e\n\ngoal (1 subgoal):\n 1. finite (fv e)", "ultimately"], ["proof (chain)\npicking this:\n  finite (atom -` supp e)\n  atom -` supp e = fv e", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (atom -` supp e)\n  atom -` supp e = fv e\n\ngoal (1 subgoal):\n 1. finite (fv e)", "by simp"], ["proof (state)\nthis:\n  finite (fv e)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition fv_list :: \"'a::fs \\<Rightarrow> 'b::at_base list\"\n  where \"fv_list e = (SOME l. set l = fv e)\""], ["", "lemma set_fv_list[simp]: \"set (fv_list e) = (fv e :: ('b::at_base) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (fv_list e) = fv e", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. set (fv_list e) = fv e", "have \"finite (fv e :: 'b set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (fv e)", "by (rule finite_fv)"], ["proof (state)\nthis:\n  finite (fv e)\n\ngoal (1 subgoal):\n 1. set (fv_list e) = fv e", "from finite_list[OF finite_fv]"], ["proof (chain)\npicking this:\n  \\<exists>xs. set xs = fv ?e1", "obtain l where \"set l = (fv e :: 'b set)\""], ["proof (prove)\nusing this:\n  \\<exists>xs. set xs = fv ?e1\n\ngoal (1 subgoal):\n 1. (\\<And>l. set l = fv e \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  set l = fv e\n\ngoal (1 subgoal):\n 1. set (fv_list e) = fv e", "thus ?thesis"], ["proof (prove)\nusing this:\n  set l = fv e\n\ngoal (1 subgoal):\n 1. set (fv_list e) = fv e", "unfolding fv_list_def"], ["proof (prove)\nusing this:\n  set l = fv e\n\ngoal (1 subgoal):\n 1. set (SOME l. set l = fv e) = fv e", "by (rule someI)"], ["proof (state)\nthis:\n  set (fv_list e) = fv e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fresh_fv_list[simp]:\n  \"a \\<sharp> (fv_list e :: 'b::at_base list) \\<longleftrightarrow> a \\<sharp> (fv e :: 'b::at_base set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> fv_list e = a \\<sharp> fv e", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<sharp> fv_list e = a \\<sharp> fv e", "have \"a \\<sharp> (fv_list e :: 'b::at_base list) \\<longleftrightarrow> a \\<sharp> set (fv_list e :: 'b::at_base list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> fv_list e = a \\<sharp> set (fv_list e)", "by (rule fresh_set[symmetric])"], ["proof (state)\nthis:\n  a \\<sharp> fv_list e = a \\<sharp> set (fv_list e)\n\ngoal (1 subgoal):\n 1. a \\<sharp> fv_list e = a \\<sharp> fv e", "also"], ["proof (state)\nthis:\n  a \\<sharp> fv_list e = a \\<sharp> set (fv_list e)\n\ngoal (1 subgoal):\n 1. a \\<sharp> fv_list e = a \\<sharp> fv e", "have \"\\<dots> \\<longleftrightarrow> a \\<sharp> (fv e :: 'b::at_base set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> set (fv_list e) = a \\<sharp> fv e", "by simp"], ["proof (state)\nthis:\n  a \\<sharp> set (fv_list e) = a \\<sharp> fv e\n\ngoal (1 subgoal):\n 1. a \\<sharp> fv_list e = a \\<sharp> fv e", "finally"], ["proof (chain)\npicking this:\n  a \\<sharp> fv_list e = a \\<sharp> fv e", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<sharp> fv_list e = a \\<sharp> fv e\n\ngoal (1 subgoal):\n 1. a \\<sharp> fv_list e = a \\<sharp> fv e", "."], ["proof (state)\nthis:\n  a \\<sharp> fv_list e = a \\<sharp> fv e\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Other useful lemmas\\<close>"], ["", "lemma pure_permute_id: \"permute p = (\\<lambda> x. (x::'a::pure))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permute p = (\\<lambda>x. x)", "by rule (simp add: permute_pure)"], ["", "lemma supp_set_elem_finite:\n  assumes \"finite S\"\n  and \"(m::'a::fs) \\<in> S\"\n  and \"y \\<in> supp m\"\n  shows \"y \\<in> supp S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> supp S", "using assms supp_of_finite_sets"], ["proof (prove)\nusing this:\n  finite S\n  m \\<in> S\n  y \\<in> supp m\n  finite ?S \\<Longrightarrow> supp ?S = \\<Union> (supp ` ?S)\n\ngoal (1 subgoal):\n 1. y \\<in> supp S", "by auto"], ["", "lemmas fresh_star_Cons = fresh_star_list(2)"], ["", "lemma mem_permute_set: \n  shows \"x \\<in> p \\<bullet> S \\<longleftrightarrow> (- p \\<bullet> x) \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> p \\<bullet> S) = (- p \\<bullet> x \\<in> S)", "by (metis mem_permute_iff permute_minus_cancel(2))"], ["", "lemma flip_set_both_not_in:\n  assumes \"x \\<notin> S\" and \"x' \\<notin> S\"\n  shows \"((x' \\<leftrightarrow> x) \\<bullet> S) = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x' \\<leftrightarrow> x) \\<bullet> S = S", "unfolding permute_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x' \\<leftrightarrow> x) \\<bullet> xa |xa. xa \\<in> S} = S", "by (auto) (metis assms flip_at_base_simps(3))+"], ["", "lemma inj_atom: \"inj atom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj atom", "by (metis atom_eq_iff injI)"], ["", "lemmas image_Int[OF inj_atom, simp]"], ["", "lemma eqvt_uncurry: \"eqvt f \\<Longrightarrow> eqvt (case_prod f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eqvt f \\<Longrightarrow> eqvt (\\<lambda>(x, y). f x y)", "unfolding eqvt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p. p \\<bullet> f = f \\<Longrightarrow>\n    \\<forall>p.\n       p \\<bullet> (\\<lambda>(x, y). f x y) = (\\<lambda>(x, y). f x y)", "by perm_simp simp"], ["", "lemma supp_fun_app_eqvt2:\n  assumes a: \"eqvt f\"\n  shows \"supp (f x y) \\<subseteq> supp x \\<union> supp y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (f x y) \\<subseteq> supp x \\<union> supp y", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. supp (f x y) \\<subseteq> supp x \\<union> supp y", "from supp_fun_app_eqvt[OF eqvt_uncurry [OF a]]"], ["proof (chain)\npicking this:\n  supp (case ?x of (x, xa) \\<Rightarrow> f x xa) \\<subseteq> supp ?x", "have \"supp (case_prod f (x,y)) \\<subseteq> supp (x,y)\""], ["proof (prove)\nusing this:\n  supp (case ?x of (x, xa) \\<Rightarrow> f x xa) \\<subseteq> supp ?x\n\ngoal (1 subgoal):\n 1. supp (case (x, y) of (x, xa) \\<Rightarrow> f x xa)\n    \\<subseteq> supp (x, y)", "."], ["proof (state)\nthis:\n  supp (case (x, y) of (x, xa) \\<Rightarrow> f x xa) \\<subseteq> supp (x, y)\n\ngoal (1 subgoal):\n 1. supp (f x y) \\<subseteq> supp x \\<union> supp y", "thus ?thesis"], ["proof (prove)\nusing this:\n  supp (case (x, y) of (x, xa) \\<Rightarrow> f x xa) \\<subseteq> supp (x, y)\n\ngoal (1 subgoal):\n 1. supp (f x y) \\<subseteq> supp x \\<union> supp y", "by (simp add: supp_Pair)"], ["proof (state)\nthis:\n  supp (f x y) \\<subseteq> supp x \\<union> supp y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma supp_fun_app_eqvt3:\n  assumes a: \"eqvt f\"\n  shows \"supp (f x y z) \\<subseteq> supp x \\<union> supp y \\<union> supp z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (f x y z) \\<subseteq> supp x \\<union> supp y \\<union> supp z", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. supp (f x y z) \\<subseteq> supp x \\<union> supp y \\<union> supp z", "from supp_fun_app_eqvt2[OF eqvt_uncurry [OF a]]"], ["proof (chain)\npicking this:\n  supp ((case ?x of (x, xa) \\<Rightarrow> f x xa) ?y)\n  \\<subseteq> supp ?x \\<union> supp ?y", "have \"supp (case_prod f (x,y) z) \\<subseteq> supp (x,y) \\<union> supp z\""], ["proof (prove)\nusing this:\n  supp ((case ?x of (x, xa) \\<Rightarrow> f x xa) ?y)\n  \\<subseteq> supp ?x \\<union> supp ?y\n\ngoal (1 subgoal):\n 1. supp ((case (x, y) of (x, xa) \\<Rightarrow> f x xa) z)\n    \\<subseteq> supp (x, y) \\<union> supp z", "."], ["proof (state)\nthis:\n  supp ((case (x, y) of (x, xa) \\<Rightarrow> f x xa) z)\n  \\<subseteq> supp (x, y) \\<union> supp z\n\ngoal (1 subgoal):\n 1. supp (f x y z) \\<subseteq> supp x \\<union> supp y \\<union> supp z", "thus ?thesis"], ["proof (prove)\nusing this:\n  supp ((case (x, y) of (x, xa) \\<Rightarrow> f x xa) z)\n  \\<subseteq> supp (x, y) \\<union> supp z\n\ngoal (1 subgoal):\n 1. supp (f x y z) \\<subseteq> supp x \\<union> supp y \\<union> supp z", "by (simp add: supp_Pair)"], ["proof (state)\nthis:\n  supp (f x y z) \\<subseteq> supp x \\<union> supp y \\<union> supp z\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Fighting eta-contraction *)"], ["", "lemma permute_0[simp]: \"permute 0 = (\\<lambda> x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permute 0 = (\\<lambda>x. x)", "by auto"], ["", "lemma permute_comp[simp]: \"permute x \\<circ> permute y = permute (x + y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. permute x \\<circ> permute y = permute (x + y)", "by auto"], ["", "lemma map_permute: \"map (permute p) = permute p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (permute p) = permute p", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. map (permute p) x = p \\<bullet> x", "apply (induct_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. map (permute p) [] = p \\<bullet> []\n 2. \\<And>x a list.\n       map (permute p) list = p \\<bullet> list \\<Longrightarrow>\n       map (permute p) (a # list) = p \\<bullet> (a # list)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fresh_star_restrictA[intro]: \"a \\<sharp>* \\<Gamma> \\<Longrightarrow> a \\<sharp>* AList.restrict V \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp>* \\<Gamma> \\<Longrightarrow>\n    a \\<sharp>* AList.restrict V \\<Gamma>", "by (induction \\<Gamma>) (auto simp add: fresh_star_Cons)"], ["", "(* Unused. Still submit? *)"], ["", "lemma Abs_lst_Nil_eq[simp]: \"[[]]lst. (x::'a::fs) = [xs]lst. x' \\<longleftrightarrow> (([],x) = (xs, x'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([[]]lst. x = [xs]lst. x') = (([], x) = (xs, x'))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. [[]]lst. x = [xs]lst. x' \\<Longrightarrow> ([], x) = (xs, x')\n 2. ([], x) = (xs, x') \\<Longrightarrow> [[]]lst. x = [xs]lst. x'", "apply (frule Abs_lst_fcb2[where f = \"\\<lambda> x y _ . (x,y)\" and as = \"[]\" and bs = \"xs\" and c = \"()\"])"], ["proof (prove)\ngoal (7 subgoals):\n 1. [[]]lst. x = [xs]lst. x' \\<Longrightarrow> set [] \\<sharp>* ([], x)\n 2. [[]]lst. x = [xs]lst. x' \\<Longrightarrow> set [] \\<sharp>* ()\n 3. [[]]lst. x = [xs]lst. x' \\<Longrightarrow> set xs \\<sharp>* ()\n 4. \\<And>p.\n       \\<lbrakk>[[]]lst. x = [xs]lst. x'; supp p \\<sharp>* ()\\<rbrakk>\n       \\<Longrightarrow> p \\<bullet> ([], x) =\n                         (p \\<bullet> [], p \\<bullet> x)\n 5. \\<And>p.\n       \\<lbrakk>[[]]lst. x = [xs]lst. x'; supp p \\<sharp>* ()\\<rbrakk>\n       \\<Longrightarrow> p \\<bullet> (xs, x') =\n                         (p \\<bullet> xs, p \\<bullet> x')\n 6. \\<lbrakk>[[]]lst. x = [xs]lst. x'; ([], x) = (xs, x')\\<rbrakk>\n    \\<Longrightarrow> ([], x) = (xs, x')\n 7. ([], x) = (xs, x') \\<Longrightarrow> [[]]lst. x = [xs]lst. x'", "apply (auto simp add: fresh_star_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* Unused. Still submit? *)"], ["", "lemma Abs_lst_Nil_eq2[simp]: \"[xs]lst. (x::'a::fs) = [[]]lst. x' \\<longleftrightarrow> ((xs,x) = ([], x'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([xs]lst. x = [[]]lst. x') = ((xs, x) = ([], x'))", "by (subst eq_commute) auto"], ["", "end"]]}