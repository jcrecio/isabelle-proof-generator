{"file_name": "/home/qj213/afp-2021-10-22/thys/Launchbury/HOLCF-Join-Classes.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Launchbury", "problem_names": ["lemmas join_mono = join_mono[OF all_compatible all_compatible ]", "lemmas join_above1[simp] = all_compatible[THEN join_above1]", "lemmas join_above2[simp] = all_compatible[THEN join_above2]", "lemmas join_below[simp] = all_compatible[THEN join_below]", "lemmas join_below_iff = all_compatible[THEN join_below_iff]", "lemmas join_assoc[simp] = join_assoc[OF all_compatible all_compatible all_compatible]", "lemmas join_comm[simp] = all_compatible[THEN join_commute]", "lemma join_lc[simp]: \"x \\<squnion> (y \\<squnion> z) = y \\<squnion> (x \\<squnion> (z::'a::Finite_Join_cpo))\"", "lemma join_cont': \"chain Y \\<Longrightarrow> (\\<Squnion> i. Y i) \\<squnion> y = (\\<Squnion> i. Y i \\<squnion> (y::'a::Finite_Join_cpo))\"", "lemma join_cont1:\n  fixes y :: \"'a :: Finite_Join_cpo\"\n  shows \"cont (\\<lambda>x. (x \\<squnion> y))\"", "lemma join_cont2: \n  fixes x :: \"'a :: Finite_Join_cpo\"\n  shows \"cont (\\<lambda>y. (x \\<squnion> y))\"", "lemma join_cont[cont2cont,simp]:\"cont f \\<Longrightarrow> cont g \\<Longrightarrow> cont (\\<lambda>x. (f x \\<squnion> (g x::'a::Finite_Join_cpo)))\"", "lemma [simp]: \"(fun_join\\<cdot>f\\<cdot>g) x = (f x) \\<squnion> (g x)\"", "lemma [simp]: \"cfun_join\\<cdot>f\\<cdot>g\\<cdot>x = (f \\<cdot> x) \\<squnion> (g \\<cdot> x)\"", "lemma bot_lub[simp]: \"S <<| \\<bottom> \\<longleftrightarrow>  S \\<subseteq> {\\<bottom>}\"", "lemma compatible_up[simp]: \"compatible (up\\<cdot>x) (up\\<cdot>y) \\<longleftrightarrow> compatible x y\"", "lemma prod_join: \n    fixes x y :: \"'a::Finite_Join_cpo \\<times> 'b::Finite_Join_cpo\" \n    shows \"x \\<squnion> y = (fst x \\<squnion> fst y, snd x \\<squnion> snd y)\"", "lemma \n  fixes x y :: \"'a::Finite_Join_cpo \\<times> 'b::Finite_Join_cpo\" \n  shows fst_join[simp]: \"fst (x \\<squnion> y) = fst x \\<squnion> fst y\"\n  and snd_join[simp]: \"snd (x \\<squnion> y) = snd x \\<squnion> snd y\"", "lemma fun_meet_simp[simp]: \"(f \\<squnion> g) x = f x \\<squnion> (g x::'a::Finite_Join_cpo)\"", "lemma fun_upd_meet_simp[simp]: \"(f \\<squnion> g) (x := y) = f (x := y)  \\<squnion> g (x := y::'a::Finite_Join_cpo)\"", "lemma cfun_meet_simp[simp]: \"(f \\<squnion> g) \\<cdot> x = f \\<cdot> x \\<squnion> (g \\<cdot> x::'a::Finite_Join_cpo)\"", "lemma cfun_join_below:\n  fixes f :: \"('a::Finite_Join_cpo) \\<rightarrow> ('b::Finite_Join_cpo)\"\n  shows \"f\\<cdot>x \\<squnion> f\\<cdot>y \\<sqsubseteq> f\\<cdot>(x \\<squnion> y)\"", "lemma join_self_below[iff]:\n  \"x = x \\<squnion> y \\<longleftrightarrow> y \\<sqsubseteq> (x::'a::Finite_Join_cpo)\"\n  \"x = y \\<squnion> x \\<longleftrightarrow> y \\<sqsubseteq> (x::'a::Finite_Join_cpo)\"\n  \"x \\<squnion> y = x \\<longleftrightarrow> y \\<sqsubseteq> (x::'a::Finite_Join_cpo)\"\n  \"y \\<squnion> x = x \\<longleftrightarrow> y \\<sqsubseteq> (x::'a::Finite_Join_cpo)\"\n  \"x \\<squnion> y \\<sqsubseteq> x \\<longleftrightarrow> y \\<sqsubseteq> (x::'a::Finite_Join_cpo)\"\n  \"y \\<squnion> x \\<sqsubseteq> x \\<longleftrightarrow> y \\<sqsubseteq> (x::'a::Finite_Join_cpo)\"", "lemma join_bottom_iff[iff]:\n  \"x \\<squnion> y = \\<bottom> \\<longleftrightarrow> x = \\<bottom> \\<and> (y::'a::{Finite_Join_cpo,pcpo}) = \\<bottom>\"", "lemma below_lubI[intro, simp]:\n  fixes x :: \"'a :: Join_cpo\"\n  shows  \"x \\<in> S \\<Longrightarrow> x \\<sqsubseteq> lub S\"", "lemma lub_belowI[intro, simp]:\n  fixes x :: \"'a :: Join_cpo\"\n  shows  \"(\\<And> y. y \\<in> S \\<Longrightarrow> y \\<sqsubseteq> x) \\<Longrightarrow> lub S \\<sqsubseteq> x\"", "lemma lub_empty_set[simp]:\n  \"lub {} = (\\<bottom>::'a::Join_cpo)\"", "lemma lub_insert[simp]:\n  fixes x :: \"'a :: Join_cpo\"\n  shows \"lub (insert x S) = x \\<squnion> lub S\""], "translations": [["", "lemmas join_mono = join_mono[OF all_compatible all_compatible ]"], ["", "lemmas join_above1[simp] = all_compatible[THEN join_above1]"], ["", "lemmas join_above2[simp] = all_compatible[THEN join_above2]"], ["", "lemmas join_below[simp] = all_compatible[THEN join_below]"], ["", "lemmas join_below_iff = all_compatible[THEN join_below_iff]"], ["", "lemmas join_assoc[simp] = join_assoc[OF all_compatible all_compatible all_compatible]"], ["", "lemmas join_comm[simp] = all_compatible[THEN join_commute]"], ["", "lemma join_lc[simp]: \"x \\<squnion> (y \\<squnion> z) = y \\<squnion> (x \\<squnion> (z::'a::Finite_Join_cpo))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> (y \\<squnion> z) = y \\<squnion> (x \\<squnion> z)", "by (metis join_assoc join_comm)"], ["", "lemma join_cont': \"chain Y \\<Longrightarrow> (\\<Squnion> i. Y i) \\<squnion> y = (\\<Squnion> i. Y i \\<squnion> (y::'a::Finite_Join_cpo))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain Y \\<Longrightarrow>\n    (\\<Squnion>i. Y i) \\<squnion> y = (\\<Squnion>i. Y i \\<squnion> y)", "by (metis all_compatible join_cont1)"], ["", "lemma join_cont1:\n  fixes y :: \"'a :: Finite_Join_cpo\"\n  shows \"cont (\\<lambda>x. (x \\<squnion> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. x \\<squnion> y)", "apply (rule contI2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. monofun (\\<lambda>x. x \\<squnion> y)\n 2. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i \\<squnion> y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>i. Y i) \\<squnion> y \\<sqsubseteq>\n                         (\\<Squnion>i. Y i \\<squnion> y)", "apply (rule monofunI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x ya.\n       x \\<sqsubseteq> ya \\<Longrightarrow>\n       x \\<squnion> y \\<sqsubseteq> ya \\<squnion> y\n 2. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i \\<squnion> y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>i. Y i) \\<squnion> y \\<sqsubseteq>\n                         (\\<Squnion>i. Y i \\<squnion> y)", "apply (metis below_refl join_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i \\<squnion> y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>i. Y i) \\<squnion> y \\<sqsubseteq>\n                         (\\<Squnion>i. Y i \\<squnion> y)", "apply (rule eq_imp_below)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i \\<squnion> y)\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>i. Y i) \\<squnion> y =\n                         (\\<Squnion>i. Y i \\<squnion> y)", "apply (rule join_cont')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; chain (\\<lambda>i. Y i \\<squnion> y)\\<rbrakk>\n       \\<Longrightarrow> chain Y", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma join_cont2: \n  fixes x :: \"'a :: Finite_Join_cpo\"\n  shows \"cont (\\<lambda>y. (x \\<squnion> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont ((\\<squnion>) x)", "by (simp only: join_comm) (rule join_cont1)"], ["", "lemma join_cont[cont2cont,simp]:\"cont f \\<Longrightarrow> cont g \\<Longrightarrow> cont (\\<lambda>x. (f x \\<squnion> (g x::'a::Finite_Join_cpo)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cont f; cont g\\<rbrakk>\n    \\<Longrightarrow> cont (\\<lambda>x. f x \\<squnion> g x)", "apply (rule cont2cont_case_prod[where g = \"\\<lambda> x. (f x, g x)\" and f = \"\\<lambda> p x y . x \\<squnion> y\", simplified])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>cont f; cont g\\<rbrakk>\n       \\<Longrightarrow> cont ((\\<squnion>) a)\n 2. \\<lbrakk>cont f; cont g\\<rbrakk>\n    \\<Longrightarrow> cont (\\<lambda>x. (f x, g x))", "apply (rule join_cont2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cont f; cont g\\<rbrakk>\n    \\<Longrightarrow> cont (\\<lambda>x. (f x, g x))", "apply (metis cont2cont_Pair)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "instantiation \"fun\" :: (type, Finite_Join_cpo) Finite_Join_cpo\nbegin"], ["", "definition fun_join :: \"('a \\<Rightarrow> 'b) \\<rightarrow> ('a \\<Rightarrow> 'b) \\<rightarrow> ('a \\<Rightarrow> 'b)\"\n    where \"fun_join = (\\<Lambda> f g . (\\<lambda> x. (f x) \\<squnion> (g x)))\""], ["", "lemma [simp]: \"(fun_join\\<cdot>f\\<cdot>g) x = (f x) \\<squnion> (g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.fun_join\\<cdot>f\\<cdot>g) x = f x \\<squnion> g x", "unfolding fun_join_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Lambda> f g. (\\<lambda>x. f x \\<squnion> g x))\\<cdot>f\\<cdot>g) x =\n    f x \\<squnion> g x", "apply (subst beta_cfun, intro cont2cont cont2cont_lambda cont2cont_fun)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<squnion> g x = f x \\<squnion> g x", ".."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<Rightarrow> 'b, Finite_Join_cpo_class)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. compatible x y", "proof(intro compatibleI exI conjI strip)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. x \\<sqsubseteq> ?z3 x y\n 2. \\<And>x y. y \\<sqsubseteq> ?z3 x y\n 3. \\<And>x y a.\n       \\<lbrakk>x \\<sqsubseteq> a; y \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> ?z3 x y \\<sqsubseteq> a", "fix x y"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. x \\<sqsubseteq> ?z3 x y\n 2. \\<And>x y. y \\<sqsubseteq> ?z3 x y\n 3. \\<And>x y a.\n       \\<lbrakk>x \\<sqsubseteq> a; y \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> ?z3 x y \\<sqsubseteq> a", "show \"x \\<sqsubseteq> fun_join\\<cdot>x\\<cdot>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> local.fun_join\\<cdot>x\\<cdot>y", "by (auto simp add: fun_below_iff)"], ["proof (state)\nthis:\n  x \\<sqsubseteq> local.fun_join\\<cdot>x\\<cdot>y\n\ngoal (2 subgoals):\n 1. \\<And>x y. y \\<sqsubseteq> local.fun_join\\<cdot>x\\<cdot>(?y7 x y)\n 2. \\<And>x y a.\n       \\<lbrakk>x \\<sqsubseteq> a; y \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> local.fun_join\\<cdot>x\\<cdot>\n                         (?y7 x y) \\<sqsubseteq>\n                         a", "show \"y \\<sqsubseteq> fun_join\\<cdot>x\\<cdot>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sqsubseteq> local.fun_join\\<cdot>x\\<cdot>y", "by (auto simp add: fun_below_iff)"], ["proof (state)\nthis:\n  y \\<sqsubseteq> local.fun_join\\<cdot>x\\<cdot>y\n\ngoal (1 subgoal):\n 1. \\<And>x y a.\n       \\<lbrakk>x \\<sqsubseteq> a; y \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> local.fun_join\\<cdot>x\\<cdot>y \\<sqsubseteq> a", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y a.\n       \\<lbrakk>x \\<sqsubseteq> a; y \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> local.fun_join\\<cdot>x\\<cdot>y \\<sqsubseteq> a", "assume \"x \\<sqsubseteq> z\" and \"y \\<sqsubseteq> z\""], ["proof (state)\nthis:\n  x \\<sqsubseteq> z\n  y \\<sqsubseteq> z\n\ngoal (1 subgoal):\n 1. \\<And>x y a.\n       \\<lbrakk>x \\<sqsubseteq> a; y \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> local.fun_join\\<cdot>x\\<cdot>y \\<sqsubseteq> a", "thus \"fun_join\\<cdot>x\\<cdot>y \\<sqsubseteq> z\""], ["proof (prove)\nusing this:\n  x \\<sqsubseteq> z\n  y \\<sqsubseteq> z\n\ngoal (1 subgoal):\n 1. local.fun_join\\<cdot>x\\<cdot>y \\<sqsubseteq> z", "by (auto simp add: fun_below_iff)"], ["proof (state)\nthis:\n  local.fun_join\\<cdot>x\\<cdot>y \\<sqsubseteq> z\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation \"cfun\" :: (cpo, Finite_Join_cpo) Finite_Join_cpo\nbegin"], ["", "definition cfun_join :: \"('a \\<rightarrow> 'b) \\<rightarrow> ('a \\<rightarrow> 'b) \\<rightarrow> ('a \\<rightarrow> 'b)\"\n    where \"cfun_join = (\\<Lambda> f g  x. (f \\<cdot> x) \\<squnion> (g \\<cdot> x))\""], ["", "lemma [simp]: \"cfun_join\\<cdot>f\\<cdot>g\\<cdot>x = (f \\<cdot> x) \\<squnion> (g \\<cdot> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.cfun_join\\<cdot>f\\<cdot>g\\<cdot>x = f\\<cdot>x \\<squnion> g\\<cdot>x", "unfolding cfun_join_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> f g x. f\\<cdot>x \\<squnion> g\\<cdot>x)\\<cdot>f\\<cdot>g\\<cdot>\n    x =\n    f\\<cdot>x \\<squnion> g\\<cdot>x", "apply (subst beta_cfun, intro cont2cont cont2cont_lambda cont2cont_fun)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<cdot>x \\<squnion> g\\<cdot>x = f\\<cdot>x \\<squnion> g\\<cdot>x", ".."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<rightarrow> 'b, Finite_Join_cpo_class)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. compatible x y", "proof(intro compatibleI exI conjI strip)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. x \\<sqsubseteq> ?z3 x y\n 2. \\<And>x y. y \\<sqsubseteq> ?z3 x y\n 3. \\<And>x y a.\n       \\<lbrakk>x \\<sqsubseteq> a; y \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> ?z3 x y \\<sqsubseteq> a", "fix x y"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y. x \\<sqsubseteq> ?z3 x y\n 2. \\<And>x y. y \\<sqsubseteq> ?z3 x y\n 3. \\<And>x y a.\n       \\<lbrakk>x \\<sqsubseteq> a; y \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> ?z3 x y \\<sqsubseteq> a", "show \"x \\<sqsubseteq> cfun_join\\<cdot>x\\<cdot>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> local.cfun_join\\<cdot>x\\<cdot>y", "by (auto simp add: cfun_below_iff)"], ["proof (state)\nthis:\n  x \\<sqsubseteq> local.cfun_join\\<cdot>x\\<cdot>y\n\ngoal (2 subgoals):\n 1. \\<And>x y. y \\<sqsubseteq> local.cfun_join\\<cdot>x\\<cdot>(?y7 x y)\n 2. \\<And>x y a.\n       \\<lbrakk>x \\<sqsubseteq> a; y \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> local.cfun_join\\<cdot>x\\<cdot>\n                         (?y7 x y) \\<sqsubseteq>\n                         a", "show \"y \\<sqsubseteq> cfun_join\\<cdot>x\\<cdot>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sqsubseteq> local.cfun_join\\<cdot>x\\<cdot>y", "by (auto simp add: cfun_below_iff)"], ["proof (state)\nthis:\n  y \\<sqsubseteq> local.cfun_join\\<cdot>x\\<cdot>y\n\ngoal (1 subgoal):\n 1. \\<And>x y a.\n       \\<lbrakk>x \\<sqsubseteq> a; y \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> local.cfun_join\\<cdot>x\\<cdot>y \\<sqsubseteq> a", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y a.\n       \\<lbrakk>x \\<sqsubseteq> a; y \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> local.cfun_join\\<cdot>x\\<cdot>y \\<sqsubseteq> a", "assume \"x \\<sqsubseteq> z\" and \"y \\<sqsubseteq> z\""], ["proof (state)\nthis:\n  x \\<sqsubseteq> z\n  y \\<sqsubseteq> z\n\ngoal (1 subgoal):\n 1. \\<And>x y a.\n       \\<lbrakk>x \\<sqsubseteq> a; y \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> local.cfun_join\\<cdot>x\\<cdot>y \\<sqsubseteq> a", "thus \"cfun_join\\<cdot>x\\<cdot>y \\<sqsubseteq> z\""], ["proof (prove)\nusing this:\n  x \\<sqsubseteq> z\n  y \\<sqsubseteq> z\n\ngoal (1 subgoal):\n 1. local.cfun_join\\<cdot>x\\<cdot>y \\<sqsubseteq> z", "by (auto simp add: cfun_below_iff)"], ["proof (state)\nthis:\n  local.cfun_join\\<cdot>x\\<cdot>y \\<sqsubseteq> z\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma bot_lub[simp]: \"S <<| \\<bottom> \\<longleftrightarrow>  S \\<subseteq> {\\<bottom>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S <<| \\<bottom> = (S \\<subseteq> {\\<bottom>})", "by (auto dest!: is_lubD1 is_ubD intro: is_lubI is_ubI)"], ["", "lemma compatible_up[simp]: \"compatible (up\\<cdot>x) (up\\<cdot>y) \\<longleftrightarrow> compatible x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compatible (up\\<cdot>x) (up\\<cdot>y) = compatible x y", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. compatible (up\\<cdot>x) (up\\<cdot>y) \\<Longrightarrow> compatible x y\n 2. compatible x y \\<Longrightarrow> compatible (up\\<cdot>x) (up\\<cdot>y)", "assume \"compatible (up\\<cdot>x) (up\\<cdot>y)\""], ["proof (state)\nthis:\n  compatible (up\\<cdot>x) (up\\<cdot>y)\n\ngoal (2 subgoals):\n 1. compatible (up\\<cdot>x) (up\\<cdot>y) \\<Longrightarrow> compatible x y\n 2. compatible x y \\<Longrightarrow> compatible (up\\<cdot>x) (up\\<cdot>y)", "then"], ["proof (chain)\npicking this:\n  compatible (up\\<cdot>x) (up\\<cdot>y)", "obtain z' where z': \"{up\\<cdot>x,up\\<cdot>y} <<| z'\""], ["proof (prove)\nusing this:\n  compatible (up\\<cdot>x) (up\\<cdot>y)\n\ngoal (1 subgoal):\n 1. (\\<And>z'.\n        {up\\<cdot>x, up\\<cdot>y} <<| z' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding compatible_def"], ["proof (prove)\nusing this:\n  Ex ((<<|) {up\\<cdot>x, up\\<cdot>y})\n\ngoal (1 subgoal):\n 1. (\\<And>z'.\n        {up\\<cdot>x, up\\<cdot>y} <<| z' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  {up\\<cdot>x, up\\<cdot>y} <<| z'\n\ngoal (2 subgoals):\n 1. compatible (up\\<cdot>x) (up\\<cdot>y) \\<Longrightarrow> compatible x y\n 2. compatible x y \\<Longrightarrow> compatible (up\\<cdot>x) (up\\<cdot>y)", "then"], ["proof (chain)\npicking this:\n  {up\\<cdot>x, up\\<cdot>y} <<| z'", "obtain z where  \"{up\\<cdot>x,up\\<cdot>y} <<| up\\<cdot>z\""], ["proof (prove)\nusing this:\n  {up\\<cdot>x, up\\<cdot>y} <<| z'\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        {up\\<cdot>x, up\\<cdot>y} <<| up\\<cdot>z \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases z') auto"], ["proof (state)\nthis:\n  {up\\<cdot>x, up\\<cdot>y} <<| up\\<cdot>z\n\ngoal (2 subgoals):\n 1. compatible (up\\<cdot>x) (up\\<cdot>y) \\<Longrightarrow> compatible x y\n 2. compatible x y \\<Longrightarrow> compatible (up\\<cdot>x) (up\\<cdot>y)", "hence \"{x,y} <<| z\""], ["proof (prove)\nusing this:\n  {up\\<cdot>x, up\\<cdot>y} <<| up\\<cdot>z\n\ngoal (1 subgoal):\n 1. {x, y} <<| z", "unfolding is_lub_def"], ["proof (prove)\nusing this:\n  {up\\<cdot>x, up\\<cdot>y} <| up\\<cdot>z \\<and>\n  (\\<forall>u.\n      {up\\<cdot>x, up\\<cdot>y} <| u \\<longrightarrow>\n      up\\<cdot>z \\<sqsubseteq> u)\n\ngoal (1 subgoal):\n 1. {x, y} <| z \\<and>\n    (\\<forall>u. {x, y} <| u \\<longrightarrow> z \\<sqsubseteq> u)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>x \\<sqsubseteq> z; y \\<sqsubseteq> z;\n        \\<forall>u.\n           up\\<cdot>x \\<sqsubseteq> u \\<and>\n           up\\<cdot>y \\<sqsubseteq> u \\<longrightarrow>\n           up\\<cdot>z \\<sqsubseteq> u;\n        x \\<sqsubseteq> u; y \\<sqsubseteq> u\\<rbrakk>\n       \\<Longrightarrow> z \\<sqsubseteq> u", "by (metis up_below)"], ["proof (state)\nthis:\n  {x, y} <<| z\n\ngoal (2 subgoals):\n 1. compatible (up\\<cdot>x) (up\\<cdot>y) \\<Longrightarrow> compatible x y\n 2. compatible x y \\<Longrightarrow> compatible (up\\<cdot>x) (up\\<cdot>y)", "thus \"compatible x y\""], ["proof (prove)\nusing this:\n  {x, y} <<| z\n\ngoal (1 subgoal):\n 1. compatible x y", "unfolding compatible_def"], ["proof (prove)\nusing this:\n  {x, y} <<| z\n\ngoal (1 subgoal):\n 1. Ex ((<<|) {x, y})", ".."], ["proof (state)\nthis:\n  compatible x y\n\ngoal (1 subgoal):\n 1. compatible x y \\<Longrightarrow> compatible (up\\<cdot>x) (up\\<cdot>y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. compatible x y \\<Longrightarrow> compatible (up\\<cdot>x) (up\\<cdot>y)", "assume \"compatible x y\""], ["proof (state)\nthis:\n  compatible x y\n\ngoal (1 subgoal):\n 1. compatible x y \\<Longrightarrow> compatible (up\\<cdot>x) (up\\<cdot>y)", "then"], ["proof (chain)\npicking this:\n  compatible x y", "obtain z where z: \"{x,y} <<| z\""], ["proof (prove)\nusing this:\n  compatible x y\n\ngoal (1 subgoal):\n 1. (\\<And>z. {x, y} <<| z \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding compatible_def"], ["proof (prove)\nusing this:\n  Ex ((<<|) {x, y})\n\ngoal (1 subgoal):\n 1. (\\<And>z. {x, y} <<| z \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  {x, y} <<| z\n\ngoal (1 subgoal):\n 1. compatible x y \\<Longrightarrow> compatible (up\\<cdot>x) (up\\<cdot>y)", "hence  \"{up\\<cdot>x,up\\<cdot>y} <<| up\\<cdot>z\""], ["proof (prove)\nusing this:\n  {x, y} <<| z\n\ngoal (1 subgoal):\n 1. {up\\<cdot>x, up\\<cdot>y} <<| up\\<cdot>z", "unfolding is_lub_def"], ["proof (prove)\nusing this:\n  {x, y} <| z \\<and>\n  (\\<forall>u. {x, y} <| u \\<longrightarrow> z \\<sqsubseteq> u)\n\ngoal (1 subgoal):\n 1. {up\\<cdot>x, up\\<cdot>y} <| up\\<cdot>z \\<and>\n    (\\<forall>u.\n        {up\\<cdot>x, up\\<cdot>y} <| u \\<longrightarrow>\n        up\\<cdot>z \\<sqsubseteq> u)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>x \\<sqsubseteq> z; y \\<sqsubseteq> z;\n        \\<forall>u.\n           x \\<sqsubseteq> u \\<and> y \\<sqsubseteq> u \\<longrightarrow>\n           z \\<sqsubseteq> u;\n        up\\<cdot>x \\<sqsubseteq> u; up\\<cdot>y \\<sqsubseteq> u\\<rbrakk>\n       \\<Longrightarrow> up\\<cdot>z \\<sqsubseteq> u", "by (metis not_up_less_UU upE up_below)"], ["proof (state)\nthis:\n  {up\\<cdot>x, up\\<cdot>y} <<| up\\<cdot>z\n\ngoal (1 subgoal):\n 1. compatible x y \\<Longrightarrow> compatible (up\\<cdot>x) (up\\<cdot>y)", "thus \"compatible (up\\<cdot>x) (up\\<cdot>y)\""], ["proof (prove)\nusing this:\n  {up\\<cdot>x, up\\<cdot>y} <<| up\\<cdot>z\n\ngoal (1 subgoal):\n 1. compatible (up\\<cdot>x) (up\\<cdot>y)", "unfolding compatible_def"], ["proof (prove)\nusing this:\n  {up\\<cdot>x, up\\<cdot>y} <<| up\\<cdot>z\n\ngoal (1 subgoal):\n 1. Ex ((<<|) {up\\<cdot>x, up\\<cdot>y})", ".."], ["proof (state)\nthis:\n  compatible (up\\<cdot>x) (up\\<cdot>y)\n\ngoal:\nNo subgoals!", "qed"], ["", "instance u :: (Finite_Join_cpo) Finite_Join_cpo"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a\\<^sub>\\<bottom>, Finite_Join_cpo_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. compatible x y", "fix x y :: \"'a\\<^sub>\\<bottom>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. compatible x y", "show \"compatible x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compatible x y", "apply (cases x, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa. x = up\\<cdot>xa \\<Longrightarrow> compatible x y", "apply (cases y, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xaa.\n       \\<lbrakk>x = up\\<cdot>xa; y = up\\<cdot>xaa\\<rbrakk>\n       \\<Longrightarrow> compatible x y", "apply (simp add: all_compatible)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  compatible x y\n\ngoal:\nNo subgoals!", "qed"], ["", "class is_unit = fixes unit assumes is_unit: \"\\<And> x. x = unit\""], ["", "instantiation unit :: is_unit\nbegin"], ["", "definition \"unit \\<equiv> ()\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(unit, is_unit_class)", "by standard auto"], ["", "end"], ["", "instance lift :: (is_unit) Finite_Join_cpo"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a lift, Finite_Join_cpo_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. compatible x y", "fix x y :: \"'a lift\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. compatible x y", "show \"compatible x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compatible x y", "apply (cases x, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. x = Def a \\<Longrightarrow> compatible x y", "apply (cases y, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa.\n       \\<lbrakk>x = Def a; y = Def aa\\<rbrakk>\n       \\<Longrightarrow> compatible x y", "apply (simp add: all_compatible)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa.\n       \\<lbrakk>x = Def a; y = Def aa\\<rbrakk>\n       \\<Longrightarrow> compatible (Def a) (Def aa)", "apply (subst is_unit)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa.\n       \\<lbrakk>x = Def a; y = Def aa\\<rbrakk>\n       \\<Longrightarrow> compatible (Def unit) (Def aa)", "apply (subst is_unit)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa.\n       \\<lbrakk>x = Def a; y = Def aa\\<rbrakk>\n       \\<Longrightarrow> compatible (Def unit) (Def aa)", "back"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa.\n       \\<lbrakk>x = Def a; y = Def aa\\<rbrakk>\n       \\<Longrightarrow> compatible (Def unit) (Def unit)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  compatible x y\n\ngoal:\nNo subgoals!", "qed"], ["", "instance prod :: (Finite_Join_cpo, Finite_Join_cpo) Finite_Join_cpo"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, Finite_Join_cpo_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. compatible x y", "fix x y :: \"('a \\<times> 'b)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. compatible x y", "let ?z = \"(fst x \\<squnion> fst y, snd x \\<squnion> snd y)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. compatible x y", "show \"compatible x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compatible x y", "proof(rule compatibleI)"], ["proof (state)\ngoal (3 subgoals):\n 1. x \\<sqsubseteq> ?z\n 2. y \\<sqsubseteq> ?z\n 3. \\<And>a.\n       \\<lbrakk>x \\<sqsubseteq> a; y \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> ?z \\<sqsubseteq> a", "show \"x \\<sqsubseteq> ?z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqsubseteq> (fst x \\<squnion> fst y, snd x \\<squnion> snd y)", "by (cases x, auto)"], ["proof (state)\nthis:\n  x \\<sqsubseteq> (fst x \\<squnion> fst y, snd x \\<squnion> snd y)\n\ngoal (2 subgoals):\n 1. y \\<sqsubseteq> (fst x \\<squnion> fst y, snd x \\<squnion> snd y)\n 2. \\<And>a.\n       \\<lbrakk>x \\<sqsubseteq> a; y \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> (fst x \\<squnion> fst y,\n                          snd x \\<squnion> snd y) \\<sqsubseteq>\n                         a", "show \"y \\<sqsubseteq> ?z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sqsubseteq> (fst x \\<squnion> fst y, snd x \\<squnion> snd y)", "by (cases y, auto)"], ["proof (state)\nthis:\n  y \\<sqsubseteq> (fst x \\<squnion> fst y, snd x \\<squnion> snd y)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>x \\<sqsubseteq> a; y \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> (fst x \\<squnion> fst y,\n                          snd x \\<squnion> snd y) \\<sqsubseteq>\n                         a", "fix z'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>x \\<sqsubseteq> a; y \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> (fst x \\<squnion> fst y,\n                          snd x \\<squnion> snd y) \\<sqsubseteq>\n                         a", "assume \"x \\<sqsubseteq> z'\" and \"y \\<sqsubseteq> z'\""], ["proof (state)\nthis:\n  x \\<sqsubseteq> z'\n  y \\<sqsubseteq> z'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>x \\<sqsubseteq> a; y \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> (fst x \\<squnion> fst y,\n                          snd x \\<squnion> snd y) \\<sqsubseteq>\n                         a", "thus \"?z \\<sqsubseteq> z'\""], ["proof (prove)\nusing this:\n  x \\<sqsubseteq> z'\n  y \\<sqsubseteq> z'\n\ngoal (1 subgoal):\n 1. (fst x \\<squnion> fst y, snd x \\<squnion> snd y) \\<sqsubseteq> z'", "by (cases z', cases x, cases y, auto)"], ["proof (state)\nthis:\n  (fst x \\<squnion> fst y, snd x \\<squnion> snd y) \\<sqsubseteq> z'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  compatible x y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prod_join: \n    fixes x y :: \"'a::Finite_Join_cpo \\<times> 'b::Finite_Join_cpo\" \n    shows \"x \\<squnion> y = (fst x \\<squnion> fst y, snd x \\<squnion> snd y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> y = (fst x \\<squnion> fst y, snd x \\<squnion> snd y)", "apply (rule is_joinI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<sqsubseteq> (fst x \\<squnion> fst y, snd x \\<squnion> snd y)\n 2. y \\<sqsubseteq> (fst x \\<squnion> fst y, snd x \\<squnion> snd y)\n 3. \\<And>a.\n       \\<lbrakk>x \\<sqsubseteq> a; y \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> (fst x \\<squnion> fst y,\n                          snd x \\<squnion> snd y) \\<sqsubseteq>\n                         a", "apply (cases x, auto)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. y \\<sqsubseteq> (fst x \\<squnion> fst y, snd x \\<squnion> snd y)\n 2. \\<And>a.\n       \\<lbrakk>x \\<sqsubseteq> a; y \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> (fst x \\<squnion> fst y,\n                          snd x \\<squnion> snd y) \\<sqsubseteq>\n                         a", "apply (cases y, auto)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>x \\<sqsubseteq> a; y \\<sqsubseteq> a\\<rbrakk>\n       \\<Longrightarrow> (fst x \\<squnion> fst y,\n                          snd x \\<squnion> snd y) \\<sqsubseteq>\n                         a", "apply (cases x, cases y, case_tac a, auto)[1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \n  fixes x y :: \"'a::Finite_Join_cpo \\<times> 'b::Finite_Join_cpo\" \n  shows fst_join[simp]: \"fst (x \\<squnion> y) = fst x \\<squnion> fst y\"\n  and snd_join[simp]: \"snd (x \\<squnion> y) = snd x \\<squnion> snd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (x \\<squnion> y) = fst x \\<squnion> fst y &&&\n    snd (x \\<squnion> y) = snd x \\<squnion> snd y", "unfolding prod_join"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (fst x \\<squnion> fst y, snd x \\<squnion> snd y) =\n    fst x \\<squnion> fst y &&&\n    snd (fst x \\<squnion> fst y, snd x \\<squnion> snd y) =\n    snd x \\<squnion> snd y", "by simp_all"], ["", "lemma fun_meet_simp[simp]: \"(f \\<squnion> g) x = f x \\<squnion> (g x::'a::Finite_Join_cpo)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<squnion> g) x = f x \\<squnion> g x", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (f \\<squnion> g) x = f x \\<squnion> g x", "have \"f \\<squnion> g = (\\<lambda> x. f x \\<squnion> g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<squnion> g = (\\<lambda>x. f x \\<squnion> g x)", "by (rule is_joinI)(auto simp add: fun_below_iff)"], ["proof (state)\nthis:\n  f \\<squnion> g = (\\<lambda>x. f x \\<squnion> g x)\n\ngoal (1 subgoal):\n 1. (f \\<squnion> g) x = f x \\<squnion> g x", "thus ?thesis"], ["proof (prove)\nusing this:\n  f \\<squnion> g = (\\<lambda>x. f x \\<squnion> g x)\n\ngoal (1 subgoal):\n 1. (f \\<squnion> g) x = f x \\<squnion> g x", "by simp"], ["proof (state)\nthis:\n  (f \\<squnion> g) x = f x \\<squnion> g x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fun_upd_meet_simp[simp]: \"(f \\<squnion> g) (x := y) = f (x := y)  \\<squnion> g (x := y::'a::Finite_Join_cpo)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<squnion> g)(x := y) = f(x := y) \\<squnion> g(x := y)", "by auto"], ["", "lemma cfun_meet_simp[simp]: \"(f \\<squnion> g) \\<cdot> x = f \\<cdot> x \\<squnion> (g \\<cdot> x::'a::Finite_Join_cpo)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<squnion> g)\\<cdot>x = f\\<cdot>x \\<squnion> g\\<cdot>x", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (f \\<squnion> g)\\<cdot>x = f\\<cdot>x \\<squnion> g\\<cdot>x", "have \"f \\<squnion> g = (\\<Lambda> x. f \\<cdot> x \\<squnion> g \\<cdot> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<squnion> g = (\\<Lambda> x. f\\<cdot>x \\<squnion> g\\<cdot>x)", "by (rule is_joinI)(auto simp add: cfun_below_iff)"], ["proof (state)\nthis:\n  f \\<squnion> g = (\\<Lambda> x. f\\<cdot>x \\<squnion> g\\<cdot>x)\n\ngoal (1 subgoal):\n 1. (f \\<squnion> g)\\<cdot>x = f\\<cdot>x \\<squnion> g\\<cdot>x", "thus ?thesis"], ["proof (prove)\nusing this:\n  f \\<squnion> g = (\\<Lambda> x. f\\<cdot>x \\<squnion> g\\<cdot>x)\n\ngoal (1 subgoal):\n 1. (f \\<squnion> g)\\<cdot>x = f\\<cdot>x \\<squnion> g\\<cdot>x", "by simp"], ["proof (state)\nthis:\n  (f \\<squnion> g)\\<cdot>x = f\\<cdot>x \\<squnion> g\\<cdot>x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cfun_join_below:\n  fixes f :: \"('a::Finite_Join_cpo) \\<rightarrow> ('b::Finite_Join_cpo)\"\n  shows \"f\\<cdot>x \\<squnion> f\\<cdot>y \\<sqsubseteq> f\\<cdot>(x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<cdot>x \\<squnion> f\\<cdot>y \\<sqsubseteq> f\\<cdot>(x \\<squnion> y)", "by (intro join_below monofun_cfun_arg join_above1 join_above2)"], ["", "lemma join_self_below[iff]:\n  \"x = x \\<squnion> y \\<longleftrightarrow> y \\<sqsubseteq> (x::'a::Finite_Join_cpo)\"\n  \"x = y \\<squnion> x \\<longleftrightarrow> y \\<sqsubseteq> (x::'a::Finite_Join_cpo)\"\n  \"x \\<squnion> y = x \\<longleftrightarrow> y \\<sqsubseteq> (x::'a::Finite_Join_cpo)\"\n  \"y \\<squnion> x = x \\<longleftrightarrow> y \\<sqsubseteq> (x::'a::Finite_Join_cpo)\"\n  \"x \\<squnion> y \\<sqsubseteq> x \\<longleftrightarrow> y \\<sqsubseteq> (x::'a::Finite_Join_cpo)\"\n  \"y \\<squnion> x \\<sqsubseteq> x \\<longleftrightarrow> y \\<sqsubseteq> (x::'a::Finite_Join_cpo)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x = x \\<squnion> y) = (y \\<sqsubseteq> x) &&&\n     (x = y \\<squnion> x) = (y \\<sqsubseteq> x) &&&\n     (x \\<squnion> y = x) = (y \\<sqsubseteq> x)) &&&\n    (y \\<squnion> x = x) = (y \\<sqsubseteq> x) &&&\n    (x \\<squnion> y \\<sqsubseteq> x) = (y \\<sqsubseteq> x) &&&\n    (y \\<squnion> x \\<sqsubseteq> x) = (y \\<sqsubseteq> x)", "apply (metis join_above2 larger_is_join1)"], ["proof (prove)\ngoal (5 subgoals):\n 1. (x = y \\<squnion> x) = (y \\<sqsubseteq> x)\n 2. (x \\<squnion> y = x) = (y \\<sqsubseteq> x)\n 3. (y \\<squnion> x = x) = (y \\<sqsubseteq> x)\n 4. (x \\<squnion> y \\<sqsubseteq> x) = (y \\<sqsubseteq> x)\n 5. (y \\<squnion> x \\<sqsubseteq> x) = (y \\<sqsubseteq> x)", "apply (metis join_above1 larger_is_join2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. (x \\<squnion> y = x) = (y \\<sqsubseteq> x)\n 2. (y \\<squnion> x = x) = (y \\<sqsubseteq> x)\n 3. (x \\<squnion> y \\<sqsubseteq> x) = (y \\<sqsubseteq> x)\n 4. (y \\<squnion> x \\<sqsubseteq> x) = (y \\<sqsubseteq> x)", "apply (metis join_above2 larger_is_join1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (y \\<squnion> x = x) = (y \\<sqsubseteq> x)\n 2. (x \\<squnion> y \\<sqsubseteq> x) = (y \\<sqsubseteq> x)\n 3. (y \\<squnion> x \\<sqsubseteq> x) = (y \\<sqsubseteq> x)", "apply (metis join_above1 larger_is_join2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (x \\<squnion> y \\<sqsubseteq> x) = (y \\<sqsubseteq> x)\n 2. (y \\<squnion> x \\<sqsubseteq> x) = (y \\<sqsubseteq> x)", "apply (metis join_above1 join_above2 below_antisym larger_is_join1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<squnion> x \\<sqsubseteq> x) = (y \\<sqsubseteq> x)", "apply (metis join_above2 join_above1 below_antisym larger_is_join2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma join_bottom_iff[iff]:\n  \"x \\<squnion> y = \\<bottom> \\<longleftrightarrow> x = \\<bottom> \\<and> (y::'a::{Finite_Join_cpo,pcpo}) = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y = \\<bottom>) = (x = \\<bottom> \\<and> y = \\<bottom>)", "by (metis all_compatible join_bottom(2) join_comm join_idem)"], ["", "class Join_cpo = cpo +\n  assumes exists_lub: \"\\<exists>u. S <<| u\""], ["", "context Join_cpo\nbegin"], ["", "subclass Finite_Join_cpo"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.Finite_Join_cpo (\\<sqsubseteq>)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. compatible x y", "unfolding compatible_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. Ex ((<<|) {x, y})", "apply (rule exists_lub)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma below_lubI[intro, simp]:\n  fixes x :: \"'a :: Join_cpo\"\n  shows  \"x \\<in> S \\<Longrightarrow> x \\<sqsubseteq> lub S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> S \\<Longrightarrow> x \\<sqsubseteq> lub S", "by (metis exists_lub is_ub_thelub_ex)"], ["", "lemma lub_belowI[intro, simp]:\n  fixes x :: \"'a :: Join_cpo\"\n  shows  \"(\\<And> y. y \\<in> S \\<Longrightarrow> y \\<sqsubseteq> x) \\<Longrightarrow> lub S \\<sqsubseteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        y \\<in> S \\<Longrightarrow> y \\<sqsubseteq> x) \\<Longrightarrow>\n    lub S \\<sqsubseteq> x", "by (metis exists_lub is_lub_thelub_ex is_ub_def)"], ["", "(* subclass (in Join_cpo)  pcpo *)"], ["", "instance Join_cpo \\<subseteq> pcpo"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a, pcpo_class)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. \\<forall>y. x \\<sqsubseteq> y", "apply (rule exI[where x = \"lub {}\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. lub {} \\<sqsubseteq> y", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lub_empty_set[simp]:\n  \"lub {} = (\\<bottom>::'a::Join_cpo)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lub {} = \\<bottom>", "by (rule lub_eqI) simp"], ["", "lemma lub_insert[simp]:\n  fixes x :: \"'a :: Join_cpo\"\n  shows \"lub (insert x S) = x \\<squnion> lub S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lub (insert x S) = x \\<squnion> lub S", "by (rule lub_eqI) (auto intro: below_trans[OF _ join_above2] simp add: join_below_iff is_ub_def is_lub_def)"], ["", "end"]]}