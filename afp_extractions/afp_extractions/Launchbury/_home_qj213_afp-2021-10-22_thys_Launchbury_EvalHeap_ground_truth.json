{"file_name": "/home/qj213/afp-2021-10-22/thys/Launchbury/EvalHeap.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Launchbury", "problem_names": ["lemma cont2cont_evalHeap[simp, cont2cont]:\n  \"(\\<And> e . e \\<in> snd ` set h \\<Longrightarrow> cont (\\<lambda>\\<rho>. eval \\<rho> e)) \\<Longrightarrow> cont (\\<lambda> \\<rho>. evalHeap h (eval \\<rho>))\"", "lemma evalHeap_eqvt[eqvt]:\n  \"\\<pi> \\<bullet> evalHeap h eval = evalHeap (\\<pi> \\<bullet> h) (\\<pi> \\<bullet> eval)\"", "lemma edom_evalHeap_subset:\"edom (evalHeap h eval) \\<subseteq> domA h\"", "lemma evalHeap_cong[fundef_cong]:\n  \"\\<lbrakk> heap1 = heap2 ;  (\\<And> e. e \\<in> snd ` set heap2 \\<Longrightarrow> eval1 e = eval2 e) \\<rbrakk>\n    \\<Longrightarrow>  evalHeap heap1 eval1 = evalHeap heap2 eval2\"", "lemma lookupEvalHeap:\n  assumes \"v \\<in> domA h\"\n  shows \"(evalHeap h f) v = f (the (map_of h v))\"", "lemma lookupEvalHeap':\n  assumes \"map_of \\<Gamma> v = Some e\"\n  shows \"(evalHeap \\<Gamma> f) v = f e\"", "lemma lookupEvalHeap_other[simp]:\n  assumes \"v \\<notin> domA \\<Gamma>\"\n  shows \"(evalHeap \\<Gamma> f) v = \\<bottom>\"", "lemma env_restr_evalHeap_noop:\n  \"domA h \\<subseteq> S \\<Longrightarrow> env_restr S (evalHeap h eval) = evalHeap h eval\"", "lemma env_restr_evalHeap_same[simp]:\n  \"env_restr (domA h) (evalHeap h eval) = evalHeap h eval\"", "lemma evalHeap_cong':\n  \"\\<lbrakk> (\\<And> x. x \\<in> domA heap \\<Longrightarrow> eval1 (the (map_of heap x)) = eval2 (the (map_of heap x))) \\<rbrakk>\n    \\<Longrightarrow>  evalHeap heap eval1 = evalHeap heap eval2\"", "lemma lookupEvalHeapNotAppend[simp]:\n  assumes \"x \\<notin> domA \\<Gamma>\"\n  shows \"(evalHeap (\\<Gamma>@h) f) x = evalHeap h f x\"", "lemma evalHeap_delete[simp]: \"evalHeap (delete x \\<Gamma>) eval = env_delete x (evalHeap \\<Gamma> eval)\"", "lemma evalHeap_mono:\n  \"x \\<notin> domA \\<Gamma> \\<Longrightarrow>\n  evalHeap \\<Gamma> eval \\<sqsubseteq> evalHeap ((x, e) # \\<Gamma>) eval\"", "lemma evalHeap_reorder:\n  assumes \"map_of \\<Gamma> = map_of \\<Delta>\"\n  shows \"evalHeap \\<Gamma> h = evalHeap \\<Delta> h\"", "lemma evalHeap_reorder_head:\n  assumes \"x \\<noteq> y\"\n  shows \"evalHeap ((x,e1)#(y,e2)#\\<Gamma>) eval = evalHeap ((y,e2)#(x,e1)#\\<Gamma>) eval\"", "lemma evalHeap_reorder_head_append:\n  assumes \"x \\<notin> domA \\<Gamma>\"\n  shows \"evalHeap ((x,e)#\\<Gamma>@\\<Delta>) eval = evalHeap (\\<Gamma> @ ((x,e)#\\<Delta>)) eval\"", "lemma evalHeap_subst_exp:\n  assumes \"eval e = eval e'\"\n  shows \"evalHeap ((x,e)#\\<Gamma>) eval = evalHeap ((x,e')#\\<Gamma>) eval\""], "translations": [["", "lemma cont2cont_evalHeap[simp, cont2cont]:\n  \"(\\<And> e . e \\<in> snd ` set h \\<Longrightarrow> cont (\\<lambda>\\<rho>. eval \\<rho> e)) \\<Longrightarrow> cont (\\<lambda> \\<rho>. evalHeap h (eval \\<rho>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e.\n        e \\<in> snd ` set h \\<Longrightarrow>\n        cont (\\<lambda>\\<rho>. eval \\<rho> e)) \\<Longrightarrow>\n    cont (\\<lambda>\\<rho>. evalHeap h (eval \\<rho>))", "by(induct h, auto)"], ["", "lemma evalHeap_eqvt[eqvt]:\n  \"\\<pi> \\<bullet> evalHeap h eval = evalHeap (\\<pi> \\<bullet> h) (\\<pi> \\<bullet> eval)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> evalHeap h eval =\n    evalHeap (\\<pi> \\<bullet> h) (\\<pi> \\<bullet> eval)", "by (induct h) (auto simp add:fun_upd_eqvt  simp del: fun_upd_apply)"], ["", "lemma edom_evalHeap_subset:\"edom (evalHeap h eval) \\<subseteq> domA h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. edom (evalHeap h eval) \\<subseteq> domA h", "by (induct h eval rule:evalHeap.induct) (auto dest:subsetD[OF edom_fun_upd_subset] simp del: fun_upd_apply)"], ["", "lemma evalHeap_cong[fundef_cong]:\n  \"\\<lbrakk> heap1 = heap2 ;  (\\<And> e. e \\<in> snd ` set heap2 \\<Longrightarrow> eval1 e = eval2 e) \\<rbrakk>\n    \\<Longrightarrow>  evalHeap heap1 eval1 = evalHeap heap2 eval2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>heap1 = heap2;\n     \\<And>e.\n        e \\<in> snd ` set heap2 \\<Longrightarrow> eval1 e = eval2 e\\<rbrakk>\n    \\<Longrightarrow> evalHeap heap1 eval1 = evalHeap heap2 eval2", "by (induct heap2 eval2 arbitrary:heap1 rule:evalHeap.induct, auto)"], ["", "lemma lookupEvalHeap:\n  assumes \"v \\<in> domA h\"\n  shows \"(evalHeap h f) v = f (the (map_of h v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalHeap h f v = f (the (map_of h v))", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> domA h\n\ngoal (1 subgoal):\n 1. evalHeap h f v = f (the (map_of h v))", "by (induct h f rule: evalHeap.induct) auto"], ["", "lemma lookupEvalHeap':\n  assumes \"map_of \\<Gamma> v = Some e\"\n  shows \"(evalHeap \\<Gamma> f) v = f e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalHeap \\<Gamma> f v = f e", "using assms"], ["proof (prove)\nusing this:\n  map_of \\<Gamma> v = Some e\n\ngoal (1 subgoal):\n 1. evalHeap \\<Gamma> f v = f e", "by (induct \\<Gamma> f rule: evalHeap.induct) auto"], ["", "lemma lookupEvalHeap_other[simp]:\n  assumes \"v \\<notin> domA \\<Gamma>\"\n  shows \"(evalHeap \\<Gamma> f) v = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalHeap \\<Gamma> f v = \\<bottom>", "using assms"], ["proof (prove)\nusing this:\n  v \\<notin> domA \\<Gamma>\n\ngoal (1 subgoal):\n 1. evalHeap \\<Gamma> f v = \\<bottom>", "by (induct \\<Gamma> f rule: evalHeap.induct) auto"], ["", "lemma env_restr_evalHeap_noop:\n  \"domA h \\<subseteq> S \\<Longrightarrow> env_restr S (evalHeap h eval) = evalHeap h eval\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domA h \\<subseteq> S \\<Longrightarrow>\n    evalHeap h eval f|` S = evalHeap h eval", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       domA h \\<subseteq> S \\<Longrightarrow>\n       (evalHeap h eval f|` S) x = evalHeap h eval x", "apply (case_tac \"x \\<in> S\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>domA h \\<subseteq> S; x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> (evalHeap h eval f|` S) x = evalHeap h eval x\n 2. \\<And>x.\n       \\<lbrakk>domA h \\<subseteq> S; x \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> (evalHeap h eval f|` S) x = evalHeap h eval x", "apply (auto simp add: lookupEvalHeap intro: lookupEvalHeap_other)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma env_restr_evalHeap_same[simp]:\n  \"env_restr (domA h) (evalHeap h eval) = evalHeap h eval\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalHeap h eval f|` domA h = evalHeap h eval", "by (simp add: env_restr_evalHeap_noop)"], ["", "lemma evalHeap_cong':\n  \"\\<lbrakk> (\\<And> x. x \\<in> domA heap \\<Longrightarrow> eval1 (the (map_of heap x)) = eval2 (the (map_of heap x))) \\<rbrakk>\n    \\<Longrightarrow>  evalHeap heap eval1 = evalHeap heap eval2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> domA heap \\<Longrightarrow>\n        eval1 (the (map_of heap x)) =\n        eval2 (the (map_of heap x))) \\<Longrightarrow>\n    evalHeap heap eval1 = evalHeap heap eval2", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>x.\n           x \\<in> domA heap \\<Longrightarrow>\n           eval1 (the (map_of heap x)) =\n           eval2 (the (map_of heap x))) \\<Longrightarrow>\n       evalHeap heap eval1 x = evalHeap heap eval2 x", "apply (case_tac \"x \\<in> domA heap\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> domA heap \\<Longrightarrow>\n                   eval1 (the (map_of heap x)) =\n                   eval2 (the (map_of heap x));\n        x \\<in> domA heap\\<rbrakk>\n       \\<Longrightarrow> evalHeap heap eval1 x = evalHeap heap eval2 x\n 2. \\<And>x.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> domA heap \\<Longrightarrow>\n                   eval1 (the (map_of heap x)) =\n                   eval2 (the (map_of heap x));\n        x \\<notin> domA heap\\<rbrakk>\n       \\<Longrightarrow> evalHeap heap eval1 x = evalHeap heap eval2 x", "apply (auto simp add: lookupEvalHeap)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lookupEvalHeapNotAppend[simp]:\n  assumes \"x \\<notin> domA \\<Gamma>\"\n  shows \"(evalHeap (\\<Gamma>@h) f) x = evalHeap h f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalHeap (\\<Gamma> @ h) f x = evalHeap h f x", "using assms"], ["proof (prove)\nusing this:\n  x \\<notin> domA \\<Gamma>\n\ngoal (1 subgoal):\n 1. evalHeap (\\<Gamma> @ h) f x = evalHeap h f x", "by (induct \\<Gamma>, auto)"], ["", "lemma evalHeap_delete[simp]: \"evalHeap (delete x \\<Gamma>) eval = env_delete x (evalHeap \\<Gamma> eval)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalHeap (delete x \\<Gamma>) eval =\n    env_delete x (evalHeap \\<Gamma> eval)", "by (induct \\<Gamma>) auto"], ["", "lemma evalHeap_mono:\n  \"x \\<notin> domA \\<Gamma> \\<Longrightarrow>\n  evalHeap \\<Gamma> eval \\<sqsubseteq> evalHeap ((x, e) # \\<Gamma>) eval\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> domA \\<Gamma> \\<Longrightarrow>\n    evalHeap \\<Gamma> eval \\<sqsubseteq> evalHeap ((x, e) # \\<Gamma>) eval", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> domA \\<Gamma> \\<Longrightarrow>\n    evalHeap \\<Gamma> eval \\<sqsubseteq> (evalHeap \\<Gamma> eval)\n    (x := eval e)", "apply (rule fun_belowI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       x \\<notin> domA \\<Gamma> \\<Longrightarrow>\n       evalHeap \\<Gamma> eval xa \\<sqsubseteq>\n       ((evalHeap \\<Gamma> eval)(x := eval e)) xa", "apply (case_tac \"xa \\<in> domA \\<Gamma>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<notin> domA \\<Gamma>; xa \\<in> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> evalHeap \\<Gamma> eval xa \\<sqsubseteq>\n                         ((evalHeap \\<Gamma> eval)(x := eval e)) xa\n 2. \\<And>xa.\n       \\<lbrakk>x \\<notin> domA \\<Gamma>; xa \\<notin> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> evalHeap \\<Gamma> eval xa \\<sqsubseteq>\n                         ((evalHeap \\<Gamma> eval)(x := eval e)) xa", "apply (case_tac \"xa = x\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>x \\<notin> domA \\<Gamma>; xa \\<in> domA \\<Gamma>;\n        xa = x\\<rbrakk>\n       \\<Longrightarrow> evalHeap \\<Gamma> eval xa \\<sqsubseteq>\n                         ((evalHeap \\<Gamma> eval)(x := eval e)) xa\n 2. \\<And>xa.\n       \\<lbrakk>x \\<notin> domA \\<Gamma>; xa \\<in> domA \\<Gamma>;\n        xa \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> evalHeap \\<Gamma> eval xa \\<sqsubseteq>\n                         ((evalHeap \\<Gamma> eval)(x := eval e)) xa\n 3. \\<And>xa.\n       \\<lbrakk>x \\<notin> domA \\<Gamma>; xa \\<notin> domA \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> evalHeap \\<Gamma> eval xa \\<sqsubseteq>\n                         ((evalHeap \\<Gamma> eval)(x := eval e)) xa", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Reordering lemmas\\<close>"], ["", "lemma evalHeap_reorder:\n  assumes \"map_of \\<Gamma> = map_of \\<Delta>\"\n  shows \"evalHeap \\<Gamma> h = evalHeap \\<Delta> h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalHeap \\<Gamma> h = evalHeap \\<Delta> h", "proof (rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. evalHeap \\<Gamma> h x = evalHeap \\<Delta> h x", "from assms"], ["proof (chain)\npicking this:\n  map_of \\<Gamma> = map_of \\<Delta>", "have *: \"domA \\<Gamma> = domA \\<Delta>\""], ["proof (prove)\nusing this:\n  map_of \\<Gamma> = map_of \\<Delta>\n\ngoal (1 subgoal):\n 1. domA \\<Gamma> = domA \\<Delta>", "by (metis dom_map_of_conv_domA)"], ["proof (state)\nthis:\n  domA \\<Gamma> = domA \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<And>x. evalHeap \\<Gamma> h x = evalHeap \\<Delta> h x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. evalHeap \\<Gamma> h x = evalHeap \\<Delta> h x", "show \"evalHeap \\<Gamma> h x = evalHeap \\<Delta> h x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalHeap \\<Gamma> h x = evalHeap \\<Delta> h x", "using assms(1) *"], ["proof (prove)\nusing this:\n  map_of \\<Gamma> = map_of \\<Delta>\n  domA \\<Gamma> = domA \\<Delta>\n\ngoal (1 subgoal):\n 1. evalHeap \\<Gamma> h x = evalHeap \\<Delta> h x", "apply (cases \"x \\<in> domA \\<Gamma>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>map_of \\<Gamma> = map_of \\<Delta>;\n     domA \\<Gamma> = domA \\<Delta>; x \\<in> domA \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> evalHeap \\<Gamma> h x = evalHeap \\<Delta> h x\n 2. \\<lbrakk>map_of \\<Gamma> = map_of \\<Delta>;\n     domA \\<Gamma> = domA \\<Delta>; x \\<notin> domA \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> evalHeap \\<Gamma> h x = evalHeap \\<Delta> h x", "apply (auto simp add: lookupEvalHeap)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  evalHeap \\<Gamma> h x = evalHeap \\<Delta> h x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma evalHeap_reorder_head:\n  assumes \"x \\<noteq> y\"\n  shows \"evalHeap ((x,e1)#(y,e2)#\\<Gamma>) eval = evalHeap ((y,e2)#(x,e1)#\\<Gamma>) eval\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalHeap ((x, e1) # (y, e2) # \\<Gamma>) eval =\n    evalHeap ((y, e2) # (x, e1) # \\<Gamma>) eval", "by (rule evalHeap_reorder) (simp add: fun_upd_twist[OF assms])"], ["", "lemma evalHeap_reorder_head_append:\n  assumes \"x \\<notin> domA \\<Gamma>\"\n  shows \"evalHeap ((x,e)#\\<Gamma>@\\<Delta>) eval = evalHeap (\\<Gamma> @ ((x,e)#\\<Delta>)) eval\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalHeap ((x, e) # \\<Gamma> @ \\<Delta>) eval =\n    evalHeap (\\<Gamma> @ (x, e) # \\<Delta>) eval", "by (rule evalHeap_reorder) (simp, metis assms dom_map_of_conv_domA map_add_upd_left)"], ["", "lemma evalHeap_subst_exp:\n  assumes \"eval e = eval e'\"\n  shows \"evalHeap ((x,e)#\\<Gamma>) eval = evalHeap ((x,e')#\\<Gamma>) eval\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalHeap ((x, e) # \\<Gamma>) eval = evalHeap ((x, e') # \\<Gamma>) eval", "by (simp add: assms)"], ["", "end"]]}