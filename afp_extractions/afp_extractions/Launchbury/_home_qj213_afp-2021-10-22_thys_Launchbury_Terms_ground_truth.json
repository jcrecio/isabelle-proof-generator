{"file_name": "/home/qj213/afp-2021-10-22/thys/Launchbury/Terms.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Launchbury", "problem_names": ["lemma exp_assn_size_eqvt[eqvt]: \"p \\<bullet> (size :: exp \\<Rightarrow> nat) = size\"", "lemma asToHeap_eqvt: \"eqvt asToHeap\"", "lemma heapToAssn_eqvt[simp,eqvt]: \"p \\<bullet> heapToAssn \\<Gamma> =  heapToAssn (p \\<bullet> \\<Gamma>)\"", "lemma bn_heapToAssn: \"bn (heapToAssn \\<Gamma>) = map (\\<lambda>x. atom (fst x)) \\<Gamma>\"", "lemma set_bn_to_atom_domA:\n  \"set (bn as) = atom ` domA (asToHeap as)\"", "lemma heapToAssn_asToHeap[simp]:\n  \"heapToAssn (asToHeap as) = as\"", "lemma asToHeap_heapToAssn[simp]:\n  \"asToHeap (heapToAssn as) = as\"", "lemma heapToAssn_inject[simp]:\n  \"heapToAssn x = heapToAssn y \\<longleftrightarrow> x = y\"", "lemma supp_heapToAssn: \"supp (heapToAssn \\<Gamma>) = supp \\<Gamma>\"", "lemma supp_asToHeap: \"supp (asToHeap as) = supp as\"", "lemma fv_asToHeap: \"fv (asToHeap \\<Gamma>) = fv \\<Gamma>\"", "lemma fv_heapToAssn: \"fv (heapToAssn \\<Gamma>) = fv \\<Gamma>\"", "lemma [simp]: \"size (heapToAssn \\<Gamma>) = size_list (\\<lambda> (v,e) . size e) \\<Gamma>\"", "lemma Lam_eq_same_var[simp]: \"Lam [y]. e = Lam [y]. e' \\<longleftrightarrow>  e = e'\"", "lemma size_Let[simp]: \"size (Let \\<Gamma> e) = size_list (\\<lambda>p. size (snd p)) \\<Gamma> + size e + Suc 0\"", "lemma Let_distinct[simp]:\n  \"Var v \\<noteq> Let \\<Gamma> e\"\n  \"Let \\<Gamma> e \\<noteq> Var v\"\n  \"App e v \\<noteq> Let \\<Gamma> e'\"\n  \"Lam [v]. e' \\<noteq> Let \\<Gamma> e\"\n  \"Let \\<Gamma> e \\<noteq> Lam [v]. e'\"\n  \"Let \\<Gamma> e' \\<noteq> App e v\"\n  \"Bool b \\<noteq> Let \\<Gamma> e\"\n  \"Let \\<Gamma> e \\<noteq> Bool b\"\n  \"(scrut ? e1 : e2) \\<noteq> Let \\<Gamma> e\"\n  \"Let \\<Gamma> e \\<noteq> (scrut ? e1 : e2)\"", "lemma Let_perm_simps[simp,eqvt]:\n  \"p \\<bullet> Let \\<Gamma> e = Let (p \\<bullet> \\<Gamma>) (p \\<bullet> e)\"", "lemma Let_supp:\n  \"supp (Let \\<Gamma> e) = (supp e \\<union> supp \\<Gamma>) - atom ` (domA \\<Gamma>)\"", "lemma Let_fresh[simp]:\n  \"a \\<sharp> Let \\<Gamma> e = (a \\<sharp> e \\<and> a \\<sharp> \\<Gamma> \\<or> a \\<in> atom ` domA \\<Gamma>)\"", "lemma Abs_eq_cong:\n  assumes \"\\<And> p. (p \\<bullet> x = x') \\<longleftrightarrow> (p \\<bullet> y = y')\"\n  assumes \"supp y = supp x\"\n  assumes \"supp y' = supp x'\"\n  shows \"([a]lst. x = [a']lst. x') \\<longleftrightarrow> ([a]lst. y = [a']lst. y')\"", "lemma Let_eq_iff[simp]:\n  \"(Let \\<Gamma> e = Let \\<Gamma>' e') = ([map (\\<lambda>x. atom (fst x)) \\<Gamma> ]lst. (e, \\<Gamma>) = [map (\\<lambda>x. atom (fst x)) \\<Gamma>']lst. (e',\\<Gamma>'))\"", "lemma exp_strong_exhaust:\n  fixes c :: \"'a :: fs\"\n  assumes \"\\<And>var. y = Var var \\<Longrightarrow> P\"\n  assumes \"\\<And>exp var. y = App exp var \\<Longrightarrow> P\"\n  assumes \"\\<And>\\<Gamma> exp. atom ` domA \\<Gamma> \\<sharp>* c \\<Longrightarrow> y = Let \\<Gamma> exp \\<Longrightarrow> P\"\n  assumes \"\\<And>var exp. {atom var} \\<sharp>* c \\<Longrightarrow> y = Lam [var]. exp \\<Longrightarrow> P\"\n  assumes \"\\<And> b. (y = Bool b) \\<Longrightarrow> P\"\n  assumes \"\\<And> scrut e1 e2. y = (scrut ? e1 : e2) \\<Longrightarrow> P\"\n  shows P", "lemma exp_heap_induct[case_names Var App Let Lam Bool IfThenElse Nil Cons]:\n  assumes \"\\<And>b var. P1 (Var var)\"\n  assumes \"\\<And>exp var. P1 exp \\<Longrightarrow> P1 (App exp var)\"\n  assumes \"\\<And>\\<Gamma> exp. P2 \\<Gamma> \\<Longrightarrow> P1 exp \\<Longrightarrow> P1 (Let \\<Gamma> exp)\"\n  assumes \"\\<And>var exp. P1 exp \\<Longrightarrow> P1 (Lam [var]. exp)\"\n  assumes \"\\<And> b. P1 (Bool b)\"\n  assumes \"\\<And> scrut e1 e2. P1 scrut \\<Longrightarrow> P1 e1 \\<Longrightarrow> P1 e2 \\<Longrightarrow> P1 (scrut ? e1 : e2)\"\n  assumes \"P2 []\"\n  assumes \"\\<And>var exp \\<Gamma>. P1 exp \\<Longrightarrow> P2 \\<Gamma> \\<Longrightarrow> P2 ((var, exp)#\\<Gamma>)\"\n  shows \"P1 e\" and \"P2 \\<Gamma>\"", "lemma exp_heap_strong_induct[case_names Var App Let Lam Bool IfThenElse Nil Cons]:\n  assumes \"\\<And>var c. P1 c (Var var)\"\n  assumes \"\\<And>exp var c. (\\<And>c. P1 c exp) \\<Longrightarrow> P1 c (App exp var)\"\n  assumes \"\\<And>\\<Gamma> exp c. atom ` domA \\<Gamma> \\<sharp>* c \\<Longrightarrow> (\\<And>c. P2 c \\<Gamma>) \\<Longrightarrow> (\\<And>c. P1 c exp) \\<Longrightarrow> P1 c (Let \\<Gamma> exp)\"\n  assumes \"\\<And>var exp c. {atom var} \\<sharp>* c \\<Longrightarrow> (\\<And>c. P1 c exp) \\<Longrightarrow> P1 c (Lam [var]. exp)\"\n  assumes \"\\<And> b c. P1 c (Bool b)\"\n  assumes \"\\<And> scrut e1 e2 c. (\\<And> c. P1 c scrut) \\<Longrightarrow> (\\<And> c. P1 c e1) \\<Longrightarrow> (\\<And> c. P1 c e2) \\<Longrightarrow> P1 c (scrut ? e1 : e2)\"\n  assumes \"\\<And>c. P2 c []\"\n  assumes \"\\<And>var exp \\<Gamma> c. (\\<And>c. P1 c exp) \\<Longrightarrow> (\\<And>c. P2 c \\<Gamma>) \\<Longrightarrow> P2 c ((var,exp)#\\<Gamma>)\"\n  fixes c :: \"'a :: fs\"\n  shows \"P1 c e\" and \"P2 c \\<Gamma>\"", "lemma exp_induct[case_names Var App Let Lam Bool IfThenElse]:\n  assumes \"\\<And>var. P (Var var)\"\n  assumes \"\\<And>exp var. P exp \\<Longrightarrow> P (App exp var)\"\n  assumes \"\\<And>\\<Gamma> exp. (\\<And> x. x \\<in> domA \\<Gamma> \\<Longrightarrow>  P (the (map_of \\<Gamma> x))) \\<Longrightarrow> P exp \\<Longrightarrow> P (Let \\<Gamma> exp)\"\n  assumes \"\\<And>var exp.  P exp \\<Longrightarrow> P (Lam [var]. exp)\"\n  assumes \"\\<And> b. P (Bool b)\"\n  assumes \"\\<And> scrut e1 e2. P scrut \\<Longrightarrow> P e1 \\<Longrightarrow> P e2 \\<Longrightarrow> P (scrut ? e1 : e2)\"\n  shows \"P exp\"", "lemma  exp_strong_induct_set[case_names Var App Let Lam Bool IfThenElse]:\n  assumes \"\\<And>var c. P c (Var var)\"\n  assumes \"\\<And>exp var c. (\\<And>c. P c exp) \\<Longrightarrow> P c (App exp var)\"\n  assumes \"\\<And>\\<Gamma> exp c.\n    atom ` domA \\<Gamma> \\<sharp>* c \\<Longrightarrow> (\\<And>c x e. (x,e) \\<in> set \\<Gamma> \\<Longrightarrow>  P c e) \\<Longrightarrow> (\\<And>c. P c exp) \\<Longrightarrow> P c (Let \\<Gamma> exp)\"\n  assumes \"\\<And>var exp c. {atom var} \\<sharp>* c \\<Longrightarrow> (\\<And>c. P c exp) \\<Longrightarrow> P c (Lam [var]. exp)\"\n  assumes \"\\<And>b c. P c (Bool b)\"\n  assumes \"\\<And>scrut e1 e2 c. (\\<And> c. P c scrut) \\<Longrightarrow> (\\<And> c. P c e1) \\<Longrightarrow> (\\<And> c. P c e2) \\<Longrightarrow> P c (scrut ? e1 : e2)\"\n  shows \"P (c::'a::fs) exp\"", "lemma  exp_strong_induct[case_names Var App Let Lam Bool IfThenElse]:\n  assumes \"\\<And>var c. P c (Var var)\"\n  assumes \"\\<And>exp var c. (\\<And>c. P c exp) \\<Longrightarrow> P c (App exp var)\"\n  assumes \"\\<And>\\<Gamma> exp c.\n    atom ` domA \\<Gamma> \\<sharp>* c \\<Longrightarrow> (\\<And>c x. x \\<in> domA \\<Gamma> \\<Longrightarrow>  P c (the (map_of \\<Gamma> x))) \\<Longrightarrow> (\\<And>c. P c exp) \\<Longrightarrow> P c (Let \\<Gamma> exp)\"\n  assumes \"\\<And>var exp c. {atom var} \\<sharp>* c \\<Longrightarrow> (\\<And>c. P c exp) \\<Longrightarrow> P c (Lam [var]. exp)\"\n  assumes \"\\<And>b c. P c (Bool b)\"\n  assumes \"\\<And> scrut e1 e2 c. (\\<And> c. P c scrut) \\<Longrightarrow> (\\<And> c. P c e1) \\<Longrightarrow> (\\<And> c. P c e2) \\<Longrightarrow> P c (scrut ? e1 : e2)\"\n  shows \"P (c::'a::fs) exp\"", "lemma alpha_test:\n  shows \"Lam [x]. (Var x) = Lam [y]. (Var y)\"", "lemma alpha_test2:\n  shows \"let x be (Var x) in (Var x) = let y be (Var y) in (Var y)\"", "lemma alpha_test3:\n  shows \"\n    Let [(x, Var y), (y, Var x)] (Var x)\n    =\n    Let [(y, Var x), (x, Var y)] (Var y)\" (is \"Let ?la ?lb = _\")", "lemma fv_supp_exp: \"supp e = atom ` (fv (e::exp) :: var set)\" and fv_supp_as: \"supp as = atom ` (fv (as::assn) :: var set)\"", "lemma fv_supp_heap: \"supp (\\<Gamma>::heap) = atom ` (fv \\<Gamma> :: var set)\"", "lemma fv_Lam[simp]: \"fv (Lam [x]. e) = fv e - {x}\"", "lemma fv_Var[simp]: \"fv (Var x) = {x}\"", "lemma fv_App[simp]: \"fv (App e x) = insert x (fv e)\"", "lemma fv_Let[simp]: \"fv (Let \\<Gamma> e) = (fv \\<Gamma> \\<union> fv e) - domA \\<Gamma>\"", "lemma fv_Bool[simp]: \"fv (Bool b) = {}\"", "lemma fv_IfThenElse[simp]: \"fv (scrut ? e1 : e2)  = fv scrut \\<union> fv e1 \\<union> fv e2\"", "lemma fv_delete_heap:\n  assumes \"map_of \\<Gamma> x = Some e\"\n  shows \"fv (delete x \\<Gamma>, e) \\<union> {x} \\<subseteq> (fv (\\<Gamma>, Var x) :: var set)\"", "lemma eqvt_lam_case:\n  assumes \"Lam [x]. e = Lam [x']. e'\"\n  assumes \"\\<And> \\<pi> . supp (-\\<pi>) \\<sharp>* (fv (Lam [x]. e) :: var set) \\<Longrightarrow>\n                 supp \\<pi> \\<sharp>* (Lam [x]. e) \\<Longrightarrow>\n        F (\\<pi> \\<bullet> e) (\\<pi> \\<bullet> x) (Lam [x]. e) = F e x (Lam [x]. e)\"\n  shows \"F e x (Lam [x]. e) = F e' x' (Lam [x']. e')\"", "lemma eqvt_let_case:\n  assumes \"Let as body = Let as' body'\"\n  assumes \"\\<And> \\<pi> .\n    supp (-\\<pi>) \\<sharp>* (fv (Let as body) :: var set) \\<Longrightarrow>\n    supp \\<pi> \\<sharp>* Let as body \\<Longrightarrow>\n    F (\\<pi> \\<bullet> as) (\\<pi> \\<bullet> body) (Let as body) = F as body (Let as body)\"\n  shows \"F as body (Let as body) = F as' body' (Let as' body')\"", "lemma SmartLet_eqvt[eqvt]: \"\\<pi> \\<bullet> (SmartLet \\<Gamma> e) = SmartLet (\\<pi> \\<bullet> \\<Gamma>) (\\<pi> \\<bullet> e)\"", "lemma SmartLet_supp:\n  \"supp (SmartLet \\<Gamma> e) = (supp e \\<union> supp \\<Gamma>) - atom ` (domA \\<Gamma>)\"", "lemma fv_SmartLet[simp]: \"fv (SmartLet \\<Gamma> e) = (fv \\<Gamma> \\<union> fv e) - domA \\<Gamma>\"", "lemma isLam_Lam: \"isLam (Lam [x]. e)\"", "lemma isLam_obtain_fresh:\n  assumes \"isLam z\"\n  obtains y e'\n  where \"z = (Lam [y]. e')\" and \"atom y \\<sharp> (c::'a::fs)\"", "lemma isVal_Lam: \"isVal (Lam [x]. e)\"", "lemma isVal_Bool: \"isVal (Bool b)\"", "lemma thunks_Nil[simp]: \"thunks [] = {}\"", "lemma thunks_domA: \"thunks \\<Gamma> \\<subseteq> domA \\<Gamma>\"", "lemma thunks_Cons: \"thunks ((x,e)#\\<Gamma>) = (if isVal e then thunks \\<Gamma> - {x} else insert x (thunks \\<Gamma>))\"", "lemma thunks_append[simp]: \"thunks (\\<Delta>@\\<Gamma>) = thunks \\<Delta> \\<union> (thunks \\<Gamma> - domA \\<Delta>)\"", "lemma thunks_delete[simp]: \"thunks (delete x \\<Gamma>) = thunks \\<Gamma> - {x}\"", "lemma thunksI[intro]: \"map_of \\<Gamma> x = Some e \\<Longrightarrow> \\<not> isVal e \\<Longrightarrow> x \\<in> thunks \\<Gamma>\"", "lemma thunksE[intro]: \"x \\<in> thunks \\<Gamma> \\<Longrightarrow> map_of \\<Gamma> x = Some e \\<Longrightarrow> \\<not> isVal e\"", "lemma thunks_cong: \"map_of \\<Gamma> = map_of \\<Delta> \\<Longrightarrow> thunks \\<Gamma> = thunks \\<Delta>\"", "lemma thunks_eqvt[eqvt]:\n  \"\\<pi> \\<bullet> thunks \\<Gamma> = thunks (\\<pi> \\<bullet> \\<Gamma>)\"", "lemma nonrecE:\n  assumes \"nonrec \\<Gamma>\"\n  obtains x e where \"\\<Gamma> = [(x,e)]\" and \"x \\<notin> fv e\"", "lemma nonrec_eqvt[eqvt]:\n  \"nonrec \\<Gamma> \\<Longrightarrow> nonrec (\\<pi> \\<bullet> \\<Gamma>)\"", "lemma exp_induct_rec[case_names Var App Let Let_nonrec Lam Bool IfThenElse]:\n  assumes \"\\<And>var. P (Var var)\"\n  assumes \"\\<And>exp var. P exp \\<Longrightarrow> P (App exp var)\"\n  assumes \"\\<And>\\<Gamma> exp. \\<not> nonrec \\<Gamma> \\<Longrightarrow> (\\<And> x. x \\<in> domA \\<Gamma> \\<Longrightarrow>  P (the (map_of \\<Gamma> x))) \\<Longrightarrow> P exp \\<Longrightarrow> P (Let \\<Gamma> exp)\"\n  assumes \"\\<And>x e exp. x \\<notin> fv e \\<Longrightarrow> P e \\<Longrightarrow> P exp \\<Longrightarrow> P (let x be e in exp)\"\n  assumes \"\\<And>var exp.  P exp \\<Longrightarrow> P (Lam [var]. exp)\"\n  assumes \"\\<And>b. P (Bool b)\"\n  assumes \"\\<And> scrut e1 e2. P scrut \\<Longrightarrow> P e1 \\<Longrightarrow> P e2 \\<Longrightarrow> P (scrut ? e1 : e2)\"\n  shows \"P exp\"", "lemma  exp_strong_induct_rec[case_names Var App Let Let_nonrec Lam Bool IfThenElse]:\n  assumes \"\\<And>var c. P c (Var var)\"\n  assumes \"\\<And>exp var c. (\\<And>c. P c exp) \\<Longrightarrow> P c (App exp var)\"\n  assumes \"\\<And>\\<Gamma> exp c.\n    atom ` domA \\<Gamma> \\<sharp>* c \\<Longrightarrow> \\<not> nonrec \\<Gamma> \\<Longrightarrow> (\\<And>c x. x \\<in> domA \\<Gamma> \\<Longrightarrow>  P c (the (map_of \\<Gamma> x))) \\<Longrightarrow> (\\<And>c. P c exp) \\<Longrightarrow> P c (Let \\<Gamma> exp)\"\n  assumes \"\\<And>x e exp c. {atom x} \\<sharp>* c \\<Longrightarrow> x \\<notin> fv e \\<Longrightarrow> (\\<And> c. P c e) \\<Longrightarrow> (\\<And> c. P c exp) \\<Longrightarrow> P c (let x be e in exp)\"\n  assumes \"\\<And>var exp c. {atom var} \\<sharp>* c \\<Longrightarrow> (\\<And>c. P c exp) \\<Longrightarrow> P c (Lam [var]. exp)\"\n  assumes \"\\<And>b c. P c (Bool b)\"\n  assumes \"\\<And> scrut e1 e2 c. (\\<And> c. P c scrut) \\<Longrightarrow> (\\<And> c. P c e1) \\<Longrightarrow> (\\<And> c. P c e2) \\<Longrightarrow> P c (scrut ? e1 : e2)\"\n  shows \"P (c::'a::fs) exp\"", "lemma  exp_strong_induct_rec_set[case_names Var App Let Let_nonrec Lam Bool IfThenElse]:\n  assumes \"\\<And>var c. P c (Var var)\"\n  assumes \"\\<And>exp var c. (\\<And>c. P c exp) \\<Longrightarrow> P c (App exp var)\"\n  assumes \"\\<And>\\<Gamma> exp c.\n    atom ` domA \\<Gamma> \\<sharp>* c \\<Longrightarrow> \\<not> nonrec \\<Gamma> \\<Longrightarrow> (\\<And>c x e. (x,e) \\<in> set \\<Gamma> \\<Longrightarrow>  P c e) \\<Longrightarrow> (\\<And>c. P c exp) \\<Longrightarrow> P c (Let \\<Gamma> exp)\"\n  assumes \"\\<And>x e exp c. {atom x} \\<sharp>* c \\<Longrightarrow> x \\<notin> fv e \\<Longrightarrow> (\\<And> c. P c e) \\<Longrightarrow> (\\<And> c. P c exp) \\<Longrightarrow> P c (let x be e in exp)\"\n  assumes \"\\<And>var exp c. {atom var} \\<sharp>* c \\<Longrightarrow> (\\<And>c. P c exp) \\<Longrightarrow> P c (Lam [var]. exp)\"\n  assumes \"\\<And>b c. P c (Bool b)\"\n  assumes \"\\<And> scrut e1 e2 c. (\\<And> c. P c scrut) \\<Longrightarrow> (\\<And> c. P c e1) \\<Longrightarrow> (\\<And> c. P c e2) \\<Longrightarrow> P c (scrut ? e1 : e2)\"\n  shows \"P (c::'a::fs) exp\"", "lemma change_Lam_Variable:\n  assumes \"y' \\<noteq> y \\<Longrightarrow> atom y' \\<sharp> (e,  y)\"\n  shows   \"Lam [y]. e =  Lam [y']. ((y \\<leftrightarrow> y') \\<bullet> e)\""], "translations": [["", "lemma exp_assn_size_eqvt[eqvt]: \"p \\<bullet> (size :: exp \\<Rightarrow> nat) = size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> size = size", "by (metis exp_assn.size_eqvt(1) fun_eqvtI permute_pure)"], ["", "subsubsection \\<open>Rewriting in terms of heaps\\<close>"], ["", "text \\<open>\nWe now work towards using @{type heap} instead of @{type assn}. All this\ncould be skipped if Nominal supported nested recursion.\n\\<close>"], ["", "text \\<open>\nConversion from @{typ assn} to @{typ heap}.\n\\<close>"], ["", "nominal_function asToHeap :: \"assn \\<Rightarrow> heap\" \n where ANilToHeap: \"asToHeap ANil = []\"\n | AConsToHeap: \"asToHeap (ACons v e as) = (v, e) # asToHeap as\""], ["proof (prove)\ngoal (6 subgoals):\n 1. eqvt asToHeap_graph_aux\n 2. \\<And>x y. asToHeap_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       \\<lbrakk>x = ANil \\<Longrightarrow> P;\n        \\<And>v e as. x = ACons v e as \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 4. ANil = ANil \\<Longrightarrow> [] = []\n 5. \\<And>v e as.\n       \\<lbrakk>eqvt_at asToHeap_sumC as; True; ANil = ACons v e as\\<rbrakk>\n       \\<Longrightarrow> [] = (v, e) # asToHeap_sumC as\n 6. \\<And>v e as va ea asa.\n       \\<lbrakk>eqvt_at asToHeap_sumC as; eqvt_at asToHeap_sumC asa; True;\n        True; ACons v e as = ACons va ea asa\\<rbrakk>\n       \\<Longrightarrow> (v, e) # asToHeap_sumC as =\n                         (va, ea) # asToHeap_sumC asa", "unfolding eqvt_def asToHeap_graph_aux_def"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<forall>p.\n       p \\<bullet> lfp (\\<lambda>p x1 x2.\n                           (\\<exists>asToHeap_aux.\n                               x1 = ANil \\<and> x2 = []) \\<or>\n                           (\\<exists>asToHeap_aux v e as.\n                               x1 = ACons v e as \\<and>\n                               x2 =\n                               (v, e) #\n                               ((\\<lambda>uu_. uu_) \\<circ> asToHeap_aux)\n                                as \\<and>\n                               p as\n                                (((\\<lambda>uu_. uu_) \\<circ> asToHeap_aux)\n                                  as))) =\n       lfp (\\<lambda>p x1 x2.\n               (\\<exists>asToHeap_aux. x1 = ANil \\<and> x2 = []) \\<or>\n               (\\<exists>asToHeap_aux v e as.\n                   x1 = ACons v e as \\<and>\n                   x2 =\n                   (v, e) #\n                   ((\\<lambda>uu_. uu_) \\<circ> asToHeap_aux) as \\<and>\n                   p as (((\\<lambda>uu_. uu_) \\<circ> asToHeap_aux) as)))\n 2. \\<And>x y. asToHeap_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       \\<lbrakk>x = ANil \\<Longrightarrow> P;\n        \\<And>v e as. x = ACons v e as \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 4. ANil = ANil \\<Longrightarrow> [] = []\n 5. \\<And>v e as.\n       \\<lbrakk>eqvt_at asToHeap_sumC as; True; ANil = ACons v e as\\<rbrakk>\n       \\<Longrightarrow> [] = (v, e) # asToHeap_sumC as\n 6. \\<And>v e as va ea asa.\n       \\<lbrakk>eqvt_at asToHeap_sumC as; eqvt_at asToHeap_sumC asa; True;\n        True; ACons v e as = ACons va ea asa\\<rbrakk>\n       \\<Longrightarrow> (v, e) # asToHeap_sumC as =\n                         (va, ea) # asToHeap_sumC asa", "apply rule"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>p.\n       p \\<bullet> lfp (\\<lambda>p x1 x2.\n                           (\\<exists>asToHeap_aux.\n                               x1 = ANil \\<and> x2 = []) \\<or>\n                           (\\<exists>asToHeap_aux v e as.\n                               x1 = ACons v e as \\<and>\n                               x2 =\n                               (v, e) #\n                               ((\\<lambda>uu_. uu_) \\<circ> asToHeap_aux)\n                                as \\<and>\n                               p as\n                                (((\\<lambda>uu_. uu_) \\<circ> asToHeap_aux)\n                                  as))) =\n       lfp (\\<lambda>p x1 x2.\n               (\\<exists>asToHeap_aux. x1 = ANil \\<and> x2 = []) \\<or>\n               (\\<exists>asToHeap_aux v e as.\n                   x1 = ACons v e as \\<and>\n                   x2 =\n                   (v, e) #\n                   ((\\<lambda>uu_. uu_) \\<circ> asToHeap_aux) as \\<and>\n                   p as (((\\<lambda>uu_. uu_) \\<circ> asToHeap_aux) as)))\n 2. \\<And>x y. asToHeap_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       \\<lbrakk>x = ANil \\<Longrightarrow> P;\n        \\<And>v e as. x = ACons v e as \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 4. ANil = ANil \\<Longrightarrow> [] = []\n 5. \\<And>v e as.\n       \\<lbrakk>eqvt_at asToHeap_sumC as; True; ANil = ACons v e as\\<rbrakk>\n       \\<Longrightarrow> [] = (v, e) # asToHeap_sumC as\n 6. \\<And>v e as va ea asa.\n       \\<lbrakk>eqvt_at asToHeap_sumC as; eqvt_at asToHeap_sumC asa; True;\n        True; ACons v e as = ACons va ea asa\\<rbrakk>\n       \\<Longrightarrow> (v, e) # asToHeap_sumC as =\n                         (va, ea) # asToHeap_sumC asa", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y. asToHeap_graph x y \\<Longrightarrow> True\n 2. \\<And>P x.\n       \\<lbrakk>x = ANil \\<Longrightarrow> P;\n        \\<And>v e as. x = ACons v e as \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 3. ANil = ANil \\<Longrightarrow> [] = []\n 4. \\<And>v e as.\n       \\<lbrakk>eqvt_at asToHeap_sumC as; True; ANil = ACons v e as\\<rbrakk>\n       \\<Longrightarrow> [] = (v, e) # asToHeap_sumC as\n 5. \\<And>v e as va ea asa.\n       \\<lbrakk>eqvt_at asToHeap_sumC as; eqvt_at asToHeap_sumC asa; True;\n        True; ACons v e as = ACons va ea asa\\<rbrakk>\n       \\<Longrightarrow> (v, e) # asToHeap_sumC as =\n                         (va, ea) # asToHeap_sumC asa", "apply rule"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>x = ANil \\<Longrightarrow> P;\n        \\<And>v e as. x = ACons v e as \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. ANil = ANil \\<Longrightarrow> [] = []\n 3. \\<And>v e as.\n       \\<lbrakk>eqvt_at asToHeap_sumC as; True; ANil = ACons v e as\\<rbrakk>\n       \\<Longrightarrow> [] = (v, e) # asToHeap_sumC as\n 4. \\<And>v e as va ea asa.\n       \\<lbrakk>eqvt_at asToHeap_sumC as; eqvt_at asToHeap_sumC asa; True;\n        True; ACons v e as = ACons va ea asa\\<rbrakk>\n       \\<Longrightarrow> (v, e) # asToHeap_sumC as =\n                         (va, ea) # asToHeap_sumC asa", "apply(case_tac x rule: exp_assn.exhaust(2))"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>x = ANil \\<Longrightarrow> P;\n        \\<And>v e as. x = ACons v e as \\<Longrightarrow> P;\n        x = ANil\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>P x x21 x22 x23.\n       \\<lbrakk>x = ANil \\<Longrightarrow> P;\n        \\<And>v e as. x = ACons v e as \\<Longrightarrow> P;\n        x = ACons x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> P\n 3. ANil = ANil \\<Longrightarrow> [] = []\n 4. \\<And>v e as.\n       \\<lbrakk>eqvt_at asToHeap_sumC as; True; ANil = ACons v e as\\<rbrakk>\n       \\<Longrightarrow> [] = (v, e) # asToHeap_sumC as\n 5. \\<And>v e as va ea asa.\n       \\<lbrakk>eqvt_at asToHeap_sumC as; eqvt_at asToHeap_sumC asa; True;\n        True; ACons v e as = ACons va ea asa\\<rbrakk>\n       \\<Longrightarrow> (v, e) # asToHeap_sumC as =\n                         (va, ea) # asToHeap_sumC asa", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "nominal_termination(eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. All asToHeap_dom", "by lexicographic_order"], ["", "lemma asToHeap_eqvt: \"eqvt asToHeap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eqvt asToHeap", "unfolding eqvt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p. p \\<bullet> asToHeap = asToHeap", "by (auto simp add: permute_fun_def asToHeap.eqvt)"], ["", "text \\<open>The other direction.\\<close>"], ["", "fun heapToAssn :: \"heap \\<Rightarrow> assn\"\n  where \"heapToAssn [] = ANil\" \n  | \"heapToAssn ((v,e)#\\<Gamma>) = ACons v e (heapToAssn \\<Gamma>)\""], ["", "declare heapToAssn.simps[simp del]"], ["", "lemma heapToAssn_eqvt[simp,eqvt]: \"p \\<bullet> heapToAssn \\<Gamma> =  heapToAssn (p \\<bullet> \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> heapToAssn \\<Gamma> = heapToAssn (p \\<bullet> \\<Gamma>)", "by (induct \\<Gamma> rule: heapToAssn.induct)\n     (auto simp add: heapToAssn.simps)"], ["", "lemma bn_heapToAssn: \"bn (heapToAssn \\<Gamma>) = map (\\<lambda>x. atom (fst x)) \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bn (heapToAssn \\<Gamma>) = map (\\<lambda>x. atom (fst x)) \\<Gamma>", "by (induct rule: heapToAssn.induct)\n     (auto simp add: heapToAssn.simps exp_assn.bn_defs)"], ["", "lemma set_bn_to_atom_domA:\n  \"set (bn as) = atom ` domA (asToHeap as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (bn as) = atom ` domA (asToHeap as)", "by (induct as rule: asToHeap.induct)\n      (auto simp add: exp_assn.bn_defs)"], ["", "text \\<open>\nThey are inverse to each other.\n\\<close>"], ["", "lemma heapToAssn_asToHeap[simp]:\n  \"heapToAssn (asToHeap as) = as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heapToAssn (asToHeap as) = as", "by (induct  rule: exp_assn.inducts(2)[of \"\\<lambda> _ . True\"])\n     (auto simp add: heapToAssn.simps)"], ["", "lemma asToHeap_heapToAssn[simp]:\n  \"asToHeap (heapToAssn as) = as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. asToHeap (heapToAssn as) = as", "by (induct rule: heapToAssn.induct)\n     (auto simp add: heapToAssn.simps)"], ["", "lemma heapToAssn_inject[simp]:\n  \"heapToAssn x = heapToAssn y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (heapToAssn x = heapToAssn y) = (x = y)", "by (metis asToHeap_heapToAssn)"], ["", "text \\<open>\nThey are transparent to various notions from the Nominal package.\n\\<close>"], ["", "lemma supp_heapToAssn: \"supp (heapToAssn \\<Gamma>) = supp \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (heapToAssn \\<Gamma>) = supp \\<Gamma>", "by (induct rule: heapToAssn.induct)\n     (simp_all add: heapToAssn.simps  exp_assn.supp supp_Nil supp_Cons supp_Pair sup_assoc)"], ["", "lemma supp_asToHeap: \"supp (asToHeap as) = supp as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (asToHeap as) = supp as", "by (induct as rule: asToHeap.induct)\n      (simp_all add:  exp_assn.supp supp_Nil supp_Cons supp_Pair sup_assoc)"], ["", "lemma fv_asToHeap: \"fv (asToHeap \\<Gamma>) = fv \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (asToHeap \\<Gamma>) = fv \\<Gamma>", "unfolding fv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {v. atom v \\<in> supp (asToHeap \\<Gamma>)} =\n    {v. atom v \\<in> supp \\<Gamma>}", "by (auto simp add: supp_asToHeap)"], ["", "lemma fv_heapToAssn: \"fv (heapToAssn \\<Gamma>) = fv \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (heapToAssn \\<Gamma>) = fv \\<Gamma>", "unfolding fv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {v. atom v \\<in> supp (heapToAssn \\<Gamma>)} =\n    {v. atom v \\<in> supp \\<Gamma>}", "by (auto simp add: supp_heapToAssn)"], ["", "lemma [simp]: \"size (heapToAssn \\<Gamma>) = size_list (\\<lambda> (v,e) . size e) \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (heapToAssn \\<Gamma>) =\n    size_list (\\<lambda>(v, e). size e) \\<Gamma>", "by (induct rule: heapToAssn.induct)\n     (simp_all add: heapToAssn.simps)"], ["", "lemma Lam_eq_same_var[simp]: \"Lam [y]. e = Lam [y]. e' \\<longleftrightarrow>  e = e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Lam [y]. e = Lam [y]. e') = (e = e')", "by auto (metis fresh_PairD(2) obtain_fresh)"], ["", "text \\<open>Now we define the Let constructor in the form that we actually want.\\<close>"], ["", "hide_const HOL.Let"], ["", "definition Let :: \"heap \\<Rightarrow> exp \\<Rightarrow> exp\"\n  where \"Let \\<Gamma> e = LetA (heapToAssn \\<Gamma>) e\""], ["", "notation (latex output) Let (\"\\<^latex>\\<open>\\\\textrm{\\\\textsf{let}}\\<close> _ \\<^latex>\\<open>\\\\textrm{\\\\textsf{in}}\\<close> _\")"], ["", "abbreviation\n  LetBe :: \"var\\<Rightarrow>exp\\<Rightarrow>exp\\<Rightarrow>exp\" (\"let _ be _ in _ \" [100,100,100] 100)\nwhere\n  \"let x be t1 in t2 \\<equiv> Let [(x,t1)] t2\""], ["", "text \\<open>\nWe rewrite all (relevant) lemmas about @{term LetA} in terms of @{term Let}.\n\\<close>"], ["", "lemma size_Let[simp]: \"size (Let \\<Gamma> e) = size_list (\\<lambda>p. size (snd p)) \\<Gamma> + size e + Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (Let \\<Gamma> e) =\n    size_list (\\<lambda>p. size (snd p)) \\<Gamma> + size e + Suc 0", "unfolding Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. size (LetA (heapToAssn \\<Gamma>) e) =\n    size_list (\\<lambda>p. size (snd p)) \\<Gamma> + size e + Suc 0", "by (auto simp add: split_beta')"], ["", "lemma Let_distinct[simp]:\n  \"Var v \\<noteq> Let \\<Gamma> e\"\n  \"Let \\<Gamma> e \\<noteq> Var v\"\n  \"App e v \\<noteq> Let \\<Gamma> e'\"\n  \"Lam [v]. e' \\<noteq> Let \\<Gamma> e\"\n  \"Let \\<Gamma> e \\<noteq> Lam [v]. e'\"\n  \"Let \\<Gamma> e' \\<noteq> App e v\"\n  \"Bool b \\<noteq> Let \\<Gamma> e\"\n  \"Let \\<Gamma> e \\<noteq> Bool b\"\n  \"(scrut ? e1 : e2) \\<noteq> Let \\<Gamma> e\"\n  \"Let \\<Gamma> e \\<noteq> (scrut ? e1 : e2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Var v \\<noteq> Let \\<Gamma> e &&& Let \\<Gamma> e \\<noteq> Var v) &&&\n     App e v \\<noteq> Let \\<Gamma> e' &&&\n     Lam [v]. e' \\<noteq> Let \\<Gamma> e &&&\n     Let \\<Gamma> e \\<noteq> Lam [v]. e') &&&\n    (Let \\<Gamma> e' \\<noteq> App e v &&&\n     Bool b \\<noteq> Let \\<Gamma> e) &&&\n    Let \\<Gamma> e \\<noteq> Bool b &&&\n    (scrut ? e1 : e2) \\<noteq> Let \\<Gamma> e &&&\n    Let \\<Gamma> e \\<noteq> (scrut ? e1 : e2)", "unfolding Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Var v \\<noteq> LetA (heapToAssn \\<Gamma>) e &&&\n      LetA (heapToAssn \\<Gamma>) e \\<noteq> Var v) &&&\n     App e v \\<noteq> LetA (heapToAssn \\<Gamma>) e' &&&\n     Lam [v]. e' \\<noteq> LetA (heapToAssn \\<Gamma>) e &&&\n     LetA (heapToAssn \\<Gamma>) e \\<noteq> Lam [v]. e') &&&\n    (LetA (heapToAssn \\<Gamma>) e' \\<noteq> App e v &&&\n     Bool b \\<noteq> LetA (heapToAssn \\<Gamma>) e) &&&\n    LetA (heapToAssn \\<Gamma>) e \\<noteq> Bool b &&&\n    (scrut ? e1 : e2) \\<noteq> LetA (heapToAssn \\<Gamma>) e &&&\n    LetA (heapToAssn \\<Gamma>) e \\<noteq> (scrut ? e1 : e2)", "by simp_all"], ["", "lemma Let_perm_simps[simp,eqvt]:\n  \"p \\<bullet> Let \\<Gamma> e = Let (p \\<bullet> \\<Gamma>) (p \\<bullet> e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> Let \\<Gamma> e = Let (p \\<bullet> \\<Gamma>) (p \\<bullet> e)", "unfolding Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bullet> LetA (heapToAssn \\<Gamma>) e =\n    LetA (heapToAssn (p \\<bullet> \\<Gamma>)) (p \\<bullet> e)", "by simp"], ["", "lemma Let_supp:\n  \"supp (Let \\<Gamma> e) = (supp e \\<union> supp \\<Gamma>) - atom ` (domA \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (Let \\<Gamma> e) =\n    supp e \\<union> supp \\<Gamma> - atom ` domA \\<Gamma>", "unfolding Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (LetA (heapToAssn \\<Gamma>) e) =\n    supp e \\<union> supp \\<Gamma> - atom ` domA \\<Gamma>", "by (simp add: exp_assn.supp supp_heapToAssn bn_heapToAssn domA_def image_image)"], ["", "lemma Let_fresh[simp]:\n  \"a \\<sharp> Let \\<Gamma> e = (a \\<sharp> e \\<and> a \\<sharp> \\<Gamma> \\<or> a \\<in> atom ` domA \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sharp> Let \\<Gamma> e =\n    (a \\<sharp> e \\<and> a \\<sharp> \\<Gamma> \\<or>\n     a \\<in> atom ` domA \\<Gamma>)", "unfolding fresh_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<notin> supp (Let \\<Gamma> e)) =\n    (a \\<notin> supp e \\<and> a \\<notin> supp \\<Gamma> \\<or>\n     a \\<in> atom ` domA \\<Gamma>)", "by (auto simp add: Let_supp)"], ["", "lemma Abs_eq_cong:\n  assumes \"\\<And> p. (p \\<bullet> x = x') \\<longleftrightarrow> (p \\<bullet> y = y')\"\n  assumes \"supp y = supp x\"\n  assumes \"supp y' = supp x'\"\n  shows \"([a]lst. x = [a']lst. x') \\<longleftrightarrow> ([a]lst. y = [a']lst. y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([a]lst. x = [a']lst. x') = ([a]lst. y = [a']lst. y')", "by (simp add: Abs_eq_iff alpha_lst assms)"], ["", "lemma Let_eq_iff[simp]:\n  \"(Let \\<Gamma> e = Let \\<Gamma>' e') = ([map (\\<lambda>x. atom (fst x)) \\<Gamma> ]lst. (e, \\<Gamma>) = [map (\\<lambda>x. atom (fst x)) \\<Gamma>']lst. (e',\\<Gamma>'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Let \\<Gamma> e = Let \\<Gamma>' e') =\n    ([map (\\<lambda>x. atom (fst x)) \\<Gamma>]lst. (e, \\<Gamma>) =\n     [map (\\<lambda>x. atom (fst x)) \\<Gamma>']lst. (e', \\<Gamma>'))", "unfolding Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LetA (heapToAssn \\<Gamma>) e = LetA (heapToAssn \\<Gamma>') e') =\n    ([map (\\<lambda>x. atom (fst x)) \\<Gamma>]lst. (e, \\<Gamma>) =\n     [map (\\<lambda>x. atom (fst x)) \\<Gamma>']lst. (e', \\<Gamma>'))", "apply (simp add: bn_heapToAssn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([map (\\<lambda>x. atom (fst x))\n       \\<Gamma>]lst. (e, heapToAssn \\<Gamma>) =\n     [map (\\<lambda>x. atom (fst x))\n       \\<Gamma>']lst. (e', heapToAssn \\<Gamma>')) =\n    ([map (\\<lambda>x. atom (fst x)) \\<Gamma>]lst. (e, \\<Gamma>) =\n     [map (\\<lambda>x. atom (fst x)) \\<Gamma>']lst. (e', \\<Gamma>'))", "apply (rule Abs_eq_cong)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>p.\n       (p \\<bullet> (e, heapToAssn \\<Gamma>) = (e', heapToAssn \\<Gamma>')) =\n       (p \\<bullet> (e, \\<Gamma>) = (e', \\<Gamma>'))\n 2. supp (e, \\<Gamma>) = supp (e, heapToAssn \\<Gamma>)\n 3. supp (e', \\<Gamma>') = supp (e', heapToAssn \\<Gamma>')", "apply (simp_all add: supp_Pair supp_heapToAssn)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma exp_strong_exhaust:\n  fixes c :: \"'a :: fs\"\n  assumes \"\\<And>var. y = Var var \\<Longrightarrow> P\"\n  assumes \"\\<And>exp var. y = App exp var \\<Longrightarrow> P\"\n  assumes \"\\<And>\\<Gamma> exp. atom ` domA \\<Gamma> \\<sharp>* c \\<Longrightarrow> y = Let \\<Gamma> exp \\<Longrightarrow> P\"\n  assumes \"\\<And>var exp. {atom var} \\<sharp>* c \\<Longrightarrow> y = Lam [var]. exp \\<Longrightarrow> P\"\n  assumes \"\\<And> b. (y = Bool b) \\<Longrightarrow> P\"\n  assumes \"\\<And> scrut e1 e2. y = (scrut ? e1 : e2) \\<Longrightarrow> P\"\n  shows P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "apply (rule  exp_assn.strong_exhaust(1)[where y = y and c = c])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x1. y = Var x1 \\<Longrightarrow> P\n 2. \\<And>x21 x22. y = App x21 x22 \\<Longrightarrow> P\n 3. \\<And>x31 x32.\n       \\<lbrakk>set (bn x31) \\<sharp>* c; y = LetA x31 x32\\<rbrakk>\n       \\<Longrightarrow> P\n 4. \\<And>x41 x42.\n       \\<lbrakk>{atom x41} \\<sharp>* c; y = Lam [x41]. x42\\<rbrakk>\n       \\<Longrightarrow> P\n 5. \\<And>x5. y = Bool x5 \\<Longrightarrow> P\n 6. \\<And>x61 x62 x63. y = (x61 ? x62 : x63) \\<Longrightarrow> P", "apply (metis assms(1))"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x21 x22. y = App x21 x22 \\<Longrightarrow> P\n 2. \\<And>x31 x32.\n       \\<lbrakk>set (bn x31) \\<sharp>* c; y = LetA x31 x32\\<rbrakk>\n       \\<Longrightarrow> P\n 3. \\<And>x41 x42.\n       \\<lbrakk>{atom x41} \\<sharp>* c; y = Lam [x41]. x42\\<rbrakk>\n       \\<Longrightarrow> P\n 4. \\<And>x5. y = Bool x5 \\<Longrightarrow> P\n 5. \\<And>x61 x62 x63. y = (x61 ? x62 : x63) \\<Longrightarrow> P", "apply (metis assms(2))"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x31 x32.\n       \\<lbrakk>set (bn x31) \\<sharp>* c; y = LetA x31 x32\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>x41 x42.\n       \\<lbrakk>{atom x41} \\<sharp>* c; y = Lam [x41]. x42\\<rbrakk>\n       \\<Longrightarrow> P\n 3. \\<And>x5. y = Bool x5 \\<Longrightarrow> P\n 4. \\<And>x61 x62 x63. y = (x61 ? x62 : x63) \\<Longrightarrow> P", "apply (metis assms(3) set_bn_to_atom_domA Let_def heapToAssn_asToHeap)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x41 x42.\n       \\<lbrakk>{atom x41} \\<sharp>* c; y = Lam [x41]. x42\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>x5. y = Bool x5 \\<Longrightarrow> P\n 3. \\<And>x61 x62 x63. y = (x61 ? x62 : x63) \\<Longrightarrow> P", "apply (metis assms(4))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x5. y = Bool x5 \\<Longrightarrow> P\n 2. \\<And>x61 x62 x63. y = (x61 ? x62 : x63) \\<Longrightarrow> P", "apply (metis assms(5))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x61 x62 x63. y = (x61 ? x62 : x63) \\<Longrightarrow> P", "apply (metis assms(6))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\nAnd finally the induction rules with @{term Let}.\n\\<close>"], ["", "lemma exp_heap_induct[case_names Var App Let Lam Bool IfThenElse Nil Cons]:\n  assumes \"\\<And>b var. P1 (Var var)\"\n  assumes \"\\<And>exp var. P1 exp \\<Longrightarrow> P1 (App exp var)\"\n  assumes \"\\<And>\\<Gamma> exp. P2 \\<Gamma> \\<Longrightarrow> P1 exp \\<Longrightarrow> P1 (Let \\<Gamma> exp)\"\n  assumes \"\\<And>var exp. P1 exp \\<Longrightarrow> P1 (Lam [var]. exp)\"\n  assumes \"\\<And> b. P1 (Bool b)\"\n  assumes \"\\<And> scrut e1 e2. P1 scrut \\<Longrightarrow> P1 e1 \\<Longrightarrow> P1 e2 \\<Longrightarrow> P1 (scrut ? e1 : e2)\"\n  assumes \"P2 []\"\n  assumes \"\\<And>var exp \\<Gamma>. P1 exp \\<Longrightarrow> P2 \\<Gamma> \\<Longrightarrow> P2 ((var, exp)#\\<Gamma>)\"\n  shows \"P1 e\" and \"P2 \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P1 e &&& P2 \\<Gamma>", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. P1 e\n 2. P2 \\<Gamma>", "have \"P1 e\" and \"P2 (asToHeap (heapToAssn \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P1 e &&& P2 (asToHeap (heapToAssn \\<Gamma>))", "apply (induct rule: exp_assn.inducts[of P1 \"\\<lambda> assn. P2 (asToHeap assn)\"])"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x. P1 (Var x)\n 2. \\<And>x1 x2. P1 x1 \\<Longrightarrow> P1 (App x1 x2)\n 3. \\<And>x1 x2.\n       \\<lbrakk>P2 (asToHeap x1); P1 x2\\<rbrakk>\n       \\<Longrightarrow> P1 (LetA x1 x2)\n 4. \\<And>x1 x2. P1 x2 \\<Longrightarrow> P1 (Lam [x1]. x2)\n 5. \\<And>x. P1 (Bool x)\n 6. \\<And>x1 x2 x3.\n       \\<lbrakk>P1 x1; P1 x2; P1 x3\\<rbrakk>\n       \\<Longrightarrow> P1 (x1 ? x2 : x3)\n 7. P2 (asToHeap ANil)\n 8. \\<And>x1 x2 x3.\n       \\<lbrakk>P1 x2; P2 (asToHeap x3)\\<rbrakk>\n       \\<Longrightarrow> P2 (asToHeap (ACons x1 x2 x3))", "apply (metis assms(1))"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x1 x2. P1 x1 \\<Longrightarrow> P1 (App x1 x2)\n 2. \\<And>x1 x2.\n       \\<lbrakk>P2 (asToHeap x1); P1 x2\\<rbrakk>\n       \\<Longrightarrow> P1 (LetA x1 x2)\n 3. \\<And>x1 x2. P1 x2 \\<Longrightarrow> P1 (Lam [x1]. x2)\n 4. \\<And>x. P1 (Bool x)\n 5. \\<And>x1 x2 x3.\n       \\<lbrakk>P1 x1; P1 x2; P1 x3\\<rbrakk>\n       \\<Longrightarrow> P1 (x1 ? x2 : x3)\n 6. P2 (asToHeap ANil)\n 7. \\<And>x1 x2 x3.\n       \\<lbrakk>P1 x2; P2 (asToHeap x3)\\<rbrakk>\n       \\<Longrightarrow> P2 (asToHeap (ACons x1 x2 x3))", "apply (metis assms(2))"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>P2 (asToHeap x1); P1 x2\\<rbrakk>\n       \\<Longrightarrow> P1 (LetA x1 x2)\n 2. \\<And>x1 x2. P1 x2 \\<Longrightarrow> P1 (Lam [x1]. x2)\n 3. \\<And>x. P1 (Bool x)\n 4. \\<And>x1 x2 x3.\n       \\<lbrakk>P1 x1; P1 x2; P1 x3\\<rbrakk>\n       \\<Longrightarrow> P1 (x1 ? x2 : x3)\n 5. P2 (asToHeap ANil)\n 6. \\<And>x1 x2 x3.\n       \\<lbrakk>P1 x2; P2 (asToHeap x3)\\<rbrakk>\n       \\<Longrightarrow> P2 (asToHeap (ACons x1 x2 x3))", "apply (metis assms(3) Let_def heapToAssn_asToHeap )"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1 x2. P1 x2 \\<Longrightarrow> P1 (Lam [x1]. x2)\n 2. \\<And>x. P1 (Bool x)\n 3. \\<And>x1 x2 x3.\n       \\<lbrakk>P1 x1; P1 x2; P1 x3\\<rbrakk>\n       \\<Longrightarrow> P1 (x1 ? x2 : x3)\n 4. P2 (asToHeap ANil)\n 5. \\<And>x1 x2 x3.\n       \\<lbrakk>P1 x2; P2 (asToHeap x3)\\<rbrakk>\n       \\<Longrightarrow> P2 (asToHeap (ACons x1 x2 x3))", "apply (metis assms(4))"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x. P1 (Bool x)\n 2. \\<And>x1 x2 x3.\n       \\<lbrakk>P1 x1; P1 x2; P1 x3\\<rbrakk>\n       \\<Longrightarrow> P1 (x1 ? x2 : x3)\n 3. P2 (asToHeap ANil)\n 4. \\<And>x1 x2 x3.\n       \\<lbrakk>P1 x2; P2 (asToHeap x3)\\<rbrakk>\n       \\<Longrightarrow> P2 (asToHeap (ACons x1 x2 x3))", "apply (metis assms(5))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>P1 x1; P1 x2; P1 x3\\<rbrakk>\n       \\<Longrightarrow> P1 (x1 ? x2 : x3)\n 2. P2 (asToHeap ANil)\n 3. \\<And>x1 x2 x3.\n       \\<lbrakk>P1 x2; P2 (asToHeap x3)\\<rbrakk>\n       \\<Longrightarrow> P2 (asToHeap (ACons x1 x2 x3))", "apply (metis assms(6))"], ["proof (prove)\ngoal (2 subgoals):\n 1. P2 (asToHeap ANil)\n 2. \\<And>x1 x2 x3.\n       \\<lbrakk>P1 x2; P2 (asToHeap x3)\\<rbrakk>\n       \\<Longrightarrow> P2 (asToHeap (ACons x1 x2 x3))", "apply (metis assms(7) asToHeap.simps(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       \\<lbrakk>P1 x2; P2 (asToHeap x3)\\<rbrakk>\n       \\<Longrightarrow> P2 (asToHeap (ACons x1 x2 x3))", "apply (metis assms(8) asToHeap.simps(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  P1 e\n  P2 (asToHeap (heapToAssn \\<Gamma>))\n\ngoal (2 subgoals):\n 1. P1 e\n 2. P2 \\<Gamma>", "thus \"P1 e\" and \"P2 \\<Gamma>\""], ["proof (prove)\nusing this:\n  P1 e\n  P2 (asToHeap (heapToAssn \\<Gamma>))\n\ngoal (1 subgoal):\n 1. P1 e &&& P2 \\<Gamma>", "unfolding asToHeap_heapToAssn"], ["proof (prove)\nusing this:\n  P1 e\n  P2 \\<Gamma>\n\ngoal (1 subgoal):\n 1. P1 e &&& P2 \\<Gamma>", "."], ["proof (state)\nthis:\n  P1 e\n  P2 \\<Gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exp_heap_strong_induct[case_names Var App Let Lam Bool IfThenElse Nil Cons]:\n  assumes \"\\<And>var c. P1 c (Var var)\"\n  assumes \"\\<And>exp var c. (\\<And>c. P1 c exp) \\<Longrightarrow> P1 c (App exp var)\"\n  assumes \"\\<And>\\<Gamma> exp c. atom ` domA \\<Gamma> \\<sharp>* c \\<Longrightarrow> (\\<And>c. P2 c \\<Gamma>) \\<Longrightarrow> (\\<And>c. P1 c exp) \\<Longrightarrow> P1 c (Let \\<Gamma> exp)\"\n  assumes \"\\<And>var exp c. {atom var} \\<sharp>* c \\<Longrightarrow> (\\<And>c. P1 c exp) \\<Longrightarrow> P1 c (Lam [var]. exp)\"\n  assumes \"\\<And> b c. P1 c (Bool b)\"\n  assumes \"\\<And> scrut e1 e2 c. (\\<And> c. P1 c scrut) \\<Longrightarrow> (\\<And> c. P1 c e1) \\<Longrightarrow> (\\<And> c. P1 c e2) \\<Longrightarrow> P1 c (scrut ? e1 : e2)\"\n  assumes \"\\<And>c. P2 c []\"\n  assumes \"\\<And>var exp \\<Gamma> c. (\\<And>c. P1 c exp) \\<Longrightarrow> (\\<And>c. P2 c \\<Gamma>) \\<Longrightarrow> P2 c ((var,exp)#\\<Gamma>)\"\n  fixes c :: \"'a :: fs\"\n  shows \"P1 c e\" and \"P2 c \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P1 c e &&& P2 c \\<Gamma>", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. P1 c e\n 2. P2 c \\<Gamma>", "have \"P1 c e\" and \"P2 c (asToHeap (heapToAssn \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P1 c e &&& P2 c (asToHeap (heapToAssn \\<Gamma>))", "apply (induct rule: exp_assn.strong_induct[of P1 \"\\<lambda> c assn. P2 c (asToHeap assn)\"])"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x c. P1 c (Var x)\n 2. \\<And>x1 x2 c. (\\<And>c. P1 c x1) \\<Longrightarrow> P1 c (App x1 x2)\n 3. \\<And>x1 x2 c.\n       \\<lbrakk>set (bn x1) \\<sharp>* c; \\<And>c. P2 c (asToHeap x1);\n        \\<And>c. P1 c x2\\<rbrakk>\n       \\<Longrightarrow> P1 c (LetA x1 x2)\n 4. \\<And>x1 x2 c.\n       \\<lbrakk>{atom x1} \\<sharp>* c; \\<And>c. P1 c x2\\<rbrakk>\n       \\<Longrightarrow> P1 c (Lam [x1]. x2)\n 5. \\<And>x c. P1 c (Bool x)\n 6. \\<And>x1 x2 x3 c.\n       \\<lbrakk>\\<And>c. P1 c x1; \\<And>c. P1 c x2;\n        \\<And>c. P1 c x3\\<rbrakk>\n       \\<Longrightarrow> P1 c (x1 ? x2 : x3)\n 7. \\<And>c. P2 c (asToHeap ANil)\n 8. \\<And>x1 x2 x3 c.\n       \\<lbrakk>\\<And>c. P1 c x2; \\<And>c. P2 c (asToHeap x3)\\<rbrakk>\n       \\<Longrightarrow> P2 c (asToHeap (ACons x1 x2 x3))", "apply (metis assms(1))"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x1 x2 c. (\\<And>c. P1 c x1) \\<Longrightarrow> P1 c (App x1 x2)\n 2. \\<And>x1 x2 c.\n       \\<lbrakk>set (bn x1) \\<sharp>* c; \\<And>c. P2 c (asToHeap x1);\n        \\<And>c. P1 c x2\\<rbrakk>\n       \\<Longrightarrow> P1 c (LetA x1 x2)\n 3. \\<And>x1 x2 c.\n       \\<lbrakk>{atom x1} \\<sharp>* c; \\<And>c. P1 c x2\\<rbrakk>\n       \\<Longrightarrow> P1 c (Lam [x1]. x2)\n 4. \\<And>x c. P1 c (Bool x)\n 5. \\<And>x1 x2 x3 c.\n       \\<lbrakk>\\<And>c. P1 c x1; \\<And>c. P1 c x2;\n        \\<And>c. P1 c x3\\<rbrakk>\n       \\<Longrightarrow> P1 c (x1 ? x2 : x3)\n 6. \\<And>c. P2 c (asToHeap ANil)\n 7. \\<And>x1 x2 x3 c.\n       \\<lbrakk>\\<And>c. P1 c x2; \\<And>c. P2 c (asToHeap x3)\\<rbrakk>\n       \\<Longrightarrow> P2 c (asToHeap (ACons x1 x2 x3))", "apply (metis assms(2))"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x1 x2 c.\n       \\<lbrakk>set (bn x1) \\<sharp>* c; \\<And>c. P2 c (asToHeap x1);\n        \\<And>c. P1 c x2\\<rbrakk>\n       \\<Longrightarrow> P1 c (LetA x1 x2)\n 2. \\<And>x1 x2 c.\n       \\<lbrakk>{atom x1} \\<sharp>* c; \\<And>c. P1 c x2\\<rbrakk>\n       \\<Longrightarrow> P1 c (Lam [x1]. x2)\n 3. \\<And>x c. P1 c (Bool x)\n 4. \\<And>x1 x2 x3 c.\n       \\<lbrakk>\\<And>c. P1 c x1; \\<And>c. P1 c x2;\n        \\<And>c. P1 c x3\\<rbrakk>\n       \\<Longrightarrow> P1 c (x1 ? x2 : x3)\n 5. \\<And>c. P2 c (asToHeap ANil)\n 6. \\<And>x1 x2 x3 c.\n       \\<lbrakk>\\<And>c. P1 c x2; \\<And>c. P2 c (asToHeap x3)\\<rbrakk>\n       \\<Longrightarrow> P2 c (asToHeap (ACons x1 x2 x3))", "apply (metis assms(3) set_bn_to_atom_domA Let_def heapToAssn_asToHeap )"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1 x2 c.\n       \\<lbrakk>{atom x1} \\<sharp>* c; \\<And>c. P1 c x2\\<rbrakk>\n       \\<Longrightarrow> P1 c (Lam [x1]. x2)\n 2. \\<And>x c. P1 c (Bool x)\n 3. \\<And>x1 x2 x3 c.\n       \\<lbrakk>\\<And>c. P1 c x1; \\<And>c. P1 c x2;\n        \\<And>c. P1 c x3\\<rbrakk>\n       \\<Longrightarrow> P1 c (x1 ? x2 : x3)\n 4. \\<And>c. P2 c (asToHeap ANil)\n 5. \\<And>x1 x2 x3 c.\n       \\<lbrakk>\\<And>c. P1 c x2; \\<And>c. P2 c (asToHeap x3)\\<rbrakk>\n       \\<Longrightarrow> P2 c (asToHeap (ACons x1 x2 x3))", "apply (metis assms(4))"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x c. P1 c (Bool x)\n 2. \\<And>x1 x2 x3 c.\n       \\<lbrakk>\\<And>c. P1 c x1; \\<And>c. P1 c x2;\n        \\<And>c. P1 c x3\\<rbrakk>\n       \\<Longrightarrow> P1 c (x1 ? x2 : x3)\n 3. \\<And>c. P2 c (asToHeap ANil)\n 4. \\<And>x1 x2 x3 c.\n       \\<lbrakk>\\<And>c. P1 c x2; \\<And>c. P2 c (asToHeap x3)\\<rbrakk>\n       \\<Longrightarrow> P2 c (asToHeap (ACons x1 x2 x3))", "apply (metis assms(5))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x3 c.\n       \\<lbrakk>\\<And>c. P1 c x1; \\<And>c. P1 c x2;\n        \\<And>c. P1 c x3\\<rbrakk>\n       \\<Longrightarrow> P1 c (x1 ? x2 : x3)\n 2. \\<And>c. P2 c (asToHeap ANil)\n 3. \\<And>x1 x2 x3 c.\n       \\<lbrakk>\\<And>c. P1 c x2; \\<And>c. P2 c (asToHeap x3)\\<rbrakk>\n       \\<Longrightarrow> P2 c (asToHeap (ACons x1 x2 x3))", "apply (metis assms(6))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c. P2 c (asToHeap ANil)\n 2. \\<And>x1 x2 x3 c.\n       \\<lbrakk>\\<And>c. P1 c x2; \\<And>c. P2 c (asToHeap x3)\\<rbrakk>\n       \\<Longrightarrow> P2 c (asToHeap (ACons x1 x2 x3))", "apply (metis assms(7) asToHeap.simps(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 c.\n       \\<lbrakk>\\<And>c. P1 c x2; \\<And>c. P2 c (asToHeap x3)\\<rbrakk>\n       \\<Longrightarrow> P2 c (asToHeap (ACons x1 x2 x3))", "apply (metis assms(8) asToHeap.simps(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  P1 c e\n  P2 c (asToHeap (heapToAssn \\<Gamma>))\n\ngoal (2 subgoals):\n 1. P1 c e\n 2. P2 c \\<Gamma>", "thus \"P1 c e\" and \"P2 c \\<Gamma>\""], ["proof (prove)\nusing this:\n  P1 c e\n  P2 c (asToHeap (heapToAssn \\<Gamma>))\n\ngoal (1 subgoal):\n 1. P1 c e &&& P2 c \\<Gamma>", "unfolding asToHeap_heapToAssn"], ["proof (prove)\nusing this:\n  P1 c e\n  P2 c \\<Gamma>\n\ngoal (1 subgoal):\n 1. P1 c e &&& P2 c \\<Gamma>", "."], ["proof (state)\nthis:\n  P1 c e\n  P2 c \\<Gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Nice induction rules\\<close>"], ["", "text \\<open>\nThese rules can be used instead of the original induction rules, which require a separate\ngoal for @{typ assn}.\n\\<close>"], ["", "lemma exp_induct[case_names Var App Let Lam Bool IfThenElse]:\n  assumes \"\\<And>var. P (Var var)\"\n  assumes \"\\<And>exp var. P exp \\<Longrightarrow> P (App exp var)\"\n  assumes \"\\<And>\\<Gamma> exp. (\\<And> x. x \\<in> domA \\<Gamma> \\<Longrightarrow>  P (the (map_of \\<Gamma> x))) \\<Longrightarrow> P exp \\<Longrightarrow> P (Let \\<Gamma> exp)\"\n  assumes \"\\<And>var exp.  P exp \\<Longrightarrow> P (Lam [var]. exp)\"\n  assumes \"\\<And> b. P (Bool b)\"\n  assumes \"\\<And> scrut e1 e2. P scrut \\<Longrightarrow> P e1 \\<Longrightarrow> P e2 \\<Longrightarrow> P (scrut ? e1 : e2)\"\n  shows \"P exp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P exp", "apply (rule exp_heap_induct[of P \"\\<lambda> \\<Gamma>. (\\<forall>x \\<in> domA \\<Gamma>. P (the (map_of \\<Gamma> x)))\"])"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>b var. P (Var var)\n 2. \\<And>exp var. P exp \\<Longrightarrow> P (App exp var)\n 3. \\<And>\\<Gamma> exp.\n       \\<lbrakk>\\<forall>x\\<in>domA \\<Gamma>. P (the (map_of \\<Gamma> x));\n        P exp\\<rbrakk>\n       \\<Longrightarrow> P (Let \\<Gamma> exp)\n 4. \\<And>var exp. P exp \\<Longrightarrow> P (Lam [var]. exp)\n 5. \\<And>b. P (Bool b)\n 6. \\<And>scrut e1 e2.\n       \\<lbrakk>P scrut; P e1; P e2\\<rbrakk>\n       \\<Longrightarrow> P (scrut ? e1 : e2)\n 7. \\<forall>x\\<in>domA []. P (the (map_of [] x))\n 8. \\<And>var exp \\<Gamma>.\n       \\<lbrakk>P exp;\n        \\<forall>x\\<in>domA \\<Gamma>. P (the (map_of \\<Gamma> x))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>domA ((var, exp) # \\<Gamma>).\n                            P (the (map_of ((var, exp) # \\<Gamma>) x))", "apply (metis assms(1))"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>exp var. P exp \\<Longrightarrow> P (App exp var)\n 2. \\<And>\\<Gamma> exp.\n       \\<lbrakk>\\<forall>x\\<in>domA \\<Gamma>. P (the (map_of \\<Gamma> x));\n        P exp\\<rbrakk>\n       \\<Longrightarrow> P (Let \\<Gamma> exp)\n 3. \\<And>var exp. P exp \\<Longrightarrow> P (Lam [var]. exp)\n 4. \\<And>b. P (Bool b)\n 5. \\<And>scrut e1 e2.\n       \\<lbrakk>P scrut; P e1; P e2\\<rbrakk>\n       \\<Longrightarrow> P (scrut ? e1 : e2)\n 6. \\<forall>x\\<in>domA []. P (the (map_of [] x))\n 7. \\<And>var exp \\<Gamma>.\n       \\<lbrakk>P exp;\n        \\<forall>x\\<in>domA \\<Gamma>. P (the (map_of \\<Gamma> x))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>domA ((var, exp) # \\<Gamma>).\n                            P (the (map_of ((var, exp) # \\<Gamma>) x))", "apply (metis assms(2))"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> exp.\n       \\<lbrakk>\\<forall>x\\<in>domA \\<Gamma>. P (the (map_of \\<Gamma> x));\n        P exp\\<rbrakk>\n       \\<Longrightarrow> P (Let \\<Gamma> exp)\n 2. \\<And>var exp. P exp \\<Longrightarrow> P (Lam [var]. exp)\n 3. \\<And>b. P (Bool b)\n 4. \\<And>scrut e1 e2.\n       \\<lbrakk>P scrut; P e1; P e2\\<rbrakk>\n       \\<Longrightarrow> P (scrut ? e1 : e2)\n 5. \\<forall>x\\<in>domA []. P (the (map_of [] x))\n 6. \\<And>var exp \\<Gamma>.\n       \\<lbrakk>P exp;\n        \\<forall>x\\<in>domA \\<Gamma>. P (the (map_of \\<Gamma> x))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>domA ((var, exp) # \\<Gamma>).\n                            P (the (map_of ((var, exp) # \\<Gamma>) x))", "apply (metis assms(3))"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>var exp. P exp \\<Longrightarrow> P (Lam [var]. exp)\n 2. \\<And>b. P (Bool b)\n 3. \\<And>scrut e1 e2.\n       \\<lbrakk>P scrut; P e1; P e2\\<rbrakk>\n       \\<Longrightarrow> P (scrut ? e1 : e2)\n 4. \\<forall>x\\<in>domA []. P (the (map_of [] x))\n 5. \\<And>var exp \\<Gamma>.\n       \\<lbrakk>P exp;\n        \\<forall>x\\<in>domA \\<Gamma>. P (the (map_of \\<Gamma> x))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>domA ((var, exp) # \\<Gamma>).\n                            P (the (map_of ((var, exp) # \\<Gamma>) x))", "apply (metis assms(4))"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>b. P (Bool b)\n 2. \\<And>scrut e1 e2.\n       \\<lbrakk>P scrut; P e1; P e2\\<rbrakk>\n       \\<Longrightarrow> P (scrut ? e1 : e2)\n 3. \\<forall>x\\<in>domA []. P (the (map_of [] x))\n 4. \\<And>var exp \\<Gamma>.\n       \\<lbrakk>P exp;\n        \\<forall>x\\<in>domA \\<Gamma>. P (the (map_of \\<Gamma> x))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>domA ((var, exp) # \\<Gamma>).\n                            P (the (map_of ((var, exp) # \\<Gamma>) x))", "apply (metis assms(5))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>scrut e1 e2.\n       \\<lbrakk>P scrut; P e1; P e2\\<rbrakk>\n       \\<Longrightarrow> P (scrut ? e1 : e2)\n 2. \\<forall>x\\<in>domA []. P (the (map_of [] x))\n 3. \\<And>var exp \\<Gamma>.\n       \\<lbrakk>P exp;\n        \\<forall>x\\<in>domA \\<Gamma>. P (the (map_of \\<Gamma> x))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>domA ((var, exp) # \\<Gamma>).\n                            P (the (map_of ((var, exp) # \\<Gamma>) x))", "apply (metis assms(6))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>domA []. P (the (map_of [] x))\n 2. \\<And>var exp \\<Gamma>.\n       \\<lbrakk>P exp;\n        \\<forall>x\\<in>domA \\<Gamma>. P (the (map_of \\<Gamma> x))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>domA ((var, exp) # \\<Gamma>).\n                            P (the (map_of ((var, exp) # \\<Gamma>) x))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma  exp_strong_induct_set[case_names Var App Let Lam Bool IfThenElse]:\n  assumes \"\\<And>var c. P c (Var var)\"\n  assumes \"\\<And>exp var c. (\\<And>c. P c exp) \\<Longrightarrow> P c (App exp var)\"\n  assumes \"\\<And>\\<Gamma> exp c.\n    atom ` domA \\<Gamma> \\<sharp>* c \\<Longrightarrow> (\\<And>c x e. (x,e) \\<in> set \\<Gamma> \\<Longrightarrow>  P c e) \\<Longrightarrow> (\\<And>c. P c exp) \\<Longrightarrow> P c (Let \\<Gamma> exp)\"\n  assumes \"\\<And>var exp c. {atom var} \\<sharp>* c \\<Longrightarrow> (\\<And>c. P c exp) \\<Longrightarrow> P c (Lam [var]. exp)\"\n  assumes \"\\<And>b c. P c (Bool b)\"\n  assumes \"\\<And>scrut e1 e2 c. (\\<And> c. P c scrut) \\<Longrightarrow> (\\<And> c. P c e1) \\<Longrightarrow> (\\<And> c. P c e2) \\<Longrightarrow> P c (scrut ? e1 : e2)\"\n  shows \"P (c::'a::fs) exp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P c exp", "apply (rule exp_heap_strong_induct(1)[of P \"\\<lambda> c \\<Gamma>. (\\<forall>(x,e) \\<in> set \\<Gamma>. P c e)\"])"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>var c. P c (Var var)\n 2. \\<And>exp var c. (\\<And>c. P c exp) \\<Longrightarrow> P c (App exp var)\n 3. \\<And>\\<Gamma> exp c.\n       \\<lbrakk>atom ` domA \\<Gamma> \\<sharp>* c;\n        \\<And>c. \\<forall>(x, e)\\<in>set \\<Gamma>. P c e;\n        \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Let \\<Gamma> exp)\n 4. \\<And>var exp c.\n       \\<lbrakk>{atom var} \\<sharp>* c; \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Lam [var]. exp)\n 5. \\<And>b c. P c (Bool b)\n 6. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)\n 7. \\<And>c. \\<forall>(x, e)\\<in>set []. P c e\n 8. \\<And>var exp \\<Gamma> c.\n       \\<lbrakk>\\<And>c. P c exp;\n        \\<And>c. \\<forall>(x, e)\\<in>set \\<Gamma>. P c e\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(x, e)\\<in>set ((var, exp) # \\<Gamma>).\n                            P c e", "apply (metis assms(1))"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>exp var c. (\\<And>c. P c exp) \\<Longrightarrow> P c (App exp var)\n 2. \\<And>\\<Gamma> exp c.\n       \\<lbrakk>atom ` domA \\<Gamma> \\<sharp>* c;\n        \\<And>c. \\<forall>(x, e)\\<in>set \\<Gamma>. P c e;\n        \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Let \\<Gamma> exp)\n 3. \\<And>var exp c.\n       \\<lbrakk>{atom var} \\<sharp>* c; \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Lam [var]. exp)\n 4. \\<And>b c. P c (Bool b)\n 5. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)\n 6. \\<And>c. \\<forall>(x, e)\\<in>set []. P c e\n 7. \\<And>var exp \\<Gamma> c.\n       \\<lbrakk>\\<And>c. P c exp;\n        \\<And>c. \\<forall>(x, e)\\<in>set \\<Gamma>. P c e\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(x, e)\\<in>set ((var, exp) # \\<Gamma>).\n                            P c e", "apply (metis assms(2))"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> exp c.\n       \\<lbrakk>atom ` domA \\<Gamma> \\<sharp>* c;\n        \\<And>c. \\<forall>(x, e)\\<in>set \\<Gamma>. P c e;\n        \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Let \\<Gamma> exp)\n 2. \\<And>var exp c.\n       \\<lbrakk>{atom var} \\<sharp>* c; \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Lam [var]. exp)\n 3. \\<And>b c. P c (Bool b)\n 4. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)\n 5. \\<And>c. \\<forall>(x, e)\\<in>set []. P c e\n 6. \\<And>var exp \\<Gamma> c.\n       \\<lbrakk>\\<And>c. P c exp;\n        \\<And>c. \\<forall>(x, e)\\<in>set \\<Gamma>. P c e\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(x, e)\\<in>set ((var, exp) # \\<Gamma>).\n                            P c e", "apply (metis assms(3) split_conv)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>var exp c.\n       \\<lbrakk>{atom var} \\<sharp>* c; \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Lam [var]. exp)\n 2. \\<And>b c. P c (Bool b)\n 3. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)\n 4. \\<And>c. \\<forall>(x, e)\\<in>set []. P c e\n 5. \\<And>var exp \\<Gamma> c.\n       \\<lbrakk>\\<And>c. P c exp;\n        \\<And>c. \\<forall>(x, e)\\<in>set \\<Gamma>. P c e\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(x, e)\\<in>set ((var, exp) # \\<Gamma>).\n                            P c e", "apply (metis assms(4))"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>b c. P c (Bool b)\n 2. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)\n 3. \\<And>c. \\<forall>(x, e)\\<in>set []. P c e\n 4. \\<And>var exp \\<Gamma> c.\n       \\<lbrakk>\\<And>c. P c exp;\n        \\<And>c. \\<forall>(x, e)\\<in>set \\<Gamma>. P c e\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(x, e)\\<in>set ((var, exp) # \\<Gamma>).\n                            P c e", "apply (metis assms(5))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)\n 2. \\<And>c. \\<forall>(x, e)\\<in>set []. P c e\n 3. \\<And>var exp \\<Gamma> c.\n       \\<lbrakk>\\<And>c. P c exp;\n        \\<And>c. \\<forall>(x, e)\\<in>set \\<Gamma>. P c e\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(x, e)\\<in>set ((var, exp) # \\<Gamma>).\n                            P c e", "apply (metis assms(6))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c. \\<forall>(x, e)\\<in>set []. P c e\n 2. \\<And>var exp \\<Gamma> c.\n       \\<lbrakk>\\<And>c. P c exp;\n        \\<And>c. \\<forall>(x, e)\\<in>set \\<Gamma>. P c e\\<rbrakk>\n       \\<Longrightarrow> \\<forall>(x, e)\\<in>set ((var, exp) # \\<Gamma>).\n                            P c e", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma  exp_strong_induct[case_names Var App Let Lam Bool IfThenElse]:\n  assumes \"\\<And>var c. P c (Var var)\"\n  assumes \"\\<And>exp var c. (\\<And>c. P c exp) \\<Longrightarrow> P c (App exp var)\"\n  assumes \"\\<And>\\<Gamma> exp c.\n    atom ` domA \\<Gamma> \\<sharp>* c \\<Longrightarrow> (\\<And>c x. x \\<in> domA \\<Gamma> \\<Longrightarrow>  P c (the (map_of \\<Gamma> x))) \\<Longrightarrow> (\\<And>c. P c exp) \\<Longrightarrow> P c (Let \\<Gamma> exp)\"\n  assumes \"\\<And>var exp c. {atom var} \\<sharp>* c \\<Longrightarrow> (\\<And>c. P c exp) \\<Longrightarrow> P c (Lam [var]. exp)\"\n  assumes \"\\<And>b c. P c (Bool b)\"\n  assumes \"\\<And> scrut e1 e2 c. (\\<And> c. P c scrut) \\<Longrightarrow> (\\<And> c. P c e1) \\<Longrightarrow> (\\<And> c. P c e2) \\<Longrightarrow> P c (scrut ? e1 : e2)\"\n  shows \"P (c::'a::fs) exp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P c exp", "apply (rule exp_heap_strong_induct(1)[of P \"\\<lambda> c \\<Gamma>. (\\<forall>x \\<in> domA \\<Gamma>. P c (the (map_of \\<Gamma> x)))\"])"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>var c. P c (Var var)\n 2. \\<And>exp var c. (\\<And>c. P c exp) \\<Longrightarrow> P c (App exp var)\n 3. \\<And>\\<Gamma> exp c.\n       \\<lbrakk>atom ` domA \\<Gamma> \\<sharp>* c;\n        \\<And>c.\n           \\<forall>x\\<in>domA \\<Gamma>. P c (the (map_of \\<Gamma> x));\n        \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Let \\<Gamma> exp)\n 4. \\<And>var exp c.\n       \\<lbrakk>{atom var} \\<sharp>* c; \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Lam [var]. exp)\n 5. \\<And>b c. P c (Bool b)\n 6. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)\n 7. \\<And>c. \\<forall>x\\<in>domA []. P c (the (map_of [] x))\n 8. \\<And>var exp \\<Gamma> c.\n       \\<lbrakk>\\<And>c. P c exp;\n        \\<And>c.\n           \\<forall>x\\<in>domA \\<Gamma>.\n              P c (the (map_of \\<Gamma> x))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>domA ((var, exp) # \\<Gamma>).\n                            P c (the (map_of ((var, exp) # \\<Gamma>) x))", "apply (metis assms(1))"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>exp var c. (\\<And>c. P c exp) \\<Longrightarrow> P c (App exp var)\n 2. \\<And>\\<Gamma> exp c.\n       \\<lbrakk>atom ` domA \\<Gamma> \\<sharp>* c;\n        \\<And>c.\n           \\<forall>x\\<in>domA \\<Gamma>. P c (the (map_of \\<Gamma> x));\n        \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Let \\<Gamma> exp)\n 3. \\<And>var exp c.\n       \\<lbrakk>{atom var} \\<sharp>* c; \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Lam [var]. exp)\n 4. \\<And>b c. P c (Bool b)\n 5. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)\n 6. \\<And>c. \\<forall>x\\<in>domA []. P c (the (map_of [] x))\n 7. \\<And>var exp \\<Gamma> c.\n       \\<lbrakk>\\<And>c. P c exp;\n        \\<And>c.\n           \\<forall>x\\<in>domA \\<Gamma>.\n              P c (the (map_of \\<Gamma> x))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>domA ((var, exp) # \\<Gamma>).\n                            P c (the (map_of ((var, exp) # \\<Gamma>) x))", "apply (metis assms(2))"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> exp c.\n       \\<lbrakk>atom ` domA \\<Gamma> \\<sharp>* c;\n        \\<And>c.\n           \\<forall>x\\<in>domA \\<Gamma>. P c (the (map_of \\<Gamma> x));\n        \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Let \\<Gamma> exp)\n 2. \\<And>var exp c.\n       \\<lbrakk>{atom var} \\<sharp>* c; \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Lam [var]. exp)\n 3. \\<And>b c. P c (Bool b)\n 4. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)\n 5. \\<And>c. \\<forall>x\\<in>domA []. P c (the (map_of [] x))\n 6. \\<And>var exp \\<Gamma> c.\n       \\<lbrakk>\\<And>c. P c exp;\n        \\<And>c.\n           \\<forall>x\\<in>domA \\<Gamma>.\n              P c (the (map_of \\<Gamma> x))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>domA ((var, exp) # \\<Gamma>).\n                            P c (the (map_of ((var, exp) # \\<Gamma>) x))", "apply (metis assms(3))"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>var exp c.\n       \\<lbrakk>{atom var} \\<sharp>* c; \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Lam [var]. exp)\n 2. \\<And>b c. P c (Bool b)\n 3. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)\n 4. \\<And>c. \\<forall>x\\<in>domA []. P c (the (map_of [] x))\n 5. \\<And>var exp \\<Gamma> c.\n       \\<lbrakk>\\<And>c. P c exp;\n        \\<And>c.\n           \\<forall>x\\<in>domA \\<Gamma>.\n              P c (the (map_of \\<Gamma> x))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>domA ((var, exp) # \\<Gamma>).\n                            P c (the (map_of ((var, exp) # \\<Gamma>) x))", "apply (metis assms(4))"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>b c. P c (Bool b)\n 2. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)\n 3. \\<And>c. \\<forall>x\\<in>domA []. P c (the (map_of [] x))\n 4. \\<And>var exp \\<Gamma> c.\n       \\<lbrakk>\\<And>c. P c exp;\n        \\<And>c.\n           \\<forall>x\\<in>domA \\<Gamma>.\n              P c (the (map_of \\<Gamma> x))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>domA ((var, exp) # \\<Gamma>).\n                            P c (the (map_of ((var, exp) # \\<Gamma>) x))", "apply (metis assms(5))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)\n 2. \\<And>c. \\<forall>x\\<in>domA []. P c (the (map_of [] x))\n 3. \\<And>var exp \\<Gamma> c.\n       \\<lbrakk>\\<And>c. P c exp;\n        \\<And>c.\n           \\<forall>x\\<in>domA \\<Gamma>.\n              P c (the (map_of \\<Gamma> x))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>domA ((var, exp) # \\<Gamma>).\n                            P c (the (map_of ((var, exp) # \\<Gamma>) x))", "apply (metis assms(6))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c. \\<forall>x\\<in>domA []. P c (the (map_of [] x))\n 2. \\<And>var exp \\<Gamma> c.\n       \\<lbrakk>\\<And>c. P c exp;\n        \\<And>c.\n           \\<forall>x\\<in>domA \\<Gamma>.\n              P c (the (map_of \\<Gamma> x))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>domA ((var, exp) # \\<Gamma>).\n                            P c (the (map_of ((var, exp) # \\<Gamma>) x))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Testing alpha equivalence\\<close>"], ["", "lemma alpha_test:\n  shows \"Lam [x]. (Var x) = Lam [y]. (Var y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lam [x]. Var x = Lam [y]. Var y", "by (simp add: Abs1_eq_iff fresh_at_base pure_fresh)"], ["", "lemma alpha_test2:\n  shows \"let x be (Var x) in (Var x) = let y be (Var y) in (Var y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. let x be Var x in Var x  = let y be Var y in Var y", "by (simp add: fresh_Cons fresh_Nil Abs1_eq_iff fresh_Pair add: fresh_at_base pure_fresh)"], ["", "lemma alpha_test3:\n  shows \"\n    Let [(x, Var y), (y, Var x)] (Var x)\n    =\n    Let [(y, Var x), (x, Var y)] (Var y)\" (is \"Let ?la ?lb = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Let [(x, Var y), (y, Var x)] (Var x) =\n    Let [(y, Var x), (x, Var y)] (Var y)", "by (simp add: bn_heapToAssn Abs1_eq_iff fresh_Pair fresh_at_base\n                Abs_swap2[of \"atom x\" \"(?lb, [(x, Var y), (y, Var x)])\" \"[atom x, atom y]\" \"atom y\"])"], ["", "subsubsection \\<open>Free variables\\<close>"], ["", "lemma fv_supp_exp: \"supp e = atom ` (fv (e::exp) :: var set)\" and fv_supp_as: \"supp as = atom ` (fv (as::assn) :: var set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp e = atom ` fv e &&& supp as = atom ` fv as", "by (induction e and as rule:exp_assn.inducts)\n     (auto simp add: fv_def exp_assn.supp supp_at_base pure_supp)"], ["", "lemma fv_supp_heap: \"supp (\\<Gamma>::heap) = atom ` (fv \\<Gamma> :: var set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp \\<Gamma> = atom ` fv \\<Gamma>", "by (metis fv_def fv_supp_as supp_heapToAssn)"], ["", "lemma fv_Lam[simp]: \"fv (Lam [x]. e) = fv e - {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (Lam [x]. e) = fv e - {x}", "unfolding fv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {v. atom v \\<in> supp (Lam [x]. e)} = {v. atom v \\<in> supp e} - {x}", "by (auto simp add: exp_assn.supp)"], ["", "lemma fv_Var[simp]: \"fv (Var x) = {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (Var x) = {x}", "unfolding fv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {v. atom v \\<in> supp (Var x)} = {x}", "by (auto simp add: exp_assn.supp supp_at_base pure_supp)"], ["", "lemma fv_App[simp]: \"fv (App e x) = insert x (fv e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (App e x) = insert x (fv e)", "unfolding fv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {v. atom v \\<in> supp (App e x)} = insert x {v. atom v \\<in> supp e}", "by (auto simp add: exp_assn.supp supp_at_base)"], ["", "lemma fv_Let[simp]: \"fv (Let \\<Gamma> e) = (fv \\<Gamma> \\<union> fv e) - domA \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (Let \\<Gamma> e) = fv \\<Gamma> \\<union> fv e - domA \\<Gamma>", "unfolding fv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {v. atom v \\<in> supp (Let \\<Gamma> e)} =\n    {v. atom v \\<in> supp \\<Gamma>} \\<union> {v. atom v \\<in> supp e} -\n    domA \\<Gamma>", "by (auto simp add: Let_supp exp_assn.supp supp_at_base set_bn_to_atom_domA)"], ["", "lemma fv_Bool[simp]: \"fv (Bool b) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (Bool b) = {}", "unfolding fv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {v. atom v \\<in> supp (Bool b)} = {}", "by (auto simp add: exp_assn.supp pure_supp)"], ["", "lemma fv_IfThenElse[simp]: \"fv (scrut ? e1 : e2)  = fv scrut \\<union> fv e1 \\<union> fv e2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (scrut ? e1 : e2) = fv scrut \\<union> fv e1 \\<union> fv e2", "unfolding fv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {v. atom v \\<in> supp (scrut ? e1 : e2)} =\n    {v. atom v \\<in> supp scrut} \\<union> {v. atom v \\<in> supp e1} \\<union>\n    {v. atom v \\<in> supp e2}", "by (auto simp add: exp_assn.supp)"], ["", "lemma fv_delete_heap:\n  assumes \"map_of \\<Gamma> x = Some e\"\n  shows \"fv (delete x \\<Gamma>, e) \\<union> {x} \\<subseteq> (fv (\\<Gamma>, Var x) :: var set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (delete x \\<Gamma>, e) \\<union> {x} \\<subseteq> fv (\\<Gamma>, Var x)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. fv (delete x \\<Gamma>, e) \\<union> {x} \\<subseteq> fv (\\<Gamma>, Var x)", "have \"fv (delete x \\<Gamma>) \\<subseteq> fv \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (delete x \\<Gamma>) \\<subseteq> fv \\<Gamma>", "by (metis fv_delete_subset)"], ["proof (state)\nthis:\n  fv (delete x \\<Gamma>) \\<subseteq> fv \\<Gamma>\n\ngoal (1 subgoal):\n 1. fv (delete x \\<Gamma>, e) \\<union> {x} \\<subseteq> fv (\\<Gamma>, Var x)", "moreover"], ["proof (state)\nthis:\n  fv (delete x \\<Gamma>) \\<subseteq> fv \\<Gamma>\n\ngoal (1 subgoal):\n 1. fv (delete x \\<Gamma>, e) \\<union> {x} \\<subseteq> fv (\\<Gamma>, Var x)", "have \"(x,e) \\<in> set \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, e) \\<in> set \\<Gamma>", "by (metis assms map_of_SomeD)"], ["proof (state)\nthis:\n  (x, e) \\<in> set \\<Gamma>\n\ngoal (1 subgoal):\n 1. fv (delete x \\<Gamma>, e) \\<union> {x} \\<subseteq> fv (\\<Gamma>, Var x)", "hence \"fv e \\<subseteq> fv \\<Gamma>\""], ["proof (prove)\nusing this:\n  (x, e) \\<in> set \\<Gamma>\n\ngoal (1 subgoal):\n 1. fv e \\<subseteq> fv \\<Gamma>", "by (metis assms domA_from_set map_of_fv_subset option.sel)"], ["proof (state)\nthis:\n  fv e \\<subseteq> fv \\<Gamma>\n\ngoal (1 subgoal):\n 1. fv (delete x \\<Gamma>, e) \\<union> {x} \\<subseteq> fv (\\<Gamma>, Var x)", "moreover"], ["proof (state)\nthis:\n  fv e \\<subseteq> fv \\<Gamma>\n\ngoal (1 subgoal):\n 1. fv (delete x \\<Gamma>, e) \\<union> {x} \\<subseteq> fv (\\<Gamma>, Var x)", "have \"x \\<in> fv (Var x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> fv (Var x)", "by simp"], ["proof (state)\nthis:\n  x \\<in> fv (Var x)\n\ngoal (1 subgoal):\n 1. fv (delete x \\<Gamma>, e) \\<union> {x} \\<subseteq> fv (\\<Gamma>, Var x)", "ultimately"], ["proof (chain)\npicking this:\n  fv (delete x \\<Gamma>) \\<subseteq> fv \\<Gamma>\n  fv e \\<subseteq> fv \\<Gamma>\n  x \\<in> fv (Var x)", "show ?thesis"], ["proof (prove)\nusing this:\n  fv (delete x \\<Gamma>) \\<subseteq> fv \\<Gamma>\n  fv e \\<subseteq> fv \\<Gamma>\n  x \\<in> fv (Var x)\n\ngoal (1 subgoal):\n 1. fv (delete x \\<Gamma>, e) \\<union> {x} \\<subseteq> fv (\\<Gamma>, Var x)", "by auto"], ["proof (state)\nthis:\n  fv (delete x \\<Gamma>, e) \\<union> {x} \\<subseteq> fv (\\<Gamma>, Var x)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Lemmas helping with nominal definitions\\<close>"], ["", "lemma eqvt_lam_case:\n  assumes \"Lam [x]. e = Lam [x']. e'\"\n  assumes \"\\<And> \\<pi> . supp (-\\<pi>) \\<sharp>* (fv (Lam [x]. e) :: var set) \\<Longrightarrow>\n                 supp \\<pi> \\<sharp>* (Lam [x]. e) \\<Longrightarrow>\n        F (\\<pi> \\<bullet> e) (\\<pi> \\<bullet> x) (Lam [x]. e) = F e x (Lam [x]. e)\"\n  shows \"F e x (Lam [x]. e) = F e' x' (Lam [x']. e')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F e x (Lam [x]. e) = F e' x' (Lam [x']. e')", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. F e x (Lam [x]. e) = F e' x' (Lam [x']. e')", "from assms(1)"], ["proof (chain)\npicking this:\n  Lam [x]. e = Lam [x']. e'", "have \"[[atom x]]lst. (e, x) = [[atom x']]lst. (e', x')\""], ["proof (prove)\nusing this:\n  Lam [x]. e = Lam [x']. e'\n\ngoal (1 subgoal):\n 1. [[atom x]]lst. (e, x) = [[atom x']]lst. (e', x')", "by auto"], ["proof (state)\nthis:\n  [[atom x]]lst. (e, x) = [[atom x']]lst. (e', x')\n\ngoal (1 subgoal):\n 1. F e x (Lam [x]. e) = F e' x' (Lam [x']. e')", "then"], ["proof (chain)\npicking this:\n  [[atom x]]lst. (e, x) = [[atom x']]lst. (e', x')", "obtain p\n    where \"(supp (e, x) - {atom x}) \\<sharp>* p\"\n    and [simp]: \"p \\<bullet> x = x'\"\n    and [simp]: \"p \\<bullet> e = e'\""], ["proof (prove)\nusing this:\n  [[atom x]]lst. (e, x) = [[atom x']]lst. (e', x')\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>(supp (e, x) - {atom x}) \\<sharp>* p; p \\<bullet> x = x';\n         p \\<bullet> e = e'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding  Abs_eq_iff(3) alpha_lst.simps"], ["proof (prove)\nusing this:\n  \\<exists>p.\n     supp (e, x) - set [atom x] = supp (e', x') - set [atom x'] \\<and>\n     (supp (e, x) - set [atom x]) \\<sharp>* p \\<and>\n     p \\<bullet> (e, x) = (e', x') \\<and> p \\<bullet> [atom x] = [atom x']\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>(supp (e, x) - {atom x}) \\<sharp>* p; p \\<bullet> x = x';\n         p \\<bullet> e = e'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (supp (e, x) - {atom x}) \\<sharp>* p\n  p \\<bullet> x = x'\n  p \\<bullet> e = e'\n\ngoal (1 subgoal):\n 1. F e x (Lam [x]. e) = F e' x' (Lam [x']. e')", "from \\<open>_ \\<sharp>* p\\<close>"], ["proof (chain)\npicking this:\n  (supp (e, x) - {atom x}) \\<sharp>* p", "have *: \"supp (-p) \\<sharp>* (fv (Lam [x]. e) :: var set)\""], ["proof (prove)\nusing this:\n  (supp (e, x) - {atom x}) \\<sharp>* p\n\ngoal (1 subgoal):\n 1. supp (- p) \\<sharp>* fv (Lam [x]. e)", "by (auto simp add: fresh_star_def fresh_def supp_finite_set_at_base supp_Pair fv_supp_exp fv_supp_heap supp_minus_perm)"], ["proof (state)\nthis:\n  supp (- p) \\<sharp>* fv (Lam [x]. e)\n\ngoal (1 subgoal):\n 1. F e x (Lam [x]. e) = F e' x' (Lam [x']. e')", "from \\<open>_ \\<sharp>* p\\<close>"], ["proof (chain)\npicking this:\n  (supp (e, x) - {atom x}) \\<sharp>* p", "have **: \"supp p \\<sharp>* Lam [x]. e\""], ["proof (prove)\nusing this:\n  (supp (e, x) - {atom x}) \\<sharp>* p\n\ngoal (1 subgoal):\n 1. supp p \\<sharp>* Lam [x]. e", "by (auto simp add: fresh_star_def fresh_def supp_Pair fv_supp_exp)"], ["proof (state)\nthis:\n  supp p \\<sharp>* Lam [x]. e\n\ngoal (1 subgoal):\n 1. F e x (Lam [x]. e) = F e' x' (Lam [x']. e')", "have \"F e x (Lam [x]. e) =  F (p \\<bullet> e) (p \\<bullet> x) (Lam [x]. e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F e x (Lam [x]. e) = F (p \\<bullet> e) (p \\<bullet> x) (Lam [x]. e)", "by (rule assms(2)[OF * **, symmetric])"], ["proof (state)\nthis:\n  F e x (Lam [x]. e) = F (p \\<bullet> e) (p \\<bullet> x) (Lam [x]. e)\n\ngoal (1 subgoal):\n 1. F e x (Lam [x]. e) = F e' x' (Lam [x']. e')", "also"], ["proof (state)\nthis:\n  F e x (Lam [x]. e) = F (p \\<bullet> e) (p \\<bullet> x) (Lam [x]. e)\n\ngoal (1 subgoal):\n 1. F e x (Lam [x]. e) = F e' x' (Lam [x']. e')", "have \"\\<dots> = F e' x' (Lam [x']. e')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F (p \\<bullet> e) (p \\<bullet> x) (Lam [x]. e) = F e' x' (Lam [x']. e')", "by (simp add: assms(1))"], ["proof (state)\nthis:\n  F (p \\<bullet> e) (p \\<bullet> x) (Lam [x]. e) = F e' x' (Lam [x']. e')\n\ngoal (1 subgoal):\n 1. F e x (Lam [x]. e) = F e' x' (Lam [x']. e')", "finally"], ["proof (chain)\npicking this:\n  F e x (Lam [x]. e) = F e' x' (Lam [x']. e')", "show ?thesis"], ["proof (prove)\nusing this:\n  F e x (Lam [x]. e) = F e' x' (Lam [x']. e')\n\ngoal (1 subgoal):\n 1. F e x (Lam [x]. e) = F e' x' (Lam [x']. e')", "."], ["proof (state)\nthis:\n  F e x (Lam [x]. e) = F e' x' (Lam [x']. e')\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Nice idea, but doesn't work well with extra arguments to the function\n\nlemma eqvt_lam_case_eqvt:\n  assumes \"Lam [x]. e = Lam [x']. e'\"\n  assumes F_eqvt: \"\\<And> \\<pi> e'. \\<pi> \\<bullet> F e x e' = F (\\<pi> \\<bullet> e) (\\<pi> \\<bullet> x) (\\<pi> \\<bullet> e')\"\n  assumes F_supp: \"atom x \\<sharp> F e x (Lam [x]. e)\"\n  shows \"F e x (Lam [x]. e) = F e' x' (Lam [x']. e')\"\nusing assms(1)\nproof(rule eqvt_lam_case)\n  have \"eqvt F\" unfolding eqvt_def by (rule, perm_simp, rule) so rry\n  hence \"supp (F e x (Lam [x]. e)) \\<subseteq> supp e \\<union> supp x \\<union> supp (Lam [x]. e)\" by (rule supp_fun_app_eqvt3)    \n  with F_supp[unfolded fresh_def]\n  have *: \"supp (F e x (Lam [x]. e)) \\<subseteq> supp (Lam [x]. e)\" by (auto simp add: exp_assn.supp supp_at_base)\n\n  fix \\<pi> :: perm\n  assume \"supp \\<pi> \\<sharp>* Lam [x]. e\" with *\n  have \"supp \\<pi> \\<sharp>* F e x (Lam [x]. e)\" by (auto simp add: fresh_star_def fresh_def)\n  hence \"F e x (Lam [x]. e) = \\<pi> \\<bullet> (F e x (Lam [x]. e))\" by (metis perm_supp_eq)\n  also have \"\\<dots> =  F (\\<pi> \\<bullet> e) (\\<pi> \\<bullet> x) (\\<pi> \\<bullet> (Lam [x]. e))\" by (simp add: F_eqvt)\n  also have \"\\<pi> \\<bullet> (Lam [x]. e) = (Lam [x]. e)\" using `supp \\<pi> \\<sharp>* Lam [x]. e` by (metis perm_supp_eq)\n  finally show \"F (\\<pi> \\<bullet> e) (\\<pi> \\<bullet> x) (Lam [x]. e) = F e x (Lam [x]. e)\"..\nqed\n*)"], ["", "lemma eqvt_let_case:\n  assumes \"Let as body = Let as' body'\"\n  assumes \"\\<And> \\<pi> .\n    supp (-\\<pi>) \\<sharp>* (fv (Let as body) :: var set) \\<Longrightarrow>\n    supp \\<pi> \\<sharp>* Let as body \\<Longrightarrow>\n    F (\\<pi> \\<bullet> as) (\\<pi> \\<bullet> body) (Let as body) = F as body (Let as body)\"\n  shows \"F as body (Let as body) = F as' body' (Let as' body')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F as body (Let as body) = F as' body' (Let as' body')", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. F as body (Let as body) = F as' body' (Let as' body')", "from assms(1)"], ["proof (chain)\npicking this:\n  Let as body = Let as' body'", "have \"[map (\\<lambda> p. atom (fst p)) as]lst. (body, as) = [map (\\<lambda> p. atom (fst p)) as']lst. (body', as')\""], ["proof (prove)\nusing this:\n  Let as body = Let as' body'\n\ngoal (1 subgoal):\n 1. [map (\\<lambda>p. atom (fst p)) as]lst. (body, as) =\n    [map (\\<lambda>p. atom (fst p)) as']lst. (body', as')", "by auto"], ["proof (state)\nthis:\n  [map (\\<lambda>p. atom (fst p)) as]lst. (body, as) =\n  [map (\\<lambda>p. atom (fst p)) as']lst. (body', as')\n\ngoal (1 subgoal):\n 1. F as body (Let as body) = F as' body' (Let as' body')", "then"], ["proof (chain)\npicking this:\n  [map (\\<lambda>p. atom (fst p)) as]lst. (body, as) =\n  [map (\\<lambda>p. atom (fst p)) as']lst. (body', as')", "obtain p\n    where \"(supp (body, as) - atom ` domA as) \\<sharp>* p\"\n    and [simp]: \"p \\<bullet> body = body'\"\n    and [simp]: \"p \\<bullet> as = as'\""], ["proof (prove)\nusing this:\n  [map (\\<lambda>p. atom (fst p)) as]lst. (body, as) =\n  [map (\\<lambda>p. atom (fst p)) as']lst. (body', as')\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>(supp (body, as) - atom ` domA as) \\<sharp>* p;\n         p \\<bullet> body = body'; p \\<bullet> as = as'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding  Abs_eq_iff(3) alpha_lst.simps"], ["proof (prove)\nusing this:\n  \\<exists>p.\n     supp (body, as) - set (map (\\<lambda>p. atom (fst p)) as) =\n     supp (body', as') - set (map (\\<lambda>p. atom (fst p)) as') \\<and>\n     (supp (body, as) -\n      set (map (\\<lambda>p. atom (fst p)) as)) \\<sharp>* p \\<and>\n     p \\<bullet> (body, as) = (body', as') \\<and>\n     p \\<bullet> map (\\<lambda>p. atom (fst p)) as =\n     map (\\<lambda>p. atom (fst p)) as'\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>(supp (body, as) - atom ` domA as) \\<sharp>* p;\n         p \\<bullet> body = body'; p \\<bullet> as = as'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: domA_def image_image)"], ["proof (state)\nthis:\n  (supp (body, as) - atom ` domA as) \\<sharp>* p\n  p \\<bullet> body = body'\n  p \\<bullet> as = as'\n\ngoal (1 subgoal):\n 1. F as body (Let as body) = F as' body' (Let as' body')", "from \\<open>_ \\<sharp>* p\\<close>"], ["proof (chain)\npicking this:\n  (supp (body, as) - atom ` domA as) \\<sharp>* p", "have *: \"supp (-p) \\<sharp>* (fv (Terms.Let as body) :: var set)\""], ["proof (prove)\nusing this:\n  (supp (body, as) - atom ` domA as) \\<sharp>* p\n\ngoal (1 subgoal):\n 1. supp (- p) \\<sharp>* fv (Let as body)", "by (auto simp add: fresh_star_def fresh_def supp_finite_set_at_base supp_Pair fv_supp_exp fv_supp_heap supp_minus_perm)"], ["proof (state)\nthis:\n  supp (- p) \\<sharp>* fv (Let as body)\n\ngoal (1 subgoal):\n 1. F as body (Let as body) = F as' body' (Let as' body')", "from \\<open>_ \\<sharp>* p\\<close>"], ["proof (chain)\npicking this:\n  (supp (body, as) - atom ` domA as) \\<sharp>* p", "have **: \"supp p \\<sharp>* Terms.Let as body\""], ["proof (prove)\nusing this:\n  (supp (body, as) - atom ` domA as) \\<sharp>* p\n\ngoal (1 subgoal):\n 1. supp p \\<sharp>* Let as body", "by (auto simp add: fresh_star_def fresh_def supp_Pair fv_supp_exp fv_supp_heap )"], ["proof (state)\nthis:\n  supp p \\<sharp>* Let as body\n\ngoal (1 subgoal):\n 1. F as body (Let as body) = F as' body' (Let as' body')", "have \"F as body (Let as body) =  F (p \\<bullet> as) (p \\<bullet> body) (Let as body)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F as body (Let as body) =\n    F (p \\<bullet> as) (p \\<bullet> body) (Let as body)", "by (rule assms(2)[OF * **, symmetric])"], ["proof (state)\nthis:\n  F as body (Let as body) =\n  F (p \\<bullet> as) (p \\<bullet> body) (Let as body)\n\ngoal (1 subgoal):\n 1. F as body (Let as body) = F as' body' (Let as' body')", "also"], ["proof (state)\nthis:\n  F as body (Let as body) =\n  F (p \\<bullet> as) (p \\<bullet> body) (Let as body)\n\ngoal (1 subgoal):\n 1. F as body (Let as body) = F as' body' (Let as' body')", "have \"\\<dots> = F as' body' (Let as' body')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F (p \\<bullet> as) (p \\<bullet> body) (Let as body) =\n    F as' body' (Let as' body')", "by (simp add: assms(1))"], ["proof (state)\nthis:\n  F (p \\<bullet> as) (p \\<bullet> body) (Let as body) =\n  F as' body' (Let as' body')\n\ngoal (1 subgoal):\n 1. F as body (Let as body) = F as' body' (Let as' body')", "finally"], ["proof (chain)\npicking this:\n  F as body (Let as body) = F as' body' (Let as' body')", "show ?thesis"], ["proof (prove)\nusing this:\n  F as body (Let as body) = F as' body' (Let as' body')\n\ngoal (1 subgoal):\n 1. F as body (Let as body) = F as' body' (Let as' body')", "."], ["proof (state)\nthis:\n  F as body (Let as body) = F as' body' (Let as' body')\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>A smart constructor for lets\\<close>"], ["", "text \\<open>\nCertian program transformations might change the bound variables, possibly making it an empty list.\nThis smart constructor avoids the empty let in the resulting expression. Semantically, it should\nnot make a difference. \n\\<close>"], ["", "definition SmartLet :: \"heap => exp => exp\"\n  where \"SmartLet \\<Gamma> e = (if \\<Gamma> = [] then e else Let \\<Gamma> e)\""], ["", "lemma SmartLet_eqvt[eqvt]: \"\\<pi> \\<bullet> (SmartLet \\<Gamma> e) = SmartLet (\\<pi> \\<bullet> \\<Gamma>) (\\<pi> \\<bullet> e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> SmartLet \\<Gamma> e =\n    SmartLet (\\<pi> \\<bullet> \\<Gamma>) (\\<pi> \\<bullet> e)", "unfolding SmartLet_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> (if \\<Gamma> = [] then e else Let \\<Gamma> e) =\n    (if \\<pi> \\<bullet> \\<Gamma> = [] then \\<pi> \\<bullet> e\n     else Let (\\<pi> \\<bullet> \\<Gamma>) (\\<pi> \\<bullet> e))", "by perm_simp rule"], ["", "lemma SmartLet_supp:\n  \"supp (SmartLet \\<Gamma> e) = (supp e \\<union> supp \\<Gamma>) - atom ` (domA \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (SmartLet \\<Gamma> e) =\n    supp e \\<union> supp \\<Gamma> - atom ` domA \\<Gamma>", "unfolding SmartLet_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. supp (if \\<Gamma> = [] then e else Let \\<Gamma> e) =\n    supp e \\<union> supp \\<Gamma> - atom ` domA \\<Gamma>", "using Let_supp"], ["proof (prove)\nusing this:\n  supp (Let ?\\<Gamma> ?e) =\n  supp ?e \\<union> supp ?\\<Gamma> - atom ` domA ?\\<Gamma>\n\ngoal (1 subgoal):\n 1. supp (if \\<Gamma> = [] then e else Let \\<Gamma> e) =\n    supp e \\<union> supp \\<Gamma> - atom ` domA \\<Gamma>", "by (auto simp add: supp_Nil)"], ["", "lemma fv_SmartLet[simp]: \"fv (SmartLet \\<Gamma> e) = (fv \\<Gamma> \\<union> fv e) - domA \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (SmartLet \\<Gamma> e) = fv \\<Gamma> \\<union> fv e - domA \\<Gamma>", "unfolding SmartLet_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (if \\<Gamma> = [] then e else Let \\<Gamma> e) =\n    fv \\<Gamma> \\<union> fv e - domA \\<Gamma>", "by auto"], ["", "subsubsection \\<open>A predicate for value expressions\\<close>"], ["", "nominal_function isLam :: \"exp \\<Rightarrow> bool\" where\n  \"isLam (Var x) = False\" |\n  \"isLam (Lam [x]. e) = True\" |\n  \"isLam (App e x) = False\" |\n  \"isLam (Let as e) = False\" |\n  \"isLam (Bool b) = False\" |\n  \"isLam (scrut ? e1 : e2) = False\""], ["proof (prove)\ngoal (24 subgoals):\n 1. eqvt isLam_graph_aux\n 2. \\<And>x y. isLam_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       \\<lbrakk>\\<And>xa. x = Var xa \\<Longrightarrow> P;\n        \\<And>xa e. x = Lam [xa]. e \\<Longrightarrow> P;\n        \\<And>e xa. x = App e xa \\<Longrightarrow> P;\n        \\<And>as e. x = Let as e \\<Longrightarrow> P;\n        \\<And>b. x = Bool b \\<Longrightarrow> P;\n        \\<And>scrut e1 e2.\n           x = (scrut ? e1 : e2) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 4. \\<And>x xa. Var x = Var xa \\<Longrightarrow> False = False\n 5. \\<And>x xa e. Var x = Lam [xa]. e \\<Longrightarrow> False = True\n 6. \\<And>x e xa. Var x = App e xa \\<Longrightarrow> False = False\n 7. \\<And>x as e. Var x = Let as e \\<Longrightarrow> False = False\n 8. \\<And>x b. Var x = Bool b \\<Longrightarrow> False = False\n 9. \\<And>x scrut e1 e2.\n       Var x = (scrut ? e1 : e2) \\<Longrightarrow> False = False\n 10. \\<And>x e xa ea.\n        Lam [x]. e = Lam [xa]. ea \\<Longrightarrow> True = True\nA total of 24 subgoals...", "unfolding isLam_graph_aux_def eqvt_def"], ["proof (prove)\ngoal (24 subgoals):\n 1. \\<forall>p.\n       p \\<bullet> lfp (\\<lambda>p x1 x2.\n                           (\\<exists>isLam_aux x.\n                               x1 = Var x \\<and> x2 = False) \\<or>\n                           (\\<exists>isLam_aux x e.\n                               x1 = Lam [x]. e \\<and> x2 = True) \\<or>\n                           (\\<exists>isLam_aux e x.\n                               x1 = App e x \\<and> x2 = False) \\<or>\n                           (\\<exists>isLam_aux as e.\n                               x1 = Let as e \\<and> x2 = False) \\<or>\n                           (\\<exists>isLam_aux b.\n                               x1 = Bool b \\<and> x2 = False) \\<or>\n                           (\\<exists>isLam_aux scrut e1 e2.\n                               x1 = (scrut ? e1 : e2) \\<and> x2 = False)) =\n       lfp (\\<lambda>p x1 x2.\n               (\\<exists>isLam_aux x. x1 = Var x \\<and> x2 = False) \\<or>\n               (\\<exists>isLam_aux x e.\n                   x1 = Lam [x]. e \\<and> x2 = True) \\<or>\n               (\\<exists>isLam_aux e x.\n                   x1 = App e x \\<and> x2 = False) \\<or>\n               (\\<exists>isLam_aux as e.\n                   x1 = Let as e \\<and> x2 = False) \\<or>\n               (\\<exists>isLam_aux b. x1 = Bool b \\<and> x2 = False) \\<or>\n               (\\<exists>isLam_aux scrut e1 e2.\n                   x1 = (scrut ? e1 : e2) \\<and> x2 = False))\n 2. \\<And>x y. isLam_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       \\<lbrakk>\\<And>xa. x = Var xa \\<Longrightarrow> P;\n        \\<And>xa e. x = Lam [xa]. e \\<Longrightarrow> P;\n        \\<And>e xa. x = App e xa \\<Longrightarrow> P;\n        \\<And>as e. x = Let as e \\<Longrightarrow> P;\n        \\<And>b. x = Bool b \\<Longrightarrow> P;\n        \\<And>scrut e1 e2.\n           x = (scrut ? e1 : e2) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 4. \\<And>x xa. Var x = Var xa \\<Longrightarrow> False = False\n 5. \\<And>x xa e. Var x = Lam [xa]. e \\<Longrightarrow> False = True\n 6. \\<And>x e xa. Var x = App e xa \\<Longrightarrow> False = False\n 7. \\<And>x as e. Var x = Let as e \\<Longrightarrow> False = False\n 8. \\<And>x b. Var x = Bool b \\<Longrightarrow> False = False\n 9. \\<And>x scrut e1 e2.\n       Var x = (scrut ? e1 : e2) \\<Longrightarrow> False = False\n 10. \\<And>x e xa ea.\n        Lam [x]. e = Lam [xa]. ea \\<Longrightarrow> True = True\nA total of 24 subgoals...", "apply simp"], ["proof (prove)\ngoal (23 subgoals):\n 1. \\<And>x y. isLam_graph x y \\<Longrightarrow> True\n 2. \\<And>P x.\n       \\<lbrakk>\\<And>xa. x = Var xa \\<Longrightarrow> P;\n        \\<And>xa e. x = Lam [xa]. e \\<Longrightarrow> P;\n        \\<And>e xa. x = App e xa \\<Longrightarrow> P;\n        \\<And>as e. x = Let as e \\<Longrightarrow> P;\n        \\<And>b. x = Bool b \\<Longrightarrow> P;\n        \\<And>scrut e1 e2.\n           x = (scrut ? e1 : e2) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 3. \\<And>x xa. Var x = Var xa \\<Longrightarrow> False = False\n 4. \\<And>x xa e. Var x = Lam [xa]. e \\<Longrightarrow> False = True\n 5. \\<And>x e xa. Var x = App e xa \\<Longrightarrow> False = False\n 6. \\<And>x as e. Var x = Let as e \\<Longrightarrow> False = False\n 7. \\<And>x b. Var x = Bool b \\<Longrightarrow> False = False\n 8. \\<And>x scrut e1 e2.\n       Var x = (scrut ? e1 : e2) \\<Longrightarrow> False = False\n 9. \\<And>x e xa ea. Lam [x]. e = Lam [xa]. ea \\<Longrightarrow> True = True\n 10. \\<And>x e ea xa. Lam [x]. e = App ea xa \\<Longrightarrow> True = False\nA total of 23 subgoals...", "apply simp"], ["proof (prove)\ngoal (22 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>xa. x = Var xa \\<Longrightarrow> P;\n        \\<And>xa e. x = Lam [xa]. e \\<Longrightarrow> P;\n        \\<And>e xa. x = App e xa \\<Longrightarrow> P;\n        \\<And>as e. x = Let as e \\<Longrightarrow> P;\n        \\<And>b. x = Bool b \\<Longrightarrow> P;\n        \\<And>scrut e1 e2.\n           x = (scrut ? e1 : e2) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>x xa. Var x = Var xa \\<Longrightarrow> False = False\n 3. \\<And>x xa e. Var x = Lam [xa]. e \\<Longrightarrow> False = True\n 4. \\<And>x e xa. Var x = App e xa \\<Longrightarrow> False = False\n 5. \\<And>x as e. Var x = Let as e \\<Longrightarrow> False = False\n 6. \\<And>x b. Var x = Bool b \\<Longrightarrow> False = False\n 7. \\<And>x scrut e1 e2.\n       Var x = (scrut ? e1 : e2) \\<Longrightarrow> False = False\n 8. \\<And>x e xa ea. Lam [x]. e = Lam [xa]. ea \\<Longrightarrow> True = True\n 9. \\<And>x e ea xa. Lam [x]. e = App ea xa \\<Longrightarrow> True = False\n 10. \\<And>x e as ea. Lam [x]. e = Let as ea \\<Longrightarrow> True = False\nA total of 22 subgoals...", "apply (metis exp_strong_exhaust)"], ["proof (prove)\ngoal (21 subgoals):\n 1. \\<And>x xa. Var x = Var xa \\<Longrightarrow> False = False\n 2. \\<And>x xa e. Var x = Lam [xa]. e \\<Longrightarrow> False = True\n 3. \\<And>x e xa. Var x = App e xa \\<Longrightarrow> False = False\n 4. \\<And>x as e. Var x = Let as e \\<Longrightarrow> False = False\n 5. \\<And>x b. Var x = Bool b \\<Longrightarrow> False = False\n 6. \\<And>x scrut e1 e2.\n       Var x = (scrut ? e1 : e2) \\<Longrightarrow> False = False\n 7. \\<And>x e xa ea. Lam [x]. e = Lam [xa]. ea \\<Longrightarrow> True = True\n 8. \\<And>x e ea xa. Lam [x]. e = App ea xa \\<Longrightarrow> True = False\n 9. \\<And>x e as ea. Lam [x]. e = Let as ea \\<Longrightarrow> True = False\n 10. \\<And>x e b. Lam [x]. e = Bool b \\<Longrightarrow> True = False\nA total of 21 subgoals...", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. All isLam_dom", "by lexicographic_order"], ["", "lemma isLam_Lam: \"isLam (Lam [x]. e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isLam (Lam [x]. e)", "by simp"], ["", "lemma isLam_obtain_fresh:\n  assumes \"isLam z\"\n  obtains y e'\n  where \"z = (Lam [y]. e')\" and \"atom y \\<sharp> (c::'a::fs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y e'.\n        \\<lbrakk>z = Lam [y]. e'; atom y \\<sharp> c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  isLam z\n\ngoal (1 subgoal):\n 1. (\\<And>y e'.\n        \\<lbrakk>z = Lam [y]. e'; atom y \\<sharp> c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (nominal_induct z avoiding: c rule:exp_strong_induct) auto"], ["", "nominal_function isVal :: \"exp \\<Rightarrow> bool\" where\n  \"isVal (Var x) = False\" |\n  \"isVal (Lam [x]. e) = True\" |\n  \"isVal (App e x) = False\" |\n  \"isVal (Let as e) = False\" |\n  \"isVal (Bool b) = True\" |\n  \"isVal (scrut ? e1 : e2) = False\""], ["proof (prove)\ngoal (24 subgoals):\n 1. eqvt isVal_graph_aux\n 2. \\<And>x y. isVal_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       \\<lbrakk>\\<And>xa. x = Var xa \\<Longrightarrow> P;\n        \\<And>xa e. x = Lam [xa]. e \\<Longrightarrow> P;\n        \\<And>e xa. x = App e xa \\<Longrightarrow> P;\n        \\<And>as e. x = Let as e \\<Longrightarrow> P;\n        \\<And>b. x = Bool b \\<Longrightarrow> P;\n        \\<And>scrut e1 e2.\n           x = (scrut ? e1 : e2) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 4. \\<And>x xa. Var x = Var xa \\<Longrightarrow> False = False\n 5. \\<And>x xa e. Var x = Lam [xa]. e \\<Longrightarrow> False = True\n 6. \\<And>x e xa. Var x = App e xa \\<Longrightarrow> False = False\n 7. \\<And>x as e. Var x = Let as e \\<Longrightarrow> False = False\n 8. \\<And>x b. Var x = Bool b \\<Longrightarrow> False = True\n 9. \\<And>x scrut e1 e2.\n       Var x = (scrut ? e1 : e2) \\<Longrightarrow> False = False\n 10. \\<And>x e xa ea.\n        Lam [x]. e = Lam [xa]. ea \\<Longrightarrow> True = True\nA total of 24 subgoals...", "unfolding isVal_graph_aux_def eqvt_def"], ["proof (prove)\ngoal (24 subgoals):\n 1. \\<forall>p.\n       p \\<bullet> lfp (\\<lambda>p x1 x2.\n                           (\\<exists>isVal_aux x.\n                               x1 = Var x \\<and> x2 = False) \\<or>\n                           (\\<exists>isVal_aux x e.\n                               x1 = Lam [x]. e \\<and> x2 = True) \\<or>\n                           (\\<exists>isVal_aux e x.\n                               x1 = App e x \\<and> x2 = False) \\<or>\n                           (\\<exists>isVal_aux as e.\n                               x1 = Let as e \\<and> x2 = False) \\<or>\n                           (\\<exists>isVal_aux b.\n                               x1 = Bool b \\<and> x2 = True) \\<or>\n                           (\\<exists>isVal_aux scrut e1 e2.\n                               x1 = (scrut ? e1 : e2) \\<and> x2 = False)) =\n       lfp (\\<lambda>p x1 x2.\n               (\\<exists>isVal_aux x. x1 = Var x \\<and> x2 = False) \\<or>\n               (\\<exists>isVal_aux x e.\n                   x1 = Lam [x]. e \\<and> x2 = True) \\<or>\n               (\\<exists>isVal_aux e x.\n                   x1 = App e x \\<and> x2 = False) \\<or>\n               (\\<exists>isVal_aux as e.\n                   x1 = Let as e \\<and> x2 = False) \\<or>\n               (\\<exists>isVal_aux b. x1 = Bool b \\<and> x2 = True) \\<or>\n               (\\<exists>isVal_aux scrut e1 e2.\n                   x1 = (scrut ? e1 : e2) \\<and> x2 = False))\n 2. \\<And>x y. isVal_graph x y \\<Longrightarrow> True\n 3. \\<And>P x.\n       \\<lbrakk>\\<And>xa. x = Var xa \\<Longrightarrow> P;\n        \\<And>xa e. x = Lam [xa]. e \\<Longrightarrow> P;\n        \\<And>e xa. x = App e xa \\<Longrightarrow> P;\n        \\<And>as e. x = Let as e \\<Longrightarrow> P;\n        \\<And>b. x = Bool b \\<Longrightarrow> P;\n        \\<And>scrut e1 e2.\n           x = (scrut ? e1 : e2) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 4. \\<And>x xa. Var x = Var xa \\<Longrightarrow> False = False\n 5. \\<And>x xa e. Var x = Lam [xa]. e \\<Longrightarrow> False = True\n 6. \\<And>x e xa. Var x = App e xa \\<Longrightarrow> False = False\n 7. \\<And>x as e. Var x = Let as e \\<Longrightarrow> False = False\n 8. \\<And>x b. Var x = Bool b \\<Longrightarrow> False = True\n 9. \\<And>x scrut e1 e2.\n       Var x = (scrut ? e1 : e2) \\<Longrightarrow> False = False\n 10. \\<And>x e xa ea.\n        Lam [x]. e = Lam [xa]. ea \\<Longrightarrow> True = True\nA total of 24 subgoals...", "apply simp"], ["proof (prove)\ngoal (23 subgoals):\n 1. \\<And>x y. isVal_graph x y \\<Longrightarrow> True\n 2. \\<And>P x.\n       \\<lbrakk>\\<And>xa. x = Var xa \\<Longrightarrow> P;\n        \\<And>xa e. x = Lam [xa]. e \\<Longrightarrow> P;\n        \\<And>e xa. x = App e xa \\<Longrightarrow> P;\n        \\<And>as e. x = Let as e \\<Longrightarrow> P;\n        \\<And>b. x = Bool b \\<Longrightarrow> P;\n        \\<And>scrut e1 e2.\n           x = (scrut ? e1 : e2) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 3. \\<And>x xa. Var x = Var xa \\<Longrightarrow> False = False\n 4. \\<And>x xa e. Var x = Lam [xa]. e \\<Longrightarrow> False = True\n 5. \\<And>x e xa. Var x = App e xa \\<Longrightarrow> False = False\n 6. \\<And>x as e. Var x = Let as e \\<Longrightarrow> False = False\n 7. \\<And>x b. Var x = Bool b \\<Longrightarrow> False = True\n 8. \\<And>x scrut e1 e2.\n       Var x = (scrut ? e1 : e2) \\<Longrightarrow> False = False\n 9. \\<And>x e xa ea. Lam [x]. e = Lam [xa]. ea \\<Longrightarrow> True = True\n 10. \\<And>x e ea xa. Lam [x]. e = App ea xa \\<Longrightarrow> True = False\nA total of 23 subgoals...", "apply simp"], ["proof (prove)\ngoal (22 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>xa. x = Var xa \\<Longrightarrow> P;\n        \\<And>xa e. x = Lam [xa]. e \\<Longrightarrow> P;\n        \\<And>e xa. x = App e xa \\<Longrightarrow> P;\n        \\<And>as e. x = Let as e \\<Longrightarrow> P;\n        \\<And>b. x = Bool b \\<Longrightarrow> P;\n        \\<And>scrut e1 e2.\n           x = (scrut ? e1 : e2) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>x xa. Var x = Var xa \\<Longrightarrow> False = False\n 3. \\<And>x xa e. Var x = Lam [xa]. e \\<Longrightarrow> False = True\n 4. \\<And>x e xa. Var x = App e xa \\<Longrightarrow> False = False\n 5. \\<And>x as e. Var x = Let as e \\<Longrightarrow> False = False\n 6. \\<And>x b. Var x = Bool b \\<Longrightarrow> False = True\n 7. \\<And>x scrut e1 e2.\n       Var x = (scrut ? e1 : e2) \\<Longrightarrow> False = False\n 8. \\<And>x e xa ea. Lam [x]. e = Lam [xa]. ea \\<Longrightarrow> True = True\n 9. \\<And>x e ea xa. Lam [x]. e = App ea xa \\<Longrightarrow> True = False\n 10. \\<And>x e as ea. Lam [x]. e = Let as ea \\<Longrightarrow> True = False\nA total of 22 subgoals...", "apply (metis exp_strong_exhaust)"], ["proof (prove)\ngoal (21 subgoals):\n 1. \\<And>x xa. Var x = Var xa \\<Longrightarrow> False = False\n 2. \\<And>x xa e. Var x = Lam [xa]. e \\<Longrightarrow> False = True\n 3. \\<And>x e xa. Var x = App e xa \\<Longrightarrow> False = False\n 4. \\<And>x as e. Var x = Let as e \\<Longrightarrow> False = False\n 5. \\<And>x b. Var x = Bool b \\<Longrightarrow> False = True\n 6. \\<And>x scrut e1 e2.\n       Var x = (scrut ? e1 : e2) \\<Longrightarrow> False = False\n 7. \\<And>x e xa ea. Lam [x]. e = Lam [xa]. ea \\<Longrightarrow> True = True\n 8. \\<And>x e ea xa. Lam [x]. e = App ea xa \\<Longrightarrow> True = False\n 9. \\<And>x e as ea. Lam [x]. e = Let as ea \\<Longrightarrow> True = False\n 10. \\<And>x e b. Lam [x]. e = Bool b \\<Longrightarrow> True = True\nA total of 21 subgoals...", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "nominal_termination (eqvt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. All isVal_dom", "by lexicographic_order"], ["", "lemma isVal_Lam: \"isVal (Lam [x]. e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isVal (Lam [x]. e)", "by simp"], ["", "lemma isVal_Bool: \"isVal (Bool b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isVal (Bool b)", "by simp"], ["", "subsubsection \\<open>The notion of thunks\\<close>"], ["", "(*\nfun thunks :: \"heap \\<Rightarrow> var set\" where\n  \"thunks [] = {}\"\n  | \"thunks ((x,e)#\\<Gamma>) = (if isLam e then {} else {x}) \\<union> thunks \\<Gamma>\"\n*)"], ["", "definition thunks :: \"heap \\<Rightarrow> var set\" where\n  \"thunks \\<Gamma> = {x . case map_of \\<Gamma> x of Some e \\<Rightarrow> \\<not> isVal e | None \\<Rightarrow> False}\""], ["", "lemma thunks_Nil[simp]: \"thunks [] = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thunks [] = {}", "by (auto simp add: thunks_def)"], ["", "lemma thunks_domA: \"thunks \\<Gamma> \\<subseteq> domA \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thunks \\<Gamma> \\<subseteq> domA \\<Gamma>", "by (induction \\<Gamma> ) (auto simp add: thunks_def)"], ["", "lemma thunks_Cons: \"thunks ((x,e)#\\<Gamma>) = (if isVal e then thunks \\<Gamma> - {x} else insert x (thunks \\<Gamma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thunks ((x, e) # \\<Gamma>) =\n    (if isVal e then thunks \\<Gamma> - {x} else insert x (thunks \\<Gamma>))", "by (auto simp add: thunks_def )"], ["", "lemma thunks_append[simp]: \"thunks (\\<Delta>@\\<Gamma>) = thunks \\<Delta> \\<union> (thunks \\<Gamma> - domA \\<Delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thunks (\\<Delta> @ \\<Gamma>) =\n    thunks \\<Delta> \\<union> (thunks \\<Gamma> - domA \\<Delta>)", "by (induction \\<Delta>) (auto simp add: thunks_def )"], ["", "lemma thunks_delete[simp]: \"thunks (delete x \\<Gamma>) = thunks \\<Gamma> - {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. thunks (delete x \\<Gamma>) = thunks \\<Gamma> - {x}", "by (induction \\<Gamma>) (auto simp add: thunks_def )"], ["", "lemma thunksI[intro]: \"map_of \\<Gamma> x = Some e \\<Longrightarrow> \\<not> isVal e \\<Longrightarrow> x \\<in> thunks \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>map_of \\<Gamma> x = Some e; \\<not> isVal e\\<rbrakk>\n    \\<Longrightarrow> x \\<in> thunks \\<Gamma>", "by (induction \\<Gamma>) (auto simp add: thunks_def )"], ["", "lemma thunksE[intro]: \"x \\<in> thunks \\<Gamma> \\<Longrightarrow> map_of \\<Gamma> x = Some e \\<Longrightarrow> \\<not> isVal e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> thunks \\<Gamma>; map_of \\<Gamma> x = Some e\\<rbrakk>\n    \\<Longrightarrow> \\<not> isVal e", "by (induction \\<Gamma>) (auto simp add: thunks_def )"], ["", "lemma thunks_cong: \"map_of \\<Gamma> = map_of \\<Delta> \\<Longrightarrow> thunks \\<Gamma> = thunks \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of \\<Gamma> = map_of \\<Delta> \\<Longrightarrow>\n    thunks \\<Gamma> = thunks \\<Delta>", "by (simp add: thunks_def)"], ["", "lemma thunks_eqvt[eqvt]:\n  \"\\<pi> \\<bullet> thunks \\<Gamma> = thunks (\\<pi> \\<bullet> \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> thunks \\<Gamma> = thunks (\\<pi> \\<bullet> \\<Gamma>)", "unfolding thunks_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> \\<bullet> {x. case map_of \\<Gamma> x of None \\<Rightarrow> False\n                        | Some e \\<Rightarrow> \\<not> isVal e} =\n    {x. case map_of (\\<pi> \\<bullet> \\<Gamma>) x of None \\<Rightarrow> False\n        | Some e \\<Rightarrow> \\<not> isVal e}", "by perm_simp rule"], ["", "subsubsection \\<open>Non-recursive Let bindings\\<close>"], ["", "definition nonrec :: \"heap \\<Rightarrow> bool\" where\n  \"nonrec \\<Gamma> = (\\<exists> x e. \\<Gamma> = [(x,e)] \\<and> x \\<notin> fv e)\""], ["", "lemma nonrecE:\n  assumes \"nonrec \\<Gamma>\"\n  obtains x e where \"\\<Gamma> = [(x,e)]\" and \"x \\<notin> fv e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x e.\n        \\<lbrakk>\\<Gamma> = [(x, e)]; x \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  nonrec \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<And>x e.\n        \\<lbrakk>\\<Gamma> = [(x, e)]; x \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding nonrec_def"], ["proof (prove)\nusing this:\n  \\<exists>x e. \\<Gamma> = [(x, e)] \\<and> x \\<notin> fv e\n\ngoal (1 subgoal):\n 1. (\\<And>x e.\n        \\<lbrakk>\\<Gamma> = [(x, e)]; x \\<notin> fv e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "lemma nonrec_eqvt[eqvt]:\n  \"nonrec \\<Gamma> \\<Longrightarrow> nonrec (\\<pi> \\<bullet> \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonrec \\<Gamma> \\<Longrightarrow> nonrec (\\<pi> \\<bullet> \\<Gamma>)", "apply (erule nonrecE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x e.\n       \\<lbrakk>\\<Gamma> = [(x, e)]; x \\<notin> fv e\\<rbrakk>\n       \\<Longrightarrow> nonrec (\\<pi> \\<bullet> \\<Gamma>)", "apply (auto simp add: nonrec_def fv_def fresh_def )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x e.\n       \\<lbrakk>\\<Gamma> = [(x, e)]; atom x \\<notin> supp e;\n        atom (\\<pi> \\<bullet> x) \\<in> supp (\\<pi> \\<bullet> e)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis fresh_at_base_permute_iff fresh_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma exp_induct_rec[case_names Var App Let Let_nonrec Lam Bool IfThenElse]:\n  assumes \"\\<And>var. P (Var var)\"\n  assumes \"\\<And>exp var. P exp \\<Longrightarrow> P (App exp var)\"\n  assumes \"\\<And>\\<Gamma> exp. \\<not> nonrec \\<Gamma> \\<Longrightarrow> (\\<And> x. x \\<in> domA \\<Gamma> \\<Longrightarrow>  P (the (map_of \\<Gamma> x))) \\<Longrightarrow> P exp \\<Longrightarrow> P (Let \\<Gamma> exp)\"\n  assumes \"\\<And>x e exp. x \\<notin> fv e \\<Longrightarrow> P e \\<Longrightarrow> P exp \\<Longrightarrow> P (let x be e in exp)\"\n  assumes \"\\<And>var exp.  P exp \\<Longrightarrow> P (Lam [var]. exp)\"\n  assumes \"\\<And>b. P (Bool b)\"\n  assumes \"\\<And> scrut e1 e2. P scrut \\<Longrightarrow> P e1 \\<Longrightarrow> P e2 \\<Longrightarrow> P (scrut ? e1 : e2)\"\n  shows \"P exp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P exp", "apply (rule exp_induct[of P])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>var. P (Var var)\n 2. \\<And>exp var. P exp \\<Longrightarrow> P (App exp var)\n 3. \\<And>\\<Gamma> exp.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> domA \\<Gamma> \\<Longrightarrow>\n                   P (the (map_of \\<Gamma> x));\n        P exp\\<rbrakk>\n       \\<Longrightarrow> P (Let \\<Gamma> exp)\n 4. \\<And>var exp. P exp \\<Longrightarrow> P (Lam [var]. exp)\n 5. \\<And>b. P (Bool b)\n 6. \\<And>scrut e1 e2.\n       \\<lbrakk>P scrut; P e1; P e2\\<rbrakk>\n       \\<Longrightarrow> P (scrut ? e1 : e2)", "apply (metis assms(1))"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>exp var. P exp \\<Longrightarrow> P (App exp var)\n 2. \\<And>\\<Gamma> exp.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> domA \\<Gamma> \\<Longrightarrow>\n                   P (the (map_of \\<Gamma> x));\n        P exp\\<rbrakk>\n       \\<Longrightarrow> P (Let \\<Gamma> exp)\n 3. \\<And>var exp. P exp \\<Longrightarrow> P (Lam [var]. exp)\n 4. \\<And>b. P (Bool b)\n 5. \\<And>scrut e1 e2.\n       \\<lbrakk>P scrut; P e1; P e2\\<rbrakk>\n       \\<Longrightarrow> P (scrut ? e1 : e2)", "apply (metis assms(2))"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> exp.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> domA \\<Gamma> \\<Longrightarrow>\n                   P (the (map_of \\<Gamma> x));\n        P exp\\<rbrakk>\n       \\<Longrightarrow> P (Let \\<Gamma> exp)\n 2. \\<And>var exp. P exp \\<Longrightarrow> P (Lam [var]. exp)\n 3. \\<And>b. P (Bool b)\n 4. \\<And>scrut e1 e2.\n       \\<lbrakk>P scrut; P e1; P e2\\<rbrakk>\n       \\<Longrightarrow> P (scrut ? e1 : e2)", "apply (case_tac \"nonrec \\<Gamma>\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> exp.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> domA \\<Gamma> \\<Longrightarrow>\n                   P (the (map_of \\<Gamma> x));\n        P exp; nonrec \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> P (Let \\<Gamma> exp)\n 2. \\<And>\\<Gamma> exp.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> domA \\<Gamma> \\<Longrightarrow>\n                   P (the (map_of \\<Gamma> x));\n        P exp; \\<not> nonrec \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> P (Let \\<Gamma> exp)\n 3. \\<And>var exp. P exp \\<Longrightarrow> P (Lam [var]. exp)\n 4. \\<And>b. P (Bool b)\n 5. \\<And>scrut e1 e2.\n       \\<lbrakk>P scrut; P e1; P e2\\<rbrakk>\n       \\<Longrightarrow> P (scrut ? e1 : e2)", "apply (erule nonrecE)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> exp x e.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> domA \\<Gamma> \\<Longrightarrow>\n                   P (the (map_of \\<Gamma> x));\n        P exp; \\<Gamma> = [(x, e)]; x \\<notin> fv e\\<rbrakk>\n       \\<Longrightarrow> P (Let \\<Gamma> exp)\n 2. \\<And>\\<Gamma> exp.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> domA \\<Gamma> \\<Longrightarrow>\n                   P (the (map_of \\<Gamma> x));\n        P exp; \\<not> nonrec \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> P (Let \\<Gamma> exp)\n 3. \\<And>var exp. P exp \\<Longrightarrow> P (Lam [var]. exp)\n 4. \\<And>b. P (Bool b)\n 5. \\<And>scrut e1 e2.\n       \\<lbrakk>P scrut; P e1; P e2\\<rbrakk>\n       \\<Longrightarrow> P (scrut ? e1 : e2)", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> exp x e.\n       \\<lbrakk>P e; P exp; \\<Gamma> = [(x, e)]; x \\<notin> fv e\\<rbrakk>\n       \\<Longrightarrow> P (let x be e in exp )\n 2. \\<And>\\<Gamma> exp.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> domA \\<Gamma> \\<Longrightarrow>\n                   P (the (map_of \\<Gamma> x));\n        P exp; \\<not> nonrec \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> P (Let \\<Gamma> exp)\n 3. \\<And>var exp. P exp \\<Longrightarrow> P (Lam [var]. exp)\n 4. \\<And>b. P (Bool b)\n 5. \\<And>scrut e1 e2.\n       \\<lbrakk>P scrut; P e1; P e2\\<rbrakk>\n       \\<Longrightarrow> P (scrut ? e1 : e2)", "apply (metis assms(4))"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> exp.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> domA \\<Gamma> \\<Longrightarrow>\n                   P (the (map_of \\<Gamma> x));\n        P exp; \\<not> nonrec \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> P (Let \\<Gamma> exp)\n 2. \\<And>var exp. P exp \\<Longrightarrow> P (Lam [var]. exp)\n 3. \\<And>b. P (Bool b)\n 4. \\<And>scrut e1 e2.\n       \\<lbrakk>P scrut; P e1; P e2\\<rbrakk>\n       \\<Longrightarrow> P (scrut ? e1 : e2)", "apply (metis assms(3))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>var exp. P exp \\<Longrightarrow> P (Lam [var]. exp)\n 2. \\<And>b. P (Bool b)\n 3. \\<And>scrut e1 e2.\n       \\<lbrakk>P scrut; P e1; P e2\\<rbrakk>\n       \\<Longrightarrow> P (scrut ? e1 : e2)", "apply (metis assms(5))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b. P (Bool b)\n 2. \\<And>scrut e1 e2.\n       \\<lbrakk>P scrut; P e1; P e2\\<rbrakk>\n       \\<Longrightarrow> P (scrut ? e1 : e2)", "apply (metis assms(6))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>scrut e1 e2.\n       \\<lbrakk>P scrut; P e1; P e2\\<rbrakk>\n       \\<Longrightarrow> P (scrut ? e1 : e2)", "apply (metis assms(7))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma  exp_strong_induct_rec[case_names Var App Let Let_nonrec Lam Bool IfThenElse]:\n  assumes \"\\<And>var c. P c (Var var)\"\n  assumes \"\\<And>exp var c. (\\<And>c. P c exp) \\<Longrightarrow> P c (App exp var)\"\n  assumes \"\\<And>\\<Gamma> exp c.\n    atom ` domA \\<Gamma> \\<sharp>* c \\<Longrightarrow> \\<not> nonrec \\<Gamma> \\<Longrightarrow> (\\<And>c x. x \\<in> domA \\<Gamma> \\<Longrightarrow>  P c (the (map_of \\<Gamma> x))) \\<Longrightarrow> (\\<And>c. P c exp) \\<Longrightarrow> P c (Let \\<Gamma> exp)\"\n  assumes \"\\<And>x e exp c. {atom x} \\<sharp>* c \\<Longrightarrow> x \\<notin> fv e \\<Longrightarrow> (\\<And> c. P c e) \\<Longrightarrow> (\\<And> c. P c exp) \\<Longrightarrow> P c (let x be e in exp)\"\n  assumes \"\\<And>var exp c. {atom var} \\<sharp>* c \\<Longrightarrow> (\\<And>c. P c exp) \\<Longrightarrow> P c (Lam [var]. exp)\"\n  assumes \"\\<And>b c. P c (Bool b)\"\n  assumes \"\\<And> scrut e1 e2 c. (\\<And> c. P c scrut) \\<Longrightarrow> (\\<And> c. P c e1) \\<Longrightarrow> (\\<And> c. P c e2) \\<Longrightarrow> P c (scrut ? e1 : e2)\"\n  shows \"P (c::'a::fs) exp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P c exp", "apply (rule exp_strong_induct[of P])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>var c. P c (Var var)\n 2. \\<And>exp var c. (\\<And>c. P c exp) \\<Longrightarrow> P c (App exp var)\n 3. \\<And>\\<Gamma> exp c.\n       \\<lbrakk>atom ` domA \\<Gamma> \\<sharp>* c;\n        \\<And>c x.\n           x \\<in> domA \\<Gamma> \\<Longrightarrow>\n           P c (the (map_of \\<Gamma> x));\n        \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Let \\<Gamma> exp)\n 4. \\<And>var exp c.\n       \\<lbrakk>{atom var} \\<sharp>* c; \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Lam [var]. exp)\n 5. \\<And>b c. P c (Bool b)\n 6. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)", "apply (metis assms(1))"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>exp var c. (\\<And>c. P c exp) \\<Longrightarrow> P c (App exp var)\n 2. \\<And>\\<Gamma> exp c.\n       \\<lbrakk>atom ` domA \\<Gamma> \\<sharp>* c;\n        \\<And>c x.\n           x \\<in> domA \\<Gamma> \\<Longrightarrow>\n           P c (the (map_of \\<Gamma> x));\n        \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Let \\<Gamma> exp)\n 3. \\<And>var exp c.\n       \\<lbrakk>{atom var} \\<sharp>* c; \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Lam [var]. exp)\n 4. \\<And>b c. P c (Bool b)\n 5. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)", "apply (metis assms(2))"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> exp c.\n       \\<lbrakk>atom ` domA \\<Gamma> \\<sharp>* c;\n        \\<And>c x.\n           x \\<in> domA \\<Gamma> \\<Longrightarrow>\n           P c (the (map_of \\<Gamma> x));\n        \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Let \\<Gamma> exp)\n 2. \\<And>var exp c.\n       \\<lbrakk>{atom var} \\<sharp>* c; \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Lam [var]. exp)\n 3. \\<And>b c. P c (Bool b)\n 4. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)", "apply (case_tac \"nonrec \\<Gamma>\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> exp c.\n       \\<lbrakk>atom ` domA \\<Gamma> \\<sharp>* c;\n        \\<And>c x.\n           x \\<in> domA \\<Gamma> \\<Longrightarrow>\n           P c (the (map_of \\<Gamma> x));\n        \\<And>c. P c exp; nonrec \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> P c (Let \\<Gamma> exp)\n 2. \\<And>\\<Gamma> exp c.\n       \\<lbrakk>atom ` domA \\<Gamma> \\<sharp>* c;\n        \\<And>c x.\n           x \\<in> domA \\<Gamma> \\<Longrightarrow>\n           P c (the (map_of \\<Gamma> x));\n        \\<And>c. P c exp; \\<not> nonrec \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> P c (Let \\<Gamma> exp)\n 3. \\<And>var exp c.\n       \\<lbrakk>{atom var} \\<sharp>* c; \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Lam [var]. exp)\n 4. \\<And>b c. P c (Bool b)\n 5. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)", "apply (erule nonrecE)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> exp c x e.\n       \\<lbrakk>atom ` domA \\<Gamma> \\<sharp>* c;\n        \\<And>c x.\n           x \\<in> domA \\<Gamma> \\<Longrightarrow>\n           P c (the (map_of \\<Gamma> x));\n        \\<And>c. P c exp; \\<Gamma> = [(x, e)]; x \\<notin> fv e\\<rbrakk>\n       \\<Longrightarrow> P c (Let \\<Gamma> exp)\n 2. \\<And>\\<Gamma> exp c.\n       \\<lbrakk>atom ` domA \\<Gamma> \\<sharp>* c;\n        \\<And>c x.\n           x \\<in> domA \\<Gamma> \\<Longrightarrow>\n           P c (the (map_of \\<Gamma> x));\n        \\<And>c. P c exp; \\<not> nonrec \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> P c (Let \\<Gamma> exp)\n 3. \\<And>var exp c.\n       \\<lbrakk>{atom var} \\<sharp>* c; \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Lam [var]. exp)\n 4. \\<And>b c. P c (Bool b)\n 5. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> exp c x e.\n       \\<lbrakk>{atom x} \\<sharp>* c; \\<And>c. P c e; \\<And>c. P c exp;\n        \\<Gamma> = [(x, e)]; x \\<notin> fv e\\<rbrakk>\n       \\<Longrightarrow> P c (let x be e in exp )\n 2. \\<And>\\<Gamma> exp c.\n       \\<lbrakk>atom ` domA \\<Gamma> \\<sharp>* c;\n        \\<And>c x.\n           x \\<in> domA \\<Gamma> \\<Longrightarrow>\n           P c (the (map_of \\<Gamma> x));\n        \\<And>c. P c exp; \\<not> nonrec \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> P c (Let \\<Gamma> exp)\n 3. \\<And>var exp c.\n       \\<lbrakk>{atom var} \\<sharp>* c; \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Lam [var]. exp)\n 4. \\<And>b c. P c (Bool b)\n 5. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)", "apply (metis assms(4))"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> exp c.\n       \\<lbrakk>atom ` domA \\<Gamma> \\<sharp>* c;\n        \\<And>c x.\n           x \\<in> domA \\<Gamma> \\<Longrightarrow>\n           P c (the (map_of \\<Gamma> x));\n        \\<And>c. P c exp; \\<not> nonrec \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> P c (Let \\<Gamma> exp)\n 2. \\<And>var exp c.\n       \\<lbrakk>{atom var} \\<sharp>* c; \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Lam [var]. exp)\n 3. \\<And>b c. P c (Bool b)\n 4. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)", "apply (metis assms(3))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>var exp c.\n       \\<lbrakk>{atom var} \\<sharp>* c; \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Lam [var]. exp)\n 2. \\<And>b c. P c (Bool b)\n 3. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)", "apply (metis assms(5))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b c. P c (Bool b)\n 2. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)", "apply (metis assms(6))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)", "apply (metis assms(7))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma  exp_strong_induct_rec_set[case_names Var App Let Let_nonrec Lam Bool IfThenElse]:\n  assumes \"\\<And>var c. P c (Var var)\"\n  assumes \"\\<And>exp var c. (\\<And>c. P c exp) \\<Longrightarrow> P c (App exp var)\"\n  assumes \"\\<And>\\<Gamma> exp c.\n    atom ` domA \\<Gamma> \\<sharp>* c \\<Longrightarrow> \\<not> nonrec \\<Gamma> \\<Longrightarrow> (\\<And>c x e. (x,e) \\<in> set \\<Gamma> \\<Longrightarrow>  P c e) \\<Longrightarrow> (\\<And>c. P c exp) \\<Longrightarrow> P c (Let \\<Gamma> exp)\"\n  assumes \"\\<And>x e exp c. {atom x} \\<sharp>* c \\<Longrightarrow> x \\<notin> fv e \\<Longrightarrow> (\\<And> c. P c e) \\<Longrightarrow> (\\<And> c. P c exp) \\<Longrightarrow> P c (let x be e in exp)\"\n  assumes \"\\<And>var exp c. {atom var} \\<sharp>* c \\<Longrightarrow> (\\<And>c. P c exp) \\<Longrightarrow> P c (Lam [var]. exp)\"\n  assumes \"\\<And>b c. P c (Bool b)\"\n  assumes \"\\<And> scrut e1 e2 c. (\\<And> c. P c scrut) \\<Longrightarrow> (\\<And> c. P c e1) \\<Longrightarrow> (\\<And> c. P c e2) \\<Longrightarrow> P c (scrut ? e1 : e2)\"\n  shows \"P (c::'a::fs) exp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P c exp", "apply (rule exp_strong_induct_set(1)[of P])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>var c. P c (Var var)\n 2. \\<And>exp var c. (\\<And>c. P c exp) \\<Longrightarrow> P c (App exp var)\n 3. \\<And>\\<Gamma> exp c.\n       \\<lbrakk>atom ` domA \\<Gamma> \\<sharp>* c;\n        \\<And>c x e. (x, e) \\<in> set \\<Gamma> \\<Longrightarrow> P c e;\n        \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Let \\<Gamma> exp)\n 4. \\<And>var exp c.\n       \\<lbrakk>{atom var} \\<sharp>* c; \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Lam [var]. exp)\n 5. \\<And>b c. P c (Bool b)\n 6. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)", "apply (metis assms(1))"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>exp var c. (\\<And>c. P c exp) \\<Longrightarrow> P c (App exp var)\n 2. \\<And>\\<Gamma> exp c.\n       \\<lbrakk>atom ` domA \\<Gamma> \\<sharp>* c;\n        \\<And>c x e. (x, e) \\<in> set \\<Gamma> \\<Longrightarrow> P c e;\n        \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Let \\<Gamma> exp)\n 3. \\<And>var exp c.\n       \\<lbrakk>{atom var} \\<sharp>* c; \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Lam [var]. exp)\n 4. \\<And>b c. P c (Bool b)\n 5. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)", "apply (metis assms(2))"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> exp c.\n       \\<lbrakk>atom ` domA \\<Gamma> \\<sharp>* c;\n        \\<And>c x e. (x, e) \\<in> set \\<Gamma> \\<Longrightarrow> P c e;\n        \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Let \\<Gamma> exp)\n 2. \\<And>var exp c.\n       \\<lbrakk>{atom var} \\<sharp>* c; \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Lam [var]. exp)\n 3. \\<And>b c. P c (Bool b)\n 4. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)", "apply (case_tac \"nonrec \\<Gamma>\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> exp c.\n       \\<lbrakk>atom ` domA \\<Gamma> \\<sharp>* c;\n        \\<And>c x e. (x, e) \\<in> set \\<Gamma> \\<Longrightarrow> P c e;\n        \\<And>c. P c exp; nonrec \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> P c (Let \\<Gamma> exp)\n 2. \\<And>\\<Gamma> exp c.\n       \\<lbrakk>atom ` domA \\<Gamma> \\<sharp>* c;\n        \\<And>c x e. (x, e) \\<in> set \\<Gamma> \\<Longrightarrow> P c e;\n        \\<And>c. P c exp; \\<not> nonrec \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> P c (Let \\<Gamma> exp)\n 3. \\<And>var exp c.\n       \\<lbrakk>{atom var} \\<sharp>* c; \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Lam [var]. exp)\n 4. \\<And>b c. P c (Bool b)\n 5. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)", "apply (erule nonrecE)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> exp c x e.\n       \\<lbrakk>atom ` domA \\<Gamma> \\<sharp>* c;\n        \\<And>c x e. (x, e) \\<in> set \\<Gamma> \\<Longrightarrow> P c e;\n        \\<And>c. P c exp; \\<Gamma> = [(x, e)]; x \\<notin> fv e\\<rbrakk>\n       \\<Longrightarrow> P c (Let \\<Gamma> exp)\n 2. \\<And>\\<Gamma> exp c.\n       \\<lbrakk>atom ` domA \\<Gamma> \\<sharp>* c;\n        \\<And>c x e. (x, e) \\<in> set \\<Gamma> \\<Longrightarrow> P c e;\n        \\<And>c. P c exp; \\<not> nonrec \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> P c (Let \\<Gamma> exp)\n 3. \\<And>var exp c.\n       \\<lbrakk>{atom var} \\<sharp>* c; \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Lam [var]. exp)\n 4. \\<And>b c. P c (Bool b)\n 5. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> exp c x e.\n       \\<lbrakk>{atom x} \\<sharp>* c; \\<And>c. P c e; \\<And>c. P c exp;\n        \\<Gamma> = [(x, e)]; x \\<notin> fv e\\<rbrakk>\n       \\<Longrightarrow> P c (let x be e in exp )\n 2. \\<And>\\<Gamma> exp c.\n       \\<lbrakk>atom ` domA \\<Gamma> \\<sharp>* c;\n        \\<And>c x e. (x, e) \\<in> set \\<Gamma> \\<Longrightarrow> P c e;\n        \\<And>c. P c exp; \\<not> nonrec \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> P c (Let \\<Gamma> exp)\n 3. \\<And>var exp c.\n       \\<lbrakk>{atom var} \\<sharp>* c; \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Lam [var]. exp)\n 4. \\<And>b c. P c (Bool b)\n 5. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)", "apply (metis assms(4))"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma> exp c.\n       \\<lbrakk>atom ` domA \\<Gamma> \\<sharp>* c;\n        \\<And>c x e. (x, e) \\<in> set \\<Gamma> \\<Longrightarrow> P c e;\n        \\<And>c. P c exp; \\<not> nonrec \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> P c (Let \\<Gamma> exp)\n 2. \\<And>var exp c.\n       \\<lbrakk>{atom var} \\<sharp>* c; \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Lam [var]. exp)\n 3. \\<And>b c. P c (Bool b)\n 4. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)", "apply (metis assms(3))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>var exp c.\n       \\<lbrakk>{atom var} \\<sharp>* c; \\<And>c. P c exp\\<rbrakk>\n       \\<Longrightarrow> P c (Lam [var]. exp)\n 2. \\<And>b c. P c (Bool b)\n 3. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)", "apply (metis assms(5))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b c. P c (Bool b)\n 2. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)", "apply (metis assms(6))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>scrut e1 e2 c.\n       \\<lbrakk>\\<And>c. P c scrut; \\<And>c. P c e1;\n        \\<And>c. P c e2\\<rbrakk>\n       \\<Longrightarrow> P c (scrut ? e1 : e2)", "apply (metis assms(7))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Renaming a lambda-bound variable\\<close>"], ["", "lemma change_Lam_Variable:\n  assumes \"y' \\<noteq> y \\<Longrightarrow> atom y' \\<sharp> (e,  y)\"\n  shows   \"Lam [y]. e =  Lam [y']. ((y \\<leftrightarrow> y') \\<bullet> e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lam [y]. e = Lam [y']. ((y \\<leftrightarrow> y') \\<bullet> e)", "proof(cases \"y' = y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y' = y \\<Longrightarrow>\n    Lam [y]. e = Lam [y']. ((y \\<leftrightarrow> y') \\<bullet> e)\n 2. y' \\<noteq> y \\<Longrightarrow>\n    Lam [y]. e = Lam [y']. ((y \\<leftrightarrow> y') \\<bullet> e)", "case True"], ["proof (state)\nthis:\n  y' = y\n\ngoal (2 subgoals):\n 1. y' = y \\<Longrightarrow>\n    Lam [y]. e = Lam [y']. ((y \\<leftrightarrow> y') \\<bullet> e)\n 2. y' \\<noteq> y \\<Longrightarrow>\n    Lam [y]. e = Lam [y']. ((y \\<leftrightarrow> y') \\<bullet> e)", "thus ?thesis"], ["proof (prove)\nusing this:\n  y' = y\n\ngoal (1 subgoal):\n 1. Lam [y]. e = Lam [y']. ((y \\<leftrightarrow> y') \\<bullet> e)", "by simp"], ["proof (state)\nthis:\n  Lam [y]. e = Lam [y']. ((y \\<leftrightarrow> y') \\<bullet> e)\n\ngoal (1 subgoal):\n 1. y' \\<noteq> y \\<Longrightarrow>\n    Lam [y]. e = Lam [y']. ((y \\<leftrightarrow> y') \\<bullet> e)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y' \\<noteq> y \\<Longrightarrow>\n    Lam [y]. e = Lam [y']. ((y \\<leftrightarrow> y') \\<bullet> e)", "case False"], ["proof (state)\nthis:\n  y' \\<noteq> y\n\ngoal (1 subgoal):\n 1. y' \\<noteq> y \\<Longrightarrow>\n    Lam [y]. e = Lam [y']. ((y \\<leftrightarrow> y') \\<bullet> e)", "from assms[OF this]"], ["proof (chain)\npicking this:\n  atom y' \\<sharp> (e, y)", "have \"(y \\<leftrightarrow> y') \\<bullet> (Lam [y]. e) = Lam [y]. e\""], ["proof (prove)\nusing this:\n  atom y' \\<sharp> (e, y)\n\ngoal (1 subgoal):\n 1. (y \\<leftrightarrow> y') \\<bullet> Lam [y]. e = Lam [y]. e", "by -(rule flip_fresh_fresh, (simp add: fresh_Pair)+)"], ["proof (state)\nthis:\n  (y \\<leftrightarrow> y') \\<bullet> Lam [y]. e = Lam [y]. e\n\ngoal (1 subgoal):\n 1. y' \\<noteq> y \\<Longrightarrow>\n    Lam [y]. e = Lam [y']. ((y \\<leftrightarrow> y') \\<bullet> e)", "moreover"], ["proof (state)\nthis:\n  (y \\<leftrightarrow> y') \\<bullet> Lam [y]. e = Lam [y]. e\n\ngoal (1 subgoal):\n 1. y' \\<noteq> y \\<Longrightarrow>\n    Lam [y]. e = Lam [y']. ((y \\<leftrightarrow> y') \\<bullet> e)", "have \"(y \\<leftrightarrow> y') \\<bullet> (Lam [y]. e) = Lam [y']. ((y \\<leftrightarrow> y') \\<bullet> e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<leftrightarrow> y') \\<bullet> Lam [y]. e =\n    Lam [y']. ((y \\<leftrightarrow> y') \\<bullet> e)", "by simp"], ["proof (state)\nthis:\n  (y \\<leftrightarrow> y') \\<bullet> Lam [y]. e =\n  Lam [y']. ((y \\<leftrightarrow> y') \\<bullet> e)\n\ngoal (1 subgoal):\n 1. y' \\<noteq> y \\<Longrightarrow>\n    Lam [y]. e = Lam [y']. ((y \\<leftrightarrow> y') \\<bullet> e)", "ultimately"], ["proof (chain)\npicking this:\n  (y \\<leftrightarrow> y') \\<bullet> Lam [y]. e = Lam [y]. e\n  (y \\<leftrightarrow> y') \\<bullet> Lam [y]. e =\n  Lam [y']. ((y \\<leftrightarrow> y') \\<bullet> e)", "show \"Lam [y]. e =  Lam [y']. ((y \\<leftrightarrow> y') \\<bullet> e)\""], ["proof (prove)\nusing this:\n  (y \\<leftrightarrow> y') \\<bullet> Lam [y]. e = Lam [y]. e\n  (y \\<leftrightarrow> y') \\<bullet> Lam [y]. e =\n  Lam [y']. ((y \\<leftrightarrow> y') \\<bullet> e)\n\ngoal (1 subgoal):\n 1. Lam [y]. e = Lam [y']. ((y \\<leftrightarrow> y') \\<bullet> e)", "by (simp add: fresh_Pair)"], ["proof (state)\nthis:\n  Lam [y]. e = Lam [y']. ((y \\<leftrightarrow> y') \\<bullet> e)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}