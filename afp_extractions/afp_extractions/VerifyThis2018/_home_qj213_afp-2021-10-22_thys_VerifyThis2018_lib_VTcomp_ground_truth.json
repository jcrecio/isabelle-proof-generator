{"file_name": "/home/qj213/afp-2021-10-22/thys/VerifyThis2018/lib/VTcomp.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/VerifyThis2018", "problem_names": ["lemma nfoldli_upt_rule:\n  assumes INTV: \"lb\\<le>ub\"\n  assumes I0: \"I lb \\<sigma>0\"\n  assumes IS: \"\\<And>i \\<sigma>. \\<lbrakk> lb\\<le>i; i<ub; I i \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> f i \\<sigma> \\<le> SPEC (I (i+1))\"\n  assumes FNC: \"\\<And>i \\<sigma>. \\<lbrakk> lb\\<le>i; i\\<le>ub; I i \\<sigma>; \\<not>c \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  assumes FC: \"\\<And>\\<sigma>. \\<lbrakk> I ub \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"nfoldli [lb..<ub] c f \\<sigma>0 \\<le> SPEC P\"", "lemma efor_rule:\n  assumes INTV: \"lb\\<le>ub\"\n  assumes I0: \"I lb \\<sigma>0\"\n  assumes IS: \"\\<And>i \\<sigma>. \\<lbrakk> lb\\<le>i; i<ub; I i \\<sigma> \\<rbrakk> \\<Longrightarrow> f i \\<sigma> \\<le> ESPEC E (I (i+1))\"\n  assumes FC: \"\\<And>\\<sigma>. \\<lbrakk> I ub \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"efor lb ub f \\<sigma>0 \\<le> ESPEC E P\"", "lemma blit_len[simp]: \"si + len \\<le> length src \\<and> di + len \\<le> length dst \n    \\<Longrightarrow> length (op_list_blit src si dst di len) = length dst\"", "lemma array_blit_hnr_aux: \n          \"(uncurry4 (\\<lambda>src si dst di len. do { blit src si dst di len; return dst }), \n            uncurry4 mop_list_blit) \n      \\<in> is_array\\<^sup>k*\\<^sub>anat_assn\\<^sup>k*\\<^sub>ais_array\\<^sup>d*\\<^sub>anat_assn\\<^sup>k*\\<^sub>anat_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_array\""], "translations": [["", "lemma nfoldli_upt_rule:\n  assumes INTV: \"lb\\<le>ub\"\n  assumes I0: \"I lb \\<sigma>0\"\n  assumes IS: \"\\<And>i \\<sigma>. \\<lbrakk> lb\\<le>i; i<ub; I i \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> f i \\<sigma> \\<le> SPEC (I (i+1))\"\n  assumes FNC: \"\\<And>i \\<sigma>. \\<lbrakk> lb\\<le>i; i\\<le>ub; I i \\<sigma>; \\<not>c \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  assumes FC: \"\\<And>\\<sigma>. \\<lbrakk> I ub \\<sigma>; c \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"nfoldli [lb..<ub] c f \\<sigma>0 \\<le> SPEC P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli [lb..<ub] c f \\<sigma>0 \\<le> SPEC P", "apply (rule nfoldli_rule[where I=\"\\<lambda>l _ \\<sigma>. I (lb+length l) \\<sigma>\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. I (lb + length []) \\<sigma>0\n 2. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>[lb..<ub] = l1 @ x # l2; I (lb + length l1) \\<sigma>;\n        c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma>\n                         \\<le> SPEC (I (lb + length (l1 @ [x])))\n 3. \\<And>l1 l2 \\<sigma>.\n       \\<lbrakk>[lb..<ub] = l1 @ l2; I (lb + length l1) \\<sigma>;\n        \\<not> c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>\n 4. \\<And>\\<sigma>.\n       \\<lbrakk>I (lb + length [lb..<ub]) \\<sigma>; c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply simp_all"], ["proof (prove)\ngoal (4 subgoals):\n 1. I lb \\<sigma>0\n 2. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>[lb..<ub] = l1 @ x # l2; I (lb + length l1) \\<sigma>;\n        c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (Suc (lb + length l1)))\n 3. \\<And>l1 l2 \\<sigma>.\n       \\<lbrakk>[lb..<ub] = l1 @ l2; I (lb + length l1) \\<sigma>;\n        \\<not> c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>\n 4. \\<And>\\<sigma>.\n       \\<lbrakk>I (lb + (ub - lb)) \\<sigma>; c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply (simp add: I0)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>[lb..<ub] = l1 @ x # l2; I (lb + length l1) \\<sigma>;\n        c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> f x \\<sigma> \\<le> SPEC (I (Suc (lb + length l1)))\n 2. \\<And>l1 l2 \\<sigma>.\n       \\<lbrakk>[lb..<ub] = l1 @ l2; I (lb + length l1) \\<sigma>;\n        \\<not> c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>I (lb + (ub - lb)) \\<sigma>; c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>[lb..<ub] = l1_ @ x_ # l2_; I (lb + length l1_) \\<sigma>_;\n     c \\<sigma>_\\<rbrakk>\n    \\<Longrightarrow> f x_ \\<sigma>_ \\<le> SPEC (I (Suc (lb + length l1_)))", "using IS"], ["proof (prove)\nusing this:\n  \\<lbrakk>lb \\<le> ?i; ?i < ub; I ?i ?\\<sigma>; c ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> f ?i ?\\<sigma> \\<le> SPEC (I (?i + 1))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>[lb..<ub] = l1_ @ x_ # l2_; I (lb + length l1_) \\<sigma>_;\n     c \\<sigma>_\\<rbrakk>\n    \\<Longrightarrow> f x_ \\<sigma>_ \\<le> SPEC (I (Suc (lb + length l1_)))", "by (metis Suc_eq_plus1 add_diff_cancel_left' eq_diff_iff le_add1 length_upt upt_eq_lel_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l1 l2 \\<sigma>.\n       \\<lbrakk>[lb..<ub] = l1 @ l2; I (lb + length l1) \\<sigma>;\n        \\<not> c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>I (lb + (ub - lb)) \\<sigma>; c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "subgoal for l1 l2 \\<sigma>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>[lb..<ub] = l1 @ l2; I (lb + length l1) \\<sigma>;\n     \\<not> c \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P \\<sigma>", "apply (rule FNC[where i=\"lb + length l1\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>[lb..<ub] = l1 @ l2; I (lb + length l1) \\<sigma>;\n     \\<not> c \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> lb \\<le> lb + length l1\n 2. \\<lbrakk>[lb..<ub] = l1 @ l2; I (lb + length l1) \\<sigma>;\n     \\<not> c \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> lb + length l1 \\<le> ub\n 3. \\<lbrakk>[lb..<ub] = l1 @ l2; I (lb + length l1) \\<sigma>;\n     \\<not> c \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> I (lb + length l1) \\<sigma>\n 4. \\<lbrakk>[lb..<ub] = l1 @ l2; I (lb + length l1) \\<sigma>;\n     \\<not> c \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> \\<not> c \\<sigma>", "apply (auto simp: INTV)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>[lb..<ub] = l1 @ l2; I (lb + length l1) \\<sigma>;\n     \\<not> c \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> lb + length l1 \\<le> ub", "using INTV upt_eq_append_conv"], ["proof (prove)\nusing this:\n  lb \\<le> ub\n  ?i \\<le> ?j \\<Longrightarrow>\n  ([?i..<?j] = ?xs @ ?ys) =\n  (\\<exists>k\\<ge>?i.\n      k \\<le> ?j \\<and> [?i..<k] = ?xs \\<and> [k..<?j] = ?ys)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>[lb..<ub] = l1 @ l2; I (lb + length l1) \\<sigma>;\n     \\<not> c \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> lb + length l1 \\<le> ub", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>I (lb + (ub - lb)) \\<sigma>; c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply (rule FC)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>I (lb + (ub - lb)) \\<sigma>; c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I ub \\<sigma>\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>I (lb + (ub - lb)) \\<sigma>; c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma>", "using INTV"], ["proof (prove)\nusing this:\n  lb \\<le> ub\n\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>I (lb + (ub - lb)) \\<sigma>; c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I ub \\<sigma>\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>I (lb + (ub - lb)) \\<sigma>; c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> c \\<sigma>", "by auto"], ["", "definition [enres_unfolds]: \"efor (lb::int) ub f \\<sigma> \\<equiv> doE {\n  EASSERT (lb\\<le>ub);\n  (_,\\<sigma>) \\<leftarrow> EWHILET (\\<lambda>(i,\\<sigma>). i<ub) (\\<lambda>(i,\\<sigma>). doE { \\<sigma> \\<leftarrow> f i \\<sigma>; ERETURN (i+1,\\<sigma>) }) (lb,\\<sigma>);\n  ERETURN \\<sigma>\n}\""], ["", "lemma efor_rule:\n  assumes INTV: \"lb\\<le>ub\"\n  assumes I0: \"I lb \\<sigma>0\"\n  assumes IS: \"\\<And>i \\<sigma>. \\<lbrakk> lb\\<le>i; i<ub; I i \\<sigma> \\<rbrakk> \\<Longrightarrow> f i \\<sigma> \\<le> ESPEC E (I (i+1))\"\n  assumes FC: \"\\<And>\\<sigma>. \\<lbrakk> I ub \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"efor lb ub f \\<sigma>0 \\<le> ESPEC E P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. efor lb ub f \\<sigma>0 \\<le> ESPEC E P", "unfolding efor_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ebind (EASSERT (lb \\<le> ub))\n     (\\<lambda>_.\n         ebind\n          (EWHILET (\\<lambda>(i, \\<sigma>). i < ub)\n            (\\<lambda>(i, \\<sigma>).\n                ebind (f i \\<sigma>)\n                 (\\<lambda>\\<sigma>. ERETURN (i + 1, \\<sigma>)))\n            (lb, \\<sigma>0))\n          (\\<lambda>(uu_, \\<sigma>). ERETURN \\<sigma>))\n    \\<le> ESPEC E P", "supply EWHILET_rule[where R=\"measure (\\<lambda>(i,_). nat (ub-i))\" and I=\"\\<lambda>(i,\\<sigma>). lb\\<le>i \\<and> i\\<le>ub \\<and> I i \\<sigma>\", refine_vcg]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ebind (EASSERT (lb \\<le> ub))\n     (\\<lambda>_.\n         ebind\n          (EWHILET (\\<lambda>(i, \\<sigma>). i < ub)\n            (\\<lambda>(i, \\<sigma>).\n                ebind (f i \\<sigma>)\n                 (\\<lambda>\\<sigma>. ERETURN (i + 1, \\<sigma>)))\n            (lb, \\<sigma>0))\n          (\\<lambda>(uu_, \\<sigma>). ERETURN \\<sigma>))\n    \\<le> ESPEC E P", "apply refine_vcg"], ["proof (prove)\ngoal (7 subgoals):\n 1. lb \\<le> ub\n 2. lb \\<le> ub \\<Longrightarrow>\n    wf (measure (\\<lambda>(i, uu_). nat (ub - i)))\n 3. \\<And>x1 x2.\n       \\<lbrakk>lb \\<le> ub; (lb, \\<sigma>0) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> lb \\<le> x1\n 4. \\<And>x1 x2.\n       \\<lbrakk>lb \\<le> ub; (lb, \\<sigma>0) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 \\<le> ub\n 5. \\<And>x1 x2.\n       \\<lbrakk>lb \\<le> ub; (lb, \\<sigma>0) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> I x1 x2\n 6. \\<And>s i \\<sigma>.\n       \\<lbrakk>lb \\<le> ub;\n        case s of\n        (i, \\<sigma>) \\<Rightarrow>\n          lb \\<le> i \\<and> i \\<le> ub \\<and> I i \\<sigma>;\n        case s of (i, \\<sigma>) \\<Rightarrow> i < ub;\n        (s, lb, \\<sigma>0)\n        \\<in> (measure (\\<lambda>(i, uu_). nat (ub - i)))\\<^sup>*;\n        s = (i, \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> f i \\<sigma>\n                         \\<le> ESPEC E\n                                (\\<lambda>\\<sigma>.\n                                    ERETURN (i + 1, \\<sigma>)\n                                    \\<le> ESPEC E\n     (\\<lambda>s'.\n         (case s' of\n          (i, \\<sigma>) \\<Rightarrow>\n            lb \\<le> i \\<and> i \\<le> ub \\<and> I i \\<sigma>) \\<and>\n         (s', s) \\<in> measure (\\<lambda>(i, uu_). nat (ub - i))))\n 7. \\<And>s uu_ \\<sigma>.\n       \\<lbrakk>lb \\<le> ub;\n        case s of\n        (i, \\<sigma>) \\<Rightarrow>\n          lb \\<le> i \\<and> i \\<le> ub \\<and> I i \\<sigma>;\n        \\<not> (case s of (i, \\<sigma>) \\<Rightarrow> i < ub);\n        (s, lb, \\<sigma>0)\n        \\<in> (measure (\\<lambda>(i, uu_). nat (ub - i)))\\<^sup>*;\n        s = (uu_, \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. lb \\<le> ub\n 2. lb \\<le> ub \\<Longrightarrow> I lb \\<sigma>0\n 3. \\<And>i \\<sigma>.\n       \\<lbrakk>i < ub;\n        ((i, \\<sigma>), lb, \\<sigma>0)\n        \\<in> (measure (\\<lambda>(i, uu_). nat (ub - i)))\\<^sup>*;\n        lb \\<le> i; I i \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> f i \\<sigma> \\<le> ESPEC E (I (i + 1))\n 4. \\<And>\\<sigma>.\n       \\<lbrakk>((ub, \\<sigma>), lb, \\<sigma>0)\n                \\<in> (measure (\\<lambda>(i, uu_). nat (ub - i)))\\<^sup>*;\n        lb \\<le> ub; I ub \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  lb \\<le> ub\n  I lb \\<sigma>0\n  \\<lbrakk>lb \\<le> ?i; ?i < ub; I ?i ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> f ?i ?\\<sigma> \\<le> ESPEC E (I (?i + 1))\n  I ub ?\\<sigma> \\<Longrightarrow> P ?\\<sigma>\n\ngoal (4 subgoals):\n 1. lb \\<le> ub\n 2. lb \\<le> ub \\<Longrightarrow> I lb \\<sigma>0\n 3. \\<And>i \\<sigma>.\n       \\<lbrakk>i < ub;\n        ((i, \\<sigma>), lb, \\<sigma>0)\n        \\<in> (measure (\\<lambda>(i, uu_). nat (ub - i)))\\<^sup>*;\n        lb \\<le> i; I i \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> f i \\<sigma> \\<le> ESPEC E (I (i + 1))\n 4. \\<And>\\<sigma>.\n       \\<lbrakk>((ub, \\<sigma>), lb, \\<sigma>0)\n                \\<in> (measure (\\<lambda>(i, uu_). nat (ub - i)))\\<^sup>*;\n        lb \\<le> ub; I ub \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Nicer do-notation for the nres-monad\\<close>"], ["", "abbreviation (do_notation) bind_doN where \"bind_doN \\<equiv> Refine_Basic.bind\""], ["", "notation (output) bind_doN (infixl \"\\<bind>\" 54)"], ["", "notation (ASCII output) bind_doN (infixl \">>=\" 54)"], ["", "nonterminal doN_binds and doN_bind"], ["", "syntax\n  \"_doN_block\" :: \"doN_binds \\<Rightarrow> 'a\" (\"doN {//(2  _)//}\" [12] 62)\n  \"_doN_bind\"  :: \"[pttrn, 'a] \\<Rightarrow> doN_bind\" (\"(2_ \\<leftarrow>/ _)\" 13)\n  \"_doN_let\" :: \"[pttrn, 'a] \\<Rightarrow> doN_bind\" (\"(2let _ =/ _)\" [1000, 13] 13)\n  \"_doN_then\" :: \"'a \\<Rightarrow> doN_bind\" (\"_\" [14] 13)\n  \"_doN_final\" :: \"'a \\<Rightarrow> doN_binds\" (\"_\")\n  \"_doN_cons\" :: \"[doN_bind, doN_binds] \\<Rightarrow> doN_binds\" (\"_;//_\" [13, 12] 12)\n  \"_thenM\" :: \"['a, 'b] \\<Rightarrow> 'c\" (infixl \"\\<then>\" 54)"], ["", "syntax (ASCII)\n  \"_doN_bind\" :: \"[pttrn, 'a] \\<Rightarrow> doN_bind\" (\"(2_ <-/ _)\" 13)\n  \"_thenM\" :: \"['a, 'b] \\<Rightarrow> 'c\" (infixl \">>\" 54)"], ["", "translations\n  \"_doN_block (_doN_cons (_doN_then t) (_doN_final e))\"\n    \\<rightleftharpoons> \"CONST bind_doN t (\\<lambda>_. e)\"\n  \"_doN_block (_doN_cons (_doN_bind p t) (_doN_final e))\"\n    \\<rightleftharpoons> \"CONST bind_doN t (\\<lambda>p. e)\"\n  \"_doN_block (_doN_cons (_doN_let p t) bs)\"\n    \\<rightleftharpoons> \"let p = t in _doN_block bs\"\n  \"_doN_block (_doN_cons b (_doN_cons c cs))\"\n    \\<rightleftharpoons> \"_doN_block (_doN_cons b (_doN_final (_doN_block (_doN_cons c cs))))\"\n  \"_doN_cons (_doN_let p t) (_doN_final s)\"\n    \\<rightleftharpoons> \"_doN_final (let p = t in s)\"\n  \"_doN_block (_doN_final e)\" \\<rightharpoonup> \"e\"\n  \"(m \\<then> n)\" \\<rightharpoonup> \"(m \\<bind> (\\<lambda>_. n))\""], ["", "subsection \\<open>Array Blit exposed to Sepref (Added after Competition)\\<close>"], ["", "definition \"op_list_blit src si dst di len \\<equiv> \n    (take di dst @ take len (drop si src) @ drop (di+len) dst)\""], ["", "context \n    notes op_list_blit_def[simp] \n  begin"], ["", "sepref_decl_op (no_def) list_blit : \n      \"op_list_blit\" \n      :: \"[\\<lambda>((((src,si),dst),di),len). si+len \\<le> length src \\<and> di+len \\<le> length dst]\\<^sub>f  \n        ((((\\<langle>A\\<rangle>list_rel \\<times>\\<^sub>r nat_rel) \\<times>\\<^sub>r \\<langle>A\\<rangle>list_rel) \\<times>\\<^sub>r nat_rel) \\<times>\\<^sub>r nat_rel) \\<rightarrow> \\<langle>A\\<rangle>list_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "lemma blit_len[simp]: \"si + len \\<le> length src \\<and> di + len \\<le> length dst \n    \\<Longrightarrow> length (op_list_blit src si dst di len) = length dst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. si + len \\<le> length src \\<and>\n    di + len \\<le> length dst \\<Longrightarrow>\n    length (op_list_blit src si dst di len) = length dst", "by (auto simp: op_list_blit_def)"], ["", "context \n    notes [fcomp_norm_unfold] = array_assn_def[symmetric]\n  begin"], ["", "lemma array_blit_hnr_aux: \n          \"(uncurry4 (\\<lambda>src si dst di len. do { blit src si dst di len; return dst }), \n            uncurry4 mop_list_blit) \n      \\<in> is_array\\<^sup>k*\\<^sub>anat_assn\\<^sup>k*\\<^sub>ais_array\\<^sup>d*\\<^sub>anat_assn\\<^sup>k*\\<^sub>anat_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_array\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2\n      (uncurry2\n        (\\<lambda>src si dst di len.\n            blit src si dst di len \\<bind> (\\<lambda>_. return dst))),\n     uncurry2 (uncurry2 mop_list_blit))\n    \\<in> is_array\\<^sup>k *\\<^sub>a nat_assn\\<^sup>k *\\<^sub>a\n          is_array\\<^sup>d *\\<^sub>a\n          nat_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_array", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi ba bia bb bib bc bic a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE('a list); bc ::\\<^sub>i TYPE(nat);\n        bb ::\\<^sub>i TYPE('a list); ba ::\\<^sub>i TYPE(nat);\n        b ::\\<^sub>i TYPE(nat); nofail (mop_list_blit a bc bb ba b)\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> nat_rel) *\n                          \\<up> ((bia, ba) \\<in> nat_rel) *\n                          is_array bb bib *\n                          \\<up> ((bic, bc) \\<in> nat_rel) *\n                          is_array a\n                           ai> blit ai bic bib bia bi \\<bind>\n                               (\\<lambda>_.\n                                   return\n                                    bib) <\\<lambda>r.\n       \\<up> ((bi, b) \\<in> nat_rel) * \\<up> ((bia, ba) \\<in> nat_rel) *\n       true *\n       \\<up> ((bic, bc) \\<in> nat_rel) *\n       is_array a ai *\n       (\\<exists>\\<^sub>Ax.\n           is_array x r *\n           \\<up> (RETURN x \\<le> mop_list_blit a bc bb ba b))>\\<^sub>t", "apply (clarsimp simp: refine_pw_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b ba bb bib bc a ai.\n       \\<lbrakk>bc + b \\<le> length a; ba + b \\<le> length bb\\<rbrakk>\n       \\<Longrightarrow> <is_array bb bib * is_array a ai>\n                         blit ai bc bib ba b \\<bind>\n                         (\\<lambda>_. return bib)\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Ax.\n                                is_array a ai * is_array x r * true *\n                                \\<up> (x = op_list_blit a bc bb ba b)>", "apply (sep_auto simp: is_array_def op_list_blit_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_decl_impl (ismop) array_blit: array_blit_hnr_aux"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "end"]]}