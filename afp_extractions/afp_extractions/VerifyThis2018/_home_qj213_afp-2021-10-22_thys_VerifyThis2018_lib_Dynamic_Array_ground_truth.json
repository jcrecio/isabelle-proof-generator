{"file_name": "/home/qj213/afp-2021-10-22/thys/VerifyThis2018/lib/Dynamic_Array.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/VerifyThis2018", "problem_names": ["lemma array_grow'_rule[sep_heap_rules]:\n  shows \"\n    < a\\<mapsto>\\<^sub>ala > \n      array_grow' a n x \n    <\\<lambda>a'. a'\\<mapsto>\\<^sub>a (la @ replicate n x)>\\<^sub>t\"", "lemma dyn_array_new_sz_rl[sep_heap_rules]: \n  \"<emp> dyn_array_new_sz dflt n <\\<lambda>r. is_nff dflt (\\<lambda>_. dflt) r>\"", "lemma array_get_dyn_rule[sep_heap_rules]: \"\n  < is_nff dflt f a > \n    array_get_dyn dflt a i \n  < \\<lambda>r. is_nff dflt f a * \\<up>(r = f i) >\"", "lemma nff_\\<alpha>_upd: \"\\<lbrakk>i < length l\\<rbrakk> \\<Longrightarrow> nff_\\<alpha> dflt (l[i := v]) = (nff_\\<alpha> dflt l)(i := v)\"", "lemma nff_\\<alpha>_append_default: \"nff_\\<alpha> dflt (l@replicate n dflt) = nff_\\<alpha> dflt l\"", "lemma array_set_dyn_rule[sep_heap_rules]: \"\n  < is_nff dflt f a >\n    array_set_dyn dflt a i v\n  <\\<lambda>r. is_nff dflt (f(i:=v)) r >\\<^sub>t  \n  \""], "translations": [["", "lemma array_grow'_rule[sep_heap_rules]:\n  shows \"\n    < a\\<mapsto>\\<^sub>ala > \n      array_grow' a n x \n    <\\<lambda>a'. a'\\<mapsto>\\<^sub>a (la @ replicate n x)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a\n     la> array_grow' a n\n          x <\\<lambda>r. r \\<mapsto>\\<^sub>a (la @ replicate n x)>\\<^sub>t", "unfolding array_grow'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <a \\<mapsto>\\<^sub>a\n     la> Array.len a \\<bind>\n         (\\<lambda>l.\n             Array.new (l + n) x \\<bind>\n             (\\<lambda>a'.\n                 blit a 0 a' 0 l \\<bind>\n                 (\\<lambda>_.\n                     return\n                      a'))) <\\<lambda>r.\n                                r \\<mapsto>\\<^sub>a\n                                (la @ replicate n x)>\\<^sub>t", "by sep_auto"], ["", "(* TODO: Move to IICF_List *)"], ["", "sepref_decl_op list_grow: \n  \"\\<lambda>xs n x. xs@replicate n x\" :: \"\\<langle>A\\<rangle>list_rel \\<rightarrow> nat_rel \\<rightarrow> A \\<rightarrow> \\<langle>A\\<rangle>list_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition \"nff_\\<alpha> dflt l i \\<equiv> if i<length l then l!i else dflt\""], ["", "definition \"is_nff dflt f a \\<equiv> \\<exists>\\<^sub>Al. a \\<mapsto>\\<^sub>a l * \\<up>(f = nff_\\<alpha> dflt l)\""], ["", "definition [code_unfold]: \"dyn_array_new_sz dflt n \\<equiv> Array.new n dflt\""], ["", "lemma dyn_array_new_sz_rl[sep_heap_rules]: \n  \"<emp> dyn_array_new_sz dflt n <\\<lambda>r. is_nff dflt (\\<lambda>_. dflt) r>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> dyn_array_new_sz dflt n <is_nff dflt (\\<lambda>_. dflt)>", "unfolding dyn_array_new_sz_def is_nff_def nff_\\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> Array.new n dflt\n    <\\<lambda>r.\n        \\<exists>\\<^sub>Al.\n           r \\<mapsto>\\<^sub>a l *\n           \\<up>\n            ((\\<lambda>_. dflt) =\n             (\\<lambda>i. if i < length l then l ! i else dflt))>", "by sep_auto"], ["", "definition \"array_get_dyn dflt a i \\<equiv> do {\n  \\<^cancel>\\<open>\\<open>nth_oo dflt a i\\<close>\\<close>\n  l \\<leftarrow> Array.len a;\n  if i<l then Array.nth a i else return dflt\n  }\""], ["", "lemma array_get_dyn_rule[sep_heap_rules]: \"\n  < is_nff dflt f a > \n    array_get_dyn dflt a i \n  < \\<lambda>r. is_nff dflt f a * \\<up>(r = f i) >\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_nff dflt f a> array_get_dyn dflt a i\n    <\\<lambda>r. is_nff dflt f a * \\<up> (r = f i)>", "unfolding array_get_dyn_def nth_oo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_nff dflt f a>\n    Array.len a \\<bind>\n    (\\<lambda>l. if i < l then Array.nth a i else return dflt)\n    <\\<lambda>r. is_nff dflt f a * \\<up> (r = f i)>", "by (sep_auto simp: nff_\\<alpha>_def is_nff_def)"], ["", "definition \"array_set_dyn dflt a i v \\<equiv> do {\n  l \\<leftarrow> Array.len a;\n  if i<l then \n    Array.upd i v a \n  else do {\n    let ns = max (2*l) (i+1);\n    a \\<leftarrow> array_grow a ns dflt;\n    Array.upd i v a\n  }\n}\""], ["", "lemma nff_\\<alpha>_upd: \"\\<lbrakk>i < length l\\<rbrakk> \\<Longrightarrow> nff_\\<alpha> dflt (l[i := v]) = (nff_\\<alpha> dflt l)(i := v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length l \\<Longrightarrow>\n    nff_\\<alpha> dflt (l[i := v]) = (nff_\\<alpha> dflt l)(i := v)", "by (auto simp: nff_\\<alpha>_def)"], ["", "lemma nff_\\<alpha>_append_default: \"nff_\\<alpha> dflt (l@replicate n dflt) = nff_\\<alpha> dflt l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nff_\\<alpha> dflt (l @ replicate n dflt) = nff_\\<alpha> dflt l", "by (auto simp: nff_\\<alpha>_def nth_append intro!: ext)"], ["", "lemma array_set_dyn_rule[sep_heap_rules]: \"\n  < is_nff dflt f a >\n    array_set_dyn dflt a i v\n  <\\<lambda>r. is_nff dflt (f(i:=v)) r >\\<^sub>t  \n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_nff dflt f\n      a> array_set_dyn dflt a i v <is_nff dflt (f(i := v))>\\<^sub>t", "unfolding array_set_dyn_def is_nff_def upd_oo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<exists>\\<^sub>Al.\n        a \\<mapsto>\\<^sub>a l *\n        \\<up>\n         (f =\n          nff_\\<alpha> dflt\n           l)> Array.len a \\<bind>\n               (\\<lambda>l.\n                   if i < l then Array.upd i v a\n                   else let ns = max (2 * l) (i + 1)\n                        in array_grow a ns dflt \\<bind>\n                           Array.upd i\n                            v) <\\<lambda>r.\n                                   \\<exists>\\<^sub>Al.\nr \\<mapsto>\\<^sub>a l * \\<up> (f(i := v) = nff_\\<alpha> dflt l)>\\<^sub>t", "by (sep_auto simp: nff_\\<alpha>_upd nff_\\<alpha>_append_default)"], ["", "end"]]}