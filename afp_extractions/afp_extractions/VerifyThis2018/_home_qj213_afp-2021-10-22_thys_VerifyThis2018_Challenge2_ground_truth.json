{"file_name": "/home/qj213/afp-2021-10-22/thys/VerifyThis2018/Challenge2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/VerifyThis2018", "problem_names": ["lemma valid_valid':\n    \"valid l \\<Longrightarrow> valid' l\"", "lemmas valid_red = valid.intros(3)[OF valid.intros(1), simplified]", "lemma valid'_valid:\n    \"valid' l \\<Longrightarrow> valid l\"", "lemma valid_eq_valid':\n    \"valid' l = valid l\"", "lemma replicate_iff:\n    \"(\\<forall>i<length l. l ! i = R) \\<longleftrightarrow> (\\<exists> n. l = replicate n R)\"", "lemma replicate_iff2:\n    \"(\\<forall>i<n. l ! i = R) \\<longleftrightarrow> (\\<exists> l'. l = replicate n R @ l')\" if \"n < length l\"", "lemma replicate_Cons_eq:\n    \"replicate n x = y # ys \\<longleftrightarrow> (\\<exists> n'. n = Suc n' \\<and> x = y \\<and> replicate n' x = ys)\"", "lemma valid_split:\n    \"valid l \\<longleftrightarrow>\n    l = [] \\<or>\n    (l!0 = B \\<and> valid (tl l)) \\<or>\n    length l \\<ge> 3 \\<and> (\\<forall> i < length l. l ! i = R) \\<or>\n    (\\<exists> j < length l. j \\<ge> 3 \\<and> (\\<forall> i < j. l ! i = R) \\<and> l ! j = B \\<and> valid (drop (j + 1) l))\"", "lemma lc0_aux:\n    \"{l. l = [] \\<and> valid l} = {[]}\"", "lemma lc0: \"lcount 0 = 1\"", "lemma lc1aux: \"{l. length l=1 \\<and> valid l} = {[B]}\"", "lemma lc2aux: \"{l. length l=2 \\<and> valid l} = {[B,B]}\"", "lemma valid_3R: \\<open>valid [R, R, R]\\<close>", "lemma lc3_aux: \"{l. length l=3 \\<and> valid l} = {[B,B,B], [R,R,R]}\"", "lemma lcounts_init: \"lcount 0 = 1\" \"lcount 1 = 1\" \"lcount 2 = 1\" \"lcount 3 = 2\"", "lemma finite_valid_length:\n    \"finite {l. length l = n \\<and> valid l}\" (is \"finite ?S\")", "lemma valid_line_just_B:\n    \"valid (replicate n B)\"", "lemma valid_line_aux:\n    \"{l. length l = n \\<and> valid l} \\<noteq> {}\" (is \"?S \\<noteq> {}\")", "lemma replicate_unequal_aux:\n    \"replicate x R @ B # l \\<noteq> replicate y R @ B # l'\" (is \"?l \\<noteq> ?r\") if \\<open>x < y\\<close> for l l'", "lemma valid_prepend_B_iff:\n    \"valid (B # xs) \\<longleftrightarrow> valid xs\"", "lemma lcrec: \"lcount n = lcount (n-1) + 1 + (\\<Sum>i=3..<n. lcount (n-i-1))\" if \\<open>n>3\\<close>", "lemma sum_spec[THEN SPEC_trans, refine_vcg]: \n    assumes \"l\\<le>u\"\n    assumes \"\\<And>i. l\\<le>i \\<Longrightarrow> i<u \\<Longrightarrow> \\<Phi> i\" \n    shows \"sum_prog \\<Phi> l u f \\<le> SPEC (\\<lambda>r. r=(\\<Sum>i=l..<u. f i))\"", "theorem icount_correct: \"M>2 \\<Longrightarrow> icount M \\<le> SPEC (\\<lambda>r. r=lcount M)\"", "theorem icount_impl_correct: \n    \"M>2 \\<Longrightarrow> <emp> icount_impl M <\\<lambda>r. \\<up>(r = lcount M)>\\<^sub>t\"", "lemma valid_lineI:\n  assumes \"\\<And> i. i < length l \\<Longrightarrow> valid_point l i\"\n  shows \"valid_line l\"", "lemma valid_B_first:\n  \"valid_point xs i \\<Longrightarrow> i < length xs \\<Longrightarrow> valid_point (B # xs) (i + 1)\"", "lemma valid_line_prepend_B:\n  \"valid_line (B # xs)\" if \"valid_line xs\"", "lemma valid_drop_B:\n  \"valid_point xs (i - 1)\" if \"valid_point (B # xs) i\" \"i > 0\"", "lemma valid_line_drop_B:\n  \"valid_line xs\" if \"valid_line (B # xs)\"", "lemma valid_line_prepend_B_iff:\n  \"valid_line (B # xs) \\<longleftrightarrow> valid_line xs\"", "lemma cases_valid_line:\n  assumes\n    \"l = [] \\<or>\n    (l!0 = B \\<and> valid_line (tl l)) \\<or>\n    length l \\<ge> 3 \\<and> (\\<forall> i < length l. l ! i = R) \\<or>\n    (\\<exists> j < length l. j \\<ge> 3 \\<and> (\\<forall> i < j. l ! i = R) \\<and> l ! j = B \\<and> valid_line (drop (j + 1) l))\"\n    (is \"?a \\<or> ?b \\<or> ?c \\<or> ?d\")\n  shows \"valid_line l\"", "lemma valid_line_cases:\n  \"l = [] \\<or>\n  (l!0 = B \\<and> valid_line (tl l)) \\<or>\n  length l \\<ge> 3 \\<and> (\\<forall> i < length l. l ! i = R) \\<or>\n  (\\<exists> j < length l. j \\<ge> 3 \\<and> (\\<forall> i < j. l ! i = R) \\<and> l ! j = B \\<and> valid_line (drop (j + 1) l))\"\n  if \"valid_line l\"", "lemma valid_line_split:\n  \"valid_line l \\<longleftrightarrow>\n  l = [] \\<or>\n  (l!0 = B \\<and> valid_line (tl l)) \\<or>\n  length l \\<ge> 3 \\<and> (\\<forall> i < length l. l ! i = R) \\<or>\n  (\\<exists> j < length l. j \\<ge> 3 \\<and> (\\<forall> i < j. l ! i = R) \\<and> l ! j = B \\<and> valid_line (drop (j + 1) l))\"", "lemma valid_valid_line:\n  \"valid l \\<longleftrightarrow> valid_line l\""], "translations": [["", "lemma valid_valid':\n    \"valid l \\<Longrightarrow> valid' l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid l \\<Longrightarrow> valid' l", "by (induction rule: valid.induct)\n       (auto 4 4 intro: valid'.intros elim: valid'.cases\n          simp: replicate_add[symmetric] append_assoc[symmetric]\n       )"], ["", "lemmas valid_red = valid.intros(3)[OF valid.intros(1), simplified]"], ["", "lemma valid'_valid:\n    \"valid' l \\<Longrightarrow> valid l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid' l \\<Longrightarrow> valid l", "by (induction rule: valid'.induct) (auto intro: valid.intros valid_red)"], ["", "lemma valid_eq_valid':\n    \"valid' l = valid l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid' l = valid l", "using valid_valid' valid'_valid"], ["proof (prove)\nusing this:\n  valid ?l \\<Longrightarrow> valid' ?l\n  valid' ?l \\<Longrightarrow> valid ?l\n\ngoal (1 subgoal):\n 1. valid' l = valid l", "by metis"], ["", "subsubsection \\<open>Additional Facts on Replicate\\<close>"], ["", "lemma replicate_iff:\n    \"(\\<forall>i<length l. l ! i = R) \\<longleftrightarrow> (\\<exists> n. l = replicate n R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i<length l. l ! i = R) = (\\<exists>n. l = replicate n R)", "by auto (metis (full_types) in_set_conv_nth replicate_eqI)"], ["", "lemma replicate_iff2:\n    \"(\\<forall>i<n. l ! i = R) \\<longleftrightarrow> (\\<exists> l'. l = replicate n R @ l')\" if \"n < length l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i<n. l ! i = R) = (\\<exists>l'. l = replicate n R @ l')", "using that"], ["proof (prove)\nusing this:\n  n < length l\n\ngoal (1 subgoal):\n 1. (\\<forall>i<n. l ! i = R) = (\\<exists>l'. l = replicate n R @ l')", "by (auto simp: list_eq_iff_nth_eq nth_append intro: exI[where x = \"drop n l\"])"], ["", "lemma replicate_Cons_eq:\n    \"replicate n x = y # ys \\<longleftrightarrow> (\\<exists> n'. n = Suc n' \\<and> x = y \\<and> replicate n' x = ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (replicate n x = y # ys) =\n    (\\<exists>n'. n = Suc n' \\<and> x = y \\<and> replicate n' x = ys)", "by (cases n) auto"], ["", "subsubsection \\<open>Main Case Analysis on \\<open>@term valid\\<close>\\<close>"], ["", "lemma valid_split:\n    \"valid l \\<longleftrightarrow>\n    l = [] \\<or>\n    (l!0 = B \\<and> valid (tl l)) \\<or>\n    length l \\<ge> 3 \\<and> (\\<forall> i < length l. l ! i = R) \\<or>\n    (\\<exists> j < length l. j \\<ge> 3 \\<and> (\\<forall> i < j. l ! i = R) \\<and> l ! j = B \\<and> valid (drop (j + 1) l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid l =\n    (l = [] \\<or>\n     l ! 0 = B \\<and> valid (tl l) \\<or>\n     3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n     (\\<exists>j<length l.\n         3 \\<le> j \\<and>\n         (\\<forall>i<j. l ! i = R) \\<and>\n         l ! j = B \\<and> valid (drop (j + 1) l)))", "unfolding valid_eq_valid'[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid' l =\n    (l = [] \\<or>\n     l ! 0 = B \\<and> valid' (tl l) \\<or>\n     3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n     (\\<exists>j<length l.\n         3 \\<le> j \\<and>\n         (\\<forall>i<j. l ! i = R) \\<and>\n         l ! j = B \\<and> valid' (drop (j + 1) l)))", "apply standard"], ["proof (prove)\ngoal (2 subgoals):\n 1. valid' l \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid' (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid' (drop (j + 1) l))\n 2. l = [] \\<or>\n    l ! 0 = B \\<and> valid' (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid' (drop (j + 1) l)) \\<Longrightarrow>\n    valid' l", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid' l \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid' (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid' (drop (j + 1) l))", "by (erule valid'.cases) (auto simp: nth_append nth_Cons split: nat.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. l = [] \\<or>\n    l ! 0 = B \\<and> valid' (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid' (drop (j + 1) l)) \\<Longrightarrow>\n    valid' l", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. l = [] \\<or>\n    l ! 0 = B \\<and> valid' (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid' (drop (j + 1) l)) \\<Longrightarrow>\n    valid' l", "by (auto intro: valid'.intros simp: replicate_iff elim!: disjE1)\n         (fastforce intro: valid'.intros simp: neq_Nil_conv replicate_iff2 nth_append)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Base cases\\<close>"], ["", "lemma lc0_aux:\n    \"{l. l = [] \\<and> valid l} = {[]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l. l = [] \\<and> valid l} = {[]}", "by (auto intro: valid.intros)"], ["", "lemma lc0: \"lcount 0 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lcount 0 = 1", "by (auto simp: lc0_aux lcount_def)"], ["", "lemma lc1aux: \"{l. length l=1 \\<and> valid l} = {[B]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l. length l = 1 \\<and> valid l} = {[B]}", "by (auto intro: valid.intros elim: valid.cases simp: replicate_Cons_eq)"], ["", "lemma lc2aux: \"{l. length l=2 \\<and> valid l} = {[B,B]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l. length l = 2 \\<and> valid l} = {[B, B]}", "by (auto 4 3 intro: valid.intros elim: valid.cases simp: replicate_Cons_eq)"], ["", "lemma valid_3R: \\<open>valid [R, R, R]\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid [R, R, R]", "using valid.intros(3) [of \\<open>[]\\<close> 3]"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid []; 3 \\<le> 3\\<rbrakk>\n  \\<Longrightarrow> valid (replicate 3 R @ [])\n\ngoal (1 subgoal):\n 1. valid [R, R, R]", "by (simp add: numeral_eq_Suc valid.intros)"], ["", "lemma lc3_aux: \"{l. length l=3 \\<and> valid l} = {[B,B,B], [R,R,R]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l. length l = 3 \\<and> valid l} = {[B, B, B], [R, R, R]}", "by (auto 4 4 intro: valid.intros valid_3R elim: valid.cases\n      simp: replicate_Cons_eq)"], ["", "lemma lcounts_init: \"lcount 0 = 1\" \"lcount 1 = 1\" \"lcount 2 = 1\" \"lcount 3 = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lcount 0 = 1 &&& lcount 1 = 1) &&& lcount 2 = 1 &&& lcount 3 = 2", "using lc0 lc1aux lc2aux lc3_aux"], ["proof (prove)\nusing this:\n  lcount 0 = 1\n  {l. length l = 1 \\<and> valid l} = {[B]}\n  {l. length l = 2 \\<and> valid l} = {[B, B]}\n  {l. length l = 3 \\<and> valid l} = {[B, B, B], [R, R, R]}\n\ngoal (1 subgoal):\n 1. (lcount 0 = 1 &&& lcount 1 = 1) &&& lcount 2 = 1 &&& lcount 3 = 2", "unfolding lcount_def"], ["proof (prove)\nusing this:\n  card {l. length l = 0 \\<and> valid l} = 1\n  {l. length l = 1 \\<and> valid l} = {[B]}\n  {l. length l = 2 \\<and> valid l} = {[B, B]}\n  {l. length l = 3 \\<and> valid l} = {[B, B, B], [R, R, R]}\n\ngoal (1 subgoal):\n 1. (card {l. length l = 0 \\<and> valid l} = 1 &&&\n     card {l. length l = 1 \\<and> valid l} = 1) &&&\n    card {l. length l = 2 \\<and> valid l} = 1 &&&\n    card {l. length l = 3 \\<and> valid l} = 2", "by simp_all"], ["", "subsubsection \\<open>The Recursion Case\\<close>"], ["", "lemma finite_valid_length:\n    \"finite {l. length l = n \\<and> valid l}\" (is \"finite ?S\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {l. length l = n \\<and> valid l}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {l. length l = n \\<and> valid l}", "have \"?S \\<subseteq> lists {R, B} \\<inter> {l. length l = n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l. length l = n \\<and> valid l}\n    \\<subseteq> lists {R, B} \\<inter> {l. length l = n}", "by (auto intro: color.exhaust)"], ["proof (state)\nthis:\n  {l. length l = n \\<and> valid l}\n  \\<subseteq> lists {R, B} \\<inter> {l. length l = n}\n\ngoal (1 subgoal):\n 1. finite {l. length l = n \\<and> valid l}", "moreover"], ["proof (state)\nthis:\n  {l. length l = n \\<and> valid l}\n  \\<subseteq> lists {R, B} \\<inter> {l. length l = n}\n\ngoal (1 subgoal):\n 1. finite {l. length l = n \\<and> valid l}", "have \"finite \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (lists {R, B} \\<inter> {l. length l = n})", "by (auto intro: lists_of_len_fin1)"], ["proof (state)\nthis:\n  finite (lists {R, B} \\<inter> {l. length l = n})\n\ngoal (1 subgoal):\n 1. finite {l. length l = n \\<and> valid l}", "ultimately"], ["proof (chain)\npicking this:\n  {l. length l = n \\<and> valid l}\n  \\<subseteq> lists {R, B} \\<inter> {l. length l = n}\n  finite (lists {R, B} \\<inter> {l. length l = n})", "show ?thesis"], ["proof (prove)\nusing this:\n  {l. length l = n \\<and> valid l}\n  \\<subseteq> lists {R, B} \\<inter> {l. length l = n}\n  finite (lists {R, B} \\<inter> {l. length l = n})\n\ngoal (1 subgoal):\n 1. finite {l. length l = n \\<and> valid l}", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite {l. length l = n \\<and> valid l}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_line_just_B:\n    \"valid (replicate n B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (replicate n B)", "by (induction n) (auto intro: valid.intros)"], ["", "lemma valid_line_aux:\n    \"{l. length l = n \\<and> valid l} \\<noteq> {}\" (is \"?S \\<noteq> {}\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {l. length l = n \\<and> valid l} \\<noteq> {}", "using valid_line_just_B[of n]"], ["proof (prove)\nusing this:\n  valid (replicate n B)\n\ngoal (1 subgoal):\n 1. {l. length l = n \\<and> valid l} \\<noteq> {}", "by force"], ["", "lemma replicate_unequal_aux:\n    \"replicate x R @ B # l \\<noteq> replicate y R @ B # l'\" (is \"?l \\<noteq> ?r\") if \\<open>x < y\\<close> for l l'"], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate x R @ B # l \\<noteq> replicate y R @ B # l'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. replicate x R @ B # l \\<noteq> replicate y R @ B # l'", "have \"?l ! x = B\" \"?r ! x = R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (replicate x R @ B # l) ! x = B &&& (replicate y R @ B # l') ! x = R", "using that"], ["proof (prove)\nusing this:\n  x < y\n\ngoal (1 subgoal):\n 1. (replicate x R @ B # l) ! x = B &&& (replicate y R @ B # l') ! x = R", "by (auto simp: nth_append)"], ["proof (state)\nthis:\n  (replicate x R @ B # l) ! x = B\n  (replicate y R @ B # l') ! x = R\n\ngoal (1 subgoal):\n 1. replicate x R @ B # l \\<noteq> replicate y R @ B # l'", "then"], ["proof (chain)\npicking this:\n  (replicate x R @ B # l) ! x = B\n  (replicate y R @ B # l') ! x = R", "show ?thesis"], ["proof (prove)\nusing this:\n  (replicate x R @ B # l) ! x = B\n  (replicate y R @ B # l') ! x = R\n\ngoal (1 subgoal):\n 1. replicate x R @ B # l \\<noteq> replicate y R @ B # l'", "by auto"], ["proof (state)\nthis:\n  replicate x R @ B # l \\<noteq> replicate y R @ B # l'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_prepend_B_iff:\n    \"valid (B # xs) \\<longleftrightarrow> valid xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (B # xs) = valid xs", "by (auto intro: valid.intros elim: valid.cases simp: Cons_replicate_eq Cons_eq_append_conv)"], ["", "lemma lcrec: \"lcount n = lcount (n-1) + 1 + (\\<Sum>i=3..<n. lcount (n-i-1))\" if \\<open>n>3\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. lcount n = lcount (n - 1) + 1 + (\\<Sum>i = 3..<n. lcount (n - i - 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lcount n = lcount (n - 1) + 1 + (\\<Sum>i = 3..<n. lcount (n - i - 1))", "have \"{l. length l = n \\<and> valid l}\n          = {l. length l = n \\<and> valid (tl l) \\<and> l!0=B}\n          \\<union> {l. length l = n \\<and>\n              (\\<exists> i. i < n \\<and> i \\<ge> 3 \\<and> (\\<forall> k < i. l!k = R) \\<and> l!i = B \\<and> valid (drop (i + 1) l))}\n          \\<union> {l. length l = n \\<and> (\\<forall>i<n. l!i=R)}\n          \" (is \"?A = ?B \\<union> ?D \\<union> ?C\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {l. length l = n \\<and> valid l} =\n    {l. length l = n \\<and> valid (tl l) \\<and> l ! 0 = B} \\<union>\n    {l. length l = n \\<and>\n        (\\<exists>i<n.\n            3 \\<le> i \\<and>\n            (\\<forall>k<i. l ! k = R) \\<and>\n            l ! i = B \\<and> valid (drop (i + 1) l))} \\<union>\n    {l. length l = n \\<and> (\\<forall>i<n. l ! i = R)}", "using \\<open>n > 3\\<close>"], ["proof (prove)\nusing this:\n  3 < n\n\ngoal (1 subgoal):\n 1. {l. length l = n \\<and> valid l} =\n    {l. length l = n \\<and> valid (tl l) \\<and> l ! 0 = B} \\<union>\n    {l. length l = n \\<and>\n        (\\<exists>i<n.\n            3 \\<le> i \\<and>\n            (\\<forall>k<i. l ! k = R) \\<and>\n            l ! i = B \\<and> valid (drop (i + 1) l))} \\<union>\n    {l. length l = n \\<and> (\\<forall>i<n. l ! i = R)}", "by (subst valid_split) auto"], ["proof (state)\nthis:\n  {l. length l = n \\<and> valid l} =\n  {l. length l = n \\<and> valid (tl l) \\<and> l ! 0 = B} \\<union>\n  {l. length l = n \\<and>\n      (\\<exists>i<n.\n          3 \\<le> i \\<and>\n          (\\<forall>k<i. l ! k = R) \\<and>\n          l ! i = B \\<and> valid (drop (i + 1) l))} \\<union>\n  {l. length l = n \\<and> (\\<forall>i<n. l ! i = R)}\n\ngoal (1 subgoal):\n 1. lcount n = lcount (n - 1) + 1 + (\\<Sum>i = 3..<n. lcount (n - i - 1))", "let ?B1 = \"((#) B) ` {l. length l = n - Suc 0 \\<and> valid l}\""], ["proof (state)\ngoal (1 subgoal):\n 1. lcount n = lcount (n - 1) + 1 + (\\<Sum>i = 3..<n. lcount (n - i - 1))", "from \\<open>n > 3\\<close>"], ["proof (chain)\npicking this:\n  3 < n", "have \"?B = ?B1\""], ["proof (prove)\nusing this:\n  3 < n\n\ngoal (1 subgoal):\n 1. {l. length l = n \\<and> valid (tl l) \\<and> l ! 0 = B} =\n    (#) B ` {l. length l = n - Suc 0 \\<and> valid l}", "apply safe"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>3 < length x; n = length x; valid (tl x); x ! 0 = B\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (#) B `\n                                 {l. length l = length x - Suc 0 \\<and>\n                                     valid l}\n 2. \\<And>x xa.\n       \\<lbrakk>3 < n; length xa = n - Suc 0; valid xa\\<rbrakk>\n       \\<Longrightarrow> length (B # xa) = n\n 3. \\<And>x xa.\n       \\<lbrakk>3 < n; length xa = n - Suc 0; valid xa\\<rbrakk>\n       \\<Longrightarrow> valid (tl (B # xa))\n 4. \\<And>x xa.\n       \\<lbrakk>3 < n; length xa = n - Suc 0; valid xa\\<rbrakk>\n       \\<Longrightarrow> (B # xa) ! 0 = B", "subgoal for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>3 < length l; n = length l; valid (tl l); l ! 0 = B\\<rbrakk>\n    \\<Longrightarrow> l \\<in> (#) B `\n                              {la.\n                               length la = length l - Suc 0 \\<and> valid la}", "by (cases l) (auto simp: valid_prepend_B_iff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>3 < n; length xa = n - Suc 0; valid xa\\<rbrakk>\n       \\<Longrightarrow> length (B # xa) = n\n 2. \\<And>x xa.\n       \\<lbrakk>3 < n; length xa = n - Suc 0; valid xa\\<rbrakk>\n       \\<Longrightarrow> valid (tl (B # xa))\n 3. \\<And>x xa.\n       \\<lbrakk>3 < n; length xa = n - Suc 0; valid xa\\<rbrakk>\n       \\<Longrightarrow> (B # xa) ! 0 = B", "by auto"], ["proof (state)\nthis:\n  {l. length l = n \\<and> valid (tl l) \\<and> l ! 0 = B} =\n  (#) B ` {l. length l = n - Suc 0 \\<and> valid l}\n\ngoal (1 subgoal):\n 1. lcount n = lcount (n - 1) + 1 + (\\<Sum>i = 3..<n. lcount (n - i - 1))", "have 1: \"card ?B1 = lcount (n-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((#) B ` {l. length l = n - Suc 0 \\<and> valid l}) = lcount (n - 1)", "unfolding lcount_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card ((#) B ` {l. length l = n - Suc 0 \\<and> valid l}) =\n    card {l. length l = n - 1 \\<and> valid l}", "by (auto intro: card_image)"], ["proof (state)\nthis:\n  card ((#) B ` {l. length l = n - Suc 0 \\<and> valid l}) = lcount (n - 1)\n\ngoal (1 subgoal):\n 1. lcount n = lcount (n - 1) + 1 + (\\<Sum>i = 3..<n. lcount (n - i - 1))", "have \"?C = {replicate n R}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l. length l = n \\<and> (\\<forall>i<n. l ! i = R)} = {replicate n R}", "by (auto simp: nth_equalityI)"], ["proof (state)\nthis:\n  {l. length l = n \\<and> (\\<forall>i<n. l ! i = R)} = {replicate n R}\n\ngoal (1 subgoal):\n 1. lcount n = lcount (n - 1) + 1 + (\\<Sum>i = 3..<n. lcount (n - i - 1))", "have 2: \"card {replicate n R} = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {replicate n R} = 1", "by auto"], ["proof (state)\nthis:\n  card {replicate n R} = 1\n\ngoal (1 subgoal):\n 1. lcount n = lcount (n - 1) + 1 + (\\<Sum>i = 3..<n. lcount (n - i - 1))", "let ?D1=\"(\\<Union> i \\<in> {3..<n}. (\\<lambda> l. replicate i R @ B # l)` {l. length l = n - i - 1 \\<and> valid l})\""], ["proof (state)\ngoal (1 subgoal):\n 1. lcount n = lcount (n - 1) + 1 + (\\<Sum>i = 3..<n. lcount (n - i - 1))", "have \"?D =\n        (\\<Union>i \\<in> {3..<n}. {l. length l = n \\<and> (\\<forall> k < i. l!k = R) \\<and> l!i = B \\<and> valid (drop (i + 1) l)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l. length l = n \\<and>\n        (\\<exists>i<n.\n            3 \\<le> i \\<and>\n            (\\<forall>k<i. l ! k = R) \\<and>\n            l ! i = B \\<and> valid (drop (i + 1) l))} =\n    (\\<Union>i\\<in>{3..<n}.\n        {l. length l = n \\<and>\n            (\\<forall>k<i. l ! k = R) \\<and>\n            l ! i = B \\<and> valid (drop (i + 1) l)})", "by auto"], ["proof (state)\nthis:\n  {l. length l = n \\<and>\n      (\\<exists>i<n.\n          3 \\<le> i \\<and>\n          (\\<forall>k<i. l ! k = R) \\<and>\n          l ! i = B \\<and> valid (drop (i + 1) l))} =\n  (\\<Union>i\\<in>{3..<n}.\n      {l. length l = n \\<and>\n          (\\<forall>k<i. l ! k = R) \\<and>\n          l ! i = B \\<and> valid (drop (i + 1) l)})\n\ngoal (1 subgoal):\n 1. lcount n = lcount (n - 1) + 1 + (\\<Sum>i = 3..<n. lcount (n - i - 1))", "have \"{l. length l = n \\<and> (\\<forall> k < i. l!k = R) \\<and> l!i = B \\<and> valid (drop (i + 1) l)}\n              = (\\<lambda> l. replicate i R @ B # l)` {l. length l = n - i - 1 \\<and> valid l}\"\n      if \"i < n\" \"2 < i\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. {l. length l = n \\<and>\n        (\\<forall>k<i. l ! k = R) \\<and>\n        l ! i = B \\<and> valid (drop (i + 1) l)} =\n    (\\<lambda>l. replicate i R @ B # l) `\n    {l. length l = n - i - 1 \\<and> valid l}", "apply safe"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>n = length x; \\<forall>k<i. x ! k = R; x ! i = B;\n        valid (drop (i + 1) x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<lambda>l. replicate i R @ B # l) `\n                                 {l. length l = length x - i - 1 \\<and>\n                                     valid l}\n 2. \\<And>x l.\n       \\<lbrakk>length l = n - i - 1; valid l\\<rbrakk>\n       \\<Longrightarrow> length (replicate i R @ B # l) = n\n 3. \\<And>x l k.\n       \\<lbrakk>length l = n - i - 1; valid l; k < i\\<rbrakk>\n       \\<Longrightarrow> (replicate i R @ B # l) ! k = R\n 4. \\<And>x l.\n       \\<lbrakk>length l = n - i - 1; valid l\\<rbrakk>\n       \\<Longrightarrow> (replicate i R @ B # l) ! i = B\n 5. \\<And>x l.\n       \\<lbrakk>length l = n - i - 1; valid l\\<rbrakk>\n       \\<Longrightarrow> valid (drop (i + 1) (replicate i R @ B # l))", "subgoal for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n = length l; \\<forall>k<i. l ! k = R; l ! i = B;\n     valid (drop (i + 1) l)\\<rbrakk>\n    \\<Longrightarrow> l \\<in> (\\<lambda>l. replicate i R @ B # l) `\n                              {la.\n                               length la = length l - i - 1 \\<and> valid la}", "apply (rule image_eqI[where x = \"drop (i + 1) l\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n = length l; \\<forall>k<i. l ! k = R; l ! i = B;\n     valid (drop (i + 1) l)\\<rbrakk>\n    \\<Longrightarrow> l = replicate i R @ B # drop (i + 1) l\n 2. \\<lbrakk>n = length l; \\<forall>k<i. l ! k = R; l ! i = B;\n     valid (drop (i + 1) l)\\<rbrakk>\n    \\<Longrightarrow> drop (i + 1) l\n                      \\<in> {la.\n                             length la = length l - i - 1 \\<and> valid la}", "apply (rule nth_equalityI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>n = length l; \\<forall>k<i. l ! k = R; l ! i = B;\n     valid (drop (i + 1) l)\\<rbrakk>\n    \\<Longrightarrow> length l = length (replicate i R @ B # drop (i + 1) l)\n 2. \\<And>ia.\n       \\<lbrakk>n = length l; \\<forall>k<i. l ! k = R; l ! i = B;\n        valid (drop (i + 1) l); ia < length l\\<rbrakk>\n       \\<Longrightarrow> l ! ia = (replicate i R @ B # drop (i + 1) l) ! ia\n 3. \\<lbrakk>n = length l; \\<forall>k<i. l ! k = R; l ! i = B;\n     valid (drop (i + 1) l)\\<rbrakk>\n    \\<Longrightarrow> drop (i + 1) l\n                      \\<in> {la.\n                             length la = length l - i - 1 \\<and> valid la}", "using that"], ["proof (prove)\nusing this:\n  i < n\n  2 < i\n\ngoal (3 subgoals):\n 1. \\<lbrakk>n = length l; \\<forall>k<i. l ! k = R; l ! i = B;\n     valid (drop (i + 1) l)\\<rbrakk>\n    \\<Longrightarrow> length l = length (replicate i R @ B # drop (i + 1) l)\n 2. \\<And>ia.\n       \\<lbrakk>n = length l; \\<forall>k<i. l ! k = R; l ! i = B;\n        valid (drop (i + 1) l); ia < length l\\<rbrakk>\n       \\<Longrightarrow> l ! ia = (replicate i R @ B # drop (i + 1) l) ! ia\n 3. \\<lbrakk>n = length l; \\<forall>k<i. l ! k = R; l ! i = B;\n     valid (drop (i + 1) l)\\<rbrakk>\n    \\<Longrightarrow> drop (i + 1) l\n                      \\<in> {la.\n                             length la = length l - i - 1 \\<and> valid la}", "apply (simp_all split: nat.split add: nth_Cons nth_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>n = length l; \\<forall>k<i. l ! k = R; l ! i = B;\n        valid (drop (Suc i) l); ia < length l; i < length l; 2 < i\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x2.\n                            ia - i = Suc x2 \\<longrightarrow>\n                            \\<not> ia < i \\<longrightarrow>\n                            l ! ia = l ! Suc (i + x2)", "using add_diff_inverse_nat"], ["proof (prove)\nusing this:\n  \\<not> ?m < ?n \\<Longrightarrow> ?n + (?m - ?n) = ?m\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>n = length l; \\<forall>k<i. l ! k = R; l ! i = B;\n        valid (drop (Suc i) l); ia < length l; i < length l; 2 < i\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x2.\n                            ia - i = Suc x2 \\<longrightarrow>\n                            \\<not> ia < i \\<longrightarrow>\n                            l ! ia = l ! Suc (i + x2)", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x l.\n       \\<lbrakk>length l = n - i - 1; valid l\\<rbrakk>\n       \\<Longrightarrow> length (replicate i R @ B # l) = n\n 2. \\<And>x l k.\n       \\<lbrakk>length l = n - i - 1; valid l; k < i\\<rbrakk>\n       \\<Longrightarrow> (replicate i R @ B # l) ! k = R\n 3. \\<And>x l.\n       \\<lbrakk>length l = n - i - 1; valid l\\<rbrakk>\n       \\<Longrightarrow> (replicate i R @ B # l) ! i = B\n 4. \\<And>x l.\n       \\<lbrakk>length l = n - i - 1; valid l\\<rbrakk>\n       \\<Longrightarrow> valid (drop (i + 1) (replicate i R @ B # l))", "using that"], ["proof (prove)\nusing this:\n  i < n\n  2 < i\n\ngoal (4 subgoals):\n 1. \\<And>x l.\n       \\<lbrakk>length l = n - i - 1; valid l\\<rbrakk>\n       \\<Longrightarrow> length (replicate i R @ B # l) = n\n 2. \\<And>x l k.\n       \\<lbrakk>length l = n - i - 1; valid l; k < i\\<rbrakk>\n       \\<Longrightarrow> (replicate i R @ B # l) ! k = R\n 3. \\<And>x l.\n       \\<lbrakk>length l = n - i - 1; valid l\\<rbrakk>\n       \\<Longrightarrow> (replicate i R @ B # l) ! i = B\n 4. \\<And>x l.\n       \\<lbrakk>length l = n - i - 1; valid l\\<rbrakk>\n       \\<Longrightarrow> valid (drop (i + 1) (replicate i R @ B # l))", "by (simp add: nth_append; fail)+"], ["proof (state)\nthis:\n  \\<lbrakk>?i < n; 2 < ?i\\<rbrakk>\n  \\<Longrightarrow> {l. length l = n \\<and>\n                        (\\<forall>k<?i. l ! k = R) \\<and>\n                        l ! ?i = B \\<and> valid (drop (?i + 1) l)} =\n                    (\\<lambda>l. replicate ?i R @ B # l) `\n                    {l. length l = n - ?i - 1 \\<and> valid l}\n\ngoal (1 subgoal):\n 1. lcount n = lcount (n - 1) + 1 + (\\<Sum>i = 3..<n. lcount (n - i - 1))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i < n; 2 < ?i\\<rbrakk>\n  \\<Longrightarrow> {l. length l = n \\<and>\n                        (\\<forall>k<?i. l ! k = R) \\<and>\n                        l ! ?i = B \\<and> valid (drop (?i + 1) l)} =\n                    (\\<lambda>l. replicate ?i R @ B # l) `\n                    {l. length l = n - ?i - 1 \\<and> valid l}", "have D_eq: \"?D = ?D1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < n; 2 < ?i\\<rbrakk>\n  \\<Longrightarrow> {l. length l = n \\<and>\n                        (\\<forall>k<?i. l ! k = R) \\<and>\n                        l ! ?i = B \\<and> valid (drop (?i + 1) l)} =\n                    (\\<lambda>l. replicate ?i R @ B # l) `\n                    {l. length l = n - ?i - 1 \\<and> valid l}\n\ngoal (1 subgoal):\n 1. {l. length l = n \\<and>\n        (\\<exists>i<n.\n            3 \\<le> i \\<and>\n            (\\<forall>k<i. l ! k = R) \\<and>\n            l ! i = B \\<and> valid (drop (i + 1) l))} =\n    (\\<Union>i\\<in>{3..<n}.\n        (\\<lambda>l. replicate i R @ B # l) `\n        {l. length l = n - i - 1 \\<and> valid l})", "unfolding \\<open>?D = _\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < n; 2 < ?i\\<rbrakk>\n  \\<Longrightarrow> {l. length l = n \\<and>\n                        (\\<forall>k<?i. l ! k = R) \\<and>\n                        l ! ?i = B \\<and> valid (drop (?i + 1) l)} =\n                    (\\<lambda>l. replicate ?i R @ B # l) `\n                    {l. length l = n - ?i - 1 \\<and> valid l}\n\ngoal (1 subgoal):\n 1. (\\<Union>i\\<in>{3..<n}.\n        {l. length l = n \\<and>\n            (\\<forall>k<i. l ! k = R) \\<and>\n            l ! i = B \\<and> valid (drop (i + 1) l)}) =\n    (\\<Union>i\\<in>{3..<n}.\n        (\\<lambda>l. replicate i R @ B # l) `\n        {l. length l = n - i - 1 \\<and> valid l})", "by auto"], ["proof (state)\nthis:\n  {l. length l = n \\<and>\n      (\\<exists>i<n.\n          3 \\<le> i \\<and>\n          (\\<forall>k<i. l ! k = R) \\<and>\n          l ! i = B \\<and> valid (drop (i + 1) l))} =\n  (\\<Union>i\\<in>{3..<n}.\n      (\\<lambda>l. replicate i R @ B # l) `\n      {l. length l = n - i - 1 \\<and> valid l})\n\ngoal (1 subgoal):\n 1. lcount n = lcount (n - 1) + 1 + (\\<Sum>i = 3..<n. lcount (n - i - 1))", "have inj: \"inj_on (\\<lambda>l. replicate x R @ B # l) {l. length l = n - Suc x \\<and> valid l}\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>l. replicate x R @ B # l)\n     {l. length l = n - Suc x \\<and> valid l}", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa\\<in>{l. length l = n - Suc x \\<and> valid l}.\n       \\<forall>y\\<in>{l. length l = n - Suc x \\<and> valid l}.\n          replicate x R @ B # xa = replicate x R @ B # y \\<longrightarrow>\n          xa = y", "by auto"], ["proof (state)\nthis:\n  inj_on (\\<lambda>l. replicate ?x R @ B # l)\n   {l. length l = n - Suc ?x \\<and> valid l}\n\ngoal (1 subgoal):\n 1. lcount n = lcount (n - 1) + 1 + (\\<Sum>i = 3..<n. lcount (n - i - 1))", "have *:\n      \"(\\<lambda>l. replicate x R @ B # l) ` {l. length l = n - Suc x \\<and> valid l} \\<inter>\n         (\\<lambda>l. replicate y R @ B # l) ` {l. length l = n - Suc y \\<and> valid l} = {}\"\n      if \"3 \\<le> x\" \"x < y\" \"y < n\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>l. replicate x R @ B # l) `\n    {l. length l = n - Suc x \\<and> valid l} \\<inter>\n    (\\<lambda>l. replicate y R @ B # l) `\n    {l. length l = n - Suc y \\<and> valid l} =\n    {}", "using that replicate_unequal_aux[OF \\<open>x < y\\<close>]"], ["proof (prove)\nusing this:\n  3 \\<le> x\n  x < y\n  y < n\n  replicate x R @ B # ?l \\<noteq> replicate y R @ B # ?l'\n\ngoal (1 subgoal):\n 1. (\\<lambda>l. replicate x R @ B # l) `\n    {l. length l = n - Suc x \\<and> valid l} \\<inter>\n    (\\<lambda>l. replicate y R @ B # l) `\n    {l. length l = n - Suc y \\<and> valid l} =\n    {}", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>3 \\<le> ?x; ?x < ?y; ?y < n\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>l. replicate ?x R @ B # l) `\n                    {l. length l = n - Suc ?x \\<and> valid l} \\<inter>\n                    (\\<lambda>l. replicate ?y R @ B # l) `\n                    {l. length l = n - Suc ?y \\<and> valid l} =\n                    {}\n\ngoal (1 subgoal):\n 1. lcount n = lcount (n - 1) + 1 + (\\<Sum>i = 3..<n. lcount (n - i - 1))", "have 3: \"card ?D1 = (\\<Sum>i=3..<n. lcount (n-i-1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (\\<Union>i\\<in>{3..<n}.\n         (\\<lambda>l. replicate i R @ B # l) `\n         {l. length l = n - i - 1 \\<and> valid l}) =\n    (\\<Sum>i = 3..<n. lcount (n - i - 1))", "proof (subst card_Union_disjoint, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. pairwise disjnt\n     ((\\<lambda>i.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> valid l}) `\n      {3..<n})\n 2. \\<And>A.\n       A \\<in> (\\<lambda>i.\n                   (\\<lambda>l. replicate i R @ B # l) `\n                   {l. length l = n - i - 1 \\<and> valid l}) `\n               {3..<n} \\<Longrightarrow>\n       finite A\n 3. sum card\n     ((\\<lambda>i.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> valid l}) `\n      {3..<n}) =\n    (\\<Sum>i = 3..<n. lcount (n - i - 1))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. pairwise disjnt\n     ((\\<lambda>i.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> valid l}) `\n      {3..<n})\n 2. \\<And>A.\n       A \\<in> (\\<lambda>i.\n                   (\\<lambda>l. replicate i R @ B # l) `\n                   {l. length l = n - i - 1 \\<and> valid l}) `\n               {3..<n} \\<Longrightarrow>\n       finite A\n 3. sum card\n     ((\\<lambda>i.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> valid l}) `\n      {3..<n}) =\n    (\\<Sum>i = 3..<n. lcount (n - i - 1))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. pairwise disjnt\n     ((\\<lambda>i.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> valid l}) `\n      {3..<n})", "unfolding pairwise_def disjnt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>(\\<lambda>i.\n                       (\\<lambda>l. replicate i R @ B # l) `\n                       {l. length l = n - i - 1 \\<and> valid l}) `\n                   {3..<n}.\n       \\<forall>y\\<in>(\\<lambda>i.\n                          (\\<lambda>l. replicate i R @ B # l) `\n                          {l. length l = n - i - 1 \\<and> valid l}) `\n                      {3..<n}.\n          x \\<noteq> y \\<longrightarrow> x \\<inter> y = {}", "proof (clarsimp, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>(\\<lambda>xa. replicate x R @ B # xa) `\n                {l. length l = n - Suc x \\<and> valid l} \\<noteq>\n                (\\<lambda>x. replicate y R @ B # x) `\n                {l. length l = n - Suc y \\<and> valid l};\n        3 \\<le> x; x < n; 3 \\<le> y; y < n\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>xa. replicate x R @ B # xa) `\n                         {l. length l = n - Suc x \\<and> valid l} \\<inter>\n                         (\\<lambda>x. replicate y R @ B # x) `\n                         {l. length l = n - Suc y \\<and> valid l} =\n                         {}", "case prems: (1 x y)"], ["proof (state)\nthis:\n  (\\<lambda>xa. replicate x R @ B # xa) `\n  {l. length l = n - Suc x \\<and> valid l} \\<noteq>\n  (\\<lambda>x. replicate y R @ B # x) `\n  {l. length l = n - Suc y \\<and> valid l}\n  3 \\<le> x\n  x < n\n  3 \\<le> y\n  y < n\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>(\\<lambda>xa. replicate x R @ B # xa) `\n                {l. length l = n - Suc x \\<and> valid l} \\<noteq>\n                (\\<lambda>x. replicate y R @ B # x) `\n                {l. length l = n - Suc y \\<and> valid l};\n        3 \\<le> x; x < n; 3 \\<le> y; y < n\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>xa. replicate x R @ B # xa) `\n                         {l. length l = n - Suc x \\<and> valid l} \\<inter>\n                         (\\<lambda>x. replicate y R @ B # x) `\n                         {l. length l = n - Suc y \\<and> valid l} =\n                         {}", "from prems"], ["proof (chain)\npicking this:\n  (\\<lambda>xa. replicate x R @ B # xa) `\n  {l. length l = n - Suc x \\<and> valid l} \\<noteq>\n  (\\<lambda>x. replicate y R @ B # x) `\n  {l. length l = n - Suc y \\<and> valid l}\n  3 \\<le> x\n  x < n\n  3 \\<le> y\n  y < n", "show ?case"], ["proof (prove)\nusing this:\n  (\\<lambda>xa. replicate x R @ B # xa) `\n  {l. length l = n - Suc x \\<and> valid l} \\<noteq>\n  (\\<lambda>x. replicate y R @ B # x) `\n  {l. length l = n - Suc y \\<and> valid l}\n  3 \\<le> x\n  x < n\n  3 \\<le> y\n  y < n\n\ngoal (1 subgoal):\n 1. (\\<lambda>xa. replicate x R @ B # xa) `\n    {l. length l = n - Suc x \\<and> valid l} \\<inter>\n    (\\<lambda>x. replicate y R @ B # x) `\n    {l. length l = n - Suc y \\<and> valid l} =\n    {}", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<lambda>xa. replicate x R @ B # xa) `\n             {l. length l = n - Suc x \\<and> valid l} \\<noteq>\n             (\\<lambda>x. replicate y R @ B # x) `\n             {l. length l = n - Suc y \\<and> valid l};\n     3 \\<le> x; x < n; 3 \\<le> y; y < n\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>xa. replicate x R @ B # xa) `\n                      {l. length l = n - Suc x \\<and> valid l} \\<inter>\n                      (\\<lambda>x. replicate y R @ B # x) `\n                      {l. length l = n - Suc y \\<and> valid l} =\n                      {}", "apply (rule linorder_cases[of x y])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(\\<lambda>xa. replicate x R @ B # xa) `\n             {l. length l = n - Suc x \\<and> valid l} \\<noteq>\n             (\\<lambda>x. replicate y R @ B # x) `\n             {l. length l = n - Suc y \\<and> valid l};\n     3 \\<le> x; x < n; 3 \\<le> y; y < n; x < y\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>xa. replicate x R @ B # xa) `\n                      {l. length l = n - Suc x \\<and> valid l} \\<inter>\n                      (\\<lambda>x. replicate y R @ B # x) `\n                      {l. length l = n - Suc y \\<and> valid l} =\n                      {}\n 2. \\<lbrakk>(\\<lambda>xa. replicate x R @ B # xa) `\n             {l. length l = n - Suc x \\<and> valid l} \\<noteq>\n             (\\<lambda>x. replicate y R @ B # x) `\n             {l. length l = n - Suc y \\<and> valid l};\n     3 \\<le> x; x < n; 3 \\<le> y; y < n; x = y\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>xa. replicate x R @ B # xa) `\n                      {l. length l = n - Suc x \\<and> valid l} \\<inter>\n                      (\\<lambda>x. replicate y R @ B # x) `\n                      {l. length l = n - Suc y \\<and> valid l} =\n                      {}\n 3. \\<lbrakk>(\\<lambda>xa. replicate x R @ B # xa) `\n             {l. length l = n - Suc x \\<and> valid l} \\<noteq>\n             (\\<lambda>x. replicate y R @ B # x) `\n             {l. length l = n - Suc y \\<and> valid l};\n     3 \\<le> x; x < n; 3 \\<le> y; y < n; y < x\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>xa. replicate x R @ B # xa) `\n                      {l. length l = n - Suc x \\<and> valid l} \\<inter>\n                      (\\<lambda>x. replicate y R @ B # x) `\n                      {l. length l = n - Suc y \\<and> valid l} =\n                      {}", "apply (rule *; assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<lambda>xa. replicate x R @ B # xa) `\n             {l. length l = n - Suc x \\<and> valid l} \\<noteq>\n             (\\<lambda>x. replicate y R @ B # x) `\n             {l. length l = n - Suc y \\<and> valid l};\n     3 \\<le> x; x < n; 3 \\<le> y; y < n; x = y\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>xa. replicate x R @ B # xa) `\n                      {l. length l = n - Suc x \\<and> valid l} \\<inter>\n                      (\\<lambda>x. replicate y R @ B # x) `\n                      {l. length l = n - Suc y \\<and> valid l} =\n                      {}\n 2. \\<lbrakk>(\\<lambda>xa. replicate x R @ B # xa) `\n             {l. length l = n - Suc x \\<and> valid l} \\<noteq>\n             (\\<lambda>x. replicate y R @ B # x) `\n             {l. length l = n - Suc y \\<and> valid l};\n     3 \\<le> x; x < n; 3 \\<le> y; y < n; y < x\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>xa. replicate x R @ B # xa) `\n                      {l. length l = n - Suc x \\<and> valid l} \\<inter>\n                      (\\<lambda>x. replicate y R @ B # x) `\n                      {l. length l = n - Suc y \\<and> valid l} =\n                      {}", "apply (simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<lambda>xa. replicate x R @ B # xa) `\n             {l. length l = n - Suc x \\<and> valid l} \\<noteq>\n             (\\<lambda>x. replicate y R @ B # x) `\n             {l. length l = n - Suc y \\<and> valid l};\n     3 \\<le> x; x < n; 3 \\<le> y; y < n; y < x\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>xa. replicate x R @ B # xa) `\n                      {l. length l = n - Suc x \\<and> valid l} \\<inter>\n                      (\\<lambda>x. replicate y R @ B # x) `\n                      {l. length l = n - Suc y \\<and> valid l} =\n                      {}", "apply (subst Int_commute; rule *; assumption)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<lambda>xa. replicate x R @ B # xa) `\n  {l. length l = n - Suc x \\<and> valid l} \\<inter>\n  (\\<lambda>x. replicate y R @ B # x) `\n  {l. length l = n - Suc y \\<and> valid l} =\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pairwise disjnt\n   ((\\<lambda>i.\n        (\\<lambda>l. replicate i R @ B # l) `\n        {l. length l = n - i - 1 \\<and> valid l}) `\n    {3..<n})\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       A \\<in> (\\<lambda>i.\n                   (\\<lambda>l. replicate i R @ B # l) `\n                   {l. length l = n - i - 1 \\<and> valid l}) `\n               {3..<n} \\<Longrightarrow>\n       finite A\n 2. sum card\n     ((\\<lambda>i.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> valid l}) `\n      {3..<n}) =\n    (\\<Sum>i = 3..<n. lcount (n - i - 1))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       A \\<in> (\\<lambda>i.\n                   (\\<lambda>l. replicate i R @ B # l) `\n                   {l. length l = n - i - 1 \\<and> valid l}) `\n               {3..<n} \\<Longrightarrow>\n       finite A\n 2. sum card\n     ((\\<lambda>i.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> valid l}) `\n      {3..<n}) =\n    (\\<Sum>i = 3..<n. lcount (n - i - 1))", "case 3"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>A.\n       A \\<in> (\\<lambda>i.\n                   (\\<lambda>l. replicate i R @ B # l) `\n                   {l. length l = n - i - 1 \\<and> valid l}) `\n               {3..<n} \\<Longrightarrow>\n       finite A\n 2. sum card\n     ((\\<lambda>i.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> valid l}) `\n      {3..<n}) =\n    (\\<Sum>i = 3..<n. lcount (n - i - 1))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum card\n     ((\\<lambda>i.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> valid l}) `\n      {3..<n}) =\n    (\\<Sum>i = 3..<n. lcount (n - i - 1))", "proof (subst sum.reindex, unfold inj_on_def, clarsimp, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>(\\<lambda>xa. replicate x R @ B # xa) `\n                {l. length l = n - Suc x \\<and> valid l} =\n                (\\<lambda>x. replicate y R @ B # x) `\n                {l. length l = n - Suc y \\<and> valid l};\n        3 \\<le> x; x < n; 3 \\<le> y; y < n\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. sum (card \\<circ>\n         (\\<lambda>i.\n             (\\<lambda>l. replicate i R @ B # l) `\n             {l. length l = n - i - 1 \\<and> valid l}))\n     {3..<n} =\n    (\\<Sum>i = 3..<n. lcount (n - i - 1))", "case prems: (1 x y)"], ["proof (state)\nthis:\n  (\\<lambda>xa. replicate x R @ B # xa) `\n  {l. length l = n - Suc x \\<and> valid l} =\n  (\\<lambda>x. replicate y R @ B # x) `\n  {l. length l = n - Suc y \\<and> valid l}\n  3 \\<le> x\n  x < n\n  3 \\<le> y\n  y < n\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>(\\<lambda>xa. replicate x R @ B # xa) `\n                {l. length l = n - Suc x \\<and> valid l} =\n                (\\<lambda>x. replicate y R @ B # x) `\n                {l. length l = n - Suc y \\<and> valid l};\n        3 \\<le> x; x < n; 3 \\<le> y; y < n\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. sum (card \\<circ>\n         (\\<lambda>i.\n             (\\<lambda>l. replicate i R @ B # l) `\n             {l. length l = n - i - 1 \\<and> valid l}))\n     {3..<n} =\n    (\\<Sum>i = 3..<n. lcount (n - i - 1))", "with *[of y x] *[of x y] valid_line_aux[of \"n - Suc x\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>3 \\<le> y; y < x; x < n\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>l. replicate y R @ B # l) `\n                    {l. length l = n - Suc y \\<and> valid l} \\<inter>\n                    (\\<lambda>l. replicate x R @ B # l) `\n                    {l. length l = n - Suc x \\<and> valid l} =\n                    {}\n  \\<lbrakk>3 \\<le> x; x < y; y < n\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>l. replicate x R @ B # l) `\n                    {l. length l = n - Suc x \\<and> valid l} \\<inter>\n                    (\\<lambda>l. replicate y R @ B # l) `\n                    {l. length l = n - Suc y \\<and> valid l} =\n                    {}\n  {l. length l = n - Suc x \\<and> valid l} \\<noteq> {}\n  (\\<lambda>xa. replicate x R @ B # xa) `\n  {l. length l = n - Suc x \\<and> valid l} =\n  (\\<lambda>x. replicate y R @ B # x) `\n  {l. length l = n - Suc y \\<and> valid l}\n  3 \\<le> x\n  x < n\n  3 \\<le> y\n  y < n", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>3 \\<le> y; y < x; x < n\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>l. replicate y R @ B # l) `\n                    {l. length l = n - Suc y \\<and> valid l} \\<inter>\n                    (\\<lambda>l. replicate x R @ B # l) `\n                    {l. length l = n - Suc x \\<and> valid l} =\n                    {}\n  \\<lbrakk>3 \\<le> x; x < y; y < n\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>l. replicate x R @ B # l) `\n                    {l. length l = n - Suc x \\<and> valid l} \\<inter>\n                    (\\<lambda>l. replicate y R @ B # l) `\n                    {l. length l = n - Suc y \\<and> valid l} =\n                    {}\n  {l. length l = n - Suc x \\<and> valid l} \\<noteq> {}\n  (\\<lambda>xa. replicate x R @ B # xa) `\n  {l. length l = n - Suc x \\<and> valid l} =\n  (\\<lambda>x. replicate y R @ B # x) `\n  {l. length l = n - Suc y \\<and> valid l}\n  3 \\<le> x\n  x < n\n  3 \\<le> y\n  y < n\n\ngoal (1 subgoal):\n 1. x = y", "by - (rule linorder_cases[of x y], auto)"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. sum (card \\<circ>\n         (\\<lambda>i.\n             (\\<lambda>l. replicate i R @ B # l) `\n             {l. length l = n - i - 1 \\<and> valid l}))\n     {3..<n} =\n    (\\<Sum>i = 3..<n. lcount (n - i - 1))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sum (card \\<circ>\n         (\\<lambda>i.\n             (\\<lambda>l. replicate i R @ B # l) `\n             {l. length l = n - i - 1 \\<and> valid l}))\n     {3..<n} =\n    (\\<Sum>i = 3..<n. lcount (n - i - 1))", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. sum (card \\<circ>\n         (\\<lambda>i.\n             (\\<lambda>l. replicate i R @ B # l) `\n             {l. length l = n - i - 1 \\<and> valid l}))\n     {3..<n} =\n    (\\<Sum>i = 3..<n. lcount (n - i - 1))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (card \\<circ>\n         (\\<lambda>i.\n             (\\<lambda>l. replicate i R @ B # l) `\n             {l. length l = n - i - 1 \\<and> valid l}))\n     {3..<n} =\n    (\\<Sum>i = 3..<n. lcount (n - i - 1))", "by (simp add: lcount_def card_image[OF inj])"], ["proof (state)\nthis:\n  sum (card \\<circ>\n       (\\<lambda>i.\n           (\\<lambda>l. replicate i R @ B # l) `\n           {l. length l = n - i - 1 \\<and> valid l}))\n   {3..<n} =\n  (\\<Sum>i = 3..<n. lcount (n - i - 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum card\n   ((\\<lambda>i.\n        (\\<lambda>l. replicate i R @ B # l) `\n        {l. length l = n - i - 1 \\<and> valid l}) `\n    {3..<n}) =\n  (\\<Sum>i = 3..<n. lcount (n - i - 1))\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> (\\<lambda>i.\n                   (\\<lambda>l. replicate i R @ B # l) `\n                   {l. length l = n - i - 1 \\<and> valid l}) `\n               {3..<n} \\<Longrightarrow>\n       finite A", "qed (auto intro: finite_subset[OF _ finite_valid_length])"], ["proof (state)\nthis:\n  card\n   (\\<Union>i\\<in>{3..<n}.\n       (\\<lambda>l. replicate i R @ B # l) `\n       {l. length l = n - i - 1 \\<and> valid l}) =\n  (\\<Sum>i = 3..<n. lcount (n - i - 1))\n\ngoal (1 subgoal):\n 1. lcount n = lcount (n - 1) + 1 + (\\<Sum>i = 3..<n. lcount (n - i - 1))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lcount n = lcount (n - 1) + 1 + (\\<Sum>i = 3..<n. lcount (n - i - 1))", "apply (subst lcount_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {l. length l = n \\<and> valid l} =\n    lcount (n - 1) + 1 + (\\<Sum>i = 3..<n. lcount (n - i - 1))", "unfolding \\<open>?A = _\\<close> \\<open>?B = _\\<close> \\<open>?C = _\\<close> D_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ((#) B ` {l. length l = n - Suc 0 \\<and> valid l} \\<union>\n      (\\<Union>i\\<in>{3..<n}.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> valid l}) \\<union>\n      {replicate n R}) =\n    lcount (n - 1) + 1 + (\\<Sum>i = 3..<n. lcount (n - i - 1))", "apply (subst card_Un_disjoint)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite\n     ((#) B ` {l. length l = n - Suc 0 \\<and> valid l} \\<union>\n      (\\<Union>i\\<in>{3..<n}.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> valid l}))\n 2. finite {replicate n R}\n 3. ((#) B ` {l. length l = n - Suc 0 \\<and> valid l} \\<union>\n     (\\<Union>i\\<in>{3..<n}.\n         (\\<lambda>l. replicate i R @ B # l) `\n         {l. length l = n - i - 1 \\<and> valid l})) \\<inter>\n    {replicate n R} =\n    {}\n 4. card\n     ((#) B ` {l. length l = n - Suc 0 \\<and> valid l} \\<union>\n      (\\<Union>i\\<in>{3..<n}.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> valid l})) +\n    card {replicate n R} =\n    lcount (n - 1) + 1 + (\\<Sum>i = 3..<n. lcount (n - i - 1))", "(* Finiteness *)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite\n     ((#) B ` {l. length l = n - Suc 0 \\<and> valid l} \\<union>\n      (\\<Union>i\\<in>{3..<n}.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> valid l}))\n 2. finite {replicate n R}\n 3. ((#) B ` {l. length l = n - Suc 0 \\<and> valid l} \\<union>\n     (\\<Union>i\\<in>{3..<n}.\n         (\\<lambda>l. replicate i R @ B # l) `\n         {l. length l = n - i - 1 \\<and> valid l})) \\<inter>\n    {replicate n R} =\n    {}\n 4. card\n     ((#) B ` {l. length l = n - Suc 0 \\<and> valid l} \\<union>\n      (\\<Union>i\\<in>{3..<n}.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> valid l})) +\n    card {replicate n R} =\n    lcount (n - 1) + 1 + (\\<Sum>i = 3..<n. lcount (n - i - 1))", "apply (blast intro: finite_subset[OF _ finite_valid_length])+"], ["proof (prove)\ngoal (2 subgoals):\n 1. ((#) B ` {l. length l = n - Suc 0 \\<and> valid l} \\<union>\n     (\\<Union>i\\<in>{3..<n}.\n         (\\<lambda>l. replicate i R @ B # l) `\n         {l. length l = n - i - 1 \\<and> valid l})) \\<inter>\n    {replicate n R} =\n    {}\n 2. card\n     ((#) B ` {l. length l = n - Suc 0 \\<and> valid l} \\<union>\n      (\\<Union>i\\<in>{3..<n}.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> valid l})) +\n    card {replicate n R} =\n    lcount (n - 1) + 1 + (\\<Sum>i = 3..<n. lcount (n - i - 1))", "(* Disjointness *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ((#) B ` {l. length l = n - Suc 0 \\<and> valid l} \\<union>\n     (\\<Union>i\\<in>{3..<n}.\n         (\\<lambda>l. replicate i R @ B # l) `\n         {l. length l = n - i - 1 \\<and> valid l})) \\<inter>\n    {replicate n R} =\n    {}\n 2. card\n     ((#) B ` {l. length l = n - Suc 0 \\<and> valid l} \\<union>\n      (\\<Union>i\\<in>{3..<n}.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> valid l})) +\n    card {replicate n R} =\n    lcount (n - 1) + 1 + (\\<Sum>i = 3..<n. lcount (n - i - 1))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((#) B ` {l. length l = n - Suc 0 \\<and> valid l} \\<union>\n     (\\<Union>i\\<in>{3..<n}.\n         (\\<lambda>l. replicate i R @ B # l) `\n         {l. length l = n - i - 1 \\<and> valid l})) \\<inter>\n    {replicate n R} =\n    {}", "using Cons_replicate_eq[of B _ n R] replicate_unequal_aux"], ["proof (prove)\nusing this:\n  (B # ?xs = replicate n R) =\n  (B = R \\<and> 0 < n \\<and> ?xs = replicate (n - 1) B)\n  ?x < ?y \\<Longrightarrow>\n  replicate ?x R @ B # ?l \\<noteq> replicate ?y R @ B # ?l'\n\ngoal (1 subgoal):\n 1. ((#) B ` {l. length l = n - Suc 0 \\<and> valid l} \\<union>\n     (\\<Union>i\\<in>{3..<n}.\n         (\\<lambda>l. replicate i R @ B # l) `\n         {l. length l = n - i - 1 \\<and> valid l})) \\<inter>\n    {replicate n R} =\n    {}", "by fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ((#) B ` {l. length l = n - Suc 0 \\<and> valid l} \\<union>\n      (\\<Union>i\\<in>{3..<n}.\n          (\\<lambda>l. replicate i R @ B # l) `\n          {l. length l = n - i - 1 \\<and> valid l})) +\n    card {replicate n R} =\n    lcount (n - 1) + 1 + (\\<Sum>i = 3..<n. lcount (n - i - 1))", "apply (subst card_Un_disjoint)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite ((#) B ` {l. length l = n - Suc 0 \\<and> valid l})\n 2. finite\n     (\\<Union>i\\<in>{3..<n}.\n         (\\<lambda>l. replicate i R @ B # l) `\n         {l. length l = n - i - 1 \\<and> valid l})\n 3. (#) B ` {l. length l = n - Suc 0 \\<and> valid l} \\<inter>\n    (\\<Union>i\\<in>{3..<n}.\n        (\\<lambda>l. replicate i R @ B # l) `\n        {l. length l = n - i - 1 \\<and> valid l}) =\n    {}\n 4. card ((#) B ` {l. length l = n - Suc 0 \\<and> valid l}) +\n    card\n     (\\<Union>i\\<in>{3..<n}.\n         (\\<lambda>l. replicate i R @ B # l) `\n         {l. length l = n - i - 1 \\<and> valid l}) +\n    card {replicate n R} =\n    lcount (n - 1) + 1 + (\\<Sum>i = 3..<n. lcount (n - i - 1))", "(* Finiteness *)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite ((#) B ` {l. length l = n - Suc 0 \\<and> valid l})\n 2. finite\n     (\\<Union>i\\<in>{3..<n}.\n         (\\<lambda>l. replicate i R @ B # l) `\n         {l. length l = n - i - 1 \\<and> valid l})\n 3. (#) B ` {l. length l = n - Suc 0 \\<and> valid l} \\<inter>\n    (\\<Union>i\\<in>{3..<n}.\n        (\\<lambda>l. replicate i R @ B # l) `\n        {l. length l = n - i - 1 \\<and> valid l}) =\n    {}\n 4. card ((#) B ` {l. length l = n - Suc 0 \\<and> valid l}) +\n    card\n     (\\<Union>i\\<in>{3..<n}.\n         (\\<lambda>l. replicate i R @ B # l) `\n         {l. length l = n - i - 1 \\<and> valid l}) +\n    card {replicate n R} =\n    lcount (n - 1) + 1 + (\\<Sum>i = 3..<n. lcount (n - i - 1))", "apply (blast intro: finite_subset[OF _ finite_valid_length])+"], ["proof (prove)\ngoal (2 subgoals):\n 1. (#) B ` {l. length l = n - Suc 0 \\<and> valid l} \\<inter>\n    (\\<Union>i\\<in>{3..<n}.\n        (\\<lambda>l. replicate i R @ B # l) `\n        {l. length l = n - i - 1 \\<and> valid l}) =\n    {}\n 2. card ((#) B ` {l. length l = n - Suc 0 \\<and> valid l}) +\n    card\n     (\\<Union>i\\<in>{3..<n}.\n         (\\<lambda>l. replicate i R @ B # l) `\n         {l. length l = n - i - 1 \\<and> valid l}) +\n    card {replicate n R} =\n    lcount (n - 1) + 1 + (\\<Sum>i = 3..<n. lcount (n - i - 1))", "(* Disjointness & final rewriting *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (#) B ` {l. length l = n - Suc 0 \\<and> valid l} \\<inter>\n    (\\<Union>i\\<in>{3..<n}.\n        (\\<lambda>l. replicate i R @ B # l) `\n        {l. length l = n - i - 1 \\<and> valid l}) =\n    {}\n 2. card ((#) B ` {l. length l = n - Suc 0 \\<and> valid l}) +\n    card\n     (\\<Union>i\\<in>{3..<n}.\n         (\\<lambda>l. replicate i R @ B # l) `\n         {l. length l = n - i - 1 \\<and> valid l}) +\n    card {replicate n R} =\n    lcount (n - 1) + 1 + (\\<Sum>i = 3..<n. lcount (n - i - 1))", "unfolding 1 2 3"], ["proof (prove)\ngoal (2 subgoals):\n 1. (#) B ` {l. length l = n - Suc 0 \\<and> valid l} \\<inter>\n    (\\<Union>i\\<in>{3..<n}.\n        (\\<lambda>l. replicate i R @ B # l) `\n        {l. length l = n - i - 1 \\<and> valid l}) =\n    {}\n 2. lcount (n - 1) + (\\<Sum>i = 3..<n. lcount (n - i - 1)) + 1 =\n    lcount (n - 1) + 1 + (\\<Sum>i = 3..<n. lcount (n - i - 1))", "by (auto simp: Cons_replicate_eq Cons_eq_append_conv)"], ["proof (state)\nthis:\n  lcount n = lcount (n - 1) + 1 + (\\<Sum>i = 3..<n. lcount (n - i - 1))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Verification of Program\\<close>"], ["", "subsubsection \\<open>Inner Loop: Summation\\<close>"], ["", "definition \"sum_prog \\<Phi> l u f \\<equiv> \n    nfoldli [l..<u] (\\<lambda>_. True) (\\<lambda>i s. doN {\n      ASSERT (\\<Phi> i); \n      RETURN (s+f i)\n    }) 0\""], ["", "lemma sum_spec[THEN SPEC_trans, refine_vcg]: \n    assumes \"l\\<le>u\"\n    assumes \"\\<And>i. l\\<le>i \\<Longrightarrow> i<u \\<Longrightarrow> \\<Phi> i\" \n    shows \"sum_prog \\<Phi> l u f \\<le> SPEC (\\<lambda>r. r=(\\<Sum>i=l..<u. f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_prog \\<Phi> l u f \\<le> SPEC (\\<lambda>r. r = sum f {l..<u})", "unfolding sum_prog_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli [l..<u] (\\<lambda>_. True)\n     (\\<lambda>i s.\n         ASSERT (\\<Phi> i) \\<bind> (\\<lambda>_. RETURN (s + f i)))\n     (0::'a)\n    \\<le> SPEC (\\<lambda>r. r = sum f {l..<u})", "supply nfoldli_upt_rule[where I=\"\\<lambda>j s. s=(\\<Sum>i=l..<j. f i)\", refine_vcg]"], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli [l..<u] (\\<lambda>_. True)\n     (\\<lambda>i s.\n         ASSERT (\\<Phi> i) \\<bind> (\\<lambda>_. RETURN (s + f i)))\n     (0::'a)\n    \\<le> SPEC (\\<lambda>r. r = sum f {l..<u})", "apply refine_vcg"], ["proof (prove)\ngoal (5 subgoals):\n 1. l \\<le> u\n 2. (0::'a) = sum f {l..<l}\n 3. \\<And>i \\<sigma>.\n       \\<lbrakk>l \\<le> i; i < u; \\<sigma> = sum f {l..<i}; True\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> i\n 4. \\<And>i \\<sigma>.\n       \\<lbrakk>l \\<le> i; i < u; \\<sigma> = sum f {l..<i}; True;\n        \\<Phi> i\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> + f i = sum f {l..<i + 1}\n 5. \\<And>i \\<sigma>.\n       \\<lbrakk>l \\<le> i; i \\<le> u; \\<sigma> = sum f {l..<i};\n        \\<not> True\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = sum f {l..<u}", "using assms"], ["proof (prove)\nusing this:\n  l \\<le> u\n  \\<lbrakk>l \\<le> ?i; ?i < u\\<rbrakk> \\<Longrightarrow> \\<Phi> ?i\n\ngoal (5 subgoals):\n 1. l \\<le> u\n 2. (0::'a) = sum f {l..<l}\n 3. \\<And>i \\<sigma>.\n       \\<lbrakk>l \\<le> i; i < u; \\<sigma> = sum f {l..<i}; True\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> i\n 4. \\<And>i \\<sigma>.\n       \\<lbrakk>l \\<le> i; i < u; \\<sigma> = sum f {l..<i}; True;\n        \\<Phi> i\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> + f i = sum f {l..<i + 1}\n 5. \\<And>i \\<sigma>.\n       \\<lbrakk>l \\<le> i; i \\<le> u; \\<sigma> = sum f {l..<i};\n        \\<not> True\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = sum f {l..<u}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Main Program\\<close>"], ["", "definition \"icount M \\<equiv> doN {\n    ASSERT (M>2);\n    let c = op_array_replicate (M+1) 0;\n    let c = c[0:=1, 1:=1, 2:=1, 3:=2];\n    \n    ASSERT (\\<forall>i<4. c!i = lcount i);\n    \n    c\\<leftarrow>nfoldli [4..<M+1] (\\<lambda>_. True) (\\<lambda>n c. doN {\n      \\<^cancel>\\<open>\\<open>let sum =    (\\<Sum>i=3..<n. c!(n-i-1));\\<close>\\<close>\n      sum \\<leftarrow> sum_prog (\\<lambda>i. n-i-1 < length c) 3 n (\\<lambda>i. c!(n-i-1));\n      ASSERT (n-1<length c \\<and> n<length c);\n      RETURN (c[n := c!(n-1) + 1 + sum])\n    }) c;\n    \n    ASSERT (\\<forall>i\\<le>M. c!i = lcount i);\n    \n    ASSERT (M < length c);\n    RETURN (c!M)\n  }\""], ["", "subsubsection \\<open>Abstract Correctness Statement\\<close>"], ["", "theorem icount_correct: \"M>2 \\<Longrightarrow> icount M \\<le> SPEC (\\<lambda>r. r=lcount M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 < M \\<Longrightarrow> icount M \\<le> SPEC (\\<lambda>r. r = lcount M)", "unfolding icount_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 < M \\<Longrightarrow>\n    ASSERT (2 < M) \\<bind>\n    (\\<lambda>_.\n        let c = op_array_replicate (M + 1) 0;\n            c = c[0 := 1, 1 := 1, 2 := 1, 3 := 2]\n        in ASSERT (\\<forall>i<4. c ! i = lcount i) \\<bind>\n           (\\<lambda>_.\n               nfoldli [4..<M + 1] (\\<lambda>_. True)\n                (\\<lambda>n c.\n                    sum_prog (\\<lambda>i. n - i - 1 < length c) 3 n\n                     (\\<lambda>i. c ! (n - i - 1)) \\<bind>\n                    (\\<lambda>sum.\n                        ASSERT\n                         (n - 1 < length c \\<and> n < length c) \\<bind>\n                        (\\<lambda>_.\n                            RETURN (c[n := c ! (n - 1) + 1 + sum]))))\n                c \\<bind>\n               (\\<lambda>c.\n                   ASSERT (\\<forall>i\\<le>M. c ! i = lcount i) \\<bind>\n                   (\\<lambda>_.\n                       ASSERT (M < length c) \\<bind>\n                       (\\<lambda>_. RETURN (c ! M))))))\n    \\<le> SPEC (\\<lambda>r. r = lcount M)", "thm nfoldli_upt_rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 < M \\<Longrightarrow>\n    ASSERT (2 < M) \\<bind>\n    (\\<lambda>_.\n        let c = op_array_replicate (M + 1) 0;\n            c = c[0 := 1, 1 := 1, 2 := 1, 3 := 2]\n        in ASSERT (\\<forall>i<4. c ! i = lcount i) \\<bind>\n           (\\<lambda>_.\n               nfoldli [4..<M + 1] (\\<lambda>_. True)\n                (\\<lambda>n c.\n                    sum_prog (\\<lambda>i. n - i - 1 < length c) 3 n\n                     (\\<lambda>i. c ! (n - i - 1)) \\<bind>\n                    (\\<lambda>sum.\n                        ASSERT\n                         (n - 1 < length c \\<and> n < length c) \\<bind>\n                        (\\<lambda>_.\n                            RETURN (c[n := c ! (n - 1) + 1 + sum]))))\n                c \\<bind>\n               (\\<lambda>c.\n                   ASSERT (\\<forall>i\\<le>M. c ! i = lcount i) \\<bind>\n                   (\\<lambda>_.\n                       ASSERT (M < length c) \\<bind>\n                       (\\<lambda>_. RETURN (c ! M))))))\n    \\<le> SPEC (\\<lambda>r. r = lcount M)", "supply nfoldli_upt_rule[where \n      I=\"\\<lambda>n c. length c = M+1 \\<and> ( \\<forall>i<n. c!i = lcount i)\", refine_vcg]"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 < M \\<Longrightarrow>\n    ASSERT (2 < M) \\<bind>\n    (\\<lambda>_.\n        let c = op_array_replicate (M + 1) 0;\n            c = c[0 := 1, 1 := 1, 2 := 1, 3 := 2]\n        in ASSERT (\\<forall>i<4. c ! i = lcount i) \\<bind>\n           (\\<lambda>_.\n               nfoldli [4..<M + 1] (\\<lambda>_. True)\n                (\\<lambda>n c.\n                    sum_prog (\\<lambda>i. n - i - 1 < length c) 3 n\n                     (\\<lambda>i. c ! (n - i - 1)) \\<bind>\n                    (\\<lambda>sum.\n                        ASSERT\n                         (n - 1 < length c \\<and> n < length c) \\<bind>\n                        (\\<lambda>_.\n                            RETURN (c[n := c ! (n - 1) + 1 + sum]))))\n                c \\<bind>\n               (\\<lambda>c.\n                   ASSERT (\\<forall>i\\<le>M. c ! i = lcount i) \\<bind>\n                   (\\<lambda>_.\n                       ASSERT (M < length c) \\<bind>\n                       (\\<lambda>_. RETURN (c ! M))))))\n    \\<le> SPEC (\\<lambda>r. r = lcount M)", "apply refine_vcg"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>2 < M; 2 < M; i < 4\\<rbrakk>\n       \\<Longrightarrow> (op_array_replicate (M + 1) 0)\n                         [0 := 1, 1 := 1, 2 := 1, 3 := 2] ! i =\n                         lcount i\n 2. \\<lbrakk>2 < M; 2 < M;\n     \\<forall>i<4.\n        (op_array_replicate (M + 1) 0)[0 := 1, 1 := 1, 2 := 1, 3 := 2] ! i =\n        lcount i\\<rbrakk>\n    \\<Longrightarrow> 4 \\<le> M + 1\n 3. \\<lbrakk>2 < M; 2 < M;\n     \\<forall>i<4.\n        (op_array_replicate (M + 1) 0)[0 := 1, 1 := 1, 2 := 1, 3 := 2] ! i =\n        lcount i\\<rbrakk>\n    \\<Longrightarrow> length\n                       ((op_array_replicate (M + 1) 0)\n                        [0 := 1, 1 := 1, 2 := 1, 3 := 2]) =\n                      M + 1\n 4. \\<And>i \\<sigma>.\n       \\<lbrakk>2 < M; 2 < M;\n        \\<forall>i<4.\n           (op_array_replicate (M + 1) 0)[0 := 1, 1 := 1, 2 := 1, 3 := 2] !\n           i =\n           lcount i;\n        4 \\<le> i; i < M + 1;\n        length \\<sigma> = M + 1 \\<and>\n        (\\<forall>ia<i. \\<sigma> ! ia = lcount ia);\n        True\\<rbrakk>\n       \\<Longrightarrow> 3 \\<le> i\n 5. \\<And>i \\<sigma> ia.\n       \\<lbrakk>2 < M; 2 < M;\n        \\<forall>i<4.\n           (op_array_replicate (M + 1) 0)[0 := 1, 1 := 1, 2 := 1, 3 := 2] !\n           i =\n           lcount i;\n        4 \\<le> i; i < M + 1;\n        length \\<sigma> = M + 1 \\<and>\n        (\\<forall>ia<i. \\<sigma> ! ia = lcount ia);\n        True; 3 \\<le> ia; ia < i\\<rbrakk>\n       \\<Longrightarrow> i - ia - 1 < length \\<sigma>\n 6. \\<And>i \\<sigma> x.\n       \\<lbrakk>2 < M; 2 < M;\n        \\<forall>i<4.\n           (op_array_replicate (M + 1) 0)[0 := 1, 1 := 1, 2 := 1, 3 := 2] !\n           i =\n           lcount i;\n        4 \\<le> i; i < M + 1;\n        length \\<sigma> = M + 1 \\<and>\n        (\\<forall>ia<i. \\<sigma> ! ia = lcount ia);\n        True; x = (\\<Sum>ia = 3..<i. \\<sigma> ! (i - ia - 1))\\<rbrakk>\n       \\<Longrightarrow> i - 1 < length \\<sigma>\n 7. \\<And>i \\<sigma> x.\n       \\<lbrakk>2 < M; 2 < M;\n        \\<forall>i<4.\n           (op_array_replicate (M + 1) 0)[0 := 1, 1 := 1, 2 := 1, 3 := 2] !\n           i =\n           lcount i;\n        4 \\<le> i; i < M + 1;\n        length \\<sigma> = M + 1 \\<and>\n        (\\<forall>ia<i. \\<sigma> ! ia = lcount ia);\n        True; x = (\\<Sum>ia = 3..<i. \\<sigma> ! (i - ia - 1))\\<rbrakk>\n       \\<Longrightarrow> i < length \\<sigma>\n 8. \\<And>i \\<sigma> x.\n       \\<lbrakk>2 < M; 2 < M;\n        \\<forall>i<4.\n           (op_array_replicate (M + 1) 0)[0 := 1, 1 := 1, 2 := 1, 3 := 2] !\n           i =\n           lcount i;\n        4 \\<le> i; i < M + 1;\n        length \\<sigma> = M + 1 \\<and>\n        (\\<forall>ia<i. \\<sigma> ! ia = lcount ia);\n        True; x = (\\<Sum>ia = 3..<i. \\<sigma> ! (i - ia - 1));\n        i - 1 < length \\<sigma> \\<and> i < length \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> length\n                          (\\<sigma>[i := \\<sigma> ! (i - 1) + 1 + x]) =\n                         M + 1\n 9. \\<And>i \\<sigma> x ia.\n       \\<lbrakk>2 < M; 2 < M;\n        \\<forall>i<4.\n           (op_array_replicate (M + 1) 0)[0 := 1, 1 := 1, 2 := 1, 3 := 2] !\n           i =\n           lcount i;\n        4 \\<le> i; i < M + 1;\n        length \\<sigma> = M + 1 \\<and>\n        (\\<forall>ia<i. \\<sigma> ! ia = lcount ia);\n        True; x = (\\<Sum>ia = 3..<i. \\<sigma> ! (i - ia - 1));\n        i - 1 < length \\<sigma> \\<and> i < length \\<sigma>;\n        ia < i + 1\\<rbrakk>\n       \\<Longrightarrow> \\<sigma>[i := \\<sigma> ! (i - 1) + 1 + x] ! ia =\n                         lcount ia\n 10. \\<And>i \\<sigma> ia.\n        \\<lbrakk>2 < M; 2 < M;\n         \\<forall>i<4.\n            (op_array_replicate (M + 1) 0)[0 := 1, 1 := 1, 2 := 1, 3 := 2] !\n            i =\n            lcount i;\n         4 \\<le> i; i \\<le> M + 1;\n         length \\<sigma> = M + 1 \\<and>\n         (\\<forall>ia<i. \\<sigma> ! ia = lcount ia);\n         \\<not> True; ia \\<le> M\\<rbrakk>\n        \\<Longrightarrow> \\<sigma> ! ia = lcount ia\nA total of 15 subgoals...", "apply (auto simp:)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>2 < M; i < 4\\<rbrakk>\n       \\<Longrightarrow> (Suc 0 # (replicate M 0)\n                          [0 := Suc 0, Suc 0 := Suc 0, 2 := 2]) !\n                         i =\n                         lcount i\n 2. \\<And>i \\<sigma> ia.\n       \\<lbrakk>\\<forall>i<4.\n                   (Suc 0 # (replicate M 0)\n                    [0 := Suc 0, Suc 0 := Suc 0, 2 := 2]) !\n                   i =\n                   lcount i;\n        4 \\<le> i; ia < Suc i; length \\<sigma> = Suc M;\n        \\<forall>ia<i. \\<sigma> ! ia = lcount ia; i - Suc 0 < Suc M;\n        i < Suc M\\<rbrakk>\n       \\<Longrightarrow> \\<sigma>\n                         [i := Suc (lcount (i - Suc 0) +\n                                    (\\<Sum>ia = 3..<i.\n  lcount (i - Suc ia)))] !\n                         ia =\n                         lcount ia", "subgoal for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 < M; i < 4\\<rbrakk>\n    \\<Longrightarrow> (Suc 0 # (replicate M 0)\n                       [0 := Suc 0, Suc 0 := Suc 0, 2 := 2]) !\n                      i =\n                      lcount i", "apply (subgoal_tac \"i\\<in>{0,1,2,3}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>2 < M; i < 4; i \\<in> {0, 1, 2, 3}\\<rbrakk>\n    \\<Longrightarrow> (Suc 0 # (replicate M 0)\n                       [0 := Suc 0, Suc 0 := Suc 0, 2 := 2]) !\n                      i =\n                      lcount i\n 2. \\<lbrakk>2 < M; i < 4\\<rbrakk> \\<Longrightarrow> i \\<in> {0, 1, 2, 3}", "using lcounts_init"], ["proof (prove)\nusing this:\n  lcount 0 = 1\n  lcount 1 = 1\n  lcount 2 = 1\n  lcount 3 = 2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>2 < M; i < 4; i \\<in> {0, 1, 2, 3}\\<rbrakk>\n    \\<Longrightarrow> (Suc 0 # (replicate M 0)\n                       [0 := Suc 0, Suc 0 := Suc 0, 2 := 2]) !\n                      i =\n                      lcount i\n 2. \\<lbrakk>2 < M; i < 4\\<rbrakk> \\<Longrightarrow> i \\<in> {0, 1, 2, 3}", "by (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i \\<sigma> ia.\n       \\<lbrakk>\\<forall>i<4.\n                   (Suc 0 # (replicate M 0)\n                    [0 := Suc 0, Suc 0 := Suc 0, 2 := 2]) !\n                   i =\n                   lcount i;\n        4 \\<le> i; ia < Suc i; length \\<sigma> = Suc M;\n        \\<forall>ia<i. \\<sigma> ! ia = lcount ia; i - Suc 0 < Suc M;\n        i < Suc M\\<rbrakk>\n       \\<Longrightarrow> \\<sigma>\n                         [i := Suc (lcount (i - Suc 0) +\n                                    (\\<Sum>ia = 3..<i.\n  lcount (i - Suc ia)))] !\n                         ia =\n                         lcount ia", "subgoal for i c j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i<4.\n                (Suc 0 # (replicate M 0)\n                 [0 := Suc 0, Suc 0 := Suc 0, 2 := 2]) !\n                i =\n                lcount i;\n     4 \\<le> i; j < Suc i; length c = Suc M;\n     \\<forall>ia<i. c ! ia = lcount ia; i - Suc 0 < Suc M;\n     i < Suc M\\<rbrakk>\n    \\<Longrightarrow> c[i := Suc (lcount (i - Suc 0) +\n                                  (\\<Sum>ia = 3..<i.\nlcount (i - Suc ia)))] !\n                      j =\n                      lcount j", "apply (cases \"j<i\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>i<4.\n                (Suc 0 # (replicate M 0)\n                 [0 := Suc 0, Suc 0 := Suc 0, 2 := 2]) !\n                i =\n                lcount i;\n     4 \\<le> i; j < Suc i; length c = Suc M;\n     \\<forall>ia<i. c ! ia = lcount ia; i - Suc 0 < Suc M; i < Suc M;\n     j < i\\<rbrakk>\n    \\<Longrightarrow> c[i := Suc (lcount (i - Suc 0) +\n                                  (\\<Sum>ia = 3..<i.\nlcount (i - Suc ia)))] !\n                      j =\n                      lcount j\n 2. \\<lbrakk>\\<forall>i<4.\n                (Suc 0 # (replicate M 0)\n                 [0 := Suc 0, Suc 0 := Suc 0, 2 := 2]) !\n                i =\n                lcount i;\n     4 \\<le> i; j < Suc i; length c = Suc M;\n     \\<forall>ia<i. c ! ia = lcount ia; i - Suc 0 < Suc M; i < Suc M;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> c[i := Suc (lcount (i - Suc 0) +\n                                  (\\<Sum>ia = 3..<i.\nlcount (i - Suc ia)))] !\n                      j =\n                      lcount j", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i<4.\n                (Suc 0 # (replicate M 0)\n                 [0 := Suc 0, Suc 0 := Suc 0, 2 := 2]) !\n                i =\n                lcount i;\n     4 \\<le> i; j < Suc i; length c = Suc M;\n     \\<forall>ia<i. c ! ia = lcount ia; i - Suc 0 < Suc M; i < Suc M;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> c[i := Suc (lcount (i - Suc 0) +\n                                  (\\<Sum>ia = 3..<i.\nlcount (i - Suc ia)))] !\n                      j =\n                      lcount j", "apply (subgoal_tac \"i=j\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>i<4.\n                (Suc 0 # (replicate M 0)\n                 [0 := Suc 0, Suc 0 := Suc 0, 2 := 2]) !\n                i =\n                lcount i;\n     4 \\<le> i; j < Suc i; length c = Suc M;\n     \\<forall>ia<i. c ! ia = lcount ia; i - Suc 0 < Suc M; i < Suc M;\n     \\<not> j < i; i = j\\<rbrakk>\n    \\<Longrightarrow> c[i := Suc (lcount (i - Suc 0) +\n                                  (\\<Sum>ia = 3..<i.\nlcount (i - Suc ia)))] !\n                      j =\n                      lcount j\n 2. \\<lbrakk>\\<forall>i<4.\n                (Suc 0 # (replicate M 0)\n                 [0 := Suc 0, Suc 0 := Suc 0, 2 := 2]) !\n                i =\n                lcount i;\n     4 \\<le> i; j < Suc i; length c = Suc M;\n     \\<forall>ia<i. c ! ia = lcount ia; i - Suc 0 < Suc M; i < Suc M;\n     \\<not> j < i\\<rbrakk>\n    \\<Longrightarrow> i = j", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i<4.\n                (Suc 0 # (replicate M 0)\n                 [0 := Suc 0, Suc 0 := Suc 0, 2 := 2]) !\n                i =\n                lcount i;\n     4 \\<le> j; length c = Suc M; \\<forall>i<j. c ! i = lcount i;\n     j - Suc 0 < Suc M; j < Suc M; i = j\\<rbrakk>\n    \\<Longrightarrow> Suc (lcount (j - Suc 0) +\n                           (\\<Sum>i = 3..<j. lcount (j - Suc i))) =\n                      lcount j", "apply (subst lcrec[where n=j])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>i<4.\n                (Suc 0 # (replicate M 0)\n                 [0 := Suc 0, Suc 0 := Suc 0, 2 := 2]) !\n                i =\n                lcount i;\n     4 \\<le> j; length c = Suc M; \\<forall>i<j. c ! i = lcount i;\n     j - Suc 0 < Suc M; j < Suc M; i = j\\<rbrakk>\n    \\<Longrightarrow> 3 < j\n 2. \\<lbrakk>\\<forall>i<4.\n                (Suc 0 # (replicate M 0)\n                 [0 := Suc 0, Suc 0 := Suc 0, 2 := 2]) !\n                i =\n                lcount i;\n     4 \\<le> j; length c = Suc M; \\<forall>i<j. c ! i = lcount i;\n     j - Suc 0 < Suc M; j < Suc M; i = j\\<rbrakk>\n    \\<Longrightarrow> Suc (lcount (j - Suc 0) +\n                           (\\<Sum>i = 3..<j. lcount (j - Suc i))) =\n                      lcount (j - 1) + 1 +\n                      (\\<Sum>i = 3..<j. lcount (j - i - 1))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Refinement to Imperative Code\\<close>"], ["", "sepref_definition icount_impl is \"icount\" :: \"nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, icount) \\<in> nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "unfolding icount_def sum_prog_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>M.\n        ASSERT (2 < M) \\<bind>\n        (\\<lambda>_.\n            let c = op_array_replicate (M + 1) 0;\n                c = c[0 := 1, 1 := 1, 2 := 1, 3 := 2]\n            in ASSERT (\\<forall>i<4. c ! i = lcount i) \\<bind>\n               (\\<lambda>_.\n                   nfoldli [4..<M + 1] (\\<lambda>_. True)\n                    (\\<lambda>n c.\n                        nfoldli [3..<n] (\\<lambda>_. True)\n                         (\\<lambda>i s.\n                             ASSERT (n - i - 1 < length c) \\<bind>\n                             (\\<lambda>_. RETURN (s + c ! (n - i - 1))))\n                         0 \\<bind>\n                        (\\<lambda>sum.\n                            ASSERT\n                             (n - 1 < length c \\<and> n < length c) \\<bind>\n                            (\\<lambda>_.\n                                RETURN (c[n := c ! (n - 1) + 1 + sum]))))\n                    c \\<bind>\n                   (\\<lambda>c.\n                       ASSERT (\\<forall>i\\<le>M. c ! i = lcount i) \\<bind>\n                       (\\<lambda>_.\n                           ASSERT (M < length c) \\<bind>\n                           (\\<lambda>_. RETURN (c ! M)))))))\n    \\<in> nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by sepref"], ["", "subsubsection \\<open>Main Correctness Statement\\<close>"], ["", "text \\<open>\n  As the main theorem, we prove the following Hoare triple, stating:\n  starting from the empty heap, our program will compute the correct result (@{term \"lcount M\"}).\n  \\<close>"], ["", "theorem icount_impl_correct: \n    \"M>2 \\<Longrightarrow> <emp> icount_impl M <\\<lambda>r. \\<up>(r = lcount M)>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 < M \\<Longrightarrow>\n    <emp> icount_impl M <\\<lambda>r. \\<up> (r = lcount M)>\\<^sub>t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 < M \\<Longrightarrow>\n    <emp> icount_impl M <\\<lambda>r. \\<up> (r = lcount M)>\\<^sub>t", "note A = icount_impl.refine[to_hnr, THEN hn_refineD]"], ["proof (state)\nthis:\n  nofail (icount $ ?x1) \\<Longrightarrow>\n  <hn_val nat_rel ?x1\n    ?xi1> icount_impl $\n          ?xi1 <\\<lambda>r.\n                   hn_val nat_rel ?x1 ?xi1 *\n                   (\\<exists>\\<^sub>Ax.\n                       nat_assn x r *\n                       \\<up> (RETURN x \\<le> icount $ ?x1))>\\<^sub>t\n\ngoal (1 subgoal):\n 1. 2 < M \\<Longrightarrow>\n    <emp> icount_impl M <\\<lambda>r. \\<up> (r = lcount M)>\\<^sub>t", "note A = A[unfolded autoref_tag_defs]"], ["proof (state)\nthis:\n  nofail (icount ?x1) \\<Longrightarrow>\n  <hn_val nat_rel ?x1\n    ?xi1> icount_impl\n           ?xi1 <\\<lambda>r.\n                    hn_val nat_rel ?x1 ?xi1 *\n                    (\\<exists>\\<^sub>Ax.\n                        nat_assn x r *\n                        \\<up> (RETURN x \\<le> icount ?x1))>\\<^sub>t\n\ngoal (1 subgoal):\n 1. 2 < M \\<Longrightarrow>\n    <emp> icount_impl M <\\<lambda>r. \\<up> (r = lcount M)>\\<^sub>t", "note A = A[unfolded hn_ctxt_def pure_def, of M M, simplified]"], ["proof (state)\nthis:\n  nofail (icount M) \\<Longrightarrow>\n  <emp> icount_impl M\n  <\\<lambda>r.\n      \\<exists>\\<^sub>Ax.\n         true * \\<up> (r = x \\<and> RETURN x \\<le> icount M)>\n\ngoal (1 subgoal):\n 1. 2 < M \\<Longrightarrow>\n    <emp> icount_impl M <\\<lambda>r. \\<up> (r = lcount M)>\\<^sub>t", "note [sep_heap_rules] = A"], ["proof (state)\nthis:\n  nofail (icount M) \\<Longrightarrow>\n  <emp> icount_impl M\n  <\\<lambda>r.\n      \\<exists>\\<^sub>Ax.\n         true * \\<up> (r = x \\<and> RETURN x \\<le> icount M)>\n\ngoal (1 subgoal):\n 1. 2 < M \\<Longrightarrow>\n    <emp> icount_impl M <\\<lambda>r. \\<up> (r = lcount M)>\\<^sub>t", "assume \"M>2\""], ["proof (state)\nthis:\n  2 < M\n\ngoal (1 subgoal):\n 1. 2 < M \\<Longrightarrow>\n    <emp> icount_impl M <\\<lambda>r. \\<up> (r = lcount M)>\\<^sub>t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> icount_impl M <\\<lambda>r. \\<up> (r = lcount M)>\\<^sub>t", "using icount_correct[OF \\<open>M>2\\<close>]"], ["proof (prove)\nusing this:\n  icount M \\<le> SPEC (\\<lambda>r. r = lcount M)\n\ngoal (1 subgoal):\n 1. <emp> icount_impl M <\\<lambda>r. \\<up> (r = lcount M)>\\<^sub>t", "by (sep_auto simp: refine_pw_simps pw_le_iff)"], ["proof (state)\nthis:\n  <emp> icount_impl M <\\<lambda>r. \\<up> (r = lcount M)>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Code Export\\<close>"], ["", "export_code icount_impl in SML_imp module_name Tiling"], ["", "export_code icount_impl in OCaml_imp module_name Tiling"], ["", "export_code icount_impl in Haskell module_name Tiling"], ["", "export_code icount_impl in Scala_imp module_name Tiling"], ["", "subsection \\<open>Alternative Problem Specification\\<close>"], ["", "text \\<open>Alternative definition of a valid line that we used in the competition\\<close>"], ["", "context fixes l :: \"color list\" begin"], ["", "inductive valid_point where\n    \"\\<lbrakk>i+2<length l; l!i=R; l!(i+1) = R; l!(i+2) = R \\<rbrakk> \\<Longrightarrow> valid_point i\"\n  | \"\\<lbrakk>1\\<le>i;i+1<length l; l!(i-1)=R; l!(i) = R; l!(i+1) = R \\<rbrakk> \\<Longrightarrow> valid_point i\"\n  | \"\\<lbrakk>2\\<le>i; i<length l; l!(i-2)=R; l!(i-1) = R; l!(i) = R \\<rbrakk> \\<Longrightarrow> valid_point i\"\n  | \"\\<lbrakk> i<length l; l!i=B\\<rbrakk> \\<Longrightarrow> valid_point i\""], ["", "definition \"valid_line = (\\<forall>i<length l. valid_point i)\""], ["", "end"], ["", "lemma valid_lineI:\n  assumes \"\\<And> i. i < length l \\<Longrightarrow> valid_point l i\"\n  shows \"valid_line l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_line l", "using assms"], ["proof (prove)\nusing this:\n  ?i < length l \\<Longrightarrow> valid_point l ?i\n\ngoal (1 subgoal):\n 1. valid_line l", "unfolding valid_line_def"], ["proof (prove)\nusing this:\n  ?i < length l \\<Longrightarrow> valid_point l ?i\n\ngoal (1 subgoal):\n 1. \\<forall>i<length l. valid_point l i", "by auto"], ["", "lemma valid_B_first:\n  \"valid_point xs i \\<Longrightarrow> i < length xs \\<Longrightarrow> valid_point (B # xs) (i + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_point xs i; i < length xs\\<rbrakk>\n    \\<Longrightarrow> valid_point (B # xs) (i + 1)", "by (auto intro: valid_point.intros simp: numeral_2_eq_2 elim!: valid_point.cases)"], ["", "lemma valid_line_prepend_B:\n  \"valid_line (B # xs)\" if \"valid_line xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_line (B # xs)", "using that"], ["proof (prove)\nusing this:\n  valid_line xs\n\ngoal (1 subgoal):\n 1. valid_line (B # xs)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_line xs \\<Longrightarrow> valid_line (B # xs)", "apply (rule valid_lineI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>valid_line xs; i < length (B # xs)\\<rbrakk>\n       \\<Longrightarrow> valid_point (B # xs) i", "subgoal for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_line xs; i < length (B # xs)\\<rbrakk>\n    \\<Longrightarrow> valid_point (B # xs) i", "by (cases i) (auto intro: valid_B_first[simplified] valid_point.intros simp: valid_line_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma valid_drop_B:\n  \"valid_point xs (i - 1)\" if \"valid_point (B # xs) i\" \"i > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_point xs (i - 1)", "using that"], ["proof (prove)\nusing this:\n  valid_point (B # xs) i\n  0 < i\n\ngoal (1 subgoal):\n 1. valid_point xs (i - 1)", "apply cases"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>0 < i; i + 2 < length (B # xs); (B # xs) ! i = R;\n     (B # xs) ! (i + 1) = R; (B # xs) ! (i + 2) = R\\<rbrakk>\n    \\<Longrightarrow> valid_point xs (i - 1)\n 2. \\<lbrakk>0 < i; 1 \\<le> i; i + 1 < length (B # xs);\n     (B # xs) ! (i - 1) = R; (B # xs) ! i = R;\n     (B # xs) ! (i + 1) = R\\<rbrakk>\n    \\<Longrightarrow> valid_point xs (i - 1)\n 3. \\<lbrakk>0 < i; 2 \\<le> i; i < length (B # xs); (B # xs) ! (i - 2) = R;\n     (B # xs) ! (i - 1) = R; (B # xs) ! i = R\\<rbrakk>\n    \\<Longrightarrow> valid_point xs (i - 1)\n 4. \\<lbrakk>0 < i; i < length (B # xs); (B # xs) ! i = B\\<rbrakk>\n    \\<Longrightarrow> valid_point xs (i - 1)", "apply (fastforce intro: valid_point.intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>0 < i; 1 \\<le> i; i + 1 < length (B # xs);\n     (B # xs) ! (i - 1) = R; (B # xs) ! i = R;\n     (B # xs) ! (i + 1) = R\\<rbrakk>\n    \\<Longrightarrow> valid_point xs (i - 1)\n 2. \\<lbrakk>0 < i; 2 \\<le> i; i < length (B # xs); (B # xs) ! (i - 2) = R;\n     (B # xs) ! (i - 1) = R; (B # xs) ! i = R\\<rbrakk>\n    \\<Longrightarrow> valid_point xs (i - 1)\n 3. \\<lbrakk>0 < i; i < length (B # xs); (B # xs) ! i = B\\<rbrakk>\n    \\<Longrightarrow> valid_point xs (i - 1)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < i; 1 \\<le> i; i + 1 < length (B # xs);\n     (B # xs) ! (i - 1) = R; (B # xs) ! i = R;\n     (B # xs) ! (i + 1) = R\\<rbrakk>\n    \\<Longrightarrow> valid_point xs (i - 1)", "by (cases \"i = 1\") (auto intro: valid_point.intros(2))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < i; 2 \\<le> i; i < length (B # xs); (B # xs) ! (i - 2) = R;\n     (B # xs) ! (i - 1) = R; (B # xs) ! i = R\\<rbrakk>\n    \\<Longrightarrow> valid_point xs (i - 1)\n 2. \\<lbrakk>0 < i; i < length (B # xs); (B # xs) ! i = B\\<rbrakk>\n    \\<Longrightarrow> valid_point xs (i - 1)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < i; 2 \\<le> i; i < length (B # xs); (B # xs) ! (i - 2) = R;\n     (B # xs) ! (i - 1) = R; (B # xs) ! i = R\\<rbrakk>\n    \\<Longrightarrow> valid_point xs (i - 1)", "unfolding numeral_nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < i; Suc (Suc 0) \\<le> i; i < length (B # xs);\n     (B # xs) ! (i - Suc (Suc 0)) = R; (B # xs) ! (i - Suc 0) = R;\n     (B # xs) ! i = R\\<rbrakk>\n    \\<Longrightarrow> valid_point xs (i - Suc 0)", "by (cases \"i = 2\") (auto intro: valid_point.intros(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < i; i < length (B # xs); (B # xs) ! i = B\\<rbrakk>\n    \\<Longrightarrow> valid_point xs (i - 1)", "apply (fastforce intro: valid_point.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma valid_line_drop_B:\n  \"valid_line xs\" if \"valid_line (B # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_line xs", "using that"], ["proof (prove)\nusing this:\n  valid_line (B # xs)\n\ngoal (1 subgoal):\n 1. valid_line xs", "unfolding valid_line_def"], ["proof (prove)\nusing this:\n  \\<forall>i<length (B # xs). valid_point (B # xs) i\n\ngoal (1 subgoal):\n 1. \\<forall>i<length xs. valid_point xs i", "proof (safe, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>i<length (B # xs). valid_point (B # xs) i;\n        i < length xs\\<rbrakk>\n       \\<Longrightarrow> valid_point xs i", "case (1 i)"], ["proof (state)\nthis:\n  \\<forall>i<length (B # xs). valid_point (B # xs) i\n  i < length xs\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>i<length (B # xs). valid_point (B # xs) i;\n        i < length xs\\<rbrakk>\n       \\<Longrightarrow> valid_point xs i", "with valid_drop_B[of xs \"i + 1\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>valid_point (B # xs) (i + 1); 0 < i + 1\\<rbrakk>\n  \\<Longrightarrow> valid_point xs (i + 1 - 1)\n  \\<forall>i<length (B # xs). valid_point (B # xs) i\n  i < length xs", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_point (B # xs) (i + 1); 0 < i + 1\\<rbrakk>\n  \\<Longrightarrow> valid_point xs (i + 1 - 1)\n  \\<forall>i<length (B # xs). valid_point (B # xs) i\n  i < length xs\n\ngoal (1 subgoal):\n 1. valid_point xs i", "by auto"], ["proof (state)\nthis:\n  valid_point xs i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_line_prepend_B_iff:\n  \"valid_line (B # xs) \\<longleftrightarrow> valid_line xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_line (B # xs) = valid_line xs", "using valid_line_prepend_B valid_line_drop_B"], ["proof (prove)\nusing this:\n  valid_line ?xs \\<Longrightarrow> valid_line (B # ?xs)\n  valid_line (B # ?xs) \\<Longrightarrow> valid_line ?xs\n\ngoal (1 subgoal):\n 1. valid_line (B # xs) = valid_line xs", "by metis"], ["", "lemma cases_valid_line:\n  assumes\n    \"l = [] \\<or>\n    (l!0 = B \\<and> valid_line (tl l)) \\<or>\n    length l \\<ge> 3 \\<and> (\\<forall> i < length l. l ! i = R) \\<or>\n    (\\<exists> j < length l. j \\<ge> 3 \\<and> (\\<forall> i < j. l ! i = R) \\<and> l ! j = B \\<and> valid_line (drop (j + 1) l))\"\n    (is \"?a \\<or> ?b \\<or> ?c \\<or> ?d\")\n  shows \"valid_line l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_line l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valid_line l", "from assms"], ["proof (chain)\npicking this:\n  l = [] \\<or>\n  l ! 0 = B \\<and> valid_line (tl l) \\<or>\n  3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n  (\\<exists>j<length l.\n      3 \\<le> j \\<and>\n      (\\<forall>i<j. l ! i = R) \\<and>\n      l ! j = B \\<and> valid_line (drop (j + 1) l))", "consider (empty) ?a | (B) \"\\<not> ?a \\<and> ?b\" | (all_red) ?c | (R_B) ?d"], ["proof (prove)\nusing this:\n  l = [] \\<or>\n  l ! 0 = B \\<and> valid_line (tl l) \\<or>\n  3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n  (\\<exists>j<length l.\n      3 \\<le> j \\<and>\n      (\\<forall>i<j. l ! i = R) \\<and>\n      l ! j = B \\<and> valid_line (drop (j + 1) l))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l = [] \\<Longrightarrow> thesis;\n     l \\<noteq> [] \\<and>\n     l ! 0 = B \\<and> valid_line (tl l) \\<Longrightarrow>\n     thesis;\n     3 \\<le> length l \\<and>\n     (\\<forall>i<length l. l ! i = R) \\<Longrightarrow>\n     thesis;\n     \\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>l = [] \\<Longrightarrow> ?thesis;\n   l \\<noteq> [] \\<and> l ! 0 = B \\<and> valid_line (tl l) \\<Longrightarrow>\n   ?thesis;\n   3 \\<le> length l \\<and>\n   (\\<forall>i<length l. l ! i = R) \\<Longrightarrow>\n   ?thesis;\n   \\<exists>j<length l.\n      3 \\<le> j \\<and>\n      (\\<forall>i<j. l ! i = R) \\<and>\n      l ! j = B \\<and> valid_line (drop (j + 1) l) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. valid_line l", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>l = [] \\<Longrightarrow> ?thesis;\n   l \\<noteq> [] \\<and> l ! 0 = B \\<and> valid_line (tl l) \\<Longrightarrow>\n   ?thesis;\n   3 \\<le> length l \\<and>\n   (\\<forall>i<length l. l ! i = R) \\<Longrightarrow>\n   ?thesis;\n   \\<exists>j<length l.\n      3 \\<le> j \\<and>\n      (\\<forall>i<j. l ! i = R) \\<and>\n      l ! j = B \\<and> valid_line (drop (j + 1) l) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>l = [] \\<Longrightarrow> ?thesis;\n   l \\<noteq> [] \\<and> l ! 0 = B \\<and> valid_line (tl l) \\<Longrightarrow>\n   ?thesis;\n   3 \\<le> length l \\<and>\n   (\\<forall>i<length l. l ! i = R) \\<Longrightarrow>\n   ?thesis;\n   \\<exists>j<length l.\n      3 \\<le> j \\<and>\n      (\\<forall>i<j. l ! i = R) \\<and>\n      l ! j = B \\<and> valid_line (drop (j + 1) l) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. valid_line l", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. l = [] \\<Longrightarrow> valid_line l\n 2. l \\<noteq> [] \\<and>\n    l ! 0 = B \\<and> valid_line (tl l) \\<Longrightarrow>\n    valid_line l\n 3. 3 \\<le> length l \\<and>\n    (\\<forall>i<length l. l ! i = R) \\<Longrightarrow>\n    valid_line l\n 4. \\<exists>j<length l.\n       3 \\<le> j \\<and>\n       (\\<forall>i<j. l ! i = R) \\<and>\n       l ! j = B \\<and> valid_line (drop (j + 1) l) \\<Longrightarrow>\n    valid_line l", "case empty"], ["proof (state)\nthis:\n  l = []\n\ngoal (4 subgoals):\n 1. l = [] \\<Longrightarrow> valid_line l\n 2. l \\<noteq> [] \\<and>\n    l ! 0 = B \\<and> valid_line (tl l) \\<Longrightarrow>\n    valid_line l\n 3. 3 \\<le> length l \\<and>\n    (\\<forall>i<length l. l ! i = R) \\<Longrightarrow>\n    valid_line l\n 4. \\<exists>j<length l.\n       3 \\<le> j \\<and>\n       (\\<forall>i<j. l ! i = R) \\<and>\n       l ! j = B \\<and> valid_line (drop (j + 1) l) \\<Longrightarrow>\n    valid_line l", "then"], ["proof (chain)\npicking this:\n  l = []", "show ?thesis"], ["proof (prove)\nusing this:\n  l = []\n\ngoal (1 subgoal):\n 1. valid_line l", "by (simp add: valid_line_def)"], ["proof (state)\nthis:\n  valid_line l\n\ngoal (3 subgoals):\n 1. l \\<noteq> [] \\<and>\n    l ! 0 = B \\<and> valid_line (tl l) \\<Longrightarrow>\n    valid_line l\n 2. 3 \\<le> length l \\<and>\n    (\\<forall>i<length l. l ! i = R) \\<Longrightarrow>\n    valid_line l\n 3. \\<exists>j<length l.\n       3 \\<le> j \\<and>\n       (\\<forall>i<j. l ! i = R) \\<and>\n       l ! j = B \\<and> valid_line (drop (j + 1) l) \\<Longrightarrow>\n    valid_line l", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. l \\<noteq> [] \\<and>\n    l ! 0 = B \\<and> valid_line (tl l) \\<Longrightarrow>\n    valid_line l\n 2. 3 \\<le> length l \\<and>\n    (\\<forall>i<length l. l ! i = R) \\<Longrightarrow>\n    valid_line l\n 3. \\<exists>j<length l.\n       3 \\<le> j \\<and>\n       (\\<forall>i<j. l ! i = R) \\<and>\n       l ! j = B \\<and> valid_line (drop (j + 1) l) \\<Longrightarrow>\n    valid_line l", "case B"], ["proof (state)\nthis:\n  l \\<noteq> [] \\<and> l ! 0 = B \\<and> valid_line (tl l)\n\ngoal (3 subgoals):\n 1. l \\<noteq> [] \\<and>\n    l ! 0 = B \\<and> valid_line (tl l) \\<Longrightarrow>\n    valid_line l\n 2. 3 \\<le> length l \\<and>\n    (\\<forall>i<length l. l ! i = R) \\<Longrightarrow>\n    valid_line l\n 3. \\<exists>j<length l.\n       3 \\<le> j \\<and>\n       (\\<forall>i<j. l ! i = R) \\<and>\n       l ! j = B \\<and> valid_line (drop (j + 1) l) \\<Longrightarrow>\n    valid_line l", "then"], ["proof (chain)\npicking this:\n  l \\<noteq> [] \\<and> l ! 0 = B \\<and> valid_line (tl l)", "show ?thesis"], ["proof (prove)\nusing this:\n  l \\<noteq> [] \\<and> l ! 0 = B \\<and> valid_line (tl l)\n\ngoal (1 subgoal):\n 1. valid_line l", "by (cases l) (auto simp: valid_line_prepend_B_iff)"], ["proof (state)\nthis:\n  valid_line l\n\ngoal (2 subgoals):\n 1. 3 \\<le> length l \\<and>\n    (\\<forall>i<length l. l ! i = R) \\<Longrightarrow>\n    valid_line l\n 2. \\<exists>j<length l.\n       3 \\<le> j \\<and>\n       (\\<forall>i<j. l ! i = R) \\<and>\n       l ! j = B \\<and> valid_line (drop (j + 1) l) \\<Longrightarrow>\n    valid_line l", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. 3 \\<le> length l \\<and>\n    (\\<forall>i<length l. l ! i = R) \\<Longrightarrow>\n    valid_line l\n 2. \\<exists>j<length l.\n       3 \\<le> j \\<and>\n       (\\<forall>i<j. l ! i = R) \\<and>\n       l ! j = B \\<and> valid_line (drop (j + 1) l) \\<Longrightarrow>\n    valid_line l", "case prems: all_red"], ["proof (state)\nthis:\n  3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R)\n\ngoal (2 subgoals):\n 1. 3 \\<le> length l \\<and>\n    (\\<forall>i<length l. l ! i = R) \\<Longrightarrow>\n    valid_line l\n 2. \\<exists>j<length l.\n       3 \\<le> j \\<and>\n       (\\<forall>i<j. l ! i = R) \\<and>\n       l ! j = B \\<and> valid_line (drop (j + 1) l) \\<Longrightarrow>\n    valid_line l", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_line l", "proof (rule valid_lineI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < length l \\<Longrightarrow> valid_point l i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < length l \\<Longrightarrow> valid_point l i", "assume \"i < length l\""], ["proof (state)\nthis:\n  i < length l\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length l \\<Longrightarrow> valid_point l i", "consider \"i = 0\" | \"i = 1\" | \"i > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i = 0 \\<Longrightarrow> thesis; i = 1 \\<Longrightarrow> thesis;\n     1 < i \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by atomize_elim auto"], ["proof (state)\nthis:\n  \\<lbrakk>i = 0 \\<Longrightarrow> ?thesis; i = 1 \\<Longrightarrow> ?thesis;\n   1 < i \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length l \\<Longrightarrow> valid_point l i", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>i = 0 \\<Longrightarrow> ?thesis; i = 1 \\<Longrightarrow> ?thesis;\n   1 < i \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show \"valid_point l i\""], ["proof (prove)\nusing this:\n  \\<lbrakk>i = 0 \\<Longrightarrow> ?thesis; i = 1 \\<Longrightarrow> ?thesis;\n   1 < i \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. valid_point l i", "using \\<open>i < _\\<close> prems"], ["proof (prove)\nusing this:\n  \\<lbrakk>i = 0 \\<Longrightarrow> ?thesis; i = 1 \\<Longrightarrow> ?thesis;\n   1 < i \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  i < length l\n  3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R)\n\ngoal (1 subgoal):\n 1. valid_point l i", "by cases (auto 4 4 intro: valid_point.intros)"], ["proof (state)\nthis:\n  valid_point l i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_line l\n\ngoal (1 subgoal):\n 1. \\<exists>j<length l.\n       3 \\<le> j \\<and>\n       (\\<forall>i<j. l ! i = R) \\<and>\n       l ! j = B \\<and> valid_line (drop (j + 1) l) \\<Longrightarrow>\n    valid_line l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>j<length l.\n       3 \\<le> j \\<and>\n       (\\<forall>i<j. l ! i = R) \\<and>\n       l ! j = B \\<and> valid_line (drop (j + 1) l) \\<Longrightarrow>\n    valid_line l", "case R_B"], ["proof (state)\nthis:\n  \\<exists>j<length l.\n     3 \\<le> j \\<and>\n     (\\<forall>i<j. l ! i = R) \\<and>\n     l ! j = B \\<and> valid_line (drop (j + 1) l)\n\ngoal (1 subgoal):\n 1. \\<exists>j<length l.\n       3 \\<le> j \\<and>\n       (\\<forall>i<j. l ! i = R) \\<and>\n       l ! j = B \\<and> valid_line (drop (j + 1) l) \\<Longrightarrow>\n    valid_line l", "then"], ["proof (chain)\npicking this:\n  \\<exists>j<length l.\n     3 \\<le> j \\<and>\n     (\\<forall>i<j. l ! i = R) \\<and>\n     l ! j = B \\<and> valid_line (drop (j + 1) l)", "obtain j where j:\n      \"j<length l\" \"3 \\<le> j\" \"(\\<forall>i<j. l ! i = R)\" \"l ! j = B\" \"valid_line (drop (j + 1) l)\""], ["proof (prove)\nusing this:\n  \\<exists>j<length l.\n     3 \\<le> j \\<and>\n     (\\<forall>i<j. l ! i = R) \\<and>\n     l ! j = B \\<and> valid_line (drop (j + 1) l)\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j < length l; 3 \\<le> j; \\<forall>i<j. l ! i = R;\n         l ! j = B; valid_line (drop (j + 1) l)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  j < length l\n  3 \\<le> j\n  \\<forall>i<j. l ! i = R\n  l ! j = B\n  valid_line (drop (j + 1) l)\n\ngoal (1 subgoal):\n 1. \\<exists>j<length l.\n       3 \\<le> j \\<and>\n       (\\<forall>i<j. l ! i = R) \\<and>\n       l ! j = B \\<and> valid_line (drop (j + 1) l) \\<Longrightarrow>\n    valid_line l", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_line l", "proof (rule valid_lineI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < length l \\<Longrightarrow> valid_point l i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < length l \\<Longrightarrow> valid_point l i", "assume \"i < length l\""], ["proof (state)\nthis:\n  i < length l\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length l \\<Longrightarrow> valid_point l i", "with \\<open>j \\<ge> 3\\<close>"], ["proof (chain)\npicking this:\n  3 \\<le> j\n  i < length l", "consider \"i \\<le> j - 3\" | \"i = j - 2\" | \"i = j - 1\" | \"i = j\" | \"i > j\""], ["proof (prove)\nusing this:\n  3 \\<le> j\n  i < length l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> j - 3 \\<Longrightarrow> thesis;\n     i = j - 2 \\<Longrightarrow> thesis; i = j - 1 \\<Longrightarrow> thesis;\n     i = j \\<Longrightarrow> thesis; j < i \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by atomize_elim auto"], ["proof (state)\nthis:\n  \\<lbrakk>i \\<le> j - 3 \\<Longrightarrow> ?thesis;\n   i = j - 2 \\<Longrightarrow> ?thesis; i = j - 1 \\<Longrightarrow> ?thesis;\n   i = j \\<Longrightarrow> ?thesis; j < i \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length l \\<Longrightarrow> valid_point l i", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>i \\<le> j - 3 \\<Longrightarrow> ?thesis;\n   i = j - 2 \\<Longrightarrow> ?thesis; i = j - 1 \\<Longrightarrow> ?thesis;\n   i = j \\<Longrightarrow> ?thesis; j < i \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show \"valid_point l i\""], ["proof (prove)\nusing this:\n  \\<lbrakk>i \\<le> j - 3 \\<Longrightarrow> ?thesis;\n   i = j - 2 \\<Longrightarrow> ?thesis; i = j - 1 \\<Longrightarrow> ?thesis;\n   i = j \\<Longrightarrow> ?thesis; j < i \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. valid_point l i", "proof cases"], ["proof (state)\ngoal (5 subgoals):\n 1. i \\<le> j - 3 \\<Longrightarrow> valid_point l i\n 2. i = j - 2 \\<Longrightarrow> valid_point l i\n 3. i = j - 1 \\<Longrightarrow> valid_point l i\n 4. i = j \\<Longrightarrow> valid_point l i\n 5. j < i \\<Longrightarrow> valid_point l i", "case 5"], ["proof (state)\nthis:\n  j < i\n\ngoal (5 subgoals):\n 1. i \\<le> j - 3 \\<Longrightarrow> valid_point l i\n 2. i = j - 2 \\<Longrightarrow> valid_point l i\n 3. i = j - 1 \\<Longrightarrow> valid_point l i\n 4. i = j \\<Longrightarrow> valid_point l i\n 5. j < i \\<Longrightarrow> valid_point l i", "with \\<open>valid_line _\\<close> \\<open>i < length l\\<close>"], ["proof (chain)\npicking this:\n  valid_line (drop (j + 1) l)\n  i < length l\n  j < i", "have \"valid_point (drop (j + 1) l) (i - j - 1)\""], ["proof (prove)\nusing this:\n  valid_line (drop (j + 1) l)\n  i < length l\n  j < i\n\ngoal (1 subgoal):\n 1. valid_point (drop (j + 1) l) (i - j - 1)", "unfolding valid_line_def"], ["proof (prove)\nusing this:\n  \\<forall>i<length (drop (j + 1) l). valid_point (drop (j + 1) l) i\n  i < length l\n  j < i\n\ngoal (1 subgoal):\n 1. valid_point (drop (j + 1) l) (i - j - 1)", "by auto"], ["proof (state)\nthis:\n  valid_point (drop (j + 1) l) (i - j - 1)\n\ngoal (5 subgoals):\n 1. i \\<le> j - 3 \\<Longrightarrow> valid_point l i\n 2. i = j - 2 \\<Longrightarrow> valid_point l i\n 3. i = j - 1 \\<Longrightarrow> valid_point l i\n 4. i = j \\<Longrightarrow> valid_point l i\n 5. j < i \\<Longrightarrow> valid_point l i", "then"], ["proof (chain)\npicking this:\n  valid_point (drop (j + 1) l) (i - j - 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_point (drop (j + 1) l) (i - j - 1)\n\ngoal (1 subgoal):\n 1. valid_point l i", "using \\<open>i > j\\<close>"], ["proof (prove)\nusing this:\n  valid_point (drop (j + 1) l) (i - j - 1)\n  j < i\n\ngoal (1 subgoal):\n 1. valid_point l i", "by cases (auto intro: valid_point.intros)"], ["proof (state)\nthis:\n  valid_point l i\n\ngoal (4 subgoals):\n 1. i \\<le> j - 3 \\<Longrightarrow> valid_point l i\n 2. i = j - 2 \\<Longrightarrow> valid_point l i\n 3. i = j - 1 \\<Longrightarrow> valid_point l i\n 4. i = j \\<Longrightarrow> valid_point l i", "qed (use j in \\<open>auto intro: valid_point.intros\\<close>)"], ["proof (state)\nthis:\n  valid_point l i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_line l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_line l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_line_cases:\n  \"l = [] \\<or>\n  (l!0 = B \\<and> valid_line (tl l)) \\<or>\n  length l \\<ge> 3 \\<and> (\\<forall> i < length l. l ! i = R) \\<or>\n  (\\<exists> j < length l. j \\<ge> 3 \\<and> (\\<forall> i < j. l ! i = R) \\<and> l ! j = B \\<and> valid_line (drop (j + 1) l))\"\n  if \"valid_line l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "proof (cases \"l = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l = [] \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))\n 2. l \\<noteq> [] \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "case True"], ["proof (state)\nthis:\n  l = []\n\ngoal (2 subgoals):\n 1. l = [] \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))\n 2. l \\<noteq> [] \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "then"], ["proof (chain)\npicking this:\n  l = []", "show ?thesis"], ["proof (prove)\nusing this:\n  l = []\n\ngoal (1 subgoal):\n 1. l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "by (simp add: valid_line_def)"], ["proof (state)\nthis:\n  l = [] \\<or>\n  l ! 0 = B \\<and> valid_line (tl l) \\<or>\n  3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n  (\\<exists>j<length l.\n      3 \\<le> j \\<and>\n      (\\<forall>i<j. l ! i = R) \\<and>\n      l ! j = B \\<and> valid_line (drop (j + 1) l))\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "case False"], ["proof (state)\nthis:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "proof (cases \"l!0 = B\")"], ["proof (state)\ngoal (2 subgoals):\n 1. l ! 0 = B \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))\n 2. l ! 0 \\<noteq> B \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "case True"], ["proof (state)\nthis:\n  l ! 0 = B\n\ngoal (2 subgoals):\n 1. l ! 0 = B \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))\n 2. l ! 0 \\<noteq> B \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "with \\<open>l \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  l \\<noteq> []\n  l ! 0 = B", "have \"l = B # tl l\""], ["proof (prove)\nusing this:\n  l \\<noteq> []\n  l ! 0 = B\n\ngoal (1 subgoal):\n 1. l = B # tl l", "by (cases l) auto"], ["proof (state)\nthis:\n  l = B # tl l\n\ngoal (2 subgoals):\n 1. l ! 0 = B \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))\n 2. l ! 0 \\<noteq> B \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "with \\<open>valid_line l\\<close> True"], ["proof (chain)\npicking this:\n  valid_line l\n  l ! 0 = B\n  l = B # tl l", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_line l\n  l ! 0 = B\n  l = B # tl l\n\ngoal (1 subgoal):\n 1. l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "by (metis valid_line_prepend_B_iff)"], ["proof (state)\nthis:\n  l = [] \\<or>\n  l ! 0 = B \\<and> valid_line (tl l) \\<or>\n  3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n  (\\<exists>j<length l.\n      3 \\<le> j \\<and>\n      (\\<forall>i<j. l ! i = R) \\<and>\n      l ! j = B \\<and> valid_line (drop (j + 1) l))\n\ngoal (1 subgoal):\n 1. l ! 0 \\<noteq> B \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l ! 0 \\<noteq> B \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "case False"], ["proof (state)\nthis:\n  l ! 0 \\<noteq> B\n\ngoal (1 subgoal):\n 1. l ! 0 \\<noteq> B \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "from \\<open>valid_line l\\<close> \\<open>l \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  valid_line l\n  l \\<noteq> []", "have \"valid_point l 0\""], ["proof (prove)\nusing this:\n  valid_line l\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. valid_point l 0", "unfolding valid_line_def"], ["proof (prove)\nusing this:\n  \\<forall>i<length l. valid_point l i\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. valid_point l 0", "by auto"], ["proof (state)\nthis:\n  valid_point l 0\n\ngoal (1 subgoal):\n 1. l ! 0 \\<noteq> B \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "with False"], ["proof (chain)\npicking this:\n  l ! 0 \\<noteq> B\n  valid_point l 0", "have red_start: \"length l \\<ge> 3\" \"l!0 = R\" \"l!1 = R\" \"l!2 = R\""], ["proof (prove)\nusing this:\n  l ! 0 \\<noteq> B\n  valid_point l 0\n\ngoal (1 subgoal):\n 1. (3 \\<le> length l &&& l ! 0 = R) &&& l ! 1 = R &&& l ! 2 = R", "by (auto elim!: valid_point.cases simp: numeral_2_eq_2)"], ["proof (state)\nthis:\n  3 \\<le> length l\n  l ! 0 = R\n  l ! 1 = R\n  l ! 2 = R\n\ngoal (1 subgoal):\n 1. l ! 0 \\<noteq> B \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "proof (cases \"\\<forall>i < length l. l ! i = R\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i<length l. l ! i = R \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))\n 2. \\<not> (\\<forall>i<length l. l ! i = R) \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "case True"], ["proof (state)\nthis:\n  \\<forall>i<length l. l ! i = R\n\ngoal (2 subgoals):\n 1. \\<forall>i<length l. l ! i = R \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))\n 2. \\<not> (\\<forall>i<length l. l ! i = R) \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "with \\<open>length l \\<ge> 3\\<close>"], ["proof (chain)\npicking this:\n  3 \\<le> length l\n  \\<forall>i<length l. l ! i = R", "show ?thesis"], ["proof (prove)\nusing this:\n  3 \\<le> length l\n  \\<forall>i<length l. l ! i = R\n\ngoal (1 subgoal):\n 1. l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "by auto"], ["proof (state)\nthis:\n  l = [] \\<or>\n  l ! 0 = B \\<and> valid_line (tl l) \\<or>\n  3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n  (\\<exists>j<length l.\n      3 \\<le> j \\<and>\n      (\\<forall>i<j. l ! i = R) \\<and>\n      l ! j = B \\<and> valid_line (drop (j + 1) l))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i<length l. l ! i = R) \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i<length l. l ! i = R) \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>i<length l. l ! i = R)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i<length l. l ! i = R) \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "let ?S = \"{j. j < length l \\<and> j \\<ge> 3 \\<and> l ! j = B}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i<length l. l ! i = R) \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "let ?j = \"Min ?S\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i<length l. l ! i = R) \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "have B_ge_3: \"i \\<ge> 3\" if \"l ! i = B\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 \\<le> i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 3 \\<le> i", "consider \"i = 0\" | \"i = 1\" | \"i = 2\" | \"i \\<ge> 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i = 0 \\<Longrightarrow> thesis; i = 1 \\<Longrightarrow> thesis;\n     i = 2 \\<Longrightarrow> thesis;\n     3 \\<le> i \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by atomize_elim auto"], ["proof (state)\nthis:\n  \\<lbrakk>i = 0 \\<Longrightarrow> ?thesis; i = 1 \\<Longrightarrow> ?thesis;\n   i = 2 \\<Longrightarrow> ?thesis;\n   3 \\<le> i \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. 3 \\<le> i", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>i = 0 \\<Longrightarrow> ?thesis; i = 1 \\<Longrightarrow> ?thesis;\n   i = 2 \\<Longrightarrow> ?thesis;\n   3 \\<le> i \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show \"i \\<ge> 3\""], ["proof (prove)\nusing this:\n  \\<lbrakk>i = 0 \\<Longrightarrow> ?thesis; i = 1 \\<Longrightarrow> ?thesis;\n   i = 2 \\<Longrightarrow> ?thesis;\n   3 \\<le> i \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. 3 \\<le> i", "using red_start \\<open>l ! i = B\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>i = 0 \\<Longrightarrow> ?thesis; i = 1 \\<Longrightarrow> ?thesis;\n   i = 2 \\<Longrightarrow> ?thesis;\n   3 \\<le> i \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  3 \\<le> length l\n  l ! 0 = R\n  l ! 1 = R\n  l ! 2 = R\n  l ! i = B\n\ngoal (1 subgoal):\n 1. 3 \\<le> i", "by cases auto"], ["proof (state)\nthis:\n  3 \\<le> i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l ! ?i = B \\<Longrightarrow> 3 \\<le> ?i\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i<length l. l ! i = R) \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "from False"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>i<length l. l ! i = R)", "obtain i where \"l ! i = B\" \"i < length l\" \"i \\<ge> 3\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i<length l. l ! i = R)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>l ! i = B; i < length l; 3 \\<le> i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto intro: B_ge_3 color.exhaust)"], ["proof (state)\nthis:\n  l ! i = B\n  i < length l\n  3 \\<le> i\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i<length l. l ! i = R) \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "then"], ["proof (chain)\npicking this:\n  l ! i = B\n  i < length l\n  3 \\<le> i", "have \"?j \\<in> ?S\""], ["proof (prove)\nusing this:\n  l ! i = B\n  i < length l\n  3 \\<le> i\n\ngoal (1 subgoal):\n 1. Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}\n    \\<in> {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}", "by - (rule Min_in, auto)"], ["proof (state)\nthis:\n  Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}\n  \\<in> {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i<length l. l ! i = R) \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "have \"\\<forall>i < ?j. l ! i = R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}.\n       l ! i = R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i<Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}.\n       l ! i = R", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i<Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}.\n       l ! i = R", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i<Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}.\n       l ! i = R", "assume \"i < ?j\" \"l ! i = B\""], ["proof (state)\nthis:\n  i < Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}\n  l ! i = B\n\ngoal (1 subgoal):\n 1. \\<forall>i<Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}.\n       l ! i = R", "then"], ["proof (chain)\npicking this:\n  i < Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}\n  l ! i = B", "have \"i \\<ge> 3\""], ["proof (prove)\nusing this:\n  i < Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}\n  l ! i = B\n\ngoal (1 subgoal):\n 1. 3 \\<le> i", "by (auto intro: B_ge_3)"], ["proof (state)\nthis:\n  3 \\<le> i\n\ngoal (1 subgoal):\n 1. \\<forall>i<Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}.\n       l ! i = R", "with \\<open>i < ?j\\<close> \\<open>l ! i = B\\<close> red_start \\<open>?j \\<in> ?S\\<close>"], ["proof (chain)\npicking this:\n  i < Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}\n  l ! i = B\n  3 \\<le> length l\n  l ! 0 = R\n  l ! 1 = R\n  l ! 2 = R\n  Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}\n  \\<in> {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}\n  3 \\<le> i", "have \"i \\<in> ?S\""], ["proof (prove)\nusing this:\n  i < Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}\n  l ! i = B\n  3 \\<le> length l\n  l ! 0 = R\n  l ! 1 = R\n  l ! 2 = R\n  Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}\n  \\<in> {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}\n  3 \\<le> i\n\ngoal (1 subgoal):\n 1. i \\<in> {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}", "by auto"], ["proof (state)\nthis:\n  i \\<in> {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}\n\ngoal (1 subgoal):\n 1. \\<forall>i<Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}.\n       l ! i = R", "then"], ["proof (chain)\npicking this:\n  i \\<in> {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}", "have \"?j \\<le> i\""], ["proof (prove)\nusing this:\n  i \\<in> {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}\n\ngoal (1 subgoal):\n 1. Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B} \\<le> i", "by (auto intro: Min_le)"], ["proof (state)\nthis:\n  Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B} \\<le> i\n\ngoal (1 subgoal):\n 1. \\<forall>i<Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}.\n       l ! i = R", "with \\<open>i < ?j\\<close>"], ["proof (chain)\npicking this:\n  i < Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}\n  Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B} \\<le> i", "have False"], ["proof (prove)\nusing this:\n  i < Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}\n  Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B} \\<le> i\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<forall>i<Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}.\n       l ! i = R", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?ia2 < Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B};\n   l ! ?ia2 = B\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<forall>i<Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}.\n       l ! i = R", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?ia2 < Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B};\n   l ! ?ia2 = B\\<rbrakk>\n  \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ia2 < Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B};\n   l ! ?ia2 = B\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<forall>i<Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}.\n       l ! i = R", "by (auto intro: color.exhaust)"], ["proof (state)\nthis:\n  \\<forall>i<Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}.\n     l ! i = R\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}.\n     l ! i = R\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i<length l. l ! i = R) \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "with \\<open>?j \\<in> ?S\\<close>"], ["proof (chain)\npicking this:\n  Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}\n  \\<in> {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}\n  \\<forall>i<Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}.\n     l ! i = R", "obtain j where j: \"j < length l\" \"j \\<ge> 3\" \"\\<forall>i < j. l ! i = R\" \"l ! j = B\""], ["proof (prove)\nusing this:\n  Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}\n  \\<in> {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}\n  \\<forall>i<Min {j. j < length l \\<and> 3 \\<le> j \\<and> l ! j = B}.\n     l ! i = R\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j < length l; 3 \\<le> j; \\<forall>i<j. l ! i = R;\n         l ! j = B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  j < length l\n  3 \\<le> j\n  \\<forall>i<j. l ! i = R\n  l ! j = B\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i<length l. l ! i = R) \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "moreover"], ["proof (state)\nthis:\n  j < length l\n  3 \\<le> j\n  \\<forall>i<j. l ! i = R\n  l ! j = B\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i<length l. l ! i = R) \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "have \"valid_line (drop (j + 1) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_line (drop (j + 1) l)", "proof (rule valid_lineI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (drop (j + 1) l) \\<Longrightarrow>\n       valid_point (drop (j + 1) l) i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (drop (j + 1) l) \\<Longrightarrow>\n       valid_point (drop (j + 1) l) i", "assume \"i < length (drop (j + 1) l)\""], ["proof (state)\nthis:\n  i < length (drop (j + 1) l)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (drop (j + 1) l) \\<Longrightarrow>\n       valid_point (drop (j + 1) l) i", "with j \\<open>valid_line l\\<close>"], ["proof (chain)\npicking this:\n  j < length l\n  3 \\<le> j\n  \\<forall>i<j. l ! i = R\n  l ! j = B\n  valid_line l\n  i < length (drop (j + 1) l)", "have \"valid_point l (j + i + 1)\""], ["proof (prove)\nusing this:\n  j < length l\n  3 \\<le> j\n  \\<forall>i<j. l ! i = R\n  l ! j = B\n  valid_line l\n  i < length (drop (j + 1) l)\n\ngoal (1 subgoal):\n 1. valid_point l (j + i + 1)", "unfolding valid_line_def"], ["proof (prove)\nusing this:\n  j < length l\n  3 \\<le> j\n  \\<forall>i<j. l ! i = R\n  l ! j = B\n  \\<forall>i<length l. valid_point l i\n  i < length (drop (j + 1) l)\n\ngoal (1 subgoal):\n 1. valid_point l (j + i + 1)", "by auto"], ["proof (state)\nthis:\n  valid_point l (j + i + 1)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (drop (j + 1) l) \\<Longrightarrow>\n       valid_point (drop (j + 1) l) i", "then"], ["proof (chain)\npicking this:\n  valid_point l (j + i + 1)", "show \"valid_point (drop (j + 1) l) i\""], ["proof (prove)\nusing this:\n  valid_point l (j + i + 1)\n\ngoal (1 subgoal):\n 1. valid_point (drop (j + 1) l) i", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>j + i + 1 + 2 < length l; l ! (j + i + 1) = R;\n     l ! (j + i + 1 + 1) = R; l ! (j + i + 1 + 2) = R\\<rbrakk>\n    \\<Longrightarrow> valid_point (drop (j + 1) l) i\n 2. \\<lbrakk>1 \\<le> j + i + 1; j + i + 1 + 1 < length l;\n     l ! (j + i + 1 - 1) = R; l ! (j + i + 1) = R;\n     l ! (j + i + 1 + 1) = R\\<rbrakk>\n    \\<Longrightarrow> valid_point (drop (j + 1) l) i\n 3. \\<lbrakk>2 \\<le> j + i + 1; j + i + 1 < length l;\n     l ! (j + i + 1 - 2) = R; l ! (j + i + 1 - 1) = R;\n     l ! (j + i + 1) = R\\<rbrakk>\n    \\<Longrightarrow> valid_point (drop (j + 1) l) i\n 4. \\<lbrakk>j + i + 1 < length l; l ! (j + i + 1) = B\\<rbrakk>\n    \\<Longrightarrow> valid_point (drop (j + 1) l) i", "case 2"], ["proof (state)\nthis:\n  1 \\<le> j + i + 1\n  j + i + 1 + 1 < length l\n  l ! (j + i + 1 - 1) = R\n  l ! (j + i + 1) = R\n  l ! (j + i + 1 + 1) = R\n\ngoal (4 subgoals):\n 1. \\<lbrakk>j + i + 1 + 2 < length l; l ! (j + i + 1) = R;\n     l ! (j + i + 1 + 1) = R; l ! (j + i + 1 + 2) = R\\<rbrakk>\n    \\<Longrightarrow> valid_point (drop (j + 1) l) i\n 2. \\<lbrakk>1 \\<le> j + i + 1; j + i + 1 + 1 < length l;\n     l ! (j + i + 1 - 1) = R; l ! (j + i + 1) = R;\n     l ! (j + i + 1 + 1) = R\\<rbrakk>\n    \\<Longrightarrow> valid_point (drop (j + 1) l) i\n 3. \\<lbrakk>2 \\<le> j + i + 1; j + i + 1 < length l;\n     l ! (j + i + 1 - 2) = R; l ! (j + i + 1 - 1) = R;\n     l ! (j + i + 1) = R\\<rbrakk>\n    \\<Longrightarrow> valid_point (drop (j + 1) l) i\n 4. \\<lbrakk>j + i + 1 < length l; l ! (j + i + 1) = B\\<rbrakk>\n    \\<Longrightarrow> valid_point (drop (j + 1) l) i", "then"], ["proof (chain)\npicking this:\n  1 \\<le> j + i + 1\n  j + i + 1 + 1 < length l\n  l ! (j + i + 1 - 1) = R\n  l ! (j + i + 1) = R\n  l ! (j + i + 1 + 1) = R", "show ?thesis"], ["proof (prove)\nusing this:\n  1 \\<le> j + i + 1\n  j + i + 1 + 1 < length l\n  l ! (j + i + 1 - 1) = R\n  l ! (j + i + 1) = R\n  l ! (j + i + 1 + 1) = R\n\ngoal (1 subgoal):\n 1. valid_point (drop (j + 1) l) i", "using j"], ["proof (prove)\nusing this:\n  1 \\<le> j + i + 1\n  j + i + 1 + 1 < length l\n  l ! (j + i + 1 - 1) = R\n  l ! (j + i + 1) = R\n  l ! (j + i + 1 + 1) = R\n  j < length l\n  3 \\<le> j\n  \\<forall>i<j. l ! i = R\n  l ! j = B\n\ngoal (1 subgoal):\n 1. valid_point (drop (j + 1) l) i", "by (cases i) (auto intro: valid_point.intros)"], ["proof (state)\nthis:\n  valid_point (drop (j + 1) l) i\n\ngoal (3 subgoals):\n 1. \\<lbrakk>j + i + 1 + 2 < length l; l ! (j + i + 1) = R;\n     l ! (j + i + 1 + 1) = R; l ! (j + i + 1 + 2) = R\\<rbrakk>\n    \\<Longrightarrow> valid_point (drop (j + 1) l) i\n 2. \\<lbrakk>2 \\<le> j + i + 1; j + i + 1 < length l;\n     l ! (j + i + 1 - 2) = R; l ! (j + i + 1 - 1) = R;\n     l ! (j + i + 1) = R\\<rbrakk>\n    \\<Longrightarrow> valid_point (drop (j + 1) l) i\n 3. \\<lbrakk>j + i + 1 < length l; l ! (j + i + 1) = B\\<rbrakk>\n    \\<Longrightarrow> valid_point (drop (j + 1) l) i", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>j + i + 1 + 2 < length l; l ! (j + i + 1) = R;\n     l ! (j + i + 1 + 1) = R; l ! (j + i + 1 + 2) = R\\<rbrakk>\n    \\<Longrightarrow> valid_point (drop (j + 1) l) i\n 2. \\<lbrakk>2 \\<le> j + i + 1; j + i + 1 < length l;\n     l ! (j + i + 1 - 2) = R; l ! (j + i + 1 - 1) = R;\n     l ! (j + i + 1) = R\\<rbrakk>\n    \\<Longrightarrow> valid_point (drop (j + 1) l) i\n 3. \\<lbrakk>j + i + 1 < length l; l ! (j + i + 1) = B\\<rbrakk>\n    \\<Longrightarrow> valid_point (drop (j + 1) l) i", "case prems: 3"], ["proof (state)\nthis:\n  2 \\<le> j + i + 1\n  j + i + 1 < length l\n  l ! (j + i + 1 - 2) = R\n  l ! (j + i + 1 - 1) = R\n  l ! (j + i + 1) = R\n\ngoal (3 subgoals):\n 1. \\<lbrakk>j + i + 1 + 2 < length l; l ! (j + i + 1) = R;\n     l ! (j + i + 1 + 1) = R; l ! (j + i + 1 + 2) = R\\<rbrakk>\n    \\<Longrightarrow> valid_point (drop (j + 1) l) i\n 2. \\<lbrakk>2 \\<le> j + i + 1; j + i + 1 < length l;\n     l ! (j + i + 1 - 2) = R; l ! (j + i + 1 - 1) = R;\n     l ! (j + i + 1) = R\\<rbrakk>\n    \\<Longrightarrow> valid_point (drop (j + 1) l) i\n 3. \\<lbrakk>j + i + 1 < length l; l ! (j + i + 1) = B\\<rbrakk>\n    \\<Longrightarrow> valid_point (drop (j + 1) l) i", "consider \"i = 0\" | \"i = 1\" | \"i > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i = 0 \\<Longrightarrow> thesis; i = 1 \\<Longrightarrow> thesis;\n     1 < i \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by atomize_elim auto"], ["proof (state)\nthis:\n  \\<lbrakk>i = 0 \\<Longrightarrow> ?thesis; i = 1 \\<Longrightarrow> ?thesis;\n   1 < i \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (3 subgoals):\n 1. \\<lbrakk>j + i + 1 + 2 < length l; l ! (j + i + 1) = R;\n     l ! (j + i + 1 + 1) = R; l ! (j + i + 1 + 2) = R\\<rbrakk>\n    \\<Longrightarrow> valid_point (drop (j + 1) l) i\n 2. \\<lbrakk>2 \\<le> j + i + 1; j + i + 1 < length l;\n     l ! (j + i + 1 - 2) = R; l ! (j + i + 1 - 1) = R;\n     l ! (j + i + 1) = R\\<rbrakk>\n    \\<Longrightarrow> valid_point (drop (j + 1) l) i\n 3. \\<lbrakk>j + i + 1 < length l; l ! (j + i + 1) = B\\<rbrakk>\n    \\<Longrightarrow> valid_point (drop (j + 1) l) i", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>i = 0 \\<Longrightarrow> ?thesis; i = 1 \\<Longrightarrow> ?thesis;\n   1 < i \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>i = 0 \\<Longrightarrow> ?thesis; i = 1 \\<Longrightarrow> ?thesis;\n   1 < i \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. valid_point (drop (j + 1) l) i", "using j prems"], ["proof (prove)\nusing this:\n  \\<lbrakk>i = 0 \\<Longrightarrow> ?thesis; i = 1 \\<Longrightarrow> ?thesis;\n   1 < i \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  j < length l\n  3 \\<le> j\n  \\<forall>i<j. l ! i = R\n  l ! j = B\n  2 \\<le> j + i + 1\n  j + i + 1 < length l\n  l ! (j + i + 1 - 2) = R\n  l ! (j + i + 1 - 1) = R\n  l ! (j + i + 1) = R\n\ngoal (1 subgoal):\n 1. valid_point (drop (j + 1) l) i", "by cases (auto intro: valid_point.intros)"], ["proof (state)\nthis:\n  valid_point (drop (j + 1) l) i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j + i + 1 + 2 < length l; l ! (j + i + 1) = R;\n     l ! (j + i + 1 + 1) = R; l ! (j + i + 1 + 2) = R\\<rbrakk>\n    \\<Longrightarrow> valid_point (drop (j + 1) l) i\n 2. \\<lbrakk>j + i + 1 < length l; l ! (j + i + 1) = B\\<rbrakk>\n    \\<Longrightarrow> valid_point (drop (j + 1) l) i", "qed (auto intro: valid_point.intros)"], ["proof (state)\nthis:\n  valid_point (drop (j + 1) l) i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_line (drop (j + 1) l)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i<length l. l ! i = R) \\<Longrightarrow>\n    l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "ultimately"], ["proof (chain)\npicking this:\n  j < length l\n  3 \\<le> j\n  \\<forall>i<j. l ! i = R\n  l ! j = B\n  valid_line (drop (j + 1) l)", "show ?thesis"], ["proof (prove)\nusing this:\n  j < length l\n  3 \\<le> j\n  \\<forall>i<j. l ! i = R\n  l ! j = B\n  valid_line (drop (j + 1) l)\n\ngoal (1 subgoal):\n 1. l = [] \\<or>\n    l ! 0 = B \\<and> valid_line (tl l) \\<or>\n    3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n    (\\<exists>j<length l.\n        3 \\<le> j \\<and>\n        (\\<forall>i<j. l ! i = R) \\<and>\n        l ! j = B \\<and> valid_line (drop (j + 1) l))", "by auto"], ["proof (state)\nthis:\n  l = [] \\<or>\n  l ! 0 = B \\<and> valid_line (tl l) \\<or>\n  3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n  (\\<exists>j<length l.\n      3 \\<le> j \\<and>\n      (\\<forall>i<j. l ! i = R) \\<and>\n      l ! j = B \\<and> valid_line (drop (j + 1) l))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l = [] \\<or>\n  l ! 0 = B \\<and> valid_line (tl l) \\<or>\n  3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n  (\\<exists>j<length l.\n      3 \\<le> j \\<and>\n      (\\<forall>i<j. l ! i = R) \\<and>\n      l ! j = B \\<and> valid_line (drop (j + 1) l))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l = [] \\<or>\n  l ! 0 = B \\<and> valid_line (tl l) \\<or>\n  3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n  (\\<exists>j<length l.\n      3 \\<le> j \\<and>\n      (\\<forall>i<j. l ! i = R) \\<and>\n      l ! j = B \\<and> valid_line (drop (j + 1) l))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_line_split:\n  \"valid_line l \\<longleftrightarrow>\n  l = [] \\<or>\n  (l!0 = B \\<and> valid_line (tl l)) \\<or>\n  length l \\<ge> 3 \\<and> (\\<forall> i < length l. l ! i = R) \\<or>\n  (\\<exists> j < length l. j \\<ge> 3 \\<and> (\\<forall> i < j. l ! i = R) \\<and> l ! j = B \\<and> valid_line (drop (j + 1) l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_line l =\n    (l = [] \\<or>\n     l ! 0 = B \\<and> valid_line (tl l) \\<or>\n     3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n     (\\<exists>j<length l.\n         3 \\<le> j \\<and>\n         (\\<forall>i<j. l ! i = R) \\<and>\n         l ! j = B \\<and> valid_line (drop (j + 1) l)))", "using valid_line_cases cases_valid_line"], ["proof (prove)\nusing this:\n  valid_line ?l \\<Longrightarrow>\n  ?l = [] \\<or>\n  ?l ! 0 = B \\<and> valid_line (tl ?l) \\<or>\n  3 \\<le> length ?l \\<and> (\\<forall>i<length ?l. ?l ! i = R) \\<or>\n  (\\<exists>j<length ?l.\n      3 \\<le> j \\<and>\n      (\\<forall>i<j. ?l ! i = R) \\<and>\n      ?l ! j = B \\<and> valid_line (drop (j + 1) ?l))\n  ?l = [] \\<or>\n  ?l ! 0 = B \\<and> valid_line (tl ?l) \\<or>\n  3 \\<le> length ?l \\<and> (\\<forall>i<length ?l. ?l ! i = R) \\<or>\n  (\\<exists>j<length ?l.\n      3 \\<le> j \\<and>\n      (\\<forall>i<j. ?l ! i = R) \\<and>\n      ?l ! j = B \\<and> valid_line (drop (j + 1) ?l)) \\<Longrightarrow>\n  valid_line ?l\n\ngoal (1 subgoal):\n 1. valid_line l =\n    (l = [] \\<or>\n     l ! 0 = B \\<and> valid_line (tl l) \\<or>\n     3 \\<le> length l \\<and> (\\<forall>i<length l. l ! i = R) \\<or>\n     (\\<exists>j<length l.\n         3 \\<le> j \\<and>\n         (\\<forall>i<j. l ! i = R) \\<and>\n         l ! j = B \\<and> valid_line (drop (j + 1) l)))", "by blast"], ["", "text \\<open>Connection to the easier definition given above\\<close>"], ["", "lemma valid_valid_line:\n  \"valid l \\<longleftrightarrow> valid_line l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid l = valid_line l", "by (induction l rule: length_induct, subst valid_line_split, subst valid_split, auto)"], ["", "end"]]}