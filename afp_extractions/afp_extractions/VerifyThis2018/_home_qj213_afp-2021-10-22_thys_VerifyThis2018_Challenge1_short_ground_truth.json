{"file_name": "/home/qj213/afp-2021-10-22/thys/VerifyThis2018/Challenge1_short.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/VerifyThis2018", "problem_names": ["lemma move_left1_correct: \n    \"(move_left1, RETURN o move_left) \\<in> gap_rel \\<rightarrow> \\<langle>gap_rel\\<rangle>nres_rel\"", "lemma move_right1_correct: \n    \"(move_right1,RETURN o move_right) \\<in> gap_rel \\<rightarrow> \\<langle>gap_rel\\<rangle>nres_rel\"", "lemma grow1_correct[THEN SPEC_trans, refine_vcg]: \n    \\<comment> \\<open>Declares this as a rule to be used by the VCG\\<close>\n    assumes \"gap_invar gb\"\n    shows \"grow1 K gb \\<le> (SPEC (\\<lambda>gb'. \n        gap_invar gb' \n      \\<and> gap_\\<alpha> gb' = gap_\\<alpha> gb \n      \\<and> (K>0 \\<longrightarrow> can_insert gb')))\"", "lemma insert1_correct: \n    \"(insert1,RETURN oo insert) \\<in> Id \\<rightarrow> gap_rel \\<rightarrow> \\<langle>gap_rel\\<rangle>nres_rel\"", "lemma delete1_correct: \n    \"(delete1,RETURN o delete) \\<in> gap_rel \\<rightarrow> \\<langle>gap_rel\\<rangle>nres_rel\"", "lemmas move_left_impl_correct = move_left_impl.refine[FCOMP move_left1_correct]\n       and move_right_impl_correct = move_right_impl.refine[FCOMP move_right1_correct]\n       and insert_impl_correct = insert_impl.refine[FCOMP insert1_correct]\n       and delete_impl_correct = delete_impl.refine[FCOMP delete1_correct]"], "translations": [["", "lemma move_left1_correct: \n    \"(move_left1, RETURN o move_left) \\<in> gap_rel \\<rightarrow> \\<langle>gap_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (move_left1, RETURN \\<circ> move_left)\n    \\<in> gap_rel \\<rightarrow> \\<langle>gap_rel\\<rangle>nres_rel", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b a'.\n       ((a, aa, b), a') \\<in> gap_rel \\<Longrightarrow>\n       (move_left1 (a, aa, b), RETURN (move_left a'))\n       \\<in> \\<langle>gap_rel\\<rangle>nres_rel", "unfolding move_left1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b a'.\n       ((a, aa, b), a') \\<in> gap_rel \\<Longrightarrow>\n       (case (a, aa, b) of\n        (l, r, buf) \\<Rightarrow>\n          if l \\<noteq> 0\n          then ASSERT (r - 1 < length buf \\<and> l - 1 < length buf) \\<bind>\n               (\\<lambda>_.\n                   RETURN (l - 1, r - 1, buf[r - 1 := buf ! (l - 1)]))\n          else RETURN (l, r, buf),\n        RETURN (move_left a'))\n       \\<in> \\<langle>gap_rel\\<rangle>nres_rel", "apply refine_vcg"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a aa b a' ab ba ac bb.\n       \\<lbrakk>((a, aa, b), a') \\<in> gap_rel; (a, aa, b) = (ab, ba);\n        ba = (ac, bb); ab \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> ac - 1 < length bb\n 2. \\<And>a aa b a' ab ba ac bb.\n       \\<lbrakk>((a, aa, b), a') \\<in> gap_rel; (a, aa, b) = (ab, ba);\n        ba = (ac, bb); ab \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> ab - 1 < length bb\n 3. \\<And>a aa b a' ab ba ac bb.\n       \\<lbrakk>((a, aa, b), a') \\<in> gap_rel; (a, aa, b) = (ab, ba);\n        ba = (ac, bb); ab \\<noteq> 0;\n        ac - 1 < length bb \\<and> ab - 1 < length bb\\<rbrakk>\n       \\<Longrightarrow> ((ab - 1, ac - 1, bb[ac - 1 := bb ! (ab - 1)]),\n                          move_left a')\n                         \\<in> gap_rel\n 4. \\<And>a aa b a' ab ba ac bb.\n       \\<lbrakk>((a, aa, b), a') \\<in> gap_rel; (a, aa, b) = (ab, ba);\n        ba = (ac, bb); \\<not> ab \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> ((ab, ac, bb), move_left a') \\<in> gap_rel", "apply (auto \n      simp: in_br_conv gap_\\<alpha>_def gap_invar_def move_left1_def \n      split: prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b ab.\n       \\<lbrakk>0 < ab; ab \\<le> aa; aa \\<le> length b;\n        aa - Suc 0 < length b; ab - Suc 0 < length b\\<rbrakk>\n       \\<Longrightarrow> take ab b @ drop aa b =\n                         take (ab - Suc 0) b @\n                         drop (aa - Suc 0)\n                          (b[aa - Suc 0 := b ! (ab - Suc 0)])", "(* sledgehammer! *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b ab.\n       \\<lbrakk>0 < ab; ab \\<le> aa; aa \\<le> length b;\n        aa - Suc 0 < length b; ab - Suc 0 < length b\\<rbrakk>\n       \\<Longrightarrow> take ab b @ drop aa b =\n                         take (ab - Suc 0) b @\n                         drop (aa - Suc 0)\n                          (b[aa - Suc 0 := b ! (ab - Suc 0)])", "by (smt Cons_nth_drop_Suc Suc_pred append.assoc append_Cons append_Nil \n      diff_Suc_less drop_update_cancel hd_drop_conv_nth length_list_update \n      less_le_trans nth_list_update_eq take_hd_drop)"], ["", "subsubsection \\<open>Right\\<close>"], ["", "definition \"move_right1 \\<equiv> \\<lambda>(l,r,buf). doN {\n    if r<length buf then doN {\n      ASSERT (l<length buf);\n      RETURN (l+1,r+1,buf[l:=buf!r])\n    } else RETURN (l,r,buf)\n  }\""], ["", "lemma move_right1_correct: \n    \"(move_right1,RETURN o move_right) \\<in> gap_rel \\<rightarrow> \\<langle>gap_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (move_right1, RETURN \\<circ> move_right)\n    \\<in> gap_rel \\<rightarrow> \\<langle>gap_rel\\<rangle>nres_rel", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b a'.\n       ((a, aa, b), a') \\<in> gap_rel \\<Longrightarrow>\n       (move_right1 (a, aa, b), RETURN (move_right a'))\n       \\<in> \\<langle>gap_rel\\<rangle>nres_rel", "unfolding move_right1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b a'.\n       ((a, aa, b), a') \\<in> gap_rel \\<Longrightarrow>\n       (case (a, aa, b) of\n        (l, r, buf) \\<Rightarrow>\n          if r < length buf\n          then ASSERT (l < length buf) \\<bind>\n               (\\<lambda>_. RETURN (l + 1, r + 1, buf[l := buf ! r]))\n          else RETURN (l, r, buf),\n        RETURN (move_right a'))\n       \\<in> \\<langle>gap_rel\\<rangle>nres_rel", "apply refine_vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa b a' ab ba ac bb.\n       \\<lbrakk>((a, aa, b), a') \\<in> gap_rel; (a, aa, b) = (ab, ba);\n        ba = (ac, bb); ac < length bb\\<rbrakk>\n       \\<Longrightarrow> ab < length bb\n 2. \\<And>a aa b a' ab ba ac bb.\n       \\<lbrakk>((a, aa, b), a') \\<in> gap_rel; (a, aa, b) = (ab, ba);\n        ba = (ac, bb); ac < length bb; ab < length bb\\<rbrakk>\n       \\<Longrightarrow> ((ab + 1, ac + 1, bb[ab := bb ! ac]),\n                          move_right a')\n                         \\<in> gap_rel\n 3. \\<And>a aa b a' ab ba ac bb.\n       \\<lbrakk>((a, aa, b), a') \\<in> gap_rel; (a, aa, b) = (ab, ba);\n        ba = (ac, bb); \\<not> ac < length bb\\<rbrakk>\n       \\<Longrightarrow> ((ab, ac, bb), move_right a') \\<in> gap_rel", "unfolding gap_\\<alpha>_def gap_invar_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa b a' ab ba ac bb.\n       \\<lbrakk>((a, aa, b), a')\n                \\<in> br (\\<lambda>(l, r, buf).\n                             BUF l (take l buf @ drop r buf))\n                       (\\<lambda>(l, r, buf).\n                           l \\<le> r \\<and> r \\<le> length buf);\n        (a, aa, b) = (ab, ba); ba = (ac, bb); ac < length bb\\<rbrakk>\n       \\<Longrightarrow> ab < length bb\n 2. \\<And>a aa b a' ab ba ac bb.\n       \\<lbrakk>((a, aa, b), a')\n                \\<in> br (\\<lambda>(l, r, buf).\n                             BUF l (take l buf @ drop r buf))\n                       (\\<lambda>(l, r, buf).\n                           l \\<le> r \\<and> r \\<le> length buf);\n        (a, aa, b) = (ab, ba); ba = (ac, bb); ac < length bb;\n        ab < length bb\\<rbrakk>\n       \\<Longrightarrow> ((ab + 1, ac + 1, bb[ab := bb ! ac]),\n                          move_right a')\n                         \\<in> br (\\<lambda>(l, r, buf).\nBUF l (take l buf @ drop r buf))\n                                (\\<lambda>(l, r, buf).\n                                    l \\<le> r \\<and> r \\<le> length buf)\n 3. \\<And>a aa b a' ab ba ac bb.\n       \\<lbrakk>((a, aa, b), a')\n                \\<in> br (\\<lambda>(l, r, buf).\n                             BUF l (take l buf @ drop r buf))\n                       (\\<lambda>(l, r, buf).\n                           l \\<le> r \\<and> r \\<le> length buf);\n        (a, aa, b) = (ab, ba); ba = (ac, bb); \\<not> ac < length bb\\<rbrakk>\n       \\<Longrightarrow> ((ab, ac, bb), move_right a')\n                         \\<in> br (\\<lambda>(l, r, buf).\nBUF l (take l buf @ drop r buf))\n                                (\\<lambda>(l, r, buf).\n                                    l \\<le> r \\<and> r \\<le> length buf)", "apply (auto simp: in_br_conv split: prod.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b ab.\n       \\<lbrakk>ab \\<le> aa; aa < length b\\<rbrakk>\n       \\<Longrightarrow> take ab b @ drop aa b =\n                         (take (Suc ab) b)[ab := b ! aa] @ drop (Suc aa) b", "apply (rule nth_equalityI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b ab.\n       \\<lbrakk>ab \\<le> aa; aa < length b\\<rbrakk>\n       \\<Longrightarrow> length (take ab b @ drop aa b) =\n                         length\n                          ((take (Suc ab) b)[ab := b ! aa] @\n                           drop (Suc aa) b)\n 2. \\<And>aa b ab i.\n       \\<lbrakk>ab \\<le> aa; aa < length b;\n        i < length (take ab b @ drop aa b)\\<rbrakk>\n       \\<Longrightarrow> (take ab b @ drop aa b) ! i =\n                         ((take (Suc ab) b)[ab := b ! aa] @\n                          drop (Suc aa) b) !\n                         i", "apply (simp_all add: Cons_nth_drop_Suc take_update_last)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Insert and Grow\\<close>"], ["", "definition \"can_insert \\<equiv> \\<lambda>(l,r,buf). l<r\""], ["", "definition \"grow1 K \\<equiv> \\<lambda>(l,r,buf). doN {\n    let b = op_array_replicate (length buf + K) default;\n    b \\<leftarrow> mop_list_blit buf 0 b 0 l;\n    b \\<leftarrow> mop_list_blit buf r b (r+K) (length buf - r);\n    RETURN (l,r+K,b)\n  }\"\n  \\<comment> \\<open>Note: Most operations have also a variant prefixed with \\<open>mop\\<close>.\n    These are defined in the refinement monad and already contain the assertion \n    of their precondition. The backside is that they cannot be easily used in as part\n    of expressions, e.g., in @{term \"buf[l:=buf!r]\"}, we would have to explicitly bind\n    each intermediate value: @{term \"doN { v \\<leftarrow> mop_list_get buf r; mop_list_set buf l v }\"}.\n  \\<close>"], ["", "lemma grow1_correct[THEN SPEC_trans, refine_vcg]: \n    \\<comment> \\<open>Declares this as a rule to be used by the VCG\\<close>\n    assumes \"gap_invar gb\"\n    shows \"grow1 K gb \\<le> (SPEC (\\<lambda>gb'. \n        gap_invar gb' \n      \\<and> gap_\\<alpha> gb' = gap_\\<alpha> gb \n      \\<and> (K>0 \\<longrightarrow> can_insert gb')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. grow1 K gb\n    \\<le> SPEC\n           (\\<lambda>gb'.\n               gap_invar gb' \\<and>\n               gap_\\<alpha> gb' = gap_\\<alpha> gb \\<and>\n               (0 < K \\<longrightarrow> can_insert gb'))", "unfolding grow1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case gb of\n     (l, r, buf) \\<Rightarrow>\n       let b = op_array_replicate (length buf + K) default\n       in mop_list_blit buf 0 b 0 l \\<bind>\n          (\\<lambda>b.\n              mop_list_blit buf r b (r + K) (length buf - r) \\<bind>\n              (\\<lambda>b. RETURN (l, r + K, b))))\n    \\<le> SPEC\n           (\\<lambda>gb'.\n               gap_invar gb' \\<and>\n               gap_\\<alpha> gb' = gap_\\<alpha> gb \\<and>\n               (0 < K \\<longrightarrow> can_insert gb'))", "apply refine_vcg"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> 0 + a \\<le> length ba\n 2. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> 0 + a\n                         \\<le> length\n                                (op_array_replicate (length ba + K) default)\n 3. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa + (length ba - aa) \\<le> length ba\n 4. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa + K + (length ba - aa)\n                         \\<le> length\n                                (op_list_blit ba 0\n                                  (op_array_replicate (length ba + K)\n                                    default)\n                                  0 a)\n 5. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> gap_invar\n                          (a, aa + K,\n                           op_list_blit ba aa\n                            (op_list_blit ba 0\n                              (op_array_replicate (length ba + K) default) 0\n                              a)\n                            (aa + K) (length ba - aa))\n 6. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> gap_\\<alpha>\n                          (a, aa + K,\n                           op_list_blit ba aa\n                            (op_list_blit ba 0\n                              (op_array_replicate (length ba + K) default) 0\n                              a)\n                            (aa + K) (length ba - aa)) =\n                         gap_\\<alpha> gb\n 7. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba); 0 < K\\<rbrakk>\n       \\<Longrightarrow> can_insert\n                          (a, aa + K,\n                           op_list_blit ba aa\n                            (op_list_blit ba 0\n                              (op_array_replicate (length ba + K) default) 0\n                              a)\n                            (aa + K) (length ba - aa))", "using assms"], ["proof (prove)\nusing this:\n  gap_invar gb\n\ngoal (7 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> 0 + a \\<le> length ba\n 2. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> 0 + a\n                         \\<le> length\n                                (op_array_replicate (length ba + K) default)\n 3. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa + (length ba - aa) \\<le> length ba\n 4. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa + K + (length ba - aa)\n                         \\<le> length\n                                (op_list_blit ba 0\n                                  (op_array_replicate (length ba + K)\n                                    default)\n                                  0 a)\n 5. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> gap_invar\n                          (a, aa + K,\n                           op_list_blit ba aa\n                            (op_list_blit ba 0\n                              (op_array_replicate (length ba + K) default) 0\n                              a)\n                            (aa + K) (length ba - aa))\n 6. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> gap_\\<alpha>\n                          (a, aa + K,\n                           op_list_blit ba aa\n                            (op_list_blit ba 0\n                              (op_array_replicate (length ba + K) default) 0\n                              a)\n                            (aa + K) (length ba - aa)) =\n                         gap_\\<alpha> gb\n 7. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba); 0 < K\\<rbrakk>\n       \\<Longrightarrow> can_insert\n                          (a, aa + K,\n                           op_list_blit ba aa\n                            (op_list_blit ba 0\n                              (op_array_replicate (length ba + K) default) 0\n                              a)\n                            (aa + K) (length ba - aa))", "unfolding gap_\\<alpha>_def gap_invar_def can_insert_def"], ["proof (prove)\nusing this:\n  case gb of (l, r, buf) \\<Rightarrow> l \\<le> r \\<and> r \\<le> length buf\n\ngoal (7 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> 0 + a \\<le> length ba\n 2. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> 0 + a\n                         \\<le> length\n                                (op_array_replicate (length ba + K) default)\n 3. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa + (length ba - aa) \\<le> length ba\n 4. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa + K + (length ba - aa)\n                         \\<le> length\n                                (op_list_blit ba 0\n                                  (op_array_replicate (length ba + K)\n                                    default)\n                                  0 a)\n 5. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> case (a, aa + K,\n                               op_list_blit ba aa\n                                (op_list_blit ba 0\n                                  (op_array_replicate (length ba + K)\n                                    default)\n                                  0 a)\n                                (aa + K) (length ba - aa)) of\n                         (l, r, buf) \\<Rightarrow>\n                           l \\<le> r \\<and> r \\<le> length buf\n 6. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> (case (a, aa + K,\n                                op_list_blit ba aa\n                                 (op_list_blit ba 0\n                                   (op_array_replicate (length ba + K)\n                                     default)\n                                   0 a)\n                                 (aa + K) (length ba - aa)) of\n                          (l, r, buf) \\<Rightarrow>\n                            BUF l (take l buf @ drop r buf)) =\n                         (case gb of\n                          (l, r, buf) \\<Rightarrow>\n                            BUF l (take l buf @ drop r buf))\n 7. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba); 0 < K\\<rbrakk>\n       \\<Longrightarrow> case (a, aa + K,\n                               op_list_blit ba aa\n                                (op_list_blit ba 0\n                                  (op_array_replicate (length ba + K)\n                                    default)\n                                  0 a)\n                                (aa + K) (length ba - aa)) of\n                         (l, r, buf) \\<Rightarrow> l < r", "apply (auto simp: op_list_blit_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"insert1 x \\<equiv> \\<lambda>(l,r,buf). doN {\n    (l,r,buf) \\<leftarrow> \n      if (l=r) then grow1 (length buf+1) (l,r,buf) else RETURN (l,r,buf);\n    ASSERT (l<length buf);\n    RETURN (l+1,r,buf[l:=x])\n  }\""], ["", "lemma insert1_correct: \n    \"(insert1,RETURN oo insert) \\<in> Id \\<rightarrow> gap_rel \\<rightarrow> \\<langle>gap_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (insert1, RETURN \\<circ>\\<circ> Challenge1_short.insert)\n    \\<in> Id \\<rightarrow>\n          gap_rel \\<rightarrow> \\<langle>gap_rel\\<rangle>nres_rel", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a' aa ab b a'a.\n       ((aa, ab, b), a'a) \\<in> gap_rel \\<Longrightarrow>\n       (insert1 a' (aa, ab, b), RETURN (Challenge1_short.insert a' a'a))\n       \\<in> \\<langle>gap_rel\\<rangle>nres_rel", "unfolding insert1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a' aa ab b a'a.\n       ((aa, ab, b), a'a) \\<in> gap_rel \\<Longrightarrow>\n       (case (aa, ab, b) of\n        (l, r, buf) \\<Rightarrow>\n          (if l = r then grow1 (length buf + 1) (l, r, buf)\n           else RETURN (l, r, buf)) \\<bind>\n          (\\<lambda>(l, r, buf).\n              ASSERT (l < length buf) \\<bind>\n              (\\<lambda>_. RETURN (l + 1, r, buf[l := a']))),\n        RETURN (Challenge1_short.insert a' a'a))\n       \\<in> \\<langle>gap_rel\\<rangle>nres_rel", "apply refine_vcg \\<comment> \\<open>VCG knows the rule for grow1 already\\<close>"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a' aa ab b a'a a ba ac bb.\n       \\<lbrakk>((aa, ab, b), a'a) \\<in> gap_rel; (aa, ab, b) = (a, ba);\n        ba = (ac, bb); a = ac\\<rbrakk>\n       \\<Longrightarrow> gap_invar (a, ac, bb)\n 2. \\<And>a' aa ab b a'a a ba ac bb x ad bc ae bd.\n       \\<lbrakk>((aa, ab, b), a'a) \\<in> gap_rel; (aa, ab, b) = (a, ba);\n        ba = (ac, bb); a = ac;\n        gap_invar x \\<and>\n        gap_\\<alpha> x = gap_\\<alpha> (a, ac, bb) \\<and>\n        (0 < length bb + 1 \\<longrightarrow> can_insert x);\n        x = (ad, bc); bc = (ae, bd)\\<rbrakk>\n       \\<Longrightarrow> ad < length bd\n 3. \\<And>a' aa ab b a'a a ba ac bb x ad bc ae bd.\n       \\<lbrakk>((aa, ab, b), a'a) \\<in> gap_rel; (aa, ab, b) = (a, ba);\n        ba = (ac, bb); a = ac;\n        gap_invar x \\<and>\n        gap_\\<alpha> x = gap_\\<alpha> (a, ac, bb) \\<and>\n        (0 < length bb + 1 \\<longrightarrow> can_insert x);\n        x = (ad, bc); bc = (ae, bd); ad < length bd\\<rbrakk>\n       \\<Longrightarrow> ((ad + 1, ae, bd[ad := a']),\n                          Challenge1_short.insert a' a'a)\n                         \\<in> gap_rel\n 4. \\<And>a' aa ab b a'a a ba ac bb ad bc ae bd.\n       \\<lbrakk>((aa, ab, b), a'a) \\<in> gap_rel; (aa, ab, b) = (a, ba);\n        ba = (ac, bb); a \\<noteq> ac; (a, ac, bb) = (ad, bc);\n        bc = (ae, bd)\\<rbrakk>\n       \\<Longrightarrow> ad < length bd\n 5. \\<And>a' aa ab b a'a a ba ac bb ad bc ae bd.\n       \\<lbrakk>((aa, ab, b), a'a) \\<in> gap_rel; (aa, ab, b) = (a, ba);\n        ba = (ac, bb); a \\<noteq> ac; (a, ac, bb) = (ad, bc); bc = (ae, bd);\n        ad < length bd\\<rbrakk>\n       \\<Longrightarrow> ((ad + 1, ae, bd[ad := a']),\n                          Challenge1_short.insert a' a'a)\n                         \\<in> gap_rel", "unfolding insert_def gap_\\<alpha>_def gap_invar_def can_insert_def"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a' aa ab b a'a a ba ac bb.\n       \\<lbrakk>((aa, ab, b), a'a)\n                \\<in> br (\\<lambda>(l, r, buf).\n                             BUF l (take l buf @ drop r buf))\n                       (\\<lambda>(l, r, buf).\n                           l \\<le> r \\<and> r \\<le> length buf);\n        (aa, ab, b) = (a, ba); ba = (ac, bb); a = ac\\<rbrakk>\n       \\<Longrightarrow> case (a, ac, bb) of\n                         (l, r, buf) \\<Rightarrow>\n                           l \\<le> r \\<and> r \\<le> length buf\n 2. \\<And>a' aa ab b a'a a ba ac bb x ad bc ae bd.\n       \\<lbrakk>((aa, ab, b), a'a)\n                \\<in> br (\\<lambda>(l, r, buf).\n                             BUF l (take l buf @ drop r buf))\n                       (\\<lambda>(l, r, buf).\n                           l \\<le> r \\<and> r \\<le> length buf);\n        (aa, ab, b) = (a, ba); ba = (ac, bb); a = ac;\n        (case x of\n         (l, r, buf) \\<Rightarrow>\n           l \\<le> r \\<and> r \\<le> length buf) \\<and>\n        (case x of\n         (l, r, buf) \\<Rightarrow> BUF l (take l buf @ drop r buf)) =\n        (case (a, ac, bb) of\n         (l, r, buf) \\<Rightarrow> BUF l (take l buf @ drop r buf)) \\<and>\n        (0 < length bb + 1 \\<longrightarrow>\n         (case x of (l, r, buf) \\<Rightarrow> l < r));\n        x = (ad, bc); bc = (ae, bd)\\<rbrakk>\n       \\<Longrightarrow> ad < length bd\n 3. \\<And>a' aa ab b a'a a ba ac bb x ad bc ae bd.\n       \\<lbrakk>((aa, ab, b), a'a)\n                \\<in> br (\\<lambda>(l, r, buf).\n                             BUF l (take l buf @ drop r buf))\n                       (\\<lambda>(l, r, buf).\n                           l \\<le> r \\<and> r \\<le> length buf);\n        (aa, ab, b) = (a, ba); ba = (ac, bb); a = ac;\n        (case x of\n         (l, r, buf) \\<Rightarrow>\n           l \\<le> r \\<and> r \\<le> length buf) \\<and>\n        (case x of\n         (l, r, buf) \\<Rightarrow> BUF l (take l buf @ drop r buf)) =\n        (case (a, ac, bb) of\n         (l, r, buf) \\<Rightarrow> BUF l (take l buf @ drop r buf)) \\<and>\n        (0 < length bb + 1 \\<longrightarrow>\n         (case x of (l, r, buf) \\<Rightarrow> l < r));\n        x = (ad, bc); bc = (ae, bd); ad < length bd\\<rbrakk>\n       \\<Longrightarrow> ((ad + 1, ae, bd[ad := a']),\n                          rec_textbuffer\n                           (\\<lambda>p t x.\n                               BUF (p + 1) (take p t @ x # drop p t))\n                           a'a a')\n                         \\<in> br (\\<lambda>(l, r, buf).\nBUF l (take l buf @ drop r buf))\n                                (\\<lambda>(l, r, buf).\n                                    l \\<le> r \\<and> r \\<le> length buf)\n 4. \\<And>a' aa ab b a'a a ba ac bb ad bc ae bd.\n       \\<lbrakk>((aa, ab, b), a'a)\n                \\<in> br (\\<lambda>(l, r, buf).\n                             BUF l (take l buf @ drop r buf))\n                       (\\<lambda>(l, r, buf).\n                           l \\<le> r \\<and> r \\<le> length buf);\n        (aa, ab, b) = (a, ba); ba = (ac, bb); a \\<noteq> ac;\n        (a, ac, bb) = (ad, bc); bc = (ae, bd)\\<rbrakk>\n       \\<Longrightarrow> ad < length bd\n 5. \\<And>a' aa ab b a'a a ba ac bb ad bc ae bd.\n       \\<lbrakk>((aa, ab, b), a'a)\n                \\<in> br (\\<lambda>(l, r, buf).\n                             BUF l (take l buf @ drop r buf))\n                       (\\<lambda>(l, r, buf).\n                           l \\<le> r \\<and> r \\<le> length buf);\n        (aa, ab, b) = (a, ba); ba = (ac, bb); a \\<noteq> ac;\n        (a, ac, bb) = (ad, bc); bc = (ae, bd); ad < length bd\\<rbrakk>\n       \\<Longrightarrow> ((ad + 1, ae, bd[ad := a']),\n                          rec_textbuffer\n                           (\\<lambda>p t x.\n                               BUF (p + 1) (take p t @ x # drop p t))\n                           a'a a')\n                         \\<in> br (\\<lambda>(l, r, buf).\nBUF l (take l buf @ drop r buf))\n                                (\\<lambda>(l, r, buf).\n                                    l \\<le> r \\<and> r \\<le> length buf)", "apply (auto simp: in_br_conv take_update_last split: prod.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Delete\\<close>"], ["", "definition \"delete1 \n    \\<equiv> \\<lambda>(l,r,buf). if l>0 then RETURN (l-1,r,buf) else RETURN (l,r,buf)\""], ["", "lemma delete1_correct: \n    \"(delete1,RETURN o delete) \\<in> gap_rel \\<rightarrow> \\<langle>gap_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (delete1, RETURN \\<circ> delete)\n    \\<in> gap_rel \\<rightarrow> \\<langle>gap_rel\\<rangle>nres_rel", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b a'.\n       ((a, aa, b), a') \\<in> gap_rel \\<Longrightarrow>\n       (delete1 (a, aa, b), RETURN (delete a'))\n       \\<in> \\<langle>gap_rel\\<rangle>nres_rel", "unfolding delete1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b a'.\n       ((a, aa, b), a') \\<in> gap_rel \\<Longrightarrow>\n       (case (a, aa, b) of\n        (l, r, buf) \\<Rightarrow>\n          if 0 < l then RETURN (l - 1, r, buf) else RETURN (l, r, buf),\n        RETURN (delete a'))\n       \\<in> \\<langle>gap_rel\\<rangle>nres_rel", "apply refine_vcg"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa b a' ab ba ac bb.\n       \\<lbrakk>((a, aa, b), a') \\<in> gap_rel; (a, aa, b) = (ab, ba);\n        ba = (ac, bb); 0 < ab\\<rbrakk>\n       \\<Longrightarrow> ((ab - 1, ac, bb), delete a') \\<in> gap_rel\n 2. \\<And>a aa b a' ab ba ac bb.\n       \\<lbrakk>((a, aa, b), a') \\<in> gap_rel; (a, aa, b) = (ab, ba);\n        ba = (ac, bb); \\<not> 0 < ab\\<rbrakk>\n       \\<Longrightarrow> ((ab, ac, bb), delete a') \\<in> gap_rel", "unfolding gap_\\<alpha>_def gap_invar_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa b a' ab ba ac bb.\n       \\<lbrakk>((a, aa, b), a')\n                \\<in> br (\\<lambda>(l, r, buf).\n                             BUF l (take l buf @ drop r buf))\n                       (\\<lambda>(l, r, buf).\n                           l \\<le> r \\<and> r \\<le> length buf);\n        (a, aa, b) = (ab, ba); ba = (ac, bb); 0 < ab\\<rbrakk>\n       \\<Longrightarrow> ((ab - 1, ac, bb), delete a')\n                         \\<in> br (\\<lambda>(l, r, buf).\nBUF l (take l buf @ drop r buf))\n                                (\\<lambda>(l, r, buf).\n                                    l \\<le> r \\<and> r \\<le> length buf)\n 2. \\<And>a aa b a' ab ba ac bb.\n       \\<lbrakk>((a, aa, b), a')\n                \\<in> br (\\<lambda>(l, r, buf).\n                             BUF l (take l buf @ drop r buf))\n                       (\\<lambda>(l, r, buf).\n                           l \\<le> r \\<and> r \\<le> length buf);\n        (a, aa, b) = (ab, ba); ba = (ac, bb); \\<not> 0 < ab\\<rbrakk>\n       \\<Longrightarrow> ((ab, ac, bb), delete a')\n                         \\<in> br (\\<lambda>(l, r, buf).\nBUF l (take l buf @ drop r buf))\n                                (\\<lambda>(l, r, buf).\n                                    l \\<le> r \\<and> r \\<le> length buf)", "by (auto simp: in_br_conv butlast_take split: prod.split)"], ["", "subsection \\<open>Imperative Arrays\\<close>"], ["", "text \\<open>The following indicates how we will further refine the gap-buffer:\n    The list will become an array, the indices and the content will not be \n    refined (expressed by @{const nat_assn} and @{const id_assn}).\n  \\<close>"], ["", "abbreviation \"gap_impl_assn \\<equiv> nat_assn \\<times>\\<^sub>a nat_assn \\<times>\\<^sub>a array_assn id_assn\""], ["", "sepref_definition move_left_impl \n    is move_left1 :: \"gap_impl_assn\\<^sup>d\\<rightarrow>\\<^sub>agap_impl_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, move_left1)\n    \\<in> gap_impl_assn\\<^sup>d \\<rightarrow>\\<^sub>a gap_impl_assn", "unfolding move_left1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>(l, r, buf).\n        if l \\<noteq> 0\n        then ASSERT (r - 1 < length buf \\<and> l - 1 < length buf) \\<bind>\n             (\\<lambda>_.\n                 RETURN (l - 1, r - 1, buf[r - 1 := buf ! (l - 1)]))\n        else RETURN (l, r, buf))\n    \\<in> gap_impl_assn\\<^sup>d \\<rightarrow>\\<^sub>a gap_impl_assn", "by sepref"], ["", "sepref_definition move_right_impl \n    is move_right1 :: \"gap_impl_assn\\<^sup>d\\<rightarrow>\\<^sub>agap_impl_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, move_right1)\n    \\<in> gap_impl_assn\\<^sup>d \\<rightarrow>\\<^sub>a gap_impl_assn", "unfolding move_right1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>(l, r, buf).\n        if r < length buf\n        then ASSERT (l < length buf) \\<bind>\n             (\\<lambda>_. RETURN (l + 1, r + 1, buf[l := buf ! r]))\n        else RETURN (l, r, buf))\n    \\<in> gap_impl_assn\\<^sup>d \\<rightarrow>\\<^sub>a gap_impl_assn", "by sepref"], ["", "sepref_definition insert_impl \n    is \"uncurry insert1\" :: \"id_assn\\<^sup>k*\\<^sub>agap_impl_assn\\<^sup>d\\<rightarrow>\\<^sub>agap_impl_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry insert1)\n    \\<in> id_assn\\<^sup>k *\\<^sub>a\n          gap_impl_assn\\<^sup>d \\<rightarrow>\\<^sub>a gap_impl_assn", "unfolding insert1_def grow1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>x (l, r, buf).\n          (if l = r\n           then case (l, r, buf) of\n                (l, r, bufa) \\<Rightarrow>\n                  let b = op_array_replicate\n                           (length bufa + (length buf + 1)) default\n                  in mop_list_blit bufa 0 b 0 l \\<bind>\n                     (\\<lambda>b.\n                         mop_list_blit bufa r b (r + (length buf + 1))\n                          (length bufa - r) \\<bind>\n                         (\\<lambda>b. RETURN (l, r + (length buf + 1), b)))\n           else RETURN (l, r, buf)) \\<bind>\n          (\\<lambda>(l, r, buf).\n              ASSERT (l < length buf) \\<bind>\n              (\\<lambda>_. RETURN (l + 1, r, buf[l := x])))))\n    \\<in> id_assn\\<^sup>k *\\<^sub>a\n          gap_impl_assn\\<^sup>d \\<rightarrow>\\<^sub>a gap_impl_assn", "by sepref \n    \\<comment> \\<open>We inline @{const grow1} here\\<close>"], ["", "sepref_definition delete_impl \n    is delete1 :: \"gap_impl_assn\\<^sup>d\\<rightarrow>\\<^sub>agap_impl_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, delete1)\n    \\<in> gap_impl_assn\\<^sup>d \\<rightarrow>\\<^sub>a gap_impl_assn", "unfolding delete1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>(l, r, buf).\n        if 0 < l then RETURN (l - 1, r, buf) else RETURN (l, r, buf))\n    \\<in> gap_impl_assn\\<^sup>d \\<rightarrow>\\<^sub>a gap_impl_assn", "by sepref"], ["", "text \\<open>Finally, we combine the two refinement steps, to get overall correctness theorems\\<close>"], ["", "definition \"gap_assn \\<equiv> hr_comp gap_impl_assn gap_rel\" \n    \\<comment> \\<open>@{const hr_comp} is composition of refinement relations\\<close>"], ["", "context notes gap_assn_def[symmetric,fcomp_norm_unfold] begin"], ["", "lemmas move_left_impl_correct = move_left_impl.refine[FCOMP move_left1_correct]\n       and move_right_impl_correct = move_right_impl.refine[FCOMP move_right1_correct]\n       and insert_impl_correct = insert_impl.refine[FCOMP insert1_correct]\n       and delete_impl_correct = delete_impl.refine[FCOMP delete1_correct]"], ["", "text \\<open>Proves:\n      @{thm [display] move_left_impl_correct}\n      @{thm [display] move_right_impl_correct}\n      @{thm [display] insert_impl_correct}\n      @{thm [display] delete_impl_correct}\n    \\<close>"], ["", "end"], ["", "subsection \\<open>Executable Code\\<close>"], ["", "text \\<open>Isabelle/HOL can generate code in various target languages.\\<close>"], ["", "export_code move_left_impl move_right_impl insert_impl delete_impl  \n    in SML_imp module_name Gap_Buffer\n    in OCaml_imp module_name Gap_Buffer\n    in Haskell module_name Gap_Buffer\n    in Scala module_name Gap_Buffer"], ["", "end"]]}