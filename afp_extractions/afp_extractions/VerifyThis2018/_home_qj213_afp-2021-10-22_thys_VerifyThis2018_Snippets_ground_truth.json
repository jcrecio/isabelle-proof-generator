{"file_name": "/home/qj213/afp-2021-10-22/thys/VerifyThis2018/Snippets.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/VerifyThis2018", "problem_names": ["lemma find_elem_correct: \"find_elem x xs \\<le> SPEC (\\<lambda>i. i\\<le>length xs \\<and> (i<length xs \\<longrightarrow> xs!i = x))\"", "lemma find_elem_r1: \"(find_elem, \\<lambda> x xs. SPEC (\\<lambda>i. i\\<le>length xs \\<and> (i<length xs \\<longrightarrow> xs!i = x))) \\<in> Id \\<rightarrow> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\"", "lemma check_prefix_correct: \"check_prefix xs ys \\<le> ESPEC (\\<lambda>_. xs \\<noteq> take (length xs) ys) (\\<lambda>_. xs = take (length xs) ys)\"", "lemmas [refine_vcg] = check_prefix_correct[THEN ESPEC_trans]", "lemma is_prefix'_correct: \"is_prefix' xs ys \\<le> ESPEC (\\<lambda>_. False) (\\<lambda>r. r \\<longleftrightarrow> xs = take (length xs) ys)\"", "lemmas [sepref_fr_rules] = check_prefix_impl.refine", "lemma \"is_prefix xs ys \\<le> ESPEC (\\<lambda>_. False) (\\<lambda>r. r \\<longleftrightarrow> xs = take (length xs) ys)\"", "lemma \"cp_array xs \\<le> SPEC (\\<lambda>ys. ys=xs)\"", "lemma \"cp_array xs \\<le> SPEC (\\<lambda>ys. ys=xs)\""], "translations": [["", "lemma find_elem_correct: \"find_elem x xs \\<le> SPEC (\\<lambda>i. i\\<le>length xs \\<and> (i<length xs \\<longrightarrow> xs!i = x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_elem x xs\n    \\<le> SPEC\n           (\\<lambda>i.\n               i \\<le> length xs \\<and>\n               (i < length xs \\<longrightarrow> xs ! i = x))", "unfolding find_elem_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T\\<^bsup>\\<lambda>i.\n                            i \\<le> length xs \\<and>\n                            x \\<notin> set (take i xs)\\<^esup>\n     (\\<lambda>i. i < length xs \\<and> xs ! i \\<noteq> x)\n     (\\<lambda>i. RETURN (i + 1)) 0\n    \\<le> SPEC\n           (\\<lambda>i.\n               i \\<le> length xs \\<and>\n               (i < length xs \\<longrightarrow> xs ! i = x))", "apply refine_vcg"], ["proof (prove)\ngoal (8 subgoals):\n 1. wf ?R\n 2. 0 \\<le> length xs\n 3. x \\<notin> set (take 0 xs)\n 4. \\<And>s.\n       \\<lbrakk>s \\<le> length xs \\<and> x \\<notin> set (take s xs);\n        s < length xs \\<and> xs ! s \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> s + 1 \\<le> length xs\n 5. \\<And>s.\n       \\<lbrakk>s \\<le> length xs \\<and> x \\<notin> set (take s xs);\n        s < length xs \\<and> xs ! s \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> set (take (s + 1) xs)\n 6. \\<And>s.\n       \\<lbrakk>s \\<le> length xs \\<and> x \\<notin> set (take s xs);\n        s < length xs \\<and> xs ! s \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> (s + 1, s) \\<in> ?R\n 7. \\<And>s.\n       \\<lbrakk>s \\<le> length xs \\<and> x \\<notin> set (take s xs);\n        \\<not> (s < length xs \\<and> xs ! s \\<noteq> x)\\<rbrakk>\n       \\<Longrightarrow> s \\<le> length xs\n 8. \\<And>s.\n       \\<lbrakk>s \\<le> length xs \\<and> x \\<notin> set (take s xs);\n        \\<not> (s < length xs \\<and> xs ! s \\<noteq> x);\n        s < length xs\\<rbrakk>\n       \\<Longrightarrow> xs ! s = x", "apply (rule wf_measure[of \"\\<lambda>i. length xs - i\"])"], ["proof (prove)\ngoal (7 subgoals):\n 1. 0 \\<le> length xs\n 2. x \\<notin> set (take 0 xs)\n 3. \\<And>s.\n       \\<lbrakk>s \\<le> length xs \\<and> x \\<notin> set (take s xs);\n        s < length xs \\<and> xs ! s \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> s + 1 \\<le> length xs\n 4. \\<And>s.\n       \\<lbrakk>s \\<le> length xs \\<and> x \\<notin> set (take s xs);\n        s < length xs \\<and> xs ! s \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> set (take (s + 1) xs)\n 5. \\<And>s.\n       \\<lbrakk>s \\<le> length xs \\<and> x \\<notin> set (take s xs);\n        s < length xs \\<and> xs ! s \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> (s + 1, s) \\<in> measure ((-) (length xs))\n 6. \\<And>s.\n       \\<lbrakk>s \\<le> length xs \\<and> x \\<notin> set (take s xs);\n        \\<not> (s < length xs \\<and> xs ! s \\<noteq> x)\\<rbrakk>\n       \\<Longrightarrow> s \\<le> length xs\n 7. \\<And>s.\n       \\<lbrakk>s \\<le> length xs \\<and> x \\<notin> set (take s xs);\n        \\<not> (s < length xs \\<and> xs ! s \\<noteq> x);\n        s < length xs\\<rbrakk>\n       \\<Longrightarrow> xs ! s = x", "apply (auto simp: in_set_conv_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s i.\n       \\<lbrakk>\\<forall>ia<s. xs ! ia \\<noteq> xs ! i; s < length xs;\n        xs ! s \\<noteq> xs ! i; i < Suc s; x = xs ! i\\<rbrakk>\n       \\<Longrightarrow> False", "(*sledgehammer*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s i.\n       \\<lbrakk>\\<forall>ia<s. xs ! ia \\<noteq> xs ! i; s < length xs;\n        xs ! s \\<noteq> xs ! i; i < Suc s; x = xs ! i\\<rbrakk>\n       \\<Longrightarrow> False", "using less_Suc_eq"], ["proof (prove)\nusing this:\n  (?m < Suc ?n) = (?m < ?n \\<or> ?m = ?n)\n\ngoal (1 subgoal):\n 1. \\<And>s i.\n       \\<lbrakk>\\<forall>ia<s. xs ! ia \\<noteq> xs ! i; s < length xs;\n        xs ! s \\<noteq> xs ! i; i < Suc s; x = xs ! i\\<rbrakk>\n       \\<Longrightarrow> False", "by blast"], ["", "sepref_definition find_elem_impl is \"uncurry find_elem\" :: \"int_assn\\<^sup>k *\\<^sub>a (array_assn int_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry find_elem)\n    \\<in> int_assn\\<^sup>k *\\<^sub>a\n          (array_assn int_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "unfolding find_elem_def short_circuit_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>x xs.\n          WHILE\\<^sub>T\\<^bsup>\\<lambda>i.\n                                  if i \\<le> length xs\n                                  then x \\<notin> set (take i xs)\n                                  else False\\<^esup>\n           (\\<lambda>i. if i < length xs then xs ! i \\<noteq> x else False)\n           (\\<lambda>i. RETURN (i + 1)) 0))\n    \\<in> int_assn\\<^sup>k *\\<^sub>a\n          (array_assn int_assn)\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by sepref"], ["", "export_code find_elem_impl in Haskell module_name test"], ["", "subsection \\<open>Combined Correctness Theorem\\<close>"], ["", "lemma find_elem_r1: \"(find_elem, \\<lambda> x xs. SPEC (\\<lambda>i. i\\<le>length xs \\<and> (i<length xs \\<longrightarrow> xs!i = x))) \\<in> Id \\<rightarrow> Id \\<rightarrow> \\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (find_elem,\n     \\<lambda>x xs.\n        SPEC\n         (\\<lambda>i.\n             i \\<le> length xs \\<and>\n             (i < length xs \\<longrightarrow> xs ! i = x)))\n    \\<in> int_rel \\<rightarrow>\n          Id \\<rightarrow> \\<langle>nat_rel\\<rangle>nres_rel", "using find_elem_correct"], ["proof (prove)\nusing this:\n  find_elem ?x ?xs\n  \\<le> SPEC\n         (\\<lambda>i.\n             i \\<le> length ?xs \\<and>\n             (i < length ?xs \\<longrightarrow> ?xs ! i = ?x))\n\ngoal (1 subgoal):\n 1. (find_elem,\n     \\<lambda>x xs.\n        SPEC\n         (\\<lambda>i.\n             i \\<le> length xs \\<and>\n             (i < length xs \\<longrightarrow> xs ! i = x)))\n    \\<in> int_rel \\<rightarrow>\n          Id \\<rightarrow> \\<langle>nat_rel\\<rangle>nres_rel", "by (auto intro: nres_relI)"], ["", "thm find_elem_impl.refine[FCOMP find_elem_r1]"], ["", "section \\<open>Check Prefix (Arrays, Exceptions: Check)\\<close>"], ["", "definition \"check_prefix xs ys \\<equiv> doE {\n    CHECK (length xs \\<le> length ys) ();\n    EWHILEIT (\\<lambda>i. i\\<le>length xs \\<and> take i xs = take i ys) (\\<lambda>i. i<length xs) (\\<lambda>i. doE { \n      EASSERT (i<length xs \\<and> i<length ys); \n      CHECK (xs!i = ys!i) (); \n      ERETURN (i+1) \n    } ) 0;\n    ERETURN ()\n  }\""], ["", "(* ESPEC Exc Normal ! *)"], ["", "lemma check_prefix_correct: \"check_prefix xs ys \\<le> ESPEC (\\<lambda>_. xs \\<noteq> take (length xs) ys) (\\<lambda>_. xs = take (length xs) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_prefix xs ys\n    \\<le> ESPEC (\\<lambda>_. xs \\<noteq> take (length xs) ys)\n           (\\<lambda>_. xs = take (length xs) ys)", "unfolding check_prefix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ebind (CHECK (length xs \\<le> length ys) ())\n     (\\<lambda>_.\n         ebind\n          (EWHILEIT\n            (\\<lambda>i. i \\<le> length xs \\<and> take i xs = take i ys)\n            (\\<lambda>i. i < length xs)\n            (\\<lambda>i.\n                ebind (EASSERT (i < length xs \\<and> i < length ys))\n                 (\\<lambda>_.\n                     ebind (CHECK (xs ! i = ys ! i) ())\n                      (\\<lambda>_. ERETURN (i + 1))))\n            0)\n          (\\<lambda>_. ERETURN ()))\n    \\<le> ESPEC (\\<lambda>_. xs \\<noteq> take (length xs) ys)\n           (\\<lambda>_. xs = take (length xs) ys)", "apply (refine_vcg EWHILEIT_rule[where R=\"measure (\\<lambda>i. length xs - i)\"])"], ["proof (prove)\ngoal (10 subgoals):\n 1. length xs \\<le> length ys \\<Longrightarrow>\n    wf (measure ((-) (length xs)))\n 2. length xs \\<le> length ys \\<Longrightarrow> 0 \\<le> length xs\n 3. length xs \\<le> length ys \\<Longrightarrow> take 0 xs = take 0 ys\n 4. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> s < length ys\n 5. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> s + 1 \\<le> length xs\n 6. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> take (s + 1) xs = take (s + 1) ys\n 7. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> (s + 1, s) \\<in> measure ((-) (length xs))\n 8. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s \\<noteq> ys ! s\\<rbrakk>\n       \\<Longrightarrow> xs \\<noteq> take (length xs) ys\n 9. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys;\n        \\<not> s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> xs = take (length xs) ys\n 10. \\<not> length xs \\<le> length ys \\<Longrightarrow>\n     xs \\<noteq> take (length xs) ys", "apply auto []"], ["proof (prove)\ngoal (9 subgoals):\n 1. length xs \\<le> length ys \\<Longrightarrow> 0 \\<le> length xs\n 2. length xs \\<le> length ys \\<Longrightarrow> take 0 xs = take 0 ys\n 3. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> s < length ys\n 4. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> s + 1 \\<le> length xs\n 5. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> take (s + 1) xs = take (s + 1) ys\n 6. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> (s + 1, s) \\<in> measure ((-) (length xs))\n 7. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s \\<noteq> ys ! s\\<rbrakk>\n       \\<Longrightarrow> xs \\<noteq> take (length xs) ys\n 8. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys;\n        \\<not> s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> xs = take (length xs) ys\n 9. \\<not> length xs \\<le> length ys \\<Longrightarrow>\n    xs \\<noteq> take (length xs) ys", "apply auto []"], ["proof (prove)\ngoal (8 subgoals):\n 1. length xs \\<le> length ys \\<Longrightarrow> take 0 xs = take 0 ys\n 2. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> s < length ys\n 3. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> s + 1 \\<le> length xs\n 4. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> take (s + 1) xs = take (s + 1) ys\n 5. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> (s + 1, s) \\<in> measure ((-) (length xs))\n 6. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s \\<noteq> ys ! s\\<rbrakk>\n       \\<Longrightarrow> xs \\<noteq> take (length xs) ys\n 7. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys;\n        \\<not> s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> xs = take (length xs) ys\n 8. \\<not> length xs \\<le> length ys \\<Longrightarrow>\n    xs \\<noteq> take (length xs) ys", "apply auto []"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> s < length ys\n 2. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> s + 1 \\<le> length xs\n 3. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> take (s + 1) xs = take (s + 1) ys\n 4. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> (s + 1, s) \\<in> measure ((-) (length xs))\n 5. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s \\<noteq> ys ! s\\<rbrakk>\n       \\<Longrightarrow> xs \\<noteq> take (length xs) ys\n 6. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys;\n        \\<not> s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> xs = take (length xs) ys\n 7. \\<not> length xs \\<le> length ys \\<Longrightarrow>\n    xs \\<noteq> take (length xs) ys", "apply auto []"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> s + 1 \\<le> length xs\n 2. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> take (s + 1) xs = take (s + 1) ys\n 3. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> (s + 1, s) \\<in> measure ((-) (length xs))\n 4. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s \\<noteq> ys ! s\\<rbrakk>\n       \\<Longrightarrow> xs \\<noteq> take (length xs) ys\n 5. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys;\n        \\<not> s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> xs = take (length xs) ys\n 6. \\<not> length xs \\<le> length ys \\<Longrightarrow>\n    xs \\<noteq> take (length xs) ys", "apply auto []"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> take (s + 1) xs = take (s + 1) ys\n 2. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> (s + 1, s) \\<in> measure ((-) (length xs))\n 3. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s \\<noteq> ys ! s\\<rbrakk>\n       \\<Longrightarrow> xs \\<noteq> take (length xs) ys\n 4. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys;\n        \\<not> s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> xs = take (length xs) ys\n 5. \\<not> length xs \\<le> length ys \\<Longrightarrow>\n    xs \\<noteq> take (length xs) ys", "apply auto []"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys; take s xs = take s ys;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*; xs ! s = ys ! s;\n        s < length xs\\<rbrakk>\n       \\<Longrightarrow> take (Suc s) xs = take (Suc s) ys\n 2. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> (s + 1, s) \\<in> measure ((-) (length xs))\n 3. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s \\<noteq> ys ! s\\<rbrakk>\n       \\<Longrightarrow> xs \\<noteq> take (length xs) ys\n 4. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys;\n        \\<not> s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> xs = take (length xs) ys\n 5. \\<not> length xs \\<le> length ys \\<Longrightarrow>\n    xs \\<noteq> take (length xs) ys", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs \\<le> length ys; take s_ xs = take s_ ys;\n     (s_, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*; xs ! s_ = ys ! s_;\n     s_ < length xs\\<rbrakk>\n    \\<Longrightarrow> take (Suc s_) xs = take (Suc s_) ys", "by (simp add: take_Suc_conv_app_nth)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> (s + 1, s) \\<in> measure ((-) (length xs))\n 2. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s \\<noteq> ys ! s\\<rbrakk>\n       \\<Longrightarrow> xs \\<noteq> take (length xs) ys\n 3. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys;\n        \\<not> s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> xs = take (length xs) ys\n 4. \\<not> length xs \\<le> length ys \\<Longrightarrow>\n    xs \\<noteq> take (length xs) ys", "apply auto []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s \\<noteq> ys ! s\\<rbrakk>\n       \\<Longrightarrow> xs \\<noteq> take (length xs) ys\n 2. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys;\n        \\<not> s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> xs = take (length xs) ys\n 3. \\<not> length xs \\<le> length ys \\<Longrightarrow>\n    xs \\<noteq> take (length xs) ys", "apply auto []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys; take s xs = take s ys;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        xs ! s \\<noteq> ys ! s; s < length xs;\n        xs = take (length xs) ys\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys;\n        \\<not> s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> xs = take (length xs) ys\n 3. \\<not> length xs \\<le> length ys \\<Longrightarrow>\n    xs \\<noteq> take (length xs) ys", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs \\<le> length ys; take s_ xs = take s_ ys;\n     (s_, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n     xs ! s_ \\<noteq> ys ! s_; s_ < length xs;\n     xs = take (length xs) ys\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis nth_take)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys;\n        \\<not> s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> xs = take (length xs) ys\n 2. \\<not> length xs \\<le> length ys \\<Longrightarrow>\n    xs \\<noteq> take (length xs) ys", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs \\<le> length ys;\n     s_ \\<le> length xs \\<and> take s_ xs = take s_ ys;\n     \\<not> s_ < length xs;\n     (s_, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> xs = take (length xs) ys", "by force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> length ys \\<Longrightarrow>\n    xs \\<noteq> take (length xs) ys", "apply auto []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "synth_definition check_prefix_bd is [enres_unfolds]: \"check_prefix xs ys = \\<hole>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_prefix xs ys = ?HOLE", "apply (rule CNV_eqD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV (check_prefix xs ys) ?HOLE", "unfolding check_prefix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV (ebind (CHECK (length xs \\<le> length ys) ())\n          (\\<lambda>_.\n              ebind\n               (EWHILEIT\n                 (\\<lambda>i.\n                     i \\<le> length xs \\<and> take i xs = take i ys)\n                 (\\<lambda>i. i < length xs)\n                 (\\<lambda>i.\n                     ebind (EASSERT (i < length xs \\<and> i < length ys))\n                      (\\<lambda>_.\n                          ebind (CHECK (xs ! i = ys ! i) ())\n                           (\\<lambda>_. ERETURN (i + 1))))\n                 0)\n               (\\<lambda>_. ERETURN ())))\n     ?HOLE", "apply opt_enres_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV (if length xs \\<le> length ys\n         then WHILE\\<^sub>T\\<^bsup>case_sum (\\<lambda>x. True)\n                                    (\\<lambda>s.\n  s \\<le> length xs \\<and> take s xs = take s ys)\\<^esup>\n               (case_sum (\\<lambda>x. False) (\\<lambda>s. s < length xs))\n               (\\<lambda>s.\n                   ASSERT (\\<not> isl s) \\<bind>\n                   (\\<lambda>_.\n                       let s = projr s\n                       in ASSERT\n                           (s < length xs \\<and> s < length ys) \\<bind>\n                          (\\<lambda>_.\n                              if xs ! s = ys ! s then RETURN (Inr (s + 1))\n                              else RETURN (Inl ()))))\n               (Inr 0) \\<bind>\n              (\\<lambda>x.\n                  case x of Inl e \\<Rightarrow> RETURN (Inl e)\n                  | Inr x \\<Rightarrow> RETURN (Inr ()))\n         else RETURN (Inl ()))\n     ?HOLE", "apply (rule CNV_I)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_definition check_prefix_impl is \"uncurry check_prefix_bd\" \n    :: \"(array_assn int_assn)\\<^sup>k *\\<^sub>a (array_assn int_assn)\\<^sup>k \\<rightarrow>\\<^sub>a (unit_assn +\\<^sub>a unit_assn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry check_prefix_bd)\n    \\<in> (array_assn int_assn)\\<^sup>k *\\<^sub>a\n          (array_assn\n            int_assn)\\<^sup>k \\<rightarrow>\\<^sub>a unit_assn +\\<^sub>a\n              unit_assn", "unfolding check_prefix_bd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>xs ys.\n          if length xs \\<le> length ys\n          then WHILE\\<^sub>T\\<^bsup>case_sum (\\<lambda>x. True)\n                                     (\\<lambda>s.\n   s \\<le> length xs \\<and> take s xs = take s ys)\\<^esup>\n                (case_sum (\\<lambda>x. False) (\\<lambda>s. s < length xs))\n                (\\<lambda>s.\n                    ASSERT (\\<not> isl s) \\<bind>\n                    (\\<lambda>_.\n                        let s = projr s\n                        in ASSERT\n                            (s < length xs \\<and> s < length ys) \\<bind>\n                           (\\<lambda>_.\n                               if xs ! s = ys ! s then RETURN (Inr (s + 1))\n                               else RETURN (Inl ()))))\n                (Inr 0) \\<bind>\n               (\\<lambda>x.\n                   case x of Inl e \\<Rightarrow> RETURN (Inl e)\n                   | Inr x \\<Rightarrow> RETURN (Inr ()))\n          else RETURN (Inl ())))\n    \\<in> (array_assn int_assn)\\<^sup>k *\\<^sub>a\n          (array_assn\n            int_assn)\\<^sup>k \\<rightarrow>\\<^sub>a unit_assn +\\<^sub>a\n              unit_assn", "by sepref"], ["", "export_code check_prefix_impl checking SML_imp"], ["", "subsection \\<open>Modularity\\<close>"], ["", "lemmas [refine_vcg] = check_prefix_correct[THEN ESPEC_trans]"], ["", "thm SPEC_trans"], ["", "(* for plain nres-monad without exceptions *)\n    \n  (* TODO: I remember to have automated the order_trans transformation, but cannot find it right now. *)"], ["", "definition \"is_prefix' xs ys \\<equiv> CATCH (doE {check_prefix xs ys; ERETURN True }) (\\<lambda>_. ERETURN False)\""], ["", "lemma is_prefix'_correct: \"is_prefix' xs ys \\<le> ESPEC (\\<lambda>_. False) (\\<lambda>r. r \\<longleftrightarrow> xs = take (length xs) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_prefix' xs ys\n    \\<le> ESPEC (\\<lambda>_. False)\n           (\\<lambda>r. r = (xs = take (length xs) ys))", "unfolding is_prefix'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CATCH (ebind (check_prefix xs ys) (\\<lambda>_. ERETURN True))\n     (\\<lambda>_. ERETURN False)\n    \\<le> ESPEC (\\<lambda>_. False)\n           (\\<lambda>r. r = (xs = take (length xs) ys))", "apply refine_vcg"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e.\n       xs \\<noteq> take (length xs) ys \\<Longrightarrow>\n       False = (xs = take (length xs) ys)\n 2. \\<And>x.\n       xs = take (length xs) ys \\<Longrightarrow>\n       True = (xs = take (length xs) ys)", "by auto"], ["", "lemmas [sepref_fr_rules] = check_prefix_impl.refine"], ["", "sepref_register check_prefix_bd :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> (unit+unit) nres\""], ["", "(* Optional interface type. Required if interfaces used that do not match Isabelle types, e.g. i_map, i_mtx, \\<dots>*)"], ["", "synth_definition is_prefix_bd' is [enres_unfolds]: \"is_prefix' xs ys = \\<hole>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_prefix' xs ys = ?HOLE", "apply (rule CNV_eqD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV (is_prefix' xs ys) ?HOLE", "unfolding is_prefix'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV (CATCH (ebind (check_prefix xs ys) (\\<lambda>_. ERETURN True))\n          (\\<lambda>_. ERETURN False))\n     ?HOLE", "apply opt_enres_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV (check_prefix_bd xs ys \\<bind>\n         (\\<lambda>x.\n             (case x of Inl e \\<Rightarrow> RETURN (Inl e)\n              | Inr x \\<Rightarrow> RETURN (Inr True)) \\<bind>\n             case_sum (\\<lambda>e. RETURN (Inr False))\n              (\\<lambda>r. RETURN (Inr r))))\n     ?HOLE", "apply (rule CNV_I)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_definition is_prefix_impl' is \"uncurry is_prefix_bd'\" \n    :: \"(array_assn int_assn)\\<^sup>k *\\<^sub>a (array_assn int_assn)\\<^sup>k \\<rightarrow>\\<^sub>a (unit_assn +\\<^sub>a bool_assn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry is_prefix_bd')\n    \\<in> (array_assn int_assn)\\<^sup>k *\\<^sub>a\n          (array_assn\n            int_assn)\\<^sup>k \\<rightarrow>\\<^sub>a unit_assn +\\<^sub>a\n              bool_assn", "unfolding is_prefix_bd'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>xs ys.\n          check_prefix_bd xs ys \\<bind>\n          (\\<lambda>x.\n              (case x of Inl e \\<Rightarrow> RETURN (Inl e)\n               | Inr x \\<Rightarrow> RETURN (Inr True)) \\<bind>\n              case_sum (\\<lambda>e. RETURN (Inr False))\n               (\\<lambda>r. RETURN (Inr r)))))\n    \\<in> (array_assn int_assn)\\<^sup>k *\\<^sub>a\n          (array_assn\n            int_assn)\\<^sup>k \\<rightarrow>\\<^sub>a unit_assn +\\<^sub>a\n              bool_assn", "by sepref"], ["", "export_code is_prefix_impl' checking SML_imp"], ["", "section \\<open>Is Prefix (Arrays, Exceptions: Catch)\\<close>"], ["", "definition \"is_prefix xs ys \\<equiv> CATCH (doE {\n    CHECK (length xs \\<le> length ys) False;\n    EWHILEIT (\\<lambda>i. i\\<le>length xs \\<and> take i xs = take i ys) (\\<lambda>i. i<length xs) (\\<lambda>i. doE { \n      EASSERT (i<length xs \\<and> i<length ys); \n      CHECK (xs!i = ys!i) False;\n      ERETURN (i+1) \n    } ) 0;\n    THROW True\n  }) (ERETURN)\""], ["", "(* ESPEC Exc Normal ! *)"], ["", "lemma \"is_prefix xs ys \\<le> ESPEC (\\<lambda>_. False) (\\<lambda>r. r \\<longleftrightarrow> xs = take (length xs) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_prefix xs ys\n    \\<le> ESPEC (\\<lambda>_. False)\n           (\\<lambda>r. r = (xs = take (length xs) ys))", "unfolding is_prefix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CATCH\n     (ebind (CHECK (length xs \\<le> length ys) False)\n       (\\<lambda>_.\n           ebind\n            (EWHILEIT\n              (\\<lambda>i. i \\<le> length xs \\<and> take i xs = take i ys)\n              (\\<lambda>i. i < length xs)\n              (\\<lambda>i.\n                  ebind (EASSERT (i < length xs \\<and> i < length ys))\n                   (\\<lambda>_.\n                       ebind (CHECK (xs ! i = ys ! i) False)\n                        (\\<lambda>_. ERETURN (i + 1))))\n              0)\n            (\\<lambda>_. THROW True)))\n     ERETURN\n    \\<le> ESPEC (\\<lambda>_. False)\n           (\\<lambda>r. r = (xs = take (length xs) ys))", "apply (refine_vcg EWHILEIT_rule[where R=\"measure (\\<lambda>i. length xs - i)\"])"], ["proof (prove)\ngoal (10 subgoals):\n 1. length xs \\<le> length ys \\<Longrightarrow>\n    wf (measure ((-) (length xs)))\n 2. length xs \\<le> length ys \\<Longrightarrow> 0 \\<le> length xs\n 3. length xs \\<le> length ys \\<Longrightarrow> take 0 xs = take 0 ys\n 4. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> s < length ys\n 5. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> s + 1 \\<le> length xs\n 6. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> take (s + 1) xs = take (s + 1) ys\n 7. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> (s + 1, s) \\<in> measure ((-) (length xs))\n 8. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s \\<noteq> ys ! s\\<rbrakk>\n       \\<Longrightarrow> False = (xs = take (length xs) ys)\n 9. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys;\n        \\<not> s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> True = (xs = take (length xs) ys)\n 10. \\<not> length xs \\<le> length ys \\<Longrightarrow>\n     False = (xs = take (length xs) ys)", "apply auto []"], ["proof (prove)\ngoal (9 subgoals):\n 1. length xs \\<le> length ys \\<Longrightarrow> 0 \\<le> length xs\n 2. length xs \\<le> length ys \\<Longrightarrow> take 0 xs = take 0 ys\n 3. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> s < length ys\n 4. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> s + 1 \\<le> length xs\n 5. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> take (s + 1) xs = take (s + 1) ys\n 6. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> (s + 1, s) \\<in> measure ((-) (length xs))\n 7. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s \\<noteq> ys ! s\\<rbrakk>\n       \\<Longrightarrow> False = (xs = take (length xs) ys)\n 8. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys;\n        \\<not> s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> True = (xs = take (length xs) ys)\n 9. \\<not> length xs \\<le> length ys \\<Longrightarrow>\n    False = (xs = take (length xs) ys)", "apply auto []"], ["proof (prove)\ngoal (8 subgoals):\n 1. length xs \\<le> length ys \\<Longrightarrow> take 0 xs = take 0 ys\n 2. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> s < length ys\n 3. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> s + 1 \\<le> length xs\n 4. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> take (s + 1) xs = take (s + 1) ys\n 5. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> (s + 1, s) \\<in> measure ((-) (length xs))\n 6. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s \\<noteq> ys ! s\\<rbrakk>\n       \\<Longrightarrow> False = (xs = take (length xs) ys)\n 7. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys;\n        \\<not> s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> True = (xs = take (length xs) ys)\n 8. \\<not> length xs \\<le> length ys \\<Longrightarrow>\n    False = (xs = take (length xs) ys)", "apply auto []"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> s < length ys\n 2. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> s + 1 \\<le> length xs\n 3. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> take (s + 1) xs = take (s + 1) ys\n 4. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> (s + 1, s) \\<in> measure ((-) (length xs))\n 5. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s \\<noteq> ys ! s\\<rbrakk>\n       \\<Longrightarrow> False = (xs = take (length xs) ys)\n 6. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys;\n        \\<not> s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> True = (xs = take (length xs) ys)\n 7. \\<not> length xs \\<le> length ys \\<Longrightarrow>\n    False = (xs = take (length xs) ys)", "apply auto []"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> s + 1 \\<le> length xs\n 2. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> take (s + 1) xs = take (s + 1) ys\n 3. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> (s + 1, s) \\<in> measure ((-) (length xs))\n 4. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s \\<noteq> ys ! s\\<rbrakk>\n       \\<Longrightarrow> False = (xs = take (length xs) ys)\n 5. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys;\n        \\<not> s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> True = (xs = take (length xs) ys)\n 6. \\<not> length xs \\<le> length ys \\<Longrightarrow>\n    False = (xs = take (length xs) ys)", "apply auto []"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> take (s + 1) xs = take (s + 1) ys\n 2. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> (s + 1, s) \\<in> measure ((-) (length xs))\n 3. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s \\<noteq> ys ! s\\<rbrakk>\n       \\<Longrightarrow> False = (xs = take (length xs) ys)\n 4. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys;\n        \\<not> s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> True = (xs = take (length xs) ys)\n 5. \\<not> length xs \\<le> length ys \\<Longrightarrow>\n    False = (xs = take (length xs) ys)", "apply auto []"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys; take s xs = take s ys;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*; xs ! s = ys ! s;\n        s < length xs\\<rbrakk>\n       \\<Longrightarrow> take (Suc s) xs = take (Suc s) ys\n 2. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> (s + 1, s) \\<in> measure ((-) (length xs))\n 3. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s \\<noteq> ys ! s\\<rbrakk>\n       \\<Longrightarrow> False = (xs = take (length xs) ys)\n 4. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys;\n        \\<not> s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> True = (xs = take (length xs) ys)\n 5. \\<not> length xs \\<le> length ys \\<Longrightarrow>\n    False = (xs = take (length xs) ys)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs \\<le> length ys; take s_ xs = take s_ ys;\n     (s_, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*; xs ! s_ = ys ! s_;\n     s_ < length xs\\<rbrakk>\n    \\<Longrightarrow> take (Suc s_) xs = take (Suc s_) ys", "by (simp add: take_Suc_conv_app_nth)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s = ys ! s\\<rbrakk>\n       \\<Longrightarrow> (s + 1, s) \\<in> measure ((-) (length xs))\n 2. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s \\<noteq> ys ! s\\<rbrakk>\n       \\<Longrightarrow> False = (xs = take (length xs) ys)\n 3. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys;\n        \\<not> s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> True = (xs = take (length xs) ys)\n 4. \\<not> length xs \\<le> length ys \\<Longrightarrow>\n    False = (xs = take (length xs) ys)", "apply auto []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys; s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        s < length xs \\<and> s < length ys; xs ! s \\<noteq> ys ! s\\<rbrakk>\n       \\<Longrightarrow> False = (xs = take (length xs) ys)\n 2. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys;\n        \\<not> s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> True = (xs = take (length xs) ys)\n 3. \\<not> length xs \\<le> length ys \\<Longrightarrow>\n    False = (xs = take (length xs) ys)", "apply auto []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys; take s xs = take s ys;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n        xs ! s \\<noteq> ys ! s; s < length xs;\n        xs = take (length xs) ys\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys;\n        \\<not> s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> True = (xs = take (length xs) ys)\n 3. \\<not> length xs \\<le> length ys \\<Longrightarrow>\n    False = (xs = take (length xs) ys)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs \\<le> length ys; take s_ xs = take s_ ys;\n     (s_, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*;\n     xs ! s_ \\<noteq> ys ! s_; s_ < length xs;\n     xs = take (length xs) ys\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis nth_take)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>length xs \\<le> length ys;\n        s \\<le> length xs \\<and> take s xs = take s ys;\n        \\<not> s < length xs;\n        (s, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> True = (xs = take (length xs) ys)\n 2. \\<not> length xs \\<le> length ys \\<Longrightarrow>\n    False = (xs = take (length xs) ys)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length xs \\<le> length ys;\n     s_ \\<le> length xs \\<and> take s_ xs = take s_ ys;\n     \\<not> s_ < length xs;\n     (s_, 0) \\<in> (measure ((-) (length xs)))\\<^sup>*\\<rbrakk>\n    \\<Longrightarrow> True = (xs = take (length xs) ys)", "by force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> length ys \\<Longrightarrow>\n    False = (xs = take (length xs) ys)", "apply auto []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "synth_definition is_prefix_bd is [enres_unfolds]: \"is_prefix xs ys = \\<hole>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_prefix xs ys = ?HOLE", "apply (rule CNV_eqD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV (is_prefix xs ys) ?HOLE", "unfolding is_prefix_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV (CATCH\n          (ebind (CHECK (length xs \\<le> length ys) False)\n            (\\<lambda>_.\n                ebind\n                 (EWHILEIT\n                   (\\<lambda>i.\n                       i \\<le> length xs \\<and> take i xs = take i ys)\n                   (\\<lambda>i. i < length xs)\n                   (\\<lambda>i.\n                       ebind (EASSERT (i < length xs \\<and> i < length ys))\n                        (\\<lambda>_.\n                            ebind (CHECK (xs ! i = ys ! i) False)\n                             (\\<lambda>_. ERETURN (i + 1))))\n                   0)\n                 (\\<lambda>_. THROW True)))\n          ERETURN)\n     ?HOLE", "apply opt_enres_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. CNV ((if length xs \\<le> length ys\n          then WHILE\\<^sub>T\\<^bsup>case_sum (\\<lambda>x. True)\n                                     (\\<lambda>s.\n   s \\<le> length xs \\<and> take s xs = take s ys)\\<^esup>\n                (case_sum (\\<lambda>x. False) (\\<lambda>s. s < length xs))\n                (\\<lambda>s.\n                    ASSERT (\\<not> isl s) \\<bind>\n                    (\\<lambda>_.\n                        let s = projr s\n                        in ASSERT\n                            (s < length xs \\<and> s < length ys) \\<bind>\n                           (\\<lambda>_.\n                               if xs ! s = ys ! s then RETURN (Inr (s + 1))\n                               else RETURN (Inl False))))\n                (Inr 0) \\<bind>\n               case_sum (\\<lambda>e. RETURN (Inl e))\n                (\\<lambda>x. RETURN (Inl True))\n          else RETURN (Inl False)) \\<bind>\n         (\\<lambda>r.\n             case r of Inl e \\<Rightarrow> RETURN (Inr e)\n             | Inr r \\<Rightarrow> RETURN (Inr r)))\n     ?HOLE", "apply (rule CNV_I)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_definition is_prefix_impl is \"uncurry is_prefix_bd\" \n    :: \"(array_assn int_assn)\\<^sup>k *\\<^sub>a (array_assn int_assn)\\<^sup>k \\<rightarrow>\\<^sub>a (unit_assn +\\<^sub>a bool_assn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry is_prefix_bd)\n    \\<in> (array_assn int_assn)\\<^sup>k *\\<^sub>a\n          (array_assn\n            int_assn)\\<^sup>k \\<rightarrow>\\<^sub>a unit_assn +\\<^sub>a\n              bool_assn", "unfolding is_prefix_bd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>xs ys.\n          (if length xs \\<le> length ys\n           then WHILE\\<^sub>T\\<^bsup>case_sum (\\<lambda>x. True)\n(\\<lambda>s. s \\<le> length xs \\<and> take s xs = take s ys)\\<^esup>\n                 (case_sum (\\<lambda>x. False) (\\<lambda>s. s < length xs))\n                 (\\<lambda>s.\n                     ASSERT (\\<not> isl s) \\<bind>\n                     (\\<lambda>_.\n                         let s = projr s\n                         in ASSERT\n                             (s < length xs \\<and> s < length ys) \\<bind>\n                            (\\<lambda>_.\n                                if xs ! s = ys ! s then RETURN (Inr (s + 1))\n                                else RETURN (Inl False))))\n                 (Inr 0) \\<bind>\n                case_sum (\\<lambda>e. RETURN (Inl e))\n                 (\\<lambda>x. RETURN (Inl True))\n           else RETURN (Inl False)) \\<bind>\n          (\\<lambda>r.\n              case r of Inl e \\<Rightarrow> RETURN (Inr e)\n              | Inr r \\<Rightarrow> RETURN (Inr r))))\n    \\<in> (array_assn int_assn)\\<^sup>k *\\<^sub>a\n          (array_assn\n            int_assn)\\<^sup>k \\<rightarrow>\\<^sub>a unit_assn +\\<^sub>a\n              bool_assn", "by sepref"], ["", "export_code is_prefix_impl checking SML_imp"], ["", "section \\<open>Copy Array (Arrays, For i=l..u)\\<close>"], ["", "definition \"cp_array xs \\<equiv> doN {\n    let ys = op_array_replicate (length xs) 0;   \\<comment> \\<open>Use proper constructors\\<close>\n    \n    ys \\<leftarrow> nfoldli [0..<length xs] (\\<lambda>_. True) (\\<lambda>i ys. doN {  \\<comment> \\<open>Ensure linearity! \\<open>ys\\<leftarrow>\\<dots>\\<close>\\<close>\n      ASSERT (i<length xs \\<and> i<length ys); \n      RETURN (ys[i:=xs!i]) \n    }) ys;\n    \n    RETURN ys\n  }\""], ["", "lemma \"cp_array xs \\<le> SPEC (\\<lambda>ys. ys=xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cp_array xs \\<le> SPEC (\\<lambda>ys. ys = xs)", "unfolding cp_array_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let ys = op_array_replicate (length xs) (0::'a)\n     in nfoldli [0..<length xs] (\\<lambda>_. True)\n         (\\<lambda>i ys.\n             ASSERT (i < length xs \\<and> i < length ys) \\<bind>\n             (\\<lambda>_. RETURN (ys[i := xs ! i])))\n         ys \\<bind>\n        RETURN)\n    \\<le> SPEC (\\<lambda>ys. ys = xs)", "supply nfoldli_rule nfoldli_rule[where I=\"\\<lambda>l1 l2 ys. length ys = length xs \\<and> (\\<forall>i\\<in>set l1. ys!i = xs!i)\", refine_vcg]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let ys = op_array_replicate (length xs) (0::'a)\n     in nfoldli [0..<length xs] (\\<lambda>_. True)\n         (\\<lambda>i ys.\n             ASSERT (i < length xs \\<and> i < length ys) \\<bind>\n             (\\<lambda>_. RETURN (ys[i := xs ! i])))\n         ys \\<bind>\n        RETURN)\n    \\<le> SPEC (\\<lambda>ys. ys = xs)", "apply refine_vcg"], ["proof (prove)\ngoal (8 subgoals):\n 1. length (op_array_replicate (length xs) (0::'a)) = length xs\n 2. \\<forall>i\\<in>set [].\n       op_array_replicate (length xs) (0::'a) ! i = xs ! i\n 3. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>[0..<length xs] = l1 @ x # l2;\n        length \\<sigma> = length xs \\<and>\n        (\\<forall>i\\<in>set l1. \\<sigma> ! i = xs ! i);\n        True\\<rbrakk>\n       \\<Longrightarrow> x < length xs\n 4. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>[0..<length xs] = l1 @ x # l2;\n        length \\<sigma> = length xs \\<and>\n        (\\<forall>i\\<in>set l1. \\<sigma> ! i = xs ! i);\n        True\\<rbrakk>\n       \\<Longrightarrow> x < length \\<sigma>\n 5. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>[0..<length xs] = l1 @ x # l2;\n        length \\<sigma> = length xs \\<and>\n        (\\<forall>i\\<in>set l1. \\<sigma> ! i = xs ! i);\n        True; x < length xs \\<and> x < length \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> length (\\<sigma>[x := xs ! x]) = length xs\n 6. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>[0..<length xs] = l1 @ x # l2;\n        length \\<sigma> = length xs \\<and>\n        (\\<forall>i\\<in>set l1. \\<sigma> ! i = xs ! i);\n        True; x < length xs \\<and> x < length \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<in>set (l1 @ [x]).\n                            \\<sigma>[x := xs ! x] ! i = xs ! i\n 7. \\<And>l1 l2 \\<sigma>.\n       \\<lbrakk>[0..<length xs] = l1 @ l2;\n        length \\<sigma> = length xs \\<and>\n        (\\<forall>i\\<in>set l1. \\<sigma> ! i = xs ! i);\n        \\<not> True\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = xs\n 8. \\<And>\\<sigma>.\n       \\<lbrakk>length \\<sigma> = length xs \\<and>\n                (\\<forall>i\\<in>set [0..<length xs]. \\<sigma> ! i = xs ! i);\n        True\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = xs", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>[0..<length xs] = l1 @ x # l2; length \\<sigma> = length xs;\n        \\<forall>i\\<in>set l1. \\<sigma> ! i = xs ! i\\<rbrakk>\n       \\<Longrightarrow> x < length xs\n 2. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>[0..<length xs] = l1 @ x # l2; length \\<sigma> = length xs;\n        \\<forall>i\\<in>set l1. \\<sigma> ! i = xs ! i\\<rbrakk>\n       \\<Longrightarrow> x < length xs\n 3. \\<And>x l1 l2 \\<sigma> i.\n       \\<lbrakk>[0..<length xs] = l1 @ x # l2; x < length xs;\n        i \\<in> set l1; length \\<sigma> = length xs;\n        \\<forall>i\\<in>set l1. \\<sigma> ! i = xs ! i\\<rbrakk>\n       \\<Longrightarrow> \\<sigma>[x := xs ! x] ! i = xs ! i\n 4. \\<And>\\<sigma>.\n       \\<lbrakk>length \\<sigma> = length xs;\n        \\<forall>i\\<in>{0..<length xs}. \\<sigma> ! i = xs ! i\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = xs", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>[0..<length xs] = l1_ @ x_ # l2_; length \\<sigma>_ = length xs;\n     \\<forall>i\\<in>set l1_. \\<sigma>_ ! i = xs ! i\\<rbrakk>\n    \\<Longrightarrow> x_ < length xs", "using upt_eq_lel_conv"], ["proof (prove)\nusing this:\n  ([?l..<?h] = ?is1.0 @ ?i # ?is2.0) =\n  (?is1.0 = [?l..<?i] \\<and>\n   ?is2.0 = [Suc ?i..<?h] \\<and> ?l \\<le> ?i \\<and> ?i < ?h)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>[0..<length xs] = l1_ @ x_ # l2_; length \\<sigma>_ = length xs;\n     \\<forall>i\\<in>set l1_. \\<sigma>_ ! i = xs ! i\\<rbrakk>\n    \\<Longrightarrow> x_ < length xs", "by blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>[0..<length xs] = l1 @ x # l2; length \\<sigma> = length xs;\n        \\<forall>i\\<in>set l1. \\<sigma> ! i = xs ! i\\<rbrakk>\n       \\<Longrightarrow> x < length xs\n 2. \\<And>x l1 l2 \\<sigma> i.\n       \\<lbrakk>[0..<length xs] = l1 @ x # l2; x < length xs;\n        i \\<in> set l1; length \\<sigma> = length xs;\n        \\<forall>i\\<in>set l1. \\<sigma> ! i = xs ! i\\<rbrakk>\n       \\<Longrightarrow> \\<sigma>[x := xs ! x] ! i = xs ! i\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>length \\<sigma> = length xs;\n        \\<forall>i\\<in>{0..<length xs}. \\<sigma> ! i = xs ! i\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = xs", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>[0..<length xs] = l1_ @ x_ # l2_; length \\<sigma>_ = length xs;\n     \\<forall>i\\<in>set l1_. \\<sigma>_ ! i = xs ! i\\<rbrakk>\n    \\<Longrightarrow> x_ < length xs", "using upt_eq_lel_conv"], ["proof (prove)\nusing this:\n  ([?l..<?h] = ?is1.0 @ ?i # ?is2.0) =\n  (?is1.0 = [?l..<?i] \\<and>\n   ?is2.0 = [Suc ?i..<?h] \\<and> ?l \\<le> ?i \\<and> ?i < ?h)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>[0..<length xs] = l1_ @ x_ # l2_; length \\<sigma>_ = length xs;\n     \\<forall>i\\<in>set l1_. \\<sigma>_ ! i = xs ! i\\<rbrakk>\n    \\<Longrightarrow> x_ < length xs", "by blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x l1 l2 \\<sigma> i.\n       \\<lbrakk>[0..<length xs] = l1 @ x # l2; x < length xs;\n        i \\<in> set l1; length \\<sigma> = length xs;\n        \\<forall>i\\<in>set l1. \\<sigma> ! i = xs ! i\\<rbrakk>\n       \\<Longrightarrow> \\<sigma>[x := xs ! x] ! i = xs ! i\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>length \\<sigma> = length xs;\n        \\<forall>i\\<in>{0..<length xs}. \\<sigma> ! i = xs ! i\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = xs", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>[0..<length xs] = l1_ @ x_ # l2_; x_ < length xs;\n     i_ \\<in> set l1_; length \\<sigma>_ = length xs;\n     \\<forall>i\\<in>set l1_. \\<sigma>_ ! i = xs ! i\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>_[x_ := xs ! x_] ! i_ = xs ! i_", "by (simp add: nth_list_update)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>length \\<sigma> = length xs;\n        \\<forall>i\\<in>{0..<length xs}. \\<sigma> ! i = xs ! i\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = xs", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length \\<sigma>_ = length xs;\n     \\<forall>i\\<in>{0..<length xs}. \\<sigma>_ ! i = xs ! i\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>_ = xs", "by (simp add: nth_equalityI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "term arl_assn"], ["", "subsection \\<open>Proof with \\<open>nfoldli_upt_rule\\<close>\\<close>"], ["", "lemma \"cp_array xs \\<le> SPEC (\\<lambda>ys. ys=xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cp_array xs \\<le> SPEC (\\<lambda>ys. ys = xs)", "unfolding cp_array_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let ys = op_array_replicate (length xs) (0::'a)\n     in nfoldli [0..<length xs] (\\<lambda>_. True)\n         (\\<lambda>i ys.\n             ASSERT (i < length xs \\<and> i < length ys) \\<bind>\n             (\\<lambda>_. RETURN (ys[i := xs ! i])))\n         ys \\<bind>\n        RETURN)\n    \\<le> SPEC (\\<lambda>ys. ys = xs)", "supply nfoldli_upt_rule nfoldli_upt_rule[where I=\"\\<lambda>i ys. length ys = length xs \\<and> (\\<forall>j<i. ys!j = xs!j)\", refine_vcg]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let ys = op_array_replicate (length xs) (0::'a)\n     in nfoldli [0..<length xs] (\\<lambda>_. True)\n         (\\<lambda>i ys.\n             ASSERT (i < length xs \\<and> i < length ys) \\<bind>\n             (\\<lambda>_. RETURN (ys[i := xs ! i])))\n         ys \\<bind>\n        RETURN)\n    \\<le> SPEC (\\<lambda>ys. ys = xs)", "apply refine_vcg"], ["proof (prove)\ngoal (8 subgoals):\n 1. 0 \\<le> length xs\n 2. length (op_array_replicate (length xs) (0::'a)) = length xs\n 3. \\<And>j.\n       j < 0 \\<Longrightarrow>\n       op_array_replicate (length xs) (0::'a) ! j = xs ! j\n 4. \\<And>i \\<sigma>.\n       \\<lbrakk>0 \\<le> i; i < length xs;\n        length \\<sigma> = length xs \\<and>\n        (\\<forall>j<i. \\<sigma> ! j = xs ! j);\n        True\\<rbrakk>\n       \\<Longrightarrow> i < length \\<sigma>\n 5. \\<And>i \\<sigma>.\n       \\<lbrakk>0 \\<le> i; i < length xs;\n        length \\<sigma> = length xs \\<and>\n        (\\<forall>j<i. \\<sigma> ! j = xs ! j);\n        True; i < length xs \\<and> i < length \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> length (\\<sigma>[i := xs ! i]) = length xs\n 6. \\<And>i \\<sigma> j.\n       \\<lbrakk>0 \\<le> i; i < length xs;\n        length \\<sigma> = length xs \\<and>\n        (\\<forall>j<i. \\<sigma> ! j = xs ! j);\n        True; i < length xs \\<and> i < length \\<sigma>; j < i + 1\\<rbrakk>\n       \\<Longrightarrow> \\<sigma>[i := xs ! i] ! j = xs ! j\n 7. \\<And>i \\<sigma>.\n       \\<lbrakk>0 \\<le> i; i \\<le> length xs;\n        length \\<sigma> = length xs \\<and>\n        (\\<forall>j<i. \\<sigma> ! j = xs ! j);\n        \\<not> True\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = xs\n 8. \\<And>\\<sigma>.\n       \\<lbrakk>length \\<sigma> = length xs \\<and>\n                (\\<forall>j<length xs. \\<sigma> ! j = xs ! j);\n        True\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = xs", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i \\<sigma> j.\n       \\<lbrakk>i < length xs; j < Suc i; length \\<sigma> = length xs;\n        \\<forall>j<i. \\<sigma> ! j = xs ! j\\<rbrakk>\n       \\<Longrightarrow> \\<sigma>[i := xs ! i] ! j = xs ! j\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>length \\<sigma> = length xs;\n        \\<forall>j<length xs. \\<sigma> ! j = xs ! j\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = xs", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i_ < length xs; j_ < Suc i_; length \\<sigma>_ = length xs;\n     \\<forall>j<i_. \\<sigma>_ ! j = xs ! j\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>_[i_ := xs ! i_] ! j_ = xs ! j_", "using less_Suc_eq"], ["proof (prove)\nusing this:\n  (?m < Suc ?n) = (?m < ?n \\<or> ?m = ?n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i_ < length xs; j_ < Suc i_; length \\<sigma>_ = length xs;\n     \\<forall>j<i_. \\<sigma>_ ! j = xs ! j\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>_[i_ := xs ! i_] ! j_ = xs ! j_", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>length \\<sigma> = length xs;\n        \\<forall>j<length xs. \\<sigma> ! j = xs ! j\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = xs", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length \\<sigma>_ = length xs;\n     \\<forall>j<length xs. \\<sigma>_ ! j = xs ! j\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>_ = xs", "by (simp add: nth_equalityI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sepref_definition cp_array_impl is cp_array :: \"(array_assn nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a array_assn nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, cp_array)\n    \\<in> (array_assn\n            nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a array_assn nat_assn", "unfolding cp_array_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>xs.\n        let ys = op_array_replicate (length xs) 0\n        in nfoldli [0..<length xs] (\\<lambda>_. True)\n            (\\<lambda>i ys.\n                ASSERT (i < length xs \\<and> i < length ys) \\<bind>\n                (\\<lambda>_. RETURN (ys[i := xs ! i])))\n            ys \\<bind>\n           RETURN)\n    \\<in> (array_assn\n            nat_assn)\\<^sup>k \\<rightarrow>\\<^sub>a array_assn nat_assn", "by sepref"], ["", "end"]]}