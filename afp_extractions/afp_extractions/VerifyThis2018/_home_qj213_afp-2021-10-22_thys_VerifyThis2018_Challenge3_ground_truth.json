{"file_name": "/home/qj213/afp-2021-10-22/thys/VerifyThis2018/Challenge3.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/VerifyThis2018", "problem_names": ["lemma N_gt0[simp, intro!]: \"0<N\"", "lemma never_blocked: \"A.can_step l s \\<longleftrightarrow> l<N\"", "lemma has_ticket_simps[simp]: \n    \"\\<not>has_ticket INIT k\"\n    \"has_ticket (WAIT k) k'\\<longleftrightarrow> k'=k\"\n    \"has_ticket (HOLD k) k'\\<longleftrightarrow> k'=k\"\n    \"has_ticket (REL k) k'\\<longleftrightarrow> k'=k\"", "lemma locks_ticket_simps[simp]: \n    \"\\<not>locks_ticket INIT k\"\n    \"\\<not>locks_ticket (WAIT k) k'\"\n    \"locks_ticket (HOLD k) k'\\<longleftrightarrow> k'=k\"\n    \"locks_ticket (REL k) k'\\<longleftrightarrow> k'=k\"", "lemma holds_imp_uses: \"locks_ticket s k \\<Longrightarrow> has_ticket s k\"", "lemma is_invar1: \"A.is_invar invar1\"", "theorem mutual_exclusion: \"\\<lbrakk>A.reachable s; \n      t<N; t'<N; t\\<noteq>t'; is_HOLD (tts s t); is_HOLD (tts s t')\n    \\<rbrakk> \\<Longrightarrow> False\"", "lemma mutual_exclusion': \"\\<lbrakk>A.reachable s; \n      t<N; t'<N; t\\<noteq>t'; \n      locks_ticket (tts s t) tk; locks_ticket (tts s t') tk'\n    \\<rbrakk> \\<Longrightarrow> False\"", "lemma fair_aux:  \n    assumes R: \"A.is_run s\"\n    assumes A: \"i<j\" \"cc (s i) \\<le> k\" \"k < cc (s j)\" \"t<N\" \"tts (s i) t=WAIT k\"\n    shows \"\\<exists>l. i\\<le>l \\<and> l<j \\<and> tts (s l) t = HOLD k\"", "lemma s_case_expand: \n    \"(case s of (c, n, ts) \\<Rightarrow> P c n ts) = P (cc s) (nn s) (tts s)\"", "lemma fair_aux2:\n    assumes RUN: \"A.is_run s\"\n    assumes ACQ: \"t<N\" \"tts (s i) t=INIT\" \"tts (s (Suc i)) t=WAIT k\" \n    assumes HOLD: \"i<j\" \"tts (s j) t = HOLD k\" \n    assumes WAIT: \"t'<N\" \"tts (s i) t' = WAIT k'\" \n    obtains l where \"i<l\" \"l<j\" \"tts (s l) t' = HOLD k'\"", "lemma find_hold_position:\n    assumes RUN: \"A.is_run s\"\n    assumes WAIT: \"t<N\" \"tts (s i) t = WAIT tk\"\n    assumes NWAIT: \"i<j\" \"tts (s j) t \\<noteq> WAIT tk\"\n    obtains l where \"i<l\" \"l\\<le>j\" \"tts (s l) t = HOLD tk\"", "theorem fair:\n    assumes RUN: \"A.is_run s\"\n    assumes ACQ: \"t<N\" \"tts (s i) t=INIT\" \"is_WAIT (tts (s (Suc i)) t)\" \n      \\<comment> \\<open>Thread \\<open>t\\<close> calls \\<open>acquire\\<close> in step \\<open>i\\<close>\\<close>\n    assumes HOLD: \"i<j\" \"is_HOLD (tts (s j) t)\" \n      \\<comment> \\<open>Thread \\<open>t\\<close> holds lock in step \\<open>j\\<close>\\<close>\n    assumes WAIT: \"t'<N\" \"is_WAIT (tts (s i) t')\" \n      \\<comment> \\<open>Thread \\<open>t'\\<close> waits for lock at step \\<open>i\\<close>\\<close>\n    obtains l where \"i<l\" \"l<j\" \"is_HOLD (tts (s l) t')\" \n      \\<comment> \\<open>Then, \\<open>t'\\<close> gets lock earlier\\<close>", "lemma is_invar2: \"A.is_invar invar2\"", "lemma has_ticket_unique: \"\\<lbrakk>A.reachable (c,n,ts); \n      t<N; has_ticket (ts t) k; t'<N; has_ticket (ts t') k\n    \\<rbrakk> \\<Longrightarrow> t'=t\"", "lemma tkt_thread_eq: \n    assumes R: \"A.reachable (c,n,ts)\"  \n    assumes A: \"t<N\" \"has_ticket (ts t) k\"\n    shows \"tkt_thread ts k = t\"", "lemma holds_only_current:\n    assumes R: \"A.reachable (c,n,ts)\"  \n    assumes A: \"t<N\" \"locks_ticket (ts t) k\"\n    shows \"k=c\"", "theorem progress:\n    assumes FRUN: \"A.is_fair_run s\"\n    assumes A: \"t<N\" \"is_WAIT (tts (s i) t)\"\n    shows \"\\<exists>j>i. is_HOLD (tts (s j) t)\"", "lemma k_gt0[simp]: \"0<k\"", "lemma b_never_blocked: \"B.can_step l s \\<longleftrightarrow> l<N\"", "lemma nat_sum_gtZ_iff[simp]: \n    \"finite s \\<Longrightarrow> sum f s \\<noteq> (0::nat) \\<longleftrightarrow> (\\<exists>x\\<in>s. f x \\<noteq> 0)\"", "lemma n_eq_Suc_sub1_conv[simp]: \"n = Suc (n - Suc 0) \\<longleftrightarrow> n\\<noteq>0\"", "lemma mod_mult_mod_eq[mod_simps]: \"x mod (k * N) mod N = x mod N\"", "lemma mod_eq_imp_eq_aux: \"b mod N = (a::nat) mod N \\<Longrightarrow> a\\<le>b \\<Longrightarrow> b<a+N \\<Longrightarrow> b=a\"", "lemma mod_eq_imp_eq: \n    \"\\<lbrakk>b \\<le> x; x < b + N; b \\<le> y; y < b + N; x mod N = y mod N \\<rbrakk> \\<Longrightarrow> x=y\"", "lemma map_ticket_addsimps[simp]:\n    \"map_ticket f t = INIT \\<longleftrightarrow> t=INIT\"  \n    \"map_ticket f t = WAIT tk \\<longleftrightarrow> (\\<exists>tk'. tk=f tk' \\<and> t=WAIT tk')\"\n    \"map_ticket f t = HOLD tk \\<longleftrightarrow> (\\<exists>tk'. tk=f tk' \\<and> t=HOLD tk')\"\n    \"map_ticket f t = REL tk \\<longleftrightarrow> (\\<exists>tk'. tk=f tk' \\<and> t=REL tk')\"", "lemma ni_weight_le1[simp]: \"ni_weight s \\<le> Suc 0\"", "lemma num_ni_init[simp]: \"num_ni (\\<lambda>_. INIT) = 0\"", "lemma num_ni_upd: \n    \"t<N \\<Longrightarrow> num_ni (ts(t:=s)) = num_ni ts - ni_weight (ts t) + ni_weight s\"", "lemma num_ni_nz_if[simp]: \"\\<lbrakk>t < N; ts t \\<noteq> INIT\\<rbrakk> \\<Longrightarrow> num_ni ts \\<noteq> 0\"", "lemma num_ni_leN: \"num_ni ts \\<le> N\"", "lemma is_invar3: \"A.is_invar invar3\"", "lemma sraux: \n    \"sim_rel1 (c,n,ts) (ci,ni,tsi) \\<Longrightarrow> ci = c mod N \\<and> ni = n mod (k*N)\"", "lemma sraux2: \"\\<lbrakk>sim_rel1 (c,n,ts) (ci,ni,tsi); t<N\\<rbrakk> \n    \\<Longrightarrow> tsi t = map_ticket (\\<lambda>x. x mod N) (ts t)\"", "lemma xfer_locks_ticket:\n    assumes \"locks_ticket (map_ticket (\\<lambda>t. t mod N) (ts t)) tki\"  \n    obtains tk where \"tki=tk mod N\" \"locks_ticket (ts t) tk\"", "lemma b_holds_only_current: \n    \"\\<lbrakk>B.reachable (c, n, ts); t < N; locks_ticket (ts t) tk\\<rbrakk> \\<Longrightarrow> tk = c\"", "lemma b_mutual_exclusion': \"\\<lbrakk>B.reachable s; \n      t<N; t'<N; t\\<noteq>t'; locks_ticket (tts s t) tk; locks_ticket (tts s t') tk'\n    \\<rbrakk> \\<Longrightarrow> False\"", "lemma xfer_has_ticket:\n    assumes \"has_ticket (map_ticket (\\<lambda>t. t mod N) (ts t)) tki\"  \n    obtains tk where \"tki=tk mod N\" \"has_ticket (ts t) tk\"", "lemma has_ticket_in_range:\n    assumes Ra: \"A.reachable (c,n,ts)\" and \"t<N\" and U: \"has_ticket (ts t) tk\" \n    shows \"c\\<le>tk \\<and> tk<c+N\"", "lemma b_has_ticket_unique: \"\\<lbrakk>B.reachable (ci,ni,tsi); \n      t<N; has_ticket (tsi t) tki; t'<N; has_ticket (tsi t') tki\n    \\<rbrakk> \\<Longrightarrow> t'=t\"", "lemma c_never_blocked: \"C.can_step l s \\<longleftrightarrow> l<N\"", "lemma is_invar4: \"B.is_invar invar4\"", "lemma is_REL_state_simps[simp]:\n    \"t<N \\<Longrightarrow> is_REL_state (ts(t:=REL tk))\"\n    \"t<N \\<Longrightarrow> \\<not>is_REL (ts t) \\<Longrightarrow> \\<not>is_REL s' \n      \\<Longrightarrow> is_REL_state (ts(t:=s')) \\<longleftrightarrow> is_REL_state ts\"", "lemma is_REL_state_aux1:  \n    assumes R: \"B.reachable (c,n,ts)\"\n    assumes REL: \"is_REL_state ts\"\n    assumes \"t<N\" and [simp]: \"ts t = WAIT tk\"\n    shows \"tk\\<noteq>c\"", "lemma is_REL_state_aux2:\n    assumes R: \"B.reachable (c,n,ts)\"\n    assumes A: \"t<N\" \"ts t = REL tk\"\n    shows \"\\<not>is_REL_state (ts(t:=INIT))\"", "lemma xfer_holds:\n    assumes \"sim_rel s cs\"\n    shows \"is_HOLD (tts cs t) \\<longleftrightarrow> is_HOLD (tts s t)\"", "lemma xfer_waits:\n    assumes \"sim_rel s cs\"\n    shows \"is_WAIT (tts cs t) \\<longleftrightarrow> is_WAIT (tts s t)\"", "lemma xfer_init:\n    assumes \"sim_rel s cs\"  \n    shows \"tts cs t = INIT \\<longleftrightarrow> tts s t = INIT\"", "theorem final_mutual_exclusion: \"\\<lbrakk>C.reachable s; \n      t<N; t'<N; t\\<noteq>t'; is_HOLD (tts s t); is_HOLD (tts s t')\n    \\<rbrakk> \\<Longrightarrow> False\"", "theorem final_fair:\n    assumes RUN: \"C.is_run s\"\n    assumes ACQ: \"t<N\" and \"tts (s i) t=INIT\" and \"is_WAIT (tts (s (Suc i)) t)\" \n      \\<comment> \\<open>Thread \\<open>t\\<close> draws ticket in step \\<open>i\\<close>\\<close>\n    assumes HOLD: \"i<j\" and \"is_HOLD (tts (s j) t)\" \n      \\<comment> \\<open>Thread \\<open>t\\<close> holds lock in step \\<open>j\\<close>\\<close>\n    assumes WAIT: \"t'<N\" and \"is_WAIT (tts (s i) t')\" \n      \\<comment> \\<open>Thread \\<open>t'\\<close> waits for lock at step \\<open>i\\<close>\\<close>\n    obtains l where \"i<l\" and \"l<j\" and \"is_HOLD (tts (s l) t')\" \n      \\<comment> \\<open>Then, \\<open>t'\\<close> gets lock earlier\\<close>", "theorem final_progress:\n    assumes FRUN: \"C.is_fair_run s\"\n    assumes WAIT: \"t<N\" and \"is_WAIT (tts (s i) t)\"\n    shows \"\\<exists>j>i. is_HOLD (tts (s j) t)\""], "translations": [["", "lemma N_gt0[simp, intro!]: \"0<N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < N", "by (cases N) auto"], ["", "text \\<open>A thread's state, representing the sequence points in the given algorithm.\n    This will not change over the refinements.\\<close>"], ["", "datatype thread = \n    INIT \n  | is_WAIT: WAIT (ticket: nat) \n  | is_HOLD: HOLD (ticket: nat) \n  | is_REL: REL (ticket: nat)"], ["", "subsection \\<open>Refinement 1: Ticket Lock with Unbounded Counters\\<close>"], ["", "text \\<open>System's state: Current ticket, next ticket, thread states\\<close>"], ["", "type_synonym astate = \"nat \\<times> nat \\<times> (nat \\<Rightarrow> thread)\""], ["", "abbreviation \"cc \\<equiv> fst\""], ["", "abbreviation \"nn s \\<equiv> fst (snd s)\""], ["", "abbreviation \"tts s \\<equiv> snd (snd s)\""], ["", "text \\<open>The step relation of a single thread\\<close>"], ["", "inductive astep_sng where\n    enter_wait: \"astep_sng (c,n,INIT) (c,(n+1),WAIT n)\"\n  | loop_wait: \"c\\<noteq>k \\<Longrightarrow> astep_sng (c,n,WAIT k) (c,n,WAIT k)\"\n  | exit_wait: \"astep_sng (c,n,WAIT c) (c,n,HOLD c)\"\n  | start_release: \"astep_sng (c,n,HOLD k) (c,n,REL k)\"\n  | release: \"astep_sng (c,n,REL k) (k+1,n,INIT)\""], ["", "text \\<open>The step relation of the system\\<close>"], ["", "inductive alstep for t where\n    \"\\<lbrakk> t<N; astep_sng (c,n,ts t) (c',n',s') \\<rbrakk> \n      \\<Longrightarrow> alstep t (c,n,ts) (c',n',ts(t:=s'))\""], ["", "text \\<open>Initial state of the system\\<close>"], ["", "definition \"as\\<^sub>0 \\<equiv> (0, 0, \\<lambda>_. INIT)\""], ["", "interpretation A: system as\\<^sub>0 alstep"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text \\<open>In our system, each thread can always perform a step\\<close>"], ["", "lemma never_blocked: \"A.can_step l s \\<longleftrightarrow> l<N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A.can_step l s = (l < N)", "apply (cases s; cases \"tts s l\"; simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>s = (a, b, c); c l = INIT\\<rbrakk>\n       \\<Longrightarrow> A.can_step l (a, b, c) = (l < N)\n 2. \\<And>a b c x2.\n       \\<lbrakk>s = (a, b, c); c l = WAIT x2\\<rbrakk>\n       \\<Longrightarrow> A.can_step l (a, b, c) = (l < N)\n 3. \\<And>a b c x3.\n       \\<lbrakk>s = (a, b, c); c l = HOLD x3\\<rbrakk>\n       \\<Longrightarrow> A.can_step l (a, b, c) = (l < N)\n 4. \\<And>a b c x4.\n       \\<lbrakk>s = (a, b, c); c l = REL x4\\<rbrakk>\n       \\<Longrightarrow> A.can_step l (a, b, c) = (l < N)", "unfolding A.can_step_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>s = (a, b, c); c l = INIT\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s'. alstep l (a, b, c) s') = (l < N)\n 2. \\<And>a b c x2.\n       \\<lbrakk>s = (a, b, c); c l = WAIT x2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s'. alstep l (a, b, c) s') = (l < N)\n 3. \\<And>a b c x3.\n       \\<lbrakk>s = (a, b, c); c l = HOLD x3\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s'. alstep l (a, b, c) s') = (l < N)\n 4. \\<And>a b c x4.\n       \\<lbrakk>s = (a, b, c); c l = REL x4\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s'. alstep l (a, b, c) s') = (l < N)", "apply (clarsimp simp: alstep.simps astep_sng.simps; blast)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Thus, our system is in particular deadlock free\\<close>"], ["", "interpretation A: df_system as\\<^sub>0 alstep"], ["proof (prove)\ngoal (1 subgoal):\n 1. df_system as\\<^sub>0 alstep", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. A.reachable s \\<Longrightarrow> \\<exists>s'. A.step s s'", "subgoal for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. A.reachable s \\<Longrightarrow> \\<exists>s'. A.step s s'", "using never_blocked[of 0 s]"], ["proof (prove)\nusing this:\n  A.can_step 0 s = (0 < N)\n\ngoal (1 subgoal):\n 1. A.reachable s \\<Longrightarrow> \\<exists>s'. A.step s s'", "unfolding A.can_step_def"], ["proof (prove)\nusing this:\n  (\\<exists>s'. alstep 0 s s') = (0 < N)\n\ngoal (1 subgoal):\n 1. A.reachable s \\<Longrightarrow> \\<exists>s'. A.step s s'", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Safety: Mutual Exclusion\\<close>"], ["", "text \\<open>Predicates to express that a thread uses or holds a ticket\\<close>"], ["", "definition \"has_ticket s k \\<equiv> s=WAIT k \\<or> s=HOLD k \\<or> s=REL k\""], ["", "lemma has_ticket_simps[simp]: \n    \"\\<not>has_ticket INIT k\"\n    \"has_ticket (WAIT k) k'\\<longleftrightarrow> k'=k\"\n    \"has_ticket (HOLD k) k'\\<longleftrightarrow> k'=k\"\n    \"has_ticket (REL k) k'\\<longleftrightarrow> k'=k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> has_ticket INIT k &&& has_ticket (WAIT k) k' = (k' = k)) &&&\n    has_ticket (HOLD k) k' = (k' = k) &&& has_ticket (REL k) k' = (k' = k)", "unfolding has_ticket_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> (INIT = WAIT k \\<or> INIT = HOLD k \\<or> INIT = REL k) &&&\n     (WAIT k = WAIT k' \\<or> WAIT k = HOLD k' \\<or> WAIT k = REL k') =\n     (k' = k)) &&&\n    (HOLD k = WAIT k' \\<or> HOLD k = HOLD k' \\<or> HOLD k = REL k') =\n    (k' = k) &&&\n    (REL k = WAIT k' \\<or> REL k = HOLD k' \\<or> REL k = REL k') = (k' = k)", "by auto"], ["", "definition \"locks_ticket s k \\<equiv> s=HOLD k \\<or> s=REL k\""], ["", "lemma locks_ticket_simps[simp]: \n    \"\\<not>locks_ticket INIT k\"\n    \"\\<not>locks_ticket (WAIT k) k'\"\n    \"locks_ticket (HOLD k) k'\\<longleftrightarrow> k'=k\"\n    \"locks_ticket (REL k) k'\\<longleftrightarrow> k'=k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> locks_ticket INIT k &&& \\<not> locks_ticket (WAIT k) k') &&&\n    locks_ticket (HOLD k) k' = (k' = k) &&&\n    locks_ticket (REL k) k' = (k' = k)", "unfolding locks_ticket_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> (INIT = HOLD k \\<or> INIT = REL k) &&&\n     \\<not> (WAIT k = HOLD k' \\<or> WAIT k = REL k')) &&&\n    (HOLD k = HOLD k' \\<or> HOLD k = REL k') = (k' = k) &&&\n    (REL k = HOLD k' \\<or> REL k = REL k') = (k' = k)", "by auto"], ["", "lemma holds_imp_uses: \"locks_ticket s k \\<Longrightarrow> has_ticket s k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. locks_ticket s k \\<Longrightarrow> has_ticket s k", "unfolding locks_ticket_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s = HOLD k \\<or> s = REL k \\<Longrightarrow> has_ticket s k", "by auto"], ["", "text \\<open>We show the following invariant.\n    Intuitively, it can be read as follows:\n      \\<^item> Current lock is less than or equal next lock\n      \\<^item> For all threads that use a ticket (i.e., are waiting, holding, or releasing):\n        \\<^item> The ticket is in between current and next\n        \\<^item> No other thread has the same ticket\n        \\<^item> Only the current ticket can be held (or released)\n  \\<close>"], ["", "definition \"invar1 \\<equiv> \\<lambda>(c,n,ts).\n    c \\<le> n\n  \\<and> (\\<forall>t k. t<N \\<and> has_ticket (ts t) k \\<longrightarrow> \n      c \\<le> k \\<and> k < n\n    \\<and> (\\<forall>t' k'. t'<N \\<and> has_ticket (ts t') k' \\<and> t\\<noteq>t' \\<longrightarrow> k\\<noteq>k')  \n    \\<and> (\\<forall>k. k\\<noteq>c \\<longrightarrow> \\<not>locks_ticket (ts t) k)\n    )\n  \""], ["", "lemma is_invar1: \"A.is_invar invar1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A.is_invar invar1", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. invar1 as\\<^sub>0\n 2. \\<And>s s'.\n       \\<lbrakk>A.reachable s; invar1 s; A.step s s'\\<rbrakk>\n       \\<Longrightarrow> invar1 s'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar1 as\\<^sub>0", "by (auto simp: invar1_def as\\<^sub>0_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>A.reachable s; invar1 s; A.step s s'\\<rbrakk>\n       \\<Longrightarrow> invar1 s'", "subgoal for s s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A.reachable s; invar1 s; A.step s s'\\<rbrakk>\n    \\<Longrightarrow> invar1 s'", "apply (clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>A.reachable s; invar1 s; alstep l s s'\\<rbrakk>\n       \\<Longrightarrow> invar1 s'", "apply (erule alstep.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l c n ts c' n' s'a.\n       \\<lbrakk>A.reachable s; invar1 s; s = (c, n, ts);\n        s' = (c', n', ts(l := s'a)); l < N;\n        astep_sng (c, n, ts l) (c', n', s'a)\\<rbrakk>\n       \\<Longrightarrow> invar1 s'", "apply (erule astep_sng.cases)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>l c n ts c' n' s'a ca na.\n       \\<lbrakk>A.reachable s; invar1 s; s = (c, n, ts);\n        s' = (c', n', ts(l := s'a)); l < N; (c, n, ts l) = (ca, na, INIT);\n        (c', n', s'a) = (ca, na + 1, WAIT na)\\<rbrakk>\n       \\<Longrightarrow> invar1 s'\n 2. \\<And>l c n ts c' n' s'a ca k na.\n       \\<lbrakk>A.reachable s; invar1 s; s = (c, n, ts);\n        s' = (c', n', ts(l := s'a)); l < N; (c, n, ts l) = (ca, na, WAIT k);\n        (c', n', s'a) = (ca, na, WAIT k); ca \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> invar1 s'\n 3. \\<And>l c n ts c' n' s'a ca na.\n       \\<lbrakk>A.reachable s; invar1 s; s = (c, n, ts);\n        s' = (c', n', ts(l := s'a)); l < N;\n        (c, n, ts l) = (ca, na, WAIT ca);\n        (c', n', s'a) = (ca, na, HOLD ca)\\<rbrakk>\n       \\<Longrightarrow> invar1 s'\n 4. \\<And>l c n ts c' n' s'a ca na k.\n       \\<lbrakk>A.reachable s; invar1 s; s = (c, n, ts);\n        s' = (c', n', ts(l := s'a)); l < N; (c, n, ts l) = (ca, na, HOLD k);\n        (c', n', s'a) = (ca, na, REL k)\\<rbrakk>\n       \\<Longrightarrow> invar1 s'\n 5. \\<And>l c n ts c' n' s'a ca na k.\n       \\<lbrakk>A.reachable s; invar1 s; s = (c, n, ts);\n        s' = (c', n', ts(l := s'a)); l < N; (c, n, ts l) = (ca, na, REL k);\n        (c', n', s'a) = (k + 1, na, INIT)\\<rbrakk>\n       \\<Longrightarrow> invar1 s'", "apply (clarsimp_all simp: invar1_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>l c n ts t.\n       \\<lbrakk>A.reachable (c, n, ts); s = (c, n, ts);\n        s' = (c, Suc n, ts(l := WAIT n)); l < N; ts l = INIT; c \\<le> n;\n        \\<forall>t k.\n           t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n           c \\<le> k \\<and>\n           k < n \\<and>\n           (\\<forall>t' k'.\n               t' < N \\<and>\n               has_ticket (ts t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n               k \\<noteq> k') \\<and>\n           (\\<forall>k.\n               k \\<noteq> c \\<longrightarrow>\n               \\<not> locks_ticket (ts t) k)\\<rbrakk>\n       \\<Longrightarrow> (t = l \\<longrightarrow>\n                          (\\<forall>t'.\n                              t' \\<noteq> l \\<longrightarrow>\n                              (\\<forall>k'.\n                                  t' < N \\<and>\n                                  has_ticket (ts t') k' \\<longrightarrow>\n                                  n \\<noteq> k'))) \\<and>\n                         (t \\<noteq> l \\<longrightarrow>\n                          (\\<forall>k.\n                              t < N \\<and>\n                              has_ticket (ts t) k \\<longrightarrow>\n                              k < Suc n \\<and>\n                              k \\<noteq> n \\<and>\n                              (\\<forall>k.\n                                  k \\<noteq> c \\<longrightarrow>\n                                  \\<not> locks_ticket (ts t) k)))\n 2. \\<And>l c n ts k t.\n       \\<lbrakk>A.reachable (c, n, ts); s = (c, n, ts);\n        s' = (c, n, ts(l := WAIT k)); l < N; ts l = WAIT k; c \\<noteq> k;\n        c \\<le> n;\n        \\<forall>t k.\n           t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n           c \\<le> k \\<and>\n           k < n \\<and>\n           (\\<forall>t' k'.\n               t' < N \\<and>\n               has_ticket (ts t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n               k \\<noteq> k') \\<and>\n           (\\<forall>k.\n               k \\<noteq> c \\<longrightarrow>\n               \\<not> locks_ticket (ts t) k)\\<rbrakk>\n       \\<Longrightarrow> (t = l \\<longrightarrow>\n                          c \\<le> k \\<and>\n                          k < n \\<and>\n                          (\\<forall>t'.\n                              t' \\<noteq> l \\<longrightarrow>\n                              (\\<forall>k'.\n                                  t' < N \\<and>\n                                  has_ticket (ts t') k' \\<longrightarrow>\n                                  k \\<noteq> k'))) \\<and>\n                         (t \\<noteq> l \\<longrightarrow>\n                          (\\<forall>ka.\n                              t < N \\<and>\n                              has_ticket (ts t) ka \\<longrightarrow>\n                              ka \\<noteq> k \\<and>\n                              (\\<forall>k.\n                                  k \\<noteq> c \\<longrightarrow>\n                                  \\<not> locks_ticket (ts t) k)))\n 3. \\<And>l c n ts t.\n       \\<lbrakk>A.reachable (c, n, ts); s = (c, n, ts);\n        s' = (c, n, ts(l := HOLD c)); l < N; ts l = WAIT c; c \\<le> n;\n        \\<forall>t k.\n           t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n           c \\<le> k \\<and>\n           k < n \\<and>\n           (\\<forall>t' k'.\n               t' < N \\<and>\n               has_ticket (ts t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n               k \\<noteq> k') \\<and>\n           (\\<forall>k.\n               k \\<noteq> c \\<longrightarrow>\n               \\<not> locks_ticket (ts t) k)\\<rbrakk>\n       \\<Longrightarrow> (t = l \\<longrightarrow>\n                          c < n \\<and>\n                          (\\<forall>t'.\n                              t' \\<noteq> l \\<longrightarrow>\n                              (\\<forall>k'.\n                                  t' < N \\<and>\n                                  has_ticket (ts t') k' \\<longrightarrow>\n                                  c \\<noteq> k'))) \\<and>\n                         (t \\<noteq> l \\<longrightarrow>\n                          (\\<forall>k.\n                              t < N \\<and>\n                              has_ticket (ts t) k \\<longrightarrow>\n                              k \\<noteq> c \\<and>\n                              (\\<forall>k.\n                                  k \\<noteq> c \\<longrightarrow>\n                                  \\<not> locks_ticket (ts t) k)))\n 4. \\<And>l c n ts k t.\n       \\<lbrakk>A.reachable (c, n, ts); s = (c, n, ts);\n        s' = (c, n, ts(l := REL k)); l < N; ts l = HOLD k; c \\<le> n;\n        \\<forall>t k.\n           t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n           c \\<le> k \\<and>\n           k < n \\<and>\n           (\\<forall>t' k'.\n               t' < N \\<and>\n               has_ticket (ts t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n               k \\<noteq> k') \\<and>\n           (\\<forall>k.\n               k \\<noteq> c \\<longrightarrow>\n               \\<not> locks_ticket (ts t) k)\\<rbrakk>\n       \\<Longrightarrow> (t = l \\<longrightarrow>\n                          c \\<le> k \\<and>\n                          k < n \\<and>\n                          (\\<forall>t'.\n                              t' \\<noteq> l \\<longrightarrow>\n                              (\\<forall>k'.\n                                  t' < N \\<and>\n                                  has_ticket (ts t') k' \\<longrightarrow>\n                                  k \\<noteq> k')) \\<and>\n                          (\\<forall>ka.\n                              ka \\<noteq> c \\<longrightarrow>\n                              ka \\<noteq> k)) \\<and>\n                         (t \\<noteq> l \\<longrightarrow>\n                          (\\<forall>ka.\n                              t < N \\<and>\n                              has_ticket (ts t) ka \\<longrightarrow>\n                              ka \\<noteq> k \\<and>\n                              (\\<forall>k.\n                                  k \\<noteq> c \\<longrightarrow>\n                                  \\<not> locks_ticket (ts t) k)))\n 5. \\<And>l c n ts k.\n       \\<lbrakk>A.reachable (c, n, ts); s = (c, n, ts);\n        s' = (Suc k, n, ts(l := INIT)); l < N; ts l = REL k; c \\<le> n;\n        \\<forall>t k.\n           t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n           c \\<le> k \\<and>\n           k < n \\<and>\n           (\\<forall>t' k'.\n               t' < N \\<and>\n               has_ticket (ts t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n               k \\<noteq> k') \\<and>\n           (\\<forall>k.\n               k \\<noteq> c \\<longrightarrow>\n               \\<not> locks_ticket (ts t) k)\\<rbrakk>\n       \\<Longrightarrow> Suc k \\<le> n \\<and>\n                         (\\<forall>t.\n                             t \\<noteq> l \\<longrightarrow>\n                             (\\<forall>ka.\n                                 t < N \\<and>\n                                 has_ticket (ts t) ka \\<longrightarrow>\n                                 Suc k \\<le> ka \\<and>\n                                 (\\<forall>ka.\n                                     ka \\<noteq> Suc k \\<longrightarrow>\n                                     \\<not> locks_ticket (ts t) ka)))", "apply fastforce"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>l c n ts k t.\n       \\<lbrakk>A.reachable (c, n, ts); s = (c, n, ts);\n        s' = (c, n, ts(l := WAIT k)); l < N; ts l = WAIT k; c \\<noteq> k;\n        c \\<le> n;\n        \\<forall>t k.\n           t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n           c \\<le> k \\<and>\n           k < n \\<and>\n           (\\<forall>t' k'.\n               t' < N \\<and>\n               has_ticket (ts t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n               k \\<noteq> k') \\<and>\n           (\\<forall>k.\n               k \\<noteq> c \\<longrightarrow>\n               \\<not> locks_ticket (ts t) k)\\<rbrakk>\n       \\<Longrightarrow> (t = l \\<longrightarrow>\n                          c \\<le> k \\<and>\n                          k < n \\<and>\n                          (\\<forall>t'.\n                              t' \\<noteq> l \\<longrightarrow>\n                              (\\<forall>k'.\n                                  t' < N \\<and>\n                                  has_ticket (ts t') k' \\<longrightarrow>\n                                  k \\<noteq> k'))) \\<and>\n                         (t \\<noteq> l \\<longrightarrow>\n                          (\\<forall>ka.\n                              t < N \\<and>\n                              has_ticket (ts t) ka \\<longrightarrow>\n                              ka \\<noteq> k \\<and>\n                              (\\<forall>k.\n                                  k \\<noteq> c \\<longrightarrow>\n                                  \\<not> locks_ticket (ts t) k)))\n 2. \\<And>l c n ts t.\n       \\<lbrakk>A.reachable (c, n, ts); s = (c, n, ts);\n        s' = (c, n, ts(l := HOLD c)); l < N; ts l = WAIT c; c \\<le> n;\n        \\<forall>t k.\n           t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n           c \\<le> k \\<and>\n           k < n \\<and>\n           (\\<forall>t' k'.\n               t' < N \\<and>\n               has_ticket (ts t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n               k \\<noteq> k') \\<and>\n           (\\<forall>k.\n               k \\<noteq> c \\<longrightarrow>\n               \\<not> locks_ticket (ts t) k)\\<rbrakk>\n       \\<Longrightarrow> (t = l \\<longrightarrow>\n                          c < n \\<and>\n                          (\\<forall>t'.\n                              t' \\<noteq> l \\<longrightarrow>\n                              (\\<forall>k'.\n                                  t' < N \\<and>\n                                  has_ticket (ts t') k' \\<longrightarrow>\n                                  c \\<noteq> k'))) \\<and>\n                         (t \\<noteq> l \\<longrightarrow>\n                          (\\<forall>k.\n                              t < N \\<and>\n                              has_ticket (ts t) k \\<longrightarrow>\n                              k \\<noteq> c \\<and>\n                              (\\<forall>k.\n                                  k \\<noteq> c \\<longrightarrow>\n                                  \\<not> locks_ticket (ts t) k)))\n 3. \\<And>l c n ts k t.\n       \\<lbrakk>A.reachable (c, n, ts); s = (c, n, ts);\n        s' = (c, n, ts(l := REL k)); l < N; ts l = HOLD k; c \\<le> n;\n        \\<forall>t k.\n           t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n           c \\<le> k \\<and>\n           k < n \\<and>\n           (\\<forall>t' k'.\n               t' < N \\<and>\n               has_ticket (ts t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n               k \\<noteq> k') \\<and>\n           (\\<forall>k.\n               k \\<noteq> c \\<longrightarrow>\n               \\<not> locks_ticket (ts t) k)\\<rbrakk>\n       \\<Longrightarrow> (t = l \\<longrightarrow>\n                          c \\<le> k \\<and>\n                          k < n \\<and>\n                          (\\<forall>t'.\n                              t' \\<noteq> l \\<longrightarrow>\n                              (\\<forall>k'.\n                                  t' < N \\<and>\n                                  has_ticket (ts t') k' \\<longrightarrow>\n                                  k \\<noteq> k')) \\<and>\n                          (\\<forall>ka.\n                              ka \\<noteq> c \\<longrightarrow>\n                              ka \\<noteq> k)) \\<and>\n                         (t \\<noteq> l \\<longrightarrow>\n                          (\\<forall>ka.\n                              t < N \\<and>\n                              has_ticket (ts t) ka \\<longrightarrow>\n                              ka \\<noteq> k \\<and>\n                              (\\<forall>k.\n                                  k \\<noteq> c \\<longrightarrow>\n                                  \\<not> locks_ticket (ts t) k)))\n 4. \\<And>l c n ts k.\n       \\<lbrakk>A.reachable (c, n, ts); s = (c, n, ts);\n        s' = (Suc k, n, ts(l := INIT)); l < N; ts l = REL k; c \\<le> n;\n        \\<forall>t k.\n           t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n           c \\<le> k \\<and>\n           k < n \\<and>\n           (\\<forall>t' k'.\n               t' < N \\<and>\n               has_ticket (ts t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n               k \\<noteq> k') \\<and>\n           (\\<forall>k.\n               k \\<noteq> c \\<longrightarrow>\n               \\<not> locks_ticket (ts t) k)\\<rbrakk>\n       \\<Longrightarrow> Suc k \\<le> n \\<and>\n                         (\\<forall>t.\n                             t \\<noteq> l \\<longrightarrow>\n                             (\\<forall>ka.\n                                 t < N \\<and>\n                                 has_ticket (ts t) ka \\<longrightarrow>\n                                 Suc k \\<le> ka \\<and>\n                                 (\\<forall>ka.\n                                     ka \\<noteq> Suc k \\<longrightarrow>\n                                     \\<not> locks_ticket (ts t) ka)))", "apply fastforce"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l c n ts t.\n       \\<lbrakk>A.reachable (c, n, ts); s = (c, n, ts);\n        s' = (c, n, ts(l := HOLD c)); l < N; ts l = WAIT c; c \\<le> n;\n        \\<forall>t k.\n           t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n           c \\<le> k \\<and>\n           k < n \\<and>\n           (\\<forall>t' k'.\n               t' < N \\<and>\n               has_ticket (ts t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n               k \\<noteq> k') \\<and>\n           (\\<forall>k.\n               k \\<noteq> c \\<longrightarrow>\n               \\<not> locks_ticket (ts t) k)\\<rbrakk>\n       \\<Longrightarrow> (t = l \\<longrightarrow>\n                          c < n \\<and>\n                          (\\<forall>t'.\n                              t' \\<noteq> l \\<longrightarrow>\n                              (\\<forall>k'.\n                                  t' < N \\<and>\n                                  has_ticket (ts t') k' \\<longrightarrow>\n                                  c \\<noteq> k'))) \\<and>\n                         (t \\<noteq> l \\<longrightarrow>\n                          (\\<forall>k.\n                              t < N \\<and>\n                              has_ticket (ts t) k \\<longrightarrow>\n                              k \\<noteq> c \\<and>\n                              (\\<forall>k.\n                                  k \\<noteq> c \\<longrightarrow>\n                                  \\<not> locks_ticket (ts t) k)))\n 2. \\<And>l c n ts k t.\n       \\<lbrakk>A.reachable (c, n, ts); s = (c, n, ts);\n        s' = (c, n, ts(l := REL k)); l < N; ts l = HOLD k; c \\<le> n;\n        \\<forall>t k.\n           t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n           c \\<le> k \\<and>\n           k < n \\<and>\n           (\\<forall>t' k'.\n               t' < N \\<and>\n               has_ticket (ts t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n               k \\<noteq> k') \\<and>\n           (\\<forall>k.\n               k \\<noteq> c \\<longrightarrow>\n               \\<not> locks_ticket (ts t) k)\\<rbrakk>\n       \\<Longrightarrow> (t = l \\<longrightarrow>\n                          c \\<le> k \\<and>\n                          k < n \\<and>\n                          (\\<forall>t'.\n                              t' \\<noteq> l \\<longrightarrow>\n                              (\\<forall>k'.\n                                  t' < N \\<and>\n                                  has_ticket (ts t') k' \\<longrightarrow>\n                                  k \\<noteq> k')) \\<and>\n                          (\\<forall>ka.\n                              ka \\<noteq> c \\<longrightarrow>\n                              ka \\<noteq> k)) \\<and>\n                         (t \\<noteq> l \\<longrightarrow>\n                          (\\<forall>ka.\n                              t < N \\<and>\n                              has_ticket (ts t) ka \\<longrightarrow>\n                              ka \\<noteq> k \\<and>\n                              (\\<forall>k.\n                                  k \\<noteq> c \\<longrightarrow>\n                                  \\<not> locks_ticket (ts t) k)))\n 3. \\<And>l c n ts k.\n       \\<lbrakk>A.reachable (c, n, ts); s = (c, n, ts);\n        s' = (Suc k, n, ts(l := INIT)); l < N; ts l = REL k; c \\<le> n;\n        \\<forall>t k.\n           t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n           c \\<le> k \\<and>\n           k < n \\<and>\n           (\\<forall>t' k'.\n               t' < N \\<and>\n               has_ticket (ts t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n               k \\<noteq> k') \\<and>\n           (\\<forall>k.\n               k \\<noteq> c \\<longrightarrow>\n               \\<not> locks_ticket (ts t) k)\\<rbrakk>\n       \\<Longrightarrow> Suc k \\<le> n \\<and>\n                         (\\<forall>t.\n                             t \\<noteq> l \\<longrightarrow>\n                             (\\<forall>ka.\n                                 t < N \\<and>\n                                 has_ticket (ts t) ka \\<longrightarrow>\n                                 Suc k \\<le> ka \\<and>\n                                 (\\<forall>ka.\n                                     ka \\<noteq> Suc k \\<longrightarrow>\n                                     \\<not> locks_ticket (ts t) ka)))", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l c n ts k t.\n       \\<lbrakk>A.reachable (c, n, ts); s = (c, n, ts);\n        s' = (c, n, ts(l := REL k)); l < N; ts l = HOLD k; c \\<le> n;\n        \\<forall>t k.\n           t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n           c \\<le> k \\<and>\n           k < n \\<and>\n           (\\<forall>t' k'.\n               t' < N \\<and>\n               has_ticket (ts t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n               k \\<noteq> k') \\<and>\n           (\\<forall>k.\n               k \\<noteq> c \\<longrightarrow>\n               \\<not> locks_ticket (ts t) k)\\<rbrakk>\n       \\<Longrightarrow> (t = l \\<longrightarrow>\n                          c \\<le> k \\<and>\n                          k < n \\<and>\n                          (\\<forall>t'.\n                              t' \\<noteq> l \\<longrightarrow>\n                              (\\<forall>k'.\n                                  t' < N \\<and>\n                                  has_ticket (ts t') k' \\<longrightarrow>\n                                  k \\<noteq> k')) \\<and>\n                          (\\<forall>ka.\n                              ka \\<noteq> c \\<longrightarrow>\n                              ka \\<noteq> k)) \\<and>\n                         (t \\<noteq> l \\<longrightarrow>\n                          (\\<forall>ka.\n                              t < N \\<and>\n                              has_ticket (ts t) ka \\<longrightarrow>\n                              ka \\<noteq> k \\<and>\n                              (\\<forall>k.\n                                  k \\<noteq> c \\<longrightarrow>\n                                  \\<not> locks_ticket (ts t) k)))\n 2. \\<And>l c n ts k.\n       \\<lbrakk>A.reachable (c, n, ts); s = (c, n, ts);\n        s' = (Suc k, n, ts(l := INIT)); l < N; ts l = REL k; c \\<le> n;\n        \\<forall>t k.\n           t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n           c \\<le> k \\<and>\n           k < n \\<and>\n           (\\<forall>t' k'.\n               t' < N \\<and>\n               has_ticket (ts t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n               k \\<noteq> k') \\<and>\n           (\\<forall>k.\n               k \\<noteq> c \\<longrightarrow>\n               \\<not> locks_ticket (ts t) k)\\<rbrakk>\n       \\<Longrightarrow> Suc k \\<le> n \\<and>\n                         (\\<forall>t.\n                             t \\<noteq> l \\<longrightarrow>\n                             (\\<forall>ka.\n                                 t < N \\<and>\n                                 has_ticket (ts t) ka \\<longrightarrow>\n                                 Suc k \\<le> ka \\<and>\n                                 (\\<forall>ka.\n                                     ka \\<noteq> Suc k \\<longrightarrow>\n                                     \\<not> locks_ticket (ts t) ka)))", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l c n ts k.\n       \\<lbrakk>A.reachable (c, n, ts); s = (c, n, ts);\n        s' = (Suc k, n, ts(l := INIT)); l < N; ts l = REL k; c \\<le> n;\n        \\<forall>t k.\n           t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n           c \\<le> k \\<and>\n           k < n \\<and>\n           (\\<forall>t' k'.\n               t' < N \\<and>\n               has_ticket (ts t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n               k \\<noteq> k') \\<and>\n           (\\<forall>k.\n               k \\<noteq> c \\<longrightarrow>\n               \\<not> locks_ticket (ts t) k)\\<rbrakk>\n       \\<Longrightarrow> Suc k \\<le> n \\<and>\n                         (\\<forall>t.\n                             t \\<noteq> l \\<longrightarrow>\n                             (\\<forall>ka.\n                                 t < N \\<and>\n                                 has_ticket (ts t) ka \\<longrightarrow>\n                                 Suc k \\<le> ka \\<and>\n                                 (\\<forall>ka.\n                                     ka \\<noteq> Suc k \\<longrightarrow>\n                                     \\<not> locks_ticket (ts t) ka)))", "by (metis Suc_le_eq holds_imp_uses locks_ticket_def le_neq_implies_less)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>From the above invariant, it's straightforward to show mutual exclusion\\<close>"], ["", "theorem mutual_exclusion: \"\\<lbrakk>A.reachable s; \n      t<N; t'<N; t\\<noteq>t'; is_HOLD (tts s t); is_HOLD (tts s t')\n    \\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A.reachable s; t < N; t' < N; t \\<noteq> t'; is_HOLD (tts s t);\n     is_HOLD (tts s t')\\<rbrakk>\n    \\<Longrightarrow> False", "apply (cases \"tts s t\"; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>A.reachable s; t < N; t' < N; t \\<noteq> t';\n        is_HOLD (tts s t'); tts s t = HOLD x3\\<rbrakk>\n       \\<Longrightarrow> False", "apply (cases \"tts s t'\"; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x3 x3a.\n       \\<lbrakk>A.reachable s; t < N; t' < N; t \\<noteq> t';\n        tts s t = HOLD x3; tts s t' = HOLD x3a\\<rbrakk>\n       \\<Longrightarrow> False", "using A.invar_reachable[OF is_invar1, of s]"], ["proof (prove)\nusing this:\n  A.reachable s \\<Longrightarrow> invar1 s\n\ngoal (1 subgoal):\n 1. \\<And>x3 x3a.\n       \\<lbrakk>A.reachable s; t < N; t' < N; t \\<noteq> t';\n        tts s t = HOLD x3; tts s t' = HOLD x3a\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto simp: invar1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x3 x3a x a b.\n       \\<lbrakk>A.reachable (x, a, b); t < N; t' < N; t \\<noteq> t';\n        b t = HOLD x3; b t' = HOLD x3a; s = (x, a, b); x \\<le> a;\n        \\<forall>t k.\n           t < N \\<and> has_ticket (b t) k \\<longrightarrow>\n           x \\<le> k \\<and>\n           k < a \\<and>\n           (\\<forall>t' k'.\n               t' < N \\<and>\n               has_ticket (b t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n               k \\<noteq> k') \\<and>\n           (\\<forall>k.\n               k \\<noteq> x \\<longrightarrow>\n               \\<not> locks_ticket (b t) k)\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis locks_ticket_simps(3) has_ticket_simps(3))"], ["", "lemma mutual_exclusion': \"\\<lbrakk>A.reachable s; \n      t<N; t'<N; t\\<noteq>t'; \n      locks_ticket (tts s t) tk; locks_ticket (tts s t') tk'\n    \\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A.reachable s; t < N; t' < N; t \\<noteq> t';\n     locks_ticket (tts s t) tk; locks_ticket (tts s t') tk'\\<rbrakk>\n    \\<Longrightarrow> False", "apply (cases \"tts s t\"; simp; cases \"tts s t'\"; simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x3 x3a.\n       \\<lbrakk>A.reachable s; t < N; t' < N; t \\<noteq> t'; tk = x3;\n        tk' = x3a; tts s t = HOLD x3; tts s t' = HOLD x3a\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x3 x4.\n       \\<lbrakk>A.reachable s; t < N; t' < N; t \\<noteq> t'; tk = x3;\n        tk' = x4; tts s t = HOLD x3; tts s t' = REL x4\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x4 x3.\n       \\<lbrakk>A.reachable s; t < N; t' < N; t \\<noteq> t'; tk = x4;\n        tk' = x3; tts s t = REL x4; tts s t' = HOLD x3\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x4 x4a.\n       \\<lbrakk>A.reachable s; t < N; t' < N; t \\<noteq> t'; tk = x4;\n        tk' = x4a; tts s t = REL x4; tts s t' = REL x4a\\<rbrakk>\n       \\<Longrightarrow> False", "apply (cases \"tts s t'\"; simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x3 x3a x3b.\n       \\<lbrakk>A.reachable s; t < N; t' < N; t \\<noteq> t'; tk = x3;\n        tk' = x3a; tts s t = HOLD x3; x3b = x3a;\n        tts s t' = HOLD x3a\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x3 x4.\n       \\<lbrakk>A.reachable s; t < N; t' < N; t \\<noteq> t'; tk = x3;\n        tk' = x4; tts s t = HOLD x3; tts s t' = REL x4\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x4 x3.\n       \\<lbrakk>A.reachable s; t < N; t' < N; t \\<noteq> t'; tk = x4;\n        tk' = x3; tts s t = REL x4; tts s t' = HOLD x3\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x4 x4a.\n       \\<lbrakk>A.reachable s; t < N; t' < N; t \\<noteq> t'; tk = x4;\n        tk' = x4a; tts s t = REL x4; tts s t' = REL x4a\\<rbrakk>\n       \\<Longrightarrow> False", "using A.invar_reachable[OF is_invar1, of s]"], ["proof (prove)\nusing this:\n  A.reachable s \\<Longrightarrow> invar1 s\n\ngoal (4 subgoals):\n 1. \\<And>x3 x3a x3b.\n       \\<lbrakk>A.reachable s; t < N; t' < N; t \\<noteq> t'; tk = x3;\n        tk' = x3a; tts s t = HOLD x3; x3b = x3a;\n        tts s t' = HOLD x3a\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x3 x4.\n       \\<lbrakk>A.reachable s; t < N; t' < N; t \\<noteq> t'; tk = x3;\n        tk' = x4; tts s t = HOLD x3; tts s t' = REL x4\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x4 x3.\n       \\<lbrakk>A.reachable s; t < N; t' < N; t \\<noteq> t'; tk = x4;\n        tk' = x3; tts s t = REL x4; tts s t' = HOLD x3\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x4 x4a.\n       \\<lbrakk>A.reachable s; t < N; t' < N; t \\<noteq> t'; tk = x4;\n        tk' = x4a; tts s t = REL x4; tts s t' = REL x4a\\<rbrakk>\n       \\<Longrightarrow> False", "apply (clarsimp_all simp: invar1_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x a b.\n       \\<lbrakk>A.reachable (x, a, b); t < N; t' < N; t \\<noteq> t';\n        b t = HOLD tk; b t' = HOLD tk'; s = (x, a, b); x \\<le> a;\n        \\<forall>t k.\n           t < N \\<and> has_ticket (b t) k \\<longrightarrow>\n           x \\<le> k \\<and>\n           k < a \\<and>\n           (\\<forall>t' k'.\n               t' < N \\<and>\n               has_ticket (b t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n               k \\<noteq> k') \\<and>\n           (\\<forall>k.\n               k \\<noteq> x \\<longrightarrow>\n               \\<not> locks_ticket (b t) k)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x a b.\n       \\<lbrakk>A.reachable (x, a, b); t < N; t' < N; t \\<noteq> t';\n        b t = HOLD tk; b t' = REL tk'; s = (x, a, b); x \\<le> a;\n        \\<forall>t k.\n           t < N \\<and> has_ticket (b t) k \\<longrightarrow>\n           x \\<le> k \\<and>\n           k < a \\<and>\n           (\\<forall>t' k'.\n               t' < N \\<and>\n               has_ticket (b t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n               k \\<noteq> k') \\<and>\n           (\\<forall>k.\n               k \\<noteq> x \\<longrightarrow>\n               \\<not> locks_ticket (b t) k)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x a b.\n       \\<lbrakk>A.reachable (x, a, b); t < N; t' < N; t \\<noteq> t';\n        b t = REL tk; b t' = HOLD tk'; s = (x, a, b); x \\<le> a;\n        \\<forall>t k.\n           t < N \\<and> has_ticket (b t) k \\<longrightarrow>\n           x \\<le> k \\<and>\n           k < a \\<and>\n           (\\<forall>t' k'.\n               t' < N \\<and>\n               has_ticket (b t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n               k \\<noteq> k') \\<and>\n           (\\<forall>k.\n               k \\<noteq> x \\<longrightarrow>\n               \\<not> locks_ticket (b t) k)\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x a b.\n       \\<lbrakk>A.reachable (x, a, b); t < N; t' < N; t \\<noteq> t';\n        b t = REL tk; b t' = REL tk'; s = (x, a, b); x \\<le> a;\n        \\<forall>t k.\n           t < N \\<and> has_ticket (b t) k \\<longrightarrow>\n           x \\<le> k \\<and>\n           k < a \\<and>\n           (\\<forall>t' k'.\n               t' < N \\<and>\n               has_ticket (b t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n               k \\<noteq> k') \\<and>\n           (\\<forall>k.\n               k \\<noteq> x \\<longrightarrow>\n               \\<not> locks_ticket (b t) k)\\<rbrakk>\n       \\<Longrightarrow> False", "unfolding locks_ticket_def has_ticket_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x a b.\n       \\<lbrakk>A.reachable (x, a, b); t < N; t' < N; t \\<noteq> t';\n        b t = HOLD tk; b t' = HOLD tk'; s = (x, a, b); x \\<le> a;\n        \\<forall>t k.\n           t < N \\<and>\n           (b t = WAIT k \\<or>\n            b t = HOLD k \\<or> b t = REL k) \\<longrightarrow>\n           x \\<le> k \\<and>\n           k < a \\<and>\n           (\\<forall>t' k'.\n               t' < N \\<and>\n               (b t' = WAIT k' \\<or>\n                b t' = HOLD k' \\<or> b t' = REL k') \\<and>\n               t \\<noteq> t' \\<longrightarrow>\n               k \\<noteq> k') \\<and>\n           (\\<forall>k.\n               k \\<noteq> x \\<longrightarrow>\n               \\<not> (b t = HOLD k \\<or> b t = REL k))\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x a b.\n       \\<lbrakk>A.reachable (x, a, b); t < N; t' < N; t \\<noteq> t';\n        b t = HOLD tk; b t' = REL tk'; s = (x, a, b); x \\<le> a;\n        \\<forall>t k.\n           t < N \\<and>\n           (b t = WAIT k \\<or>\n            b t = HOLD k \\<or> b t = REL k) \\<longrightarrow>\n           x \\<le> k \\<and>\n           k < a \\<and>\n           (\\<forall>t' k'.\n               t' < N \\<and>\n               (b t' = WAIT k' \\<or>\n                b t' = HOLD k' \\<or> b t' = REL k') \\<and>\n               t \\<noteq> t' \\<longrightarrow>\n               k \\<noteq> k') \\<and>\n           (\\<forall>k.\n               k \\<noteq> x \\<longrightarrow>\n               \\<not> (b t = HOLD k \\<or> b t = REL k))\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>x a b.\n       \\<lbrakk>A.reachable (x, a, b); t < N; t' < N; t \\<noteq> t';\n        b t = REL tk; b t' = HOLD tk'; s = (x, a, b); x \\<le> a;\n        \\<forall>t k.\n           t < N \\<and>\n           (b t = WAIT k \\<or>\n            b t = HOLD k \\<or> b t = REL k) \\<longrightarrow>\n           x \\<le> k \\<and>\n           k < a \\<and>\n           (\\<forall>t' k'.\n               t' < N \\<and>\n               (b t' = WAIT k' \\<or>\n                b t' = HOLD k' \\<or> b t' = REL k') \\<and>\n               t \\<noteq> t' \\<longrightarrow>\n               k \\<noteq> k') \\<and>\n           (\\<forall>k.\n               k \\<noteq> x \\<longrightarrow>\n               \\<not> (b t = HOLD k \\<or> b t = REL k))\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>x a b.\n       \\<lbrakk>A.reachable (x, a, b); t < N; t' < N; t \\<noteq> t';\n        b t = REL tk; b t' = REL tk'; s = (x, a, b); x \\<le> a;\n        \\<forall>t k.\n           t < N \\<and>\n           (b t = WAIT k \\<or>\n            b t = HOLD k \\<or> b t = REL k) \\<longrightarrow>\n           x \\<le> k \\<and>\n           k < a \\<and>\n           (\\<forall>t' k'.\n               t' < N \\<and>\n               (b t' = WAIT k' \\<or>\n                b t' = HOLD k' \\<or> b t' = REL k') \\<and>\n               t \\<noteq> t' \\<longrightarrow>\n               k \\<noteq> k') \\<and>\n           (\\<forall>k.\n               k \\<noteq> x \\<longrightarrow>\n               \\<not> (b t = HOLD k \\<or> b t = REL k))\\<rbrakk>\n       \\<Longrightarrow> False", "apply metis+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Fairness: Ordered Lock Acquisition\\<close>"], ["", "text \\<open>We first show an auxiliary lemma: \n    Consider a segment of a run from \\<open>i\\<close> to \\<open>j\\<close>. Every thread that waits for\n    a ticket in between the current ticket at \\<open>i\\<close> and the current ticket at \\<open>j\\<close>\n    will be granted the lock in between \\<open>i\\<close> and \\<open>j\\<close>.\n  \\<close>"], ["", "lemma fair_aux:  \n    assumes R: \"A.is_run s\"\n    assumes A: \"i<j\" \"cc (s i) \\<le> k\" \"k < cc (s j)\" \"t<N\" \"tts (s i) t=WAIT k\"\n    shows \"\\<exists>l. i\\<le>l \\<and> l<j \\<and> tts (s l) t = HOLD k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "interpret A: run as\\<^sub>0 alstep s"], ["proof (prove)\ngoal (1 subgoal):\n 1. DF_System.run as\\<^sub>0 alstep s", "by unfold_locales fact"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "from A"], ["proof (chain)\npicking this:\n  i < j\n  cc (s i) \\<le> k\n  k < cc (s j)\n  t < N\n  tts (s i) t = WAIT k", "show ?thesis"], ["proof (prove)\nusing this:\n  i < j\n  cc (s i) \\<le> k\n  k < cc (s j)\n  t < N\n  tts (s i) t = WAIT k\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "proof (induction \"j-i\" arbitrary: i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>0 = j - i; i < j; cc (s i) \\<le> k; k < cc (s j); t < N;\n        tts (s i) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 2. \\<And>x i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>x = j - i; i < j; cc (s i) \\<le> k;\n                    k < cc (s j); t < N; tts (s i) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<ge>i.\n  l < j \\<and> tts (s l) t = HOLD k;\n        Suc x = j - i; i < j; cc (s i) \\<le> k; k < cc (s j); t < N;\n        tts (s i) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "case 0"], ["proof (state)\nthis:\n  0 = j - i\n  i < j\n  cc (s i) \\<le> k\n  k < cc (s j)\n  t < N\n  tts (s i) t = WAIT k\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>0 = j - i; i < j; cc (s i) \\<le> k; k < cc (s j); t < N;\n        tts (s i) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 2. \\<And>x i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>x = j - i; i < j; cc (s i) \\<le> k;\n                    k < cc (s j); t < N; tts (s i) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<ge>i.\n  l < j \\<and> tts (s l) t = HOLD k;\n        Suc x = j - i; i < j; cc (s i) \\<le> k; k < cc (s j); t < N;\n        tts (s i) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "then"], ["proof (chain)\npicking this:\n  0 = j - i\n  i < j\n  cc (s i) \\<le> k\n  k < cc (s j)\n  t < N\n  tts (s i) t = WAIT k", "show ?case"], ["proof (prove)\nusing this:\n  0 = j - i\n  i < j\n  cc (s i) \\<le> k\n  k < cc (s j)\n  t < N\n  tts (s i) t = WAIT k\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "by auto"], ["proof (state)\nthis:\n  \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>x = j - i; i < j; cc (s i) \\<le> k;\n                    k < cc (s j); t < N; tts (s i) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<ge>i.\n  l < j \\<and> tts (s l) t = HOLD k;\n        Suc x = j - i; i < j; cc (s i) \\<le> k; k < cc (s j); t < N;\n        tts (s i) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>x = j - i; i < j; cc (s i) \\<le> k;\n                    k < cc (s j); t < N; tts (s i) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<ge>i.\n  l < j \\<and> tts (s l) t = HOLD k;\n        Suc x = j - i; i < j; cc (s i) \\<le> k; k < cc (s j); t < N;\n        tts (s i) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "case (Suc i')"], ["proof (state)\nthis:\n  \\<lbrakk>i' = j - ?i; ?i < j; cc (s ?i) \\<le> k; k < cc (s j); t < N;\n   tts (s ?i) t = WAIT k\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<ge>?i. l < j \\<and> tts (s l) t = HOLD k\n  Suc i' = j - i\n  i < j\n  cc (s i) \\<le> k\n  k < cc (s j)\n  t < N\n  tts (s i) t = WAIT k\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>x = j - i; i < j; cc (s i) \\<le> k;\n                    k < cc (s j); t < N; tts (s i) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<ge>i.\n  l < j \\<and> tts (s l) t = HOLD k;\n        Suc x = j - i; i < j; cc (s i) \\<le> k; k < cc (s j); t < N;\n        tts (s i) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "hence [simp]: \"i'=j - Suc i\""], ["proof (prove)\nusing this:\n  \\<lbrakk>i' = j - ?i; ?i < j; cc (s ?i) \\<le> k; k < cc (s j); t < N;\n   tts (s ?i) t = WAIT k\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<ge>?i. l < j \\<and> tts (s l) t = HOLD k\n  Suc i' = j - i\n  i < j\n  cc (s i) \\<le> k\n  k < cc (s j)\n  t < N\n  tts (s i) t = WAIT k\n\ngoal (1 subgoal):\n 1. i' = j - Suc i", "by auto"], ["proof (state)\nthis:\n  i' = j - Suc i\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>x = j - i; i < j; cc (s i) \\<le> k;\n                    k < cc (s j); t < N; tts (s i) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<ge>i.\n  l < j \\<and> tts (s l) t = HOLD k;\n        Suc x = j - i; i < j; cc (s i) \\<le> k; k < cc (s j); t < N;\n        tts (s i) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "note IH=Suc.hyps(1)[OF this]"], ["proof (state)\nthis:\n  \\<lbrakk>Suc i < j; cc (s (Suc i)) \\<le> k; k < cc (s j); t < N;\n   tts (s (Suc i)) t = WAIT k\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<ge>Suc i. l < j \\<and> tts (s l) t = HOLD k\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>x = j - i; i < j; cc (s i) \\<le> k;\n                    k < cc (s j); t < N; tts (s i) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<ge>i.\n  l < j \\<and> tts (s l) t = HOLD k;\n        Suc x = j - i; i < j; cc (s i) \\<le> k; k < cc (s j); t < N;\n        tts (s i) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "obtain t' where \"alstep t' (s i) (s (Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        alstep t' (s i) (s (Suc i)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule A.stepE)"], ["proof (state)\nthis:\n  alstep t' (s i) (s (Suc i))\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>x = j - i; i < j; cc (s i) \\<le> k;\n                    k < cc (s j); t < N; tts (s i) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l\\<ge>i.\n  l < j \\<and> tts (s l) t = HOLD k;\n        Suc x = j - i; i < j; cc (s i) \\<le> k; k < cc (s j); t < N;\n        tts (s i) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "then"], ["proof (chain)\npicking this:\n  alstep t' (s i) (s (Suc i))", "show ?case"], ["proof (prove)\nusing this:\n  alstep t' (s i) (s (Suc i))\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "using Suc.prems"], ["proof (prove)\nusing this:\n  alstep t' (s i) (s (Suc i))\n  i < j\n  cc (s i) \\<le> k\n  k < cc (s j)\n  t < N\n  tts (s i) t = WAIT k\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "proof cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c n ts c' n' s'.\n       \\<lbrakk>i < j; cc (s i) \\<le> k; k < cc (s j); t < N;\n        tts (s i) t = WAIT k; s i = (c, n, ts);\n        s (Suc i) = (c', n', ts(t' := s')); t' < N;\n        astep_sng (c, n, ts t') (c', n', s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "case (1 c n ts c' n' s')"], ["proof (state)\nthis:\n  s i = (c, n, ts)\n  s (Suc i) = (c', n', ts(t' := s'))\n  t' < N\n  astep_sng (c, n, ts t') (c', n', s')\n\ngoal (1 subgoal):\n 1. \\<And>c n ts c' n' s'.\n       \\<lbrakk>i < j; cc (s i) \\<le> k; k < cc (s j); t < N;\n        tts (s i) t = WAIT k; s i = (c, n, ts);\n        s (Suc i) = (c', n', ts(t' := s')); t' < N;\n        astep_sng (c, n, ts t') (c', n', s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "note [simp] = \"1\"(1,2,3)"], ["proof (state)\nthis:\n  s i = (c, n, ts)\n  s (Suc i) = (c', n', ts(t' := s'))\n  t' < N\n\ngoal (1 subgoal):\n 1. \\<And>c n ts c' n' s'.\n       \\<lbrakk>i < j; cc (s i) \\<le> k; k < cc (s j); t < N;\n        tts (s i) t = WAIT k; s i = (c, n, ts);\n        s (Suc i) = (c', n', ts(t' := s')); t' < N;\n        astep_sng (c, n, ts t') (c', n', s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "from A.run_invar[OF is_invar1, of i]"], ["proof (chain)\npicking this:\n  invar1 (s i)", "have \"invar1 (c,n,ts)\""], ["proof (prove)\nusing this:\n  invar1 (s i)\n\ngoal (1 subgoal):\n 1. invar1 (c, n, ts)", "by auto"], ["proof (state)\nthis:\n  invar1 (c, n, ts)\n\ngoal (1 subgoal):\n 1. \\<And>c n ts c' n' s'.\n       \\<lbrakk>i < j; cc (s i) \\<le> k; k < cc (s j); t < N;\n        tts (s i) t = WAIT k; s i = (c, n, ts);\n        s (Suc i) = (c', n', ts(t' := s')); t' < N;\n        astep_sng (c, n, ts t') (c', n', s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "note I1 = this[unfolded invar1_def, simplified]"], ["proof (state)\nthis:\n  c \\<le> n \\<and>\n  (\\<forall>t k.\n      t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n      c \\<le> k \\<and>\n      k < n \\<and>\n      (\\<forall>t' k'.\n          t' < N \\<and>\n          has_ticket (ts t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n          k \\<noteq> k') \\<and>\n      (\\<forall>k.\n          k \\<noteq> c \\<longrightarrow> \\<not> locks_ticket (ts t) k))\n\ngoal (1 subgoal):\n 1. \\<And>c n ts c' n' s'.\n       \\<lbrakk>i < j; cc (s i) \\<le> k; k < cc (s j); t < N;\n        tts (s i) t = WAIT k; s i = (c, n, ts);\n        s (Suc i) = (c', n', ts(t' := s')); t' < N;\n        astep_sng (c, n, ts t') (c', n', s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "from \"1\"(4)"], ["proof (chain)\npicking this:\n  astep_sng (c, n, ts t') (c', n', s')", "show ?thesis"], ["proof (prove)\nusing this:\n  astep_sng (c, n, ts t') (c', n', s')\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "proof (cases rule: astep_sng.cases)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<lbrakk>ts t' = INIT; c' = c; n' = n + 1; s' = WAIT n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 2. \\<And>ka.\n       \\<lbrakk>ts t' = WAIT ka; c' = c; n' = n; s' = WAIT ka;\n        c \\<noteq> ka\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 3. \\<lbrakk>ts t' = WAIT c; c' = c; n' = n; s' = HOLD c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 4. \\<And>ka.\n       \\<lbrakk>ts t' = HOLD ka; c' = c; n' = n; s' = REL ka\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 5. \\<And>ka.\n       \\<lbrakk>ts t' = REL ka; c' = ka + 1; n' = n; s' = INIT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "case enter_wait"], ["proof (state)\nthis:\n  ts t' = INIT\n  c' = c\n  n' = n + 1\n  s' = WAIT n\n\ngoal (5 subgoals):\n 1. \\<lbrakk>ts t' = INIT; c' = c; n' = n + 1; s' = WAIT n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 2. \\<And>ka.\n       \\<lbrakk>ts t' = WAIT ka; c' = c; n' = n; s' = WAIT ka;\n        c \\<noteq> ka\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 3. \\<lbrakk>ts t' = WAIT c; c' = c; n' = n; s' = HOLD c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 4. \\<And>ka.\n       \\<lbrakk>ts t' = HOLD ka; c' = c; n' = n; s' = REL ka\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 5. \\<And>ka.\n       \\<lbrakk>ts t' = REL ka; c' = ka + 1; n' = n; s' = INIT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "then"], ["proof (chain)\npicking this:\n  ts t' = INIT\n  c' = c\n  n' = n + 1\n  s' = WAIT n", "show ?thesis"], ["proof (prove)\nusing this:\n  ts t' = INIT\n  c' = c\n  n' = n + 1\n  s' = WAIT n\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "using IH Suc.prems"], ["proof (prove)\nusing this:\n  ts t' = INIT\n  c' = c\n  n' = n + 1\n  s' = WAIT n\n  \\<lbrakk>Suc i < j; cc (s (Suc i)) \\<le> k; k < cc (s j); t < N;\n   tts (s (Suc i)) t = WAIT k\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<ge>Suc i. l < j \\<and> tts (s l) t = HOLD k\n  i < j\n  cc (s i) \\<le> k\n  k < cc (s j)\n  t < N\n  tts (s i) t = WAIT k\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts t' = INIT; c' = c; n' = Suc n; s' = WAIT n;\n     \\<lbrakk>Suc i < j; (if t = t' then WAIT n else ts t) = WAIT k\\<rbrakk>\n     \\<Longrightarrow> \\<exists>l\\<ge>Suc i.\n                          l < j \\<and> tts (s l) t = HOLD k;\n     i < j; c \\<le> k; k < cc (s j); t < N; ts t = WAIT k\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "by (metis \"1\"(2) Suc_leD Suc_lessI fst_conv leD thread.distinct(1))"], ["proof (state)\nthis:\n  \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n\ngoal (4 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>ts t' = WAIT ka; c' = c; n' = n; s' = WAIT ka;\n        c \\<noteq> ka\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 2. \\<lbrakk>ts t' = WAIT c; c' = c; n' = n; s' = HOLD c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 3. \\<And>ka.\n       \\<lbrakk>ts t' = HOLD ka; c' = c; n' = n; s' = REL ka\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 4. \\<And>ka.\n       \\<lbrakk>ts t' = REL ka; c' = ka + 1; n' = n; s' = INIT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>ts t' = WAIT ka; c' = c; n' = n; s' = WAIT ka;\n        c \\<noteq> ka\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 2. \\<lbrakk>ts t' = WAIT c; c' = c; n' = n; s' = HOLD c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 3. \\<And>ka.\n       \\<lbrakk>ts t' = HOLD ka; c' = c; n' = n; s' = REL ka\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 4. \\<And>ka.\n       \\<lbrakk>ts t' = REL ka; c' = ka + 1; n' = n; s' = INIT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "case (loop_wait k)"], ["proof (state)\nthis:\n  ts t' = WAIT k\n  c' = c\n  n' = n\n  s' = WAIT k\n  c \\<noteq> k\n\ngoal (4 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>ts t' = WAIT ka; c' = c; n' = n; s' = WAIT ka;\n        c \\<noteq> ka\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 2. \\<lbrakk>ts t' = WAIT c; c' = c; n' = n; s' = HOLD c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 3. \\<And>ka.\n       \\<lbrakk>ts t' = HOLD ka; c' = c; n' = n; s' = REL ka\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 4. \\<And>ka.\n       \\<lbrakk>ts t' = REL ka; c' = ka + 1; n' = n; s' = INIT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "then"], ["proof (chain)\npicking this:\n  ts t' = WAIT k\n  c' = c\n  n' = n\n  s' = WAIT k\n  c \\<noteq> k", "show ?thesis"], ["proof (prove)\nusing this:\n  ts t' = WAIT k\n  c' = c\n  n' = n\n  s' = WAIT k\n  c \\<noteq> k\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "using IH Suc.prems"], ["proof (prove)\nusing this:\n  ts t' = WAIT k\n  c' = c\n  n' = n\n  s' = WAIT k\n  c \\<noteq> k\n  \\<lbrakk>Suc i < j; cc (s (Suc i)) \\<le> k; k < cc (s j); t < N;\n   tts (s (Suc i)) t = WAIT k\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<ge>Suc i. l < j \\<and> tts (s l) t = HOLD k\n  i < j\n  cc (s i) \\<le> k\n  k < cc (s j)\n  t < N\n  tts (s i) t = WAIT k\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts t' = WAIT k; c' = c; n' = n; s' = WAIT k; c \\<noteq> k;\n     \\<lbrakk>Suc i < j; (if t = t' then WAIT k else ts t) = WAIT k\\<rbrakk>\n     \\<Longrightarrow> \\<exists>l\\<ge>Suc i.\n                          l < j \\<and> tts (s l) t = HOLD k;\n     i < j; c \\<le> k; k < cc (s j); t < N; ts t = WAIT k\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "by (metis \"1\"(2) Suc_leD Suc_lessI fst_conv leD)"], ["proof (state)\nthis:\n  \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n\ngoal (3 subgoals):\n 1. \\<lbrakk>ts t' = WAIT c; c' = c; n' = n; s' = HOLD c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 2. \\<And>ka.\n       \\<lbrakk>ts t' = HOLD ka; c' = c; n' = n; s' = REL ka\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 3. \\<And>ka.\n       \\<lbrakk>ts t' = REL ka; c' = ka + 1; n' = n; s' = INIT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>ts t' = WAIT c; c' = c; n' = n; s' = HOLD c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 2. \\<And>ka.\n       \\<lbrakk>ts t' = HOLD ka; c' = c; n' = n; s' = REL ka\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 3. \\<And>ka.\n       \\<lbrakk>ts t' = REL ka; c' = ka + 1; n' = n; s' = INIT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "case exit_wait"], ["proof (state)\nthis:\n  ts t' = WAIT c\n  c' = c\n  n' = n\n  s' = HOLD c\n\ngoal (3 subgoals):\n 1. \\<lbrakk>ts t' = WAIT c; c' = c; n' = n; s' = HOLD c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 2. \\<And>ka.\n       \\<lbrakk>ts t' = HOLD ka; c' = c; n' = n; s' = REL ka\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 3. \\<And>ka.\n       \\<lbrakk>ts t' = REL ka; c' = ka + 1; n' = n; s' = INIT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "then"], ["proof (chain)\npicking this:\n  ts t' = WAIT c\n  c' = c\n  n' = n\n  s' = HOLD c", "show ?thesis"], ["proof (prove)\nusing this:\n  ts t' = WAIT c\n  c' = c\n  n' = n\n  s' = HOLD c\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "apply (cases \"t'=t\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ts t' = WAIT c; c' = c; n' = n; s' = HOLD c; t' = t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 2. \\<lbrakk>ts t' = WAIT c; c' = c; n' = n; s' = HOLD c;\n     t' \\<noteq> t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts t' = WAIT c; c' = c; n' = n; s' = HOLD c; t' = t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "using Suc.prems"], ["proof (prove)\nusing this:\n  i < j\n  cc (s i) \\<le> k\n  k < cc (s j)\n  t < N\n  tts (s i) t = WAIT k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ts t' = WAIT c; c' = c; n' = n; s' = HOLD c; t' = t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts t = WAIT k; c' = k; n' = n; s' = HOLD k; t' = t; i < j;\n     k < cc (s j); t < N; c = k\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "by (metis \"1\"(2) Suc_leD Suc_lessI fst_conv fun_upd_same leD \n                less_or_eq_imp_le snd_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts t' = WAIT c; c' = c; n' = n; s' = HOLD c;\n     t' \\<noteq> t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts t' = WAIT c; c' = c; n' = n; s' = HOLD c;\n     t' \\<noteq> t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "using Suc.prems IH"], ["proof (prove)\nusing this:\n  i < j\n  cc (s i) \\<le> k\n  k < cc (s j)\n  t < N\n  tts (s i) t = WAIT k\n  \\<lbrakk>Suc i < j; cc (s (Suc i)) \\<le> k; k < cc (s j); t < N;\n   tts (s (Suc i)) t = WAIT k\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<ge>Suc i. l < j \\<and> tts (s l) t = HOLD k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ts t' = WAIT c; c' = c; n' = n; s' = HOLD c;\n     t' \\<noteq> t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts t' = WAIT c; c' = c; n' = n; s' = HOLD c; t' \\<noteq> t;\n     i < j; c \\<le> k; k < cc (s j); t < N; ts t = WAIT k;\n     Suc i < j \\<Longrightarrow>\n     \\<exists>l\\<ge>Suc i. l < j \\<and> tts (s l) t = HOLD k\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "by (metis \"1\"(2) Suc_leD Suc_lessI fst_conv leD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>ts t' = HOLD ka; c' = c; n' = n; s' = REL ka\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 2. \\<And>ka.\n       \\<lbrakk>ts t' = REL ka; c' = ka + 1; n' = n; s' = INIT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>ts t' = HOLD ka; c' = c; n' = n; s' = REL ka\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 2. \\<And>ka.\n       \\<lbrakk>ts t' = REL ka; c' = ka + 1; n' = n; s' = INIT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "case (start_release k)"], ["proof (state)\nthis:\n  ts t' = HOLD k\n  c' = c\n  n' = n\n  s' = REL k\n\ngoal (2 subgoals):\n 1. \\<And>ka.\n       \\<lbrakk>ts t' = HOLD ka; c' = c; n' = n; s' = REL ka\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 2. \\<And>ka.\n       \\<lbrakk>ts t' = REL ka; c' = ka + 1; n' = n; s' = INIT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "then"], ["proof (chain)\npicking this:\n  ts t' = HOLD k\n  c' = c\n  n' = n\n  s' = REL k", "show ?thesis"], ["proof (prove)\nusing this:\n  ts t' = HOLD k\n  c' = c\n  n' = n\n  s' = REL k\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "using IH Suc.prems"], ["proof (prove)\nusing this:\n  ts t' = HOLD k\n  c' = c\n  n' = n\n  s' = REL k\n  \\<lbrakk>Suc i < j; cc (s (Suc i)) \\<le> k; k < cc (s j); t < N;\n   tts (s (Suc i)) t = WAIT k\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<ge>Suc i. l < j \\<and> tts (s l) t = HOLD k\n  i < j\n  cc (s i) \\<le> k\n  k < cc (s j)\n  t < N\n  tts (s i) t = WAIT k\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts t' = HOLD k; c' = c; n' = n; s' = REL k;\n     \\<lbrakk>Suc i < j; (if t = t' then REL k else ts t) = WAIT k\\<rbrakk>\n     \\<Longrightarrow> \\<exists>l\\<ge>Suc i.\n                          l < j \\<and> tts (s l) t = HOLD k;\n     i < j; c \\<le> k; k < cc (s j); t < N; ts t = WAIT k\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "by (metis \"1\"(2) Suc_leD Suc_lessI fst_conv leD thread.distinct(7))"], ["proof (state)\nthis:\n  \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>ts t' = REL ka; c' = ka + 1; n' = n; s' = INIT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>ts t' = REL ka; c' = ka + 1; n' = n; s' = INIT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "case (release k)"], ["proof (state)\nthis:\n  ts t' = REL k\n  c' = k + 1\n  n' = n\n  s' = INIT\n\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>ts t' = REL ka; c' = ka + 1; n' = n; s' = INIT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "then"], ["proof (chain)\npicking this:\n  ts t' = REL k\n  c' = k + 1\n  n' = n\n  s' = INIT", "show ?thesis"], ["proof (prove)\nusing this:\n  ts t' = REL k\n  c' = k + 1\n  n' = n\n  s' = INIT\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "apply (cases \"t'=t\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ts t' = REL k; c' = k + 1; n' = n; s' = INIT; t' = t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 2. \\<lbrakk>ts t' = REL k; c' = k + 1; n' = n; s' = INIT;\n     t' \\<noteq> t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "using I1 IH Suc.prems"], ["proof (prove)\nusing this:\n  c \\<le> n \\<and>\n  (\\<forall>t k.\n      t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n      c \\<le> k \\<and>\n      k < n \\<and>\n      (\\<forall>t' k'.\n          t' < N \\<and>\n          has_ticket (ts t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n          k \\<noteq> k') \\<and>\n      (\\<forall>k.\n          k \\<noteq> c \\<longrightarrow> \\<not> locks_ticket (ts t) k))\n  \\<lbrakk>Suc i < j; cc (s (Suc i)) \\<le> k; k < cc (s j); t < N;\n   tts (s (Suc i)) t = WAIT k\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<ge>Suc i. l < j \\<and> tts (s l) t = HOLD k\n  i < j\n  cc (s i) \\<le> k\n  k < cc (s j)\n  t < N\n  tts (s i) t = WAIT k\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ts t' = REL k; c' = k + 1; n' = n; s' = INIT; t' = t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n 2. \\<lbrakk>ts t' = REL k; c' = k + 1; n' = n; s' = INIT;\n     t' \\<noteq> t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts t' = REL k; c' = Suc k; n' = n; s' = INIT; t' \\<noteq> t;\n     \\<lbrakk>Suc i < j; Suc k \\<le> k\\<rbrakk>\n     \\<Longrightarrow> \\<exists>l\\<ge>Suc i.\n                          l < j \\<and> tts (s l) t = HOLD k;\n     i < j; c \\<le> k; k < cc (s j); t < N; ts t = WAIT k; c \\<le> n;\n     \\<forall>t k.\n        t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n        c \\<le> k \\<and>\n        k < n \\<and>\n        (\\<forall>t' k'.\n            t' < N \\<and>\n            has_ticket (ts t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n            k \\<noteq> k') \\<and>\n        (\\<forall>k.\n            k \\<noteq> c \\<longrightarrow>\n            \\<not> locks_ticket (ts t) k)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k", "by (metis \"1\"(2) \"1\"(3) Suc_leD Suc_leI Suc_lessI fst_conv \n              locks_ticket_simps(4) le_antisym not_less_eq_eq \n              has_ticket_simps(2) has_ticket_simps(4))"], ["proof (state)\nthis:\n  \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>l\\<ge>i. l < j \\<and> tts (s l) t = HOLD k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma s_case_expand: \n    \"(case s of (c, n, ts) \\<Rightarrow> P c n ts) = P (cc s) (nn s) (tts s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case s of (c, n, ts) \\<Rightarrow> P c n ts) = P (cc s) (nn s) (tts s)", "by (auto split: prod.splits)"], ["", "text \\<open>\n    A version of the fairness lemma which is very detailed on the \n    actual ticket numbers. We will weaken this later.\n  \\<close>"], ["", "lemma fair_aux2:\n    assumes RUN: \"A.is_run s\"\n    assumes ACQ: \"t<N\" \"tts (s i) t=INIT\" \"tts (s (Suc i)) t=WAIT k\" \n    assumes HOLD: \"i<j\" \"tts (s j) t = HOLD k\" \n    assumes WAIT: \"t'<N\" \"tts (s i) t' = WAIT k'\" \n    obtains l where \"i<l\" \"l<j\" \"tts (s l) t' = HOLD k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>i < l; l < j; tts (s l) t' = HOLD k'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>i < l; l < j; tts (s l) t' = HOLD k'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "interpret A: run as\\<^sub>0 alstep s"], ["proof (prove)\ngoal (1 subgoal):\n 1. DF_System.run as\\<^sub>0 alstep s", "by unfold_locales fact"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>i < l; l < j; tts (s l) t' = HOLD k'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from ACQ WAIT"], ["proof (chain)\npicking this:\n  t < N\n  tts (s i) t = INIT\n  tts (s (Suc i)) t = WAIT k\n  t' < N\n  tts (s i) t' = WAIT k'", "have [simp]: \"t\\<noteq>t'\" \"t'\\<noteq>t\""], ["proof (prove)\nusing this:\n  t < N\n  tts (s i) t = INIT\n  tts (s (Suc i)) t = WAIT k\n  t' < N\n  tts (s i) t' = WAIT k'\n\ngoal (1 subgoal):\n 1. t \\<noteq> t' &&& t' \\<noteq> t", "by auto"], ["proof (state)\nthis:\n  t \\<noteq> t'\n  t' \\<noteq> t\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>i < l; l < j; tts (s l) t' = HOLD k'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from ACQ"], ["proof (chain)\npicking this:\n  t < N\n  tts (s i) t = INIT\n  tts (s (Suc i)) t = WAIT k", "have [simp]: \n      \"nn (s i) = k \\<and> nn (s (Suc i)) = Suc k \n    \\<and> cc (s (Suc i)) = cc (s i) \\<and> tts (s (Suc i)) = (tts (s i))(t:=WAIT k)\""], ["proof (prove)\nusing this:\n  t < N\n  tts (s i) t = INIT\n  tts (s (Suc i)) t = WAIT k\n\ngoal (1 subgoal):\n 1. nn (s i) = k \\<and>\n    nn (s (Suc i)) = Suc k \\<and>\n    cc (s (Suc i)) = cc (s i) \\<and>\n    tts (s (Suc i)) = (tts (s i))(t := WAIT k)", "apply (rule_tac A.stepE[of i])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>t < N; tts (s i) t = INIT; tts (s (Suc i)) t = WAIT k;\n        alstep l (s i) (s (Suc i))\\<rbrakk>\n       \\<Longrightarrow> nn (s i) = k \\<and>\n                         nn (s (Suc i)) = Suc k \\<and>\n                         cc (s (Suc i)) = cc (s i) \\<and>\n                         tts (s (Suc i)) = (tts (s i))(t := WAIT k)", "apply (erule alstep.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l c n ts c' n' s'.\n       \\<lbrakk>t < N; tts (s i) t = INIT; tts (s (Suc i)) t = WAIT k;\n        s i = (c, n, ts); s (Suc i) = (c', n', ts(l := s')); l < N;\n        astep_sng (c, n, ts l) (c', n', s')\\<rbrakk>\n       \\<Longrightarrow> nn (s i) = k \\<and>\n                         nn (s (Suc i)) = Suc k \\<and>\n                         cc (s (Suc i)) = cc (s i) \\<and>\n                         tts (s (Suc i)) = (tts (s i))(t := WAIT k)", "apply (erule astep_sng.cases)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>l c n ts c' n' s' ca na.\n       \\<lbrakk>t < N; tts (s i) t = INIT; tts (s (Suc i)) t = WAIT k;\n        s i = (c, n, ts); s (Suc i) = (c', n', ts(l := s')); l < N;\n        (c, n, ts l) = (ca, na, INIT);\n        (c', n', s') = (ca, na + 1, WAIT na)\\<rbrakk>\n       \\<Longrightarrow> nn (s i) = k \\<and>\n                         nn (s (Suc i)) = Suc k \\<and>\n                         cc (s (Suc i)) = cc (s i) \\<and>\n                         tts (s (Suc i)) = (tts (s i))(t := WAIT k)\n 2. \\<And>l c n ts c' n' s' ca ka na.\n       \\<lbrakk>t < N; tts (s i) t = INIT; tts (s (Suc i)) t = WAIT k;\n        s i = (c, n, ts); s (Suc i) = (c', n', ts(l := s')); l < N;\n        (c, n, ts l) = (ca, na, WAIT ka); (c', n', s') = (ca, na, WAIT ka);\n        ca \\<noteq> ka\\<rbrakk>\n       \\<Longrightarrow> nn (s i) = k \\<and>\n                         nn (s (Suc i)) = Suc k \\<and>\n                         cc (s (Suc i)) = cc (s i) \\<and>\n                         tts (s (Suc i)) = (tts (s i))(t := WAIT k)\n 3. \\<And>l c n ts c' n' s' ca na.\n       \\<lbrakk>t < N; tts (s i) t = INIT; tts (s (Suc i)) t = WAIT k;\n        s i = (c, n, ts); s (Suc i) = (c', n', ts(l := s')); l < N;\n        (c, n, ts l) = (ca, na, WAIT ca);\n        (c', n', s') = (ca, na, HOLD ca)\\<rbrakk>\n       \\<Longrightarrow> nn (s i) = k \\<and>\n                         nn (s (Suc i)) = Suc k \\<and>\n                         cc (s (Suc i)) = cc (s i) \\<and>\n                         tts (s (Suc i)) = (tts (s i))(t := WAIT k)\n 4. \\<And>l c n ts c' n' s' ca na ka.\n       \\<lbrakk>t < N; tts (s i) t = INIT; tts (s (Suc i)) t = WAIT k;\n        s i = (c, n, ts); s (Suc i) = (c', n', ts(l := s')); l < N;\n        (c, n, ts l) = (ca, na, HOLD ka);\n        (c', n', s') = (ca, na, REL ka)\\<rbrakk>\n       \\<Longrightarrow> nn (s i) = k \\<and>\n                         nn (s (Suc i)) = Suc k \\<and>\n                         cc (s (Suc i)) = cc (s i) \\<and>\n                         tts (s (Suc i)) = (tts (s i))(t := WAIT k)\n 5. \\<And>l c n ts c' n' s' ca na ka.\n       \\<lbrakk>t < N; tts (s i) t = INIT; tts (s (Suc i)) t = WAIT k;\n        s i = (c, n, ts); s (Suc i) = (c', n', ts(l := s')); l < N;\n        (c, n, ts l) = (ca, na, REL ka);\n        (c', n', s') = (ka + 1, na, INIT)\\<rbrakk>\n       \\<Longrightarrow> nn (s i) = k \\<and>\n                         nn (s (Suc i)) = Suc k \\<and>\n                         cc (s (Suc i)) = cc (s i) \\<and>\n                         tts (s (Suc i)) = (tts (s i))(t := WAIT k)", "by (auto simp: nth_list_update split: if_splits)"], ["proof (state)\nthis:\n  nn (s i) = k \\<and>\n  nn (s (Suc i)) = Suc k \\<and>\n  cc (s (Suc i)) = cc (s i) \\<and>\n  tts (s (Suc i)) = (tts (s i))(t := WAIT k)\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>i < l; l < j; tts (s l) t' = HOLD k'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from A.run_invar[OF is_invar1, of i]"], ["proof (chain)\npicking this:\n  invar1 (s i)", "have \"invar1 (s i)\""], ["proof (prove)\nusing this:\n  invar1 (s i)\n\ngoal (1 subgoal):\n 1. invar1 (s i)", "by auto"], ["proof (state)\nthis:\n  invar1 (s i)\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>i < l; l < j; tts (s l) t' = HOLD k'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "note I1 = this[unfolded invar1_def, unfolded s_case_expand, simplified]"], ["proof (state)\nthis:\n  cc (s i) \\<le> k \\<and>\n  (\\<forall>t ka.\n      t < N \\<and> has_ticket (tts (s i) t) ka \\<longrightarrow>\n      cc (s i) \\<le> ka \\<and>\n      ka < k \\<and>\n      (\\<forall>t' k'.\n          t' < N \\<and>\n          has_ticket (tts (s i) t') k' \\<and>\n          t \\<noteq> t' \\<longrightarrow>\n          ka \\<noteq> k') \\<and>\n      (\\<forall>k.\n          k \\<noteq> cc (s i) \\<longrightarrow>\n          \\<not> locks_ticket (tts (s i) t) k))\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>i < l; l < j; tts (s l) t' = HOLD k'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from WAIT I1"], ["proof (chain)\npicking this:\n  t' < N\n  tts (s i) t' = WAIT k'\n  cc (s i) \\<le> k \\<and>\n  (\\<forall>t ka.\n      t < N \\<and> has_ticket (tts (s i) t) ka \\<longrightarrow>\n      cc (s i) \\<le> ka \\<and>\n      ka < k \\<and>\n      (\\<forall>t' k'.\n          t' < N \\<and>\n          has_ticket (tts (s i) t') k' \\<and>\n          t \\<noteq> t' \\<longrightarrow>\n          ka \\<noteq> k') \\<and>\n      (\\<forall>k.\n          k \\<noteq> cc (s i) \\<longrightarrow>\n          \\<not> locks_ticket (tts (s i) t) k))", "have \"k' < k\""], ["proof (prove)\nusing this:\n  t' < N\n  tts (s i) t' = WAIT k'\n  cc (s i) \\<le> k \\<and>\n  (\\<forall>t ka.\n      t < N \\<and> has_ticket (tts (s i) t) ka \\<longrightarrow>\n      cc (s i) \\<le> ka \\<and>\n      ka < k \\<and>\n      (\\<forall>t' k'.\n          t' < N \\<and>\n          has_ticket (tts (s i) t') k' \\<and>\n          t \\<noteq> t' \\<longrightarrow>\n          ka \\<noteq> k') \\<and>\n      (\\<forall>k.\n          k \\<noteq> cc (s i) \\<longrightarrow>\n          \\<not> locks_ticket (tts (s i) t) k))\n\ngoal (1 subgoal):\n 1. k' < k", "by fastforce"], ["proof (state)\nthis:\n  k' < k\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>i < l; l < j; tts (s l) t' = HOLD k'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from ACQ HOLD"], ["proof (chain)\npicking this:\n  t < N\n  tts (s i) t = INIT\n  tts (s (Suc i)) t = WAIT k\n  i < j\n  tts (s j) t = HOLD k", "have \"Suc i \\<noteq> j\""], ["proof (prove)\nusing this:\n  t < N\n  tts (s i) t = INIT\n  tts (s (Suc i)) t = WAIT k\n  i < j\n  tts (s j) t = HOLD k\n\ngoal (1 subgoal):\n 1. Suc i \\<noteq> j", "by auto"], ["proof (state)\nthis:\n  Suc i \\<noteq> j\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>i < l; l < j; tts (s l) t' = HOLD k'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with HOLD"], ["proof (chain)\npicking this:\n  i < j\n  tts (s j) t = HOLD k\n  Suc i \\<noteq> j", "have \"Suc i < j\""], ["proof (prove)\nusing this:\n  i < j\n  tts (s j) t = HOLD k\n  Suc i \\<noteq> j\n\ngoal (1 subgoal):\n 1. Suc i < j", "by auto"], ["proof (state)\nthis:\n  Suc i < j\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>i < l; l < j; tts (s l) t' = HOLD k'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have X1: \"cc (s i) \\<le> k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cc (s i) \\<le> k'", "using I1 WAIT"], ["proof (prove)\nusing this:\n  cc (s i) \\<le> k \\<and>\n  (\\<forall>t ka.\n      t < N \\<and> has_ticket (tts (s i) t) ka \\<longrightarrow>\n      cc (s i) \\<le> ka \\<and>\n      ka < k \\<and>\n      (\\<forall>t' k'.\n          t' < N \\<and>\n          has_ticket (tts (s i) t') k' \\<and>\n          t \\<noteq> t' \\<longrightarrow>\n          ka \\<noteq> k') \\<and>\n      (\\<forall>k.\n          k \\<noteq> cc (s i) \\<longrightarrow>\n          \\<not> locks_ticket (tts (s i) t) k))\n  t' < N\n  tts (s i) t' = WAIT k'\n\ngoal (1 subgoal):\n 1. cc (s i) \\<le> k'", "by fastforce"], ["proof (state)\nthis:\n  cc (s i) \\<le> k'\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>i < l; l < j; tts (s l) t' = HOLD k'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have X2: \"k' < cc (s j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k' < cc (s j)", "using A.run_invar[OF is_invar1, of j, unfolded invar1_def s_case_expand]"], ["proof (prove)\nusing this:\n  cc (s j) \\<le> nn (s j) \\<and>\n  (\\<forall>t k.\n      t < N \\<and> has_ticket (tts (s j) t) k \\<longrightarrow>\n      cc (s j) \\<le> k \\<and>\n      k < nn (s j) \\<and>\n      (\\<forall>t' k'.\n          t' < N \\<and>\n          has_ticket (tts (s j) t') k' \\<and>\n          t \\<noteq> t' \\<longrightarrow>\n          k \\<noteq> k') \\<and>\n      (\\<forall>k.\n          k \\<noteq> cc (s j) \\<longrightarrow>\n          \\<not> locks_ticket (tts (s j) t) k))\n\ngoal (1 subgoal):\n 1. k' < cc (s j)", "using \\<open>k' < k\\<close> \\<open>t<N\\<close> HOLD(2)"], ["proof (prove)\nusing this:\n  cc (s j) \\<le> nn (s j) \\<and>\n  (\\<forall>t k.\n      t < N \\<and> has_ticket (tts (s j) t) k \\<longrightarrow>\n      cc (s j) \\<le> k \\<and>\n      k < nn (s j) \\<and>\n      (\\<forall>t' k'.\n          t' < N \\<and>\n          has_ticket (tts (s j) t') k' \\<and>\n          t \\<noteq> t' \\<longrightarrow>\n          k \\<noteq> k') \\<and>\n      (\\<forall>k.\n          k \\<noteq> cc (s j) \\<longrightarrow>\n          \\<not> locks_ticket (tts (s j) t) k))\n  k' < k\n  t < N\n  tts (s j) t = HOLD k\n\ngoal (1 subgoal):\n 1. k' < cc (s j)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k' < k; t < N; tts (s j) t = HOLD k; cc (s j) \\<le> nn (s j);\n     \\<forall>t k.\n        t < N \\<and> has_ticket (tts (s j) t) k \\<longrightarrow>\n        cc (s j) \\<le> k \\<and>\n        k < nn (s j) \\<and>\n        (\\<forall>t' k'.\n            t' < N \\<and>\n            has_ticket (tts (s j) t') k' \\<and>\n            t \\<noteq> t' \\<longrightarrow>\n            k \\<noteq> k') \\<and>\n        (\\<forall>k.\n            k \\<noteq> cc (s j) \\<longrightarrow>\n            \\<not> locks_ticket (tts (s j) t) k)\\<rbrakk>\n    \\<Longrightarrow> k' < cc (s j)", "by (metis locks_ticket_simps(3) has_ticket_simps(3))"], ["proof (state)\nthis:\n  k' < cc (s j)\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>i < l; l < j; tts (s l) t' = HOLD k'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from fair_aux[OF RUN \\<open>Suc i < j\\<close>, of k' t', simplified]"], ["proof (chain)\npicking this:\n  \\<lbrakk>cc (s i) \\<le> k'; k' < cc (s j); t' < N;\n   tts (s i) t' = WAIT k'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<ge>Suc i.\n                       l < j \\<and> tts (s l) t' = HOLD k'", "obtain l where\n      \"l\\<ge>Suc i\" \"l<j\" \"tts (s l) t' = HOLD k'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>cc (s i) \\<le> k'; k' < cc (s j); t' < N;\n   tts (s i) t' = WAIT k'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<ge>Suc i.\n                       l < j \\<and> tts (s l) t' = HOLD k'\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>Suc i \\<le> l; l < j; tts (s l) t' = HOLD k'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using WAIT X1 X2"], ["proof (prove)\nusing this:\n  \\<lbrakk>cc (s i) \\<le> k'; k' < cc (s j); t' < N;\n   tts (s i) t' = WAIT k'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l\\<ge>Suc i.\n                       l < j \\<and> tts (s l) t' = HOLD k'\n  t' < N\n  tts (s i) t' = WAIT k'\n  cc (s i) \\<le> k'\n  k' < cc (s j)\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>Suc i \\<le> l; l < j; tts (s l) t' = HOLD k'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Suc i \\<le> l\n  l < j\n  tts (s l) t' = HOLD k'\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>i < l; l < j; tts (s l) t' = HOLD k'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  Suc i \\<le> l\n  l < j\n  tts (s l) t' = HOLD k'\n\ngoal (1 subgoal):\n 1. thesis", "apply (rule_tac that[of l])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>Suc i \\<le> l; l < j; tts (s l) t' = HOLD k'\\<rbrakk>\n    \\<Longrightarrow> i < l\n 2. \\<lbrakk>Suc i \\<le> l; l < j; tts (s l) t' = HOLD k'\\<rbrakk>\n    \\<Longrightarrow> l < j\n 3. \\<lbrakk>Suc i \\<le> l; l < j; tts (s l) t' = HOLD k'\\<rbrakk>\n    \\<Longrightarrow> tts (s l) t' = HOLD k'", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_hold_position:\n    assumes RUN: \"A.is_run s\"\n    assumes WAIT: \"t<N\" \"tts (s i) t = WAIT tk\"\n    assumes NWAIT: \"i<j\" \"tts (s j) t \\<noteq> WAIT tk\"\n    obtains l where \"i<l\" \"l\\<le>j\" \"tts (s l) t = HOLD tk\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>i < l; l \\<le> j; tts (s l) t = HOLD tk\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>i < l; l \\<le> j; tts (s l) t = HOLD tk\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "interpret A: run as\\<^sub>0 alstep s"], ["proof (prove)\ngoal (1 subgoal):\n 1. DF_System.run as\\<^sub>0 alstep s", "by unfold_locales fact"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>i < l; l \\<le> j; tts (s l) t = HOLD tk\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from WAIT(2) NWAIT"], ["proof (chain)\npicking this:\n  tts (s i) t = WAIT tk\n  i < j\n  tts (s j) t \\<noteq> WAIT tk", "have \"\\<exists>l. i<l \\<and> l\\<le>j \\<and> tts (s l) t = HOLD tk\""], ["proof (prove)\nusing this:\n  tts (s i) t = WAIT tk\n  i < j\n  tts (s j) t \\<noteq> WAIT tk\n\ngoal (1 subgoal):\n 1. \\<exists>l>i. l \\<le> j \\<and> tts (s l) t = HOLD tk", "proof (induction \"j-i\" arbitrary: i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>0 = j - i; tts (s i) t = WAIT tk; i < j;\n        tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 2. \\<And>x i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>x = j - i; tts (s i) t = WAIT tk; i < j;\n                    tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l>i.\n  l \\<le> j \\<and> tts (s l) t = HOLD tk;\n        Suc x = j - i; tts (s i) t = WAIT tk; i < j;\n        tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk", "case 0"], ["proof (state)\nthis:\n  0 = j - i\n  tts (s i) t = WAIT tk\n  i < j\n  tts (s j) t \\<noteq> WAIT tk\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>0 = j - i; tts (s i) t = WAIT tk; i < j;\n        tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 2. \\<And>x i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>x = j - i; tts (s i) t = WAIT tk; i < j;\n                    tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l>i.\n  l \\<le> j \\<and> tts (s l) t = HOLD tk;\n        Suc x = j - i; tts (s i) t = WAIT tk; i < j;\n        tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk", "then"], ["proof (chain)\npicking this:\n  0 = j - i\n  tts (s i) t = WAIT tk\n  i < j\n  tts (s j) t \\<noteq> WAIT tk", "show ?case"], ["proof (prove)\nusing this:\n  0 = j - i\n  tts (s i) t = WAIT tk\n  i < j\n  tts (s j) t \\<noteq> WAIT tk\n\ngoal (1 subgoal):\n 1. \\<exists>l>i. l \\<le> j \\<and> tts (s l) t = HOLD tk", "by auto"], ["proof (state)\nthis:\n  \\<exists>l>i. l \\<le> j \\<and> tts (s l) t = HOLD tk\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>x = j - i; tts (s i) t = WAIT tk; i < j;\n                    tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l>i.\n  l \\<le> j \\<and> tts (s l) t = HOLD tk;\n        Suc x = j - i; tts (s i) t = WAIT tk; i < j;\n        tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>x = j - i; tts (s i) t = WAIT tk; i < j;\n                    tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l>i.\n  l \\<le> j \\<and> tts (s l) t = HOLD tk;\n        Suc x = j - i; tts (s i) t = WAIT tk; i < j;\n        tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk", "case (Suc i')"], ["proof (state)\nthis:\n  \\<lbrakk>i' = j - ?i; tts (s ?i) t = WAIT tk; ?i < j;\n   tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l>?i. l \\<le> j \\<and> tts (s l) t = HOLD tk\n  Suc i' = j - i\n  tts (s i) t = WAIT tk\n  i < j\n  tts (s j) t \\<noteq> WAIT tk\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>x = j - i; tts (s i) t = WAIT tk; i < j;\n                    tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l>i.\n  l \\<le> j \\<and> tts (s l) t = HOLD tk;\n        Suc x = j - i; tts (s i) t = WAIT tk; i < j;\n        tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk", "hence [simp]: \"i'=j - Suc i\""], ["proof (prove)\nusing this:\n  \\<lbrakk>i' = j - ?i; tts (s ?i) t = WAIT tk; ?i < j;\n   tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l>?i. l \\<le> j \\<and> tts (s l) t = HOLD tk\n  Suc i' = j - i\n  tts (s i) t = WAIT tk\n  i < j\n  tts (s j) t \\<noteq> WAIT tk\n\ngoal (1 subgoal):\n 1. i' = j - Suc i", "by auto"], ["proof (state)\nthis:\n  i' = j - Suc i\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>x = j - i; tts (s i) t = WAIT tk; i < j;\n                    tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l>i.\n  l \\<le> j \\<and> tts (s l) t = HOLD tk;\n        Suc x = j - i; tts (s i) t = WAIT tk; i < j;\n        tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk", "note IH=Suc.hyps(1)[OF this]"], ["proof (state)\nthis:\n  \\<lbrakk>tts (s (Suc i)) t = WAIT tk; Suc i < j;\n   tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l>Suc i. l \\<le> j \\<and> tts (s l) t = HOLD tk\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>x = j - i; tts (s i) t = WAIT tk; i < j;\n                    tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l>i.\n  l \\<le> j \\<and> tts (s l) t = HOLD tk;\n        Suc x = j - i; tts (s i) t = WAIT tk; i < j;\n        tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk", "obtain t' where \"alstep t' (s i) (s (Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        alstep t' (s i) (s (Suc i)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule A.stepE)"], ["proof (state)\nthis:\n  alstep t' (s i) (s (Suc i))\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>x = j - i; tts (s i) t = WAIT tk; i < j;\n                    tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>l>i.\n  l \\<le> j \\<and> tts (s l) t = HOLD tk;\n        Suc x = j - i; tts (s i) t = WAIT tk; i < j;\n        tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk", "then"], ["proof (chain)\npicking this:\n  alstep t' (s i) (s (Suc i))", "show ?case"], ["proof (prove)\nusing this:\n  alstep t' (s i) (s (Suc i))\n\ngoal (1 subgoal):\n 1. \\<exists>l>i. l \\<le> j \\<and> tts (s l) t = HOLD tk", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. alstep t' (s i) (s (Suc i)) \\<Longrightarrow>\n    \\<exists>l>i. l \\<le> j \\<and> tts (s l) t = HOLD tk", "apply (cases \"t=t'\";erule alstep.cases; erule astep_sng.cases)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>c n ts c' n' s' ca na.\n       \\<lbrakk>t = t'; s i = (c, n, ts);\n        s (Suc i) = (c', n', ts(t' := s')); t' < N;\n        (c, n, ts t') = (ca, na, INIT);\n        (c', n', s') = (ca, na + 1, WAIT na)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 2. \\<And>c n ts c' n' s' ca k na.\n       \\<lbrakk>t = t'; s i = (c, n, ts);\n        s (Suc i) = (c', n', ts(t' := s')); t' < N;\n        (c, n, ts t') = (ca, na, WAIT k); (c', n', s') = (ca, na, WAIT k);\n        ca \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 3. \\<And>c n ts c' n' s' ca na.\n       \\<lbrakk>t = t'; s i = (c, n, ts);\n        s (Suc i) = (c', n', ts(t' := s')); t' < N;\n        (c, n, ts t') = (ca, na, WAIT ca);\n        (c', n', s') = (ca, na, HOLD ca)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 4. \\<And>c n ts c' n' s' ca na k.\n       \\<lbrakk>t = t'; s i = (c, n, ts);\n        s (Suc i) = (c', n', ts(t' := s')); t' < N;\n        (c, n, ts t') = (ca, na, HOLD k);\n        (c', n', s') = (ca, na, REL k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 5. \\<And>c n ts c' n' s' ca na k.\n       \\<lbrakk>t = t'; s i = (c, n, ts);\n        s (Suc i) = (c', n', ts(t' := s')); t' < N;\n        (c, n, ts t') = (ca, na, REL k);\n        (c', n', s') = (k + 1, na, INIT)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 6. \\<And>c n ts c' n' s' ca na.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (c', n', ts(t' := s')); t' < N;\n        (c, n, ts t') = (ca, na, INIT);\n        (c', n', s') = (ca, na + 1, WAIT na)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 7. \\<And>c n ts c' n' s' ca k na.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (c', n', ts(t' := s')); t' < N;\n        (c, n, ts t') = (ca, na, WAIT k); (c', n', s') = (ca, na, WAIT k);\n        ca \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 8. \\<And>c n ts c' n' s' ca na.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (c', n', ts(t' := s')); t' < N;\n        (c, n, ts t') = (ca, na, WAIT ca);\n        (c', n', s') = (ca, na, HOLD ca)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 9. \\<And>c n ts c' n' s' ca na k.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (c', n', ts(t' := s')); t' < N;\n        (c, n, ts t') = (ca, na, HOLD k);\n        (c', n', s') = (ca, na, REL k)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 10. \\<And>c n ts c' n' s' ca na k.\n        \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n         s (Suc i) = (c', n', ts(t' := s')); t' < N;\n         (c, n, ts t') = (ca, na, REL k);\n         (c', n', s') = (k + 1, na, INIT)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l>i.\n                             l \\<le> j \\<and> tts (s l) t = HOLD tk", "apply auto"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>c n ts.\n       \\<lbrakk>t = t'; s i = (c, n, ts);\n        s (Suc i) = (c, Suc n, ts(t' := WAIT n)); t' < N;\n        ts t' = INIT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t' = HOLD tk\n 2. \\<And>c n ts k.\n       \\<lbrakk>t = t'; s i = (c, n, ts);\n        s (Suc i) = (c, n, ts(t' := WAIT k)); t' < N; ts t' = WAIT k;\n        c \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t' = HOLD tk\n 3. \\<And>c n ts.\n       \\<lbrakk>t = t'; s i = (c, n, ts);\n        s (Suc i) = (c, n, ts(t' := HOLD c)); t' < N;\n        ts t' = WAIT c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t' = HOLD tk\n 4. \\<And>c n ts k.\n       \\<lbrakk>t = t'; s i = (c, n, ts);\n        s (Suc i) = (c, n, ts(t' := REL k)); t' < N; ts t' = HOLD k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t' = HOLD tk\n 5. \\<And>c n ts k.\n       \\<lbrakk>t = t'; s i = (c, n, ts);\n        s (Suc i) = (Suc k, n, ts(t' := INIT)); t' < N;\n        ts t' = REL k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t' = HOLD tk\n 6. \\<And>c n ts.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (c, Suc n, ts(t' := WAIT n)); t' < N;\n        ts t' = INIT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 7. \\<And>c n ts k.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (c, n, ts(t' := WAIT k)); t' < N; ts t' = WAIT k;\n        c \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 8. \\<And>c n ts.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (c, n, ts(t' := HOLD c)); t' < N;\n        ts t' = WAIT c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 9. \\<And>c n ts k.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (c, n, ts(t' := REL k)); t' < N; ts t' = HOLD k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 10. \\<And>c n ts k.\n        \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n         s (Suc i) = (Suc k, n, ts(t' := INIT)); t' < N;\n         ts t' = REL k\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l>i.\n                             l \\<le> j \\<and> tts (s l) t = HOLD tk", "using IH Suc.prems Suc.hyps(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>tts (s (Suc i)) t = WAIT tk; Suc i < j;\n   tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n  \\<Longrightarrow> \\<exists>l>Suc i. l \\<le> j \\<and> tts (s l) t = HOLD tk\n  tts (s i) t = WAIT tk\n  i < j\n  tts (s j) t \\<noteq> WAIT tk\n  Suc i' = j - i\n\ngoal (10 subgoals):\n 1. \\<And>c n ts.\n       \\<lbrakk>t = t'; s i = (c, n, ts);\n        s (Suc i) = (c, Suc n, ts(t' := WAIT n)); t' < N;\n        ts t' = INIT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t' = HOLD tk\n 2. \\<And>c n ts k.\n       \\<lbrakk>t = t'; s i = (c, n, ts);\n        s (Suc i) = (c, n, ts(t' := WAIT k)); t' < N; ts t' = WAIT k;\n        c \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t' = HOLD tk\n 3. \\<And>c n ts.\n       \\<lbrakk>t = t'; s i = (c, n, ts);\n        s (Suc i) = (c, n, ts(t' := HOLD c)); t' < N;\n        ts t' = WAIT c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t' = HOLD tk\n 4. \\<And>c n ts k.\n       \\<lbrakk>t = t'; s i = (c, n, ts);\n        s (Suc i) = (c, n, ts(t' := REL k)); t' < N; ts t' = HOLD k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t' = HOLD tk\n 5. \\<And>c n ts k.\n       \\<lbrakk>t = t'; s i = (c, n, ts);\n        s (Suc i) = (Suc k, n, ts(t' := INIT)); t' < N;\n        ts t' = REL k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t' = HOLD tk\n 6. \\<And>c n ts.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (c, Suc n, ts(t' := WAIT n)); t' < N;\n        ts t' = INIT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 7. \\<And>c n ts k.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (c, n, ts(t' := WAIT k)); t' < N; ts t' = WAIT k;\n        c \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 8. \\<And>c n ts.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (c, n, ts(t' := HOLD c)); t' < N;\n        ts t' = WAIT c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 9. \\<And>c n ts k.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (c, n, ts(t' := REL k)); t' < N; ts t' = HOLD k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 10. \\<And>c n ts k.\n        \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n         s (Suc i) = (Suc k, n, ts(t' := INIT)); t' < N;\n         ts t' = REL k\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l>i.\n                             l \\<le> j \\<and> tts (s l) t = HOLD tk", "apply (auto)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>c n ts.\n       \\<lbrakk>t = t'; s i = (c, n, ts);\n        s (Suc i) = (c, n, ts(t' := WAIT tk)); t' < N; ts t' = WAIT tk;\n        c \\<noteq> tk;\n        Suc i < j \\<Longrightarrow>\n        \\<exists>l>Suc i. l \\<le> j \\<and> tts (s l) t' = HOLD tk;\n        i < j; tts (s j) t' \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t' = HOLD tk\n 2. \\<And>c n ts.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (c, Suc n, ts(t' := WAIT n)); t' < N; ts t' = INIT;\n        Suc i < j \\<Longrightarrow>\n        \\<exists>l>Suc i. l \\<le> j \\<and> tts (s l) t = HOLD tk;\n        ts t = WAIT tk; i < j; tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 3. \\<And>c n ts k.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (c, n, ts(t' := WAIT k)); t' < N; ts t' = WAIT k;\n        c \\<noteq> k;\n        Suc i < j \\<Longrightarrow>\n        \\<exists>l>Suc i. l \\<le> j \\<and> tts (s l) t = HOLD tk;\n        ts t = WAIT tk; i < j; tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 4. \\<And>c n ts.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (c, n, ts(t' := HOLD c)); t' < N; ts t' = WAIT c;\n        Suc i < j \\<Longrightarrow>\n        \\<exists>l>Suc i. l \\<le> j \\<and> tts (s l) t = HOLD tk;\n        ts t = WAIT tk; i < j; tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 5. \\<And>c n ts k.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (c, n, ts(t' := REL k)); t' < N; ts t' = HOLD k;\n        Suc i < j \\<Longrightarrow>\n        \\<exists>l>Suc i. l \\<le> j \\<and> tts (s l) t = HOLD tk;\n        ts t = WAIT tk; i < j; tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 6. \\<And>c n ts k.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (Suc k, n, ts(t' := INIT)); t' < N; ts t' = REL k;\n        Suc i < j \\<Longrightarrow>\n        \\<exists>l>Suc i. l \\<le> j \\<and> tts (s l) t = HOLD tk;\n        ts t = WAIT tk; i < j; tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk", "apply (metis Suc_lessD Suc_lessI fun_upd_same snd_conv)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>c n ts.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (c, Suc n, ts(t' := WAIT n)); t' < N; ts t' = INIT;\n        Suc i < j \\<Longrightarrow>\n        \\<exists>l>Suc i. l \\<le> j \\<and> tts (s l) t = HOLD tk;\n        ts t = WAIT tk; i < j; tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 2. \\<And>c n ts k.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (c, n, ts(t' := WAIT k)); t' < N; ts t' = WAIT k;\n        c \\<noteq> k;\n        Suc i < j \\<Longrightarrow>\n        \\<exists>l>Suc i. l \\<le> j \\<and> tts (s l) t = HOLD tk;\n        ts t = WAIT tk; i < j; tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 3. \\<And>c n ts.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (c, n, ts(t' := HOLD c)); t' < N; ts t' = WAIT c;\n        Suc i < j \\<Longrightarrow>\n        \\<exists>l>Suc i. l \\<le> j \\<and> tts (s l) t = HOLD tk;\n        ts t = WAIT tk; i < j; tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 4. \\<And>c n ts k.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (c, n, ts(t' := REL k)); t' < N; ts t' = HOLD k;\n        Suc i < j \\<Longrightarrow>\n        \\<exists>l>Suc i. l \\<le> j \\<and> tts (s l) t = HOLD tk;\n        ts t = WAIT tk; i < j; tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 5. \\<And>c n ts k.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (Suc k, n, ts(t' := INIT)); t' < N; ts t' = REL k;\n        Suc i < j \\<Longrightarrow>\n        \\<exists>l>Suc i. l \\<le> j \\<and> tts (s l) t = HOLD tk;\n        ts t = WAIT tk; i < j; tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk", "apply (metis Suc_lessD Suc_lessI fun_upd_other snd_conv)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>c n ts k.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (c, n, ts(t' := WAIT k)); t' < N; ts t' = WAIT k;\n        c \\<noteq> k;\n        Suc i < j \\<Longrightarrow>\n        \\<exists>l>Suc i. l \\<le> j \\<and> tts (s l) t = HOLD tk;\n        ts t = WAIT tk; i < j; tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 2. \\<And>c n ts.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (c, n, ts(t' := HOLD c)); t' < N; ts t' = WAIT c;\n        Suc i < j \\<Longrightarrow>\n        \\<exists>l>Suc i. l \\<le> j \\<and> tts (s l) t = HOLD tk;\n        ts t = WAIT tk; i < j; tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 3. \\<And>c n ts k.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (c, n, ts(t' := REL k)); t' < N; ts t' = HOLD k;\n        Suc i < j \\<Longrightarrow>\n        \\<exists>l>Suc i. l \\<le> j \\<and> tts (s l) t = HOLD tk;\n        ts t = WAIT tk; i < j; tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 4. \\<And>c n ts k.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (Suc k, n, ts(t' := INIT)); t' < N; ts t' = REL k;\n        Suc i < j \\<Longrightarrow>\n        \\<exists>l>Suc i. l \\<le> j \\<and> tts (s l) t = HOLD tk;\n        ts t = WAIT tk; i < j; tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk", "apply (metis Suc.prems(1) Suc_lessD Suc_lessI fun_upd_triv)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>c n ts.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (c, n, ts(t' := HOLD c)); t' < N; ts t' = WAIT c;\n        Suc i < j \\<Longrightarrow>\n        \\<exists>l>Suc i. l \\<le> j \\<and> tts (s l) t = HOLD tk;\n        ts t = WAIT tk; i < j; tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 2. \\<And>c n ts k.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (c, n, ts(t' := REL k)); t' < N; ts t' = HOLD k;\n        Suc i < j \\<Longrightarrow>\n        \\<exists>l>Suc i. l \\<le> j \\<and> tts (s l) t = HOLD tk;\n        ts t = WAIT tk; i < j; tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 3. \\<And>c n ts k.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (Suc k, n, ts(t' := INIT)); t' < N; ts t' = REL k;\n        Suc i < j \\<Longrightarrow>\n        \\<exists>l>Suc i. l \\<le> j \\<and> tts (s l) t = HOLD tk;\n        ts t = WAIT tk; i < j; tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk", "apply (metis Suc_lessD Suc_lessI fun_upd_other snd_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c n ts k.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (c, n, ts(t' := REL k)); t' < N; ts t' = HOLD k;\n        Suc i < j \\<Longrightarrow>\n        \\<exists>l>Suc i. l \\<le> j \\<and> tts (s l) t = HOLD tk;\n        ts t = WAIT tk; i < j; tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk\n 2. \\<And>c n ts k.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (Suc k, n, ts(t' := INIT)); t' < N; ts t' = REL k;\n        Suc i < j \\<Longrightarrow>\n        \\<exists>l>Suc i. l \\<le> j \\<and> tts (s l) t = HOLD tk;\n        ts t = WAIT tk; i < j; tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk", "apply (metis Suc_lessD Suc_lessI fun_upd_other snd_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c n ts k.\n       \\<lbrakk>t \\<noteq> t'; s i = (c, n, ts);\n        s (Suc i) = (Suc k, n, ts(t' := INIT)); t' < N; ts t' = REL k;\n        Suc i < j \\<Longrightarrow>\n        \\<exists>l>Suc i. l \\<le> j \\<and> tts (s l) t = HOLD tk;\n        ts t = WAIT tk; i < j; tts (s j) t \\<noteq> WAIT tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l>i.\n                            l \\<le> j \\<and> tts (s l) t = HOLD tk", "apply (metis Suc_lessD Suc_lessI fun_upd_other snd_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>l>i. l \\<le> j \\<and> tts (s l) t = HOLD tk\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>l>i. l \\<le> j \\<and> tts (s l) t = HOLD tk\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>i < l; l \\<le> j; tts (s l) t = HOLD tk\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>l>i. l \\<le> j \\<and> tts (s l) t = HOLD tk\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  \\<exists>l>i. l \\<le> j \\<and> tts (s l) t = HOLD tk\n  \\<lbrakk>i < ?l; ?l \\<le> j; tts (s ?l) t = HOLD tk\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n    Finally we can show fairness, which we state as follows:\n      Whenever a thread \\<open>t\\<close> gets a ticket, all other threads \\<open>t'\\<close> waiting for the lock\n      will be granted the lock before \\<open>t\\<close>.\n  \\<close>"], ["", "theorem fair:\n    assumes RUN: \"A.is_run s\"\n    assumes ACQ: \"t<N\" \"tts (s i) t=INIT\" \"is_WAIT (tts (s (Suc i)) t)\" \n      \\<comment> \\<open>Thread \\<open>t\\<close> calls \\<open>acquire\\<close> in step \\<open>i\\<close>\\<close>\n    assumes HOLD: \"i<j\" \"is_HOLD (tts (s j) t)\" \n      \\<comment> \\<open>Thread \\<open>t\\<close> holds lock in step \\<open>j\\<close>\\<close>\n    assumes WAIT: \"t'<N\" \"is_WAIT (tts (s i) t')\" \n      \\<comment> \\<open>Thread \\<open>t'\\<close> waits for lock at step \\<open>i\\<close>\\<close>\n    obtains l where \"i<l\" \"l<j\" \"is_HOLD (tts (s l) t')\" \n      \\<comment> \\<open>Then, \\<open>t'\\<close> gets lock earlier\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>i < l; l < j; is_HOLD (tts (s l) t')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>i < l; l < j; is_HOLD (tts (s l) t')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain k where Wk: \"tts (s (Suc i)) t = WAIT k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        tts (s (Suc i)) t = WAIT k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ACQ"], ["proof (prove)\nusing this:\n  t < N\n  tts (s i) t = INIT\n  is_WAIT (tts (s (Suc i)) t)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        tts (s (Suc i)) t = WAIT k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"tts (s (Suc i)) t\") auto"], ["proof (state)\nthis:\n  tts (s (Suc i)) t = WAIT k\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>i < l; l < j; is_HOLD (tts (s l) t')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain k' where Wk': \"tts (s i) t' = WAIT k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        tts (s i) t' = WAIT k' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using WAIT"], ["proof (prove)\nusing this:\n  t' < N\n  is_WAIT (tts (s i) t')\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        tts (s i) t' = WAIT k' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"tts (s i) t'\") auto"], ["proof (state)\nthis:\n  tts (s i) t' = WAIT k'\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>i < l; l < j; is_HOLD (tts (s l) t')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from ACQ HOLD"], ["proof (chain)\npicking this:\n  t < N\n  tts (s i) t = INIT\n  is_WAIT (tts (s (Suc i)) t)\n  i < j\n  is_HOLD (tts (s j) t)", "have \"Suc i \\<noteq> j\""], ["proof (prove)\nusing this:\n  t < N\n  tts (s i) t = INIT\n  is_WAIT (tts (s (Suc i)) t)\n  i < j\n  is_HOLD (tts (s j) t)\n\ngoal (1 subgoal):\n 1. Suc i \\<noteq> j", "by auto"], ["proof (state)\nthis:\n  Suc i \\<noteq> j\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>i < l; l < j; is_HOLD (tts (s l) t')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with HOLD"], ["proof (chain)\npicking this:\n  i < j\n  is_HOLD (tts (s j) t)\n  Suc i \\<noteq> j", "have \"Suc i < j\""], ["proof (prove)\nusing this:\n  i < j\n  is_HOLD (tts (s j) t)\n  Suc i \\<noteq> j\n\ngoal (1 subgoal):\n 1. Suc i < j", "by auto"], ["proof (state)\nthis:\n  Suc i < j\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>i < l; l < j; is_HOLD (tts (s l) t')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain j' where H': \"Suc i < j'\" \"j' \\<le> j\" \"tts (s j') t = HOLD k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j'.\n        \\<lbrakk>Suc i < j'; j' \\<le> j; tts (s j') t = HOLD k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (rule find_hold_position[OF RUN \\<open>t<N\\<close> Wk \\<open>Suc i < j\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>j'.\n        \\<lbrakk>Suc i < j'; j' \\<le> j; tts (s j') t = HOLD k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    tts (s j) t \\<noteq> WAIT k\n 2. \\<And>l.\n       \\<lbrakk>\\<And>j'.\n                   \\<lbrakk>Suc i < j'; j' \\<le> j;\n                    tts (s j') t = HOLD k\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Suc i < l; l \\<le> j; tts (s l) t = HOLD k\\<rbrakk>\n       \\<Longrightarrow> thesis", "using HOLD(2)"], ["proof (prove)\nusing this:\n  is_HOLD (tts (s j) t)\n\ngoal (2 subgoals):\n 1. (\\<And>j'.\n        \\<lbrakk>Suc i < j'; j' \\<le> j; tts (s j') t = HOLD k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    tts (s j) t \\<noteq> WAIT k\n 2. \\<And>l.\n       \\<lbrakk>\\<And>j'.\n                   \\<lbrakk>Suc i < j'; j' \\<le> j;\n                    tts (s j') t = HOLD k\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        Suc i < l; l \\<le> j; tts (s l) t = HOLD k\\<rbrakk>\n       \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  Suc i < j'\n  j' \\<le> j\n  tts (s j') t = HOLD k\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>i < l; l < j; is_HOLD (tts (s l) t')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "apply (rule fair_aux2[OF RUN ACQ(1,2) Wk _ H'(3) WAIT(1) Wk'])"], ["proof (prove)\ngoal (2 subgoals):\n 1. i < j'\n 2. \\<And>l.\n       \\<lbrakk>i < l; l < j'; tts (s l) t' = HOLD k'\\<rbrakk>\n       \\<Longrightarrow> thesis", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j'", "using H'(1)"], ["proof (prove)\nusing this:\n  Suc i < j'\n\ngoal (1 subgoal):\n 1. i < j'", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>i < l; l < j'; tts (s l) t' = HOLD k'\\<rbrakk>\n       \\<Longrightarrow> thesis", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < l_; l_ < j'; tts (s l_) t' = HOLD k'\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (erule that)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>l_ < j'; tts (s l_) t' = HOLD k'\\<rbrakk>\n    \\<Longrightarrow> l_ < j\n 2. \\<lbrakk>l_ < j'; tts (s l_) t' = HOLD k'\\<rbrakk>\n    \\<Longrightarrow> is_HOLD (tts (s l_) t')", "using H'(2)"], ["proof (prove)\nusing this:\n  j' \\<le> j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>l_ < j'; tts (s l_) t' = HOLD k'\\<rbrakk>\n    \\<Longrightarrow> l_ < j\n 2. \\<lbrakk>l_ < j'; tts (s l_) t' = HOLD k'\\<rbrakk>\n    \\<Longrightarrow> is_HOLD (tts (s l_) t')", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Liveness\\<close>"], ["", "text \\<open>For all tickets in between the current and the next ticket, \n    there is a thread that has this ticket\\<close>"], ["", "definition \"invar2 \n    \\<equiv> \\<lambda>(c,n,ts). \\<forall>k. c\\<le>k \\<and> k<n \\<longrightarrow> (\\<exists>t<N. has_ticket (ts t) k)\""], ["", "lemma is_invar2: \"A.is_invar invar2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A.is_invar invar2", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. invar2 as\\<^sub>0\n 2. \\<And>s s'.\n       \\<lbrakk>A.reachable s; invar2 s; A.step s s'\\<rbrakk>\n       \\<Longrightarrow> invar2 s'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar2 as\\<^sub>0", "by (auto simp: invar2_def as\\<^sub>0_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>A.reachable s; invar2 s; A.step s s'\\<rbrakk>\n       \\<Longrightarrow> invar2 s'", "subgoal for s s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A.reachable s; invar2 s; A.step s s'\\<rbrakk>\n    \\<Longrightarrow> invar2 s'", "apply (clarsimp simp: invar2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c a b x aa ba l k.\n       \\<lbrakk>A.reachable (x, aa, ba); s' = (c, a, b);\n        \\<forall>k.\n           x \\<le> k \\<and> k < aa \\<longrightarrow>\n           (\\<exists>t<N. has_ticket (ba t) k);\n        s = (x, aa, ba); alstep l (x, aa, ba) (c, a, b); c \\<le> k;\n        k < a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t<N. has_ticket (b t) k", "apply (erule alstep.cases; erule astep_sng.cases; clarsimp)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>c aa l k ts.\n       \\<lbrakk>A.reachable (c, aa, ts); s' = (c, Suc aa, ts(l := WAIT aa));\n        \\<forall>k.\n           c \\<le> k \\<and> k < aa \\<longrightarrow>\n           (\\<exists>t<N. has_ticket (ts t) k);\n        s = (c, aa, ts); c \\<le> k; k < Suc aa; l < N; ts l = INIT\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            (t = l \\<longrightarrow> k = aa) \\<and>\n                            (t \\<noteq> l \\<longrightarrow>\n                             t < N \\<and> has_ticket (ts t) k)\n 2. \\<And>c a l k ts ka.\n       \\<lbrakk>A.reachable (c, a, ts); s' = (c, a, ts(l := WAIT ka));\n        \\<forall>k.\n           c \\<le> k \\<and> k < a \\<longrightarrow>\n           (\\<exists>t<N. has_ticket (ts t) k);\n        s = (c, a, ts); c \\<le> k; k < a; l < N; ts l = WAIT ka;\n        c \\<noteq> ka\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            (t = l \\<longrightarrow> k = ka) \\<and>\n                            (t \\<noteq> l \\<longrightarrow>\n                             t < N \\<and> has_ticket (ts t) k)\n 3. \\<And>c a l k ts.\n       \\<lbrakk>A.reachable (c, a, ts); s' = (c, a, ts(l := HOLD c));\n        \\<forall>k.\n           c \\<le> k \\<and> k < a \\<longrightarrow>\n           (\\<exists>t<N. has_ticket (ts t) k);\n        s = (c, a, ts); c \\<le> k; k < a; l < N; ts l = WAIT c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            (t = l \\<longrightarrow> k = c) \\<and>\n                            (t \\<noteq> l \\<longrightarrow>\n                             t < N \\<and> has_ticket (ts t) k)\n 4. \\<And>c a l k ts ka.\n       \\<lbrakk>A.reachable (c, a, ts); s' = (c, a, ts(l := REL ka));\n        \\<forall>k.\n           c \\<le> k \\<and> k < a \\<longrightarrow>\n           (\\<exists>t<N. has_ticket (ts t) k);\n        s = (c, a, ts); c \\<le> k; k < a; l < N; ts l = HOLD ka\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            (t = l \\<longrightarrow> k = ka) \\<and>\n                            (t \\<noteq> l \\<longrightarrow>\n                             t < N \\<and> has_ticket (ts t) k)\n 5. \\<And>a x l k ts ka.\n       \\<lbrakk>A.reachable (x, a, ts); s' = (Suc ka, a, ts(l := INIT));\n        \\<forall>k.\n           x \\<le> k \\<and> k < a \\<longrightarrow>\n           (\\<exists>t<N. has_ticket (ts t) k);\n        s = (x, a, ts); Suc ka \\<le> k; k < a; l < N; ts l = REL ka\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            t \\<noteq> l \\<and>\n                            t < N \\<and> has_ticket (ts t) k", "apply (metis less_antisym has_ticket_simps(1))"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>c a l k ts ka.\n       \\<lbrakk>A.reachable (c, a, ts); s' = (c, a, ts(l := WAIT ka));\n        \\<forall>k.\n           c \\<le> k \\<and> k < a \\<longrightarrow>\n           (\\<exists>t<N. has_ticket (ts t) k);\n        s = (c, a, ts); c \\<le> k; k < a; l < N; ts l = WAIT ka;\n        c \\<noteq> ka\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            (t = l \\<longrightarrow> k = ka) \\<and>\n                            (t \\<noteq> l \\<longrightarrow>\n                             t < N \\<and> has_ticket (ts t) k)\n 2. \\<And>c a l k ts.\n       \\<lbrakk>A.reachable (c, a, ts); s' = (c, a, ts(l := HOLD c));\n        \\<forall>k.\n           c \\<le> k \\<and> k < a \\<longrightarrow>\n           (\\<exists>t<N. has_ticket (ts t) k);\n        s = (c, a, ts); c \\<le> k; k < a; l < N; ts l = WAIT c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            (t = l \\<longrightarrow> k = c) \\<and>\n                            (t \\<noteq> l \\<longrightarrow>\n                             t < N \\<and> has_ticket (ts t) k)\n 3. \\<And>c a l k ts ka.\n       \\<lbrakk>A.reachable (c, a, ts); s' = (c, a, ts(l := REL ka));\n        \\<forall>k.\n           c \\<le> k \\<and> k < a \\<longrightarrow>\n           (\\<exists>t<N. has_ticket (ts t) k);\n        s = (c, a, ts); c \\<le> k; k < a; l < N; ts l = HOLD ka\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            (t = l \\<longrightarrow> k = ka) \\<and>\n                            (t \\<noteq> l \\<longrightarrow>\n                             t < N \\<and> has_ticket (ts t) k)\n 4. \\<And>a x l k ts ka.\n       \\<lbrakk>A.reachable (x, a, ts); s' = (Suc ka, a, ts(l := INIT));\n        \\<forall>k.\n           x \\<le> k \\<and> k < a \\<longrightarrow>\n           (\\<exists>t<N. has_ticket (ts t) k);\n        s = (x, a, ts); Suc ka \\<le> k; k < a; l < N; ts l = REL ka\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            t \\<noteq> l \\<and>\n                            t < N \\<and> has_ticket (ts t) k", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A.reachable (c_, a_, ts_); s' = (c_, a_, ts_(l_ := WAIT ka_));\n     \\<forall>k.\n        c_ \\<le> k \\<and> k < a_ \\<longrightarrow>\n        (\\<exists>t<N. has_ticket (ts_ t) k);\n     s = (c_, a_, ts_); c_ \\<le> k_; k_ < a_; l_ < N; ts_ l_ = WAIT ka_;\n     c_ \\<noteq> ka_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t.\n                         (t = l_ \\<longrightarrow> k_ = ka_) \\<and>\n                         (t \\<noteq> l_ \\<longrightarrow>\n                          t < N \\<and> has_ticket (ts_ t) k_)", "by (metis has_ticket_simps(2))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>c a l k ts.\n       \\<lbrakk>A.reachable (c, a, ts); s' = (c, a, ts(l := HOLD c));\n        \\<forall>k.\n           c \\<le> k \\<and> k < a \\<longrightarrow>\n           (\\<exists>t<N. has_ticket (ts t) k);\n        s = (c, a, ts); c \\<le> k; k < a; l < N; ts l = WAIT c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            (t = l \\<longrightarrow> k = c) \\<and>\n                            (t \\<noteq> l \\<longrightarrow>\n                             t < N \\<and> has_ticket (ts t) k)\n 2. \\<And>c a l k ts ka.\n       \\<lbrakk>A.reachable (c, a, ts); s' = (c, a, ts(l := REL ka));\n        \\<forall>k.\n           c \\<le> k \\<and> k < a \\<longrightarrow>\n           (\\<exists>t<N. has_ticket (ts t) k);\n        s = (c, a, ts); c \\<le> k; k < a; l < N; ts l = HOLD ka\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            (t = l \\<longrightarrow> k = ka) \\<and>\n                            (t \\<noteq> l \\<longrightarrow>\n                             t < N \\<and> has_ticket (ts t) k)\n 3. \\<And>a x l k ts ka.\n       \\<lbrakk>A.reachable (x, a, ts); s' = (Suc ka, a, ts(l := INIT));\n        \\<forall>k.\n           x \\<le> k \\<and> k < a \\<longrightarrow>\n           (\\<exists>t<N. has_ticket (ts t) k);\n        s = (x, a, ts); Suc ka \\<le> k; k < a; l < N; ts l = REL ka\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            t \\<noteq> l \\<and>\n                            t < N \\<and> has_ticket (ts t) k", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A.reachable (c_, a_, ts_); s' = (c_, a_, ts_(l_ := HOLD c_));\n     \\<forall>k.\n        c_ \\<le> k \\<and> k < a_ \\<longrightarrow>\n        (\\<exists>t<N. has_ticket (ts_ t) k);\n     s = (c_, a_, ts_); c_ \\<le> k_; k_ < a_; l_ < N;\n     ts_ l_ = WAIT c_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t.\n                         (t = l_ \\<longrightarrow> k_ = c_) \\<and>\n                         (t \\<noteq> l_ \\<longrightarrow>\n                          t < N \\<and> has_ticket (ts_ t) k_)", "by (metis has_ticket_simps(2))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c a l k ts ka.\n       \\<lbrakk>A.reachable (c, a, ts); s' = (c, a, ts(l := REL ka));\n        \\<forall>k.\n           c \\<le> k \\<and> k < a \\<longrightarrow>\n           (\\<exists>t<N. has_ticket (ts t) k);\n        s = (c, a, ts); c \\<le> k; k < a; l < N; ts l = HOLD ka\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            (t = l \\<longrightarrow> k = ka) \\<and>\n                            (t \\<noteq> l \\<longrightarrow>\n                             t < N \\<and> has_ticket (ts t) k)\n 2. \\<And>a x l k ts ka.\n       \\<lbrakk>A.reachable (x, a, ts); s' = (Suc ka, a, ts(l := INIT));\n        \\<forall>k.\n           x \\<le> k \\<and> k < a \\<longrightarrow>\n           (\\<exists>t<N. has_ticket (ts t) k);\n        s = (x, a, ts); Suc ka \\<le> k; k < a; l < N; ts l = REL ka\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            t \\<noteq> l \\<and>\n                            t < N \\<and> has_ticket (ts t) k", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A.reachable (c_, a_, ts_); s' = (c_, a_, ts_(l_ := REL ka_));\n     \\<forall>k.\n        c_ \\<le> k \\<and> k < a_ \\<longrightarrow>\n        (\\<exists>t<N. has_ticket (ts_ t) k);\n     s = (c_, a_, ts_); c_ \\<le> k_; k_ < a_; l_ < N;\n     ts_ l_ = HOLD ka_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t.\n                         (t = l_ \\<longrightarrow> k_ = ka_) \\<and>\n                         (t \\<noteq> l_ \\<longrightarrow>\n                          t < N \\<and> has_ticket (ts_ t) k_)", "by (metis has_ticket_simps(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x l k ts ka.\n       \\<lbrakk>A.reachable (x, a, ts); s' = (Suc ka, a, ts(l := INIT));\n        \\<forall>k.\n           x \\<le> k \\<and> k < a \\<longrightarrow>\n           (\\<exists>t<N. has_ticket (ts t) k);\n        s = (x, a, ts); Suc ka \\<le> k; k < a; l < N; ts l = REL ka\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            t \\<noteq> l \\<and>\n                            t < N \\<and> has_ticket (ts t) k", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A.reachable (x_, a_, ts_); s' = (Suc ka_, a_, ts_(l_ := INIT));\n     \\<forall>k.\n        x_ \\<le> k \\<and> k < a_ \\<longrightarrow>\n        (\\<exists>t<N. has_ticket (ts_ t) k);\n     s = (x_, a_, ts_); Suc ka_ \\<le> k_; k_ < a_; l_ < N;\n     ts_ l_ = REL ka_\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t.\n                         t \\<noteq> l_ \\<and>\n                         t < N \\<and> has_ticket (ts_ t) k_", "apply (frule A.invar_reachable[OF is_invar1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A.reachable (x_, a_, ts_); s' = (Suc ka_, a_, ts_(l_ := INIT));\n     \\<forall>k.\n        x_ \\<le> k \\<and> k < a_ \\<longrightarrow>\n        (\\<exists>t<N. has_ticket (ts_ t) k);\n     s = (x_, a_, ts_); Suc ka_ \\<le> k_; k_ < a_; l_ < N; ts_ l_ = REL ka_;\n     invar1 (x_, a_, ts_)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t.\n                         t \\<noteq> l_ \\<and>\n                         t < N \\<and> has_ticket (ts_ t) k_", "unfolding invar1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A.reachable (x_, a_, ts_); s' = (Suc ka_, a_, ts_(l_ := INIT));\n     \\<forall>k.\n        x_ \\<le> k \\<and> k < a_ \\<longrightarrow>\n        (\\<exists>t<N. has_ticket (ts_ t) k);\n     s = (x_, a_, ts_); Suc ka_ \\<le> k_; k_ < a_; l_ < N; ts_ l_ = REL ka_;\n     case (x_, a_, ts_) of\n     (c, n, ts) \\<Rightarrow>\n       c \\<le> n \\<and>\n       (\\<forall>t k.\n           t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n           c \\<le> k \\<and>\n           k < n \\<and>\n           (\\<forall>t' k'.\n               t' < N \\<and>\n               has_ticket (ts t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n               k \\<noteq> k') \\<and>\n           (\\<forall>k.\n               k \\<noteq> c \\<longrightarrow>\n               \\<not> locks_ticket (ts t) k))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t.\n                         t \\<noteq> l_ \\<and>\n                         t < N \\<and> has_ticket (ts_ t) k_", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A.reachable (x_, a_, ts_); s' = (Suc ka_, a_, ts_(l_ := INIT));\n     \\<forall>k.\n        x_ \\<le> k \\<and> k < a_ \\<longrightarrow>\n        (\\<exists>t<N. has_ticket (ts_ t) k);\n     s = (x_, a_, ts_); Suc ka_ \\<le> k_; k_ < a_; l_ < N; ts_ l_ = REL ka_;\n     x_ \\<le> a_;\n     \\<forall>t k.\n        t < N \\<and> has_ticket (ts_ t) k \\<longrightarrow>\n        x_ \\<le> k \\<and>\n        k < a_ \\<and>\n        (\\<forall>t' k'.\n            t' < N \\<and>\n            has_ticket (ts_ t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n            k \\<noteq> k') \\<and>\n        (\\<forall>k.\n            k \\<noteq> x_ \\<longrightarrow>\n            \\<not> locks_ticket (ts_ t) k)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t.\n                         t \\<noteq> l_ \\<and>\n                         t < N \\<and> has_ticket (ts_ t) k_", "by (metis Suc_leD locks_ticket_simps(4) \n          not_less_eq_eq has_ticket_simps(4))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>If a thread t is waiting for a lock, the current lock is also used by a thread\\<close>"], ["", "corollary current_lock_used:\n    assumes R: \"A.reachable (c,n,ts)\"\n    assumes WAIT: \"t<N\" \"ts t = WAIT k\" \n    obtains t' where \"t'<N\"  \"has_ticket (ts t') c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t' < N; has_ticket (ts t') c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using A.invar_reachable[OF is_invar2 R] \n      and A.invar_reachable[OF is_invar1 R] WAIT"], ["proof (prove)\nusing this:\n  invar2 (c, n, ts)\n  invar1 (c, n, ts)\n  t < N\n  ts t = WAIT k\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t' < N; has_ticket (ts t') c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding invar1_def invar2_def"], ["proof (prove)\nusing this:\n  case (c, n, ts) of\n  (c, n, ts) \\<Rightarrow>\n    \\<forall>k.\n       c \\<le> k \\<and> k < n \\<longrightarrow>\n       (\\<exists>t<N. has_ticket (ts t) k)\n  case (c, n, ts) of\n  (c, n, ts) \\<Rightarrow>\n    c \\<le> n \\<and>\n    (\\<forall>t k.\n        t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n        c \\<le> k \\<and>\n        k < n \\<and>\n        (\\<forall>t' k'.\n            t' < N \\<and>\n            has_ticket (ts t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n            k \\<noteq> k') \\<and>\n        (\\<forall>k.\n            k \\<noteq> c \\<longrightarrow> \\<not> locks_ticket (ts t) k))\n  t < N\n  ts t = WAIT k\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t' < N; has_ticket (ts t') c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t'.\n                \\<lbrakk>t' < N; has_ticket (ts t') c\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<forall>k.\n        c \\<le> k \\<and> k < n \\<longrightarrow>\n        (\\<exists>t<N. has_ticket (ts t) k);\n     t < N; ts t = WAIT k; c \\<le> n;\n     \\<forall>t k.\n        t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n        c \\<le> k \\<and>\n        k < n \\<and>\n        (\\<forall>t' k'.\n            t' < N \\<and>\n            has_ticket (ts t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n            k \\<noteq> k') \\<and>\n        (\\<forall>k.\n            k \\<noteq> c \\<longrightarrow>\n            \\<not> locks_ticket (ts t) k)\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis (full_types) le_neq_implies_less not_le order_mono_setup.refl \n      has_ticket_simps(2))"], ["", "text \\<open>Used tickets are unique (Corollary from invariant 1)\\<close>"], ["", "lemma has_ticket_unique: \"\\<lbrakk>A.reachable (c,n,ts); \n      t<N; has_ticket (ts t) k; t'<N; has_ticket (ts t') k\n    \\<rbrakk> \\<Longrightarrow> t'=t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A.reachable (c, n, ts); t < N; has_ticket (ts t) k; t' < N;\n     has_ticket (ts t') k\\<rbrakk>\n    \\<Longrightarrow> t' = t", "apply (drule A.invar_reachable[OF is_invar1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t < N; has_ticket (ts t) k; t' < N; has_ticket (ts t') k;\n     invar1 (c, n, ts)\\<rbrakk>\n    \\<Longrightarrow> t' = t", "by (auto simp: invar1_def)"], ["", "text \\<open>We define the thread that holds a specified ticket\\<close>"], ["", "definition \"tkt_thread \\<equiv> \\<lambda>ts k. THE t. t<N \\<and> has_ticket (ts t) k\""], ["", "lemma tkt_thread_eq: \n    assumes R: \"A.reachable (c,n,ts)\"  \n    assumes A: \"t<N\" \"has_ticket (ts t) k\"\n    shows \"tkt_thread ts k = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tkt_thread ts k = t", "using has_ticket_unique[OF R]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?t < N; has_ticket (ts ?t) ?k; ?t' < N;\n   has_ticket (ts ?t') ?k\\<rbrakk>\n  \\<Longrightarrow> ?t' = ?t\n\ngoal (1 subgoal):\n 1. tkt_thread ts k = t", "unfolding tkt_thread_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?t < N; has_ticket (ts ?t) ?k; ?t' < N;\n   has_ticket (ts ?t') ?k\\<rbrakk>\n  \\<Longrightarrow> ?t' = ?t\n\ngoal (1 subgoal):\n 1. (THE t. t < N \\<and> has_ticket (ts t) k) = t", "using A"], ["proof (prove)\nusing this:\n  \\<lbrakk>?t < N; has_ticket (ts ?t) ?k; ?t' < N;\n   has_ticket (ts ?t') ?k\\<rbrakk>\n  \\<Longrightarrow> ?t' = ?t\n  t < N\n  has_ticket (ts t) k\n\ngoal (1 subgoal):\n 1. (THE t. t < N \\<and> has_ticket (ts t) k) = t", "by auto"], ["", "lemma holds_only_current:\n    assumes R: \"A.reachable (c,n,ts)\"  \n    assumes A: \"t<N\" \"locks_ticket (ts t) k\"\n    shows \"k=c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k = c", "using A.invar_reachable[OF is_invar1 R] A"], ["proof (prove)\nusing this:\n  invar1 (c, n, ts)\n  t < N\n  locks_ticket (ts t) k\n\ngoal (1 subgoal):\n 1. k = c", "unfolding invar1_def"], ["proof (prove)\nusing this:\n  case (c, n, ts) of\n  (c, n, ts) \\<Rightarrow>\n    c \\<le> n \\<and>\n    (\\<forall>t k.\n        t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n        c \\<le> k \\<and>\n        k < n \\<and>\n        (\\<forall>t' k'.\n            t' < N \\<and>\n            has_ticket (ts t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n            k \\<noteq> k') \\<and>\n        (\\<forall>k.\n            k \\<noteq> c \\<longrightarrow> \\<not> locks_ticket (ts t) k))\n  t < N\n  locks_ticket (ts t) k\n\ngoal (1 subgoal):\n 1. k = c", "using holds_imp_uses"], ["proof (prove)\nusing this:\n  case (c, n, ts) of\n  (c, n, ts) \\<Rightarrow>\n    c \\<le> n \\<and>\n    (\\<forall>t k.\n        t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n        c \\<le> k \\<and>\n        k < n \\<and>\n        (\\<forall>t' k'.\n            t' < N \\<and>\n            has_ticket (ts t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n            k \\<noteq> k') \\<and>\n        (\\<forall>k.\n            k \\<noteq> c \\<longrightarrow> \\<not> locks_ticket (ts t) k))\n  t < N\n  locks_ticket (ts t) k\n  locks_ticket ?s ?k \\<Longrightarrow> has_ticket ?s ?k\n\ngoal (1 subgoal):\n 1. k = c", "by blast"], ["", "text \\<open>For the inductive argument, we will use this measure, that decreases as a\n    single thread progresses through its phases.\n  \\<close>"], ["", "definition \"tweight s \\<equiv> \n    case s of WAIT _ \\<Rightarrow> 3::nat | HOLD _ \\<Rightarrow> 2 | REL _ \\<Rightarrow> 1 | INIT \\<Rightarrow> 0\""], ["", "text \\<open>We show progress: Every thread that waits for the lock\n    will eventually hold the lock.\\<close>"], ["", "theorem progress:\n    assumes FRUN: \"A.is_fair_run s\"\n    assumes A: \"t<N\" \"is_WAIT (tts (s i) t)\"\n    shows \"\\<exists>j>i. is_HOLD (tts (s j) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j>i. is_HOLD (tts (s j) t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>j>i. is_HOLD (tts (s j) t)", "interpret A: fair_run as\\<^sub>0 alstep s"], ["proof (prove)\ngoal (1 subgoal):\n 1. fair_run as\\<^sub>0 alstep s", "by unfold_locales fact"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>j>i. is_HOLD (tts (s j) t)", "from A"], ["proof (chain)\npicking this:\n  t < N\n  is_WAIT (tts (s i) t)", "obtain k where Wk: \"tts (s i) t = WAIT k\""], ["proof (prove)\nusing this:\n  t < N\n  is_WAIT (tts (s i) t)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        tts (s i) t = WAIT k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"tts (s i) t\") auto"], ["proof (state)\nthis:\n  tts (s i) t = WAIT k\n\ngoal (1 subgoal):\n 1. \\<exists>j>i. is_HOLD (tts (s j) t)", "text \\<open>We use the following induction scheme:\n      \\<^item> Either the current thread increases (if we reach \\<open>k\\<close>, we are done)\n      \\<^item> (lex) the thread using the current ticket makes a step\n      \\<^item> (lex) another thread makes a step\n    \\<close>"], ["proof (state)\nthis:\n  tts (s i) t = WAIT k\n\ngoal (1 subgoal):\n 1. \\<exists>j>i. is_HOLD (tts (s j) t)", "define lrel where \"lrel \\<equiv> \n      inv_image (measure id <*lex*> measure id <*lex*> measure id) (\\<lambda>i. (\n        k-cc (s i),\n        tweight (tts (s i) (tkt_thread (tts (s i)) (cc (s i)))),\n        A.dist_step (tkt_thread (tts (s i)) (cc (s i))) i\n      ))\""], ["proof (state)\nthis:\n  lrel \\<equiv>\n  inv_image (measure id <*lex*> measure id <*lex*> measure id)\n   (\\<lambda>i.\n       (k - cc (s i),\n        tweight (tts (s i) (tkt_thread (tts (s i)) (cc (s i)))),\n        A.dist_step (tkt_thread (tts (s i)) (cc (s i))) i))\n\ngoal (1 subgoal):\n 1. \\<exists>j>i. is_HOLD (tts (s j) t)", "have \"wf lrel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf lrel", "unfolding lrel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (inv_image (measure id <*lex*> measure id <*lex*> measure id)\n         (\\<lambda>i.\n             (k - cc (s i),\n              tweight (tts (s i) (tkt_thread (tts (s i)) (cc (s i)))),\n              A.dist_step (tkt_thread (tts (s i)) (cc (s i))) i)))", "by auto"], ["proof (state)\nthis:\n  wf lrel\n\ngoal (1 subgoal):\n 1. \\<exists>j>i. is_HOLD (tts (s j) t)", "then"], ["proof (chain)\npicking this:\n  wf lrel", "show ?thesis"], ["proof (prove)\nusing this:\n  wf lrel\n\ngoal (1 subgoal):\n 1. \\<exists>j>i. is_HOLD (tts (s j) t)", "using A(1) Wk"], ["proof (prove)\nusing this:\n  wf lrel\n  t < N\n  tts (s i) t = WAIT k\n\ngoal (1 subgoal):\n 1. \\<exists>j>i. is_HOLD (tts (s j) t)", "proof (induction i)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> lrel; t < N;\n                    tts (s y) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j>y. is_HOLD (tts (s j) t);\n        t < N; tts (s x) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>x. is_HOLD (tts (s j) t)", "case (less i)"], ["proof (state)\nthis:\n  \\<lbrakk>(?y, i) \\<in> lrel; t < N; tts (s ?y) t = WAIT k\\<rbrakk>\n  \\<Longrightarrow> \\<exists>j>?y. is_HOLD (tts (s j) t)\n  t < N\n  tts (s i) t = WAIT k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> lrel; t < N;\n                    tts (s y) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j>y. is_HOLD (tts (s j) t);\n        t < N; tts (s x) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>x. is_HOLD (tts (s j) t)", "text \\<open>We name the components of this and the next state\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>(?y, i) \\<in> lrel; t < N; tts (s ?y) t = WAIT k\\<rbrakk>\n  \\<Longrightarrow> \\<exists>j>?y. is_HOLD (tts (s j) t)\n  t < N\n  tts (s i) t = WAIT k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> lrel; t < N;\n                    tts (s y) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j>y. is_HOLD (tts (s j) t);\n        t < N; tts (s x) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>x. is_HOLD (tts (s j) t)", "obtain c n ts where [simp]: \"s i = (c,n,ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c n ts.\n        s i = (c, n, ts) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"s i\")"], ["proof (state)\nthis:\n  s i = (c, n, ts)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> lrel; t < N;\n                    tts (s y) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j>y. is_HOLD (tts (s j) t);\n        t < N; tts (s x) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>x. is_HOLD (tts (s j) t)", "from A.run_reachable[of i]"], ["proof (chain)\npicking this:\n  A.reachable (s i)", "have R: \"A.reachable (c,n,ts)\""], ["proof (prove)\nusing this:\n  A.reachable (s i)\n\ngoal (1 subgoal):\n 1. A.reachable (c, n, ts)", "by simp"], ["proof (state)\nthis:\n  A.reachable (c, n, ts)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> lrel; t < N;\n                    tts (s y) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j>y. is_HOLD (tts (s j) t);\n        t < N; tts (s x) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>x. is_HOLD (tts (s j) t)", "obtain c' n' ts' where [simp]: \"s (Suc i) = (c',n',ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c' n' ts'.\n        s (Suc i) = (c', n', ts') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"s (Suc i)\")"], ["proof (state)\nthis:\n  s (Suc i) = (c', n', ts')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> lrel; t < N;\n                    tts (s y) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j>y. is_HOLD (tts (s j) t);\n        t < N; tts (s x) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>x. is_HOLD (tts (s j) t)", "from A.run_reachable[of \"Suc i\"]"], ["proof (chain)\npicking this:\n  A.reachable (s (Suc i))", "have R': \"A.reachable (c',n',ts')\""], ["proof (prove)\nusing this:\n  A.reachable (s (Suc i))\n\ngoal (1 subgoal):\n 1. A.reachable (c', n', ts')", "by simp"], ["proof (state)\nthis:\n  A.reachable (c', n', ts')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> lrel; t < N;\n                    tts (s y) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j>y. is_HOLD (tts (s j) t);\n        t < N; tts (s x) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>x. is_HOLD (tts (s j) t)", "from less.prems"], ["proof (chain)\npicking this:\n  t < N\n  tts (s i) t = WAIT k", "have WAIT[simp]: \"ts t = WAIT k\""], ["proof (prove)\nusing this:\n  t < N\n  tts (s i) t = WAIT k\n\ngoal (1 subgoal):\n 1. ts t = WAIT k", "by simp"], ["proof (state)\nthis:\n  ts t = WAIT k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> lrel; t < N;\n                    tts (s y) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j>y. is_HOLD (tts (s j) t);\n        t < N; tts (s x) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>x. is_HOLD (tts (s j) t)", "{"], ["proof (state)\nthis:\n  ts t = WAIT k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> lrel; t < N;\n                    tts (s y) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j>y. is_HOLD (tts (s j) t);\n        t < N; tts (s x) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>x. is_HOLD (tts (s j) t)", "text \\<open>If thread \\<open>t\\<close> left waiting state, we are done\\<close>"], ["proof (state)\nthis:\n  ts t = WAIT k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> lrel; t < N;\n                    tts (s y) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j>y. is_HOLD (tts (s j) t);\n        t < N; tts (s x) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>x. is_HOLD (tts (s j) t)", "assume \"ts' t \\<noteq> WAIT k\""], ["proof (state)\nthis:\n  ts' t \\<noteq> WAIT k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> lrel; t < N;\n                    tts (s y) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j>y. is_HOLD (tts (s j) t);\n        t < N; tts (s x) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>x. is_HOLD (tts (s j) t)", "hence \"ts' t = HOLD k\""], ["proof (prove)\nusing this:\n  ts' t \\<noteq> WAIT k\n\ngoal (1 subgoal):\n 1. ts' t = HOLD k", "using less.prems"], ["proof (prove)\nusing this:\n  ts' t \\<noteq> WAIT k\n  t < N\n  tts (s i) t = WAIT k\n\ngoal (1 subgoal):\n 1. ts' t = HOLD k", "apply (rule_tac A.stepE[of i])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>ts' t \\<noteq> WAIT k; t < N; tts (s i) t = WAIT k;\n        alstep l (s i) (s (Suc i))\\<rbrakk>\n       \\<Longrightarrow> ts' t = HOLD k", "apply (auto elim!: alstep.cases astep_sng.cases split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ts' t = HOLD k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> lrel; t < N;\n                    tts (s y) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j>y. is_HOLD (tts (s j) t);\n        t < N; tts (s x) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>x. is_HOLD (tts (s j) t)", "hence ?case"], ["proof (prove)\nusing this:\n  ts' t = HOLD k\n\ngoal (1 subgoal):\n 1. \\<exists>j>i. is_HOLD (tts (s j) t)", "by auto"], ["proof (state)\nthis:\n  \\<exists>j>i. is_HOLD (tts (s j) t)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> lrel; t < N;\n                    tts (s y) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j>y. is_HOLD (tts (s j) t);\n        t < N; tts (s x) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>x. is_HOLD (tts (s j) t)", "}"], ["proof (state)\nthis:\n  ts' t \\<noteq> WAIT k \\<Longrightarrow>\n  \\<exists>j>i. is_HOLD (tts (s j) t)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> lrel; t < N;\n                    tts (s y) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j>y. is_HOLD (tts (s j) t);\n        t < N; tts (s x) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>x. is_HOLD (tts (s j) t)", "moreover"], ["proof (state)\nthis:\n  ts' t \\<noteq> WAIT k \\<Longrightarrow>\n  \\<exists>j>i. is_HOLD (tts (s j) t)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> lrel; t < N;\n                    tts (s y) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j>y. is_HOLD (tts (s j) t);\n        t < N; tts (s x) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>x. is_HOLD (tts (s j) t)", "{"], ["proof (state)\nthis:\n  ts' t \\<noteq> WAIT k \\<Longrightarrow>\n  \\<exists>j>i. is_HOLD (tts (s j) t)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> lrel; t < N;\n                    tts (s y) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j>y. is_HOLD (tts (s j) t);\n        t < N; tts (s x) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>x. is_HOLD (tts (s j) t)", "assume [simp]: \"ts' t = WAIT k\""], ["proof (state)\nthis:\n  ts' t = WAIT k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> lrel; t < N;\n                    tts (s y) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j>y. is_HOLD (tts (s j) t);\n        t < N; tts (s x) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>x. is_HOLD (tts (s j) t)", "text \\<open>Otherwise, we obtain the thread \\<open>tt\\<close> that holds the current lock\\<close>"], ["proof (state)\nthis:\n  ts' t = WAIT k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> lrel; t < N;\n                    tts (s y) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j>y. is_HOLD (tts (s j) t);\n        t < N; tts (s x) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>x. is_HOLD (tts (s j) t)", "obtain tt where UTT: \"tt<N\" \"has_ticket (ts tt) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tt.\n        \\<lbrakk>tt < N; has_ticket (ts tt) c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using current_lock_used[of c n ts t k] \n            and less.prems A.run_reachable[of i]"], ["proof (prove)\nusing this:\n  \\<lbrakk>A.reachable (c, n, ts); t < N; ts t = WAIT k;\n   \\<And>t'.\n      \\<lbrakk>t' < N; has_ticket (ts t') c\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  t < N\n  tts (s i) t = WAIT k\n  A.reachable (s i)\n\ngoal (1 subgoal):\n 1. (\\<And>tt.\n        \\<lbrakk>tt < N; has_ticket (ts tt) c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  tt < N\n  has_ticket (ts tt) c\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> lrel; t < N;\n                    tts (s y) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j>y. is_HOLD (tts (s j) t);\n        t < N; tts (s x) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>x. is_HOLD (tts (s j) t)", "have [simp]: \"tkt_thread ts c = tt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tkt_thread ts c = tt", "using tkt_thread_eq[OF R UTT]"], ["proof (prove)\nusing this:\n  tkt_thread ts c = tt\n\ngoal (1 subgoal):\n 1. tkt_thread ts c = tt", "."], ["proof (state)\nthis:\n  tkt_thread ts c = tt\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> lrel; t < N;\n                    tts (s y) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j>y. is_HOLD (tts (s j) t);\n        t < N; tts (s x) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>x. is_HOLD (tts (s j) t)", "note [simp] = \\<open>tt<N\\<close>"], ["proof (state)\nthis:\n  tt < N\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> lrel; t < N;\n                    tts (s y) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j>y. is_HOLD (tts (s j) t);\n        t < N; tts (s x) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>x. is_HOLD (tts (s j) t)", "have \"A.can_step tt (s i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A.can_step tt (s i)", "by (simp add: never_blocked)"], ["proof (state)\nthis:\n  A.can_step tt (s i)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> lrel; t < N;\n                    tts (s y) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j>y. is_HOLD (tts (s j) t);\n        t < N; tts (s x) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>x. is_HOLD (tts (s j) t)", "hence ?case"], ["proof (prove)\nusing this:\n  A.can_step tt (s i)\n\ngoal (1 subgoal):\n 1. \\<exists>j>i. is_HOLD (tts (s j) t)", "proof (cases rule: A.rstep_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l'.\n       \\<lbrakk>tt \\<noteq> l'; \\<not> A.rstep tt s i; A.rstep l' s i;\n        A.dist_step tt (Suc i) < A.dist_step tt i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)\n 2. A.rstep tt s i \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)", "case (other t') \\<comment> \\<open>Another thread than \\<open>tt\\<close> makes a step.\\<close>"], ["proof (state)\nthis:\n  tt \\<noteq> t'\n  \\<not> A.rstep tt s i\n  A.rstep t' s i\n  A.dist_step tt (Suc i) < A.dist_step tt i\n\ngoal (2 subgoals):\n 1. \\<And>l'.\n       \\<lbrakk>tt \\<noteq> l'; \\<not> A.rstep tt s i; A.rstep l' s i;\n        A.dist_step tt (Suc i) < A.dist_step tt i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)\n 2. A.rstep tt s i \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)", "text \\<open>The current ticket and \\<open>tt\\<close>'s state remain the same\\<close>"], ["proof (state)\nthis:\n  tt \\<noteq> t'\n  \\<not> A.rstep tt s i\n  A.rstep t' s i\n  A.dist_step tt (Suc i) < A.dist_step tt i\n\ngoal (2 subgoals):\n 1. \\<And>l'.\n       \\<lbrakk>tt \\<noteq> l'; \\<not> A.rstep tt s i; A.rstep l' s i;\n        A.dist_step tt (Suc i) < A.dist_step tt i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)\n 2. A.rstep tt s i \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)", "hence [simp]: \"c' = c \\<and> ts' tt = ts tt\""], ["proof (prove)\nusing this:\n  tt \\<noteq> t'\n  \\<not> A.rstep tt s i\n  A.rstep t' s i\n  A.dist_step tt (Suc i) < A.dist_step tt i\n\ngoal (1 subgoal):\n 1. c' = c \\<and> ts' tt = ts tt", "using has_ticket_unique[OF R UTT, of t']"], ["proof (prove)\nusing this:\n  tt \\<noteq> t'\n  \\<not> A.rstep tt s i\n  A.rstep t' s i\n  A.dist_step tt (Suc i) < A.dist_step tt i\n  \\<lbrakk>t' < N; has_ticket (ts t') c\\<rbrakk> \\<Longrightarrow> t' = tt\n\ngoal (1 subgoal):\n 1. c' = c \\<and> ts' tt = ts tt", "unfolding A.rstep_def"], ["proof (prove)\nusing this:\n  tt \\<noteq> t'\n  \\<not> alstep tt (s i) (s (Suc i))\n  alstep t' (s i) (s (Suc i))\n  A.dist_step tt (Suc i) < A.dist_step tt i\n  \\<lbrakk>t' < N; has_ticket (ts t') c\\<rbrakk> \\<Longrightarrow> t' = tt\n\ngoal (1 subgoal):\n 1. c' = c \\<and> ts' tt = ts tt", "using holds_only_current[OF R, of t']"], ["proof (prove)\nusing this:\n  tt \\<noteq> t'\n  \\<not> alstep tt (s i) (s (Suc i))\n  alstep t' (s i) (s (Suc i))\n  A.dist_step tt (Suc i) < A.dist_step tt i\n  \\<lbrakk>t' < N; has_ticket (ts t') c\\<rbrakk> \\<Longrightarrow> t' = tt\n  \\<lbrakk>t' < N; locks_ticket (ts t') ?k\\<rbrakk> \\<Longrightarrow> ?k = c\n\ngoal (1 subgoal):\n 1. c' = c \\<and> ts' tt = ts tt", "by (force elim!: alstep.cases astep_sng.cases)"], ["proof (state)\nthis:\n  c' = c \\<and> ts' tt = ts tt\n\ngoal (2 subgoals):\n 1. \\<And>l'.\n       \\<lbrakk>tt \\<noteq> l'; \\<not> A.rstep tt s i; A.rstep l' s i;\n        A.dist_step tt (Suc i) < A.dist_step tt i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)\n 2. A.rstep tt s i \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)", "text \\<open>Thus, \\<open>tt\\<close> is still using the current ticket\\<close>"], ["proof (state)\nthis:\n  c' = c \\<and> ts' tt = ts tt\n\ngoal (2 subgoals):\n 1. \\<And>l'.\n       \\<lbrakk>tt \\<noteq> l'; \\<not> A.rstep tt s i; A.rstep l' s i;\n        A.dist_step tt (Suc i) < A.dist_step tt i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)\n 2. A.rstep tt s i \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)", "have [simp]: \"tkt_thread ts' c = tt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tkt_thread ts' c = tt", "using UTT tkt_thread_eq[OF R', of tt c]"], ["proof (prove)\nusing this:\n  tt < N\n  has_ticket (ts tt) c\n  \\<lbrakk>tt < N; has_ticket (ts' tt) c\\<rbrakk>\n  \\<Longrightarrow> tkt_thread ts' c = tt\n\ngoal (1 subgoal):\n 1. tkt_thread ts' c = tt", "by auto"], ["proof (state)\nthis:\n  tkt_thread ts' c = tt\n\ngoal (2 subgoals):\n 1. \\<And>l'.\n       \\<lbrakk>tt \\<noteq> l'; \\<not> A.rstep tt s i; A.rstep l' s i;\n        A.dist_step tt (Suc i) < A.dist_step tt i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)\n 2. A.rstep tt s i \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)", "text \\<open>Only the distance to \\<open>tt\\<close>'s next step has decreased\\<close>"], ["proof (state)\nthis:\n  tkt_thread ts' c = tt\n\ngoal (2 subgoals):\n 1. \\<And>l'.\n       \\<lbrakk>tt \\<noteq> l'; \\<not> A.rstep tt s i; A.rstep l' s i;\n        A.dist_step tt (Suc i) < A.dist_step tt i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)\n 2. A.rstep tt s i \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)", "have \"(Suc i, i) \\<in> lrel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc i, i) \\<in> lrel", "unfolding lrel_def tweight_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc i, i)\n    \\<in> inv_image (measure id <*lex*> measure id <*lex*> measure id)\n           (\\<lambda>i.\n               (k - cc (s i),\n                case tts (s i) (tkt_thread (tts (s i)) (cc (s i))) of\n                INIT \\<Rightarrow> 0 | WAIT x \\<Rightarrow> 3\n                | HOLD x \\<Rightarrow> 2 | REL x \\<Rightarrow> 1,\n                A.dist_step (tkt_thread (tts (s i)) (cc (s i))) i))", "by (simp add: other)"], ["proof (state)\nthis:\n  (Suc i, i) \\<in> lrel\n\ngoal (2 subgoals):\n 1. \\<And>l'.\n       \\<lbrakk>tt \\<noteq> l'; \\<not> A.rstep tt s i; A.rstep l' s i;\n        A.dist_step tt (Suc i) < A.dist_step tt i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)\n 2. A.rstep tt s i \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)", "text \\<open>And we can apply the induction hypothesis\\<close>"], ["proof (state)\nthis:\n  (Suc i, i) \\<in> lrel\n\ngoal (2 subgoals):\n 1. \\<And>l'.\n       \\<lbrakk>tt \\<noteq> l'; \\<not> A.rstep tt s i; A.rstep l' s i;\n        A.dist_step tt (Suc i) < A.dist_step tt i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)\n 2. A.rstep tt s i \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)", "with less.IH[of \"Suc i\"] \\<open>t<N\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>(Suc i, i) \\<in> lrel; t < N; tts (s (Suc i)) t = WAIT k\\<rbrakk>\n  \\<Longrightarrow> \\<exists>j>Suc i. is_HOLD (tts (s j) t)\n  t < N\n  (Suc i, i) \\<in> lrel", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(Suc i, i) \\<in> lrel; t < N; tts (s (Suc i)) t = WAIT k\\<rbrakk>\n  \\<Longrightarrow> \\<exists>j>Suc i. is_HOLD (tts (s j) t)\n  t < N\n  (Suc i, i) \\<in> lrel\n\ngoal (1 subgoal):\n 1. \\<exists>j>i. is_HOLD (tts (s j) t)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>t < N; (Suc i, i) \\<in> lrel; Suc i < j;\n        is_HOLD (tts (s j) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)", "using Suc_lessD"], ["proof (prove)\nusing this:\n  Suc ?m < ?n \\<Longrightarrow> ?m < ?n\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>t < N; (Suc i, i) \\<in> lrel; Suc i < j;\n        is_HOLD (tts (s j) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)", "by blast"], ["proof (state)\nthis:\n  \\<exists>j>i. is_HOLD (tts (s j) t)\n\ngoal (1 subgoal):\n 1. A.rstep tt s i \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A.rstep tt s i \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)", "case THIS: this \\<comment> \\<open>The thread \\<open>tt\\<close> that uses the current ticket makes a step\\<close>"], ["proof (state)\nthis:\n  A.rstep tt s i\n\ngoal (1 subgoal):\n 1. A.rstep tt s i \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j>i. is_HOLD (tts (s j) t)", "proof (cases \"\\<exists>k'. ts tt = REL k'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>k'. ts tt = REL k' \\<Longrightarrow>\n    \\<exists>j>i. is_HOLD (tts (s j) t)\n 2. \\<nexists>k'. ts tt = REL k' \\<Longrightarrow>\n    \\<exists>j>i. is_HOLD (tts (s j) t)", "case True \\<comment> \\<open>\\<open>tt\\<close> has finished releasing the lock \\<close>"], ["proof (state)\nthis:\n  \\<exists>k'. ts tt = REL k'\n\ngoal (2 subgoals):\n 1. \\<exists>k'. ts tt = REL k' \\<Longrightarrow>\n    \\<exists>j>i. is_HOLD (tts (s j) t)\n 2. \\<nexists>k'. ts tt = REL k' \\<Longrightarrow>\n    \\<exists>j>i. is_HOLD (tts (s j) t)", "then"], ["proof (chain)\npicking this:\n  \\<exists>k'. ts tt = REL k'", "have [simp]: \"ts tt = REL c\""], ["proof (prove)\nusing this:\n  \\<exists>k'. ts tt = REL k'\n\ngoal (1 subgoal):\n 1. ts tt = REL c", "using UTT"], ["proof (prove)\nusing this:\n  \\<exists>k'. ts tt = REL k'\n  tt < N\n  has_ticket (ts tt) c\n\ngoal (1 subgoal):\n 1. ts tt = REL c", "by auto"], ["proof (state)\nthis:\n  ts tt = REL c\n\ngoal (2 subgoals):\n 1. \\<exists>k'. ts tt = REL k' \\<Longrightarrow>\n    \\<exists>j>i. is_HOLD (tts (s j) t)\n 2. \\<nexists>k'. ts tt = REL k' \\<Longrightarrow>\n    \\<exists>j>i. is_HOLD (tts (s j) t)", "text \\<open>Thus, current increases\\<close>"], ["proof (state)\nthis:\n  ts tt = REL c\n\ngoal (2 subgoals):\n 1. \\<exists>k'. ts tt = REL k' \\<Longrightarrow>\n    \\<exists>j>i. is_HOLD (tts (s j) t)\n 2. \\<nexists>k'. ts tt = REL k' \\<Longrightarrow>\n    \\<exists>j>i. is_HOLD (tts (s j) t)", "have [simp]: \"c' = Suc c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c' = Suc c", "using THIS"], ["proof (prove)\nusing this:\n  A.rstep tt s i\n\ngoal (1 subgoal):\n 1. c' = Suc c", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. A.rstep tt s i \\<Longrightarrow> c' = Suc c", "unfolding A.rstep_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. alstep tt (s i) (s (Suc i)) \\<Longrightarrow> c' = Suc c", "apply (erule alstep.cases, erule astep_sng.cases)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>ca n ts c'a n' s' caa na.\n       \\<lbrakk>s i = (ca, n, ts); s (Suc i) = (c'a, n', ts(tt := s'));\n        tt < N; (ca, n, ts tt) = (caa, na, INIT);\n        (c'a, n', s') = (caa, na + 1, WAIT na)\\<rbrakk>\n       \\<Longrightarrow> c' = Suc c\n 2. \\<And>ca n ts c'a n' s' caa k na.\n       \\<lbrakk>s i = (ca, n, ts); s (Suc i) = (c'a, n', ts(tt := s'));\n        tt < N; (ca, n, ts tt) = (caa, na, WAIT k);\n        (c'a, n', s') = (caa, na, WAIT k); caa \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> c' = Suc c\n 3. \\<And>ca n ts c'a n' s' caa na.\n       \\<lbrakk>s i = (ca, n, ts); s (Suc i) = (c'a, n', ts(tt := s'));\n        tt < N; (ca, n, ts tt) = (caa, na, WAIT caa);\n        (c'a, n', s') = (caa, na, HOLD caa)\\<rbrakk>\n       \\<Longrightarrow> c' = Suc c\n 4. \\<And>ca n ts c'a n' s' caa na k.\n       \\<lbrakk>s i = (ca, n, ts); s (Suc i) = (c'a, n', ts(tt := s'));\n        tt < N; (ca, n, ts tt) = (caa, na, HOLD k);\n        (c'a, n', s') = (caa, na, REL k)\\<rbrakk>\n       \\<Longrightarrow> c' = Suc c\n 5. \\<And>ca n ts c'a n' s' caa na k.\n       \\<lbrakk>s i = (ca, n, ts); s (Suc i) = (c'a, n', ts(tt := s'));\n        tt < N; (ca, n, ts tt) = (caa, na, REL k);\n        (c'a, n', s') = (k + 1, na, INIT)\\<rbrakk>\n       \\<Longrightarrow> c' = Suc c", "by auto"], ["proof (state)\nthis:\n  c' = Suc c\n\ngoal (2 subgoals):\n 1. \\<exists>k'. ts tt = REL k' \\<Longrightarrow>\n    \\<exists>j>i. is_HOLD (tts (s j) t)\n 2. \\<nexists>k'. ts tt = REL k' \\<Longrightarrow>\n    \\<exists>j>i. is_HOLD (tts (s j) t)", "text \\<open>But is still less than \\<open>k\\<close>\\<close>"], ["proof (state)\nthis:\n  c' = Suc c\n\ngoal (2 subgoals):\n 1. \\<exists>k'. ts tt = REL k' \\<Longrightarrow>\n    \\<exists>j>i. is_HOLD (tts (s j) t)\n 2. \\<nexists>k'. ts tt = REL k' \\<Longrightarrow>\n    \\<exists>j>i. is_HOLD (tts (s j) t)", "from A.invar_reachable[OF is_invar1 R]"], ["proof (chain)\npicking this:\n  invar1 (c, n, ts)", "have \"k>c\""], ["proof (prove)\nusing this:\n  invar1 (c, n, ts)\n\ngoal (1 subgoal):\n 1. c < k", "apply (auto simp: invar1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<le> n;\n     \\<forall>t k.\n        t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n        c \\<le> k \\<and>\n        k < n \\<and>\n        (\\<forall>t' k'.\n            t' < N \\<and>\n            has_ticket (ts t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n            k \\<noteq> k') \\<and>\n        (\\<forall>k.\n            k \\<noteq> c \\<longrightarrow>\n            \\<not> locks_ticket (ts t) k)\\<rbrakk>\n    \\<Longrightarrow> c < k", "by (metis UTT WAIT \\<open>ts tt = REL c\\<close> le_neq_implies_less \n                less.prems(1) thread.distinct(9) has_ticket_simps(2))"], ["proof (state)\nthis:\n  c < k\n\ngoal (2 subgoals):\n 1. \\<exists>k'. ts tt = REL k' \\<Longrightarrow>\n    \\<exists>j>i. is_HOLD (tts (s j) t)\n 2. \\<nexists>k'. ts tt = REL k' \\<Longrightarrow>\n    \\<exists>j>i. is_HOLD (tts (s j) t)", "text \\<open>And we can apply the induction hypothesis\\<close>"], ["proof (state)\nthis:\n  c < k\n\ngoal (2 subgoals):\n 1. \\<exists>k'. ts tt = REL k' \\<Longrightarrow>\n    \\<exists>j>i. is_HOLD (tts (s j) t)\n 2. \\<nexists>k'. ts tt = REL k' \\<Longrightarrow>\n    \\<exists>j>i. is_HOLD (tts (s j) t)", "hence \"(Suc i, i) \\<in> lrel\""], ["proof (prove)\nusing this:\n  c < k\n\ngoal (1 subgoal):\n 1. (Suc i, i) \\<in> lrel", "unfolding lrel_def"], ["proof (prove)\nusing this:\n  c < k\n\ngoal (1 subgoal):\n 1. (Suc i, i)\n    \\<in> inv_image (measure id <*lex*> measure id <*lex*> measure id)\n           (\\<lambda>i.\n               (k - cc (s i),\n                tweight (tts (s i) (tkt_thread (tts (s i)) (cc (s i)))),\n                A.dist_step (tkt_thread (tts (s i)) (cc (s i))) i))", "by auto"], ["proof (state)\nthis:\n  (Suc i, i) \\<in> lrel\n\ngoal (2 subgoals):\n 1. \\<exists>k'. ts tt = REL k' \\<Longrightarrow>\n    \\<exists>j>i. is_HOLD (tts (s j) t)\n 2. \\<nexists>k'. ts tt = REL k' \\<Longrightarrow>\n    \\<exists>j>i. is_HOLD (tts (s j) t)", "with less.IH[of \"Suc i\"] \\<open>t<N\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>(Suc i, i) \\<in> lrel; t < N; tts (s (Suc i)) t = WAIT k\\<rbrakk>\n  \\<Longrightarrow> \\<exists>j>Suc i. is_HOLD (tts (s j) t)\n  t < N\n  (Suc i, i) \\<in> lrel", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(Suc i, i) \\<in> lrel; t < N; tts (s (Suc i)) t = WAIT k\\<rbrakk>\n  \\<Longrightarrow> \\<exists>j>Suc i. is_HOLD (tts (s j) t)\n  t < N\n  (Suc i, i) \\<in> lrel\n\ngoal (1 subgoal):\n 1. \\<exists>j>i. is_HOLD (tts (s j) t)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>t < N; (Suc i, i) \\<in> lrel; Suc i < j;\n        is_HOLD (tts (s j) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)", "using Suc_lessD"], ["proof (prove)\nusing this:\n  Suc ?m < ?n \\<Longrightarrow> ?m < ?n\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>t < N; (Suc i, i) \\<in> lrel; Suc i < j;\n        is_HOLD (tts (s j) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)", "by blast"], ["proof (state)\nthis:\n  \\<exists>j>i. is_HOLD (tts (s j) t)\n\ngoal (1 subgoal):\n 1. \\<nexists>k'. ts tt = REL k' \\<Longrightarrow>\n    \\<exists>j>i. is_HOLD (tts (s j) t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>k'. ts tt = REL k' \\<Longrightarrow>\n    \\<exists>j>i. is_HOLD (tts (s j) t)", "case False \\<comment> \\<open>\\<open>tt\\<close> has acquired the lock, or started releasing it\\<close>"], ["proof (state)\nthis:\n  \\<nexists>k'. ts tt = REL k'\n\ngoal (1 subgoal):\n 1. \\<nexists>k'. ts tt = REL k' \\<Longrightarrow>\n    \\<exists>j>i. is_HOLD (tts (s j) t)", "text \\<open>Hence, current remains the same, but the weight of \\<open>tt\\<close> decreases\\<close>"], ["proof (state)\nthis:\n  \\<nexists>k'. ts tt = REL k'\n\ngoal (1 subgoal):\n 1. \\<nexists>k'. ts tt = REL k' \\<Longrightarrow>\n    \\<exists>j>i. is_HOLD (tts (s j) t)", "hence [simp]: \"\n              c' = c \n            \\<and> tweight (ts tt) > tweight (ts' tt) \n            \\<and> has_ticket (ts' tt) c\""], ["proof (prove)\nusing this:\n  \\<nexists>k'. ts tt = REL k'\n\ngoal (1 subgoal):\n 1. c' = c \\<and>\n    tweight (ts' tt) < tweight (ts tt) \\<and> has_ticket (ts' tt) c", "using THIS UTT"], ["proof (prove)\nusing this:\n  \\<nexists>k'. ts tt = REL k'\n  A.rstep tt s i\n  tt < N\n  has_ticket (ts tt) c\n\ngoal (1 subgoal):\n 1. c' = c \\<and>\n    tweight (ts' tt) < tweight (ts tt) \\<and> has_ticket (ts' tt) c", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nexists>k'. ts tt = REL k'; A.rstep tt s i; tt < N;\n     has_ticket (ts tt) c\\<rbrakk>\n    \\<Longrightarrow> c' = c \\<and>\n                      tweight (ts' tt) < tweight (ts tt) \\<and>\n                      has_ticket (ts' tt) c", "unfolding A.rstep_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nexists>k'. ts tt = REL k'; alstep tt (s i) (s (Suc i));\n     tt < N; has_ticket (ts tt) c\\<rbrakk>\n    \\<Longrightarrow> c' = c \\<and>\n                      tweight (ts' tt) < tweight (ts tt) \\<and>\n                      has_ticket (ts' tt) c", "apply (erule alstep.cases, erule astep_sng.cases)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>ca n tsa c'a n' s' caa na.\n       \\<lbrakk>\\<nexists>k'. ts tt = REL k'; tt < N; has_ticket (ts tt) c;\n        s i = (ca, n, tsa); s (Suc i) = (c'a, n', tsa(tt := s')); tt < N;\n        (ca, n, tsa tt) = (caa, na, INIT);\n        (c'a, n', s') = (caa, na + 1, WAIT na)\\<rbrakk>\n       \\<Longrightarrow> c' = c \\<and>\n                         tweight (ts' tt) < tweight (ts tt) \\<and>\n                         has_ticket (ts' tt) c\n 2. \\<And>ca n tsa c'a n' s' caa k na.\n       \\<lbrakk>\\<nexists>k'. ts tt = REL k'; tt < N; has_ticket (ts tt) c;\n        s i = (ca, n, tsa); s (Suc i) = (c'a, n', tsa(tt := s')); tt < N;\n        (ca, n, tsa tt) = (caa, na, WAIT k);\n        (c'a, n', s') = (caa, na, WAIT k); caa \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> c' = c \\<and>\n                         tweight (ts' tt) < tweight (ts tt) \\<and>\n                         has_ticket (ts' tt) c\n 3. \\<And>ca n tsa c'a n' s' caa na.\n       \\<lbrakk>\\<nexists>k'. ts tt = REL k'; tt < N; has_ticket (ts tt) c;\n        s i = (ca, n, tsa); s (Suc i) = (c'a, n', tsa(tt := s')); tt < N;\n        (ca, n, tsa tt) = (caa, na, WAIT caa);\n        (c'a, n', s') = (caa, na, HOLD caa)\\<rbrakk>\n       \\<Longrightarrow> c' = c \\<and>\n                         tweight (ts' tt) < tweight (ts tt) \\<and>\n                         has_ticket (ts' tt) c\n 4. \\<And>ca n tsa c'a n' s' caa na k.\n       \\<lbrakk>\\<nexists>k'. ts tt = REL k'; tt < N; has_ticket (ts tt) c;\n        s i = (ca, n, tsa); s (Suc i) = (c'a, n', tsa(tt := s')); tt < N;\n        (ca, n, tsa tt) = (caa, na, HOLD k);\n        (c'a, n', s') = (caa, na, REL k)\\<rbrakk>\n       \\<Longrightarrow> c' = c \\<and>\n                         tweight (ts' tt) < tweight (ts tt) \\<and>\n                         has_ticket (ts' tt) c\n 5. \\<And>ca n tsa c'a n' s' caa na k.\n       \\<lbrakk>\\<nexists>k'. ts tt = REL k'; tt < N; has_ticket (ts tt) c;\n        s i = (ca, n, tsa); s (Suc i) = (c'a, n', tsa(tt := s')); tt < N;\n        (ca, n, tsa tt) = (caa, na, REL k);\n        (c'a, n', s') = (k + 1, na, INIT)\\<rbrakk>\n       \\<Longrightarrow> c' = c \\<and>\n                         tweight (ts' tt) < tweight (ts tt) \\<and>\n                         has_ticket (ts' tt) c", "by (auto simp: has_ticket_def tweight_def)"], ["proof (state)\nthis:\n  c' = c \\<and>\n  tweight (ts' tt) < tweight (ts tt) \\<and> has_ticket (ts' tt) c\n\ngoal (1 subgoal):\n 1. \\<nexists>k'. ts tt = REL k' \\<Longrightarrow>\n    \\<exists>j>i. is_HOLD (tts (s j) t)", "text \\<open>\\<open>tt\\<close> still holds the current lock\\<close>"], ["proof (state)\nthis:\n  c' = c \\<and>\n  tweight (ts' tt) < tweight (ts tt) \\<and> has_ticket (ts' tt) c\n\ngoal (1 subgoal):\n 1. \\<nexists>k'. ts tt = REL k' \\<Longrightarrow>\n    \\<exists>j>i. is_HOLD (tts (s j) t)", "have [simp]: \"tkt_thread ts' c = tt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tkt_thread ts' c = tt", "using tkt_thread_eq[OF R' \\<open>tt<N\\<close>, of c]"], ["proof (prove)\nusing this:\n  has_ticket (ts' tt) c \\<Longrightarrow> tkt_thread ts' c = tt\n\ngoal (1 subgoal):\n 1. tkt_thread ts' c = tt", "by simp"], ["proof (state)\nthis:\n  tkt_thread ts' c = tt\n\ngoal (1 subgoal):\n 1. \\<nexists>k'. ts tt = REL k' \\<Longrightarrow>\n    \\<exists>j>i. is_HOLD (tts (s j) t)", "text \\<open>And we can apply the IH\\<close>"], ["proof (state)\nthis:\n  tkt_thread ts' c = tt\n\ngoal (1 subgoal):\n 1. \\<nexists>k'. ts tt = REL k' \\<Longrightarrow>\n    \\<exists>j>i. is_HOLD (tts (s j) t)", "have \"(Suc i, i) \\<in> lrel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc i, i) \\<in> lrel", "unfolding lrel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Suc i, i)\n    \\<in> inv_image (measure id <*lex*> measure id <*lex*> measure id)\n           (\\<lambda>i.\n               (k - cc (s i),\n                tweight (tts (s i) (tkt_thread (tts (s i)) (cc (s i)))),\n                A.dist_step (tkt_thread (tts (s i)) (cc (s i))) i))", "by auto"], ["proof (state)\nthis:\n  (Suc i, i) \\<in> lrel\n\ngoal (1 subgoal):\n 1. \\<nexists>k'. ts tt = REL k' \\<Longrightarrow>\n    \\<exists>j>i. is_HOLD (tts (s j) t)", "with less.IH[of \"Suc i\"] \\<open>t<N\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>(Suc i, i) \\<in> lrel; t < N; tts (s (Suc i)) t = WAIT k\\<rbrakk>\n  \\<Longrightarrow> \\<exists>j>Suc i. is_HOLD (tts (s j) t)\n  t < N\n  (Suc i, i) \\<in> lrel", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(Suc i, i) \\<in> lrel; t < N; tts (s (Suc i)) t = WAIT k\\<rbrakk>\n  \\<Longrightarrow> \\<exists>j>Suc i. is_HOLD (tts (s j) t)\n  t < N\n  (Suc i, i) \\<in> lrel\n\ngoal (1 subgoal):\n 1. \\<exists>j>i. is_HOLD (tts (s j) t)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>t < N; (Suc i, i) \\<in> lrel; Suc i < j;\n        is_HOLD (tts (s j) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)", "using Suc_lessD"], ["proof (prove)\nusing this:\n  Suc ?m < ?n \\<Longrightarrow> ?m < ?n\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>t < N; (Suc i, i) \\<in> lrel; Suc i < j;\n        is_HOLD (tts (s j) t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)", "by blast"], ["proof (state)\nthis:\n  \\<exists>j>i. is_HOLD (tts (s j) t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>j>i. is_HOLD (tts (s j) t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>j>i. is_HOLD (tts (s j) t)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> lrel; t < N;\n                    tts (s y) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j>y. is_HOLD (tts (s j) t);\n        t < N; tts (s x) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>x. is_HOLD (tts (s j) t)", "}"], ["proof (state)\nthis:\n  ts' t = WAIT k \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>(y, x) \\<in> lrel; t < N;\n                    tts (s y) t = WAIT k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>j>y. is_HOLD (tts (s j) t);\n        t < N; tts (s x) t = WAIT k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>x. is_HOLD (tts (s j) t)", "ultimately"], ["proof (chain)\npicking this:\n  ts' t \\<noteq> WAIT k \\<Longrightarrow>\n  \\<exists>j>i. is_HOLD (tts (s j) t)\n  ts' t = WAIT k \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)", "show ?case"], ["proof (prove)\nusing this:\n  ts' t \\<noteq> WAIT k \\<Longrightarrow>\n  \\<exists>j>i. is_HOLD (tts (s j) t)\n  ts' t = WAIT k \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)\n\ngoal (1 subgoal):\n 1. \\<exists>j>i. is_HOLD (tts (s j) t)", "by blast"], ["proof (state)\nthis:\n  \\<exists>j>i. is_HOLD (tts (s j) t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>j>i. is_HOLD (tts (s j) t)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Refinement 2: Bounding the Counters\\<close>"], ["", "text \\<open>We fix the \\<open>k\\<close> from the task description, which must be positive\\<close>"], ["", "consts k::nat"], ["", "specification (k) k_not0[simp]: \"k\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. k \\<noteq> 0", "by auto"], ["", "lemma k_gt0[simp]: \"0<k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k", "by (cases k) auto"], ["", "text \\<open>System's state: Current ticket, next ticket, thread states\\<close>"], ["", "type_synonym bstate = \"nat \\<times> nat \\<times> (nat \\<Rightarrow> thread)\""], ["", "text \\<open>The step relation of a single thread\\<close>"], ["", "inductive bstep_sng where\n    enter_wait: \"bstep_sng (c,n,INIT) (c,(n+1) mod (k*N),WAIT (n mod N))\"\n  | loop_wait: \"c\\<noteq>tk \\<Longrightarrow> bstep_sng (c,n,WAIT tk) (c,n,WAIT tk)\"\n  | exit_wait: \"bstep_sng (c,n,WAIT c) (c,n,HOLD c)\"\n  | start_release: \"bstep_sng (c,n,HOLD tk) (c,n,REL tk)\"\n  | release: \"bstep_sng (c,n,REL tk) ((tk+1) mod N,n,INIT)\""], ["", "text \\<open>The step relation of the system, labeled with the thread \\<open>t\\<close> that performs the step\\<close>"], ["", "inductive blstep for t where\n    \"\\<lbrakk> t<N; bstep_sng (c,n,ts t) (c',n',s') \\<rbrakk> \n      \\<Longrightarrow> blstep t (c,n,ts) (c',n',ts(t:=s'))\""], ["", "text \\<open>Initial state of the system\\<close>"], ["", "definition \"bs\\<^sub>0 \\<equiv> (0, 0, \\<lambda>_. INIT)\""], ["", "interpretation B: system bs\\<^sub>0 blstep"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma b_never_blocked: \"B.can_step l s \\<longleftrightarrow> l<N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B.can_step l s = (l < N)", "apply (cases s; cases \"tts s l\"; simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>s = (a, b, c); c l = INIT\\<rbrakk>\n       \\<Longrightarrow> B.can_step l (a, b, c) = (l < N)\n 2. \\<And>a b c x2.\n       \\<lbrakk>s = (a, b, c); c l = WAIT x2\\<rbrakk>\n       \\<Longrightarrow> B.can_step l (a, b, c) = (l < N)\n 3. \\<And>a b c x3.\n       \\<lbrakk>s = (a, b, c); c l = HOLD x3\\<rbrakk>\n       \\<Longrightarrow> B.can_step l (a, b, c) = (l < N)\n 4. \\<And>a b c x4.\n       \\<lbrakk>s = (a, b, c); c l = REL x4\\<rbrakk>\n       \\<Longrightarrow> B.can_step l (a, b, c) = (l < N)", "unfolding B.can_step_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>s = (a, b, c); c l = INIT\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s'. blstep l (a, b, c) s') = (l < N)\n 2. \\<And>a b c x2.\n       \\<lbrakk>s = (a, b, c); c l = WAIT x2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s'. blstep l (a, b, c) s') = (l < N)\n 3. \\<And>a b c x3.\n       \\<lbrakk>s = (a, b, c); c l = HOLD x3\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s'. blstep l (a, b, c) s') = (l < N)\n 4. \\<And>a b c x4.\n       \\<lbrakk>s = (a, b, c); c l = REL x4\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s'. blstep l (a, b, c) s') = (l < N)", "apply (clarsimp simp: blstep.simps bstep_sng.simps; blast)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation B: df_system bs\\<^sub>0 blstep"], ["proof (prove)\ngoal (1 subgoal):\n 1. df_system bs\\<^sub>0 blstep", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. B.reachable s \\<Longrightarrow> \\<exists>s'. B.step s s'", "subgoal for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. B.reachable s \\<Longrightarrow> \\<exists>s'. B.step s s'", "using b_never_blocked[of 0 s]"], ["proof (prove)\nusing this:\n  B.can_step 0 s = (0 < N)\n\ngoal (1 subgoal):\n 1. B.reachable s \\<Longrightarrow> \\<exists>s'. B.step s s'", "unfolding B.can_step_def"], ["proof (prove)\nusing this:\n  (\\<exists>s'. blstep 0 s s') = (0 < N)\n\ngoal (1 subgoal):\n 1. B.reachable s \\<Longrightarrow> \\<exists>s'. B.step s s'", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Simulation\\<close>"], ["", "text \\<open>We show that the abstract system simulates the concrete one.\\<close>"], ["", "text \\<open>A few lemmas to ease the automation further below\\<close>"], ["", "lemma nat_sum_gtZ_iff[simp]: \n    \"finite s \\<Longrightarrow> sum f s \\<noteq> (0::nat) \\<longleftrightarrow> (\\<exists>x\\<in>s. f x \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite s \\<Longrightarrow>\n    (sum f s \\<noteq> 0) = (\\<exists>x\\<in>s. f x \\<noteq> 0)", "by simp"], ["", "lemma n_eq_Suc_sub1_conv[simp]: \"n = Suc (n - Suc 0) \\<longleftrightarrow> n\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n = Suc (n - Suc 0)) = (n \\<noteq> 0)", "by auto"], ["", "lemma mod_mult_mod_eq[mod_simps]: \"x mod (k * N) mod N = x mod N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x mod (k * N) mod N = x mod N", "by (meson dvd_eq_mod_eq_0 mod_mod_cancel mod_mult_self2_is_0)"], ["", "lemma mod_eq_imp_eq_aux: \"b mod N = (a::nat) mod N \\<Longrightarrow> a\\<le>b \\<Longrightarrow> b<a+N \\<Longrightarrow> b=a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b mod N = a mod N; a \\<le> b; b < a + N\\<rbrakk>\n    \\<Longrightarrow> b = a", "using nat_mod_eq_lemma"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x mod ?n = ?y mod ?n; ?y \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q. ?x = ?y + ?n * q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b mod N = a mod N; a \\<le> b; b < a + N\\<rbrakk>\n    \\<Longrightarrow> b = a", "by force"], ["", "lemma mod_eq_imp_eq: \n    \"\\<lbrakk>b \\<le> x; x < b + N; b \\<le> y; y < b + N; x mod N = y mod N \\<rbrakk> \\<Longrightarrow> x=y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<le> x; x < b + N; b \\<le> y; y < b + N;\n     x mod N = y mod N\\<rbrakk>\n    \\<Longrightarrow> x = y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<le> x; x < b + N; b \\<le> y; y < b + N;\n     x mod N = y mod N\\<rbrakk>\n    \\<Longrightarrow> x = y", "assume a1: \"b \\<le> y\""], ["proof (state)\nthis:\n  b \\<le> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<le> x; x < b + N; b \\<le> y; y < b + N;\n     x mod N = y mod N\\<rbrakk>\n    \\<Longrightarrow> x = y", "assume a2: \"y < b + N\""], ["proof (state)\nthis:\n  y < b + N\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<le> x; x < b + N; b \\<le> y; y < b + N;\n     x mod N = y mod N\\<rbrakk>\n    \\<Longrightarrow> x = y", "assume a3: \"b \\<le> x\""], ["proof (state)\nthis:\n  b \\<le> x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<le> x; x < b + N; b \\<le> y; y < b + N;\n     x mod N = y mod N\\<rbrakk>\n    \\<Longrightarrow> x = y", "assume a4: \"x < b + N\""], ["proof (state)\nthis:\n  x < b + N\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<le> x; x < b + N; b \\<le> y; y < b + N;\n     x mod N = y mod N\\<rbrakk>\n    \\<Longrightarrow> x = y", "assume a5: \"x mod N = y mod N\""], ["proof (state)\nthis:\n  x mod N = y mod N\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<le> x; x < b + N; b \\<le> y; y < b + N;\n     x mod N = y mod N\\<rbrakk>\n    \\<Longrightarrow> x = y", "have f6: \"x < y + N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y + N", "using a4 a1"], ["proof (prove)\nusing this:\n  x < b + N\n  b \\<le> y\n\ngoal (1 subgoal):\n 1. x < y + N", "by linarith"], ["proof (state)\nthis:\n  x < y + N\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<le> x; x < b + N; b \\<le> y; y < b + N;\n     x mod N = y mod N\\<rbrakk>\n    \\<Longrightarrow> x = y", "have \"y < x + N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y < x + N", "using a3 a2"], ["proof (prove)\nusing this:\n  b \\<le> x\n  y < b + N\n\ngoal (1 subgoal):\n 1. y < x + N", "by linarith"], ["proof (state)\nthis:\n  y < x + N\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<le> x; x < b + N; b \\<le> y; y < b + N;\n     x mod N = y mod N\\<rbrakk>\n    \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  y < x + N", "show ?thesis"], ["proof (prove)\nusing this:\n  y < x + N\n\ngoal (1 subgoal):\n 1. x = y", "using f6 a5"], ["proof (prove)\nusing this:\n  y < x + N\n  x < y + N\n  x mod N = y mod N\n\ngoal (1 subgoal):\n 1. x = y", "by (metis (no_types) mod_eq_imp_eq_aux nat_le_linear)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Map the ticket of a thread\\<close>"], ["", "fun map_ticket where\n    \"map_ticket f INIT = INIT\"\n  | \"map_ticket f (WAIT tk) = WAIT (f tk)\"\n  | \"map_ticket f (HOLD tk) = HOLD (f tk)\"\n  | \"map_ticket f (REL tk) = REL (f tk)\""], ["", "lemma map_ticket_addsimps[simp]:\n    \"map_ticket f t = INIT \\<longleftrightarrow> t=INIT\"  \n    \"map_ticket f t = WAIT tk \\<longleftrightarrow> (\\<exists>tk'. tk=f tk' \\<and> t=WAIT tk')\"\n    \"map_ticket f t = HOLD tk \\<longleftrightarrow> (\\<exists>tk'. tk=f tk' \\<and> t=HOLD tk')\"\n    \"map_ticket f t = REL tk \\<longleftrightarrow> (\\<exists>tk'. tk=f tk' \\<and> t=REL tk')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((map_ticket f t = INIT) = (t = INIT) &&&\n     (map_ticket f t = WAIT tk) =\n     (\\<exists>tk'. tk = f tk' \\<and> t = WAIT tk')) &&&\n    (map_ticket f t = HOLD tk) =\n    (\\<exists>tk'. tk = f tk' \\<and> t = HOLD tk') &&&\n    (map_ticket f t = REL tk) =\n    (\\<exists>tk'. tk = f tk' \\<and> t = REL tk')", "by (cases t; auto)+"], ["", "text \\<open>We define the number of threads that use a ticket\\<close>"], ["", "fun ni_weight :: \"thread \\<Rightarrow> nat\" where\n    \"ni_weight INIT = 0\" | \"ni_weight _ = 1\""], ["", "lemma ni_weight_le1[simp]: \"ni_weight s \\<le> Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ni_weight s \\<le> Suc 0", "by (cases s) auto"], ["", "definition \"num_ni ts \\<equiv> \\<Sum> i=0..<N. ni_weight (ts i)\""], ["", "lemma num_ni_init[simp]: \"num_ni (\\<lambda>_. INIT) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_ni (\\<lambda>_. INIT) = 0", "by (auto simp: num_ni_def)"], ["", "lemma num_ni_upd: \n    \"t<N \\<Longrightarrow> num_ni (ts(t:=s)) = num_ni ts - ni_weight (ts t) + ni_weight s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t < N \\<Longrightarrow>\n    num_ni (ts(t := s)) = num_ni ts - ni_weight (ts t) + ni_weight s", "by (auto \n      simp: num_ni_def if_distrib[of ni_weight] sum.If_cases algebra_simps\n      simp: sum_diff1_nat\n      )"], ["", "lemma num_ni_nz_if[simp]: \"\\<lbrakk>t < N; ts t \\<noteq> INIT\\<rbrakk> \\<Longrightarrow> num_ni ts \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t < N; ts t \\<noteq> INIT\\<rbrakk>\n    \\<Longrightarrow> num_ni ts \\<noteq> 0", "apply (cases \"ts t\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>t < N; ts t \\<noteq> INIT; ts t = INIT\\<rbrakk>\n    \\<Longrightarrow> num_ni ts \\<noteq> 0\n 2. \\<And>x2.\n       \\<lbrakk>t < N; ts t \\<noteq> INIT; ts t = WAIT x2\\<rbrakk>\n       \\<Longrightarrow> num_ni ts \\<noteq> 0\n 3. \\<And>x3.\n       \\<lbrakk>t < N; ts t \\<noteq> INIT; ts t = HOLD x3\\<rbrakk>\n       \\<Longrightarrow> num_ni ts \\<noteq> 0\n 4. \\<And>x4.\n       \\<lbrakk>t < N; ts t \\<noteq> INIT; ts t = REL x4\\<rbrakk>\n       \\<Longrightarrow> num_ni ts \\<noteq> 0", "by (simp_all add: num_ni_def) force+"], ["", "lemma num_ni_leN: \"num_ni ts \\<le> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_ni ts \\<le> N", "apply (clarsimp simp: num_ni_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<N. ni_weight (ts i)) \\<le> N", "apply (rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<Sum>i = 0..<N. ni_weight (ts i)) \\<le> ?y\n 2. ?y \\<le> N", "apply (rule sum_bounded_above[where K=1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i. i \\<in> {0..<N} \\<Longrightarrow> ni_weight (ts i) \\<le> 1\n 2. of_nat (card {0..<N}) * 1 \\<le> N", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>We provide an additional invariant, considering the distance of \n    \\<open>c\\<close> and \\<open>n\\<close>. Although we could probably get this from the previous \n    invariants, it is easy enough to prove directly.\n  \\<close>"], ["", "definition \"invar3 \\<equiv> \\<lambda>(c,n,ts). n = c + num_ni ts\""], ["", "lemma is_invar3: \"A.is_invar invar3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A.is_invar invar3", "apply (rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. invar3 as\\<^sub>0\n 2. \\<And>s s'.\n       \\<lbrakk>A.reachable s; invar3 s; A.step s s'\\<rbrakk>\n       \\<Longrightarrow> invar3 s'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar3 as\\<^sub>0", "by (auto simp: invar3_def as\\<^sub>0_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>A.reachable s; invar3 s; A.step s s'\\<rbrakk>\n       \\<Longrightarrow> invar3 s'", "subgoal for s s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A.reachable s; invar3 s; A.step s s'\\<rbrakk>\n    \\<Longrightarrow> invar3 s'", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>A.reachable s; invar3 s; alstep l s s'\\<rbrakk>\n       \\<Longrightarrow> invar3 s'", "apply (erule alstep.cases, erule astep_sng.cases)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>l c n ts c' n' s'a ca na.\n       \\<lbrakk>A.reachable s; invar3 s; s = (c, n, ts);\n        s' = (c', n', ts(l := s'a)); l < N; (c, n, ts l) = (ca, na, INIT);\n        (c', n', s'a) = (ca, na + 1, WAIT na)\\<rbrakk>\n       \\<Longrightarrow> invar3 s'\n 2. \\<And>l c n ts c' n' s'a ca k na.\n       \\<lbrakk>A.reachable s; invar3 s; s = (c, n, ts);\n        s' = (c', n', ts(l := s'a)); l < N; (c, n, ts l) = (ca, na, WAIT k);\n        (c', n', s'a) = (ca, na, WAIT k); ca \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> invar3 s'\n 3. \\<And>l c n ts c' n' s'a ca na.\n       \\<lbrakk>A.reachable s; invar3 s; s = (c, n, ts);\n        s' = (c', n', ts(l := s'a)); l < N;\n        (c, n, ts l) = (ca, na, WAIT ca);\n        (c', n', s'a) = (ca, na, HOLD ca)\\<rbrakk>\n       \\<Longrightarrow> invar3 s'\n 4. \\<And>l c n ts c' n' s'a ca na k.\n       \\<lbrakk>A.reachable s; invar3 s; s = (c, n, ts);\n        s' = (c', n', ts(l := s'a)); l < N; (c, n, ts l) = (ca, na, HOLD k);\n        (c', n', s'a) = (ca, na, REL k)\\<rbrakk>\n       \\<Longrightarrow> invar3 s'\n 5. \\<And>l c n ts c' n' s'a ca na k.\n       \\<lbrakk>A.reachable s; invar3 s; s = (c, n, ts);\n        s' = (c', n', ts(l := s'a)); l < N; (c, n, ts l) = (ca, na, REL k);\n        (c', n', s'a) = (k + 1, na, INIT)\\<rbrakk>\n       \\<Longrightarrow> invar3 s'", "apply (auto simp: invar3_def num_ni_upd)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l c ts k.\n       \\<lbrakk>A.reachable (c, c + num_ni ts, ts);\n        s = (c, c + num_ni ts, ts);\n        s' = (Suc k, c + num_ni ts, ts(l := INIT)); l < N;\n        ts l = REL k\\<rbrakk>\n       \\<Longrightarrow> c + num_ni ts = Suc (k + (num_ni ts - Suc 0))", "using holds_only_current"], ["proof (prove)\nusing this:\n  \\<lbrakk>A.reachable (?c, ?n, ?ts); ?t < N;\n   locks_ticket (?ts ?t) ?k\\<rbrakk>\n  \\<Longrightarrow> ?k = ?c\n\ngoal (1 subgoal):\n 1. \\<And>l c ts k.\n       \\<lbrakk>A.reachable (c, c + num_ni ts, ts);\n        s = (c, c + num_ni ts, ts);\n        s' = (Suc k, c + num_ni ts, ts(l := INIT)); l < N;\n        ts l = REL k\\<rbrakk>\n       \\<Longrightarrow> c + num_ni ts = Suc (k + (num_ni ts - Suc 0))", "by fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>We establish a simulation relation: The concrete counters are \n    the abstract ones, wrapped around.\n  \\<close>"], ["", "definition \"sim_rel1 \\<equiv> \\<lambda>(c,n,ts) (ci,ni,tsi). \n    ci = c mod N\n  \\<and> ni = n mod (k*N)\n  \\<and> tsi = (map_ticket (\\<lambda>t. t mod N)) o ts\n  \""], ["", "lemma sraux: \n    \"sim_rel1 (c,n,ts) (ci,ni,tsi) \\<Longrightarrow> ci = c mod N \\<and> ni = n mod (k*N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sim_rel1 (c, n, ts) (ci, ni, tsi) \\<Longrightarrow>\n    ci = c mod N \\<and> ni = n mod (k * N)", "by (auto simp: sim_rel1_def Let_def)"], ["", "lemma sraux2: \"\\<lbrakk>sim_rel1 (c,n,ts) (ci,ni,tsi); t<N\\<rbrakk> \n    \\<Longrightarrow> tsi t = map_ticket (\\<lambda>x. x mod N) (ts t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sim_rel1 (c, n, ts) (ci, ni, tsi); t < N\\<rbrakk>\n    \\<Longrightarrow> tsi t = map_ticket (\\<lambda>x. x mod N) (ts t)", "by (auto simp: sim_rel1_def Let_def)"], ["", "interpretation sim1: simulationI as\\<^sub>0 alstep bs\\<^sub>0 blstep sim_rel1"], ["proof (prove)\ngoal (1 subgoal):\n 1. simulationI as\\<^sub>0 alstep bs\\<^sub>0 blstep sim_rel1", "proof unfold_locales"], ["proof (state)\ngoal (3 subgoals):\n 1. sim_rel1 as\\<^sub>0 bs\\<^sub>0\n 2. \\<And>as cs l cs'.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        blstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel1 as' cs' \\<and> alstep l as as'\n 3. \\<And>as cs l.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        A.can_step l as\\<rbrakk>\n       \\<Longrightarrow> B.can_step l cs", "show \"sim_rel1 as\\<^sub>0 bs\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sim_rel1 as\\<^sub>0 bs\\<^sub>0", "by (auto simp: sim_rel1_def as\\<^sub>0_def bs\\<^sub>0_def)"], ["proof (state)\nthis:\n  sim_rel1 as\\<^sub>0 bs\\<^sub>0\n\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        blstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel1 as' cs' \\<and> alstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        A.can_step l as\\<rbrakk>\n       \\<Longrightarrow> B.can_step l cs", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        blstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel1 as' cs' \\<and> alstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        A.can_step l as\\<rbrakk>\n       \\<Longrightarrow> B.can_step l cs", "fix as bs t bs'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        blstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel1 as' cs' \\<and> alstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        A.can_step l as\\<rbrakk>\n       \\<Longrightarrow> B.can_step l cs", "assume Ra_aux: \"A.reachable as\" \n       and Rc_aux: \"B.reachable bs\" \n       and SIM: \"sim_rel1 as bs\" \n       and CS: \"blstep t bs bs'\""], ["proof (state)\nthis:\n  A.reachable as\n  B.reachable bs\n  sim_rel1 as bs\n  blstep t bs bs'\n\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        blstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel1 as' cs' \\<and> alstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        A.can_step l as\\<rbrakk>\n       \\<Longrightarrow> B.can_step l cs", "obtain c n ts where [simp]: \"as=(c,n,ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c n ts.\n        as = (c, n, ts) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases as)"], ["proof (state)\nthis:\n  as = (c, n, ts)\n\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        blstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel1 as' cs' \\<and> alstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        A.can_step l as\\<rbrakk>\n       \\<Longrightarrow> B.can_step l cs", "obtain ci ni tsi where [simp]: \"bs=(ci,ni,tsi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ci ni tsi.\n        bs = (ci, ni, tsi) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases bs)"], ["proof (state)\nthis:\n  bs = (ci, ni, tsi)\n\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        blstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel1 as' cs' \\<and> alstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        A.can_step l as\\<rbrakk>\n       \\<Longrightarrow> B.can_step l cs", "obtain ci' ni' tsi' where [simp]: \"bs'=(ci',ni',tsi')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ci' ni' tsi'.\n        bs' = (ci', ni', tsi') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases bs')"], ["proof (state)\nthis:\n  bs' = (ci', ni', tsi')\n\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        blstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel1 as' cs' \\<and> alstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        A.can_step l as\\<rbrakk>\n       \\<Longrightarrow> B.can_step l cs", "from Ra_aux"], ["proof (chain)\npicking this:\n  A.reachable as", "have Ra: \"A.reachable (c,n,ts)\""], ["proof (prove)\nusing this:\n  A.reachable as\n\ngoal (1 subgoal):\n 1. A.reachable (c, n, ts)", "by simp"], ["proof (state)\nthis:\n  A.reachable (c, n, ts)\n\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        blstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel1 as' cs' \\<and> alstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        A.can_step l as\\<rbrakk>\n       \\<Longrightarrow> B.can_step l cs", "from Rc_aux"], ["proof (chain)\npicking this:\n  B.reachable bs", "have Rc: \"B.reachable (ci,ni,tsi)\""], ["proof (prove)\nusing this:\n  B.reachable bs\n\ngoal (1 subgoal):\n 1. B.reachable (ci, ni, tsi)", "by simp"], ["proof (state)\nthis:\n  B.reachable (ci, ni, tsi)\n\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        blstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel1 as' cs' \\<and> alstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        A.can_step l as\\<rbrakk>\n       \\<Longrightarrow> B.can_step l cs", "from CS"], ["proof (chain)\npicking this:\n  blstep t bs bs'", "have \"t<N\""], ["proof (prove)\nusing this:\n  blstep t bs bs'\n\ngoal (1 subgoal):\n 1. t < N", "by cases auto"], ["proof (state)\nthis:\n  t < N\n\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        blstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel1 as' cs' \\<and> alstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        A.can_step l as\\<rbrakk>\n       \\<Longrightarrow> B.can_step l cs", "have [simp]: \"n = c + num_ni ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = c + num_ni ts", "using A.invar_reachable[OF is_invar3 Ra, unfolded invar3_def]"], ["proof (prove)\nusing this:\n  case (c, n, ts) of (c, n, ts) \\<Rightarrow> n = c + num_ni ts\n\ngoal (1 subgoal):\n 1. n = c + num_ni ts", "by simp"], ["proof (state)\nthis:\n  n = c + num_ni ts\n\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        blstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel1 as' cs' \\<and> alstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        A.can_step l as\\<rbrakk>\n       \\<Longrightarrow> B.can_step l cs", "have AUX1: \"c\\<le>tk\" \"tk<c+N\" if \"ts t = WAIT tk\" for tk"], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<le> tk &&& tk < c + N", "using that A.invar_reachable[OF is_invar1 Ra]"], ["proof (prove)\nusing this:\n  ts t = WAIT tk\n  invar1 (c, n, ts)\n\ngoal (1 subgoal):\n 1. c \\<le> tk &&& tk < c + N", "apply (auto simp: invar1_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ts t = WAIT tk;\n     \\<forall>t k.\n        t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n        c \\<le> k \\<and>\n        k < c + num_ni ts \\<and>\n        (\\<forall>t' k'.\n            t' < N \\<and>\n            has_ticket (ts t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n            k \\<noteq> k') \\<and>\n        (\\<forall>k.\n            k \\<noteq> c \\<longrightarrow>\n            \\<not> locks_ticket (ts t) k)\\<rbrakk>\n    \\<Longrightarrow> c \\<le> tk\n 2. \\<lbrakk>ts t = WAIT tk;\n     \\<forall>t k.\n        t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n        c \\<le> k \\<and>\n        k < c + num_ni ts \\<and>\n        (\\<forall>t' k'.\n            t' < N \\<and>\n            has_ticket (ts t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n            k \\<noteq> k') \\<and>\n        (\\<forall>k.\n            k \\<noteq> c \\<longrightarrow>\n            \\<not> locks_ticket (ts t) k)\\<rbrakk>\n    \\<Longrightarrow> tk < c + N", "using \\<open>t<N\\<close>"], ["proof (prove)\nusing this:\n  t < N\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ts t = WAIT tk;\n     \\<forall>t k.\n        t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n        c \\<le> k \\<and>\n        k < c + num_ni ts \\<and>\n        (\\<forall>t' k'.\n            t' < N \\<and>\n            has_ticket (ts t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n            k \\<noteq> k') \\<and>\n        (\\<forall>k.\n            k \\<noteq> c \\<longrightarrow>\n            \\<not> locks_ticket (ts t) k)\\<rbrakk>\n    \\<Longrightarrow> c \\<le> tk\n 2. \\<lbrakk>ts t = WAIT tk;\n     \\<forall>t k.\n        t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n        c \\<le> k \\<and>\n        k < c + num_ni ts \\<and>\n        (\\<forall>t' k'.\n            t' < N \\<and>\n            has_ticket (ts t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n            k \\<noteq> k') \\<and>\n        (\\<forall>k.\n            k \\<noteq> c \\<longrightarrow>\n            \\<not> locks_ticket (ts t) k)\\<rbrakk>\n    \\<Longrightarrow> tk < c + N", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts t = WAIT tk;\n     \\<forall>t k.\n        t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n        c \\<le> k \\<and>\n        k < c + num_ni ts \\<and>\n        (\\<forall>t' k'.\n            t' < N \\<and>\n            has_ticket (ts t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n            k \\<noteq> k') \\<and>\n        (\\<forall>k.\n            k \\<noteq> c \\<longrightarrow>\n            \\<not> locks_ticket (ts t) k)\\<rbrakk>\n    \\<Longrightarrow> tk < c + N", "using \\<open>t<N\\<close> num_ni_leN[of ts]"], ["proof (prove)\nusing this:\n  t < N\n  num_ni ts \\<le> N\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ts t = WAIT tk;\n     \\<forall>t k.\n        t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n        c \\<le> k \\<and>\n        k < c + num_ni ts \\<and>\n        (\\<forall>t' k'.\n            t' < N \\<and>\n            has_ticket (ts t') k' \\<and> t \\<noteq> t' \\<longrightarrow>\n            k \\<noteq> k') \\<and>\n        (\\<forall>k.\n            k \\<noteq> c \\<longrightarrow>\n            \\<not> locks_ticket (ts t) k)\\<rbrakk>\n    \\<Longrightarrow> tk < c + N", "by fastforce"], ["proof (state)\nthis:\n  ts t = WAIT ?tk \\<Longrightarrow> c \\<le> ?tk\n  ts t = WAIT ?tk \\<Longrightarrow> ?tk < c + N\n\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        blstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel1 as' cs' \\<and> alstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        A.can_step l as\\<rbrakk>\n       \\<Longrightarrow> B.can_step l cs", "from SIM CS"], ["proof (chain)\npicking this:\n  sim_rel1 as bs\n  blstep t bs bs'", "have \"\\<exists>as'. alstep t as as' \\<and> sim_rel1 as' bs'\""], ["proof (prove)\nusing this:\n  sim_rel1 as bs\n  blstep t bs bs'\n\ngoal (1 subgoal):\n 1. \\<exists>as'. alstep t as as' \\<and> sim_rel1 as' bs'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi);\n     blstep t (ci, ni, tsi) (ci', ni', tsi')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a aa b.\n                         alstep t (c, c + num_ni ts, ts) (a, aa, b) \\<and>\n                         sim_rel1 (a, aa, b) (ci', ni', tsi')", "apply (erule blstep.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ca n tsa c' n' s'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi);\n        (ci, ni, tsi) = (ca, n, tsa);\n        (ci', ni', tsi') = (c', n', tsa(t := s')); t < N;\n        bstep_sng (ca, n, tsa t) (c', n', s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            alstep t (c, c + num_ni ts, ts)\n                             (a, aa, b) \\<and>\n                            sim_rel1 (a, aa, b) (ci', ni', tsi')", "apply (erule bstep_sng.cases)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>ca n tsa c' n' s' caa na.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi);\n        (ci, ni, tsi) = (ca, n, tsa);\n        (ci', ni', tsi') = (c', n', tsa(t := s')); t < N;\n        (ca, n, tsa t) = (caa, na, INIT);\n        (c', n', s') = (caa, (na + 1) mod (k * N), WAIT (na mod N))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            alstep t (c, c + num_ni ts, ts)\n                             (a, aa, b) \\<and>\n                            sim_rel1 (a, aa, b) (ci', ni', tsi')\n 2. \\<And>ca n tsa c' n' s' caa tk na.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi);\n        (ci, ni, tsi) = (ca, n, tsa);\n        (ci', ni', tsi') = (c', n', tsa(t := s')); t < N;\n        (ca, n, tsa t) = (caa, na, WAIT tk);\n        (c', n', s') = (caa, na, WAIT tk); caa \\<noteq> tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            alstep t (c, c + num_ni ts, ts)\n                             (a, aa, b) \\<and>\n                            sim_rel1 (a, aa, b) (ci', ni', tsi')\n 3. \\<And>ca n tsa c' n' s' caa na.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi);\n        (ci, ni, tsi) = (ca, n, tsa);\n        (ci', ni', tsi') = (c', n', tsa(t := s')); t < N;\n        (ca, n, tsa t) = (caa, na, WAIT caa);\n        (c', n', s') = (caa, na, HOLD caa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            alstep t (c, c + num_ni ts, ts)\n                             (a, aa, b) \\<and>\n                            sim_rel1 (a, aa, b) (ci', ni', tsi')\n 4. \\<And>ca n tsa c' n' s' caa na tk.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi);\n        (ci, ni, tsi) = (ca, n, tsa);\n        (ci', ni', tsi') = (c', n', tsa(t := s')); t < N;\n        (ca, n, tsa t) = (caa, na, HOLD tk);\n        (c', n', s') = (caa, na, REL tk)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            alstep t (c, c + num_ni ts, ts)\n                             (a, aa, b) \\<and>\n                            sim_rel1 (a, aa, b) (ci', ni', tsi')\n 5. \\<And>ca n tsa c' n' s' caa na tk.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi);\n        (ci, ni, tsi) = (ca, n, tsa);\n        (ci', ni', tsi') = (c', n', tsa(t := s')); t < N;\n        (ca, n, tsa t) = (caa, na, REL tk);\n        (c', n', s') = ((tk + 1) mod N, na, INIT)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            alstep t (c, c + num_ni ts, ts)\n                             (a, aa, b) \\<and>\n                            sim_rel1 (a, aa, b) (ci', ni', tsi')", "apply clarsimp_all"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n     tsi t = INIT; ci' = ci; ni' = Suc ni mod (k * N);\n     tsi' = tsi(t := WAIT (ni mod N))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a aa b.\n                         alstep t (c, c + num_ni ts, ts) (a, aa, b) \\<and>\n                         sim_rel1 (a, aa, b)\n                          (ci, Suc ni mod (k * N), tsi\n                           (t := WAIT (ni mod N)))\n 2. \\<And>tk.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        tsi t = WAIT tk; ci \\<noteq> tk; ci' = ci; ni' = ni;\n        tsi' = tsi(t := WAIT tk)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            alstep t (c, c + num_ni ts, ts)\n                             (a, aa, b) \\<and>\n                            sim_rel1 (a, aa, b) (ci, ni, tsi(t := WAIT tk))\n 3. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n     tsi t = WAIT ci; ci' = ci; ni' = ni; tsi' = tsi(t := HOLD ci)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a aa b.\n                         alstep t (c, c + num_ni ts, ts) (a, aa, b) \\<and>\n                         sim_rel1 (a, aa, b) (ci, ni, tsi(t := HOLD ci))\n 4. \\<And>tk.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        tsi t = HOLD tk; ci' = ci; ni' = ni;\n        tsi' = tsi(t := REL tk)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            alstep t (c, c + num_ni ts, ts)\n                             (a, aa, b) \\<and>\n                            sim_rel1 (a, aa, b) (ci, ni, tsi(t := REL tk))\n 5. \\<And>tk.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        tsi t = REL tk; ci' = Suc tk mod N; ni' = ni;\n        tsi' = tsi(t := INIT)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            alstep t (c, c + num_ni ts, ts)\n                             (a, aa, b) \\<and>\n                            sim_rel1 (a, aa, b)\n                             (Suc tk mod N, ni, tsi(t := INIT))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n     tsi t = INIT; ci' = ci; ni' = Suc ni mod (k * N);\n     tsi' = tsi(t := WAIT (ni mod N))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a aa b.\n                         alstep t (c, c + num_ni ts, ts) (a, aa, b) \\<and>\n                         sim_rel1 (a, aa, b)\n                          (ci, Suc ni mod (k * N), tsi\n                           (t := WAIT (ni mod N)))", "apply (intro exI conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n     tsi t = INIT; ci' = ci; ni' = Suc ni mod (k * N);\n     tsi' = tsi(t := WAIT (ni mod N))\\<rbrakk>\n    \\<Longrightarrow> alstep t (c, c + num_ni ts, ts) (?a, ?a1, ?b2)\n 2. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n     tsi t = INIT; ci' = ci; ni' = Suc ni mod (k * N);\n     tsi' = tsi(t := WAIT (ni mod N))\\<rbrakk>\n    \\<Longrightarrow> sim_rel1 (?a, ?a1, ?b2)\n                       (ci, Suc ni mod (k * N), tsi(t := WAIT (ni mod N)))", "apply (rule alstep.intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n     tsi t = INIT; ci' = ci; ni' = Suc ni mod (k * N);\n     tsi' = tsi(t := WAIT (ni mod N))\\<rbrakk>\n    \\<Longrightarrow> t < N\n 2. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n     tsi t = INIT; ci' = ci; ni' = Suc ni mod (k * N);\n     tsi' = tsi(t := WAIT (ni mod N))\\<rbrakk>\n    \\<Longrightarrow> astep_sng (c, c + num_ni ts, ts t) (?a, ?a1, ?s'4)\n 3. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n     tsi t = INIT; ci' = ci; ni' = Suc ni mod (k * N);\n     tsi' = tsi(t := WAIT (ni mod N))\\<rbrakk>\n    \\<Longrightarrow> sim_rel1 (?a, ?a1, ts(t := ?s'4))\n                       (ci, Suc ni mod (k * N), tsi(t := WAIT (ni mod N)))", "apply (simp add: sim_rel1_def Let_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n     tsi t = INIT; ci' = ci; ni' = Suc ni mod (k * N);\n     tsi' = tsi(t := WAIT (ni mod N))\\<rbrakk>\n    \\<Longrightarrow> astep_sng (c, c + num_ni ts, ts t) (?a, ?a1, ?s'4)\n 2. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n     tsi t = INIT; ci' = ci; ni' = Suc ni mod (k * N);\n     tsi' = tsi(t := WAIT (ni mod N))\\<rbrakk>\n    \\<Longrightarrow> sim_rel1 (?a, ?a1, ts(t := ?s'4))\n                       (ci, Suc ni mod (k * N), tsi(t := WAIT (ni mod N)))", "apply (simp add: sraux sraux2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n     ts t = INIT; ci' = ci; ni' = Suc ni mod (k * N);\n     tsi' = tsi(t := WAIT (ni mod N))\\<rbrakk>\n    \\<Longrightarrow> astep_sng (c, c + num_ni ts, INIT) (?a, ?a1, ?s'4)\n 2. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n     tsi t = INIT; ci' = ci; ni' = Suc ni mod (k * N);\n     tsi' = tsi(t := WAIT (ni mod N))\\<rbrakk>\n    \\<Longrightarrow> sim_rel1 (?a, ?a1, ts(t := ?s'4))\n                       (ci, Suc ni mod (k * N), tsi(t := WAIT (ni mod N)))", "apply (rule astep_sng.enter_wait)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n     tsi t = INIT; ci' = ci; ni' = Suc ni mod (k * N);\n     tsi' = tsi(t := WAIT (ni mod N))\\<rbrakk>\n    \\<Longrightarrow> sim_rel1\n                       (c, c + num_ni ts + 1, ts(t := WAIT (c + num_ni ts)))\n                       (ci, Suc ni mod (k * N), tsi(t := WAIT (ni mod N)))", "apply (simp add: sim_rel1_def; intro conjI ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ci = c mod N \\<and>\n             ni = (c + num_ni ts) mod (k * N) \\<and>\n             tsi = map_ticket (\\<lambda>t. t mod N) \\<circ> ts;\n     t < N; ts t = INIT; ci' = c mod N;\n     ni' = Suc ((c + num_ni ts) mod (k * N)) mod (k * N);\n     tsi' = (map_ticket (\\<lambda>t. t mod N) \\<circ> ts)\n     (t := WAIT ((c + num_ni ts) mod (k * N) mod N))\\<rbrakk>\n    \\<Longrightarrow> Suc ((c + num_ni ts) mod (k * N)) mod (k * N) =\n                      Suc (c + num_ni ts) mod (k * N)\n 2. \\<And>x.\n       \\<lbrakk>ci = c mod N \\<and>\n                ni = (c + num_ni ts) mod (k * N) \\<and>\n                tsi = map_ticket (\\<lambda>t. t mod N) \\<circ> ts;\n        t < N; ts t = INIT; ci' = c mod N;\n        ni' = Suc ((c + num_ni ts) mod (k * N)) mod (k * N);\n        tsi' = (map_ticket (\\<lambda>t. t mod N) \\<circ> ts)\n        (t := WAIT ((c + num_ni ts) mod (k * N) mod N))\\<rbrakk>\n       \\<Longrightarrow> ((map_ticket (\\<lambda>t. t mod N) \\<circ> ts)\n                          (t := WAIT ((c + num_ni ts) mod (k * N) mod N)))\n                          x =\n                         (map_ticket\n                           (\\<lambda>t. t mod N) \\<circ>\\<circ>\\<circ>\n                          fun_upd ts)\n                          t (WAIT (c + num_ni ts)) x", "apply (auto simp: sim_rel1_def Let_def mod_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>tk.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        tsi t = WAIT tk; ci \\<noteq> tk; ci' = ci; ni' = ni;\n        tsi' = tsi(t := WAIT tk)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            alstep t (c, c + num_ni ts, ts)\n                             (a, aa, b) \\<and>\n                            sim_rel1 (a, aa, b) (ci, ni, tsi(t := WAIT tk))\n 2. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n     tsi t = WAIT ci; ci' = ci; ni' = ni; tsi' = tsi(t := HOLD ci)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a aa b.\n                         alstep t (c, c + num_ni ts, ts) (a, aa, b) \\<and>\n                         sim_rel1 (a, aa, b) (ci, ni, tsi(t := HOLD ci))\n 3. \\<And>tk.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        tsi t = HOLD tk; ci' = ci; ni' = ni;\n        tsi' = tsi(t := REL tk)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            alstep t (c, c + num_ni ts, ts)\n                             (a, aa, b) \\<and>\n                            sim_rel1 (a, aa, b) (ci, ni, tsi(t := REL tk))\n 4. \\<And>tk.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        tsi t = REL tk; ci' = Suc tk mod N; ni' = ni;\n        tsi' = tsi(t := INIT)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            alstep t (c, c + num_ni ts, ts)\n                             (a, aa, b) \\<and>\n                            sim_rel1 (a, aa, b)\n                             (Suc tk mod N, ni, tsi(t := INIT))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n     tsi t = WAIT tk_; ci \\<noteq> tk_; ci' = ci; ni' = ni;\n     tsi' = tsi(t := WAIT tk_)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a aa b.\n                         alstep t (c, c + num_ni ts, ts) (a, aa, b) \\<and>\n                         sim_rel1 (a, aa, b) (ci, ni, tsi(t := WAIT tk_))", "apply (clarsimp simp: sraux sraux2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci \\<noteq> tk' mod N; ci' = ci; ni' = ni;\n        tsi' = tsi(t := WAIT (tk' mod N)); ts t = WAIT tk';\n        tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            alstep t (c, c + num_ni ts, ts)\n                             (a, aa, b) \\<and>\n                            sim_rel1 (a, aa, b)\n                             (ci, ni, tsi(t := WAIT (tk' mod N)))", "apply (intro exI conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci \\<noteq> tk' mod N; ci' = ci; ni' = ni;\n        tsi' = tsi(t := WAIT (tk' mod N)); ts t = WAIT tk';\n        tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> alstep t (c, c + num_ni ts, ts)\n                          (?a6 tk', ?a7 tk', ?b8 tk')\n 2. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci \\<noteq> tk' mod N; ci' = ci; ni' = ni;\n        tsi' = tsi(t := WAIT (tk' mod N)); ts t = WAIT tk';\n        tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> sim_rel1 (?a6 tk', ?a7 tk', ?b8 tk')\n                          (ci, ni, tsi(t := WAIT (tk' mod N)))", "apply (rule alstep.intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci \\<noteq> tk' mod N; ci' = ci; ni' = ni;\n        tsi' = tsi(t := WAIT (tk' mod N)); ts t = WAIT tk';\n        tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> t < N\n 2. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci \\<noteq> tk' mod N; ci' = ci; ni' = ni;\n        tsi' = tsi(t := WAIT (tk' mod N)); ts t = WAIT tk';\n        tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> astep_sng (c, c + num_ni ts, ts t)\n                          (?a6 tk', ?a7 tk', ?s'10 tk')\n 3. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci \\<noteq> tk' mod N; ci' = ci; ni' = ni;\n        tsi' = tsi(t := WAIT (tk' mod N)); ts t = WAIT tk';\n        tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> sim_rel1 (?a6 tk', ?a7 tk', ts(t := ?s'10 tk'))\n                          (ci, ni, tsi(t := WAIT (tk' mod N)))", "apply (simp add: sim_rel1_def Let_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci \\<noteq> tk' mod N; ci' = ci; ni' = ni;\n        tsi' = tsi(t := WAIT (tk' mod N)); ts t = WAIT tk';\n        tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> astep_sng (c, c + num_ni ts, ts t)\n                          (?a6 tk', ?a7 tk', ?s'10 tk')\n 2. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci \\<noteq> tk' mod N; ci' = ci; ni' = ni;\n        tsi' = tsi(t := WAIT (tk' mod N)); ts t = WAIT tk';\n        tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> sim_rel1 (?a6 tk', ?a7 tk', ts(t := ?s'10 tk'))\n                          (ci, ni, tsi(t := WAIT (tk' mod N)))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci \\<noteq> tk' mod N; ci' = ci; ni' = ni;\n        tsi' = tsi(t := WAIT (tk' mod N)); ts t = WAIT tk';\n        tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> astep_sng (c, c + num_ni ts, WAIT tk')\n                          (?a6 tk', ?a7 tk', ?s'10 tk')\n 2. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci \\<noteq> tk' mod N; ci' = ci; ni' = ni;\n        tsi' = tsi(t := WAIT (tk' mod N)); ts t = WAIT tk';\n        tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> sim_rel1 (?a6 tk', ?a7 tk', ts(t := ?s'10 tk'))\n                          (ci, ni, tsi(t := WAIT (tk' mod N)))", "apply (rule astep_sng.loop_wait)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci \\<noteq> tk' mod N; ci' = ci; ni' = ni;\n        tsi' = tsi(t := WAIT (tk' mod N)); ts t = WAIT tk';\n        tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> c \\<noteq> tk'\n 2. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci \\<noteq> tk' mod N; ci' = ci; ni' = ni;\n        tsi' = tsi(t := WAIT (tk' mod N)); ts t = WAIT tk';\n        tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> sim_rel1 (c, c + num_ni ts, ts(t := WAIT tk'))\n                          (ci, ni, tsi(t := WAIT (tk' mod N)))", "apply (auto simp: sim_rel1_def Let_def mod_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n     tsi t = WAIT ci; ci' = ci; ni' = ni; tsi' = tsi(t := HOLD ci)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a aa b.\n                         alstep t (c, c + num_ni ts, ts) (a, aa, b) \\<and>\n                         sim_rel1 (a, aa, b) (ci, ni, tsi(t := HOLD ci))\n 2. \\<And>tk.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        tsi t = HOLD tk; ci' = ci; ni' = ni;\n        tsi' = tsi(t := REL tk)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            alstep t (c, c + num_ni ts, ts)\n                             (a, aa, b) \\<and>\n                            sim_rel1 (a, aa, b) (ci, ni, tsi(t := REL tk))\n 3. \\<And>tk.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        tsi t = REL tk; ci' = Suc tk mod N; ni' = ni;\n        tsi' = tsi(t := INIT)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            alstep t (c, c + num_ni ts, ts)\n                             (a, aa, b) \\<and>\n                            sim_rel1 (a, aa, b)\n                             (Suc tk mod N, ni, tsi(t := INIT))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n     tsi t = WAIT ci; ci' = ci; ni' = ni; tsi' = tsi(t := HOLD ci)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a aa b.\n                         alstep t (c, c + num_ni ts, ts) (a, aa, b) \\<and>\n                         sim_rel1 (a, aa, b) (ci, ni, tsi(t := HOLD ci))", "apply (clarsimp simp: sraux sraux2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (tk' mod N, ni, tsi); t < N;\n        ci' = tk' mod N; ni' = ni; tsi' = tsi(t := HOLD (tk' mod N));\n        ts t = WAIT tk'; ci = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            alstep t (c, c + num_ni ts, ts)\n                             (a, aa, b) \\<and>\n                            sim_rel1 (a, aa, b)\n                             (tk' mod N, ni, tsi(t := HOLD (tk' mod N)))", "subgoal for tk'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (tk' mod N, ni, tsi); t < N;\n     ci' = tk' mod N; ni' = ni; tsi' = tsi(t := HOLD (tk' mod N));\n     ts t = WAIT tk'; ci = tk' mod N\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a aa b.\n                         alstep t (c, c + num_ni ts, ts) (a, aa, b) \\<and>\n                         sim_rel1 (a, aa, b)\n                          (tk' mod N, ni, tsi(t := HOLD (tk' mod N)))", "apply (subgoal_tac \"tk'=c\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (tk' mod N, ni, tsi); t < N;\n     ci' = tk' mod N; ni' = ni; tsi' = tsi(t := HOLD (tk' mod N));\n     ts t = WAIT tk'; ci = tk' mod N; tk' = c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a aa b.\n                         alstep t (c, c + num_ni ts, ts) (a, aa, b) \\<and>\n                         sim_rel1 (a, aa, b)\n                          (tk' mod N, ni, tsi(t := HOLD (tk' mod N)))\n 2. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (tk' mod N, ni, tsi); t < N;\n     ci' = tk' mod N; ni' = ni; tsi' = tsi(t := HOLD (tk' mod N));\n     ts t = WAIT tk'; ci = tk' mod N\\<rbrakk>\n    \\<Longrightarrow> tk' = c", "apply (intro exI conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (tk' mod N, ni, tsi); t < N;\n     ci' = tk' mod N; ni' = ni; tsi' = tsi(t := HOLD (tk' mod N));\n     ts t = WAIT tk'; ci = tk' mod N; tk' = c\\<rbrakk>\n    \\<Longrightarrow> alstep t (c, c + num_ni ts, ts) (?a1, ?a2, ?b3)\n 2. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (tk' mod N, ni, tsi); t < N;\n     ci' = tk' mod N; ni' = ni; tsi' = tsi(t := HOLD (tk' mod N));\n     ts t = WAIT tk'; ci = tk' mod N; tk' = c\\<rbrakk>\n    \\<Longrightarrow> sim_rel1 (?a1, ?a2, ?b3)\n                       (tk' mod N, ni, tsi(t := HOLD (tk' mod N)))\n 3. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (tk' mod N, ni, tsi); t < N;\n     ci' = tk' mod N; ni' = ni; tsi' = tsi(t := HOLD (tk' mod N));\n     ts t = WAIT tk'; ci = tk' mod N\\<rbrakk>\n    \\<Longrightarrow> tk' = c", "apply (rule alstep.intros)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (tk' mod N, ni, tsi); t < N;\n     ci' = tk' mod N; ni' = ni; tsi' = tsi(t := HOLD (tk' mod N));\n     ts t = WAIT tk'; ci = tk' mod N; tk' = c\\<rbrakk>\n    \\<Longrightarrow> t < N\n 2. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (tk' mod N, ni, tsi); t < N;\n     ci' = tk' mod N; ni' = ni; tsi' = tsi(t := HOLD (tk' mod N));\n     ts t = WAIT tk'; ci = tk' mod N; tk' = c\\<rbrakk>\n    \\<Longrightarrow> astep_sng (c, c + num_ni ts, ts t) (?a1, ?a2, ?s'5)\n 3. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (tk' mod N, ni, tsi); t < N;\n     ci' = tk' mod N; ni' = ni; tsi' = tsi(t := HOLD (tk' mod N));\n     ts t = WAIT tk'; ci = tk' mod N; tk' = c\\<rbrakk>\n    \\<Longrightarrow> sim_rel1 (?a1, ?a2, ts(t := ?s'5))\n                       (tk' mod N, ni, tsi(t := HOLD (tk' mod N)))\n 4. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (tk' mod N, ni, tsi); t < N;\n     ci' = tk' mod N; ni' = ni; tsi' = tsi(t := HOLD (tk' mod N));\n     ts t = WAIT tk'; ci = tk' mod N\\<rbrakk>\n    \\<Longrightarrow> tk' = c", "apply (simp add: sim_rel1_def Let_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (tk' mod N, ni, tsi); t < N;\n     ci' = tk' mod N; ni' = ni; tsi' = tsi(t := HOLD (tk' mod N));\n     ts t = WAIT tk'; ci = tk' mod N; tk' = c\\<rbrakk>\n    \\<Longrightarrow> astep_sng (c, c + num_ni ts, ts t) (?a1, ?a2, ?s'5)\n 2. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (tk' mod N, ni, tsi); t < N;\n     ci' = tk' mod N; ni' = ni; tsi' = tsi(t := HOLD (tk' mod N));\n     ts t = WAIT tk'; ci = tk' mod N; tk' = c\\<rbrakk>\n    \\<Longrightarrow> sim_rel1 (?a1, ?a2, ts(t := ?s'5))\n                       (tk' mod N, ni, tsi(t := HOLD (tk' mod N)))\n 3. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (tk' mod N, ni, tsi); t < N;\n     ci' = tk' mod N; ni' = ni; tsi' = tsi(t := HOLD (tk' mod N));\n     ts t = WAIT tk'; ci = tk' mod N\\<rbrakk>\n    \\<Longrightarrow> tk' = c", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (c mod N, ni, tsi); t < N;\n     ci' = c mod N; ni' = ni; tsi' = tsi(t := HOLD (c mod N));\n     ts t = WAIT c; ci = c mod N; tk' = c\\<rbrakk>\n    \\<Longrightarrow> astep_sng (c, c + num_ni ts, WAIT c) (?a1, ?a2, ?s'5)\n 2. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (tk' mod N, ni, tsi); t < N;\n     ci' = tk' mod N; ni' = ni; tsi' = tsi(t := HOLD (tk' mod N));\n     ts t = WAIT tk'; ci = tk' mod N; tk' = c\\<rbrakk>\n    \\<Longrightarrow> sim_rel1 (?a1, ?a2, ts(t := ?s'5))\n                       (tk' mod N, ni, tsi(t := HOLD (tk' mod N)))\n 3. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (tk' mod N, ni, tsi); t < N;\n     ci' = tk' mod N; ni' = ni; tsi' = tsi(t := HOLD (tk' mod N));\n     ts t = WAIT tk'; ci = tk' mod N\\<rbrakk>\n    \\<Longrightarrow> tk' = c", "apply (rule astep_sng.exit_wait)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (tk' mod N, ni, tsi); t < N;\n     ci' = tk' mod N; ni' = ni; tsi' = tsi(t := HOLD (tk' mod N));\n     ts t = WAIT tk'; ci = tk' mod N; tk' = c\\<rbrakk>\n    \\<Longrightarrow> sim_rel1 (c, c + num_ni ts, ts(t := HOLD c))\n                       (tk' mod N, ni, tsi(t := HOLD (tk' mod N)))\n 2. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (tk' mod N, ni, tsi); t < N;\n     ci' = tk' mod N; ni' = ni; tsi' = tsi(t := HOLD (tk' mod N));\n     ts t = WAIT tk'; ci = tk' mod N\\<rbrakk>\n    \\<Longrightarrow> tk' = c", "apply (auto simp: sim_rel1_def Let_def mod_simps) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (tk' mod N, ni, tsi); t < N;\n     ci' = tk' mod N; ni' = ni; tsi' = tsi(t := HOLD (tk' mod N));\n     ts t = WAIT tk'; ci = tk' mod N\\<rbrakk>\n    \\<Longrightarrow> tk' = c", "apply (clarsimp simp: sim_rel1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t < N; ci' = c mod N; ni' = (c + num_ni ts) mod (k * N);\n     tsi' = (map_ticket (\\<lambda>t. t mod N) \\<circ> ts)\n     (t := HOLD (c mod N));\n     ts t = WAIT tk'; ci = c mod N; tk' mod N = c mod N;\n     ni = (c + num_ni ts) mod (k * N);\n     tsi = map_ticket (\\<lambda>t. t mod N) \\<circ> ts\\<rbrakk>\n    \\<Longrightarrow> tk' = c", "apply (erule mod_eq_imp_eq_aux)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>t < N; ci' = c mod N; ni' = (c + num_ni ts) mod (k * N);\n     tsi' = (map_ticket (\\<lambda>t. t mod N) \\<circ> ts)\n     (t := HOLD (c mod N));\n     ts t = WAIT tk'; ci = c mod N; ni = (c + num_ni ts) mod (k * N);\n     tsi = map_ticket (\\<lambda>t. t mod N) \\<circ> ts\\<rbrakk>\n    \\<Longrightarrow> c \\<le> tk'\n 2. \\<lbrakk>t < N; ci' = c mod N; ni' = (c + num_ni ts) mod (k * N);\n     tsi' = (map_ticket (\\<lambda>t. t mod N) \\<circ> ts)\n     (t := HOLD (c mod N));\n     ts t = WAIT tk'; ci = c mod N; ni = (c + num_ni ts) mod (k * N);\n     tsi = map_ticket (\\<lambda>t. t mod N) \\<circ> ts\\<rbrakk>\n    \\<Longrightarrow> tk' < c + N", "apply (auto simp: AUX1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>tk.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        tsi t = HOLD tk; ci' = ci; ni' = ni;\n        tsi' = tsi(t := REL tk)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            alstep t (c, c + num_ni ts, ts)\n                             (a, aa, b) \\<and>\n                            sim_rel1 (a, aa, b) (ci, ni, tsi(t := REL tk))\n 2. \\<And>tk.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        tsi t = REL tk; ci' = Suc tk mod N; ni' = ni;\n        tsi' = tsi(t := INIT)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            alstep t (c, c + num_ni ts, ts)\n                             (a, aa, b) \\<and>\n                            sim_rel1 (a, aa, b)\n                             (Suc tk mod N, ni, tsi(t := INIT))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n     tsi t = HOLD tk_; ci' = ci; ni' = ni; tsi' = tsi(t := REL tk_)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a aa b.\n                         alstep t (c, c + num_ni ts, ts) (a, aa, b) \\<and>\n                         sim_rel1 (a, aa, b) (ci, ni, tsi(t := REL tk_))", "apply (clarsimp simp: sraux sraux2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci' = ci; ni' = ni; tsi' = tsi(t := REL (tk' mod N));\n        ts t = HOLD tk'; tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            alstep t (c, c + num_ni ts, ts)\n                             (a, aa, b) \\<and>\n                            sim_rel1 (a, aa, b)\n                             (ci, ni, tsi(t := REL (tk' mod N)))", "apply (intro exI conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci' = ci; ni' = ni; tsi' = tsi(t := REL (tk' mod N));\n        ts t = HOLD tk'; tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> alstep t (c, c + num_ni ts, ts)\n                          (?a6 tk', ?a7 tk', ?b8 tk')\n 2. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci' = ci; ni' = ni; tsi' = tsi(t := REL (tk' mod N));\n        ts t = HOLD tk'; tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> sim_rel1 (?a6 tk', ?a7 tk', ?b8 tk')\n                          (ci, ni, tsi(t := REL (tk' mod N)))", "apply (rule alstep.intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci' = ci; ni' = ni; tsi' = tsi(t := REL (tk' mod N));\n        ts t = HOLD tk'; tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> t < N\n 2. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci' = ci; ni' = ni; tsi' = tsi(t := REL (tk' mod N));\n        ts t = HOLD tk'; tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> astep_sng (c, c + num_ni ts, ts t)\n                          (?a6 tk', ?a7 tk', ?s'10 tk')\n 3. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci' = ci; ni' = ni; tsi' = tsi(t := REL (tk' mod N));\n        ts t = HOLD tk'; tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> sim_rel1 (?a6 tk', ?a7 tk', ts(t := ?s'10 tk'))\n                          (ci, ni, tsi(t := REL (tk' mod N)))", "apply (simp add: sim_rel1_def Let_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci' = ci; ni' = ni; tsi' = tsi(t := REL (tk' mod N));\n        ts t = HOLD tk'; tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> astep_sng (c, c + num_ni ts, ts t)\n                          (?a6 tk', ?a7 tk', ?s'10 tk')\n 2. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci' = ci; ni' = ni; tsi' = tsi(t := REL (tk' mod N));\n        ts t = HOLD tk'; tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> sim_rel1 (?a6 tk', ?a7 tk', ts(t := ?s'10 tk'))\n                          (ci, ni, tsi(t := REL (tk' mod N)))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci' = ci; ni' = ni; tsi' = tsi(t := REL (tk' mod N));\n        ts t = HOLD tk'; tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> astep_sng (c, c + num_ni ts, HOLD tk')\n                          (?a6 tk', ?a7 tk', ?s'10 tk')\n 2. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci' = ci; ni' = ni; tsi' = tsi(t := REL (tk' mod N));\n        ts t = HOLD tk'; tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> sim_rel1 (?a6 tk', ?a7 tk', ts(t := ?s'10 tk'))\n                          (ci, ni, tsi(t := REL (tk' mod N)))", "apply (rule astep_sng.start_release)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci' = ci; ni' = ni; tsi' = tsi(t := REL (tk' mod N));\n        ts t = HOLD tk'; tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> sim_rel1 (c, c + num_ni ts, ts(t := REL tk'))\n                          (ci, ni, tsi(t := REL (tk' mod N)))", "apply (auto simp: sim_rel1_def Let_def mod_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tk.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        tsi t = REL tk; ci' = Suc tk mod N; ni' = ni;\n        tsi' = tsi(t := INIT)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            alstep t (c, c + num_ni ts, ts)\n                             (a, aa, b) \\<and>\n                            sim_rel1 (a, aa, b)\n                             (Suc tk mod N, ni, tsi(t := INIT))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n     tsi t = REL tk_; ci' = Suc tk_ mod N; ni' = ni;\n     tsi' = tsi(t := INIT)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a aa b.\n                         alstep t (c, c + num_ni ts, ts) (a, aa, b) \\<and>\n                         sim_rel1 (a, aa, b)\n                          (Suc tk_ mod N, ni, tsi(t := INIT))", "apply (clarsimp simp: sraux sraux2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci' = Suc (tk' mod N) mod N; ni' = ni; tsi' = tsi(t := INIT);\n        ts t = REL tk'; tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            alstep t (c, c + num_ni ts, ts)\n                             (a, aa, b) \\<and>\n                            sim_rel1 (a, aa, b)\n                             (Suc (tk' mod N) mod N, ni, tsi(t := INIT))", "apply (intro exI conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci' = Suc (tk' mod N) mod N; ni' = ni; tsi' = tsi(t := INIT);\n        ts t = REL tk'; tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> alstep t (c, c + num_ni ts, ts)\n                          (?a6 tk', ?a7 tk', ?b8 tk')\n 2. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci' = Suc (tk' mod N) mod N; ni' = ni; tsi' = tsi(t := INIT);\n        ts t = REL tk'; tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> sim_rel1 (?a6 tk', ?a7 tk', ?b8 tk')\n                          (Suc (tk' mod N) mod N, ni, tsi(t := INIT))", "apply (rule alstep.intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci' = Suc (tk' mod N) mod N; ni' = ni; tsi' = tsi(t := INIT);\n        ts t = REL tk'; tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> t < N\n 2. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci' = Suc (tk' mod N) mod N; ni' = ni; tsi' = tsi(t := INIT);\n        ts t = REL tk'; tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> astep_sng (c, c + num_ni ts, ts t)\n                          (?a6 tk', ?a7 tk', ?s'10 tk')\n 3. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci' = Suc (tk' mod N) mod N; ni' = ni; tsi' = tsi(t := INIT);\n        ts t = REL tk'; tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> sim_rel1 (?a6 tk', ?a7 tk', ts(t := ?s'10 tk'))\n                          (Suc (tk' mod N) mod N, ni, tsi(t := INIT))", "apply (simp add: sim_rel1_def Let_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci' = Suc (tk' mod N) mod N; ni' = ni; tsi' = tsi(t := INIT);\n        ts t = REL tk'; tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> astep_sng (c, c + num_ni ts, ts t)\n                          (?a6 tk', ?a7 tk', ?s'10 tk')\n 2. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci' = Suc (tk' mod N) mod N; ni' = ni; tsi' = tsi(t := INIT);\n        ts t = REL tk'; tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> sim_rel1 (?a6 tk', ?a7 tk', ts(t := ?s'10 tk'))\n                          (Suc (tk' mod N) mod N, ni, tsi(t := INIT))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci' = Suc (tk' mod N) mod N; ni' = ni; tsi' = tsi(t := INIT);\n        ts t = REL tk'; tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> astep_sng (c, c + num_ni ts, REL tk')\n                          (?a6 tk', ?a7 tk', ?s'10 tk')\n 2. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci' = Suc (tk' mod N) mod N; ni' = ni; tsi' = tsi(t := INIT);\n        ts t = REL tk'; tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> sim_rel1 (?a6 tk', ?a7 tk', ts(t := ?s'10 tk'))\n                          (Suc (tk' mod N) mod N, ni, tsi(t := INIT))", "apply (rule astep_sng.release)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tk'.\n       \\<lbrakk>sim_rel1 (c, c + num_ni ts, ts) (ci, ni, tsi); t < N;\n        ci' = Suc (tk' mod N) mod N; ni' = ni; tsi' = tsi(t := INIT);\n        ts t = REL tk'; tk_ = tk' mod N\\<rbrakk>\n       \\<Longrightarrow> sim_rel1 (tk' + 1, c + num_ni ts, ts(t := INIT))\n                          (Suc (tk' mod N) mod N, ni, tsi(t := INIT))", "apply (auto simp: sim_rel1_def Let_def mod_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>as'. alstep t as as' \\<and> sim_rel1 as' bs'\n\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        blstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel1 as' cs' \\<and> alstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        A.can_step l as\\<rbrakk>\n       \\<Longrightarrow> B.can_step l cs", "then"], ["proof (chain)\npicking this:\n  \\<exists>as'. alstep t as as' \\<and> sim_rel1 as' bs'", "show \"\\<exists>as'. sim_rel1 as' bs' \\<and> alstep t as as'\""], ["proof (prove)\nusing this:\n  \\<exists>as'. alstep t as as' \\<and> sim_rel1 as' bs'\n\ngoal (1 subgoal):\n 1. \\<exists>as'. sim_rel1 as' bs' \\<and> alstep t as as'", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'. sim_rel1 as' bs' \\<and> alstep t as as'\n\ngoal (1 subgoal):\n 1. \\<And>as cs l.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        A.can_step l as\\<rbrakk>\n       \\<Longrightarrow> B.can_step l cs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>as cs l.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        A.can_step l as\\<rbrakk>\n       \\<Longrightarrow> B.can_step l cs", "fix as bs l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>as cs l.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        A.can_step l as\\<rbrakk>\n       \\<Longrightarrow> B.can_step l cs", "assume \"A.reachable as\" \"B.reachable bs\" \"sim_rel1 as bs\" \"A.can_step l as\""], ["proof (state)\nthis:\n  A.reachable as\n  B.reachable bs\n  sim_rel1 as bs\n  A.can_step l as\n\ngoal (1 subgoal):\n 1. \\<And>as cs l.\n       \\<lbrakk>A.reachable as; B.reachable cs; sim_rel1 as cs;\n        A.can_step l as\\<rbrakk>\n       \\<Longrightarrow> B.can_step l cs", "then"], ["proof (chain)\npicking this:\n  A.reachable as\n  B.reachable bs\n  sim_rel1 as bs\n  A.can_step l as", "show \"B.can_step l bs\""], ["proof (prove)\nusing this:\n  A.reachable as\n  B.reachable bs\n  sim_rel1 as bs\n  A.can_step l as\n\ngoal (1 subgoal):\n 1. B.can_step l bs", "using b_never_blocked never_blocked"], ["proof (prove)\nusing this:\n  A.reachable as\n  B.reachable bs\n  sim_rel1 as bs\n  A.can_step l as\n  B.can_step ?l ?s = (?l < N)\n  A.can_step ?l ?s = (?l < N)\n\ngoal (1 subgoal):\n 1. B.can_step l bs", "by simp"], ["proof (state)\nthis:\n  B.can_step l bs\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Transfer of Properties\\<close>"], ["", "text \\<open>We transfer a few properties over the simulation,\n    which we need for the next refinement step.\n  \\<close>"], ["", "lemma xfer_locks_ticket:\n    assumes \"locks_ticket (map_ticket (\\<lambda>t. t mod N) (ts t)) tki\"  \n    obtains tk where \"tki=tk mod N\" \"locks_ticket (ts t) tk\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tk.\n        \\<lbrakk>tki = tk mod N; locks_ticket (ts t) tk\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  locks_ticket (map_ticket (\\<lambda>t. t mod N) (ts t)) tki\n\ngoal (1 subgoal):\n 1. (\\<And>tk.\n        \\<lbrakk>tki = tk mod N; locks_ticket (ts t) tk\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding locks_ticket_def"], ["proof (prove)\nusing this:\n  map_ticket (\\<lambda>t. t mod N) (ts t) = HOLD tki \\<or>\n  map_ticket (\\<lambda>t. t mod N) (ts t) = REL tki\n\ngoal (1 subgoal):\n 1. (\\<And>tk.\n        \\<lbrakk>tki = tk mod N; ts t = HOLD tk \\<or> ts t = REL tk\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "lemma b_holds_only_current: \n    \"\\<lbrakk>B.reachable (c, n, ts); t < N; locks_ticket (ts t) tk\\<rbrakk> \\<Longrightarrow> tk = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>B.reachable (c, n, ts); t < N; locks_ticket (ts t) tk\\<rbrakk>\n    \\<Longrightarrow> tk = c", "apply (rule sim1.xfer_reachable, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as.\n       \\<lbrakk>B.reachable (c, n, ts); t < N; locks_ticket (ts t) tk;\n        sim_rel1 as (c, n, ts); A.reachable as\\<rbrakk>\n       \\<Longrightarrow> tk = c", "apply (clarsimp simp: sim_rel1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>B.reachable\n                 (a mod N, aa mod (k * N),\n                  map_ticket (\\<lambda>t. t mod N) \\<circ> b);\n        t < N; locks_ticket (map_ticket (\\<lambda>t. t mod N) (b t)) tk;\n        A.reachable (a, aa, b); c = a mod N;\n        ts = map_ticket (\\<lambda>t. t mod N) \\<circ> b;\n        n = aa mod (k * N)\\<rbrakk>\n       \\<Longrightarrow> tk = a mod N", "apply (erule xfer_locks_ticket)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b tka.\n       \\<lbrakk>B.reachable\n                 (a mod N, aa mod (k * N),\n                  map_ticket (\\<lambda>t. t mod N) \\<circ> b);\n        t < N; A.reachable (a, aa, b); c = a mod N;\n        ts = map_ticket (\\<lambda>t. t mod N) \\<circ> b; n = aa mod (k * N);\n        tk = tka mod N; locks_ticket (b t) tka\\<rbrakk>\n       \\<Longrightarrow> tk = a mod N", "using holds_only_current"], ["proof (prove)\nusing this:\n  \\<lbrakk>A.reachable (?c, ?n, ?ts); ?t < N;\n   locks_ticket (?ts ?t) ?k\\<rbrakk>\n  \\<Longrightarrow> ?k = ?c\n\ngoal (1 subgoal):\n 1. \\<And>a aa b tka.\n       \\<lbrakk>B.reachable\n                 (a mod N, aa mod (k * N),\n                  map_ticket (\\<lambda>t. t mod N) \\<circ> b);\n        t < N; A.reachable (a, aa, b); c = a mod N;\n        ts = map_ticket (\\<lambda>t. t mod N) \\<circ> b; n = aa mod (k * N);\n        tk = tka mod N; locks_ticket (b t) tka\\<rbrakk>\n       \\<Longrightarrow> tk = a mod N", "by blast"], ["", "lemma b_mutual_exclusion': \"\\<lbrakk>B.reachable s; \n      t<N; t'<N; t\\<noteq>t'; locks_ticket (tts s t) tk; locks_ticket (tts s t') tk'\n    \\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>B.reachable s; t < N; t' < N; t \\<noteq> t';\n     locks_ticket (tts s t) tk; locks_ticket (tts s t') tk'\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule sim1.xfer_reachable, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as.\n       \\<lbrakk>B.reachable s; t < N; t' < N; t \\<noteq> t';\n        locks_ticket (tts s t) tk; locks_ticket (tts s t') tk';\n        sim_rel1 as s; A.reachable as\\<rbrakk>\n       \\<Longrightarrow> False", "apply (clarsimp simp: sim_rel1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>B.reachable\n                 (a mod N, aa mod (k * N),\n                  map_ticket (\\<lambda>t. t mod N) \\<circ> b);\n        t < N; t' < N; t \\<noteq> t';\n        locks_ticket (map_ticket (\\<lambda>t. t mod N) (b t)) tk;\n        locks_ticket (map_ticket (\\<lambda>t. t mod N) (b t')) tk';\n        A.reachable (a, aa, b);\n        s =\n        (a mod N, aa mod (k * N),\n         map_ticket (\\<lambda>t. t mod N) \\<circ> b)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (erule xfer_locks_ticket)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b tka tkaa.\n       \\<lbrakk>B.reachable\n                 (a mod N, aa mod (k * N),\n                  map_ticket (\\<lambda>t. t mod N) \\<circ> b);\n        t < N; t' < N; t \\<noteq> t'; A.reachable (a, aa, b);\n        s =\n        (a mod N, aa mod (k * N),\n         map_ticket (\\<lambda>t. t mod N) \\<circ> b);\n        tk = tka mod N; locks_ticket (b t) tka; tk' = tkaa mod N;\n        locks_ticket (b t') tkaa\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule (3) mutual_exclusion'; simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma xfer_has_ticket:\n    assumes \"has_ticket (map_ticket (\\<lambda>t. t mod N) (ts t)) tki\"  \n    obtains tk where \"tki=tk mod N\" \"has_ticket (ts t) tk\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tk.\n        \\<lbrakk>tki = tk mod N; has_ticket (ts t) tk\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  has_ticket (map_ticket (\\<lambda>t. t mod N) (ts t)) tki\n\ngoal (1 subgoal):\n 1. (\\<And>tk.\n        \\<lbrakk>tki = tk mod N; has_ticket (ts t) tk\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding has_ticket_def"], ["proof (prove)\nusing this:\n  map_ticket (\\<lambda>t. t mod N) (ts t) = WAIT tki \\<or>\n  map_ticket (\\<lambda>t. t mod N) (ts t) = HOLD tki \\<or>\n  map_ticket (\\<lambda>t. t mod N) (ts t) = REL tki\n\ngoal (1 subgoal):\n 1. (\\<And>tk.\n        \\<lbrakk>tki = tk mod N;\n         ts t = WAIT tk \\<or> ts t = HOLD tk \\<or> ts t = REL tk\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "lemma has_ticket_in_range:\n    assumes Ra: \"A.reachable (c,n,ts)\" and \"t<N\" and U: \"has_ticket (ts t) tk\" \n    shows \"c\\<le>tk \\<and> tk<c+N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<le> tk \\<and> tk < c + N", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<le> tk \\<and> tk < c + N", "have [simp]: \"n=c + num_ni ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = c + num_ni ts", "using A.invar_reachable[OF is_invar3 Ra, unfolded invar3_def]"], ["proof (prove)\nusing this:\n  case (c, n, ts) of (c, n, ts) \\<Rightarrow> n = c + num_ni ts\n\ngoal (1 subgoal):\n 1. n = c + num_ni ts", "by simp"], ["proof (state)\nthis:\n  n = c + num_ni ts\n\ngoal (1 subgoal):\n 1. c \\<le> tk \\<and> tk < c + N", "show \"c\\<le>tk \\<and> tk<c+N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<le> tk \\<and> tk < c + N", "using A.invar_reachable[OF is_invar1 Ra] U"], ["proof (prove)\nusing this:\n  invar1 (c, n, ts)\n  has_ticket (ts t) tk\n\ngoal (1 subgoal):\n 1. c \\<le> tk \\<and> tk < c + N", "apply (auto simp: invar1_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>t k.\n                t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n                c \\<le> k \\<and>\n                k < c + num_ni ts \\<and>\n                (\\<forall>t' k'.\n                    t' < N \\<and>\n                    has_ticket (ts t') k' \\<and>\n                    t \\<noteq> t' \\<longrightarrow>\n                    k \\<noteq> k') \\<and>\n                (\\<forall>k.\n                    k \\<noteq> c \\<longrightarrow>\n                    \\<not> locks_ticket (ts t) k);\n     has_ticket (ts t) tk\\<rbrakk>\n    \\<Longrightarrow> c \\<le> tk\n 2. \\<lbrakk>\\<forall>t k.\n                t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n                c \\<le> k \\<and>\n                k < c + num_ni ts \\<and>\n                (\\<forall>t' k'.\n                    t' < N \\<and>\n                    has_ticket (ts t') k' \\<and>\n                    t \\<noteq> t' \\<longrightarrow>\n                    k \\<noteq> k') \\<and>\n                (\\<forall>k.\n                    k \\<noteq> c \\<longrightarrow>\n                    \\<not> locks_ticket (ts t) k);\n     has_ticket (ts t) tk\\<rbrakk>\n    \\<Longrightarrow> tk < c + N", "using \\<open>t<N\\<close>"], ["proof (prove)\nusing this:\n  t < N\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>t k.\n                t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n                c \\<le> k \\<and>\n                k < c + num_ni ts \\<and>\n                (\\<forall>t' k'.\n                    t' < N \\<and>\n                    has_ticket (ts t') k' \\<and>\n                    t \\<noteq> t' \\<longrightarrow>\n                    k \\<noteq> k') \\<and>\n                (\\<forall>k.\n                    k \\<noteq> c \\<longrightarrow>\n                    \\<not> locks_ticket (ts t) k);\n     has_ticket (ts t) tk\\<rbrakk>\n    \\<Longrightarrow> c \\<le> tk\n 2. \\<lbrakk>\\<forall>t k.\n                t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n                c \\<le> k \\<and>\n                k < c + num_ni ts \\<and>\n                (\\<forall>t' k'.\n                    t' < N \\<and>\n                    has_ticket (ts t') k' \\<and>\n                    t \\<noteq> t' \\<longrightarrow>\n                    k \\<noteq> k') \\<and>\n                (\\<forall>k.\n                    k \\<noteq> c \\<longrightarrow>\n                    \\<not> locks_ticket (ts t) k);\n     has_ticket (ts t) tk\\<rbrakk>\n    \\<Longrightarrow> tk < c + N", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t k.\n                t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n                c \\<le> k \\<and>\n                k < c + num_ni ts \\<and>\n                (\\<forall>t' k'.\n                    t' < N \\<and>\n                    has_ticket (ts t') k' \\<and>\n                    t \\<noteq> t' \\<longrightarrow>\n                    k \\<noteq> k') \\<and>\n                (\\<forall>k.\n                    k \\<noteq> c \\<longrightarrow>\n                    \\<not> locks_ticket (ts t) k);\n     has_ticket (ts t) tk\\<rbrakk>\n    \\<Longrightarrow> tk < c + N", "using \\<open>t<N\\<close> num_ni_leN[of ts]"], ["proof (prove)\nusing this:\n  t < N\n  num_ni ts \\<le> N\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t k.\n                t < N \\<and> has_ticket (ts t) k \\<longrightarrow>\n                c \\<le> k \\<and>\n                k < c + num_ni ts \\<and>\n                (\\<forall>t' k'.\n                    t' < N \\<and>\n                    has_ticket (ts t') k' \\<and>\n                    t \\<noteq> t' \\<longrightarrow>\n                    k \\<noteq> k') \\<and>\n                (\\<forall>k.\n                    k \\<noteq> c \\<longrightarrow>\n                    \\<not> locks_ticket (ts t) k);\n     has_ticket (ts t) tk\\<rbrakk>\n    \\<Longrightarrow> tk < c + N", "by fastforce"], ["proof (state)\nthis:\n  c \\<le> tk \\<and> tk < c + N\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma b_has_ticket_unique: \"\\<lbrakk>B.reachable (ci,ni,tsi); \n      t<N; has_ticket (tsi t) tki; t'<N; has_ticket (tsi t') tki\n    \\<rbrakk> \\<Longrightarrow> t'=t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>B.reachable (ci, ni, tsi); t < N; has_ticket (tsi t) tki;\n     t' < N; has_ticket (tsi t') tki\\<rbrakk>\n    \\<Longrightarrow> t' = t", "apply (rule sim1.xfer_reachable, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as.\n       \\<lbrakk>B.reachable (ci, ni, tsi); t < N; has_ticket (tsi t) tki;\n        t' < N; has_ticket (tsi t') tki; sim_rel1 as (ci, ni, tsi);\n        A.reachable as\\<rbrakk>\n       \\<Longrightarrow> t' = t", "apply (auto simp: sim_rel1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>B.reachable\n                 (a mod N, aa mod (k * N),\n                  map_ticket (\\<lambda>t. t mod N) \\<circ> b);\n        t < N; has_ticket (map_ticket (\\<lambda>t. t mod N) (b t)) tki;\n        t' < N; has_ticket (map_ticket (\\<lambda>t. t mod N) (b t')) tki;\n        A.reachable (a, aa, b); ci = a mod N;\n        tsi = map_ticket (\\<lambda>t. t mod N) \\<circ> b;\n        ni = aa mod (k * N)\\<rbrakk>\n       \\<Longrightarrow> t' = t", "subgoal for c n ts"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>B.reachable\n              (c mod N, n mod (k * N),\n               map_ticket (\\<lambda>t. t mod N) \\<circ> ts);\n     t < N; has_ticket (map_ticket (\\<lambda>t. t mod N) (ts t)) tki;\n     t' < N; has_ticket (map_ticket (\\<lambda>t. t mod N) (ts t')) tki;\n     A.reachable (c, n, ts); ci = c mod N;\n     tsi = map_ticket (\\<lambda>t. t mod N) \\<circ> ts;\n     ni = n mod (k * N)\\<rbrakk>\n    \\<Longrightarrow> t' = t", "apply (erule xfer_has_ticket)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tk tka.\n       \\<lbrakk>B.reachable\n                 (c mod N, n mod (k * N),\n                  map_ticket (\\<lambda>t. t mod N) \\<circ> ts);\n        t < N; t' < N; A.reachable (c, n, ts); ci = c mod N;\n        tsi = map_ticket (\\<lambda>t. t mod N) \\<circ> ts;\n        ni = n mod (k * N); tki = tk mod N; has_ticket (ts t) tk;\n        tki = tka mod N; has_ticket (ts t') tka\\<rbrakk>\n       \\<Longrightarrow> t' = t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tk tka.\n       \\<lbrakk>B.reachable\n                 (c mod N, n mod (k * N),\n                  map_ticket (\\<lambda>t. t mod N) \\<circ> ts);\n        t < N; t' < N; A.reachable (c, n, ts); ci = c mod N;\n        tsi = map_ticket (\\<lambda>t. t mod N) \\<circ> ts;\n        ni = n mod (k * N); tka mod N = tk mod N; has_ticket (ts t) tk;\n        tki = tk mod N; has_ticket (ts t') tka\\<rbrakk>\n       \\<Longrightarrow> t' = t", "subgoal for tk tk'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>B.reachable\n              (c mod N, n mod (k * N),\n               map_ticket (\\<lambda>t. t mod N) \\<circ> ts);\n     t < N; t' < N; A.reachable (c, n, ts); ci = c mod N;\n     tsi = map_ticket (\\<lambda>t. t mod N) \\<circ> ts; ni = n mod (k * N);\n     tk' mod N = tk mod N; has_ticket (ts t) tk; tki = tk mod N;\n     has_ticket (ts t') tk'\\<rbrakk>\n    \\<Longrightarrow> t' = t", "apply (subgoal_tac \"tk=tk'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>B.reachable\n              (c mod N, n mod (k * N),\n               map_ticket (\\<lambda>t. t mod N) \\<circ> ts);\n     t < N; t' < N; A.reachable (c, n, ts); ci = c mod N;\n     tsi = map_ticket (\\<lambda>t. t mod N) \\<circ> ts; ni = n mod (k * N);\n     tk' mod N = tk mod N; has_ticket (ts t) tk; tki = tk mod N;\n     has_ticket (ts t') tk'; tk = tk'\\<rbrakk>\n    \\<Longrightarrow> t' = t\n 2. \\<lbrakk>B.reachable\n              (c mod N, n mod (k * N),\n               map_ticket (\\<lambda>t. t mod N) \\<circ> ts);\n     t < N; t' < N; A.reachable (c, n, ts); ci = c mod N;\n     tsi = map_ticket (\\<lambda>t. t mod N) \\<circ> ts; ni = n mod (k * N);\n     tk' mod N = tk mod N; has_ticket (ts t) tk; tki = tk mod N;\n     has_ticket (ts t') tk'\\<rbrakk>\n    \\<Longrightarrow> tk = tk'", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>B.reachable\n              (c mod N, n mod (k * N),\n               map_ticket (\\<lambda>t. t mod N) \\<circ> ts);\n     t < N; t' < N; A.reachable (c, n, ts); ci = c mod N;\n     tsi = map_ticket (\\<lambda>t. t mod N) \\<circ> ts; ni = n mod (k * N);\n     has_ticket (ts t) tk'; tki = tk' mod N; has_ticket (ts t') tk';\n     tk = tk'\\<rbrakk>\n    \\<Longrightarrow> t' = t\n 2. \\<lbrakk>B.reachable\n              (c mod N, n mod (k * N),\n               map_ticket (\\<lambda>t. t mod N) \\<circ> ts);\n     t < N; t' < N; A.reachable (c, n, ts); ci = c mod N;\n     tsi = map_ticket (\\<lambda>t. t mod N) \\<circ> ts; ni = n mod (k * N);\n     tk' mod N = tk mod N; has_ticket (ts t) tk; tki = tk mod N;\n     has_ticket (ts t') tk'\\<rbrakk>\n    \\<Longrightarrow> tk = tk'", "apply (frule (4) has_ticket_unique, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>B.reachable\n              (c mod N, n mod (k * N),\n               map_ticket (\\<lambda>t. t mod N) \\<circ> ts);\n     t < N; t' < N; A.reachable (c, n, ts); ci = c mod N;\n     tsi = map_ticket (\\<lambda>t. t mod N) \\<circ> ts; ni = n mod (k * N);\n     tk' mod N = tk mod N; has_ticket (ts t) tk; tki = tk mod N;\n     has_ticket (ts t') tk'\\<rbrakk>\n    \\<Longrightarrow> tk = tk'", "apply (frule (2) has_ticket_in_range[where tk=tk])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>B.reachable\n              (c mod N, n mod (k * N),\n               map_ticket (\\<lambda>t. t mod N) \\<circ> ts);\n     t < N; t' < N; A.reachable (c, n, ts); ci = c mod N;\n     tsi = map_ticket (\\<lambda>t. t mod N) \\<circ> ts; ni = n mod (k * N);\n     tk' mod N = tk mod N; has_ticket (ts t) tk; tki = tk mod N;\n     has_ticket (ts t') tk'; c \\<le> tk \\<and> tk < c + N\\<rbrakk>\n    \\<Longrightarrow> tk = tk'", "apply (frule (2) has_ticket_in_range[where tk=tk'])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>B.reachable\n              (c mod N, n mod (k * N),\n               map_ticket (\\<lambda>t. t mod N) \\<circ> ts);\n     t < N; t' < N; A.reachable (c, n, ts); ci = c mod N;\n     tsi = map_ticket (\\<lambda>t. t mod N) \\<circ> ts; ni = n mod (k * N);\n     tk' mod N = tk mod N; has_ticket (ts t) tk; tki = tk mod N;\n     has_ticket (ts t') tk'; c \\<le> tk \\<and> tk < c + N;\n     c \\<le> tk' \\<and> tk' < c + N\\<rbrakk>\n    \\<Longrightarrow> tk = tk'", "apply (auto simp: mod_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>B.reachable\n              (c mod N, n mod (k * N),\n               map_ticket (\\<lambda>t. t mod N) \\<circ> ts);\n     t < N; t' < N; A.reachable (c, n, ts); ci = c mod N;\n     tsi = map_ticket (\\<lambda>t. t mod N) \\<circ> ts; ni = n mod (k * N);\n     tk' mod N = tk mod N; has_ticket (ts t) tk; tki = tk mod N;\n     has_ticket (ts t') tk'; c \\<le> tk; tk < c + N; c \\<le> tk';\n     tk' < c + N\\<rbrakk>\n    \\<Longrightarrow> tk = tk'", "apply (rule mod_eq_imp_eq; (assumption|simp))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Refinement 3: Using an Array\\<close>"], ["", "text_raw \\<open>\\label{sec:refine3}\\<close>"], ["", "text \\<open>Finally, we use an array instead of a counter, thus obtaining\n    the exact data structures from the challenge assignment.\n    \n    Note that we model the array by a list of Booleans here.\n  \\<close>"], ["", "text \\<open>System's state: Current ticket array, next ticket, thread states\\<close>"], ["", "type_synonym cstate = \"bool list \\<times> nat \\<times> (nat \\<Rightarrow> thread)\""], ["", "text \\<open>The step relation of a single thread\\<close>"], ["", "inductive cstep_sng where\n    enter_wait: \"cstep_sng (p,n,INIT) (p,(n+1) mod (k*N),WAIT (n mod N))\"\n  | loop_wait: \"\\<not>p!tk \\<Longrightarrow> cstep_sng (p,n,WAIT tk) (p,n,WAIT tk)\"\n  | exit_wait: \"p!tk \\<Longrightarrow> cstep_sng (p,n,WAIT tk) (p,n,HOLD tk)\"\n  | start_release: \"cstep_sng (p,n,HOLD tk) (p[tk:=False],n,REL tk)\"\n  | release: \"cstep_sng (p,n,REL tk) (p[(tk+1) mod N := True],n,INIT)\""], ["", "text \\<open>The step relation of the system, labeled with the thread \\<open>t\\<close> that performs the step\\<close>"], ["", "inductive clstep for t where\n    \"\\<lbrakk> t<N; cstep_sng (c,n,ts t) (c',n',s') \\<rbrakk> \n      \\<Longrightarrow> clstep t (c,n,ts) (c',n',ts(t:=s'))\""], ["", "text \\<open>Initial state of the system\\<close>"], ["", "definition \"cs\\<^sub>0 \\<equiv> ((replicate N False)[0:=True], 0, \\<lambda>_. INIT)\""], ["", "interpretation C: system cs\\<^sub>0 clstep"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma c_never_blocked: \"C.can_step l s \\<longleftrightarrow> l<N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C.can_step l s = (l < N)", "apply (cases s; cases \"tts s l\"; simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>s = (a, b, c); c l = INIT\\<rbrakk>\n       \\<Longrightarrow> C.can_step l (a, b, c) = (l < N)\n 2. \\<And>a b c x2.\n       \\<lbrakk>s = (a, b, c); c l = WAIT x2\\<rbrakk>\n       \\<Longrightarrow> C.can_step l (a, b, c) = (l < N)\n 3. \\<And>a b c x3.\n       \\<lbrakk>s = (a, b, c); c l = HOLD x3\\<rbrakk>\n       \\<Longrightarrow> C.can_step l (a, b, c) = (l < N)\n 4. \\<And>a b c x4.\n       \\<lbrakk>s = (a, b, c); c l = REL x4\\<rbrakk>\n       \\<Longrightarrow> C.can_step l (a, b, c) = (l < N)", "unfolding C.can_step_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>s = (a, b, c); c l = INIT\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s'. clstep l (a, b, c) s') = (l < N)\n 2. \\<And>a b c x2.\n       \\<lbrakk>s = (a, b, c); c l = WAIT x2\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s'. clstep l (a, b, c) s') = (l < N)\n 3. \\<And>a b c x3.\n       \\<lbrakk>s = (a, b, c); c l = HOLD x3\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s'. clstep l (a, b, c) s') = (l < N)\n 4. \\<And>a b c x4.\n       \\<lbrakk>s = (a, b, c); c l = REL x4\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s'. clstep l (a, b, c) s') = (l < N)", "apply (clarsimp_all simp: clstep.simps cstep_sng.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c x2.\n       \\<lbrakk>s = (a, b, c); c l = WAIT x2\\<rbrakk>\n       \\<Longrightarrow> (l < N \\<and>\n                          (\\<exists>aa ab s'.\n                              aa = a \\<and>\n                              ab = b \\<and>\n                              s' = WAIT x2 \\<and> \\<not> a ! x2 \\<or>\n                              aa = a \\<and>\n                              ab = b \\<and> s' = HOLD x2 \\<and> a ! x2)) =\n                         (l < N)", "by metis"], ["", "interpretation C: df_system cs\\<^sub>0 clstep"], ["proof (prove)\ngoal (1 subgoal):\n 1. df_system cs\\<^sub>0 clstep", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. C.reachable s \\<Longrightarrow> \\<exists>s'. C.step s s'", "subgoal for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. C.reachable s \\<Longrightarrow> \\<exists>s'. C.step s s'", "using c_never_blocked[of 0 s]"], ["proof (prove)\nusing this:\n  C.can_step 0 s = (0 < N)\n\ngoal (1 subgoal):\n 1. C.reachable s \\<Longrightarrow> \\<exists>s'. C.step s s'", "unfolding C.can_step_def"], ["proof (prove)\nusing this:\n  (\\<exists>s'. clstep 0 s s') = (0 < N)\n\ngoal (1 subgoal):\n 1. C.reachable s \\<Longrightarrow> \\<exists>s'. C.step s s'", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>We establish another invariant that states that the ticket numbers are bounded.\\<close>"], ["", "definition \"invar4 \n    \\<equiv> \\<lambda>(c,n,ts). c<N \\<and> (\\<forall>t<N. \\<forall>tk. has_ticket (ts t) tk \\<longrightarrow> tk<N)\""], ["", "lemma is_invar4: \"B.is_invar invar4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B.is_invar invar4", "apply (rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. invar4 bs\\<^sub>0\n 2. \\<And>s s'.\n       \\<lbrakk>B.reachable s; invar4 s; B.step s s'\\<rbrakk>\n       \\<Longrightarrow> invar4 s'", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar4 bs\\<^sub>0", "by (auto simp: invar4_def bs\\<^sub>0_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>B.reachable s; invar4 s; B.step s s'\\<rbrakk>\n       \\<Longrightarrow> invar4 s'", "subgoal for s s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>B.reachable s; invar4 s; B.step s s'\\<rbrakk>\n    \\<Longrightarrow> invar4 s'", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>B.reachable s; invar4 s; blstep l s s'\\<rbrakk>\n       \\<Longrightarrow> invar4 s'", "apply (erule blstep.cases, erule bstep_sng.cases)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>l c n ts c' n' s'a ca na.\n       \\<lbrakk>B.reachable s; invar4 s; s = (c, n, ts);\n        s' = (c', n', ts(l := s'a)); l < N; (c, n, ts l) = (ca, na, INIT);\n        (c', n', s'a) = (ca, (na + 1) mod (k * N), WAIT (na mod N))\\<rbrakk>\n       \\<Longrightarrow> invar4 s'\n 2. \\<And>l c n ts c' n' s'a ca tk na.\n       \\<lbrakk>B.reachable s; invar4 s; s = (c, n, ts);\n        s' = (c', n', ts(l := s'a)); l < N;\n        (c, n, ts l) = (ca, na, WAIT tk); (c', n', s'a) = (ca, na, WAIT tk);\n        ca \\<noteq> tk\\<rbrakk>\n       \\<Longrightarrow> invar4 s'\n 3. \\<And>l c n ts c' n' s'a ca na.\n       \\<lbrakk>B.reachable s; invar4 s; s = (c, n, ts);\n        s' = (c', n', ts(l := s'a)); l < N;\n        (c, n, ts l) = (ca, na, WAIT ca);\n        (c', n', s'a) = (ca, na, HOLD ca)\\<rbrakk>\n       \\<Longrightarrow> invar4 s'\n 4. \\<And>l c n ts c' n' s'a ca na tk.\n       \\<lbrakk>B.reachable s; invar4 s; s = (c, n, ts);\n        s' = (c', n', ts(l := s'a)); l < N;\n        (c, n, ts l) = (ca, na, HOLD tk);\n        (c', n', s'a) = (ca, na, REL tk)\\<rbrakk>\n       \\<Longrightarrow> invar4 s'\n 5. \\<And>l c n ts c' n' s'a ca na tk.\n       \\<lbrakk>B.reachable s; invar4 s; s = (c, n, ts);\n        s' = (c', n', ts(l := s'a)); l < N; (c, n, ts l) = (ca, na, REL tk);\n        (c', n', s'a) = ((tk + 1) mod N, na, INIT)\\<rbrakk>\n       \\<Longrightarrow> invar4 s'", "unfolding invar4_def"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>l c n ts c' n' s'a ca na.\n       \\<lbrakk>B.reachable s;\n        case s of\n        (c, n, ts) \\<Rightarrow>\n          c < N \\<and>\n          (\\<forall>t<N.\n              \\<forall>tk. has_ticket (ts t) tk \\<longrightarrow> tk < N);\n        s = (c, n, ts); s' = (c', n', ts(l := s'a)); l < N;\n        (c, n, ts l) = (ca, na, INIT);\n        (c', n', s'a) = (ca, (na + 1) mod (k * N), WAIT (na mod N))\\<rbrakk>\n       \\<Longrightarrow> case s' of\n                         (c, n, ts) \\<Rightarrow>\n                           c < N \\<and>\n                           (\\<forall>t<N.\n                               \\<forall>tk.\n                                  has_ticket (ts t) tk \\<longrightarrow>\n                                  tk < N)\n 2. \\<And>l c n ts c' n' s'a ca tk na.\n       \\<lbrakk>B.reachable s;\n        case s of\n        (c, n, ts) \\<Rightarrow>\n          c < N \\<and>\n          (\\<forall>t<N.\n              \\<forall>tk. has_ticket (ts t) tk \\<longrightarrow> tk < N);\n        s = (c, n, ts); s' = (c', n', ts(l := s'a)); l < N;\n        (c, n, ts l) = (ca, na, WAIT tk); (c', n', s'a) = (ca, na, WAIT tk);\n        ca \\<noteq> tk\\<rbrakk>\n       \\<Longrightarrow> case s' of\n                         (c, n, ts) \\<Rightarrow>\n                           c < N \\<and>\n                           (\\<forall>t<N.\n                               \\<forall>tk.\n                                  has_ticket (ts t) tk \\<longrightarrow>\n                                  tk < N)\n 3. \\<And>l c n ts c' n' s'a ca na.\n       \\<lbrakk>B.reachable s;\n        case s of\n        (c, n, ts) \\<Rightarrow>\n          c < N \\<and>\n          (\\<forall>t<N.\n              \\<forall>tk. has_ticket (ts t) tk \\<longrightarrow> tk < N);\n        s = (c, n, ts); s' = (c', n', ts(l := s'a)); l < N;\n        (c, n, ts l) = (ca, na, WAIT ca);\n        (c', n', s'a) = (ca, na, HOLD ca)\\<rbrakk>\n       \\<Longrightarrow> case s' of\n                         (c, n, ts) \\<Rightarrow>\n                           c < N \\<and>\n                           (\\<forall>t<N.\n                               \\<forall>tk.\n                                  has_ticket (ts t) tk \\<longrightarrow>\n                                  tk < N)\n 4. \\<And>l c n ts c' n' s'a ca na tk.\n       \\<lbrakk>B.reachable s;\n        case s of\n        (c, n, ts) \\<Rightarrow>\n          c < N \\<and>\n          (\\<forall>t<N.\n              \\<forall>tk. has_ticket (ts t) tk \\<longrightarrow> tk < N);\n        s = (c, n, ts); s' = (c', n', ts(l := s'a)); l < N;\n        (c, n, ts l) = (ca, na, HOLD tk);\n        (c', n', s'a) = (ca, na, REL tk)\\<rbrakk>\n       \\<Longrightarrow> case s' of\n                         (c, n, ts) \\<Rightarrow>\n                           c < N \\<and>\n                           (\\<forall>t<N.\n                               \\<forall>tk.\n                                  has_ticket (ts t) tk \\<longrightarrow>\n                                  tk < N)\n 5. \\<And>l c n ts c' n' s'a ca na tk.\n       \\<lbrakk>B.reachable s;\n        case s of\n        (c, n, ts) \\<Rightarrow>\n          c < N \\<and>\n          (\\<forall>t<N.\n              \\<forall>tk. has_ticket (ts t) tk \\<longrightarrow> tk < N);\n        s = (c, n, ts); s' = (c', n', ts(l := s'a)); l < N;\n        (c, n, ts l) = (ca, na, REL tk);\n        (c', n', s'a) = ((tk + 1) mod N, na, INIT)\\<rbrakk>\n       \\<Longrightarrow> case s' of\n                         (c, n, ts) \\<Rightarrow>\n                           c < N \\<and>\n                           (\\<forall>t<N.\n                               \\<forall>tk.\n                                  has_ticket (ts t) tk \\<longrightarrow>\n                                  tk < N)", "apply safe"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>l c n ts c' n' s'a ca na t tk.\n       \\<lbrakk>B.reachable (ca, na, ts);\n        s' = (ca, (na + 1) mod (k * N), ts(l := WAIT (na mod N))); l < N;\n        s = (ca, na, ts); ca < N;\n        \\<forall>t<N.\n           \\<forall>tk. has_ticket (ts t) tk \\<longrightarrow> tk < N;\n        ts l = INIT; t < N;\n        has_ticket ((ts(l := WAIT (na mod N))) t) tk\\<rbrakk>\n       \\<Longrightarrow> tk < N\n 2. \\<And>l c n ts c' n' s'a ca tk na t tka.\n       \\<lbrakk>B.reachable (ca, na, ts); s' = (ca, na, ts(l := WAIT tk));\n        l < N; ca \\<noteq> tk; s = (ca, na, ts); ca < N;\n        \\<forall>t<N.\n           \\<forall>tk. has_ticket (ts t) tk \\<longrightarrow> tk < N;\n        ts l = WAIT tk; t < N;\n        has_ticket ((ts(l := WAIT tk)) t) tka\\<rbrakk>\n       \\<Longrightarrow> tka < N\n 3. \\<And>l c n ts c' n' s'a ca na t tk.\n       \\<lbrakk>B.reachable (ca, na, ts); s' = (ca, na, ts(l := HOLD ca));\n        l < N; s = (ca, na, ts); ca < N;\n        \\<forall>t<N.\n           \\<forall>tk. has_ticket (ts t) tk \\<longrightarrow> tk < N;\n        ts l = WAIT ca; t < N; has_ticket ((ts(l := HOLD ca)) t) tk\\<rbrakk>\n       \\<Longrightarrow> tk < N\n 4. \\<And>l c n ts c' n' s'a ca na tk t tka.\n       \\<lbrakk>B.reachable (ca, na, ts); s' = (ca, na, ts(l := REL tk));\n        l < N; s = (ca, na, ts); ca < N;\n        \\<forall>t<N.\n           \\<forall>tk. has_ticket (ts t) tk \\<longrightarrow> tk < N;\n        ts l = HOLD tk; t < N; has_ticket ((ts(l := REL tk)) t) tka\\<rbrakk>\n       \\<Longrightarrow> tka < N\n 5. \\<And>l c n ts c' n' s'a ca na tk.\n       \\<lbrakk>B.reachable (ca, na, ts);\n        s' = ((tk + 1) mod N, na, ts(l := INIT)); l < N; s = (ca, na, ts);\n        ca < N;\n        \\<forall>t<N.\n           \\<forall>tk. has_ticket (ts t) tk \\<longrightarrow> tk < N;\n        ts l = REL tk\\<rbrakk>\n       \\<Longrightarrow> (tk + 1) mod N < N\n 6. \\<And>l c n ts c' n' s'a ca na tk t tka.\n       \\<lbrakk>B.reachable (ca, na, ts);\n        s' = ((tk + 1) mod N, na, ts(l := INIT)); l < N; s = (ca, na, ts);\n        ca < N;\n        \\<forall>t<N.\n           \\<forall>tk. has_ticket (ts t) tk \\<longrightarrow> tk < N;\n        ts l = REL tk; t < N; has_ticket ((ts(l := INIT)) t) tka\\<rbrakk>\n       \\<Longrightarrow> tka < N", "apply (metis N_gt0 fun_upd_apply has_ticket_simps(2) mod_less_divisor)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>l c n ts c' n' s'a ca tk na t tka.\n       \\<lbrakk>B.reachable (ca, na, ts); s' = (ca, na, ts(l := WAIT tk));\n        l < N; ca \\<noteq> tk; s = (ca, na, ts); ca < N;\n        \\<forall>t<N.\n           \\<forall>tk. has_ticket (ts t) tk \\<longrightarrow> tk < N;\n        ts l = WAIT tk; t < N;\n        has_ticket ((ts(l := WAIT tk)) t) tka\\<rbrakk>\n       \\<Longrightarrow> tka < N\n 2. \\<And>l c n ts c' n' s'a ca na t tk.\n       \\<lbrakk>B.reachable (ca, na, ts); s' = (ca, na, ts(l := HOLD ca));\n        l < N; s = (ca, na, ts); ca < N;\n        \\<forall>t<N.\n           \\<forall>tk. has_ticket (ts t) tk \\<longrightarrow> tk < N;\n        ts l = WAIT ca; t < N; has_ticket ((ts(l := HOLD ca)) t) tk\\<rbrakk>\n       \\<Longrightarrow> tk < N\n 3. \\<And>l c n ts c' n' s'a ca na tk t tka.\n       \\<lbrakk>B.reachable (ca, na, ts); s' = (ca, na, ts(l := REL tk));\n        l < N; s = (ca, na, ts); ca < N;\n        \\<forall>t<N.\n           \\<forall>tk. has_ticket (ts t) tk \\<longrightarrow> tk < N;\n        ts l = HOLD tk; t < N; has_ticket ((ts(l := REL tk)) t) tka\\<rbrakk>\n       \\<Longrightarrow> tka < N\n 4. \\<And>l c n ts c' n' s'a ca na tk.\n       \\<lbrakk>B.reachable (ca, na, ts);\n        s' = ((tk + 1) mod N, na, ts(l := INIT)); l < N; s = (ca, na, ts);\n        ca < N;\n        \\<forall>t<N.\n           \\<forall>tk. has_ticket (ts t) tk \\<longrightarrow> tk < N;\n        ts l = REL tk\\<rbrakk>\n       \\<Longrightarrow> (tk + 1) mod N < N\n 5. \\<And>l c n ts c' n' s'a ca na tk t tka.\n       \\<lbrakk>B.reachable (ca, na, ts);\n        s' = ((tk + 1) mod N, na, ts(l := INIT)); l < N; s = (ca, na, ts);\n        ca < N;\n        \\<forall>t<N.\n           \\<forall>tk. has_ticket (ts t) tk \\<longrightarrow> tk < N;\n        ts l = REL tk; t < N; has_ticket ((ts(l := INIT)) t) tka\\<rbrakk>\n       \\<Longrightarrow> tka < N", "apply (metis fun_upd_triv)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>l c n ts c' n' s'a ca na t tk.\n       \\<lbrakk>B.reachable (ca, na, ts); s' = (ca, na, ts(l := HOLD ca));\n        l < N; s = (ca, na, ts); ca < N;\n        \\<forall>t<N.\n           \\<forall>tk. has_ticket (ts t) tk \\<longrightarrow> tk < N;\n        ts l = WAIT ca; t < N; has_ticket ((ts(l := HOLD ca)) t) tk\\<rbrakk>\n       \\<Longrightarrow> tk < N\n 2. \\<And>l c n ts c' n' s'a ca na tk t tka.\n       \\<lbrakk>B.reachable (ca, na, ts); s' = (ca, na, ts(l := REL tk));\n        l < N; s = (ca, na, ts); ca < N;\n        \\<forall>t<N.\n           \\<forall>tk. has_ticket (ts t) tk \\<longrightarrow> tk < N;\n        ts l = HOLD tk; t < N; has_ticket ((ts(l := REL tk)) t) tka\\<rbrakk>\n       \\<Longrightarrow> tka < N\n 3. \\<And>l c n ts c' n' s'a ca na tk.\n       \\<lbrakk>B.reachable (ca, na, ts);\n        s' = ((tk + 1) mod N, na, ts(l := INIT)); l < N; s = (ca, na, ts);\n        ca < N;\n        \\<forall>t<N.\n           \\<forall>tk. has_ticket (ts t) tk \\<longrightarrow> tk < N;\n        ts l = REL tk\\<rbrakk>\n       \\<Longrightarrow> (tk + 1) mod N < N\n 4. \\<And>l c n ts c' n' s'a ca na tk t tka.\n       \\<lbrakk>B.reachable (ca, na, ts);\n        s' = ((tk + 1) mod N, na, ts(l := INIT)); l < N; s = (ca, na, ts);\n        ca < N;\n        \\<forall>t<N.\n           \\<forall>tk. has_ticket (ts t) tk \\<longrightarrow> tk < N;\n        ts l = REL tk; t < N; has_ticket ((ts(l := INIT)) t) tka\\<rbrakk>\n       \\<Longrightarrow> tka < N", "apply (metis fun_upd_other fun_upd_same has_ticket_simps(3))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>l c n ts c' n' s'a ca na tk t tka.\n       \\<lbrakk>B.reachable (ca, na, ts); s' = (ca, na, ts(l := REL tk));\n        l < N; s = (ca, na, ts); ca < N;\n        \\<forall>t<N.\n           \\<forall>tk. has_ticket (ts t) tk \\<longrightarrow> tk < N;\n        ts l = HOLD tk; t < N; has_ticket ((ts(l := REL tk)) t) tka\\<rbrakk>\n       \\<Longrightarrow> tka < N\n 2. \\<And>l c n ts c' n' s'a ca na tk.\n       \\<lbrakk>B.reachable (ca, na, ts);\n        s' = ((tk + 1) mod N, na, ts(l := INIT)); l < N; s = (ca, na, ts);\n        ca < N;\n        \\<forall>t<N.\n           \\<forall>tk. has_ticket (ts t) tk \\<longrightarrow> tk < N;\n        ts l = REL tk\\<rbrakk>\n       \\<Longrightarrow> (tk + 1) mod N < N\n 3. \\<And>l c n ts c' n' s'a ca na tk t tka.\n       \\<lbrakk>B.reachable (ca, na, ts);\n        s' = ((tk + 1) mod N, na, ts(l := INIT)); l < N; s = (ca, na, ts);\n        ca < N;\n        \\<forall>t<N.\n           \\<forall>tk. has_ticket (ts t) tk \\<longrightarrow> tk < N;\n        ts l = REL tk; t < N; has_ticket ((ts(l := INIT)) t) tka\\<rbrakk>\n       \\<Longrightarrow> tka < N", "apply (metis fun_upd_other fun_upd_same has_ticket_def has_ticket_simps(4))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l c n ts c' n' s'a ca na tk.\n       \\<lbrakk>B.reachable (ca, na, ts);\n        s' = ((tk + 1) mod N, na, ts(l := INIT)); l < N; s = (ca, na, ts);\n        ca < N;\n        \\<forall>t<N.\n           \\<forall>tk. has_ticket (ts t) tk \\<longrightarrow> tk < N;\n        ts l = REL tk\\<rbrakk>\n       \\<Longrightarrow> (tk + 1) mod N < N\n 2. \\<And>l c n ts c' n' s'a ca na tk t tka.\n       \\<lbrakk>B.reachable (ca, na, ts);\n        s' = ((tk + 1) mod N, na, ts(l := INIT)); l < N; s = (ca, na, ts);\n        ca < N;\n        \\<forall>t<N.\n           \\<forall>tk. has_ticket (ts t) tk \\<longrightarrow> tk < N;\n        ts l = REL tk; t < N; has_ticket ((ts(l := INIT)) t) tka\\<rbrakk>\n       \\<Longrightarrow> tka < N", "using mod_less_divisor"], ["proof (prove)\nusing this:\n  0 < ?n \\<Longrightarrow> ?m mod ?n < ?n\n\ngoal (2 subgoals):\n 1. \\<And>l c n ts c' n' s'a ca na tk.\n       \\<lbrakk>B.reachable (ca, na, ts);\n        s' = ((tk + 1) mod N, na, ts(l := INIT)); l < N; s = (ca, na, ts);\n        ca < N;\n        \\<forall>t<N.\n           \\<forall>tk. has_ticket (ts t) tk \\<longrightarrow> tk < N;\n        ts l = REL tk\\<rbrakk>\n       \\<Longrightarrow> (tk + 1) mod N < N\n 2. \\<And>l c n ts c' n' s'a ca na tk t tka.\n       \\<lbrakk>B.reachable (ca, na, ts);\n        s' = ((tk + 1) mod N, na, ts(l := INIT)); l < N; s = (ca, na, ts);\n        ca < N;\n        \\<forall>t<N.\n           \\<forall>tk. has_ticket (ts t) tk \\<longrightarrow> tk < N;\n        ts l = REL tk; t < N; has_ticket ((ts(l := INIT)) t) tka\\<rbrakk>\n       \\<Longrightarrow> tka < N", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l c n ts c' n' s'a ca na tk t tka.\n       \\<lbrakk>B.reachable (ca, na, ts);\n        s' = ((tk + 1) mod N, na, ts(l := INIT)); l < N; s = (ca, na, ts);\n        ca < N;\n        \\<forall>t<N.\n           \\<forall>tk. has_ticket (ts t) tk \\<longrightarrow> tk < N;\n        ts l = REL tk; t < N; has_ticket ((ts(l := INIT)) t) tka\\<rbrakk>\n       \\<Longrightarrow> tka < N", "apply (metis fun_upd_apply thread.distinct(1) thread.distinct(3) \n          thread.distinct(5) has_ticket_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>We define a predicate that describes that\n    a thread of the system is at the release sequence point --- in this case,\n    the array does not have a set bit, otherwise, the set bit corresponds to the \n    current ticket.\\<close>"], ["", "definition \"is_REL_state \\<equiv> \\<lambda>ts. \\<exists>t<N. \\<exists>tk. ts t = REL tk\""], ["", "lemma is_REL_state_simps[simp]:\n    \"t<N \\<Longrightarrow> is_REL_state (ts(t:=REL tk))\"\n    \"t<N \\<Longrightarrow> \\<not>is_REL (ts t) \\<Longrightarrow> \\<not>is_REL s' \n      \\<Longrightarrow> is_REL_state (ts(t:=s')) \\<longleftrightarrow> is_REL_state ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t < N \\<Longrightarrow> is_REL_state (ts(t := REL tk))) &&&\n    (\\<lbrakk>t < N; \\<not> is_REL (ts t); \\<not> is_REL s'\\<rbrakk>\n     \\<Longrightarrow> is_REL_state (ts(t := s')) = is_REL_state ts)", "unfolding is_REL_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (t < N \\<Longrightarrow>\n     \\<exists>ta<N. \\<exists>tka. (ts(t := REL tk)) ta = REL tka) &&&\n    (\\<lbrakk>t < N; \\<not> is_REL (ts t); \\<not> is_REL s'\\<rbrakk>\n     \\<Longrightarrow> (\\<exists>ta<N.\n                           \\<exists>tk. (ts(t := s')) ta = REL tk) =\n                       (\\<exists>t<N. \\<exists>tk. ts t = REL tk))", "apply (auto; fail) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t < N; \\<not> is_REL (ts t); \\<not> is_REL s'\\<rbrakk>\n    \\<Longrightarrow> (\\<exists>ta<N.\n                          \\<exists>tk. (ts(t := s')) ta = REL tk) =\n                      (\\<exists>t<N. \\<exists>tk. ts t = REL tk)", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ta tk.\n       \\<lbrakk>t < N; \\<not> is_REL (ts t); \\<not> is_REL s'; ta < N;\n        ts ta = REL tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta.\n                            (ta = t \\<longrightarrow>\n                             (\\<exists>tk. s' = REL tk)) \\<and>\n                            (ta \\<noteq> t \\<longrightarrow>\n                             ta < N \\<and> (\\<exists>tk. ts ta = REL tk))", "by (metis thread.disc(12))"], ["", "lemma is_REL_state_aux1:  \n    assumes R: \"B.reachable (c,n,ts)\"\n    assumes REL: \"is_REL_state ts\"\n    assumes \"t<N\" and [simp]: \"ts t = WAIT tk\"\n    shows \"tk\\<noteq>c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tk \\<noteq> c", "using REL"], ["proof (prove)\nusing this:\n  is_REL_state ts\n\ngoal (1 subgoal):\n 1. tk \\<noteq> c", "unfolding is_REL_state_def"], ["proof (prove)\nusing this:\n  \\<exists>t<N. \\<exists>tk. ts t = REL tk\n\ngoal (1 subgoal):\n 1. tk \\<noteq> c", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t tka.\n       \\<lbrakk>t < N; ts t = REL tka; tk = c\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for t' tk'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t' < N; ts t' = REL tk'; tk = c\\<rbrakk>\n    \\<Longrightarrow> False", "using b_has_ticket_unique[OF R \\<open>t<N\\<close>, of tk t']"], ["proof (prove)\nusing this:\n  \\<lbrakk>has_ticket (ts t) tk; t' < N; has_ticket (ts t') tk\\<rbrakk>\n  \\<Longrightarrow> t' = t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t' < N; ts t' = REL tk'; tk = c\\<rbrakk>\n    \\<Longrightarrow> False", "using b_holds_only_current[OF R, of t' tk']"], ["proof (prove)\nusing this:\n  \\<lbrakk>has_ticket (ts t) tk; t' < N; has_ticket (ts t') tk\\<rbrakk>\n  \\<Longrightarrow> t' = t\n  \\<lbrakk>t' < N; locks_ticket (ts t') tk'\\<rbrakk>\n  \\<Longrightarrow> tk' = c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t' < N; ts t' = REL tk'; tk = c\\<rbrakk>\n    \\<Longrightarrow> False", "by (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma is_REL_state_aux2:\n    assumes R: \"B.reachable (c,n,ts)\"\n    assumes A: \"t<N\" \"ts t = REL tk\"\n    shows \"\\<not>is_REL_state (ts(t:=INIT))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_REL_state (ts(t := INIT))", "using b_holds_only_current[OF R] A"], ["proof (prove)\nusing this:\n  \\<lbrakk>?t < N; locks_ticket (ts ?t) ?tk\\<rbrakk>\n  \\<Longrightarrow> ?tk = c\n  t < N\n  ts t = REL tk\n\ngoal (1 subgoal):\n 1. \\<not> is_REL_state (ts(t := INIT))", "using b_mutual_exclusion'[OF R]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?t < N; locks_ticket (ts ?t) ?tk\\<rbrakk>\n  \\<Longrightarrow> ?tk = c\n  t < N\n  ts t = REL tk\n  \\<lbrakk>?t < N; ?t' < N; ?t \\<noteq> ?t';\n   locks_ticket (tts (c, n, ts) ?t) ?tk;\n   locks_ticket (tts (c, n, ts) ?t') ?tk'\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> is_REL_state (ts(t := INIT))", "apply (clarsimp simp: is_REL_state_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ta tka.\n       \\<lbrakk>\\<And>t tk.\n                   \\<lbrakk>t < N; locks_ticket (ts t) tk\\<rbrakk>\n                   \\<Longrightarrow> tk = c;\n        t < N; ts t = REL tk;\n        \\<And>t t' tk tk'.\n           \\<lbrakk>t < N; t' < N; t \\<noteq> t'; locks_ticket (ts t) tk;\n            locks_ticket (ts t') tk'\\<rbrakk>\n           \\<Longrightarrow> False;\n        ta \\<noteq> t; ta < N; ts ta = REL tka\\<rbrakk>\n       \\<Longrightarrow> False", "by fastforce"], ["", "text \\<open>Simulation relation that implements current ticket by array\\<close>"], ["", "definition \"sim_rel2 \\<equiv> \\<lambda>(c,n,ts) (ci,ni,tsi). \n    (if is_REL_state ts then \n      ci = replicate N False \n    else   \n      ci = (replicate N False)[c:=True]\n    )\n  \\<and> ni = n\n  \\<and> tsi = ts\n  \""], ["", "interpretation sim2: simulationI bs\\<^sub>0 blstep cs\\<^sub>0 clstep sim_rel2"], ["proof (prove)\ngoal (1 subgoal):\n 1. simulationI bs\\<^sub>0 blstep cs\\<^sub>0 clstep sim_rel2", "proof unfold_locales"], ["proof (state)\ngoal (3 subgoals):\n 1. sim_rel2 bs\\<^sub>0 cs\\<^sub>0\n 2. \\<And>as cs l cs'.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        clstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel2 as' cs' \\<and> blstep l as as'\n 3. \\<And>as cs l.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        B.can_step l as\\<rbrakk>\n       \\<Longrightarrow> C.can_step l cs", "show \"sim_rel2 bs\\<^sub>0 cs\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sim_rel2 bs\\<^sub>0 cs\\<^sub>0", "by (auto simp: sim_rel2_def bs\\<^sub>0_def cs\\<^sub>0_def is_REL_state_def)"], ["proof (state)\nthis:\n  sim_rel2 bs\\<^sub>0 cs\\<^sub>0\n\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        clstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel2 as' cs' \\<and> blstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        B.can_step l as\\<rbrakk>\n       \\<Longrightarrow> C.can_step l cs", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        clstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel2 as' cs' \\<and> blstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        B.can_step l as\\<rbrakk>\n       \\<Longrightarrow> C.can_step l cs", "fix bs cs t cs'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        clstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel2 as' cs' \\<and> blstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        B.can_step l as\\<rbrakk>\n       \\<Longrightarrow> C.can_step l cs", "assume Rc_aux: \"B.reachable bs\" \n       and Rd_aux: \"C.reachable cs\" \n       and SIM: \"sim_rel2 bs cs\" \n       and CS: \"clstep t cs cs'\""], ["proof (state)\nthis:\n  B.reachable bs\n  C.reachable cs\n  sim_rel2 bs cs\n  clstep t cs cs'\n\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        clstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel2 as' cs' \\<and> blstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        B.can_step l as\\<rbrakk>\n       \\<Longrightarrow> C.can_step l cs", "obtain c n ts where [simp]: \"bs=(c,n,ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c n ts.\n        bs = (c, n, ts) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases bs)"], ["proof (state)\nthis:\n  bs = (c, n, ts)\n\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        clstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel2 as' cs' \\<and> blstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        B.can_step l as\\<rbrakk>\n       \\<Longrightarrow> C.can_step l cs", "obtain ci ni tsi where [simp]: \"cs=(ci,ni,tsi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ci ni tsi.\n        cs = (ci, ni, tsi) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases cs)"], ["proof (state)\nthis:\n  cs = (ci, ni, tsi)\n\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        clstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel2 as' cs' \\<and> blstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        B.can_step l as\\<rbrakk>\n       \\<Longrightarrow> C.can_step l cs", "obtain ci' ni' tsi' where [simp]: \"cs'=(ci',ni',tsi')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ci' ni' tsi'.\n        cs' = (ci', ni', tsi') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases cs')"], ["proof (state)\nthis:\n  cs' = (ci', ni', tsi')\n\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        clstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel2 as' cs' \\<and> blstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        B.can_step l as\\<rbrakk>\n       \\<Longrightarrow> C.can_step l cs", "from Rc_aux"], ["proof (chain)\npicking this:\n  B.reachable bs", "have Rc: \"B.reachable (c,n,ts)\""], ["proof (prove)\nusing this:\n  B.reachable bs\n\ngoal (1 subgoal):\n 1. B.reachable (c, n, ts)", "by simp"], ["proof (state)\nthis:\n  B.reachable (c, n, ts)\n\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        clstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel2 as' cs' \\<and> blstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        B.can_step l as\\<rbrakk>\n       \\<Longrightarrow> C.can_step l cs", "from Rd_aux"], ["proof (chain)\npicking this:\n  C.reachable cs", "have Rd: \"C.reachable (ci,ni,tsi)\""], ["proof (prove)\nusing this:\n  C.reachable cs\n\ngoal (1 subgoal):\n 1. C.reachable (ci, ni, tsi)", "by simp"], ["proof (state)\nthis:\n  C.reachable (ci, ni, tsi)\n\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        clstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel2 as' cs' \\<and> blstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        B.can_step l as\\<rbrakk>\n       \\<Longrightarrow> C.can_step l cs", "from CS"], ["proof (chain)\npicking this:\n  clstep t cs cs'", "have \"t<N\""], ["proof (prove)\nusing this:\n  clstep t cs cs'\n\ngoal (1 subgoal):\n 1. t < N", "by cases auto"], ["proof (state)\nthis:\n  t < N\n\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        clstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel2 as' cs' \\<and> blstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        B.can_step l as\\<rbrakk>\n       \\<Longrightarrow> C.can_step l cs", "have [simp]: \"tk<N\" if \"ts t = WAIT tk\" for tk"], ["proof (prove)\ngoal (1 subgoal):\n 1. tk < N", "using B.invar_reachable[OF is_invar4 Rc] that \\<open>t<N\\<close>"], ["proof (prove)\nusing this:\n  invar4 (c, n, ts)\n  ts t = WAIT tk\n  t < N\n\ngoal (1 subgoal):\n 1. tk < N", "by (auto simp: invar4_def)"], ["proof (state)\nthis:\n  ts t = WAIT ?tk \\<Longrightarrow> ?tk < N\n\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        clstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel2 as' cs' \\<and> blstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        B.can_step l as\\<rbrakk>\n       \\<Longrightarrow> C.can_step l cs", "have HOLD_AUX: \"tk=c\" if \"ts t = HOLD tk\" for tk"], ["proof (prove)\ngoal (1 subgoal):\n 1. tk = c", "using b_holds_only_current[OF Rc \\<open>t<N\\<close>, of tk] that"], ["proof (prove)\nusing this:\n  locks_ticket (ts t) tk \\<Longrightarrow> tk = c\n  ts t = HOLD tk\n\ngoal (1 subgoal):\n 1. tk = c", "by auto"], ["proof (state)\nthis:\n  ts t = HOLD ?tk \\<Longrightarrow> ?tk = c\n\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        clstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel2 as' cs' \\<and> blstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        B.can_step l as\\<rbrakk>\n       \\<Longrightarrow> C.can_step l cs", "have REL_AUX: \"tk=c\" if \"ts t = REL tk\" \"t<N\" for t tk"], ["proof (prove)\ngoal (1 subgoal):\n 1. tk = c", "using b_holds_only_current[OF Rc \\<open>t<N\\<close>, of tk] that"], ["proof (prove)\nusing this:\n  locks_ticket (ts t) tk \\<Longrightarrow> tk = c\n  ts t = REL tk\n  t < N\n\ngoal (1 subgoal):\n 1. tk = c", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>ts ?t = REL ?tk; ?t < N\\<rbrakk> \\<Longrightarrow> ?tk = c\n\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        clstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel2 as' cs' \\<and> blstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        B.can_step l as\\<rbrakk>\n       \\<Longrightarrow> C.can_step l cs", "have [simp]: \"c<N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c < N", "using B.invar_reachable[OF is_invar4 Rc]"], ["proof (prove)\nusing this:\n  invar4 (c, n, ts)\n\ngoal (1 subgoal):\n 1. c < N", "by (auto simp: invar4_def)"], ["proof (state)\nthis:\n  c < N\n\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        clstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel2 as' cs' \\<and> blstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        B.can_step l as\\<rbrakk>\n       \\<Longrightarrow> C.can_step l cs", "have [simp]: \n      \"replicate N False \\<noteq> (replicate N False)[c := True]\"  \n      \"(replicate N False)[c := True] \\<noteq> replicate N False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate N False \\<noteq> (replicate N False)[c := True] &&&\n    (replicate N False)[c := True] \\<noteq> replicate N False", "apply (auto simp: list_eq_iff_nth_eq nth_list_update)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>i.\n       (c = i \\<longrightarrow> i < N) \\<and>\n       (c \\<noteq> i \\<longrightarrow> i < N \\<and> replicate N False ! i)\n 2. \\<exists>i.\n       (c = i \\<longrightarrow> i < N) \\<and>\n       (c \\<noteq> i \\<longrightarrow> i < N \\<and> replicate N False ! i)", "using \\<open>c < N\\<close>"], ["proof (prove)\nusing this:\n  c < N\n\ngoal (2 subgoals):\n 1. \\<exists>i.\n       (c = i \\<longrightarrow> i < N) \\<and>\n       (c \\<noteq> i \\<longrightarrow> i < N \\<and> replicate N False ! i)\n 2. \\<exists>i.\n       (c = i \\<longrightarrow> i < N) \\<and>\n       (c \\<noteq> i \\<longrightarrow> i < N \\<and> replicate N False ! i)", "by blast+"], ["proof (state)\nthis:\n  replicate N False \\<noteq> (replicate N False)[c := True]\n  (replicate N False)[c := True] \\<noteq> replicate N False\n\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        clstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel2 as' cs' \\<and> blstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        B.can_step l as\\<rbrakk>\n       \\<Longrightarrow> C.can_step l cs", "have [simp]:\n      \"(replicate N False)[c := True] ! d \\<longleftrightarrow> d=c\" if \"d<N\" for d"], ["proof (prove)\ngoal (1 subgoal):\n 1. (replicate N False)[c := True] ! d = (d = c)", "using that"], ["proof (prove)\nusing this:\n  d < N\n\ngoal (1 subgoal):\n 1. (replicate N False)[c := True] ! d = (d = c)", "by (auto simp: list_eq_iff_nth_eq nth_list_update)"], ["proof (state)\nthis:\n  ?d < N \\<Longrightarrow> (replicate N False)[c := True] ! ?d = (?d = c)\n\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        clstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel2 as' cs' \\<and> blstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        B.can_step l as\\<rbrakk>\n       \\<Longrightarrow> C.can_step l cs", "have [simp]: \"(replicate N False)[tk := False] = replicate N False\" for tk"], ["proof (prove)\ngoal (1 subgoal):\n 1. (replicate N False)[tk := False] = replicate N False", "by (auto simp: list_eq_iff_nth_eq nth_list_update')"], ["proof (state)\nthis:\n  (replicate N False)[?tk := False] = replicate N False\n\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        clstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel2 as' cs' \\<and> blstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        B.can_step l as\\<rbrakk>\n       \\<Longrightarrow> C.can_step l cs", "from SIM CS"], ["proof (chain)\npicking this:\n  sim_rel2 bs cs\n  clstep t cs cs'", "have \"\\<exists>bs'. blstep t bs bs' \\<and> sim_rel2 bs' cs'\""], ["proof (prove)\nusing this:\n  sim_rel2 bs cs\n  clstep t cs cs'\n\ngoal (1 subgoal):\n 1. \\<exists>bs'. blstep t bs bs' \\<and> sim_rel2 bs' cs'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sim_rel2 (c, n, ts) (ci, ni, tsi);\n     clstep t (ci, ni, tsi) (ci', ni', tsi')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a aa b.\n                         blstep t (c, n, ts) (a, aa, b) \\<and>\n                         sim_rel2 (a, aa, b) (ci', ni', tsi')", "apply (subst (asm) sim_rel2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(case (c, n, ts) of\n              (c, n, ts) \\<Rightarrow>\n                \\<lambda>(ci, ni, tsi).\n                   (if is_REL_state ts then ci = replicate N False\n                    else ci = (replicate N False)[c := True]) \\<and>\n                   ni = n \\<and> tsi = ts)\n              (ci, ni, tsi);\n     clstep t (ci, ni, tsi) (ci', ni', tsi')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a aa b.\n                         blstep t (c, n, ts) (a, aa, b) \\<and>\n                         sim_rel2 (a, aa, b) (ci', ni', tsi')", "apply (erule clstep.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ca na tsa c' n' s'.\n       \\<lbrakk>(case (c, n, ts) of\n                 (c, n, ts) \\<Rightarrow>\n                   \\<lambda>(ci, ni, tsi).\n                      (if is_REL_state ts then ci = replicate N False\n                       else ci = (replicate N False)[c := True]) \\<and>\n                      ni = n \\<and> tsi = ts)\n                 (ci, ni, tsi);\n        (ci, ni, tsi) = (ca, na, tsa);\n        (ci', ni', tsi') = (c', n', tsa(t := s')); t < N;\n        cstep_sng (ca, na, tsa t) (c', n', s')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            blstep t (c, n, ts) (a, aa, b) \\<and>\n                            sim_rel2 (a, aa, b) (ci', ni', tsi')", "apply (erule cstep_sng.cases)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>ca na tsa c' n' s' p naa.\n       \\<lbrakk>(case (c, n, ts) of\n                 (c, n, ts) \\<Rightarrow>\n                   \\<lambda>(ci, ni, tsi).\n                      (if is_REL_state ts then ci = replicate N False\n                       else ci = (replicate N False)[c := True]) \\<and>\n                      ni = n \\<and> tsi = ts)\n                 (ci, ni, tsi);\n        (ci, ni, tsi) = (ca, na, tsa);\n        (ci', ni', tsi') = (c', n', tsa(t := s')); t < N;\n        (ca, na, tsa t) = (p, naa, INIT);\n        (c', n', s') = (p, (naa + 1) mod (k * N), WAIT (naa mod N))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            blstep t (c, n, ts) (a, aa, b) \\<and>\n                            sim_rel2 (a, aa, b) (ci', ni', tsi')\n 2. \\<And>ca na tsa c' n' s' p tk naa.\n       \\<lbrakk>(case (c, n, ts) of\n                 (c, n, ts) \\<Rightarrow>\n                   \\<lambda>(ci, ni, tsi).\n                      (if is_REL_state ts then ci = replicate N False\n                       else ci = (replicate N False)[c := True]) \\<and>\n                      ni = n \\<and> tsi = ts)\n                 (ci, ni, tsi);\n        (ci, ni, tsi) = (ca, na, tsa);\n        (ci', ni', tsi') = (c', n', tsa(t := s')); t < N;\n        (ca, na, tsa t) = (p, naa, WAIT tk);\n        (c', n', s') = (p, naa, WAIT tk); \\<not> p ! tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            blstep t (c, n, ts) (a, aa, b) \\<and>\n                            sim_rel2 (a, aa, b) (ci', ni', tsi')\n 3. \\<And>ca na tsa c' n' s' p tk naa.\n       \\<lbrakk>(case (c, n, ts) of\n                 (c, n, ts) \\<Rightarrow>\n                   \\<lambda>(ci, ni, tsi).\n                      (if is_REL_state ts then ci = replicate N False\n                       else ci = (replicate N False)[c := True]) \\<and>\n                      ni = n \\<and> tsi = ts)\n                 (ci, ni, tsi);\n        (ci, ni, tsi) = (ca, na, tsa);\n        (ci', ni', tsi') = (c', n', tsa(t := s')); t < N;\n        (ca, na, tsa t) = (p, naa, WAIT tk);\n        (c', n', s') = (p, naa, HOLD tk); p ! tk\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            blstep t (c, n, ts) (a, aa, b) \\<and>\n                            sim_rel2 (a, aa, b) (ci', ni', tsi')\n 4. \\<And>ca na tsa c' n' s' p naa tk.\n       \\<lbrakk>(case (c, n, ts) of\n                 (c, n, ts) \\<Rightarrow>\n                   \\<lambda>(ci, ni, tsi).\n                      (if is_REL_state ts then ci = replicate N False\n                       else ci = (replicate N False)[c := True]) \\<and>\n                      ni = n \\<and> tsi = ts)\n                 (ci, ni, tsi);\n        (ci, ni, tsi) = (ca, na, tsa);\n        (ci', ni', tsi') = (c', n', tsa(t := s')); t < N;\n        (ca, na, tsa t) = (p, naa, HOLD tk);\n        (c', n', s') = (p[tk := False], naa, REL tk)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            blstep t (c, n, ts) (a, aa, b) \\<and>\n                            sim_rel2 (a, aa, b) (ci', ni', tsi')\n 5. \\<And>ca na tsa c' n' s' p naa tk.\n       \\<lbrakk>(case (c, n, ts) of\n                 (c, n, ts) \\<Rightarrow>\n                   \\<lambda>(ci, ni, tsi).\n                      (if is_REL_state ts then ci = replicate N False\n                       else ci = (replicate N False)[c := True]) \\<and>\n                      ni = n \\<and> tsi = ts)\n                 (ci, ni, tsi);\n        (ci, ni, tsi) = (ca, na, tsa);\n        (ci', ni', tsi') = (c', n', tsa(t := s')); t < N;\n        (ca, na, tsa t) = (p, naa, REL tk);\n        (c', n', s') = (p[(tk + 1) mod N := True], naa, INIT)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            blstep t (c, n, ts) (a, aa, b) \\<and>\n                            sim_rel2 (a, aa, b) (ci', ni', tsi')", "apply clarsimp_all"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci; n = ni; ts t = INIT;\n     ni' = Suc ni mod (k * N); tsi' = ts(t := WAIT (ni mod N))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a aa b.\n                         blstep t (c, ni, ts) (a, aa, b) \\<and>\n                         sim_rel2 (a, aa, b)\n                          (ci, Suc ni mod (k * N), ts(t := WAIT (ni mod N)))\n 2. \\<And>tk.\n       \\<lbrakk>if is_REL_state ts then ci = replicate N False\n                else ci = (replicate N False)[c := True];\n        tsi = ts; t < N; \\<not> ci ! tk; ci' = ci; n = ni; ts t = WAIT tk;\n        ni' = ni; tsi' = ts(t := WAIT tk)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            blstep t (c, ni, ts) (a, aa, b) \\<and>\n                            sim_rel2 (a, aa, b) (ci, ni, ts(t := WAIT tk))\n 3. \\<And>tk.\n       \\<lbrakk>if is_REL_state ts then ci = replicate N False\n                else ci = (replicate N False)[c := True];\n        tsi = ts; t < N; ci ! tk; ci' = ci; n = ni; ts t = WAIT tk;\n        ni' = ni; tsi' = ts(t := HOLD tk)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            blstep t (c, ni, ts) (a, aa, b) \\<and>\n                            sim_rel2 (a, aa, b) (ci, ni, ts(t := HOLD tk))\n 4. \\<And>tk.\n       \\<lbrakk>if is_REL_state ts then ci = replicate N False\n                else ci = (replicate N False)[c := True];\n        tsi = ts; t < N; ci' = ci[tk := False]; n = ni; ts t = HOLD tk;\n        ni' = ni; tsi' = ts(t := REL tk)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            blstep t (c, ni, ts) (a, aa, b) \\<and>\n                            sim_rel2 (a, aa, b)\n                             (ci[tk := False], ni, ts(t := REL tk))\n 5. \\<And>tk.\n       \\<lbrakk>if is_REL_state ts then ci = replicate N False\n                else ci = (replicate N False)[c := True];\n        tsi = ts; t < N; ci' = ci[Suc tk mod N := True]; n = ni;\n        ts t = REL tk; ni' = ni; tsi' = ts(t := INIT)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            blstep t (c, ni, ts) (a, aa, b) \\<and>\n                            sim_rel2 (a, aa, b)\n                             (ci[Suc tk mod N := True], ni, ts(t := INIT))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci; n = ni; ts t = INIT;\n     ni' = Suc ni mod (k * N); tsi' = ts(t := WAIT (ni mod N))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a aa b.\n                         blstep t (c, ni, ts) (a, aa, b) \\<and>\n                         sim_rel2 (a, aa, b)\n                          (ci, Suc ni mod (k * N), ts(t := WAIT (ni mod N)))", "apply (intro exI conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci; n = ni; ts t = INIT;\n     ni' = Suc ni mod (k * N); tsi' = ts(t := WAIT (ni mod N))\\<rbrakk>\n    \\<Longrightarrow> blstep t (c, ni, ts) (?a, ?a1, ?b2)\n 2. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci; n = ni; ts t = INIT;\n     ni' = Suc ni mod (k * N); tsi' = ts(t := WAIT (ni mod N))\\<rbrakk>\n    \\<Longrightarrow> sim_rel2 (?a, ?a1, ?b2)\n                       (ci, Suc ni mod (k * N), ts(t := WAIT (ni mod N)))", "apply (rule blstep.intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci; n = ni; ts t = INIT;\n     ni' = Suc ni mod (k * N); tsi' = ts(t := WAIT (ni mod N))\\<rbrakk>\n    \\<Longrightarrow> t < N\n 2. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci; n = ni; ts t = INIT;\n     ni' = Suc ni mod (k * N); tsi' = ts(t := WAIT (ni mod N))\\<rbrakk>\n    \\<Longrightarrow> bstep_sng (c, ni, ts t) (?a, ?a1, ?s'4)\n 3. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci; n = ni; ts t = INIT;\n     ni' = Suc ni mod (k * N); tsi' = ts(t := WAIT (ni mod N))\\<rbrakk>\n    \\<Longrightarrow> sim_rel2 (?a, ?a1, ts(t := ?s'4))\n                       (ci, Suc ni mod (k * N), ts(t := WAIT (ni mod N)))", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci; n = ni; ts t = INIT;\n     ni' = Suc ni mod (k * N); tsi' = ts(t := WAIT (ni mod N))\\<rbrakk>\n    \\<Longrightarrow> bstep_sng (c, ni, ts t) (?a, ?a1, ?s'4)\n 2. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci; n = ni; ts t = INIT;\n     ni' = Suc ni mod (k * N); tsi' = ts(t := WAIT (ni mod N))\\<rbrakk>\n    \\<Longrightarrow> sim_rel2 (?a, ?a1, ts(t := ?s'4))\n                       (ci, Suc ni mod (k * N), ts(t := WAIT (ni mod N)))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci; n = ni; ts t = INIT;\n     ni' = Suc ni mod (k * N); tsi' = ts(t := WAIT (ni mod N))\\<rbrakk>\n    \\<Longrightarrow> bstep_sng (c, ni, INIT) (?a, ?a1, ?s'4)\n 2. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci; n = ni; ts t = INIT;\n     ni' = Suc ni mod (k * N); tsi' = ts(t := WAIT (ni mod N))\\<rbrakk>\n    \\<Longrightarrow> sim_rel2 (?a, ?a1, ts(t := ?s'4))\n                       (ci, Suc ni mod (k * N), ts(t := WAIT (ni mod N)))", "apply (rule bstep_sng.enter_wait)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci; n = ni; ts t = INIT;\n     ni' = Suc ni mod (k * N); tsi' = ts(t := WAIT (ni mod N))\\<rbrakk>\n    \\<Longrightarrow> sim_rel2\n                       (c, (ni + 1) mod (k * N), ts(t := WAIT (ni mod N)))\n                       (ci, Suc ni mod (k * N), ts(t := WAIT (ni mod N)))", "apply (auto simp: sim_rel2_def split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>tk.\n       \\<lbrakk>if is_REL_state ts then ci = replicate N False\n                else ci = (replicate N False)[c := True];\n        tsi = ts; t < N; \\<not> ci ! tk; ci' = ci; n = ni; ts t = WAIT tk;\n        ni' = ni; tsi' = ts(t := WAIT tk)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            blstep t (c, ni, ts) (a, aa, b) \\<and>\n                            sim_rel2 (a, aa, b) (ci, ni, ts(t := WAIT tk))\n 2. \\<And>tk.\n       \\<lbrakk>if is_REL_state ts then ci = replicate N False\n                else ci = (replicate N False)[c := True];\n        tsi = ts; t < N; ci ! tk; ci' = ci; n = ni; ts t = WAIT tk;\n        ni' = ni; tsi' = ts(t := HOLD tk)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            blstep t (c, ni, ts) (a, aa, b) \\<and>\n                            sim_rel2 (a, aa, b) (ci, ni, ts(t := HOLD tk))\n 3. \\<And>tk.\n       \\<lbrakk>if is_REL_state ts then ci = replicate N False\n                else ci = (replicate N False)[c := True];\n        tsi = ts; t < N; ci' = ci[tk := False]; n = ni; ts t = HOLD tk;\n        ni' = ni; tsi' = ts(t := REL tk)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            blstep t (c, ni, ts) (a, aa, b) \\<and>\n                            sim_rel2 (a, aa, b)\n                             (ci[tk := False], ni, ts(t := REL tk))\n 4. \\<And>tk.\n       \\<lbrakk>if is_REL_state ts then ci = replicate N False\n                else ci = (replicate N False)[c := True];\n        tsi = ts; t < N; ci' = ci[Suc tk mod N := True]; n = ni;\n        ts t = REL tk; ni' = ni; tsi' = ts(t := INIT)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            blstep t (c, ni, ts) (a, aa, b) \\<and>\n                            sim_rel2 (a, aa, b)\n                             (ci[Suc tk mod N := True], ni, ts(t := INIT))", "subgoal for tk'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; \\<not> ci ! tk'; ci' = ci; n = ni; ts t = WAIT tk';\n     ni' = ni; tsi' = ts(t := WAIT tk')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a aa b.\n                         blstep t (c, ni, ts) (a, aa, b) \\<and>\n                         sim_rel2 (a, aa, b) (ci, ni, ts(t := WAIT tk'))", "apply (intro exI conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; \\<not> ci ! tk'; ci' = ci; n = ni; ts t = WAIT tk';\n     ni' = ni; tsi' = ts(t := WAIT tk')\\<rbrakk>\n    \\<Longrightarrow> blstep t (c, ni, ts) (?a, ?a1, ?b2)\n 2. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; \\<not> ci ! tk'; ci' = ci; n = ni; ts t = WAIT tk';\n     ni' = ni; tsi' = ts(t := WAIT tk')\\<rbrakk>\n    \\<Longrightarrow> sim_rel2 (?a, ?a1, ?b2) (ci, ni, ts(t := WAIT tk'))", "apply (rule blstep.intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; \\<not> ci ! tk'; ci' = ci; n = ni; ts t = WAIT tk';\n     ni' = ni; tsi' = ts(t := WAIT tk')\\<rbrakk>\n    \\<Longrightarrow> t < N\n 2. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; \\<not> ci ! tk'; ci' = ci; n = ni; ts t = WAIT tk';\n     ni' = ni; tsi' = ts(t := WAIT tk')\\<rbrakk>\n    \\<Longrightarrow> bstep_sng (c, ni, ts t) (?a, ?a1, ?s'4)\n 3. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; \\<not> ci ! tk'; ci' = ci; n = ni; ts t = WAIT tk';\n     ni' = ni; tsi' = ts(t := WAIT tk')\\<rbrakk>\n    \\<Longrightarrow> sim_rel2 (?a, ?a1, ts(t := ?s'4))\n                       (ci, ni, ts(t := WAIT tk'))", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; \\<not> ci ! tk'; ci' = ci; n = ni; ts t = WAIT tk';\n     ni' = ni; tsi' = ts(t := WAIT tk')\\<rbrakk>\n    \\<Longrightarrow> bstep_sng (c, ni, ts t) (?a, ?a1, ?s'4)\n 2. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; \\<not> ci ! tk'; ci' = ci; n = ni; ts t = WAIT tk';\n     ni' = ni; tsi' = ts(t := WAIT tk')\\<rbrakk>\n    \\<Longrightarrow> sim_rel2 (?a, ?a1, ts(t := ?s'4))\n                       (ci, ni, ts(t := WAIT tk'))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; \\<not> ci ! tk'; ci' = ci; n = ni; ts t = WAIT tk';\n     ni' = ni; tsi' = ts(t := WAIT tk')\\<rbrakk>\n    \\<Longrightarrow> bstep_sng (c, ni, WAIT tk') (?a, ?a1, ?s'4)\n 2. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; \\<not> ci ! tk'; ci' = ci; n = ni; ts t = WAIT tk';\n     ni' = ni; tsi' = ts(t := WAIT tk')\\<rbrakk>\n    \\<Longrightarrow> sim_rel2 (?a, ?a1, ts(t := ?s'4))\n                       (ci, ni, ts(t := WAIT tk'))", "apply (rule bstep_sng.loop_wait)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; \\<not> ci ! tk'; ci' = ci; n = ni; ts t = WAIT tk';\n     ni' = ni; tsi' = ts(t := WAIT tk')\\<rbrakk>\n    \\<Longrightarrow> c \\<noteq> tk'\n 2. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; \\<not> ci ! tk'; ci' = ci; n = ni; ts t = WAIT tk';\n     ni' = ni; tsi' = ts(t := WAIT tk')\\<rbrakk>\n    \\<Longrightarrow> sim_rel2 (c, ni, ts(t := WAIT tk'))\n                       (ci, ni, ts(t := WAIT tk'))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; \\<not> ci ! tk'; ci' = ci; n = ni; ts t = WAIT tk';\n     ni' = ni; tsi' = ts(t := WAIT tk')\\<rbrakk>\n    \\<Longrightarrow> c \\<noteq> tk'", "apply (clarsimp simp: sim_rel2_def split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tsi = ts; t < N; ci' = replicate N False; n = ni;\n     ts t = WAIT tk'; ni' = ni; tsi' = ts(t := WAIT tk'); is_REL_state ts;\n     ci = replicate N False; c = tk'\\<rbrakk>\n    \\<Longrightarrow> False", "apply (frule (2) is_REL_state_aux1[OF Rc])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tsi = ts; t < N; ci' = replicate N False; n = ni;\n     ts t = WAIT tk'; ni' = ni; tsi' = ts(t := WAIT tk'); is_REL_state ts;\n     ci = replicate N False; c = tk'; tk' \\<noteq> c\\<rbrakk>\n    \\<Longrightarrow> False", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; \\<not> ci ! tk'; ci' = ci; n = ni; ts t = WAIT tk';\n     ni' = ni; tsi' = ts(t := WAIT tk')\\<rbrakk>\n    \\<Longrightarrow> sim_rel2 (c, ni, ts(t := WAIT tk'))\n                       (ci, ni, ts(t := WAIT tk'))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; \\<not> ci ! tk'; ci' = ci; n = ni; ts t = WAIT tk';\n     ni' = ni; tsi' = ts(t := WAIT tk')\\<rbrakk>\n    \\<Longrightarrow> sim_rel2 (c, ni, ts(t := WAIT tk'))\n                       (ci, ni, ts(t := WAIT tk'))", "by (auto simp: sim_rel2_def split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>tk.\n       \\<lbrakk>if is_REL_state ts then ci = replicate N False\n                else ci = (replicate N False)[c := True];\n        tsi = ts; t < N; ci ! tk; ci' = ci; n = ni; ts t = WAIT tk;\n        ni' = ni; tsi' = ts(t := HOLD tk)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            blstep t (c, ni, ts) (a, aa, b) \\<and>\n                            sim_rel2 (a, aa, b) (ci, ni, ts(t := HOLD tk))\n 2. \\<And>tk.\n       \\<lbrakk>if is_REL_state ts then ci = replicate N False\n                else ci = (replicate N False)[c := True];\n        tsi = ts; t < N; ci' = ci[tk := False]; n = ni; ts t = HOLD tk;\n        ni' = ni; tsi' = ts(t := REL tk)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            blstep t (c, ni, ts) (a, aa, b) \\<and>\n                            sim_rel2 (a, aa, b)\n                             (ci[tk := False], ni, ts(t := REL tk))\n 3. \\<And>tk.\n       \\<lbrakk>if is_REL_state ts then ci = replicate N False\n                else ci = (replicate N False)[c := True];\n        tsi = ts; t < N; ci' = ci[Suc tk mod N := True]; n = ni;\n        ts t = REL tk; ni' = ni; tsi' = ts(t := INIT)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            blstep t (c, ni, ts) (a, aa, b) \\<and>\n                            sim_rel2 (a, aa, b)\n                             (ci[Suc tk mod N := True], ni, ts(t := INIT))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci ! tk_; ci' = ci; n = ni; ts t = WAIT tk_; ni' = ni;\n     tsi' = ts(t := HOLD tk_)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a aa b.\n                         blstep t (c, ni, ts) (a, aa, b) \\<and>\n                         sim_rel2 (a, aa, b) (ci, ni, ts(t := HOLD tk_))", "apply (intro exI conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci ! tk_; ci' = ci; n = ni; ts t = WAIT tk_; ni' = ni;\n     tsi' = ts(t := HOLD tk_)\\<rbrakk>\n    \\<Longrightarrow> blstep t (c, ni, ts) (?a, ?a1, ?b2)\n 2. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci ! tk_; ci' = ci; n = ni; ts t = WAIT tk_; ni' = ni;\n     tsi' = ts(t := HOLD tk_)\\<rbrakk>\n    \\<Longrightarrow> sim_rel2 (?a, ?a1, ?b2) (ci, ni, ts(t := HOLD tk_))", "apply (rule blstep.intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci ! tk_; ci' = ci; n = ni; ts t = WAIT tk_; ni' = ni;\n     tsi' = ts(t := HOLD tk_)\\<rbrakk>\n    \\<Longrightarrow> t < N\n 2. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci ! tk_; ci' = ci; n = ni; ts t = WAIT tk_; ni' = ni;\n     tsi' = ts(t := HOLD tk_)\\<rbrakk>\n    \\<Longrightarrow> bstep_sng (c, ni, ts t) (?a, ?a1, ?s'4)\n 3. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci ! tk_; ci' = ci; n = ni; ts t = WAIT tk_; ni' = ni;\n     tsi' = ts(t := HOLD tk_)\\<rbrakk>\n    \\<Longrightarrow> sim_rel2 (?a, ?a1, ts(t := ?s'4))\n                       (ci, ni, ts(t := HOLD tk_))", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci ! tk_; ci' = ci; n = ni; ts t = WAIT tk_; ni' = ni;\n     tsi' = ts(t := HOLD tk_)\\<rbrakk>\n    \\<Longrightarrow> bstep_sng (c, ni, ts t) (?a, ?a1, ?s'4)\n 2. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci ! tk_; ci' = ci; n = ni; ts t = WAIT tk_; ni' = ni;\n     tsi' = ts(t := HOLD tk_)\\<rbrakk>\n    \\<Longrightarrow> sim_rel2 (?a, ?a1, ts(t := ?s'4))\n                       (ci, ni, ts(t := HOLD tk_))", "apply (clarsimp split: if_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>tsi = ts; t < N; tk_ = c; ci' = (replicate N False)[c := True];\n     n = ni; ts t = WAIT c; ni' = ni; tsi' = ts(t := HOLD c);\n     \\<not> is_REL_state ts; ci = (replicate N False)[c := True]\\<rbrakk>\n    \\<Longrightarrow> bstep_sng (c, ni, WAIT c) (?a, ?a1, ?s'4)\n 2. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci ! tk_; ci' = ci; n = ni; ts t = WAIT tk_; ni' = ni;\n     tsi' = ts(t := HOLD tk_)\\<rbrakk>\n    \\<Longrightarrow> sim_rel2 (?a, ?a1, ts(t := ?s'4))\n                       (ci, ni, ts(t := HOLD tk_))", "apply (rule bstep_sng.exit_wait)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci ! tk_; ci' = ci; n = ni; ts t = WAIT tk_; ni' = ni;\n     tsi' = ts(t := HOLD tk_)\\<rbrakk>\n    \\<Longrightarrow> sim_rel2 (c, ni, ts(t := HOLD c))\n                       (ci, ni, ts(t := HOLD tk_))", "apply (auto simp: sim_rel2_def split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>tk.\n       \\<lbrakk>if is_REL_state ts then ci = replicate N False\n                else ci = (replicate N False)[c := True];\n        tsi = ts; t < N; ci' = ci[tk := False]; n = ni; ts t = HOLD tk;\n        ni' = ni; tsi' = ts(t := REL tk)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            blstep t (c, ni, ts) (a, aa, b) \\<and>\n                            sim_rel2 (a, aa, b)\n                             (ci[tk := False], ni, ts(t := REL tk))\n 2. \\<And>tk.\n       \\<lbrakk>if is_REL_state ts then ci = replicate N False\n                else ci = (replicate N False)[c := True];\n        tsi = ts; t < N; ci' = ci[Suc tk mod N := True]; n = ni;\n        ts t = REL tk; ni' = ni; tsi' = ts(t := INIT)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            blstep t (c, ni, ts) (a, aa, b) \\<and>\n                            sim_rel2 (a, aa, b)\n                             (ci[Suc tk mod N := True], ni, ts(t := INIT))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci[tk_ := False]; n = ni; ts t = HOLD tk_;\n     ni' = ni; tsi' = ts(t := REL tk_)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a aa b.\n                         blstep t (c, ni, ts) (a, aa, b) \\<and>\n                         sim_rel2 (a, aa, b)\n                          (ci[tk_ := False], ni, ts(t := REL tk_))", "apply (intro exI conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci[tk_ := False]; n = ni; ts t = HOLD tk_;\n     ni' = ni; tsi' = ts(t := REL tk_)\\<rbrakk>\n    \\<Longrightarrow> blstep t (c, ni, ts) (?a, ?a1, ?b2)\n 2. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci[tk_ := False]; n = ni; ts t = HOLD tk_;\n     ni' = ni; tsi' = ts(t := REL tk_)\\<rbrakk>\n    \\<Longrightarrow> sim_rel2 (?a, ?a1, ?b2)\n                       (ci[tk_ := False], ni, ts(t := REL tk_))", "apply (rule blstep.intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci[tk_ := False]; n = ni; ts t = HOLD tk_;\n     ni' = ni; tsi' = ts(t := REL tk_)\\<rbrakk>\n    \\<Longrightarrow> t < N\n 2. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci[tk_ := False]; n = ni; ts t = HOLD tk_;\n     ni' = ni; tsi' = ts(t := REL tk_)\\<rbrakk>\n    \\<Longrightarrow> bstep_sng (c, ni, ts t) (?a, ?a1, ?s'4)\n 3. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci[tk_ := False]; n = ni; ts t = HOLD tk_;\n     ni' = ni; tsi' = ts(t := REL tk_)\\<rbrakk>\n    \\<Longrightarrow> sim_rel2 (?a, ?a1, ts(t := ?s'4))\n                       (ci[tk_ := False], ni, ts(t := REL tk_))", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci[tk_ := False]; n = ni; ts t = HOLD tk_;\n     ni' = ni; tsi' = ts(t := REL tk_)\\<rbrakk>\n    \\<Longrightarrow> bstep_sng (c, ni, ts t) (?a, ?a1, ?s'4)\n 2. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci[tk_ := False]; n = ni; ts t = HOLD tk_;\n     ni' = ni; tsi' = ts(t := REL tk_)\\<rbrakk>\n    \\<Longrightarrow> sim_rel2 (?a, ?a1, ts(t := ?s'4))\n                       (ci[tk_ := False], ni, ts(t := REL tk_))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci[tk_ := False]; n = ni; ts t = HOLD tk_;\n     ni' = ni; tsi' = ts(t := REL tk_)\\<rbrakk>\n    \\<Longrightarrow> bstep_sng (c, ni, HOLD tk_) (?a, ?a1, ?s'4)\n 2. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci[tk_ := False]; n = ni; ts t = HOLD tk_;\n     ni' = ni; tsi' = ts(t := REL tk_)\\<rbrakk>\n    \\<Longrightarrow> sim_rel2 (?a, ?a1, ts(t := ?s'4))\n                       (ci[tk_ := False], ni, ts(t := REL tk_))", "apply (rule bstep_sng.start_release)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci[tk_ := False]; n = ni; ts t = HOLD tk_;\n     ni' = ni; tsi' = ts(t := REL tk_)\\<rbrakk>\n    \\<Longrightarrow> sim_rel2 (c, ni, ts(t := REL tk_))\n                       (ci[tk_ := False], ni, ts(t := REL tk_))", "apply (auto simp: sim_rel2_def dest: HOLD_AUX split: if_splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>tk.\n       \\<lbrakk>if is_REL_state ts then ci = replicate N False\n                else ci = (replicate N False)[c := True];\n        tsi = ts; t < N; ci' = ci[Suc tk mod N := True]; n = ni;\n        ts t = REL tk; ni' = ni; tsi' = ts(t := INIT)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            blstep t (c, ni, ts) (a, aa, b) \\<and>\n                            sim_rel2 (a, aa, b)\n                             (ci[Suc tk mod N := True], ni, ts(t := INIT))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci[Suc tk_ mod N := True]; n = ni;\n     ts t = REL tk_; ni' = ni; tsi' = ts(t := INIT)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a aa b.\n                         blstep t (c, ni, ts) (a, aa, b) \\<and>\n                         sim_rel2 (a, aa, b)\n                          (ci[Suc tk_ mod N := True], ni, ts(t := INIT))", "apply (intro exI conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci[Suc tk_ mod N := True]; n = ni;\n     ts t = REL tk_; ni' = ni; tsi' = ts(t := INIT)\\<rbrakk>\n    \\<Longrightarrow> blstep t (c, ni, ts) (?a, ?a1, ?b2)\n 2. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci[Suc tk_ mod N := True]; n = ni;\n     ts t = REL tk_; ni' = ni; tsi' = ts(t := INIT)\\<rbrakk>\n    \\<Longrightarrow> sim_rel2 (?a, ?a1, ?b2)\n                       (ci[Suc tk_ mod N := True], ni, ts(t := INIT))", "apply (rule blstep.intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci[Suc tk_ mod N := True]; n = ni;\n     ts t = REL tk_; ni' = ni; tsi' = ts(t := INIT)\\<rbrakk>\n    \\<Longrightarrow> t < N\n 2. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci[Suc tk_ mod N := True]; n = ni;\n     ts t = REL tk_; ni' = ni; tsi' = ts(t := INIT)\\<rbrakk>\n    \\<Longrightarrow> bstep_sng (c, ni, ts t) (?a, ?a1, ?s'4)\n 3. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci[Suc tk_ mod N := True]; n = ni;\n     ts t = REL tk_; ni' = ni; tsi' = ts(t := INIT)\\<rbrakk>\n    \\<Longrightarrow> sim_rel2 (?a, ?a1, ts(t := ?s'4))\n                       (ci[Suc tk_ mod N := True], ni, ts(t := INIT))", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci[Suc tk_ mod N := True]; n = ni;\n     ts t = REL tk_; ni' = ni; tsi' = ts(t := INIT)\\<rbrakk>\n    \\<Longrightarrow> bstep_sng (c, ni, ts t) (?a, ?a1, ?s'4)\n 2. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci[Suc tk_ mod N := True]; n = ni;\n     ts t = REL tk_; ni' = ni; tsi' = ts(t := INIT)\\<rbrakk>\n    \\<Longrightarrow> sim_rel2 (?a, ?a1, ts(t := ?s'4))\n                       (ci[Suc tk_ mod N := True], ni, ts(t := INIT))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci[Suc tk_ mod N := True]; n = ni;\n     ts t = REL tk_; ni' = ni; tsi' = ts(t := INIT)\\<rbrakk>\n    \\<Longrightarrow> bstep_sng (c, ni, REL tk_) (?a, ?a1, ?s'4)\n 2. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci[Suc tk_ mod N := True]; n = ni;\n     ts t = REL tk_; ni' = ni; tsi' = ts(t := INIT)\\<rbrakk>\n    \\<Longrightarrow> sim_rel2 (?a, ?a1, ts(t := ?s'4))\n                       (ci[Suc tk_ mod N := True], ni, ts(t := INIT))", "apply (rule bstep_sng.release)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>if is_REL_state ts then ci = replicate N False\n             else ci = (replicate N False)[c := True];\n     tsi = ts; t < N; ci' = ci[Suc tk_ mod N := True]; n = ni;\n     ts t = REL tk_; ni' = ni; tsi' = ts(t := INIT)\\<rbrakk>\n    \\<Longrightarrow> sim_rel2 ((tk_ + 1) mod N, ni, ts(t := INIT))\n                       (ci[Suc tk_ mod N := True], ni, ts(t := INIT))", "apply (auto \n          simp: sim_rel2_def \n          dest: is_REL_state_aux2[OF Rc] \n          split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tsi = ts; t < N;\n     ci' = (replicate N False)[c := True, Suc tk_ mod N := True]; n = ni;\n     ts t = REL tk_; ni' = ni; tsi' = ts(t := INIT); \\<not> is_REL_state ts;\n     ci = (replicate N False)[c := True];\n     \\<not> is_REL_state (ts(t := INIT))\\<rbrakk>\n    \\<Longrightarrow> (replicate N False)\n                      [c := True, Suc tk_ mod N := True] =\n                      (replicate N False)[Suc tk_ mod N := True]", "by (metis fun_upd_triv is_REL_state_simps(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>bs'. blstep t bs bs' \\<and> sim_rel2 bs' cs'\n\ngoal (2 subgoals):\n 1. \\<And>as cs l cs'.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        clstep l cs cs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            sim_rel2 as' cs' \\<and> blstep l as as'\n 2. \\<And>as cs l.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        B.can_step l as\\<rbrakk>\n       \\<Longrightarrow> C.can_step l cs", "then"], ["proof (chain)\npicking this:\n  \\<exists>bs'. blstep t bs bs' \\<and> sim_rel2 bs' cs'", "show \"\\<exists>bs'. sim_rel2 bs' cs' \\<and> blstep t bs bs'\""], ["proof (prove)\nusing this:\n  \\<exists>bs'. blstep t bs bs' \\<and> sim_rel2 bs' cs'\n\ngoal (1 subgoal):\n 1. \\<exists>bs'. sim_rel2 bs' cs' \\<and> blstep t bs bs'", "by blast"], ["proof (state)\nthis:\n  \\<exists>bs'. sim_rel2 bs' cs' \\<and> blstep t bs bs'\n\ngoal (1 subgoal):\n 1. \\<And>as cs l.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        B.can_step l as\\<rbrakk>\n       \\<Longrightarrow> C.can_step l cs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>as cs l.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        B.can_step l as\\<rbrakk>\n       \\<Longrightarrow> C.can_step l cs", "fix bs cs l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>as cs l.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        B.can_step l as\\<rbrakk>\n       \\<Longrightarrow> C.can_step l cs", "assume \"B.reachable bs\" \"C.reachable cs\" \"sim_rel2 bs cs\" \"B.can_step l bs\""], ["proof (state)\nthis:\n  B.reachable bs\n  C.reachable cs\n  sim_rel2 bs cs\n  B.can_step l bs\n\ngoal (1 subgoal):\n 1. \\<And>as cs l.\n       \\<lbrakk>B.reachable as; C.reachable cs; sim_rel2 as cs;\n        B.can_step l as\\<rbrakk>\n       \\<Longrightarrow> C.can_step l cs", "then"], ["proof (chain)\npicking this:\n  B.reachable bs\n  C.reachable cs\n  sim_rel2 bs cs\n  B.can_step l bs", "show \"C.can_step l cs\""], ["proof (prove)\nusing this:\n  B.reachable bs\n  C.reachable cs\n  sim_rel2 bs cs\n  B.can_step l bs\n\ngoal (1 subgoal):\n 1. C.can_step l cs", "using c_never_blocked b_never_blocked"], ["proof (prove)\nusing this:\n  B.reachable bs\n  C.reachable cs\n  sim_rel2 bs cs\n  B.can_step l bs\n  C.can_step ?l ?s = (?l < N)\n  B.can_step ?l ?s = (?l < N)\n\ngoal (1 subgoal):\n 1. C.can_step l cs", "by simp"], ["proof (state)\nthis:\n  C.can_step l cs\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Transfer Setup\\<close>"], ["", "text \\<open>We set up the final simulation relation, and the transfer of the \n    concepts used in the correctness statements. \\<close>"], ["", "definition \"sim_rel \\<equiv> sim_rel1 OO sim_rel2\""], ["", "interpretation sim: simulation as\\<^sub>0 alstep cs\\<^sub>0 clstep sim_rel"], ["proof (prove)\ngoal (1 subgoal):\n 1. simulation as\\<^sub>0 alstep cs\\<^sub>0 clstep sim_rel", "unfolding sim_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. simulation as\\<^sub>0 alstep cs\\<^sub>0 clstep (sim_rel1 OO sim_rel2)", "by (rule sim_trans) unfold_locales"], ["", "lemma xfer_holds:\n    assumes \"sim_rel s cs\"\n    shows \"is_HOLD (tts cs t) \\<longleftrightarrow> is_HOLD (tts s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_HOLD (tts cs t) = is_HOLD (tts s t)", "using assms"], ["proof (prove)\nusing this:\n  sim_rel s cs\n\ngoal (1 subgoal):\n 1. is_HOLD (tts cs t) = is_HOLD (tts s t)", "unfolding sim_rel_def sim_rel1_def sim_rel2_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>(c, n, ts) (ci, ni, tsi).\n       ci = c mod N \\<and>\n       ni = n mod (k * N) \\<and>\n       tsi = map_ticket (\\<lambda>t. t mod N) \\<circ> ts) OO\n   (\\<lambda>(c, n, ts) (ci, ni, tsi).\n       (if is_REL_state ts then ci = replicate N False\n        else ci = (replicate N False)[c := True]) \\<and>\n       ni = n \\<and> tsi = ts))\n   s cs\n\ngoal (1 subgoal):\n 1. is_HOLD (tts cs t) = is_HOLD (tts s t)", "by (cases \"tts cs t\") auto"], ["", "lemma xfer_waits:\n    assumes \"sim_rel s cs\"\n    shows \"is_WAIT (tts cs t) \\<longleftrightarrow> is_WAIT (tts s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_WAIT (tts cs t) = is_WAIT (tts s t)", "using assms"], ["proof (prove)\nusing this:\n  sim_rel s cs\n\ngoal (1 subgoal):\n 1. is_WAIT (tts cs t) = is_WAIT (tts s t)", "unfolding sim_rel_def sim_rel1_def sim_rel2_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>(c, n, ts) (ci, ni, tsi).\n       ci = c mod N \\<and>\n       ni = n mod (k * N) \\<and>\n       tsi = map_ticket (\\<lambda>t. t mod N) \\<circ> ts) OO\n   (\\<lambda>(c, n, ts) (ci, ni, tsi).\n       (if is_REL_state ts then ci = replicate N False\n        else ci = (replicate N False)[c := True]) \\<and>\n       ni = n \\<and> tsi = ts))\n   s cs\n\ngoal (1 subgoal):\n 1. is_WAIT (tts cs t) = is_WAIT (tts s t)", "by (cases \"tts cs t\") auto"], ["", "lemma xfer_init:\n    assumes \"sim_rel s cs\"  \n    shows \"tts cs t = INIT \\<longleftrightarrow> tts s t = INIT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (tts cs t = INIT) = (tts s t = INIT)", "using assms"], ["proof (prove)\nusing this:\n  sim_rel s cs\n\ngoal (1 subgoal):\n 1. (tts cs t = INIT) = (tts s t = INIT)", "unfolding sim_rel_def sim_rel1_def sim_rel2_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>(c, n, ts) (ci, ni, tsi).\n       ci = c mod N \\<and>\n       ni = n mod (k * N) \\<and>\n       tsi = map_ticket (\\<lambda>t. t mod N) \\<circ> ts) OO\n   (\\<lambda>(c, n, ts) (ci, ni, tsi).\n       (if is_REL_state ts then ci = replicate N False\n        else ci = (replicate N False)[c := True]) \\<and>\n       ni = n \\<and> tsi = ts))\n   s cs\n\ngoal (1 subgoal):\n 1. (tts cs t = INIT) = (tts s t = INIT)", "by auto"], ["", "subsection \\<open>Main Theorems\\<close>"], ["", "text_raw \\<open>\\label{sec:main_theorems}\\<close>"], ["", "subsubsection \\<open>Trusted Code Base\\<close>"], ["", "text \\<open>  \n    Note that the trusted code base for these theorems is only the \n    formalization of the concrete system as defined in Section~\\ref{sec:refine3}. \n    The simulation setup and the \n    abstract systems are only auxiliary constructions for the proof.\n    \n    For completeness, we display the relevant definitions of\n    reachability, runs, and fairness here:\n    \n    @{lemma [display, source] \"C.step s s' = (\\<exists>l. clstep l s s')\" by simp}\n    @{thm [display] C.reachable_def[no_vars] C.run_definitions[no_vars]}\n  \\<close>"], ["", "subsubsection \\<open>Safety\\<close>"], ["", "text \\<open>We show that there is no reachable state in which two different \n    threads hold the lock.\\<close>"], ["", "(* ALWAYS (NOT (HOLD ** HOLD)) *)"], ["", "theorem final_mutual_exclusion: \"\\<lbrakk>C.reachable s; \n      t<N; t'<N; t\\<noteq>t'; is_HOLD (tts s t); is_HOLD (tts s t')\n    \\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C.reachable s; t < N; t' < N; t \\<noteq> t'; is_HOLD (tts s t);\n     is_HOLD (tts s t')\\<rbrakk>\n    \\<Longrightarrow> False", "apply (erule sim.xfer_reachable)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as.\n       \\<lbrakk>t < N; t' < N; t \\<noteq> t'; is_HOLD (tts s t);\n        is_HOLD (tts s t'); sim_rel as s; A.reachable as\\<rbrakk>\n       \\<Longrightarrow> False", "apply (simp add: xfer_holds)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as.\n       \\<lbrakk>t < N; t' < N; t \\<noteq> t'; is_HOLD (tts as t);\n        is_HOLD (tts as t'); sim_rel as s; A.reachable as\\<rbrakk>\n       \\<Longrightarrow> False", "by (erule (5) mutual_exclusion)"], ["", "subsubsection \\<open>Fairness\\<close>"], ["", "text \\<open>We show that, whenever a thread \\<open>t\\<close> draws a ticket, all other \n    threads \\<open>t'\\<close> waiting for the lock will be granted the lock before \\<open>t\\<close>. \\<close>"], ["", "(* ALWAYS (INIT t\\<^sub>1 \\<and> WAIT t\\<^sub>2 \\<and> X (WAIT t\\<^sub>1) \\<longrightarrow> HOLD t\\<^sub>2 BEFORE HOLD t\\<^sub>1 ) *)"], ["", "theorem final_fair:\n    assumes RUN: \"C.is_run s\"\n    assumes ACQ: \"t<N\" and \"tts (s i) t=INIT\" and \"is_WAIT (tts (s (Suc i)) t)\" \n      \\<comment> \\<open>Thread \\<open>t\\<close> draws ticket in step \\<open>i\\<close>\\<close>\n    assumes HOLD: \"i<j\" and \"is_HOLD (tts (s j) t)\" \n      \\<comment> \\<open>Thread \\<open>t\\<close> holds lock in step \\<open>j\\<close>\\<close>\n    assumes WAIT: \"t'<N\" and \"is_WAIT (tts (s i) t')\" \n      \\<comment> \\<open>Thread \\<open>t'\\<close> waits for lock at step \\<open>i\\<close>\\<close>\n    obtains l where \"i<l\" and \"l<j\" and \"is_HOLD (tts (s l) t')\" \n      \\<comment> \\<open>Then, \\<open>t'\\<close> gets lock earlier\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>i < l; l < j; is_HOLD (tts (s l) t')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using RUN"], ["proof (prove)\nusing this:\n  C.is_run s\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>i < l; l < j; is_HOLD (tts (s l) t')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (rule sim.xfer_run)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>as.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>i < l; l < j; is_HOLD (tts (s l) t')\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        A.is_run as; \\<forall>i. sim_rel (as i) (s i)\\<rbrakk>\n       \\<Longrightarrow> thesis", "fix as"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>as.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>i < l; l < j; is_HOLD (tts (s l) t')\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        A.is_run as; \\<forall>i. sim_rel (as i) (s i)\\<rbrakk>\n       \\<Longrightarrow> thesis", "assume Ra: \"A.is_run as\" and SIM[rule_format]: \"\\<forall>i. sim_rel (as i) (s i)\""], ["proof (state)\nthis:\n  A.is_run as\n  sim_rel (as ?i) (s ?i)\n\ngoal (1 subgoal):\n 1. \\<And>as.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>i < l; l < j; is_HOLD (tts (s l) t')\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        A.is_run as; \\<forall>i. sim_rel (as i) (s i)\\<rbrakk>\n       \\<Longrightarrow> thesis", "note XFER = xfer_init[OF SIM] xfer_holds[OF SIM] xfer_waits[OF SIM]"], ["proof (state)\nthis:\n  (tts (s ?i1) ?t = INIT) = (tts (as ?i1) ?t = INIT)\n  is_HOLD (tts (s ?i1) ?t) = is_HOLD (tts (as ?i1) ?t)\n  is_WAIT (tts (s ?i1) ?t) = is_WAIT (tts (as ?i1) ?t)\n\ngoal (1 subgoal):\n 1. \\<And>as.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>i < l; l < j; is_HOLD (tts (s l) t')\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        A.is_run as; \\<forall>i. sim_rel (as i) (s i)\\<rbrakk>\n       \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using assms"], ["proof (prove)\nusing this:\n  C.is_run s\n  t < N\n  tts (s i) t = INIT\n  is_WAIT (tts (s (Suc i)) t)\n  i < j\n  is_HOLD (tts (s j) t)\n  t' < N\n  is_WAIT (tts (s i) t')\n\ngoal (1 subgoal):\n 1. thesis", "apply (simp add: XFER)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C.is_run s; t < N; tts (as i) t = INIT;\n     is_WAIT (tts (as (Suc i)) t); i < j; is_HOLD (tts (as j) t); t' < N;\n     is_WAIT (tts (as i) t')\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (erule (6) fair[OF Ra])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>C.is_run s; tts (as i) t = INIT;\n        is_WAIT (tts (as (Suc i)) t); i < j; is_HOLD (tts (as j) t); t' < N;\n        is_WAIT (tts (as i) t'); i < l; l < j;\n        is_HOLD (tts (as l) t')\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (erule (1) that)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>C.is_run s; tts (as i) t = INIT;\n        is_WAIT (tts (as (Suc i)) t); i < j; is_HOLD (tts (as j) t); t' < N;\n        is_WAIT (tts (as i) t'); l < j; is_HOLD (tts (as l) t')\\<rbrakk>\n       \\<Longrightarrow> is_HOLD (tts (s l) t')", "apply (simp add: XFER)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Liveness\\<close>"], ["", "text \\<open>We show that, for a fair run, every thread that waits for the lock \n    will eventually hold the lock.\\<close>"], ["", "(* ALWAYS (WAIT  \\<longrightarrow> EVENTUALLY HOLD) *)"], ["", "theorem final_progress:\n    assumes FRUN: \"C.is_fair_run s\"\n    assumes WAIT: \"t<N\" and \"is_WAIT (tts (s i) t)\"\n    shows \"\\<exists>j>i. is_HOLD (tts (s j) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j>i. is_HOLD (tts (s j) t)", "using FRUN"], ["proof (prove)\nusing this:\n  C.is_fair_run s\n\ngoal (1 subgoal):\n 1. \\<exists>j>i. is_HOLD (tts (s j) t)", "proof (rule sim.xfer_fair_run)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>as.\n       \\<lbrakk>A.is_fair_run as; \\<forall>i. sim_rel (as i) (s i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)", "fix as"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>as.\n       \\<lbrakk>A.is_fair_run as; \\<forall>i. sim_rel (as i) (s i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)", "assume Ra: \"A.is_fair_run as\" \n       and SIM[rule_format]: \"\\<forall>i. sim_rel (as i) (s i)\""], ["proof (state)\nthis:\n  A.is_fair_run as\n  sim_rel (as ?i) (s ?i)\n\ngoal (1 subgoal):\n 1. \\<And>as.\n       \\<lbrakk>A.is_fair_run as; \\<forall>i. sim_rel (as i) (s i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)", "note XFER = xfer_init[OF SIM] xfer_holds[OF SIM] xfer_waits[OF SIM]"], ["proof (state)\nthis:\n  (tts (s ?i1) ?t = INIT) = (tts (as ?i1) ?t = INIT)\n  is_HOLD (tts (s ?i1) ?t) = is_HOLD (tts (as ?i1) ?t)\n  is_WAIT (tts (s ?i1) ?t) = is_WAIT (tts (as ?i1) ?t)\n\ngoal (1 subgoal):\n 1. \\<And>as.\n       \\<lbrakk>A.is_fair_run as; \\<forall>i. sim_rel (as i) (s i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (s j) t)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j>i. is_HOLD (tts (s j) t)", "using assms"], ["proof (prove)\nusing this:\n  C.is_fair_run s\n  t < N\n  is_WAIT (tts (s i) t)\n\ngoal (1 subgoal):\n 1. \\<exists>j>i. is_HOLD (tts (s j) t)", "apply (simp add: XFER)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C.is_fair_run s; t < N; is_WAIT (tts (as i) t)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>j>i. is_HOLD (tts (as j) t)", "apply (erule (1) progress[OF Ra])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>j>i. is_HOLD (tts (s j) t)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}