{"file_name": "/home/qj213/afp-2021-10-22/thys/VerifyThis2018/lib/Array_Map_Default.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/VerifyThis2018", "problem_names": ["lemma is_unused_elem_pure[simp]: \n    \"is_unused_elem dflt (pure R) \\<longleftrightarrow> dflt \\<notin> Domain R\"", "lemma amd1_empty_refine: \n    \"(uncurry0 (\\<lambda>_. dflt), uncurry0 op_map_empty) \n    \\<in> Id \\<rightarrow>\\<^sub>f (Id \\<rightarrow> dflt_option_rel_aux dflt)\"", "lemma amd1_lookup_refine: \n    \"(\\<lambda>x f. f x, op_map_lookup) \n    \\<in> Id \\<rightarrow> (Id \\<rightarrow> dflt_option_rel_aux dflt) \\<rightarrow> dflt_option_rel_aux dflt\"", "lemma amd1_update_refine: \n    \"(uncurry2 (\\<lambda>k v f. f(k:=v)), uncurry2 op_map_update) \n    \\<in> [\\<lambda>((k,v),m). v\\<noteq>dflt]\\<^sub>f \n      ((Id \\<times>\\<^sub>r Id) \\<times>\\<^sub>r (Id \\<rightarrow> dflt_option_rel_aux dflt)) \n      \\<rightarrow> (Id \\<rightarrow> dflt_option_rel_aux dflt)\"", "lemma amd1_delete_refine: \n    \"(uncurry (amd1_delete dflt), uncurry op_map_delete) \n    \\<in> Id \\<times>\\<^sub>r (Id \\<rightarrow> dflt_option_rel_aux dflt) \\<rightarrow>\\<^sub>f (Id \\<rightarrow> dflt_option_rel_aux dflt)\"", "lemma amd_assn_fold2: \"hr_comp (hr_comp \n      (is_nff dflt) \n      (nat_rel \\<rightarrow> dflt_option_rel_aux dflt)) \n      (\\<langle>the_pure K, the_pure V\\<rangle>map_rel) \n    = amd_assn dflt K V\"", "lemmas [intf_of_assn] \n    = intf_of_assnI[where R=\"amd_assn dflt K V\" \n                      and 'a=\"(nat,'vv) i_map\" for dflt K V]", "lemmas [safe_constraint_rules] \n    = CN_FALSEI[of is_pure \"amd_assn dflt K V\" for dflt K V]", "lemma amd2_empty_refine: \n    \"(uncurry0 (amd_empty dflt), uncurry0 (RETURN (\\<lambda>_. dflt))) \n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_nff dflt\"", "lemma amd2_lookup_refine: \n    \"(uncurry (amd_lookup dflt), uncurry (RETURN oo (\\<lambda>x f. f x))) \n    \\<in> id_assn\\<^sup>k*\\<^sub>a(is_nff dflt)\\<^sup>k \\<rightarrow>\\<^sub>a id_assn\"", "lemma amd2_update_refine: \n    \"(uncurry2 (amd_update dflt), uncurry2 (RETURN ooo (\\<lambda>k v f. f(k:=v)))) \n    \\<in> id_assn\\<^sup>k*\\<^sub>aid_assn\\<^sup>k*\\<^sub>a(is_nff dflt)\\<^sup>d \\<rightarrow>\\<^sub>a is_nff dflt\"", "lemma amd2_delete_refine: \n    \"(uncurry (amd_delete dflt), uncurry (RETURN oo (amd1_delete dflt))) \n    \\<in> id_assn\\<^sup>k*\\<^sub>a(is_nff dflt)\\<^sup>d \\<rightarrow>\\<^sub>a is_nff dflt\"", "lemma amd2_update_hnr_aux:\n    assumes \"CONSTRAINT (IS_PURE single_valued) K\"\n      and \"CONSTRAINT (IS_PURE IS_LEFT_UNIQUE) K\"\n      and \"CONSTRAINT is_pure V\"\n      and \"CONSTRAINT (is_unused_elem dflt) V\"\n    shows \"(uncurry2 (amd_update dflt), uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_map_update))\n           \\<in>  K\\<^sup>k *\\<^sub>a V\\<^sup>k *\\<^sub>a (amd_assn dflt K V)\\<^sup>d \\<rightarrow>\\<^sub>a amd_assn dflt K V\"", "lemma op_map_update_id_param: \n    \"(uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_map_update), uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_map_update)) \n    \\<in> (Id\\<times>\\<^sub>rId)\\<times>\\<^sub>rId \\<rightarrow>\\<^sub>f \\<langle>Id\\<rangle>nres_rel\"", "lemmas [sepref_fr_rules] = amd_empty_hnr[folded op_amd_empty_def]", "lemma doa_None_hnr: \n  \"(uncurry0 (return dflt), uncurry0 (RETURN dflt_None)) \n  \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a dflt_option_assn dflt A\"", "lemma doa_Some_hnr: \"\\<lbrakk>CONSTRAINT (is_unused_elem dflt) A; CONSTRAINT is_pure A\\<rbrakk> \n  \\<Longrightarrow> (return o (\\<lambda>x. x), RETURN o dflt_Some) \\<in> A\\<^sup>k \\<rightarrow>\\<^sub>a dflt_option_assn dflt A\"", "lemma doa_is_None_hnr[sepref_fr_rules]: \n  \"(return o ((=) dflt), RETURN o is_None) \n  \\<in> (dflt_option_assn dflt A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\"", "lemma doa_the_hnr[sepref_fr_rules]: \"\\<lbrakk>CONSTRAINT is_pure A\\<rbrakk> \n  \\<Longrightarrow> (return o (\\<lambda>x. x), RETURN o the) \n      \\<in> [\\<lambda>x. x\\<noteq>None]\\<^sub>a (dflt_option_assn dflt A)\\<^sup>k \\<rightarrow> A\"", "lemma cnv_option_case_2_if: \"(case x of None \\<Rightarrow> fn | Some v \\<Rightarrow> fv v) \n  \\<longleftrightarrow> (if is_None x then fn else fv (the x))\"", "lemma fold_dflt_option[def_pat_rules]: \n    \"(None::'a option) \\<equiv> dflt_None\"\n    \"(Some::'a\\<Rightarrow>_) \\<equiv> dflt_Some\"\n    \"((=)::'a option \\<Rightarrow> _) \\<equiv> dflt_option_eq\"", "lemmas [sepref_fr_rules] = \n    doa_None_hnr[where dflt = dflt and A=A]\n    doa_Some_hnr[where dflt = dflt and A=A]", "lemma eq_option_refine[sepref_fr_rules]:\n    assumes \"CONSTRAINT is_pure A\"\n    shows \"(uncurry eq,uncurry (RETURN oo dflt_option_eq)) \n      \\<in> (dflt_option_assn dflt A)\\<^sup>k *\\<^sub>a (dflt_option_assn dflt A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], "translations": [["", "lemma is_unused_elem_pure[simp]: \n    \"is_unused_elem dflt (pure R) \\<longleftrightarrow> dflt \\<notin> Domain R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unused_elem dflt (pure R) = (dflt \\<notin> Domain R)", "unfolding is_unused_elem_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. pure R x dflt = false) = (dflt \\<notin> Domain R)", "by (auto simp: pure_rel_eq_false_iff)"], ["", "definition \"dflt_option_rel_aux dflt \n    \\<equiv> { (dflt,None) } \\<union> { (x, Some x) | x. x\\<noteq>dflt }\""], ["", "definition [to_relAPP]: \"dflt_option_assn dflt A \n    \\<equiv> pure (dflt_option_rel_aux dflt O \\<langle>the_pure A\\<rangle>option_rel)\""], ["", "subsection \\<open>Function-Level Map Operations\\<close>"], ["", "text \\<open>We justify the map operations implemented by a function\\<close>"], ["", "lemma amd1_empty_refine: \n    \"(uncurry0 (\\<lambda>_. dflt), uncurry0 op_map_empty) \n    \\<in> Id \\<rightarrow>\\<^sub>f (Id \\<rightarrow> dflt_option_rel_aux dflt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 (\\<lambda>_. dflt), uncurry0 op_map_empty)\n    \\<in> unit_rel \\<rightarrow>\\<^sub>f Id \\<rightarrow>\n   dflt_option_rel_aux dflt", "by (auto simp: dflt_option_rel_aux_def fref_def)"], ["", "lemma amd1_lookup_refine: \n    \"(\\<lambda>x f. f x, op_map_lookup) \n    \\<in> Id \\<rightarrow> (Id \\<rightarrow> dflt_option_rel_aux dflt) \\<rightarrow> dflt_option_rel_aux dflt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x f. f x, op_map_lookup)\n    \\<in> Id \\<rightarrow>\n          (Id \\<rightarrow> dflt_option_rel_aux dflt) \\<rightarrow>\n          dflt_option_rel_aux dflt", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x f. f x, \\<lambda>k m. m k)\n    \\<in> Id \\<rightarrow>\n          (Id \\<rightarrow> dflt_option_rel_aux dflt) \\<rightarrow>\n          dflt_option_rel_aux dflt", "by parametricity"], ["", "lemma amd1_update_refine: \n    \"(uncurry2 (\\<lambda>k v f. f(k:=v)), uncurry2 op_map_update) \n    \\<in> [\\<lambda>((k,v),m). v\\<noteq>dflt]\\<^sub>f \n      ((Id \\<times>\\<^sub>r Id) \\<times>\\<^sub>r (Id \\<rightarrow> dflt_option_rel_aux dflt)) \n      \\<rightarrow> (Id \\<rightarrow> dflt_option_rel_aux dflt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (\\<lambda>k v f. f(k := v)), uncurry2 op_map_update)\n    \\<in> [\\<lambda>((k, v), m).\n              v \\<noteq>\n              dflt]\\<^sub>f (Id \\<times>\\<^sub>r Id) \\<times>\\<^sub>r\n                            (Id \\<rightarrow>\n                             dflt_option_rel_aux\n                              dflt) \\<rightarrow> Id \\<rightarrow>\n            dflt_option_rel_aux dflt", "unfolding op_map_update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (\\<lambda>k v f. f(k := v)),\n     uncurry2 (\\<lambda>k v m. m(k \\<mapsto> v)))\n    \\<in> [\\<lambda>((k, v), m).\n              v \\<noteq>\n              dflt]\\<^sub>f (Id \\<times>\\<^sub>r Id) \\<times>\\<^sub>r\n                            (Id \\<rightarrow>\n                             dflt_option_rel_aux\n                              dflt) \\<rightarrow> Id \\<rightarrow>\n            dflt_option_rel_aux dflt", "apply (rule frefI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case y of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (k, v) \\<Rightarrow> \\<lambda>m. v \\<noteq> dflt)\n                   xa;\n        (x, y)\n        \\<in> (Id \\<times>\\<^sub>r Id) \\<times>\\<^sub>r\n              (Id \\<rightarrow> dflt_option_rel_aux dflt)\\<rbrakk>\n       \\<Longrightarrow> (uncurry2 (\\<lambda>k v f. f(k := v)) x,\n                          uncurry2 (\\<lambda>k v m. m(k \\<mapsto> v)) y)\n                         \\<in> Id \\<rightarrow> dflt_option_rel_aux dflt", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b ba bc.\n       \\<lbrakk>b \\<noteq> dflt;\n        (ba, bc) \\<in> Id \\<rightarrow> dflt_option_rel_aux dflt\\<rbrakk>\n       \\<Longrightarrow> (b, Some b) \\<in> dflt_option_rel_aux dflt\n 2. \\<And>a b ba bc a'.\n       \\<lbrakk>b \\<noteq> dflt;\n        (ba, bc) \\<in> Id \\<rightarrow> dflt_option_rel_aux dflt;\n        a' \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> (ba a', bc a') \\<in> dflt_option_rel_aux dflt", "applyS (auto simp: dflt_option_rel_aux_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba bc a'.\n       \\<lbrakk>b \\<noteq> dflt;\n        (ba, bc) \\<in> Id \\<rightarrow> dflt_option_rel_aux dflt;\n        a' \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> (ba a', bc a') \\<in> dflt_option_rel_aux dflt", "applyS (parametricity; simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition [simp]: \"amd1_delete dflt k f \\<equiv> fun_upd f k dflt\""], ["", "lemma amd1_delete_refine: \n    \"(uncurry (amd1_delete dflt), uncurry op_map_delete) \n    \\<in> Id \\<times>\\<^sub>r (Id \\<rightarrow> dflt_option_rel_aux dflt) \\<rightarrow>\\<^sub>f (Id \\<rightarrow> dflt_option_rel_aux dflt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (amd1_delete dflt), uncurry op_map_delete)\n    \\<in> Id \\<times>\\<^sub>r\n          (Id \\<rightarrow>\n           dflt_option_rel_aux\n            dflt) \\<rightarrow>\\<^sub>f Id \\<rightarrow>\n  dflt_option_rel_aux dflt", "unfolding op_map_delete_def PR_CONST_def amd1_delete_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (\\<lambda>k f. f(k := dflt)),\n     uncurry (\\<lambda>k m. m(k := None)))\n    \\<in> Id \\<times>\\<^sub>r\n          (Id \\<rightarrow>\n           dflt_option_rel_aux\n            dflt) \\<rightarrow>\\<^sub>f Id \\<rightarrow>\n  dflt_option_rel_aux dflt", "apply (rule frefI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>True;\n        (x, y)\n        \\<in> Id \\<times>\\<^sub>r\n              (Id \\<rightarrow> dflt_option_rel_aux dflt)\\<rbrakk>\n       \\<Longrightarrow> (uncurry (\\<lambda>k f. f(k := dflt)) x,\n                          uncurry (\\<lambda>k m. m(k := None)) y)\n                         \\<in> Id \\<rightarrow> dflt_option_rel_aux dflt", "apply parametricity"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y a a' aa a'a.\n       \\<lbrakk>True;\n        (x, y)\n        \\<in> Id \\<times>\\<^sub>r\n              (Id \\<rightarrow> dflt_option_rel_aux dflt);\n        (a, a') \\<in> Id;\n        (aa, a'a) \\<in> Id \\<rightarrow> dflt_option_rel_aux dflt\\<rbrakk>\n       \\<Longrightarrow> ((=), (=))\n                         \\<in> Id \\<rightarrow> Id \\<rightarrow> bool_rel\n 2. \\<And>x y a a' aa a'a.\n       \\<lbrakk>True;\n        (x, y)\n        \\<in> Id \\<times>\\<^sub>r\n              (Id \\<rightarrow> dflt_option_rel_aux dflt);\n        (a, a') \\<in> Id;\n        (aa, a'a) \\<in> Id \\<rightarrow> dflt_option_rel_aux dflt\\<rbrakk>\n       \\<Longrightarrow> (dflt, None) \\<in> dflt_option_rel_aux dflt", "apply (auto simp: dflt_option_rel_aux_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Map Operations, array-level\\<close>"], ["", "text \\<open>We use dynamic arrays to implement the function, and combine both to \n      implement the map interface.\\<close>"], ["", "definition [code_unfold]: \"amd_empty dflt \\<equiv> dyn_array_new_sz dflt 16\""], ["", "definition [code_unfold]: \"amd_lookup dflt k a \\<equiv> array_get_dyn dflt a k\""], ["", "definition [code_unfold]: \"amd_update dflt k v a \\<equiv> array_set_dyn dflt a k v\""], ["", "definition [code_unfold]: \"amd_delete dflt k a \\<equiv> array_set_dyn dflt a k dflt\""], ["", "definition \"amd_assn dflt K V \n    \\<equiv> hr_comp (hr_comp \n        (is_nff dflt) \n        (nat_rel \\<rightarrow>\\<^sub>f dflt_option_rel_aux dflt)) \n        (\\<langle>the_pure K, the_pure V\\<rangle>map_rel)\""], ["", "lemma amd_assn_fold2: \"hr_comp (hr_comp \n      (is_nff dflt) \n      (nat_rel \\<rightarrow> dflt_option_rel_aux dflt)) \n      (\\<langle>the_pure K, the_pure V\\<rangle>map_rel) \n    = amd_assn dflt K V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hr_comp\n     (hr_comp (is_nff dflt)\n       (nat_rel \\<rightarrow> dflt_option_rel_aux dflt))\n     (\\<langle>the_pure K, the_pure V\\<rangle>map_rel) =\n    amd_assn dflt K V", "unfolding amd_assn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hr_comp\n     (hr_comp (is_nff dflt)\n       (nat_rel \\<rightarrow> dflt_option_rel_aux dflt))\n     (\\<langle>the_pure K, the_pure V\\<rangle>map_rel) =\n    hr_comp\n     (hr_comp (is_nff dflt)\n       (nat_rel \\<rightarrow>\\<^sub>f dflt_option_rel_aux dflt))\n     (\\<langle>the_pure K, the_pure V\\<rangle>map_rel)", "apply (fo_rule fun_cong arg_cong)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<rightarrow>) nat_rel = freft nat_rel", "unfolding fref_def fun_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>B.\n        {(f, f'). \\<forall>(a, a')\\<in>nat_rel. (f a, f' a') \\<in> B}) =\n    (\\<lambda>S.\n        {(f, g).\n         \\<forall>x y.\n            True \\<and> (x, y) \\<in> nat_rel \\<longrightarrow>\n            (f x, g y) \\<in> S})", "by auto"], ["", "(* TODO: Move *)"], ["", "lemmas [intf_of_assn] \n    = intf_of_assnI[where R=\"amd_assn dflt K V\" \n                      and 'a=\"(nat,'vv) i_map\" for dflt K V]"], ["", "lemmas [safe_constraint_rules] \n    = CN_FALSEI[of is_pure \"amd_assn dflt K V\" for dflt K V]"], ["", "context \n  notes [fcomp_norm_unfold] = \n    amd_assn_def[symmetric] dflt_option_assn_def[symmetric] amd_assn_fold2\n  notes [intro!] = hfrefI hn_refineI[THEN hn_refine_preI]\n  notes [simp] = pure_def hn_ctxt_def invalid_assn_def \n  fixes dflt :: \"'a::heap\"\nbegin"], ["", "lemma amd2_empty_refine: \n    \"(uncurry0 (amd_empty dflt), uncurry0 (RETURN (\\<lambda>_. dflt))) \n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_nff dflt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 (amd_empty dflt), uncurry0 (RETURN (\\<lambda>_. dflt)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a is_nff dflt", "by (sep_auto simp: amd_empty_def)"], ["", "lemma amd2_lookup_refine: \n    \"(uncurry (amd_lookup dflt), uncurry (RETURN oo (\\<lambda>x f. f x))) \n    \\<in> id_assn\\<^sup>k*\\<^sub>a(is_nff dflt)\\<^sup>k \\<rightarrow>\\<^sub>a id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (amd_lookup dflt),\n     uncurry (\\<lambda>x. RETURN \\<circ> (\\<lambda>f. f x)))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a\n          (is_nff dflt)\\<^sup>k \\<rightarrow>\\<^sub>a id_assn", "by (sep_auto simp: amd_lookup_def)"], ["", "lemma amd2_update_refine: \n    \"(uncurry2 (amd_update dflt), uncurry2 (RETURN ooo (\\<lambda>k v f. f(k:=v)))) \n    \\<in> id_assn\\<^sup>k*\\<^sub>aid_assn\\<^sup>k*\\<^sub>a(is_nff dflt)\\<^sup>d \\<rightarrow>\\<^sub>a is_nff dflt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (amd_update dflt),\n     uncurry2 (\\<lambda>x xa. RETURN \\<circ> (\\<lambda>f. f(x := xa))))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a id_assn\\<^sup>k *\\<^sub>a\n          (is_nff dflt)\\<^sup>d \\<rightarrow>\\<^sub>a is_nff dflt", "by (sep_auto simp: amd_update_def)"], ["", "lemma amd2_delete_refine: \n    \"(uncurry (amd_delete dflt), uncurry (RETURN oo (amd1_delete dflt))) \n    \\<in> id_assn\\<^sup>k*\\<^sub>a(is_nff dflt)\\<^sup>d \\<rightarrow>\\<^sub>a is_nff dflt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry (amd_delete dflt),\n     uncurry ((RETURN \\<circ>\\<circ>\\<circ> amd1_delete) dflt))\n    \\<in> nat_assn\\<^sup>k *\\<^sub>a\n          (is_nff dflt)\\<^sup>d \\<rightarrow>\\<^sub>a is_nff dflt", "by (sep_auto simp: amd_delete_def)"], ["", "sepref_decl_impl (no_register) amd_empty: \n    amd2_empty_refine[FCOMP amd1_empty_refine[where dflt=dflt]]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition [simp]: \"op_amd_empty \\<equiv> op_map_empty\""], ["", "sepref_decl_impl \n    amd2_lookup_refine[FCOMP amd1_lookup_refine[where dflt=dflt]]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_impl \n    amd2_delete_refine[FCOMP amd1_delete_refine[where dflt=dflt]]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text \\<open>The only complication arises for the update operation, where we have \n    to use the fact that the default element is invalid, which forces us to do\n    a manual composition proof.\\<close>"], ["", "lemma amd2_update_hnr_aux:\n    assumes \"CONSTRAINT (IS_PURE single_valued) K\"\n      and \"CONSTRAINT (IS_PURE IS_LEFT_UNIQUE) K\"\n      and \"CONSTRAINT is_pure V\"\n      and \"CONSTRAINT (is_unused_elem dflt) V\"\n    shows \"(uncurry2 (amd_update dflt), uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_map_update))\n           \\<in>  K\\<^sup>k *\\<^sub>a V\\<^sup>k *\\<^sub>a (amd_assn dflt K V)\\<^sup>d \\<rightarrow>\\<^sub>a amd_assn dflt K V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (amd_update dflt),\n     uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_map_update))\n    \\<in> K\\<^sup>k *\\<^sub>a V\\<^sup>k *\\<^sub>a\n          (amd_assn dflt K\n            V)\\<^sup>d \\<rightarrow>\\<^sub>a amd_assn dflt K V", "apply (rule \n        hfref_cons[\n          OF amd2_update_refine[\n                FCOMP amd1_update_refine[where dflt=dflt], \n                FCOMP (no_prenorm) op_map_update.fref, of K V]])"], ["proof (prove)\ngoal (8 subgoals):\n 1. CONSTRAINT is_pure K\n 2. CONSTRAINT is_pure V\n 3. single_valued (the_pure K)\n 4. single_valued ((the_pure K)\\<inverse>)\n 5. \\<And>x.\n       True \\<Longrightarrow>\n       comp_PRE\n        ((the_pure K \\<times>\\<^sub>r the_pure V) \\<times>\\<^sub>r\n         \\<langle>the_pure K, the_pure V\\<rangle>map_rel)\n        (\\<lambda>_. True) (\\<lambda>x ((a, b), ba). b \\<noteq> dflt)\n        (\\<lambda>x.\n            nofail\n             (uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_map_update) x))\n        x\n 6. \\<And>x y.\n       fst (K\\<^sup>k *\\<^sub>a V\\<^sup>k *\\<^sub>a\n            (amd_assn dflt K V)\\<^sup>d)\n        x y \\<Longrightarrow>\\<^sub>t\n       fst (K\\<^sup>k *\\<^sub>a V\\<^sup>k *\\<^sub>a\n            (amd_assn dflt K V)\\<^sup>d)\n        x y\n 7. \\<And>x y.\n       snd (K\\<^sup>k *\\<^sub>a V\\<^sup>k *\\<^sub>a\n            (amd_assn dflt K V)\\<^sup>d)\n        x y \\<Longrightarrow>\\<^sub>t\n       snd (K\\<^sup>k *\\<^sub>a V\\<^sup>k *\\<^sub>a\n            (amd_assn dflt K V)\\<^sup>d)\n        x y\n 8. \\<And>x y.\n       amd_assn dflt K V x y \\<Longrightarrow>\\<^sub>t amd_assn dflt K V x y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT is_pure K", "using assms"], ["proof (prove)\nusing this:\n  CONSTRAINT (IS_PURE single_valued) K\n  CONSTRAINT (IS_PURE IS_LEFT_UNIQUE) K\n  CONSTRAINT is_pure V\n  CONSTRAINT (is_unused_elem dflt) V\n\ngoal (1 subgoal):\n 1. CONSTRAINT is_pure K", "by (simp add: IS_PURE_def)"], ["proof (prove)\ngoal (7 subgoals):\n 1. CONSTRAINT is_pure V\n 2. single_valued (the_pure K)\n 3. single_valued ((the_pure K)\\<inverse>)\n 4. \\<And>x.\n       True \\<Longrightarrow>\n       comp_PRE\n        ((the_pure K \\<times>\\<^sub>r the_pure V) \\<times>\\<^sub>r\n         \\<langle>the_pure K, the_pure V\\<rangle>map_rel)\n        (\\<lambda>_. True) (\\<lambda>x ((a, b), ba). b \\<noteq> dflt)\n        (\\<lambda>x.\n            nofail\n             (uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_map_update) x))\n        x\n 5. \\<And>x y.\n       fst (K\\<^sup>k *\\<^sub>a V\\<^sup>k *\\<^sub>a\n            (amd_assn dflt K V)\\<^sup>d)\n        x y \\<Longrightarrow>\\<^sub>t\n       fst (K\\<^sup>k *\\<^sub>a V\\<^sup>k *\\<^sub>a\n            (amd_assn dflt K V)\\<^sup>d)\n        x y\n 6. \\<And>x y.\n       snd (K\\<^sup>k *\\<^sub>a V\\<^sup>k *\\<^sub>a\n            (amd_assn dflt K V)\\<^sup>d)\n        x y \\<Longrightarrow>\\<^sub>t\n       snd (K\\<^sup>k *\\<^sub>a V\\<^sup>k *\\<^sub>a\n            (amd_assn dflt K V)\\<^sup>d)\n        x y\n 7. \\<And>x y.\n       amd_assn dflt K V x y \\<Longrightarrow>\\<^sub>t amd_assn dflt K V x y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT is_pure V", "using assms"], ["proof (prove)\nusing this:\n  CONSTRAINT (IS_PURE single_valued) K\n  CONSTRAINT (IS_PURE IS_LEFT_UNIQUE) K\n  CONSTRAINT is_pure V\n  CONSTRAINT (is_unused_elem dflt) V\n\ngoal (1 subgoal):\n 1. CONSTRAINT is_pure V", "by (simp add: IS_PURE_def)"], ["proof (prove)\ngoal (6 subgoals):\n 1. single_valued (the_pure K)\n 2. single_valued ((the_pure K)\\<inverse>)\n 3. \\<And>x.\n       True \\<Longrightarrow>\n       comp_PRE\n        ((the_pure K \\<times>\\<^sub>r the_pure V) \\<times>\\<^sub>r\n         \\<langle>the_pure K, the_pure V\\<rangle>map_rel)\n        (\\<lambda>_. True) (\\<lambda>x ((a, b), ba). b \\<noteq> dflt)\n        (\\<lambda>x.\n            nofail\n             (uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_map_update) x))\n        x\n 4. \\<And>x y.\n       fst (K\\<^sup>k *\\<^sub>a V\\<^sup>k *\\<^sub>a\n            (amd_assn dflt K V)\\<^sup>d)\n        x y \\<Longrightarrow>\\<^sub>t\n       fst (K\\<^sup>k *\\<^sub>a V\\<^sup>k *\\<^sub>a\n            (amd_assn dflt K V)\\<^sup>d)\n        x y\n 5. \\<And>x y.\n       snd (K\\<^sup>k *\\<^sub>a V\\<^sup>k *\\<^sub>a\n            (amd_assn dflt K V)\\<^sup>d)\n        x y \\<Longrightarrow>\\<^sub>t\n       snd (K\\<^sup>k *\\<^sub>a V\\<^sup>k *\\<^sub>a\n            (amd_assn dflt K V)\\<^sup>d)\n        x y\n 6. \\<And>x y.\n       amd_assn dflt K V x y \\<Longrightarrow>\\<^sub>t amd_assn dflt K V x y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (the_pure K)", "using assms"], ["proof (prove)\nusing this:\n  CONSTRAINT (IS_PURE single_valued) K\n  CONSTRAINT (IS_PURE IS_LEFT_UNIQUE) K\n  CONSTRAINT is_pure V\n  CONSTRAINT (is_unused_elem dflt) V\n\ngoal (1 subgoal):\n 1. single_valued (the_pure K)", "by (simp add: IS_PURE_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. single_valued ((the_pure K)\\<inverse>)\n 2. \\<And>x.\n       True \\<Longrightarrow>\n       comp_PRE\n        ((the_pure K \\<times>\\<^sub>r the_pure V) \\<times>\\<^sub>r\n         \\<langle>the_pure K, the_pure V\\<rangle>map_rel)\n        (\\<lambda>_. True) (\\<lambda>x ((a, b), ba). b \\<noteq> dflt)\n        (\\<lambda>x.\n            nofail\n             (uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_map_update) x))\n        x\n 3. \\<And>x y.\n       fst (K\\<^sup>k *\\<^sub>a V\\<^sup>k *\\<^sub>a\n            (amd_assn dflt K V)\\<^sup>d)\n        x y \\<Longrightarrow>\\<^sub>t\n       fst (K\\<^sup>k *\\<^sub>a V\\<^sup>k *\\<^sub>a\n            (amd_assn dflt K V)\\<^sup>d)\n        x y\n 4. \\<And>x y.\n       snd (K\\<^sup>k *\\<^sub>a V\\<^sup>k *\\<^sub>a\n            (amd_assn dflt K V)\\<^sup>d)\n        x y \\<Longrightarrow>\\<^sub>t\n       snd (K\\<^sup>k *\\<^sub>a V\\<^sup>k *\\<^sub>a\n            (amd_assn dflt K V)\\<^sup>d)\n        x y\n 5. \\<And>x y.\n       amd_assn dflt K V x y \\<Longrightarrow>\\<^sub>t amd_assn dflt K V x y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued ((the_pure K)\\<inverse>)", "using assms"], ["proof (prove)\nusing this:\n  CONSTRAINT (IS_PURE single_valued) K\n  CONSTRAINT (IS_PURE IS_LEFT_UNIQUE) K\n  CONSTRAINT is_pure V\n  CONSTRAINT (is_unused_elem dflt) V\n\ngoal (1 subgoal):\n 1. single_valued ((the_pure K)\\<inverse>)", "by (simp add: IS_PURE_def IS_LEFT_UNIQUE_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       True \\<Longrightarrow>\n       comp_PRE\n        ((the_pure K \\<times>\\<^sub>r the_pure V) \\<times>\\<^sub>r\n         \\<langle>the_pure K, the_pure V\\<rangle>map_rel)\n        (\\<lambda>_. True) (\\<lambda>x ((a, b), ba). b \\<noteq> dflt)\n        (\\<lambda>x.\n            nofail\n             (uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_map_update) x))\n        x\n 2. \\<And>x y.\n       fst (K\\<^sup>k *\\<^sub>a V\\<^sup>k *\\<^sub>a\n            (amd_assn dflt K V)\\<^sup>d)\n        x y \\<Longrightarrow>\\<^sub>t\n       fst (K\\<^sup>k *\\<^sub>a V\\<^sup>k *\\<^sub>a\n            (amd_assn dflt K V)\\<^sup>d)\n        x y\n 3. \\<And>x y.\n       snd (K\\<^sup>k *\\<^sub>a V\\<^sup>k *\\<^sub>a\n            (amd_assn dflt K V)\\<^sup>d)\n        x y \\<Longrightarrow>\\<^sub>t\n       snd (K\\<^sup>k *\\<^sub>a V\\<^sup>k *\\<^sub>a\n            (amd_assn dflt K V)\\<^sup>d)\n        x y\n 4. \\<And>x y.\n       amd_assn dflt K V x y \\<Longrightarrow>\\<^sub>t amd_assn dflt K V x y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. True \\<Longrightarrow>\n    comp_PRE\n     ((the_pure K \\<times>\\<^sub>r the_pure V) \\<times>\\<^sub>r\n      \\<langle>the_pure K, the_pure V\\<rangle>map_rel)\n     (\\<lambda>_. True) (\\<lambda>x ((a, b), ba). b \\<noteq> dflt)\n     (\\<lambda>x.\n         nofail (uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_map_update) x))\n     x_", "using assms"], ["proof (prove)\nusing this:\n  CONSTRAINT (IS_PURE single_valued) K\n  CONSTRAINT (IS_PURE IS_LEFT_UNIQUE) K\n  CONSTRAINT is_pure V\n  CONSTRAINT (is_unused_elem dflt) V\n\ngoal (1 subgoal):\n 1. True \\<Longrightarrow>\n    comp_PRE\n     ((the_pure K \\<times>\\<^sub>r the_pure V) \\<times>\\<^sub>r\n      \\<langle>the_pure K, the_pure V\\<rangle>map_rel)\n     (\\<lambda>_. True) (\\<lambda>x ((a, b), ba). b \\<noteq> dflt)\n     (\\<lambda>x.\n         nofail (uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_map_update) x))\n     x_", "by (auto \n          simp del: pure_def\n          simp: comp_PRE_def IS_PURE_def is_unused_elem_def is_pure_conv \n          simp: pure_rel_eq_false_iff \n          elim!: prod_relE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       fst (K\\<^sup>k *\\<^sub>a V\\<^sup>k *\\<^sub>a\n            (amd_assn dflt K V)\\<^sup>d)\n        x y \\<Longrightarrow>\\<^sub>t\n       fst (K\\<^sup>k *\\<^sub>a V\\<^sup>k *\\<^sub>a\n            (amd_assn dflt K V)\\<^sup>d)\n        x y\n 2. \\<And>x y.\n       snd (K\\<^sup>k *\\<^sub>a V\\<^sup>k *\\<^sub>a\n            (amd_assn dflt K V)\\<^sup>d)\n        x y \\<Longrightarrow>\\<^sub>t\n       snd (K\\<^sup>k *\\<^sub>a V\\<^sup>k *\\<^sub>a\n            (amd_assn dflt K V)\\<^sup>d)\n        x y\n 3. \\<And>x y.\n       amd_assn dflt K V x y \\<Longrightarrow>\\<^sub>t amd_assn dflt K V x y", "applyS simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       snd (K\\<^sup>k *\\<^sub>a V\\<^sup>k *\\<^sub>a\n            (amd_assn dflt K V)\\<^sup>d)\n        x y \\<Longrightarrow>\\<^sub>t\n       snd (K\\<^sup>k *\\<^sub>a V\\<^sup>k *\\<^sub>a\n            (amd_assn dflt K V)\\<^sup>d)\n        x y\n 2. \\<And>x y.\n       amd_assn dflt K V x y \\<Longrightarrow>\\<^sub>t amd_assn dflt K V x y", "applyS simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       amd_assn dflt K V x y \\<Longrightarrow>\\<^sub>t amd_assn dflt K V x y", "applyS simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* TODO: Somewhat of a hack. Perhaps add a flag to switch of \n      automatic parameterization on sepref_decl_impl? *)\n  private"], ["", "lemma op_map_update_id_param: \n    \"(uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_map_update), uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_map_update)) \n    \\<in> (Id\\<times>\\<^sub>rId)\\<times>\\<^sub>rId \\<rightarrow>\\<^sub>f \\<langle>Id\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_map_update),\n     uncurry2 (RETURN \\<circ>\\<circ>\\<circ> op_map_update))\n    \\<in> (Id \\<times>\\<^sub>r Id) \\<times>\\<^sub>r\n          Id \\<rightarrow>\\<^sub>f \\<langle>Id\\<rangle>nres_rel", "by (simp add: fref_def nres_rel_def)"], ["", "sepref_decl_impl amd2_update_hnr_aux uses op_map_update_id_param"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "interpretation amd: map_custom_empty op_amd_empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_custom_empty op_amd_empty", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. op_amd_empty = op_map_empty", "by auto"], ["", "lemmas [sepref_fr_rules] = amd_empty_hnr[folded op_amd_empty_def]"], ["", "subsection \\<open>Operations on Options\\<close>"], ["", "text \\<open>We give own names to constructors, otherwise, we will get confusions \n  with the default option refinement.\\<close>"], ["", "definition [simp]: \"dflt_None \\<equiv> None\""], ["", "definition [simp]: \"dflt_Some \\<equiv> Some\""], ["", "sepref_register dflt_None dflt_Some"], ["", "lemma doa_None_hnr: \n  \"(uncurry0 (return dflt), uncurry0 (RETURN dflt_None)) \n  \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a dflt_option_assn dflt A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 (return dflt), uncurry0 (RETURN dflt_None))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a dflt_option_assn dflt A", "apply (sepref_to_hoare)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>x ::\\<^sub>i TYPE(unit); nofail (RETURN dflt_None)\\<rbrakk>\n       \\<Longrightarrow> <emp> return\n                                dflt <\\<lambda>r.\n   emp *\n   (\\<exists>\\<^sub>Ax.\n       dflt_option_assn dflt A x r *\n       \\<up> (RETURN x \\<le> RETURN dflt_None))>\\<^sub>t", "apply (sep_auto simp: pure_def dflt_option_rel_aux_def dflt_option_assn_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma doa_Some_hnr: \"\\<lbrakk>CONSTRAINT (is_unused_elem dflt) A; CONSTRAINT is_pure A\\<rbrakk> \n  \\<Longrightarrow> (return o (\\<lambda>x. x), RETURN o dflt_Some) \\<in> A\\<^sup>k \\<rightarrow>\\<^sub>a dflt_option_assn dflt A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>CONSTRAINT (is_unused_elem dflt) A;\n     CONSTRAINT is_pure A\\<rbrakk>\n    \\<Longrightarrow> (return \\<circ> (\\<lambda>x. x),\n                       RETURN \\<circ> dflt_Some)\n                      \\<in> A\\<^sup>k \\<rightarrow>\\<^sub>a dflt_option_assn\n                       dflt A", "apply (sepref_to_hoare)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>CONSTRAINT (is_unused_elem dflt) A; CONSTRAINT is_pure A;\n        hfsynth_ID_R A x; nofail (RETURN (dflt_Some x))\\<rbrakk>\n       \\<Longrightarrow> <A x xi> return\n                                   xi <\\<lambda>r.\n    A x xi *\n    (\\<exists>\\<^sub>Axa.\n        dflt_option_assn dflt A xa r *\n        \\<up> (RETURN xa \\<le> RETURN (dflt_Some x)))>\\<^sub>t", "apply (clarsimp simp: is_pure_conv dflt_option_assn_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi R'.\n       \\<lbrakk>dflt \\<notin> Domain R'; A = pure R'\\<rbrakk>\n       \\<Longrightarrow> <pure R' x xi> return xi\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Axa.\n                                pure R' x xi *\n                                pure\n                                 (dflt_option_rel_aux dflt O\n                                  \\<langle>R'\\<rangle>option_rel)\n                                 xa r *\n                                true *\n                                \\<up> (xa = Some x)>", "apply (sep_auto simp: pure_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi R' a b.\n       \\<lbrakk>dflt \\<notin> Domain R';\n        A = (\\<lambda>a c. \\<up> ((c, a) \\<in> R')); (xi, x) \\<in> R';\n        (a, b) \\<Turnstile> emp\\<rbrakk>\n       \\<Longrightarrow> (xi, Some x)\n                         \\<in> dflt_option_rel_aux dflt O\n                               \\<langle>R'\\<rangle>option_rel", "apply (fastforce simp: dflt_option_rel_aux_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma doa_is_None_hnr[sepref_fr_rules]: \n  \"(return o ((=) dflt), RETURN o is_None) \n  \\<in> (dflt_option_assn dflt A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((return \\<circ>\\<circ> (=)) dflt, RETURN \\<circ> is_None)\n    \\<in> (dflt_option_assn dflt A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "apply (sepref_to_hoare)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>x ::\\<^sub>i TYPE('b option);\n        nofail (RETURN (is_None x))\\<rbrakk>\n       \\<Longrightarrow> <dflt_option_assn dflt A x\n                           xi> return\n                                (dflt =\n                                 xi) <\\<lambda>r.\n   dflt_option_assn dflt A x xi *\n   (\\<exists>\\<^sub>Axa.\n       \\<up> ((r, xa) \\<in> bool_rel) *\n       \\<up> (RETURN xa \\<le> RETURN (is_None x)))>\\<^sub>t", "by (sep_auto \n        simp: dflt_option_assn_def pure_def dflt_option_rel_aux_def \n        split: option.split)"], ["", "lemma doa_the_hnr[sepref_fr_rules]: \"\\<lbrakk>CONSTRAINT is_pure A\\<rbrakk> \n  \\<Longrightarrow> (return o (\\<lambda>x. x), RETURN o the) \n      \\<in> [\\<lambda>x. x\\<noteq>None]\\<^sub>a (dflt_option_assn dflt A)\\<^sup>k \\<rightarrow> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT is_pure A \\<Longrightarrow>\n    (return \\<circ> (\\<lambda>x. x), RETURN \\<circ> the)\n    \\<in> [\\<lambda>x.\n              x \\<noteq>\n              None]\\<^sub>a (dflt_option_assn dflt\n                              A)\\<^sup>k \\<rightarrow> A", "apply (sepref_to_hoare)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xi.\n       \\<lbrakk>CONSTRAINT is_pure A; x \\<noteq> None;\n        hfsynth_ID_R (dflt_option_assn dflt A) x;\n        nofail (RETURN (the x))\\<rbrakk>\n       \\<Longrightarrow> <dflt_option_assn dflt A x\n                           xi> return\n                                xi <\\<lambda>r.\n dflt_option_assn dflt A x xi *\n (\\<exists>\\<^sub>Axa.\n     A xa r * \\<up> (RETURN xa \\<le> RETURN (the x)))>\\<^sub>t", "apply (clarsimp simp: is_pure_conv dflt_option_assn_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xi R' y.\n       A = pure R' \\<Longrightarrow>\n       <pure (dflt_option_rel_aux dflt O \\<langle>R'\\<rangle>option_rel)\n         (Some y) xi>\n       return xi\n       <\\<lambda>r.\n           \\<exists>\\<^sub>Ax.\n              pure\n               (dflt_option_rel_aux dflt O \\<langle>R'\\<rangle>option_rel)\n               (Some y) xi *\n              pure R' x r *\n              true *\n              \\<up> (x = y)>", "apply (sep_auto simp: pure_def dflt_option_rel_aux_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* TODO: Add proper rule for case distinction *)\n\n(* Workaround for case-distinction: Rewrite with abstract-level rule: *)"], ["", "lemma cnv_option_case_2_if: \"(case x of None \\<Rightarrow> fn | Some v \\<Rightarrow> fv v) \n  \\<longleftrightarrow> (if is_None x then fn else fv (the x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case x of None \\<Rightarrow> fn | Some v \\<Rightarrow> fv v) =\n    (if is_None x then fn else fv (the x))", "by (cases x) auto"], ["", "(* TODO: Hack:\n  Due to lack of recursive generic algorithms with specialization, \n  we have instantiated equality on options as combinator rule. \n  This allows no backtracking or alternatives.\n  Thus, we do a type-based rewriting of option-equalities for dflt-option \n  types in operator-id phase.\n*)"], ["", "definition [simp]: \"dflt_option_eq \\<equiv> (=)\""], ["", "locale dflt_option =\n  fixes A :: \"'a \\<Rightarrow> 'c \\<Rightarrow> assn\"\n  fixes dflt :: \"'c\"\n  fixes eq :: \"'c \\<Rightarrow> 'c \\<Rightarrow> bool Heap\"\n  assumes unused_dflt[safe_constraint_rules]: \"(is_unused_elem dflt) A\"\n\n  assumes eq_op: \"(uncurry eq, uncurry (RETURN oo (=))) \\<in> A\\<^sup>k*\\<^sub>aA\\<^sup>k\\<rightarrow>\\<^sub>abool_assn\"\n  assumes eq_dflt: \"\\<And>a b. \\<lbrakk> a=dflt \\<or> b=dflt \\<rbrakk> \\<Longrightarrow> <emp> eq a b <\\<lambda>r. \\<up>(r \\<longleftrightarrow> a=b)>\\<^sub>t\"\nbegin"], ["", "(* Type-based rewrites. \n      TODO: We would prefer type-based specializations in translate-phase! *)"], ["", "lemma fold_dflt_option[def_pat_rules]: \n    \"(None::'a option) \\<equiv> dflt_None\"\n    \"(Some::'a\\<Rightarrow>_) \\<equiv> dflt_Some\"\n    \"((=)::'a option \\<Rightarrow> _) \\<equiv> dflt_option_eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (None \\<equiv> dflt_None) &&&\n    (Some \\<equiv> dflt_Some) &&& (=) \\<equiv> dflt_option_eq", "by auto"], ["", "(* Constructors *)"], ["", "lemmas [sepref_fr_rules] = \n    doa_None_hnr[where dflt = dflt and A=A]\n    doa_Some_hnr[where dflt = dflt and A=A]"], ["", "lemma eq_option_refine[sepref_fr_rules]:\n    assumes \"CONSTRAINT is_pure A\"\n    shows \"(uncurry eq,uncurry (RETURN oo dflt_option_eq)) \n      \\<in> (dflt_option_assn dflt A)\\<^sup>k *\\<^sub>a (dflt_option_assn dflt A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry eq, uncurry (RETURN \\<circ>\\<circ> dflt_option_eq))\n    \\<in> (dflt_option_assn dflt A)\\<^sup>k *\\<^sub>a\n          (dflt_option_assn dflt A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (uncurry eq, uncurry (RETURN \\<circ>\\<circ> dflt_option_eq))\n    \\<in> (dflt_option_assn dflt A)\\<^sup>k *\\<^sub>a\n          (dflt_option_assn dflt A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "from assms"], ["proof (chain)\npicking this:\n  CONSTRAINT is_pure A", "obtain R where [simp]: \"A = pure R\""], ["proof (prove)\nusing this:\n  CONSTRAINT is_pure A\n\ngoal (1 subgoal):\n 1. (\\<And>R. A = pure R \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto simp: is_pure_conv)"], ["proof (state)\nthis:\n  A = pure R\n\ngoal (1 subgoal):\n 1. (uncurry eq, uncurry (RETURN \\<circ>\\<circ> dflt_option_eq))\n    \\<in> (dflt_option_assn dflt A)\\<^sup>k *\\<^sub>a\n          (dflt_option_assn dflt A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "from eq_op"], ["proof (chain)\npicking this:\n  (uncurry eq, uncurry (RETURN \\<circ>\\<circ> (=)))\n  \\<in> A\\<^sup>k *\\<^sub>a A\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "have [sep_heap_rules]: \n      \"\\<lbrakk> (x,x')\\<in>R; (y,y')\\<in>R \\<rbrakk> \n      \\<Longrightarrow> <emp> eq x y <\\<lambda>r. \\<up>(r \\<longleftrightarrow> x'=y')>\\<^sub>t\" for x x' y y'"], ["proof (prove)\nusing this:\n  (uncurry eq, uncurry (RETURN \\<circ>\\<circ> (=)))\n  \\<in> A\\<^sup>k *\\<^sub>a A\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, x') \\<in> R; (y, y') \\<in> R\\<rbrakk>\n    \\<Longrightarrow> <emp> eq x\n                             y <\\<lambda>r. \\<up> (r = (x' = y'))>\\<^sub>t", "apply (drule_tac hfrefD[where a=\"(x',y')\" and c=\"(x,y)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(x, x') \\<in> R; (y, y') \\<in> R\\<rbrakk>\n    \\<Longrightarrow> True\n 2. \\<lbrakk>(x, x') \\<in> R; (y, y') \\<in> R;\n     hn_refine (fst (A\\<^sup>k *\\<^sub>a A\\<^sup>k) (x', y') (x, y))\n      (uncurry eq (x, y))\n      (snd (A\\<^sup>k *\\<^sub>a A\\<^sup>k) (x', y') (x, y)) bool_assn\n      (uncurry (RETURN \\<circ>\\<circ> (=)) (x', y'))\\<rbrakk>\n    \\<Longrightarrow> <emp> eq x\n                             y <\\<lambda>r. \\<up> (r = (x' = y'))>\\<^sub>t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, x') \\<in> R; (y, y') \\<in> R;\n     hn_refine (fst (A\\<^sup>k *\\<^sub>a A\\<^sup>k) (x', y') (x, y))\n      (uncurry eq (x, y))\n      (snd (A\\<^sup>k *\\<^sub>a A\\<^sup>k) (x', y') (x, y)) bool_assn\n      (uncurry (RETURN \\<circ>\\<circ> (=)) (x', y'))\\<rbrakk>\n    \\<Longrightarrow> <emp> eq x\n                             y <\\<lambda>r. \\<up> (r = (x' = y'))>\\<^sub>t", "apply (drule hn_refineD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(x, x') \\<in> R; (y, y') \\<in> R\\<rbrakk>\n    \\<Longrightarrow> nofail (uncurry (RETURN \\<circ>\\<circ> (=)) (x', y'))\n 2. \\<lbrakk>(x, x') \\<in> R; (y, y') \\<in> R;\n     <fst (A\\<^sup>k *\\<^sub>a A\\<^sup>k) (x', y')\n       (x, y)> uncurry eq\n                (x, y) <\\<lambda>r.\n                           snd (A\\<^sup>k *\\<^sub>a A\\<^sup>k) (x', y')\n                            (x, y) *\n                           (\\<exists>\\<^sub>Ax.\n                               bool_assn x r *\n                               \\<up>\n                                (RETURN x\n                                 \\<le> uncurry (RETURN \\<circ>\\<circ> (=))\n  (x', y')))>\\<^sub>t\\<rbrakk>\n    \\<Longrightarrow> <emp> eq x\n                             y <\\<lambda>r. \\<up> (r = (x' = y'))>\\<^sub>t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, x') \\<in> R; (y, y') \\<in> R;\n     <fst (A\\<^sup>k *\\<^sub>a A\\<^sup>k) (x', y')\n       (x, y)> uncurry eq\n                (x, y) <\\<lambda>r.\n                           snd (A\\<^sup>k *\\<^sub>a A\\<^sup>k) (x', y')\n                            (x, y) *\n                           (\\<exists>\\<^sub>Ax.\n                               bool_assn x r *\n                               \\<up>\n                                (RETURN x\n                                 \\<le> uncurry (RETURN \\<circ>\\<circ> (=))\n  (x', y')))>\\<^sub>t\\<rbrakk>\n    \\<Longrightarrow> <emp> eq x\n                             y <\\<lambda>r. \\<up> (r = (x' = y'))>\\<^sub>t", "apply (sep_auto simp: pure_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, x') \\<in> R; (y, y') \\<in> R;\n     <emp> eq x y\n     <\\<lambda>r.\n         \\<exists>\\<^sub>Ax.\n            true * \\<up> (r = x \\<and> x = (x' = y'))>\\<rbrakk>\n    \\<Longrightarrow> <emp> eq x y\n                      <\\<lambda>r. true * \\<up> (r = (x' = y'))>", "apply (rule Hoare_Triple.cons_post_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(x, x') \\<in> R; (y, y') \\<in> R;\n     <emp> eq x y\n     <\\<lambda>r.\n         \\<exists>\\<^sub>Ax.\n            true * \\<up> (r = x \\<and> x = (x' = y'))>\\<rbrakk>\n    \\<Longrightarrow> <emp> eq x y <?Q5>\n 2. \\<And>xa.\n       \\<lbrakk>(x, x') \\<in> R; (y, y') \\<in> R;\n        <emp> eq x y\n        <\\<lambda>r.\n            \\<exists>\\<^sub>Ax.\n               true * \\<up> (r = x \\<and> x = (x' = y'))>\\<rbrakk>\n       \\<Longrightarrow> ?Q5 xa \\<Longrightarrow>\\<^sub>A\n                         true * \\<up> (xa = (x' = y'))", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>(x, x') \\<in> R; (y, y') \\<in> R;\n        <emp> eq x y\n        <\\<lambda>r.\n            \\<exists>\\<^sub>Ax.\n               true * \\<up> (r = x \\<and> x = (x' = y'))>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<^sub>Ax.\n                            true *\n                            \\<up>\n                             (xa = x \\<and>\n                              x = (x' = y')) \\<Longrightarrow>\\<^sub>A\n                         true * \\<up> (xa = (x' = y'))", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>(?x, ?x') \\<in> R; (?y, ?y') \\<in> R\\<rbrakk>\n  \\<Longrightarrow> <emp> eq ?x\n                           ?y <\\<lambda>r. \\<up> (r = (?x' = ?y'))>\\<^sub>t\n\ngoal (1 subgoal):\n 1. (uncurry eq, uncurry (RETURN \\<circ>\\<circ> dflt_option_eq))\n    \\<in> (dflt_option_assn dflt A)\\<^sup>k *\\<^sub>a\n          (dflt_option_assn dflt A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "note [simplified,sep_heap_rules] \n      = eq_dflt[of dflt dflt] eq_dflt[of dflt] eq_dflt[of _ dflt]"], ["proof (state)\nthis:\n  <emp> eq dflt dflt <\\<lambda>r. true * \\<up> r>\n  <emp> eq dflt ?b <\\<lambda>r. true * \\<up> (r = (dflt = ?b))>\n  <emp> eq ?a dflt <\\<lambda>r. true * \\<up> (r = (?a = dflt))>\n\ngoal (1 subgoal):\n 1. (uncurry eq, uncurry (RETURN \\<circ>\\<circ> dflt_option_eq))\n    \\<in> (dflt_option_assn dflt A)\\<^sup>k *\\<^sub>a\n          (dflt_option_assn dflt A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry eq, uncurry (RETURN \\<circ>\\<circ> dflt_option_eq))\n    \\<in> (dflt_option_assn dflt A)\\<^sup>k *\\<^sub>a\n          (dflt_option_assn dflt A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>a ::\\<^sub>i TYPE('a option); b ::\\<^sub>i TYPE('a option);\n        nofail (RETURN (dflt_option_eq a b))\\<rbrakk>\n       \\<Longrightarrow> <dflt_option_assn dflt A b bi *\n                          dflt_option_assn dflt A a\n                           ai> eq ai\n                                bi <\\<lambda>r.\n dflt_option_assn dflt A b bi * dflt_option_assn dflt A a ai *\n (\\<exists>\\<^sub>Ax.\n     \\<up> ((r, x) \\<in> bool_rel) *\n     \\<up> (RETURN x \\<le> RETURN (dflt_option_eq a b)))>\\<^sub>t", "apply (simp add: dflt_option_assn_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai.\n       <pure (dflt_option_rel_aux dflt O \\<langle>R\\<rangle>option_rel) b\n         bi *\n        pure (dflt_option_rel_aux dflt O \\<langle>R\\<rangle>option_rel) a\n         ai>\n       eq ai bi\n       <\\<lambda>r.\n           \\<exists>\\<^sub>Ax.\n              pure\n               (dflt_option_rel_aux dflt O \\<langle>R\\<rangle>option_rel) b\n               bi *\n              pure\n               (dflt_option_rel_aux dflt O \\<langle>R\\<rangle>option_rel) a\n               ai *\n              true *\n              \\<up> (r = x \\<and> x = (a = b))>", "apply (auto simp: pure_def dflt_option_rel_aux_def elim!: option_relE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. <emp> eq dflt dflt\n    <\\<lambda>r. \\<exists>\\<^sub>Ax. true * \\<up> (r = x \\<and> x)>\n 2. \\<And>a' xb.\n       \\<lbrakk>(xb, a') \\<in> R; xb \\<noteq> dflt\\<rbrakk>\n       \\<Longrightarrow> <emp> eq xb dflt\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Ax.\n                                true * \\<up> (r = x \\<and> \\<not> x)>\n 3. \\<And>a' xb.\n       \\<lbrakk>(xb, a') \\<in> R; xb \\<noteq> dflt\\<rbrakk>\n       \\<Longrightarrow> <emp> eq dflt xb\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Ax.\n                                true * \\<up> (r = x \\<and> \\<not> x)>\n 4. \\<And>a' a'a xb xc.\n       \\<lbrakk>(xb, a') \\<in> R; (xc, a'a) \\<in> R; xb \\<noteq> dflt;\n        xc \\<noteq> dflt\\<rbrakk>\n       \\<Longrightarrow> <emp> eq xc xb\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Ax.\n                                true * \\<up> (r = x \\<and> x = (a'a = a'))>", "apply (sep_auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a' xb.\n       \\<lbrakk>(xb, a') \\<in> R; xb \\<noteq> dflt\\<rbrakk>\n       \\<Longrightarrow> <emp> eq xb dflt\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Ax.\n                                true * \\<up> (r = x \\<and> \\<not> x)>\n 2. \\<And>a' xb.\n       \\<lbrakk>(xb, a') \\<in> R; xb \\<noteq> dflt\\<rbrakk>\n       \\<Longrightarrow> <emp> eq dflt xb\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Ax.\n                                true * \\<up> (r = x \\<and> \\<not> x)>\n 3. \\<And>a' a'a xb xc.\n       \\<lbrakk>(xb, a') \\<in> R; (xc, a'a) \\<in> R; xb \\<noteq> dflt;\n        xc \\<noteq> dflt\\<rbrakk>\n       \\<Longrightarrow> <emp> eq xc xb\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Ax.\n                                true * \\<up> (r = x \\<and> x = (a'a = a'))>", "apply (sep_auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a' xb.\n       \\<lbrakk>(xb, a') \\<in> R; xb \\<noteq> dflt\\<rbrakk>\n       \\<Longrightarrow> <emp> eq dflt xb\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Ax.\n                                true * \\<up> (r = x \\<and> \\<not> x)>\n 2. \\<And>a' a'a xb xc.\n       \\<lbrakk>(xb, a') \\<in> R; (xc, a'a) \\<in> R; xb \\<noteq> dflt;\n        xc \\<noteq> dflt\\<rbrakk>\n       \\<Longrightarrow> <emp> eq xc xb\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Ax.\n                                true * \\<up> (r = x \\<and> x = (a'a = a'))>", "apply (sep_auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a' a'a xb xc.\n       \\<lbrakk>(xb, a') \\<in> R; (xc, a'a) \\<in> R; xb \\<noteq> dflt;\n        xc \\<noteq> dflt\\<rbrakk>\n       \\<Longrightarrow> <emp> eq xc xb\n                         <\\<lambda>r.\n                             \\<exists>\\<^sub>Ax.\n                                true * \\<up> (r = x \\<and> x = (a'a = a'))>", "apply (sep_auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (uncurry eq, uncurry (RETURN \\<circ>\\<circ> dflt_option_eq))\n  \\<in> (dflt_option_assn dflt A)\\<^sup>k *\\<^sub>a\n        (dflt_option_assn dflt A)\\<^sup>k \\<rightarrow>\\<^sub>a bool_assn\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}