{"file_name": "/home/qj213/afp-2021-10-22/thys/VerifyThis2018/Challenge1.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/VerifyThis2018", "problem_names": ["lemma empty_pos[simp]: \"get_pos empty = 0\"", "lemma empty_text[simp]: \"get_text empty = []\"", "lemma move_left_pos[simp]: \"get_pos (move_left b) = get_pos b - 1\" \n    \\<comment> \\<open>Note that @{lemma \\<open>0-(1::nat)=0\\<close> by simp} in Isabelle\\<close>", "lemma move_left_text[simp]: \"get_text (move_left b) = get_text b\"", "lemma move_right_pos[simp]: \n    \"get_pos (move_right b) = min (get_pos b+1) (length (get_text b))\"", "lemma move_right_text[simp]: \"get_text (move_right b) = get_text b\"", "lemma insert_pos[simp]: \"get_pos (insert x b) = get_pos b + 1\"", "lemma insert_text: \"get_text (insert x b) \n    = take (get_pos b) (get_text b)@x#drop (get_pos b) (get_text b)\"", "lemma delete_pos[simp]: \"get_pos (delete b) = get_pos b - 1\"", "lemma delete_text: \"get_text (delete b) \n    = take (get_pos b-1) (get_text b)@drop (get_pos b) (get_text b)\"", "lemma delete_text0[simp]: \"get_pos b=0 \\<Longrightarrow> get_text (delete b) = get_text b\"", "lemma [param]: \"(BUF,BUF) \\<in> \\<langle>A\\<rangle>list_rel \\<rightarrow> \\<langle>A\\<rangle>list_rel \\<rightarrow> \\<langle>A\\<rangle>textbuffer_rel\"", "lemma [param]: \"(rec_textbuffer,rec_textbuffer)\n    \\<in> (\\<langle>A\\<rangle>list_rel \\<rightarrow> \\<langle>A\\<rangle>list_rel\\<rightarrow>B) \\<rightarrow> \\<langle>A\\<rangle>textbuffer_rel \\<rightarrow> B\"", "lemma empty1_correct: \"(empty1, RETURN empty) \\<in> \\<langle>gap_rel\\<rangle>nres_rel\"", "lemma move_left1_correct: \n    \"(move_left1, RETURN o move_left) \\<in> gap_rel \\<rightarrow> \\<langle>gap_rel\\<rangle>nres_rel\"", "lemma move_right1_correct: \n    \"(move_right1,RETURN o move_right) \\<in> gap_rel \\<rightarrow> \\<langle>gap_rel\\<rangle>nres_rel\"", "lemma grow1_correct[THEN SPEC_trans, refine_vcg]:\n    assumes \"gap_invar gb\"\n    shows \"grow1 K gb  \\<le> (SPEC (\\<lambda>gb'. \n          gap_invar gb' \n        \\<and> gap_\\<alpha> gb' = gap_\\<alpha> gb \n        \\<and> (K>0 \\<longrightarrow> can_insert gb')))\"", "lemma insert1_correct: \n    \"(insert1,RETURN oo insert) \\<in> Id \\<rightarrow> gap_rel \\<rightarrow> \\<langle>gap_rel\\<rangle>nres_rel\"", "lemma delete1_correct: \n    \"(delete1,RETURN o delete) \\<in> gap_rel \\<rightarrow> \\<langle>gap_rel\\<rangle>nres_rel\"", "lemma \"client \\<le> SPEC (\\<lambda>r. get_text r=[1,2,3,4,5])\""], "translations": [["", "lemma empty_pos[simp]: \"get_pos empty = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_pos Challenge1.empty = 0", "unfolding empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. get_pos (BUF [] []) = 0", "by auto"], ["", "lemma empty_text[simp]: \"get_text empty = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_text Challenge1.empty = []", "unfolding empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. get_text (BUF [] []) = []", "by auto"], ["", "lemma move_left_pos[simp]: \"get_pos (move_left b) = get_pos b - 1\" \n    \\<comment> \\<open>Note that @{lemma \\<open>0-(1::nat)=0\\<close> by simp} in Isabelle\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. get_pos (move_left b) = get_pos b - 1", "by (cases b) auto"], ["", "lemma move_left_text[simp]: \"get_text (move_left b) = get_text b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_text (move_left b) = get_text b", "by (cases b) auto"], ["", "lemma move_right_pos[simp]: \n    \"get_pos (move_right b) = min (get_pos b+1) (length (get_text b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_pos (move_right b) = min (get_pos b + 1) (length (get_text b))", "by (cases b) auto"], ["", "lemma move_right_text[simp]: \"get_text (move_right b) = get_text b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_text (move_right b) = get_text b", "by (cases b) auto"], ["", "lemma insert_pos[simp]: \"get_pos (insert x b) = get_pos b + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_pos (Challenge1.insert x b) = get_pos b + 1", "by (cases b) auto"], ["", "lemma insert_text: \"get_text (insert x b) \n    = take (get_pos b) (get_text b)@x#drop (get_pos b) (get_text b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_text (Challenge1.insert x b) =\n    take (get_pos b) (get_text b) @ x # drop (get_pos b) (get_text b)", "by (cases b) auto"], ["", "lemma delete_pos[simp]: \"get_pos (delete b) = get_pos b - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_pos (delete b) = get_pos b - 1", "by (cases b) auto"], ["", "lemma delete_text: \"get_text (delete b) \n    = take (get_pos b-1) (get_text b)@drop (get_pos b) (get_text b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_text (delete b) =\n    take (get_pos b - 1) (get_text b) @ drop (get_pos b) (get_text b)", "by (cases b) auto"], ["", "text \\<open>For the zero case, we can prove a simpler (equivalent) lemma\\<close>"], ["", "lemma delete_text0[simp]: \"get_pos b=0 \\<Longrightarrow> get_text (delete b) = get_text b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_pos b = 0 \\<Longrightarrow> get_text (delete b) = get_text b", "by (cases b) auto"], ["", "text \\<open>To fully exploit the capabilities of our tool, we can (optionally) show \n    that the operations of a text buffer are parametric in its content. \n    Then, we can automatically refine the representation of the content.\n  \\<close>"], ["", "definition [to_relAPP]:\n    \"textbuffer_rel A \\<equiv> {(BUF a b, BUF a' b') | a b a' b'. \n                           (a,a')\\<in>\\<langle>A\\<rangle>list_rel \\<and> (b,b')\\<in>\\<langle>A\\<rangle>list_rel}\""], ["", "lemma [param]: \"(BUF,BUF) \\<in> \\<langle>A\\<rangle>list_rel \\<rightarrow> \\<langle>A\\<rangle>list_rel \\<rightarrow> \\<langle>A\\<rangle>textbuffer_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (BUF, BUF)\n    \\<in> \\<langle>A\\<rangle>list_rel \\<rightarrow>\n          \\<langle>A\\<rangle>list_rel \\<rightarrow>\n          \\<langle>A\\<rangle>textbuffer_rel", "by (auto simp: textbuffer_rel_def)"], ["", "lemma [param]: \"(rec_textbuffer,rec_textbuffer)\n    \\<in> (\\<langle>A\\<rangle>list_rel \\<rightarrow> \\<langle>A\\<rangle>list_rel\\<rightarrow>B) \\<rightarrow> \\<langle>A\\<rangle>textbuffer_rel \\<rightarrow> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rec_textbuffer, rec_textbuffer)\n    \\<in> (\\<langle>A\\<rangle>list_rel \\<rightarrow>\n           \\<langle>A\\<rangle>list_rel \\<rightarrow> B) \\<rightarrow>\n          \\<langle>A\\<rangle>textbuffer_rel \\<rightarrow> B", "by (auto simp: textbuffer_rel_def) parametricity"], ["", "context \n    notes[simp] = \n      empty_def get_text_def get_pos_def move_left_def move_right_def \n      insert_def delete_def conv_to_is_Nil\n  begin"], ["", "sepref_decl_op (no_def) empty :: \"\\<langle>A\\<rangle>textbuffer_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op (no_def) get_text :: \"\\<langle>A\\<rangle>textbuffer_rel \\<rightarrow> \\<langle>A\\<rangle>list_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op (no_def) get_pos :: \"\\<langle>A\\<rangle>textbuffer_rel \\<rightarrow> nat_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op (no_def) move_left :: \"\\<langle>A\\<rangle>textbuffer_rel \\<rightarrow> \\<langle>A\\<rangle>textbuffer_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op (no_def) move_right :: \"\\<langle>A\\<rangle>textbuffer_rel \\<rightarrow> \\<langle>A\\<rangle>textbuffer_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op (no_def) insert :: \"A\\<rightarrow>\\<langle>A\\<rangle>textbuffer_rel \\<rightarrow> \\<langle>A\\<rangle>textbuffer_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_decl_op (no_def) delete :: \"\\<langle>A\\<rangle>textbuffer_rel \\<rightarrow> \\<langle>A\\<rangle>textbuffer_rel\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "subsection \\<open>Refinement 1: List with Gap\\<close>"], ["", "subsection \\<open>Implementation on List-Level\\<close>"], ["", "type_synonym 'a gap_buffer = \"nat \\<times> nat \\<times> 'a list\""], ["", "subsubsection \\<open>Abstraction Relation\\<close>"], ["", "text \\<open>Also called coupling relation sometimes. \n    Can be any relation, here we define it by an invariant and an \n    abstraction function.  \\<close>"], ["", "definition \"gap_\\<alpha> \\<equiv> \\<lambda>(l,r,buf). BUF (take l buf) (drop r buf)\""], ["", "definition \"gap_invar \\<equiv> \\<lambda>(l,r,buf). l\\<le>r \\<and> r\\<le>length buf\""], ["", "abbreviation \"gap_rel \\<equiv> br gap_\\<alpha> gap_invar\""], ["", "subsubsection \\<open>Empty\\<close>"], ["", "definition \"empty1 \\<equiv> RETURN (0,0,[])\""], ["", "lemma empty1_correct: \"(empty1, RETURN empty) \\<in> \\<langle>gap_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (empty1, RETURN Challenge1.empty)\n    \\<in> \\<langle>gap_rel\\<rangle>nres_rel", "unfolding empty1_def empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN (0, 0, []), RETURN (BUF [] []))\n    \\<in> \\<langle>gap_rel\\<rangle>nres_rel", "apply refine_vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((0, 0, []), BUF [] []) \\<in> gap_rel", "by (auto simp: in_br_conv gap_\\<alpha>_def gap_invar_def)"], ["", "subsubsection \\<open>Left\\<close>"], ["", "definition \"move_left1 \\<equiv> \\<lambda>(l,r,buf). doN {\n    if l\\<noteq>0 then doN {\n      ASSERT(r-1<length buf \\<and> l-1<length buf);\n      RETURN (l-1,r-1,buf[r-1:=buf!(l-1)])\n    } else RETURN (l,r,buf)\n  }\""], ["", "lemma move_left1_correct: \n    \"(move_left1, RETURN o move_left) \\<in> gap_rel \\<rightarrow> \\<langle>gap_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (move_left1, RETURN \\<circ> move_left)\n    \\<in> gap_rel \\<rightarrow> \\<langle>gap_rel\\<rangle>nres_rel", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b a'.\n       ((a, aa, b), a') \\<in> gap_rel \\<Longrightarrow>\n       (move_left1 (a, aa, b), RETURN (move_left a'))\n       \\<in> \\<langle>gap_rel\\<rangle>nres_rel", "unfolding move_left1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b a'.\n       ((a, aa, b), a') \\<in> gap_rel \\<Longrightarrow>\n       (case (a, aa, b) of\n        (l, r, buf) \\<Rightarrow>\n          if l \\<noteq> 0\n          then ASSERT (r - 1 < length buf \\<and> l - 1 < length buf) \\<bind>\n               (\\<lambda>_.\n                   RETURN (l - 1, r - 1, buf[r - 1 := buf ! (l - 1)]))\n          else RETURN (l, r, buf),\n        RETURN (move_left a'))\n       \\<in> \\<langle>gap_rel\\<rangle>nres_rel", "apply refine_vcg"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a aa b a' ab ba ac bb.\n       \\<lbrakk>((a, aa, b), a') \\<in> gap_rel; (a, aa, b) = (ab, ba);\n        ba = (ac, bb); ab \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> ac - 1 < length bb\n 2. \\<And>a aa b a' ab ba ac bb.\n       \\<lbrakk>((a, aa, b), a') \\<in> gap_rel; (a, aa, b) = (ab, ba);\n        ba = (ac, bb); ab \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> ab - 1 < length bb\n 3. \\<And>a aa b a' ab ba ac bb.\n       \\<lbrakk>((a, aa, b), a') \\<in> gap_rel; (a, aa, b) = (ab, ba);\n        ba = (ac, bb); ab \\<noteq> 0;\n        ac - 1 < length bb \\<and> ab - 1 < length bb\\<rbrakk>\n       \\<Longrightarrow> ((ab - 1, ac - 1, bb[ac - 1 := bb ! (ab - 1)]),\n                          move_left a')\n                         \\<in> gap_rel\n 4. \\<And>a aa b a' ab ba ac bb.\n       \\<lbrakk>((a, aa, b), a') \\<in> gap_rel; (a, aa, b) = (ab, ba);\n        ba = (ac, bb); \\<not> ab \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> ((ab, ac, bb), move_left a') \\<in> gap_rel", "apply (auto \n      simp: in_br_conv gap_\\<alpha>_def gap_invar_def move_left1_def \n      split: prod.splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b ab.\n       \\<lbrakk>0 < ab; ab \\<le> aa; aa \\<le> length b;\n        aa - Suc 0 < length b; ab - Suc 0 < length b\\<rbrakk>\n       \\<Longrightarrow> butlast (take ab b) = take (ab - Suc 0) b\n 2. \\<And>aa b ab.\n       \\<lbrakk>0 < ab; ab \\<le> aa; aa \\<le> length b;\n        aa - Suc 0 < length b; ab - Suc 0 < length b\\<rbrakk>\n       \\<Longrightarrow> last (take ab b) # drop aa b =\n                         drop (aa - Suc 0)\n                          (b[aa - Suc 0 := b ! (ab - Suc 0)])", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < ab_; ab_ \\<le> aa_; aa_ \\<le> length b_;\n     aa_ - Suc 0 < length b_; ab_ - Suc 0 < length b_\\<rbrakk>\n    \\<Longrightarrow> butlast (take ab_ b_) = take (ab_ - Suc 0) b_", "by (simp add: butlast_take)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b ab.\n       \\<lbrakk>0 < ab; ab \\<le> aa; aa \\<le> length b;\n        aa - Suc 0 < length b; ab - Suc 0 < length b\\<rbrakk>\n       \\<Longrightarrow> last (take ab b) # drop aa b =\n                         drop (aa - Suc 0)\n                          (b[aa - Suc 0 := b ! (ab - Suc 0)])", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < ab_; ab_ \\<le> aa_; aa_ \\<le> length b_;\n     aa_ - Suc 0 < length b_; ab_ - Suc 0 < length b_\\<rbrakk>\n    \\<Longrightarrow> last (take ab_ b_) # drop aa_ b_ =\n                      drop (aa_ - Suc 0)\n                       (b_[aa_ - Suc 0 := b_ ! (ab_ - Suc 0)])", "by (smt Cons_nth_drop_Suc One_nat_def Suc_pred diff_Suc_less \n        drop_update_cancel last_take_nth_conv le_trans length_list_update \n        less_le_trans neq0_conv nth_list_update_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Right\\<close>"], ["", "definition \"move_right1 \\<equiv> \\<lambda>(l,r,buf). doN {\n    if r<length buf then doN {\n      ASSERT (l<length buf);\n      RETURN (l+1,r+1,buf[l:=buf!r])\n    } else RETURN (l,r,buf)\n  }\""], ["", "lemma move_right1_correct: \n    \"(move_right1,RETURN o move_right) \\<in> gap_rel \\<rightarrow> \\<langle>gap_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (move_right1, RETURN \\<circ> move_right)\n    \\<in> gap_rel \\<rightarrow> \\<langle>gap_rel\\<rangle>nres_rel", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b a'.\n       ((a, aa, b), a') \\<in> gap_rel \\<Longrightarrow>\n       (move_right1 (a, aa, b), RETURN (move_right a'))\n       \\<in> \\<langle>gap_rel\\<rangle>nres_rel", "unfolding move_right1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b a'.\n       ((a, aa, b), a') \\<in> gap_rel \\<Longrightarrow>\n       (case (a, aa, b) of\n        (l, r, buf) \\<Rightarrow>\n          if r < length buf\n          then ASSERT (l < length buf) \\<bind>\n               (\\<lambda>_. RETURN (l + 1, r + 1, buf[l := buf ! r]))\n          else RETURN (l, r, buf),\n        RETURN (move_right a'))\n       \\<in> \\<langle>gap_rel\\<rangle>nres_rel", "apply refine_vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa b a' ab ba ac bb.\n       \\<lbrakk>((a, aa, b), a') \\<in> gap_rel; (a, aa, b) = (ab, ba);\n        ba = (ac, bb); ac < length bb\\<rbrakk>\n       \\<Longrightarrow> ab < length bb\n 2. \\<And>a aa b a' ab ba ac bb.\n       \\<lbrakk>((a, aa, b), a') \\<in> gap_rel; (a, aa, b) = (ab, ba);\n        ba = (ac, bb); ac < length bb; ab < length bb\\<rbrakk>\n       \\<Longrightarrow> ((ab + 1, ac + 1, bb[ab := bb ! ac]),\n                          move_right a')\n                         \\<in> gap_rel\n 3. \\<And>a aa b a' ab ba ac bb.\n       \\<lbrakk>((a, aa, b), a') \\<in> gap_rel; (a, aa, b) = (ab, ba);\n        ba = (ac, bb); \\<not> ac < length bb\\<rbrakk>\n       \\<Longrightarrow> ((ab, ac, bb), move_right a') \\<in> gap_rel", "unfolding gap_\\<alpha>_def gap_invar_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa b a' ab ba ac bb.\n       \\<lbrakk>((a, aa, b), a')\n                \\<in> br (\\<lambda>(l, r, buf).\n                             BUF (take l buf) (drop r buf))\n                       (\\<lambda>(l, r, buf).\n                           l \\<le> r \\<and> r \\<le> length buf);\n        (a, aa, b) = (ab, ba); ba = (ac, bb); ac < length bb\\<rbrakk>\n       \\<Longrightarrow> ab < length bb\n 2. \\<And>a aa b a' ab ba ac bb.\n       \\<lbrakk>((a, aa, b), a')\n                \\<in> br (\\<lambda>(l, r, buf).\n                             BUF (take l buf) (drop r buf))\n                       (\\<lambda>(l, r, buf).\n                           l \\<le> r \\<and> r \\<le> length buf);\n        (a, aa, b) = (ab, ba); ba = (ac, bb); ac < length bb;\n        ab < length bb\\<rbrakk>\n       \\<Longrightarrow> ((ab + 1, ac + 1, bb[ab := bb ! ac]),\n                          move_right a')\n                         \\<in> br (\\<lambda>(l, r, buf).\nBUF (take l buf) (drop r buf))\n                                (\\<lambda>(l, r, buf).\n                                    l \\<le> r \\<and> r \\<le> length buf)\n 3. \\<And>a aa b a' ab ba ac bb.\n       \\<lbrakk>((a, aa, b), a')\n                \\<in> br (\\<lambda>(l, r, buf).\n                             BUF (take l buf) (drop r buf))\n                       (\\<lambda>(l, r, buf).\n                           l \\<le> r \\<and> r \\<le> length buf);\n        (a, aa, b) = (ab, ba); ba = (ac, bb); \\<not> ac < length bb\\<rbrakk>\n       \\<Longrightarrow> ((ab, ac, bb), move_right a')\n                         \\<in> br (\\<lambda>(l, r, buf).\nBUF (take l buf) (drop r buf))\n                                (\\<lambda>(l, r, buf).\n                                    l \\<le> r \\<and> r \\<le> length buf)", "apply (auto \n      simp: in_br_conv hd_drop_conv_nth take_update_last\n      split: prod.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b ab.\n       \\<lbrakk>ab \\<le> aa; aa < length b\\<rbrakk>\n       \\<Longrightarrow> tl (drop aa b) = drop (Suc aa) b", "by (simp add: drop_Suc tl_drop)"], ["", "subsubsection \\<open>Insert and Grow\\<close>"], ["", "definition \"can_insert \\<equiv> \\<lambda>(l,r,buf). l<r\""], ["", "definition \"grow1 K \\<equiv> \\<lambda>(l,r,buf). doN {\n    let b = op_array_replicate (length buf + K) default;\n    b \\<leftarrow> mop_list_blit buf 0 b 0 l;\n    b \\<leftarrow> mop_list_blit buf r b (r+K) (length buf - r);\n    RETURN (l,r+K,b)\n  }\""], ["", "lemma grow1_correct[THEN SPEC_trans, refine_vcg]:\n    assumes \"gap_invar gb\"\n    shows \"grow1 K gb  \\<le> (SPEC (\\<lambda>gb'. \n          gap_invar gb' \n        \\<and> gap_\\<alpha> gb' = gap_\\<alpha> gb \n        \\<and> (K>0 \\<longrightarrow> can_insert gb')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. grow1 K gb\n    \\<le> SPEC\n           (\\<lambda>gb'.\n               gap_invar gb' \\<and>\n               gap_\\<alpha> gb' = gap_\\<alpha> gb \\<and>\n               (0 < K \\<longrightarrow> can_insert gb'))", "unfolding grow1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case gb of\n     (l, r, buf) \\<Rightarrow>\n       let b = op_array_replicate (length buf + K) default\n       in mop_list_blit buf 0 b 0 l \\<bind>\n          (\\<lambda>b.\n              mop_list_blit buf r b (r + K) (length buf - r) \\<bind>\n              (\\<lambda>b. RETURN (l, r + K, b))))\n    \\<le> SPEC\n           (\\<lambda>gb'.\n               gap_invar gb' \\<and>\n               gap_\\<alpha> gb' = gap_\\<alpha> gb \\<and>\n               (0 < K \\<longrightarrow> can_insert gb'))", "apply refine_vcg"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> 0 + a \\<le> length ba\n 2. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> 0 + a\n                         \\<le> length\n                                (op_array_replicate (length ba + K) default)\n 3. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa + (length ba - aa) \\<le> length ba\n 4. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa + K + (length ba - aa)\n                         \\<le> length\n                                (op_list_blit ba 0\n                                  (op_array_replicate (length ba + K)\n                                    default)\n                                  0 a)\n 5. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> gap_invar\n                          (a, aa + K,\n                           op_list_blit ba aa\n                            (op_list_blit ba 0\n                              (op_array_replicate (length ba + K) default) 0\n                              a)\n                            (aa + K) (length ba - aa))\n 6. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> gap_\\<alpha>\n                          (a, aa + K,\n                           op_list_blit ba aa\n                            (op_list_blit ba 0\n                              (op_array_replicate (length ba + K) default) 0\n                              a)\n                            (aa + K) (length ba - aa)) =\n                         gap_\\<alpha> gb\n 7. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba); 0 < K\\<rbrakk>\n       \\<Longrightarrow> can_insert\n                          (a, aa + K,\n                           op_list_blit ba aa\n                            (op_list_blit ba 0\n                              (op_array_replicate (length ba + K) default) 0\n                              a)\n                            (aa + K) (length ba - aa))", "using assms"], ["proof (prove)\nusing this:\n  gap_invar gb\n\ngoal (7 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> 0 + a \\<le> length ba\n 2. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> 0 + a\n                         \\<le> length\n                                (op_array_replicate (length ba + K) default)\n 3. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa + (length ba - aa) \\<le> length ba\n 4. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa + K + (length ba - aa)\n                         \\<le> length\n                                (op_list_blit ba 0\n                                  (op_array_replicate (length ba + K)\n                                    default)\n                                  0 a)\n 5. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> gap_invar\n                          (a, aa + K,\n                           op_list_blit ba aa\n                            (op_list_blit ba 0\n                              (op_array_replicate (length ba + K) default) 0\n                              a)\n                            (aa + K) (length ba - aa))\n 6. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> gap_\\<alpha>\n                          (a, aa + K,\n                           op_list_blit ba aa\n                            (op_list_blit ba 0\n                              (op_array_replicate (length ba + K) default) 0\n                              a)\n                            (aa + K) (length ba - aa)) =\n                         gap_\\<alpha> gb\n 7. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba); 0 < K\\<rbrakk>\n       \\<Longrightarrow> can_insert\n                          (a, aa + K,\n                           op_list_blit ba aa\n                            (op_list_blit ba 0\n                              (op_array_replicate (length ba + K) default) 0\n                              a)\n                            (aa + K) (length ba - aa))", "unfolding gap_\\<alpha>_def gap_invar_def can_insert_def"], ["proof (prove)\nusing this:\n  case gb of (l, r, buf) \\<Rightarrow> l \\<le> r \\<and> r \\<le> length buf\n\ngoal (7 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> 0 + a \\<le> length ba\n 2. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> 0 + a\n                         \\<le> length\n                                (op_array_replicate (length ba + K) default)\n 3. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa + (length ba - aa) \\<le> length ba\n 4. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> aa + K + (length ba - aa)\n                         \\<le> length\n                                (op_list_blit ba 0\n                                  (op_array_replicate (length ba + K)\n                                    default)\n                                  0 a)\n 5. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> case (a, aa + K,\n                               op_list_blit ba aa\n                                (op_list_blit ba 0\n                                  (op_array_replicate (length ba + K)\n                                    default)\n                                  0 a)\n                                (aa + K) (length ba - aa)) of\n                         (l, r, buf) \\<Rightarrow>\n                           l \\<le> r \\<and> r \\<le> length buf\n 6. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> (case (a, aa + K,\n                                op_list_blit ba aa\n                                 (op_list_blit ba 0\n                                   (op_array_replicate (length ba + K)\n                                     default)\n                                   0 a)\n                                 (aa + K) (length ba - aa)) of\n                          (l, r, buf) \\<Rightarrow>\n                            BUF (take l buf) (drop r buf)) =\n                         (case gb of\n                          (l, r, buf) \\<Rightarrow>\n                            BUF (take l buf) (drop r buf))\n 7. \\<And>a b aa ba.\n       \\<lbrakk>gb = (a, b); b = (aa, ba); 0 < K\\<rbrakk>\n       \\<Longrightarrow> case (a, aa + K,\n                               op_list_blit ba aa\n                                (op_list_blit ba 0\n                                  (op_array_replicate (length ba + K)\n                                    default)\n                                  0 a)\n                                (aa + K) (length ba - aa)) of\n                         (l, r, buf) \\<Rightarrow> l < r", "apply (auto simp: op_list_blit_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"insert1 x \\<equiv> \\<lambda>(l,r,buf). doN {\n    (l,r,buf) \\<leftarrow> \n      if (l=r) then grow1 (length buf+1) (l,r,buf) else RETURN (l,r,buf);\n    ASSERT (l<length buf);\n    RETURN (l+1,r,buf[l:=x])\n  }\""], ["", "lemma insert1_correct: \n    \"(insert1,RETURN oo insert) \\<in> Id \\<rightarrow> gap_rel \\<rightarrow> \\<langle>gap_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (insert1, RETURN \\<circ>\\<circ> Challenge1.insert)\n    \\<in> Id \\<rightarrow>\n          gap_rel \\<rightarrow> \\<langle>gap_rel\\<rangle>nres_rel", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a' aa ab b a'a.\n       ((aa, ab, b), a'a) \\<in> gap_rel \\<Longrightarrow>\n       (insert1 a' (aa, ab, b), RETURN (Challenge1.insert a' a'a))\n       \\<in> \\<langle>gap_rel\\<rangle>nres_rel", "unfolding insert1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a' aa ab b a'a.\n       ((aa, ab, b), a'a) \\<in> gap_rel \\<Longrightarrow>\n       (case (aa, ab, b) of\n        (l, r, buf) \\<Rightarrow>\n          (if l = r then grow1 (length buf + 1) (l, r, buf)\n           else RETURN (l, r, buf)) \\<bind>\n          (\\<lambda>(l, r, buf).\n              ASSERT (l < length buf) \\<bind>\n              (\\<lambda>_. RETURN (l + 1, r, buf[l := a']))),\n        RETURN (Challenge1.insert a' a'a))\n       \\<in> \\<langle>gap_rel\\<rangle>nres_rel", "apply refine_vcg"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a' aa ab b a'a a ba ac bb.\n       \\<lbrakk>((aa, ab, b), a'a) \\<in> gap_rel; (aa, ab, b) = (a, ba);\n        ba = (ac, bb); a = ac\\<rbrakk>\n       \\<Longrightarrow> gap_invar (a, ac, bb)\n 2. \\<And>a' aa ab b a'a a ba ac bb x ad bc ae bd.\n       \\<lbrakk>((aa, ab, b), a'a) \\<in> gap_rel; (aa, ab, b) = (a, ba);\n        ba = (ac, bb); a = ac;\n        gap_invar x \\<and>\n        gap_\\<alpha> x = gap_\\<alpha> (a, ac, bb) \\<and>\n        (0 < length bb + 1 \\<longrightarrow> can_insert x);\n        x = (ad, bc); bc = (ae, bd)\\<rbrakk>\n       \\<Longrightarrow> ad < length bd\n 3. \\<And>a' aa ab b a'a a ba ac bb x ad bc ae bd.\n       \\<lbrakk>((aa, ab, b), a'a) \\<in> gap_rel; (aa, ab, b) = (a, ba);\n        ba = (ac, bb); a = ac;\n        gap_invar x \\<and>\n        gap_\\<alpha> x = gap_\\<alpha> (a, ac, bb) \\<and>\n        (0 < length bb + 1 \\<longrightarrow> can_insert x);\n        x = (ad, bc); bc = (ae, bd); ad < length bd\\<rbrakk>\n       \\<Longrightarrow> ((ad + 1, ae, bd[ad := a']),\n                          Challenge1.insert a' a'a)\n                         \\<in> gap_rel\n 4. \\<And>a' aa ab b a'a a ba ac bb ad bc ae bd.\n       \\<lbrakk>((aa, ab, b), a'a) \\<in> gap_rel; (aa, ab, b) = (a, ba);\n        ba = (ac, bb); a \\<noteq> ac; (a, ac, bb) = (ad, bc);\n        bc = (ae, bd)\\<rbrakk>\n       \\<Longrightarrow> ad < length bd\n 5. \\<And>a' aa ab b a'a a ba ac bb ad bc ae bd.\n       \\<lbrakk>((aa, ab, b), a'a) \\<in> gap_rel; (aa, ab, b) = (a, ba);\n        ba = (ac, bb); a \\<noteq> ac; (a, ac, bb) = (ad, bc); bc = (ae, bd);\n        ad < length bd\\<rbrakk>\n       \\<Longrightarrow> ((ad + 1, ae, bd[ad := a']),\n                          Challenge1.insert a' a'a)\n                         \\<in> gap_rel", "unfolding insert_def gap_\\<alpha>_def gap_invar_def can_insert_def"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a' aa ab b a'a a ba ac bb.\n       \\<lbrakk>((aa, ab, b), a'a)\n                \\<in> br (\\<lambda>(l, r, buf).\n                             BUF (take l buf) (drop r buf))\n                       (\\<lambda>(l, r, buf).\n                           l \\<le> r \\<and> r \\<le> length buf);\n        (aa, ab, b) = (a, ba); ba = (ac, bb); a = ac\\<rbrakk>\n       \\<Longrightarrow> case (a, ac, bb) of\n                         (l, r, buf) \\<Rightarrow>\n                           l \\<le> r \\<and> r \\<le> length buf\n 2. \\<And>a' aa ab b a'a a ba ac bb x ad bc ae bd.\n       \\<lbrakk>((aa, ab, b), a'a)\n                \\<in> br (\\<lambda>(l, r, buf).\n                             BUF (take l buf) (drop r buf))\n                       (\\<lambda>(l, r, buf).\n                           l \\<le> r \\<and> r \\<le> length buf);\n        (aa, ab, b) = (a, ba); ba = (ac, bb); a = ac;\n        (case x of\n         (l, r, buf) \\<Rightarrow>\n           l \\<le> r \\<and> r \\<le> length buf) \\<and>\n        (case x of\n         (l, r, buf) \\<Rightarrow> BUF (take l buf) (drop r buf)) =\n        (case (a, ac, bb) of\n         (l, r, buf) \\<Rightarrow> BUF (take l buf) (drop r buf)) \\<and>\n        (0 < length bb + 1 \\<longrightarrow>\n         (case x of (l, r, buf) \\<Rightarrow> l < r));\n        x = (ad, bc); bc = (ae, bd)\\<rbrakk>\n       \\<Longrightarrow> ad < length bd\n 3. \\<And>a' aa ab b a'a a ba ac bb x ad bc ae bd.\n       \\<lbrakk>((aa, ab, b), a'a)\n                \\<in> br (\\<lambda>(l, r, buf).\n                             BUF (take l buf) (drop r buf))\n                       (\\<lambda>(l, r, buf).\n                           l \\<le> r \\<and> r \\<le> length buf);\n        (aa, ab, b) = (a, ba); ba = (ac, bb); a = ac;\n        (case x of\n         (l, r, buf) \\<Rightarrow>\n           l \\<le> r \\<and> r \\<le> length buf) \\<and>\n        (case x of\n         (l, r, buf) \\<Rightarrow> BUF (take l buf) (drop r buf)) =\n        (case (a, ac, bb) of\n         (l, r, buf) \\<Rightarrow> BUF (take l buf) (drop r buf)) \\<and>\n        (0 < length bb + 1 \\<longrightarrow>\n         (case x of (l, r, buf) \\<Rightarrow> l < r));\n        x = (ad, bc); bc = (ae, bd); ad < length bd\\<rbrakk>\n       \\<Longrightarrow> ((ad + 1, ae, bd[ad := a']),\n                          rec_textbuffer (\\<lambda>a b x. BUF (a @ [x]) b)\n                           a'a a')\n                         \\<in> br (\\<lambda>(l, r, buf).\nBUF (take l buf) (drop r buf))\n                                (\\<lambda>(l, r, buf).\n                                    l \\<le> r \\<and> r \\<le> length buf)\n 4. \\<And>a' aa ab b a'a a ba ac bb ad bc ae bd.\n       \\<lbrakk>((aa, ab, b), a'a)\n                \\<in> br (\\<lambda>(l, r, buf).\n                             BUF (take l buf) (drop r buf))\n                       (\\<lambda>(l, r, buf).\n                           l \\<le> r \\<and> r \\<le> length buf);\n        (aa, ab, b) = (a, ba); ba = (ac, bb); a \\<noteq> ac;\n        (a, ac, bb) = (ad, bc); bc = (ae, bd)\\<rbrakk>\n       \\<Longrightarrow> ad < length bd\n 5. \\<And>a' aa ab b a'a a ba ac bb ad bc ae bd.\n       \\<lbrakk>((aa, ab, b), a'a)\n                \\<in> br (\\<lambda>(l, r, buf).\n                             BUF (take l buf) (drop r buf))\n                       (\\<lambda>(l, r, buf).\n                           l \\<le> r \\<and> r \\<le> length buf);\n        (aa, ab, b) = (a, ba); ba = (ac, bb); a \\<noteq> ac;\n        (a, ac, bb) = (ad, bc); bc = (ae, bd); ad < length bd\\<rbrakk>\n       \\<Longrightarrow> ((ad + 1, ae, bd[ad := a']),\n                          rec_textbuffer (\\<lambda>a b x. BUF (a @ [x]) b)\n                           a'a a')\n                         \\<in> br (\\<lambda>(l, r, buf).\nBUF (take l buf) (drop r buf))\n                                (\\<lambda>(l, r, buf).\n                                    l \\<le> r \\<and> r \\<le> length buf)", "apply (auto simp: in_br_conv take_update_last split: prod.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Delete\\<close>"], ["", "definition \"delete1 \n    \\<equiv> \\<lambda>(l,r,buf). if l>0 then RETURN (l-1,r,buf) else RETURN (l,r,buf)\""], ["", "lemma delete1_correct: \n    \"(delete1,RETURN o delete) \\<in> gap_rel \\<rightarrow> \\<langle>gap_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (delete1, RETURN \\<circ> delete)\n    \\<in> gap_rel \\<rightarrow> \\<langle>gap_rel\\<rangle>nres_rel", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b a'.\n       ((a, aa, b), a') \\<in> gap_rel \\<Longrightarrow>\n       (delete1 (a, aa, b), RETURN (delete a'))\n       \\<in> \\<langle>gap_rel\\<rangle>nres_rel", "unfolding delete1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b a'.\n       ((a, aa, b), a') \\<in> gap_rel \\<Longrightarrow>\n       (case (a, aa, b) of\n        (l, r, buf) \\<Rightarrow>\n          if 0 < l then RETURN (l - 1, r, buf) else RETURN (l, r, buf),\n        RETURN (delete a'))\n       \\<in> \\<langle>gap_rel\\<rangle>nres_rel", "apply refine_vcg"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa b a' ab ba ac bb.\n       \\<lbrakk>((a, aa, b), a') \\<in> gap_rel; (a, aa, b) = (ab, ba);\n        ba = (ac, bb); 0 < ab\\<rbrakk>\n       \\<Longrightarrow> ((ab - 1, ac, bb), delete a') \\<in> gap_rel\n 2. \\<And>a aa b a' ab ba ac bb.\n       \\<lbrakk>((a, aa, b), a') \\<in> gap_rel; (a, aa, b) = (ab, ba);\n        ba = (ac, bb); \\<not> 0 < ab\\<rbrakk>\n       \\<Longrightarrow> ((ab, ac, bb), delete a') \\<in> gap_rel", "unfolding gap_\\<alpha>_def gap_invar_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa b a' ab ba ac bb.\n       \\<lbrakk>((a, aa, b), a')\n                \\<in> br (\\<lambda>(l, r, buf).\n                             BUF (take l buf) (drop r buf))\n                       (\\<lambda>(l, r, buf).\n                           l \\<le> r \\<and> r \\<le> length buf);\n        (a, aa, b) = (ab, ba); ba = (ac, bb); 0 < ab\\<rbrakk>\n       \\<Longrightarrow> ((ab - 1, ac, bb), delete a')\n                         \\<in> br (\\<lambda>(l, r, buf).\nBUF (take l buf) (drop r buf))\n                                (\\<lambda>(l, r, buf).\n                                    l \\<le> r \\<and> r \\<le> length buf)\n 2. \\<And>a aa b a' ab ba ac bb.\n       \\<lbrakk>((a, aa, b), a')\n                \\<in> br (\\<lambda>(l, r, buf).\n                             BUF (take l buf) (drop r buf))\n                       (\\<lambda>(l, r, buf).\n                           l \\<le> r \\<and> r \\<le> length buf);\n        (a, aa, b) = (ab, ba); ba = (ac, bb); \\<not> 0 < ab\\<rbrakk>\n       \\<Longrightarrow> ((ab, ac, bb), delete a')\n                         \\<in> br (\\<lambda>(l, r, buf).\nBUF (take l buf) (drop r buf))\n                                (\\<lambda>(l, r, buf).\n                                    l \\<le> r \\<and> r \\<le> length buf)", "by (auto simp: in_br_conv butlast_take split: prod.split)"], ["", "subsection \\<open>Imperative Arrays and Executable Code\\<close>"], ["", "abbreviation \"gap_impl_assn \\<equiv> nat_assn \\<times>\\<^sub>a nat_assn \\<times>\\<^sub>a array_assn id_assn\""], ["", "definition \"gap_assn A \n    \\<equiv> hr_comp (hr_comp gap_impl_assn gap_rel) (\\<langle>the_pure A\\<rangle>textbuffer_rel)\""], ["", "context \n    notes gap_assn_def[symmetric,fcomp_norm_unfold] \n  begin"], ["", "sepref_definition empty_impl \n      is \"uncurry0 empty1\" :: \"unit_assn\\<^sup>k\\<rightarrow>\\<^sub>agap_impl_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 empty1)\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a gap_impl_assn", "unfolding empty1_def array.fold_custom_empty"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 (RETURN (0, 0, op_array_empty)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a gap_impl_assn", "by sepref"], ["", "sepref_decl_impl empty_impl: empty_impl.refine[FCOMP empty1_correct]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_definition move_left_impl \n      is move_left1 :: \"gap_impl_assn\\<^sup>d\\<rightarrow>\\<^sub>agap_impl_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, move_left1)\n    \\<in> gap_impl_assn\\<^sup>d \\<rightarrow>\\<^sub>a gap_impl_assn", "unfolding move_left1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>(l, r, buf).\n        if l \\<noteq> 0\n        then ASSERT (r - 1 < length buf \\<and> l - 1 < length buf) \\<bind>\n             (\\<lambda>_.\n                 RETURN (l - 1, r - 1, buf[r - 1 := buf ! (l - 1)]))\n        else RETURN (l, r, buf))\n    \\<in> gap_impl_assn\\<^sup>d \\<rightarrow>\\<^sub>a gap_impl_assn", "by sepref"], ["", "sepref_decl_impl move_left_impl: move_left_impl.refine[FCOMP move_left1_correct]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_definition move_right_impl \n      is move_right1 :: \"gap_impl_assn\\<^sup>d\\<rightarrow>\\<^sub>agap_impl_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, move_right1)\n    \\<in> gap_impl_assn\\<^sup>d \\<rightarrow>\\<^sub>a gap_impl_assn", "unfolding move_right1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>(l, r, buf).\n        if r < length buf\n        then ASSERT (l < length buf) \\<bind>\n             (\\<lambda>_. RETURN (l + 1, r + 1, buf[l := buf ! r]))\n        else RETURN (l, r, buf))\n    \\<in> gap_impl_assn\\<^sup>d \\<rightarrow>\\<^sub>a gap_impl_assn", "by sepref"], ["", "sepref_decl_impl move_right_impl: move_right_impl.refine[FCOMP move_right1_correct]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_definition insert_impl \n      is \"uncurry insert1\" :: \"id_assn\\<^sup>k*\\<^sub>agap_impl_assn\\<^sup>d\\<rightarrow>\\<^sub>agap_impl_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry insert1)\n    \\<in> id_assn\\<^sup>k *\\<^sub>a\n          gap_impl_assn\\<^sup>d \\<rightarrow>\\<^sub>a gap_impl_assn", "unfolding insert1_def grow1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>x (l, r, buf).\n          (if l = r\n           then case (l, r, buf) of\n                (l, r, bufa) \\<Rightarrow>\n                  let b = op_array_replicate\n                           (length bufa + (length buf + 1)) default\n                  in mop_list_blit bufa 0 b 0 l \\<bind>\n                     (\\<lambda>b.\n                         mop_list_blit bufa r b (r + (length buf + 1))\n                          (length bufa - r) \\<bind>\n                         (\\<lambda>b. RETURN (l, r + (length buf + 1), b)))\n           else RETURN (l, r, buf)) \\<bind>\n          (\\<lambda>(l, r, buf).\n              ASSERT (l < length buf) \\<bind>\n              (\\<lambda>_. RETURN (l + 1, r, buf[l := x])))))\n    \\<in> id_assn\\<^sup>k *\\<^sub>a\n          gap_impl_assn\\<^sup>d \\<rightarrow>\\<^sub>a gap_impl_assn", "by sepref \n      \\<comment> \\<open>We inline @{const grow1} here\\<close>"], ["", "sepref_decl_impl insert_impl: insert_impl.refine[FCOMP insert1_correct]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sepref_definition delete_impl \n      is delete1 :: \"gap_impl_assn\\<^sup>d\\<rightarrow>\\<^sub>agap_impl_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, delete1)\n    \\<in> gap_impl_assn\\<^sup>d \\<rightarrow>\\<^sub>a gap_impl_assn", "unfolding delete1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>(l, r, buf).\n        if 0 < l then RETURN (l - 1, r, buf) else RETURN (l, r, buf))\n    \\<in> gap_impl_assn\\<^sup>d \\<rightarrow>\\<^sub>a gap_impl_assn", "by sepref"], ["", "sepref_decl_impl delete_impl: delete_impl.refine[FCOMP delete1_correct]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "text \\<open>\n  The above setup generated the following refinement theorems, connecting the implementations\n  with our abstract specification:\n  @{thm [display]\n    empty_impl_hnr move_left_impl_hnr move_right_impl_hnr insert_impl_hnr delete_impl_hnr\n  }\n  \\<close>"], ["", "export_code move_left_impl move_right_impl insert_impl delete_impl  \n    in SML_imp module_name Gap_Buffer\n    in OCaml_imp module_name Gap_Buffer\n    in Haskell module_name Gap_Buffer\n    in Scala module_name Gap_Buffer"], ["", "subsection \\<open>Simple Client\\<close>"], ["", "definition \"client \\<equiv> RETURN (fold (\\<lambda>f. f) [\n    insert (1::int),\n    insert (2::int),\n    insert (3::int),\n    insert (5::int),\n    move_left,\n    insert (4::int),\n    move_right,\n    insert (6::int),\n    delete\n  ] empty)\""], ["", "lemma \"client \\<le> SPEC (\\<lambda>r. get_text r=[1,2,3,4,5])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. client \\<le> SPEC (\\<lambda>r. get_text r = [1, 2, 3, 4, 5])", "unfolding client_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN\n     (fold (\\<lambda>f. f)\n       [Challenge1.insert 1, Challenge1.insert 2, Challenge1.insert 3,\n        Challenge1.insert 5, move_left, Challenge1.insert 4, move_right,\n        Challenge1.insert 6, delete]\n       Challenge1.empty)\n    \\<le> SPEC (\\<lambda>r. get_text r = [1, 2, 3, 4, 5])", "by (simp add: delete_text insert_text)"], ["", "sepref_definition client_impl \n    is \"uncurry0 client\" :: \"unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a gap_assn id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 client)\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a gap_assn int_assn", "unfolding client_def fold.simps id_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2,\n     uncurry0\n      (RETURN\n        (delete\n          (Challenge1.insert 6\n            (move_right\n              (Challenge1.insert 4\n                (move_left\n                  (Challenge1.insert 5\n                    (Challenge1.insert 3\n                      (Challenge1.insert 2\n                        (Challenge1.insert 1 Challenge1.empty)))))))))))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a gap_assn int_assn", "by sepref"], ["", "ML_val \\<open>\n    @{code client_impl} () \n  \\<close>"], ["", "end"]]}