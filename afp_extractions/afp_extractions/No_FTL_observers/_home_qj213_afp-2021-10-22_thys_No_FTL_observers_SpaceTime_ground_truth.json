{"file_name": "/home/qj213/afp-2021-10-22/thys/No_FTL_observers/SpaceTime.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/No_FTL_observers", "problem_names": ["lemma lemVecZeroMinus:\n  shows \"0 \\<ominus> u = ~ u\"", "lemma lemVecSelfMinus:\n  shows \"u \\<ominus> u = 0\"", "lemma lemVecPlusCommute:\n  shows \"u \\<oplus> v = v \\<oplus> u\"", "lemma lemVecPlusAssoc:\n  shows \"u \\<oplus> (v \\<oplus> w) = (u \\<oplus> v) \\<oplus> w\"", "lemma lemVecPlusMinus:\n  shows \"u \\<oplus> (~ v)  = u \\<ominus> v\"", "lemma lemDotCommute: \n  shows \"(u dot v) = (v dot u)\"", "lemma lemMDotCommute: \n  shows \"(u mdot v) = (v mdot u)\"", "lemma lemScaleScale:\n  shows \"a**(b**u) = (a*b)**u\"", "lemma lemScale1:\n  shows \"1 ** u = u\"", "lemma lemScale0:\n  shows \"0 ** u = 0\"", "lemma lemScaleNeg:\n  shows \"(-k)**u = ~ (k**u)\"", "lemma lemScaleOrigin:\n  shows \"k**0 = 0\"", "lemma lemScaleOverAdd:\n  shows \"k**(u \\<oplus> v) = k**u \\<oplus> k**v\"", "lemma lemAddOverScale: \n  shows \"a**u \\<oplus> b**u = (a+b)**u\"", "lemma lemScaleInverse:\n  assumes \"k \\<noteq> (0::'a)\"\n    and   \"v = k**u\"\n  shows   \"u = (inverse k)**v\"", "lemma lemOrthoSym:\n  assumes \"u \\<bottom> v\"\n  shows \"v \\<bottom> u\"", "lemma lemFromToTo: \n    shows \"(from p to q) \\<oplus> (from q to r) = (from p to r)\"", "lemma lemMoveByMove: \n    shows \"p \\<leadsto> u \\<leadsto> v = p \\<leadsto> (u \\<oplus> v)\"", "lemma lemScaleLinear: \n    shows \"p \\<leadsto> a**u \\<leadsto> b**v = p \\<leadsto> (a**u \\<oplus> b**v)\"", "lemma lemParallelReflexive: \n    shows \"lineA \\<parallel> lineA\"", "lemma lemParallelSym: \n    assumes \"lineA \\<parallel> lineB\"\n    shows   \"lineB \\<parallel> lineA\"", "lemma lemParallelTrans: \n    assumes \"lineA \\<parallel> lineB\"\n      and   \"lineB \\<parallel> lineC\"\n      and   \"direction lineB \\<noteq> vecZero\"\n    shows   \"lineA \\<parallel> lineC\"", "lemma (in -) lemLineIdentity: \n    assumes \"lineA = \\<lparr> basepoint = basepoint lineB, direction = direction lineB \\<rparr>\"\n    shows \"lineA = lineB\"", "lemma lemDirectionJoining: \n    shows \"vectorJoining p (p \\<leadsto> v) = v\"", "lemma lemDirectionFromTo: \n    shows \"direction (line joining p to (p \\<leadsto> dir)) = dir\"", "lemma lemLineEndpoint: \n    shows \"q = p \\<leadsto> (from p to q)\"", "lemma lemNullLine:\n    assumes \"direction lineA = vecZero\" \n      and   \"inLine x lineA\"\n    shows   \"x = basepoint lineA\"", "lemma lemLineContainsBasepoint: \n    shows \"inLine p (line joining p to q)\"", "lemma lemLineContainsEndpoint: \n    shows \"inLine q (line joining p to q)\"", "lemma lemDirectionReverse: \n    shows \"from q to p = vecNegate (from p to q)\"", "lemma lemParallelJoin: \n    assumes \"line joining p to q \\<parallel> line joining q to r\"\n    shows  \"line joining p to q \\<parallel> line joining p to r\"", "lemma lemDirectionCollinear: \n    shows \"collinear u v (v \\<leadsto> d) \\<longleftrightarrow> (\\<exists>\\<beta>.(from u to v = (-\\<beta>)**d))\"", "lemma lemParallelNotMeet: \n    assumes \"lineA \\<parallel> lineB\"\n      and   \"direction lineA \\<noteq> vecZero\"\n      and   \"direction lineB \\<noteq> vecZero\"\n      and   \"inLine x lineA\"\n      and   \"\\<not>(inLine x lineB)\"\n    shows   \"\\<not>(meets lineA lineB)\"", "lemma lemAxisIsLine:\n    assumes \"onAxisT x\"\n      and   \"onAxisT y\"\n      and   \"onAxisT z\"\n      and   \"x \\<noteq> y\"\n      and   \"y \\<noteq> z\"\n      and   \"z \\<noteq> x\"\n    shows   \"collinear x y z\"", "lemma lemSpace2Sym: \n    shows \"space2 x y = space2 y x\"", "lemma lemTime2Sym: \n    shows \"time2 x y = time2 y x\"", "lemma lemPlaneContainsBasePoint: \n  shows \"inPlane (pbasepoint pl) pl\"", "lemma lemVertexOnCone: \n    shows \"onCone (vertex cone) cone\"", "lemma lemOutsideNotOnCone: \n    assumes \"outsideCone f cone\"\n    shows   \"\\<not> (onCone f cone)\""], "translations": [["", "lemma lemVecZeroMinus:\n  shows \"0 \\<ominus> u = ~ u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<ominus> u = ~ u", "by simp"], ["", "lemma lemVecSelfMinus:\n  shows \"u \\<ominus> u = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<ominus> u = 0", "by simp"], ["", "lemma lemVecPlusCommute:\n  shows \"u \\<oplus> v = v \\<oplus> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<oplus> v = v \\<oplus> u", "by (simp add: add.commute)"], ["", "lemma lemVecPlusAssoc:\n  shows \"u \\<oplus> (v \\<oplus> w) = (u \\<oplus> v) \\<oplus> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<oplus> v \\<oplus> w = (u \\<oplus> v) \\<oplus> w", "by (simp add: add.assoc)"], ["", "lemma lemVecPlusMinus:\n  shows \"u \\<oplus> (~ v)  = u \\<ominus> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<oplus> ~ v = u \\<ominus> v", "by (simp add: local.add_uminus_conv_diff)"], ["", "(*\n  Dot product commutes.\n*)"], ["", "lemma lemDotCommute: \n  shows \"(u dot v) = (v dot u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u dot v) = (v dot u)", "by (simp add: mult.commute)"], ["", "(*\n  Minkowski product commutes.\n*)"], ["", "lemma lemMDotCommute: \n  shows \"(u mdot v) = (v mdot u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u mdot v) = (v mdot u)", "by (simp add:mult.commute)"], ["", "(* Scaling can be done in stages *)"], ["", "lemma lemScaleScale:\n  shows \"a**(b**u) = (a*b)**u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a ** (b ** u) = (a * b) ** u", "by (simp add: mult.assoc)"], ["", "(* Scaling by 1 has no effect *)"], ["", "lemma lemScale1:\n  shows \"1 ** u = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) ** u = u", "by simp"], ["", "(* Scaling by 0 gives the null vector *)"], ["", "lemma lemScale0:\n  shows \"0 ** u = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) ** u = 0", "by simp"], ["", "(* Scaling by a negative value reverses *)"], ["", "lemma lemScaleNeg:\n  shows \"(-k)**u = ~ (k**u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- k) ** u = ~ k ** u", "by simp"], ["", "(* The null vector is invariant under scaling *)"], ["", "lemma lemScaleOrigin:\n  shows \"k**0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k ** 0 = 0", "by auto"], ["", "(* Scaling distributes over addition *)"], ["", "lemma lemScaleOverAdd:\n  shows \"k**(u \\<oplus> v) = k**u \\<oplus> k**v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k ** (u \\<oplus> v) = k ** u \\<oplus> k ** v", "by (simp add: semiring_normalization_rules(34))"], ["", "lemma lemAddOverScale: \n  shows \"a**u \\<oplus> b**u = (a+b)**u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a ** u \\<oplus> b ** u = (a + b) ** u", "by (simp add: semiring_normalization_rules(1))"], ["", "(* Scaling can be reversed *)"], ["", "lemma lemScaleInverse:\n  assumes \"k \\<noteq> (0::'a)\"\n    and   \"v = k**u\"\n  shows   \"u = (inverse k)**v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u = inverse k ** v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u = inverse k ** v", "have \"(inverse k)**v = (inverse k * k)**u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse k ** v = (inverse k * k) ** u", "by (simp add: lemScaleScale assms(2) mult.assoc)"], ["proof (state)\nthis:\n  inverse k ** v = (inverse k * k) ** u\n\ngoal (1 subgoal):\n 1. u = inverse k ** v", "thus ?thesis"], ["proof (prove)\nusing this:\n  inverse k ** v = (inverse k * k) ** u\n\ngoal (1 subgoal):\n 1. u = inverse k ** v", "by (metis (lifting) field_inverse assms(1) lemScale1)"], ["proof (state)\nthis:\n  u = inverse k ** v\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Being orthogonal is mutual *)"], ["", "lemma lemOrthoSym:\n  assumes \"u \\<bottom> v\"\n  shows \"v \\<bottom> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<bottom> u", "by (metis assms(1) lemDotCommute orthogonal.simps)"], ["", "end"], ["", "(*\n  Points have coordinates in the field of quantities.\n*)"], ["", "class Points = Quantities + Vectors\nbegin"], ["", "abbreviation origin :: \"'a Point\" where \n    \"origin \\<equiv> \\<lparr> tval = 0, xval = 0, yval = 0, zval = 0 \\<rparr>\""], ["", "fun vectorJoining :: \"'a Point \\<Rightarrow> 'a Point \\<Rightarrow> 'a Vector\" (\"from _ to _\") where\n    \"vectorJoining p q\n      = \\<lparr> tdir = tval q - tval p, xdir = xval q - xval p, \n          ydir = yval q - yval p, zdir = zval q - zval p \\<rparr>\""], ["", "fun moveBy :: \"'a Point \\<Rightarrow> 'a Vector \\<Rightarrow> 'a Point\" (infixl \"\\<leadsto>\" 100) where\n    \"moveBy p u \n      = \\<lparr> tval = tval p + tdir u, xval = xval p + xdir u, \n          yval = yval p + ydir u, zval = zval p + zdir u \\<rparr>\""], ["", "fun positionVector :: \"'a Point \\<Rightarrow> 'a Vector\" where\n    \"positionVector p = \\<lparr> tdir = tval p, xdir = xval p, ydir = yval p, zdir = zval p \\<rparr>\""], ["", "fun before :: \"'a Point \\<Rightarrow> 'a Point \\<Rightarrow> bool\" (infixr \"\\<lesssim>\" 100) where\n    \"before p q = (tval p < tval q)\""], ["", "fun after :: \"'a Point \\<Rightarrow> 'a Point \\<Rightarrow> bool\" (infixr \"\\<greatersim>\" 100) where\n    \"after p q = (tval p > tval q)\""], ["", "fun sametime :: \"'a Point \\<Rightarrow> 'a Point \\<Rightarrow> bool\" (infixr \"\\<approx>\" 100) where\n    \"sametime p q = (tval p = tval q)\""], ["", "lemma lemFromToTo: \n    shows \"(from p to q) \\<oplus> (from q to r) = (from p to r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from p to q \\<oplus> from q to r = from p to r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. from p to q \\<oplus> from q to r = from p to r", "have shared: \"\\<forall>valp valq valr.( valq - valp + (valr - valq) = valr - valp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>valp valq valr. valq - valp + (valr - valq) = valr - valp", "by (metis add_uminus_conv_diff add_diff_cancel \n                semiring_normalization_rules(24) semiring_normalization_rules(25))"], ["proof (state)\nthis:\n  \\<forall>valp valq valr. valq - valp + (valr - valq) = valr - valp\n\ngoal (1 subgoal):\n 1. from p to q \\<oplus> from q to r = from p to r", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>valp valq valr. valq - valp + (valr - valq) = valr - valp\n\ngoal (1 subgoal):\n 1. from p to q \\<oplus> from q to r = from p to r", "by auto"], ["proof (state)\nthis:\n  from p to q \\<oplus> from q to r = from p to r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lemMoveByMove: \n    shows \"p \\<leadsto> u \\<leadsto> v = p \\<leadsto> (u \\<oplus> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<leadsto> u \\<leadsto> v = p \\<leadsto> (u \\<oplus> v)", "by (simp add: add.assoc)"], ["", "lemma lemScaleLinear: \n    shows \"p \\<leadsto> a**u \\<leadsto> b**v = p \\<leadsto> (a**u \\<oplus> b**v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<leadsto> a ** u \\<leadsto> b ** v =\n    p \\<leadsto> (a ** u \\<oplus> b ** v)", "by (simp add: add.assoc)"], ["", "end"], ["", "(*\n  Lines are defined using a basepoint and a direction.\n*)"], ["", "class Lines = Quantities + Vectors + Points\nbegin"], ["", "fun onAxisT :: \"'a Point \\<Rightarrow> bool\" where\n     \"onAxisT u = ((xval u = 0) \\<and> (yval u = 0) \\<and> (zval u = 0))\""], ["", "fun space2 :: \"('a Point) \\<Rightarrow> ('a Point) \\<Rightarrow> 'a\" where\n    \"space2 u v \n      = (xval u - xval v)*(xval u - xval v) \n      + (yval u - yval v)*(yval u - yval v) \n      + (zval u - zval v)*(zval u - zval v)\""], ["", "fun time2 :: \"('a Point) \\<Rightarrow> ('a Point) \\<Rightarrow> 'a\" where\n    \"time2 u v = (tval u - tval v)*(tval u - tval v)\""], ["", "fun speed :: \"('a Point) \\<Rightarrow> ('a Point) \\<Rightarrow> 'a\" where\n    \"speed u v = (space2 u v /  time2 u v)\""], ["", "fun mkLine :: \"'a Point => 'a Vector \\<Rightarrow> 'a Line\" where\n    \"mkLine b d = \\<lparr> basepoint = b, direction = d \\<rparr>\""], ["", "fun lineJoining :: \"'a Point \\<Rightarrow> 'a Point \\<Rightarrow> 'a Line\" (\"line joining _ to _\") where\n    \"lineJoining p q = \\<lparr> basepoint = p, direction = from p to q \\<rparr>\""], ["", "fun parallel :: \"'a Line \\<Rightarrow> 'a Line \\<Rightarrow> bool\" (\"_ \\<parallel> \") where\n    \"parallel lineA lineB = ((direction lineA = vecZero) \\<or> (direction lineB = vecZero) \n                                   \\<or> (\\<exists>k.(k \\<noteq> (0::'a) \\<and> direction lineB = k**direction lineA)))\""], ["", "fun collinear :: \"'a Point \\<Rightarrow> 'a Point \\<Rightarrow> 'a Point \\<Rightarrow> bool\" where\n    \"collinear p q r = (\\<exists>\\<alpha> \\<beta>. ( (\\<alpha> + \\<beta> = 1)  \\<and>\n            positionVector p = \\<alpha>**(positionVector q) \\<oplus> \\<beta>**(positionVector r) ))\""], ["", "fun inLine :: \"'a Point \\<Rightarrow> 'a Line \\<Rightarrow> bool\" where\n    \"inLine p l = collinear p (basepoint l) (basepoint l \\<leadsto> direction l)\""], ["", "fun meets :: \"'a Line \\<Rightarrow> 'a Line \\<Rightarrow> bool\" where\n    \"meets line1 line2 = (\\<exists>p.(inLine p line1 \\<and> inLine p line2))\""], ["", "lemma lemParallelReflexive: \n    shows \"lineA \\<parallel> lineA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lineA \\<parallel>  lineA", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lineA \\<parallel>  lineA", "define dir where \"dir = direction lineA\""], ["proof (state)\nthis:\n  dir = direction lineA\n\ngoal (1 subgoal):\n 1. lineA \\<parallel>  lineA", "have \"(1 \\<noteq> 0) \\<and> (dir = 1**dir)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<noteq> (0::'a) \\<and> dir = (1::'a) ** dir", "by simp"], ["proof (state)\nthis:\n  (1::'a) \\<noteq> (0::'a) \\<and> dir = (1::'a) ** dir\n\ngoal (1 subgoal):\n 1. lineA \\<parallel>  lineA", "thus ?thesis"], ["proof (prove)\nusing this:\n  (1::'a) \\<noteq> (0::'a) \\<and> dir = (1::'a) ** dir\n\ngoal (1 subgoal):\n 1. lineA \\<parallel>  lineA", "by (metis dir_def parallel.simps)"], ["proof (state)\nthis:\n  lineA \\<parallel>  lineA\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lemParallelSym: \n    assumes \"lineA \\<parallel> lineB\"\n    shows   \"lineB \\<parallel> lineA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lineB \\<parallel>  lineA", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lineB \\<parallel>  lineA", "have case1: \"direction lineA = vecZero \\<longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. direction lineA = 0 \\<longrightarrow> lineB \\<parallel>  lineA", "by auto"], ["proof (state)\nthis:\n  direction lineA = 0 \\<longrightarrow> lineB \\<parallel>  lineA\n\ngoal (1 subgoal):\n 1. lineB \\<parallel>  lineA", "have case2: \"direction lineB = vecZero \\<longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. direction lineB = 0 \\<longrightarrow> lineB \\<parallel>  lineA", "by auto"], ["proof (state)\nthis:\n  direction lineB = 0 \\<longrightarrow> lineB \\<parallel>  lineA\n\ngoal (1 subgoal):\n 1. lineB \\<parallel>  lineA", "{"], ["proof (state)\nthis:\n  direction lineB = 0 \\<longrightarrow> lineB \\<parallel>  lineA\n\ngoal (1 subgoal):\n 1. lineB \\<parallel>  lineA", "assume case3: \"direction lineA \\<noteq> vecZero \\<and> direction lineB \\<noteq> vecZero\""], ["proof (state)\nthis:\n  direction lineA \\<noteq> 0 \\<and> direction lineB \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lineB \\<parallel>  lineA", "have exists_kab: \"\\<exists>kab.(kab \\<noteq> (0::'a) \\<and> direction lineB = kab**direction lineA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>kab.\n       kab \\<noteq> (0::'a) \\<and> direction lineB = kab ** direction lineA", "by (metis parallel.simps assms(1) case3)"], ["proof (state)\nthis:\n  \\<exists>kab.\n     kab \\<noteq> (0::'a) \\<and> direction lineB = kab ** direction lineA\n\ngoal (1 subgoal):\n 1. lineB \\<parallel>  lineA", "define kab where \"kab \\<equiv> (SOME kab.(kab \\<noteq> (0::'a) \\<and> direction lineB = kab**direction lineA))\""], ["proof (state)\nthis:\n  kab \\<equiv>\n  SOME kab.\n     kab \\<noteq> (0::'a) \\<and> direction lineB = kab ** direction lineA\n\ngoal (1 subgoal):\n 1. lineB \\<parallel>  lineA", "have kab_props: \"kab \\<noteq> 0 \\<and> direction lineB = kab**direction lineA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kab \\<noteq> (0::'a) \\<and> direction lineB = kab ** direction lineA", "using exists_kab kab_def"], ["proof (prove)\nusing this:\n  \\<exists>kab.\n     kab \\<noteq> (0::'a) \\<and> direction lineB = kab ** direction lineA\n  kab \\<equiv>\n  SOME kab.\n     kab \\<noteq> (0::'a) \\<and> direction lineB = kab ** direction lineA\n\ngoal (1 subgoal):\n 1. kab \\<noteq> (0::'a) \\<and> direction lineB = kab ** direction lineA", "by (rule Hilbert_Choice.exE_some)"], ["proof (state)\nthis:\n  kab \\<noteq> (0::'a) \\<and> direction lineB = kab ** direction lineA\n\ngoal (1 subgoal):\n 1. lineB \\<parallel>  lineA", "define kba where \"kba = inverse kab\""], ["proof (state)\nthis:\n  kba = inverse kab\n\ngoal (1 subgoal):\n 1. lineB \\<parallel>  lineA", "have kba_nonzero: \"kba \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kba \\<noteq> (0::'a)", "by (metis inverse_zero_imp_zero kab_props kba_def)"], ["proof (state)\nthis:\n  kba \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. lineB \\<parallel>  lineA", "have \"direction lineA = kba**direction lineB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. direction lineA = kba ** direction lineB", "by (metis kba_def lemScaleInverse kab_props)"], ["proof (state)\nthis:\n  direction lineA = kba ** direction lineB\n\ngoal (1 subgoal):\n 1. lineB \\<parallel>  lineA", "hence ?thesis"], ["proof (prove)\nusing this:\n  direction lineA = kba ** direction lineB\n\ngoal (1 subgoal):\n 1. lineB \\<parallel>  lineA", "by (metis kba_nonzero parallel.simps)"], ["proof (state)\nthis:\n  lineB \\<parallel>  lineA\n\ngoal (1 subgoal):\n 1. lineB \\<parallel>  lineA", "}"], ["proof (state)\nthis:\n  direction lineA \\<noteq> 0 \\<and>\n  direction lineB \\<noteq> 0 \\<Longrightarrow>\n  lineB \\<parallel>  lineA\n\ngoal (1 subgoal):\n 1. lineB \\<parallel>  lineA", "from this"], ["proof (chain)\npicking this:\n  direction lineA \\<noteq> 0 \\<and>\n  direction lineB \\<noteq> 0 \\<Longrightarrow>\n  lineB \\<parallel>  lineA", "have \"(direction lineA \\<noteq> vecZero \\<and> direction lineB \\<noteq> vecZero) \\<longrightarrow> ?thesis\""], ["proof (prove)\nusing this:\n  direction lineA \\<noteq> 0 \\<and>\n  direction lineB \\<noteq> 0 \\<Longrightarrow>\n  lineB \\<parallel>  lineA\n\ngoal (1 subgoal):\n 1. direction lineA \\<noteq> 0 \\<and>\n    direction lineB \\<noteq> 0 \\<longrightarrow>\n    lineB \\<parallel>  lineA", "by blast"], ["proof (state)\nthis:\n  direction lineA \\<noteq> 0 \\<and>\n  direction lineB \\<noteq> 0 \\<longrightarrow>\n  lineB \\<parallel>  lineA\n\ngoal (1 subgoal):\n 1. lineB \\<parallel>  lineA", "thus ?thesis"], ["proof (prove)\nusing this:\n  direction lineA \\<noteq> 0 \\<and>\n  direction lineB \\<noteq> 0 \\<longrightarrow>\n  lineB \\<parallel>  lineA\n\ngoal (1 subgoal):\n 1. lineB \\<parallel>  lineA", "by (metis case1 case2)"], ["proof (state)\nthis:\n  lineB \\<parallel>  lineA\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lemParallelTrans: \n    assumes \"lineA \\<parallel> lineB\"\n      and   \"lineB \\<parallel> lineC\"\n      and   \"direction lineB \\<noteq> vecZero\"\n    shows   \"lineA \\<parallel> lineC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lineA \\<parallel>  lineC", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lineA \\<parallel>  lineC", "have case1: \"direction lineA = vecZero \\<longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. direction lineA = 0 \\<longrightarrow> lineA \\<parallel>  lineC", "by auto"], ["proof (state)\nthis:\n  direction lineA = 0 \\<longrightarrow> lineA \\<parallel>  lineC\n\ngoal (1 subgoal):\n 1. lineA \\<parallel>  lineC", "have case2: \"direction lineC = vecZero \\<longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. direction lineC = 0 \\<longrightarrow> lineA \\<parallel>  lineC", "by auto"], ["proof (state)\nthis:\n  direction lineC = 0 \\<longrightarrow> lineA \\<parallel>  lineC\n\ngoal (1 subgoal):\n 1. lineA \\<parallel>  lineC", "{"], ["proof (state)\nthis:\n  direction lineC = 0 \\<longrightarrow> lineA \\<parallel>  lineC\n\ngoal (1 subgoal):\n 1. lineA \\<parallel>  lineC", "assume case3: \"direction lineA \\<noteq> vecZero \\<and> direction lineC \\<noteq> vecZero\""], ["proof (state)\nthis:\n  direction lineA \\<noteq> 0 \\<and> direction lineC \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lineA \\<parallel>  lineC", "have exists_kab: \"\\<exists>kab.(kab \\<noteq> (0::'a) \\<and> direction lineB = kab**direction lineA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>kab.\n       kab \\<noteq> (0::'a) \\<and> direction lineB = kab ** direction lineA", "by (metis parallel.simps assms(1) case3 assms(3))"], ["proof (state)\nthis:\n  \\<exists>kab.\n     kab \\<noteq> (0::'a) \\<and> direction lineB = kab ** direction lineA\n\ngoal (1 subgoal):\n 1. lineA \\<parallel>  lineC", "then"], ["proof (chain)\npicking this:\n  \\<exists>kab.\n     kab \\<noteq> (0::'a) \\<and> direction lineB = kab ** direction lineA", "obtain kab where kab_props: \"kab \\<noteq> 0 \\<and> direction lineB = kab**direction lineA\""], ["proof (prove)\nusing this:\n  \\<exists>kab.\n     kab \\<noteq> (0::'a) \\<and> direction lineB = kab ** direction lineA\n\ngoal (1 subgoal):\n 1. (\\<And>kab.\n        kab \\<noteq> (0::'a) \\<and>\n        direction lineB = kab ** direction lineA \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  kab \\<noteq> (0::'a) \\<and> direction lineB = kab ** direction lineA\n\ngoal (1 subgoal):\n 1. lineA \\<parallel>  lineC", "have exists_kbc: \"\\<exists>kbc.(kbc \\<noteq> (0::'a) \\<and> direction lineC = kbc**direction lineB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>kbc.\n       kbc \\<noteq> (0::'a) \\<and> direction lineC = kbc ** direction lineB", "by (metis parallel.simps assms(2) case3 assms(3))"], ["proof (state)\nthis:\n  \\<exists>kbc.\n     kbc \\<noteq> (0::'a) \\<and> direction lineC = kbc ** direction lineB\n\ngoal (1 subgoal):\n 1. lineA \\<parallel>  lineC", "then"], ["proof (chain)\npicking this:\n  \\<exists>kbc.\n     kbc \\<noteq> (0::'a) \\<and> direction lineC = kbc ** direction lineB", "obtain kbc where kbc_props: \"kbc \\<noteq> 0 \\<and> direction lineC = kbc**direction lineB\""], ["proof (prove)\nusing this:\n  \\<exists>kbc.\n     kbc \\<noteq> (0::'a) \\<and> direction lineC = kbc ** direction lineB\n\ngoal (1 subgoal):\n 1. (\\<And>kbc.\n        kbc \\<noteq> (0::'a) \\<and>\n        direction lineC = kbc ** direction lineB \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  kbc \\<noteq> (0::'a) \\<and> direction lineC = kbc ** direction lineB\n\ngoal (1 subgoal):\n 1. lineA \\<parallel>  lineC", "define kac where \"kac = kbc * kab\""], ["proof (state)\nthis:\n  kac = kbc * kab\n\ngoal (1 subgoal):\n 1. lineA \\<parallel>  lineC", "have kac_nonzero: \"kac \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kac \\<noteq> (0::'a)", "by (metis kab_props kac_def kbc_props no_zero_divisors)"], ["proof (state)\nthis:\n  kac \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. lineA \\<parallel>  lineC", "have \"direction lineC = kac**direction lineA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. direction lineC = kac ** direction lineA", "by (metis kab_props kbc_props kac_def lemScaleScale)"], ["proof (state)\nthis:\n  direction lineC = kac ** direction lineA\n\ngoal (1 subgoal):\n 1. lineA \\<parallel>  lineC", "hence ?thesis"], ["proof (prove)\nusing this:\n  direction lineC = kac ** direction lineA\n\ngoal (1 subgoal):\n 1. lineA \\<parallel>  lineC", "by (metis kac_nonzero parallel.simps)"], ["proof (state)\nthis:\n  lineA \\<parallel>  lineC\n\ngoal (1 subgoal):\n 1. lineA \\<parallel>  lineC", "}"], ["proof (state)\nthis:\n  direction lineA \\<noteq> 0 \\<and>\n  direction lineC \\<noteq> 0 \\<Longrightarrow>\n  lineA \\<parallel>  lineC\n\ngoal (1 subgoal):\n 1. lineA \\<parallel>  lineC", "from this"], ["proof (chain)\npicking this:\n  direction lineA \\<noteq> 0 \\<and>\n  direction lineC \\<noteq> 0 \\<Longrightarrow>\n  lineA \\<parallel>  lineC", "have \"(direction lineA \\<noteq> vecZero \\<and> direction lineC \\<noteq> vecZero) \\<longrightarrow> ?thesis\""], ["proof (prove)\nusing this:\n  direction lineA \\<noteq> 0 \\<and>\n  direction lineC \\<noteq> 0 \\<Longrightarrow>\n  lineA \\<parallel>  lineC\n\ngoal (1 subgoal):\n 1. direction lineA \\<noteq> 0 \\<and>\n    direction lineC \\<noteq> 0 \\<longrightarrow>\n    lineA \\<parallel>  lineC", "by blast"], ["proof (state)\nthis:\n  direction lineA \\<noteq> 0 \\<and>\n  direction lineC \\<noteq> 0 \\<longrightarrow>\n  lineA \\<parallel>  lineC\n\ngoal (1 subgoal):\n 1. lineA \\<parallel>  lineC", "thus ?thesis"], ["proof (prove)\nusing this:\n  direction lineA \\<noteq> 0 \\<and>\n  direction lineC \\<noteq> 0 \\<longrightarrow>\n  lineA \\<parallel>  lineC\n\ngoal (1 subgoal):\n 1. lineA \\<parallel>  lineC", "by (metis case1 case2)"], ["proof (state)\nthis:\n  lineA \\<parallel>  lineC\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in -) lemLineIdentity: \n    assumes \"lineA = \\<lparr> basepoint = basepoint lineB, direction = direction lineB \\<rparr>\"\n    shows \"lineA = lineB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lineA = lineB", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lineA = lineB", "have \"basepoint lineA = basepoint lineB \\<and> direction lineA = direction lineB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basepoint lineA = basepoint lineB \\<and>\n    direction lineA = direction lineB", "by (simp add: assms(1))"], ["proof (state)\nthis:\n  basepoint lineA = basepoint lineB \\<and> direction lineA = direction lineB\n\ngoal (1 subgoal):\n 1. lineA = lineB", "thus ?thesis"], ["proof (prove)\nusing this:\n  basepoint lineA = basepoint lineB \\<and> direction lineA = direction lineB\n\ngoal (1 subgoal):\n 1. lineA = lineB", "by simp"], ["proof (state)\nthis:\n  lineA = lineB\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lemDirectionJoining: \n    shows \"vectorJoining p (p \\<leadsto> v) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from p to p \\<leadsto> v = v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. from p to p \\<leadsto> v = v", "have \"\\<forall>a b.(a + b - a = b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b. a + b - a = b", "by (metis add_uminus_conv_diff diff_add_cancel semiring_normalization_rules(24))"], ["proof (state)\nthis:\n  \\<forall>a b. a + b - a = b\n\ngoal (1 subgoal):\n 1. from p to p \\<leadsto> v = v", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>a b. a + b - a = b\n\ngoal (1 subgoal):\n 1. from p to p \\<leadsto> v = v", "by auto"], ["proof (state)\nthis:\n  from p to p \\<leadsto> v = v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lemDirectionFromTo: \n    shows \"direction (line joining p to (p \\<leadsto> dir)) = dir\""], ["proof (prove)\ngoal (1 subgoal):\n 1. direction line joining p to p \\<leadsto> dir = dir", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. direction line joining p to p \\<leadsto> dir = dir", "have \"direction (line joining p to (p \\<leadsto> dir)) = from p to (p \\<leadsto> dir)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. direction line joining p to p \\<leadsto> dir =\n    from p to p \\<leadsto> dir", "by simp"], ["proof (state)\nthis:\n  direction line joining p to p \\<leadsto> dir = from p to p \\<leadsto> dir\n\ngoal (1 subgoal):\n 1. direction line joining p to p \\<leadsto> dir = dir", "thus ?thesis"], ["proof (prove)\nusing this:\n  direction line joining p to p \\<leadsto> dir = from p to p \\<leadsto> dir\n\ngoal (1 subgoal):\n 1. direction line joining p to p \\<leadsto> dir = dir", "by (metis lemDirectionJoining)"], ["proof (state)\nthis:\n  direction line joining p to p \\<leadsto> dir = dir\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lemLineEndpoint: \n    shows \"q = p \\<leadsto> (from p to q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q = p \\<leadsto> from p to q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. q = p \\<leadsto> from p to q", "have \"\\<forall>a b. (b = a + (b - a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b. b = a + (b - a)", "by (metis diff_add_cancel semiring_normalization_rules(24))"], ["proof (state)\nthis:\n  \\<forall>a b. b = a + (b - a)\n\ngoal (1 subgoal):\n 1. q = p \\<leadsto> from p to q", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>a b. b = a + (b - a)\n\ngoal (1 subgoal):\n 1. q = p \\<leadsto> from p to q", "by auto"], ["proof (state)\nthis:\n  q = p \\<leadsto> from p to q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lemNullLine:\n    assumes \"direction lineA = vecZero\" \n      and   \"inLine x lineA\"\n    shows   \"x = basepoint lineA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = basepoint lineA", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = basepoint lineA", "define bp where \"bp = basepoint lineA\""], ["proof (state)\nthis:\n  bp = basepoint lineA\n\ngoal (1 subgoal):\n 1. x = basepoint lineA", "have \"collinear x (basepoint lineA) (basepoint lineA \\<leadsto> direction lineA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collinear x (basepoint lineA)\n     (basepoint lineA \\<leadsto> direction lineA)", "by (metis inLine.simps assms(2))"], ["proof (state)\nthis:\n  collinear x (basepoint lineA) (basepoint lineA \\<leadsto> direction lineA)\n\ngoal (1 subgoal):\n 1. x = basepoint lineA", "hence \"collinear x bp (bp \\<leadsto> vecZero)\""], ["proof (prove)\nusing this:\n  collinear x (basepoint lineA) (basepoint lineA \\<leadsto> direction lineA)\n\ngoal (1 subgoal):\n 1. collinear x bp (bp \\<leadsto> 0)", "by (metis bp_def  assms(1))"], ["proof (state)\nthis:\n  collinear x bp (bp \\<leadsto> 0)\n\ngoal (1 subgoal):\n 1. x = basepoint lineA", "hence \"collinear x bp bp\""], ["proof (prove)\nusing this:\n  collinear x bp (bp \\<leadsto> 0)\n\ngoal (1 subgoal):\n 1. collinear x bp bp", "by simp"], ["proof (state)\nthis:\n  collinear x bp bp\n\ngoal (1 subgoal):\n 1. x = basepoint lineA", "hence \"\\<exists>a b.( (a + b = 1) \\<and>  \n                  (positionVector x = a**(positionVector bp) \\<oplus> b**(positionVector bp)) )\""], ["proof (prove)\nusing this:\n  collinear x bp bp\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a + b = (1::'a) \\<and>\n       positionVector x =\n       a ** positionVector bp \\<oplus> b ** positionVector bp", "by (metis collinear.simps)"], ["proof (state)\nthis:\n  \\<exists>a b.\n     a + b = (1::'a) \\<and>\n     positionVector x =\n     a ** positionVector bp \\<oplus> b ** positionVector bp\n\ngoal (1 subgoal):\n 1. x = basepoint lineA", "hence \"positionVector x = positionVector bp\""], ["proof (prove)\nusing this:\n  \\<exists>a b.\n     a + b = (1::'a) \\<and>\n     positionVector x =\n     a ** positionVector bp \\<oplus> b ** positionVector bp\n\ngoal (1 subgoal):\n 1. positionVector x = positionVector bp", "by (metis lemScale1 lemAddOverScale)"], ["proof (state)\nthis:\n  positionVector x = positionVector bp\n\ngoal (1 subgoal):\n 1. x = basepoint lineA", "thus ?thesis"], ["proof (prove)\nusing this:\n  positionVector x = positionVector bp\n\ngoal (1 subgoal):\n 1. x = basepoint lineA", "by (simp add: bp_def)"], ["proof (state)\nthis:\n  x = basepoint lineA\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lemLineContainsBasepoint: \n    shows \"inLine p (line joining p to q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inLine p line joining p to q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inLine p line joining p to q", "define linePQ where \"linePQ = line joining p to q\""], ["proof (state)\nthis:\n  linePQ = line joining p to q\n\ngoal (1 subgoal):\n 1. inLine p line joining p to q", "have bp: \"basepoint linePQ = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basepoint linePQ = p", "by (simp add: linePQ_def)"], ["proof (state)\nthis:\n  basepoint linePQ = p\n\ngoal (1 subgoal):\n 1. inLine p line joining p to q", "have dir: \"direction linePQ = from p to q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. direction linePQ = from p to q", "by (simp add: linePQ_def)"], ["proof (state)\nthis:\n  direction linePQ = from p to q\n\ngoal (1 subgoal):\n 1. inLine p line joining p to q", "have endq: \"basepoint linePQ \\<leadsto> direction linePQ = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basepoint linePQ \\<leadsto> direction linePQ = q", "by (metis bp dir lemLineEndpoint)"], ["proof (state)\nthis:\n  basepoint linePQ \\<leadsto> direction linePQ = q\n\ngoal (1 subgoal):\n 1. inLine p line joining p to q", "have \"(1 + 0 = 1)  \\<and> (positionVector p = 1**(positionVector p) \\<oplus> 0**(positionVector q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) + (0::'a) = (1::'a) \\<and>\n    positionVector p =\n    (1::'a) ** positionVector p \\<oplus> (0::'a) ** positionVector q", "by auto"], ["proof (state)\nthis:\n  (1::'a) + (0::'a) = (1::'a) \\<and>\n  positionVector p =\n  (1::'a) ** positionVector p \\<oplus> (0::'a) ** positionVector q\n\ngoal (1 subgoal):\n 1. inLine p line joining p to q", "hence \"collinear p p q\""], ["proof (prove)\nusing this:\n  (1::'a) + (0::'a) = (1::'a) \\<and>\n  positionVector p =\n  (1::'a) ** positionVector p \\<oplus> (0::'a) ** positionVector q\n\ngoal (1 subgoal):\n 1. collinear p p q", "by (metis collinear.simps)"], ["proof (state)\nthis:\n  collinear p p q\n\ngoal (1 subgoal):\n 1. inLine p line joining p to q", "hence \"collinear p (basepoint linePQ) (basepoint linePQ \\<leadsto> direction linePQ)\""], ["proof (prove)\nusing this:\n  collinear p p q\n\ngoal (1 subgoal):\n 1. collinear p (basepoint linePQ)\n     (basepoint linePQ \\<leadsto> direction linePQ)", "by (metis bp endq)"], ["proof (state)\nthis:\n  collinear p (basepoint linePQ)\n   (basepoint linePQ \\<leadsto> direction linePQ)\n\ngoal (1 subgoal):\n 1. inLine p line joining p to q", "thus ?thesis"], ["proof (prove)\nusing this:\n  collinear p (basepoint linePQ)\n   (basepoint linePQ \\<leadsto> direction linePQ)\n\ngoal (1 subgoal):\n 1. inLine p line joining p to q", "by (simp add: linePQ_def)"], ["proof (state)\nthis:\n  inLine p line joining p to q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lemLineContainsEndpoint: \n    shows \"inLine q (line joining p to q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inLine q line joining p to q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inLine q line joining p to q", "define linePQ where \"linePQ = line joining p to q\""], ["proof (state)\nthis:\n  linePQ = line joining p to q\n\ngoal (1 subgoal):\n 1. inLine q line joining p to q", "have bp: \"basepoint linePQ = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basepoint linePQ = p", "by (simp add: linePQ_def)"], ["proof (state)\nthis:\n  basepoint linePQ = p\n\ngoal (1 subgoal):\n 1. inLine q line joining p to q", "have dir: \"direction linePQ = from p to q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. direction linePQ = from p to q", "by (simp add: linePQ_def)"], ["proof (state)\nthis:\n  direction linePQ = from p to q\n\ngoal (1 subgoal):\n 1. inLine q line joining p to q", "have endq: \"basepoint linePQ \\<leadsto> direction linePQ = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. basepoint linePQ \\<leadsto> direction linePQ = q", "by (metis bp dir lemLineEndpoint)"], ["proof (state)\nthis:\n  basepoint linePQ \\<leadsto> direction linePQ = q\n\ngoal (1 subgoal):\n 1. inLine q line joining p to q", "have \"(0 + 1 = 1)  \\<and> (positionVector q = 0**(positionVector p) \\<oplus> 1**(positionVector q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) + (1::'a) = (1::'a) \\<and>\n    positionVector q =\n    (0::'a) ** positionVector p \\<oplus> (1::'a) ** positionVector q", "by auto"], ["proof (state)\nthis:\n  (0::'a) + (1::'a) = (1::'a) \\<and>\n  positionVector q =\n  (0::'a) ** positionVector p \\<oplus> (1::'a) ** positionVector q\n\ngoal (1 subgoal):\n 1. inLine q line joining p to q", "hence \"collinear q p q\""], ["proof (prove)\nusing this:\n  (0::'a) + (1::'a) = (1::'a) \\<and>\n  positionVector q =\n  (0::'a) ** positionVector p \\<oplus> (1::'a) ** positionVector q\n\ngoal (1 subgoal):\n 1. collinear q p q", "by (metis collinear.simps)"], ["proof (state)\nthis:\n  collinear q p q\n\ngoal (1 subgoal):\n 1. inLine q line joining p to q", "hence \"collinear q (basepoint linePQ) (basepoint linePQ \\<leadsto> direction linePQ)\""], ["proof (prove)\nusing this:\n  collinear q p q\n\ngoal (1 subgoal):\n 1. collinear q (basepoint linePQ)\n     (basepoint linePQ \\<leadsto> direction linePQ)", "by (metis bp endq)"], ["proof (state)\nthis:\n  collinear q (basepoint linePQ)\n   (basepoint linePQ \\<leadsto> direction linePQ)\n\ngoal (1 subgoal):\n 1. inLine q line joining p to q", "thus ?thesis"], ["proof (prove)\nusing this:\n  collinear q (basepoint linePQ)\n   (basepoint linePQ \\<leadsto> direction linePQ)\n\ngoal (1 subgoal):\n 1. inLine q line joining p to q", "by (simp add: linePQ_def)"], ["proof (state)\nthis:\n  inLine q line joining p to q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lemDirectionReverse: \n    shows \"from q to p = vecNegate (from p to q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from q to p = ~ from p to q", "by simp"], ["", "lemma lemParallelJoin: \n    assumes \"line joining p to q \\<parallel> line joining q to r\"\n    shows  \"line joining p to q \\<parallel> line joining p to r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "define linePQ where \"linePQ = line joining p to q\""], ["proof (state)\nthis:\n  linePQ = line joining p to q\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "define lineQR where \"lineQR = line joining q to r\""], ["proof (state)\nthis:\n  lineQR = line joining q to r\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "define linePR where \"linePR = line joining p to r\""], ["proof (state)\nthis:\n  linePR = line joining p to r\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "have case1: \"(direction linePQ = vecZero) \\<longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. direction linePQ = 0 \\<longrightarrow>\n    line joining p to q \\<parallel>  line joining p to r", "by (simp add: linePQ_def)"], ["proof (state)\nthis:\n  direction linePQ = 0 \\<longrightarrow>\n  line joining p to q \\<parallel>  line joining p to r\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "have case2: \"(direction linePR = vecZero) \\<longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. direction linePR = 0 \\<longrightarrow>\n    line joining p to q \\<parallel>  line joining p to r", "by (simp add: linePR_def)"], ["proof (state)\nthis:\n  direction linePR = 0 \\<longrightarrow>\n  line joining p to q \\<parallel>  line joining p to r\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "{"], ["proof (state)\nthis:\n  direction linePR = 0 \\<longrightarrow>\n  line joining p to q \\<parallel>  line joining p to r\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "assume case3: \"direction linePQ \\<noteq> vecZero \\<and> direction linePR \\<noteq> vecZero\""], ["proof (state)\nthis:\n  direction linePQ \\<noteq> 0 \\<and> direction linePR \\<noteq> 0\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "{"], ["proof (state)\nthis:\n  direction linePQ \\<noteq> 0 \\<and> direction linePR \\<noteq> 0\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "assume case3a: \"direction lineQR = vecZero\""], ["proof (state)\nthis:\n  direction lineQR = 0\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "have \"inLine r lineQR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inLine r lineQR", "by (metis lemLineContainsEndpoint lineQR_def)"], ["proof (state)\nthis:\n  inLine r lineQR\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "hence \"r = basepoint lineQR\""], ["proof (prove)\nusing this:\n  inLine r lineQR\n\ngoal (1 subgoal):\n 1. r = basepoint lineQR", "by (metis lemNullLine case3a)"], ["proof (state)\nthis:\n  r = basepoint lineQR\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "hence \"r = q\""], ["proof (prove)\nusing this:\n  r = basepoint lineQR\n\ngoal (1 subgoal):\n 1. r = q", "by (simp add: lineQR_def)"], ["proof (state)\nthis:\n  r = q\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "hence \"linePQ = linePR\""], ["proof (prove)\nusing this:\n  r = q\n\ngoal (1 subgoal):\n 1. linePQ = linePR", "by (simp add: linePQ_def linePR_def)"], ["proof (state)\nthis:\n  linePQ = linePR\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "hence ?thesis"], ["proof (prove)\nusing this:\n  linePQ = linePR\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "by (metis lemParallelReflexive linePQ_def linePR_def)"], ["proof (state)\nthis:\n  line joining p to q \\<parallel>  line joining p to r\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "}"], ["proof (state)\nthis:\n  direction lineQR = 0 \\<Longrightarrow>\n  line joining p to q \\<parallel>  line joining p to r\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "from this"], ["proof (chain)\npicking this:\n  direction lineQR = 0 \\<Longrightarrow>\n  line joining p to q \\<parallel>  line joining p to r", "have rtp3a: \"direction lineQR = vecZero \\<longrightarrow> ?thesis\""], ["proof (prove)\nusing this:\n  direction lineQR = 0 \\<Longrightarrow>\n  line joining p to q \\<parallel>  line joining p to r\n\ngoal (1 subgoal):\n 1. direction lineQR = 0 \\<longrightarrow>\n    line joining p to q \\<parallel>  line joining p to r", "by blast"], ["proof (state)\nthis:\n  direction lineQR = 0 \\<longrightarrow>\n  line joining p to q \\<parallel>  line joining p to r\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "{"], ["proof (state)\nthis:\n  direction lineQR = 0 \\<longrightarrow>\n  line joining p to q \\<parallel>  line joining p to r\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "assume case3b: \"direction lineQR \\<noteq> vecZero\""], ["proof (state)\nthis:\n  direction lineQR \\<noteq> 0\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "define dirPQ where \"dirPQ = from p to q\""], ["proof (state)\nthis:\n  dirPQ = from p to q\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "have dir_pq: \"direction linePQ = dirPQ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. direction linePQ = dirPQ", "by (simp add: linePQ_def dirPQ_def)"], ["proof (state)\nthis:\n  direction linePQ = dirPQ\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "define dirQR where \"dirQR = from q to r\""], ["proof (state)\nthis:\n  dirQR = from q to r\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "have dir_qr: \"direction lineQR = dirQR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. direction lineQR = dirQR", "by (simp add: lineQR_def dirQR_def)"], ["proof (state)\nthis:\n  direction lineQR = dirQR\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "have exists_k: \"\\<exists>k.(k \\<noteq> 0 \\<and> direction lineQR = k**direction linePQ)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k.\n       k \\<noteq> (0::'a) \\<and> direction lineQR = k ** direction linePQ", "by (metis linePQ_def lineQR_def assms(1) parallel.simps case3b case3)"], ["proof (state)\nthis:\n  \\<exists>k.\n     k \\<noteq> (0::'a) \\<and> direction lineQR = k ** direction linePQ\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "then"], ["proof (chain)\npicking this:\n  \\<exists>k.\n     k \\<noteq> (0::'a) \\<and> direction lineQR = k ** direction linePQ", "obtain k where k_props: \"k \\<noteq> 0 \\<and> dirQR= k**dirPQ\""], ["proof (prove)\nusing this:\n  \\<exists>k.\n     k \\<noteq> (0::'a) \\<and> direction lineQR = k ** direction linePQ\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        k \\<noteq> (0::'a) \\<and> dirQR = k ** dirPQ \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis dir_pq dir_qr)"], ["proof (state)\nthis:\n  k \\<noteq> (0::'a) \\<and> dirQR = k ** dirPQ\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "define scalar where \"scalar = 1+k\""], ["proof (state)\nthis:\n  scalar = (1::'a) + k\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "have \"q = p \\<leadsto> dirPQ \\<and> r = q \\<leadsto> dirQR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q = p \\<leadsto> dirPQ \\<and> r = q \\<leadsto> dirQR", "by (metis lemLineEndpoint dirPQ_def dirQR_def)"], ["proof (state)\nthis:\n  q = p \\<leadsto> dirPQ \\<and> r = q \\<leadsto> dirQR\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "hence \"r = p \\<leadsto> dirPQ \\<leadsto> (k**dirPQ)\""], ["proof (prove)\nusing this:\n  q = p \\<leadsto> dirPQ \\<and> r = q \\<leadsto> dirQR\n\ngoal (1 subgoal):\n 1. r = p \\<leadsto> dirPQ \\<leadsto> k ** dirPQ", "by (metis k_props)"], ["proof (state)\nthis:\n  r = p \\<leadsto> dirPQ \\<leadsto> k ** dirPQ\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "hence scalarPR: \"r = p \\<leadsto> scalar**dirPQ\""], ["proof (prove)\nusing this:\n  r = p \\<leadsto> dirPQ \\<leadsto> k ** dirPQ\n\ngoal (1 subgoal):\n 1. r = p \\<leadsto> scalar ** dirPQ", "by (metis lemScaleLinear lemScale1 lemAddOverScale scalar_def)"], ["proof (state)\nthis:\n  r = p \\<leadsto> scalar ** dirPQ\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "{"], ["proof (state)\nthis:\n  r = p \\<leadsto> scalar ** dirPQ\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "assume scalar0: \"scalar = 0\""], ["proof (state)\nthis:\n  scalar = (0::'a)\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "have \"r = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r = p", "by (simp add: lemScale0 scalarPR scalar0)"], ["proof (state)\nthis:\n  r = p\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "hence \"direction linePR = vecZero\""], ["proof (prove)\nusing this:\n  r = p\n\ngoal (1 subgoal):\n 1. direction linePR = 0", "by (simp add: linePR_def)"], ["proof (state)\nthis:\n  direction linePR = 0\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "hence \"False\""], ["proof (prove)\nusing this:\n  direction linePR = 0\n\ngoal (1 subgoal):\n 1. False", "by (metis case3)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "}"], ["proof (state)\nthis:\n  scalar = (0::'a) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "from this"], ["proof (chain)\npicking this:\n  scalar = (0::'a) \\<Longrightarrow> False", "have scalar_nonzero: \"scalar \\<noteq> 0\""], ["proof (prove)\nusing this:\n  scalar = (0::'a) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. scalar \\<noteq> (0::'a)", "by blast"], ["proof (state)\nthis:\n  scalar \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "have \"linePR = line joining p to (p \\<leadsto> scalar**dirPQ)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linePR = line joining p to p \\<leadsto> scalar ** dirPQ", "by (simp add: linePR_def scalarPR)"], ["proof (state)\nthis:\n  linePR = line joining p to p \\<leadsto> scalar ** dirPQ\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "hence \"direction linePR = scalar**dirPQ\""], ["proof (prove)\nusing this:\n  linePR = line joining p to p \\<leadsto> scalar ** dirPQ\n\ngoal (1 subgoal):\n 1. direction linePR = scalar ** dirPQ", "by (metis lemDirectionFromTo)"], ["proof (state)\nthis:\n  direction linePR = scalar ** dirPQ\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "hence scalar_props: \"scalar \\<noteq> 0 \\<and> direction linePR = scalar**direction linePQ\""], ["proof (prove)\nusing this:\n  direction linePR = scalar ** dirPQ\n\ngoal (1 subgoal):\n 1. scalar \\<noteq> (0::'a) \\<and>\n    direction linePR = scalar ** direction linePQ", "by (metis scalar_nonzero dir_pq)"], ["proof (state)\nthis:\n  scalar \\<noteq> (0::'a) \\<and>\n  direction linePR = scalar ** direction linePQ\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "hence ?thesis"], ["proof (prove)\nusing this:\n  scalar \\<noteq> (0::'a) \\<and>\n  direction linePR = scalar ** direction linePQ\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "by (metis parallel.simps linePR_def linePQ_def)"], ["proof (state)\nthis:\n  line joining p to q \\<parallel>  line joining p to r\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "}"], ["proof (state)\nthis:\n  direction lineQR \\<noteq> 0 \\<Longrightarrow>\n  line joining p to q \\<parallel>  line joining p to r\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "from this"], ["proof (chain)\npicking this:\n  direction lineQR \\<noteq> 0 \\<Longrightarrow>\n  line joining p to q \\<parallel>  line joining p to r", "have \"direction lineQR \\<noteq> vecZero \\<longrightarrow> ?thesis\""], ["proof (prove)\nusing this:\n  direction lineQR \\<noteq> 0 \\<Longrightarrow>\n  line joining p to q \\<parallel>  line joining p to r\n\ngoal (1 subgoal):\n 1. direction lineQR \\<noteq> 0 \\<longrightarrow>\n    line joining p to q \\<parallel>  line joining p to r", "by blast"], ["proof (state)\nthis:\n  direction lineQR \\<noteq> 0 \\<longrightarrow>\n  line joining p to q \\<parallel>  line joining p to r\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "hence ?thesis"], ["proof (prove)\nusing this:\n  direction lineQR \\<noteq> 0 \\<longrightarrow>\n  line joining p to q \\<parallel>  line joining p to r\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "by (metis rtp3a)"], ["proof (state)\nthis:\n  line joining p to q \\<parallel>  line joining p to r\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "}"], ["proof (state)\nthis:\n  direction linePQ \\<noteq> 0 \\<and>\n  direction linePR \\<noteq> 0 \\<Longrightarrow>\n  line joining p to q \\<parallel>  line joining p to r\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "from this"], ["proof (chain)\npicking this:\n  direction linePQ \\<noteq> 0 \\<and>\n  direction linePR \\<noteq> 0 \\<Longrightarrow>\n  line joining p to q \\<parallel>  line joining p to r", "have \"(direction linePQ \\<noteq> vecZero \\<and> direction linePR \\<noteq> vecZero) \\<longrightarrow> ?thesis\""], ["proof (prove)\nusing this:\n  direction linePQ \\<noteq> 0 \\<and>\n  direction linePR \\<noteq> 0 \\<Longrightarrow>\n  line joining p to q \\<parallel>  line joining p to r\n\ngoal (1 subgoal):\n 1. direction linePQ \\<noteq> 0 \\<and>\n    direction linePR \\<noteq> 0 \\<longrightarrow>\n    line joining p to q \\<parallel>  line joining p to r", "by blast"], ["proof (state)\nthis:\n  direction linePQ \\<noteq> 0 \\<and>\n  direction linePR \\<noteq> 0 \\<longrightarrow>\n  line joining p to q \\<parallel>  line joining p to r\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "thus ?thesis"], ["proof (prove)\nusing this:\n  direction linePQ \\<noteq> 0 \\<and>\n  direction linePR \\<noteq> 0 \\<longrightarrow>\n  line joining p to q \\<parallel>  line joining p to r\n\ngoal (1 subgoal):\n 1. line joining p to q \\<parallel>  line joining p to r", "by (metis case1 case2)"], ["proof (state)\nthis:\n  line joining p to q \\<parallel>  line joining p to r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lemDirectionCollinear: \n    shows \"collinear u v (v \\<leadsto> d) \\<longleftrightarrow> (\\<exists>\\<beta>.(from u to v = (-\\<beta>)**d))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) =\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) =\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "have basic1: \"\\<forall>u v.(positionVector (u \\<leadsto> v)) = (positionVector u) \\<oplus> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u v.\n       positionVector (u \\<leadsto> v) = positionVector u \\<oplus> v", "by simp"], ["proof (state)\nthis:\n  \\<forall>u v.\n     positionVector (u \\<leadsto> v) = positionVector u \\<oplus> v\n\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) =\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "have basic2: \"\\<forall>u v w.(u = v \\<oplus> w \\<longrightarrow> v \\<ominus> u = vecNegate w )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u v w. u = v \\<oplus> w \\<longrightarrow> v \\<ominus> u = ~ w", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v w. tdir v - (tdir v + tdir w) = - tdir w\n 2. \\<And>v w. xdir v - (xdir v + xdir w) = - xdir w\n 3. \\<And>v w. ydir v - (ydir v + ydir w) = - ydir w\n 4. \\<And>v w. zdir v - (zdir v + zdir w) = - zdir w", "by    (metis add_uminus_conv_diff diff_add_cancel minus_add \n              semiring_normalization_rules(24)) +"], ["proof (state)\nthis:\n  \\<forall>u v w. u = v \\<oplus> w \\<longrightarrow> v \\<ominus> u = ~ w\n\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) =\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "have basic3: \"\\<forall>u v.(from u to v = positionVector v \\<ominus> positionVector u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u v. from u to v = positionVector v \\<ominus> positionVector u", "by simp"], ["proof (state)\nthis:\n  \\<forall>u v. from u to v = positionVector v \\<ominus> positionVector u\n\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) =\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "have basic4: \"\\<forall>u v w.(v \\<ominus> u = vecNegate w \\<longrightarrow> u = v \\<oplus> w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u v w. v \\<ominus> u = ~ w \\<longrightarrow> u = v \\<oplus> w", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u v w.\n       \\<lbrakk>tdir v - tdir u = - tdir w; xdir v - xdir u = - xdir w;\n        ydir v - ydir u = - ydir w; zdir v - zdir u = - zdir w\\<rbrakk>\n       \\<Longrightarrow> u =\n                         \\<lparr>tdir = tdir v + tdir w,\n                            xdir = xdir v + xdir w, ydir = ydir v + ydir w,\n                            zdir = zdir v + zdir w\\<rparr>", "by (metis add_uminus_conv_diff diff_add_cancel lemScale1 mult.left_neutral \n          semiring_normalization_rules(24) vecScale.simps)"], ["proof (state)\nthis:\n  \\<forall>u v w. v \\<ominus> u = ~ w \\<longrightarrow> u = v \\<oplus> w\n\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) =\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "{"], ["proof (state)\nthis:\n  \\<forall>u v w. v \\<ominus> u = ~ w \\<longrightarrow> u = v \\<oplus> w\n\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) =\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "assume assm: \"collinear u v (v \\<leadsto> d)\""], ["proof (state)\nthis:\n  collinear u v (v \\<leadsto> d)\n\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) =\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "have \"\\<exists>\\<alpha> \\<beta>. ( (\\<alpha> + \\<beta> = 1)  \\<and>\n         positionVector u = \\<alpha>**(positionVector v) \\<oplus> \\<beta>**(positionVector (v \\<leadsto> d)) )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha> \\<beta>.\n       \\<alpha> + \\<beta> = (1::'a) \\<and>\n       positionVector u =\n       \\<alpha> ** positionVector v \\<oplus>\n       \\<beta> ** positionVector (v \\<leadsto> d)", "by (metis assm collinear.simps)"], ["proof (state)\nthis:\n  \\<exists>\\<alpha> \\<beta>.\n     \\<alpha> + \\<beta> = (1::'a) \\<and>\n     positionVector u =\n     \\<alpha> ** positionVector v \\<oplus>\n     \\<beta> ** positionVector (v \\<leadsto> d)\n\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) =\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<alpha> \\<beta>.\n     \\<alpha> + \\<beta> = (1::'a) \\<and>\n     positionVector u =\n     \\<alpha> ** positionVector v \\<oplus>\n     \\<beta> ** positionVector (v \\<leadsto> d)", "obtain \\<alpha> \\<beta> where props: \"(\\<alpha> + \\<beta> = 1)  \\<and>\n              positionVector u = \\<alpha>**(positionVector v) \\<oplus> \\<beta>**(positionVector (v \\<leadsto> d))\""], ["proof (prove)\nusing this:\n  \\<exists>\\<alpha> \\<beta>.\n     \\<alpha> + \\<beta> = (1::'a) \\<and>\n     positionVector u =\n     \\<alpha> ** positionVector v \\<oplus>\n     \\<beta> ** positionVector (v \\<leadsto> d)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha> \\<beta>.\n        \\<alpha> + \\<beta> = (1::'a) \\<and>\n        positionVector u =\n        \\<alpha> ** positionVector v \\<oplus>\n        \\<beta> ** positionVector (v \\<leadsto> d) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<alpha> + \\<beta> = (1::'a) \\<and>\n  positionVector u =\n  \\<alpha> ** positionVector v \\<oplus>\n  \\<beta> ** positionVector (v \\<leadsto> d)\n\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) =\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "hence \"positionVector u = 1**(positionVector v) \\<oplus> \\<beta>**d\""], ["proof (prove)\nusing this:\n  \\<alpha> + \\<beta> = (1::'a) \\<and>\n  positionVector u =\n  \\<alpha> ** positionVector v \\<oplus>\n  \\<beta> ** positionVector (v \\<leadsto> d)\n\ngoal (1 subgoal):\n 1. positionVector u = (1::'a) ** positionVector v \\<oplus> \\<beta> ** d", "by (metis basic1 lemScaleOverAdd lemVecPlusAssoc lemAddOverScale props)"], ["proof (state)\nthis:\n  positionVector u = (1::'a) ** positionVector v \\<oplus> \\<beta> ** d\n\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) =\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "hence \"positionVector u = positionVector v \\<oplus> \\<beta>**d\""], ["proof (prove)\nusing this:\n  positionVector u = (1::'a) ** positionVector v \\<oplus> \\<beta> ** d\n\ngoal (1 subgoal):\n 1. positionVector u = positionVector v \\<oplus> \\<beta> ** d", "by (metis lemScale1)"], ["proof (state)\nthis:\n  positionVector u = positionVector v \\<oplus> \\<beta> ** d\n\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) =\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "hence \"positionVector v \\<ominus> positionVector u = (-\\<beta>)**d\""], ["proof (prove)\nusing this:\n  positionVector u = positionVector v \\<oplus> \\<beta> ** d\n\ngoal (1 subgoal):\n 1. positionVector v \\<ominus> positionVector u = (- \\<beta>) ** d", "by (metis basic2 lemScaleNeg)"], ["proof (state)\nthis:\n  positionVector v \\<ominus> positionVector u = (- \\<beta>) ** d\n\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) =\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "hence \"\\<exists>\\<beta>.(from u to v = (-\\<beta>)**d)\""], ["proof (prove)\nusing this:\n  positionVector v \\<ominus> positionVector u = (- \\<beta>) ** d\n\ngoal (1 subgoal):\n 1. \\<exists>\\<beta>. from u to v = (- \\<beta>) ** d", "by (metis basic3)"], ["proof (state)\nthis:\n  \\<exists>\\<beta>. from u to v = (- \\<beta>) ** d\n\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) =\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "}"], ["proof (state)\nthis:\n  collinear u v (v \\<leadsto> d) \\<Longrightarrow>\n  \\<exists>\\<beta>. from u to v = (- \\<beta>) ** d\n\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) =\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "from this"], ["proof (chain)\npicking this:\n  collinear u v (v \\<leadsto> d) \\<Longrightarrow>\n  \\<exists>\\<beta>. from u to v = (- \\<beta>) ** d", "have fwd: \"collinear u v (v \\<leadsto> d) \\<longrightarrow> (\\<exists>\\<beta>.(from u to v = (-\\<beta>)**d))\""], ["proof (prove)\nusing this:\n  collinear u v (v \\<leadsto> d) \\<Longrightarrow>\n  \\<exists>\\<beta>. from u to v = (- \\<beta>) ** d\n\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) \\<longrightarrow>\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "by blast"], ["proof (state)\nthis:\n  collinear u v (v \\<leadsto> d) \\<longrightarrow>\n  (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)\n\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) =\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "{"], ["proof (state)\nthis:\n  collinear u v (v \\<leadsto> d) \\<longrightarrow>\n  (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)\n\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) =\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "assume \"\\<exists>\\<beta>.(from u to v = (-\\<beta>)**d)\""], ["proof (state)\nthis:\n  \\<exists>\\<beta>. from u to v = (- \\<beta>) ** d\n\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) =\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<beta>. from u to v = (- \\<beta>) ** d", "obtain \\<beta> where assm: \"from u to v = (-\\<beta>)**d\""], ["proof (prove)\nusing this:\n  \\<exists>\\<beta>. from u to v = (- \\<beta>) ** d\n\ngoal (1 subgoal):\n 1. (\\<And>\\<beta>.\n        from u to v = (- \\<beta>) ** d \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  from u to v = (- \\<beta>) ** d\n\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) =\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "define \\<alpha> where \"\\<alpha> = 1 - \\<beta>\""], ["proof (state)\nthis:\n  \\<alpha> = (1::'a) - \\<beta>\n\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) =\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "have \\<alpha>\\<beta>_sum: \"\\<alpha> + \\<beta> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> + \\<beta> = (1::'a)", "by (simp add: \\<alpha>_def)"], ["proof (state)\nthis:\n  \\<alpha> + \\<beta> = (1::'a)\n\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) =\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "have \"from u to v = vecNegate (\\<beta>**d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from u to v = ~ \\<beta> ** d", "by (metis assm lemScaleNeg)"], ["proof (state)\nthis:\n  from u to v = ~ \\<beta> ** d\n\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) =\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "hence \"positionVector v \\<ominus> positionVector u = vecNegate (\\<beta>**d)\""], ["proof (prove)\nusing this:\n  from u to v = ~ \\<beta> ** d\n\ngoal (1 subgoal):\n 1. positionVector v \\<ominus> positionVector u = ~ \\<beta> ** d", "by auto"], ["proof (state)\nthis:\n  positionVector v \\<ominus> positionVector u = ~ \\<beta> ** d\n\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) =\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "hence \"positionVector u = positionVector v \\<oplus> \\<beta>**d\""], ["proof (prove)\nusing this:\n  positionVector v \\<ominus> positionVector u = ~ \\<beta> ** d\n\ngoal (1 subgoal):\n 1. positionVector u = positionVector v \\<oplus> \\<beta> ** d", "by (metis basic4)"], ["proof (state)\nthis:\n  positionVector u = positionVector v \\<oplus> \\<beta> ** d\n\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) =\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "hence \"positionVector u = 1**(positionVector v) \\<oplus> \\<beta>**d\""], ["proof (prove)\nusing this:\n  positionVector u = positionVector v \\<oplus> \\<beta> ** d\n\ngoal (1 subgoal):\n 1. positionVector u = (1::'a) ** positionVector v \\<oplus> \\<beta> ** d", "by (metis lemScale1)"], ["proof (state)\nthis:\n  positionVector u = (1::'a) ** positionVector v \\<oplus> \\<beta> ** d\n\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) =\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "hence \"(\\<alpha> + \\<beta> = 1)  \\<and>\n            positionVector u = \\<alpha>**(positionVector v) \\<oplus> \\<beta>**(positionVector (v \\<leadsto> d))\""], ["proof (prove)\nusing this:\n  positionVector u = (1::'a) ** positionVector v \\<oplus> \\<beta> ** d\n\ngoal (1 subgoal):\n 1. \\<alpha> + \\<beta> = (1::'a) \\<and>\n    positionVector u =\n    \\<alpha> ** positionVector v \\<oplus>\n    \\<beta> ** positionVector (v \\<leadsto> d)", "by (metis \\<alpha>\\<beta>_sum basic1 lemScaleOverAdd lemVecPlusAssoc lemAddOverScale)"], ["proof (state)\nthis:\n  \\<alpha> + \\<beta> = (1::'a) \\<and>\n  positionVector u =\n  \\<alpha> ** positionVector v \\<oplus>\n  \\<beta> ** positionVector (v \\<leadsto> d)\n\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) =\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "hence \"collinear u v (v \\<leadsto> d)\""], ["proof (prove)\nusing this:\n  \\<alpha> + \\<beta> = (1::'a) \\<and>\n  positionVector u =\n  \\<alpha> ** positionVector v \\<oplus>\n  \\<beta> ** positionVector (v \\<leadsto> d)\n\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d)", "by auto"], ["proof (state)\nthis:\n  collinear u v (v \\<leadsto> d)\n\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) =\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "}"], ["proof (state)\nthis:\n  \\<exists>\\<beta>. from u to v = (- \\<beta>) ** d \\<Longrightarrow>\n  collinear u v (v \\<leadsto> d)\n\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) =\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>\\<beta>. from u to v = (- \\<beta>) ** d \\<Longrightarrow>\n  collinear u v (v \\<leadsto> d)", "have \"(\\<exists>\\<beta>.(from u to v = (-\\<beta>)**d)) \\<longrightarrow> collinear u v (v \\<leadsto> d)\""], ["proof (prove)\nusing this:\n  \\<exists>\\<beta>. from u to v = (- \\<beta>) ** d \\<Longrightarrow>\n  collinear u v (v \\<leadsto> d)\n\ngoal (1 subgoal):\n 1. (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d) \\<longrightarrow>\n    collinear u v (v \\<leadsto> d)", "by blast"], ["proof (state)\nthis:\n  (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d) \\<longrightarrow>\n  collinear u v (v \\<leadsto> d)\n\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) =\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d) \\<longrightarrow>\n  collinear u v (v \\<leadsto> d)\n\ngoal (1 subgoal):\n 1. collinear u v (v \\<leadsto> d) =\n    (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)", "by (metis fwd)"], ["proof (state)\nthis:\n  collinear u v (v \\<leadsto> d) =\n  (\\<exists>\\<beta>. from u to v = (- \\<beta>) ** d)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lemParallelNotMeet: \n    assumes \"lineA \\<parallel> lineB\"\n      and   \"direction lineA \\<noteq> vecZero\"\n      and   \"direction lineB \\<noteq> vecZero\"\n      and   \"inLine x lineA\"\n      and   \"\\<not>(inLine x lineB)\"\n    shows   \"\\<not>(meets lineA lineB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "have basic: \"\\<forall>p q v a.(from p to q = a**v \\<longrightarrow> from q to p = (-a)**v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p q v a.\n       from p to q = a ** v \\<longrightarrow> from q to p = (- a) ** v", "apply (simp add: lemScaleNeg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p q v a.\n       tval q - tval p = a * tdir v \\<and>\n       xval q - xval p = a * xdir v \\<and>\n       yval q - yval p = a * ydir v \\<and>\n       zval q - zval p = a * zdir v \\<longrightarrow>\n       tval p - tval q = - (a * tdir v) \\<and>\n       xval p - xval q = - (a * xdir v) \\<and>\n       yval p - yval q = - (a * ydir v) \\<and>\n       zval p - zval q = - (a * zdir v)", "by (metis minus_diff_eq)"], ["proof (state)\nthis:\n  \\<forall>p q v a.\n     from p to q = a ** v \\<longrightarrow> from q to p = (- a) ** v\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "define bpA where \"bpA = basepoint lineA\""], ["proof (state)\nthis:\n  bpA = basepoint lineA\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "define dirA where \"dirA = direction lineA\""], ["proof (state)\nthis:\n  dirA = direction lineA\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "define bpB where \"bpB = basepoint lineB\""], ["proof (state)\nthis:\n  bpB = basepoint lineB\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "define dirB where \"dirB = direction lineB\""], ["proof (state)\nthis:\n  dirB = direction lineB\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "(* lineA is parallel to lineB *)"], ["proof (state)\nthis:\n  dirB = direction lineB\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "have \"lineB \\<parallel> lineA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lineB \\<parallel>  lineA", "by (metis lemParallelSym assms(1))"], ["proof (state)\nthis:\n  lineB \\<parallel>  lineA\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "hence exists_kab: \"\\<exists>kab.(kab \\<noteq> (0::'a) \\<and> direction lineA = kab**direction lineB)\""], ["proof (prove)\nusing this:\n  lineB \\<parallel>  lineA\n\ngoal (1 subgoal):\n 1. \\<exists>kab.\n       kab \\<noteq> (0::'a) \\<and> direction lineA = kab ** direction lineB", "by (metis parallel.simps assms(2) assms(3))"], ["proof (state)\nthis:\n  \\<exists>kab.\n     kab \\<noteq> (0::'a) \\<and> direction lineA = kab ** direction lineB\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "then"], ["proof (chain)\npicking this:\n  \\<exists>kab.\n     kab \\<noteq> (0::'a) \\<and> direction lineA = kab ** direction lineB", "obtain kab where kab_props: \"kab \\<noteq> 0 \\<and> dirA = kab**dirB\""], ["proof (prove)\nusing this:\n  \\<exists>kab.\n     kab \\<noteq> (0::'a) \\<and> direction lineA = kab ** direction lineB\n\ngoal (1 subgoal):\n 1. (\\<And>kab.\n        kab \\<noteq> (0::'a) \\<and> dirA = kab ** dirB \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis dirA_def dirB_def)"], ["proof (state)\nthis:\n  kab \\<noteq> (0::'a) \\<and> dirA = kab ** dirB\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "(* x is in lineA *)"], ["proof (state)\nthis:\n  kab \\<noteq> (0::'a) \\<and> dirA = kab ** dirB\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "have \"collinear x bpA (bpA \\<leadsto> dirA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collinear x bpA (bpA \\<leadsto> dirA)", "by (metis assms(4) inLine.simps bpA_def dirA_def)"], ["proof (state)\nthis:\n  collinear x bpA (bpA \\<leadsto> dirA)\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "then"], ["proof (chain)\npicking this:\n  collinear x bpA (bpA \\<leadsto> dirA)", "obtain \\<beta> where \"from x to bpA = (-\\<beta>)**dirA\""], ["proof (prove)\nusing this:\n  collinear x bpA (bpA \\<leadsto> dirA)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<beta>.\n        from x to bpA = (- \\<beta>) ** dirA \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis lemDirectionCollinear)"], ["proof (state)\nthis:\n  from x to bpA = (- \\<beta>) ** dirA\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "hence x_to_bpA: \"from x to bpA = ((-\\<beta>)*kab)**dirB\""], ["proof (prove)\nusing this:\n  from x to bpA = (- \\<beta>) ** dirA\n\ngoal (1 subgoal):\n 1. from x to bpA = (- \\<beta> * kab) ** dirB", "by (metis lemScaleScale kab_props)"], ["proof (state)\nthis:\n  from x to bpA = (- \\<beta> * kab) ** dirB\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "(* Assume the claim is false, and show that x is in lineB, contrary to assumption *)"], ["proof (state)\nthis:\n  from x to bpA = (- \\<beta> * kab) ** dirB\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "{"], ["proof (state)\nthis:\n  from x to bpA = (- \\<beta> * kab) ** dirB\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "assume converse: \"meets lineA lineB\""], ["proof (state)\nthis:\n  meets lineA lineB\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "have \"\\<exists>p.(inLine p lineA \\<and> inLine p lineB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. inLine p lineA \\<and> inLine p lineB", "by (metis converse meets.simps)"], ["proof (state)\nthis:\n  \\<exists>p. inLine p lineA \\<and> inLine p lineB\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "then"], ["proof (chain)\npicking this:\n  \\<exists>p. inLine p lineA \\<and> inLine p lineB", "obtain p where  p_in_AB: \"inLine p lineA \\<and> inLine p lineB\""], ["proof (prove)\nusing this:\n  \\<exists>p. inLine p lineA \\<and> inLine p lineB\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        inLine p lineA \\<and> inLine p lineB \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  inLine p lineA \\<and> inLine p lineB\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "have \"collinear p bpA (bpA \\<leadsto> dirA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collinear p bpA (bpA \\<leadsto> dirA)", "by (metis p_in_AB inLine.simps bpA_def dirA_def)"], ["proof (state)\nthis:\n  collinear p bpA (bpA \\<leadsto> dirA)\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "then"], ["proof (chain)\npicking this:\n  collinear p bpA (bpA \\<leadsto> dirA)", "obtain \\<beta>A where \"from p to bpA = (-\\<beta>A)**dirA\""], ["proof (prove)\nusing this:\n  collinear p bpA (bpA \\<leadsto> dirA)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<beta>A.\n        from p to bpA = (- \\<beta>A) ** dirA \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis lemDirectionCollinear)"], ["proof (state)\nthis:\n  from p to bpA = (- \\<beta>A) ** dirA\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "hence \"from bpA to p = (\\<beta>A)**dirA\""], ["proof (prove)\nusing this:\n  from p to bpA = (- \\<beta>A) ** dirA\n\ngoal (1 subgoal):\n 1. from bpA to p = \\<beta>A ** dirA", "by (metis basic minus_minus)"], ["proof (state)\nthis:\n  from bpA to p = \\<beta>A ** dirA\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "hence bpA_to_p: \"from bpA to p = (\\<beta>A*kab)**dirB\""], ["proof (prove)\nusing this:\n  from bpA to p = \\<beta>A ** dirA\n\ngoal (1 subgoal):\n 1. from bpA to p = (\\<beta>A * kab) ** dirB", "by (metis lemScaleScale kab_props)"], ["proof (state)\nthis:\n  from bpA to p = (\\<beta>A * kab) ** dirB\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "have \"collinear p bpB (bpB \\<leadsto> dirB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collinear p bpB (bpB \\<leadsto> dirB)", "by (metis p_in_AB inLine.simps bpB_def dirB_def)"], ["proof (state)\nthis:\n  collinear p bpB (bpB \\<leadsto> dirB)\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "then"], ["proof (chain)\npicking this:\n  collinear p bpB (bpB \\<leadsto> dirB)", "obtain \\<beta>B where p_to_bpB: \"from p to bpB = (-\\<beta>B)**dirB\""], ["proof (prove)\nusing this:\n  collinear p bpB (bpB \\<leadsto> dirB)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<beta>B.\n        from p to bpB = (- \\<beta>B) ** dirB \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis lemDirectionCollinear)"], ["proof (state)\nthis:\n  from p to bpB = (- \\<beta>B) ** dirB\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "(* Express from x to bpB directly in terms of dirB *)"], ["proof (state)\nthis:\n  from p to bpB = (- \\<beta>B) ** dirB\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "define \\<gamma> where \"\\<gamma> = -((-\\<beta>)*kab + (\\<beta>A*kab) + (-\\<beta>B))\""], ["proof (state)\nthis:\n  \\<gamma> = - (- \\<beta> * kab + \\<beta>A * kab + - \\<beta>B)\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "have x_to_bpB: \"(from x to bpA) \\<oplus> (from bpA to p) \\<oplus> (from p to bpB) = (from x to bpB)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from x to bpA \\<oplus> from bpA to p \\<oplus> from p to bpB =\n    from x to bpB", "by (metis lemFromToTo)"], ["proof (state)\nthis:\n  from x to bpA \\<oplus> from bpA to p \\<oplus> from p to bpB =\n  from x to bpB\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "hence \"from x to bpB = ((-\\<beta>)*kab)**dirB \\<oplus> (\\<beta>A*kab)**dirB \\<oplus> (-\\<beta>B)**dirB\""], ["proof (prove)\nusing this:\n  from x to bpA \\<oplus> from bpA to p \\<oplus> from p to bpB =\n  from x to bpB\n\ngoal (1 subgoal):\n 1. from x to bpB =\n    (- \\<beta> * kab) ** dirB \\<oplus>\n    (\\<beta>A * kab) ** dirB \\<oplus> (- \\<beta>B) ** dirB", "by (metis x_to_bpA bpA_to_p p_to_bpB)"], ["proof (state)\nthis:\n  from x to bpB =\n  (- \\<beta> * kab) ** dirB \\<oplus>\n  (\\<beta>A * kab) ** dirB \\<oplus> (- \\<beta>B) ** dirB\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "hence \"from x to bpB = (-\\<gamma>)**dirB\""], ["proof (prove)\nusing this:\n  from x to bpB =\n  (- \\<beta> * kab) ** dirB \\<oplus>\n  (\\<beta>A * kab) ** dirB \\<oplus> (- \\<beta>B) ** dirB\n\ngoal (1 subgoal):\n 1. from x to bpB = (- \\<gamma>) ** dirB", "by (metis lemAddOverScale add.assoc \\<gamma>_def minus_minus)"], ["proof (state)\nthis:\n  from x to bpB = (- \\<gamma>) ** dirB\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "hence \"collinear x bpB (bpB \\<leadsto> dirB)\""], ["proof (prove)\nusing this:\n  from x to bpB = (- \\<gamma>) ** dirB\n\ngoal (1 subgoal):\n 1. collinear x bpB (bpB \\<leadsto> dirB)", "by (metis lemDirectionCollinear)"], ["proof (state)\nthis:\n  collinear x bpB (bpB \\<leadsto> dirB)\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "hence \"inLine x lineB\""], ["proof (prove)\nusing this:\n  collinear x bpB (bpB \\<leadsto> dirB)\n\ngoal (1 subgoal):\n 1. inLine x lineB", "by (metis inLine.simps bpB_def dirB_def)"], ["proof (state)\nthis:\n  inLine x lineB\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "}"], ["proof (state)\nthis:\n  meets lineA lineB \\<Longrightarrow> inLine x lineB\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "from this"], ["proof (chain)\npicking this:\n  meets lineA lineB \\<Longrightarrow> inLine x lineB", "have \"meets lineA lineB \\<longrightarrow> inLine x lineB\""], ["proof (prove)\nusing this:\n  meets lineA lineB \\<Longrightarrow> inLine x lineB\n\ngoal (1 subgoal):\n 1. meets lineA lineB \\<longrightarrow> inLine x lineB", "by blast"], ["proof (state)\nthis:\n  meets lineA lineB \\<longrightarrow> inLine x lineB\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "thus ?thesis"], ["proof (prove)\nusing this:\n  meets lineA lineB \\<longrightarrow> inLine x lineB\n\ngoal (1 subgoal):\n 1. \\<not> meets lineA lineB", "by (metis assms(5))"], ["proof (state)\nthis:\n  \\<not> meets lineA lineB\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lemAxisIsLine:\n    assumes \"onAxisT x\"\n      and   \"onAxisT y\"\n      and   \"onAxisT z\"\n      and   \"x \\<noteq> y\"\n      and   \"y \\<noteq> z\"\n      and   \"z \\<noteq> x\"\n    shows   \"collinear x y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collinear x y z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. collinear x y z", "define ratio where \"ratio = -(tval y - tval x) / (tval z - tval y)\""], ["proof (state)\nthis:\n  ratio = - (tval y - tval x) / (tval z - tval y)\n\ngoal (1 subgoal):\n 1. collinear x y z", "have x_onAxis: \"xval x = 0 \\<and> yval x = 0 \\<and> zval x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xval x = (0::'a) \\<and> yval x = (0::'a) \\<and> zval x = (0::'a)", "by (metis assms(1) onAxisT.simps)"], ["proof (state)\nthis:\n  xval x = (0::'a) \\<and> yval x = (0::'a) \\<and> zval x = (0::'a)\n\ngoal (1 subgoal):\n 1. collinear x y z", "have y_onAxis: \"xval y = 0 \\<and> yval y = 0 \\<and> zval y = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xval y = (0::'a) \\<and> yval y = (0::'a) \\<and> zval y = (0::'a)", "by (metis assms(2) onAxisT.simps)"], ["proof (state)\nthis:\n  xval y = (0::'a) \\<and> yval y = (0::'a) \\<and> zval y = (0::'a)\n\ngoal (1 subgoal):\n 1. collinear x y z", "have z_onAxis: \"xval z = 0 \\<and> yval z = 0 \\<and> zval z = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xval z = (0::'a) \\<and> yval z = (0::'a) \\<and> zval z = (0::'a)", "by (metis assms(3) onAxisT.simps)"], ["proof (state)\nthis:\n  xval z = (0::'a) \\<and> yval z = (0::'a) \\<and> zval z = (0::'a)\n\ngoal (1 subgoal):\n 1. collinear x y z", "have  \"tval z - tval y = 0 \\<longrightarrow> z = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tval z - tval y = (0::'a) \\<longrightarrow> z = y", "by (simp add: z_onAxis y_onAxis)"], ["proof (state)\nthis:\n  tval z - tval y = (0::'a) \\<longrightarrow> z = y\n\ngoal (1 subgoal):\n 1. collinear x y z", "hence \"tval z \\<noteq> tval y\""], ["proof (prove)\nusing this:\n  tval z - tval y = (0::'a) \\<longrightarrow> z = y\n\ngoal (1 subgoal):\n 1. tval z \\<noteq> tval y", "by (metis assms(5) eq_iff_diff_eq_0)"], ["proof (state)\nthis:\n  tval z \\<noteq> tval y\n\ngoal (1 subgoal):\n 1. collinear x y z", "hence tvalyz_nonzero: \"tval z - tval y \\<noteq> 0\""], ["proof (prove)\nusing this:\n  tval z \\<noteq> tval y\n\ngoal (1 subgoal):\n 1. tval z - tval y \\<noteq> (0::'a)", "by (metis eq_iff_diff_eq_0)"], ["proof (state)\nthis:\n  tval z - tval y \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. collinear x y z", "have x_to_y: \"from x to y = \\<lparr> tdir = tval y - tval x, xdir = 0, ydir = 0, zdir = 0 \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from x to y =\n    \\<lparr>tdir = tval y - tval x, xdir = 0::'a, ydir = 0::'a,\n       zdir = 0::'a\\<rparr>", "by (simp add: x_onAxis y_onAxis)"], ["proof (state)\nthis:\n  from x to y =\n  \\<lparr>tdir = tval y - tval x, xdir = 0::'a, ydir = 0::'a,\n     zdir = 0::'a\\<rparr>\n\ngoal (1 subgoal):\n 1. collinear x y z", "have y_to_z: \"from y to z = \\<lparr> tdir = tval z - tval y, xdir = 0, ydir = 0, zdir = 0 \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from y to z =\n    \\<lparr>tdir = tval z - tval y, xdir = 0::'a, ydir = 0::'a,\n       zdir = 0::'a\\<rparr>", "by (simp add:y_onAxis z_onAxis)"], ["proof (state)\nthis:\n  from y to z =\n  \\<lparr>tdir = tval z - tval y, xdir = 0::'a, ydir = 0::'a,\n     zdir = 0::'a\\<rparr>\n\ngoal (1 subgoal):\n 1. collinear x y z", "have \"from x to y = (-ratio)**(from y to z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from x to y = (- ratio) ** from y to z", "apply (simp add: x_to_y y_to_z ratio_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. tval y - tval x =\n    - ((tval x - tval y) * (tval z - tval y) / (tval z - tval y)) \\<and>\n    xval y - xval x =\n    - ((tval x - tval y) * (xval z - xval y) / (tval z - tval y)) \\<and>\n    yval y - yval x =\n    - ((tval x - tval y) * (yval z - yval y) / (tval z - tval y)) \\<and>\n    zval y - zval x =\n    - ((tval x - tval y) * (zval z - zval y) / (tval z - tval y))", "by (metis diff_self eq_divide_imp minus_diff_eq mult_eq_0_iff \n                tvalyz_nonzero x_onAxis y_onAxis z_onAxis)"], ["proof (state)\nthis:\n  from x to y = (- ratio) ** from y to z\n\ngoal (1 subgoal):\n 1. collinear x y z", "hence \"collinear x y (y \\<leadsto> (from y to z))\""], ["proof (prove)\nusing this:\n  from x to y = (- ratio) ** from y to z\n\ngoal (1 subgoal):\n 1. collinear x y (y \\<leadsto> from y to z)", "by (metis lemDirectionCollinear)"], ["proof (state)\nthis:\n  collinear x y (y \\<leadsto> from y to z)\n\ngoal (1 subgoal):\n 1. collinear x y z", "thus ?thesis"], ["proof (prove)\nusing this:\n  collinear x y (y \\<leadsto> from y to z)\n\ngoal (1 subgoal):\n 1. collinear x y z", "by (metis lemLineEndpoint)"], ["proof (state)\nthis:\n  collinear x y z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lemSpace2Sym: \n    shows \"space2 x y = space2 y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. space2 x y = space2 y x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. space2 x y = space2 y x", "define xsep where \"xsep = xval x - xval y\""], ["proof (state)\nthis:\n  xsep = xval x - xval y\n\ngoal (1 subgoal):\n 1. space2 x y = space2 y x", "define ysep where \"ysep = yval x - yval y\""], ["proof (state)\nthis:\n  ysep = yval x - yval y\n\ngoal (1 subgoal):\n 1. space2 x y = space2 y x", "define zsep where \"zsep = zval x - zval y\""], ["proof (state)\nthis:\n  zsep = zval x - zval y\n\ngoal (1 subgoal):\n 1. space2 x y = space2 y x", "have spacexy: \"space2 x y = (xsep*xsep) + (ysep*ysep) + (zsep*zsep)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. space2 x y = xsep * xsep + ysep * ysep + zsep * zsep", "by (simp add: xsep_def ysep_def zsep_def)"], ["proof (state)\nthis:\n  space2 x y = xsep * xsep + ysep * ysep + zsep * zsep\n\ngoal (1 subgoal):\n 1. space2 x y = space2 y x", "have spaceyx: \"space2 y x = (-xsep)*(-xsep) + (-ysep)*(-ysep) + (-zsep)*(-zsep)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. space2 y x = - xsep * - xsep + - ysep * - ysep + - zsep * - zsep", "by (simp add: xsep_def ysep_def zsep_def)"], ["proof (state)\nthis:\n  space2 y x = - xsep * - xsep + - ysep * - ysep + - zsep * - zsep\n\ngoal (1 subgoal):\n 1. space2 x y = space2 y x", "thus ?thesis"], ["proof (prove)\nusing this:\n  space2 y x = - xsep * - xsep + - ysep * - ysep + - zsep * - zsep\n\ngoal (1 subgoal):\n 1. space2 x y = space2 y x", "by (metis spacexy diff_0_right minus_diff_eq minus_mult_left minus_mult_right)"], ["proof (state)\nthis:\n  space2 x y = space2 y x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lemTime2Sym: \n    shows \"time2 x y = time2 y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. time2 x y = time2 y x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. time2 x y = time2 y x", "define tsep where \"tsep = tval x - tval y\""], ["proof (state)\nthis:\n  tsep = tval x - tval y\n\ngoal (1 subgoal):\n 1. time2 x y = time2 y x", "have timexy: \"time2 x y = tsep*tsep\""], ["proof (prove)\ngoal (1 subgoal):\n 1. time2 x y = tsep * tsep", "by (simp add: tsep_def)"], ["proof (state)\nthis:\n  time2 x y = tsep * tsep\n\ngoal (1 subgoal):\n 1. time2 x y = time2 y x", "have timeyx: \"time2 y x = (-tsep)*(-tsep)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. time2 y x = - tsep * - tsep", "by (simp add: tsep_def)"], ["proof (state)\nthis:\n  time2 y x = - tsep * - tsep\n\ngoal (1 subgoal):\n 1. time2 x y = time2 y x", "thus ?thesis"], ["proof (prove)\nusing this:\n  time2 y x = - tsep * - tsep\n\ngoal (1 subgoal):\n 1. time2 x y = time2 y x", "by (metis timexy diff_0_right minus_diff_eq minus_mult_left minus_mult_right)"], ["proof (state)\nthis:\n  time2 x y = time2 y x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(*\n  A plane is determined by a basepoint with two directions.\n*)"], ["", "class Planes = Quantities + Lines\nbegin"], ["", "fun mkPlane :: \"'a Point \\<Rightarrow> 'a Vector \\<Rightarrow> 'a Vector \\<Rightarrow> 'a Plane\" where\n    \"mkPlane b d1 d2 = \\<lparr> pbasepoint = b, direction1 = d1, direction2 = d2 \\<rparr>\""], ["", "fun coplanar :: \"'a Point \\<Rightarrow> 'a Point \\<Rightarrow> 'a Point \\<Rightarrow> 'a Point \\<Rightarrow> bool\" where\n    \"coplanar e x y z \n      = (\\<exists>\\<alpha> \\<beta> \\<gamma>. ( (\\<alpha> +  \\<beta> +  \\<gamma> = 1)  \\<and>\n            positionVector e \n              = (\\<alpha>**(positionVector x) \\<oplus> \\<beta>**(positionVector y) \\<oplus> \\<gamma>**(positionVector z) )))\""], ["", "fun inPlane :: \"'a Point \\<Rightarrow> 'a Plane \\<Rightarrow> bool\" where\n    \"inPlane e pl = coplanar e (pbasepoint pl) (pbasepoint pl \\<leadsto> direction1 pl)\n                                               (pbasepoint pl \\<leadsto> direction2 pl)\""], ["", "fun samePlane :: \"'a Plane \\<Rightarrow> 'a Plane \\<Rightarrow> bool\" where\n    \"samePlane pl pl' = (inPlane (pbasepoint pl) pl' \\<and>\n                         inPlane (pbasepoint pl \\<leadsto> direction1 pl) pl' \\<and>\n                         inPlane (pbasepoint pl \\<leadsto> direction2 pl) pl')\""], ["", "lemma lemPlaneContainsBasePoint: \n  shows \"inPlane (pbasepoint pl) pl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inPlane (pbasepoint pl) pl", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inPlane (pbasepoint pl) pl", "define \\<alpha> where \"\\<alpha> = (1::'a)\""], ["proof (state)\nthis:\n  \\<alpha> = (1::'a)\n\ngoal (1 subgoal):\n 1. inPlane (pbasepoint pl) pl", "define \\<beta> where \"\\<beta> = (0::'a)\""], ["proof (state)\nthis:\n  \\<beta> = (0::'a)\n\ngoal (1 subgoal):\n 1. inPlane (pbasepoint pl) pl", "define \\<gamma> where \"\\<gamma> = (0::'a)\""], ["proof (state)\nthis:\n  \\<gamma> = (0::'a)\n\ngoal (1 subgoal):\n 1. inPlane (pbasepoint pl) pl", "have rtp1: \"\\<alpha> + \\<beta> + \\<gamma> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> + \\<beta> + \\<gamma> = (1::'a)", "by (simp add: \\<alpha>_def \\<beta>_def \\<gamma>_def)"], ["proof (state)\nthis:\n  \\<alpha> + \\<beta> + \\<gamma> = (1::'a)\n\ngoal (1 subgoal):\n 1. inPlane (pbasepoint pl) pl", "define e where \"e = pbasepoint pl\""], ["proof (state)\nthis:\n  e = pbasepoint pl\n\ngoal (1 subgoal):\n 1. inPlane (pbasepoint pl) pl", "define x where \"x = pbasepoint pl\""], ["proof (state)\nthis:\n  x = pbasepoint pl\n\ngoal (1 subgoal):\n 1. inPlane (pbasepoint pl) pl", "define y where \"y = pbasepoint pl \\<leadsto> direction1 pl\""], ["proof (state)\nthis:\n  y = pbasepoint pl \\<leadsto> direction1 pl\n\ngoal (1 subgoal):\n 1. inPlane (pbasepoint pl) pl", "define z where \"z = pbasepoint pl \\<leadsto> direction2 pl\""], ["proof (state)\nthis:\n  z = pbasepoint pl \\<leadsto> direction2 pl\n\ngoal (1 subgoal):\n 1. inPlane (pbasepoint pl) pl", "have rtp2: \"positionVector e = \\<alpha>**(positionVector x) \n                                 \\<oplus> \\<beta>**(positionVector y) \\<oplus> \\<gamma>**(positionVector z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positionVector e =\n    \\<alpha> ** positionVector x \\<oplus>\n    \\<beta> ** positionVector y \\<oplus> \\<gamma> ** positionVector z", "by (simp add: e_def x_def \\<alpha>_def \\<beta>_def \\<gamma>_def)"], ["proof (state)\nthis:\n  positionVector e =\n  \\<alpha> ** positionVector x \\<oplus>\n  \\<beta> ** positionVector y \\<oplus> \\<gamma> ** positionVector z\n\ngoal (1 subgoal):\n 1. inPlane (pbasepoint pl) pl", "have sameplane: \"coplanar e x y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coplanar e x y z", "by (metis coplanar.simps rtp1 rtp2)"], ["proof (state)\nthis:\n  coplanar e x y z\n\ngoal (1 subgoal):\n 1. inPlane (pbasepoint pl) pl", "hence \"coplanar e (pbasepoint pl) (pbasepoint pl \\<leadsto> direction1 pl) \n                                      (pbasepoint pl \\<leadsto> direction2 pl)\""], ["proof (prove)\nusing this:\n  coplanar e x y z\n\ngoal (1 subgoal):\n 1. coplanar e (pbasepoint pl) (pbasepoint pl \\<leadsto> direction1 pl)\n     (pbasepoint pl \\<leadsto> direction2 pl)", "by (simp add: x_def y_def z_def)"], ["proof (state)\nthis:\n  coplanar e (pbasepoint pl) (pbasepoint pl \\<leadsto> direction1 pl)\n   (pbasepoint pl \\<leadsto> direction2 pl)\n\ngoal (1 subgoal):\n 1. inPlane (pbasepoint pl) pl", "hence \"inPlane e pl\""], ["proof (prove)\nusing this:\n  coplanar e (pbasepoint pl) (pbasepoint pl \\<leadsto> direction1 pl)\n   (pbasepoint pl \\<leadsto> direction2 pl)\n\ngoal (1 subgoal):\n 1. inPlane e pl", "by simp"], ["proof (state)\nthis:\n  inPlane e pl\n\ngoal (1 subgoal):\n 1. inPlane (pbasepoint pl) pl", "thus ?thesis"], ["proof (prove)\nusing this:\n  inPlane e pl\n\ngoal (1 subgoal):\n 1. inPlane (pbasepoint pl) pl", "by (simp add: e_def)"], ["proof (state)\nthis:\n  inPlane (pbasepoint pl) pl\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(*\n  An upright cone is determined by its vertex + slope (ie, speed).\n*)"], ["", "class Cones = Quantities + Lines + Planes +\nfixes \n  (* the tangent plane at a point on a cone *)\n  tangentPlane :: \"'a Point \\<Rightarrow> 'a Cone \\<Rightarrow> 'a Plane\"\nassumes \n  (* The pbasepoint of the plane-at-e is e *)\n  AxTangentBase: \"pbasepoint (tangentPlane e cone) = e\"\nand\n  (* The tangent plane contains the vertex *)\n  AxTangentVertex: \"inPlane (vertex cone) (tangentPlane e cone)\"\nand\n  (* The tangent plane meets the cone in a line *)\n  AxConeTangent: \"(onCone e cone) \\<longrightarrow>\n                  ((inPlane pt (tangentPlane e cone) \\<and> onCone pt cone) \n                                                           \\<longleftrightarrow> collinear (vertex cone) e pt)\"\nand\n  (* The tangent plane is tangential to all cones with vertex in that plane, and\n     the intersection lines are parallel. *)\n  AxParallelCones: \"(onCone e econe \\<and> e \\<noteq> vertex econe \\<and> onCone f fcone \\<and> f \\<noteq> vertex fcone\n                      \\<and> inPlane f (tangentPlane e econe))\n                    \\<longrightarrow>  (samePlane (tangentPlane e econe) (tangentPlane f fcone)\n                          \\<and> ((lineJoining (vertex econe) e) \\<parallel> (lineJoining (vertex fcone) f)))\"\nand\n  (* \n     if f is outside a cone, there is a tangent plane to that cone which contains f. The \n     tangent plane is determined by some e lying on the intersection line with the cone.\n  *)\n  AxParallelConesE: \"outsideCone f cone\n    \\<longrightarrow> (\\<exists>e.(onCone e cone \\<and> e \\<noteq> vertex cone \\<and> inPlane f (tangentPlane e cone)))\"\nand\n(* \n  Given distinct e f on the t-axis, and g off the axis, we can \n  find a point p on the line e-g such that the line f-p has \n  slope s. This can be proven using AxEuclidean, by taking the \n  intersection of a line with a cone.\n*)\n  AxSlopedLineInVerticalPlane: \"\\<lbrakk>onAxisT e; onAxisT f; e \\<noteq> f; \\<not>(onAxisT g)\\<rbrakk>\n     \\<Longrightarrow> (\\<forall>s.( \\<exists>p . (collinear e g p \\<and> (space2 p f = (s*s)*time2 p f))))\"\n\nbegin"], ["", "fun onCone :: \"'a Point \\<Rightarrow> 'a Cone \\<Rightarrow> bool\" where\n    \"onCone p cone  \n      = (space2 (vertex cone) p  = (slope cone * slope cone) * time2 (vertex cone) p )\""], ["", "fun insideCone :: \"'a Point \\<Rightarrow> 'a Cone \\<Rightarrow> bool\" where\n    \"insideCone p cone  \n      = (space2 (vertex cone) p < (slope cone * slope cone) * time2 (vertex cone) p)\""], ["", "fun outsideCone :: \"'a Point \\<Rightarrow> 'a Cone \\<Rightarrow> bool\" where\n    \"outsideCone p cone  \n      = (space2 (vertex cone) p > (slope cone * slope cone) * time2 (vertex cone) p)\""], ["", "fun mkCone :: \"'a Point \\<Rightarrow> 'a \\<Rightarrow> 'a Cone\" where\n    \"mkCone v s = \\<lparr> vertex = v, slope = s \\<rparr>\""], ["", "lemma lemVertexOnCone: \n    shows \"onCone (vertex cone) cone\""], ["proof (prove)\ngoal (1 subgoal):\n 1. onCone (vertex cone) cone", "by simp"], ["", "lemma lemOutsideNotOnCone: \n    assumes \"outsideCone f cone\"\n    shows   \"\\<not> (onCone f cone)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> onCone f cone", "by (metis assms less_irrefl onCone.simps outsideCone.simps)"], ["", "end"], ["", "class SpaceTime = Quantities + Vectors + Points + Lines + Planes + Cones"], ["", "end"]]}