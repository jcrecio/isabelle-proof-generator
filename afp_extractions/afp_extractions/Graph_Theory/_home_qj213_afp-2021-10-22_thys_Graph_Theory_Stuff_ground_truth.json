{"file_name": "/home/qj213/afp-2021-10-22/thys/Graph_Theory/Stuff.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Graph_Theory", "problem_names": ["lemma ereal_Inf_finite_Min:\n  fixes S :: \"ereal set\"\n  assumes \"finite S\" and \"S \\<noteq> {}\"\n  shows \"Inf S = Min S\"", "lemma finite_INF_in:\n  fixes f :: \"'a \\<Rightarrow> ereal\"\n  assumes \"finite S\"\n  assumes \"S \\<noteq> {}\"\n  shows \"(INF s\\<in> S. f s) \\<in> f ` S\"", "lemma not_mem_less_INF:\n  fixes f :: \"'a \\<Rightarrow> 'b :: complete_lattice\"\n  assumes \"f x < (INF s\\<in> S. f s)\"\n  assumes \"x \\<in> S\"\n  shows \"False\"", "lemma sym_diff:\n  assumes \"sym A\" \"sym B\" shows \"sym (A - B)\"", "lemmas list_exhaust2 = list.exhaust[case_product list.exhaust]", "lemma list_exhaust_NSC:\n  obtains (Nil) \"xs = []\" | (Single) x where \"xs = [x]\" | (Cons_Cons) x y ys where \"xs = x # y # ys\"", "lemma tl_rev:\n  \"tl (rev p) = rev (butlast p)\"", "lemma butlast_rev:\n  \"butlast (rev p) = rev (tl p)\"", "lemma take_drop_take:\n   \"take n xs @ drop n (take m xs) = take (max n m) xs\"", "lemma drop_take_drop:\n  \"drop n (take m xs) @ drop m xs = drop (min n m) xs\"", "lemma not_distinct_decomp_min_prefix:\n  assumes \"\\<not> distinct ws\"\n  shows \"\\<exists> xs ys zs y. ws = xs @ y # ys @ y # zs \\<and> distinct xs \\<and> y \\<notin> set xs \\<and> y \\<notin> set ys \"", "lemma not_distinct_decomp_min_not_distinct:\n  assumes \"\\<not> distinct ws\"\n  shows \"\\<exists>xs y ys zs. ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])\"", "lemma card_Ex_subset:\n  \"k \\<le> card M \\<Longrightarrow> \\<exists>N. N \\<subseteq> M \\<and> card N = k\"", "lemma list_set_tl: \"x \\<in> set (tl xs) \\<Longrightarrow> x \\<in> set xs\"", "lemma NOMATCH_cong[cong]: \"NOMATCH val pat = NOMATCH val pat\""], "translations": [["", "lemma ereal_Inf_finite_Min:\n  fixes S :: \"ereal set\"\n  assumes \"finite S\" and \"S \\<noteq> {}\"\n  shows \"Inf S = Min S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf S = Min S", "using assms"], ["proof (prove)\nusing this:\n  finite S\n  S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Inf S = Min S", "by (induct S rule: finite_ne_induct) (auto simp: min_absorb1)"], ["", "lemma finite_INF_in:\n  fixes f :: \"'a \\<Rightarrow> ereal\"\n  assumes \"finite S\"\n  assumes \"S \\<noteq> {}\"\n  shows \"(INF s\\<in> S. f s) \\<in> f ` S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf (f ` S) \\<in> f ` S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Inf (f ` S) \\<in> f ` S", "from assms"], ["proof (chain)\npicking this:\n  finite S\n  S \\<noteq> {}", "have \"finite (f ` S)\" \"f ` S \\<noteq> {}\""], ["proof (prove)\nusing this:\n  finite S\n  S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. finite (f ` S) &&& f ` S \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  finite (f ` S)\n  f ` S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Inf (f ` S) \\<in> f ` S", "then"], ["proof (chain)\npicking this:\n  finite (f ` S)\n  f ` S \\<noteq> {}", "show \"Inf (f ` S) \\<in> f ` S\""], ["proof (prove)\nusing this:\n  finite (f ` S)\n  f ` S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Inf (f ` S) \\<in> f ` S", "using ereal_Inf_finite_Min [of \"f ` S\"]"], ["proof (prove)\nusing this:\n  finite (f ` S)\n  f ` S \\<noteq> {}\n  \\<lbrakk>finite (f ` S); f ` S \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> Inf (f ` S) = Min (f ` S)\n\ngoal (1 subgoal):\n 1. Inf (f ` S) \\<in> f ` S", "by simp"], ["proof (state)\nthis:\n  Inf (f ` S) \\<in> f ` S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_mem_less_INF:\n  fixes f :: \"'a \\<Rightarrow> 'b :: complete_lattice\"\n  assumes \"f x < (INF s\\<in> S. f s)\"\n  assumes \"x \\<in> S\"\n  shows \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  f x < Inf (f ` S)\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. False", "by (metis INF_lower less_le_not_le)"], ["", "lemma sym_diff:\n  assumes \"sym A\" \"sym B\" shows \"sym (A - B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sym (A - B)", "using assms"], ["proof (prove)\nusing this:\n  sym A\n  sym B\n\ngoal (1 subgoal):\n 1. sym (A - B)", "by (auto simp: sym_def)"], ["", "subsection \\<open>List\\<close>"], ["", "lemmas list_exhaust2 = list.exhaust[case_product list.exhaust]"], ["", "lemma list_exhaust_NSC:\n  obtains (Nil) \"xs = []\" | (Single) x where \"xs = [x]\" | (Cons_Cons) x y ys where \"xs = x # y # ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs = [] \\<Longrightarrow> thesis;\n     \\<And>x. xs = [x] \\<Longrightarrow> thesis;\n     \\<And>x y ys. xs = x # y # ys \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis list.exhaust)"], ["", "lemma tl_rev:\n  \"tl (rev p) = rev (butlast p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (rev p) = rev (butlast p)", "by (induct p) auto"], ["", "lemma butlast_rev:\n  \"butlast (rev p) = rev (tl p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. butlast (rev p) = rev (tl p)", "by (induct p) auto"], ["", "lemma take_drop_take:\n   \"take n xs @ drop n (take m xs) = take (max n m) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take n xs @ drop n (take m xs) = take (max n m) xs", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> take n xs @ drop n (take m xs) = take (max n m) xs\n 2. \\<not> ?P \\<Longrightarrow>\n    take n xs @ drop n (take m xs) = take (max n m) xs", "assume \"m < n\""], ["proof (state)\nthis:\n  m < n\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> take n xs @ drop n (take m xs) = take (max n m) xs\n 2. \\<not> ?P \\<Longrightarrow>\n    take n xs @ drop n (take m xs) = take (max n m) xs", "then"], ["proof (chain)\npicking this:\n  m < n", "show ?thesis"], ["proof (prove)\nusing this:\n  m < n\n\ngoal (1 subgoal):\n 1. take n xs @ drop n (take m xs) = take (max n m) xs", "by (auto simp: max_def)"], ["proof (state)\nthis:\n  take n xs @ drop n (take m xs) = take (max n m) xs\n\ngoal (1 subgoal):\n 1. \\<not> m < n \\<Longrightarrow>\n    take n xs @ drop n (take m xs) = take (max n m) xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> m < n \\<Longrightarrow>\n    take n xs @ drop n (take m xs) = take (max n m) xs", "assume \"\\<not>m < n\""], ["proof (state)\nthis:\n  \\<not> m < n\n\ngoal (1 subgoal):\n 1. \\<not> m < n \\<Longrightarrow>\n    take n xs @ drop n (take m xs) = take (max n m) xs", "then"], ["proof (chain)\npicking this:\n  \\<not> m < n", "have \"take n xs = take n (take m xs)\""], ["proof (prove)\nusing this:\n  \\<not> m < n\n\ngoal (1 subgoal):\n 1. take n xs = take n (take m xs)", "by (auto simp: min_def)"], ["proof (state)\nthis:\n  take n xs = take n (take m xs)\n\ngoal (1 subgoal):\n 1. \\<not> m < n \\<Longrightarrow>\n    take n xs @ drop n (take m xs) = take (max n m) xs", "then"], ["proof (chain)\npicking this:\n  take n xs = take n (take m xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  take n xs = take n (take m xs)\n\ngoal (1 subgoal):\n 1. take n xs @ drop n (take m xs) = take (max n m) xs", "by (simp del: take_take add: max_def)"], ["proof (state)\nthis:\n  take n xs @ drop n (take m xs) = take (max n m) xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma drop_take_drop:\n  \"drop n (take m xs) @ drop m xs = drop (min n m) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop n (take m xs) @ drop m xs = drop (min n m) xs", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> drop n (take m xs) @ drop m xs = drop (min n m) xs\n 2. \\<not> ?P \\<Longrightarrow>\n    drop n (take m xs) @ drop m xs = drop (min n m) xs", "assume A: \"\\<not>m < n\""], ["proof (state)\nthis:\n  \\<not> m < n\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> drop n (take m xs) @ drop m xs = drop (min n m) xs\n 2. \\<not> ?P \\<Longrightarrow>\n    drop n (take m xs) @ drop m xs = drop (min n m) xs", "then"], ["proof (chain)\npicking this:\n  \\<not> m < n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> m < n\n\ngoal (1 subgoal):\n 1. drop n (take m xs) @ drop m xs = drop (min n m) xs", "using drop_append[of n \"take m xs\" \"drop m xs\"]"], ["proof (prove)\nusing this:\n  \\<not> m < n\n  drop n (take m xs @ drop m xs) =\n  drop n (take m xs) @ drop (n - length (take m xs)) (drop m xs)\n\ngoal (1 subgoal):\n 1. drop n (take m xs) @ drop m xs = drop (min n m) xs", "by (cases \"length xs < n\") (auto simp: not_less min_def)"], ["proof (state)\nthis:\n  drop n (take m xs) @ drop m xs = drop (min n m) xs\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> m < n \\<Longrightarrow>\n    drop n (take m xs) @ drop m xs = drop (min n m) xs", "qed (auto simp: min_def)"], ["", "lemma not_distinct_decomp_min_prefix:\n  assumes \"\\<not> distinct ws\"\n  shows \"\\<exists> xs ys zs y. ws = xs @ y # ys @ y # zs \\<and> distinct xs \\<and> y \\<notin> set xs \\<and> y \\<notin> set ys \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs y.\n       ws = xs @ y # ys @ y # zs \\<and>\n       distinct xs \\<and> y \\<notin> set xs \\<and> y \\<notin> set ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs y.\n       ws = xs @ y # ys @ y # zs \\<and>\n       distinct xs \\<and> y \\<notin> set xs \\<and> y \\<notin> set ys", "obtain xs y ys where \"y \\<in> set xs\" \"distinct xs\" \"ws = xs @ y # ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y xs ys.\n        \\<lbrakk>y \\<in> set xs; distinct xs; ws = xs @ y # ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<not> distinct ws\n\ngoal (1 subgoal):\n 1. (\\<And>y xs ys.\n        \\<lbrakk>y \\<in> set xs; distinct xs; ws = xs @ y # ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: not_distinct_conv_prefix)"], ["proof (state)\nthis:\n  y \\<in> set xs\n  distinct xs\n  ws = xs @ y # ys\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs y.\n       ws = xs @ y # ys @ y # zs \\<and>\n       distinct xs \\<and> y \\<notin> set xs \\<and> y \\<notin> set ys", "moreover"], ["proof (state)\nthis:\n  y \\<in> set xs\n  distinct xs\n  ws = xs @ y # ys\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs y.\n       ws = xs @ y # ys @ y # zs \\<and>\n       distinct xs \\<and> y \\<notin> set xs \\<and> y \\<notin> set ys", "then"], ["proof (chain)\npicking this:\n  y \\<in> set xs\n  distinct xs\n  ws = xs @ y # ys", "obtain xs' ys' where \"xs = xs' @ y # ys'\""], ["proof (prove)\nusing this:\n  y \\<in> set xs\n  distinct xs\n  ws = xs @ y # ys\n\ngoal (1 subgoal):\n 1. (\\<And>xs' ys'.\n        xs = xs' @ y # ys' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_set_conv_decomp)"], ["proof (state)\nthis:\n  xs = xs' @ y # ys'\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs y.\n       ws = xs @ y # ys @ y # zs \\<and>\n       distinct xs \\<and> y \\<notin> set xs \\<and> y \\<notin> set ys", "ultimately"], ["proof (chain)\npicking this:\n  y \\<in> set xs\n  distinct xs\n  ws = xs @ y # ys\n  xs = xs' @ y # ys'", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<in> set xs\n  distinct xs\n  ws = xs @ y # ys\n  xs = xs' @ y # ys'\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs y.\n       ws = xs @ y # ys @ y # zs \\<and>\n       distinct xs \\<and> y \\<notin> set xs \\<and> y \\<notin> set ys", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs ys zs y.\n     ws = xs @ y # ys @ y # zs \\<and>\n     distinct xs \\<and> y \\<notin> set xs \\<and> y \\<notin> set ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_distinct_decomp_min_not_distinct:\n  assumes \"\\<not> distinct ws\"\n  shows \"\\<exists>xs y ys zs. ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs y ys zs.\n       ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])", "using assms"], ["proof (prove)\nusing this:\n  \\<not> distinct ws\n\ngoal (1 subgoal):\n 1. \\<exists>xs y ys zs.\n       ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])", "proof (induct ws)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> distinct [] \\<Longrightarrow>\n    \\<exists>xs y ys zs.\n       [] = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])\n 2. \\<And>a ws.\n       \\<lbrakk>\\<not> distinct ws \\<Longrightarrow>\n                \\<exists>xs y ys zs.\n                   ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y]);\n        \\<not> distinct (a # ws)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs y ys zs.\n                            a # ws = xs @ y # ys @ y # zs \\<and>\n                            distinct (ys @ [y])", "case (Cons w ws)"], ["proof (state)\nthis:\n  \\<not> distinct ws \\<Longrightarrow>\n  \\<exists>xs y ys zs. ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])\n  \\<not> distinct (w # ws)\n\ngoal (2 subgoals):\n 1. \\<not> distinct [] \\<Longrightarrow>\n    \\<exists>xs y ys zs.\n       [] = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])\n 2. \\<And>a ws.\n       \\<lbrakk>\\<not> distinct ws \\<Longrightarrow>\n                \\<exists>xs y ys zs.\n                   ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y]);\n        \\<not> distinct (a # ws)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs y ys zs.\n                            a # ws = xs @ y # ys @ y # zs \\<and>\n                            distinct (ys @ [y])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs y ys zs.\n       w # ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])", "proof (cases \"distinct ws\")"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct ws \\<Longrightarrow>\n    \\<exists>xs y ys zs.\n       w # ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])\n 2. \\<not> distinct ws \\<Longrightarrow>\n    \\<exists>xs y ys zs.\n       w # ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])", "case True"], ["proof (state)\nthis:\n  distinct ws\n\ngoal (2 subgoals):\n 1. distinct ws \\<Longrightarrow>\n    \\<exists>xs y ys zs.\n       w # ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])\n 2. \\<not> distinct ws \\<Longrightarrow>\n    \\<exists>xs y ys zs.\n       w # ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])", "then"], ["proof (chain)\npicking this:\n  distinct ws", "obtain xs ys where \"ws = xs @ w # ys\" \"w \\<notin> set xs\""], ["proof (prove)\nusing this:\n  distinct ws\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        \\<lbrakk>ws = xs @ w # ys; w \\<notin> set xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons.prems"], ["proof (prove)\nusing this:\n  distinct ws\n  \\<not> distinct (w # ws)\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        \\<lbrakk>ws = xs @ w # ys; w \\<notin> set xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce dest: split_list_first)"], ["proof (state)\nthis:\n  ws = xs @ w # ys\n  w \\<notin> set xs\n\ngoal (2 subgoals):\n 1. distinct ws \\<Longrightarrow>\n    \\<exists>xs y ys zs.\n       w # ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])\n 2. \\<not> distinct ws \\<Longrightarrow>\n    \\<exists>xs y ys zs.\n       w # ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])", "then"], ["proof (chain)\npicking this:\n  ws = xs @ w # ys\n  w \\<notin> set xs", "have \"distinct (xs @ [w])\" \"w # ws = [] @ w # xs @ w # ys\""], ["proof (prove)\nusing this:\n  ws = xs @ w # ys\n  w \\<notin> set xs\n\ngoal (1 subgoal):\n 1. distinct (xs @ [w]) &&& w # ws = [] @ w # xs @ w # ys", "using \\<open>distinct ws\\<close>"], ["proof (prove)\nusing this:\n  ws = xs @ w # ys\n  w \\<notin> set xs\n  distinct ws\n\ngoal (1 subgoal):\n 1. distinct (xs @ [w]) &&& w # ws = [] @ w # xs @ w # ys", "by auto"], ["proof (state)\nthis:\n  distinct (xs @ [w])\n  w # ws = [] @ w # xs @ w # ys\n\ngoal (2 subgoals):\n 1. distinct ws \\<Longrightarrow>\n    \\<exists>xs y ys zs.\n       w # ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])\n 2. \\<not> distinct ws \\<Longrightarrow>\n    \\<exists>xs y ys zs.\n       w # ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])", "then"], ["proof (chain)\npicking this:\n  distinct (xs @ [w])\n  w # ws = [] @ w # xs @ w # ys", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct (xs @ [w])\n  w # ws = [] @ w # xs @ w # ys\n\ngoal (1 subgoal):\n 1. \\<exists>xs y ys zs.\n       w # ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])", "by blast"], ["proof (state)\nthis:\n  \\<exists>xs y ys zs.\n     w # ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])\n\ngoal (1 subgoal):\n 1. \\<not> distinct ws \\<Longrightarrow>\n    \\<exists>xs y ys zs.\n       w # ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> distinct ws \\<Longrightarrow>\n    \\<exists>xs y ys zs.\n       w # ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])", "case False"], ["proof (state)\nthis:\n  \\<not> distinct ws\n\ngoal (1 subgoal):\n 1. \\<not> distinct ws \\<Longrightarrow>\n    \\<exists>xs y ys zs.\n       w # ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])", "then"], ["proof (chain)\npicking this:\n  \\<not> distinct ws", "obtain xs y ys zs where \"ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])\""], ["proof (prove)\nusing this:\n  \\<not> distinct ws\n\ngoal (1 subgoal):\n 1. (\\<And>xs y ys zs.\n        ws = xs @ y # ys @ y # zs \\<and>\n        distinct (ys @ [y]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Cons"], ["proof (prove)\nusing this:\n  \\<not> distinct ws\n  \\<not> distinct ws \\<Longrightarrow>\n  \\<exists>xs y ys zs. ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])\n  \\<not> distinct (w # ws)\n\ngoal (1 subgoal):\n 1. (\\<And>xs y ys zs.\n        ws = xs @ y # ys @ y # zs \\<and>\n        distinct (ys @ [y]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])\n\ngoal (1 subgoal):\n 1. \\<not> distinct ws \\<Longrightarrow>\n    \\<exists>xs y ys zs.\n       w # ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])", "then"], ["proof (chain)\npicking this:\n  ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])", "have \"w # ws = (w # xs) @ y # ys @ y # zs \\<and> distinct (ys @ [y])\""], ["proof (prove)\nusing this:\n  ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])\n\ngoal (1 subgoal):\n 1. w # ws = (w # xs) @ y # ys @ y # zs \\<and> distinct (ys @ [y])", "by simp"], ["proof (state)\nthis:\n  w # ws = (w # xs) @ y # ys @ y # zs \\<and> distinct (ys @ [y])\n\ngoal (1 subgoal):\n 1. \\<not> distinct ws \\<Longrightarrow>\n    \\<exists>xs y ys zs.\n       w # ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])", "then"], ["proof (chain)\npicking this:\n  w # ws = (w # xs) @ y # ys @ y # zs \\<and> distinct (ys @ [y])", "show ?thesis"], ["proof (prove)\nusing this:\n  w # ws = (w # xs) @ y # ys @ y # zs \\<and> distinct (ys @ [y])\n\ngoal (1 subgoal):\n 1. \\<exists>xs y ys zs.\n       w # ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])", "by blast"], ["proof (state)\nthis:\n  \\<exists>xs y ys zs.\n     w # ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs y ys zs.\n     w # ws = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])\n\ngoal (1 subgoal):\n 1. \\<not> distinct [] \\<Longrightarrow>\n    \\<exists>xs y ys zs.\n       [] = xs @ y # ys @ y # zs \\<and> distinct (ys @ [y])", "qed simp"], ["", "lemma card_Ex_subset:\n  \"k \\<le> card M \\<Longrightarrow> \\<exists>N. N \\<subseteq> M \\<and> card N = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> card M \\<Longrightarrow> \\<exists>N\\<subseteq>M. card N = k", "by (induct rule: inc_induct) (auto simp: card_Suc_eq)"], ["", "lemma list_set_tl: \"x \\<in> set (tl xs) \\<Longrightarrow> x \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (tl xs) \\<Longrightarrow> x \\<in> set xs", "by (cases xs) auto"], ["", "section \\<open>NOMATCH simproc\\<close>"], ["", "text \\<open>\n The simplification procedure can be used to avoid simplification of terms of a certain form\n\\<close>"], ["", "definition NOMATCH :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" where \"NOMATCH val pat \\<equiv> True\""], ["", "lemma NOMATCH_cong[cong]: \"NOMATCH val pat = NOMATCH val pat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NOMATCH val pat = NOMATCH val pat", "by (rule refl)"], ["", "simproc_setup NOMATCH (\"NOMATCH val pat\") = \\<open>fn _ => fn ctxt => fn ct =>\n  let\n    val thy = Proof_Context.theory_of ctxt\n    val dest_binop = Term.dest_comb #> apfst (Term.dest_comb #> snd)\n    val m = Pattern.matches thy (dest_binop (Thm.term_of ct))\n  in if m then NONE else SOME @{thm NOMATCH_def} end\n\\<close>"], ["", "text \\<open>\n  This setup ensures that a rewrite rule of the form @{term \"NOMATCH val pat \\<Longrightarrow> t\"}\n  is only applied, if the pattern @{term pat} does not match the value @{term val}.\n\\<close>"], ["", "end"]]}