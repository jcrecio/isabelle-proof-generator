{"file_name": "/home/qj213/afp-2021-10-22/thys/Graph_Theory/Subdivision.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Graph_Theory", "problem_names": ["lemma subdivision_induct[case_names base divide, induct pred: subdivision]:\n  assumes \"subdivision (G, rev_G) (H, rev_H)\"\n    and \"bidirected_digraph G rev_G \\<Longrightarrow> P G rev_G\"\n    and \"\\<And>I rev_I H rev_H u v w uv uw vw.\n            subdivision (G, rev_G) (I, rev_I) \\<Longrightarrow> P I rev_I \\<Longrightarrow> subdivision_step I rev_I H rev_H (u, v, w) (uv, uw, vw) \\<Longrightarrow> P H rev_H\"\n  shows \"P H rev_H\"", "lemma subdivision_base:\n  \"bidirected_digraph G rev_G \\<Longrightarrow> subdivision (G, rev_G) (G, rev_G)\"", "lemma subdivision_step_rev:\n  assumes \"subdivision_step G rev_G H rev_H (u, v, w) (uv, uw, vw)\" \"subdivision (H, rev_H) (I, rev_I)\"\n  shows \"subdivision (G, rev_G) (I, rev_I)\"", "lemma subdivision_trans:\n  assumes \"subdivision (G, rev_G) (H, rev_H)\" \"subdivision (H, rev_H) (I, rev_I)\"\n  shows \"subdivision (G, rev_G) (I, rev_I)\"", "lemma subdiv_compat: \"compatible G H\"", "lemma arc_to_ends_eq: \"arc_to_ends H = arc_to_ends G\"", "lemma head_eq: \"head H = head G\"", "lemma tail_eq: \"tail H = tail G\"", "lemma verts_H: \"verts H = verts G \\<union> {w}\"", "lemma verts_G: \"verts G = verts H - {w}\"", "lemma arcs_H: \"arcs H = {uw, wu, vw, wv} \\<union> arcs G - {uv, vu}\"", "lemma not_in_verts_G: \"w \\<notin> verts G\"", "lemma in_arcs_G: \"{uv, vu} \\<subseteq> arcs G\"", "lemma not_in_arcs_H: \"{uv,vu} \\<inter> arcs H = {}\"", "lemma subdiv_ate:\n      \"arc_to_ends G uv = (u,v)\"\n      \"arc_to_ends H uv = (u,v)\"\n      \"arc_to_ends H uw = (u,w)\"\n      \"arc_to_ends H vw = (v,w)\"", "lemma subdiv_ends[simp]:\n    \"tail G uv = u\" \"head G uv = v\" \"tail H uv = u\" \"head H uv = v\"\n    \"tail H uw = u\" \"head H uw = w\" \"tail H vw = v\" \"head H vw = w\"", "lemma subdiv_ends_G_rev[simp]:\n    \"tail G (vu) = v\" \"head G (vu) = u\" \"tail H (vu) = v\" \"head H (vu) = u\"", "lemma subdiv_distinct_verts0: \"u \\<noteq> w\" \"v \\<noteq> w\"", "lemma in_arcs_H: \"{uw, wu, vw, wv} \\<subseteq> arcs H\"", "lemma subdiv_ends_H_rev[simp]:\n    \"tail H (wu) = w\" \"tail H (wv) = w\"\n    \"head H (wu) = u\" \"head H (wv) = v\"", "lemma in_verts_G: \"{u,v} \\<subseteq> verts G\"", "lemma not_in_arcs_G: \"{uw, wu, vw, wv} \\<inter> arcs G = {}\"", "lemma subdiv_distinct_arcs: \"distinct [uv, vu, uw, wu, vw, wv]\"", "lemma arcs_G: \"arcs G = arcs H \\<union> {uv, vu} - {uw, wu, vw, wv}\"", "lemma subdiv_ate_H_rev:\n    \"arc_to_ends H (wu) = (w,u)\"\n    \"arc_to_ends H (wv) = (w,v)\"", "lemma adj_with_w: \"u \\<rightarrow>\\<^bsub>H\\<^esub> w\" \"w \\<rightarrow>\\<^bsub>H\\<^esub> u\" \"v \\<rightarrow>\\<^bsub>H\\<^esub> w\" \"w \\<rightarrow>\\<^bsub>H\\<^esub> v\"", "lemma w_reach: \"u \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> w\" \"w \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> u\" \"v \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> w\" \"w \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> v\"", "lemma G_reach: \"v \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> u\" \"u \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> v\"", "lemma out_arcs_w: \"out_arcs H w = {wu, wv}\"", "lemma out_degree_w: \"out_degree H w = 2\"", "lemma subdivision_compatible:\n  assumes \"subdivision (G, rev_G) (H, rev_H)\" shows \"compatible G H\"", "lemma subdivision_bidir:\n  assumes \"subdivision (G, rev_G) (H, rev_H)\"\n  shows \"bidirected_digraph H rev_H\"", "lemma subdivision_choose_rev:\n  assumes \"subdivision (G, rev_G) (H, rev_H)\" \"bidirected_digraph H rev_H'\"\n  shows \"\\<exists>rev_G'. subdivision (G, rev_G') (H, rev_H')\"", "lemma subdivision_verts_subset:\n  assumes \"subdivision (G,rev_G) (H,rev_H)\" \"x \\<in> verts G\"\n  shows \"x \\<in> verts H\"", "lemma arc_to_ends_with_proj[simp]: \"arc_to_ends (with_proj G) = id\"", "lemma bidirected_digraphI_pair_sd:\n    assumes \"pair_sd G H\" shows \"pair_bidirected_digraph H\"", "lemma subdivision_with_projI:\n    assumes \"pair_sd G H\"\n    shows \"subdivision_pair G H\"", "lemma subdivision_with_projD:\n    assumes \"subdivision_pair G H\"\n    shows \"pair_sd G H\"", "lemma subdivision_pair_conv:\n    \"pair_sd G H = subdivision_pair G H \"", "lemmas subdivision_pair_induct = pair_sd.induct[\n      unfolded subdivision_pair_conv, case_names base divide, induct pred: pair_sd]", "lemmas subdivision_pair_base = pair_sd.base[unfolded subdivision_pair_conv]", "lemmas subdivision_pair_divide = pair_sd.divide[unfolded subdivision_pair_conv]", "lemmas subdivision_pair_intros = pair_sd.intros[unfolded subdivision_pair_conv]", "lemmas subdivision_pair_cases = pair_sd.cases[unfolded subdivision_pair_conv]", "lemmas subdivision_pair_simps = pair_sd.simps[unfolded subdivision_pair_conv]", "lemmas bidirected_digraphI_subdivision = bidirected_digraphI_pair_sd[unfolded subdivision_pair_conv]", "lemma (in pair_graph) pair_graph_subdivision:\n  assumes \"subdivision_pair G H\"\n  shows \"pair_graph H\""], "translations": [["", "lemma subdivision_induct[case_names base divide, induct pred: subdivision]:\n  assumes \"subdivision (G, rev_G) (H, rev_H)\"\n    and \"bidirected_digraph G rev_G \\<Longrightarrow> P G rev_G\"\n    and \"\\<And>I rev_I H rev_H u v w uv uw vw.\n            subdivision (G, rev_G) (I, rev_I) \\<Longrightarrow> P I rev_I \\<Longrightarrow> subdivision_step I rev_I H rev_H (u, v, w) (uv, uw, vw) \\<Longrightarrow> P H rev_H\"\n  shows \"P H rev_H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P H rev_H", "using assms(1)"], ["proof (prove)\nusing this:\n  subdivision (G, rev_G) (H, rev_H)\n\ngoal (1 subgoal):\n 1. P H rev_H", "by (induct biH\\<equiv>\"(H, rev_H)\" arbitrary: H rev_H) (auto intro: assms(2,3))"], ["", "lemma subdivision_base:\n  \"bidirected_digraph G rev_G \\<Longrightarrow> subdivision (G, rev_G) (G, rev_G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bidirected_digraph G rev_G \\<Longrightarrow>\n    subdivision (G, rev_G) (G, rev_G)", "by (rule subdivision.base) simp"], ["", "lemma subdivision_step_rev:\n  assumes \"subdivision_step G rev_G H rev_H (u, v, w) (uv, uw, vw)\" \"subdivision (H, rev_H) (I, rev_I)\"\n  shows \"subdivision (G, rev_G) (I, rev_I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subdivision (G, rev_G) (I, rev_I)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. subdivision (G, rev_G) (I, rev_I)", "have \"bidirected_digraph (fst (G, rev_G)) (snd (G, rev_G))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bidirected_digraph (fst (G, rev_G)) (snd (G, rev_G))", "using assms"], ["proof (prove)\nusing this:\n  subdivision_step G rev_G H rev_H (u, v, w) (uv, uw, vw)\n  subdivision (H, rev_H) (I, rev_I)\n\ngoal (1 subgoal):\n 1. bidirected_digraph (fst (G, rev_G)) (snd (G, rev_G))", "by (auto simp: subdivision_step_def)"], ["proof (state)\nthis:\n  bidirected_digraph (fst (G, rev_G)) (snd (G, rev_G))\n\ngoal (1 subgoal):\n 1. subdivision (G, rev_G) (I, rev_I)", "with assms(2,1)"], ["proof (chain)\npicking this:\n  subdivision (H, rev_H) (I, rev_I)\n  subdivision_step G rev_G H rev_H (u, v, w) (uv, uw, vw)\n  bidirected_digraph (fst (G, rev_G)) (snd (G, rev_G))", "show ?thesis"], ["proof (prove)\nusing this:\n  subdivision (H, rev_H) (I, rev_I)\n  subdivision_step G rev_G H rev_H (u, v, w) (uv, uw, vw)\n  bidirected_digraph (fst (G, rev_G)) (snd (G, rev_G))\n\ngoal (1 subgoal):\n 1. subdivision (G, rev_G) (I, rev_I)", "using assms(2,1)"], ["proof (prove)\nusing this:\n  subdivision (H, rev_H) (I, rev_I)\n  subdivision_step G rev_G H rev_H (u, v, w) (uv, uw, vw)\n  bidirected_digraph (fst (G, rev_G)) (snd (G, rev_G))\n  subdivision (H, rev_H) (I, rev_I)\n  subdivision_step G rev_G H rev_H (u, v, w) (uv, uw, vw)\n\ngoal (1 subgoal):\n 1. subdivision (G, rev_G) (I, rev_I)", "by induct (auto intro: subdivision.intros dest: subdivision_base)"], ["proof (state)\nthis:\n  subdivision (G, rev_G) (I, rev_I)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subdivision_trans:\n  assumes \"subdivision (G, rev_G) (H, rev_H)\" \"subdivision (H, rev_H) (I, rev_I)\"\n  shows \"subdivision (G, rev_G) (I, rev_I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subdivision (G, rev_G) (I, rev_I)", "using assms"], ["proof (prove)\nusing this:\n  subdivision (G, rev_G) (H, rev_H)\n  subdivision (H, rev_H) (I, rev_I)\n\ngoal (1 subgoal):\n 1. subdivision (G, rev_G) (I, rev_I)", "by induction (auto intro: subdivision_step_rev)"], ["", "locale subdiv_step =\n  fixes G rev_G H rev_H u v w uv uw vw\n  assumes subdiv_step: \"subdivision_step G rev_G H rev_H (u, v, w) (uv, uw, vw)\""], ["", "sublocale subdiv_step \\<subseteq> G: bidirected_digraph G rev_G"], ["proof (prove)\ngoal (1 subgoal):\n 1. bidirected_digraph G rev_G", "using subdiv_step"], ["proof (prove)\nusing this:\n  subdivision_step G rev_G H rev_H (u, v, w) (uv, uw, vw)\n\ngoal (1 subgoal):\n 1. bidirected_digraph G rev_G", "unfolding subdivision_step_def"], ["proof (prove)\nusing this:\n  (case (u, v, w) of\n   (u, v, w) \\<Rightarrow>\n     \\<lambda>(uv, uw, vw).\n        bidirected_digraph G rev_G \\<and>\n        bidirected_digraph H rev_H \\<and>\n        perm_restrict rev_H (arcs G) = perm_restrict rev_G (arcs H) \\<and>\n        compatible G H \\<and>\n        verts H = verts G \\<union> {w} \\<and>\n        w \\<notin> verts G \\<and>\n        arcs H =\n        {uw, rev_H uw, vw, rev_H vw} \\<union> arcs G - {uv, rev_G uv} \\<and>\n        uv \\<in> arcs G \\<and>\n        distinct [uw, rev_H uw, vw, rev_H vw] \\<and>\n        arc_to_ends G uv = (u, v) \\<and>\n        arc_to_ends H uw = (u, w) \\<and> arc_to_ends H vw = (v, w))\n   (uv, uw, vw)\n\ngoal (1 subgoal):\n 1. bidirected_digraph G rev_G", "by simp"], ["", "sublocale subdiv_step \\<subseteq> H: bidirected_digraph H rev_H"], ["proof (prove)\ngoal (1 subgoal):\n 1. bidirected_digraph H rev_H", "using subdiv_step"], ["proof (prove)\nusing this:\n  subdivision_step G rev_G H rev_H (u, v, w) (uv, uw, vw)\n\ngoal (1 subgoal):\n 1. bidirected_digraph H rev_H", "unfolding subdivision_step_def"], ["proof (prove)\nusing this:\n  (case (u, v, w) of\n   (u, v, w) \\<Rightarrow>\n     \\<lambda>(uv, uw, vw).\n        bidirected_digraph G rev_G \\<and>\n        bidirected_digraph H rev_H \\<and>\n        perm_restrict rev_H (arcs G) = perm_restrict rev_G (arcs H) \\<and>\n        compatible G H \\<and>\n        verts H = verts G \\<union> {w} \\<and>\n        w \\<notin> verts G \\<and>\n        arcs H =\n        {uw, rev_H uw, vw, rev_H vw} \\<union> arcs G - {uv, rev_G uv} \\<and>\n        uv \\<in> arcs G \\<and>\n        distinct [uw, rev_H uw, vw, rev_H vw] \\<and>\n        arc_to_ends G uv = (u, v) \\<and>\n        arc_to_ends H uw = (u, w) \\<and> arc_to_ends H vw = (v, w))\n   (uv, uw, vw)\n\ngoal (1 subgoal):\n 1. bidirected_digraph H rev_H", "by simp"], ["", "context subdiv_step begin"], ["", "(*XXX*)"], ["", "abbreviation (input) \"vu \\<equiv> rev_G uv\""], ["", "abbreviation (input) \"wu \\<equiv> rev_H uw\""], ["", "abbreviation (input) \"wv \\<equiv> rev_H vw\""], ["", "lemma subdiv_compat: \"compatible G H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compatible G H", "using subdiv_step"], ["proof (prove)\nusing this:\n  subdivision_step G rev_G H rev_H (u, v, w) (uv, uw, vw)\n\ngoal (1 subgoal):\n 1. compatible G H", "by (simp add: subdivision_step_def)"], ["", "lemma arc_to_ends_eq: \"arc_to_ends H = arc_to_ends G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arc_to_ends H = arc_to_ends G", "using subdiv_compat"], ["proof (prove)\nusing this:\n  compatible G H\n\ngoal (1 subgoal):\n 1. arc_to_ends H = arc_to_ends G", "by (simp add: compatible_def arc_to_ends_def fun_eq_iff)"], ["", "lemma head_eq: \"head H = head G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head H = head G", "using subdiv_compat"], ["proof (prove)\nusing this:\n  compatible G H\n\ngoal (1 subgoal):\n 1. head H = head G", "by (simp add: compatible_def fun_eq_iff)"], ["", "lemma tail_eq: \"tail H = tail G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tail H = tail G", "using subdiv_compat"], ["proof (prove)\nusing this:\n  compatible G H\n\ngoal (1 subgoal):\n 1. tail H = tail G", "by (simp add: compatible_def fun_eq_iff)"], ["", "lemma verts_H: \"verts H = verts G \\<union> {w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. verts H = verts G \\<union> {w}", "using subdiv_step"], ["proof (prove)\nusing this:\n  subdivision_step G rev_G H rev_H (u, v, w) (uv, uw, vw)\n\ngoal (1 subgoal):\n 1. verts H = verts G \\<union> {w}", "by (simp add: subdivision_step_def)"], ["", "lemma verts_G: \"verts G = verts H - {w}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. verts G = verts H - {w}", "using subdiv_step"], ["proof (prove)\nusing this:\n  subdivision_step G rev_G H rev_H (u, v, w) (uv, uw, vw)\n\ngoal (1 subgoal):\n 1. verts G = verts H - {w}", "by (auto simp: subdivision_step_def)"], ["", "lemma arcs_H: \"arcs H = {uw, wu, vw, wv} \\<union> arcs G - {uv, vu}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arcs H = {uw, rev_H uw, vw, rev_H vw} \\<union> arcs G - {uv, rev_G uv}", "using subdiv_step"], ["proof (prove)\nusing this:\n  subdivision_step G rev_G H rev_H (u, v, w) (uv, uw, vw)\n\ngoal (1 subgoal):\n 1. arcs H = {uw, rev_H uw, vw, rev_H vw} \\<union> arcs G - {uv, rev_G uv}", "by (simp add: subdivision_step_def)"], ["", "lemma not_in_verts_G: \"w \\<notin> verts G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<notin> verts G", "using subdiv_step"], ["proof (prove)\nusing this:\n  subdivision_step G rev_G H rev_H (u, v, w) (uv, uw, vw)\n\ngoal (1 subgoal):\n 1. w \\<notin> verts G", "by (simp add: subdivision_step_def)"], ["", "lemma in_arcs_G: \"{uv, vu} \\<subseteq> arcs G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {uv, rev_G uv} \\<subseteq> arcs G", "using subdiv_step"], ["proof (prove)\nusing this:\n  subdivision_step G rev_G H rev_H (u, v, w) (uv, uw, vw)\n\ngoal (1 subgoal):\n 1. {uv, rev_G uv} \\<subseteq> arcs G", "by (simp add: subdivision_step_def)"], ["", "lemma not_in_arcs_H: \"{uv,vu} \\<inter> arcs H = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {uv, rev_G uv} \\<inter> arcs H = {}", "using arcs_H"], ["proof (prove)\nusing this:\n  arcs H = {uw, rev_H uw, vw, rev_H vw} \\<union> arcs G - {uv, rev_G uv}\n\ngoal (1 subgoal):\n 1. {uv, rev_G uv} \\<inter> arcs H = {}", "by auto"], ["", "lemma subdiv_ate:\n      \"arc_to_ends G uv = (u,v)\"\n      \"arc_to_ends H uv = (u,v)\"\n      \"arc_to_ends H uw = (u,w)\"\n      \"arc_to_ends H vw = (v,w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (arc_to_ends G uv = (u, v) &&& arc_to_ends H uv = (u, v)) &&&\n    arc_to_ends H uw = (u, w) &&& arc_to_ends H vw = (v, w)", "using subdiv_step subdiv_compat"], ["proof (prove)\nusing this:\n  subdivision_step G rev_G H rev_H (u, v, w) (uv, uw, vw)\n  compatible G H\n\ngoal (1 subgoal):\n 1. (arc_to_ends G uv = (u, v) &&& arc_to_ends H uv = (u, v)) &&&\n    arc_to_ends H uw = (u, w) &&& arc_to_ends H vw = (v, w)", "by (auto simp: subdivision_step_def arc_to_ends_def compatible_def)"], ["", "lemma subdiv_ends[simp]:\n    \"tail G uv = u\" \"head G uv = v\" \"tail H uv = u\" \"head H uv = v\"\n    \"tail H uw = u\" \"head H uw = w\" \"tail H vw = v\" \"head H vw = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((tail G uv = u &&& head G uv = v) &&&\n     tail H uv = u &&& head H uv = v) &&&\n    (tail H uw = u &&& head H uw = w) &&& tail H vw = v &&& head H vw = w", "using subdiv_ate"], ["proof (prove)\nusing this:\n  arc_to_ends G uv = (u, v)\n  arc_to_ends H uv = (u, v)\n  arc_to_ends H uw = (u, w)\n  arc_to_ends H vw = (v, w)\n\ngoal (1 subgoal):\n 1. ((tail G uv = u &&& head G uv = v) &&&\n     tail H uv = u &&& head H uv = v) &&&\n    (tail H uw = u &&& head H uw = w) &&& tail H vw = v &&& head H vw = w", "by (auto simp: arc_to_ends_def)"], ["", "lemma subdiv_ends_G_rev[simp]:\n    \"tail G (vu) = v\" \"head G (vu) = u\" \"tail H (vu) = v\" \"head H (vu) = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (tail G (rev_G uv) = v &&& head G (rev_G uv) = u) &&&\n    tail H (rev_G uv) = v &&& head H (rev_G uv) = u", "using in_arcs_G"], ["proof (prove)\nusing this:\n  {uv, rev_G uv} \\<subseteq> arcs G\n\ngoal (1 subgoal):\n 1. (tail G (rev_G uv) = v &&& head G (rev_G uv) = u) &&&\n    tail H (rev_G uv) = v &&& head H (rev_G uv) = u", "by (auto simp: tail_eq head_eq)"], ["", "lemma subdiv_distinct_verts0: \"u \\<noteq> w\" \"v \\<noteq> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<noteq> w &&& v \\<noteq> w", "using in_arcs_G not_in_verts_G"], ["proof (prove)\nusing this:\n  {uv, rev_G uv} \\<subseteq> arcs G\n  w \\<notin> verts G\n\ngoal (1 subgoal):\n 1. u \\<noteq> w &&& v \\<noteq> w", "using subdiv_ate"], ["proof (prove)\nusing this:\n  {uv, rev_G uv} \\<subseteq> arcs G\n  w \\<notin> verts G\n  arc_to_ends G uv = (u, v)\n  arc_to_ends H uv = (u, v)\n  arc_to_ends H uw = (u, w)\n  arc_to_ends H vw = (v, w)\n\ngoal (1 subgoal):\n 1. u \\<noteq> w &&& v \\<noteq> w", "by (auto simp: arc_to_ends_def dest: G.wellformed)"], ["", "lemma in_arcs_H: \"{uw, wu, vw, wv} \\<subseteq> arcs H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H", "assume \"uv = uw\""], ["proof (state)\nthis:\n  uv = uw\n\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H", "then"], ["proof (chain)\npicking this:\n  uv = uw", "have \"arc_to_ends H uv = arc_to_ends H uw\""], ["proof (prove)\nusing this:\n  uv = uw\n\ngoal (1 subgoal):\n 1. arc_to_ends H uv = arc_to_ends H uw", "by simp"], ["proof (state)\nthis:\n  arc_to_ends H uv = arc_to_ends H uw\n\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H", "then"], ["proof (chain)\npicking this:\n  arc_to_ends H uv = arc_to_ends H uw", "have \"v = w\""], ["proof (prove)\nusing this:\n  arc_to_ends H uv = arc_to_ends H uw\n\ngoal (1 subgoal):\n 1. v = w", "by (simp add: arc_to_ends_def)"], ["proof (state)\nthis:\n  v = w\n\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H", "}"], ["proof (state)\nthis:\n  uv = uw \\<Longrightarrow> v = w\n\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H", "moreover"], ["proof (state)\nthis:\n  uv = uw \\<Longrightarrow> v = w\n\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H", "{"], ["proof (state)\nthis:\n  uv = uw \\<Longrightarrow> v = w\n\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H", "assume \"uv = vw\""], ["proof (state)\nthis:\n  uv = vw\n\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H", "then"], ["proof (chain)\npicking this:\n  uv = vw", "have \"arc_to_ends H uv = arc_to_ends H vw\""], ["proof (prove)\nusing this:\n  uv = vw\n\ngoal (1 subgoal):\n 1. arc_to_ends H uv = arc_to_ends H vw", "by simp"], ["proof (state)\nthis:\n  arc_to_ends H uv = arc_to_ends H vw\n\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H", "then"], ["proof (chain)\npicking this:\n  arc_to_ends H uv = arc_to_ends H vw", "have \"v = w\""], ["proof (prove)\nusing this:\n  arc_to_ends H uv = arc_to_ends H vw\n\ngoal (1 subgoal):\n 1. v = w", "by (simp add: arc_to_ends_def)"], ["proof (state)\nthis:\n  v = w\n\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H", "}"], ["proof (state)\nthis:\n  uv = vw \\<Longrightarrow> v = w\n\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H", "moreover"], ["proof (state)\nthis:\n  uv = vw \\<Longrightarrow> v = w\n\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H", "{"], ["proof (state)\nthis:\n  uv = vw \\<Longrightarrow> v = w\n\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H", "assume \"vu = uw\""], ["proof (state)\nthis:\n  rev_G uv = uw\n\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H", "then"], ["proof (chain)\npicking this:\n  rev_G uv = uw", "have \"arc_to_ends H (vu) = arc_to_ends H uw\""], ["proof (prove)\nusing this:\n  rev_G uv = uw\n\ngoal (1 subgoal):\n 1. arc_to_ends H (rev_G uv) = arc_to_ends H uw", "by simp"], ["proof (state)\nthis:\n  arc_to_ends H (rev_G uv) = arc_to_ends H uw\n\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H", "then"], ["proof (chain)\npicking this:\n  arc_to_ends H (rev_G uv) = arc_to_ends H uw", "have \"u = w\""], ["proof (prove)\nusing this:\n  arc_to_ends H (rev_G uv) = arc_to_ends H uw\n\ngoal (1 subgoal):\n 1. u = w", "by (simp add: arc_to_ends_def)"], ["proof (state)\nthis:\n  u = w\n\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H", "}"], ["proof (state)\nthis:\n  rev_G uv = uw \\<Longrightarrow> u = w\n\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H", "moreover"], ["proof (state)\nthis:\n  rev_G uv = uw \\<Longrightarrow> u = w\n\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H", "{"], ["proof (state)\nthis:\n  rev_G uv = uw \\<Longrightarrow> u = w\n\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H", "assume \"vu = vw\""], ["proof (state)\nthis:\n  rev_G uv = vw\n\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H", "then"], ["proof (chain)\npicking this:\n  rev_G uv = vw", "have \"arc_to_ends H (vu) = arc_to_ends H vw\""], ["proof (prove)\nusing this:\n  rev_G uv = vw\n\ngoal (1 subgoal):\n 1. arc_to_ends H (rev_G uv) = arc_to_ends H vw", "by simp"], ["proof (state)\nthis:\n  arc_to_ends H (rev_G uv) = arc_to_ends H vw\n\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H", "then"], ["proof (chain)\npicking this:\n  arc_to_ends H (rev_G uv) = arc_to_ends H vw", "have \"u = w\""], ["proof (prove)\nusing this:\n  arc_to_ends H (rev_G uv) = arc_to_ends H vw\n\ngoal (1 subgoal):\n 1. u = w", "by (simp add: arc_to_ends_def)"], ["proof (state)\nthis:\n  u = w\n\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H", "}"], ["proof (state)\nthis:\n  rev_G uv = vw \\<Longrightarrow> u = w\n\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H", "ultimately"], ["proof (chain)\npicking this:\n  uv = uw \\<Longrightarrow> v = w\n  uv = vw \\<Longrightarrow> v = w\n  rev_G uv = uw \\<Longrightarrow> u = w\n  rev_G uv = vw \\<Longrightarrow> u = w", "have \"{uw,vw} \\<subseteq> arcs H\""], ["proof (prove)\nusing this:\n  uv = uw \\<Longrightarrow> v = w\n  uv = vw \\<Longrightarrow> v = w\n  rev_G uv = uw \\<Longrightarrow> u = w\n  rev_G uv = vw \\<Longrightarrow> u = w\n\ngoal (1 subgoal):\n 1. {uw, vw} \\<subseteq> arcs H", "unfolding arcs_H"], ["proof (prove)\nusing this:\n  uv = uw \\<Longrightarrow> v = w\n  uv = vw \\<Longrightarrow> v = w\n  rev_G uv = uw \\<Longrightarrow> u = w\n  rev_G uv = vw \\<Longrightarrow> u = w\n\ngoal (1 subgoal):\n 1. {uw, vw}\n    \\<subseteq> {uw, rev_H uw, vw, rev_H vw} \\<union> arcs G -\n                {uv, rev_G uv}", "using subdiv_distinct_verts0"], ["proof (prove)\nusing this:\n  uv = uw \\<Longrightarrow> v = w\n  uv = vw \\<Longrightarrow> v = w\n  rev_G uv = uw \\<Longrightarrow> u = w\n  rev_G uv = vw \\<Longrightarrow> u = w\n  u \\<noteq> w\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. {uw, vw}\n    \\<subseteq> {uw, rev_H uw, vw, rev_H vw} \\<union> arcs G -\n                {uv, rev_G uv}", "by auto"], ["proof (state)\nthis:\n  {uw, vw} \\<subseteq> arcs H\n\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H", "then"], ["proof (chain)\npicking this:\n  {uw, vw} \\<subseteq> arcs H", "show ?thesis"], ["proof (prove)\nusing this:\n  {uw, vw} \\<subseteq> arcs H\n\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H", "by auto"], ["proof (state)\nthis:\n  {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subdiv_ends_H_rev[simp]:\n    \"tail H (wu) = w\" \"tail H (wv) = w\"\n    \"head H (wu) = u\" \"head H (wv) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (tail H (rev_H uw) = w &&& tail H (rev_H vw) = w) &&&\n    head H (rev_H uw) = u &&& head H (rev_H vw) = v", "using in_arcs_H subdiv_ate"], ["proof (prove)\nusing this:\n  {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H\n  arc_to_ends G uv = (u, v)\n  arc_to_ends H uv = (u, v)\n  arc_to_ends H uw = (u, w)\n  arc_to_ends H vw = (v, w)\n\ngoal (1 subgoal):\n 1. (tail H (rev_H uw) = w &&& tail H (rev_H vw) = w) &&&\n    head H (rev_H uw) = u &&& head H (rev_H vw) = v", "by simp_all"], ["", "lemma in_verts_G: \"{u,v} \\<subseteq> verts G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {u, v} \\<subseteq> verts G", "using in_arcs_G"], ["proof (prove)\nusing this:\n  {uv, rev_G uv} \\<subseteq> arcs G\n\ngoal (1 subgoal):\n 1. {u, v} \\<subseteq> verts G", "by (auto dest: G.wellformed)"], ["", "lemma not_in_arcs_G: \"{uw, wu, vw, wv} \\<inter> arcs G = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<inter> arcs G = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<inter> arcs G = {}", "note X = G.wellformed[simplified tail_eq[symmetric] head_eq[symmetric]]"], ["proof (state)\nthis:\n  ?e \\<in> arcs G \\<Longrightarrow> tail H ?e \\<in> verts G\n  ?e \\<in> arcs G \\<Longrightarrow> head H ?e \\<in> verts G\n\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<inter> arcs G = {}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<inter> arcs G = {}", "using not_in_verts_G in_arcs_H"], ["proof (prove)\nusing this:\n  w \\<notin> verts G\n  {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H\n\ngoal (1 subgoal):\n 1. {uw, rev_H uw, vw, rev_H vw} \\<inter> arcs G = {}", "by (auto dest: X )"], ["proof (state)\nthis:\n  {uw, rev_H uw, vw, rev_H vw} \\<inter> arcs G = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subdiv_distinct_arcs: \"distinct [uv, vu, uw, wu, vw, wv]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct [uv, rev_G uv, uw, rev_H uw, vw, rev_H vw]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct [uv, rev_G uv, uw, rev_H uw, vw, rev_H vw]", "have \"distinct [uw, wu, vw, wv]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct [uw, rev_H uw, vw, rev_H vw]", "using subdiv_step"], ["proof (prove)\nusing this:\n  subdivision_step G rev_G H rev_H (u, v, w) (uv, uw, vw)\n\ngoal (1 subgoal):\n 1. distinct [uw, rev_H uw, vw, rev_H vw]", "by (simp add: subdivision_step_def)"], ["proof (state)\nthis:\n  distinct [uw, rev_H uw, vw, rev_H vw]\n\ngoal (1 subgoal):\n 1. distinct [uv, rev_G uv, uw, rev_H uw, vw, rev_H vw]", "moreover"], ["proof (state)\nthis:\n  distinct [uw, rev_H uw, vw, rev_H vw]\n\ngoal (1 subgoal):\n 1. distinct [uv, rev_G uv, uw, rev_H uw, vw, rev_H vw]", "have \"distinct [uv, vu]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct [uv, rev_G uv]", "using in_arcs_G G.arev_dom"], ["proof (prove)\nusing this:\n  {uv, rev_G uv} \\<subseteq> arcs G\n  (?a \\<in> arcs G) = (rev_G ?a \\<noteq> ?a)\n\ngoal (1 subgoal):\n 1. distinct [uv, rev_G uv]", "by auto"], ["proof (state)\nthis:\n  distinct [uv, rev_G uv]\n\ngoal (1 subgoal):\n 1. distinct [uv, rev_G uv, uw, rev_H uw, vw, rev_H vw]", "moreover"], ["proof (state)\nthis:\n  distinct [uv, rev_G uv]\n\ngoal (1 subgoal):\n 1. distinct [uv, rev_G uv, uw, rev_H uw, vw, rev_H vw]", "have \"{uv, vu} \\<inter> {uw, wu, vw, wv} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {uv, rev_G uv} \\<inter> {uw, rev_H uw, vw, rev_H vw} = {}", "using arcs_H in_arcs_H"], ["proof (prove)\nusing this:\n  arcs H = {uw, rev_H uw, vw, rev_H vw} \\<union> arcs G - {uv, rev_G uv}\n  {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H\n\ngoal (1 subgoal):\n 1. {uv, rev_G uv} \\<inter> {uw, rev_H uw, vw, rev_H vw} = {}", "by auto"], ["proof (state)\nthis:\n  {uv, rev_G uv} \\<inter> {uw, rev_H uw, vw, rev_H vw} = {}\n\ngoal (1 subgoal):\n 1. distinct [uv, rev_G uv, uw, rev_H uw, vw, rev_H vw]", "ultimately"], ["proof (chain)\npicking this:\n  distinct [uw, rev_H uw, vw, rev_H vw]\n  distinct [uv, rev_G uv]\n  {uv, rev_G uv} \\<inter> {uw, rev_H uw, vw, rev_H vw} = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct [uw, rev_H uw, vw, rev_H vw]\n  distinct [uv, rev_G uv]\n  {uv, rev_G uv} \\<inter> {uw, rev_H uw, vw, rev_H vw} = {}\n\ngoal (1 subgoal):\n 1. distinct [uv, rev_G uv, uw, rev_H uw, vw, rev_H vw]", "by auto"], ["proof (state)\nthis:\n  distinct [uv, rev_G uv, uw, rev_H uw, vw, rev_H vw]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arcs_G: \"arcs G = arcs H \\<union> {uv, vu} - {uw, wu, vw, wv}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arcs G = arcs H \\<union> {uv, rev_G uv} - {uw, rev_H uw, vw, rev_H vw}", "using in_arcs_G not_in_arcs_G"], ["proof (prove)\nusing this:\n  {uv, rev_G uv} \\<subseteq> arcs G\n  {uw, rev_H uw, vw, rev_H vw} \\<inter> arcs G = {}\n\ngoal (1 subgoal):\n 1. arcs G = arcs H \\<union> {uv, rev_G uv} - {uw, rev_H uw, vw, rev_H vw}", "unfolding arcs_H"], ["proof (prove)\nusing this:\n  {uv, rev_G uv} \\<subseteq> arcs G\n  {uw, rev_H uw, vw, rev_H vw} \\<inter> arcs G = {}\n\ngoal (1 subgoal):\n 1. arcs G =\n    {uw, rev_H uw, vw, rev_H vw} \\<union> arcs G - {uv, rev_G uv} \\<union>\n    {uv, rev_G uv} -\n    {uw, rev_H uw, vw, rev_H vw}", "by auto"], ["", "lemma subdiv_ate_H_rev:\n    \"arc_to_ends H (wu) = (w,u)\"\n    \"arc_to_ends H (wv) = (w,v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arc_to_ends H (rev_H uw) = (w, u) &&& arc_to_ends H (rev_H vw) = (w, v)", "using in_arcs_H subdiv_ate"], ["proof (prove)\nusing this:\n  {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H\n  arc_to_ends G uv = (u, v)\n  arc_to_ends H uv = (u, v)\n  arc_to_ends H uw = (u, w)\n  arc_to_ends H vw = (v, w)\n\ngoal (1 subgoal):\n 1. arc_to_ends H (rev_H uw) = (w, u) &&& arc_to_ends H (rev_H vw) = (w, v)", "by simp_all"], ["", "lemma adj_with_w: \"u \\<rightarrow>\\<^bsub>H\\<^esub> w\" \"w \\<rightarrow>\\<^bsub>H\\<^esub> u\" \"v \\<rightarrow>\\<^bsub>H\\<^esub> w\" \"w \\<rightarrow>\\<^bsub>H\\<^esub> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u \\<rightarrow>\\<^bsub>H\\<^esub> w &&&\n     w \\<rightarrow>\\<^bsub>H\\<^esub> u) &&&\n    v \\<rightarrow>\\<^bsub>H\\<^esub> w &&&\n    w \\<rightarrow>\\<^bsub>H\\<^esub> v", "using in_arcs_H subdiv_ate"], ["proof (prove)\nusing this:\n  {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H\n  arc_to_ends G uv = (u, v)\n  arc_to_ends H uv = (u, v)\n  arc_to_ends H uw = (u, w)\n  arc_to_ends H vw = (v, w)\n\ngoal (1 subgoal):\n 1. (u \\<rightarrow>\\<^bsub>H\\<^esub> w &&&\n     w \\<rightarrow>\\<^bsub>H\\<^esub> u) &&&\n    v \\<rightarrow>\\<^bsub>H\\<^esub> w &&&\n    w \\<rightarrow>\\<^bsub>H\\<^esub> v", "by (auto intro: H.dominatesI[rotated])"], ["", "lemma w_reach: \"u \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> w\" \"w \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> u\" \"v \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> w\" \"w \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> w &&&\n     w \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> u) &&&\n    v \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> w &&&\n    w \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> v", "using adj_with_w"], ["proof (prove)\nusing this:\n  u \\<rightarrow>\\<^bsub>H\\<^esub> w\n  w \\<rightarrow>\\<^bsub>H\\<^esub> u\n  v \\<rightarrow>\\<^bsub>H\\<^esub> w\n  w \\<rightarrow>\\<^bsub>H\\<^esub> v\n\ngoal (1 subgoal):\n 1. (u \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> w &&&\n     w \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> u) &&&\n    v \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> w &&&\n    w \\<rightarrow>\\<^sup>*\\<^bsub>H\\<^esub> v", "by auto"], ["", "lemma G_reach: \"v \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> u\" \"u \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> u &&&\n    u \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> v", "using subdiv_ate in_arcs_G"], ["proof (prove)\nusing this:\n  arc_to_ends G uv = (u, v)\n  arc_to_ends H uv = (u, v)\n  arc_to_ends H uw = (u, w)\n  arc_to_ends H vw = (v, w)\n  {uv, rev_G uv} \\<subseteq> arcs G\n\ngoal (1 subgoal):\n 1. v \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> u &&&\n    u \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> v", "by (simp add: G.dominatesI G.symmetric_reachable')+"], ["", "lemma out_arcs_w: \"out_arcs H w = {wu, wv}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. out_arcs H w = {rev_H uw, rev_H vw}", "using subdiv_distinct_verts0 in_arcs_H"], ["proof (prove)\nusing this:\n  u \\<noteq> w\n  v \\<noteq> w\n  {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H\n\ngoal (1 subgoal):\n 1. out_arcs H w = {rev_H uw, rev_H vw}", "by (auto simp: arcs_H) (auto simp: tail_eq verts_G dest: G.tail_in_verts)"], ["", "lemma out_degree_w: \"out_degree H w = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. out_degree H w = 2", "using subdiv_distinct_arcs"], ["proof (prove)\nusing this:\n  distinct [uv, rev_G uv, uw, rev_H uw, vw, rev_H vw]\n\ngoal (1 subgoal):\n 1. out_degree H w = 2", "by (auto simp: out_degree_def out_arcs_w card_insert_if)"], ["", "end"], ["", "lemma subdivision_compatible:\n  assumes \"subdivision (G, rev_G) (H, rev_H)\" shows \"compatible G H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compatible G H", "using assms"], ["proof (prove)\nusing this:\n  subdivision (G, rev_G) (H, rev_H)\n\ngoal (1 subgoal):\n 1. compatible G H", "by induct (auto simp: compatible_def subdivision_step_def)"], ["", "lemma subdivision_bidir:\n  assumes \"subdivision (G, rev_G) (H, rev_H)\"\n  shows \"bidirected_digraph H rev_H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bidirected_digraph H rev_H", "using assms"], ["proof (prove)\nusing this:\n  subdivision (G, rev_G) (H, rev_H)\n\ngoal (1 subgoal):\n 1. bidirected_digraph H rev_H", "by induct (auto simp: subdivision_step_def)"], ["", "lemma subdivision_choose_rev:\n  assumes \"subdivision (G, rev_G) (H, rev_H)\" \"bidirected_digraph H rev_H'\"\n  shows \"\\<exists>rev_G'. subdivision (G, rev_G') (H, rev_H')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rev_G'. subdivision (G, rev_G') (H, rev_H')", "using assms"], ["proof (prove)\nusing this:\n  subdivision (G, rev_G) (H, rev_H)\n  bidirected_digraph H rev_H'\n\ngoal (1 subgoal):\n 1. \\<exists>rev_G'. subdivision (G, rev_G') (H, rev_H')", "proof (induction arbitrary: rev_H')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>rev_H'.\n       \\<lbrakk>bidirected_digraph G rev_G;\n        bidirected_digraph G rev_H'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rev_G'.\n                            subdivision (G, rev_G') (G, rev_H')\n 2. \\<And>I rev_I H rev_H u v w uv uw vw rev_H'.\n       \\<lbrakk>subdivision (G, rev_G) (I, rev_I);\n        \\<And>rev_H'.\n           bidirected_digraph I rev_H' \\<Longrightarrow>\n           \\<exists>rev_G'. subdivision (G, rev_G') (I, rev_H');\n        subdivision_step I rev_I H rev_H (u, v, w) (uv, uw, vw);\n        bidirected_digraph H rev_H'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rev_G'.\n                            subdivision (G, rev_G') (H, rev_H')", "case base"], ["proof (state)\nthis:\n  bidirected_digraph G rev_G\n  bidirected_digraph G rev_H'\n\ngoal (2 subgoals):\n 1. \\<And>rev_H'.\n       \\<lbrakk>bidirected_digraph G rev_G;\n        bidirected_digraph G rev_H'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rev_G'.\n                            subdivision (G, rev_G') (G, rev_H')\n 2. \\<And>I rev_I H rev_H u v w uv uw vw rev_H'.\n       \\<lbrakk>subdivision (G, rev_G) (I, rev_I);\n        \\<And>rev_H'.\n           bidirected_digraph I rev_H' \\<Longrightarrow>\n           \\<exists>rev_G'. subdivision (G, rev_G') (I, rev_H');\n        subdivision_step I rev_I H rev_H (u, v, w) (uv, uw, vw);\n        bidirected_digraph H rev_H'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rev_G'.\n                            subdivision (G, rev_G') (H, rev_H')", "then"], ["proof (chain)\npicking this:\n  bidirected_digraph G rev_G\n  bidirected_digraph G rev_H'", "show ?case"], ["proof (prove)\nusing this:\n  bidirected_digraph G rev_G\n  bidirected_digraph G rev_H'\n\ngoal (1 subgoal):\n 1. \\<exists>rev_G'. subdivision (G, rev_G') (G, rev_H')", "by (auto dest: subdivision_base)"], ["proof (state)\nthis:\n  \\<exists>rev_G'. subdivision (G, rev_G') (G, rev_H')\n\ngoal (1 subgoal):\n 1. \\<And>I rev_I H rev_H u v w uv uw vw rev_H'.\n       \\<lbrakk>subdivision (G, rev_G) (I, rev_I);\n        \\<And>rev_H'.\n           bidirected_digraph I rev_H' \\<Longrightarrow>\n           \\<exists>rev_G'. subdivision (G, rev_G') (I, rev_H');\n        subdivision_step I rev_I H rev_H (u, v, w) (uv, uw, vw);\n        bidirected_digraph H rev_H'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rev_G'.\n                            subdivision (G, rev_G') (H, rev_H')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I rev_I H rev_H u v w uv uw vw rev_H'.\n       \\<lbrakk>subdivision (G, rev_G) (I, rev_I);\n        \\<And>rev_H'.\n           bidirected_digraph I rev_H' \\<Longrightarrow>\n           \\<exists>rev_G'. subdivision (G, rev_G') (I, rev_H');\n        subdivision_step I rev_I H rev_H (u, v, w) (uv, uw, vw);\n        bidirected_digraph H rev_H'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rev_G'.\n                            subdivision (G, rev_G') (H, rev_H')", "case (divide I rev_I H rev_H u v w uv uw vw)"], ["proof (state)\nthis:\n  subdivision (G, rev_G) (I, rev_I)\n  subdivision_step I rev_I H rev_H (u, v, w) (uv, uw, vw)\n  bidirected_digraph I ?rev_H' \\<Longrightarrow>\n  \\<exists>rev_G'. subdivision (G, rev_G') (I, ?rev_H')\n  bidirected_digraph H rev_H'\n\ngoal (1 subgoal):\n 1. \\<And>I rev_I H rev_H u v w uv uw vw rev_H'.\n       \\<lbrakk>subdivision (G, rev_G) (I, rev_I);\n        \\<And>rev_H'.\n           bidirected_digraph I rev_H' \\<Longrightarrow>\n           \\<exists>rev_G'. subdivision (G, rev_G') (I, rev_H');\n        subdivision_step I rev_I H rev_H (u, v, w) (uv, uw, vw);\n        bidirected_digraph H rev_H'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rev_G'.\n                            subdivision (G, rev_G') (H, rev_H')", "interpret subdiv_step I rev_I H rev_H u v w uv uw vw"], ["proof (prove)\ngoal (1 subgoal):\n 1. subdiv_step I rev_I H rev_H u v w uv uw vw", "using divide"], ["proof (prove)\nusing this:\n  subdivision (G, rev_G) (I, rev_I)\n  subdivision_step I rev_I H rev_H (u, v, w) (uv, uw, vw)\n  bidirected_digraph I ?rev_H' \\<Longrightarrow>\n  \\<exists>rev_G'. subdivision (G, rev_G') (I, ?rev_H')\n  bidirected_digraph H rev_H'\n\ngoal (1 subgoal):\n 1. subdiv_step I rev_I H rev_H u v w uv uw vw", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I rev_I H rev_H u v w uv uw vw rev_H'.\n       \\<lbrakk>subdivision (G, rev_G) (I, rev_I);\n        \\<And>rev_H'.\n           bidirected_digraph I rev_H' \\<Longrightarrow>\n           \\<exists>rev_G'. subdivision (G, rev_G') (I, rev_H');\n        subdivision_step I rev_I H rev_H (u, v, w) (uv, uw, vw);\n        bidirected_digraph H rev_H'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rev_G'.\n                            subdivision (G, rev_G') (H, rev_H')", "interpret H': bidirected_digraph H rev_H'"], ["proof (prove)\ngoal (1 subgoal):\n 1. bidirected_digraph H rev_H'", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I rev_I H rev_H u v w uv uw vw rev_H'.\n       \\<lbrakk>subdivision (G, rev_G) (I, rev_I);\n        \\<And>rev_H'.\n           bidirected_digraph I rev_H' \\<Longrightarrow>\n           \\<exists>rev_G'. subdivision (G, rev_G') (I, rev_H');\n        subdivision_step I rev_I H rev_H (u, v, w) (uv, uw, vw);\n        bidirected_digraph H rev_H'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rev_G'.\n                            subdivision (G, rev_G') (H, rev_H')", "define rev_I' where \"rev_I' x =\n    (if x = uv then rev_I uv else if x = rev_I uv then uv else if x \\<in> arcs I then rev_H' x else x)\"\n    for x"], ["proof (state)\nthis:\n  rev_I' ?x =\n  (if ?x = uv then rev_I uv\n   else if ?x = rev_I uv then uv\n        else if ?x \\<in> arcs I then rev_H' ?x else ?x)\n\ngoal (1 subgoal):\n 1. \\<And>I rev_I H rev_H u v w uv uw vw rev_H'.\n       \\<lbrakk>subdivision (G, rev_G) (I, rev_I);\n        \\<And>rev_H'.\n           bidirected_digraph I rev_H' \\<Longrightarrow>\n           \\<exists>rev_G'. subdivision (G, rev_G') (I, rev_H');\n        subdivision_step I rev_I H rev_H (u, v, w) (uv, uw, vw);\n        bidirected_digraph H rev_H'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rev_G'.\n                            subdivision (G, rev_G') (H, rev_H')", "have rev_H_injD: \"\\<And>x y z. rev_H' x = z \\<Longrightarrow> rev_H' y = z \\<Longrightarrow> x \\<noteq> y \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>rev_H' x = z; rev_H' y = z; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis H'.arev_eq_iff)"], ["proof (state)\nthis:\n  \\<lbrakk>rev_H' ?x = ?z; rev_H' ?y = ?z; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>I rev_I H rev_H u v w uv uw vw rev_H'.\n       \\<lbrakk>subdivision (G, rev_G) (I, rev_I);\n        \\<And>rev_H'.\n           bidirected_digraph I rev_H' \\<Longrightarrow>\n           \\<exists>rev_G'. subdivision (G, rev_G') (I, rev_H');\n        subdivision_step I rev_I H rev_H (u, v, w) (uv, uw, vw);\n        bidirected_digraph H rev_H'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rev_G'.\n                            subdivision (G, rev_G') (H, rev_H')", "have rev_H'_simps: \"rev_H' uw = rev_H uw \\<and> rev_H' vw = rev_H vw\n    \\<or> rev_H' uw = rev_H vw \\<and> rev_H' vw = rev_H uw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev_H' uw = rev_H uw \\<and> rev_H' vw = rev_H vw \\<or>\n    rev_H' uw = rev_H vw \\<and> rev_H' vw = rev_H uw", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rev_H' uw = rev_H uw \\<and> rev_H' vw = rev_H vw \\<or>\n    rev_H' uw = rev_H vw \\<and> rev_H' vw = rev_H uw", "have \"arc_to_ends H (rev_H' uw) = (w,u)\" \"arc_to_ends H (rev_H' vw) = (w,v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arc_to_ends H (rev_H' uw) = (w, u) &&&\n    arc_to_ends H (rev_H' vw) = (w, v)", "using in_arcs_H"], ["proof (prove)\nusing this:\n  {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H\n\ngoal (1 subgoal):\n 1. arc_to_ends H (rev_H' uw) = (w, u) &&&\n    arc_to_ends H (rev_H' vw) = (w, v)", "by (auto simp: subdiv_ate)"], ["proof (state)\nthis:\n  arc_to_ends H (rev_H' uw) = (w, u)\n  arc_to_ends H (rev_H' vw) = (w, v)\n\ngoal (1 subgoal):\n 1. rev_H' uw = rev_H uw \\<and> rev_H' vw = rev_H vw \\<or>\n    rev_H' uw = rev_H vw \\<and> rev_H' vw = rev_H uw", "moreover"], ["proof (state)\nthis:\n  arc_to_ends H (rev_H' uw) = (w, u)\n  arc_to_ends H (rev_H' vw) = (w, v)\n\ngoal (1 subgoal):\n 1. rev_H' uw = rev_H uw \\<and> rev_H' vw = rev_H vw \\<or>\n    rev_H' uw = rev_H vw \\<and> rev_H' vw = rev_H uw", "have \"\\<And>x. x \\<in> arcs H \\<Longrightarrow> tail H x = w \\<Longrightarrow> x \\<in> {rev_H uw, rev_H vw}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> arcs H; tail H x = w\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {rev_H uw, rev_H vw}", "using subdiv_distinct_verts0 not_in_verts_G"], ["proof (prove)\nusing this:\n  u \\<noteq> w\n  v \\<noteq> w\n  w \\<notin> verts I\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> arcs H; tail H x = w\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {rev_H uw, rev_H vw}", "by (auto simp: arcs_H) (simp add: tail_eq)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> arcs H; tail H ?x = w\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> {rev_H uw, rev_H vw}\n\ngoal (1 subgoal):\n 1. rev_H' uw = rev_H uw \\<and> rev_H' vw = rev_H vw \\<or>\n    rev_H' uw = rev_H vw \\<and> rev_H' vw = rev_H uw", "ultimately"], ["proof (chain)\npicking this:\n  arc_to_ends H (rev_H' uw) = (w, u)\n  arc_to_ends H (rev_H' vw) = (w, v)\n  \\<lbrakk>?x \\<in> arcs H; tail H ?x = w\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> {rev_H uw, rev_H vw}", "have \"rev_H' uw \\<in> {rev_H uw, rev_H vw}\" \"rev_H' vw \\<in> {rev_H uw, rev_H vw}\""], ["proof (prove)\nusing this:\n  arc_to_ends H (rev_H' uw) = (w, u)\n  arc_to_ends H (rev_H' vw) = (w, v)\n  \\<lbrakk>?x \\<in> arcs H; tail H ?x = w\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> {rev_H uw, rev_H vw}\n\ngoal (1 subgoal):\n 1. rev_H' uw \\<in> {rev_H uw, rev_H vw} &&&\n    rev_H' vw \\<in> {rev_H uw, rev_H vw}", "using in_arcs_H"], ["proof (prove)\nusing this:\n  arc_to_ends H (rev_H' uw) = (w, u)\n  arc_to_ends H (rev_H' vw) = (w, v)\n  \\<lbrakk>?x \\<in> arcs H; tail H ?x = w\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> {rev_H uw, rev_H vw}\n  {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H\n\ngoal (1 subgoal):\n 1. rev_H' uw \\<in> {rev_H uw, rev_H vw} &&&\n    rev_H' vw \\<in> {rev_H uw, rev_H vw}", "by auto"], ["proof (state)\nthis:\n  rev_H' uw \\<in> {rev_H uw, rev_H vw}\n  rev_H' vw \\<in> {rev_H uw, rev_H vw}\n\ngoal (1 subgoal):\n 1. rev_H' uw = rev_H uw \\<and> rev_H' vw = rev_H vw \\<or>\n    rev_H' uw = rev_H vw \\<and> rev_H' vw = rev_H uw", "then"], ["proof (chain)\npicking this:\n  rev_H' uw \\<in> {rev_H uw, rev_H vw}\n  rev_H' vw \\<in> {rev_H uw, rev_H vw}", "show ?thesis"], ["proof (prove)\nusing this:\n  rev_H' uw \\<in> {rev_H uw, rev_H vw}\n  rev_H' vw \\<in> {rev_H uw, rev_H vw}\n\ngoal (1 subgoal):\n 1. rev_H' uw = rev_H uw \\<and> rev_H' vw = rev_H vw \\<or>\n    rev_H' uw = rev_H vw \\<and> rev_H' vw = rev_H uw", "using in_arcs_H"], ["proof (prove)\nusing this:\n  rev_H' uw \\<in> {rev_H uw, rev_H vw}\n  rev_H' vw \\<in> {rev_H uw, rev_H vw}\n  {uw, rev_H uw, vw, rev_H vw} \\<subseteq> arcs H\n\ngoal (1 subgoal):\n 1. rev_H' uw = rev_H uw \\<and> rev_H' vw = rev_H vw \\<or>\n    rev_H' uw = rev_H vw \\<and> rev_H' vw = rev_H uw", "by (auto dest: rev_H_injD)"], ["proof (state)\nthis:\n  rev_H' uw = rev_H uw \\<and> rev_H' vw = rev_H vw \\<or>\n  rev_H' uw = rev_H vw \\<and> rev_H' vw = rev_H uw\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rev_H' uw = rev_H uw \\<and> rev_H' vw = rev_H vw \\<or>\n  rev_H' uw = rev_H vw \\<and> rev_H' vw = rev_H uw\n\ngoal (1 subgoal):\n 1. \\<And>I rev_I H rev_H u v w uv uw vw rev_H'.\n       \\<lbrakk>subdivision (G, rev_G) (I, rev_I);\n        \\<And>rev_H'.\n           bidirected_digraph I rev_H' \\<Longrightarrow>\n           \\<exists>rev_G'. subdivision (G, rev_G') (I, rev_H');\n        subdivision_step I rev_I H rev_H (u, v, w) (uv, uw, vw);\n        bidirected_digraph H rev_H'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rev_G'.\n                            subdivision (G, rev_G') (H, rev_H')", "have rev_H_uv: \"rev_H' uv = uv\" \"rev_H' (rev_I uv) = rev_I uv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev_H' uv = uv &&& rev_H' (rev_I uv) = rev_I uv", "using not_in_arcs_H"], ["proof (prove)\nusing this:\n  {uv, rev_I uv} \\<inter> arcs H = {}\n\ngoal (1 subgoal):\n 1. rev_H' uv = uv &&& rev_H' (rev_I uv) = rev_I uv", "by (auto simp: H'.arev_eq)"], ["proof (state)\nthis:\n  rev_H' uv = uv\n  rev_H' (rev_I uv) = rev_I uv\n\ngoal (1 subgoal):\n 1. \\<And>I rev_I H rev_H u v w uv uw vw rev_H'.\n       \\<lbrakk>subdivision (G, rev_G) (I, rev_I);\n        \\<And>rev_H'.\n           bidirected_digraph I rev_H' \\<Longrightarrow>\n           \\<exists>rev_G'. subdivision (G, rev_G') (I, rev_H');\n        subdivision_step I rev_I H rev_H (u, v, w) (uv, uw, vw);\n        bidirected_digraph H rev_H'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rev_G'.\n                            subdivision (G, rev_G') (H, rev_H')", "have bd_I': \"bidirected_digraph I rev_I'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bidirected_digraph I rev_I'", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a. (a \\<in> arcs I) = (rev_I' a \\<noteq> a)\n 2. \\<And>a. a \\<in> arcs I \\<Longrightarrow> rev_I' (rev_I' a) = a\n 3. \\<And>a. a \\<in> arcs I \\<Longrightarrow> tail I (rev_I' a) = head I a", "fix a"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a. (a \\<in> arcs I) = (rev_I' a \\<noteq> a)\n 2. \\<And>a. a \\<in> arcs I \\<Longrightarrow> rev_I' (rev_I' a) = a\n 3. \\<And>a. a \\<in> arcs I \\<Longrightarrow> tail I (rev_I' a) = head I a", "have \"\\<And>a. a \\<noteq> uv \\<Longrightarrow> a \\<noteq> rev_I uv \\<Longrightarrow> a \\<in> arcs I \\<Longrightarrow> a \\<in> arcs H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<noteq> uv; a \\<noteq> rev_I uv; a \\<in> arcs I\\<rbrakk>\n       \\<Longrightarrow> a \\<in> arcs H", "by (auto simp: arcs_H)"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<noteq> uv; ?a \\<noteq> rev_I uv; ?a \\<in> arcs I\\<rbrakk>\n  \\<Longrightarrow> ?a \\<in> arcs H\n\ngoal (3 subgoals):\n 1. \\<And>a. (a \\<in> arcs I) = (rev_I' a \\<noteq> a)\n 2. \\<And>a. a \\<in> arcs I \\<Longrightarrow> rev_I' (rev_I' a) = a\n 3. \\<And>a. a \\<in> arcs I \\<Longrightarrow> tail I (rev_I' a) = head I a", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?a \\<noteq> uv; ?a \\<noteq> rev_I uv; ?a \\<in> arcs I\\<rbrakk>\n  \\<Longrightarrow> ?a \\<in> arcs H", "show \"(a \\<in> arcs I) = (rev_I' a \\<noteq> a)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<noteq> uv; ?a \\<noteq> rev_I uv; ?a \\<in> arcs I\\<rbrakk>\n  \\<Longrightarrow> ?a \\<in> arcs H\n\ngoal (1 subgoal):\n 1. (a \\<in> arcs I) = (rev_I' a \\<noteq> a)", "using in_arcs_G"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<noteq> uv; ?a \\<noteq> rev_I uv; ?a \\<in> arcs I\\<rbrakk>\n  \\<Longrightarrow> ?a \\<in> arcs H\n  {uv, rev_I uv} \\<subseteq> arcs I\n\ngoal (1 subgoal):\n 1. (a \\<in> arcs I) = (rev_I' a \\<noteq> a)", "by (auto simp: rev_I'_def dest: G.arev_neq H'.arev_neq)"], ["proof (state)\nthis:\n  (a \\<in> arcs I) = (rev_I' a \\<noteq> a)\n\ngoal (2 subgoals):\n 1. \\<And>a. a \\<in> arcs I \\<Longrightarrow> rev_I' (rev_I' a) = a\n 2. \\<And>a. a \\<in> arcs I \\<Longrightarrow> tail I (rev_I' a) = head I a", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. a \\<in> arcs I \\<Longrightarrow> rev_I' (rev_I' a) = a\n 2. \\<And>a. a \\<in> arcs I \\<Longrightarrow> tail I (rev_I' a) = head I a", "fix a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. a \\<in> arcs I \\<Longrightarrow> rev_I' (rev_I' a) = a\n 2. \\<And>a. a \\<in> arcs I \\<Longrightarrow> tail I (rev_I' a) = head I a", "have *: \"\\<And>a. rev_H' a = rev_I uv \\<longleftrightarrow> a = rev_I uv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. (rev_H' a = rev_I uv) = (a = rev_I uv)", "by (metis H'.arev_arev H'.arev_dom insert_disjoint(1) not_in_arcs_H)"], ["proof (state)\nthis:\n  (rev_H' ?a = rev_I uv) = (?a = rev_I uv)\n\ngoal (2 subgoals):\n 1. \\<And>a. a \\<in> arcs I \\<Longrightarrow> rev_I' (rev_I' a) = a\n 2. \\<And>a. a \\<in> arcs I \\<Longrightarrow> tail I (rev_I' a) = head I a", "have **: \"\\<And>a. uv = rev_H' a \\<longleftrightarrow> a = uv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. (uv = rev_H' a) = (a = uv)", "using H'.arev_eq not_in_arcs_H"], ["proof (prove)\nusing this:\n  ?a \\<notin> arcs H \\<Longrightarrow> rev_H' ?a = ?a\n  {uv, rev_I uv} \\<inter> arcs H = {}\n\ngoal (1 subgoal):\n 1. \\<And>a. (uv = rev_H' a) = (a = uv)", "by force"], ["proof (state)\nthis:\n  (uv = rev_H' ?a) = (?a = uv)\n\ngoal (2 subgoals):\n 1. \\<And>a. a \\<in> arcs I \\<Longrightarrow> rev_I' (rev_I' a) = a\n 2. \\<And>a. a \\<in> arcs I \\<Longrightarrow> tail I (rev_I' a) = head I a", "have ***: \"\\<And>a. a \\<in> arcs I \\<Longrightarrow> rev_H' a \\<in> arcs I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> arcs I \\<Longrightarrow> rev_H' a \\<in> arcs I", "using rev_H'_simps"], ["proof (prove)\nusing this:\n  rev_H' uw = rev_H uw \\<and> rev_H' vw = rev_H vw \\<or>\n  rev_H' uw = rev_H vw \\<and> rev_H' vw = rev_H uw\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> arcs I \\<Longrightarrow> rev_H' a \\<in> arcs I", "by (case_tac \"a \\<in> {uv,vu}\") (fastforce simp: rev_H_uv, auto simp: arcs_G dest: rev_H_injD)"], ["proof (state)\nthis:\n  ?a \\<in> arcs I \\<Longrightarrow> rev_H' ?a \\<in> arcs I\n\ngoal (2 subgoals):\n 1. \\<And>a. a \\<in> arcs I \\<Longrightarrow> rev_I' (rev_I' a) = a\n 2. \\<And>a. a \\<in> arcs I \\<Longrightarrow> tail I (rev_I' a) = head I a", "show \"rev_I' (rev_I' a) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev_I' (rev_I' a) = a", "by (auto simp: rev_I'_def H'.arev_eq rev_H_uv * ** ***)"], ["proof (state)\nthis:\n  rev_I' (rev_I' a) = a\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> arcs I \\<Longrightarrow> tail I (rev_I' a) = head I a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> arcs I \\<Longrightarrow> tail I (rev_I' a) = head I a", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> arcs I \\<Longrightarrow> tail I (rev_I' a) = head I a", "assume \"a \\<in> arcs I\""], ["proof (state)\nthis:\n  a \\<in> arcs I\n\ngoal (1 subgoal):\n 1. \\<And>a. a \\<in> arcs I \\<Longrightarrow> tail I (rev_I' a) = head I a", "then"], ["proof (chain)\npicking this:\n  a \\<in> arcs I", "show \"tail I (rev_I' a) = head I a\""], ["proof (prove)\nusing this:\n  a \\<in> arcs I\n\ngoal (1 subgoal):\n 1. tail I (rev_I' a) = head I a", "using in_arcs_G"], ["proof (prove)\nusing this:\n  a \\<in> arcs I\n  {uv, rev_I uv} \\<subseteq> arcs I\n\ngoal (1 subgoal):\n 1. tail I (rev_I' a) = head I a", "by (auto simp: rev_I'_def tail_eq[symmetric] head_eq[symmetric] arcs_H)"], ["proof (state)\nthis:\n  tail I (rev_I' a) = head I a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bidirected_digraph I rev_I'\n\ngoal (1 subgoal):\n 1. \\<And>I rev_I H rev_H u v w uv uw vw rev_H'.\n       \\<lbrakk>subdivision (G, rev_G) (I, rev_I);\n        \\<And>rev_H'.\n           bidirected_digraph I rev_H' \\<Longrightarrow>\n           \\<exists>rev_G'. subdivision (G, rev_G') (I, rev_H');\n        subdivision_step I rev_I H rev_H (u, v, w) (uv, uw, vw);\n        bidirected_digraph H rev_H'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rev_G'.\n                            subdivision (G, rev_G') (H, rev_H')", "moreover"], ["proof (state)\nthis:\n  bidirected_digraph I rev_I'\n\ngoal (1 subgoal):\n 1. \\<And>I rev_I H rev_H u v w uv uw vw rev_H'.\n       \\<lbrakk>subdivision (G, rev_G) (I, rev_I);\n        \\<And>rev_H'.\n           bidirected_digraph I rev_H' \\<Longrightarrow>\n           \\<exists>rev_G'. subdivision (G, rev_G') (I, rev_H');\n        subdivision_step I rev_I H rev_H (u, v, w) (uv, uw, vw);\n        bidirected_digraph H rev_H'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rev_G'.\n                            subdivision (G, rev_G') (H, rev_H')", "have \"\\<And>x. rev_H' x = uv \\<longleftrightarrow> x = uv\" \"\\<And>x. rev_H' x = rev_I uv \\<longleftrightarrow> x = rev_I uv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. (rev_H' x = uv) = (x = uv)) &&&\n    (\\<And>x. (rev_H' x = rev_I uv) = (x = rev_I uv))", "using not_in_arcs_H"], ["proof (prove)\nusing this:\n  {uv, rev_I uv} \\<inter> arcs H = {}\n\ngoal (1 subgoal):\n 1. (\\<And>x. (rev_H' x = uv) = (x = uv)) &&&\n    (\\<And>x. (rev_H' x = rev_I uv) = (x = rev_I uv))", "by (auto dest: H'.arev_eq) (metis H'.arev_arev H'.arev_eq)"], ["proof (state)\nthis:\n  (rev_H' ?x = uv) = (?x = uv)\n  (rev_H' ?x = rev_I uv) = (?x = rev_I uv)\n\ngoal (1 subgoal):\n 1. \\<And>I rev_I H rev_H u v w uv uw vw rev_H'.\n       \\<lbrakk>subdivision (G, rev_G) (I, rev_I);\n        \\<And>rev_H'.\n           bidirected_digraph I rev_H' \\<Longrightarrow>\n           \\<exists>rev_G'. subdivision (G, rev_G') (I, rev_H');\n        subdivision_step I rev_I H rev_H (u, v, w) (uv, uw, vw);\n        bidirected_digraph H rev_H'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rev_G'.\n                            subdivision (G, rev_G') (H, rev_H')", "then"], ["proof (chain)\npicking this:\n  (rev_H' ?x = uv) = (?x = uv)\n  (rev_H' ?x = rev_I uv) = (?x = rev_I uv)", "have \"perm_restrict rev_H' (arcs I) = perm_restrict rev_I' (arcs H)\""], ["proof (prove)\nusing this:\n  (rev_H' ?x = uv) = (?x = uv)\n  (rev_H' ?x = rev_I uv) = (?x = rev_I uv)\n\ngoal (1 subgoal):\n 1. perm_restrict rev_H' (arcs I) = perm_restrict rev_I' (arcs H)", "using not_in_arcs_H"], ["proof (prove)\nusing this:\n  (rev_H' ?x = uv) = (?x = uv)\n  (rev_H' ?x = rev_I uv) = (?x = rev_I uv)\n  {uv, rev_I uv} \\<inter> arcs H = {}\n\ngoal (1 subgoal):\n 1. perm_restrict rev_H' (arcs I) = perm_restrict rev_I' (arcs H)", "by (auto simp: rev_I'_def perm_restrict_def H'.arev_eq)"], ["proof (state)\nthis:\n  perm_restrict rev_H' (arcs I) = perm_restrict rev_I' (arcs H)\n\ngoal (1 subgoal):\n 1. \\<And>I rev_I H rev_H u v w uv uw vw rev_H'.\n       \\<lbrakk>subdivision (G, rev_G) (I, rev_I);\n        \\<And>rev_H'.\n           bidirected_digraph I rev_H' \\<Longrightarrow>\n           \\<exists>rev_G'. subdivision (G, rev_G') (I, rev_H');\n        subdivision_step I rev_I H rev_H (u, v, w) (uv, uw, vw);\n        bidirected_digraph H rev_H'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rev_G'.\n                            subdivision (G, rev_G') (H, rev_H')", "ultimately"], ["proof (chain)\npicking this:\n  bidirected_digraph I rev_I'\n  perm_restrict rev_H' (arcs I) = perm_restrict rev_I' (arcs H)", "have sds_I'H': \"subdivision_step I rev_I' H rev_H' (u, v, w) (uv, uw, vw)\""], ["proof (prove)\nusing this:\n  bidirected_digraph I rev_I'\n  perm_restrict rev_H' (arcs I) = perm_restrict rev_I' (arcs H)\n\ngoal (1 subgoal):\n 1. subdivision_step I rev_I' H rev_H' (u, v, w) (uv, uw, vw)", "using divide(2,4) rev_H'_simps"], ["proof (prove)\nusing this:\n  bidirected_digraph I rev_I'\n  perm_restrict rev_H' (arcs I) = perm_restrict rev_I' (arcs H)\n  subdivision_step I rev_I H rev_H (u, v, w) (uv, uw, vw)\n  bidirected_digraph H rev_H'\n  rev_H' uw = rev_H uw \\<and> rev_H' vw = rev_H vw \\<or>\n  rev_H' uw = rev_H vw \\<and> rev_H' vw = rev_H uw\n\ngoal (1 subgoal):\n 1. subdivision_step I rev_I' H rev_H' (u, v, w) (uv, uw, vw)", "unfolding subdivision_step_def"], ["proof (prove)\nusing this:\n  bidirected_digraph I rev_I'\n  perm_restrict rev_H' (arcs I) = perm_restrict rev_I' (arcs H)\n  (case (u, v, w) of\n   (u, v, w) \\<Rightarrow>\n     \\<lambda>(uv, uw, vw).\n        bidirected_digraph I rev_I \\<and>\n        bidirected_digraph H rev_H \\<and>\n        perm_restrict rev_H (arcs I) = perm_restrict rev_I (arcs H) \\<and>\n        compatible I H \\<and>\n        verts H = verts I \\<union> {w} \\<and>\n        w \\<notin> verts I \\<and>\n        arcs H =\n        {uw, rev_H uw, vw, rev_H vw} \\<union> arcs I - {uv, rev_I uv} \\<and>\n        uv \\<in> arcs I \\<and>\n        distinct [uw, rev_H uw, vw, rev_H vw] \\<and>\n        arc_to_ends I uv = (u, v) \\<and>\n        arc_to_ends H uw = (u, w) \\<and> arc_to_ends H vw = (v, w))\n   (uv, uw, vw)\n  bidirected_digraph H rev_H'\n  rev_H' uw = rev_H uw \\<and> rev_H' vw = rev_H vw \\<or>\n  rev_H' uw = rev_H vw \\<and> rev_H' vw = rev_H uw\n\ngoal (1 subgoal):\n 1. (case (u, v, w) of\n     (u, v, w) \\<Rightarrow>\n       \\<lambda>(uv, uw, vw).\n          bidirected_digraph I rev_I' \\<and>\n          bidirected_digraph H rev_H' \\<and>\n          perm_restrict rev_H' (arcs I) =\n          perm_restrict rev_I' (arcs H) \\<and>\n          compatible I H \\<and>\n          verts H = verts I \\<union> {w} \\<and>\n          w \\<notin> verts I \\<and>\n          arcs H =\n          {uw, rev_H' uw, vw, rev_H' vw} \\<union> arcs I -\n          {uv, rev_I' uv} \\<and>\n          uv \\<in> arcs I \\<and>\n          distinct [uw, rev_H' uw, vw, rev_H' vw] \\<and>\n          arc_to_ends I uv = (u, v) \\<and>\n          arc_to_ends H uw = (u, w) \\<and> arc_to_ends H vw = (v, w))\n     (uv, uw, vw)", "by (fastforce simp:  rev_I'_def)"], ["proof (state)\nthis:\n  subdivision_step I rev_I' H rev_H' (u, v, w) (uv, uw, vw)\n\ngoal (1 subgoal):\n 1. \\<And>I rev_I H rev_H u v w uv uw vw rev_H'.\n       \\<lbrakk>subdivision (G, rev_G) (I, rev_I);\n        \\<And>rev_H'.\n           bidirected_digraph I rev_H' \\<Longrightarrow>\n           \\<exists>rev_G'. subdivision (G, rev_G') (I, rev_H');\n        subdivision_step I rev_I H rev_H (u, v, w) (uv, uw, vw);\n        bidirected_digraph H rev_H'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rev_G'.\n                            subdivision (G, rev_G') (H, rev_H')", "then"], ["proof (chain)\npicking this:\n  subdivision_step I rev_I' H rev_H' (u, v, w) (uv, uw, vw)", "have \"subdivision (I, rev_I') (H, rev_H')\" \"\\<exists>rev_G'. subdivision (G, rev_G') (I, rev_I')\""], ["proof (prove)\nusing this:\n  subdivision_step I rev_I' H rev_H' (u, v, w) (uv, uw, vw)\n\ngoal (1 subgoal):\n 1. subdivision (I, rev_I') (H, rev_H') &&&\n    \\<exists>rev_G'. subdivision (G, rev_G') (I, rev_I')", "using bd_I' divide"], ["proof (prove)\nusing this:\n  subdivision_step I rev_I' H rev_H' (u, v, w) (uv, uw, vw)\n  bidirected_digraph I rev_I'\n  subdivision (G, rev_G) (I, rev_I)\n  subdivision_step I rev_I H rev_H (u, v, w) (uv, uw, vw)\n  bidirected_digraph I ?rev_H' \\<Longrightarrow>\n  \\<exists>rev_G'. subdivision (G, rev_G') (I, ?rev_H')\n  bidirected_digraph H rev_H'\n\ngoal (1 subgoal):\n 1. subdivision (I, rev_I') (H, rev_H') &&&\n    \\<exists>rev_G'. subdivision (G, rev_G') (I, rev_I')", "by (auto intro: subdivision.intros dest: subdivision_base)"], ["proof (state)\nthis:\n  subdivision (I, rev_I') (H, rev_H')\n  \\<exists>rev_G'. subdivision (G, rev_G') (I, rev_I')\n\ngoal (1 subgoal):\n 1. \\<And>I rev_I H rev_H u v w uv uw vw rev_H'.\n       \\<lbrakk>subdivision (G, rev_G) (I, rev_I);\n        \\<And>rev_H'.\n           bidirected_digraph I rev_H' \\<Longrightarrow>\n           \\<exists>rev_G'. subdivision (G, rev_G') (I, rev_H');\n        subdivision_step I rev_I H rev_H (u, v, w) (uv, uw, vw);\n        bidirected_digraph H rev_H'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rev_G'.\n                            subdivision (G, rev_G') (H, rev_H')", "then"], ["proof (chain)\npicking this:\n  subdivision (I, rev_I') (H, rev_H')\n  \\<exists>rev_G'. subdivision (G, rev_G') (I, rev_I')", "show ?case"], ["proof (prove)\nusing this:\n  subdivision (I, rev_I') (H, rev_H')\n  \\<exists>rev_G'. subdivision (G, rev_G') (I, rev_I')\n\ngoal (1 subgoal):\n 1. \\<exists>rev_G'. subdivision (G, rev_G') (H, rev_H')", "by (blast intro: subdivision_trans)"], ["proof (state)\nthis:\n  \\<exists>rev_G'. subdivision (G, rev_G') (H, rev_H')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subdivision_verts_subset:\n  assumes \"subdivision (G,rev_G) (H,rev_H)\" \"x \\<in> verts G\"\n  shows \"x \\<in> verts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> verts H", "using assms"], ["proof (prove)\nusing this:\n  subdivision (G, rev_G) (H, rev_H)\n  x \\<in> verts G\n\ngoal (1 subgoal):\n 1. x \\<in> verts H", "by induct (auto simp: subdiv_step.verts_H subdiv_step_def)"], ["", "subsection \\<open>Subdivision on Pair Digraphs\\<close>"], ["", "text \\<open>\n  In this section, we introduce specialized rules for pair digraphs.\n\\<close>"], ["", "abbreviation \"subdivision_pair G H \\<equiv> subdivision (with_proj G, swap_in (parcs G)) (with_proj H, swap_in (parcs H))\""], ["", "lemma arc_to_ends_with_proj[simp]: \"arc_to_ends (with_proj G) = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arc_to_ends (with_proj G) = id", "by (auto simp: arc_to_ends_def)"], ["", "context\nbegin"], ["", "text \\<open>\n    We use the @{verbatim inductive} command to define an inductive definition pair graphs.\n    This is proven to be equivalent to @{const subdivision}.\n    This allows us to transfer the rules proven by @{verbatim inductive} to @{const subdivision}.\n    To spare the user confusion, we hide this new constant.\n  \\<close>"], ["", "private"], ["", "inductive pair_sd :: \"'a pair_pre_digraph \\<Rightarrow> 'a pair_pre_digraph \\<Rightarrow> bool\"\n    for G where\n      base: \"pair_bidirected_digraph G \\<Longrightarrow> pair_sd G G\"\n    | divide: \"\\<And>e w H. \\<lbrakk>e \\<in> parcs H; w \\<notin> pverts H; pair_sd G H\\<rbrakk>\n        \\<Longrightarrow> pair_sd G (subdivide H e w)\""], ["", "private"], ["", "lemma bidirected_digraphI_pair_sd:\n    assumes \"pair_sd G H\" shows \"pair_bidirected_digraph H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_bidirected_digraph H", "using assms"], ["proof (prove)\nusing this:\n  pair_sd G H\n\ngoal (1 subgoal):\n 1. pair_bidirected_digraph H", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. pair_bidirected_digraph G \\<Longrightarrow> pair_bidirected_digraph G\n 2. \\<And>e w H.\n       \\<lbrakk>e \\<in> parcs H; w \\<notin> pverts H; pair_sd G H;\n        pair_bidirected_digraph H\\<rbrakk>\n       \\<Longrightarrow> pair_bidirected_digraph (subdivide H e w)", "case base"], ["proof (state)\nthis:\n  pair_bidirected_digraph G\n\ngoal (2 subgoals):\n 1. pair_bidirected_digraph G \\<Longrightarrow> pair_bidirected_digraph G\n 2. \\<And>e w H.\n       \\<lbrakk>e \\<in> parcs H; w \\<notin> pverts H; pair_sd G H;\n        pair_bidirected_digraph H\\<rbrakk>\n       \\<Longrightarrow> pair_bidirected_digraph (subdivide H e w)", "then"], ["proof (chain)\npicking this:\n  pair_bidirected_digraph G", "show ?case"], ["proof (prove)\nusing this:\n  pair_bidirected_digraph G\n\ngoal (1 subgoal):\n 1. pair_bidirected_digraph G", "by auto"], ["proof (state)\nthis:\n  pair_bidirected_digraph G\n\ngoal (1 subgoal):\n 1. \\<And>e w H.\n       \\<lbrakk>e \\<in> parcs H; w \\<notin> pverts H; pair_sd G H;\n        pair_bidirected_digraph H\\<rbrakk>\n       \\<Longrightarrow> pair_bidirected_digraph (subdivide H e w)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e w H.\n       \\<lbrakk>e \\<in> parcs H; w \\<notin> pverts H; pair_sd G H;\n        pair_bidirected_digraph H\\<rbrakk>\n       \\<Longrightarrow> pair_bidirected_digraph (subdivide H e w)", "case (divide e w H)"], ["proof (state)\nthis:\n  e \\<in> parcs H\n  w \\<notin> pverts H\n  pair_sd G H\n  pair_bidirected_digraph H\n\ngoal (1 subgoal):\n 1. \\<And>e w H.\n       \\<lbrakk>e \\<in> parcs H; w \\<notin> pverts H; pair_sd G H;\n        pair_bidirected_digraph H\\<rbrakk>\n       \\<Longrightarrow> pair_bidirected_digraph (subdivide H e w)", "interpret H: pair_bidirected_digraph H"], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_bidirected_digraph H", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e w H.\n       \\<lbrakk>e \\<in> parcs H; w \\<notin> pverts H; pair_sd G H;\n        pair_bidirected_digraph H\\<rbrakk>\n       \\<Longrightarrow> pair_bidirected_digraph (subdivide H e w)", "from divide"], ["proof (chain)\npicking this:\n  e \\<in> parcs H\n  w \\<notin> pverts H\n  pair_sd G H\n  pair_bidirected_digraph H", "show ?case"], ["proof (prove)\nusing this:\n  e \\<in> parcs H\n  w \\<notin> pverts H\n  pair_sd G H\n  pair_bidirected_digraph H\n\ngoal (1 subgoal):\n 1. pair_bidirected_digraph (subdivide H e w)", "by (intro H.pair_bidirected_digraph_subdivide)"], ["proof (state)\nthis:\n  pair_bidirected_digraph (subdivide H e w)\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma subdivision_with_projI:\n    assumes \"pair_sd G H\"\n    shows \"subdivision_pair G H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subdivision_pair G H", "using assms"], ["proof (prove)\nusing this:\n  pair_sd G H\n\ngoal (1 subgoal):\n 1. subdivision_pair G H", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. pair_bidirected_digraph G \\<Longrightarrow> subdivision_pair G G\n 2. \\<And>e w H.\n       \\<lbrakk>e \\<in> parcs H; w \\<notin> pverts H; pair_sd G H;\n        subdivision_pair G H\\<rbrakk>\n       \\<Longrightarrow> subdivision_pair G (subdivide H e w)", "case base"], ["proof (state)\nthis:\n  pair_bidirected_digraph G\n\ngoal (2 subgoals):\n 1. pair_bidirected_digraph G \\<Longrightarrow> subdivision_pair G G\n 2. \\<And>e w H.\n       \\<lbrakk>e \\<in> parcs H; w \\<notin> pverts H; pair_sd G H;\n        subdivision_pair G H\\<rbrakk>\n       \\<Longrightarrow> subdivision_pair G (subdivide H e w)", "then"], ["proof (chain)\npicking this:\n  pair_bidirected_digraph G", "show ?case"], ["proof (prove)\nusing this:\n  pair_bidirected_digraph G\n\ngoal (1 subgoal):\n 1. subdivision_pair G G", "by (blast intro: pair_bidirected_digraph.bidirected_digraph subdivision_base)"], ["proof (state)\nthis:\n  subdivision_pair G G\n\ngoal (1 subgoal):\n 1. \\<And>e w H.\n       \\<lbrakk>e \\<in> parcs H; w \\<notin> pverts H; pair_sd G H;\n        subdivision_pair G H\\<rbrakk>\n       \\<Longrightarrow> subdivision_pair G (subdivide H e w)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e w H.\n       \\<lbrakk>e \\<in> parcs H; w \\<notin> pverts H; pair_sd G H;\n        subdivision_pair G H\\<rbrakk>\n       \\<Longrightarrow> subdivision_pair G (subdivide H e w)", "case (divide e w H)"], ["proof (state)\nthis:\n  e \\<in> parcs H\n  w \\<notin> pverts H\n  pair_sd G H\n  subdivision_pair G H\n\ngoal (1 subgoal):\n 1. \\<And>e w H.\n       \\<lbrakk>e \\<in> parcs H; w \\<notin> pverts H; pair_sd G H;\n        subdivision_pair G H\\<rbrakk>\n       \\<Longrightarrow> subdivision_pair G (subdivide H e w)", "obtain u v where \"e = (u,v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u v. e = (u, v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases e)"], ["proof (state)\nthis:\n  e = (u, v)\n\ngoal (1 subgoal):\n 1. \\<And>e w H.\n       \\<lbrakk>e \\<in> parcs H; w \\<notin> pverts H; pair_sd G H;\n        subdivision_pair G H\\<rbrakk>\n       \\<Longrightarrow> subdivision_pair G (subdivide H e w)", "interpret H: pair_bidirected_digraph H"], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_bidirected_digraph H", "using divide(3)"], ["proof (prove)\nusing this:\n  pair_sd G H\n\ngoal (1 subgoal):\n 1. pair_bidirected_digraph H", "by (rule bidirected_digraphI_pair_sd)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e w H.\n       \\<lbrakk>e \\<in> parcs H; w \\<notin> pverts H; pair_sd G H;\n        subdivision_pair G H\\<rbrakk>\n       \\<Longrightarrow> subdivision_pair G (subdivide H e w)", "interpret I: pair_bidirected_digraph \"subdivide H e w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_bidirected_digraph (subdivide H e w)", "using divide(1,2)"], ["proof (prove)\nusing this:\n  e \\<in> parcs H\n  w \\<notin> pverts H\n\ngoal (1 subgoal):\n 1. pair_bidirected_digraph (subdivide H e w)", "by (rule H.pair_bidirected_digraph_subdivide)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e w H.\n       \\<lbrakk>e \\<in> parcs H; w \\<notin> pverts H; pair_sd G H;\n        subdivision_pair G H\\<rbrakk>\n       \\<Longrightarrow> subdivision_pair G (subdivide H e w)", "have uvw: \"u \\<noteq> v\" \"u \\<noteq> w\" \"v \\<noteq> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<noteq> v &&& u \\<noteq> w &&& v \\<noteq> w", "using divide"], ["proof (prove)\nusing this:\n  e \\<in> parcs H\n  w \\<notin> pverts H\n  pair_sd G H\n  subdivision_pair G H\n\ngoal (1 subgoal):\n 1. u \\<noteq> v &&& u \\<noteq> w &&& v \\<noteq> w", "by (auto simp: \\<open>e = _\\<close> dest: H.adj_not_same H.wellformed)"], ["proof (state)\nthis:\n  u \\<noteq> v\n  u \\<noteq> w\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<And>e w H.\n       \\<lbrakk>e \\<in> parcs H; w \\<notin> pverts H; pair_sd G H;\n        subdivision_pair G H\\<rbrakk>\n       \\<Longrightarrow> subdivision_pair G (subdivide H e w)", "have \"subdivision (with_proj G, swap_in (parcs G)) (H, swap_in (parcs H))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subdivision (with_proj G, swap_in (parcs G))\n     (case (H, swap_in (parcs H)) of (x, y) \\<Rightarrow> (with_proj x, y))", "using divide"], ["proof (prove)\nusing this:\n  e \\<in> parcs H\n  w \\<notin> pverts H\n  pair_sd G H\n  subdivision_pair G H\n\ngoal (1 subgoal):\n 1. subdivision (with_proj G, swap_in (parcs G))\n     (case (H, swap_in (parcs H)) of (x, y) \\<Rightarrow> (with_proj x, y))", "by auto"], ["proof (state)\nthis:\n  subdivision (with_proj G, swap_in (parcs G))\n   (case (H, swap_in (parcs H)) of (x, y) \\<Rightarrow> (with_proj x, y))\n\ngoal (1 subgoal):\n 1. \\<And>e w H.\n       \\<lbrakk>e \\<in> parcs H; w \\<notin> pverts H; pair_sd G H;\n        subdivision_pair G H\\<rbrakk>\n       \\<Longrightarrow> subdivision_pair G (subdivide H e w)", "moreover"], ["proof (state)\nthis:\n  subdivision (with_proj G, swap_in (parcs G))\n   (case (H, swap_in (parcs H)) of (x, y) \\<Rightarrow> (with_proj x, y))\n\ngoal (1 subgoal):\n 1. \\<And>e w H.\n       \\<lbrakk>e \\<in> parcs H; w \\<notin> pverts H; pair_sd G H;\n        subdivision_pair G H\\<rbrakk>\n       \\<Longrightarrow> subdivision_pair G (subdivide H e w)", "have *: \"perm_restrict (swap_in (parcs (subdivide H e w))) (parcs H) = perm_restrict (swap_in (parcs H)) (parcs (subdivide H e w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. perm_restrict (swap_in (parcs (subdivide H e w))) (parcs H) =\n    perm_restrict (swap_in (parcs H)) (parcs (subdivide H e w))", "by (auto simp: perm_restrict_def fun_eq_iff swap_in_def)"], ["proof (state)\nthis:\n  perm_restrict (swap_in (parcs (subdivide H e w))) (parcs H) =\n  perm_restrict (swap_in (parcs H)) (parcs (subdivide H e w))\n\ngoal (1 subgoal):\n 1. \\<And>e w H.\n       \\<lbrakk>e \\<in> parcs H; w \\<notin> pverts H; pair_sd G H;\n        subdivision_pair G H\\<rbrakk>\n       \\<Longrightarrow> subdivision_pair G (subdivide H e w)", "have \"subdivision_step (with_proj H) (swap_in (arcs H)) (with_proj (subdivide H e w)) (swap_in (arcs (subdivide H e w)))\n        (u, v, w) (e, (u,w), (v,w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subdivision_step (with_proj H) (swap_in (arcs (with_proj H)))\n     (with_proj (subdivide H e w))\n     (swap_in (arcs (with_proj (subdivide H e w)))) (u, v, w)\n     (e, (u, w), v, w)", "unfolding subdivision_step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (u, v, w) of\n     (u, v, wa) \\<Rightarrow>\n       \\<lambda>(uv, uw, vw).\n          bidirected_digraph (with_proj H)\n           (swap_in (arcs (with_proj H))) \\<and>\n          bidirected_digraph (with_proj (subdivide H e w))\n           (swap_in (arcs (with_proj (subdivide H e w)))) \\<and>\n          perm_restrict (swap_in (arcs (with_proj (subdivide H e w))))\n           (arcs (with_proj H)) =\n          perm_restrict (swap_in (arcs (with_proj H)))\n           (arcs (with_proj (subdivide H e w))) \\<and>\n          compatible (with_proj H) (with_proj (subdivide H e w)) \\<and>\n          verts (with_proj (subdivide H e w)) =\n          verts (with_proj H) \\<union> {wa} \\<and>\n          wa \\<notin> verts (with_proj H) \\<and>\n          arcs (with_proj (subdivide H e w)) =\n          {uw, swap_in (arcs (with_proj (subdivide H e w))) uw, vw,\n           swap_in (arcs (with_proj (subdivide H e w))) vw} \\<union>\n          arcs (with_proj H) -\n          {uv, swap_in (arcs (with_proj H)) uv} \\<and>\n          uv \\<in> arcs (with_proj H) \\<and>\n          distinct\n           [uw, swap_in (arcs (with_proj (subdivide H e w))) uw, vw,\n            swap_in (arcs (with_proj (subdivide H e w))) vw] \\<and>\n          arc_to_ends (with_proj H) uv = (u, v) \\<and>\n          arc_to_ends (with_proj (subdivide H e w)) uw = (u, wa) \\<and>\n          arc_to_ends (with_proj (subdivide H e w)) vw = (v, wa))\n     (e, (u, w), v, w)", "unfolding prod.simps with_proj_simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. bidirected_digraph (with_proj H) (swap_in (parcs H)) \\<and>\n    bidirected_digraph (with_proj (subdivide H e w))\n     (swap_in (parcs (subdivide H e w))) \\<and>\n    perm_restrict (swap_in (parcs (subdivide H e w))) (parcs H) =\n    perm_restrict (swap_in (parcs H)) (parcs (subdivide H e w)) \\<and>\n    compatible (with_proj H) (with_proj (subdivide H e w)) \\<and>\n    pverts (subdivide H e w) = pverts H \\<union> {w} \\<and>\n    w \\<notin> pverts H \\<and>\n    parcs (subdivide H e w) =\n    {(u, w), swap_in (parcs (subdivide H e w)) (u, w), (v, w),\n     swap_in (parcs (subdivide H e w)) (v, w)} \\<union>\n    parcs H -\n    {e, swap_in (parcs H) e} \\<and>\n    e \\<in> parcs H \\<and>\n    distinct\n     [(u, w), swap_in (parcs (subdivide H e w)) (u, w), (v, w),\n      swap_in (parcs (subdivide H e w)) (v, w)] \\<and>\n    arc_to_ends (with_proj H) e = (u, v) \\<and>\n    arc_to_ends (with_proj (subdivide H e w)) (u, w) = (u, w) \\<and>\n    arc_to_ends (with_proj (subdivide H e w)) (v, w) = (v, w)", "using divide uvw"], ["proof (prove)\nusing this:\n  e \\<in> parcs H\n  w \\<notin> pverts H\n  pair_sd G H\n  subdivision_pair G H\n  u \\<noteq> v\n  u \\<noteq> w\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. bidirected_digraph (with_proj H) (swap_in (parcs H)) \\<and>\n    bidirected_digraph (with_proj (subdivide H e w))\n     (swap_in (parcs (subdivide H e w))) \\<and>\n    perm_restrict (swap_in (parcs (subdivide H e w))) (parcs H) =\n    perm_restrict (swap_in (parcs H)) (parcs (subdivide H e w)) \\<and>\n    compatible (with_proj H) (with_proj (subdivide H e w)) \\<and>\n    pverts (subdivide H e w) = pverts H \\<union> {w} \\<and>\n    w \\<notin> pverts H \\<and>\n    parcs (subdivide H e w) =\n    {(u, w), swap_in (parcs (subdivide H e w)) (u, w), (v, w),\n     swap_in (parcs (subdivide H e w)) (v, w)} \\<union>\n    parcs H -\n    {e, swap_in (parcs H) e} \\<and>\n    e \\<in> parcs H \\<and>\n    distinct\n     [(u, w), swap_in (parcs (subdivide H e w)) (u, w), (v, w),\n      swap_in (parcs (subdivide H e w)) (v, w)] \\<and>\n    arc_to_ends (with_proj H) e = (u, v) \\<and>\n    arc_to_ends (with_proj (subdivide H e w)) (u, w) = (u, w) \\<and>\n    arc_to_ends (with_proj (subdivide H e w)) (v, w) = (v, w)", "by (intro conjI H.bidirected_digraph I.bidirected_digraph *)\n         (auto simp add: swap_in_def \\<open>e = _\\<close> compatibleI_with_proj)"], ["proof (state)\nthis:\n  subdivision_step (with_proj H) (swap_in (arcs (with_proj H)))\n   (with_proj (subdivide H e w))\n   (swap_in (arcs (with_proj (subdivide H e w)))) (u, v, w)\n   (e, (u, w), v, w)\n\ngoal (1 subgoal):\n 1. \\<And>e w H.\n       \\<lbrakk>e \\<in> parcs H; w \\<notin> pverts H; pair_sd G H;\n        subdivision_pair G H\\<rbrakk>\n       \\<Longrightarrow> subdivision_pair G (subdivide H e w)", "ultimately"], ["proof (chain)\npicking this:\n  subdivision (with_proj G, swap_in (parcs G))\n   (case (H, swap_in (parcs H)) of (x, y) \\<Rightarrow> (with_proj x, y))\n  subdivision_step (with_proj H) (swap_in (arcs (with_proj H)))\n   (with_proj (subdivide H e w))\n   (swap_in (arcs (with_proj (subdivide H e w)))) (u, v, w)\n   (e, (u, w), v, w)", "show ?case"], ["proof (prove)\nusing this:\n  subdivision (with_proj G, swap_in (parcs G))\n   (case (H, swap_in (parcs H)) of (x, y) \\<Rightarrow> (with_proj x, y))\n  subdivision_step (with_proj H) (swap_in (arcs (with_proj H)))\n   (with_proj (subdivide H e w))\n   (swap_in (arcs (with_proj (subdivide H e w)))) (u, v, w)\n   (e, (u, w), v, w)\n\ngoal (1 subgoal):\n 1. subdivision_pair G (subdivide H e w)", "by (auto intro: subdivision.divide)"], ["proof (state)\nthis:\n  subdivision_pair G (subdivide H e w)\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma subdivision_with_projD:\n    assumes \"subdivision_pair G H\"\n    shows \"pair_sd G H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_sd G H", "using assms"], ["proof (prove)\nusing this:\n  subdivision_pair G H\n\ngoal (1 subgoal):\n 1. pair_sd G H", "proof (induct \"with_proj H\" \"swap_in (parcs H)\" arbitrary: H rule: subdivision_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>H.\n       \\<lbrakk>bidirected_digraph (with_proj G) (swap_in (parcs G));\n        with_proj G = with_proj H;\n        swap_in (parcs G) = swap_in (parcs H)\\<rbrakk>\n       \\<Longrightarrow> pair_sd G H\n 2. \\<And>I rev_I u v w uv uw vw H.\n       \\<lbrakk>subdivision (with_proj G, swap_in (parcs G)) (I, rev_I);\n        \\<And>H.\n           \\<lbrakk>I = with_proj H; rev_I = swap_in (parcs H)\\<rbrakk>\n           \\<Longrightarrow> pair_sd G H;\n        subdivision_step I rev_I (with_proj H) (swap_in (parcs H)) (u, v, w)\n         (uv, uw, vw)\\<rbrakk>\n       \\<Longrightarrow> pair_sd G H", "case base"], ["proof (state)\nthis:\n  bidirected_digraph (with_proj G) (swap_in (parcs G))\n  with_proj G = with_proj H\n  swap_in (parcs G) = swap_in (parcs H)\n\ngoal (2 subgoals):\n 1. \\<And>H.\n       \\<lbrakk>bidirected_digraph (with_proj G) (swap_in (parcs G));\n        with_proj G = with_proj H;\n        swap_in (parcs G) = swap_in (parcs H)\\<rbrakk>\n       \\<Longrightarrow> pair_sd G H\n 2. \\<And>I rev_I u v w uv uw vw H.\n       \\<lbrakk>subdivision (with_proj G, swap_in (parcs G)) (I, rev_I);\n        \\<And>H.\n           \\<lbrakk>I = with_proj H; rev_I = swap_in (parcs H)\\<rbrakk>\n           \\<Longrightarrow> pair_sd G H;\n        subdivision_step I rev_I (with_proj H) (swap_in (parcs H)) (u, v, w)\n         (uv, uw, vw)\\<rbrakk>\n       \\<Longrightarrow> pair_sd G H", "interpret bidirected_digraph \"with_proj G\" \"swap_in (parcs G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bidirected_digraph (with_proj G) (swap_in (parcs G))", "by fact"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>H.\n       \\<lbrakk>bidirected_digraph (with_proj G) (swap_in (parcs G));\n        with_proj G = with_proj H;\n        swap_in (parcs G) = swap_in (parcs H)\\<rbrakk>\n       \\<Longrightarrow> pair_sd G H\n 2. \\<And>I rev_I u v w uv uw vw H.\n       \\<lbrakk>subdivision (with_proj G, swap_in (parcs G)) (I, rev_I);\n        \\<And>H.\n           \\<lbrakk>I = with_proj H; rev_I = swap_in (parcs H)\\<rbrakk>\n           \\<Longrightarrow> pair_sd G H;\n        subdivision_step I rev_I (with_proj H) (swap_in (parcs H)) (u, v, w)\n         (uv, uw, vw)\\<rbrakk>\n       \\<Longrightarrow> pair_sd G H", "from base"], ["proof (chain)\npicking this:\n  bidirected_digraph (with_proj G) (swap_in (parcs G))\n  with_proj G = with_proj H\n  swap_in (parcs G) = swap_in (parcs H)", "have \"G = H\""], ["proof (prove)\nusing this:\n  bidirected_digraph (with_proj G) (swap_in (parcs G))\n  with_proj G = with_proj H\n  swap_in (parcs G) = swap_in (parcs H)\n\ngoal (1 subgoal):\n 1. G = H", "by (simp add: with_proj_def)"], ["proof (state)\nthis:\n  G = H\n\ngoal (2 subgoals):\n 1. \\<And>H.\n       \\<lbrakk>bidirected_digraph (with_proj G) (swap_in (parcs G));\n        with_proj G = with_proj H;\n        swap_in (parcs G) = swap_in (parcs H)\\<rbrakk>\n       \\<Longrightarrow> pair_sd G H\n 2. \\<And>I rev_I u v w uv uw vw H.\n       \\<lbrakk>subdivision (with_proj G, swap_in (parcs G)) (I, rev_I);\n        \\<And>H.\n           \\<lbrakk>I = with_proj H; rev_I = swap_in (parcs H)\\<rbrakk>\n           \\<Longrightarrow> pair_sd G H;\n        subdivision_step I rev_I (with_proj H) (swap_in (parcs H)) (u, v, w)\n         (uv, uw, vw)\\<rbrakk>\n       \\<Longrightarrow> pair_sd G H", "with base"], ["proof (chain)\npicking this:\n  bidirected_digraph (with_proj G) (swap_in (parcs G))\n  with_proj G = with_proj H\n  swap_in (parcs G) = swap_in (parcs H)\n  G = H", "show ?case"], ["proof (prove)\nusing this:\n  bidirected_digraph (with_proj G) (swap_in (parcs G))\n  with_proj G = with_proj H\n  swap_in (parcs G) = swap_in (parcs H)\n  G = H\n\ngoal (1 subgoal):\n 1. pair_sd G H", "by (auto intro: pair_sd.base pair_bidirected_digraphI_bidirected_digraph)"], ["proof (state)\nthis:\n  pair_sd G H\n\ngoal (1 subgoal):\n 1. \\<And>I rev_I u v w uv uw vw H.\n       \\<lbrakk>subdivision (with_proj G, swap_in (parcs G)) (I, rev_I);\n        \\<And>H.\n           \\<lbrakk>I = with_proj H; rev_I = swap_in (parcs H)\\<rbrakk>\n           \\<Longrightarrow> pair_sd G H;\n        subdivision_step I rev_I (with_proj H) (swap_in (parcs H)) (u, v, w)\n         (uv, uw, vw)\\<rbrakk>\n       \\<Longrightarrow> pair_sd G H", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I rev_I u v w uv uw vw H.\n       \\<lbrakk>subdivision (with_proj G, swap_in (parcs G)) (I, rev_I);\n        \\<And>H.\n           \\<lbrakk>I = with_proj H; rev_I = swap_in (parcs H)\\<rbrakk>\n           \\<Longrightarrow> pair_sd G H;\n        subdivision_step I rev_I (with_proj H) (swap_in (parcs H)) (u, v, w)\n         (uv, uw, vw)\\<rbrakk>\n       \\<Longrightarrow> pair_sd G H", "case (divide I rev_I u v w uv uw vw)"], ["proof (state)\nthis:\n  subdivision (with_proj G, swap_in (parcs G)) (I, rev_I)\n  \\<lbrakk>I = with_proj ?H; rev_I = swap_in (parcs ?H)\\<rbrakk>\n  \\<Longrightarrow> pair_sd G ?H\n  subdivision_step I rev_I (with_proj H) (swap_in (parcs H)) (u, v, w)\n   (uv, uw, vw)\n\ngoal (1 subgoal):\n 1. \\<And>I rev_I u v w uv uw vw H.\n       \\<lbrakk>subdivision (with_proj G, swap_in (parcs G)) (I, rev_I);\n        \\<And>H.\n           \\<lbrakk>I = with_proj H; rev_I = swap_in (parcs H)\\<rbrakk>\n           \\<Longrightarrow> pair_sd G H;\n        subdivision_step I rev_I (with_proj H) (swap_in (parcs H)) (u, v, w)\n         (uv, uw, vw)\\<rbrakk>\n       \\<Longrightarrow> pair_sd G H", "define I' where \"I' = \\<lparr> pverts = verts I, parcs = arcs I \\<rparr>\""], ["proof (state)\nthis:\n  I' = \\<lparr>pverts = verts I, parcs = arcs I\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>I rev_I u v w uv uw vw H.\n       \\<lbrakk>subdivision (with_proj G, swap_in (parcs G)) (I, rev_I);\n        \\<And>H.\n           \\<lbrakk>I = with_proj H; rev_I = swap_in (parcs H)\\<rbrakk>\n           \\<Longrightarrow> pair_sd G H;\n        subdivision_step I rev_I (with_proj H) (swap_in (parcs H)) (u, v, w)\n         (uv, uw, vw)\\<rbrakk>\n       \\<Longrightarrow> pair_sd G H", "have \"compatible G I \""], ["proof (prove)\ngoal (1 subgoal):\n 1. compatible (with_proj G) I", "using \\<open>subdivision (with_proj G, _) (I, _)\\<close>"], ["proof (prove)\nusing this:\n  subdivision (with_proj G, swap_in (parcs G)) (I, rev_I)\n\ngoal (1 subgoal):\n 1. compatible (with_proj G) I", "by (rule subdivision_compatible)"], ["proof (state)\nthis:\n  compatible (with_proj G) I\n\ngoal (1 subgoal):\n 1. \\<And>I rev_I u v w uv uw vw H.\n       \\<lbrakk>subdivision (with_proj G, swap_in (parcs G)) (I, rev_I);\n        \\<And>H.\n           \\<lbrakk>I = with_proj H; rev_I = swap_in (parcs H)\\<rbrakk>\n           \\<Longrightarrow> pair_sd G H;\n        subdivision_step I rev_I (with_proj H) (swap_in (parcs H)) (u, v, w)\n         (uv, uw, vw)\\<rbrakk>\n       \\<Longrightarrow> pair_sd G H", "then"], ["proof (chain)\npicking this:\n  compatible (with_proj G) I", "have \"tail I = fst\" \"head I = snd\""], ["proof (prove)\nusing this:\n  compatible (with_proj G) I\n\ngoal (1 subgoal):\n 1. tail I = fst &&& head I = snd", "by (auto simp: compatible_def)"], ["proof (state)\nthis:\n  tail I = fst\n  head I = snd\n\ngoal (1 subgoal):\n 1. \\<And>I rev_I u v w uv uw vw H.\n       \\<lbrakk>subdivision (with_proj G, swap_in (parcs G)) (I, rev_I);\n        \\<And>H.\n           \\<lbrakk>I = with_proj H; rev_I = swap_in (parcs H)\\<rbrakk>\n           \\<Longrightarrow> pair_sd G H;\n        subdivision_step I rev_I (with_proj H) (swap_in (parcs H)) (u, v, w)\n         (uv, uw, vw)\\<rbrakk>\n       \\<Longrightarrow> pair_sd G H", "then"], ["proof (chain)\npicking this:\n  tail I = fst\n  head I = snd", "have I: \"I = I'\""], ["proof (prove)\nusing this:\n  tail I = fst\n  head I = snd\n\ngoal (1 subgoal):\n 1. I = with_proj I'", "by (auto simp: I'_def)"], ["proof (state)\nthis:\n  I = with_proj I'\n\ngoal (1 subgoal):\n 1. \\<And>I rev_I u v w uv uw vw H.\n       \\<lbrakk>subdivision (with_proj G, swap_in (parcs G)) (I, rev_I);\n        \\<And>H.\n           \\<lbrakk>I = with_proj H; rev_I = swap_in (parcs H)\\<rbrakk>\n           \\<Longrightarrow> pair_sd G H;\n        subdivision_step I rev_I (with_proj H) (swap_in (parcs H)) (u, v, w)\n         (uv, uw, vw)\\<rbrakk>\n       \\<Longrightarrow> pair_sd G H", "moreover"], ["proof (state)\nthis:\n  I = with_proj I'\n\ngoal (1 subgoal):\n 1. \\<And>I rev_I u v w uv uw vw H.\n       \\<lbrakk>subdivision (with_proj G, swap_in (parcs G)) (I, rev_I);\n        \\<And>H.\n           \\<lbrakk>I = with_proj H; rev_I = swap_in (parcs H)\\<rbrakk>\n           \\<Longrightarrow> pair_sd G H;\n        subdivision_step I rev_I (with_proj H) (swap_in (parcs H)) (u, v, w)\n         (uv, uw, vw)\\<rbrakk>\n       \\<Longrightarrow> pair_sd G H", "from I"], ["proof (chain)\npicking this:\n  I = with_proj I'", "have \"rev_I = swap_in (parcs I')\""], ["proof (prove)\nusing this:\n  I = with_proj I'\n\ngoal (1 subgoal):\n 1. rev_I = swap_in (parcs I')", "using \\<open>subdivision_step _ _ _ _ _ _\\<close>"], ["proof (prove)\nusing this:\n  I = with_proj I'\n  subdivision_step I rev_I (with_proj H) (swap_in (parcs H)) (u, v, w)\n   (uv, uw, vw)\n\ngoal (1 subgoal):\n 1. rev_I = swap_in (parcs I')", "by (simp add: subdivision_step_def bidirected_digraph_rev_conv_pair)"], ["proof (state)\nthis:\n  rev_I = swap_in (parcs I')\n\ngoal (1 subgoal):\n 1. \\<And>I rev_I u v w uv uw vw H.\n       \\<lbrakk>subdivision (with_proj G, swap_in (parcs G)) (I, rev_I);\n        \\<And>H.\n           \\<lbrakk>I = with_proj H; rev_I = swap_in (parcs H)\\<rbrakk>\n           \\<Longrightarrow> pair_sd G H;\n        subdivision_step I rev_I (with_proj H) (swap_in (parcs H)) (u, v, w)\n         (uv, uw, vw)\\<rbrakk>\n       \\<Longrightarrow> pair_sd G H", "ultimately"], ["proof (chain)\npicking this:\n  I = with_proj I'\n  rev_I = swap_in (parcs I')", "have pd_sd: \"pair_sd G I'\""], ["proof (prove)\nusing this:\n  I = with_proj I'\n  rev_I = swap_in (parcs I')\n\ngoal (1 subgoal):\n 1. pair_sd G I'", "by (auto intro: divide.hyps)"], ["proof (state)\nthis:\n  pair_sd G I'\n\ngoal (1 subgoal):\n 1. \\<And>I rev_I u v w uv uw vw H.\n       \\<lbrakk>subdivision (with_proj G, swap_in (parcs G)) (I, rev_I);\n        \\<And>H.\n           \\<lbrakk>I = with_proj H; rev_I = swap_in (parcs H)\\<rbrakk>\n           \\<Longrightarrow> pair_sd G H;\n        subdivision_step I rev_I (with_proj H) (swap_in (parcs H)) (u, v, w)\n         (uv, uw, vw)\\<rbrakk>\n       \\<Longrightarrow> pair_sd G H", "interpret sd: subdiv_step I' \"swap_in (parcs I')\" H \"swap_in (parcs H)\" u v w uv uw vw"], ["proof (prove)\ngoal (1 subgoal):\n 1. subdiv_step (with_proj I') (swap_in (parcs I')) (with_proj H)\n     (swap_in (parcs H)) u v w uv uw vw", "using \\<open>subdivision_step _ _ _ _ _ _\\<close>"], ["proof (prove)\nusing this:\n  subdivision_step I rev_I (with_proj H) (swap_in (parcs H)) (u, v, w)\n   (uv, uw, vw)\n\ngoal (1 subgoal):\n 1. subdiv_step (with_proj I') (swap_in (parcs I')) (with_proj H)\n     (swap_in (parcs H)) u v w uv uw vw", "unfolding \\<open>I = _\\<close> \\<open>rev_I = _\\<close>"], ["proof (prove)\nusing this:\n  subdivision_step (with_proj I') (swap_in (parcs I')) (with_proj H)\n   (swap_in (parcs H)) (u, v, w) (uv, uw, vw)\n\ngoal (1 subgoal):\n 1. subdiv_step (with_proj I') (swap_in (parcs I')) (with_proj H)\n     (swap_in (parcs H)) u v w uv uw vw", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I rev_I u v w uv uw vw H.\n       \\<lbrakk>subdivision (with_proj G, swap_in (parcs G)) (I, rev_I);\n        \\<And>H.\n           \\<lbrakk>I = with_proj H; rev_I = swap_in (parcs H)\\<rbrakk>\n           \\<Longrightarrow> pair_sd G H;\n        subdivision_step I rev_I (with_proj H) (swap_in (parcs H)) (u, v, w)\n         (uv, uw, vw)\\<rbrakk>\n       \\<Longrightarrow> pair_sd G H", "have ends: \"uv = (u,v)\" \"uw = (u,w)\" \"vw = (v,w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uv = (u, v) &&& uw = (u, w) &&& vw = (v, w)", "using sd.subdiv_ate"], ["proof (prove)\nusing this:\n  arc_to_ends (with_proj I') uv = (u, v)\n  arc_to_ends (with_proj H) uv = (u, v)\n  arc_to_ends (with_proj H) uw = (u, w)\n  arc_to_ends (with_proj H) vw = (v, w)\n\ngoal (1 subgoal):\n 1. uv = (u, v) &&& uw = (u, w) &&& vw = (v, w)", "by simp_all"], ["proof (state)\nthis:\n  uv = (u, v)\n  uw = (u, w)\n  vw = (v, w)\n\ngoal (1 subgoal):\n 1. \\<And>I rev_I u v w uv uw vw H.\n       \\<lbrakk>subdivision (with_proj G, swap_in (parcs G)) (I, rev_I);\n        \\<And>H.\n           \\<lbrakk>I = with_proj H; rev_I = swap_in (parcs H)\\<rbrakk>\n           \\<Longrightarrow> pair_sd G H;\n        subdivision_step I rev_I (with_proj H) (swap_in (parcs H)) (u, v, w)\n         (uv, uw, vw)\\<rbrakk>\n       \\<Longrightarrow> pair_sd G H", "then"], ["proof (chain)\npicking this:\n  uv = (u, v)\n  uw = (u, w)\n  vw = (v, w)", "have si_ends: \"swap_in (parcs H) (u,w) = (w,u)\" \"swap_in (parcs H) (v,w) = (w,v)\"\n        \"swap_in (parcs I') (u,v) = (v,u)\""], ["proof (prove)\nusing this:\n  uv = (u, v)\n  uw = (u, w)\n  vw = (v, w)\n\ngoal (1 subgoal):\n 1. swap_in (parcs H) (u, w) = (w, u) &&&\n    swap_in (parcs H) (v, w) = (w, v) &&& swap_in (parcs I') (u, v) = (v, u)", "using sd.subdiv_ends_H_rev sd.subdiv_ends_G_rev"], ["proof (prove)\nusing this:\n  uv = (u, v)\n  uw = (u, w)\n  vw = (v, w)\n  tail (with_proj H) (swap_in (parcs H) uw) = w\n  tail (with_proj H) (swap_in (parcs H) vw) = w\n  head (with_proj H) (swap_in (parcs H) uw) = u\n  head (with_proj H) (swap_in (parcs H) vw) = v\n  tail (with_proj I') (swap_in (parcs I') uv) = v\n  head (with_proj I') (swap_in (parcs I') uv) = u\n  tail (with_proj H) (swap_in (parcs I') uv) = v\n  head (with_proj H) (swap_in (parcs I') uv) = u\n\ngoal (1 subgoal):\n 1. swap_in (parcs H) (u, w) = (w, u) &&&\n    swap_in (parcs H) (v, w) = (w, v) &&& swap_in (parcs I') (u, v) = (v, u)", "by (auto simp: swap_in_def)"], ["proof (state)\nthis:\n  swap_in (parcs H) (u, w) = (w, u)\n  swap_in (parcs H) (v, w) = (w, v)\n  swap_in (parcs I') (u, v) = (v, u)\n\ngoal (1 subgoal):\n 1. \\<And>I rev_I u v w uv uw vw H.\n       \\<lbrakk>subdivision (with_proj G, swap_in (parcs G)) (I, rev_I);\n        \\<And>H.\n           \\<lbrakk>I = with_proj H; rev_I = swap_in (parcs H)\\<rbrakk>\n           \\<Longrightarrow> pair_sd G H;\n        subdivision_step I rev_I (with_proj H) (swap_in (parcs H)) (u, v, w)\n         (uv, uw, vw)\\<rbrakk>\n       \\<Longrightarrow> pair_sd G H", "have \"parcs H = parcs I' - {(u, v), (v, u)} \\<union> {(u, w), (w, u), (w, v), (v, w)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parcs H =\n    parcs I' - {(u, v), (v, u)} \\<union> {(u, w), (w, u), (w, v), (v, w)}", "using sd.in_arcs_G sd.not_in_arcs_G sd.arcs_H"], ["proof (prove)\nusing this:\n  {uv, swap_in (parcs I') uv} \\<subseteq> arcs (with_proj I')\n  {uw, swap_in (parcs H) uw, vw, swap_in (parcs H) vw} \\<inter>\n  arcs (with_proj I') =\n  {}\n  arcs (with_proj H) =\n  {uw, swap_in (parcs H) uw, vw, swap_in (parcs H) vw} \\<union>\n  arcs (with_proj I') -\n  {uv, swap_in (parcs I') uv}\n\ngoal (1 subgoal):\n 1. parcs H =\n    parcs I' - {(u, v), (v, u)} \\<union> {(u, w), (w, u), (w, v), (v, w)}", "by (auto simp: si_ends ends)"], ["proof (state)\nthis:\n  parcs H =\n  parcs I' - {(u, v), (v, u)} \\<union> {(u, w), (w, u), (w, v), (v, w)}\n\ngoal (1 subgoal):\n 1. \\<And>I rev_I u v w uv uw vw H.\n       \\<lbrakk>subdivision (with_proj G, swap_in (parcs G)) (I, rev_I);\n        \\<And>H.\n           \\<lbrakk>I = with_proj H; rev_I = swap_in (parcs H)\\<rbrakk>\n           \\<Longrightarrow> pair_sd G H;\n        subdivision_step I rev_I (with_proj H) (swap_in (parcs H)) (u, v, w)\n         (uv, uw, vw)\\<rbrakk>\n       \\<Longrightarrow> pair_sd G H", "then"], ["proof (chain)\npicking this:\n  parcs H =\n  parcs I' - {(u, v), (v, u)} \\<union> {(u, w), (w, u), (w, v), (v, w)}", "have \"H = subdivide I' uv w\""], ["proof (prove)\nusing this:\n  parcs H =\n  parcs I' - {(u, v), (v, u)} \\<union> {(u, w), (w, u), (w, v), (v, w)}\n\ngoal (1 subgoal):\n 1. H = subdivide I' uv w", "using sd.verts_H"], ["proof (prove)\nusing this:\n  parcs H =\n  parcs I' - {(u, v), (v, u)} \\<union> {(u, w), (w, u), (w, v), (v, w)}\n  verts (with_proj H) = verts (with_proj I') \\<union> {w}\n\ngoal (1 subgoal):\n 1. H = subdivide I' uv w", "by (simp add: ends subdivide.simps)"], ["proof (state)\nthis:\n  H = subdivide I' uv w\n\ngoal (1 subgoal):\n 1. \\<And>I rev_I u v w uv uw vw H.\n       \\<lbrakk>subdivision (with_proj G, swap_in (parcs G)) (I, rev_I);\n        \\<And>H.\n           \\<lbrakk>I = with_proj H; rev_I = swap_in (parcs H)\\<rbrakk>\n           \\<Longrightarrow> pair_sd G H;\n        subdivision_step I rev_I (with_proj H) (swap_in (parcs H)) (u, v, w)\n         (uv, uw, vw)\\<rbrakk>\n       \\<Longrightarrow> pair_sd G H", "then"], ["proof (chain)\npicking this:\n  H = subdivide I' uv w", "show ?case"], ["proof (prove)\nusing this:\n  H = subdivide I' uv w\n\ngoal (1 subgoal):\n 1. pair_sd G H", "using sd.in_arcs_G sd.not_in_verts_G"], ["proof (prove)\nusing this:\n  H = subdivide I' uv w\n  {uv, swap_in (parcs I') uv} \\<subseteq> arcs (with_proj I')\n  w \\<notin> verts (with_proj I')\n\ngoal (1 subgoal):\n 1. pair_sd G H", "by (auto intro: pd_sd pair_sd.divide)"], ["proof (state)\nthis:\n  pair_sd G H\n\ngoal:\nNo subgoals!", "qed"], ["", "private"], ["", "lemma subdivision_pair_conv:\n    \"pair_sd G H = subdivision_pair G H \""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_sd G H = subdivision_pair G H", "by (metis subdivision_with_projD subdivision_with_projI)"], ["", "lemmas subdivision_pair_induct = pair_sd.induct[\n      unfolded subdivision_pair_conv, case_names base divide, induct pred: pair_sd]"], ["", "lemmas subdivision_pair_base = pair_sd.base[unfolded subdivision_pair_conv]"], ["", "lemmas subdivision_pair_divide = pair_sd.divide[unfolded subdivision_pair_conv]"], ["", "lemmas subdivision_pair_intros = pair_sd.intros[unfolded subdivision_pair_conv]"], ["", "lemmas subdivision_pair_cases = pair_sd.cases[unfolded subdivision_pair_conv]"], ["", "lemmas subdivision_pair_simps = pair_sd.simps[unfolded subdivision_pair_conv]"], ["", "lemmas bidirected_digraphI_subdivision = bidirected_digraphI_pair_sd[unfolded subdivision_pair_conv]"], ["", "end"], ["", "lemma (in pair_graph) pair_graph_subdivision:\n  assumes \"subdivision_pair G H\"\n  shows \"pair_graph H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_graph H", "using assms"], ["proof (prove)\nusing this:\n  subdivision_pair G H\n\ngoal (1 subgoal):\n 1. pair_graph H", "by (induct rule: subdivision_pair_induct) (blast intro: pair_graph.pair_graph_subdivide divide)+"], ["", "end"]]}