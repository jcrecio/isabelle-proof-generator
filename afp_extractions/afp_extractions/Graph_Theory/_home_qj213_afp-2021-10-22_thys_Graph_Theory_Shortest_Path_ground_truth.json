{"file_name": "/home/qj213/afp-2021-10-22/thys/Graph_Theory/Shortest_Path.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Graph_Theory", "problem_names": ["lemma shortest_path_inf:\n  assumes \"\\<not>(u \\<rightarrow>\\<^sup>* v)\"\n  shows \"\\<mu> f u v = \\<infinity>\"", "lemma min_cost_le_walk_cost:\n  assumes \"awalk u p v\" \n  shows \"\\<mu> c u v \\<le> awalk_cost c p\"", "lemma pos_cost_pos_awalk_cost:\n  assumes \"awalk u p v\"\n  assumes pos_cost: \"\\<And>e. e \\<in> arcs G \\<Longrightarrow> c e \\<ge> 0\"\n  shows \"awalk_cost c p \\<ge> 0\"", "lemma mk_cycles_path_awalk:\n  assumes \"awalk u c u\"\n  shows \"awalk u (mk_cycles_path n c) u\"", "lemma mk_cycles_awalk_cost:\n  assumes \"awalk u p u\"\n  shows \"awalk_cost c (mk_cycles_path n p) = n * awalk_cost c p\"", "lemma inf_over_nats:\n  fixes a c :: real\n  assumes \"c < 0\"\n  shows \"(INF (i :: nat). ereal (a + i * c)) = - \\<infinity>\"", "lemma neg_cycle_imp_inf_\\<mu>:\n  assumes walk_p: \"awalk u p v\"\n  assumes walk_c: \"awalk w c w\"\n  assumes w_in_p: \"w \\<in> set (awalk_verts u p)\"\n  assumes \"awalk_cost f c < 0\"\n  shows \"\\<mu> f u v = -\\<infinity>\"", "lemma walk_cheaper_path_imp_neg_cyc:\n  assumes p_props: \"awalk u p v\"\n  assumes less_path_\\<mu>: \"awalk_cost f p < (INF p\\<in> {p. apath u p v}. ereal (awalk_cost f p))\"\n  shows \"\\<exists>w c. awalk w c w \\<and> w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\"", "lemma (in fin_digraph) neg_inf_imp_neg_cyc:\n  assumes inf_mu: \"\\<mu> f u v = - \\<infinity>\"\n  shows \"\\<exists>p. awalk u p v \\<and> (\\<exists>w c. awalk w c w \\<and> w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0)\"", "lemma (in fin_digraph) no_neg_cyc_imp_no_neg_inf:\n  assumes no_neg_cyc: \"\\<And>p. awalk u p v\n    \\<Longrightarrow> \\<not>(\\<exists>w c. awalk w c w \\<and> w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0)\"\n  shows \"- \\<infinity> < \\<mu> f u v\"", "lemma \\<mu>_reach_conv:\n  \"\\<mu> f u v < \\<infinity> \\<longleftrightarrow> u \\<rightarrow>\\<^sup>* v\"", "lemma awalk_to_path_no_neg_cyc_cost:\n  assumes p_props:\"awalk u p v\"\n  assumes no_neg_cyc: \"\\<not> (\\<exists>w c. awalk w c w \\<and> w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0)\"\n  shows \"awalk_cost f (awalk_to_apath p) \\<le> awalk_cost f p\"", "lemma (in fin_digraph) no_neg_cyc_reach_imp_path:\n  assumes reach: \"u \\<rightarrow>\\<^sup>* v\"\n  assumes no_neg_cyc: \"\\<And>p. awalk u p v\n    \\<Longrightarrow> \\<not>(\\<exists>w c. awalk w c w \\<and> w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0)\"\n  shows \"\\<exists>p. apath u p v \\<and> \\<mu> f u v = awalk_cost f p\"", "lemma (in fin_digraph) min_cost_awalk:\n  assumes reach: \"u \\<rightarrow>\\<^sup>* v\"\n  assumes pos_cost: \"\\<And>e. e \\<in> arcs G \\<Longrightarrow> c e \\<ge> 0\"\n  shows \"\\<exists>p. apath u p v \\<and> \\<mu> c u v = awalk_cost c p\"", "lemma (in fin_digraph) pos_cost_mu_triangle:\n  assumes pos_cost: \"\\<And>e. e \\<in> arcs G \\<Longrightarrow> c e \\<ge> 0\" (* introduce predicate? *)\n  assumes e_props: \"arc_to_ends G e = (u,v)\" \"e \\<in> arcs G\"\n  shows \"\\<mu> c s v \\<le> \\<mu> c s u + c e\"", "lemma (in fin_digraph) mu_exact_triangle:\n  assumes \"v \\<noteq> s\"\n  assumes \"s \\<rightarrow>\\<^sup>* v\"\n  assumes nonneg_arcs: \"\\<And>e. e \\<in> arcs G \\<Longrightarrow> 0 \\<le> c e\"\n  obtains u e where \"\\<mu> c s v = \\<mu> c s u + c e\" and \"arc e (u,v)\"", "lemma (in fin_digraph) mu_exact_triangle_Ex:\n  assumes \"v \\<noteq> s\"\n  assumes \"s \\<rightarrow>\\<^sup>* v\"\n  assumes \"\\<And>e. e \\<in> arcs G \\<Longrightarrow> 0 \\<le> c e\"\n  shows \"\\<exists>u e. \\<mu> c s v = \\<mu> c s u + c e \\<and> arc e (u,v)\"", "lemma (in fin_digraph) mu_Inf_triangle:\n  assumes \"v \\<noteq> s\"\n  assumes \"\\<And>e. e \\<in> arcs G \\<Longrightarrow> 0 \\<le> c e\"\n  shows \"\\<mu> c s v = Inf {\\<mu> c s u + c e | u e. arc e (u, v)}\" (is \"_ = Inf ?S\")"], "translations": [["", "lemma shortest_path_inf:\n  assumes \"\\<not>(u \\<rightarrow>\\<^sup>* v)\"\n  shows \"\\<mu> f u v = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> f u v = \\<infinity>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<mu> f u v = \\<infinity>", "have *: \"{p. awalk u p v} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. awalk u p v} = {}", "using assms"], ["proof (prove)\nusing this:\n  \\<not> u \\<rightarrow>\\<^sup>* v\n\ngoal (1 subgoal):\n 1. {p. awalk u p v} = {}", "by (auto simp: reachable_awalk)"], ["proof (state)\nthis:\n  {p. awalk u p v} = {}\n\ngoal (1 subgoal):\n 1. \\<mu> f u v = \\<infinity>", "show \"\\<mu> f u v = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> f u v = \\<infinity>", "unfolding \\<mu>_def *"], ["proof (prove)\ngoal (1 subgoal):\n 1. (INF p\\<in>{}. ereal (awalk_cost f p)) = \\<infinity>", "by (simp add: top_ereal_def)"], ["proof (state)\nthis:\n  \\<mu> f u v = \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma min_cost_le_walk_cost:\n  assumes \"awalk u p v\" \n  shows \"\\<mu> c u v \\<le> awalk_cost c p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> c u v \\<le> ereal (awalk_cost c p)", "using assms"], ["proof (prove)\nusing this:\n  awalk u p v\n\ngoal (1 subgoal):\n 1. \\<mu> c u v \\<le> ereal (awalk_cost c p)", "unfolding \\<mu>_def"], ["proof (prove)\nusing this:\n  awalk u p v\n\ngoal (1 subgoal):\n 1. (INF p\\<in>{p. awalk u p v}. ereal (awalk_cost c p))\n    \\<le> ereal (awalk_cost c p)", "by (auto intro: INF_lower2)"], ["", "lemma pos_cost_pos_awalk_cost:\n  assumes \"awalk u p v\"\n  assumes pos_cost: \"\\<And>e. e \\<in> arcs G \\<Longrightarrow> c e \\<ge> 0\"\n  shows \"awalk_cost c p \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> awalk_cost c p", "using assms"], ["proof (prove)\nusing this:\n  awalk u p v\n  ?e \\<in> arcs G \\<Longrightarrow> 0 \\<le> c ?e\n\ngoal (1 subgoal):\n 1. 0 \\<le> awalk_cost c p", "by (induct p arbitrary: u) (auto simp: awalk_Cons_iff)"], ["", "fun mk_cycles_path :: \"nat\n  \\<Rightarrow> 'b awalk \\<Rightarrow> 'b awalk\" where\n    \"mk_cycles_path 0 c = []\"\n  | \"mk_cycles_path (Suc n) c = c @ (mk_cycles_path n c)\""], ["", "lemma mk_cycles_path_awalk:\n  assumes \"awalk u c u\"\n  shows \"awalk u (mk_cycles_path n c) u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk u (mk_cycles_path n c) u", "using assms"], ["proof (prove)\nusing this:\n  awalk u c u\n\ngoal (1 subgoal):\n 1. awalk u (mk_cycles_path n c) u", "by (induct n) (auto simp: awalk_Nil_iff)"], ["", "lemma mk_cycles_awalk_cost:\n  assumes \"awalk u p u\"\n  shows \"awalk_cost c (mk_cycles_path n p) = n * awalk_cost c p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk_cost c (mk_cycles_path n p) = real n * awalk_cost c p", "using assms"], ["proof (prove)\nusing this:\n  awalk u p u\n\ngoal (1 subgoal):\n 1. awalk_cost c (mk_cycles_path n p) = real n * awalk_cost c p", "proof (induct rule: mk_cycles_path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ca.\n       awalk u ca u \\<Longrightarrow>\n       awalk_cost c (mk_cycles_path 0 ca) = real 0 * awalk_cost c ca\n 2. \\<And>n ca.\n       \\<lbrakk>awalk u ca u \\<Longrightarrow>\n                awalk_cost c (mk_cycles_path n ca) =\n                real n * awalk_cost c ca;\n        awalk u ca u\\<rbrakk>\n       \\<Longrightarrow> awalk_cost c (mk_cycles_path (Suc n) ca) =\n                         real (Suc n) * awalk_cost c ca", "case 1"], ["proof (state)\nthis:\n  awalk u c_ u\n\ngoal (2 subgoals):\n 1. \\<And>ca.\n       awalk u ca u \\<Longrightarrow>\n       awalk_cost c (mk_cycles_path 0 ca) = real 0 * awalk_cost c ca\n 2. \\<And>n ca.\n       \\<lbrakk>awalk u ca u \\<Longrightarrow>\n                awalk_cost c (mk_cycles_path n ca) =\n                real n * awalk_cost c ca;\n        awalk u ca u\\<rbrakk>\n       \\<Longrightarrow> awalk_cost c (mk_cycles_path (Suc n) ca) =\n                         real (Suc n) * awalk_cost c ca", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk_cost c (mk_cycles_path 0 c_) = real 0 * awalk_cost c c_", "by simp"], ["proof (state)\nthis:\n  awalk_cost c (mk_cycles_path 0 c_) = real 0 * awalk_cost c c_\n\ngoal (1 subgoal):\n 1. \\<And>n ca.\n       \\<lbrakk>awalk u ca u \\<Longrightarrow>\n                awalk_cost c (mk_cycles_path n ca) =\n                real n * awalk_cost c ca;\n        awalk u ca u\\<rbrakk>\n       \\<Longrightarrow> awalk_cost c (mk_cycles_path (Suc n) ca) =\n                         real (Suc n) * awalk_cost c ca", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n ca.\n       \\<lbrakk>awalk u ca u \\<Longrightarrow>\n                awalk_cost c (mk_cycles_path n ca) =\n                real n * awalk_cost c ca;\n        awalk u ca u\\<rbrakk>\n       \\<Longrightarrow> awalk_cost c (mk_cycles_path (Suc n) ca) =\n                         real (Suc n) * awalk_cost c ca", "case (2 n p)"], ["proof (state)\nthis:\n  awalk u p u \\<Longrightarrow>\n  awalk_cost c (mk_cycles_path n p) = real n * awalk_cost c p\n  awalk u p u\n\ngoal (1 subgoal):\n 1. \\<And>n ca.\n       \\<lbrakk>awalk u ca u \\<Longrightarrow>\n                awalk_cost c (mk_cycles_path n ca) =\n                real n * awalk_cost c ca;\n        awalk u ca u\\<rbrakk>\n       \\<Longrightarrow> awalk_cost c (mk_cycles_path (Suc n) ca) =\n                         real (Suc n) * awalk_cost c ca", "have \"awalk_cost c (mk_cycles_path (Suc n) p)\n      = awalk_cost c (p @ (mk_cycles_path n p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk_cost c (mk_cycles_path (Suc n) p) =\n    awalk_cost c (p @ mk_cycles_path n p)", "by simp"], ["proof (state)\nthis:\n  awalk_cost c (mk_cycles_path (Suc n) p) =\n  awalk_cost c (p @ mk_cycles_path n p)\n\ngoal (1 subgoal):\n 1. \\<And>n ca.\n       \\<lbrakk>awalk u ca u \\<Longrightarrow>\n                awalk_cost c (mk_cycles_path n ca) =\n                real n * awalk_cost c ca;\n        awalk u ca u\\<rbrakk>\n       \\<Longrightarrow> awalk_cost c (mk_cycles_path (Suc n) ca) =\n                         real (Suc n) * awalk_cost c ca", "also"], ["proof (state)\nthis:\n  awalk_cost c (mk_cycles_path (Suc n) p) =\n  awalk_cost c (p @ mk_cycles_path n p)\n\ngoal (1 subgoal):\n 1. \\<And>n ca.\n       \\<lbrakk>awalk u ca u \\<Longrightarrow>\n                awalk_cost c (mk_cycles_path n ca) =\n                real n * awalk_cost c ca;\n        awalk u ca u\\<rbrakk>\n       \\<Longrightarrow> awalk_cost c (mk_cycles_path (Suc n) ca) =\n                         real (Suc n) * awalk_cost c ca", "have \"\\<dots> = awalk_cost c p + real n * awalk_cost c p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk_cost c (p @ mk_cycles_path n p) =\n    awalk_cost c p + real n * awalk_cost c p", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    awalk_cost c (p @ mk_cycles_path n p) =\n    awalk_cost c p + real n * awalk_cost c p\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       awalk_cost c (p @ mk_cycles_path n p) =\n       awalk_cost c p + real n * awalk_cost c p", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    awalk_cost c (p @ mk_cycles_path n p) =\n    awalk_cost c p + real n * awalk_cost c p\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       awalk_cost c (p @ mk_cycles_path n p) =\n       awalk_cost c p + real n * awalk_cost c p", "then"], ["proof (chain)\npicking this:\n  n = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. awalk_cost c (p @ mk_cycles_path n p) =\n    awalk_cost c p + real n * awalk_cost c p", "by simp"], ["proof (state)\nthis:\n  awalk_cost c (p @ mk_cycles_path n p) =\n  awalk_cost c p + real n * awalk_cost c p\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       awalk_cost c (p @ mk_cycles_path n p) =\n       awalk_cost c p + real n * awalk_cost c p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       awalk_cost c (p @ mk_cycles_path n p) =\n       awalk_cost c p + real n * awalk_cost c p", "case (Suc n')"], ["proof (state)\nthis:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       awalk_cost c (p @ mk_cycles_path n p) =\n       awalk_cost c p + real n * awalk_cost c p", "then"], ["proof (chain)\npicking this:\n  n = Suc n'", "show ?thesis"], ["proof (prove)\nusing this:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. awalk_cost c (p @ mk_cycles_path n p) =\n    awalk_cost c p + real n * awalk_cost c p", "using 2"], ["proof (prove)\nusing this:\n  n = Suc n'\n  awalk u p u \\<Longrightarrow>\n  awalk_cost c (mk_cycles_path n p) = real n * awalk_cost c p\n  awalk u p u\n\ngoal (1 subgoal):\n 1. awalk_cost c (p @ mk_cycles_path n p) =\n    awalk_cost c p + real n * awalk_cost c p", "by simp"], ["proof (state)\nthis:\n  awalk_cost c (p @ mk_cycles_path n p) =\n  awalk_cost c p + real n * awalk_cost c p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  awalk_cost c (p @ mk_cycles_path n p) =\n  awalk_cost c p + real n * awalk_cost c p\n\ngoal (1 subgoal):\n 1. \\<And>n ca.\n       \\<lbrakk>awalk u ca u \\<Longrightarrow>\n                awalk_cost c (mk_cycles_path n ca) =\n                real n * awalk_cost c ca;\n        awalk u ca u\\<rbrakk>\n       \\<Longrightarrow> awalk_cost c (mk_cycles_path (Suc n) ca) =\n                         real (Suc n) * awalk_cost c ca", "also"], ["proof (state)\nthis:\n  awalk_cost c (p @ mk_cycles_path n p) =\n  awalk_cost c p + real n * awalk_cost c p\n\ngoal (1 subgoal):\n 1. \\<And>n ca.\n       \\<lbrakk>awalk u ca u \\<Longrightarrow>\n                awalk_cost c (mk_cycles_path n ca) =\n                real n * awalk_cost c ca;\n        awalk u ca u\\<rbrakk>\n       \\<Longrightarrow> awalk_cost c (mk_cycles_path (Suc n) ca) =\n                         real (Suc n) * awalk_cost c ca", "have \"\\<dots> = real (Suc n) * awalk_cost c p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk_cost c p + real n * awalk_cost c p = real (Suc n) * awalk_cost c p", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  awalk_cost c p + real n * awalk_cost c p = real (Suc n) * awalk_cost c p\n\ngoal (1 subgoal):\n 1. \\<And>n ca.\n       \\<lbrakk>awalk u ca u \\<Longrightarrow>\n                awalk_cost c (mk_cycles_path n ca) =\n                real n * awalk_cost c ca;\n        awalk u ca u\\<rbrakk>\n       \\<Longrightarrow> awalk_cost c (mk_cycles_path (Suc n) ca) =\n                         real (Suc n) * awalk_cost c ca", "finally"], ["proof (chain)\npicking this:\n  awalk_cost c (mk_cycles_path (Suc n) p) = real (Suc n) * awalk_cost c p", "show ?case"], ["proof (prove)\nusing this:\n  awalk_cost c (mk_cycles_path (Suc n) p) = real (Suc n) * awalk_cost c p\n\ngoal (1 subgoal):\n 1. awalk_cost c (mk_cycles_path (Suc n) p) = real (Suc n) * awalk_cost c p", "."], ["proof (state)\nthis:\n  awalk_cost c (mk_cycles_path (Suc n) p) = real (Suc n) * awalk_cost c p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inf_over_nats:\n  fixes a c :: real\n  assumes \"c < 0\"\n  shows \"(INF (i :: nat). ereal (a + i * c)) = - \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (INF x. ereal (a + real x * c)) = - \\<infinity>", "proof (rule INF_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow>\n       - \\<infinity> \\<le> ereal (a + real x * c)\n 2. \\<And>y.\n       (\\<And>x.\n           x \\<in> UNIV \\<Longrightarrow>\n           y \\<le> ereal (a + real x * c)) \\<Longrightarrow>\n       y \\<le> - \\<infinity>", "fix i :: nat"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow>\n       - \\<infinity> \\<le> ereal (a + real x * c)\n 2. \\<And>y.\n       (\\<And>x.\n           x \\<in> UNIV \\<Longrightarrow>\n           y \\<le> ereal (a + real x * c)) \\<Longrightarrow>\n       y \\<le> - \\<infinity>", "show \"- \\<infinity> \\<le> a + real i * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - \\<infinity> \\<le> ereal (a + real i * c)", "by simp"], ["proof (state)\nthis:\n  - \\<infinity> \\<le> ereal (a + real i * c)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       (\\<And>x.\n           x \\<in> UNIV \\<Longrightarrow>\n           y \\<le> ereal (a + real x * c)) \\<Longrightarrow>\n       y \\<le> - \\<infinity>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       (\\<And>x.\n           x \\<in> UNIV \\<Longrightarrow>\n           y \\<le> ereal (a + real x * c)) \\<Longrightarrow>\n       y \\<le> - \\<infinity>", "fix y :: ereal"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       (\\<And>x.\n           x \\<in> UNIV \\<Longrightarrow>\n           y \\<le> ereal (a + real x * c)) \\<Longrightarrow>\n       y \\<le> - \\<infinity>", "assume \"\\<And>(i :: nat). i \\<in> UNIV \\<Longrightarrow> y \\<le> a + real i * c\""], ["proof (state)\nthis:\n  ?i \\<in> UNIV \\<Longrightarrow> y \\<le> ereal (a + real ?i * c)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       (\\<And>x.\n           x \\<in> UNIV \\<Longrightarrow>\n           y \\<le> ereal (a + real x * c)) \\<Longrightarrow>\n       y \\<le> - \\<infinity>", "then"], ["proof (chain)\npicking this:\n  ?i \\<in> UNIV \\<Longrightarrow> y \\<le> ereal (a + real ?i * c)", "have l_assm: \"\\<And>i::nat. y \\<le> a + real i * c\""], ["proof (prove)\nusing this:\n  ?i \\<in> UNIV \\<Longrightarrow> y \\<le> ereal (a + real ?i * c)\n\ngoal (1 subgoal):\n 1. \\<And>i. y \\<le> ereal (a + real i * c)", "by simp"], ["proof (state)\nthis:\n  y \\<le> ereal (a + real ?i * c)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       (\\<And>x.\n           x \\<in> UNIV \\<Longrightarrow>\n           y \\<le> ereal (a + real x * c)) \\<Longrightarrow>\n       y \\<le> - \\<infinity>", "show \"y \\<le> - \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> - \\<infinity>", "proof (subst ereal_infty_less_eq, rule ereal_bot)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B. y \\<le> ereal B", "fix B :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>B. y \\<le> ereal B", "obtain real_x where \"a + real_x * c \\<le> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>real_x.\n        a + real_x * c \\<le> B \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>c < 0\\<close>"], ["proof (prove)\nusing this:\n  c < 0\n\ngoal (1 subgoal):\n 1. (\\<And>real_x.\n        a + real_x * c \\<le> B \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim\n         (rule exI[where x=\"(- abs B -a)/c\"], auto simp: field_simps)"], ["proof (state)\nthis:\n  a + real_x * c \\<le> B\n\ngoal (1 subgoal):\n 1. \\<And>B. y \\<le> ereal B", "obtain x :: nat where \"a + x * c \\<le> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        a + real x * c \\<le> B \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (atomize_elim, intro exI[where x=\"nat(ceiling real_x)\"] conjI)"], ["proof (state)\ngoal (1 subgoal):\n 1. a + real (nat \\<lceil>real_x\\<rceil>) * c \\<le> B", "have \"real (nat(ceiling real_x)) * c \\<le> real_x * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (nat \\<lceil>real_x\\<rceil>) * c \\<le> real_x * c", "using \\<open>c < 0\\<close>"], ["proof (prove)\nusing this:\n  c < 0\n\ngoal (1 subgoal):\n 1. real (nat \\<lceil>real_x\\<rceil>) * c \\<le> real_x * c", "by (simp add: real_nat_ceiling_ge)"], ["proof (state)\nthis:\n  real (nat \\<lceil>real_x\\<rceil>) * c \\<le> real_x * c\n\ngoal (1 subgoal):\n 1. a + real (nat \\<lceil>real_x\\<rceil>) * c \\<le> B", "then"], ["proof (chain)\npicking this:\n  real (nat \\<lceil>real_x\\<rceil>) * c \\<le> real_x * c", "show \"a + nat(ceiling real_x) * c \\<le> B\""], ["proof (prove)\nusing this:\n  real (nat \\<lceil>real_x\\<rceil>) * c \\<le> real_x * c\n\ngoal (1 subgoal):\n 1. a + real (nat \\<lceil>real_x\\<rceil>) * c \\<le> B", "using \\<open>a + real_x * c \\<le> B\\<close>"], ["proof (prove)\nusing this:\n  real (nat \\<lceil>real_x\\<rceil>) * c \\<le> real_x * c\n  a + real_x * c \\<le> B\n\ngoal (1 subgoal):\n 1. a + real (nat \\<lceil>real_x\\<rceil>) * c \\<le> B", "by simp"], ["proof (state)\nthis:\n  a + real (nat \\<lceil>real_x\\<rceil>) * c \\<le> B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a + real x * c \\<le> B\n\ngoal (1 subgoal):\n 1. \\<And>B. y \\<le> ereal B", "then"], ["proof (chain)\npicking this:\n  a + real x * c \\<le> B", "show \"y \\<le> ereal B\""], ["proof (prove)\nusing this:\n  a + real x * c \\<le> B\n\ngoal (1 subgoal):\n 1. y \\<le> ereal B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a + real x * c \\<le> B \\<Longrightarrow> y \\<le> ereal B", "have \"ereal (a + x * c) \\<le> ereal B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (a + real x * c) \\<le> ereal B", "using \\<open>a + x * c \\<le> B\\<close>"], ["proof (prove)\nusing this:\n  a + real x * c \\<le> B\n\ngoal (1 subgoal):\n 1. ereal (a + real x * c) \\<le> ereal B", "by simp"], ["proof (state)\nthis:\n  ereal (a + real x * c) \\<le> ereal B\n\ngoal (1 subgoal):\n 1. a + real x * c \\<le> B \\<Longrightarrow> y \\<le> ereal B", "with l_assm"], ["proof (chain)\npicking this:\n  y \\<le> ereal (a + real ?i * c)\n  ereal (a + real x * c) \\<le> ereal B", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<le> ereal (a + real ?i * c)\n  ereal (a + real x * c) \\<le> ereal B\n\ngoal (1 subgoal):\n 1. y \\<le> ereal B", "by (rule order_trans)"], ["proof (state)\nthis:\n  y \\<le> ereal B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y \\<le> ereal B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y \\<le> - \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma neg_cycle_imp_inf_\\<mu>:\n  assumes walk_p: \"awalk u p v\"\n  assumes walk_c: \"awalk w c w\"\n  assumes w_in_p: \"w \\<in> set (awalk_verts u p)\"\n  assumes \"awalk_cost f c < 0\"\n  shows \"\\<mu> f u v = -\\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> f u v = - \\<infinity>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<mu> f u v = - \\<infinity>", "from w_in_p"], ["proof (chain)\npicking this:\n  w \\<in> set (awalk_verts u p)", "obtain xs ys where pv_decomp: \"awalk_verts u p = xs @ w # ys\""], ["proof (prove)\nusing this:\n  w \\<in> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        awalk_verts u p = xs @ w # ys \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_set_conv_decomp)"], ["proof (state)\nthis:\n  awalk_verts u p = xs @ w # ys\n\ngoal (1 subgoal):\n 1. \\<mu> f u v = - \\<infinity>", "define q r where \"q = take (length xs) p\" and \"r = drop (length xs) p\""], ["proof (state)\nthis:\n  q = take (length xs) p\n  r = drop (length xs) p\n\ngoal (1 subgoal):\n 1. \\<mu> f u v = - \\<infinity>", "define ext_p where \"ext_p n = q @ mk_cycles_path n c @ r\" for n"], ["proof (state)\nthis:\n  ext_p ?n = q @ mk_cycles_path ?n c @ r\n\ngoal (1 subgoal):\n 1. \\<mu> f u v = - \\<infinity>", "have ext_p_cost: \"\\<And>n. awalk_cost f (ext_p n)\n      = (awalk_cost f q + awalk_cost f r) + n * awalk_cost f c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       awalk_cost f (ext_p n) =\n       awalk_cost f q + awalk_cost f r + real n * awalk_cost f c", "using \\<open>awalk w c w\\<close>"], ["proof (prove)\nusing this:\n  awalk w c w\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       awalk_cost f (ext_p n) =\n       awalk_cost f q + awalk_cost f r + real n * awalk_cost f c", "by (auto simp: ext_p_def intro: mk_cycles_awalk_cost)"], ["proof (state)\nthis:\n  awalk_cost f (ext_p ?n) =\n  awalk_cost f q + awalk_cost f r + real ?n * awalk_cost f c\n\ngoal (1 subgoal):\n 1. \\<mu> f u v = - \\<infinity>", "from q_def r_def"], ["proof (chain)\npicking this:\n  q = take (length xs) p\n  r = drop (length xs) p", "have \"awlast u q = w\""], ["proof (prove)\nusing this:\n  q = take (length xs) p\n  r = drop (length xs) p\n\ngoal (1 subgoal):\n 1. awlast u q = w", "using pv_decomp walk_p"], ["proof (prove)\nusing this:\n  q = take (length xs) p\n  r = drop (length xs) p\n  awalk_verts u p = xs @ w # ys\n  awalk u p v\n\ngoal (1 subgoal):\n 1. awlast u q = w", "by (auto simp: awalk_verts_take_conv elim!: awalkE)"], ["proof (state)\nthis:\n  awlast u q = w\n\ngoal (1 subgoal):\n 1. \\<mu> f u v = - \\<infinity>", "moreover"], ["proof (state)\nthis:\n  awlast u q = w\n\ngoal (1 subgoal):\n 1. \\<mu> f u v = - \\<infinity>", "from q_def r_def"], ["proof (chain)\npicking this:\n  q = take (length xs) p\n  r = drop (length xs) p", "have \"awalk u (q @ r) v\""], ["proof (prove)\nusing this:\n  q = take (length xs) p\n  r = drop (length xs) p\n\ngoal (1 subgoal):\n 1. awalk u (q @ r) v", "using walk_p"], ["proof (prove)\nusing this:\n  q = take (length xs) p\n  r = drop (length xs) p\n  awalk u p v\n\ngoal (1 subgoal):\n 1. awalk u (q @ r) v", "by simp"], ["proof (state)\nthis:\n  awalk u (q @ r) v\n\ngoal (1 subgoal):\n 1. \\<mu> f u v = - \\<infinity>", "ultimately"], ["proof (chain)\npicking this:\n  awlast u q = w\n  awalk u (q @ r) v", "have \"awalk u q w\" \"awalk w r v\" \"\\<And>n. awalk w (mk_cycles_path n c) w\""], ["proof (prove)\nusing this:\n  awlast u q = w\n  awalk u (q @ r) v\n\ngoal (1 subgoal):\n 1. awalk u q w &&&\n    awalk w r v &&& (\\<And>n. awalk w (mk_cycles_path n c) w)", "using walk_c"], ["proof (prove)\nusing this:\n  awlast u q = w\n  awalk u (q @ r) v\n  awalk w c w\n\ngoal (1 subgoal):\n 1. awalk u q w &&&\n    awalk w r v &&& (\\<And>n. awalk w (mk_cycles_path n c) w)", "by (auto simp: intro: mk_cycles_path_awalk)"], ["proof (state)\nthis:\n  awalk u q w\n  awalk w r v\n  awalk w (mk_cycles_path ?n c) w\n\ngoal (1 subgoal):\n 1. \\<mu> f u v = - \\<infinity>", "then"], ["proof (chain)\npicking this:\n  awalk u q w\n  awalk w r v\n  awalk w (mk_cycles_path ?n c) w", "have \"\\<And>n. awalk u (ext_p n) v\""], ["proof (prove)\nusing this:\n  awalk u q w\n  awalk w r v\n  awalk w (mk_cycles_path ?n c) w\n\ngoal (1 subgoal):\n 1. \\<And>n. awalk u (ext_p n) v", "unfolding ext_p_def"], ["proof (prove)\nusing this:\n  awalk u q w\n  awalk w r v\n  awalk w (mk_cycles_path ?n c) w\n\ngoal (1 subgoal):\n 1. \\<And>n. awalk u (q @ mk_cycles_path n c @ r) v", "by (blast intro: awalk_appendI)"], ["proof (state)\nthis:\n  awalk u (ext_p ?n) v\n\ngoal (1 subgoal):\n 1. \\<mu> f u v = - \\<infinity>", "then"], ["proof (chain)\npicking this:\n  awalk u (ext_p ?n) v", "have \"{ext_p i|i. i \\<in> UNIV} \\<subseteq> {p. awalk u p v}\""], ["proof (prove)\nusing this:\n  awalk u (ext_p ?n) v\n\ngoal (1 subgoal):\n 1. {ext_p i |i. i \\<in> UNIV} \\<subseteq> {p. awalk u p v}", "by auto"], ["proof (state)\nthis:\n  {ext_p i |i. i \\<in> UNIV} \\<subseteq> {p. awalk u p v}\n\ngoal (1 subgoal):\n 1. \\<mu> f u v = - \\<infinity>", "then"], ["proof (chain)\npicking this:\n  {ext_p i |i. i \\<in> UNIV} \\<subseteq> {p. awalk u p v}", "have \"(INF p\\<in>{p. awalk u p v}. ereal (awalk_cost f p))\n      \\<le> (INF p\\<in> {ext_p i|i. i \\<in> UNIV}. ereal (awalk_cost f p))\""], ["proof (prove)\nusing this:\n  {ext_p i |i. i \\<in> UNIV} \\<subseteq> {p. awalk u p v}\n\ngoal (1 subgoal):\n 1. (INF p\\<in>{p. awalk u p v}. ereal (awalk_cost f p))\n    \\<le> (INF p\\<in>{ext_p i |i. i \\<in> UNIV}. ereal (awalk_cost f p))", "by (auto intro: INF_superset_mono)"], ["proof (state)\nthis:\n  (INF p\\<in>{p. awalk u p v}. ereal (awalk_cost f p))\n  \\<le> (INF p\\<in>{ext_p i |i. i \\<in> UNIV}. ereal (awalk_cost f p))\n\ngoal (1 subgoal):\n 1. \\<mu> f u v = - \\<infinity>", "also"], ["proof (state)\nthis:\n  (INF p\\<in>{p. awalk u p v}. ereal (awalk_cost f p))\n  \\<le> (INF p\\<in>{ext_p i |i. i \\<in> UNIV}. ereal (awalk_cost f p))\n\ngoal (1 subgoal):\n 1. \\<mu> f u v = - \\<infinity>", "have \"\\<dots> = (INF i\\<in> UNIV. ereal (awalk_cost f (ext_p i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (INF p\\<in>{ext_p i |i. i \\<in> UNIV}. ereal (awalk_cost f p)) =\n    (INF i. ereal (awalk_cost f (ext_p i)))", "by (rule arg_cong[where f=Inf], auto)"], ["proof (state)\nthis:\n  (INF p\\<in>{ext_p i |i. i \\<in> UNIV}. ereal (awalk_cost f p)) =\n  (INF i. ereal (awalk_cost f (ext_p i)))\n\ngoal (1 subgoal):\n 1. \\<mu> f u v = - \\<infinity>", "also"], ["proof (state)\nthis:\n  (INF p\\<in>{ext_p i |i. i \\<in> UNIV}. ereal (awalk_cost f p)) =\n  (INF i. ereal (awalk_cost f (ext_p i)))\n\ngoal (1 subgoal):\n 1. \\<mu> f u v = - \\<infinity>", "have \"\\<dots> = - \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (INF i. ereal (awalk_cost f (ext_p i))) = - \\<infinity>", "unfolding ext_p_cost"], ["proof (prove)\ngoal (1 subgoal):\n 1. (INF i.\n        ereal (awalk_cost f q + awalk_cost f r + real i * awalk_cost f c)) =\n    - \\<infinity>", "by (rule inf_over_nats[OF \\<open>awalk_cost f c < 0\\<close>])"], ["proof (state)\nthis:\n  (INF i. ereal (awalk_cost f (ext_p i))) = - \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<mu> f u v = - \\<infinity>", "finally"], ["proof (chain)\npicking this:\n  (INF p\\<in>{p. awalk u p v}. ereal (awalk_cost f p)) \\<le> - \\<infinity>", "show ?thesis"], ["proof (prove)\nusing this:\n  (INF p\\<in>{p. awalk u p v}. ereal (awalk_cost f p)) \\<le> - \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<mu> f u v = - \\<infinity>", "unfolding \\<mu>_def"], ["proof (prove)\nusing this:\n  (INF p\\<in>{p. awalk u p v}. ereal (awalk_cost f p)) \\<le> - \\<infinity>\n\ngoal (1 subgoal):\n 1. (INF p\\<in>{p. awalk u p v}. ereal (awalk_cost f p)) = - \\<infinity>", "by simp"], ["proof (state)\nthis:\n  \\<mu> f u v = - \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma walk_cheaper_path_imp_neg_cyc:\n  assumes p_props: \"awalk u p v\"\n  assumes less_path_\\<mu>: \"awalk_cost f p < (INF p\\<in> {p. apath u p v}. ereal (awalk_cost f p))\"\n  shows \"\\<exists>w c. awalk w c w \\<and> w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w c.\n       awalk w c w \\<and>\n       w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>w c.\n       awalk w c w \\<and>\n       w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0", "define path_\\<mu> where \"path_\\<mu> = (INF p\\<in> {p. apath u p v}. ereal (awalk_cost f p))\""], ["proof (state)\nthis:\n  path_\\<mu> = (INF p\\<in>{p. apath u p v}. ereal (awalk_cost f p))\n\ngoal (1 subgoal):\n 1. \\<exists>w c.\n       awalk w c w \\<and>\n       w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0", "then"], ["proof (chain)\npicking this:\n  path_\\<mu> = (INF p\\<in>{p. apath u p v}. ereal (awalk_cost f p))", "have \"awalk u p v\" and \"awalk_cost f p < path_\\<mu>\""], ["proof (prove)\nusing this:\n  path_\\<mu> = (INF p\\<in>{p. apath u p v}. ereal (awalk_cost f p))\n\ngoal (1 subgoal):\n 1. awalk u p v &&& ereal (awalk_cost f p) < path_\\<mu>", "using p_props less_path_\\<mu>"], ["proof (prove)\nusing this:\n  path_\\<mu> = (INF p\\<in>{p. apath u p v}. ereal (awalk_cost f p))\n  awalk u p v\n  ereal (awalk_cost f p)\n  < (INF p\\<in>{p. apath u p v}. ereal (awalk_cost f p))\n\ngoal (1 subgoal):\n 1. awalk u p v &&& ereal (awalk_cost f p) < path_\\<mu>", "by simp_all"], ["proof (state)\nthis:\n  awalk u p v\n  ereal (awalk_cost f p) < path_\\<mu>\n\ngoal (1 subgoal):\n 1. \\<exists>w c.\n       awalk w c w \\<and>\n       w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0", "then"], ["proof (chain)\npicking this:\n  awalk u p v\n  ereal (awalk_cost f p) < path_\\<mu>", "show ?thesis"], ["proof (prove)\nusing this:\n  awalk u p v\n  ereal (awalk_cost f p) < path_\\<mu>\n\ngoal (1 subgoal):\n 1. \\<exists>w c.\n       awalk w c w \\<and>\n       w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0", "proof (induct rule: awalk_to_apath_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>awalk u p v; distinct (awalk_verts u p);\n        ereal (awalk_cost f p) < path_\\<mu>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w c.\n                            awalk w c w \\<and>\n                            w \\<in> set (awalk_verts u p) \\<and>\n                            awalk_cost f c < 0\n 2. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        ereal (awalk_cost f (q @ s)) < path_\\<mu> \\<Longrightarrow>\n        \\<exists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u (q @ s)) \\<and> awalk_cost f c < 0;\n        ereal (awalk_cost f p) < path_\\<mu>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w c.\n                            awalk w c w \\<and>\n                            w \\<in> set (awalk_verts u p) \\<and>\n                            awalk_cost f c < 0", "case (path p)"], ["proof (state)\nthis:\n  awalk u p v\n  distinct (awalk_verts u p)\n  ereal (awalk_cost f p) < path_\\<mu>\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>awalk u p v; distinct (awalk_verts u p);\n        ereal (awalk_cost f p) < path_\\<mu>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w c.\n                            awalk w c w \\<and>\n                            w \\<in> set (awalk_verts u p) \\<and>\n                            awalk_cost f c < 0\n 2. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        ereal (awalk_cost f (q @ s)) < path_\\<mu> \\<Longrightarrow>\n        \\<exists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u (q @ s)) \\<and> awalk_cost f c < 0;\n        ereal (awalk_cost f p) < path_\\<mu>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w c.\n                            awalk w c w \\<and>\n                            w \\<in> set (awalk_verts u p) \\<and>\n                            awalk_cost f c < 0", "then"], ["proof (chain)\npicking this:\n  awalk u p v\n  distinct (awalk_verts u p)\n  ereal (awalk_cost f p) < path_\\<mu>", "have \"apath u p v\""], ["proof (prove)\nusing this:\n  awalk u p v\n  distinct (awalk_verts u p)\n  ereal (awalk_cost f p) < path_\\<mu>\n\ngoal (1 subgoal):\n 1. apath u p v", "by (auto simp: apath_def)"], ["proof (state)\nthis:\n  apath u p v\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>awalk u p v; distinct (awalk_verts u p);\n        ereal (awalk_cost f p) < path_\\<mu>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w c.\n                            awalk w c w \\<and>\n                            w \\<in> set (awalk_verts u p) \\<and>\n                            awalk_cost f c < 0\n 2. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        ereal (awalk_cost f (q @ s)) < path_\\<mu> \\<Longrightarrow>\n        \\<exists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u (q @ s)) \\<and> awalk_cost f c < 0;\n        ereal (awalk_cost f p) < path_\\<mu>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w c.\n                            awalk w c w \\<and>\n                            w \\<in> set (awalk_verts u p) \\<and>\n                            awalk_cost f c < 0", "then"], ["proof (chain)\npicking this:\n  apath u p v", "show ?case"], ["proof (prove)\nusing this:\n  apath u p v\n\ngoal (1 subgoal):\n 1. \\<exists>w c.\n       awalk w c w \\<and>\n       w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0", "using path.prems"], ["proof (prove)\nusing this:\n  apath u p v\n  ereal (awalk_cost f p) < path_\\<mu>\n\ngoal (1 subgoal):\n 1. \\<exists>w c.\n       awalk w c w \\<and>\n       w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0", "by (auto simp: path_\\<mu>_def dest: not_mem_less_INF)"], ["proof (state)\nthis:\n  \\<exists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\n\ngoal (1 subgoal):\n 1. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        ereal (awalk_cost f (q @ s)) < path_\\<mu> \\<Longrightarrow>\n        \\<exists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u (q @ s)) \\<and> awalk_cost f c < 0;\n        ereal (awalk_cost f p) < path_\\<mu>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w c.\n                            awalk w c w \\<and>\n                            w \\<in> set (awalk_verts u p) \\<and>\n                            awalk_cost f c < 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        ereal (awalk_cost f (q @ s)) < path_\\<mu> \\<Longrightarrow>\n        \\<exists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u (q @ s)) \\<and> awalk_cost f c < 0;\n        ereal (awalk_cost f p) < path_\\<mu>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w c.\n                            awalk w c w \\<and>\n                            w \\<in> set (awalk_verts u p) \\<and>\n                            awalk_cost f c < 0", "case (decomp p q r s)"], ["proof (state)\nthis:\n  awalk u p v\n  awalk_cyc_decomp p = (q, r, s)\n  \\<not> distinct (awalk_verts u p)\n  ereal (awalk_cost f (q @ s)) < path_\\<mu> \\<Longrightarrow>\n  \\<exists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u (q @ s)) \\<and> awalk_cost f c < 0\n  ereal (awalk_cost f p) < path_\\<mu>\n\ngoal (1 subgoal):\n 1. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        ereal (awalk_cost f (q @ s)) < path_\\<mu> \\<Longrightarrow>\n        \\<exists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u (q @ s)) \\<and> awalk_cost f c < 0;\n        ereal (awalk_cost f p) < path_\\<mu>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w c.\n                            awalk w c w \\<and>\n                            w \\<in> set (awalk_verts u p) \\<and>\n                            awalk_cost f c < 0", "then"], ["proof (chain)\npicking this:\n  awalk u p v\n  awalk_cyc_decomp p = (q, r, s)\n  \\<not> distinct (awalk_verts u p)\n  ereal (awalk_cost f (q @ s)) < path_\\<mu> \\<Longrightarrow>\n  \\<exists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u (q @ s)) \\<and> awalk_cost f c < 0\n  ereal (awalk_cost f p) < path_\\<mu>", "obtain w where p_props: \"p = q @ r @ s\" \"awalk u q w\" \"awalk w r w\" \"awalk w s v\""], ["proof (prove)\nusing this:\n  awalk u p v\n  awalk_cyc_decomp p = (q, r, s)\n  \\<not> distinct (awalk_verts u p)\n  ereal (awalk_cost f (q @ s)) < path_\\<mu> \\<Longrightarrow>\n  \\<exists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u (q @ s)) \\<and> awalk_cost f c < 0\n  ereal (awalk_cost f p) < path_\\<mu>\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>p = q @ r @ s; awalk u q w; awalk w r w;\n         awalk w s v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: awalk_cyc_decompE)"], ["proof (state)\nthis:\n  p = q @ r @ s\n  awalk u q w\n  awalk w r w\n  awalk w s v\n\ngoal (1 subgoal):\n 1. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        ereal (awalk_cost f (q @ s)) < path_\\<mu> \\<Longrightarrow>\n        \\<exists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u (q @ s)) \\<and> awalk_cost f c < 0;\n        ereal (awalk_cost f p) < path_\\<mu>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w c.\n                            awalk w c w \\<and>\n                            w \\<in> set (awalk_verts u p) \\<and>\n                            awalk_cost f c < 0", "then"], ["proof (chain)\npicking this:\n  p = q @ r @ s\n  awalk u q w\n  awalk w r w\n  awalk w s v", "have \"awalk u (q @ s) v\""], ["proof (prove)\nusing this:\n  p = q @ r @ s\n  awalk u q w\n  awalk w r w\n  awalk w s v\n\ngoal (1 subgoal):\n 1. awalk u (q @ s) v", "using \\<open>awalk u p v\\<close>"], ["proof (prove)\nusing this:\n  p = q @ r @ s\n  awalk u q w\n  awalk w r w\n  awalk w s v\n  awalk u p v\n\ngoal (1 subgoal):\n 1. awalk u (q @ s) v", "by (auto simp: awalk_appendI)"], ["proof (state)\nthis:\n  awalk u (q @ s) v\n\ngoal (1 subgoal):\n 1. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        ereal (awalk_cost f (q @ s)) < path_\\<mu> \\<Longrightarrow>\n        \\<exists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u (q @ s)) \\<and> awalk_cost f c < 0;\n        ereal (awalk_cost f p) < path_\\<mu>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w c.\n                            awalk w c w \\<and>\n                            w \\<in> set (awalk_verts u p) \\<and>\n                            awalk_cost f c < 0", "then"], ["proof (chain)\npicking this:\n  awalk u (q @ s) v", "have verts_ss: \"set (awalk_verts u (q @ s)) \\<subseteq> set (awalk_verts u p)\""], ["proof (prove)\nusing this:\n  awalk u (q @ s) v\n\ngoal (1 subgoal):\n 1. set (awalk_verts u (q @ s)) \\<subseteq> set (awalk_verts u p)", "using \\<open>awalk u p v\\<close> \\<open>p = q @ r @ s\\<close>"], ["proof (prove)\nusing this:\n  awalk u (q @ s) v\n  awalk u p v\n  p = q @ r @ s\n\ngoal (1 subgoal):\n 1. set (awalk_verts u (q @ s)) \\<subseteq> set (awalk_verts u p)", "by (auto simp: set_awalk_verts)"], ["proof (state)\nthis:\n  set (awalk_verts u (q @ s)) \\<subseteq> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        ereal (awalk_cost f (q @ s)) < path_\\<mu> \\<Longrightarrow>\n        \\<exists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u (q @ s)) \\<and> awalk_cost f c < 0;\n        ereal (awalk_cost f p) < path_\\<mu>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w c.\n                            awalk w c w \\<and>\n                            w \\<in> set (awalk_verts u p) \\<and>\n                            awalk_cost f c < 0", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w c.\n       awalk w c w \\<and>\n       w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0", "proof (cases \"ereal (awalk_cost f (q @ s)) < path_\\<mu>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ereal (awalk_cost f (q @ s)) < path_\\<mu> \\<Longrightarrow>\n    \\<exists>w c.\n       awalk w c w \\<and>\n       w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\n 2. \\<not> ereal (awalk_cost f (q @ s)) < path_\\<mu> \\<Longrightarrow>\n    \\<exists>w c.\n       awalk w c w \\<and>\n       w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0", "case True"], ["proof (state)\nthis:\n  ereal (awalk_cost f (q @ s)) < path_\\<mu>\n\ngoal (2 subgoals):\n 1. ereal (awalk_cost f (q @ s)) < path_\\<mu> \\<Longrightarrow>\n    \\<exists>w c.\n       awalk w c w \\<and>\n       w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\n 2. \\<not> ereal (awalk_cost f (q @ s)) < path_\\<mu> \\<Longrightarrow>\n    \\<exists>w c.\n       awalk w c w \\<and>\n       w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0", "then"], ["proof (chain)\npicking this:\n  ereal (awalk_cost f (q @ s)) < path_\\<mu>", "have \"\\<exists>w c. awalk w c w \\<and> w \\<in> set (awalk_verts u (q @ s)) \\<and> awalk_cost f c < 0\""], ["proof (prove)\nusing this:\n  ereal (awalk_cost f (q @ s)) < path_\\<mu>\n\ngoal (1 subgoal):\n 1. \\<exists>w c.\n       awalk w c w \\<and>\n       w \\<in> set (awalk_verts u (q @ s)) \\<and> awalk_cost f c < 0", "by (rule decomp)"], ["proof (state)\nthis:\n  \\<exists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u (q @ s)) \\<and> awalk_cost f c < 0\n\ngoal (2 subgoals):\n 1. ereal (awalk_cost f (q @ s)) < path_\\<mu> \\<Longrightarrow>\n    \\<exists>w c.\n       awalk w c w \\<and>\n       w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\n 2. \\<not> ereal (awalk_cost f (q @ s)) < path_\\<mu> \\<Longrightarrow>\n    \\<exists>w c.\n       awalk w c w \\<and>\n       w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u (q @ s)) \\<and> awalk_cost f c < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u (q @ s)) \\<and> awalk_cost f c < 0\n\ngoal (1 subgoal):\n 1. \\<exists>w c.\n       awalk w c w \\<and>\n       w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0", "using verts_ss"], ["proof (prove)\nusing this:\n  \\<exists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u (q @ s)) \\<and> awalk_cost f c < 0\n  set (awalk_verts u (q @ s)) \\<subseteq> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. \\<exists>w c.\n       awalk w c w \\<and>\n       w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\n\ngoal (1 subgoal):\n 1. \\<not> ereal (awalk_cost f (q @ s)) < path_\\<mu> \\<Longrightarrow>\n    \\<exists>w c.\n       awalk w c w \\<and>\n       w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ereal (awalk_cost f (q @ s)) < path_\\<mu> \\<Longrightarrow>\n    \\<exists>w c.\n       awalk w c w \\<and>\n       w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0", "case False"], ["proof (state)\nthis:\n  \\<not> ereal (awalk_cost f (q @ s)) < path_\\<mu>\n\ngoal (1 subgoal):\n 1. \\<not> ereal (awalk_cost f (q @ s)) < path_\\<mu> \\<Longrightarrow>\n    \\<exists>w c.\n       awalk w c w \\<and>\n       w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0", "note \\<open>awalk_cost f p < path_\\<mu>\\<close>"], ["proof (state)\nthis:\n  ereal (awalk_cost f p) < path_\\<mu>\n\ngoal (1 subgoal):\n 1. \\<not> ereal (awalk_cost f (q @ s)) < path_\\<mu> \\<Longrightarrow>\n    \\<exists>w c.\n       awalk w c w \\<and>\n       w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0", "also"], ["proof (state)\nthis:\n  ereal (awalk_cost f p) < path_\\<mu>\n\ngoal (1 subgoal):\n 1. \\<not> ereal (awalk_cost f (q @ s)) < path_\\<mu> \\<Longrightarrow>\n    \\<exists>w c.\n       awalk w c w \\<and>\n       w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0", "have \"path_\\<mu> \\<le> awalk_cost f (q @ s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_\\<mu> \\<le> ereal (awalk_cost f (q @ s))", "using False"], ["proof (prove)\nusing this:\n  \\<not> ereal (awalk_cost f (q @ s)) < path_\\<mu>\n\ngoal (1 subgoal):\n 1. path_\\<mu> \\<le> ereal (awalk_cost f (q @ s))", "by simp"], ["proof (state)\nthis:\n  path_\\<mu> \\<le> ereal (awalk_cost f (q @ s))\n\ngoal (1 subgoal):\n 1. \\<not> ereal (awalk_cost f (q @ s)) < path_\\<mu> \\<Longrightarrow>\n    \\<exists>w c.\n       awalk w c w \\<and>\n       w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0", "finally"], ["proof (chain)\npicking this:\n  ereal (awalk_cost f p) < ereal (awalk_cost f (q @ s))", "have \"awalk_cost f r < 0\""], ["proof (prove)\nusing this:\n  ereal (awalk_cost f p) < ereal (awalk_cost f (q @ s))\n\ngoal (1 subgoal):\n 1. awalk_cost f r < 0", "using \\<open>p = q @ r @ s\\<close>"], ["proof (prove)\nusing this:\n  ereal (awalk_cost f p) < ereal (awalk_cost f (q @ s))\n  p = q @ r @ s\n\ngoal (1 subgoal):\n 1. awalk_cost f r < 0", "by simp"], ["proof (state)\nthis:\n  awalk_cost f r < 0\n\ngoal (1 subgoal):\n 1. \\<not> ereal (awalk_cost f (q @ s)) < path_\\<mu> \\<Longrightarrow>\n    \\<exists>w c.\n       awalk w c w \\<and>\n       w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0", "moreover"], ["proof (state)\nthis:\n  awalk_cost f r < 0\n\ngoal (1 subgoal):\n 1. \\<not> ereal (awalk_cost f (q @ s)) < path_\\<mu> \\<Longrightarrow>\n    \\<exists>w c.\n       awalk w c w \\<and>\n       w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0", "have \"w \\<in> set (awalk_verts u q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> set (awalk_verts u q)", "using \\<open>awalk u q w\\<close>"], ["proof (prove)\nusing this:\n  awalk u q w\n\ngoal (1 subgoal):\n 1. w \\<in> set (awalk_verts u q)", "by auto"], ["proof (state)\nthis:\n  w \\<in> set (awalk_verts u q)\n\ngoal (1 subgoal):\n 1. \\<not> ereal (awalk_cost f (q @ s)) < path_\\<mu> \\<Longrightarrow>\n    \\<exists>w c.\n       awalk w c w \\<and>\n       w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0", "then"], ["proof (chain)\npicking this:\n  w \\<in> set (awalk_verts u q)", "have \"w \\<in> set (awalk_verts u p)\""], ["proof (prove)\nusing this:\n  w \\<in> set (awalk_verts u q)\n\ngoal (1 subgoal):\n 1. w \\<in> set (awalk_verts u p)", "using \\<open>awalk u p v\\<close> \\<open>awalk u q w\\<close> \\<open>p = q @ r @ s\\<close>"], ["proof (prove)\nusing this:\n  w \\<in> set (awalk_verts u q)\n  awalk u p v\n  awalk u q w\n  p = q @ r @ s\n\ngoal (1 subgoal):\n 1. w \\<in> set (awalk_verts u p)", "by (auto simp: set_awalk_verts)"], ["proof (state)\nthis:\n  w \\<in> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. \\<not> ereal (awalk_cost f (q @ s)) < path_\\<mu> \\<Longrightarrow>\n    \\<exists>w c.\n       awalk w c w \\<and>\n       w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0", "ultimately"], ["proof (chain)\npicking this:\n  awalk_cost f r < 0\n  w \\<in> set (awalk_verts u p)", "show ?thesis"], ["proof (prove)\nusing this:\n  awalk_cost f r < 0\n  w \\<in> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. \\<exists>w c.\n       awalk w c w \\<and>\n       w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0", "using \\<open>awalk w r w\\<close>"], ["proof (prove)\nusing this:\n  awalk_cost f r < 0\n  w \\<in> set (awalk_verts u p)\n  awalk w r w\n\ngoal (1 subgoal):\n 1. \\<exists>w c.\n       awalk w c w \\<and>\n       w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in fin_digraph) neg_inf_imp_neg_cyc:\n  assumes inf_mu: \"\\<mu> f u v = - \\<infinity>\"\n  shows \"\\<exists>p. awalk u p v \\<and> (\\<exists>w c. awalk w c w \\<and> w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       awalk u p v \\<and>\n       (\\<exists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p.\n       awalk u p v \\<and>\n       (\\<exists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0)", "define path_\\<mu> where \"path_\\<mu> = (INF s\\<in>{p. apath u p v}. ereal (awalk_cost f s))\""], ["proof (state)\nthis:\n  path_\\<mu> = (INF s\\<in>{p. apath u p v}. ereal (awalk_cost f s))\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       awalk u p v \\<and>\n       (\\<exists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0)", "have awalks_ne: \"{p. awalk u p v} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. awalk u p v} \\<noteq> {}", "using inf_mu"], ["proof (prove)\nusing this:\n  \\<mu> f u v = - \\<infinity>\n\ngoal (1 subgoal):\n 1. {p. awalk u p v} \\<noteq> {}", "unfolding \\<mu>_def"], ["proof (prove)\nusing this:\n  (INF p\\<in>{p. awalk u p v}. ereal (awalk_cost f p)) = - \\<infinity>\n\ngoal (1 subgoal):\n 1. {p. awalk u p v} \\<noteq> {}", "by safe (simp add: top_ereal_def)"], ["proof (state)\nthis:\n  {p. awalk u p v} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       awalk u p v \\<and>\n       (\\<exists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0)", "then"], ["proof (chain)\npicking this:\n  {p. awalk u p v} \\<noteq> {}", "have paths_ne: \"{p. apath u p v} ~= {}\""], ["proof (prove)\nusing this:\n  {p. awalk u p v} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {p. apath u p v} \\<noteq> {}", "by (auto intro: apath_awalk_to_apath)"], ["proof (state)\nthis:\n  {p. apath u p v} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       awalk u p v \\<and>\n       (\\<exists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0)", "obtain p where \"apath u p v\" \"awalk_cost f p = path_\\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>apath u p v; ereal (awalk_cost f p) = path_\\<mu>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>apath u p v; ereal (awalk_cost f p) = path_\\<mu>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain p where \"p \\<in> {p. apath u p v}\" \"awalk_cost f p = path_\\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in> {p. apath u p v};\n         ereal (awalk_cost f p) = path_\\<mu>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using finite_INF_in[OF apaths_finite paths_ne, of \"awalk_cost f\"]"], ["proof (prove)\nusing this:\n  (INF s\\<in>{p. apath u p v}. ereal (awalk_cost f s))\n  \\<in> (\\<lambda>x. ereal (awalk_cost f x)) ` {p. apath u p v}\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in> {p. apath u p v};\n         ereal (awalk_cost f p) = path_\\<mu>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: path_\\<mu>_def)"], ["proof (state)\nthis:\n  p \\<in> {p. apath u p v}\n  ereal (awalk_cost f p) = path_\\<mu>\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>apath u p v; ereal (awalk_cost f p) = path_\\<mu>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  p \\<in> {p. apath u p v}\n  ereal (awalk_cost f p) = path_\\<mu>", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<in> {p. apath u p v}\n  ereal (awalk_cost f p) = path_\\<mu>\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  p \\<in> {p. apath u p v}\n  ereal (awalk_cost f p) = path_\\<mu>\n  \\<lbrakk>apath u ?p v; ereal (awalk_cost f ?p) = path_\\<mu>\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  apath u p v\n  ereal (awalk_cost f p) = path_\\<mu>\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       awalk u p v \\<and>\n       (\\<exists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0)", "then"], ["proof (chain)\npicking this:\n  apath u p v\n  ereal (awalk_cost f p) = path_\\<mu>", "have \"path_\\<mu> \\<noteq> -\\<infinity>\""], ["proof (prove)\nusing this:\n  apath u p v\n  ereal (awalk_cost f p) = path_\\<mu>\n\ngoal (1 subgoal):\n 1. path_\\<mu> \\<noteq> - \\<infinity>", "by auto"], ["proof (state)\nthis:\n  path_\\<mu> \\<noteq> - \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       awalk u p v \\<and>\n       (\\<exists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0)", "then"], ["proof (chain)\npicking this:\n  path_\\<mu> \\<noteq> - \\<infinity>", "have \"\\<mu> f u v < path_\\<mu>\""], ["proof (prove)\nusing this:\n  path_\\<mu> \\<noteq> - \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<mu> f u v < path_\\<mu>", "using inf_mu"], ["proof (prove)\nusing this:\n  path_\\<mu> \\<noteq> - \\<infinity>\n  \\<mu> f u v = - \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<mu> f u v < path_\\<mu>", "by simp"], ["proof (state)\nthis:\n  \\<mu> f u v < path_\\<mu>\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       awalk u p v \\<and>\n       (\\<exists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0)", "then"], ["proof (chain)\npicking this:\n  \\<mu> f u v < path_\\<mu>", "obtain pw where p_def: \"awalk u pw v\" \"awalk_cost f pw < path_\\<mu>\""], ["proof (prove)\nusing this:\n  \\<mu> f u v < path_\\<mu>\n\ngoal (1 subgoal):\n 1. (\\<And>pw.\n        \\<lbrakk>awalk u pw v; ereal (awalk_cost f pw) < path_\\<mu>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim (auto simp: \\<mu>_def INF_less_iff)"], ["proof (state)\nthis:\n  awalk u pw v\n  ereal (awalk_cost f pw) < path_\\<mu>\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       awalk u p v \\<and>\n       (\\<exists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0)", "then"], ["proof (chain)\npicking this:\n  awalk u pw v\n  ereal (awalk_cost f pw) < path_\\<mu>", "have \"\\<exists>w c. awalk w c w \\<and> w \\<in> set (awalk_verts u pw) \\<and> awalk_cost f c < 0\""], ["proof (prove)\nusing this:\n  awalk u pw v\n  ereal (awalk_cost f pw) < path_\\<mu>\n\ngoal (1 subgoal):\n 1. \\<exists>w c.\n       awalk w c w \\<and>\n       w \\<in> set (awalk_verts u pw) \\<and> awalk_cost f c < 0", "by (intro walk_cheaper_path_imp_neg_cyc) (auto simp: path_\\<mu>_def)"], ["proof (state)\nthis:\n  \\<exists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u pw) \\<and> awalk_cost f c < 0\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       awalk u p v \\<and>\n       (\\<exists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0)", "with \\<open>awalk u pw v\\<close>"], ["proof (chain)\npicking this:\n  awalk u pw v\n  \\<exists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u pw) \\<and> awalk_cost f c < 0", "show ?thesis"], ["proof (prove)\nusing this:\n  awalk u pw v\n  \\<exists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u pw) \\<and> awalk_cost f c < 0\n\ngoal (1 subgoal):\n 1. \\<exists>p.\n       awalk u p v \\<and>\n       (\\<exists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0)", "by auto"], ["proof (state)\nthis:\n  \\<exists>p.\n     awalk u p v \\<and>\n     (\\<exists>w c.\n         awalk w c w \\<and>\n         w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in fin_digraph) no_neg_cyc_imp_no_neg_inf:\n  assumes no_neg_cyc: \"\\<And>p. awalk u p v\n    \\<Longrightarrow> \\<not>(\\<exists>w c. awalk w c w \\<and> w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0)\"\n  shows \"- \\<infinity> < \\<mu> f u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - \\<infinity> < \\<mu> f u v", "proof (intro ereal_MInfty_lessI notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<mu> f u v = - \\<infinity> \\<Longrightarrow> False", "assume \"\\<mu> f u v = - \\<infinity>\""], ["proof (state)\nthis:\n  \\<mu> f u v = - \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<mu> f u v = - \\<infinity> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<mu> f u v = - \\<infinity>", "obtain p where p_props: \"awalk u p v\"\n    and ex_cyc: \"\\<exists>w c. awalk w c w \\<and> w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\""], ["proof (prove)\nusing this:\n  \\<mu> f u v = - \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>awalk u p v;\n         \\<exists>w c.\n            awalk w c w \\<and>\n            w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim (rule neg_inf_imp_neg_cyc)"], ["proof (state)\nthis:\n  awalk u p v\n  \\<exists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\n\ngoal (1 subgoal):\n 1. \\<mu> f u v = - \\<infinity> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  awalk u p v\n  \\<exists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0", "show False"], ["proof (prove)\nusing this:\n  awalk u p v\n  \\<exists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\n\ngoal (1 subgoal):\n 1. False", "using no_neg_cyc"], ["proof (prove)\nusing this:\n  awalk u p v\n  \\<exists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\n  awalk u ?p v \\<Longrightarrow>\n  \\<nexists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u ?p) \\<and> awalk_cost f c < 0\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<mu>_reach_conv:\n  \"\\<mu> f u v < \\<infinity> \\<longleftrightarrow> u \\<rightarrow>\\<^sup>* v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<mu> f u v < \\<infinity>) = (u \\<rightarrow>\\<^sup>* v)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<mu> f u v < \\<infinity> \\<Longrightarrow> u \\<rightarrow>\\<^sup>* v\n 2. u \\<rightarrow>\\<^sup>* v \\<Longrightarrow> \\<mu> f u v < \\<infinity>", "assume \"\\<mu> f u v < \\<infinity>\""], ["proof (state)\nthis:\n  \\<mu> f u v < \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<mu> f u v < \\<infinity> \\<Longrightarrow> u \\<rightarrow>\\<^sup>* v\n 2. u \\<rightarrow>\\<^sup>* v \\<Longrightarrow> \\<mu> f u v < \\<infinity>", "then"], ["proof (chain)\npicking this:\n  \\<mu> f u v < \\<infinity>", "have \"{p. awalk u p v} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<mu> f u v < \\<infinity>\n\ngoal (1 subgoal):\n 1. {p. awalk u p v} \\<noteq> {}", "unfolding \\<mu>_def"], ["proof (prove)\nusing this:\n  (INF p\\<in>{p. awalk u p v}. ereal (awalk_cost f p)) < \\<infinity>\n\ngoal (1 subgoal):\n 1. {p. awalk u p v} \\<noteq> {}", "by safe (simp add: top_ereal_def)"], ["proof (state)\nthis:\n  {p. awalk u p v} \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<mu> f u v < \\<infinity> \\<Longrightarrow> u \\<rightarrow>\\<^sup>* v\n 2. u \\<rightarrow>\\<^sup>* v \\<Longrightarrow> \\<mu> f u v < \\<infinity>", "then"], ["proof (chain)\npicking this:\n  {p. awalk u p v} \\<noteq> {}", "show \"u \\<rightarrow>\\<^sup>* v\""], ["proof (prove)\nusing this:\n  {p. awalk u p v} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>* v", "by (simp add: reachable_awalk)"], ["proof (state)\nthis:\n  u \\<rightarrow>\\<^sup>* v\n\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>* v \\<Longrightarrow> \\<mu> f u v < \\<infinity>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>* v \\<Longrightarrow> \\<mu> f u v < \\<infinity>", "assume \"u \\<rightarrow>\\<^sup>* v\""], ["proof (state)\nthis:\n  u \\<rightarrow>\\<^sup>* v\n\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>* v \\<Longrightarrow> \\<mu> f u v < \\<infinity>", "then"], ["proof (chain)\npicking this:\n  u \\<rightarrow>\\<^sup>* v", "obtain p where p_props: \"apath u p v\""], ["proof (prove)\nusing this:\n  u \\<rightarrow>\\<^sup>* v\n\ngoal (1 subgoal):\n 1. (\\<And>p. apath u p v \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (metis reachable_awalk apath_awalk_to_apath)"], ["proof (state)\nthis:\n  apath u p v\n\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>* v \\<Longrightarrow> \\<mu> f u v < \\<infinity>", "then"], ["proof (chain)\npicking this:\n  apath u p v", "have \"{p} \\<subseteq> {p. apath u p v}\""], ["proof (prove)\nusing this:\n  apath u p v\n\ngoal (1 subgoal):\n 1. {p} \\<subseteq> {p. apath u p v}", "by simp"], ["proof (state)\nthis:\n  {p} \\<subseteq> {p. apath u p v}\n\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>* v \\<Longrightarrow> \\<mu> f u v < \\<infinity>", "then"], ["proof (chain)\npicking this:\n  {p} \\<subseteq> {p. apath u p v}", "have \"\\<mu> f u v \\<le> (INF p\\<in> {p}. ereal (awalk_cost f p))\""], ["proof (prove)\nusing this:\n  {p} \\<subseteq> {p. apath u p v}\n\ngoal (1 subgoal):\n 1. \\<mu> f u v \\<le> (INF p\\<in>{p}. ereal (awalk_cost f p))", "unfolding \\<mu>_def"], ["proof (prove)\nusing this:\n  {p} \\<subseteq> {p. apath u p v}\n\ngoal (1 subgoal):\n 1. (INF p\\<in>{p. awalk u p v}. ereal (awalk_cost f p))\n    \\<le> (INF p\\<in>{p}. ereal (awalk_cost f p))", "by (intro INF_superset_mono) (auto simp: apath_def)"], ["proof (state)\nthis:\n  \\<mu> f u v \\<le> (INF p\\<in>{p}. ereal (awalk_cost f p))\n\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>* v \\<Longrightarrow> \\<mu> f u v < \\<infinity>", "also"], ["proof (state)\nthis:\n  \\<mu> f u v \\<le> (INF p\\<in>{p}. ereal (awalk_cost f p))\n\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>* v \\<Longrightarrow> \\<mu> f u v < \\<infinity>", "have \"\\<dots> < \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (INF p\\<in>{p}. ereal (awalk_cost f p)) < \\<infinity>", "by (simp add: min_def)"], ["proof (state)\nthis:\n  (INF p\\<in>{p}. ereal (awalk_cost f p)) < \\<infinity>\n\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>* v \\<Longrightarrow> \\<mu> f u v < \\<infinity>", "finally"], ["proof (chain)\npicking this:\n  \\<mu> f u v < \\<infinity>", "show \"\\<mu> f u v < \\<infinity>\""], ["proof (prove)\nusing this:\n  \\<mu> f u v < \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<mu> f u v < \\<infinity>", "."], ["proof (state)\nthis:\n  \\<mu> f u v < \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma awalk_to_path_no_neg_cyc_cost:\n  assumes p_props:\"awalk u p v\"\n  assumes no_neg_cyc: \"\\<not> (\\<exists>w c. awalk w c w \\<and> w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0)\"\n  shows \"awalk_cost f (awalk_to_apath p) \\<le> awalk_cost f p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk_cost f (awalk_to_apath p) \\<le> awalk_cost f p", "using assms"], ["proof (prove)\nusing this:\n  awalk u p v\n  \\<nexists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\n\ngoal (1 subgoal):\n 1. awalk_cost f (awalk_to_apath p) \\<le> awalk_cost f p", "proof (induct rule: awalk_to_apath_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>awalk u p v; distinct (awalk_verts u p);\n        \\<nexists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\\<rbrakk>\n       \\<Longrightarrow> awalk_cost f (awalk_to_apath p)\n                         \\<le> awalk_cost f p\n 2. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        \\<nexists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u (q @ s)) \\<and>\n           awalk_cost f c < 0 \\<Longrightarrow>\n        awalk_cost f (awalk_to_apath (q @ s)) \\<le> awalk_cost f (q @ s);\n        \\<nexists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\\<rbrakk>\n       \\<Longrightarrow> awalk_cost f (awalk_to_apath p)\n                         \\<le> awalk_cost f p", "case path"], ["proof (state)\nthis:\n  awalk u p_ v\n  distinct (awalk_verts u p_)\n  \\<nexists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u p_) \\<and> awalk_cost f c < 0\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>awalk u p v; distinct (awalk_verts u p);\n        \\<nexists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\\<rbrakk>\n       \\<Longrightarrow> awalk_cost f (awalk_to_apath p)\n                         \\<le> awalk_cost f p\n 2. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        \\<nexists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u (q @ s)) \\<and>\n           awalk_cost f c < 0 \\<Longrightarrow>\n        awalk_cost f (awalk_to_apath (q @ s)) \\<le> awalk_cost f (q @ s);\n        \\<nexists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\\<rbrakk>\n       \\<Longrightarrow> awalk_cost f (awalk_to_apath p)\n                         \\<le> awalk_cost f p", "then"], ["proof (chain)\npicking this:\n  awalk u p_ v\n  distinct (awalk_verts u p_)\n  \\<nexists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u p_) \\<and> awalk_cost f c < 0", "show ?case"], ["proof (prove)\nusing this:\n  awalk u p_ v\n  distinct (awalk_verts u p_)\n  \\<nexists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u p_) \\<and> awalk_cost f c < 0\n\ngoal (1 subgoal):\n 1. awalk_cost f (awalk_to_apath p_) \\<le> awalk_cost f p_", "by (auto simp: awalk_to_apath.simps)"], ["proof (state)\nthis:\n  awalk_cost f (awalk_to_apath p_) \\<le> awalk_cost f p_\n\ngoal (1 subgoal):\n 1. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        \\<nexists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u (q @ s)) \\<and>\n           awalk_cost f c < 0 \\<Longrightarrow>\n        awalk_cost f (awalk_to_apath (q @ s)) \\<le> awalk_cost f (q @ s);\n        \\<nexists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\\<rbrakk>\n       \\<Longrightarrow> awalk_cost f (awalk_to_apath p)\n                         \\<le> awalk_cost f p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        \\<nexists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u (q @ s)) \\<and>\n           awalk_cost f c < 0 \\<Longrightarrow>\n        awalk_cost f (awalk_to_apath (q @ s)) \\<le> awalk_cost f (q @ s);\n        \\<nexists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\\<rbrakk>\n       \\<Longrightarrow> awalk_cost f (awalk_to_apath p)\n                         \\<le> awalk_cost f p", "case (decomp p q r s)"], ["proof (state)\nthis:\n  awalk u p v\n  awalk_cyc_decomp p = (q, r, s)\n  \\<not> distinct (awalk_verts u p)\n  \\<nexists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u (q @ s)) \\<and>\n     awalk_cost f c < 0 \\<Longrightarrow>\n  awalk_cost f (awalk_to_apath (q @ s)) \\<le> awalk_cost f (q @ s)\n  \\<nexists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\n\ngoal (1 subgoal):\n 1. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        \\<nexists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u (q @ s)) \\<and>\n           awalk_cost f c < 0 \\<Longrightarrow>\n        awalk_cost f (awalk_to_apath (q @ s)) \\<le> awalk_cost f (q @ s);\n        \\<nexists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\\<rbrakk>\n       \\<Longrightarrow> awalk_cost f (awalk_to_apath p)\n                         \\<le> awalk_cost f p", "from decomp(2,3)"], ["proof (chain)\npicking this:\n  awalk_cyc_decomp p = (q, r, s)\n  \\<not> distinct (awalk_verts u p)", "have \"is_awalk_cyc_decomp p (q,r,s)\""], ["proof (prove)\nusing this:\n  awalk_cyc_decomp p = (q, r, s)\n  \\<not> distinct (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. is_awalk_cyc_decomp p (q, r, s)", "using awalk_cyc_decomp_has_prop[OF decomp(1)]"], ["proof (prove)\nusing this:\n  awalk_cyc_decomp p = (q, r, s)\n  \\<not> distinct (awalk_verts u p)\n  \\<not> distinct (awalk_verts u p) \\<Longrightarrow>\n  is_awalk_cyc_decomp p (awalk_cyc_decomp p)\n\ngoal (1 subgoal):\n 1. is_awalk_cyc_decomp p (q, r, s)", "by auto"], ["proof (state)\nthis:\n  is_awalk_cyc_decomp p (q, r, s)\n\ngoal (1 subgoal):\n 1. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        \\<nexists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u (q @ s)) \\<and>\n           awalk_cost f c < 0 \\<Longrightarrow>\n        awalk_cost f (awalk_to_apath (q @ s)) \\<le> awalk_cost f (q @ s);\n        \\<nexists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\\<rbrakk>\n       \\<Longrightarrow> awalk_cost f (awalk_to_apath p)\n                         \\<le> awalk_cost f p", "then"], ["proof (chain)\npicking this:\n  is_awalk_cyc_decomp p (q, r, s)", "have decomp_props: \"p = q @ r @ s\" \"\\<exists>w. awalk w r w\""], ["proof (prove)\nusing this:\n  is_awalk_cyc_decomp p (q, r, s)\n\ngoal (1 subgoal):\n 1. p = q @ r @ s &&& \\<exists>w. awalk w r w", "by auto"], ["proof (state)\nthis:\n  p = q @ r @ s\n  \\<exists>w. awalk w r w\n\ngoal (1 subgoal):\n 1. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        \\<nexists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u (q @ s)) \\<and>\n           awalk_cost f c < 0 \\<Longrightarrow>\n        awalk_cost f (awalk_to_apath (q @ s)) \\<le> awalk_cost f (q @ s);\n        \\<nexists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\\<rbrakk>\n       \\<Longrightarrow> awalk_cost f (awalk_to_apath p)\n                         \\<le> awalk_cost f p", "have \"awalk_cost f (awalk_to_apath p) = awalk_cost f (awalk_to_apath (q @ s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk_cost f (awalk_to_apath p) = awalk_cost f (awalk_to_apath (q @ s))", "using decomp"], ["proof (prove)\nusing this:\n  awalk u p v\n  awalk_cyc_decomp p = (q, r, s)\n  \\<not> distinct (awalk_verts u p)\n  \\<nexists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u (q @ s)) \\<and>\n     awalk_cost f c < 0 \\<Longrightarrow>\n  awalk_cost f (awalk_to_apath (q @ s)) \\<le> awalk_cost f (q @ s)\n  \\<nexists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\n\ngoal (1 subgoal):\n 1. awalk_cost f (awalk_to_apath p) = awalk_cost f (awalk_to_apath (q @ s))", "by (auto simp: step_awalk_to_apath[of _ p _ q r s])"], ["proof (state)\nthis:\n  awalk_cost f (awalk_to_apath p) = awalk_cost f (awalk_to_apath (q @ s))\n\ngoal (1 subgoal):\n 1. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        \\<nexists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u (q @ s)) \\<and>\n           awalk_cost f c < 0 \\<Longrightarrow>\n        awalk_cost f (awalk_to_apath (q @ s)) \\<le> awalk_cost f (q @ s);\n        \\<nexists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\\<rbrakk>\n       \\<Longrightarrow> awalk_cost f (awalk_to_apath p)\n                         \\<le> awalk_cost f p", "also"], ["proof (state)\nthis:\n  awalk_cost f (awalk_to_apath p) = awalk_cost f (awalk_to_apath (q @ s))\n\ngoal (1 subgoal):\n 1. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        \\<nexists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u (q @ s)) \\<and>\n           awalk_cost f c < 0 \\<Longrightarrow>\n        awalk_cost f (awalk_to_apath (q @ s)) \\<le> awalk_cost f (q @ s);\n        \\<nexists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\\<rbrakk>\n       \\<Longrightarrow> awalk_cost f (awalk_to_apath p)\n                         \\<le> awalk_cost f p", "have \"\\<dots> \\<le> awalk_cost f (q @ s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk_cost f (awalk_to_apath (q @ s)) \\<le> awalk_cost f (q @ s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. awalk_cost f (awalk_to_apath (q @ s)) \\<le> awalk_cost f (q @ s)", "have \"awalk u (q @ s) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk u (q @ s) v", "using \\<open>awalk u p v\\<close> decomp_props"], ["proof (prove)\nusing this:\n  awalk u p v\n  p = q @ r @ s\n  \\<exists>w. awalk w r w\n\ngoal (1 subgoal):\n 1. awalk u (q @ s) v", "by (auto dest!: awalk_ends_eqD)"], ["proof (state)\nthis:\n  awalk u (q @ s) v\n\ngoal (1 subgoal):\n 1. awalk_cost f (awalk_to_apath (q @ s)) \\<le> awalk_cost f (q @ s)", "then"], ["proof (chain)\npicking this:\n  awalk u (q @ s) v", "have \"set (awalk_verts u (q @ s)) \\<subseteq> set (awalk_verts u p)\""], ["proof (prove)\nusing this:\n  awalk u (q @ s) v\n\ngoal (1 subgoal):\n 1. set (awalk_verts u (q @ s)) \\<subseteq> set (awalk_verts u p)", "using \\<open>awalk u p v\\<close> \\<open>p = q @ r @ s\\<close>"], ["proof (prove)\nusing this:\n  awalk u (q @ s) v\n  awalk u p v\n  p = q @ r @ s\n\ngoal (1 subgoal):\n 1. set (awalk_verts u (q @ s)) \\<subseteq> set (awalk_verts u p)", "by (auto simp add: set_awalk_verts)"], ["proof (state)\nthis:\n  set (awalk_verts u (q @ s)) \\<subseteq> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. awalk_cost f (awalk_to_apath (q @ s)) \\<le> awalk_cost f (q @ s)", "then"], ["proof (chain)\npicking this:\n  set (awalk_verts u (q @ s)) \\<subseteq> set (awalk_verts u p)", "show ?thesis"], ["proof (prove)\nusing this:\n  set (awalk_verts u (q @ s)) \\<subseteq> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. awalk_cost f (awalk_to_apath (q @ s)) \\<le> awalk_cost f (q @ s)", "using decomp.prems"], ["proof (prove)\nusing this:\n  set (awalk_verts u (q @ s)) \\<subseteq> set (awalk_verts u p)\n  \\<nexists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\n\ngoal (1 subgoal):\n 1. awalk_cost f (awalk_to_apath (q @ s)) \\<le> awalk_cost f (q @ s)", "by (intro decomp.hyps) auto"], ["proof (state)\nthis:\n  awalk_cost f (awalk_to_apath (q @ s)) \\<le> awalk_cost f (q @ s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  awalk_cost f (awalk_to_apath (q @ s)) \\<le> awalk_cost f (q @ s)\n\ngoal (1 subgoal):\n 1. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        \\<nexists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u (q @ s)) \\<and>\n           awalk_cost f c < 0 \\<Longrightarrow>\n        awalk_cost f (awalk_to_apath (q @ s)) \\<le> awalk_cost f (q @ s);\n        \\<nexists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\\<rbrakk>\n       \\<Longrightarrow> awalk_cost f (awalk_to_apath p)\n                         \\<le> awalk_cost f p", "also"], ["proof (state)\nthis:\n  awalk_cost f (awalk_to_apath (q @ s)) \\<le> awalk_cost f (q @ s)\n\ngoal (1 subgoal):\n 1. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        \\<nexists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u (q @ s)) \\<and>\n           awalk_cost f c < 0 \\<Longrightarrow>\n        awalk_cost f (awalk_to_apath (q @ s)) \\<le> awalk_cost f (q @ s);\n        \\<nexists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\\<rbrakk>\n       \\<Longrightarrow> awalk_cost f (awalk_to_apath p)\n                         \\<le> awalk_cost f p", "have \"\\<dots> \\<le> awalk_cost f p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk_cost f (q @ s) \\<le> awalk_cost f p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. awalk_cost f (q @ s) \\<le> awalk_cost f p", "obtain w where \"awalk u q w\" \"awalk w r w\" \"awalk w s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>awalk u q w; awalk w r w; awalk w s v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using decomp"], ["proof (prove)\nusing this:\n  awalk u p v\n  awalk_cyc_decomp p = (q, r, s)\n  \\<not> distinct (awalk_verts u p)\n  \\<nexists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u (q @ s)) \\<and>\n     awalk_cost f c < 0 \\<Longrightarrow>\n  awalk_cost f (awalk_to_apath (q @ s)) \\<le> awalk_cost f (q @ s)\n  \\<nexists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>awalk u q w; awalk w r w; awalk w s v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: awalk_cyc_decompE)"], ["proof (state)\nthis:\n  awalk u q w\n  awalk w r w\n  awalk w s v\n\ngoal (1 subgoal):\n 1. awalk_cost f (q @ s) \\<le> awalk_cost f p", "then"], ["proof (chain)\npicking this:\n  awalk u q w\n  awalk w r w\n  awalk w s v", "have \"w \\<in> set (awalk_verts u q)\""], ["proof (prove)\nusing this:\n  awalk u q w\n  awalk w r w\n  awalk w s v\n\ngoal (1 subgoal):\n 1. w \\<in> set (awalk_verts u q)", "by auto"], ["proof (state)\nthis:\n  w \\<in> set (awalk_verts u q)\n\ngoal (1 subgoal):\n 1. awalk_cost f (q @ s) \\<le> awalk_cost f p", "then"], ["proof (chain)\npicking this:\n  w \\<in> set (awalk_verts u q)", "have \"w \\<in> set (awalk_verts u p)\""], ["proof (prove)\nusing this:\n  w \\<in> set (awalk_verts u q)\n\ngoal (1 subgoal):\n 1. w \\<in> set (awalk_verts u p)", "using \\<open>p = q @ r @ s\\<close> \\<open>awalk u p v\\<close> \\<open>awalk u q w\\<close>"], ["proof (prove)\nusing this:\n  w \\<in> set (awalk_verts u q)\n  p = q @ r @ s\n  awalk u p v\n  awalk u q w\n\ngoal (1 subgoal):\n 1. w \\<in> set (awalk_verts u p)", "by (auto simp add: set_awalk_verts)"], ["proof (state)\nthis:\n  w \\<in> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. awalk_cost f (q @ s) \\<le> awalk_cost f p", "then"], ["proof (chain)\npicking this:\n  w \\<in> set (awalk_verts u p)", "have \"0 \\<le> awalk_cost f r\""], ["proof (prove)\nusing this:\n  w \\<in> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. 0 \\<le> awalk_cost f r", "using \\<open>awalk w r w\\<close>"], ["proof (prove)\nusing this:\n  w \\<in> set (awalk_verts u p)\n  awalk w r w\n\ngoal (1 subgoal):\n 1. 0 \\<le> awalk_cost f r", "using decomp.prems"], ["proof (prove)\nusing this:\n  w \\<in> set (awalk_verts u p)\n  awalk w r w\n  \\<nexists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> awalk_cost f r", "by (auto simp: not_less)"], ["proof (state)\nthis:\n  0 \\<le> awalk_cost f r\n\ngoal (1 subgoal):\n 1. awalk_cost f (q @ s) \\<le> awalk_cost f p", "then"], ["proof (chain)\npicking this:\n  0 \\<le> awalk_cost f r", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> awalk_cost f r\n\ngoal (1 subgoal):\n 1. awalk_cost f (q @ s) \\<le> awalk_cost f p", "using \\<open>p = q @ r @ s\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> awalk_cost f r\n  p = q @ r @ s\n\ngoal (1 subgoal):\n 1. awalk_cost f (q @ s) \\<le> awalk_cost f p", "by simp"], ["proof (state)\nthis:\n  awalk_cost f (q @ s) \\<le> awalk_cost f p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  awalk_cost f (q @ s) \\<le> awalk_cost f p\n\ngoal (1 subgoal):\n 1. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        \\<nexists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u (q @ s)) \\<and>\n           awalk_cost f c < 0 \\<Longrightarrow>\n        awalk_cost f (awalk_to_apath (q @ s)) \\<le> awalk_cost f (q @ s);\n        \\<nexists>w c.\n           awalk w c w \\<and>\n           w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0\\<rbrakk>\n       \\<Longrightarrow> awalk_cost f (awalk_to_apath p)\n                         \\<le> awalk_cost f p", "finally"], ["proof (chain)\npicking this:\n  awalk_cost f (awalk_to_apath p) \\<le> awalk_cost f p", "show ?case"], ["proof (prove)\nusing this:\n  awalk_cost f (awalk_to_apath p) \\<le> awalk_cost f p\n\ngoal (1 subgoal):\n 1. awalk_cost f (awalk_to_apath p) \\<le> awalk_cost f p", "."], ["proof (state)\nthis:\n  awalk_cost f (awalk_to_apath p) \\<le> awalk_cost f p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in fin_digraph) no_neg_cyc_reach_imp_path:\n  assumes reach: \"u \\<rightarrow>\\<^sup>* v\"\n  assumes no_neg_cyc: \"\\<And>p. awalk u p v\n    \\<Longrightarrow> \\<not>(\\<exists>w c. awalk w c w \\<and> w \\<in> set (awalk_verts u p) \\<and> awalk_cost f c < 0)\"\n  shows \"\\<exists>p. apath u p v \\<and> \\<mu> f u v = awalk_cost f p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. apath u p v \\<and> \\<mu> f u v = ereal (awalk_cost f p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. apath u p v \\<and> \\<mu> f u v = ereal (awalk_cost f p)", "define set_walks where \"set_walks = {p. awalk u p v}\""], ["proof (state)\nthis:\n  set_walks = {p. awalk u p v}\n\ngoal (1 subgoal):\n 1. \\<exists>p. apath u p v \\<and> \\<mu> f u v = ereal (awalk_cost f p)", "define set_paths where \"set_paths = {p. apath u p v}\""], ["proof (state)\nthis:\n  set_paths = {p. apath u p v}\n\ngoal (1 subgoal):\n 1. \\<exists>p. apath u p v \\<and> \\<mu> f u v = ereal (awalk_cost f p)", "have \"set_paths \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_paths \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_paths \\<noteq> {}", "obtain p where \"apath u p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p. apath u p v \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using reach"], ["proof (prove)\nusing this:\n  u \\<rightarrow>\\<^sup>* v\n\ngoal (1 subgoal):\n 1. (\\<And>p. apath u p v \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (metis apath_awalk_to_apath reachable_awalk)"], ["proof (state)\nthis:\n  apath u p v\n\ngoal (1 subgoal):\n 1. set_paths \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  apath u p v", "show ?thesis"], ["proof (prove)\nusing this:\n  apath u p v\n\ngoal (1 subgoal):\n 1. set_paths \\<noteq> {}", "unfolding set_paths_def"], ["proof (prove)\nusing this:\n  apath u p v\n\ngoal (1 subgoal):\n 1. {p. apath u p v} \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  set_paths \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set_paths \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>p. apath u p v \\<and> \\<mu> f u v = ereal (awalk_cost f p)", "have \"\\<mu> f u v = (INF p\\<in> set_walks. ereal (awalk_cost f p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> f u v = (INF p\\<in>set_walks. ereal (awalk_cost f p))", "unfolding \\<mu>_def set_walks_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (INF p\\<in>{p. awalk u p v}. ereal (awalk_cost f p)) =\n    (INF p\\<in>{p. awalk u p v}. ereal (awalk_cost f p))", "by simp"], ["proof (state)\nthis:\n  \\<mu> f u v = (INF p\\<in>set_walks. ereal (awalk_cost f p))\n\ngoal (1 subgoal):\n 1. \\<exists>p. apath u p v \\<and> \\<mu> f u v = ereal (awalk_cost f p)", "also"], ["proof (state)\nthis:\n  \\<mu> f u v = (INF p\\<in>set_walks. ereal (awalk_cost f p))\n\ngoal (1 subgoal):\n 1. \\<exists>p. apath u p v \\<and> \\<mu> f u v = ereal (awalk_cost f p)", "have \"\\<dots> = (INF p\\<in> set_paths. ereal (awalk_cost f p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (INF p\\<in>set_walks. ereal (awalk_cost f p)) =\n    (INF p\\<in>set_paths. ereal (awalk_cost f p))", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. (INF p\\<in>set_walks. ereal (awalk_cost f p))\n    \\<le> (INF p\\<in>set_paths. ereal (awalk_cost f p))\n 2. (INF p\\<in>set_paths. ereal (awalk_cost f p))\n    \\<le> (INF p\\<in>set_walks. ereal (awalk_cost f p))", "have \"awalk_to_apath ` set_walks \\<subseteq> set_paths\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk_to_apath ` set_walks \\<subseteq> set_paths", "unfolding set_walks_def set_paths_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk_to_apath ` {p. awalk u p v} \\<subseteq> {p. apath u p v}", "by (intro subsetI) (auto elim: apath_awalk_to_apath)"], ["proof (state)\nthis:\n  awalk_to_apath ` set_walks \\<subseteq> set_paths\n\ngoal (2 subgoals):\n 1. (INF p\\<in>set_walks. ereal (awalk_cost f p))\n    \\<le> (INF p\\<in>set_paths. ereal (awalk_cost f p))\n 2. (INF p\\<in>set_paths. ereal (awalk_cost f p))\n    \\<le> (INF p\\<in>set_walks. ereal (awalk_cost f p))", "then"], ["proof (chain)\npicking this:\n  awalk_to_apath ` set_walks \\<subseteq> set_paths", "have \"(INF p\\<in> set_paths. ereal (awalk_cost f p))\n      \\<le> (INF p\\<in> awalk_to_apath ` set_walks. ereal (awalk_cost f p))\""], ["proof (prove)\nusing this:\n  awalk_to_apath ` set_walks \\<subseteq> set_paths\n\ngoal (1 subgoal):\n 1. (INF p\\<in>set_paths. ereal (awalk_cost f p))\n    \\<le> (INF p\\<in>awalk_to_apath ` set_walks. ereal (awalk_cost f p))", "by (rule INF_superset_mono) simp"], ["proof (state)\nthis:\n  (INF p\\<in>set_paths. ereal (awalk_cost f p))\n  \\<le> (INF p\\<in>awalk_to_apath ` set_walks. ereal (awalk_cost f p))\n\ngoal (2 subgoals):\n 1. (INF p\\<in>set_walks. ereal (awalk_cost f p))\n    \\<le> (INF p\\<in>set_paths. ereal (awalk_cost f p))\n 2. (INF p\\<in>set_paths. ereal (awalk_cost f p))\n    \\<le> (INF p\\<in>set_walks. ereal (awalk_cost f p))", "also"], ["proof (state)\nthis:\n  (INF p\\<in>set_paths. ereal (awalk_cost f p))\n  \\<le> (INF p\\<in>awalk_to_apath ` set_walks. ereal (awalk_cost f p))\n\ngoal (2 subgoals):\n 1. (INF p\\<in>set_walks. ereal (awalk_cost f p))\n    \\<le> (INF p\\<in>set_paths. ereal (awalk_cost f p))\n 2. (INF p\\<in>set_paths. ereal (awalk_cost f p))\n    \\<le> (INF p\\<in>set_walks. ereal (awalk_cost f p))", "have \"\\<dots> = (INF p\\<in> set_walks. ereal (awalk_cost f (awalk_to_apath p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (INF p\\<in>awalk_to_apath ` set_walks. ereal (awalk_cost f p)) =\n    (INF p\\<in>set_walks. ereal (awalk_cost f (awalk_to_apath p)))", "by (simp add: image_comp)"], ["proof (state)\nthis:\n  (INF p\\<in>awalk_to_apath ` set_walks. ereal (awalk_cost f p)) =\n  (INF p\\<in>set_walks. ereal (awalk_cost f (awalk_to_apath p)))\n\ngoal (2 subgoals):\n 1. (INF p\\<in>set_walks. ereal (awalk_cost f p))\n    \\<le> (INF p\\<in>set_paths. ereal (awalk_cost f p))\n 2. (INF p\\<in>set_paths. ereal (awalk_cost f p))\n    \\<le> (INF p\\<in>set_walks. ereal (awalk_cost f p))", "also"], ["proof (state)\nthis:\n  (INF p\\<in>awalk_to_apath ` set_walks. ereal (awalk_cost f p)) =\n  (INF p\\<in>set_walks. ereal (awalk_cost f (awalk_to_apath p)))\n\ngoal (2 subgoals):\n 1. (INF p\\<in>set_walks. ereal (awalk_cost f p))\n    \\<le> (INF p\\<in>set_paths. ereal (awalk_cost f p))\n 2. (INF p\\<in>set_paths. ereal (awalk_cost f p))\n    \\<le> (INF p\\<in>set_walks. ereal (awalk_cost f p))", "have \"\\<dots> \\<le> (INF p\\<in> set_walks. ereal (awalk_cost f p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (INF p\\<in>set_walks. ereal (awalk_cost f (awalk_to_apath p)))\n    \\<le> (INF p\\<in>set_walks. ereal (awalk_cost f p))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (INF p\\<in>set_walks. ereal (awalk_cost f (awalk_to_apath p)))\n    \\<le> (INF p\\<in>set_walks. ereal (awalk_cost f p))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (INF p\\<in>set_walks. ereal (awalk_cost f (awalk_to_apath p)))\n    \\<le> (INF p\\<in>set_walks. ereal (awalk_cost f p))", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. (INF p\\<in>set_walks. ereal (awalk_cost f (awalk_to_apath p)))\n    \\<le> (INF p\\<in>set_walks. ereal (awalk_cost f p))", "assume \"p \\<in> set_walks\""], ["proof (state)\nthis:\n  p \\<in> set_walks\n\ngoal (1 subgoal):\n 1. (INF p\\<in>set_walks. ereal (awalk_cost f (awalk_to_apath p)))\n    \\<le> (INF p\\<in>set_walks. ereal (awalk_cost f p))", "then"], ["proof (chain)\npicking this:\n  p \\<in> set_walks", "have \"awalk u p v\""], ["proof (prove)\nusing this:\n  p \\<in> set_walks\n\ngoal (1 subgoal):\n 1. awalk u p v", "by (auto simp: set_walks_def)"], ["proof (state)\nthis:\n  awalk u p v\n\ngoal (1 subgoal):\n 1. (INF p\\<in>set_walks. ereal (awalk_cost f (awalk_to_apath p)))\n    \\<le> (INF p\\<in>set_walks. ereal (awalk_cost f p))", "then"], ["proof (chain)\npicking this:\n  awalk u p v", "have \"awalk_cost f (awalk_to_apath p) \\<le> awalk_cost f p\""], ["proof (prove)\nusing this:\n  awalk u p v\n\ngoal (1 subgoal):\n 1. awalk_cost f (awalk_to_apath p) \\<le> awalk_cost f p", "using no_neg_cyc"], ["proof (prove)\nusing this:\n  awalk u p v\n  awalk u ?p v \\<Longrightarrow>\n  \\<nexists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u ?p) \\<and> awalk_cost f c < 0\n\ngoal (1 subgoal):\n 1. awalk_cost f (awalk_to_apath p) \\<le> awalk_cost f p", "using no_neg_cyc and awalk_to_path_no_neg_cyc_cost"], ["proof (prove)\nusing this:\n  awalk u p v\n  awalk u ?p v \\<Longrightarrow>\n  \\<nexists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u ?p) \\<and> awalk_cost f c < 0\n  awalk u ?p v \\<Longrightarrow>\n  \\<nexists>w c.\n     awalk w c w \\<and>\n     w \\<in> set (awalk_verts u ?p) \\<and> awalk_cost f c < 0\n  \\<lbrakk>awalk ?u ?p ?v;\n   \\<nexists>w c.\n      awalk w c w \\<and>\n      w \\<in> set (awalk_verts ?u ?p) \\<and> awalk_cost ?f c < 0\\<rbrakk>\n  \\<Longrightarrow> awalk_cost ?f (awalk_to_apath ?p) \\<le> awalk_cost ?f ?p\n\ngoal (1 subgoal):\n 1. awalk_cost f (awalk_to_apath p) \\<le> awalk_cost f p", "by auto"], ["proof (state)\nthis:\n  awalk_cost f (awalk_to_apath p) \\<le> awalk_cost f p\n\ngoal (1 subgoal):\n 1. (INF p\\<in>set_walks. ereal (awalk_cost f (awalk_to_apath p)))\n    \\<le> (INF p\\<in>set_walks. ereal (awalk_cost f p))", "}"], ["proof (state)\nthis:\n  ?p2 \\<in> set_walks \\<Longrightarrow>\n  awalk_cost f (awalk_to_apath ?p2) \\<le> awalk_cost f ?p2\n\ngoal (1 subgoal):\n 1. (INF p\\<in>set_walks. ereal (awalk_cost f (awalk_to_apath p)))\n    \\<le> (INF p\\<in>set_walks. ereal (awalk_cost f p))", "then"], ["proof (chain)\npicking this:\n  ?p2 \\<in> set_walks \\<Longrightarrow>\n  awalk_cost f (awalk_to_apath ?p2) \\<le> awalk_cost f ?p2", "show ?thesis"], ["proof (prove)\nusing this:\n  ?p2 \\<in> set_walks \\<Longrightarrow>\n  awalk_cost f (awalk_to_apath ?p2) \\<le> awalk_cost f ?p2\n\ngoal (1 subgoal):\n 1. (INF p\\<in>set_walks. ereal (awalk_cost f (awalk_to_apath p)))\n    \\<le> (INF p\\<in>set_walks. ereal (awalk_cost f p))", "by (intro INF_mono) auto"], ["proof (state)\nthis:\n  (INF p\\<in>set_walks. ereal (awalk_cost f (awalk_to_apath p)))\n  \\<le> (INF p\\<in>set_walks. ereal (awalk_cost f p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (INF p\\<in>set_walks. ereal (awalk_cost f (awalk_to_apath p)))\n  \\<le> (INF p\\<in>set_walks. ereal (awalk_cost f p))\n\ngoal (2 subgoals):\n 1. (INF p\\<in>set_walks. ereal (awalk_cost f p))\n    \\<le> (INF p\\<in>set_paths. ereal (awalk_cost f p))\n 2. (INF p\\<in>set_paths. ereal (awalk_cost f p))\n    \\<le> (INF p\\<in>set_walks. ereal (awalk_cost f p))", "finally"], ["proof (chain)\npicking this:\n  (INF p\\<in>set_paths. ereal (awalk_cost f p))\n  \\<le> (INF p\\<in>set_walks. ereal (awalk_cost f p))", "show\n      \"(INF p\\<in> set_paths. ereal (awalk_cost f p))\n      \\<le> (INF p\\<in> set_walks. ereal (awalk_cost f p))\""], ["proof (prove)\nusing this:\n  (INF p\\<in>set_paths. ereal (awalk_cost f p))\n  \\<le> (INF p\\<in>set_walks. ereal (awalk_cost f p))\n\ngoal (1 subgoal):\n 1. (INF p\\<in>set_paths. ereal (awalk_cost f p))\n    \\<le> (INF p\\<in>set_walks. ereal (awalk_cost f p))", "by simp"], ["proof (state)\nthis:\n  (INF p\\<in>set_paths. ereal (awalk_cost f p))\n  \\<le> (INF p\\<in>set_walks. ereal (awalk_cost f p))\n\ngoal (1 subgoal):\n 1. (INF p\\<in>set_walks. ereal (awalk_cost f p))\n    \\<le> (INF p\\<in>set_paths. ereal (awalk_cost f p))", "have \"set_paths \\<subseteq> set_walks\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_paths \\<subseteq> set_walks", "unfolding set_paths_def set_walks_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. apath u p v} \\<subseteq> {p. awalk u p v}", "by (auto simp: apath_def)"], ["proof (state)\nthis:\n  set_paths \\<subseteq> set_walks\n\ngoal (1 subgoal):\n 1. (INF p\\<in>set_walks. ereal (awalk_cost f p))\n    \\<le> (INF p\\<in>set_paths. ereal (awalk_cost f p))", "then"], ["proof (chain)\npicking this:\n  set_paths \\<subseteq> set_walks", "show \"(INF p\\<in> set_walks. ereal (awalk_cost f p))\n      \\<le> (INF p\\<in> set_paths. ereal (awalk_cost f p))\""], ["proof (prove)\nusing this:\n  set_paths \\<subseteq> set_walks\n\ngoal (1 subgoal):\n 1. (INF p\\<in>set_walks. ereal (awalk_cost f p))\n    \\<le> (INF p\\<in>set_paths. ereal (awalk_cost f p))", "by (rule INF_superset_mono) simp"], ["proof (state)\nthis:\n  (INF p\\<in>set_walks. ereal (awalk_cost f p))\n  \\<le> (INF p\\<in>set_paths. ereal (awalk_cost f p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (INF p\\<in>set_walks. ereal (awalk_cost f p)) =\n  (INF p\\<in>set_paths. ereal (awalk_cost f p))\n\ngoal (1 subgoal):\n 1. \\<exists>p. apath u p v \\<and> \\<mu> f u v = ereal (awalk_cost f p)", "also"], ["proof (state)\nthis:\n  (INF p\\<in>set_walks. ereal (awalk_cost f p)) =\n  (INF p\\<in>set_paths. ereal (awalk_cost f p))\n\ngoal (1 subgoal):\n 1. \\<exists>p. apath u p v \\<and> \\<mu> f u v = ereal (awalk_cost f p)", "have \"\\<dots> \\<in> (\\<lambda>p. ereal (awalk_cost f p)) ` set_paths\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (INF p\\<in>set_paths. ereal (awalk_cost f p))\n    \\<in> (\\<lambda>p. ereal (awalk_cost f p)) ` set_paths", "using apaths_finite \\<open>set_paths \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  finite {p. apath ?u p ?v}\n  set_paths \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (INF p\\<in>set_paths. ereal (awalk_cost f p))\n    \\<in> (\\<lambda>p. ereal (awalk_cost f p)) ` set_paths", "by (intro finite_INF_in) (auto simp: set_paths_def)"], ["proof (state)\nthis:\n  (INF p\\<in>set_paths. ereal (awalk_cost f p))\n  \\<in> (\\<lambda>p. ereal (awalk_cost f p)) ` set_paths\n\ngoal (1 subgoal):\n 1. \\<exists>p. apath u p v \\<and> \\<mu> f u v = ereal (awalk_cost f p)", "finally"], ["proof (chain)\npicking this:\n  \\<mu> f u v \\<in> (\\<lambda>p. ereal (awalk_cost f p)) ` set_paths", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<mu> f u v \\<in> (\\<lambda>p. ereal (awalk_cost f p)) ` set_paths\n\ngoal (1 subgoal):\n 1. \\<exists>p. apath u p v \\<and> \\<mu> f u v = ereal (awalk_cost f p)", "by (simp add: set_paths_def image_def)"], ["proof (state)\nthis:\n  \\<exists>p. apath u p v \\<and> \\<mu> f u v = ereal (awalk_cost f p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in fin_digraph) min_cost_awalk:\n  assumes reach: \"u \\<rightarrow>\\<^sup>* v\"\n  assumes pos_cost: \"\\<And>e. e \\<in> arcs G \\<Longrightarrow> c e \\<ge> 0\"\n  shows \"\\<exists>p. apath u p v \\<and> \\<mu> c u v = awalk_cost c p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. apath u p v \\<and> \\<mu> c u v = ereal (awalk_cost c p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. apath u p v \\<and> \\<mu> c u v = ereal (awalk_cost c p)", "have pc: \"\\<And>u p v. awalk u p v \\<Longrightarrow> 0 \\<le> awalk_cost c p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u p v. awalk u p v \\<Longrightarrow> 0 \\<le> awalk_cost c p", "using pos_cost_pos_awalk_cost pos_cost"], ["proof (prove)\nusing this:\n  \\<lbrakk>awalk ?u ?p ?v;\n   \\<And>e. e \\<in> arcs G \\<Longrightarrow> 0 \\<le> ?c e\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> awalk_cost ?c ?p\n  ?e \\<in> arcs G \\<Longrightarrow> 0 \\<le> c ?e\n\ngoal (1 subgoal):\n 1. \\<And>u p v. awalk u p v \\<Longrightarrow> 0 \\<le> awalk_cost c p", "by auto"], ["proof (state)\nthis:\n  awalk ?u ?p ?v \\<Longrightarrow> 0 \\<le> awalk_cost c ?p\n\ngoal (1 subgoal):\n 1. \\<exists>p. apath u p v \\<and> \\<mu> c u v = ereal (awalk_cost c p)", "from reach"], ["proof (chain)\npicking this:\n  u \\<rightarrow>\\<^sup>* v", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<rightarrow>\\<^sup>* v\n\ngoal (1 subgoal):\n 1. \\<exists>p. apath u p v \\<and> \\<mu> c u v = ereal (awalk_cost c p)", "by (rule no_neg_cyc_reach_imp_path) (auto simp: not_less intro: pc)"], ["proof (state)\nthis:\n  \\<exists>p. apath u p v \\<and> \\<mu> c u v = ereal (awalk_cost c p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in fin_digraph) pos_cost_mu_triangle:\n  assumes pos_cost: \"\\<And>e. e \\<in> arcs G \\<Longrightarrow> c e \\<ge> 0\" (* introduce predicate? *)\n  assumes e_props: \"arc_to_ends G e = (u,v)\" \"e \\<in> arcs G\"\n  shows \"\\<mu> c s v \\<le> \\<mu> c s u + c e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> c s v \\<le> \\<mu> c s u + ereal (c e)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<mu> c s v \\<le> \\<mu> c s u + ereal (c e)\n 2. \\<not> ?P \\<Longrightarrow> \\<mu> c s v \\<le> \\<mu> c s u + ereal (c e)", "assume \"\\<mu> c s u = \\<infinity>\""], ["proof (state)\nthis:\n  \\<mu> c s u = \\<infinity>\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<mu> c s v \\<le> \\<mu> c s u + ereal (c e)\n 2. \\<not> ?P \\<Longrightarrow> \\<mu> c s v \\<le> \\<mu> c s u + ereal (c e)", "then"], ["proof (chain)\npicking this:\n  \\<mu> c s u = \\<infinity>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<mu> c s u = \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<mu> c s v \\<le> \\<mu> c s u + ereal (c e)", "by simp"], ["proof (state)\nthis:\n  \\<mu> c s v \\<le> \\<mu> c s u + ereal (c e)\n\ngoal (1 subgoal):\n 1. \\<mu> c s u \\<noteq> \\<infinity> \\<Longrightarrow>\n    \\<mu> c s v \\<le> \\<mu> c s u + ereal (c e)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<mu> c s u \\<noteq> \\<infinity> \\<Longrightarrow>\n    \\<mu> c s v \\<le> \\<mu> c s u + ereal (c e)", "assume \"\\<mu> c s u \\<noteq> \\<infinity>\""], ["proof (state)\nthis:\n  \\<mu> c s u \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<mu> c s u \\<noteq> \\<infinity> \\<Longrightarrow>\n    \\<mu> c s v \\<le> \\<mu> c s u + ereal (c e)", "then"], ["proof (chain)\npicking this:\n  \\<mu> c s u \\<noteq> \\<infinity>", "have \"{p. awalk s p u} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<mu> c s u \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. {p. awalk s p u} \\<noteq> {}", "unfolding \\<mu>_def"], ["proof (prove)\nusing this:\n  (INF p\\<in>{p. awalk s p u}. ereal (awalk_cost c p)) \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. {p. awalk s p u} \\<noteq> {}", "by safe (simp add: top_ereal_def)"], ["proof (state)\nthis:\n  {p. awalk s p u} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<mu> c s u \\<noteq> \\<infinity> \\<Longrightarrow>\n    \\<mu> c s v \\<le> \\<mu> c s u + ereal (c e)", "then"], ["proof (chain)\npicking this:\n  {p. awalk s p u} \\<noteq> {}", "have \"s \\<rightarrow>\\<^sup>* u\""], ["proof (prove)\nusing this:\n  {p. awalk s p u} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. s \\<rightarrow>\\<^sup>* u", "by (simp add: reachable_awalk)"], ["proof (state)\nthis:\n  s \\<rightarrow>\\<^sup>* u\n\ngoal (1 subgoal):\n 1. \\<mu> c s u \\<noteq> \\<infinity> \\<Longrightarrow>\n    \\<mu> c s v \\<le> \\<mu> c s u + ereal (c e)", "with pos_cost"], ["proof (chain)\npicking this:\n  ?e \\<in> arcs G \\<Longrightarrow> 0 \\<le> c ?e\n  s \\<rightarrow>\\<^sup>* u", "obtain p where p_props: \"apath s p u\" \n      and p_cost: \"\\<mu> c s u = awalk_cost c p\""], ["proof (prove)\nusing this:\n  ?e \\<in> arcs G \\<Longrightarrow> 0 \\<le> c ?e\n  s \\<rightarrow>\\<^sup>* u\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>apath s p u; \\<mu> c s u = ereal (awalk_cost c p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis min_cost_awalk)"], ["proof (state)\nthis:\n  apath s p u\n  \\<mu> c s u = ereal (awalk_cost c p)\n\ngoal (1 subgoal):\n 1. \\<mu> c s u \\<noteq> \\<infinity> \\<Longrightarrow>\n    \\<mu> c s v \\<le> \\<mu> c s u + ereal (c e)", "have \"awalk u [e] v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk u [e] v", "using e_props"], ["proof (prove)\nusing this:\n  arc_to_ends G e = (u, v)\n  e \\<in> arcs G\n\ngoal (1 subgoal):\n 1. awalk u [e] v", "by (auto simp: arc_to_ends_def awalk_simps)"], ["proof (state)\nthis:\n  awalk u [e] v\n\ngoal (1 subgoal):\n 1. \\<mu> c s u \\<noteq> \\<infinity> \\<Longrightarrow>\n    \\<mu> c s v \\<le> \\<mu> c s u + ereal (c e)", "with \\<open>apath s p u\\<close>"], ["proof (chain)\npicking this:\n  apath s p u\n  awalk u [e] v", "have \"awalk s (p @ [e]) v\""], ["proof (prove)\nusing this:\n  apath s p u\n  awalk u [e] v\n\ngoal (1 subgoal):\n 1. awalk s (p @ [e]) v", "by (auto simp: apath_def awalk_appendI)"], ["proof (state)\nthis:\n  awalk s (p @ [e]) v\n\ngoal (1 subgoal):\n 1. \\<mu> c s u \\<noteq> \\<infinity> \\<Longrightarrow>\n    \\<mu> c s v \\<le> \\<mu> c s u + ereal (c e)", "then"], ["proof (chain)\npicking this:\n  awalk s (p @ [e]) v", "have \"\\<mu> c s v \\<le> awalk_cost c (p @ [e])\""], ["proof (prove)\nusing this:\n  awalk s (p @ [e]) v\n\ngoal (1 subgoal):\n 1. \\<mu> c s v \\<le> ereal (awalk_cost c (p @ [e]))", "by (rule min_cost_le_walk_cost)"], ["proof (state)\nthis:\n  \\<mu> c s v \\<le> ereal (awalk_cost c (p @ [e]))\n\ngoal (1 subgoal):\n 1. \\<mu> c s u \\<noteq> \\<infinity> \\<Longrightarrow>\n    \\<mu> c s v \\<le> \\<mu> c s u + ereal (c e)", "also"], ["proof (state)\nthis:\n  \\<mu> c s v \\<le> ereal (awalk_cost c (p @ [e]))\n\ngoal (1 subgoal):\n 1. \\<mu> c s u \\<noteq> \\<infinity> \\<Longrightarrow>\n    \\<mu> c s v \\<le> \\<mu> c s u + ereal (c e)", "have \"\\<dots> \\<le> awalk_cost c p + c e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (awalk_cost c (p @ [e])) \\<le> ereal (awalk_cost c p + c e)", "by simp"], ["proof (state)\nthis:\n  ereal (awalk_cost c (p @ [e])) \\<le> ereal (awalk_cost c p + c e)\n\ngoal (1 subgoal):\n 1. \\<mu> c s u \\<noteq> \\<infinity> \\<Longrightarrow>\n    \\<mu> c s v \\<le> \\<mu> c s u + ereal (c e)", "also"], ["proof (state)\nthis:\n  ereal (awalk_cost c (p @ [e])) \\<le> ereal (awalk_cost c p + c e)\n\ngoal (1 subgoal):\n 1. \\<mu> c s u \\<noteq> \\<infinity> \\<Longrightarrow>\n    \\<mu> c s v \\<le> \\<mu> c s u + ereal (c e)", "have \"\\<dots> \\<le> \\<mu> c s u + c e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (awalk_cost c p + c e) \\<le> \\<mu> c s u + ereal (c e)", "using p_cost"], ["proof (prove)\nusing this:\n  \\<mu> c s u = ereal (awalk_cost c p)\n\ngoal (1 subgoal):\n 1. ereal (awalk_cost c p + c e) \\<le> \\<mu> c s u + ereal (c e)", "by simp"], ["proof (state)\nthis:\n  ereal (awalk_cost c p + c e) \\<le> \\<mu> c s u + ereal (c e)\n\ngoal (1 subgoal):\n 1. \\<mu> c s u \\<noteq> \\<infinity> \\<Longrightarrow>\n    \\<mu> c s v \\<le> \\<mu> c s u + ereal (c e)", "finally"], ["proof (chain)\npicking this:\n  \\<mu> c s v \\<le> \\<mu> c s u + ereal (c e)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<mu> c s v \\<le> \\<mu> c s u + ereal (c e)\n\ngoal (1 subgoal):\n 1. \\<mu> c s v \\<le> \\<mu> c s u + ereal (c e)", "."], ["proof (state)\nthis:\n  \\<mu> c s v \\<le> \\<mu> c s u + ereal (c e)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in fin_digraph) mu_exact_triangle:\n  assumes \"v \\<noteq> s\"\n  assumes \"s \\<rightarrow>\\<^sup>* v\"\n  assumes nonneg_arcs: \"\\<And>e. e \\<in> arcs G \\<Longrightarrow> 0 \\<le> c e\"\n  obtains u e where \"\\<mu> c s v = \\<mu> c s u + c e\" and \"arc e (u,v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u e.\n        \\<lbrakk>\\<mu> c s v = \\<mu> c s u + ereal (c e);\n         arc e (u, v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>u e.\n        \\<lbrakk>\\<mu> c s v = \\<mu> c s u + ereal (c e);\n         arc e (u, v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain p where p_path: \"apath s p v\"\n    and p_cost: \"\\<mu> c s v = awalk_cost c p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>apath s p v; \\<mu> c s v = ereal (awalk_cost c p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  v \\<noteq> s\n  s \\<rightarrow>\\<^sup>* v\n  ?e \\<in> arcs G \\<Longrightarrow> 0 \\<le> c ?e\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>apath s p v; \\<mu> c s v = ereal (awalk_cost c p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis min_cost_awalk)"], ["proof (state)\nthis:\n  apath s p v\n  \\<mu> c s v = ereal (awalk_cost c p)\n\ngoal (1 subgoal):\n 1. (\\<And>u e.\n        \\<lbrakk>\\<mu> c s v = \\<mu> c s u + ereal (c e);\n         arc e (u, v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  apath s p v\n  \\<mu> c s v = ereal (awalk_cost c p)", "obtain e p' where p'_props: \"p = p' @ [e]\""], ["proof (prove)\nusing this:\n  apath s p v\n  \\<mu> c s v = ereal (awalk_cost c p)\n\ngoal (1 subgoal):\n 1. (\\<And>p' e. p = p' @ [e] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>v \\<noteq> s\\<close>"], ["proof (prove)\nusing this:\n  apath s p v\n  \\<mu> c s v = ereal (awalk_cost c p)\n  v \\<noteq> s\n\ngoal (1 subgoal):\n 1. (\\<And>p' e. p = p' @ [e] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p rule: rev_cases) (auto simp: apath_def)"], ["proof (state)\nthis:\n  p = p' @ [e]\n\ngoal (1 subgoal):\n 1. (\\<And>u e.\n        \\<lbrakk>\\<mu> c s v = \\<mu> c s u + ereal (c e);\n         arc e (u, v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  p = p' @ [e]", "obtain u where \"awalk s p' u\" \"awalk u [e] v\""], ["proof (prove)\nusing this:\n  p = p' @ [e]\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>awalk s p' u; awalk u [e] v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>apath s p v\\<close>"], ["proof (prove)\nusing this:\n  p = p' @ [e]\n  apath s p v\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>awalk s p' u; awalk u [e] v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: apath_def)"], ["proof (state)\nthis:\n  awalk s p' u\n  awalk u [e] v\n\ngoal (1 subgoal):\n 1. (\\<And>u e.\n        \\<lbrakk>\\<mu> c s v = \\<mu> c s u + ereal (c e);\n         arc e (u, v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  awalk s p' u\n  awalk u [e] v", "have mu_le: \"\\<mu> c s v \\<le> \\<mu> c s u + c e\" and arc: \"arc e (u,v)\""], ["proof (prove)\nusing this:\n  awalk s p' u\n  awalk u [e] v\n\ngoal (1 subgoal):\n 1. \\<mu> c s v \\<le> \\<mu> c s u + ereal (c e) &&& arc e (u, v)", "using nonneg_arcs"], ["proof (prove)\nusing this:\n  awalk s p' u\n  awalk u [e] v\n  ?e \\<in> arcs G \\<Longrightarrow> 0 \\<le> c ?e\n\ngoal (1 subgoal):\n 1. \\<mu> c s v \\<le> \\<mu> c s u + ereal (c e) &&& arc e (u, v)", "by (auto intro!: pos_cost_mu_triangle simp: arc_to_ends_def arc_def)"], ["proof (state)\nthis:\n  \\<mu> c s v \\<le> \\<mu> c s u + ereal (c e)\n  arc e (u, v)\n\ngoal (1 subgoal):\n 1. (\\<And>u e.\n        \\<lbrakk>\\<mu> c s v = \\<mu> c s u + ereal (c e);\n         arc e (u, v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<mu> c s u + c e \\<le> ereal (awalk_cost c p') + ereal (c e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> c s u + ereal (c e) \\<le> ereal (awalk_cost c p') + ereal (c e)", "using \\<open>awalk s p' u\\<close>"], ["proof (prove)\nusing this:\n  awalk s p' u\n\ngoal (1 subgoal):\n 1. \\<mu> c s u + ereal (c e) \\<le> ereal (awalk_cost c p') + ereal (c e)", "by (fast intro: add_right_mono min_cost_le_walk_cost)"], ["proof (state)\nthis:\n  \\<mu> c s u + ereal (c e) \\<le> ereal (awalk_cost c p') + ereal (c e)\n\ngoal (1 subgoal):\n 1. (\\<And>u e.\n        \\<lbrakk>\\<mu> c s v = \\<mu> c s u + ereal (c e);\n         arc e (u, v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  \\<mu> c s u + ereal (c e) \\<le> ereal (awalk_cost c p') + ereal (c e)\n\ngoal (1 subgoal):\n 1. (\\<And>u e.\n        \\<lbrakk>\\<mu> c s v = \\<mu> c s u + ereal (c e);\n         arc e (u, v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = awalk_cost c p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (awalk_cost c p') + ereal (c e) = ereal (awalk_cost c p)", "using p'_props"], ["proof (prove)\nusing this:\n  p = p' @ [e]\n\ngoal (1 subgoal):\n 1. ereal (awalk_cost c p') + ereal (c e) = ereal (awalk_cost c p)", "by simp"], ["proof (state)\nthis:\n  ereal (awalk_cost c p') + ereal (c e) = ereal (awalk_cost c p)\n\ngoal (1 subgoal):\n 1. (\\<And>u e.\n        \\<lbrakk>\\<mu> c s v = \\<mu> c s u + ereal (c e);\n         arc e (u, v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  ereal (awalk_cost c p') + ereal (c e) = ereal (awalk_cost c p)\n\ngoal (1 subgoal):\n 1. (\\<And>u e.\n        \\<lbrakk>\\<mu> c s v = \\<mu> c s u + ereal (c e);\n         arc e (u, v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = \\<mu> c s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (awalk_cost c p) = \\<mu> c s v", "using p_cost"], ["proof (prove)\nusing this:\n  \\<mu> c s v = ereal (awalk_cost c p)\n\ngoal (1 subgoal):\n 1. ereal (awalk_cost c p) = \\<mu> c s v", "by simp"], ["proof (state)\nthis:\n  ereal (awalk_cost c p) = \\<mu> c s v\n\ngoal (1 subgoal):\n 1. (\\<And>u e.\n        \\<lbrakk>\\<mu> c s v = \\<mu> c s u + ereal (c e);\n         arc e (u, v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  \\<mu> c s u + ereal (c e) \\<le> \\<mu> c s v", "have \"\\<mu> c s v = \\<mu> c s u + c e\""], ["proof (prove)\nusing this:\n  \\<mu> c s u + ereal (c e) \\<le> \\<mu> c s v\n\ngoal (1 subgoal):\n 1. \\<mu> c s v = \\<mu> c s u + ereal (c e)", "using mu_le"], ["proof (prove)\nusing this:\n  \\<mu> c s u + ereal (c e) \\<le> \\<mu> c s v\n  \\<mu> c s v \\<le> \\<mu> c s u + ereal (c e)\n\ngoal (1 subgoal):\n 1. \\<mu> c s v = \\<mu> c s u + ereal (c e)", "by auto"], ["proof (state)\nthis:\n  \\<mu> c s v = \\<mu> c s u + ereal (c e)\n\ngoal (1 subgoal):\n 1. (\\<And>u e.\n        \\<lbrakk>\\<mu> c s v = \\<mu> c s u + ereal (c e);\n         arc e (u, v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<mu> c s v = \\<mu> c s u + ereal (c e)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<mu> c s v = \\<mu> c s u + ereal (c e)\n\ngoal (1 subgoal):\n 1. thesis", "using arc"], ["proof (prove)\nusing this:\n  \\<mu> c s v = \\<mu> c s u + ereal (c e)\n  arc e (u, v)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in fin_digraph) mu_exact_triangle_Ex:\n  assumes \"v \\<noteq> s\"\n  assumes \"s \\<rightarrow>\\<^sup>* v\"\n  assumes \"\\<And>e. e \\<in> arcs G \\<Longrightarrow> 0 \\<le> c e\"\n  shows \"\\<exists>u e. \\<mu> c s v = \\<mu> c s u + c e \\<and> arc e (u,v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u e.\n       \\<mu> c s v = \\<mu> c s u + ereal (c e) \\<and> arc e (u, v)", "using assms"], ["proof (prove)\nusing this:\n  v \\<noteq> s\n  s \\<rightarrow>\\<^sup>* v\n  ?e \\<in> arcs G \\<Longrightarrow> 0 \\<le> c ?e\n\ngoal (1 subgoal):\n 1. \\<exists>u e.\n       \\<mu> c s v = \\<mu> c s u + ereal (c e) \\<and> arc e (u, v)", "by (metis mu_exact_triangle)"], ["", "lemma (in fin_digraph) mu_Inf_triangle:\n  assumes \"v \\<noteq> s\"\n  assumes \"\\<And>e. e \\<in> arcs G \\<Longrightarrow> 0 \\<le> c e\"\n  shows \"\\<mu> c s v = Inf {\\<mu> c s u + c e | u e. arc e (u, v)}\" (is \"_ = Inf ?S\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> c s v = Inf {\\<mu> c s u + ereal (c e) |u e. arc e (u, v)}", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<mu> c s v = Inf {\\<mu> c s u + ereal (c e) |u e. arc e (u, v)}\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<mu> c s v = Inf {\\<mu> c s u + ereal (c e) |u e. arc e (u, v)}", "assume \"s \\<rightarrow>\\<^sup>* v\""], ["proof (state)\nthis:\n  s \\<rightarrow>\\<^sup>* v\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<mu> c s v = Inf {\\<mu> c s u + ereal (c e) |u e. arc e (u, v)}\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<mu> c s v = Inf {\\<mu> c s u + ereal (c e) |u e. arc e (u, v)}", "then"], ["proof (chain)\npicking this:\n  s \\<rightarrow>\\<^sup>* v", "obtain u e where \"\\<mu> c s v = \\<mu> c s u + c e\" \"arc e (u,v)\""], ["proof (prove)\nusing this:\n  s \\<rightarrow>\\<^sup>* v\n\ngoal (1 subgoal):\n 1. (\\<And>u e.\n        \\<lbrakk>\\<mu> c s v = \\<mu> c s u + ereal (c e);\n         arc e (u, v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  s \\<rightarrow>\\<^sup>* v\n  v \\<noteq> s\n  ?e \\<in> arcs G \\<Longrightarrow> 0 \\<le> c ?e\n\ngoal (1 subgoal):\n 1. (\\<And>u e.\n        \\<lbrakk>\\<mu> c s v = \\<mu> c s u + ereal (c e);\n         arc e (u, v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis mu_exact_triangle)"], ["proof (state)\nthis:\n  \\<mu> c s v = \\<mu> c s u + ereal (c e)\n  arc e (u, v)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<mu> c s v = Inf {\\<mu> c s u + ereal (c e) |u e. arc e (u, v)}\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<mu> c s v = Inf {\\<mu> c s u + ereal (c e) |u e. arc e (u, v)}", "then"], ["proof (chain)\npicking this:\n  \\<mu> c s v = \\<mu> c s u + ereal (c e)\n  arc e (u, v)", "have \"Inf ?S \\<le> \\<mu> c s v\""], ["proof (prove)\nusing this:\n  \\<mu> c s v = \\<mu> c s u + ereal (c e)\n  arc e (u, v)\n\ngoal (1 subgoal):\n 1. Inf {\\<mu> c s u + ereal (c e) |u e. arc e (u, v)} \\<le> \\<mu> c s v", "by (auto intro: Complete_Lattices.Inf_lower)"], ["proof (state)\nthis:\n  Inf {\\<mu> c s u + ereal (c e) |u e. arc e (u, v)} \\<le> \\<mu> c s v\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<mu> c s v = Inf {\\<mu> c s u + ereal (c e) |u e. arc e (u, v)}\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<mu> c s v = Inf {\\<mu> c s u + ereal (c e) |u e. arc e (u, v)}", "also"], ["proof (state)\nthis:\n  Inf {\\<mu> c s u + ereal (c e) |u e. arc e (u, v)} \\<le> \\<mu> c s v\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<mu> c s v = Inf {\\<mu> c s u + ereal (c e) |u e. arc e (u, v)}\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<mu> c s v = Inf {\\<mu> c s u + ereal (c e) |u e. arc e (u, v)}", "have \"\\<dots> \\<le> Inf ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> c s v \\<le> Inf {\\<mu> c s u + ereal (c e) |u e. arc e (u, v)}", "using assms(2)"], ["proof (prove)\nusing this:\n  ?e \\<in> arcs G \\<Longrightarrow> 0 \\<le> c ?e\n\ngoal (1 subgoal):\n 1. \\<mu> c s v \\<le> Inf {\\<mu> c s u + ereal (c e) |u e. arc e (u, v)}", "by (auto intro!: Complete_Lattices.Inf_greatest pos_cost_mu_triangle\n      simp: arc_def arc_to_ends_def)"], ["proof (state)\nthis:\n  \\<mu> c s v \\<le> Inf {\\<mu> c s u + ereal (c e) |u e. arc e (u, v)}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<mu> c s v = Inf {\\<mu> c s u + ereal (c e) |u e. arc e (u, v)}\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<mu> c s v = Inf {\\<mu> c s u + ereal (c e) |u e. arc e (u, v)}", "finally"], ["proof (chain)\npicking this:\n  Inf {\\<mu> c s u + ereal (c e) |u e. arc e (u, v)} = \\<mu> c s v", "show ?thesis"], ["proof (prove)\nusing this:\n  Inf {\\<mu> c s u + ereal (c e) |u e. arc e (u, v)} = \\<mu> c s v\n\ngoal (1 subgoal):\n 1. \\<mu> c s v = Inf {\\<mu> c s u + ereal (c e) |u e. arc e (u, v)}", "by simp"], ["proof (state)\nthis:\n  \\<mu> c s v = Inf {\\<mu> c s u + ereal (c e) |u e. arc e (u, v)}\n\ngoal (1 subgoal):\n 1. \\<not> s \\<rightarrow>\\<^sup>* v \\<Longrightarrow>\n    \\<mu> c s v = Inf {\\<mu> c s u + ereal (c e) |u e. arc e (u, v)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> s \\<rightarrow>\\<^sup>* v \\<Longrightarrow>\n    \\<mu> c s v = Inf {\\<mu> c s u + ereal (c e) |u e. arc e (u, v)}", "assume \"\\<not>s \\<rightarrow>\\<^sup>* v\""], ["proof (state)\nthis:\n  \\<not> s \\<rightarrow>\\<^sup>* v\n\ngoal (1 subgoal):\n 1. \\<not> s \\<rightarrow>\\<^sup>* v \\<Longrightarrow>\n    \\<mu> c s v = Inf {\\<mu> c s u + ereal (c e) |u e. arc e (u, v)}", "then"], ["proof (chain)\npicking this:\n  \\<not> s \\<rightarrow>\\<^sup>* v", "have \"\\<mu> c s v = \\<infinity>\""], ["proof (prove)\nusing this:\n  \\<not> s \\<rightarrow>\\<^sup>* v\n\ngoal (1 subgoal):\n 1. \\<mu> c s v = \\<infinity>", "by (metis shortest_path_inf)"], ["proof (state)\nthis:\n  \\<mu> c s v = \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<not> s \\<rightarrow>\\<^sup>* v \\<Longrightarrow>\n    \\<mu> c s v = Inf {\\<mu> c s u + ereal (c e) |u e. arc e (u, v)}", "define S where \"S = ?S\""], ["proof (state)\nthis:\n  S = {\\<mu> c s u + ereal (c e) |u e. arc e (u, v)}\n\ngoal (1 subgoal):\n 1. \\<not> s \\<rightarrow>\\<^sup>* v \\<Longrightarrow>\n    \\<mu> c s v = Inf {\\<mu> c s u + ereal (c e) |u e. arc e (u, v)}", "show \"\\<mu> c s v = Inf S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> c s v = Inf S", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<mu> c s v = Inf S\n 2. \\<not> ?P \\<Longrightarrow> \\<mu> c s v = Inf S", "assume \"S = {}\""], ["proof (state)\nthis:\n  S = {}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<mu> c s v = Inf S\n 2. \\<not> ?P \\<Longrightarrow> \\<mu> c s v = Inf S", "then"], ["proof (chain)\npicking this:\n  S = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  S = {}\n\ngoal (1 subgoal):\n 1. \\<mu> c s v = Inf S", "unfolding \\<open>\\<mu> c s v = \\<infinity>\\<close>"], ["proof (prove)\nusing this:\n  S = {}\n\ngoal (1 subgoal):\n 1. \\<infinity> = Inf S", "by (simp add: top_ereal_def)"], ["proof (state)\nthis:\n  \\<mu> c s v = Inf S\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> \\<mu> c s v = Inf S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> \\<mu> c s v = Inf S", "assume \"S \\<noteq> {}\""], ["proof (state)\nthis:\n  S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> \\<mu> c s v = Inf S", "{"], ["proof (state)\nthis:\n  S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> \\<mu> c s v = Inf S", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> \\<mu> c s v = Inf S", "assume \"x \\<in> S\""], ["proof (state)\nthis:\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> \\<mu> c s v = Inf S", "then"], ["proof (chain)\npicking this:\n  x \\<in> S", "obtain u e where \"arc e (u,v)\" and x_val: \"x = \\<mu> c s u + c e\""], ["proof (prove)\nusing this:\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>e u.\n        \\<lbrakk>arc e (u, v); x = \\<mu> c s u + ereal (c e)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding S_def"], ["proof (prove)\nusing this:\n  x \\<in> {\\<mu> c s u + ereal (c e) |u e. arc e (u, v)}\n\ngoal (1 subgoal):\n 1. (\\<And>e u.\n        \\<lbrakk>arc e (u, v); x = \\<mu> c s u + ereal (c e)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  arc e (u, v)\n  x = \\<mu> c s u + ereal (c e)\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> \\<mu> c s v = Inf S", "then"], ["proof (chain)\npicking this:\n  arc e (u, v)\n  x = \\<mu> c s u + ereal (c e)", "have \"\\<not>s \\<rightarrow>\\<^sup>* u\""], ["proof (prove)\nusing this:\n  arc e (u, v)\n  x = \\<mu> c s u + ereal (c e)\n\ngoal (1 subgoal):\n 1. \\<not> s \\<rightarrow>\\<^sup>* u", "using \\<open>\\<not> s \\<rightarrow>\\<^sup>* v\\<close>"], ["proof (prove)\nusing this:\n  arc e (u, v)\n  x = \\<mu> c s u + ereal (c e)\n  \\<not> s \\<rightarrow>\\<^sup>* v\n\ngoal (1 subgoal):\n 1. \\<not> s \\<rightarrow>\\<^sup>* u", "by (metis reachable_arc_trans)"], ["proof (state)\nthis:\n  \\<not> s \\<rightarrow>\\<^sup>* u\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> \\<mu> c s v = Inf S", "then"], ["proof (chain)\npicking this:\n  \\<not> s \\<rightarrow>\\<^sup>* u", "have \"\\<mu> c s u + c e= \\<infinity>\""], ["proof (prove)\nusing this:\n  \\<not> s \\<rightarrow>\\<^sup>* u\n\ngoal (1 subgoal):\n 1. \\<mu> c s u + ereal (c e) = \\<infinity>", "by (simp add: shortest_path_inf)"], ["proof (state)\nthis:\n  \\<mu> c s u + ereal (c e) = \\<infinity>\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> \\<mu> c s v = Inf S", "then"], ["proof (chain)\npicking this:\n  \\<mu> c s u + ereal (c e) = \\<infinity>", "have \"x = \\<infinity>\""], ["proof (prove)\nusing this:\n  \\<mu> c s u + ereal (c e) = \\<infinity>\n\ngoal (1 subgoal):\n 1. x = \\<infinity>", "using x_val"], ["proof (prove)\nusing this:\n  \\<mu> c s u + ereal (c e) = \\<infinity>\n  x = \\<mu> c s u + ereal (c e)\n\ngoal (1 subgoal):\n 1. x = \\<infinity>", "by simp"], ["proof (state)\nthis:\n  x = \\<infinity>\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> \\<mu> c s v = Inf S", "}"], ["proof (state)\nthis:\n  ?x2 \\<in> S \\<Longrightarrow> ?x2 = \\<infinity>\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> \\<mu> c s v = Inf S", "then"], ["proof (chain)\npicking this:\n  ?x2 \\<in> S \\<Longrightarrow> ?x2 = \\<infinity>", "have \"S = {\\<infinity>}\""], ["proof (prove)\nusing this:\n  ?x2 \\<in> S \\<Longrightarrow> ?x2 = \\<infinity>\n\ngoal (1 subgoal):\n 1. S = {\\<infinity>}", "using \\<open>S \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  ?x2 \\<in> S \\<Longrightarrow> ?x2 = \\<infinity>\n  S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. S = {\\<infinity>}", "by auto"], ["proof (state)\nthis:\n  S = {\\<infinity>}\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow> \\<mu> c s v = Inf S", "then"], ["proof (chain)\npicking this:\n  S = {\\<infinity>}", "show ?thesis"], ["proof (prove)\nusing this:\n  S = {\\<infinity>}\n\ngoal (1 subgoal):\n 1. \\<mu> c s v = Inf S", "using \\<open>\\<mu> c s v = \\<infinity>\\<close>"], ["proof (prove)\nusing this:\n  S = {\\<infinity>}\n  \\<mu> c s v = \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<mu> c s v = Inf S", "by (simp add: min_def)"], ["proof (state)\nthis:\n  \\<mu> c s v = Inf S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<mu> c s v = Inf S\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}