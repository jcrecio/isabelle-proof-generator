{"file_name": "/home/qj213/afp-2021-10-22/thys/Graph_Theory/Euler.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Graph_Theory", "problem_names": ["lemma finite_distinct:\n  assumes \"finite A\" shows \"finite {p. distinct p \\<and> set p \\<subseteq> A}\"", "lemma (in fin_digraph) trails_finite: \"finite {p. \\<exists>u v. trail u p v}\"", "lemma rotate_awalkE:\n  assumes \"awalk u p u\" \"w \\<in> set (awalk_verts u p)\"\n  obtains q r where \"p = q @ r\" \"awalk w (r @ q) w\" \"set (awalk_verts w (r @ q)) = set (awalk_verts u p)\"", "lemma rotate_trailE:\n  assumes \"trail u p u\" \"w \\<in> set (awalk_verts u p)\"\n  obtains q r where \"p = q @ r\" \"trail w (r @ q) w\" \"set (awalk_verts w (r @ q)) = set (awalk_verts u p)\"", "lemma rotate_trailE':\n  assumes \"trail u p u\" \"w \\<in> set (awalk_verts u p)\"\n  obtains q where \"trail w q w\" \"set q = set p\" \"set (awalk_verts w q) = set (awalk_verts u p)\"", "lemma sym_reachableI_in_awalk:\n  assumes walk: \"awalk u p v\" and\n    w1: \"w1 \\<in> set (awalk_verts u p)\" and w2: \"w2 \\<in> set (awalk_verts u p)\"\n  shows \"w1 \\<rightarrow>\\<^sup>*\\<^bsub>mk_symmetric G\\<^esub> w2\"", "lemma euler_imp_connected:\n  assumes \"euler_trail u p v\" shows \"connected G\"", "lemma arc_set_balanced_all:\n  \"arc_set_balanced u (arcs G) v =\n      (if u = v then (\\<forall>w \\<in> verts G. in_degree G w = out_degree G w)\n      else (\\<forall>w \\<in> verts G. (w \\<noteq> u \\<and> w \\<noteq> v) \\<longrightarrow> in_degree G w = out_degree G w)\n        \\<and> in_degree G u + 1 = out_degree G u\n        \\<and> out_degree G v + 1 = in_degree G v)\"", "lemma arc_balance_Cons:\n  assumes \"trail u (e # es) v\"\n  shows \"arc_set_balance w (insert e (set es)) = arc_set_balance w {e} + arc_balance w es\"", "lemma arc_balancedI_trail:\n  assumes \"trail u p v\" shows \"arc_balanced u p v\"", "lemma trail_arc_balanceE:\n  assumes \"trail u p v\"\n  obtains \"\\<And>w. \\<lbrakk> u = v \\<or> (w \\<noteq> u \\<and> w \\<noteq> v); w \\<in> verts G \\<rbrakk>\n      \\<Longrightarrow> arc_balance w p = 0\"\n    and \"\\<lbrakk> u \\<noteq> v \\<rbrakk> \\<Longrightarrow> arc_balance u p = - 1\"\n    and \"\\<lbrakk> u \\<noteq> v \\<rbrakk> \\<Longrightarrow> arc_balance v p = 1\"", "lemma (in wf_digraph) awalk_vertex_props:\n  assumes \"awalk u p v\" \"p \\<noteq> []\"\n  assumes \"\\<And>w. w \\<in> set (awalk_verts u p) \\<Longrightarrow> P w \\<or> Q w\"\n  assumes \"P u\" \"Q v\"\n  shows \"\\<exists>e \\<in> set p. P (tail G e) \\<and> Q (head G e)\"", "lemma (in wf_digraph) connected_verts:\n  assumes \"connected G\" \"arcs G \\<noteq> {}\"\n  shows \"verts G = tail G ` arcs G \\<union> head G ` arcs G\"", "lemma (in wf_digraph) connected_arcs_empty:\n  assumes \"connected G\" \"arcs G = {}\" \"verts G \\<noteq> {}\" obtains v where \"verts G = {v}\"", "lemma (in wf_digraph) euler_trail_conv_connected:\n  assumes \"connected G\"\n  shows \"euler_trail u p v \\<longleftrightarrow> trail u p v \\<and> set p = arcs G\" (is \"?L \\<longleftrightarrow> ?R\")", "lemma (in wf_digraph) awalk_connected:\n  assumes \"connected G\" \"awalk u p v\" \"set p \\<noteq> arcs G\"\n  shows \"\\<exists>e. e \\<in> arcs G - set p \\<and> (tail G e \\<in> set (awalk_verts u p) \\<or> head G e \\<in> set (awalk_verts u p))\"", "lemma (in wf_digraph) trail_connected:\n  assumes \"connected G\" \"trail u p v\" \"set p \\<noteq> arcs G\"\n  shows \"\\<exists>e. e \\<in> arcs G - set p \\<and> (tail G e \\<in> set (awalk_verts u p) \\<or> head G e \\<in> set (awalk_verts u p))\"", "theorem (in fin_digraph) closed_euler1:\n  assumes con: \"connected G\"\n  assumes deg: \"\\<And>u. u \\<in> verts G \\<Longrightarrow> in_degree G u = out_degree G u\"\n  shows \"\\<exists>u p. euler_trail u p u\"", "lemma (in wf_digraph) closed_euler_imp_eq_degree:\n  assumes \"euler_trail u p u\"\n  assumes \"v \\<in> verts G\"\n  shows \"in_degree G v = out_degree G v\"", "theorem (in fin_digraph) closed_euler2:\n  assumes \"euler_trail u p u\"\n  shows \"connected G\"\n    and \"\\<And>u. u \\<in> verts G \\<Longrightarrow> in_degree G u = out_degree G u\" (is \"\\<And>u. _ \\<Longrightarrow> ?eq_deg u\")", "lemma open_euler_infinite_label:\n  fixes G :: \"('a, 'a \\<times> nat \\<times> 'a) pre_digraph\"\n  assumes \"fin_digraph G\"\n  assumes [simp]: \"tail G = fst\" \"head G = snd o snd\"\n  assumes con: \"connected G\"\n  assumes uv: \"u \\<in> verts G\" \"v \\<in> verts G\"\n  assumes deg: \"\\<And>w. \\<lbrakk>w \\<in> verts G; u \\<noteq> w; v \\<noteq> w\\<rbrakk> \\<Longrightarrow> in_degree G w = out_degree G w\"\n  assumes deg_in: \"in_degree G u + 1 = out_degree G u\"\n  assumes deg_out: \"out_degree G v + 1 = in_degree G v\"\n  shows \"\\<exists>p. pre_digraph.euler_trail G u p v\"", "lemma trail_app_isoI:\n  assumes t: \"trail u p v\"\n    and hom: \"digraph_isomorphism hom\"\n  shows \"pre_digraph.trail (app_iso hom G) (iso_verts hom u) (map (iso_arcs hom) p) (iso_verts hom v)\"", "lemma euler_trail_app_isoI:\n  assumes t: \"euler_trail u p v\"\n    and hom: \"digraph_isomorphism hom\"\n  shows \"pre_digraph.euler_trail (app_iso hom G) (iso_verts hom u) (map (iso_arcs hom) p) (iso_verts hom v)\"", "theorem open_euler1:\n  assumes \"connected G\"\n  assumes \"u \\<in> verts G\" \"v \\<in> verts G\"\n  assumes \"\\<And>w. \\<lbrakk>w \\<in> verts G; u \\<noteq> w; v \\<noteq> w\\<rbrakk> \\<Longrightarrow> in_degree G w = out_degree G w\"\n  assumes \"in_degree G u + 1 = out_degree G u\"\n  assumes \"out_degree G v + 1 = in_degree G v\"\n  shows \"\\<exists>p. euler_trail u p v\"", "theorem open_euler2:\n  assumes et: \"euler_trail u p v\" and \"u \\<noteq> v\"\n  shows \"connected G \\<and>\n    (\\<forall>w \\<in> verts G. u \\<noteq> w \\<longrightarrow> v \\<noteq> w \\<longrightarrow> in_degree G w = out_degree G w) \\<and>\n    in_degree G u + 1 = out_degree G u \\<and>\n    out_degree G v + 1 = in_degree G v\""], "translations": [["", "lemma finite_distinct:\n  assumes \"finite A\" shows \"finite {p. distinct p \\<and> set p \\<subseteq> A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {p. distinct p \\<and> set p \\<subseteq> A}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {p. distinct p \\<and> set p \\<subseteq> A}", "have \"{p. distinct p \\<and> set p \\<subseteq> A} \\<subseteq> {p. set p \\<subseteq> A \\<and> length p \\<le> card A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. distinct p \\<and> set p \\<subseteq> A}\n    \\<subseteq> {p. set p \\<subseteq> A \\<and> length p \\<le> card A}", "using assms"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. {p. distinct p \\<and> set p \\<subseteq> A}\n    \\<subseteq> {p. set p \\<subseteq> A \\<and> length p \\<le> card A}", "by (auto simp: distinct_card[symmetric] intro: card_mono)"], ["proof (state)\nthis:\n  {p. distinct p \\<and> set p \\<subseteq> A}\n  \\<subseteq> {p. set p \\<subseteq> A \\<and> length p \\<le> card A}\n\ngoal (1 subgoal):\n 1. finite {p. distinct p \\<and> set p \\<subseteq> A}", "also"], ["proof (state)\nthis:\n  {p. distinct p \\<and> set p \\<subseteq> A}\n  \\<subseteq> {p. set p \\<subseteq> A \\<and> length p \\<le> card A}\n\ngoal (1 subgoal):\n 1. finite {p. distinct p \\<and> set p \\<subseteq> A}", "have \"finite ...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {p. set p \\<subseteq> A \\<and> length p \\<le> card A}", "using assms"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. finite {p. set p \\<subseteq> A \\<and> length p \\<le> card A}", "by (simp add: finite_lists_length_le)"], ["proof (state)\nthis:\n  finite {p. set p \\<subseteq> A \\<and> length p \\<le> card A}\n\ngoal (1 subgoal):\n 1. finite {p. distinct p \\<and> set p \\<subseteq> A}", "finally (finite_subset)"], ["proof (chain)\npicking this:\n  finite {p. distinct p \\<and> set p \\<subseteq> A}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {p. distinct p \\<and> set p \\<subseteq> A}\n\ngoal (1 subgoal):\n 1. finite {p. distinct p \\<and> set p \\<subseteq> A}", "."], ["proof (state)\nthis:\n  finite {p. distinct p \\<and> set p \\<subseteq> A}\n\ngoal:\nNo subgoals!", "qed"], ["", "(* XXX move; notused*)"], ["", "lemma (in fin_digraph) trails_finite: \"finite {p. \\<exists>u v. trail u p v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {p. \\<exists>u v. trail u p v}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {p. \\<exists>u v. trail u p v}", "have \"{p. \\<exists>u v. trail u p v} \\<subseteq> {p. distinct p \\<and> set p \\<subseteq> arcs G}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. \\<exists>u v. trail u p v}\n    \\<subseteq> {p. distinct p \\<and> set p \\<subseteq> arcs G}", "by (auto simp: trail_def)"], ["proof (state)\nthis:\n  {p. \\<exists>u v. trail u p v}\n  \\<subseteq> {p. distinct p \\<and> set p \\<subseteq> arcs G}\n\ngoal (1 subgoal):\n 1. finite {p. \\<exists>u v. trail u p v}", "with finite_arcs finite_distinct"], ["proof (chain)\npicking this:\n  finite (arcs G)\n  finite ?A \\<Longrightarrow>\n  finite {p. distinct p \\<and> set p \\<subseteq> ?A}\n  {p. \\<exists>u v. trail u p v}\n  \\<subseteq> {p. distinct p \\<and> set p \\<subseteq> arcs G}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (arcs G)\n  finite ?A \\<Longrightarrow>\n  finite {p. distinct p \\<and> set p \\<subseteq> ?A}\n  {p. \\<exists>u v. trail u p v}\n  \\<subseteq> {p. distinct p \\<and> set p \\<subseteq> arcs G}\n\ngoal (1 subgoal):\n 1. finite {p. \\<exists>u v. trail u p v}", "by (blast intro: finite_subset)"], ["proof (state)\nthis:\n  finite {p. \\<exists>u v. trail u p v}\n\ngoal:\nNo subgoals!", "qed"], ["", "(* XXX: simplify apath_finite proof? *)"], ["", "lemma rotate_awalkE:\n  assumes \"awalk u p u\" \"w \\<in> set (awalk_verts u p)\"\n  obtains q r where \"p = q @ r\" \"awalk w (r @ q) w\" \"set (awalk_verts w (r @ q)) = set (awalk_verts u p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = q @ r; awalk w (r @ q) w;\n         set (awalk_verts w (r @ q)) = set (awalk_verts u p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = q @ r; awalk w (r @ q) w;\n         set (awalk_verts w (r @ q)) = set (awalk_verts u p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  awalk u p u\n  w \\<in> set (awalk_verts u p)", "obtain q r where A: \"p = q @ r\" and A': \"awalk u q w\" \"awalk w r u\""], ["proof (prove)\nusing this:\n  awalk u p u\n  w \\<in> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = q @ r; awalk u q w; awalk w r u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim (rule awalk_decomp)"], ["proof (state)\nthis:\n  p = q @ r\n  awalk u q w\n  awalk w r u\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = q @ r; awalk w (r @ q) w;\n         set (awalk_verts w (r @ q)) = set (awalk_verts u p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  p = q @ r\n  awalk u q w\n  awalk w r u", "have B: \"awalk w (r @ q) w\""], ["proof (prove)\nusing this:\n  p = q @ r\n  awalk u q w\n  awalk w r u\n\ngoal (1 subgoal):\n 1. awalk w (r @ q) w", "by auto"], ["proof (state)\nthis:\n  awalk w (r @ q) w\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = q @ r; awalk w (r @ q) w;\n         set (awalk_verts w (r @ q)) = set (awalk_verts u p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have C: \"set (awalk_verts w (r @ q)) = set (awalk_verts u p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (awalk_verts w (r @ q)) = set (awalk_verts u p)", "using \\<open>awalk u p u\\<close> A A'"], ["proof (prove)\nusing this:\n  awalk u p u\n  p = q @ r\n  awalk u q w\n  awalk w r u\n\ngoal (1 subgoal):\n 1. set (awalk_verts w (r @ q)) = set (awalk_verts u p)", "by (auto simp: set_awalk_verts_append)"], ["proof (state)\nthis:\n  set (awalk_verts w (r @ q)) = set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = q @ r; awalk w (r @ q) w;\n         set (awalk_verts w (r @ q)) = set (awalk_verts u p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from A B C"], ["proof (chain)\npicking this:\n  p = q @ r\n  awalk w (r @ q) w\n  set (awalk_verts w (r @ q)) = set (awalk_verts u p)", "show ?thesis"], ["proof (prove)\nusing this:\n  p = q @ r\n  awalk w (r @ q) w\n  set (awalk_verts w (r @ q)) = set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rotate_trailE:\n  assumes \"trail u p u\" \"w \\<in> set (awalk_verts u p)\"\n  obtains q r where \"p = q @ r\" \"trail w (r @ q) w\" \"set (awalk_verts w (r @ q)) = set (awalk_verts u p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = q @ r; trail w (r @ q) w;\n         set (awalk_verts w (r @ q)) = set (awalk_verts u p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  trail u p u\n  w \\<in> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = q @ r; trail w (r @ q) w;\n         set (awalk_verts w (r @ q)) = set (awalk_verts u p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by - (rule rotate_awalkE[where u=u and p=p and w=w], auto simp: trail_def)"], ["", "lemma rotate_trailE':\n  assumes \"trail u p u\" \"w \\<in> set (awalk_verts u p)\"\n  obtains q where \"trail w q w\" \"set q = set p\" \"set (awalk_verts w q) = set (awalk_verts u p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>trail w q w; set q = set p;\n         set (awalk_verts w q) = set (awalk_verts u p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>trail w q w; set q = set p;\n         set (awalk_verts w q) = set (awalk_verts u p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  trail u p u\n  w \\<in> set (awalk_verts u p)", "obtain q r where \"p = q @ r\" \"trail w (r @ q) w\" \"set (awalk_verts w (r @ q)) = set (awalk_verts u p)\""], ["proof (prove)\nusing this:\n  trail u p u\n  w \\<in> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = q @ r; trail w (r @ q) w;\n         set (awalk_verts w (r @ q)) = set (awalk_verts u p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule rotate_trailE)"], ["proof (state)\nthis:\n  p = q @ r\n  trail w (r @ q) w\n  set (awalk_verts w (r @ q)) = set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>trail w q w; set q = set p;\n         set (awalk_verts w q) = set (awalk_verts u p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  p = q @ r\n  trail w (r @ q) w\n  set (awalk_verts w (r @ q)) = set (awalk_verts u p)", "have \"set (r @ q) = set p\""], ["proof (prove)\nusing this:\n  p = q @ r\n  trail w (r @ q) w\n  set (awalk_verts w (r @ q)) = set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. set (r @ q) = set p", "by auto"], ["proof (state)\nthis:\n  set (r @ q) = set p\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>trail w q w; set q = set p;\n         set (awalk_verts w q) = set (awalk_verts u p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "by (rule that) fact+"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sym_reachableI_in_awalk:\n  assumes walk: \"awalk u p v\" and\n    w1: \"w1 \\<in> set (awalk_verts u p)\" and w2: \"w2 \\<in> set (awalk_verts u p)\"\n  shows \"w1 \\<rightarrow>\\<^sup>*\\<^bsub>mk_symmetric G\\<^esub> w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w1 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> w2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. w1 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> w2", "from walk w1"], ["proof (chain)\npicking this:\n  awalk u p v\n  w1 \\<in> set (awalk_verts u p)", "obtain q r where \"p = q @ r\" \"awalk u q w1\" \"awalk w1 r v\""], ["proof (prove)\nusing this:\n  awalk u p v\n  w1 \\<in> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>p = q @ r; awalk u q w1; awalk w1 r v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (atomize_elim) (rule awalk_decomp)"], ["proof (state)\nthis:\n  p = q @ r\n  awalk u q w1\n  awalk w1 r v\n\ngoal (1 subgoal):\n 1. w1 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> w2", "then"], ["proof (chain)\npicking this:\n  p = q @ r\n  awalk u q w1\n  awalk w1 r v", "have w2_in: \"w2 \\<in> set (awalk_verts u q) \\<union> set (awalk_verts w1 r)\""], ["proof (prove)\nusing this:\n  p = q @ r\n  awalk u q w1\n  awalk w1 r v\n\ngoal (1 subgoal):\n 1. w2 \\<in> set (awalk_verts u q) \\<union> set (awalk_verts w1 r)", "using w2"], ["proof (prove)\nusing this:\n  p = q @ r\n  awalk u q w1\n  awalk w1 r v\n  w2 \\<in> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. w2 \\<in> set (awalk_verts u q) \\<union> set (awalk_verts w1 r)", "by (auto simp: set_awalk_verts_append)"], ["proof (state)\nthis:\n  w2 \\<in> set (awalk_verts u q) \\<union> set (awalk_verts w1 r)\n\ngoal (1 subgoal):\n 1. w1 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> w2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. w1 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> w2", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    w1 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> w2\n 2. \\<not> ?P \\<Longrightarrow>\n    w1 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> w2", "assume A: \"w2 \\<in> set (awalk_verts u q)\""], ["proof (state)\nthis:\n  w2 \\<in> set (awalk_verts u q)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    w1 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> w2\n 2. \\<not> ?P \\<Longrightarrow>\n    w1 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> w2", "obtain s where \"awalk w2 s w1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s. awalk w2 s w1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using awalk_decomp[OF \\<open>awalk u q w1\\<close> A]"], ["proof (prove)\nusing this:\n  \\<exists>qa r. q = qa @ r \\<and> awalk u qa w2 \\<and> awalk w2 r w1\n\ngoal (1 subgoal):\n 1. (\\<And>s. awalk w2 s w1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  awalk w2 s w1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    w1 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> w2\n 2. \\<not> ?P \\<Longrightarrow>\n    w1 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> w2", "then"], ["proof (chain)\npicking this:\n  awalk w2 s w1", "have \"w2 \\<rightarrow>\\<^sup>*\\<^bsub>mk_symmetric G\\<^esub> w1\""], ["proof (prove)\nusing this:\n  awalk w2 s w1\n\ngoal (1 subgoal):\n 1. w2 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> w1", "by (intro reachable_awalkI reachable_mk_symmetricI)"], ["proof (state)\nthis:\n  w2 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> w1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    w1 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> w2\n 2. \\<not> ?P \\<Longrightarrow>\n    w1 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> w2", "with symmetric_mk_symmetric"], ["proof (chain)\npicking this:\n  symmetric (with_proj (mk_symmetric ?G))\n  w2 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> w1", "show ?thesis"], ["proof (prove)\nusing this:\n  symmetric (with_proj (mk_symmetric ?G))\n  w2 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> w1\n\ngoal (1 subgoal):\n 1. w1 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> w2", "by (rule symmetric_reachable)"], ["proof (state)\nthis:\n  w1 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> w2\n\ngoal (1 subgoal):\n 1. w2 \\<notin> set (awalk_verts u q) \\<Longrightarrow>\n    w1 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> w2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. w2 \\<notin> set (awalk_verts u q) \\<Longrightarrow>\n    w1 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> w2", "assume \"w2 \\<notin> set (awalk_verts u q)\""], ["proof (state)\nthis:\n  w2 \\<notin> set (awalk_verts u q)\n\ngoal (1 subgoal):\n 1. w2 \\<notin> set (awalk_verts u q) \\<Longrightarrow>\n    w1 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> w2", "then"], ["proof (chain)\npicking this:\n  w2 \\<notin> set (awalk_verts u q)", "have A: \"w2 \\<in> set (awalk_verts w1 r)\""], ["proof (prove)\nusing this:\n  w2 \\<notin> set (awalk_verts u q)\n\ngoal (1 subgoal):\n 1. w2 \\<in> set (awalk_verts w1 r)", "using w2_in"], ["proof (prove)\nusing this:\n  w2 \\<notin> set (awalk_verts u q)\n  w2 \\<in> set (awalk_verts u q) \\<union> set (awalk_verts w1 r)\n\ngoal (1 subgoal):\n 1. w2 \\<in> set (awalk_verts w1 r)", "by blast"], ["proof (state)\nthis:\n  w2 \\<in> set (awalk_verts w1 r)\n\ngoal (1 subgoal):\n 1. w2 \\<notin> set (awalk_verts u q) \\<Longrightarrow>\n    w1 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> w2", "obtain s where \"awalk w1 s w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s. awalk w1 s w2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using awalk_decomp[OF \\<open>awalk w1 r v\\<close> A]"], ["proof (prove)\nusing this:\n  \\<exists>q ra. r = q @ ra \\<and> awalk w1 q w2 \\<and> awalk w2 ra v\n\ngoal (1 subgoal):\n 1. (\\<And>s. awalk w1 s w2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  awalk w1 s w2\n\ngoal (1 subgoal):\n 1. w2 \\<notin> set (awalk_verts u q) \\<Longrightarrow>\n    w1 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> w2", "then"], ["proof (chain)\npicking this:\n  awalk w1 s w2", "show \"w1 \\<rightarrow>\\<^sup>*\\<^bsub>mk_symmetric G\\<^esub> w2\""], ["proof (prove)\nusing this:\n  awalk w1 s w2\n\ngoal (1 subgoal):\n 1. w1 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> w2", "by (intro reachable_awalkI reachable_mk_symmetricI)"], ["proof (state)\nthis:\n  w1 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> w2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w1 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> w2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma euler_imp_connected:\n  assumes \"euler_trail u p v\" shows \"connected G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Digraph_Component.connected G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Digraph_Component.connected G", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. Digraph_Component.connected G", "have \"verts G \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. verts G \\<noteq> {}", "using assms"], ["proof (prove)\nusing this:\n  euler_trail u p v\n\ngoal (1 subgoal):\n 1. verts G \\<noteq> {}", "unfolding euler_trail_def trail_def"], ["proof (prove)\nusing this:\n  (awalk u p v \\<and> distinct p) \\<and>\n  set p = arcs G \\<and> set (awalk_verts u p) = verts G\n\ngoal (1 subgoal):\n 1. verts G \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  verts G \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Digraph_Component.connected G", "}"], ["proof (state)\nthis:\n  verts G \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Digraph_Component.connected G", "moreover"], ["proof (state)\nthis:\n  verts G \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Digraph_Component.connected G", "{"], ["proof (state)\nthis:\n  verts G \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Digraph_Component.connected G", "fix w1 w2"], ["proof (state)\ngoal (1 subgoal):\n 1. Digraph_Component.connected G", "assume \"w1 \\<in> verts G\" \"w2 \\<in> verts G\""], ["proof (state)\nthis:\n  w1 \\<in> verts G\n  w2 \\<in> verts G\n\ngoal (1 subgoal):\n 1. Digraph_Component.connected G", "then"], ["proof (chain)\npicking this:\n  w1 \\<in> verts G\n  w2 \\<in> verts G", "have \"awalk u p v \" \"w1 \\<in> set (awalk_verts u p)\" \"w2 \\<in> set (awalk_verts u p)\""], ["proof (prove)\nusing this:\n  w1 \\<in> verts G\n  w2 \\<in> verts G\n\ngoal (1 subgoal):\n 1. awalk u p v &&&\n    w1 \\<in> set (awalk_verts u p) &&& w2 \\<in> set (awalk_verts u p)", "using assms"], ["proof (prove)\nusing this:\n  w1 \\<in> verts G\n  w2 \\<in> verts G\n  euler_trail u p v\n\ngoal (1 subgoal):\n 1. awalk u p v &&&\n    w1 \\<in> set (awalk_verts u p) &&& w2 \\<in> set (awalk_verts u p)", "by (auto simp: euler_trail_def trail_def)"], ["proof (state)\nthis:\n  awalk u p v\n  w1 \\<in> set (awalk_verts u p)\n  w2 \\<in> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. Digraph_Component.connected G", "then"], ["proof (chain)\npicking this:\n  awalk u p v\n  w1 \\<in> set (awalk_verts u p)\n  w2 \\<in> set (awalk_verts u p)", "have \"w1 \\<rightarrow>\\<^sup>*\\<^bsub>mk_symmetric G\\<^esub> w2\""], ["proof (prove)\nusing this:\n  awalk u p v\n  w1 \\<in> set (awalk_verts u p)\n  w2 \\<in> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. w1 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> w2", "by (rule sym_reachableI_in_awalk)"], ["proof (state)\nthis:\n  w1 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> w2\n\ngoal (1 subgoal):\n 1. Digraph_Component.connected G", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?w1.4 \\<in> verts G; ?w2.4 \\<in> verts G\\<rbrakk>\n  \\<Longrightarrow> ?w1.4 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> ?w2.4\n\ngoal (1 subgoal):\n 1. Digraph_Component.connected G", "ultimately"], ["proof (chain)\npicking this:\n  verts G \\<noteq> {}\n  \\<lbrakk>?w1.4 \\<in> verts G; ?w2.4 \\<in> verts G\\<rbrakk>\n  \\<Longrightarrow> ?w1.4 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> ?w2.4", "show \"connected G\""], ["proof (prove)\nusing this:\n  verts G \\<noteq> {}\n  \\<lbrakk>?w1.4 \\<in> verts G; ?w2.4 \\<in> verts G\\<rbrakk>\n  \\<Longrightarrow> ?w1.4 \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> ?w2.4\n\ngoal (1 subgoal):\n 1. Digraph_Component.connected G", "by (rule connectedI)"], ["proof (state)\nthis:\n  Digraph_Component.connected G\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Arc Balance of Walks\\<close>"], ["", "context pre_digraph begin"], ["", "(* XXX change order of arguments? *)"], ["", "definition arc_set_balance :: \"'a \\<Rightarrow> 'b set \\<Rightarrow> int\" where\n  \"arc_set_balance w A = int (card (in_arcs G w \\<inter> A)) - int (card (out_arcs G w \\<inter> A))\""], ["", "definition  arc_set_balanced :: \"'a \\<Rightarrow> 'b set \\<Rightarrow> 'a \\<Rightarrow> bool\" where\n  \"arc_set_balanced u A v \\<equiv>\n      if u = v then (\\<forall>w \\<in> verts G. arc_set_balance w A = 0)\n      else (\\<forall>w \\<in> verts G. (w \\<noteq> u \\<and> w \\<noteq> v) \\<longrightarrow> arc_set_balance w A = 0)\n        \\<and> arc_set_balance u A = -1\n        \\<and> arc_set_balance v A = 1\""], ["", "abbreviation arc_balance :: \"'a \\<Rightarrow> 'b awalk \\<Rightarrow> int\" where\n  \"arc_balance w p \\<equiv> arc_set_balance w (set p)\""], ["", "abbreviation arc_balanced :: \"'a \\<Rightarrow> 'b awalk \\<Rightarrow> 'a \\<Rightarrow> bool\" where\n  \"arc_balanced u p v \\<equiv> arc_set_balanced u (set p) v\""], ["", "lemma arc_set_balanced_all:\n  \"arc_set_balanced u (arcs G) v =\n      (if u = v then (\\<forall>w \\<in> verts G. in_degree G w = out_degree G w)\n      else (\\<forall>w \\<in> verts G. (w \\<noteq> u \\<and> w \\<noteq> v) \\<longrightarrow> in_degree G w = out_degree G w)\n        \\<and> in_degree G u + 1 = out_degree G u\n        \\<and> out_degree G v + 1 = in_degree G v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arc_set_balanced u (arcs G) v =\n    (if u = v then \\<forall>w\\<in>verts G. in_degree G w = out_degree G w\n     else (\\<forall>w\\<in>verts G.\n              w \\<noteq> u \\<and> w \\<noteq> v \\<longrightarrow>\n              in_degree G w = out_degree G w) \\<and>\n          in_degree G u + 1 = out_degree G u \\<and>\n          out_degree G v + 1 = in_degree G v)", "unfolding arc_set_balanced_def arc_set_balance_def in_degree_def out_degree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if u = v\n     then \\<forall>w\\<in>verts G.\n             int (card (in_arcs G w \\<inter> arcs G)) -\n             int (card (out_arcs G w \\<inter> arcs G)) =\n             0\n     else (\\<forall>w\\<in>verts G.\n              w \\<noteq> u \\<and> w \\<noteq> v \\<longrightarrow>\n              int (card (in_arcs G w \\<inter> arcs G)) -\n              int (card (out_arcs G w \\<inter> arcs G)) =\n              0) \\<and>\n          int (card (in_arcs G u \\<inter> arcs G)) -\n          int (card (out_arcs G u \\<inter> arcs G)) =\n          - 1 \\<and>\n          int (card (in_arcs G v \\<inter> arcs G)) -\n          int (card (out_arcs G v \\<inter> arcs G)) =\n          1) =\n    (if u = v\n     then \\<forall>w\\<in>verts G. card (in_arcs G w) = card (out_arcs G w)\n     else (\\<forall>w\\<in>verts G.\n              w \\<noteq> u \\<and> w \\<noteq> v \\<longrightarrow>\n              card (in_arcs G w) = card (out_arcs G w)) \\<and>\n          card (in_arcs G u) + 1 = card (out_arcs G u) \\<and>\n          card (out_arcs G v) + 1 = card (in_arcs G v))", "by auto"], ["", "end"], ["", "context wf_digraph begin"], ["", "(* XXX tune assumption? e \\<notin> set es oder so? *)"], ["", "lemma arc_balance_Cons:\n  assumes \"trail u (e # es) v\"\n  shows \"arc_set_balance w (insert e (set es)) = arc_set_balance w {e} + arc_balance w es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arc_set_balance w (insert e (set es)) =\n    arc_set_balance w {e} + arc_balance w es", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. arc_set_balance w (insert e (set es)) =\n    arc_set_balance w {e} + arc_balance w es", "from assms"], ["proof (chain)\npicking this:\n  trail u (e # es) v", "have \"e \\<notin> set es\" \"e \\<in> arcs G\""], ["proof (prove)\nusing this:\n  trail u (e # es) v\n\ngoal (1 subgoal):\n 1. e \\<notin> set es &&& e \\<in> arcs G", "by (auto simp: trail_def)"], ["proof (state)\nthis:\n  e \\<notin> set es\n  e \\<in> arcs G\n\ngoal (1 subgoal):\n 1. arc_set_balance w (insert e (set es)) =\n    arc_set_balance w {e} + arc_balance w es", "with \\<open>e \\<notin> set es\\<close>"], ["proof (chain)\npicking this:\n  e \\<notin> set es\n  e \\<notin> set es\n  e \\<in> arcs G", "show ?thesis"], ["proof (prove)\nusing this:\n  e \\<notin> set es\n  e \\<notin> set es\n  e \\<in> arcs G\n\ngoal (1 subgoal):\n 1. arc_set_balance w (insert e (set es)) =\n    arc_set_balance w {e} + arc_balance w es", "apply (cases \"w = tail G e\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>e \\<notin> set es; e \\<notin> set es; e \\<in> arcs G;\n     w = tail G e\\<rbrakk>\n    \\<Longrightarrow> arc_set_balance w (insert e (set es)) =\n                      arc_set_balance w {e} + arc_balance w es\n 2. \\<lbrakk>e \\<notin> set es; e \\<notin> set es; e \\<in> arcs G;\n     w \\<noteq> tail G e\\<rbrakk>\n    \\<Longrightarrow> arc_set_balance w (insert e (set es)) =\n                      arc_set_balance w {e} + arc_balance w es", "apply (case_tac [!] \"w = head G e\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>e \\<notin> set es; e \\<notin> set es; e \\<in> arcs G;\n     w = tail G e; w = head G e\\<rbrakk>\n    \\<Longrightarrow> arc_set_balance w (insert e (set es)) =\n                      arc_set_balance w {e} + arc_balance w es\n 2. \\<lbrakk>e \\<notin> set es; e \\<notin> set es; e \\<in> arcs G;\n     w = tail G e; w \\<noteq> head G e\\<rbrakk>\n    \\<Longrightarrow> arc_set_balance w (insert e (set es)) =\n                      arc_set_balance w {e} + arc_balance w es\n 3. \\<lbrakk>e \\<notin> set es; e \\<notin> set es; e \\<in> arcs G;\n     w \\<noteq> tail G e; w = head G e\\<rbrakk>\n    \\<Longrightarrow> arc_set_balance w (insert e (set es)) =\n                      arc_set_balance w {e} + arc_balance w es\n 4. \\<lbrakk>e \\<notin> set es; e \\<notin> set es; e \\<in> arcs G;\n     w \\<noteq> tail G e; w \\<noteq> head G e\\<rbrakk>\n    \\<Longrightarrow> arc_set_balance w (insert e (set es)) =\n                      arc_set_balance w {e} + arc_balance w es", "apply (auto simp: arc_set_balance_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  arc_set_balance w (insert e (set es)) =\n  arc_set_balance w {e} + arc_balance w es\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arc_balancedI_trail:\n  assumes \"trail u p v\" shows \"arc_balanced u p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arc_balanced u p v", "using assms"], ["proof (prove)\nusing this:\n  trail u p v\n\ngoal (1 subgoal):\n 1. arc_balanced u p v", "proof (induct p arbitrary: u)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u. trail u [] v \\<Longrightarrow> arc_balanced u [] v\n 2. \\<And>a p u.\n       \\<lbrakk>\\<And>u. trail u p v \\<Longrightarrow> arc_balanced u p v;\n        trail u (a # p) v\\<rbrakk>\n       \\<Longrightarrow> arc_balanced u (a # p) v", "case Nil"], ["proof (state)\nthis:\n  trail u [] v\n\ngoal (2 subgoals):\n 1. \\<And>u. trail u [] v \\<Longrightarrow> arc_balanced u [] v\n 2. \\<And>a p u.\n       \\<lbrakk>\\<And>u. trail u p v \\<Longrightarrow> arc_balanced u p v;\n        trail u (a # p) v\\<rbrakk>\n       \\<Longrightarrow> arc_balanced u (a # p) v", "then"], ["proof (chain)\npicking this:\n  trail u [] v", "show ?case"], ["proof (prove)\nusing this:\n  trail u [] v\n\ngoal (1 subgoal):\n 1. arc_balanced u [] v", "by (auto simp: arc_set_balanced_def arc_set_balance_def trail_def)"], ["proof (state)\nthis:\n  arc_balanced u [] v\n\ngoal (1 subgoal):\n 1. \\<And>a p u.\n       \\<lbrakk>\\<And>u. trail u p v \\<Longrightarrow> arc_balanced u p v;\n        trail u (a # p) v\\<rbrakk>\n       \\<Longrightarrow> arc_balanced u (a # p) v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p u.\n       \\<lbrakk>\\<And>u. trail u p v \\<Longrightarrow> arc_balanced u p v;\n        trail u (a # p) v\\<rbrakk>\n       \\<Longrightarrow> arc_balanced u (a # p) v", "case (Cons e es)"], ["proof (state)\nthis:\n  trail ?u2 es v \\<Longrightarrow> arc_balanced ?u2 es v\n  trail u (e # es) v\n\ngoal (1 subgoal):\n 1. \\<And>a p u.\n       \\<lbrakk>\\<And>u. trail u p v \\<Longrightarrow> arc_balanced u p v;\n        trail u (a # p) v\\<rbrakk>\n       \\<Longrightarrow> arc_balanced u (a # p) v", "then"], ["proof (chain)\npicking this:\n  trail ?u2 es v \\<Longrightarrow> arc_balanced ?u2 es v\n  trail u (e # es) v", "have \"arc_balanced (head G e) es v\" \"u = tail G e\" \"e \\<in> arcs G\""], ["proof (prove)\nusing this:\n  trail ?u2 es v \\<Longrightarrow> arc_balanced ?u2 es v\n  trail u (e # es) v\n\ngoal (1 subgoal):\n 1. arc_balanced (head G e) es v &&& u = tail G e &&& e \\<in> arcs G", "by (auto simp: awalk_Cons_iff trail_def)"], ["proof (state)\nthis:\n  arc_balanced (head G e) es v\n  u = tail G e\n  e \\<in> arcs G\n\ngoal (1 subgoal):\n 1. \\<And>a p u.\n       \\<lbrakk>\\<And>u. trail u p v \\<Longrightarrow> arc_balanced u p v;\n        trail u (a # p) v\\<rbrakk>\n       \\<Longrightarrow> arc_balanced u (a # p) v", "moreover"], ["proof (state)\nthis:\n  arc_balanced (head G e) es v\n  u = tail G e\n  e \\<in> arcs G\n\ngoal (1 subgoal):\n 1. \\<And>a p u.\n       \\<lbrakk>\\<And>u. trail u p v \\<Longrightarrow> arc_balanced u p v;\n        trail u (a # p) v\\<rbrakk>\n       \\<Longrightarrow> arc_balanced u (a # p) v", "have \"\\<And>w. arc_balance w [e] = (if w = tail G e \\<and> tail G e \\<noteq> head G e then -1\n      else if w = head G e \\<and> tail G e \\<noteq> head G e then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w.\n       arc_balance w [e] =\n       (if w = tail G e \\<and> tail G e \\<noteq> head G e then - 1\n        else if w = head G e \\<and> tail G e \\<noteq> head G e then 1\n             else 0)", "using \\<open>e \\<in> _\\<close>"], ["proof (prove)\nusing this:\n  e \\<in> arcs G\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       arc_balance w [e] =\n       (if w = tail G e \\<and> tail G e \\<noteq> head G e then - 1\n        else if w = head G e \\<and> tail G e \\<noteq> head G e then 1\n             else 0)", "by (case_tac \"w = tail G e\") (auto simp: arc_set_balance_def)"], ["proof (state)\nthis:\n  arc_balance ?w2 [e] =\n  (if ?w2 = tail G e \\<and> tail G e \\<noteq> head G e then - 1\n   else if ?w2 = head G e \\<and> tail G e \\<noteq> head G e then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<And>a p u.\n       \\<lbrakk>\\<And>u. trail u p v \\<Longrightarrow> arc_balanced u p v;\n        trail u (a # p) v\\<rbrakk>\n       \\<Longrightarrow> arc_balanced u (a # p) v", "ultimately"], ["proof (chain)\npicking this:\n  arc_balanced (head G e) es v\n  u = tail G e\n  e \\<in> arcs G\n  arc_balance ?w2 [e] =\n  (if ?w2 = tail G e \\<and> tail G e \\<noteq> head G e then - 1\n   else if ?w2 = head G e \\<and> tail G e \\<noteq> head G e then 1 else 0)", "show ?case"], ["proof (prove)\nusing this:\n  arc_balanced (head G e) es v\n  u = tail G e\n  e \\<in> arcs G\n  arc_balance ?w2 [e] =\n  (if ?w2 = tail G e \\<and> tail G e \\<noteq> head G e then - 1\n   else if ?w2 = head G e \\<and> tail G e \\<noteq> head G e then 1 else 0)\n\ngoal (1 subgoal):\n 1. arc_balanced u (e # es) v", "by (auto simp: arc_set_balanced_def arc_balance_Cons[OF \\<open>trail u _ _\\<close>])"], ["proof (state)\nthis:\n  arc_balanced u (e # es) v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trail_arc_balanceE:\n  assumes \"trail u p v\"\n  obtains \"\\<And>w. \\<lbrakk> u = v \\<or> (w \\<noteq> u \\<and> w \\<noteq> v); w \\<in> verts G \\<rbrakk>\n      \\<Longrightarrow> arc_balance w p = 0\"\n    and \"\\<lbrakk> u \\<noteq> v \\<rbrakk> \\<Longrightarrow> arc_balance u p = - 1\"\n    and \"\\<lbrakk> u \\<noteq> v \\<rbrakk> \\<Longrightarrow> arc_balance v p = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<And>w.\n                 \\<lbrakk>u = v \\<or> w \\<noteq> u \\<and> w \\<noteq> v;\n                  w \\<in> verts G\\<rbrakk>\n                 \\<Longrightarrow> arc_balance w p = 0;\n      u \\<noteq> v \\<Longrightarrow> arc_balance u p = - 1;\n      u \\<noteq> v \\<Longrightarrow> arc_balance v p = 1\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using arc_balancedI_trail[OF assms]"], ["proof (prove)\nusing this:\n  arc_balanced u p v\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<And>w.\n                 \\<lbrakk>u = v \\<or> w \\<noteq> u \\<and> w \\<noteq> v;\n                  w \\<in> verts G\\<rbrakk>\n                 \\<Longrightarrow> arc_balance w p = 0;\n      u \\<noteq> v \\<Longrightarrow> arc_balance u p = - 1;\n      u \\<noteq> v \\<Longrightarrow> arc_balance v p = 1\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding arc_set_balanced_def"], ["proof (prove)\nusing this:\n  if u = v then \\<forall>w\\<in>verts G. arc_balance w p = 0\n  else (\\<forall>w\\<in>verts G.\n           w \\<noteq> u \\<and> w \\<noteq> v \\<longrightarrow>\n           arc_balance w p = 0) \\<and>\n       arc_balance u p = - 1 \\<and> arc_balance v p = 1\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<And>w.\n                 \\<lbrakk>u = v \\<or> w \\<noteq> u \\<and> w \\<noteq> v;\n                  w \\<in> verts G\\<rbrakk>\n                 \\<Longrightarrow> arc_balance w p = 0;\n      u \\<noteq> v \\<Longrightarrow> arc_balance u p = - 1;\n      u \\<noteq> v \\<Longrightarrow> arc_balance v p = 1\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (intro that) (metis,presburger+)"], ["", "end"], ["", "subsection \\<open>Closed Euler Trails\\<close>"], ["", "lemma (in wf_digraph) awalk_vertex_props:\n  assumes \"awalk u p v\" \"p \\<noteq> []\"\n  assumes \"\\<And>w. w \\<in> set (awalk_verts u p) \\<Longrightarrow> P w \\<or> Q w\"\n  assumes \"P u\" \"Q v\"\n  shows \"\\<exists>e \\<in> set p. P (tail G e) \\<and> Q (head G e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>set p. P (tail G e) \\<and> Q (head G e)", "using assms(2,1,3-)"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  awalk u p v\n  ?w2 \\<in> set (awalk_verts u p) \\<Longrightarrow> P ?w2 \\<or> Q ?w2\n  P u\n  Q v\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>set p. P (tail G e) \\<and> Q (head G e)", "proof (induct p arbitrary: u rule: list_nonempty_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x u.\n       \\<lbrakk>awalk u [x] v;\n        \\<And>w.\n           w \\<in> set (awalk_verts u [x]) \\<Longrightarrow> P w \\<or> Q w;\n        P u; Q v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e\\<in>set [x].\n                            P (tail G e) \\<and> Q (head G e)\n 2. \\<And>x xs u.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>u.\n           \\<lbrakk>awalk u xs v;\n            \\<And>w.\n               w \\<in> set (awalk_verts u xs) \\<Longrightarrow>\n               P w \\<or> Q w;\n            P u; Q v\\<rbrakk>\n           \\<Longrightarrow> \\<exists>e\\<in>set xs.\n                                P (tail G e) \\<and> Q (head G e);\n        awalk u (x # xs) v;\n        \\<And>w.\n           w \\<in> set (awalk_verts u (x # xs)) \\<Longrightarrow>\n           P w \\<or> Q w;\n        P u; Q v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e\\<in>set (x # xs).\n                            P (tail G e) \\<and> Q (head G e)", "case (cons e es)"], ["proof (state)\nthis:\n  es \\<noteq> []\n  \\<lbrakk>awalk ?u2 es v;\n   \\<And>w.\n      w \\<in> set (awalk_verts ?u2 es) \\<Longrightarrow> P w \\<or> Q w;\n   P ?u2; Q v\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e\\<in>set es. P (tail G e) \\<and> Q (head G e)\n  awalk u (e # es) v\n  ?w2 \\<in> set (awalk_verts u (e # es)) \\<Longrightarrow> P ?w2 \\<or> Q ?w2\n  P u\n  Q v\n\ngoal (2 subgoals):\n 1. \\<And>x u.\n       \\<lbrakk>awalk u [x] v;\n        \\<And>w.\n           w \\<in> set (awalk_verts u [x]) \\<Longrightarrow> P w \\<or> Q w;\n        P u; Q v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e\\<in>set [x].\n                            P (tail G e) \\<and> Q (head G e)\n 2. \\<And>x xs u.\n       \\<lbrakk>xs \\<noteq> [];\n        \\<And>u.\n           \\<lbrakk>awalk u xs v;\n            \\<And>w.\n               w \\<in> set (awalk_verts u xs) \\<Longrightarrow>\n               P w \\<or> Q w;\n            P u; Q v\\<rbrakk>\n           \\<Longrightarrow> \\<exists>e\\<in>set xs.\n                                P (tail G e) \\<and> Q (head G e);\n        awalk u (x # xs) v;\n        \\<And>w.\n           w \\<in> set (awalk_verts u (x # xs)) \\<Longrightarrow>\n           P w \\<or> Q w;\n        P u; Q v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e\\<in>set (x # xs).\n                            P (tail G e) \\<and> Q (head G e)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>set (e # es). P (tail G e) \\<and> Q (head G e)", "proof (cases \"P (tail G e) \\<and> Q (head G e)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. P (tail G e) \\<and> Q (head G e) \\<Longrightarrow>\n    \\<exists>e\\<in>set (e # es). P (tail G e) \\<and> Q (head G e)\n 2. \\<not> (P (tail G e) \\<and> Q (head G e)) \\<Longrightarrow>\n    \\<exists>e\\<in>set (e # es). P (tail G e) \\<and> Q (head G e)", "case False"], ["proof (state)\nthis:\n  \\<not> (P (tail G e) \\<and> Q (head G e))\n\ngoal (2 subgoals):\n 1. P (tail G e) \\<and> Q (head G e) \\<Longrightarrow>\n    \\<exists>e\\<in>set (e # es). P (tail G e) \\<and> Q (head G e)\n 2. \\<not> (P (tail G e) \\<and> Q (head G e)) \\<Longrightarrow>\n    \\<exists>e\\<in>set (e # es). P (tail G e) \\<and> Q (head G e)", "then"], ["proof (chain)\npicking this:\n  \\<not> (P (tail G e) \\<and> Q (head G e))", "have \"P (head G e) \\<or> Q (head G e)\""], ["proof (prove)\nusing this:\n  \\<not> (P (tail G e) \\<and> Q (head G e))\n\ngoal (1 subgoal):\n 1. P (head G e) \\<or> Q (head G e)", "using cons.prems(1) cons.prems(2)[of \"head G e\"]"], ["proof (prove)\nusing this:\n  \\<not> (P (tail G e) \\<and> Q (head G e))\n  awalk u (e # es) v\n  head G e \\<in> set (awalk_verts u (e # es)) \\<Longrightarrow>\n  P (head G e) \\<or> Q (head G e)\n\ngoal (1 subgoal):\n 1. P (head G e) \\<or> Q (head G e)", "by (auto simp: awalk_Cons_iff set_awalk_verts)"], ["proof (state)\nthis:\n  P (head G e) \\<or> Q (head G e)\n\ngoal (2 subgoals):\n 1. P (tail G e) \\<and> Q (head G e) \\<Longrightarrow>\n    \\<exists>e\\<in>set (e # es). P (tail G e) \\<and> Q (head G e)\n 2. \\<not> (P (tail G e) \\<and> Q (head G e)) \\<Longrightarrow>\n    \\<exists>e\\<in>set (e # es). P (tail G e) \\<and> Q (head G e)", "then"], ["proof (chain)\npicking this:\n  P (head G e) \\<or> Q (head G e)", "have \"P (tail G e) \\<and> P (head G e)\""], ["proof (prove)\nusing this:\n  P (head G e) \\<or> Q (head G e)\n\ngoal (1 subgoal):\n 1. P (tail G e) \\<and> P (head G e)", "using False"], ["proof (prove)\nusing this:\n  P (head G e) \\<or> Q (head G e)\n  \\<not> (P (tail G e) \\<and> Q (head G e))\n\ngoal (1 subgoal):\n 1. P (tail G e) \\<and> P (head G e)", "using cons.prems(1,3)"], ["proof (prove)\nusing this:\n  P (head G e) \\<or> Q (head G e)\n  \\<not> (P (tail G e) \\<and> Q (head G e))\n  awalk u (e # es) v\n  P u\n\ngoal (1 subgoal):\n 1. P (tail G e) \\<and> P (head G e)", "by auto"], ["proof (state)\nthis:\n  P (tail G e) \\<and> P (head G e)\n\ngoal (2 subgoals):\n 1. P (tail G e) \\<and> Q (head G e) \\<Longrightarrow>\n    \\<exists>e\\<in>set (e # es). P (tail G e) \\<and> Q (head G e)\n 2. \\<not> (P (tail G e) \\<and> Q (head G e)) \\<Longrightarrow>\n    \\<exists>e\\<in>set (e # es). P (tail G e) \\<and> Q (head G e)", "then"], ["proof (chain)\npicking this:\n  P (tail G e) \\<and> P (head G e)", "have \"\\<exists>e \\<in> set es. P (tail G e) \\<and> Q (head G e)\""], ["proof (prove)\nusing this:\n  P (tail G e) \\<and> P (head G e)\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>set es. P (tail G e) \\<and> Q (head G e)", "using cons"], ["proof (prove)\nusing this:\n  P (tail G e) \\<and> P (head G e)\n  es \\<noteq> []\n  \\<lbrakk>awalk ?u2 es v;\n   \\<And>w.\n      w \\<in> set (awalk_verts ?u2 es) \\<Longrightarrow> P w \\<or> Q w;\n   P ?u2; Q v\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e\\<in>set es. P (tail G e) \\<and> Q (head G e)\n  awalk u (e # es) v\n  ?w2 \\<in> set (awalk_verts u (e # es)) \\<Longrightarrow> P ?w2 \\<or> Q ?w2\n  P u\n  Q v\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>set es. P (tail G e) \\<and> Q (head G e)", "by (auto intro: cons simp: awalk_Cons_iff)"], ["proof (state)\nthis:\n  \\<exists>e\\<in>set es. P (tail G e) \\<and> Q (head G e)\n\ngoal (2 subgoals):\n 1. P (tail G e) \\<and> Q (head G e) \\<Longrightarrow>\n    \\<exists>e\\<in>set (e # es). P (tail G e) \\<and> Q (head G e)\n 2. \\<not> (P (tail G e) \\<and> Q (head G e)) \\<Longrightarrow>\n    \\<exists>e\\<in>set (e # es). P (tail G e) \\<and> Q (head G e)", "then"], ["proof (chain)\npicking this:\n  \\<exists>e\\<in>set es. P (tail G e) \\<and> Q (head G e)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>e\\<in>set es. P (tail G e) \\<and> Q (head G e)\n\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>set (e # es). P (tail G e) \\<and> Q (head G e)", "by auto"], ["proof (state)\nthis:\n  \\<exists>e\\<in>set (e # es). P (tail G e) \\<and> Q (head G e)\n\ngoal (1 subgoal):\n 1. P (tail G e) \\<and> Q (head G e) \\<Longrightarrow>\n    \\<exists>e\\<in>set (e # es). P (tail G e) \\<and> Q (head G e)", "qed auto"], ["proof (state)\nthis:\n  \\<exists>e\\<in>set (e # es). P (tail G e) \\<and> Q (head G e)\n\ngoal (1 subgoal):\n 1. \\<And>x u.\n       \\<lbrakk>awalk u [x] v;\n        \\<And>w.\n           w \\<in> set (awalk_verts u [x]) \\<Longrightarrow> P w \\<or> Q w;\n        P u; Q v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e\\<in>set [x].\n                            P (tail G e) \\<and> Q (head G e)", "qed (simp add: awalk_simps)"], ["", "lemma (in wf_digraph) connected_verts:\n  assumes \"connected G\" \"arcs G \\<noteq> {}\"\n  shows \"verts G = tail G ` arcs G \\<union> head G ` arcs G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "assume \"verts G = {}\""], ["proof (state)\nthis:\n  verts G = {}\n\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "then"], ["proof (chain)\npicking this:\n  verts G = {}", "have ?thesis"], ["proof (prove)\nusing this:\n  verts G = {}\n\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "by (auto dest: tail_in_verts)"], ["proof (state)\nthis:\n  verts G = tail G ` arcs G \\<union> head G ` arcs G\n\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "}"], ["proof (state)\nthis:\n  verts G = {} \\<Longrightarrow>\n  verts G = tail G ` arcs G \\<union> head G ` arcs G\n\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "moreover"], ["proof (state)\nthis:\n  verts G = {} \\<Longrightarrow>\n  verts G = tail G ` arcs G \\<union> head G ` arcs G\n\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "{"], ["proof (state)\nthis:\n  verts G = {} \\<Longrightarrow>\n  verts G = tail G ` arcs G \\<union> head G ` arcs G\n\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "assume \"\\<exists>v. verts G = {v}\""], ["proof (state)\nthis:\n  \\<exists>v. verts G = {v}\n\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "then"], ["proof (chain)\npicking this:\n  \\<exists>v. verts G = {v}", "obtain v where \"verts G = {v}\""], ["proof (prove)\nusing this:\n  \\<exists>v. verts G = {v}\n\ngoal (1 subgoal):\n 1. (\\<And>v. verts G = {v} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: card_Suc_eq)"], ["proof (state)\nthis:\n  verts G = {v}\n\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "moreover"], ["proof (state)\nthis:\n  verts G = {v}\n\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "with \\<open>arcs G \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  arcs G \\<noteq> {}\n  verts G = {v}", "obtain e where \"e \\<in> arcs G\" \"tail G e = v\" \"head G e = v\""], ["proof (prove)\nusing this:\n  arcs G \\<noteq> {}\n  verts G = {v}\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>e \\<in> arcs G; tail G e = v; head G e = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: tail_in_verts head_in_verts)"], ["proof (state)\nthis:\n  e \\<in> arcs G\n  tail G e = v\n  head G e = v\n\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "moreover"], ["proof (state)\nthis:\n  e \\<in> arcs G\n  tail G e = v\n  head G e = v\n\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "have \"tail G ` arcs G \\<union> head G ` arcs G \\<subseteq> verts G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tail G ` arcs G \\<union> head G ` arcs G \\<subseteq> verts G", "by auto"], ["proof (state)\nthis:\n  tail G ` arcs G \\<union> head G ` arcs G \\<subseteq> verts G\n\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "ultimately"], ["proof (chain)\npicking this:\n  verts G = {v}\n  e \\<in> arcs G\n  tail G e = v\n  head G e = v\n  tail G ` arcs G \\<union> head G ` arcs G \\<subseteq> verts G", "have ?thesis"], ["proof (prove)\nusing this:\n  verts G = {v}\n  e \\<in> arcs G\n  tail G e = v\n  head G e = v\n  tail G ` arcs G \\<union> head G ` arcs G \\<subseteq> verts G\n\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "by auto"], ["proof (state)\nthis:\n  verts G = tail G ` arcs G \\<union> head G ` arcs G\n\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "}"], ["proof (state)\nthis:\n  \\<exists>v. verts G = {v} \\<Longrightarrow>\n  verts G = tail G ` arcs G \\<union> head G ` arcs G\n\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "moreover"], ["proof (state)\nthis:\n  \\<exists>v. verts G = {v} \\<Longrightarrow>\n  verts G = tail G ` arcs G \\<union> head G ` arcs G\n\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "{"], ["proof (state)\nthis:\n  \\<exists>v. verts G = {v} \\<Longrightarrow>\n  verts G = tail G ` arcs G \\<union> head G ` arcs G\n\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "assume A: \"\\<exists>u v. u \\<in> verts G \\<and> v \\<in> verts G \\<and> u \\<noteq> v\""], ["proof (state)\nthis:\n  \\<exists>u v. u \\<in> verts G \\<and> v \\<in> verts G \\<and> u \\<noteq> v\n\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "{"], ["proof (state)\nthis:\n  \\<exists>u v. u \\<in> verts G \\<and> v \\<in> verts G \\<and> u \\<noteq> v\n\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "assume \"u \\<in> verts G\""], ["proof (state)\nthis:\n  u \\<in> verts G\n\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "interpret S: pair_wf_digraph \"mk_symmetric G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_wf_digraph (mk_symmetric G)", "by rule"], ["proof (state)\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "from A"], ["proof (chain)\npicking this:\n  \\<exists>u v. u \\<in> verts G \\<and> v \\<in> verts G \\<and> u \\<noteq> v", "obtain v where \"v \\<in> verts G\" \"u \\<noteq> v\""], ["proof (prove)\nusing this:\n  \\<exists>u v. u \\<in> verts G \\<and> v \\<in> verts G \\<and> u \\<noteq> v\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> verts G; u \\<noteq> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v \\<in> verts G\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "then"], ["proof (chain)\npicking this:\n  v \\<in> verts G\n  u \\<noteq> v", "obtain p where \"S.awalk u p v\""], ["proof (prove)\nusing this:\n  v \\<in> verts G\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. (\\<And>p. S.awalk u p v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>connected G\\<close> \\<open>u \\<in> verts G\\<close>"], ["proof (prove)\nusing this:\n  v \\<in> verts G\n  u \\<noteq> v\n  Digraph_Component.connected G\n  u \\<in> verts G\n\ngoal (1 subgoal):\n 1. (\\<And>p. S.awalk u p v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: connected_awalkE)"], ["proof (state)\nthis:\n  S.awalk u p v\n\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "with \\<open>u \\<noteq> v\\<close>"], ["proof (chain)\npicking this:\n  u \\<noteq> v\n  S.awalk u p v", "obtain e where \"e \\<in> parcs (mk_symmetric G)\" \"fst e = u\""], ["proof (prove)\nusing this:\n  u \\<noteq> v\n  S.awalk u p v\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>e \\<in> parcs (mk_symmetric G); fst e = u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis S.awalk_Cons_iff S.awalk_empty_ends list_exhaust2)"], ["proof (state)\nthis:\n  e \\<in> parcs (mk_symmetric G)\n  fst e = u\n\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "then"], ["proof (chain)\npicking this:\n  e \\<in> parcs (mk_symmetric G)\n  fst e = u", "obtain e' where \"tail G e' = u \\<or> head G e' = u\" \"e' \\<in> arcs G\""], ["proof (prove)\nusing this:\n  e \\<in> parcs (mk_symmetric G)\n  fst e = u\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>tail G e' = u \\<or> head G e' = u; e' \\<in> arcs G\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (force simp: parcs_mk_symmetric)"], ["proof (state)\nthis:\n  tail G e' = u \\<or> head G e' = u\n  e' \\<in> arcs G\n\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "then"], ["proof (chain)\npicking this:\n  tail G e' = u \\<or> head G e' = u\n  e' \\<in> arcs G", "have \"u \\<in> tail G ` arcs G \\<union> head G `arcs G\""], ["proof (prove)\nusing this:\n  tail G e' = u \\<or> head G e' = u\n  e' \\<in> arcs G\n\ngoal (1 subgoal):\n 1. u \\<in> tail G ` arcs G \\<union> head G ` arcs G", "by auto"], ["proof (state)\nthis:\n  u \\<in> tail G ` arcs G \\<union> head G ` arcs G\n\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "}"], ["proof (state)\nthis:\n  ?u4 \\<in> verts G \\<Longrightarrow>\n  ?u4 \\<in> tail G ` arcs G \\<union> head G ` arcs G\n\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "then"], ["proof (chain)\npicking this:\n  ?u4 \\<in> verts G \\<Longrightarrow>\n  ?u4 \\<in> tail G ` arcs G \\<union> head G ` arcs G", "have ?thesis"], ["proof (prove)\nusing this:\n  ?u4 \\<in> verts G \\<Longrightarrow>\n  ?u4 \\<in> tail G ` arcs G \\<union> head G ` arcs G\n\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "by auto"], ["proof (state)\nthis:\n  verts G = tail G ` arcs G \\<union> head G ` arcs G\n\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "}"], ["proof (state)\nthis:\n  \\<exists>u v.\n     u \\<in> verts G \\<and>\n     v \\<in> verts G \\<and> u \\<noteq> v \\<Longrightarrow>\n  verts G = tail G ` arcs G \\<union> head G ` arcs G\n\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "ultimately"], ["proof (chain)\npicking this:\n  verts G = {} \\<Longrightarrow>\n  verts G = tail G ` arcs G \\<union> head G ` arcs G\n  \\<exists>v. verts G = {v} \\<Longrightarrow>\n  verts G = tail G ` arcs G \\<union> head G ` arcs G\n  \\<exists>u v.\n     u \\<in> verts G \\<and>\n     v \\<in> verts G \\<and> u \\<noteq> v \\<Longrightarrow>\n  verts G = tail G ` arcs G \\<union> head G ` arcs G", "show ?thesis"], ["proof (prove)\nusing this:\n  verts G = {} \\<Longrightarrow>\n  verts G = tail G ` arcs G \\<union> head G ` arcs G\n  \\<exists>v. verts G = {v} \\<Longrightarrow>\n  verts G = tail G ` arcs G \\<union> head G ` arcs G\n  \\<exists>u v.\n     u \\<in> verts G \\<and>\n     v \\<in> verts G \\<and> u \\<noteq> v \\<Longrightarrow>\n  verts G = tail G ` arcs G \\<union> head G ` arcs G\n\ngoal (1 subgoal):\n 1. verts G = tail G ` arcs G \\<union> head G ` arcs G", "by blast"], ["proof (state)\nthis:\n  verts G = tail G ` arcs G \\<union> head G ` arcs G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in wf_digraph) connected_arcs_empty:\n  assumes \"connected G\" \"arcs G = {}\" \"verts G \\<noteq> {}\" obtains v where \"verts G = {v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v. verts G = {v} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (atomize_elim, rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>v. verts G = {v} \\<Longrightarrow> False", "assume A: \"\\<not> (\\<exists>v. verts G = {v})\""], ["proof (state)\nthis:\n  \\<nexists>v. verts G = {v}\n\ngoal (1 subgoal):\n 1. \\<nexists>v. verts G = {v} \\<Longrightarrow> False", "interpret S: pair_wf_digraph \"mk_symmetric G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_wf_digraph (mk_symmetric G)", "by rule"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>v. verts G = {v} \\<Longrightarrow> False", "from \\<open>verts G \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  verts G \\<noteq> {}", "obtain u where \"u \\<in> verts G\""], ["proof (prove)\nusing this:\n  verts G \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>u. u \\<in> verts G \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u \\<in> verts G\n\ngoal (1 subgoal):\n 1. \\<nexists>v. verts G = {v} \\<Longrightarrow> False", "with A"], ["proof (chain)\npicking this:\n  \\<nexists>v. verts G = {v}\n  u \\<in> verts G", "obtain v where \"v \\<in> verts G\" \"u \\<noteq> v\""], ["proof (prove)\nusing this:\n  \\<nexists>v. verts G = {v}\n  u \\<in> verts G\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> verts G; u \\<noteq> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<in> verts G\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<nexists>v. verts G = {v} \\<Longrightarrow> False", "from \\<open>connected G\\<close> \\<open>u \\<in> verts G\\<close> \\<open>v \\<in> verts G\\<close>"], ["proof (chain)\npicking this:\n  Digraph_Component.connected G\n  u \\<in> verts G\n  v \\<in> verts G", "obtain p where \"S.awalk u p v\""], ["proof (prove)\nusing this:\n  Digraph_Component.connected G\n  u \\<in> verts G\n  v \\<in> verts G\n\ngoal (1 subgoal):\n 1. (\\<And>p. S.awalk u p v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>connected G\\<close> \\<open>u \\<in> verts G\\<close>"], ["proof (prove)\nusing this:\n  Digraph_Component.connected G\n  u \\<in> verts G\n  v \\<in> verts G\n  Digraph_Component.connected G\n  u \\<in> verts G\n\ngoal (1 subgoal):\n 1. (\\<And>p. S.awalk u p v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: connected_awalkE)"], ["proof (state)\nthis:\n  S.awalk u p v\n\ngoal (1 subgoal):\n 1. \\<nexists>v. verts G = {v} \\<Longrightarrow> False", "with \\<open>u \\<noteq> v\\<close>"], ["proof (chain)\npicking this:\n  u \\<noteq> v\n  S.awalk u p v", "obtain e where \"e \\<in> parcs (mk_symmetric G)\""], ["proof (prove)\nusing this:\n  u \\<noteq> v\n  S.awalk u p v\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        e \\<in> parcs (mk_symmetric G) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis S.awalk_Cons_iff S.awalk_empty_ends list_exhaust2)"], ["proof (state)\nthis:\n  e \\<in> parcs (mk_symmetric G)\n\ngoal (1 subgoal):\n 1. \\<nexists>v. verts G = {v} \\<Longrightarrow> False", "with \\<open>arcs G = {}\\<close>"], ["proof (chain)\npicking this:\n  arcs G = {}\n  e \\<in> parcs (mk_symmetric G)", "show False"], ["proof (prove)\nusing this:\n  arcs G = {}\n  e \\<in> parcs (mk_symmetric G)\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: parcs_mk_symmetric)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in wf_digraph) euler_trail_conv_connected:\n  assumes \"connected G\"\n  shows \"euler_trail u p v \\<longleftrightarrow> trail u p v \\<and> set p = arcs G\" (is \"?L \\<longleftrightarrow> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. euler_trail u p v = (trail u p v \\<and> set p = arcs G)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. euler_trail u p v \\<Longrightarrow> trail u p v \\<and> set p = arcs G\n 2. trail u p v \\<and> set p = arcs G \\<Longrightarrow> euler_trail u p v", "assume ?R"], ["proof (state)\nthis:\n  trail u p v \\<and> set p = arcs G\n\ngoal (2 subgoals):\n 1. euler_trail u p v \\<Longrightarrow> trail u p v \\<and> set p = arcs G\n 2. trail u p v \\<and> set p = arcs G \\<Longrightarrow> euler_trail u p v", "show ?L"], ["proof (prove)\ngoal (1 subgoal):\n 1. euler_trail u p v", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> euler_trail u p v\n 2. \\<not> ?P \\<Longrightarrow> euler_trail u p v", "assume \"p = []\""], ["proof (state)\nthis:\n  p = []\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> euler_trail u p v\n 2. \\<not> ?P \\<Longrightarrow> euler_trail u p v", "with assms \\<open>?R\\<close>"], ["proof (chain)\npicking this:\n  Digraph_Component.connected G\n  trail u p v \\<and> set p = arcs G\n  p = []", "show ?thesis"], ["proof (prove)\nusing this:\n  Digraph_Component.connected G\n  trail u p v \\<and> set p = arcs G\n  p = []\n\ngoal (1 subgoal):\n 1. euler_trail u p v", "by (auto simp: euler_trail_def trail_def awalk_def elim: connected_arcs_empty)"], ["proof (state)\nthis:\n  euler_trail u p v\n\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow> euler_trail u p v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow> euler_trail u p v", "assume \"p \\<noteq> []\""], ["proof (state)\nthis:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow> euler_trail u p v", "then"], ["proof (chain)\npicking this:\n  p \\<noteq> []", "have \"arcs G \\<noteq> {}\""], ["proof (prove)\nusing this:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. arcs G \\<noteq> {}", "using \\<open>?R\\<close>"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  trail u p v \\<and> set p = arcs G\n\ngoal (1 subgoal):\n 1. arcs G \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  arcs G \\<noteq> {}\n\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow> euler_trail u p v", "with assms \\<open>?R\\<close> \\<open>p \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  Digraph_Component.connected G\n  trail u p v \\<and> set p = arcs G\n  p \\<noteq> []\n  arcs G \\<noteq> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  Digraph_Component.connected G\n  trail u p v \\<and> set p = arcs G\n  p \\<noteq> []\n  arcs G \\<noteq> {}\n\ngoal (1 subgoal):\n 1. euler_trail u p v", "by (auto simp: euler_trail_def trail_def set_awalk_verts_not_Nil connected_verts)"], ["proof (state)\nthis:\n  euler_trail u p v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  euler_trail u p v\n\ngoal (1 subgoal):\n 1. euler_trail u p v \\<Longrightarrow> trail u p v \\<and> set p = arcs G", "qed (simp add: euler_trail_def)"], ["", "lemma (in wf_digraph) awalk_connected:\n  assumes \"connected G\" \"awalk u p v\" \"set p \\<noteq> arcs G\"\n  shows \"\\<exists>e. e \\<in> arcs G - set p \\<and> (tail G e \\<in> set (awalk_verts u p) \\<or> head G e \\<in> set (awalk_verts u p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> arcs G - set p \\<and>\n       (tail G e \\<in> set (awalk_verts u p) \\<or>\n        head G e \\<in> set (awalk_verts u p))", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>e.\n       e \\<in> arcs G - set p \\<and>\n       (tail G e \\<in> set (awalk_verts u p) \\<or>\n        head G e \\<in> set (awalk_verts u p)) \\<Longrightarrow>\n    False", "assume A: \"\\<not>?thesis\""], ["proof (state)\nthis:\n  \\<nexists>e.\n     e \\<in> arcs G - set p \\<and>\n     (tail G e \\<in> set (awalk_verts u p) \\<or>\n      head G e \\<in> set (awalk_verts u p))\n\ngoal (1 subgoal):\n 1. \\<nexists>e.\n       e \\<in> arcs G - set p \\<and>\n       (tail G e \\<in> set (awalk_verts u p) \\<or>\n        head G e \\<in> set (awalk_verts u p)) \\<Longrightarrow>\n    False", "obtain e where \"e \\<in> arcs G - set p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e.\n        e \\<in> arcs G - set p \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  Digraph_Component.connected G\n  awalk u p v\n  set p \\<noteq> arcs G\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        e \\<in> arcs G - set p \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: trail_def)"], ["proof (state)\nthis:\n  e \\<in> arcs G - set p\n\ngoal (1 subgoal):\n 1. \\<nexists>e.\n       e \\<in> arcs G - set p \\<and>\n       (tail G e \\<in> set (awalk_verts u p) \\<or>\n        head G e \\<in> set (awalk_verts u p)) \\<Longrightarrow>\n    False", "with A"], ["proof (chain)\npicking this:\n  \\<nexists>e.\n     e \\<in> arcs G - set p \\<and>\n     (tail G e \\<in> set (awalk_verts u p) \\<or>\n      head G e \\<in> set (awalk_verts u p))\n  e \\<in> arcs G - set p", "have \"tail G e \\<notin> set (awalk_verts u p)\" \"tail G e \\<in> verts G\""], ["proof (prove)\nusing this:\n  \\<nexists>e.\n     e \\<in> arcs G - set p \\<and>\n     (tail G e \\<in> set (awalk_verts u p) \\<or>\n      head G e \\<in> set (awalk_verts u p))\n  e \\<in> arcs G - set p\n\ngoal (1 subgoal):\n 1. tail G e \\<notin> set (awalk_verts u p) &&& tail G e \\<in> verts G", "by auto"], ["proof (state)\nthis:\n  tail G e \\<notin> set (awalk_verts u p)\n  tail G e \\<in> verts G\n\ngoal (1 subgoal):\n 1. \\<nexists>e.\n       e \\<in> arcs G - set p \\<and>\n       (tail G e \\<in> set (awalk_verts u p) \\<or>\n        head G e \\<in> set (awalk_verts u p)) \\<Longrightarrow>\n    False", "interpret S: pair_wf_digraph \"mk_symmetric G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_wf_digraph (mk_symmetric G)", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>e.\n       e \\<in> arcs G - set p \\<and>\n       (tail G e \\<in> set (awalk_verts u p) \\<or>\n        head G e \\<in> set (awalk_verts u p)) \\<Longrightarrow>\n    False", "have \"u \\<in> verts G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> verts G", "using \\<open>awalk u p v\\<close>"], ["proof (prove)\nusing this:\n  awalk u p v\n\ngoal (1 subgoal):\n 1. u \\<in> verts G", "by (auto simp: awalk_hd_in_verts)"], ["proof (state)\nthis:\n  u \\<in> verts G\n\ngoal (1 subgoal):\n 1. \\<nexists>e.\n       e \\<in> arcs G - set p \\<and>\n       (tail G e \\<in> set (awalk_verts u p) \\<or>\n        head G e \\<in> set (awalk_verts u p)) \\<Longrightarrow>\n    False", "with \\<open>tail G e \\<in> _\\<close> and \\<open>connected G\\<close>"], ["proof (chain)\npicking this:\n  tail G e \\<in> verts G\n  Digraph_Component.connected G\n  u \\<in> verts G", "obtain q where q: \"S.awalk u q (tail G e)\""], ["proof (prove)\nusing this:\n  tail G e \\<in> verts G\n  Digraph_Component.connected G\n  u \\<in> verts G\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        S.awalk u q (tail G e) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: connected_awalkE)"], ["proof (state)\nthis:\n  S.awalk u q (tail G e)\n\ngoal (1 subgoal):\n 1. \\<nexists>e.\n       e \\<in> arcs G - set p \\<and>\n       (tail G e \\<in> set (awalk_verts u p) \\<or>\n        head G e \\<in> set (awalk_verts u p)) \\<Longrightarrow>\n    False", "have \"u \\<in> set (awalk_verts u p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> set (awalk_verts u p)", "using \\<open>awalk u p v\\<close>"], ["proof (prove)\nusing this:\n  awalk u p v\n\ngoal (1 subgoal):\n 1. u \\<in> set (awalk_verts u p)", "by (auto simp: set_awalk_verts)"], ["proof (state)\nthis:\n  u \\<in> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. \\<nexists>e.\n       e \\<in> arcs G - set p \\<and>\n       (tail G e \\<in> set (awalk_verts u p) \\<or>\n        head G e \\<in> set (awalk_verts u p)) \\<Longrightarrow>\n    False", "have \"q \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<noteq> []", "using \\<open>u \\<in> set _\\<close> \\<open>tail G e \\<notin> _\\<close> q"], ["proof (prove)\nusing this:\n  u \\<in> set (awalk_verts u p)\n  tail G e \\<notin> set (awalk_verts u p)\n  S.awalk u q (tail G e)\n\ngoal (1 subgoal):\n 1. q \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  q \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<nexists>e.\n       e \\<in> arcs G - set p \\<and>\n       (tail G e \\<in> set (awalk_verts u p) \\<or>\n        head G e \\<in> set (awalk_verts u p)) \\<Longrightarrow>\n    False", "have \"\\<exists>e \\<in> set q. fst e \\<in> set (awalk_verts u p) \\<and> snd e \\<notin> set (awalk_verts u p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e\\<in>set q.\n       fst e \\<in> set (awalk_verts u p) \\<and>\n       snd e \\<notin> set (awalk_verts u p)", "by (rule S.awalk_vertex_props[OF \\<open>S.awalk _ _ _\\<close> \\<open>q \\<noteq> []\\<close>]) (auto simp: \\<open>u \\<in> set _\\<close> \\<open>tail G e \\<notin> _\\<close>)"], ["proof (state)\nthis:\n  \\<exists>e\\<in>set q.\n     fst e \\<in> set (awalk_verts u p) \\<and>\n     snd e \\<notin> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. \\<nexists>e.\n       e \\<in> arcs G - set p \\<and>\n       (tail G e \\<in> set (awalk_verts u p) \\<or>\n        head G e \\<in> set (awalk_verts u p)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>e\\<in>set q.\n     fst e \\<in> set (awalk_verts u p) \\<and>\n     snd e \\<notin> set (awalk_verts u p)", "obtain se' where se': \"se' \\<in> set q\" \"fst se' \\<in> set (awalk_verts u p)\" \"snd se' \\<notin> set (awalk_verts u p)\""], ["proof (prove)\nusing this:\n  \\<exists>e\\<in>set q.\n     fst e \\<in> set (awalk_verts u p) \\<and>\n     snd e \\<notin> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. (\\<And>se'.\n        \\<lbrakk>se' \\<in> set q; fst se' \\<in> set (awalk_verts u p);\n         snd se' \\<notin> set (awalk_verts u p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  se' \\<in> set q\n  fst se' \\<in> set (awalk_verts u p)\n  snd se' \\<notin> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. \\<nexists>e.\n       e \\<in> arcs G - set p \\<and>\n       (tail G e \\<in> set (awalk_verts u p) \\<or>\n        head G e \\<in> set (awalk_verts u p)) \\<Longrightarrow>\n    False", "from se'"], ["proof (chain)\npicking this:\n  se' \\<in> set q\n  fst se' \\<in> set (awalk_verts u p)\n  snd se' \\<notin> set (awalk_verts u p)", "have \"se' \\<in> parcs (mk_symmetric G)\""], ["proof (prove)\nusing this:\n  se' \\<in> set q\n  fst se' \\<in> set (awalk_verts u p)\n  snd se' \\<notin> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. se' \\<in> parcs (mk_symmetric G)", "using q"], ["proof (prove)\nusing this:\n  se' \\<in> set q\n  fst se' \\<in> set (awalk_verts u p)\n  snd se' \\<notin> set (awalk_verts u p)\n  S.awalk u q (tail G e)\n\ngoal (1 subgoal):\n 1. se' \\<in> parcs (mk_symmetric G)", "by auto"], ["proof (state)\nthis:\n  se' \\<in> parcs (mk_symmetric G)\n\ngoal (1 subgoal):\n 1. \\<nexists>e.\n       e \\<in> arcs G - set p \\<and>\n       (tail G e \\<in> set (awalk_verts u p) \\<or>\n        head G e \\<in> set (awalk_verts u p)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  se' \\<in> parcs (mk_symmetric G)", "obtain e' where \"e' \\<in> arcs G\" \"(tail G e' = fst se' \\<and> head G e' = snd se') \\<or> (tail G e' = snd se' \\<and> head G e' = fst se')\""], ["proof (prove)\nusing this:\n  se' \\<in> parcs (mk_symmetric G)\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>e' \\<in> arcs G;\n         tail G e' = fst se' \\<and> head G e' = snd se' \\<or>\n         tail G e' = snd se' \\<and> head G e' = fst se'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: parcs_mk_symmetric)"], ["proof (state)\nthis:\n  e' \\<in> arcs G\n  tail G e' = fst se' \\<and> head G e' = snd se' \\<or>\n  tail G e' = snd se' \\<and> head G e' = fst se'\n\ngoal (1 subgoal):\n 1. \\<nexists>e.\n       e \\<in> arcs G - set p \\<and>\n       (tail G e \\<in> set (awalk_verts u p) \\<or>\n        head G e \\<in> set (awalk_verts u p)) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  e' \\<in> arcs G\n  tail G e' = fst se' \\<and> head G e' = snd se' \\<or>\n  tail G e' = snd se' \\<and> head G e' = fst se'\n\ngoal (1 subgoal):\n 1. \\<nexists>e.\n       e \\<in> arcs G - set p \\<and>\n       (tail G e \\<in> set (awalk_verts u p) \\<or>\n        head G e \\<in> set (awalk_verts u p)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  e' \\<in> arcs G\n  tail G e' = fst se' \\<and> head G e' = snd se' \\<or>\n  tail G e' = snd se' \\<and> head G e' = fst se'", "have \"e' \\<notin> set p\""], ["proof (prove)\nusing this:\n  e' \\<in> arcs G\n  tail G e' = fst se' \\<and> head G e' = snd se' \\<or>\n  tail G e' = snd se' \\<and> head G e' = fst se'\n\ngoal (1 subgoal):\n 1. e' \\<notin> set p", "using se' \\<open>awalk u p v\\<close>"], ["proof (prove)\nusing this:\n  e' \\<in> arcs G\n  tail G e' = fst se' \\<and> head G e' = snd se' \\<or>\n  tail G e' = snd se' \\<and> head G e' = fst se'\n  se' \\<in> set q\n  fst se' \\<in> set (awalk_verts u p)\n  snd se' \\<notin> set (awalk_verts u p)\n  awalk u p v\n\ngoal (1 subgoal):\n 1. e' \\<notin> set p", "by (auto dest: awalk_verts_arc2 awalk_verts_arc1)"], ["proof (state)\nthis:\n  e' \\<notin> set p\n\ngoal (1 subgoal):\n 1. \\<nexists>e.\n       e \\<in> arcs G - set p \\<and>\n       (tail G e \\<in> set (awalk_verts u p) \\<or>\n        head G e \\<in> set (awalk_verts u p)) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  e' \\<in> arcs G\n  tail G e' = fst se' \\<and> head G e' = snd se' \\<or>\n  tail G e' = snd se' \\<and> head G e' = fst se'\n  e' \\<notin> set p", "show False"], ["proof (prove)\nusing this:\n  e' \\<in> arcs G\n  tail G e' = fst se' \\<and> head G e' = snd se' \\<or>\n  tail G e' = snd se' \\<and> head G e' = fst se'\n  e' \\<notin> set p\n\ngoal (1 subgoal):\n 1. False", "using se'"], ["proof (prove)\nusing this:\n  e' \\<in> arcs G\n  tail G e' = fst se' \\<and> head G e' = snd se' \\<or>\n  tail G e' = snd se' \\<and> head G e' = fst se'\n  e' \\<notin> set p\n  se' \\<in> set q\n  fst se' \\<in> set (awalk_verts u p)\n  snd se' \\<notin> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. False", "using A"], ["proof (prove)\nusing this:\n  e' \\<in> arcs G\n  tail G e' = fst se' \\<and> head G e' = snd se' \\<or>\n  tail G e' = snd se' \\<and> head G e' = fst se'\n  e' \\<notin> set p\n  se' \\<in> set q\n  fst se' \\<in> set (awalk_verts u p)\n  snd se' \\<notin> set (awalk_verts u p)\n  \\<nexists>e.\n     e \\<in> arcs G - set p \\<and>\n     (tail G e \\<in> set (awalk_verts u p) \\<or>\n      head G e \\<in> set (awalk_verts u p))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in wf_digraph) trail_connected:\n  assumes \"connected G\" \"trail u p v\" \"set p \\<noteq> arcs G\"\n  shows \"\\<exists>e. e \\<in> arcs G - set p \\<and> (tail G e \\<in> set (awalk_verts u p) \\<or> head G e \\<in> set (awalk_verts u p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> arcs G - set p \\<and>\n       (tail G e \\<in> set (awalk_verts u p) \\<or>\n        head G e \\<in> set (awalk_verts u p))", "using assms"], ["proof (prove)\nusing this:\n  Digraph_Component.connected G\n  trail u p v\n  set p \\<noteq> arcs G\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       e \\<in> arcs G - set p \\<and>\n       (tail G e \\<in> set (awalk_verts u p) \\<or>\n        head G e \\<in> set (awalk_verts u p))", "by (intro awalk_connected) (auto simp: trail_def)"], ["", "theorem (in fin_digraph) closed_euler1:\n  assumes con: \"connected G\"\n  assumes deg: \"\\<And>u. u \\<in> verts G \\<Longrightarrow> in_degree G u = out_degree G u\"\n  shows \"\\<exists>u p. euler_trail u p u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u p. euler_trail u p u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>u p. euler_trail u p u", "from con"], ["proof (chain)\npicking this:\n  Digraph_Component.connected G", "obtain u where \"u \\<in> verts G\""], ["proof (prove)\nusing this:\n  Digraph_Component.connected G\n\ngoal (1 subgoal):\n 1. (\\<And>u. u \\<in> verts G \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: connected_def strongly_connected_def)"], ["proof (state)\nthis:\n  u \\<in> verts G\n\ngoal (1 subgoal):\n 1. \\<exists>u p. euler_trail u p u", "then"], ["proof (chain)\npicking this:\n  u \\<in> verts G", "have \"trail u [] u\""], ["proof (prove)\nusing this:\n  u \\<in> verts G\n\ngoal (1 subgoal):\n 1. trail u [] u", "by (auto simp: trail_def awalk_simps)"], ["proof (state)\nthis:\n  trail u [] u\n\ngoal (1 subgoal):\n 1. \\<exists>u p. euler_trail u p u", "moreover"], ["proof (state)\nthis:\n  trail u [] u\n\ngoal (1 subgoal):\n 1. \\<exists>u p. euler_trail u p u", "{"], ["proof (state)\nthis:\n  trail u [] u\n\ngoal (1 subgoal):\n 1. \\<exists>u p. euler_trail u p u", "fix u p v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>u p. euler_trail u p u", "assume  \"trail u p v\""], ["proof (state)\nthis:\n  trail u p v\n\ngoal (1 subgoal):\n 1. \\<exists>u p. euler_trail u p u", "then"], ["proof (chain)\npicking this:\n  trail u p v", "have \"\\<exists>u' p' v'. euler_trail u' p' v'\""], ["proof (prove)\nusing this:\n  trail u p v\n\ngoal (1 subgoal):\n 1. \\<exists>u' p' v'. euler_trail u' p' v'", "proof (induct \"card (arcs G) - length p\" arbitrary: u p v)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p u v.\n       \\<lbrakk>0 = card (arcs G) - length p; trail u p v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n 2. \\<And>x p u v.\n       \\<lbrakk>\\<And>p u v.\n                   \\<lbrakk>x = card (arcs G) - length p;\n                    trail u p v\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p');\n        Suc x = card (arcs G) - length p; trail u p v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')", "case 0"], ["proof (state)\nthis:\n  0 = card (arcs G) - length p\n  trail u p v\n\ngoal (2 subgoals):\n 1. \\<And>p u v.\n       \\<lbrakk>0 = card (arcs G) - length p; trail u p v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n 2. \\<And>x p u v.\n       \\<lbrakk>\\<And>p u v.\n                   \\<lbrakk>x = card (arcs G) - length p;\n                    trail u p v\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p');\n        Suc x = card (arcs G) - length p; trail u p v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')", "then"], ["proof (chain)\npicking this:\n  0 = card (arcs G) - length p\n  trail u p v", "have \"u \\<in> verts G\""], ["proof (prove)\nusing this:\n  0 = card (arcs G) - length p\n  trail u p v\n\ngoal (1 subgoal):\n 1. u \\<in> verts G", "by (auto simp: trail_def)"], ["proof (state)\nthis:\n  u \\<in> verts G\n\ngoal (2 subgoals):\n 1. \\<And>p u v.\n       \\<lbrakk>0 = card (arcs G) - length p; trail u p v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n 2. \\<And>x p u v.\n       \\<lbrakk>\\<And>p u v.\n                   \\<lbrakk>x = card (arcs G) - length p;\n                    trail u p v\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p');\n        Suc x = card (arcs G) - length p; trail u p v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')", "have \"set p \\<subseteq> arcs G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set p \\<subseteq> arcs G", "using \\<open>trail u p v\\<close>"], ["proof (prove)\nusing this:\n  trail u p v\n\ngoal (1 subgoal):\n 1. set p \\<subseteq> arcs G", "by (auto simp: trail_def)"], ["proof (state)\nthis:\n  set p \\<subseteq> arcs G\n\ngoal (2 subgoals):\n 1. \\<And>p u v.\n       \\<lbrakk>0 = card (arcs G) - length p; trail u p v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n 2. \\<And>x p u v.\n       \\<lbrakk>\\<And>p u v.\n                   \\<lbrakk>x = card (arcs G) - length p;\n                    trail u p v\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p');\n        Suc x = card (arcs G) - length p; trail u p v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')", "with 0"], ["proof (chain)\npicking this:\n  0 = card (arcs G) - length p\n  trail u p v\n  set p \\<subseteq> arcs G", "have \"set p = arcs G\""], ["proof (prove)\nusing this:\n  0 = card (arcs G) - length p\n  trail u p v\n  set p \\<subseteq> arcs G\n\ngoal (1 subgoal):\n 1. set p = arcs G", "by (auto simp: trail_def distinct_card[symmetric] card_seteq)"], ["proof (state)\nthis:\n  set p = arcs G\n\ngoal (2 subgoals):\n 1. \\<And>p u v.\n       \\<lbrakk>0 = card (arcs G) - length p; trail u p v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n 2. \\<And>x p u v.\n       \\<lbrakk>\\<And>p u v.\n                   \\<lbrakk>x = card (arcs G) - length p;\n                    trail u p v\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p');\n        Suc x = card (arcs G) - length p; trail u p v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')", "then"], ["proof (chain)\npicking this:\n  set p = arcs G", "have \"euler_trail u p v\""], ["proof (prove)\nusing this:\n  set p = arcs G\n\ngoal (1 subgoal):\n 1. euler_trail u p v", "using 0"], ["proof (prove)\nusing this:\n  set p = arcs G\n  0 = card (arcs G) - length p\n  trail u p v\n\ngoal (1 subgoal):\n 1. euler_trail u p v", "by (simp add: euler_trail_conv_connected[OF con])"], ["proof (state)\nthis:\n  euler_trail u p v\n\ngoal (2 subgoals):\n 1. \\<And>p u v.\n       \\<lbrakk>0 = card (arcs G) - length p; trail u p v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n 2. \\<And>x p u v.\n       \\<lbrakk>\\<And>p u v.\n                   \\<lbrakk>x = card (arcs G) - length p;\n                    trail u p v\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p');\n        Suc x = card (arcs G) - length p; trail u p v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')", "then"], ["proof (chain)\npicking this:\n  euler_trail u p v", "show ?case"], ["proof (prove)\nusing this:\n  euler_trail u p v\n\ngoal (1 subgoal):\n 1. \\<exists>u' p' a. euler_trail u' p' a", "by blast"], ["proof (state)\nthis:\n  \\<exists>u' p' a. euler_trail u' p' a\n\ngoal (1 subgoal):\n 1. \\<And>x p u v.\n       \\<lbrakk>\\<And>p u v.\n                   \\<lbrakk>x = card (arcs G) - length p;\n                    trail u p v\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p');\n        Suc x = card (arcs G) - length p; trail u p v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x p u v.\n       \\<lbrakk>\\<And>p u v.\n                   \\<lbrakk>x = card (arcs G) - length p;\n                    trail u p v\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p');\n        Suc x = card (arcs G) - length p; trail u p v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>n = card (arcs G) - length ?p2; trail ?u2 ?p2 ?v2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n  Suc n = card (arcs G) - length p\n  trail u p v\n\ngoal (1 subgoal):\n 1. \\<And>x p u v.\n       \\<lbrakk>\\<And>p u v.\n                   \\<lbrakk>x = card (arcs G) - length p;\n                    trail u p v\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p');\n        Suc x = card (arcs G) - length p; trail u p v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>n = card (arcs G) - length ?p2; trail ?u2 ?p2 ?v2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n  Suc n = card (arcs G) - length p\n  trail u p v", "have neq: \"set p \\<noteq> arcs G\" \"u \\<in> verts G\""], ["proof (prove)\nusing this:\n  \\<lbrakk>n = card (arcs G) - length ?p2; trail ?u2 ?p2 ?v2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n  Suc n = card (arcs G) - length p\n  trail u p v\n\ngoal (1 subgoal):\n 1. set p \\<noteq> arcs G &&& u \\<in> verts G", "by (auto simp: trail_def distinct_card[symmetric])"], ["proof (state)\nthis:\n  set p \\<noteq> arcs G\n  u \\<in> verts G\n\ngoal (1 subgoal):\n 1. \\<And>x p u v.\n       \\<lbrakk>\\<And>p u v.\n                   \\<lbrakk>x = card (arcs G) - length p;\n                    trail u p v\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p');\n        Suc x = card (arcs G) - length p; trail u p v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u' p'. Ex (euler_trail u' p')", "proof (cases \"u = v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n 2. u \\<noteq> v \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')", "assume \"u \\<noteq> v\""], ["proof (state)\nthis:\n  u \\<noteq> v\n\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n 2. u \\<noteq> v \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')", "then"], ["proof (chain)\npicking this:\n  u \\<noteq> v", "have \"arc_balance u p = -1\""], ["proof (prove)\nusing this:\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. arc_balance u p = - 1", "using Suc neq"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n  \\<lbrakk>n = card (arcs G) - length ?p2; trail ?u2 ?p2 ?v2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n  Suc n = card (arcs G) - length p\n  trail u p v\n  set p \\<noteq> arcs G\n  u \\<in> verts G\n\ngoal (1 subgoal):\n 1. arc_balance u p = - 1", "by (auto elim: trail_arc_balanceE)"], ["proof (state)\nthis:\n  arc_balance u p = - 1\n\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n 2. u \\<noteq> v \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')", "then"], ["proof (chain)\npicking this:\n  arc_balance u p = - 1", "have \"card (in_arcs G u \\<inter> set p) < card (out_arcs G u \\<inter> set p)\""], ["proof (prove)\nusing this:\n  arc_balance u p = - 1\n\ngoal (1 subgoal):\n 1. card (in_arcs G u \\<inter> set p) < card (out_arcs G u \\<inter> set p)", "unfolding arc_set_balance_def"], ["proof (prove)\nusing this:\n  int (card (in_arcs G u \\<inter> set p)) -\n  int (card (out_arcs G u \\<inter> set p)) =\n  - 1\n\ngoal (1 subgoal):\n 1. card (in_arcs G u \\<inter> set p) < card (out_arcs G u \\<inter> set p)", "by auto"], ["proof (state)\nthis:\n  card (in_arcs G u \\<inter> set p) < card (out_arcs G u \\<inter> set p)\n\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n 2. u \\<noteq> v \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')", "also"], ["proof (state)\nthis:\n  card (in_arcs G u \\<inter> set p) < card (out_arcs G u \\<inter> set p)\n\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n 2. u \\<noteq> v \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')", "have \"\\<dots> \\<le> card (out_arcs G u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (out_arcs G u \\<inter> set p) \\<le> card (out_arcs G u)", "by (rule card_mono) auto"], ["proof (state)\nthis:\n  card (out_arcs G u \\<inter> set p) \\<le> card (out_arcs G u)\n\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n 2. u \\<noteq> v \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')", "finally"], ["proof (chain)\npicking this:\n  card (in_arcs G u \\<inter> set p) < card (out_arcs G u)", "have \"card (in_arcs G u \\<inter> set p) < card (in_arcs G u)\""], ["proof (prove)\nusing this:\n  card (in_arcs G u \\<inter> set p) < card (out_arcs G u)\n\ngoal (1 subgoal):\n 1. card (in_arcs G u \\<inter> set p) < card (in_arcs G u)", "using deg[OF \\<open>u \\<in> _\\<close>]"], ["proof (prove)\nusing this:\n  card (in_arcs G u \\<inter> set p) < card (out_arcs G u)\n  in_degree G u = out_degree G u\n\ngoal (1 subgoal):\n 1. card (in_arcs G u \\<inter> set p) < card (in_arcs G u)", "unfolding out_degree_def in_degree_def"], ["proof (prove)\nusing this:\n  card (in_arcs G u \\<inter> set p) < card (out_arcs G u)\n  card (in_arcs G u) = card (out_arcs G u)\n\ngoal (1 subgoal):\n 1. card (in_arcs G u \\<inter> set p) < card (in_arcs G u)", "by simp"], ["proof (state)\nthis:\n  card (in_arcs G u \\<inter> set p) < card (in_arcs G u)\n\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n 2. u \\<noteq> v \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')", "then"], ["proof (chain)\npicking this:\n  card (in_arcs G u \\<inter> set p) < card (in_arcs G u)", "have \"in_arcs G u - set p \\<noteq> {}\""], ["proof (prove)\nusing this:\n  card (in_arcs G u \\<inter> set p) < card (in_arcs G u)\n\ngoal (1 subgoal):\n 1. in_arcs G u - set p \\<noteq> {}", "by (auto dest: card_psubset[rotated 2])"], ["proof (state)\nthis:\n  in_arcs G u - set p \\<noteq> {}\n\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n 2. u \\<noteq> v \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')", "then"], ["proof (chain)\npicking this:\n  in_arcs G u - set p \\<noteq> {}", "obtain a where \"a \\<in> arcs G\" \"head G a = u\" \"a \\<notin> set p\""], ["proof (prove)\nusing this:\n  in_arcs G u - set p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> arcs G; head G a = u; a \\<notin> set p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_arcs_def)"], ["proof (state)\nthis:\n  a \\<in> arcs G\n  head G a = u\n  a \\<notin> set p\n\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n 2. u \\<noteq> v \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')", "then"], ["proof (chain)\npicking this:\n  a \\<in> arcs G\n  head G a = u\n  a \\<notin> set p", "have *: \"trail (tail G a) (a # p) v\""], ["proof (prove)\nusing this:\n  a \\<in> arcs G\n  head G a = u\n  a \\<notin> set p\n\ngoal (1 subgoal):\n 1. trail (tail G a) (a # p) v", "using Suc"], ["proof (prove)\nusing this:\n  a \\<in> arcs G\n  head G a = u\n  a \\<notin> set p\n  \\<lbrakk>n = card (arcs G) - length ?p2; trail ?u2 ?p2 ?v2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n  Suc n = card (arcs G) - length p\n  trail u p v\n\ngoal (1 subgoal):\n 1. trail (tail G a) (a # p) v", "by (auto simp: trail_def awalk_simps)"], ["proof (state)\nthis:\n  trail (tail G a) (a # p) v\n\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n 2. u \\<noteq> v \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')", "then"], ["proof (chain)\npicking this:\n  trail (tail G a) (a # p) v", "show ?thesis"], ["proof (prove)\nusing this:\n  trail (tail G a) (a # p) v\n\ngoal (1 subgoal):\n 1. \\<exists>u' p'. Ex (euler_trail u' p')", "using Suc"], ["proof (prove)\nusing this:\n  trail (tail G a) (a # p) v\n  \\<lbrakk>n = card (arcs G) - length ?p2; trail ?u2 ?p2 ?v2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n  Suc n = card (arcs G) - length p\n  trail u p v\n\ngoal (1 subgoal):\n 1. \\<exists>u' p'. Ex (euler_trail u' p')", "by (intro Suc) auto"], ["proof (state)\nthis:\n  \\<exists>u' p'. Ex (euler_trail u' p')\n\ngoal (1 subgoal):\n 1. u = v \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u = v \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')", "assume \"u = v\""], ["proof (state)\nthis:\n  u = v\n\ngoal (1 subgoal):\n 1. u = v \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')", "with neq con Suc"], ["proof (chain)\npicking this:\n  set p \\<noteq> arcs G\n  u \\<in> verts G\n  Digraph_Component.connected G\n  \\<lbrakk>n = card (arcs G) - length ?p2; trail ?u2 ?p2 ?v2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n  Suc n = card (arcs G) - length p\n  trail u p v\n  u = v", "obtain a where a_in: \"a \\<in> arcs G - set p\"\n            and a_end: \"(tail G a \\<in> set (awalk_verts u p) \\<or> head G a \\<in> set (awalk_verts u p))\""], ["proof (prove)\nusing this:\n  set p \\<noteq> arcs G\n  u \\<in> verts G\n  Digraph_Component.connected G\n  \\<lbrakk>n = card (arcs G) - length ?p2; trail ?u2 ?p2 ?v2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n  Suc n = card (arcs G) - length p\n  trail u p v\n  u = v\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> arcs G - set p;\n         tail G a \\<in> set (awalk_verts u p) \\<or>\n         head G a \\<in> set (awalk_verts u p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (atomize_elim) (rule trail_connected)"], ["proof (state)\nthis:\n  a \\<in> arcs G - set p\n  tail G a \\<in> set (awalk_verts u p) \\<or>\n  head G a \\<in> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. u = v \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')", "have \"trail u p u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trail u p u", "using Suc \\<open>u = v\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>n = card (arcs G) - length ?p2; trail ?u2 ?p2 ?v2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n  Suc n = card (arcs G) - length p\n  trail u p v\n  u = v\n\ngoal (1 subgoal):\n 1. trail u p u", "by simp"], ["proof (state)\nthis:\n  trail u p u\n\ngoal (1 subgoal):\n 1. u = v \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u' p'. Ex (euler_trail u' p')", "proof (cases \"tail G a \\<in> set (awalk_verts u p)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. tail G a \\<in> set (awalk_verts u p) \\<Longrightarrow>\n    \\<exists>u' p'. Ex (euler_trail u' p')\n 2. tail G a \\<notin> set (awalk_verts u p) \\<Longrightarrow>\n    \\<exists>u' p'. Ex (euler_trail u' p')", "case True"], ["proof (state)\nthis:\n  tail G a \\<in> set (awalk_verts u p)\n\ngoal (2 subgoals):\n 1. tail G a \\<in> set (awalk_verts u p) \\<Longrightarrow>\n    \\<exists>u' p'. Ex (euler_trail u' p')\n 2. tail G a \\<notin> set (awalk_verts u p) \\<Longrightarrow>\n    \\<exists>u' p'. Ex (euler_trail u' p')", "with \\<open>trail u p u\\<close>"], ["proof (chain)\npicking this:\n  trail u p u\n  tail G a \\<in> set (awalk_verts u p)", "obtain q where q: \"set p = set q\" \"trail (tail G a) q (tail G a)\""], ["proof (prove)\nusing this:\n  trail u p u\n  tail G a \\<in> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>set p = set q; trail (tail G a) q (tail G a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule rotate_trailE') blast"], ["proof (state)\nthis:\n  set p = set q\n  trail (tail G a) q (tail G a)\n\ngoal (2 subgoals):\n 1. tail G a \\<in> set (awalk_verts u p) \\<Longrightarrow>\n    \\<exists>u' p'. Ex (euler_trail u' p')\n 2. tail G a \\<notin> set (awalk_verts u p) \\<Longrightarrow>\n    \\<exists>u' p'. Ex (euler_trail u' p')", "with True a_in"], ["proof (chain)\npicking this:\n  tail G a \\<in> set (awalk_verts u p)\n  a \\<in> arcs G - set p\n  set p = set q\n  trail (tail G a) q (tail G a)", "have *: \"trail (tail G a) (q @ [a]) (head G a)\""], ["proof (prove)\nusing this:\n  tail G a \\<in> set (awalk_verts u p)\n  a \\<in> arcs G - set p\n  set p = set q\n  trail (tail G a) q (tail G a)\n\ngoal (1 subgoal):\n 1. trail (tail G a) (q @ [a]) (head G a)", "by (fastforce simp: trail_def awalk_simps )"], ["proof (state)\nthis:\n  trail (tail G a) (q @ [a]) (head G a)\n\ngoal (2 subgoals):\n 1. tail G a \\<in> set (awalk_verts u p) \\<Longrightarrow>\n    \\<exists>u' p'. Ex (euler_trail u' p')\n 2. tail G a \\<notin> set (awalk_verts u p) \\<Longrightarrow>\n    \\<exists>u' p'. Ex (euler_trail u' p')", "moreover"], ["proof (state)\nthis:\n  trail (tail G a) (q @ [a]) (head G a)\n\ngoal (2 subgoals):\n 1. tail G a \\<in> set (awalk_verts u p) \\<Longrightarrow>\n    \\<exists>u' p'. Ex (euler_trail u' p')\n 2. tail G a \\<notin> set (awalk_verts u p) \\<Longrightarrow>\n    \\<exists>u' p'. Ex (euler_trail u' p')", "from q Suc"], ["proof (chain)\npicking this:\n  set p = set q\n  trail (tail G a) q (tail G a)\n  \\<lbrakk>n = card (arcs G) - length ?p2; trail ?u2 ?p2 ?v2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n  Suc n = card (arcs G) - length p\n  trail u p v", "have \"length q = length p\""], ["proof (prove)\nusing this:\n  set p = set q\n  trail (tail G a) q (tail G a)\n  \\<lbrakk>n = card (arcs G) - length ?p2; trail ?u2 ?p2 ?v2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n  Suc n = card (arcs G) - length p\n  trail u p v\n\ngoal (1 subgoal):\n 1. length q = length p", "by (simp add: trail_def distinct_card[symmetric])"], ["proof (state)\nthis:\n  length q = length p\n\ngoal (2 subgoals):\n 1. tail G a \\<in> set (awalk_verts u p) \\<Longrightarrow>\n    \\<exists>u' p'. Ex (euler_trail u' p')\n 2. tail G a \\<notin> set (awalk_verts u p) \\<Longrightarrow>\n    \\<exists>u' p'. Ex (euler_trail u' p')", "ultimately"], ["proof (chain)\npicking this:\n  trail (tail G a) (q @ [a]) (head G a)\n  length q = length p", "show ?thesis"], ["proof (prove)\nusing this:\n  trail (tail G a) (q @ [a]) (head G a)\n  length q = length p\n\ngoal (1 subgoal):\n 1. \\<exists>u' p'. Ex (euler_trail u' p')", "using Suc"], ["proof (prove)\nusing this:\n  trail (tail G a) (q @ [a]) (head G a)\n  length q = length p\n  \\<lbrakk>n = card (arcs G) - length ?p2; trail ?u2 ?p2 ?v2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n  Suc n = card (arcs G) - length p\n  trail u p v\n\ngoal (1 subgoal):\n 1. \\<exists>u' p'. Ex (euler_trail u' p')", "by (intro Suc) auto"], ["proof (state)\nthis:\n  \\<exists>u' p'. Ex (euler_trail u' p')\n\ngoal (1 subgoal):\n 1. tail G a \\<notin> set (awalk_verts u p) \\<Longrightarrow>\n    \\<exists>u' p'. Ex (euler_trail u' p')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. tail G a \\<notin> set (awalk_verts u p) \\<Longrightarrow>\n    \\<exists>u' p'. Ex (euler_trail u' p')", "case False"], ["proof (state)\nthis:\n  tail G a \\<notin> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. tail G a \\<notin> set (awalk_verts u p) \\<Longrightarrow>\n    \\<exists>u' p'. Ex (euler_trail u' p')", "with a_end"], ["proof (chain)\npicking this:\n  tail G a \\<in> set (awalk_verts u p) \\<or>\n  head G a \\<in> set (awalk_verts u p)\n  tail G a \\<notin> set (awalk_verts u p)", "have \"head G a \\<in> set (awalk_verts u p)\""], ["proof (prove)\nusing this:\n  tail G a \\<in> set (awalk_verts u p) \\<or>\n  head G a \\<in> set (awalk_verts u p)\n  tail G a \\<notin> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. head G a \\<in> set (awalk_verts u p)", "by blast"], ["proof (state)\nthis:\n  head G a \\<in> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. tail G a \\<notin> set (awalk_verts u p) \\<Longrightarrow>\n    \\<exists>u' p'. Ex (euler_trail u' p')", "with \\<open>trail u p u\\<close>"], ["proof (chain)\npicking this:\n  trail u p u\n  head G a \\<in> set (awalk_verts u p)", "obtain q where q: \"set p = set q\" \"trail (head G a) q (head G a)\""], ["proof (prove)\nusing this:\n  trail u p u\n  head G a \\<in> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>set p = set q; trail (head G a) q (head G a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule rotate_trailE') blast"], ["proof (state)\nthis:\n  set p = set q\n  trail (head G a) q (head G a)\n\ngoal (1 subgoal):\n 1. tail G a \\<notin> set (awalk_verts u p) \\<Longrightarrow>\n    \\<exists>u' p'. Ex (euler_trail u' p')", "with False a_in"], ["proof (chain)\npicking this:\n  tail G a \\<notin> set (awalk_verts u p)\n  a \\<in> arcs G - set p\n  set p = set q\n  trail (head G a) q (head G a)", "have *: \"trail (tail G a) (a # q) (head G a)\""], ["proof (prove)\nusing this:\n  tail G a \\<notin> set (awalk_verts u p)\n  a \\<in> arcs G - set p\n  set p = set q\n  trail (head G a) q (head G a)\n\ngoal (1 subgoal):\n 1. trail (tail G a) (a # q) (head G a)", "by (fastforce simp: trail_def awalk_simps )"], ["proof (state)\nthis:\n  trail (tail G a) (a # q) (head G a)\n\ngoal (1 subgoal):\n 1. tail G a \\<notin> set (awalk_verts u p) \\<Longrightarrow>\n    \\<exists>u' p'. Ex (euler_trail u' p')", "moreover"], ["proof (state)\nthis:\n  trail (tail G a) (a # q) (head G a)\n\ngoal (1 subgoal):\n 1. tail G a \\<notin> set (awalk_verts u p) \\<Longrightarrow>\n    \\<exists>u' p'. Ex (euler_trail u' p')", "from q Suc"], ["proof (chain)\npicking this:\n  set p = set q\n  trail (head G a) q (head G a)\n  \\<lbrakk>n = card (arcs G) - length ?p2; trail ?u2 ?p2 ?v2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n  Suc n = card (arcs G) - length p\n  trail u p v", "have \"length q = length p\""], ["proof (prove)\nusing this:\n  set p = set q\n  trail (head G a) q (head G a)\n  \\<lbrakk>n = card (arcs G) - length ?p2; trail ?u2 ?p2 ?v2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n  Suc n = card (arcs G) - length p\n  trail u p v\n\ngoal (1 subgoal):\n 1. length q = length p", "by (simp add: trail_def distinct_card[symmetric])"], ["proof (state)\nthis:\n  length q = length p\n\ngoal (1 subgoal):\n 1. tail G a \\<notin> set (awalk_verts u p) \\<Longrightarrow>\n    \\<exists>u' p'. Ex (euler_trail u' p')", "ultimately"], ["proof (chain)\npicking this:\n  trail (tail G a) (a # q) (head G a)\n  length q = length p", "show ?thesis"], ["proof (prove)\nusing this:\n  trail (tail G a) (a # q) (head G a)\n  length q = length p\n\ngoal (1 subgoal):\n 1. \\<exists>u' p'. Ex (euler_trail u' p')", "using Suc"], ["proof (prove)\nusing this:\n  trail (tail G a) (a # q) (head G a)\n  length q = length p\n  \\<lbrakk>n = card (arcs G) - length ?p2; trail ?u2 ?p2 ?v2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u' p'. Ex (euler_trail u' p')\n  Suc n = card (arcs G) - length p\n  trail u p v\n\ngoal (1 subgoal):\n 1. \\<exists>u' p'. Ex (euler_trail u' p')", "by (intro Suc) auto"], ["proof (state)\nthis:\n  \\<exists>u' p'. Ex (euler_trail u' p')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>u' p'. Ex (euler_trail u' p')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>u' p'. Ex (euler_trail u' p')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>u' p' v'. euler_trail u' p' v'\n\ngoal (1 subgoal):\n 1. \\<exists>u p. euler_trail u p u", "}"], ["proof (state)\nthis:\n  trail ?ua4 ?p4 ?v4 \\<Longrightarrow>\n  \\<exists>u' p' v'. euler_trail u' p' v'\n\ngoal (1 subgoal):\n 1. \\<exists>u p. euler_trail u p u", "ultimately"], ["proof (chain)\npicking this:\n  trail u [] u\n  trail ?ua4 ?p4 ?v4 \\<Longrightarrow>\n  \\<exists>u' p' v'. euler_trail u' p' v'", "obtain u p v where et: \"euler_trail u p v\""], ["proof (prove)\nusing this:\n  trail u [] u\n  trail ?ua4 ?p4 ?v4 \\<Longrightarrow>\n  \\<exists>u' p' v'. euler_trail u' p' v'\n\ngoal (1 subgoal):\n 1. (\\<And>u p v.\n        euler_trail u p v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  euler_trail u p v\n\ngoal (1 subgoal):\n 1. \\<exists>u p. euler_trail u p u", "moreover"], ["proof (state)\nthis:\n  euler_trail u p v\n\ngoal (1 subgoal):\n 1. \\<exists>u p. euler_trail u p u", "have \"u = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u = v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u = v", "have \"arc_balanced u p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arc_balanced u p v", "using \\<open>euler_trail u p v\\<close>"], ["proof (prove)\nusing this:\n  euler_trail u p v\n\ngoal (1 subgoal):\n 1. arc_balanced u p v", "by (auto simp: euler_trail_def dest: arc_balancedI_trail)"], ["proof (state)\nthis:\n  arc_balanced u p v\n\ngoal (1 subgoal):\n 1. u = v", "then"], ["proof (chain)\npicking this:\n  arc_balanced u p v", "show ?thesis"], ["proof (prove)\nusing this:\n  arc_balanced u p v\n\ngoal (1 subgoal):\n 1. u = v", "using \\<open>euler_trail u p v\\<close> deg"], ["proof (prove)\nusing this:\n  arc_balanced u p v\n  euler_trail u p v\n  ?u2 \\<in> verts G \\<Longrightarrow> in_degree G ?u2 = out_degree G ?u2\n\ngoal (1 subgoal):\n 1. u = v", "by (auto simp add: euler_trail_def trail_def arc_set_balanced_all split: if_split_asm)"], ["proof (state)\nthis:\n  u = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u = v\n\ngoal (1 subgoal):\n 1. \\<exists>u p. euler_trail u p u", "ultimately"], ["proof (chain)\npicking this:\n  euler_trail u p v\n  u = v", "show ?thesis"], ["proof (prove)\nusing this:\n  euler_trail u p v\n  u = v\n\ngoal (1 subgoal):\n 1. \\<exists>u p. euler_trail u p u", "by blast"], ["proof (state)\nthis:\n  \\<exists>u p. euler_trail u p u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in wf_digraph) closed_euler_imp_eq_degree:\n  assumes \"euler_trail u p u\"\n  assumes \"v \\<in> verts G\"\n  shows \"in_degree G v = out_degree G v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. in_degree G v = out_degree G v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. in_degree G v = out_degree G v", "from assms"], ["proof (chain)\npicking this:\n  euler_trail u p u\n  v \\<in> verts G", "have \"arc_balanced u p u\" \"set p = arcs G\""], ["proof (prove)\nusing this:\n  euler_trail u p u\n  v \\<in> verts G\n\ngoal (1 subgoal):\n 1. arc_balanced u p u &&& set p = arcs G", "unfolding euler_trail_def"], ["proof (prove)\nusing this:\n  trail u p u \\<and> set p = arcs G \\<and> set (awalk_verts u p) = verts G\n  v \\<in> verts G\n\ngoal (1 subgoal):\n 1. arc_balanced u p u &&& set p = arcs G", "by (auto dest: arc_balancedI_trail)"], ["proof (state)\nthis:\n  arc_balanced u p u\n  set p = arcs G\n\ngoal (1 subgoal):\n 1. in_degree G v = out_degree G v", "with assms"], ["proof (chain)\npicking this:\n  euler_trail u p u\n  v \\<in> verts G\n  arc_balanced u p u\n  set p = arcs G", "have \"arc_balance v p = 0\""], ["proof (prove)\nusing this:\n  euler_trail u p u\n  v \\<in> verts G\n  arc_balanced u p u\n  set p = arcs G\n\ngoal (1 subgoal):\n 1. arc_balance v p = 0", "unfolding arc_set_balanced_def"], ["proof (prove)\nusing this:\n  euler_trail u p u\n  v \\<in> verts G\n  if u = u then \\<forall>w\\<in>verts G. arc_balance w p = 0\n  else (\\<forall>w\\<in>verts G.\n           w \\<noteq> u \\<and> w \\<noteq> u \\<longrightarrow>\n           arc_balance w p = 0) \\<and>\n       arc_balance u p = - 1 \\<and> arc_balance u p = 1\n  set p = arcs G\n\ngoal (1 subgoal):\n 1. arc_balance v p = 0", "by auto"], ["proof (state)\nthis:\n  arc_balance v p = 0\n\ngoal (1 subgoal):\n 1. in_degree G v = out_degree G v", "moreover"], ["proof (state)\nthis:\n  arc_balance v p = 0\n\ngoal (1 subgoal):\n 1. in_degree G v = out_degree G v", "from \\<open>set p = _\\<close>"], ["proof (chain)\npicking this:\n  set p = arcs G", "have \"in_arcs G v \\<inter> set p = in_arcs G v\" \"out_arcs G v \\<inter> set p = out_arcs G v\""], ["proof (prove)\nusing this:\n  set p = arcs G\n\ngoal (1 subgoal):\n 1. in_arcs G v \\<inter> set p = in_arcs G v &&&\n    out_arcs G v \\<inter> set p = out_arcs G v", "by (auto intro: in_arcs_in_arcs out_arcs_in_arcs)"], ["proof (state)\nthis:\n  in_arcs G v \\<inter> set p = in_arcs G v\n  out_arcs G v \\<inter> set p = out_arcs G v\n\ngoal (1 subgoal):\n 1. in_degree G v = out_degree G v", "ultimately"], ["proof (chain)\npicking this:\n  arc_balance v p = 0\n  in_arcs G v \\<inter> set p = in_arcs G v\n  out_arcs G v \\<inter> set p = out_arcs G v", "show ?thesis"], ["proof (prove)\nusing this:\n  arc_balance v p = 0\n  in_arcs G v \\<inter> set p = in_arcs G v\n  out_arcs G v \\<inter> set p = out_arcs G v\n\ngoal (1 subgoal):\n 1. in_degree G v = out_degree G v", "unfolding arc_set_balance_def in_degree_def out_degree_def"], ["proof (prove)\nusing this:\n  int (card (in_arcs G v \\<inter> set p)) -\n  int (card (out_arcs G v \\<inter> set p)) =\n  0\n  in_arcs G v \\<inter> set p = in_arcs G v\n  out_arcs G v \\<inter> set p = out_arcs G v\n\ngoal (1 subgoal):\n 1. card (in_arcs G v) = card (out_arcs G v)", "by auto"], ["proof (state)\nthis:\n  in_degree G v = out_degree G v\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem (in fin_digraph) closed_euler2:\n  assumes \"euler_trail u p u\"\n  shows \"connected G\"\n    and \"\\<And>u. u \\<in> verts G \\<Longrightarrow> in_degree G u = out_degree G u\" (is \"\\<And>u. _ \\<Longrightarrow> ?eq_deg u\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Digraph_Component.connected G &&&\n    (\\<And>u.\n        u \\<in> verts G \\<Longrightarrow> in_degree G u = out_degree G u)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. Digraph_Component.connected G\n 2. \\<And>u.\n       u \\<in> verts G \\<Longrightarrow> in_degree G u = out_degree G u", "from assms"], ["proof (chain)\npicking this:\n  euler_trail u p u", "show \"connected G\""], ["proof (prove)\nusing this:\n  euler_trail u p u\n\ngoal (1 subgoal):\n 1. Digraph_Component.connected G", "by (rule euler_imp_connected)"], ["proof (state)\nthis:\n  Digraph_Component.connected G\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> verts G \\<Longrightarrow> in_degree G u = out_degree G u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> verts G \\<Longrightarrow> in_degree G u = out_degree G u", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> verts G \\<Longrightarrow> in_degree G u = out_degree G u", "assume A: \"v \\<in> verts G\""], ["proof (state)\nthis:\n  v \\<in> verts G\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> verts G \\<Longrightarrow> in_degree G u = out_degree G u", "with assms"], ["proof (chain)\npicking this:\n  euler_trail u p u\n  v \\<in> verts G", "show \"?eq_deg v\""], ["proof (prove)\nusing this:\n  euler_trail u p u\n  v \\<in> verts G\n\ngoal (1 subgoal):\n 1. in_degree G v = out_degree G v", "by (rule closed_euler_imp_eq_degree)"], ["proof (state)\nthis:\n  in_degree G v = out_degree G v\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary (in fin_digraph) closed_euler:\n  \"(\\<exists>u p. euler_trail u p u) \\<longleftrightarrow> connected G \\<and> (\\<forall>u \\<in> verts G. in_degree G u = out_degree G u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>u p. euler_trail u p u) =\n    (Digraph_Component.connected G \\<and>\n     (\\<forall>u\\<in>verts G. in_degree G u = out_degree G u))", "by (auto dest: closed_euler1 closed_euler2)"], ["", "subsection \\<open>Open euler trails\\<close>"], ["", "text \\<open>\n  Intuitively, a graph has an open euler trail if and only if it is possible to add\n  an arc such that the resulting graph has a closed euler trail. However, this is\n  not true in our formalization, as the arc type @{typ 'b} might be finite:\n\n  Consider for example the graph\n  @{term \"\\<lparr> verts = {0,1}, arcs = {()}, tail = \\<lambda>_. 0, head = \\<lambda>_. 1 \\<rparr>\"}. This graph\n  obviously has an open euler trail, but we cannot add another arc, as we already\n  exhausted the universe.\n\n  However, for each @{term \"fin_digraph G\"} there exist an isomorphic graph\n  @{term H} with arc type @{typ \"'a \\<times> nat \\<times> 'a\"}. Hence, we first characterize\n  the existence of euler trail for the infinite arc type @{typ \"'a \\<times> nat \\<times> 'a\"}\n  and transfer that result back to arbitrary arc types.\n\\<close>"], ["", "lemma open_euler_infinite_label:\n  fixes G :: \"('a, 'a \\<times> nat \\<times> 'a) pre_digraph\"\n  assumes \"fin_digraph G\"\n  assumes [simp]: \"tail G = fst\" \"head G = snd o snd\"\n  assumes con: \"connected G\"\n  assumes uv: \"u \\<in> verts G\" \"v \\<in> verts G\"\n  assumes deg: \"\\<And>w. \\<lbrakk>w \\<in> verts G; u \\<noteq> w; v \\<noteq> w\\<rbrakk> \\<Longrightarrow> in_degree G w = out_degree G w\"\n  assumes deg_in: \"in_degree G u + 1 = out_degree G u\"\n  assumes deg_out: \"out_degree G v + 1 = in_degree G v\"\n  shows \"\\<exists>p. pre_digraph.euler_trail G u p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. pre_digraph.euler_trail G u p v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. pre_digraph.euler_trail G u p v", "define label :: \"'a \\<times> nat \\<times> 'a \\<Rightarrow> nat\" where [simp]: \"label = fst o snd\""], ["proof (state)\nthis:\n  label = fst \\<circ> snd\n\ngoal (1 subgoal):\n 1. \\<exists>p. pre_digraph.euler_trail G u p v", "interpret fin_digraph G"], ["proof (prove)\ngoal (1 subgoal):\n 1. fin_digraph G", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "have \"finite (label ` arcs G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (label ` arcs G)", "by auto"], ["proof (state)\nthis:\n  finite (label ` arcs G)\n\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "moreover"], ["proof (state)\nthis:\n  finite (label ` arcs G)\n\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "have \"\\<not>finite (UNIV :: nat set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite UNIV", "by blast"], ["proof (state)\nthis:\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "ultimately"], ["proof (chain)\npicking this:\n  finite (label ` arcs G)\n  infinite UNIV", "obtain l where \"l \\<notin> label ` arcs G\""], ["proof (prove)\nusing this:\n  finite (label ` arcs G)\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        l \\<notin> label ` arcs G \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim (rule ex_new_if_finite)"], ["proof (state)\nthis:\n  l \\<notin> label ` arcs G\n\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "from deg_in deg_out"], ["proof (chain)\npicking this:\n  in_degree G u + 1 = out_degree G u\n  out_degree G v + 1 = in_degree G v", "have \"u \\<noteq> v\""], ["proof (prove)\nusing this:\n  in_degree G u + 1 = out_degree G u\n  out_degree G v + 1 = in_degree G v\n\ngoal (1 subgoal):\n 1. u \\<noteq> v", "by auto"], ["proof (state)\nthis:\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "let ?e = \"(v,l,u)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "have e_notin:\"?e \\<notin> arcs G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, l, u) \\<notin> arcs G", "using \\<open>l \\<notin> _\\<close>"], ["proof (prove)\nusing this:\n  l \\<notin> label ` arcs G\n\ngoal (1 subgoal):\n 1. (v, l, u) \\<notin> arcs G", "by (auto simp: image_def)"], ["proof (state)\nthis:\n  (v, l, u) \\<notin> arcs G\n\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "let ?H = \"add_arc ?e\"\n    \\<comment> \\<open>We define a graph which has an closed euler trail\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "have [simp]: \"verts ?H = verts G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. verts (add_arc (v, l, u)) = verts G", "using uv"], ["proof (prove)\nusing this:\n  u \\<in> verts G\n  v \\<in> verts G\n\ngoal (1 subgoal):\n 1. verts (add_arc (v, l, u)) = verts G", "by simp"], ["proof (state)\nthis:\n  verts (add_arc (v, l, u)) = verts G\n\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "have [intro]: \"\\<And>a. compatible (add_arc a) G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. compatible (add_arc a) G", "by (simp add: compatible_def)"], ["proof (state)\nthis:\n  compatible (add_arc ?a1) G\n\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "interpret H: fin_digraph \"add_arc a\"\n    rewrites \"tail (add_arc a) = tail G\" and \"head (add_arc a) = head G\"\n      and \"pre_digraph.cas (add_arc a) = cas\"\n      and \"pre_digraph.awalk_verts (add_arc a) = awalk_verts\"\n     for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. (fin_digraph (add_arc a) &&& tail (add_arc a) = tail G) &&&\n    head (add_arc a) = head G &&&\n    pre_digraph.cas (add_arc a) = cas &&&\n    pre_digraph.awalk_verts (add_arc a) = awalk_verts", "by unfold_locales (auto dest: wellformed intro: compatible_cas compatible_awalk_verts\n          simp: verts_add_arc_conv)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "have \"\\<exists>u p. H.euler_trail ?e u p u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ua p. H.euler_trail (v, l, u) ua p ua", "proof (rule H.closed_euler1)"], ["proof (state)\ngoal (2 subgoals):\n 1. Digraph_Component.connected (add_arc (v, l, u))\n 2. \\<And>ua.\n       ua \\<in> verts (add_arc (v, l, u)) \\<Longrightarrow>\n       in_degree (add_arc (v, l, u)) ua = out_degree (add_arc (v, l, u)) ua", "show \"connected ?H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Digraph_Component.connected (add_arc (v, l, u))", "proof (rule H.connectedI)"], ["proof (state)\ngoal (2 subgoals):\n 1. verts (add_arc (v, l, u)) \\<noteq> {}\n 2. \\<And>ua va.\n       \\<lbrakk>ua \\<in> verts (add_arc (v, l, u));\n        va \\<in> verts (add_arc (v, l, u))\\<rbrakk>\n       \\<Longrightarrow> ua \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric (add_arc (v, l, u)))\\<^esub> va", "interpret sH: pair_fin_digraph \"mk_symmetric ?H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_fin_digraph (mk_symmetric (add_arc (v, l, u)))", ".."], ["proof (state)\ngoal (2 subgoals):\n 1. verts (add_arc (v, l, u)) \\<noteq> {}\n 2. \\<And>ua va.\n       \\<lbrakk>ua \\<in> verts (add_arc (v, l, u));\n        va \\<in> verts (add_arc (v, l, u))\\<rbrakk>\n       \\<Longrightarrow> ua \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric (add_arc (v, l, u)))\\<^esub> va", "fix u v"], ["proof (state)\ngoal (2 subgoals):\n 1. verts (add_arc (v, l, u)) \\<noteq> {}\n 2. \\<And>ua va.\n       \\<lbrakk>ua \\<in> verts (add_arc (v, l, u));\n        va \\<in> verts (add_arc (v, l, u))\\<rbrakk>\n       \\<Longrightarrow> ua \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric (add_arc (v, l, u)))\\<^esub> va", "assume \"u \\<in> verts ?H\" \"v \\<in> verts ?H\""], ["proof (state)\nthis:\n  u \\<in> verts (add_arc (v, l, u))\n  v \\<in> verts (add_arc (v, l, u))\n\ngoal (2 subgoals):\n 1. verts (add_arc (v, l, u)) \\<noteq> {}\n 2. \\<And>ua va.\n       \\<lbrakk>ua \\<in> verts (add_arc (v, l, u));\n        va \\<in> verts (add_arc (v, l, u))\\<rbrakk>\n       \\<Longrightarrow> ua \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric (add_arc (v, l, u)))\\<^esub> va", "with con"], ["proof (chain)\npicking this:\n  Digraph_Component.connected G\n  u \\<in> verts (add_arc (v, l, u))\n  v \\<in> verts (add_arc (v, l, u))", "have \"u \\<rightarrow>\\<^sup>*\\<^bsub>mk_symmetric G\\<^esub> v\""], ["proof (prove)\nusing this:\n  Digraph_Component.connected G\n  u \\<in> verts (add_arc (v, l, u))\n  v \\<in> verts (add_arc (v, l, u))\n\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> v", "by (auto simp: connected_def)"], ["proof (state)\nthis:\n  u \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> v\n\ngoal (2 subgoals):\n 1. verts (add_arc (v, l, u)) \\<noteq> {}\n 2. \\<And>ua va.\n       \\<lbrakk>ua \\<in> verts (add_arc (v, l, u));\n        va \\<in> verts (add_arc (v, l, u))\\<rbrakk>\n       \\<Longrightarrow> ua \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric (add_arc (v, l, u)))\\<^esub> va", "moreover"], ["proof (state)\nthis:\n  u \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> v\n\ngoal (2 subgoals):\n 1. verts (add_arc (v, l, u)) \\<noteq> {}\n 2. \\<And>ua va.\n       \\<lbrakk>ua \\<in> verts (add_arc (v, l, u));\n        va \\<in> verts (add_arc (v, l, u))\\<rbrakk>\n       \\<Longrightarrow> ua \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric (add_arc (v, l, u)))\\<^esub> va", "have \"subgraph G ?H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subgraph G (add_arc (v, l, u))", "by (auto simp: subgraph_def) unfold_locales"], ["proof (state)\nthis:\n  subgraph G (add_arc (v, l, u))\n\ngoal (2 subgoals):\n 1. verts (add_arc (v, l, u)) \\<noteq> {}\n 2. \\<And>ua va.\n       \\<lbrakk>ua \\<in> verts (add_arc (v, l, u));\n        va \\<in> verts (add_arc (v, l, u))\\<rbrakk>\n       \\<Longrightarrow> ua \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric (add_arc (v, l, u)))\\<^esub> va", "ultimately"], ["proof (chain)\npicking this:\n  u \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> v\n  subgraph G (add_arc (v, l, u))", "show \"u \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric ?H)\\<^esub> v\""], ["proof (prove)\nusing this:\n  u \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric G)\\<^esub> v\n  subgraph G (add_arc (v, l, u))\n\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric (add_arc (v, l, u)))\\<^esub> v", "by (blast intro: sH.reachable_mono subgraph_mk_symmetric)"], ["proof (state)\nthis:\n  u \\<rightarrow>\\<^sup>*\\<^bsub>with_proj (mk_symmetric (add_arc (v, l, u)))\\<^esub> v\n\ngoal (1 subgoal):\n 1. verts (add_arc (v, l, u)) \\<noteq> {}", "qed (simp add: verts_add_arc_conv)"], ["proof (state)\nthis:\n  Digraph_Component.connected (add_arc (v, l, u))\n\ngoal (1 subgoal):\n 1. \\<And>ua.\n       ua \\<in> verts (add_arc (v, l, u)) \\<Longrightarrow>\n       in_degree (add_arc (v, l, u)) ua = out_degree (add_arc (v, l, u)) ua", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ua.\n       ua \\<in> verts (add_arc (v, l, u)) \\<Longrightarrow>\n       in_degree (add_arc (v, l, u)) ua = out_degree (add_arc (v, l, u)) ua", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ua.\n       ua \\<in> verts (add_arc (v, l, u)) \\<Longrightarrow>\n       in_degree (add_arc (v, l, u)) ua = out_degree (add_arc (v, l, u)) ua", "assume \"w \\<in> verts ?H\""], ["proof (state)\nthis:\n  w \\<in> verts (add_arc (v, l, u))\n\ngoal (1 subgoal):\n 1. \\<And>ua.\n       ua \\<in> verts (add_arc (v, l, u)) \\<Longrightarrow>\n       in_degree (add_arc (v, l, u)) ua = out_degree (add_arc (v, l, u)) ua", "then"], ["proof (chain)\npicking this:\n  w \\<in> verts (add_arc (v, l, u))", "show \"in_degree ?H w = out_degree ?H w\""], ["proof (prove)\nusing this:\n  w \\<in> verts (add_arc (v, l, u))\n\ngoal (1 subgoal):\n 1. in_degree (add_arc (v, l, u)) w = out_degree (add_arc (v, l, u)) w", "using deg deg_in deg_out e_notin"], ["proof (prove)\nusing this:\n  w \\<in> verts (add_arc (v, l, u))\n  \\<lbrakk>?w \\<in> verts G; u \\<noteq> ?w; v \\<noteq> ?w\\<rbrakk>\n  \\<Longrightarrow> in_degree G ?w = out_degree G ?w\n  in_degree G u + 1 = out_degree G u\n  out_degree G v + 1 = in_degree G v\n  (v, l, u) \\<notin> arcs G\n\ngoal (1 subgoal):\n 1. in_degree (add_arc (v, l, u)) w = out_degree (add_arc (v, l, u)) w", "apply (cases \"w = u\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>w \\<in> verts (add_arc (v, l, u));\n     \\<And>w.\n        \\<lbrakk>w \\<in> verts G; u \\<noteq> w; v \\<noteq> w\\<rbrakk>\n        \\<Longrightarrow> in_degree G w = out_degree G w;\n     in_degree G u + 1 = out_degree G u; out_degree G v + 1 = in_degree G v;\n     (v, l, u) \\<notin> arcs G; w = u\\<rbrakk>\n    \\<Longrightarrow> in_degree (add_arc (v, l, u)) w =\n                      out_degree (add_arc (v, l, u)) w\n 2. \\<lbrakk>w \\<in> verts (add_arc (v, l, u));\n     \\<And>w.\n        \\<lbrakk>w \\<in> verts G; u \\<noteq> w; v \\<noteq> w\\<rbrakk>\n        \\<Longrightarrow> in_degree G w = out_degree G w;\n     in_degree G u + 1 = out_degree G u; out_degree G v + 1 = in_degree G v;\n     (v, l, u) \\<notin> arcs G; w \\<noteq> u\\<rbrakk>\n    \\<Longrightarrow> in_degree (add_arc (v, l, u)) w =\n                      out_degree (add_arc (v, l, u)) w", "apply (case_tac [!] \"w = v\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>w \\<in> verts (add_arc (v, l, u));\n     \\<And>w.\n        \\<lbrakk>w \\<in> verts G; u \\<noteq> w; v \\<noteq> w\\<rbrakk>\n        \\<Longrightarrow> in_degree G w = out_degree G w;\n     in_degree G u + 1 = out_degree G u; out_degree G v + 1 = in_degree G v;\n     (v, l, u) \\<notin> arcs G; w = u; w = v\\<rbrakk>\n    \\<Longrightarrow> in_degree (add_arc (v, l, u)) w =\n                      out_degree (add_arc (v, l, u)) w\n 2. \\<lbrakk>w \\<in> verts (add_arc (v, l, u));\n     \\<And>w.\n        \\<lbrakk>w \\<in> verts G; u \\<noteq> w; v \\<noteq> w\\<rbrakk>\n        \\<Longrightarrow> in_degree G w = out_degree G w;\n     in_degree G u + 1 = out_degree G u; out_degree G v + 1 = in_degree G v;\n     (v, l, u) \\<notin> arcs G; w = u; w \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> in_degree (add_arc (v, l, u)) w =\n                      out_degree (add_arc (v, l, u)) w\n 3. \\<lbrakk>w \\<in> verts (add_arc (v, l, u));\n     \\<And>w.\n        \\<lbrakk>w \\<in> verts G; u \\<noteq> w; v \\<noteq> w\\<rbrakk>\n        \\<Longrightarrow> in_degree G w = out_degree G w;\n     in_degree G u + 1 = out_degree G u; out_degree G v + 1 = in_degree G v;\n     (v, l, u) \\<notin> arcs G; w \\<noteq> u; w = v\\<rbrakk>\n    \\<Longrightarrow> in_degree (add_arc (v, l, u)) w =\n                      out_degree (add_arc (v, l, u)) w\n 4. \\<lbrakk>w \\<in> verts (add_arc (v, l, u));\n     \\<And>w.\n        \\<lbrakk>w \\<in> verts G; u \\<noteq> w; v \\<noteq> w\\<rbrakk>\n        \\<Longrightarrow> in_degree G w = out_degree G w;\n     in_degree G u + 1 = out_degree G u; out_degree G v + 1 = in_degree G v;\n     (v, l, u) \\<notin> arcs G; w \\<noteq> u; w \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> in_degree (add_arc (v, l, u)) w =\n                      out_degree (add_arc (v, l, u)) w", "by (auto simp: in_degree_add_arc_iff out_degree_add_arc_iff)"], ["proof (state)\nthis:\n  in_degree (add_arc (v, l, u)) w = out_degree (add_arc (v, l, u)) w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ua p. H.euler_trail (v, l, u) ua p ua\n\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "then"], ["proof (chain)\npicking this:\n  \\<exists>ua p. H.euler_trail (v, l, u) ua p ua", "obtain w p where Het: \"H.euler_trail ?e w p w\""], ["proof (prove)\nusing this:\n  \\<exists>ua p. H.euler_trail (v, l, u) ua p ua\n\ngoal (1 subgoal):\n 1. (\\<And>w p.\n        H.euler_trail (v, l, u) w p w \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  H.euler_trail (v, l, u) w p w\n\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "then"], ["proof (chain)\npicking this:\n  H.euler_trail (v, l, u) w p w", "have \"?e \\<in> set p\""], ["proof (prove)\nusing this:\n  H.euler_trail (v, l, u) w p w\n\ngoal (1 subgoal):\n 1. (v, l, u) \\<in> set p", "by (auto simp: pre_digraph.euler_trail_def)"], ["proof (state)\nthis:\n  (v, l, u) \\<in> set p\n\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "then"], ["proof (chain)\npicking this:\n  (v, l, u) \\<in> set p", "obtain q r where p_decomp: \"p = q @ [?e] @ r\""], ["proof (prove)\nusing this:\n  (v, l, u) \\<in> set p\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        p = q @ [(v, l, u)] @ r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_set_conv_decomp)\n    \\<comment> \\<open>We show now that removing the additional arc of @{term ?H}\n      from p yields an euler trail in G\\<close>"], ["proof (state)\nthis:\n  p = q @ [(v, l, u)] @ r\n\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "have \"euler_trail u (r @ q) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. euler_trail u (r @ q) v", "proof (unfold euler_trail_conv_connected[OF con], intro conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. trail u (r @ q) v\n 2. set (r @ q) = arcs G", "from Het"], ["proof (chain)\npicking this:\n  H.euler_trail (v, l, u) w p w", "have Ht': \"H.trail ?e v (?e # r @ q) v\""], ["proof (prove)\nusing this:\n  H.euler_trail (v, l, u) w p w\n\ngoal (1 subgoal):\n 1. H.trail (v, l, u) v ((v, l, u) # r @ q) v", "unfolding p_decomp H.euler_trail_def H.trail_def"], ["proof (prove)\nusing this:\n  (H.awalk (v, l, u) w (q @ [(v, l, u)] @ r) w \\<and>\n   distinct (q @ [(v, l, u)] @ r)) \\<and>\n  set (q @ [(v, l, u)] @ r) = arcs (add_arc (v, l, u)) \\<and>\n  set (H.awalk_verts w (q @ [(v, l, u)] @ r)) = verts (add_arc (v, l, u))\n\ngoal (1 subgoal):\n 1. H.awalk (v, l, u) v ((v, l, u) # r @ q) v \\<and>\n    distinct ((v, l, u) # r @ q)", "by (auto simp: p_decomp H.awalk_Cons_iff)"], ["proof (state)\nthis:\n  H.trail (v, l, u) v ((v, l, u) # r @ q) v\n\ngoal (2 subgoals):\n 1. trail u (r @ q) v\n 2. set (r @ q) = arcs G", "then"], ["proof (chain)\npicking this:\n  H.trail (v, l, u) v ((v, l, u) # r @ q) v", "have \"H.trail ?e u (r @ q) v\" \"?e \\<notin> set (r @ q)\""], ["proof (prove)\nusing this:\n  H.trail (v, l, u) v ((v, l, u) # r @ q) v\n\ngoal (1 subgoal):\n 1. H.trail (v, l, u) u (r @ q) v &&& (v, l, u) \\<notin> set (r @ q)", "by (auto simp: H.trail_def H.awalk_Cons_iff)"], ["proof (state)\nthis:\n  H.trail (v, l, u) u (r @ q) v\n  (v, l, u) \\<notin> set (r @ q)\n\ngoal (2 subgoals):\n 1. trail u (r @ q) v\n 2. set (r @ q) = arcs G", "then"], ["proof (chain)\npicking this:\n  H.trail (v, l, u) u (r @ q) v\n  (v, l, u) \\<notin> set (r @ q)", "show t': \"trail u (r @ q) v\""], ["proof (prove)\nusing this:\n  H.trail (v, l, u) u (r @ q) v\n  (v, l, u) \\<notin> set (r @ q)\n\ngoal (1 subgoal):\n 1. trail u (r @ q) v", "by (auto simp: trail_def H.trail_def awalk_def H.awalk_def)"], ["proof (state)\nthis:\n  trail u (r @ q) v\n\ngoal (1 subgoal):\n 1. set (r @ q) = arcs G", "show \"set (r @ q) = arcs G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (r @ q) = arcs G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (r @ q) = arcs G", "have \"arcs G = arcs ?H - {?e}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arcs G = arcs (add_arc (v, l, u)) - {(v, l, u)}", "using e_notin"], ["proof (prove)\nusing this:\n  (v, l, u) \\<notin> arcs G\n\ngoal (1 subgoal):\n 1. arcs G = arcs (add_arc (v, l, u)) - {(v, l, u)}", "by auto"], ["proof (state)\nthis:\n  arcs G = arcs (add_arc (v, l, u)) - {(v, l, u)}\n\ngoal (1 subgoal):\n 1. set (r @ q) = arcs G", "also"], ["proof (state)\nthis:\n  arcs G = arcs (add_arc (v, l, u)) - {(v, l, u)}\n\ngoal (1 subgoal):\n 1. set (r @ q) = arcs G", "have \"arcs ?H = set p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arcs (add_arc (v, l, u)) = set p", "using Het"], ["proof (prove)\nusing this:\n  H.euler_trail (v, l, u) w p w\n\ngoal (1 subgoal):\n 1. arcs (add_arc (v, l, u)) = set p", "by (auto simp: pre_digraph.euler_trail_def pre_digraph.trail_def)"], ["proof (state)\nthis:\n  arcs (add_arc (v, l, u)) = set p\n\ngoal (1 subgoal):\n 1. set (r @ q) = arcs G", "finally"], ["proof (chain)\npicking this:\n  arcs G = set p - {(v, l, u)}", "show ?thesis"], ["proof (prove)\nusing this:\n  arcs G = set p - {(v, l, u)}\n\ngoal (1 subgoal):\n 1. set (r @ q) = arcs G", "using \\<open>?e \\<notin> set _\\<close>"], ["proof (prove)\nusing this:\n  arcs G = set p - {(v, l, u)}\n  (v, l, u) \\<notin> set (r @ q)\n\ngoal (1 subgoal):\n 1. set (r @ q) = arcs G", "by (auto simp: p_decomp)"], ["proof (state)\nthis:\n  set (r @ q) = arcs G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (r @ q) = arcs G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  euler_trail u (r @ q) v\n\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "then"], ["proof (chain)\npicking this:\n  euler_trail u (r @ q) v", "show ?thesis"], ["proof (prove)\nusing this:\n  euler_trail u (r @ q) v\n\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "by blast"], ["proof (state)\nthis:\n  \\<exists>p. euler_trail u p v\n\ngoal:\nNo subgoals!", "qed"], ["", "context wf_digraph begin"], ["", "lemma trail_app_isoI:\n  assumes t: \"trail u p v\"\n    and hom: \"digraph_isomorphism hom\"\n  shows \"pre_digraph.trail (app_iso hom G) (iso_verts hom u) (map (iso_arcs hom) p) (iso_verts hom v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_digraph.trail (app_iso hom G) (iso_verts hom u)\n     (map (iso_arcs hom) p) (iso_verts hom v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pre_digraph.trail (app_iso hom G) (iso_verts hom u)\n     (map (iso_arcs hom) p) (iso_verts hom v)", "interpret H: wf_digraph \"app_iso hom G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_digraph (app_iso hom G)", "using hom"], ["proof (prove)\nusing this:\n  digraph_isomorphism hom\n\ngoal (1 subgoal):\n 1. wf_digraph (app_iso hom G)", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. H.trail (iso_verts hom u) (map (iso_arcs hom) p) (iso_verts hom v)", "from t hom"], ["proof (chain)\npicking this:\n  trail u p v\n  digraph_isomorphism hom", "have i: \"inj_on (iso_arcs hom) (set p)\""], ["proof (prove)\nusing this:\n  trail u p v\n  digraph_isomorphism hom\n\ngoal (1 subgoal):\n 1. inj_on (iso_arcs hom) (set p)", "unfolding trail_def digraph_isomorphism_def"], ["proof (prove)\nusing this:\n  awalk u p v \\<and> distinct p\n  wf_digraph G \\<and>\n  inj_on (iso_verts hom) (verts G) \\<and>\n  inj_on (iso_arcs hom) (arcs G) \\<and>\n  (\\<forall>a\\<in>arcs G.\n      iso_verts hom (tail G a) = iso_tail hom (iso_arcs hom a) \\<and>\n      iso_verts hom (head G a) = iso_head hom (iso_arcs hom a))\n\ngoal (1 subgoal):\n 1. inj_on (iso_arcs hom) (set p)", "by (auto dest:subset_inj_on[where A=\"set p\"])"], ["proof (state)\nthis:\n  inj_on (iso_arcs hom) (set p)\n\ngoal (1 subgoal):\n 1. H.trail (iso_verts hom u) (map (iso_arcs hom) p) (iso_verts hom v)", "then"], ["proof (chain)\npicking this:\n  inj_on (iso_arcs hom) (set p)", "have \"distinct (map (iso_arcs hom) p) = distinct p\""], ["proof (prove)\nusing this:\n  inj_on (iso_arcs hom) (set p)\n\ngoal (1 subgoal):\n 1. distinct (map (iso_arcs hom) p) = distinct p", "by (auto simp: distinct_map dest: inj_onD)"], ["proof (state)\nthis:\n  distinct (map (iso_arcs hom) p) = distinct p\n\ngoal (1 subgoal):\n 1. H.trail (iso_verts hom u) (map (iso_arcs hom) p) (iso_verts hom v)", "with t hom"], ["proof (chain)\npicking this:\n  trail u p v\n  digraph_isomorphism hom\n  distinct (map (iso_arcs hom) p) = distinct p", "show ?thesis"], ["proof (prove)\nusing this:\n  trail u p v\n  digraph_isomorphism hom\n  distinct (map (iso_arcs hom) p) = distinct p\n\ngoal (1 subgoal):\n 1. H.trail (iso_verts hom u) (map (iso_arcs hom) p) (iso_verts hom v)", "by (auto simp: pre_digraph.trail_def awalk_app_isoI)"], ["proof (state)\nthis:\n  H.trail (iso_verts hom u) (map (iso_arcs hom) p) (iso_verts hom v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma euler_trail_app_isoI:\n  assumes t: \"euler_trail u p v\"\n    and hom: \"digraph_isomorphism hom\"\n  shows \"pre_digraph.euler_trail (app_iso hom G) (iso_verts hom u) (map (iso_arcs hom) p) (iso_verts hom v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_digraph.euler_trail (app_iso hom G) (iso_verts hom u)\n     (map (iso_arcs hom) p) (iso_verts hom v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pre_digraph.euler_trail (app_iso hom G) (iso_verts hom u)\n     (map (iso_arcs hom) p) (iso_verts hom v)", "from t"], ["proof (chain)\npicking this:\n  euler_trail u p v", "have \"awalk u p v\""], ["proof (prove)\nusing this:\n  euler_trail u p v\n\ngoal (1 subgoal):\n 1. awalk u p v", "by (auto simp: euler_trail_def trail_def)"], ["proof (state)\nthis:\n  awalk u p v\n\ngoal (1 subgoal):\n 1. pre_digraph.euler_trail (app_iso hom G) (iso_verts hom u)\n     (map (iso_arcs hom) p) (iso_verts hom v)", "with assms"], ["proof (chain)\npicking this:\n  euler_trail u p v\n  digraph_isomorphism hom\n  awalk u p v", "show ?thesis"], ["proof (prove)\nusing this:\n  euler_trail u p v\n  digraph_isomorphism hom\n  awalk u p v\n\ngoal (1 subgoal):\n 1. pre_digraph.euler_trail (app_iso hom G) (iso_verts hom u)\n     (map (iso_arcs hom) p) (iso_verts hom v)", "by (simp add: pre_digraph.euler_trail_def trail_app_isoI awalk_verts_app_iso_eq)"], ["proof (state)\nthis:\n  pre_digraph.euler_trail (app_iso hom G) (iso_verts hom u)\n   (map (iso_arcs hom) p) (iso_verts hom v)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context fin_digraph begin"], ["", "(* XXX: We can get rid of \"u \\<in> verts G\" \"v \\<in> verts G\" here and in @{thm open_euler_infinite_label} *)"], ["", "theorem open_euler1:\n  assumes \"connected G\"\n  assumes \"u \\<in> verts G\" \"v \\<in> verts G\"\n  assumes \"\\<And>w. \\<lbrakk>w \\<in> verts G; u \\<noteq> w; v \\<noteq> w\\<rbrakk> \\<Longrightarrow> in_degree G w = out_degree G w\"\n  assumes \"in_degree G u + 1 = out_degree G u\"\n  assumes \"out_degree G v + 1 = in_degree G v\"\n  shows \"\\<exists>p. euler_trail u p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "obtain f and n :: nat where \"f ` arcs G = {i. i < n}\"\n      and i: \"inj_on f (arcs G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f n.\n        \\<lbrakk>f ` arcs G = {i. i < n}; inj_on f (arcs G)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim (rule finite_imp_inj_to_nat_seg, auto)"], ["proof (state)\nthis:\n  f ` arcs G = {i. i < n}\n  inj_on f (arcs G)\n\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "define iso_f where \"iso_f =\n    \\<lparr> iso_verts = id, iso_arcs = (\\<lambda>a. (tail G a, f a, head G a)),\n      head = snd o snd, tail = fst \\<rparr>\""], ["proof (state)\nthis:\n  iso_f =\n  \\<lparr>iso_verts = id, iso_arcs = \\<lambda>a. (tail G a, f a, head G a),\n     iso_head = snd \\<circ> snd, iso_tail = fst\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "have [simp]: \"iso_verts iso_f = id\" \"iso_head iso_f = snd o snd\" \"iso_tail iso_f = fst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iso_verts iso_f = id &&&\n    iso_head iso_f = snd \\<circ> snd &&& iso_tail iso_f = fst", "unfolding iso_f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. iso_verts\n     \\<lparr>iso_verts = id,\n        iso_arcs = \\<lambda>a. (tail G a, f a, head G a),\n        iso_head = snd \\<circ> snd, iso_tail = fst\\<rparr> =\n    id &&&\n    iso_head\n     \\<lparr>iso_verts = id,\n        iso_arcs = \\<lambda>a. (tail G a, f a, head G a),\n        iso_head = snd \\<circ> snd, iso_tail = fst\\<rparr> =\n    snd \\<circ> snd &&&\n    iso_tail\n     \\<lparr>iso_verts = id,\n        iso_arcs = \\<lambda>a. (tail G a, f a, head G a),\n        iso_head = snd \\<circ> snd, iso_tail = fst\\<rparr> =\n    fst", "by auto"], ["proof (state)\nthis:\n  iso_verts iso_f = id\n  iso_head iso_f = snd \\<circ> snd\n  iso_tail iso_f = fst\n\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "have di_iso_f: \"digraph_isomorphism iso_f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. digraph_isomorphism iso_f", "unfolding digraph_isomorphism_def iso_f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_digraph G \\<and>\n    inj_on\n     (iso_verts\n       \\<lparr>iso_verts = id,\n          iso_arcs = \\<lambda>a. (tail G a, f a, head G a),\n          iso_head = snd \\<circ> snd, iso_tail = fst\\<rparr>)\n     (verts G) \\<and>\n    inj_on\n     (iso_arcs\n       \\<lparr>iso_verts = id,\n          iso_arcs = \\<lambda>a. (tail G a, f a, head G a),\n          iso_head = snd \\<circ> snd, iso_tail = fst\\<rparr>)\n     (arcs G) \\<and>\n    (\\<forall>a\\<in>arcs G.\n        iso_verts\n         \\<lparr>iso_verts = id,\n            iso_arcs = \\<lambda>a. (tail G a, f a, head G a),\n            iso_head = snd \\<circ> snd, iso_tail = fst\\<rparr>\n         (tail G a) =\n        iso_tail\n         \\<lparr>iso_verts = id,\n            iso_arcs = \\<lambda>a. (tail G a, f a, head G a),\n            iso_head = snd \\<circ> snd, iso_tail = fst\\<rparr>\n         (iso_arcs\n           \\<lparr>iso_verts = id,\n              iso_arcs = \\<lambda>a. (tail G a, f a, head G a),\n              iso_head = snd \\<circ> snd, iso_tail = fst\\<rparr>\n           a) \\<and>\n        iso_verts\n         \\<lparr>iso_verts = id,\n            iso_arcs = \\<lambda>a. (tail G a, f a, head G a),\n            iso_head = snd \\<circ> snd, iso_tail = fst\\<rparr>\n         (head G a) =\n        iso_head\n         \\<lparr>iso_verts = id,\n            iso_arcs = \\<lambda>a. (tail G a, f a, head G a),\n            iso_head = snd \\<circ> snd, iso_tail = fst\\<rparr>\n         (iso_arcs\n           \\<lparr>iso_verts = id,\n              iso_arcs = \\<lambda>a. (tail G a, f a, head G a),\n              iso_head = snd \\<circ> snd, iso_tail = fst\\<rparr>\n           a))", "by (auto intro: inj_onI wf_digraph dest: inj_onD[OF i])"], ["proof (state)\nthis:\n  digraph_isomorphism iso_f\n\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "let ?iso_g = \"inv_iso iso_f\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "have [simp]: \"\\<And>u. u \\<in> verts G \\<Longrightarrow> iso_verts ?iso_g u = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> verts G \\<Longrightarrow> iso_verts (inv_iso iso_f) u = u", "by (auto simp: inv_iso_def fun_eq_iff the_inv_into_f_eq)"], ["proof (state)\nthis:\n  ?u2 \\<in> verts G \\<Longrightarrow> iso_verts (inv_iso iso_f) ?u2 = ?u2\n\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "let ?H = \"app_iso iso_f G\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "interpret H: fin_digraph ?H"], ["proof (prove)\ngoal (1 subgoal):\n 1. fin_digraph (app_iso iso_f G)", "using di_iso_f"], ["proof (prove)\nusing this:\n  digraph_isomorphism iso_f\n\ngoal (1 subgoal):\n 1. fin_digraph (app_iso iso_f G)", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "have \"\\<exists>p. H.euler_trail u p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. H.euler_trail u p v", "using di_iso_f assms i"], ["proof (prove)\nusing this:\n  digraph_isomorphism iso_f\n  Digraph_Component.connected G\n  u \\<in> verts G\n  v \\<in> verts G\n  \\<lbrakk>?w2 \\<in> verts G; u \\<noteq> ?w2; v \\<noteq> ?w2\\<rbrakk>\n  \\<Longrightarrow> in_degree G ?w2 = out_degree G ?w2\n  in_degree G u + 1 = out_degree G u\n  out_degree G v + 1 = in_degree G v\n  inj_on f (arcs G)\n\ngoal (1 subgoal):\n 1. \\<exists>p. H.euler_trail u p v", "by (intro open_euler_infinite_label) (auto simp: connectedI_app_iso app_iso_eq)"], ["proof (state)\nthis:\n  \\<exists>p. H.euler_trail u p v\n\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "then"], ["proof (chain)\npicking this:\n  \\<exists>p. H.euler_trail u p v", "obtain p where Het: \"H.euler_trail u p v\""], ["proof (prove)\nusing this:\n  \\<exists>p. H.euler_trail u p v\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        H.euler_trail u p v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  H.euler_trail u p v\n\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "have \"pre_digraph.euler_trail (app_iso ?iso_g ?H) (iso_verts ?iso_g u) (map (iso_arcs ?iso_g) p) (iso_verts ?iso_g v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pre_digraph.euler_trail (app_iso (inv_iso iso_f) (app_iso iso_f G))\n     (iso_verts (inv_iso iso_f) u) (map (iso_arcs (inv_iso iso_f)) p)\n     (iso_verts (inv_iso iso_f) v)", "using Het"], ["proof (prove)\nusing this:\n  H.euler_trail u p v\n\ngoal (1 subgoal):\n 1. pre_digraph.euler_trail (app_iso (inv_iso iso_f) (app_iso iso_f G))\n     (iso_verts (inv_iso iso_f) u) (map (iso_arcs (inv_iso iso_f)) p)\n     (iso_verts (inv_iso iso_f) v)", "by (intro H.euler_trail_app_isoI digraph_isomorphism_invI di_iso_f)"], ["proof (state)\nthis:\n  pre_digraph.euler_trail (app_iso (inv_iso iso_f) (app_iso iso_f G))\n   (iso_verts (inv_iso iso_f) u) (map (iso_arcs (inv_iso iso_f)) p)\n   (iso_verts (inv_iso iso_f) v)\n\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "then"], ["proof (chain)\npicking this:\n  pre_digraph.euler_trail (app_iso (inv_iso iso_f) (app_iso iso_f G))\n   (iso_verts (inv_iso iso_f) u) (map (iso_arcs (inv_iso iso_f)) p)\n   (iso_verts (inv_iso iso_f) v)", "show ?thesis"], ["proof (prove)\nusing this:\n  pre_digraph.euler_trail (app_iso (inv_iso iso_f) (app_iso iso_f G))\n   (iso_verts (inv_iso iso_f) u) (map (iso_arcs (inv_iso iso_f)) p)\n   (iso_verts (inv_iso iso_f) v)\n\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "using di_iso_f \\<open>u \\<in> _\\<close> \\<open>v \\<in> _\\<close>"], ["proof (prove)\nusing this:\n  pre_digraph.euler_trail (app_iso (inv_iso iso_f) (app_iso iso_f G))\n   (iso_verts (inv_iso iso_f) u) (map (iso_arcs (inv_iso iso_f)) p)\n   (iso_verts (inv_iso iso_f) v)\n  digraph_isomorphism iso_f\n  u \\<in> verts G\n  v \\<in> verts G\n\ngoal (1 subgoal):\n 1. \\<exists>p. euler_trail u p v", "by simp rule"], ["proof (state)\nthis:\n  \\<exists>p. euler_trail u p v\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem open_euler2:\n  assumes et: \"euler_trail u p v\" and \"u \\<noteq> v\"\n  shows \"connected G \\<and>\n    (\\<forall>w \\<in> verts G. u \\<noteq> w \\<longrightarrow> v \\<noteq> w \\<longrightarrow> in_degree G w = out_degree G w) \\<and>\n    in_degree G u + 1 = out_degree G u \\<and>\n    out_degree G v + 1 = in_degree G v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Digraph_Component.connected G \\<and>\n    (\\<forall>w\\<in>verts G.\n        u \\<noteq> w \\<longrightarrow>\n        v \\<noteq> w \\<longrightarrow>\n        in_degree G w = out_degree G w) \\<and>\n    in_degree G u + 1 = out_degree G u \\<and>\n    out_degree G v + 1 = in_degree G v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Digraph_Component.connected G \\<and>\n    (\\<forall>w\\<in>verts G.\n        u \\<noteq> w \\<longrightarrow>\n        v \\<noteq> w \\<longrightarrow>\n        in_degree G w = out_degree G w) \\<and>\n    in_degree G u + 1 = out_degree G u \\<and>\n    out_degree G v + 1 = in_degree G v", "from et"], ["proof (chain)\npicking this:\n  euler_trail u p v", "have *: \"trail u p v\" \"u \\<in> verts G\" \"v \\<in> verts G\""], ["proof (prove)\nusing this:\n  euler_trail u p v\n\ngoal (1 subgoal):\n 1. trail u p v &&& u \\<in> verts G &&& v \\<in> verts G", "by (auto simp: euler_trail_def trail_def awalk_hd_in_verts)"], ["proof (state)\nthis:\n  trail u p v\n  u \\<in> verts G\n  v \\<in> verts G\n\ngoal (1 subgoal):\n 1. Digraph_Component.connected G \\<and>\n    (\\<forall>w\\<in>verts G.\n        u \\<noteq> w \\<longrightarrow>\n        v \\<noteq> w \\<longrightarrow>\n        in_degree G w = out_degree G w) \\<and>\n    in_degree G u + 1 = out_degree G u \\<and>\n    out_degree G v + 1 = in_degree G v", "from et"], ["proof (chain)\npicking this:\n  euler_trail u p v", "have [simp]: \"\\<And>u. card (in_arcs G u \\<inter> set p) = in_degree G u\"\n      \"\\<And>u. card (out_arcs G u \\<inter> set p) = out_degree G u\""], ["proof (prove)\nusing this:\n  euler_trail u p v\n\ngoal (1 subgoal):\n 1. (\\<And>u. card (in_arcs G u \\<inter> set p) = in_degree G u) &&&\n    (\\<And>u. card (out_arcs G u \\<inter> set p) = out_degree G u)", "by (auto simp: in_degree_def out_degree_def euler_trail_def intro: arg_cong[where f=card])"], ["proof (state)\nthis:\n  card (in_arcs G ?u2 \\<inter> set p) = in_degree G ?u2\n  card (out_arcs G ?u2 \\<inter> set p) = out_degree G ?u2\n\ngoal (1 subgoal):\n 1. Digraph_Component.connected G \\<and>\n    (\\<forall>w\\<in>verts G.\n        u \\<noteq> w \\<longrightarrow>\n        v \\<noteq> w \\<longrightarrow>\n        in_degree G w = out_degree G w) \\<and>\n    in_degree G u + 1 = out_degree G u \\<and>\n    out_degree G v + 1 = in_degree G v", "from assms *"], ["proof (chain)\npicking this:\n  euler_trail u p v\n  u \\<noteq> v\n  trail u p v\n  u \\<in> verts G\n  v \\<in> verts G", "show ?thesis"], ["proof (prove)\nusing this:\n  euler_trail u p v\n  u \\<noteq> v\n  trail u p v\n  u \\<in> verts G\n  v \\<in> verts G\n\ngoal (1 subgoal):\n 1. Digraph_Component.connected G \\<and>\n    (\\<forall>w\\<in>verts G.\n        u \\<noteq> w \\<longrightarrow>\n        v \\<noteq> w \\<longrightarrow>\n        in_degree G w = out_degree G w) \\<and>\n    in_degree G u + 1 = out_degree G u \\<and>\n    out_degree G v + 1 = in_degree G v", "by (auto simp: arc_set_balance_def elim: trail_arc_balanceE\n        intro: euler_imp_connected)"], ["proof (state)\nthis:\n  Digraph_Component.connected G \\<and>\n  (\\<forall>w\\<in>verts G.\n      u \\<noteq> w \\<longrightarrow>\n      v \\<noteq> w \\<longrightarrow> in_degree G w = out_degree G w) \\<and>\n  in_degree G u + 1 = out_degree G u \\<and>\n  out_degree G v + 1 = in_degree G v\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary open_euler:\n  \"(\\<exists>u p v. euler_trail u p v \\<and> u \\<noteq> v) \\<longleftrightarrow>\n    connected G \\<and> (\\<exists>u v. u \\<in> verts G \\<and> v \\<in> verts G \\<and>\n      (\\<forall>w \\<in> verts G. u \\<noteq> w \\<longrightarrow> v \\<noteq> w \\<longrightarrow> in_degree G w = out_degree G w) \\<and>\n      in_degree G u + 1 = out_degree G u \\<and>\n      out_degree G v + 1 = in_degree G v)\" (is \"?L \\<longleftrightarrow> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>u p v. euler_trail u p v \\<and> u \\<noteq> v) =\n    (Digraph_Component.connected G \\<and>\n     (\\<exists>u v.\n         u \\<in> verts G \\<and>\n         v \\<in> verts G \\<and>\n         (\\<forall>w\\<in>verts G.\n             u \\<noteq> w \\<longrightarrow>\n             v \\<noteq> w \\<longrightarrow>\n             in_degree G w = out_degree G w) \\<and>\n         in_degree G u + 1 = out_degree G u \\<and>\n         out_degree G v + 1 = in_degree G v))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>u p v. euler_trail u p v \\<and> u \\<noteq> v \\<Longrightarrow>\n    Digraph_Component.connected G \\<and>\n    (\\<exists>u v.\n        u \\<in> verts G \\<and>\n        v \\<in> verts G \\<and>\n        (\\<forall>w\\<in>verts G.\n            u \\<noteq> w \\<longrightarrow>\n            v \\<noteq> w \\<longrightarrow>\n            in_degree G w = out_degree G w) \\<and>\n        in_degree G u + 1 = out_degree G u \\<and>\n        out_degree G v + 1 = in_degree G v)\n 2. Digraph_Component.connected G \\<and>\n    (\\<exists>u v.\n        u \\<in> verts G \\<and>\n        v \\<in> verts G \\<and>\n        (\\<forall>w\\<in>verts G.\n            u \\<noteq> w \\<longrightarrow>\n            v \\<noteq> w \\<longrightarrow>\n            in_degree G w = out_degree G w) \\<and>\n        in_degree G u + 1 = out_degree G u \\<and>\n        out_degree G v + 1 = in_degree G v) \\<Longrightarrow>\n    \\<exists>u p v. euler_trail u p v \\<and> u \\<noteq> v", "assume ?L"], ["proof (state)\nthis:\n  \\<exists>u p v. euler_trail u p v \\<and> u \\<noteq> v\n\ngoal (2 subgoals):\n 1. \\<exists>u p v. euler_trail u p v \\<and> u \\<noteq> v \\<Longrightarrow>\n    Digraph_Component.connected G \\<and>\n    (\\<exists>u v.\n        u \\<in> verts G \\<and>\n        v \\<in> verts G \\<and>\n        (\\<forall>w\\<in>verts G.\n            u \\<noteq> w \\<longrightarrow>\n            v \\<noteq> w \\<longrightarrow>\n            in_degree G w = out_degree G w) \\<and>\n        in_degree G u + 1 = out_degree G u \\<and>\n        out_degree G v + 1 = in_degree G v)\n 2. Digraph_Component.connected G \\<and>\n    (\\<exists>u v.\n        u \\<in> verts G \\<and>\n        v \\<in> verts G \\<and>\n        (\\<forall>w\\<in>verts G.\n            u \\<noteq> w \\<longrightarrow>\n            v \\<noteq> w \\<longrightarrow>\n            in_degree G w = out_degree G w) \\<and>\n        in_degree G u + 1 = out_degree G u \\<and>\n        out_degree G v + 1 = in_degree G v) \\<Longrightarrow>\n    \\<exists>u p v. euler_trail u p v \\<and> u \\<noteq> v", "then"], ["proof (chain)\npicking this:\n  \\<exists>u p v. euler_trail u p v \\<and> u \\<noteq> v", "obtain u p v where *: \"euler_trail u p v\" \"u \\<noteq> v\""], ["proof (prove)\nusing this:\n  \\<exists>u p v. euler_trail u p v \\<and> u \\<noteq> v\n\ngoal (1 subgoal):\n 1. (\\<And>u p v.\n        \\<lbrakk>euler_trail u p v; u \\<noteq> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  euler_trail u p v\n  u \\<noteq> v\n\ngoal (2 subgoals):\n 1. \\<exists>u p v. euler_trail u p v \\<and> u \\<noteq> v \\<Longrightarrow>\n    Digraph_Component.connected G \\<and>\n    (\\<exists>u v.\n        u \\<in> verts G \\<and>\n        v \\<in> verts G \\<and>\n        (\\<forall>w\\<in>verts G.\n            u \\<noteq> w \\<longrightarrow>\n            v \\<noteq> w \\<longrightarrow>\n            in_degree G w = out_degree G w) \\<and>\n        in_degree G u + 1 = out_degree G u \\<and>\n        out_degree G v + 1 = in_degree G v)\n 2. Digraph_Component.connected G \\<and>\n    (\\<exists>u v.\n        u \\<in> verts G \\<and>\n        v \\<in> verts G \\<and>\n        (\\<forall>w\\<in>verts G.\n            u \\<noteq> w \\<longrightarrow>\n            v \\<noteq> w \\<longrightarrow>\n            in_degree G w = out_degree G w) \\<and>\n        in_degree G u + 1 = out_degree G u \\<and>\n        out_degree G v + 1 = in_degree G v) \\<Longrightarrow>\n    \\<exists>u p v. euler_trail u p v \\<and> u \\<noteq> v", "then"], ["proof (chain)\npicking this:\n  euler_trail u p v\n  u \\<noteq> v", "have \"u \\<in> verts G\" \"v \\<in> verts G\""], ["proof (prove)\nusing this:\n  euler_trail u p v\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. u \\<in> verts G &&& v \\<in> verts G", "by (auto simp: euler_trail_def trail_def awalk_hd_in_verts)"], ["proof (state)\nthis:\n  u \\<in> verts G\n  v \\<in> verts G\n\ngoal (2 subgoals):\n 1. \\<exists>u p v. euler_trail u p v \\<and> u \\<noteq> v \\<Longrightarrow>\n    Digraph_Component.connected G \\<and>\n    (\\<exists>u v.\n        u \\<in> verts G \\<and>\n        v \\<in> verts G \\<and>\n        (\\<forall>w\\<in>verts G.\n            u \\<noteq> w \\<longrightarrow>\n            v \\<noteq> w \\<longrightarrow>\n            in_degree G w = out_degree G w) \\<and>\n        in_degree G u + 1 = out_degree G u \\<and>\n        out_degree G v + 1 = in_degree G v)\n 2. Digraph_Component.connected G \\<and>\n    (\\<exists>u v.\n        u \\<in> verts G \\<and>\n        v \\<in> verts G \\<and>\n        (\\<forall>w\\<in>verts G.\n            u \\<noteq> w \\<longrightarrow>\n            v \\<noteq> w \\<longrightarrow>\n            in_degree G w = out_degree G w) \\<and>\n        in_degree G u + 1 = out_degree G u \\<and>\n        out_degree G v + 1 = in_degree G v) \\<Longrightarrow>\n    \\<exists>u p v. euler_trail u p v \\<and> u \\<noteq> v", "then"], ["proof (chain)\npicking this:\n  u \\<in> verts G\n  v \\<in> verts G", "show ?R"], ["proof (prove)\nusing this:\n  u \\<in> verts G\n  v \\<in> verts G\n\ngoal (1 subgoal):\n 1. Digraph_Component.connected G \\<and>\n    (\\<exists>u v.\n        u \\<in> verts G \\<and>\n        v \\<in> verts G \\<and>\n        (\\<forall>w\\<in>verts G.\n            u \\<noteq> w \\<longrightarrow>\n            v \\<noteq> w \\<longrightarrow>\n            in_degree G w = out_degree G w) \\<and>\n        in_degree G u + 1 = out_degree G u \\<and>\n        out_degree G v + 1 = in_degree G v)", "using open_euler2[OF *]"], ["proof (prove)\nusing this:\n  u \\<in> verts G\n  v \\<in> verts G\n  Digraph_Component.connected G \\<and>\n  (\\<forall>w\\<in>verts G.\n      u \\<noteq> w \\<longrightarrow>\n      v \\<noteq> w \\<longrightarrow> in_degree G w = out_degree G w) \\<and>\n  in_degree G u + 1 = out_degree G u \\<and>\n  out_degree G v + 1 = in_degree G v\n\ngoal (1 subgoal):\n 1. Digraph_Component.connected G \\<and>\n    (\\<exists>u v.\n        u \\<in> verts G \\<and>\n        v \\<in> verts G \\<and>\n        (\\<forall>w\\<in>verts G.\n            u \\<noteq> w \\<longrightarrow>\n            v \\<noteq> w \\<longrightarrow>\n            in_degree G w = out_degree G w) \\<and>\n        in_degree G u + 1 = out_degree G u \\<and>\n        out_degree G v + 1 = in_degree G v)", "by blast"], ["proof (state)\nthis:\n  Digraph_Component.connected G \\<and>\n  (\\<exists>u v.\n      u \\<in> verts G \\<and>\n      v \\<in> verts G \\<and>\n      (\\<forall>w\\<in>verts G.\n          u \\<noteq> w \\<longrightarrow>\n          v \\<noteq> w \\<longrightarrow>\n          in_degree G w = out_degree G w) \\<and>\n      in_degree G u + 1 = out_degree G u \\<and>\n      out_degree G v + 1 = in_degree G v)\n\ngoal (1 subgoal):\n 1. Digraph_Component.connected G \\<and>\n    (\\<exists>u v.\n        u \\<in> verts G \\<and>\n        v \\<in> verts G \\<and>\n        (\\<forall>w\\<in>verts G.\n            u \\<noteq> w \\<longrightarrow>\n            v \\<noteq> w \\<longrightarrow>\n            in_degree G w = out_degree G w) \\<and>\n        in_degree G u + 1 = out_degree G u \\<and>\n        out_degree G v + 1 = in_degree G v) \\<Longrightarrow>\n    \\<exists>u p v. euler_trail u p v \\<and> u \\<noteq> v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Digraph_Component.connected G \\<and>\n    (\\<exists>u v.\n        u \\<in> verts G \\<and>\n        v \\<in> verts G \\<and>\n        (\\<forall>w\\<in>verts G.\n            u \\<noteq> w \\<longrightarrow>\n            v \\<noteq> w \\<longrightarrow>\n            in_degree G w = out_degree G w) \\<and>\n        in_degree G u + 1 = out_degree G u \\<and>\n        out_degree G v + 1 = in_degree G v) \\<Longrightarrow>\n    \\<exists>u p v. euler_trail u p v \\<and> u \\<noteq> v", "assume ?R"], ["proof (state)\nthis:\n  Digraph_Component.connected G \\<and>\n  (\\<exists>u v.\n      u \\<in> verts G \\<and>\n      v \\<in> verts G \\<and>\n      (\\<forall>w\\<in>verts G.\n          u \\<noteq> w \\<longrightarrow>\n          v \\<noteq> w \\<longrightarrow>\n          in_degree G w = out_degree G w) \\<and>\n      in_degree G u + 1 = out_degree G u \\<and>\n      out_degree G v + 1 = in_degree G v)\n\ngoal (1 subgoal):\n 1. Digraph_Component.connected G \\<and>\n    (\\<exists>u v.\n        u \\<in> verts G \\<and>\n        v \\<in> verts G \\<and>\n        (\\<forall>w\\<in>verts G.\n            u \\<noteq> w \\<longrightarrow>\n            v \\<noteq> w \\<longrightarrow>\n            in_degree G w = out_degree G w) \\<and>\n        in_degree G u + 1 = out_degree G u \\<and>\n        out_degree G v + 1 = in_degree G v) \\<Longrightarrow>\n    \\<exists>u p v. euler_trail u p v \\<and> u \\<noteq> v", "then"], ["proof (chain)\npicking this:\n  Digraph_Component.connected G \\<and>\n  (\\<exists>u v.\n      u \\<in> verts G \\<and>\n      v \\<in> verts G \\<and>\n      (\\<forall>w\\<in>verts G.\n          u \\<noteq> w \\<longrightarrow>\n          v \\<noteq> w \\<longrightarrow>\n          in_degree G w = out_degree G w) \\<and>\n      in_degree G u + 1 = out_degree G u \\<and>\n      out_degree G v + 1 = in_degree G v)", "obtain u v where *:\n    \"connected G\" \"u \\<in> verts G\" \"v \\<in> verts G\"\n    \"\\<And>w. \\<lbrakk>w \\<in> verts G; u \\<noteq> w; v \\<noteq> w\\<rbrakk> \\<Longrightarrow> in_degree G w = out_degree G w\"\n    \"in_degree G u + 1 = out_degree G u\"\n    \"out_degree G v + 1 = in_degree G v\""], ["proof (prove)\nusing this:\n  Digraph_Component.connected G \\<and>\n  (\\<exists>u v.\n      u \\<in> verts G \\<and>\n      v \\<in> verts G \\<and>\n      (\\<forall>w\\<in>verts G.\n          u \\<noteq> w \\<longrightarrow>\n          v \\<noteq> w \\<longrightarrow>\n          in_degree G w = out_degree G w) \\<and>\n      in_degree G u + 1 = out_degree G u \\<and>\n      out_degree G v + 1 = in_degree G v)\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>Digraph_Component.connected G; u \\<in> verts G;\n         v \\<in> verts G;\n         \\<And>w.\n            \\<lbrakk>w \\<in> verts G; u \\<noteq> w; v \\<noteq> w\\<rbrakk>\n            \\<Longrightarrow> in_degree G w = out_degree G w;\n         in_degree G u + 1 = out_degree G u;\n         out_degree G v + 1 = in_degree G v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Digraph_Component.connected G\n  u \\<in> verts G\n  v \\<in> verts G\n  \\<lbrakk>?w2 \\<in> verts G; u \\<noteq> ?w2; v \\<noteq> ?w2\\<rbrakk>\n  \\<Longrightarrow> in_degree G ?w2 = out_degree G ?w2\n  in_degree G u + 1 = out_degree G u\n  out_degree G v + 1 = in_degree G v\n\ngoal (1 subgoal):\n 1. Digraph_Component.connected G \\<and>\n    (\\<exists>u v.\n        u \\<in> verts G \\<and>\n        v \\<in> verts G \\<and>\n        (\\<forall>w\\<in>verts G.\n            u \\<noteq> w \\<longrightarrow>\n            v \\<noteq> w \\<longrightarrow>\n            in_degree G w = out_degree G w) \\<and>\n        in_degree G u + 1 = out_degree G u \\<and>\n        out_degree G v + 1 = in_degree G v) \\<Longrightarrow>\n    \\<exists>u p v. euler_trail u p v \\<and> u \\<noteq> v", "then"], ["proof (chain)\npicking this:\n  Digraph_Component.connected G\n  u \\<in> verts G\n  v \\<in> verts G\n  \\<lbrakk>?w2 \\<in> verts G; u \\<noteq> ?w2; v \\<noteq> ?w2\\<rbrakk>\n  \\<Longrightarrow> in_degree G ?w2 = out_degree G ?w2\n  in_degree G u + 1 = out_degree G u\n  out_degree G v + 1 = in_degree G v", "have \"u \\<noteq> v\""], ["proof (prove)\nusing this:\n  Digraph_Component.connected G\n  u \\<in> verts G\n  v \\<in> verts G\n  \\<lbrakk>?w2 \\<in> verts G; u \\<noteq> ?w2; v \\<noteq> ?w2\\<rbrakk>\n  \\<Longrightarrow> in_degree G ?w2 = out_degree G ?w2\n  in_degree G u + 1 = out_degree G u\n  out_degree G v + 1 = in_degree G v\n\ngoal (1 subgoal):\n 1. u \\<noteq> v", "by auto"], ["proof (state)\nthis:\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. Digraph_Component.connected G \\<and>\n    (\\<exists>u v.\n        u \\<in> verts G \\<and>\n        v \\<in> verts G \\<and>\n        (\\<forall>w\\<in>verts G.\n            u \\<noteq> w \\<longrightarrow>\n            v \\<noteq> w \\<longrightarrow>\n            in_degree G w = out_degree G w) \\<and>\n        in_degree G u + 1 = out_degree G u \\<and>\n        out_degree G v + 1 = in_degree G v) \\<Longrightarrow>\n    \\<exists>u p v. euler_trail u p v \\<and> u \\<noteq> v", "from *"], ["proof (chain)\npicking this:\n  Digraph_Component.connected G\n  u \\<in> verts G\n  v \\<in> verts G\n  \\<lbrakk>?w2 \\<in> verts G; u \\<noteq> ?w2; v \\<noteq> ?w2\\<rbrakk>\n  \\<Longrightarrow> in_degree G ?w2 = out_degree G ?w2\n  in_degree G u + 1 = out_degree G u\n  out_degree G v + 1 = in_degree G v", "show ?L"], ["proof (prove)\nusing this:\n  Digraph_Component.connected G\n  u \\<in> verts G\n  v \\<in> verts G\n  \\<lbrakk>?w2 \\<in> verts G; u \\<noteq> ?w2; v \\<noteq> ?w2\\<rbrakk>\n  \\<Longrightarrow> in_degree G ?w2 = out_degree G ?w2\n  in_degree G u + 1 = out_degree G u\n  out_degree G v + 1 = in_degree G v\n\ngoal (1 subgoal):\n 1. \\<exists>u p v. euler_trail u p v \\<and> u \\<noteq> v", "by (metis open_euler1 \\<open>u \\<noteq> v\\<close>)"], ["proof (state)\nthis:\n  \\<exists>u p v. euler_trail u p v \\<and> u \\<noteq> v\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}