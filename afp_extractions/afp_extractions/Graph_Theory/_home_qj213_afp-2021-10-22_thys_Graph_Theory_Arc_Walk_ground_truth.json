{"file_name": "/home/qj213/afp-2021-10-22/thys/Graph_Theory/Arc_Walk.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Graph_Theory", "problem_names": ["lemma cas_simp:\n  assumes \"es \\<noteq> []\"\n  shows \"cas u es v \\<longleftrightarrow> tail G (hd es) = u \\<and> cas (head G (hd es)) (tl es) v\"", "lemma (in pre_digraph) awalk_verts_conv:\n  \"awalk_verts u p = (if p = [] then [u] else map (tail G) p @ [head G (last p)])\"", "lemma (in pre_digraph) awalk_verts_conv':\n  assumes \"cas u p v\"\n  shows \"awalk_verts u p = (if p = [] then [u] else tail G (hd p) # map (head G) p)\"", "lemma (in pre_digraph) length_awalk_verts:\n  \"length (awalk_verts u p) = Suc (length p)\"", "lemma (in pre_digraph) awalk_verts_ne_eq:\n  assumes \"p \\<noteq> []\"\n  shows \"awalk_verts u p = awalk_verts v p\"", "lemma (in pre_digraph) awalk_verts_non_Nil[simp]:\n  \"awalk_verts u p \\<noteq> []\"", "lemma\n  assumes \"cas u p v\"\n  shows awhd_if_cas: \"awhd u p = u\" and awlast_if_cas: \"awlast u p = v\"", "lemma awalk_verts_in_verts:\n  assumes \"u \\<in> verts G\" \"set p \\<subseteq> arcs G\" \"v \\<in> set (awalk_verts u p)\"\n  shows \"v \\<in> verts G\"", "lemma\n  assumes \"u \\<in> verts G\" \"set p \\<subseteq> arcs G\"\n  shows awhd_in_verts: \"awhd u p \\<in> verts G\"\n    and awlast_in_verts: \"awlast u p \\<in> verts G\"", "lemma awalk_conv:\n  \"awalk u p v = (set (awalk_verts u p) \\<subseteq> verts G\n    \\<and> set p \\<subseteq> arcs G\n    \\<and> awhd u p = u \\<and> awlast u p = v \\<and> cas u p v)\"", "lemma awalkI:\n  assumes \"set (awalk_verts u p) \\<subseteq> verts G\" \"set p \\<subseteq> arcs G\" \"cas u p v\"\n  shows \"awalk u p v\"", "lemma awalkE[elim]:\n  assumes \"awalk u p v\"\n  obtains \"set (awalk_verts u p) \\<subseteq> verts G\" \"set p \\<subseteq> arcs G\" \"cas u p v\"\n    \"awhd u p = u\" \"awlast u p = v\"", "lemma awalk_Nil_iff:\n  \"awalk u [] v \\<longleftrightarrow> u = v \\<and> u \\<in> verts G\"", "lemma trail_Nil_iff:\n  \"trail u [] v \\<longleftrightarrow> u = v \\<and> u \\<in> verts G\"", "lemma apath_Nil_iff: \"apath u [] v \\<longleftrightarrow> u = v \\<and> u \\<in> verts G\"", "lemma awalk_hd_in_verts: \"awalk u p v \\<Longrightarrow> u \\<in> verts G\"", "lemma awalk_last_in_verts: \"awalk u p v \\<Longrightarrow> v \\<in> verts G\"", "lemma hd_in_awalk_verts:\n  \"awalk u p v \\<Longrightarrow> u \\<in> set (awalk_verts u p)\"\n  \"apath u p v \\<Longrightarrow> u \\<in> set (awalk_verts u p)\"", "lemma awalk_Cons_iff:\n  \"awalk u (e # es) w \\<longleftrightarrow> e \\<in> arcs G \\<and> u = tail G e \\<and> awalk (head G e) es w\"", "lemma trail_Cons_iff:\n  \"trail u (e # es ) w \\<longleftrightarrow> e \\<in> arcs G \\<and> u = tail G e \\<and> e \\<notin> set es \\<and> trail (head G e) es w\"", "lemma apath_Cons_iff:\n  \"apath u (e # es) w \\<longleftrightarrow> e \\<in> arcs G \\<and> tail G e = u \\<and> apath (head G e) es w\n    \\<and> tail G e \\<notin> set (awalk_verts (head G e) es)\" (is \"?L \\<longleftrightarrow> ?R\")", "lemmas awalk_simps = awalk_Nil_iff awalk_Cons_iff", "lemmas trail_simps = trail_Nil_iff trail_Cons_iff", "lemmas apath_simps = apath_Nil_iff apath_Cons_iff", "lemma arc_implies_awalk:\n  \"e \\<in> arcs G \\<Longrightarrow> awalk (tail G e) [e] (head G e)\"", "lemma apath_nonempty_ends:\n  assumes \"apath u p v\"\n  assumes \"p \\<noteq> []\"\n  shows \"u \\<noteq> v\"", "lemma awalk_ConsI:\n  assumes \"awalk v es w\"\n  assumes \"e \\<in> arcs G\" and \"arc_to_ends G e = (u,v)\"\n  shows \"awalk u (e # es) w\"", "lemma (in pre_digraph) awalkI_apath:\n  assumes \"apath u p v\" shows \"awalk u p v\"", "lemma arcE:\n  assumes \"arc e (u,v)\"\n  assumes \"\\<lbrakk>e \\<in> arcs G; tail G e = u; head G e = v\\<rbrakk> \\<Longrightarrow> P\"\n  shows \"P\"", "lemma in_arcs_imp_in_arcs_ends:\n  assumes \"e \\<in> arcs G\"\n  shows \"(tail G e, head G e) \\<in> arcs_ends G\"", "lemma set_awalk_verts_cas:\n  assumes \"cas u p v\"\n  shows \"set (awalk_verts u p) = {u} \\<union> set (map (tail G) p) \\<union> set (map (head G) p)\"", "lemma set_awalk_verts_not_Nil_cas:\n  assumes \"cas u p v\" \"p \\<noteq> []\"\n  shows \"set (awalk_verts u p) = set (map (tail G) p) \\<union> set (map (head G) p)\"", "lemma set_awalk_verts:\n  assumes \"awalk u p v\"\n  shows \"set (awalk_verts u p) = {u} \\<union> set (map (tail G) p) \\<union> set (map (head G) p)\"", "lemma set_awalk_verts_not_Nil:\n  assumes \"awalk u p v\" \"p \\<noteq> []\"\n  shows \"set (awalk_verts u p) = set (map (tail G) p) \\<union> set (map (head G) p)\"", "lemma\n  awhd_of_awalk: \"awalk u p v \\<Longrightarrow> awhd u p = u\" and\n  awlast_of_awalk: \"awalk u p v \\<Longrightarrow> NOMATCH (awlast u p) v \\<Longrightarrow> awlast u p = v\"", "lemmas awends_of_awalk[simp] = awhd_of_awalk awlast_of_awalk", "lemma awalk_verts_arc1:\n  assumes \"e \\<in> set p\"\n  shows \"tail G e \\<in> set (awalk_verts u p)\"", "lemma awalk_verts_arc2:\n  assumes \"awalk u p v\" \"e \\<in> set p\"\n  shows \"head G e \\<in> set (awalk_verts u p)\"", "lemma awalk_induct_raw[case_names Base Cons(*, induct pred: awalk*)]:\n  assumes \"awalk u p v\"\n  assumes \"\\<And>w1. w1 \\<in> verts G \\<Longrightarrow> P w1 [] w1\"\n  assumes \"\\<And>w1 w2 e es. e \\<in> arcs G \\<Longrightarrow> arc_to_ends G e = (w1, w2)\n    \\<Longrightarrow> P w2 es v \\<Longrightarrow> P w1 (e # es) v\"\n  shows \"P u p v\"", "lemma (in pre_digraph) cas_append_iff[simp]:\n  \"cas u (p @ q) v \\<longleftrightarrow> cas u p (awlast u p) \\<and> cas (awlast u p) q v\"", "lemma cas_ends:\n  assumes \"cas u p v\" \"cas u' p v'\"\n  shows \"(p \\<noteq> [] \\<and> u = u' \\<and> v = v') \\<or> (p = [] \\<and> u = v \\<and> u' = v')\"", "lemma awalk_ends:\n  assumes \"awalk u p v\" \"awalk u' p v'\"\n  shows \"(p \\<noteq> [] \\<and> u = u' \\<and> v = v') \\<or> (p = [] \\<and> u = v \\<and> u' = v')\"", "lemma awalk_ends_eqD:\n  assumes \"awalk u p u\" \"awalk v p w\"\n  shows \"v = w\"", "lemma awalk_empty_ends:\n  assumes \"awalk u [] v\"\n  shows \"u = v\"", "lemma apath_ends:\n assumes \"apath u p v\" and \"apath u' p v'\"\n  shows \"(p \\<noteq> [] \\<and> u \\<noteq> v \\<and> u = u' \\<and> v = v') \\<or> (p = [] \\<and> u = v \\<and> u' = v')\"", "lemma awalk_append_iff[simp]:\n  \"awalk u (p @ q) v \\<longleftrightarrow> awalk u p (awlast u p) \\<and> awalk (awlast u p) q v\" (is \"?L \\<longleftrightarrow> ?R\")", "lemma awlast_append:\n  \"awlast u (p @ q) = awlast (awlast u p) q\"", "lemma awhd_append:\n  \"awhd u (p @ q) = awhd (awhd u q) p\"", "lemma awalkE'[elim]:\n  assumes \"awalk u p v\"\n  obtains \"set (awalk_verts u p) \\<subseteq> verts G\" \"set p \\<subseteq> arcs G\" \"cas u p v\"\n    \"awhd u p = u\" \"awlast u p = v\" \"u \\<in> verts G\" \"v \\<in> verts G\"", "lemma awalk_appendI:\n  assumes \"awalk u p v\"\n  assumes \"awalk v q w\"\n  shows \"awalk u (p @ q) w\"", "lemma awalk_verts_append_cas:\n  assumes \"cas u (p @ q) v\"\n  shows \"awalk_verts u (p @ q) = awalk_verts u p @ tl (awalk_verts (awlast u p) q)\"", "lemma awalk_verts_append:\n  assumes \"awalk u (p @ q) v\"\n  shows \"awalk_verts u (p @ q) = awalk_verts u p @ tl (awalk_verts (awlast u p) q)\"", "lemma awalk_verts_append2:\n  assumes \"awalk u (p @ q) v\"\n  shows \"awalk_verts u (p @ q) = butlast (awalk_verts u p) @ awalk_verts (awlast u p) q\"", "lemma apath_append_iff:\n  \"apath u (p @ q) v \\<longleftrightarrow> apath u p (awlast u p) \\<and> apath (awlast u p) q v \\<and>\n    set (awalk_verts u p) \\<inter> set (tl (awalk_verts (awlast u p) q)) = {}\" (is \"?L \\<longleftrightarrow> ?R\")", "lemma (in wf_digraph) set_awalk_verts_append_cas:\n  assumes \"cas u p v\" \"cas v q w\"\n  shows \"set (awalk_verts u (p @ q)) = set (awalk_verts u p) \\<union> set (awalk_verts v q)\"", "lemma (in wf_digraph) set_awalk_verts_append:\n  assumes \"awalk u p v\" \"awalk v q w\"\n  shows \"set (awalk_verts u (p @ q)) = set (awalk_verts u p) \\<union> set (awalk_verts v q)\"", "lemma cas_takeI:\n  assumes \"cas u p v\" \"awlast u (take n p) = v'\"\n  shows \"cas u (take n p) v'\"", "lemma cas_dropI:\n  assumes \"cas u p v\" \"awlast u (take n p) = u'\"\n  shows \"cas u' (drop n p) v\"", "lemma awalk_verts_take_conv:\n  assumes \"cas u p v\"\n  shows \"awalk_verts u (take n p) = take (Suc n) (awalk_verts u p)\"", "lemma awalk_verts_drop_conv:\n  assumes \"cas u p v\"\n  shows \"awalk_verts u' (drop n p) = (if n < length p then drop n (awalk_verts u p) else [u'])\"", "lemma awalk_decomp_verts:\n  assumes cas: \"cas u p v\" and ev_decomp: \"awalk_verts u p = xs @ y # ys\"\n  obtains q r where \"cas u q y\" \"cas y r v\" \"p = q @ r\" \"awalk_verts u q = xs @ [y]\" \"awalk_verts y r = y # ys\"", "lemma awalk_decomp:\n  assumes \"awalk u p v\"\n  assumes \"w \\<in> set (awalk_verts u p)\"\n  shows \"\\<exists>q r. p = q @ r \\<and> awalk u q w \\<and> awalk w r v\"", "lemma awalk_not_distinct_decomp:\n  assumes \"awalk u p v\"\n  assumes \"\\<not> distinct (awalk_verts u p)\"\n  shows \"\\<exists>q r s. p = q @ r @ s \\<and> distinct (awalk_verts u q)\n    \\<and> 0 < length r\n    \\<and> (\\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v)\"", "lemma apath_decomp_disjoint:\n  assumes \"apath u p v\"\n  assumes \"p = q @ r\"\n  assumes \"x \\<in> set (awalk_verts u q)\" \"x \\<in> set (tl (awalk_verts (awlast u q) r))\"\n  shows False", "lemma cycle_altdef:\n  \"cycle p \\<longleftrightarrow> closed_w p \\<and> (\\<exists>u. distinct (tl (awalk_verts u p)))\"", "lemma (in wf_digraph) distinct_tl_verts_imp_distinct:\n  assumes \"awalk u p v\"\n  assumes \"distinct (tl (awalk_verts u p))\"\n  shows \"distinct p\"", "lemma (in wf_digraph) distinct_verts_imp_distinct:\n  assumes \"awalk u p v\"\n  assumes \"distinct (awalk_verts u p)\"\n  shows \"distinct p\"", "lemma (in wf_digraph) cycle_conv:\n  \"cycle p \\<longleftrightarrow> (\\<exists>u. awalk u p u \\<and> distinct (tl (awalk_verts u p)) \\<and> distinct p \\<and> p \\<noteq> [])\"", "lemma (in loopfree_digraph) cycle_digraph_conv:\n  \"cycle p \\<longleftrightarrow> (\\<exists>u. awalk u p u \\<and> distinct (tl (awalk_verts u p)) \\<and> 2 \\<le> length p)\" (is \"?L \\<longleftrightarrow> ?R\")", "lemma (in wf_digraph) closed_w_imp_cycle:\n  assumes \"closed_w p\" shows \"\\<exists>p. cycle p\"", "lemma reachable1_awalk:\n  \"u \\<rightarrow>\\<^sup>+ v \\<longleftrightarrow> (\\<exists>p. awalk u p v \\<and> p \\<noteq> [])\"", "lemma reachable_awalk:\n  \"u \\<rightarrow>\\<^sup>* v \\<longleftrightarrow> (\\<exists>p. awalk u p v)\"", "lemma reachable_awalkI[intro?]:\n  assumes \"awalk u p v\"\n  shows \"u \\<rightarrow>\\<^sup>* v\"", "lemma reachable1_awalkI:\n  \"awalk v p w \\<Longrightarrow> p \\<noteq> [] \\<Longrightarrow> v \\<rightarrow>\\<^sup>+ w\"", "lemma reachable_arc_trans:\n  assumes \"u \\<rightarrow>\\<^sup>* v\" \"arc e (v,w)\"\n  shows \"u \\<rightarrow>\\<^sup>* w\"", "lemma awalk_verts_reachable_from:\n  assumes \"awalk u p v\" \"w \\<in> set (awalk_verts u p)\" shows \"u \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> w\"", "lemma awalk_verts_reachable_to:\n  assumes \"awalk u p v\" \"w \\<in> set (awalk_verts u p)\" shows \"w \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> v\"", "lemma (in fin_digraph) length_apath_less:\n  assumes \"apath u p v\"\n  shows \"length p < card (verts G)\"", "lemma (in fin_digraph) length_apath:\n  assumes \"apath u p v\"\n  shows \"length p \\<le> card (verts G)\"", "lemma (in fin_digraph) apaths_finite_triple:\n  shows \"finite {(u,p,v). apath u p v}\"", "lemma (in fin_digraph) apaths_finite:\n  shows \"finite {p. apath u p v}\"", "lemma awalk_cyc_decomp_has_prop:\n  assumes \"awalk u p v\" and \"\\<not>distinct (awalk_verts u p)\"\n  shows \"is_awalk_cyc_decomp p (awalk_cyc_decomp p)\"", "lemma awalk_cyc_decompE:\n  assumes dec: \"awalk_cyc_decomp p = (q,r,s)\"\n  assumes p_props: \"awalk u p v\" \"\\<not>distinct (awalk_verts u p)\"\n  obtains \"p = q @ r @ s\" \"distinct (awalk_verts u q)\" \"\\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v\" \"closed_w r\"", "lemma awalk_cyc_decompE':\n  assumes p_props: \"awalk u p v\" \"\\<not>distinct (awalk_verts u p)\"\n  obtains q r s where \"p = q @ r @ s\" \"distinct (awalk_verts u q)\" \"\\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v\" \"closed_w r\"", "lemma awalk_to_apath_induct[consumes 1, case_names path decomp]:\n  assumes awalk: \"awalk u p v\"\n  assumes dist: \"\\<And>p. awalk u p v \\<Longrightarrow> distinct (awalk_verts u p) \\<Longrightarrow> P p\"\n  assumes dec: \"\\<And>p q r s. \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q,r,s);\n    \\<not>distinct (awalk_verts u p); P (q @ s)\\<rbrakk> \\<Longrightarrow> P p\"\n  shows \"P p\"", "lemma step_awalk_to_apath:\n  assumes awalk: \"awalk u p v\"\n    and decomp: \"awalk_cyc_decomp p = (q, r, s)\"\n    and dist: \"\\<not> distinct (awalk_verts u p)\"\n  shows \"awalk_to_apath p = awalk_to_apath (q @ s)\"", "lemma apath_awalk_to_apath:\n  assumes \"awalk u p v\"\n  shows \"apath u (awalk_to_apath p) v\"", "lemma (in wf_digraph) awalk_to_apath_subset:\n  assumes \"awalk u p v\"\n  shows \"set (awalk_to_apath p) \\<subseteq> set p\"", "lemma reachable_apath:\n  \"u \\<rightarrow>\\<^sup>* v \\<longleftrightarrow> (\\<exists>p. apath u p v)\"", "lemma no_loops_in_apath:\n  assumes \"apath u p v\" \"a \\<in> set p\" shows \"tail G a \\<noteq> head G a\""], "translations": [["", "lemma cas_simp:\n  assumes \"es \\<noteq> []\"\n  shows \"cas u es v \\<longleftrightarrow> tail G (hd es) = u \\<and> cas (head G (hd es)) (tl es) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cas u es v = (tail G (hd es) = u \\<and> cas (head G (hd es)) (tl es) v)", "using assms"], ["proof (prove)\nusing this:\n  es \\<noteq> []\n\ngoal (1 subgoal):\n 1. cas u es v = (tail G (hd es) = u \\<and> cas (head G (hd es)) (tl es) v)", "by (cases es) auto"], ["", "definition awalk :: \"'a \\<Rightarrow> 'b awalk \\<Rightarrow> 'a \\<Rightarrow> bool\" where\n  \"awalk u p v \\<equiv> u \\<in> verts G \\<and> set p \\<subseteq> arcs G \\<and> cas u p v\""], ["", "(* XXX: rename to atrail? *)"], ["", "definition (in pre_digraph) trail :: \"'a \\<Rightarrow> 'b awalk \\<Rightarrow> 'a \\<Rightarrow> bool\" where\n  \"trail u p v \\<equiv> awalk u p v \\<and> distinct p\""], ["", "definition apath :: \"'a \\<Rightarrow>'b awalk \\<Rightarrow> 'a \\<Rightarrow> bool\" where\n  \"apath u p v \\<equiv> awalk u p v \\<and> distinct (awalk_verts u p)\""], ["", "end"], ["", "subsection \\<open>Basic Lemmas\\<close>"], ["", "lemma (in pre_digraph) awalk_verts_conv:\n  \"awalk_verts u p = (if p = [] then [u] else map (tail G) p @ [head G (last p)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk_verts u p =\n    (if p = [] then [u] else map (tail G) p @ [head G (last p)])", "by (induct p arbitrary: u) auto"], ["", "lemma (in pre_digraph) awalk_verts_conv':\n  assumes \"cas u p v\"\n  shows \"awalk_verts u p = (if p = [] then [u] else tail G (hd p) # map (head G) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk_verts u p =\n    (if p = [] then [u] else tail G (hd p) # map (head G) p)", "using assms"], ["proof (prove)\nusing this:\n  cas u p v\n\ngoal (1 subgoal):\n 1. awalk_verts u p =\n    (if p = [] then [u] else tail G (hd p) # map (head G) p)", "by (induct u p v rule: cas.induct) (auto simp: cas_simp)"], ["", "lemma (in pre_digraph) length_awalk_verts:\n  \"length (awalk_verts u p) = Suc (length p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (awalk_verts u p) = Suc (length p)", "by (simp add: awalk_verts_conv)"], ["", "lemma (in pre_digraph) awalk_verts_ne_eq:\n  assumes \"p \\<noteq> []\"\n  shows \"awalk_verts u p = awalk_verts v p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk_verts u p = awalk_verts v p", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. awalk_verts u p = awalk_verts v p", "by (auto simp: awalk_verts_conv)"], ["", "lemma (in pre_digraph) awalk_verts_non_Nil[simp]:\n  \"awalk_verts u p \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk_verts u p \\<noteq> []", "by (simp add: awalk_verts_conv)"], ["", "context wf_digraph begin"], ["", "lemma\n  assumes \"cas u p v\"\n  shows awhd_if_cas: \"awhd u p = u\" and awlast_if_cas: \"awlast u p = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awhd u p = u &&& awlast u p = v", "using assms"], ["proof (prove)\nusing this:\n  cas u p v\n\ngoal (1 subgoal):\n 1. awhd u p = u &&& awlast u p = v", "by (induct p arbitrary: u) auto"], ["", "lemma awalk_verts_in_verts:\n  assumes \"u \\<in> verts G\" \"set p \\<subseteq> arcs G\" \"v \\<in> set (awalk_verts u p)\"\n  shows \"v \\<in> verts G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> verts G", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> verts G\n  set p \\<subseteq> arcs G\n  v \\<in> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. v \\<in> verts G", "by (induct p arbitrary: u) (auto intro: wellformed)"], ["", "lemma\n  assumes \"u \\<in> verts G\" \"set p \\<subseteq> arcs G\"\n  shows awhd_in_verts: \"awhd u p \\<in> verts G\"\n    and awlast_in_verts: \"awlast u p \\<in> verts G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awhd u p \\<in> verts G &&& awlast u p \\<in> verts G", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> verts G\n  set p \\<subseteq> arcs G\n\ngoal (1 subgoal):\n 1. awhd u p \\<in> verts G &&& awlast u p \\<in> verts G", "by (auto elim: awalk_verts_in_verts)"], ["", "lemma awalk_conv:\n  \"awalk u p v = (set (awalk_verts u p) \\<subseteq> verts G\n    \\<and> set p \\<subseteq> arcs G\n    \\<and> awhd u p = u \\<and> awlast u p = v \\<and> cas u p v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk u p v =\n    (set (awalk_verts u p) \\<subseteq> verts G \\<and>\n     set p \\<subseteq> arcs G \\<and>\n     awhd u p = u \\<and> awlast u p = v \\<and> cas u p v)", "unfolding awalk_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (u \\<in> verts G \\<and> set p \\<subseteq> arcs G \\<and> cas u p v) =\n    (set (awalk_verts u p) \\<subseteq> verts G \\<and>\n     set p \\<subseteq> arcs G \\<and>\n     awhd u p = u \\<and> awlast u p = v \\<and> cas u p v)", "using hd_in_set[OF awalk_verts_non_Nil, of u p]"], ["proof (prove)\nusing this:\n  awhd u p \\<in> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. (u \\<in> verts G \\<and> set p \\<subseteq> arcs G \\<and> cas u p v) =\n    (set (awalk_verts u p) \\<subseteq> verts G \\<and>\n     set p \\<subseteq> arcs G \\<and>\n     awhd u p = u \\<and> awlast u p = v \\<and> cas u p v)", "by (auto intro: awalk_verts_in_verts awhd_if_cas awlast_if_cas simp del: hd_in_set)"], ["", "lemma awalkI:\n  assumes \"set (awalk_verts u p) \\<subseteq> verts G\" \"set p \\<subseteq> arcs G\" \"cas u p v\"\n  shows \"awalk u p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk u p v", "using assms"], ["proof (prove)\nusing this:\n  set (awalk_verts u p) \\<subseteq> verts G\n  set p \\<subseteq> arcs G\n  cas u p v\n\ngoal (1 subgoal):\n 1. awalk u p v", "by (auto simp: awalk_conv awhd_if_cas awlast_if_cas)"], ["", "lemma awalkE[elim]:\n  assumes \"awalk u p v\"\n  obtains \"set (awalk_verts u p) \\<subseteq> verts G\" \"set p \\<subseteq> arcs G\" \"cas u p v\"\n    \"awhd u p = u\" \"awlast u p = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>set (awalk_verts u p) \\<subseteq> verts G;\n      set p \\<subseteq> arcs G; cas u p v; awhd u p = u;\n      awlast u p = v\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  awalk u p v\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>set (awalk_verts u p) \\<subseteq> verts G;\n      set p \\<subseteq> arcs G; cas u p v; awhd u p = u;\n      awlast u p = v\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: awalk_conv)"], ["", "lemma awalk_Nil_iff:\n  \"awalk u [] v \\<longleftrightarrow> u = v \\<and> u \\<in> verts G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk u [] v = (u = v \\<and> u \\<in> verts G)", "unfolding awalk_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (u \\<in> verts G \\<and> set [] \\<subseteq> arcs G \\<and> cas u [] v) =\n    (u = v \\<and> u \\<in> verts G)", "by auto"], ["", "lemma trail_Nil_iff:\n  \"trail u [] v \\<longleftrightarrow> u = v \\<and> u \\<in> verts G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trail u [] v = (u = v \\<and> u \\<in> verts G)", "by (auto simp: trail_def awalk_Nil_iff)"], ["", "lemma apath_Nil_iff: \"apath u [] v \\<longleftrightarrow> u = v \\<and> u \\<in> verts G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apath u [] v = (u = v \\<and> u \\<in> verts G)", "by (auto simp: apath_def awalk_Nil_iff)"], ["", "lemma awalk_hd_in_verts: \"awalk u p v \\<Longrightarrow> u \\<in> verts G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk u p v \\<Longrightarrow> u \\<in> verts G", "by (cases p) auto"], ["", "lemma awalk_last_in_verts: \"awalk u p v \\<Longrightarrow> v \\<in> verts G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk u p v \\<Longrightarrow> v \\<in> verts G", "unfolding awalk_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (awalk_verts u p) \\<subseteq> verts G \\<and>\n    set p \\<subseteq> arcs G \\<and>\n    awhd u p = u \\<and> awlast u p = v \\<and> cas u p v \\<Longrightarrow>\n    v \\<in> verts G", "by auto"], ["", "lemma hd_in_awalk_verts:\n  \"awalk u p v \\<Longrightarrow> u \\<in> set (awalk_verts u p)\"\n  \"apath u p v \\<Longrightarrow> u \\<in> set (awalk_verts u p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (awalk u p v \\<Longrightarrow> u \\<in> set (awalk_verts u p)) &&&\n    (apath u p v \\<Longrightarrow> u \\<in> set (awalk_verts u p))", "by (case_tac [!]p) (auto simp: apath_def)"], ["", "lemma awalk_Cons_iff:\n  \"awalk u (e # es) w \\<longleftrightarrow> e \\<in> arcs G \\<and> u = tail G e \\<and> awalk (head G e) es w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk u (e # es) w =\n    (e \\<in> arcs G \\<and> u = tail G e \\<and> awalk (head G e) es w)", "by (auto simp: awalk_def)"], ["", "lemma trail_Cons_iff:\n  \"trail u (e # es ) w \\<longleftrightarrow> e \\<in> arcs G \\<and> u = tail G e \\<and> e \\<notin> set es \\<and> trail (head G e) es w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trail u (e # es) w =\n    (e \\<in> arcs G \\<and>\n     u = tail G e \\<and> e \\<notin> set es \\<and> trail (head G e) es w)", "by (auto simp: trail_def awalk_Cons_iff)"], ["", "lemma apath_Cons_iff:\n  \"apath u (e # es) w \\<longleftrightarrow> e \\<in> arcs G \\<and> tail G e = u \\<and> apath (head G e) es w\n    \\<and> tail G e \\<notin> set (awalk_verts (head G e) es)\" (is \"?L \\<longleftrightarrow> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. apath u (e # es) w =\n    (e \\<in> arcs G \\<and>\n     tail G e = u \\<and>\n     apath (head G e) es w \\<and>\n     tail G e \\<notin> set (awalk_verts (head G e) es))", "by (auto simp: apath_def awalk_Cons_iff)"], ["", "lemmas awalk_simps = awalk_Nil_iff awalk_Cons_iff"], ["", "lemmas trail_simps = trail_Nil_iff trail_Cons_iff"], ["", "lemmas apath_simps = apath_Nil_iff apath_Cons_iff"], ["", "lemma arc_implies_awalk:\n  \"e \\<in> arcs G \\<Longrightarrow> awalk (tail G e) [e] (head G e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<in> arcs G \\<Longrightarrow> awalk (tail G e) [e] (head G e)", "by (simp add: awalk_simps)"], ["", "lemma apath_nonempty_ends:\n  assumes \"apath u p v\"\n  assumes \"p \\<noteq> []\"\n  shows \"u \\<noteq> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<noteq> v", "using assms"], ["proof (prove)\nusing this:\n  apath u p v\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. u \\<noteq> v", "proof (induct p arbitrary: u)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>apath u [] v; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> u \\<noteq> v\n 2. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>apath u p v; p \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> u \\<noteq> v;\n        apath u (a # p) v; a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> u \\<noteq> v", "case (Cons e es)"], ["proof (state)\nthis:\n  \\<lbrakk>apath ?u es v; es \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?u \\<noteq> v\n  apath u (e # es) v\n  e # es \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>apath u [] v; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> u \\<noteq> v\n 2. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>apath u p v; p \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> u \\<noteq> v;\n        apath u (a # p) v; a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> u \\<noteq> v", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>apath ?u es v; es \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?u \\<noteq> v\n  apath u (e # es) v\n  e # es \\<noteq> []", "have \"apath (head G e) es v\" \"u \\<notin> set (awalk_verts (head G e) es)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>apath ?u es v; es \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?u \\<noteq> v\n  apath u (e # es) v\n  e # es \\<noteq> []\n\ngoal (1 subgoal):\n 1. apath (head G e) es v &&& u \\<notin> set (awalk_verts (head G e) es)", "by (auto simp: apath_Cons_iff)"], ["proof (state)\nthis:\n  apath (head G e) es v\n  u \\<notin> set (awalk_verts (head G e) es)\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>apath u [] v; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> u \\<noteq> v\n 2. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>apath u p v; p \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> u \\<noteq> v;\n        apath u (a # p) v; a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> u \\<noteq> v", "moreover"], ["proof (state)\nthis:\n  apath (head G e) es v\n  u \\<notin> set (awalk_verts (head G e) es)\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>apath u [] v; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> u \\<noteq> v\n 2. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>apath u p v; p \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> u \\<noteq> v;\n        apath u (a # p) v; a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> u \\<noteq> v", "then"], ["proof (chain)\npicking this:\n  apath (head G e) es v\n  u \\<notin> set (awalk_verts (head G e) es)", "have \"v \\<in> set (awalk_verts (head G e) es)\""], ["proof (prove)\nusing this:\n  apath (head G e) es v\n  u \\<notin> set (awalk_verts (head G e) es)\n\ngoal (1 subgoal):\n 1. v \\<in> set (awalk_verts (head G e) es)", "by (auto simp: apath_def)"], ["proof (state)\nthis:\n  v \\<in> set (awalk_verts (head G e) es)\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>apath u [] v; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> u \\<noteq> v\n 2. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>apath u p v; p \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> u \\<noteq> v;\n        apath u (a # p) v; a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> u \\<noteq> v", "ultimately"], ["proof (chain)\npicking this:\n  apath (head G e) es v\n  u \\<notin> set (awalk_verts (head G e) es)\n  v \\<in> set (awalk_verts (head G e) es)", "show \"u \\<noteq> v\""], ["proof (prove)\nusing this:\n  apath (head G e) es v\n  u \\<notin> set (awalk_verts (head G e) es)\n  v \\<in> set (awalk_verts (head G e) es)\n\ngoal (1 subgoal):\n 1. u \\<noteq> v", "by auto"], ["proof (state)\nthis:\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>apath u [] v; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> u \\<noteq> v", "qed simp"], ["", "(* replace by awalk_Cons_iff?*)"], ["", "lemma awalk_ConsI:\n  assumes \"awalk v es w\"\n  assumes \"e \\<in> arcs G\" and \"arc_to_ends G e = (u,v)\"\n  shows \"awalk u (e # es) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk u (e # es) w", "using assms"], ["proof (prove)\nusing this:\n  awalk v es w\n  e \\<in> arcs G\n  arc_to_ends G e = (u, v)\n\ngoal (1 subgoal):\n 1. awalk u (e # es) w", "by (cases es) (auto simp: awalk_def arc_to_ends_def)"], ["", "lemma (in pre_digraph) awalkI_apath:\n  assumes \"apath u p v\" shows \"awalk u p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk u p v", "using assms"], ["proof (prove)\nusing this:\n  apath u p v\n\ngoal (1 subgoal):\n 1. awalk u p v", "by (simp add: apath_def)"], ["", "lemma arcE:\n  assumes \"arc e (u,v)\"\n  assumes \"\\<lbrakk>e \\<in> arcs G; tail G e = u; head G e = v\\<rbrakk> \\<Longrightarrow> P\"\n  shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using assms"], ["proof (prove)\nusing this:\n  arc e (u, v)\n  \\<lbrakk>e \\<in> arcs G; tail G e = u; head G e = v\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by (auto simp: arc_def)"], ["", "lemma in_arcs_imp_in_arcs_ends:\n  assumes \"e \\<in> arcs G\"\n  shows \"(tail G e, head G e) \\<in> arcs_ends G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tail G e \\<rightarrow> head G e", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> arcs G\n\ngoal (1 subgoal):\n 1. tail G e \\<rightarrow> head G e", "by (auto simp: arcs_ends_conv)"], ["", "lemma set_awalk_verts_cas:\n  assumes \"cas u p v\"\n  shows \"set (awalk_verts u p) = {u} \\<union> set (map (tail G) p) \\<union> set (map (head G) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (awalk_verts u p) =\n    {u} \\<union> set (map (tail G) p) \\<union> set (map (head G) p)", "using assms"], ["proof (prove)\nusing this:\n  cas u p v\n\ngoal (1 subgoal):\n 1. set (awalk_verts u p) =\n    {u} \\<union> set (map (tail G) p) \\<union> set (map (head G) p)", "proof (induct p arbitrary: u)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u.\n       cas u [] v \\<Longrightarrow>\n       set (awalk_verts u []) =\n       {u} \\<union> set (map (tail G) []) \\<union> set (map (head G) [])\n 2. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   cas u p v \\<Longrightarrow>\n                   set (awalk_verts u p) =\n                   {u} \\<union> set (map (tail G) p) \\<union>\n                   set (map (head G) p);\n        cas u (a # p) v\\<rbrakk>\n       \\<Longrightarrow> set (awalk_verts u (a # p)) =\n                         {u} \\<union> set (map (tail G) (a # p)) \\<union>\n                         set (map (head G) (a # p))", "case Nil"], ["proof (state)\nthis:\n  cas u [] v\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       cas u [] v \\<Longrightarrow>\n       set (awalk_verts u []) =\n       {u} \\<union> set (map (tail G) []) \\<union> set (map (head G) [])\n 2. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   cas u p v \\<Longrightarrow>\n                   set (awalk_verts u p) =\n                   {u} \\<union> set (map (tail G) p) \\<union>\n                   set (map (head G) p);\n        cas u (a # p) v\\<rbrakk>\n       \\<Longrightarrow> set (awalk_verts u (a # p)) =\n                         {u} \\<union> set (map (tail G) (a # p)) \\<union>\n                         set (map (head G) (a # p))", "then"], ["proof (chain)\npicking this:\n  cas u [] v", "show ?case"], ["proof (prove)\nusing this:\n  cas u [] v\n\ngoal (1 subgoal):\n 1. set (awalk_verts u []) =\n    {u} \\<union> set (map (tail G) []) \\<union> set (map (head G) [])", "by simp"], ["proof (state)\nthis:\n  set (awalk_verts u []) =\n  {u} \\<union> set (map (tail G) []) \\<union> set (map (head G) [])\n\ngoal (1 subgoal):\n 1. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   cas u p v \\<Longrightarrow>\n                   set (awalk_verts u p) =\n                   {u} \\<union> set (map (tail G) p) \\<union>\n                   set (map (head G) p);\n        cas u (a # p) v\\<rbrakk>\n       \\<Longrightarrow> set (awalk_verts u (a # p)) =\n                         {u} \\<union> set (map (tail G) (a # p)) \\<union>\n                         set (map (head G) (a # p))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   cas u p v \\<Longrightarrow>\n                   set (awalk_verts u p) =\n                   {u} \\<union> set (map (tail G) p) \\<union>\n                   set (map (head G) p);\n        cas u (a # p) v\\<rbrakk>\n       \\<Longrightarrow> set (awalk_verts u (a # p)) =\n                         {u} \\<union> set (map (tail G) (a # p)) \\<union>\n                         set (map (head G) (a # p))", "case (Cons e es)"], ["proof (state)\nthis:\n  cas ?u es v \\<Longrightarrow>\n  set (awalk_verts ?u es) =\n  {?u} \\<union> set (map (tail G) es) \\<union> set (map (head G) es)\n  cas u (e # es) v\n\ngoal (1 subgoal):\n 1. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   cas u p v \\<Longrightarrow>\n                   set (awalk_verts u p) =\n                   {u} \\<union> set (map (tail G) p) \\<union>\n                   set (map (head G) p);\n        cas u (a # p) v\\<rbrakk>\n       \\<Longrightarrow> set (awalk_verts u (a # p)) =\n                         {u} \\<union> set (map (tail G) (a # p)) \\<union>\n                         set (map (head G) (a # p))", "then"], ["proof (chain)\npicking this:\n  cas ?u es v \\<Longrightarrow>\n  set (awalk_verts ?u es) =\n  {?u} \\<union> set (map (tail G) es) \\<union> set (map (head G) es)\n  cas u (e # es) v", "have \"set (awalk_verts (head G e) es)\n      = {head G e} \\<union> set (map (tail G) es) \\<union> set (map (head G) es)\""], ["proof (prove)\nusing this:\n  cas ?u es v \\<Longrightarrow>\n  set (awalk_verts ?u es) =\n  {?u} \\<union> set (map (tail G) es) \\<union> set (map (head G) es)\n  cas u (e # es) v\n\ngoal (1 subgoal):\n 1. set (awalk_verts (head G e) es) =\n    {head G e} \\<union> set (map (tail G) es) \\<union> set (map (head G) es)", "by (auto simp: awalk_Cons_iff)"], ["proof (state)\nthis:\n  set (awalk_verts (head G e) es) =\n  {head G e} \\<union> set (map (tail G) es) \\<union> set (map (head G) es)\n\ngoal (1 subgoal):\n 1. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   cas u p v \\<Longrightarrow>\n                   set (awalk_verts u p) =\n                   {u} \\<union> set (map (tail G) p) \\<union>\n                   set (map (head G) p);\n        cas u (a # p) v\\<rbrakk>\n       \\<Longrightarrow> set (awalk_verts u (a # p)) =\n                         {u} \\<union> set (map (tail G) (a # p)) \\<union>\n                         set (map (head G) (a # p))", "with Cons.prems"], ["proof (chain)\npicking this:\n  cas u (e # es) v\n  set (awalk_verts (head G e) es) =\n  {head G e} \\<union> set (map (tail G) es) \\<union> set (map (head G) es)", "show ?case"], ["proof (prove)\nusing this:\n  cas u (e # es) v\n  set (awalk_verts (head G e) es) =\n  {head G e} \\<union> set (map (tail G) es) \\<union> set (map (head G) es)\n\ngoal (1 subgoal):\n 1. set (awalk_verts u (e # es)) =\n    {u} \\<union> set (map (tail G) (e # es)) \\<union>\n    set (map (head G) (e # es))", "by auto"], ["proof (state)\nthis:\n  set (awalk_verts u (e # es)) =\n  {u} \\<union> set (map (tail G) (e # es)) \\<union>\n  set (map (head G) (e # es))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_awalk_verts_not_Nil_cas:\n  assumes \"cas u p v\" \"p \\<noteq> []\"\n  shows \"set (awalk_verts u p) = set (map (tail G) p) \\<union> set (map (head G) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (awalk_verts u p) =\n    set (map (tail G) p) \\<union> set (map (head G) p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (awalk_verts u p) =\n    set (map (tail G) p) \\<union> set (map (head G) p)", "have \"u \\<in> set (map (tail G) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> set (map (tail G) p)", "using assms"], ["proof (prove)\nusing this:\n  cas u p v\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. u \\<in> set (map (tail G) p)", "by (cases p) auto"], ["proof (state)\nthis:\n  u \\<in> set (map (tail G) p)\n\ngoal (1 subgoal):\n 1. set (awalk_verts u p) =\n    set (map (tail G) p) \\<union> set (map (head G) p)", "with assms"], ["proof (chain)\npicking this:\n  cas u p v\n  p \\<noteq> []\n  u \\<in> set (map (tail G) p)", "show ?thesis"], ["proof (prove)\nusing this:\n  cas u p v\n  p \\<noteq> []\n  u \\<in> set (map (tail G) p)\n\ngoal (1 subgoal):\n 1. set (awalk_verts u p) =\n    set (map (tail G) p) \\<union> set (map (head G) p)", "by (auto simp: set_awalk_verts_cas)"], ["proof (state)\nthis:\n  set (awalk_verts u p) = set (map (tail G) p) \\<union> set (map (head G) p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_awalk_verts:\n  assumes \"awalk u p v\"\n  shows \"set (awalk_verts u p) = {u} \\<union> set (map (tail G) p) \\<union> set (map (head G) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (awalk_verts u p) =\n    {u} \\<union> set (map (tail G) p) \\<union> set (map (head G) p)", "using assms"], ["proof (prove)\nusing this:\n  awalk u p v\n\ngoal (1 subgoal):\n 1. set (awalk_verts u p) =\n    {u} \\<union> set (map (tail G) p) \\<union> set (map (head G) p)", "by (intro set_awalk_verts_cas) blast"], ["", "lemma set_awalk_verts_not_Nil:\n  assumes \"awalk u p v\" \"p \\<noteq> []\"\n  shows \"set (awalk_verts u p) = set (map (tail G) p) \\<union> set (map (head G) p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (awalk_verts u p) =\n    set (map (tail G) p) \\<union> set (map (head G) p)", "using assms"], ["proof (prove)\nusing this:\n  awalk u p v\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. set (awalk_verts u p) =\n    set (map (tail G) p) \\<union> set (map (head G) p)", "by (intro set_awalk_verts_not_Nil_cas) blast"], ["", "lemma\n  awhd_of_awalk: \"awalk u p v \\<Longrightarrow> awhd u p = u\" and\n  awlast_of_awalk: \"awalk u p v \\<Longrightarrow> NOMATCH (awlast u p) v \\<Longrightarrow> awlast u p = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (awalk u p v \\<Longrightarrow> awhd u p = u) &&&\n    (\\<lbrakk>awalk u p v; NOMATCH (awlast u p) v\\<rbrakk>\n     \\<Longrightarrow> awlast u p = v)", "unfolding NOMATCH_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (awalk u p v \\<Longrightarrow> awhd u p = u) &&&\n    (\\<lbrakk>awalk u p v; True\\<rbrakk> \\<Longrightarrow> awlast u p = v)", "by auto"], ["", "lemmas awends_of_awalk[simp] = awhd_of_awalk awlast_of_awalk"], ["", "lemma awalk_verts_arc1:\n  assumes \"e \\<in> set p\"\n  shows \"tail G e \\<in> set (awalk_verts u p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tail G e \\<in> set (awalk_verts u p)", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> set p\n\ngoal (1 subgoal):\n 1. tail G e \\<in> set (awalk_verts u p)", "by (auto simp: awalk_verts_conv)"], ["", "lemma awalk_verts_arc2:\n  assumes \"awalk u p v\" \"e \\<in> set p\"\n  shows \"head G e \\<in> set (awalk_verts u p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head G e \\<in> set (awalk_verts u p)", "using assms"], ["proof (prove)\nusing this:\n  awalk u p v\n  e \\<in> set p\n\ngoal (1 subgoal):\n 1. head G e \\<in> set (awalk_verts u p)", "by (simp add: set_awalk_verts)"], ["", "lemma awalk_induct_raw[case_names Base Cons(*, induct pred: awalk*)]:\n  assumes \"awalk u p v\"\n  assumes \"\\<And>w1. w1 \\<in> verts G \\<Longrightarrow> P w1 [] w1\"\n  assumes \"\\<And>w1 w2 e es. e \\<in> arcs G \\<Longrightarrow> arc_to_ends G e = (w1, w2)\n    \\<Longrightarrow> P w2 es v \\<Longrightarrow> P w1 (e # es) v\"\n  shows \"P u p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P u p v", "using assms"], ["proof (prove)\nusing this:\n  awalk u p v\n  ?w1.0 \\<in> verts G \\<Longrightarrow> P ?w1.0 [] ?w1.0\n  \\<lbrakk>?e \\<in> arcs G; arc_to_ends G ?e = (?w1.0, ?w2.0);\n   P ?w2.0 ?es v\\<rbrakk>\n  \\<Longrightarrow> P ?w1.0 (?e # ?es) v\n\ngoal (1 subgoal):\n 1. P u p v", "proof (induct p arbitrary: u v)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>awalk u [] v;\n        \\<And>w1. w1 \\<in> verts G \\<Longrightarrow> P w1 [] w1;\n        \\<And>e w1 w2 es.\n           \\<lbrakk>e \\<in> arcs G; arc_to_ends G e = (w1, w2);\n            P w2 es v\\<rbrakk>\n           \\<Longrightarrow> P w1 (e # es) v\\<rbrakk>\n       \\<Longrightarrow> P u [] v\n 2. \\<And>a p u v.\n       \\<lbrakk>\\<And>u v.\n                   \\<lbrakk>awalk u p v;\n                    \\<And>w1. w1 \\<in> verts G \\<Longrightarrow> P w1 [] w1;\n                    \\<And>e w1 w2 es.\n                       \\<lbrakk>e \\<in> arcs G; arc_to_ends G e = (w1, w2);\n                        P w2 es v\\<rbrakk>\n                       \\<Longrightarrow> P w1 (e # es) v\\<rbrakk>\n                   \\<Longrightarrow> P u p v;\n        awalk u (a # p) v;\n        \\<And>w1. w1 \\<in> verts G \\<Longrightarrow> P w1 [] w1;\n        \\<And>e w1 w2 es.\n           \\<lbrakk>e \\<in> arcs G; arc_to_ends G e = (w1, w2);\n            P w2 es v\\<rbrakk>\n           \\<Longrightarrow> P w1 (e # es) v\\<rbrakk>\n       \\<Longrightarrow> P u (a # p) v", "case Nil"], ["proof (state)\nthis:\n  awalk u [] v\n  ?w1.0 \\<in> verts G \\<Longrightarrow> P ?w1.0 [] ?w1.0\n  \\<lbrakk>?e \\<in> arcs G; arc_to_ends G ?e = (?w1.0, ?w2.0);\n   P ?w2.0 ?es v\\<rbrakk>\n  \\<Longrightarrow> P ?w1.0 (?e # ?es) v\n\ngoal (2 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>awalk u [] v;\n        \\<And>w1. w1 \\<in> verts G \\<Longrightarrow> P w1 [] w1;\n        \\<And>e w1 w2 es.\n           \\<lbrakk>e \\<in> arcs G; arc_to_ends G e = (w1, w2);\n            P w2 es v\\<rbrakk>\n           \\<Longrightarrow> P w1 (e # es) v\\<rbrakk>\n       \\<Longrightarrow> P u [] v\n 2. \\<And>a p u v.\n       \\<lbrakk>\\<And>u v.\n                   \\<lbrakk>awalk u p v;\n                    \\<And>w1. w1 \\<in> verts G \\<Longrightarrow> P w1 [] w1;\n                    \\<And>e w1 w2 es.\n                       \\<lbrakk>e \\<in> arcs G; arc_to_ends G e = (w1, w2);\n                        P w2 es v\\<rbrakk>\n                       \\<Longrightarrow> P w1 (e # es) v\\<rbrakk>\n                   \\<Longrightarrow> P u p v;\n        awalk u (a # p) v;\n        \\<And>w1. w1 \\<in> verts G \\<Longrightarrow> P w1 [] w1;\n        \\<And>e w1 w2 es.\n           \\<lbrakk>e \\<in> arcs G; arc_to_ends G e = (w1, w2);\n            P w2 es v\\<rbrakk>\n           \\<Longrightarrow> P w1 (e # es) v\\<rbrakk>\n       \\<Longrightarrow> P u (a # p) v", "then"], ["proof (chain)\npicking this:\n  awalk u [] v\n  ?w1.0 \\<in> verts G \\<Longrightarrow> P ?w1.0 [] ?w1.0\n  \\<lbrakk>?e \\<in> arcs G; arc_to_ends G ?e = (?w1.0, ?w2.0);\n   P ?w2.0 ?es v\\<rbrakk>\n  \\<Longrightarrow> P ?w1.0 (?e # ?es) v", "show ?case"], ["proof (prove)\nusing this:\n  awalk u [] v\n  ?w1.0 \\<in> verts G \\<Longrightarrow> P ?w1.0 [] ?w1.0\n  \\<lbrakk>?e \\<in> arcs G; arc_to_ends G ?e = (?w1.0, ?w2.0);\n   P ?w2.0 ?es v\\<rbrakk>\n  \\<Longrightarrow> P ?w1.0 (?e # ?es) v\n\ngoal (1 subgoal):\n 1. P u [] v", "using Nil.prems"], ["proof (prove)\nusing this:\n  awalk u [] v\n  ?w1.0 \\<in> verts G \\<Longrightarrow> P ?w1.0 [] ?w1.0\n  \\<lbrakk>?e \\<in> arcs G; arc_to_ends G ?e = (?w1.0, ?w2.0);\n   P ?w2.0 ?es v\\<rbrakk>\n  \\<Longrightarrow> P ?w1.0 (?e # ?es) v\n  awalk u [] v\n  ?w1.0 \\<in> verts G \\<Longrightarrow> P ?w1.0 [] ?w1.0\n  \\<lbrakk>?e \\<in> arcs G; arc_to_ends G ?e = (?w1.0, ?w2.0);\n   P ?w2.0 ?es v\\<rbrakk>\n  \\<Longrightarrow> P ?w1.0 (?e # ?es) v\n\ngoal (1 subgoal):\n 1. P u [] v", "by auto"], ["proof (state)\nthis:\n  P u [] v\n\ngoal (1 subgoal):\n 1. \\<And>a p u v.\n       \\<lbrakk>\\<And>u v.\n                   \\<lbrakk>awalk u p v;\n                    \\<And>w1. w1 \\<in> verts G \\<Longrightarrow> P w1 [] w1;\n                    \\<And>e w1 w2 es.\n                       \\<lbrakk>e \\<in> arcs G; arc_to_ends G e = (w1, w2);\n                        P w2 es v\\<rbrakk>\n                       \\<Longrightarrow> P w1 (e # es) v\\<rbrakk>\n                   \\<Longrightarrow> P u p v;\n        awalk u (a # p) v;\n        \\<And>w1. w1 \\<in> verts G \\<Longrightarrow> P w1 [] w1;\n        \\<And>e w1 w2 es.\n           \\<lbrakk>e \\<in> arcs G; arc_to_ends G e = (w1, w2);\n            P w2 es v\\<rbrakk>\n           \\<Longrightarrow> P w1 (e # es) v\\<rbrakk>\n       \\<Longrightarrow> P u (a # p) v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p u v.\n       \\<lbrakk>\\<And>u v.\n                   \\<lbrakk>awalk u p v;\n                    \\<And>w1. w1 \\<in> verts G \\<Longrightarrow> P w1 [] w1;\n                    \\<And>e w1 w2 es.\n                       \\<lbrakk>e \\<in> arcs G; arc_to_ends G e = (w1, w2);\n                        P w2 es v\\<rbrakk>\n                       \\<Longrightarrow> P w1 (e # es) v\\<rbrakk>\n                   \\<Longrightarrow> P u p v;\n        awalk u (a # p) v;\n        \\<And>w1. w1 \\<in> verts G \\<Longrightarrow> P w1 [] w1;\n        \\<And>e w1 w2 es.\n           \\<lbrakk>e \\<in> arcs G; arc_to_ends G e = (w1, w2);\n            P w2 es v\\<rbrakk>\n           \\<Longrightarrow> P w1 (e # es) v\\<rbrakk>\n       \\<Longrightarrow> P u (a # p) v", "case (Cons e es)"], ["proof (state)\nthis:\n  \\<lbrakk>awalk ?u es ?v;\n   \\<And>w1. w1 \\<in> verts G \\<Longrightarrow> P w1 [] w1;\n   \\<And>e w1 w2 es.\n      \\<lbrakk>e \\<in> arcs G; arc_to_ends G e = (w1, w2);\n       P w2 es ?v\\<rbrakk>\n      \\<Longrightarrow> P w1 (e # es) ?v\\<rbrakk>\n  \\<Longrightarrow> P ?u es ?v\n  awalk u (e # es) v\n  ?w1.0 \\<in> verts G \\<Longrightarrow> P ?w1.0 [] ?w1.0\n  \\<lbrakk>?e \\<in> arcs G; arc_to_ends G ?e = (?w1.0, ?w2.0);\n   P ?w2.0 ?es v\\<rbrakk>\n  \\<Longrightarrow> P ?w1.0 (?e # ?es) v\n\ngoal (1 subgoal):\n 1. \\<And>a p u v.\n       \\<lbrakk>\\<And>u v.\n                   \\<lbrakk>awalk u p v;\n                    \\<And>w1. w1 \\<in> verts G \\<Longrightarrow> P w1 [] w1;\n                    \\<And>e w1 w2 es.\n                       \\<lbrakk>e \\<in> arcs G; arc_to_ends G e = (w1, w2);\n                        P w2 es v\\<rbrakk>\n                       \\<Longrightarrow> P w1 (e # es) v\\<rbrakk>\n                   \\<Longrightarrow> P u p v;\n        awalk u (a # p) v;\n        \\<And>w1. w1 \\<in> verts G \\<Longrightarrow> P w1 [] w1;\n        \\<And>e w1 w2 es.\n           \\<lbrakk>e \\<in> arcs G; arc_to_ends G e = (w1, w2);\n            P w2 es v\\<rbrakk>\n           \\<Longrightarrow> P w1 (e # es) v\\<rbrakk>\n       \\<Longrightarrow> P u (a # p) v", "from Cons.prems(1)"], ["proof (chain)\npicking this:\n  awalk u (e # es) v", "show ?case"], ["proof (prove)\nusing this:\n  awalk u (e # es) v\n\ngoal (1 subgoal):\n 1. P u (e # es) v", "by (intro Cons) (auto intro: Cons(2-) simp: arc_to_ends_def awalk_Cons_iff)"], ["proof (state)\nthis:\n  P u (e # es) v\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Appending awalks\\<close>"], ["", "lemma (in pre_digraph) cas_append_iff[simp]:\n  \"cas u (p @ q) v \\<longleftrightarrow> cas u p (awlast u p) \\<and> cas (awlast u p) q v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cas u (p @ q) v = (cas u p (awlast u p) \\<and> cas (awlast u p) q v)", "by (induct u p v rule: cas.induct) auto"], ["", "lemma cas_ends:\n  assumes \"cas u p v\" \"cas u' p v'\"\n  shows \"(p \\<noteq> [] \\<and> u = u' \\<and> v = v') \\<or> (p = [] \\<and> u = v \\<and> u' = v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<and> u = u' \\<and> v = v' \\<or>\n    p = [] \\<and> u = v \\<and> u' = v'", "using assms"], ["proof (prove)\nusing this:\n  cas u p v\n  cas u' p v'\n\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<and> u = u' \\<and> v = v' \\<or>\n    p = [] \\<and> u = v \\<and> u' = v'", "by (induct u p v arbitrary: u u' rule: cas.induct) auto"], ["", "lemma awalk_ends:\n  assumes \"awalk u p v\" \"awalk u' p v'\"\n  shows \"(p \\<noteq> [] \\<and> u = u' \\<and> v = v') \\<or> (p = [] \\<and> u = v \\<and> u' = v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<and> u = u' \\<and> v = v' \\<or>\n    p = [] \\<and> u = v \\<and> u' = v'", "using assms"], ["proof (prove)\nusing this:\n  awalk u p v\n  awalk u' p v'\n\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<and> u = u' \\<and> v = v' \\<or>\n    p = [] \\<and> u = v \\<and> u' = v'", "by (simp add: awalk_def cas_ends)"], ["", "lemma awalk_ends_eqD:\n  assumes \"awalk u p u\" \"awalk v p w\"\n  shows \"v = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = w", "using awalk_ends[OF assms(1,2)]"], ["proof (prove)\nusing this:\n  p \\<noteq> [] \\<and> u = v \\<and> u = w \\<or>\n  p = [] \\<and> u = u \\<and> v = w\n\ngoal (1 subgoal):\n 1. v = w", "by auto"], ["", "lemma awalk_empty_ends:\n  assumes \"awalk u [] v\"\n  shows \"u = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u = v", "using assms"], ["proof (prove)\nusing this:\n  awalk u [] v\n\ngoal (1 subgoal):\n 1. u = v", "by (auto simp: awalk_def)"], ["", "lemma apath_ends:\n assumes \"apath u p v\" and \"apath u' p v'\"\n  shows \"(p \\<noteq> [] \\<and> u \\<noteq> v \\<and> u = u' \\<and> v = v') \\<or> (p = [] \\<and> u = v \\<and> u' = v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<and> u \\<noteq> v \\<and> u = u' \\<and> v = v' \\<or>\n    p = [] \\<and> u = v \\<and> u' = v'", "using assms"], ["proof (prove)\nusing this:\n  apath u p v\n  apath u' p v'\n\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<and> u \\<noteq> v \\<and> u = u' \\<and> v = v' \\<or>\n    p = [] \\<and> u = v \\<and> u' = v'", "unfolding apath_def"], ["proof (prove)\nusing this:\n  awalk u p v \\<and> distinct (awalk_verts u p)\n  awalk u' p v' \\<and> distinct (awalk_verts u' p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<and> u \\<noteq> v \\<and> u = u' \\<and> v = v' \\<or>\n    p = [] \\<and> u = v \\<and> u' = v'", "by (metis assms(2) apath_nonempty_ends  awalk_ends)"], ["", "lemma awalk_append_iff[simp]:\n  \"awalk u (p @ q) v \\<longleftrightarrow> awalk u p (awlast u p) \\<and> awalk (awlast u p) q v\" (is \"?L \\<longleftrightarrow> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk u (p @ q) v =\n    (awalk u p (awlast u p) \\<and> awalk (awlast u p) q v)", "by (auto simp: awalk_def intro: awlast_in_verts)"], ["", "lemma awlast_append:\n  \"awlast u (p @ q) = awlast (awlast u p) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awlast u (p @ q) = awlast (awlast u p) q", "by (simp add: awalk_verts_conv)"], ["", "lemma awhd_append:\n  \"awhd u (p @ q) = awhd (awhd u q) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awhd u (p @ q) = awhd (awhd u q) p", "by (simp add: awalk_verts_conv)"], ["", "declare awalkE[rule del]"], ["", "lemma awalkE'[elim]:\n  assumes \"awalk u p v\"\n  obtains \"set (awalk_verts u p) \\<subseteq> verts G\" \"set p \\<subseteq> arcs G\" \"cas u p v\"\n    \"awhd u p = u\" \"awlast u p = v\" \"u \\<in> verts G\" \"v \\<in> verts G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>set (awalk_verts u p) \\<subseteq> verts G;\n      set p \\<subseteq> arcs G; cas u p v; awhd u p = u; awlast u p = v;\n      u \\<in> verts G; v \\<in> verts G\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lbrakk>set (awalk_verts u p) \\<subseteq> verts G;\n      set p \\<subseteq> arcs G; cas u p v; awhd u p = u; awlast u p = v;\n      u \\<in> verts G; v \\<in> verts G\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"u \\<in> set (awalk_verts u p)\" \"v \\<in> set (awalk_verts u p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> set (awalk_verts u p) &&& v \\<in> set (awalk_verts u p)", "using assms"], ["proof (prove)\nusing this:\n  awalk u p v\n\ngoal (1 subgoal):\n 1. u \\<in> set (awalk_verts u p) &&& v \\<in> set (awalk_verts u p)", "by (auto simp: hd_in_awalk_verts elim: awalkE)"], ["proof (state)\nthis:\n  u \\<in> set (awalk_verts u p)\n  v \\<in> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>set (awalk_verts u p) \\<subseteq> verts G;\n      set p \\<subseteq> arcs G; cas u p v; awhd u p = u; awlast u p = v;\n      u \\<in> verts G; v \\<in> verts G\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  u \\<in> set (awalk_verts u p)\n  v \\<in> set (awalk_verts u p)", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<in> set (awalk_verts u p)\n  v \\<in> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. thesis", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> set (awalk_verts u p)\n  v \\<in> set (awalk_verts u p)\n  awalk u p v\n\ngoal (1 subgoal):\n 1. thesis", "by (auto elim: awalkE intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma awalk_appendI:\n  assumes \"awalk u p v\"\n  assumes \"awalk v q w\"\n  shows \"awalk u (p @ q) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk u (p @ q) w", "using assms"], ["proof (prove)\nusing this:\n  awalk u p v\n  awalk v q w\n\ngoal (1 subgoal):\n 1. awalk u (p @ q) w", "proof (induct p arbitrary: u)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>awalk u [] v; awalk v q w\\<rbrakk>\n       \\<Longrightarrow> awalk u ([] @ q) w\n 2. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>awalk u p v; awalk v q w\\<rbrakk>\n                   \\<Longrightarrow> awalk u (p @ q) w;\n        awalk u (a # p) v; awalk v q w\\<rbrakk>\n       \\<Longrightarrow> awalk u ((a # p) @ q) w", "case Nil"], ["proof (state)\nthis:\n  awalk u [] v\n  awalk v q w\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>awalk u [] v; awalk v q w\\<rbrakk>\n       \\<Longrightarrow> awalk u ([] @ q) w\n 2. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>awalk u p v; awalk v q w\\<rbrakk>\n                   \\<Longrightarrow> awalk u (p @ q) w;\n        awalk u (a # p) v; awalk v q w\\<rbrakk>\n       \\<Longrightarrow> awalk u ((a # p) @ q) w", "then"], ["proof (chain)\npicking this:\n  awalk u [] v\n  awalk v q w", "show ?case"], ["proof (prove)\nusing this:\n  awalk u [] v\n  awalk v q w\n\ngoal (1 subgoal):\n 1. awalk u ([] @ q) w", "by auto"], ["proof (state)\nthis:\n  awalk u ([] @ q) w\n\ngoal (1 subgoal):\n 1. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>awalk u p v; awalk v q w\\<rbrakk>\n                   \\<Longrightarrow> awalk u (p @ q) w;\n        awalk u (a # p) v; awalk v q w\\<rbrakk>\n       \\<Longrightarrow> awalk u ((a # p) @ q) w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>awalk u p v; awalk v q w\\<rbrakk>\n                   \\<Longrightarrow> awalk u (p @ q) w;\n        awalk u (a # p) v; awalk v q w\\<rbrakk>\n       \\<Longrightarrow> awalk u ((a # p) @ q) w", "case (Cons e es)"], ["proof (state)\nthis:\n  \\<lbrakk>awalk ?u es v; awalk v q w\\<rbrakk>\n  \\<Longrightarrow> awalk ?u (es @ q) w\n  awalk u (e # es) v\n  awalk v q w\n\ngoal (1 subgoal):\n 1. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>awalk u p v; awalk v q w\\<rbrakk>\n                   \\<Longrightarrow> awalk u (p @ q) w;\n        awalk u (a # p) v; awalk v q w\\<rbrakk>\n       \\<Longrightarrow> awalk u ((a # p) @ q) w", "from Cons.prems"], ["proof (chain)\npicking this:\n  awalk u (e # es) v\n  awalk v q w", "have ee_e: \"arc_to_ends G e = (u, head G e)\""], ["proof (prove)\nusing this:\n  awalk u (e # es) v\n  awalk v q w\n\ngoal (1 subgoal):\n 1. arc_to_ends G e = (u, head G e)", "unfolding arc_to_ends_def"], ["proof (prove)\nusing this:\n  awalk u (e # es) v\n  awalk v q w\n\ngoal (1 subgoal):\n 1. (tail G e, head G e) = (u, head G e)", "by auto"], ["proof (state)\nthis:\n  arc_to_ends G e = (u, head G e)\n\ngoal (1 subgoal):\n 1. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>awalk u p v; awalk v q w\\<rbrakk>\n                   \\<Longrightarrow> awalk u (p @ q) w;\n        awalk u (a # p) v; awalk v q w\\<rbrakk>\n       \\<Longrightarrow> awalk u ((a # p) @ q) w", "have \"awalk (head G e) es v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk (head G e) es v", "using ee_e Cons(2) awalk_Cons_iff"], ["proof (prove)\nusing this:\n  arc_to_ends G e = (u, head G e)\n  awalk u (e # es) v\n  awalk ?u (?e # ?es) ?w =\n  (?e \\<in> arcs G \\<and> ?u = tail G ?e \\<and> awalk (head G ?e) ?es ?w)\n\ngoal (1 subgoal):\n 1. awalk (head G e) es v", "by auto"], ["proof (state)\nthis:\n  awalk (head G e) es v\n\ngoal (1 subgoal):\n 1. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>awalk u p v; awalk v q w\\<rbrakk>\n                   \\<Longrightarrow> awalk u (p @ q) w;\n        awalk u (a # p) v; awalk v q w\\<rbrakk>\n       \\<Longrightarrow> awalk u ((a # p) @ q) w", "then"], ["proof (chain)\npicking this:\n  awalk (head G e) es v", "show ?case"], ["proof (prove)\nusing this:\n  awalk (head G e) es v\n\ngoal (1 subgoal):\n 1. awalk u ((e # es) @ q) w", "using Cons ee_e"], ["proof (prove)\nusing this:\n  awalk (head G e) es v\n  \\<lbrakk>awalk ?u es v; awalk v q w\\<rbrakk>\n  \\<Longrightarrow> awalk ?u (es @ q) w\n  awalk u (e # es) v\n  awalk v q w\n  arc_to_ends G e = (u, head G e)\n\ngoal (1 subgoal):\n 1. awalk u ((e # es) @ q) w", "by (auto simp: awalk_Cons_iff)"], ["proof (state)\nthis:\n  awalk u ((e # es) @ q) w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma awalk_verts_append_cas:\n  assumes \"cas u (p @ q) v\"\n  shows \"awalk_verts u (p @ q) = awalk_verts u p @ tl (awalk_verts (awlast u p) q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk_verts u (p @ q) =\n    awalk_verts u p @ tl (awalk_verts (awlast u p) q)", "using assms"], ["proof (prove)\nusing this:\n  cas u (p @ q) v\n\ngoal (1 subgoal):\n 1. awalk_verts u (p @ q) =\n    awalk_verts u p @ tl (awalk_verts (awlast u p) q)", "proof (induct p arbitrary: u)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u.\n       cas u ([] @ q) v \\<Longrightarrow>\n       awalk_verts u ([] @ q) =\n       awalk_verts u [] @ tl (awalk_verts (awlast u []) q)\n 2. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   cas u (p @ q) v \\<Longrightarrow>\n                   awalk_verts u (p @ q) =\n                   awalk_verts u p @ tl (awalk_verts (awlast u p) q);\n        cas u ((a # p) @ q) v\\<rbrakk>\n       \\<Longrightarrow> awalk_verts u ((a # p) @ q) =\n                         awalk_verts u (a # p) @\n                         tl (awalk_verts (awlast u (a # p)) q)", "case Nil"], ["proof (state)\nthis:\n  cas u ([] @ q) v\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       cas u ([] @ q) v \\<Longrightarrow>\n       awalk_verts u ([] @ q) =\n       awalk_verts u [] @ tl (awalk_verts (awlast u []) q)\n 2. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   cas u (p @ q) v \\<Longrightarrow>\n                   awalk_verts u (p @ q) =\n                   awalk_verts u p @ tl (awalk_verts (awlast u p) q);\n        cas u ((a # p) @ q) v\\<rbrakk>\n       \\<Longrightarrow> awalk_verts u ((a # p) @ q) =\n                         awalk_verts u (a # p) @\n                         tl (awalk_verts (awlast u (a # p)) q)", "then"], ["proof (chain)\npicking this:\n  cas u ([] @ q) v", "show ?case"], ["proof (prove)\nusing this:\n  cas u ([] @ q) v\n\ngoal (1 subgoal):\n 1. awalk_verts u ([] @ q) =\n    awalk_verts u [] @ tl (awalk_verts (awlast u []) q)", "by (cases q) auto"], ["proof (state)\nthis:\n  awalk_verts u ([] @ q) =\n  awalk_verts u [] @ tl (awalk_verts (awlast u []) q)\n\ngoal (1 subgoal):\n 1. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   cas u (p @ q) v \\<Longrightarrow>\n                   awalk_verts u (p @ q) =\n                   awalk_verts u p @ tl (awalk_verts (awlast u p) q);\n        cas u ((a # p) @ q) v\\<rbrakk>\n       \\<Longrightarrow> awalk_verts u ((a # p) @ q) =\n                         awalk_verts u (a # p) @\n                         tl (awalk_verts (awlast u (a # p)) q)", "qed (auto simp: awalk_Cons_iff)"], ["", "lemma awalk_verts_append:\n  assumes \"awalk u (p @ q) v\"\n  shows \"awalk_verts u (p @ q) = awalk_verts u p @ tl (awalk_verts (awlast u p) q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk_verts u (p @ q) =\n    awalk_verts u p @ tl (awalk_verts (awlast u p) q)", "using assms"], ["proof (prove)\nusing this:\n  awalk u (p @ q) v\n\ngoal (1 subgoal):\n 1. awalk_verts u (p @ q) =\n    awalk_verts u p @ tl (awalk_verts (awlast u p) q)", "by (intro awalk_verts_append_cas) blast"], ["", "lemma awalk_verts_append2:\n  assumes \"awalk u (p @ q) v\"\n  shows \"awalk_verts u (p @ q) = butlast (awalk_verts u p) @ awalk_verts (awlast u p) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk_verts u (p @ q) =\n    butlast (awalk_verts u p) @ awalk_verts (awlast u p) q", "using assms"], ["proof (prove)\nusing this:\n  awalk u (p @ q) v\n\ngoal (1 subgoal):\n 1. awalk_verts u (p @ q) =\n    butlast (awalk_verts u p) @ awalk_verts (awlast u p) q", "by (auto simp: awalk_verts_conv)"], ["", "lemma apath_append_iff:\n  \"apath u (p @ q) v \\<longleftrightarrow> apath u p (awlast u p) \\<and> apath (awlast u p) q v \\<and>\n    set (awalk_verts u p) \\<inter> set (tl (awalk_verts (awlast u p) q)) = {}\" (is \"?L \\<longleftrightarrow> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. apath u (p @ q) v =\n    (apath u p (awlast u p) \\<and>\n     apath (awlast u p) q v \\<and>\n     set (awalk_verts u p) \\<inter> set (tl (awalk_verts (awlast u p) q)) =\n     {})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. apath u (p @ q) v \\<Longrightarrow>\n    apath u p (awlast u p) \\<and>\n    apath (awlast u p) q v \\<and>\n    set (awalk_verts u p) \\<inter> set (tl (awalk_verts (awlast u p) q)) =\n    {}\n 2. apath u p (awlast u p) \\<and>\n    apath (awlast u p) q v \\<and>\n    set (awalk_verts u p) \\<inter> set (tl (awalk_verts (awlast u p) q)) =\n    {} \\<Longrightarrow>\n    apath u (p @ q) v", "assume ?L"], ["proof (state)\nthis:\n  apath u (p @ q) v\n\ngoal (2 subgoals):\n 1. apath u (p @ q) v \\<Longrightarrow>\n    apath u p (awlast u p) \\<and>\n    apath (awlast u p) q v \\<and>\n    set (awalk_verts u p) \\<inter> set (tl (awalk_verts (awlast u p) q)) =\n    {}\n 2. apath u p (awlast u p) \\<and>\n    apath (awlast u p) q v \\<and>\n    set (awalk_verts u p) \\<inter> set (tl (awalk_verts (awlast u p) q)) =\n    {} \\<Longrightarrow>\n    apath u (p @ q) v", "then"], ["proof (chain)\npicking this:\n  apath u (p @ q) v", "have \"distinct (awalk_verts (awlast u p) q)\""], ["proof (prove)\nusing this:\n  apath u (p @ q) v\n\ngoal (1 subgoal):\n 1. distinct (awalk_verts (awlast u p) q)", "by (auto simp: apath_def awalk_verts_append2)"], ["proof (state)\nthis:\n  distinct (awalk_verts (awlast u p) q)\n\ngoal (2 subgoals):\n 1. apath u (p @ q) v \\<Longrightarrow>\n    apath u p (awlast u p) \\<and>\n    apath (awlast u p) q v \\<and>\n    set (awalk_verts u p) \\<inter> set (tl (awalk_verts (awlast u p) q)) =\n    {}\n 2. apath u p (awlast u p) \\<and>\n    apath (awlast u p) q v \\<and>\n    set (awalk_verts u p) \\<inter> set (tl (awalk_verts (awlast u p) q)) =\n    {} \\<Longrightarrow>\n    apath u (p @ q) v", "with \\<open>?L\\<close>"], ["proof (chain)\npicking this:\n  apath u (p @ q) v\n  distinct (awalk_verts (awlast u p) q)", "show ?R"], ["proof (prove)\nusing this:\n  apath u (p @ q) v\n  distinct (awalk_verts (awlast u p) q)\n\ngoal (1 subgoal):\n 1. apath u p (awlast u p) \\<and>\n    apath (awlast u p) q v \\<and>\n    set (awalk_verts u p) \\<inter> set (tl (awalk_verts (awlast u p) q)) =\n    {}", "by (auto simp: apath_def awalk_verts_append)"], ["proof (state)\nthis:\n  apath u p (awlast u p) \\<and>\n  apath (awlast u p) q v \\<and>\n  set (awalk_verts u p) \\<inter> set (tl (awalk_verts (awlast u p) q)) = {}\n\ngoal (1 subgoal):\n 1. apath u p (awlast u p) \\<and>\n    apath (awlast u p) q v \\<and>\n    set (awalk_verts u p) \\<inter> set (tl (awalk_verts (awlast u p) q)) =\n    {} \\<Longrightarrow>\n    apath u (p @ q) v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. apath u p (awlast u p) \\<and>\n    apath (awlast u p) q v \\<and>\n    set (awalk_verts u p) \\<inter> set (tl (awalk_verts (awlast u p) q)) =\n    {} \\<Longrightarrow>\n    apath u (p @ q) v", "assume ?R"], ["proof (state)\nthis:\n  apath u p (awlast u p) \\<and>\n  apath (awlast u p) q v \\<and>\n  set (awalk_verts u p) \\<inter> set (tl (awalk_verts (awlast u p) q)) = {}\n\ngoal (1 subgoal):\n 1. apath u p (awlast u p) \\<and>\n    apath (awlast u p) q v \\<and>\n    set (awalk_verts u p) \\<inter> set (tl (awalk_verts (awlast u p) q)) =\n    {} \\<Longrightarrow>\n    apath u (p @ q) v", "then"], ["proof (chain)\npicking this:\n  apath u p (awlast u p) \\<and>\n  apath (awlast u p) q v \\<and>\n  set (awalk_verts u p) \\<inter> set (tl (awalk_verts (awlast u p) q)) = {}", "show ?L"], ["proof (prove)\nusing this:\n  apath u p (awlast u p) \\<and>\n  apath (awlast u p) q v \\<and>\n  set (awalk_verts u p) \\<inter> set (tl (awalk_verts (awlast u p) q)) = {}\n\ngoal (1 subgoal):\n 1. apath u (p @ q) v", "by (auto simp: apath_def awalk_verts_append dest: distinct_tl)"], ["proof (state)\nthis:\n  apath u (p @ q) v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in wf_digraph) set_awalk_verts_append_cas:\n  assumes \"cas u p v\" \"cas v q w\"\n  shows \"set (awalk_verts u (p @ q)) = set (awalk_verts u p) \\<union> set (awalk_verts v q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (awalk_verts u (p @ q)) =\n    set (awalk_verts u p) \\<union> set (awalk_verts v q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (awalk_verts u (p @ q)) =\n    set (awalk_verts u p) \\<union> set (awalk_verts v q)", "from assms"], ["proof (chain)\npicking this:\n  cas u p v\n  cas v q w", "have cas_pq: \"cas u (p @ q) w\""], ["proof (prove)\nusing this:\n  cas u p v\n  cas v q w\n\ngoal (1 subgoal):\n 1. cas u (p @ q) w", "by (simp add: awlast_if_cas)"], ["proof (state)\nthis:\n  cas u (p @ q) w\n\ngoal (1 subgoal):\n 1. set (awalk_verts u (p @ q)) =\n    set (awalk_verts u p) \\<union> set (awalk_verts v q)", "moreover"], ["proof (state)\nthis:\n  cas u (p @ q) w\n\ngoal (1 subgoal):\n 1. set (awalk_verts u (p @ q)) =\n    set (awalk_verts u p) \\<union> set (awalk_verts v q)", "from assms"], ["proof (chain)\npicking this:\n  cas u p v\n  cas v q w", "have \"v \\<in> set (awalk_verts u p)\""], ["proof (prove)\nusing this:\n  cas u p v\n  cas v q w\n\ngoal (1 subgoal):\n 1. v \\<in> set (awalk_verts u p)", "by (metis awalk_verts_non_Nil awlast_if_cas last_in_set)"], ["proof (state)\nthis:\n  v \\<in> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. set (awalk_verts u (p @ q)) =\n    set (awalk_verts u p) \\<union> set (awalk_verts v q)", "ultimately"], ["proof (chain)\npicking this:\n  cas u (p @ q) w\n  v \\<in> set (awalk_verts u p)", "show ?thesis"], ["proof (prove)\nusing this:\n  cas u (p @ q) w\n  v \\<in> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. set (awalk_verts u (p @ q)) =\n    set (awalk_verts u p) \\<union> set (awalk_verts v q)", "using assms"], ["proof (prove)\nusing this:\n  cas u (p @ q) w\n  v \\<in> set (awalk_verts u p)\n  cas u p v\n  cas v q w\n\ngoal (1 subgoal):\n 1. set (awalk_verts u (p @ q)) =\n    set (awalk_verts u p) \\<union> set (awalk_verts v q)", "by (auto simp: set_awalk_verts_cas)"], ["proof (state)\nthis:\n  set (awalk_verts u (p @ q)) =\n  set (awalk_verts u p) \\<union> set (awalk_verts v q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in wf_digraph) set_awalk_verts_append:\n  assumes \"awalk u p v\" \"awalk v q w\"\n  shows \"set (awalk_verts u (p @ q)) = set (awalk_verts u p) \\<union> set (awalk_verts v q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (awalk_verts u (p @ q)) =\n    set (awalk_verts u p) \\<union> set (awalk_verts v q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (awalk_verts u (p @ q)) =\n    set (awalk_verts u p) \\<union> set (awalk_verts v q)", "from assms"], ["proof (chain)\npicking this:\n  awalk u p v\n  awalk v q w", "have \"awalk u (p @ q) w\""], ["proof (prove)\nusing this:\n  awalk u p v\n  awalk v q w\n\ngoal (1 subgoal):\n 1. awalk u (p @ q) w", "by auto"], ["proof (state)\nthis:\n  awalk u (p @ q) w\n\ngoal (1 subgoal):\n 1. set (awalk_verts u (p @ q)) =\n    set (awalk_verts u p) \\<union> set (awalk_verts v q)", "moreover"], ["proof (state)\nthis:\n  awalk u (p @ q) w\n\ngoal (1 subgoal):\n 1. set (awalk_verts u (p @ q)) =\n    set (awalk_verts u p) \\<union> set (awalk_verts v q)", "with assms"], ["proof (chain)\npicking this:\n  awalk u p v\n  awalk v q w\n  awalk u (p @ q) w", "have \"v \\<in> set (awalk_verts u (p @ q))\""], ["proof (prove)\nusing this:\n  awalk u p v\n  awalk v q w\n  awalk u (p @ q) w\n\ngoal (1 subgoal):\n 1. v \\<in> set (awalk_verts u (p @ q))", "by (auto simp: awalk_verts_append)"], ["proof (state)\nthis:\n  v \\<in> set (awalk_verts u (p @ q))\n\ngoal (1 subgoal):\n 1. set (awalk_verts u (p @ q)) =\n    set (awalk_verts u p) \\<union> set (awalk_verts v q)", "ultimately"], ["proof (chain)\npicking this:\n  awalk u (p @ q) w\n  v \\<in> set (awalk_verts u (p @ q))", "show ?thesis"], ["proof (prove)\nusing this:\n  awalk u (p @ q) w\n  v \\<in> set (awalk_verts u (p @ q))\n\ngoal (1 subgoal):\n 1. set (awalk_verts u (p @ q)) =\n    set (awalk_verts u p) \\<union> set (awalk_verts v q)", "using assms"], ["proof (prove)\nusing this:\n  awalk u (p @ q) w\n  v \\<in> set (awalk_verts u (p @ q))\n  awalk u p v\n  awalk v q w\n\ngoal (1 subgoal):\n 1. set (awalk_verts u (p @ q)) =\n    set (awalk_verts u p) \\<union> set (awalk_verts v q)", "by (auto simp: set_awalk_verts)"], ["proof (state)\nthis:\n  set (awalk_verts u (p @ q)) =\n  set (awalk_verts u p) \\<union> set (awalk_verts v q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cas_takeI:\n  assumes \"cas u p v\" \"awlast u (take n p) = v'\"\n  shows \"cas u (take n p) v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cas u (take n p) v'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cas u (take n p) v'", "from assms"], ["proof (chain)\npicking this:\n  cas u p v\n  awlast u (take n p) = v'", "have \"cas u (take n p @ drop n p) v\""], ["proof (prove)\nusing this:\n  cas u p v\n  awlast u (take n p) = v'\n\ngoal (1 subgoal):\n 1. cas u (take n p @ drop n p) v", "by simp"], ["proof (state)\nthis:\n  cas u (take n p @ drop n p) v\n\ngoal (1 subgoal):\n 1. cas u (take n p) v'", "with assms"], ["proof (chain)\npicking this:\n  cas u p v\n  awlast u (take n p) = v'\n  cas u (take n p @ drop n p) v", "show ?thesis"], ["proof (prove)\nusing this:\n  cas u p v\n  awlast u (take n p) = v'\n  cas u (take n p @ drop n p) v\n\ngoal (1 subgoal):\n 1. cas u (take n p) v'", "unfolding cas_append_iff"], ["proof (prove)\nusing this:\n  cas u p v\n  awlast u (take n p) = v'\n  cas u (take n p) (awlast u (take n p)) \\<and>\n  cas (awlast u (take n p)) (drop n p) v\n\ngoal (1 subgoal):\n 1. cas u (take n p) v'", "by simp"], ["proof (state)\nthis:\n  cas u (take n p) v'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cas_dropI:\n  assumes \"cas u p v\" \"awlast u (take n p) = u'\"\n  shows \"cas u' (drop n p) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cas u' (drop n p) v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cas u' (drop n p) v", "from assms"], ["proof (chain)\npicking this:\n  cas u p v\n  awlast u (take n p) = u'", "have \"cas u (take n p @ drop n p) v\""], ["proof (prove)\nusing this:\n  cas u p v\n  awlast u (take n p) = u'\n\ngoal (1 subgoal):\n 1. cas u (take n p @ drop n p) v", "by simp"], ["proof (state)\nthis:\n  cas u (take n p @ drop n p) v\n\ngoal (1 subgoal):\n 1. cas u' (drop n p) v", "with assms"], ["proof (chain)\npicking this:\n  cas u p v\n  awlast u (take n p) = u'\n  cas u (take n p @ drop n p) v", "show ?thesis"], ["proof (prove)\nusing this:\n  cas u p v\n  awlast u (take n p) = u'\n  cas u (take n p @ drop n p) v\n\ngoal (1 subgoal):\n 1. cas u' (drop n p) v", "unfolding cas_append_iff"], ["proof (prove)\nusing this:\n  cas u p v\n  awlast u (take n p) = u'\n  cas u (take n p) (awlast u (take n p)) \\<and>\n  cas (awlast u (take n p)) (drop n p) v\n\ngoal (1 subgoal):\n 1. cas u' (drop n p) v", "by simp"], ["proof (state)\nthis:\n  cas u' (drop n p) v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma awalk_verts_take_conv:\n  assumes \"cas u p v\"\n  shows \"awalk_verts u (take n p) = take (Suc n) (awalk_verts u p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk_verts u (take n p) = take (Suc n) (awalk_verts u p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. awalk_verts u (take n p) = take (Suc n) (awalk_verts u p)", "from assms"], ["proof (chain)\npicking this:\n  cas u p v", "have \"cas u (take n p) (awlast u (take n p))\""], ["proof (prove)\nusing this:\n  cas u p v\n\ngoal (1 subgoal):\n 1. cas u (take n p) (awlast u (take n p))", "by (auto intro: cas_takeI)"], ["proof (state)\nthis:\n  cas u (take n p) (awlast u (take n p))\n\ngoal (1 subgoal):\n 1. awalk_verts u (take n p) = take (Suc n) (awalk_verts u p)", "with assms"], ["proof (chain)\npicking this:\n  cas u p v\n  cas u (take n p) (awlast u (take n p))", "show ?thesis"], ["proof (prove)\nusing this:\n  cas u p v\n  cas u (take n p) (awlast u (take n p))\n\ngoal (1 subgoal):\n 1. awalk_verts u (take n p) = take (Suc n) (awalk_verts u p)", "by (cases n p rule: nat.exhaust[case_product list.exhaust])\n       (auto simp: awalk_verts_conv' take_map simp del: awalk_verts.simps)"], ["proof (state)\nthis:\n  awalk_verts u (take n p) = take (Suc n) (awalk_verts u p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma awalk_verts_drop_conv:\n  assumes \"cas u p v\"\n  shows \"awalk_verts u' (drop n p) = (if n < length p then drop n (awalk_verts u p) else [u'])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk_verts u' (drop n p) =\n    (if n < length p then drop n (awalk_verts u p) else [u'])", "using assms"], ["proof (prove)\nusing this:\n  cas u p v\n\ngoal (1 subgoal):\n 1. awalk_verts u' (drop n p) =\n    (if n < length p then drop n (awalk_verts u p) else [u'])", "by (auto simp: awalk_verts_conv drop_map)"], ["", "lemma awalk_decomp_verts:\n  assumes cas: \"cas u p v\" and ev_decomp: \"awalk_verts u p = xs @ y # ys\"\n  obtains q r where \"cas u q y\" \"cas y r v\" \"p = q @ r\" \"awalk_verts u q = xs @ [y]\" \"awalk_verts y r = y # ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>cas u q y; cas y r v; p = q @ r;\n         awalk_verts u q = xs @ [y]; awalk_verts y r = y # ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  cas u p v\n  awalk_verts u p = xs @ y # ys\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>cas u q y; cas y r v; p = q @ r;\n         awalk_verts u q = xs @ [y]; awalk_verts y r = y # ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q r.\n                \\<lbrakk>cas u q y; cas y r v; p = q @ r;\n                 awalk_verts u q = xs @ [y];\n                 awalk_verts y r = y # ys\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     cas u p v; awalk_verts u p = xs @ y # ys\\<rbrakk>\n    \\<Longrightarrow> thesis", "define q r where \"q = take (length xs) p\" and \"r = drop (length xs) p\""], ["proof (state)\nthis:\n  q = take (length xs) p\n  r = drop (length xs) p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q r.\n                \\<lbrakk>cas u q y; cas y r v; p = q @ r;\n                 awalk_verts u q = xs @ [y];\n                 awalk_verts y r = y # ys\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     cas u p v; awalk_verts u p = xs @ y # ys\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  q = take (length xs) p\n  r = drop (length xs) p", "have p: \"p = q @ r\""], ["proof (prove)\nusing this:\n  q = take (length xs) p\n  r = drop (length xs) p\n\ngoal (1 subgoal):\n 1. p = q @ r", "by simp"], ["proof (state)\nthis:\n  p = q @ r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q r.\n                \\<lbrakk>cas u q y; cas y r v; p = q @ r;\n                 awalk_verts u q = xs @ [y];\n                 awalk_verts y r = y # ys\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     cas u p v; awalk_verts u p = xs @ y # ys\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  p = q @ r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q r.\n                \\<lbrakk>cas u q y; cas y r v; p = q @ r;\n                 awalk_verts u q = xs @ [y];\n                 awalk_verts y r = y # ys\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     cas u p v; awalk_verts u p = xs @ y # ys\\<rbrakk>\n    \\<Longrightarrow> thesis", "from p"], ["proof (chain)\npicking this:\n  p = q @ r", "have \"cas u q (awlast u q)\" \"cas (awlast u q) r v\""], ["proof (prove)\nusing this:\n  p = q @ r\n\ngoal (1 subgoal):\n 1. cas u q (awlast u q) &&& cas (awlast u q) r v", "using \\<open>cas u p v\\<close>"], ["proof (prove)\nusing this:\n  p = q @ r\n  cas u p v\n\ngoal (1 subgoal):\n 1. cas u q (awlast u q) &&& cas (awlast u q) r v", "by auto"], ["proof (state)\nthis:\n  cas u q (awlast u q)\n  cas (awlast u q) r v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q r.\n                \\<lbrakk>cas u q y; cas y r v; p = q @ r;\n                 awalk_verts u q = xs @ [y];\n                 awalk_verts y r = y # ys\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     cas u p v; awalk_verts u p = xs @ y # ys\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  cas u q (awlast u q)\n  cas (awlast u q) r v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q r.\n                \\<lbrakk>cas u q y; cas y r v; p = q @ r;\n                 awalk_verts u q = xs @ [y];\n                 awalk_verts y r = y # ys\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     cas u p v; awalk_verts u p = xs @ y # ys\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"awlast u q = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awlast u q = y", "using q_def and assms"], ["proof (prove)\nusing this:\n  q = take (length xs) p\n  cas u p v\n  awalk_verts u p = xs @ y # ys\n\ngoal (1 subgoal):\n 1. awlast u q = y", "by (auto simp: awalk_verts_take_conv)"], ["proof (state)\nthis:\n  awlast u q = y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q r.\n                \\<lbrakk>cas u q y; cas y r v; p = q @ r;\n                 awalk_verts u q = xs @ [y];\n                 awalk_verts y r = y # ys\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     cas u p v; awalk_verts u p = xs @ y # ys\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  awlast u q = y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q r.\n                \\<lbrakk>cas u q y; cas y r v; p = q @ r;\n                 awalk_verts u q = xs @ [y];\n                 awalk_verts y r = y # ys\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     cas u p v; awalk_verts u p = xs @ y # ys\\<rbrakk>\n    \\<Longrightarrow> thesis", "have *: \"awalk_verts u q = xs @ [awlast u q]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk_verts u q = xs @ [awlast u q]", "using assms q_def"], ["proof (prove)\nusing this:\n  cas u p v\n  awalk_verts u p = xs @ y # ys\n  q = take (length xs) p\n\ngoal (1 subgoal):\n 1. awalk_verts u q = xs @ [awlast u q]", "by (auto simp: awalk_verts_take_conv)"], ["proof (state)\nthis:\n  awalk_verts u q = xs @ [awlast u q]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q r.\n                \\<lbrakk>cas u q y; cas y r v; p = q @ r;\n                 awalk_verts u q = xs @ [y];\n                 awalk_verts y r = y # ys\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     cas u p v; awalk_verts u p = xs @ y # ys\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  awalk_verts u q = xs @ [awlast u q]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q r.\n                \\<lbrakk>cas u q y; cas y r v; p = q @ r;\n                 awalk_verts u q = xs @ [y];\n                 awalk_verts y r = y # ys\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     cas u p v; awalk_verts u p = xs @ y # ys\\<rbrakk>\n    \\<Longrightarrow> thesis", "from *"], ["proof (chain)\npicking this:\n  awalk_verts u q = xs @ [awlast u q]", "have \"awalk_verts y r = y # ys\""], ["proof (prove)\nusing this:\n  awalk_verts u q = xs @ [awlast u q]\n\ngoal (1 subgoal):\n 1. awalk_verts y r = y # ys", "unfolding q_def r_def"], ["proof (prove)\nusing this:\n  awalk_verts u (take (length xs) p) = xs @ [awlast u (take (length xs) p)]\n\ngoal (1 subgoal):\n 1. awalk_verts y (drop (length xs) p) = y # ys", "using assms"], ["proof (prove)\nusing this:\n  awalk_verts u (take (length xs) p) = xs @ [awlast u (take (length xs) p)]\n  cas u p v\n  awalk_verts u p = xs @ y # ys\n\ngoal (1 subgoal):\n 1. awalk_verts y (drop (length xs) p) = y # ys", "by (auto simp: awalk_verts_drop_conv not_less)"], ["proof (state)\nthis:\n  awalk_verts y r = y # ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>q r.\n                \\<lbrakk>cas u q y; cas y r v; p = q @ r;\n                 awalk_verts u q = xs @ [y];\n                 awalk_verts y r = y # ys\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     cas u p v; awalk_verts u p = xs @ y # ys\\<rbrakk>\n    \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  p = q @ r\n  cas u q (awlast u q)\n  cas (awlast u q) r v\n  awlast u q = y\n  awalk_verts u q = xs @ [awlast u q]\n  awalk_verts y r = y # ys", "show ?thesis"], ["proof (prove)\nusing this:\n  p = q @ r\n  cas u q (awlast u q)\n  cas (awlast u q) r v\n  awlast u q = y\n  awalk_verts u q = xs @ [awlast u q]\n  awalk_verts y r = y # ys\n\ngoal (1 subgoal):\n 1. thesis", "by (intro that) auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma awalk_decomp:\n  assumes \"awalk u p v\"\n  assumes \"w \\<in> set (awalk_verts u p)\"\n  shows \"\\<exists>q r. p = q @ r \\<and> awalk u q w \\<and> awalk w r v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q r. p = q @ r \\<and> awalk u q w \\<and> awalk w r v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>q r. p = q @ r \\<and> awalk u q w \\<and> awalk w r v", "from assms"], ["proof (chain)\npicking this:\n  awalk u p v\n  w \\<in> set (awalk_verts u p)", "have \"cas u p v\""], ["proof (prove)\nusing this:\n  awalk u p v\n  w \\<in> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. cas u p v", "by auto"], ["proof (state)\nthis:\n  cas u p v\n\ngoal (1 subgoal):\n 1. \\<exists>q r. p = q @ r \\<and> awalk u q w \\<and> awalk w r v", "moreover"], ["proof (state)\nthis:\n  cas u p v\n\ngoal (1 subgoal):\n 1. \\<exists>q r. p = q @ r \\<and> awalk u q w \\<and> awalk w r v", "from assms"], ["proof (chain)\npicking this:\n  awalk u p v\n  w \\<in> set (awalk_verts u p)", "obtain xs ys where\n    \"awalk_verts u p = xs @ w # ys\""], ["proof (prove)\nusing this:\n  awalk u p v\n  w \\<in> set (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. (\\<And>xs ys.\n        awalk_verts u p = xs @ w # ys \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_set_conv_decomp)"], ["proof (state)\nthis:\n  awalk_verts u p = xs @ w # ys\n\ngoal (1 subgoal):\n 1. \\<exists>q r. p = q @ r \\<and> awalk u q w \\<and> awalk w r v", "ultimately"], ["proof (chain)\npicking this:\n  cas u p v\n  awalk_verts u p = xs @ w # ys", "obtain q r where \"cas u q w\" \"cas w r v\" \"p = q @ r\" \"awalk_verts u q = xs @ [w]\""], ["proof (prove)\nusing this:\n  cas u p v\n  awalk_verts u p = xs @ w # ys\n\ngoal (1 subgoal):\n 1. (\\<And>q r.\n        \\<lbrakk>cas u q w; cas w r v; p = q @ r;\n         awalk_verts u q = xs @ [w]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto intro: awalk_decomp_verts)"], ["proof (state)\nthis:\n  cas u q w\n  cas w r v\n  p = q @ r\n  awalk_verts u q = xs @ [w]\n\ngoal (1 subgoal):\n 1. \\<exists>q r. p = q @ r \\<and> awalk u q w \\<and> awalk w r v", "with assms"], ["proof (chain)\npicking this:\n  awalk u p v\n  w \\<in> set (awalk_verts u p)\n  cas u q w\n  cas w r v\n  p = q @ r\n  awalk_verts u q = xs @ [w]", "show ?thesis"], ["proof (prove)\nusing this:\n  awalk u p v\n  w \\<in> set (awalk_verts u p)\n  cas u q w\n  cas w r v\n  p = q @ r\n  awalk_verts u q = xs @ [w]\n\ngoal (1 subgoal):\n 1. \\<exists>q r. p = q @ r \\<and> awalk u q w \\<and> awalk w r v", "by auto"], ["proof (state)\nthis:\n  \\<exists>q r. p = q @ r \\<and> awalk u q w \\<and> awalk w r v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma awalk_not_distinct_decomp:\n  assumes \"awalk u p v\"\n  assumes \"\\<not> distinct (awalk_verts u p)\"\n  shows \"\\<exists>q r s. p = q @ r @ s \\<and> distinct (awalk_verts u q)\n    \\<and> 0 < length r\n    \\<and> (\\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q r s.\n       p = q @ r @ s \\<and>\n       distinct (awalk_verts u q) \\<and>\n       0 < length r \\<and>\n       (\\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>q r s.\n       p = q @ r @ s \\<and>\n       distinct (awalk_verts u q) \\<and>\n       0 < length r \\<and>\n       (\\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v)", "from assms"], ["proof (chain)\npicking this:\n  awalk u p v\n  \\<not> distinct (awalk_verts u p)", "obtain xs ys zs y where\n    pv_decomp: \"awalk_verts u p = xs @ y # ys @ y # zs\"\n    and xs_y_props: \"distinct xs\" \"y \\<notin> set xs\" \"y \\<notin> set ys\""], ["proof (prove)\nusing this:\n  awalk u p v\n  \\<not> distinct (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. (\\<And>xs y ys zs.\n        \\<lbrakk>awalk_verts u p = xs @ y # ys @ y # zs; distinct xs;\n         y \\<notin> set xs; y \\<notin> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using not_distinct_decomp_min_prefix"], ["proof (prove)\nusing this:\n  awalk u p v\n  \\<not> distinct (awalk_verts u p)\n  \\<not> distinct ?ws \\<Longrightarrow>\n  \\<exists>xs ys zs y.\n     ?ws = xs @ y # ys @ y # zs \\<and>\n     distinct xs \\<and> y \\<notin> set xs \\<and> y \\<notin> set ys\n\ngoal (1 subgoal):\n 1. (\\<And>xs y ys zs.\n        \\<lbrakk>awalk_verts u p = xs @ y # ys @ y # zs; distinct xs;\n         y \\<notin> set xs; y \\<notin> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  awalk_verts u p = xs @ y # ys @ y # zs\n  distinct xs\n  y \\<notin> set xs\n  y \\<notin> set ys\n\ngoal (1 subgoal):\n 1. \\<exists>q r s.\n       p = q @ r @ s \\<and>\n       distinct (awalk_verts u q) \\<and>\n       0 < length r \\<and>\n       (\\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v)", "obtain q p' where \"cas u q y\" \"p = q @ p'\" \"awalk_verts u q = xs @ [y]\"\n    and p'_props: \"cas y p' v\"  \"awalk_verts y p' = (y # ys) @ y # zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q p'.\n        \\<lbrakk>cas u q y; p = q @ p'; awalk_verts u q = xs @ [y];\n         cas y p' v; awalk_verts y p' = (y # ys) @ y # zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms pv_decomp"], ["proof (prove)\nusing this:\n  awalk u p v\n  \\<not> distinct (awalk_verts u p)\n  awalk_verts u p = xs @ y # ys @ y # zs\n\ngoal (1 subgoal):\n 1. (\\<And>q p'.\n        \\<lbrakk>cas u q y; p = q @ p'; awalk_verts u q = xs @ [y];\n         cas y p' v; awalk_verts y p' = (y # ys) @ y # zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by - (rule awalk_decomp_verts, auto)"], ["proof (state)\nthis:\n  cas u q y\n  p = q @ p'\n  awalk_verts u q = xs @ [y]\n  cas y p' v\n  awalk_verts y p' = (y # ys) @ y # zs\n\ngoal (1 subgoal):\n 1. \\<exists>q r s.\n       p = q @ r @ s \\<and>\n       distinct (awalk_verts u q) \\<and>\n       0 < length r \\<and>\n       (\\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v)", "obtain r s where \"cas y r y\" \"cas y s v\" \"p' = r @ s\"\n    \"awalk_verts y r = y # ys @ [y]\" \"awalk_verts y s = y # zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r s.\n        \\<lbrakk>cas y r y; cas y s v; p' = r @ s;\n         awalk_verts y r = y # ys @ [y]; awalk_verts y s = y # zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using p'_props"], ["proof (prove)\nusing this:\n  cas y p' v\n  awalk_verts y p' = (y # ys) @ y # zs\n\ngoal (1 subgoal):\n 1. (\\<And>r s.\n        \\<lbrakk>cas y r y; cas y s v; p' = r @ s;\n         awalk_verts y r = y # ys @ [y]; awalk_verts y s = y # zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule awalk_decomp_verts) auto"], ["proof (state)\nthis:\n  cas y r y\n  cas y s v\n  p' = r @ s\n  awalk_verts y r = y # ys @ [y]\n  awalk_verts y s = y # zs\n\ngoal (1 subgoal):\n 1. \\<exists>q r s.\n       p = q @ r @ s \\<and>\n       distinct (awalk_verts u q) \\<and>\n       0 < length r \\<and>\n       (\\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v)", "have \"p = q @ r @ s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q @ r @ s", "using \\<open>p = q @ p'\\<close> \\<open>p' = r @ s\\<close>"], ["proof (prove)\nusing this:\n  p = q @ p'\n  p' = r @ s\n\ngoal (1 subgoal):\n 1. p = q @ r @ s", "by simp"], ["proof (state)\nthis:\n  p = q @ r @ s\n\ngoal (1 subgoal):\n 1. \\<exists>q r s.\n       p = q @ r @ s \\<and>\n       distinct (awalk_verts u q) \\<and>\n       0 < length r \\<and>\n       (\\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v)", "moreover"], ["proof (state)\nthis:\n  p = q @ r @ s\n\ngoal (1 subgoal):\n 1. \\<exists>q r s.\n       p = q @ r @ s \\<and>\n       distinct (awalk_verts u q) \\<and>\n       0 < length r \\<and>\n       (\\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v)", "have \"distinct (awalk_verts u q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (awalk_verts u q)", "using \\<open>awalk_verts u q = xs @ [y]\\<close> and xs_y_props"], ["proof (prove)\nusing this:\n  awalk_verts u q = xs @ [y]\n  distinct xs\n  y \\<notin> set xs\n  y \\<notin> set ys\n\ngoal (1 subgoal):\n 1. distinct (awalk_verts u q)", "by simp"], ["proof (state)\nthis:\n  distinct (awalk_verts u q)\n\ngoal (1 subgoal):\n 1. \\<exists>q r s.\n       p = q @ r @ s \\<and>\n       distinct (awalk_verts u q) \\<and>\n       0 < length r \\<and>\n       (\\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v)", "moreover"], ["proof (state)\nthis:\n  distinct (awalk_verts u q)\n\ngoal (1 subgoal):\n 1. \\<exists>q r s.\n       p = q @ r @ s \\<and>\n       distinct (awalk_verts u q) \\<and>\n       0 < length r \\<and>\n       (\\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v)", "have \"0 < length r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length r", "using \\<open>awalk_verts y r = y # ys @ [y]\\<close>"], ["proof (prove)\nusing this:\n  awalk_verts y r = y # ys @ [y]\n\ngoal (1 subgoal):\n 1. 0 < length r", "by auto"], ["proof (state)\nthis:\n  0 < length r\n\ngoal (1 subgoal):\n 1. \\<exists>q r s.\n       p = q @ r @ s \\<and>\n       distinct (awalk_verts u q) \\<and>\n       0 < length r \\<and>\n       (\\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v)", "moreover"], ["proof (state)\nthis:\n  0 < length r\n\ngoal (1 subgoal):\n 1. \\<exists>q r s.\n       p = q @ r @ s \\<and>\n       distinct (awalk_verts u q) \\<and>\n       0 < length r \\<and>\n       (\\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v)", "from pv_decomp assms"], ["proof (chain)\npicking this:\n  awalk_verts u p = xs @ y # ys @ y # zs\n  awalk u p v\n  \\<not> distinct (awalk_verts u p)", "have \"y \\<in> verts G\""], ["proof (prove)\nusing this:\n  awalk_verts u p = xs @ y # ys @ y # zs\n  awalk u p v\n  \\<not> distinct (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. y \\<in> verts G", "by auto"], ["proof (state)\nthis:\n  y \\<in> verts G\n\ngoal (1 subgoal):\n 1. \\<exists>q r s.\n       p = q @ r @ s \\<and>\n       distinct (awalk_verts u q) \\<and>\n       0 < length r \\<and>\n       (\\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v)", "then"], ["proof (chain)\npicking this:\n  y \\<in> verts G", "have \"awalk u q y\" \"awalk y r y\" \"awalk y s v\""], ["proof (prove)\nusing this:\n  y \\<in> verts G\n\ngoal (1 subgoal):\n 1. awalk u q y &&& awalk y r y &&& awalk y s v", "using \\<open>awalk u p v\\<close> \\<open>cas u q y\\<close> \\<open>cas y r y\\<close> \\<open>cas y s v\\<close>"], ["proof (prove)\nusing this:\n  y \\<in> verts G\n  awalk u p v\n  cas u q y\n  cas y r y\n  cas y s v\n\ngoal (1 subgoal):\n 1. awalk u q y &&& awalk y r y &&& awalk y s v", "unfolding \\<open>p = q @ r @ s\\<close>"], ["proof (prove)\nusing this:\n  y \\<in> verts G\n  awalk u (q @ r @ s) v\n  cas u q y\n  cas y r y\n  cas y s v\n\ngoal (1 subgoal):\n 1. awalk u q y &&& awalk y r y &&& awalk y s v", "by (auto simp: awalk_def)"], ["proof (state)\nthis:\n  awalk u q y\n  awalk y r y\n  awalk y s v\n\ngoal (1 subgoal):\n 1. \\<exists>q r s.\n       p = q @ r @ s \\<and>\n       distinct (awalk_verts u q) \\<and>\n       0 < length r \\<and>\n       (\\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v)", "ultimately"], ["proof (chain)\npicking this:\n  p = q @ r @ s\n  distinct (awalk_verts u q)\n  0 < length r\n  awalk u q y\n  awalk y r y\n  awalk y s v", "show ?thesis"], ["proof (prove)\nusing this:\n  p = q @ r @ s\n  distinct (awalk_verts u q)\n  0 < length r\n  awalk u q y\n  awalk y r y\n  awalk y s v\n\ngoal (1 subgoal):\n 1. \\<exists>q r s.\n       p = q @ r @ s \\<and>\n       distinct (awalk_verts u q) \\<and>\n       0 < length r \\<and>\n       (\\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v)", "by blast"], ["proof (state)\nthis:\n  \\<exists>q r s.\n     p = q @ r @ s \\<and>\n     distinct (awalk_verts u q) \\<and>\n     0 < length r \\<and>\n     (\\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma apath_decomp_disjoint:\n  assumes \"apath u p v\"\n  assumes \"p = q @ r\"\n  assumes \"x \\<in> set (awalk_verts u q)\" \"x \\<in> set (tl (awalk_verts (awlast u q) r))\"\n  shows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  apath u p v\n  p = q @ r\n  x \\<in> set (awalk_verts u q)\n  x \\<in> set (tl (awalk_verts (awlast u q) r))\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: apath_def awalk_verts_append)"], ["", "subsection \\<open>Cycles\\<close>"], ["", "definition closed_w :: \"'b awalk \\<Rightarrow> bool\" where\n  \"closed_w p \\<equiv> \\<exists>u. awalk u p u \\<and> 0 < length p\""], ["", "text \\<open>\n  The definitions of cycles in textbooks vary w.r.t to the minimial length\n  of a cycle.\n\n  The definition given here matches \\cite{diestel2010graph}.\n  \\cite{bangjensen2009digraphs} excludes loops from being cycles.\n  Volkmann (Lutz Volkmann: Graphen an allen Ecken und Kanten, 2006 (?))\n  places no restriction on the length in the definition, but later\n  usage assumes cycles to be non-empty.\n\\<close>"], ["", "definition (in pre_digraph) cycle :: \"'b awalk \\<Rightarrow> bool\" where\n  \"cycle p \\<equiv> \\<exists>u. awalk u p u \\<and> distinct (tl (awalk_verts u p)) \\<and> p \\<noteq> []\""], ["", "lemma cycle_altdef:\n  \"cycle p \\<longleftrightarrow> closed_w p \\<and> (\\<exists>u. distinct (tl (awalk_verts u p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cycle p =\n    (closed_w p \\<and> (\\<exists>u. distinct (tl (awalk_verts u p))))", "by (cases p) (auto simp: closed_w_def cycle_def)"], ["", "lemma (in wf_digraph) distinct_tl_verts_imp_distinct:\n  assumes \"awalk u p v\"\n  assumes \"distinct (tl (awalk_verts u p))\"\n  shows \"distinct p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct p", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> distinct p \\<Longrightarrow> False", "assume \"\\<not>distinct p\""], ["proof (state)\nthis:\n  \\<not> distinct p\n\ngoal (1 subgoal):\n 1. \\<not> distinct p \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> distinct p", "obtain e xs ys zs where p_decomp: \"p = xs @ e # ys @ e # zs\""], ["proof (prove)\nusing this:\n  \\<not> distinct p\n\ngoal (1 subgoal):\n 1. (\\<And>xs e ys zs.\n        p = xs @ e # ys @ e # zs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: not_distinct_decomp_min_prefix)"], ["proof (state)\nthis:\n  p = xs @ e # ys @ e # zs\n\ngoal (1 subgoal):\n 1. \\<not> distinct p \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  p = xs @ e # ys @ e # zs", "show False"], ["proof (prove)\nusing this:\n  p = xs @ e # ys @ e # zs\n\ngoal (1 subgoal):\n 1. False", "using assms p_decomp"], ["proof (prove)\nusing this:\n  p = xs @ e # ys @ e # zs\n  awalk u p v\n  distinct (tl (awalk_verts u p))\n  p = xs @ e # ys @ e # zs\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: awalk_verts_append awalk_Cons_iff set_awalk_verts)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in wf_digraph) distinct_verts_imp_distinct:\n  assumes \"awalk u p v\"\n  assumes \"distinct (awalk_verts u p)\"\n  shows \"distinct p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct p", "using assms"], ["proof (prove)\nusing this:\n  awalk u p v\n  distinct (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. distinct p", "by (blast intro: distinct_tl_verts_imp_distinct distinct_tl)"], ["", "lemma (in wf_digraph) cycle_conv:\n  \"cycle p \\<longleftrightarrow> (\\<exists>u. awalk u p u \\<and> distinct (tl (awalk_verts u p)) \\<and> distinct p \\<and> p \\<noteq> [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cycle p =\n    (\\<exists>u.\n        awalk u p u \\<and>\n        distinct (tl (awalk_verts u p)) \\<and>\n        distinct p \\<and> p \\<noteq> [])", "unfolding cycle_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>u.\n        awalk u p u \\<and>\n        distinct (tl (awalk_verts u p)) \\<and> p \\<noteq> []) =\n    (\\<exists>u.\n        awalk u p u \\<and>\n        distinct (tl (awalk_verts u p)) \\<and>\n        distinct p \\<and> p \\<noteq> [])", "by (auto intro: distinct_tl_verts_imp_distinct)"], ["", "lemma (in loopfree_digraph) cycle_digraph_conv:\n  \"cycle p \\<longleftrightarrow> (\\<exists>u. awalk u p u \\<and> distinct (tl (awalk_verts u p)) \\<and> 2 \\<le> length p)\" (is \"?L \\<longleftrightarrow> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. cycle p =\n    (\\<exists>u.\n        awalk u p u \\<and>\n        distinct (tl (awalk_verts u p)) \\<and> 2 \\<le> length p)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. cycle p \\<Longrightarrow>\n    \\<exists>u.\n       awalk u p u \\<and>\n       distinct (tl (awalk_verts u p)) \\<and> 2 \\<le> length p\n 2. \\<exists>u.\n       awalk u p u \\<and>\n       distinct (tl (awalk_verts u p)) \\<and>\n       2 \\<le> length p \\<Longrightarrow>\n    cycle p", "assume \"cycle p\""], ["proof (state)\nthis:\n  cycle p\n\ngoal (2 subgoals):\n 1. cycle p \\<Longrightarrow>\n    \\<exists>u.\n       awalk u p u \\<and>\n       distinct (tl (awalk_verts u p)) \\<and> 2 \\<le> length p\n 2. \\<exists>u.\n       awalk u p u \\<and>\n       distinct (tl (awalk_verts u p)) \\<and>\n       2 \\<le> length p \\<Longrightarrow>\n    cycle p", "then"], ["proof (chain)\npicking this:\n  cycle p", "obtain u where *: \"awalk u p u\" \"distinct (tl (awalk_verts u p))\" \"p \\<noteq> []\""], ["proof (prove)\nusing this:\n  cycle p\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>awalk u p u; distinct (tl (awalk_verts u p));\n         p \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding cycle_def"], ["proof (prove)\nusing this:\n  \\<exists>u.\n     awalk u p u \\<and> distinct (tl (awalk_verts u p)) \\<and> p \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>awalk u p u; distinct (tl (awalk_verts u p));\n         p \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  awalk u p u\n  distinct (tl (awalk_verts u p))\n  p \\<noteq> []\n\ngoal (2 subgoals):\n 1. cycle p \\<Longrightarrow>\n    \\<exists>u.\n       awalk u p u \\<and>\n       distinct (tl (awalk_verts u p)) \\<and> 2 \\<le> length p\n 2. \\<exists>u.\n       awalk u p u \\<and>\n       distinct (tl (awalk_verts u p)) \\<and>\n       2 \\<le> length p \\<Longrightarrow>\n    cycle p", "have \"2 \\<le> length p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> length p", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 2 \\<le> length p \\<Longrightarrow> False", "assume \"\\<not>?thesis\""], ["proof (state)\nthis:\n  \\<not> 2 \\<le> length p\n\ngoal (1 subgoal):\n 1. \\<not> 2 \\<le> length p \\<Longrightarrow> False", "with *"], ["proof (chain)\npicking this:\n  awalk u p u\n  distinct (tl (awalk_verts u p))\n  p \\<noteq> []\n  \\<not> 2 \\<le> length p", "obtain e where \"p=[e]\""], ["proof (prove)\nusing this:\n  awalk u p u\n  distinct (tl (awalk_verts u p))\n  p \\<noteq> []\n  \\<not> 2 \\<le> length p\n\ngoal (1 subgoal):\n 1. (\\<And>e. p = [e] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases p) (auto simp: not_le)"], ["proof (state)\nthis:\n  p = [e]\n\ngoal (1 subgoal):\n 1. \\<not> 2 \\<le> length p \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  p = [e]", "show False"], ["proof (prove)\nusing this:\n  p = [e]\n\ngoal (1 subgoal):\n 1. False", "using *"], ["proof (prove)\nusing this:\n  p = [e]\n  awalk u p u\n  distinct (tl (awalk_verts u p))\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: awalk_simps dest: no_loops)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 \\<le> length p\n\ngoal (2 subgoals):\n 1. cycle p \\<Longrightarrow>\n    \\<exists>u.\n       awalk u p u \\<and>\n       distinct (tl (awalk_verts u p)) \\<and> 2 \\<le> length p\n 2. \\<exists>u.\n       awalk u p u \\<and>\n       distinct (tl (awalk_verts u p)) \\<and>\n       2 \\<le> length p \\<Longrightarrow>\n    cycle p", "then"], ["proof (chain)\npicking this:\n  2 \\<le> length p", "show ?R"], ["proof (prove)\nusing this:\n  2 \\<le> length p\n\ngoal (1 subgoal):\n 1. \\<exists>u.\n       awalk u p u \\<and>\n       distinct (tl (awalk_verts u p)) \\<and> 2 \\<le> length p", "using *"], ["proof (prove)\nusing this:\n  2 \\<le> length p\n  awalk u p u\n  distinct (tl (awalk_verts u p))\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>u.\n       awalk u p u \\<and>\n       distinct (tl (awalk_verts u p)) \\<and> 2 \\<le> length p", "by auto"], ["proof (state)\nthis:\n  \\<exists>u.\n     awalk u p u \\<and>\n     distinct (tl (awalk_verts u p)) \\<and> 2 \\<le> length p\n\ngoal (1 subgoal):\n 1. \\<exists>u.\n       awalk u p u \\<and>\n       distinct (tl (awalk_verts u p)) \\<and>\n       2 \\<le> length p \\<Longrightarrow>\n    cycle p", "qed (auto simp: cycle_def)"], ["", "lemma (in wf_digraph) closed_w_imp_cycle:\n  assumes \"closed_w p\" shows \"\\<exists>p. cycle p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex cycle", "using assms"], ["proof (prove)\nusing this:\n  closed_w p\n\ngoal (1 subgoal):\n 1. Ex cycle", "proof (induct \"length p\" arbitrary: p rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>length pa < length p; closed_w pa\\<rbrakk>\n                   \\<Longrightarrow> Ex cycle;\n        closed_w p\\<rbrakk>\n       \\<Longrightarrow> Ex cycle", "case less"], ["proof (state)\nthis:\n  \\<lbrakk>length ?p < length p; closed_w ?p\\<rbrakk>\n  \\<Longrightarrow> Ex cycle\n  closed_w p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>length pa < length p; closed_w pa\\<rbrakk>\n                   \\<Longrightarrow> Ex cycle;\n        closed_w p\\<rbrakk>\n       \\<Longrightarrow> Ex cycle", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?p < length p; closed_w ?p\\<rbrakk>\n  \\<Longrightarrow> Ex cycle\n  closed_w p", "obtain u where *: \"awalk u p u\" \"p \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?p < length p; closed_w ?p\\<rbrakk>\n  \\<Longrightarrow> Ex cycle\n  closed_w p\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>awalk u p u; p \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: closed_w_def)"], ["proof (state)\nthis:\n  awalk u p u\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>length pa < length p; closed_w pa\\<rbrakk>\n                   \\<Longrightarrow> Ex cycle;\n        closed_w p\\<rbrakk>\n       \\<Longrightarrow> Ex cycle", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex cycle", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> Ex cycle\n 2. \\<not> ?P \\<Longrightarrow> Ex cycle", "assume \"distinct (tl (awalk_verts u p))\""], ["proof (state)\nthis:\n  distinct (tl (awalk_verts u p))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> Ex cycle\n 2. \\<not> ?P \\<Longrightarrow> Ex cycle", "with less"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?p < length p; closed_w ?p\\<rbrakk>\n  \\<Longrightarrow> Ex cycle\n  closed_w p\n  distinct (tl (awalk_verts u p))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?p < length p; closed_w ?p\\<rbrakk>\n  \\<Longrightarrow> Ex cycle\n  closed_w p\n  distinct (tl (awalk_verts u p))\n\ngoal (1 subgoal):\n 1. Ex cycle", "by (auto simp: closed_w_def cycle_altdef)"], ["proof (state)\nthis:\n  Ex cycle\n\ngoal (1 subgoal):\n 1. \\<not> distinct (tl (awalk_verts u p)) \\<Longrightarrow> Ex cycle", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> distinct (tl (awalk_verts u p)) \\<Longrightarrow> Ex cycle", "assume A: \"\\<not>distinct (tl (awalk_verts u p))\""], ["proof (state)\nthis:\n  \\<not> distinct (tl (awalk_verts u p))\n\ngoal (1 subgoal):\n 1. \\<not> distinct (tl (awalk_verts u p)) \\<Longrightarrow> Ex cycle", "then"], ["proof (chain)\npicking this:\n  \\<not> distinct (tl (awalk_verts u p))", "obtain e es where \"p = e # es\""], ["proof (prove)\nusing this:\n  \\<not> distinct (tl (awalk_verts u p))\n\ngoal (1 subgoal):\n 1. (\\<And>e es. p = e # es \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p) auto"], ["proof (state)\nthis:\n  p = e # es\n\ngoal (1 subgoal):\n 1. \\<not> distinct (tl (awalk_verts u p)) \\<Longrightarrow> Ex cycle", "with A *"], ["proof (chain)\npicking this:\n  \\<not> distinct (tl (awalk_verts u p))\n  awalk u p u\n  p \\<noteq> []\n  p = e # es", "have **: \"awalk (head G e) es u\" \"\\<not>distinct (awalk_verts (head G e) es)\""], ["proof (prove)\nusing this:\n  \\<not> distinct (tl (awalk_verts u p))\n  awalk u p u\n  p \\<noteq> []\n  p = e # es\n\ngoal (1 subgoal):\n 1. awalk (head G e) es u &&& \\<not> distinct (awalk_verts (head G e) es)", "by (auto simp: awalk_Cons_iff)"], ["proof (state)\nthis:\n  awalk (head G e) es u\n  \\<not> distinct (awalk_verts (head G e) es)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (tl (awalk_verts u p)) \\<Longrightarrow> Ex cycle", "obtain q r s where \"es = q @ r @ s\" \"\\<exists>w. awalk w r w\" \"closed_w r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q r s.\n        \\<lbrakk>es = q @ r @ s; \\<exists>w. awalk w r w;\n         closed_w r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using awalk_not_distinct_decomp[OF **]"], ["proof (prove)\nusing this:\n  \\<exists>q r s.\n     es = q @ r @ s \\<and>\n     distinct (awalk_verts (head G e) q) \\<and>\n     0 < length r \\<and>\n     (\\<exists>w.\n         awalk (head G e) q w \\<and> awalk w r w \\<and> awalk w s u)\n\ngoal (1 subgoal):\n 1. (\\<And>q r s.\n        \\<lbrakk>es = q @ r @ s; \\<exists>w. awalk w r w;\n         closed_w r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: closed_w_def)"], ["proof (state)\nthis:\n  es = q @ r @ s\n  \\<exists>w. awalk w r w\n  closed_w r\n\ngoal (1 subgoal):\n 1. \\<not> distinct (tl (awalk_verts u p)) \\<Longrightarrow> Ex cycle", "then"], ["proof (chain)\npicking this:\n  es = q @ r @ s\n  \\<exists>w. awalk w r w\n  closed_w r", "have \"length r < length p\""], ["proof (prove)\nusing this:\n  es = q @ r @ s\n  \\<exists>w. awalk w r w\n  closed_w r\n\ngoal (1 subgoal):\n 1. length r < length p", "using \\<open>p = _\\<close>"], ["proof (prove)\nusing this:\n  es = q @ r @ s\n  \\<exists>w. awalk w r w\n  closed_w r\n  p = e # es\n\ngoal (1 subgoal):\n 1. length r < length p", "by auto"], ["proof (state)\nthis:\n  length r < length p\n\ngoal (1 subgoal):\n 1. \\<not> distinct (tl (awalk_verts u p)) \\<Longrightarrow> Ex cycle", "then"], ["proof (chain)\npicking this:\n  length r < length p", "show ?thesis"], ["proof (prove)\nusing this:\n  length r < length p\n\ngoal (1 subgoal):\n 1. Ex cycle", "using \\<open>closed_w r\\<close>"], ["proof (prove)\nusing this:\n  length r < length p\n  closed_w r\n\ngoal (1 subgoal):\n 1. Ex cycle", "by (rule less)"], ["proof (state)\nthis:\n  Ex cycle\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Ex cycle\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Reachability\\<close>"], ["", "lemma reachable1_awalk:\n  \"u \\<rightarrow>\\<^sup>+ v \\<longleftrightarrow> (\\<exists>p. awalk u p v \\<and> p \\<noteq> [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u \\<rightarrow>\\<^sup>+ v) =\n    (\\<exists>p. awalk u p v \\<and> p \\<noteq> [])", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. u \\<rightarrow>\\<^sup>+ v \\<Longrightarrow>\n    \\<exists>p. awalk u p v \\<and> p \\<noteq> []\n 2. \\<exists>p. awalk u p v \\<and> p \\<noteq> [] \\<Longrightarrow>\n    u \\<rightarrow>\\<^sup>+ v", "assume \"u \\<rightarrow>\\<^sup>+ v\""], ["proof (state)\nthis:\n  u \\<rightarrow>\\<^sup>+ v\n\ngoal (2 subgoals):\n 1. u \\<rightarrow>\\<^sup>+ v \\<Longrightarrow>\n    \\<exists>p. awalk u p v \\<and> p \\<noteq> []\n 2. \\<exists>p. awalk u p v \\<and> p \\<noteq> [] \\<Longrightarrow>\n    u \\<rightarrow>\\<^sup>+ v", "then"], ["proof (chain)\npicking this:\n  u \\<rightarrow>\\<^sup>+ v", "show \"\\<exists>p. awalk u p v \\<and> p \\<noteq> []\""], ["proof (prove)\nusing this:\n  u \\<rightarrow>\\<^sup>+ v\n\ngoal (1 subgoal):\n 1. \\<exists>p. awalk u p v \\<and> p \\<noteq> []", "proof (induct rule: converse_trancl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<rightarrow> v \\<Longrightarrow>\n       \\<exists>p. awalk y p v \\<and> p \\<noteq> []\n 2. \\<And>y z.\n       \\<lbrakk>y \\<rightarrow> z; z \\<rightarrow>\\<^sup>+ v;\n        \\<exists>p. awalk z p v \\<and> p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. awalk y p v \\<and> p \\<noteq> []", "case (base y)"], ["proof (state)\nthis:\n  y \\<rightarrow> v\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<rightarrow> v \\<Longrightarrow>\n       \\<exists>p. awalk y p v \\<and> p \\<noteq> []\n 2. \\<And>y z.\n       \\<lbrakk>y \\<rightarrow> z; z \\<rightarrow>\\<^sup>+ v;\n        \\<exists>p. awalk z p v \\<and> p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. awalk y p v \\<and> p \\<noteq> []", "then"], ["proof (chain)\npicking this:\n  y \\<rightarrow> v", "obtain e where \"e \\<in> arcs G\" \"tail G e = y\" \"head G e = v\""], ["proof (prove)\nusing this:\n  y \\<rightarrow> v\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>e \\<in> arcs G; tail G e = y; head G e = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  e \\<in> arcs G\n  tail G e = y\n  head G e = v\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<rightarrow> v \\<Longrightarrow>\n       \\<exists>p. awalk y p v \\<and> p \\<noteq> []\n 2. \\<And>y z.\n       \\<lbrakk>y \\<rightarrow> z; z \\<rightarrow>\\<^sup>+ v;\n        \\<exists>p. awalk z p v \\<and> p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. awalk y p v \\<and> p \\<noteq> []", "with arc_implies_awalk"], ["proof (chain)\npicking this:\n  ?e \\<in> arcs G \\<Longrightarrow> awalk (tail G ?e) [?e] (head G ?e)\n  e \\<in> arcs G\n  tail G e = y\n  head G e = v", "show ?case"], ["proof (prove)\nusing this:\n  ?e \\<in> arcs G \\<Longrightarrow> awalk (tail G ?e) [?e] (head G ?e)\n  e \\<in> arcs G\n  tail G e = y\n  head G e = v\n\ngoal (1 subgoal):\n 1. \\<exists>p. awalk y p v \\<and> p \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  \\<exists>p. awalk y p v \\<and> p \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>y \\<rightarrow> z; z \\<rightarrow>\\<^sup>+ v;\n        \\<exists>p. awalk z p v \\<and> p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. awalk y p v \\<and> p \\<noteq> []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>y \\<rightarrow> z; z \\<rightarrow>\\<^sup>+ v;\n        \\<exists>p. awalk z p v \\<and> p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. awalk y p v \\<and> p \\<noteq> []", "case (step x y)"], ["proof (state)\nthis:\n  x \\<rightarrow> y\n  y \\<rightarrow>\\<^sup>+ v\n  \\<exists>p. awalk y p v \\<and> p \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>y \\<rightarrow> z; z \\<rightarrow>\\<^sup>+ v;\n        \\<exists>p. awalk z p v \\<and> p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. awalk y p v \\<and> p \\<noteq> []", "then"], ["proof (chain)\npicking this:\n  x \\<rightarrow> y\n  y \\<rightarrow>\\<^sup>+ v\n  \\<exists>p. awalk y p v \\<and> p \\<noteq> []", "obtain p where \"awalk y p v\" \"p \\<noteq> []\""], ["proof (prove)\nusing this:\n  x \\<rightarrow> y\n  y \\<rightarrow>\\<^sup>+ v\n  \\<exists>p. awalk y p v \\<and> p \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>awalk y p v; p \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  awalk y p v\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>y \\<rightarrow> z; z \\<rightarrow>\\<^sup>+ v;\n        \\<exists>p. awalk z p v \\<and> p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. awalk y p v \\<and> p \\<noteq> []", "moreover"], ["proof (state)\nthis:\n  awalk y p v\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>y \\<rightarrow> z; z \\<rightarrow>\\<^sup>+ v;\n        \\<exists>p. awalk z p v \\<and> p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. awalk y p v \\<and> p \\<noteq> []", "from \\<open>x \\<rightarrow> y\\<close>"], ["proof (chain)\npicking this:\n  x \\<rightarrow> y", "obtain e where \"tail G e = x\" \"head G e = y\" \"e \\<in> arcs G\""], ["proof (prove)\nusing this:\n  x \\<rightarrow> y\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>tail G e = x; head G e = y; e \\<in> arcs G\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  tail G e = x\n  head G e = y\n  e \\<in> arcs G\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>y \\<rightarrow> z; z \\<rightarrow>\\<^sup>+ v;\n        \\<exists>p. awalk z p v \\<and> p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. awalk y p v \\<and> p \\<noteq> []", "ultimately"], ["proof (chain)\npicking this:\n  awalk y p v\n  p \\<noteq> []\n  tail G e = x\n  head G e = y\n  e \\<in> arcs G", "have \"awalk x (e # p) v\""], ["proof (prove)\nusing this:\n  awalk y p v\n  p \\<noteq> []\n  tail G e = x\n  head G e = y\n  e \\<in> arcs G\n\ngoal (1 subgoal):\n 1. awalk x (e # p) v", "by (auto simp: awalk_Cons_iff)"], ["proof (state)\nthis:\n  awalk x (e # p) v\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>y \\<rightarrow> z; z \\<rightarrow>\\<^sup>+ v;\n        \\<exists>p. awalk z p v \\<and> p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. awalk y p v \\<and> p \\<noteq> []", "then"], ["proof (chain)\npicking this:\n  awalk x (e # p) v", "show ?case"], ["proof (prove)\nusing this:\n  awalk x (e # p) v\n\ngoal (1 subgoal):\n 1. \\<exists>p. awalk x p v \\<and> p \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  \\<exists>p. awalk x p v \\<and> p \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p. awalk u p v \\<and> p \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>p. awalk u p v \\<and> p \\<noteq> [] \\<Longrightarrow>\n    u \\<rightarrow>\\<^sup>+ v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p. awalk u p v \\<and> p \\<noteq> [] \\<Longrightarrow>\n    u \\<rightarrow>\\<^sup>+ v", "assume \"\\<exists>p. awalk u p v \\<and> p \\<noteq> []\""], ["proof (state)\nthis:\n  \\<exists>p. awalk u p v \\<and> p \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>p. awalk u p v \\<and> p \\<noteq> [] \\<Longrightarrow>\n    u \\<rightarrow>\\<^sup>+ v", "then"], ["proof (chain)\npicking this:\n  \\<exists>p. awalk u p v \\<and> p \\<noteq> []", "obtain p where \"awalk u p v\" \"p \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<exists>p. awalk u p v \\<and> p \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>awalk u p v; p \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  awalk u p v\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>p. awalk u p v \\<and> p \\<noteq> [] \\<Longrightarrow>\n    u \\<rightarrow>\\<^sup>+ v", "thus \"u \\<rightarrow>\\<^sup>+ v\""], ["proof (prove)\nusing this:\n  awalk u p v\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>+ v", "proof (induct p arbitrary: u)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>awalk u [] v; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> u \\<rightarrow>\\<^sup>+ v\n 2. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>awalk u p v; p \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> u \\<rightarrow>\\<^sup>+ v;\n        awalk u (a # p) v; a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> u \\<rightarrow>\\<^sup>+ v", "case (Cons a as)"], ["proof (state)\nthis:\n  \\<lbrakk>awalk ?u as v; as \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?u \\<rightarrow>\\<^sup>+ v\n  awalk u (a # as) v\n  a # as \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>awalk u [] v; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> u \\<rightarrow>\\<^sup>+ v\n 2. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   \\<lbrakk>awalk u p v; p \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> u \\<rightarrow>\\<^sup>+ v;\n        awalk u (a # p) v; a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> u \\<rightarrow>\\<^sup>+ v", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>awalk ?u as v; as \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?u \\<rightarrow>\\<^sup>+ v\n  awalk u (a # as) v\n  a # as \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>awalk ?u as v; as \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?u \\<rightarrow>\\<^sup>+ v\n  awalk u (a # as) v\n  a # as \\<noteq> []\n\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>+ v", "by (cases \"as = []\") (auto simp: awalk_simps trancl_into_trancl2 dest: in_arcs_imp_in_arcs_ends)"], ["proof (state)\nthis:\n  u \\<rightarrow>\\<^sup>+ v\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>awalk u [] v; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> u \\<rightarrow>\\<^sup>+ v", "qed simp"], ["proof (state)\nthis:\n  u \\<rightarrow>\\<^sup>+ v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reachable_awalk:\n  \"u \\<rightarrow>\\<^sup>* v \\<longleftrightarrow> (\\<exists>p. awalk u p v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u \\<rightarrow>\\<^sup>* v) = (\\<exists>p. awalk u p v)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (u \\<rightarrow>\\<^sup>* v) = (\\<exists>p. awalk u p v)\n 2. \\<not> ?P \\<Longrightarrow>\n    (u \\<rightarrow>\\<^sup>* v) = (\\<exists>p. awalk u p v)", "assume \"u = v\""], ["proof (state)\nthis:\n  u = v\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (u \\<rightarrow>\\<^sup>* v) = (\\<exists>p. awalk u p v)\n 2. \\<not> ?P \\<Longrightarrow>\n    (u \\<rightarrow>\\<^sup>* v) = (\\<exists>p. awalk u p v)", "have \"u \\<rightarrow>\\<^sup>*u \\<longleftrightarrow> awalk u [] u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u \\<rightarrow>\\<^sup>* u) = awalk u [] u", "by (auto simp: awalk_Nil_iff reachable_in_verts)"], ["proof (state)\nthis:\n  (u \\<rightarrow>\\<^sup>* u) = awalk u [] u\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (u \\<rightarrow>\\<^sup>* v) = (\\<exists>p. awalk u p v)\n 2. \\<not> ?P \\<Longrightarrow>\n    (u \\<rightarrow>\\<^sup>* v) = (\\<exists>p. awalk u p v)", "also"], ["proof (state)\nthis:\n  (u \\<rightarrow>\\<^sup>* u) = awalk u [] u\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (u \\<rightarrow>\\<^sup>* v) = (\\<exists>p. awalk u p v)\n 2. \\<not> ?P \\<Longrightarrow>\n    (u \\<rightarrow>\\<^sup>* v) = (\\<exists>p. awalk u p v)", "have \"\\<dots> \\<longleftrightarrow> (\\<exists>p. awalk u p u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk u [] u = (\\<exists>p. awalk u p u)", "by (metis awalk_Nil_iff awalk_hd_in_verts)"], ["proof (state)\nthis:\n  awalk u [] u = (\\<exists>p. awalk u p u)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (u \\<rightarrow>\\<^sup>* v) = (\\<exists>p. awalk u p v)\n 2. \\<not> ?P \\<Longrightarrow>\n    (u \\<rightarrow>\\<^sup>* v) = (\\<exists>p. awalk u p v)", "finally"], ["proof (chain)\npicking this:\n  (u \\<rightarrow>\\<^sup>* u) = (\\<exists>p. awalk u p u)", "show ?thesis"], ["proof (prove)\nusing this:\n  (u \\<rightarrow>\\<^sup>* u) = (\\<exists>p. awalk u p u)\n\ngoal (1 subgoal):\n 1. (u \\<rightarrow>\\<^sup>* v) = (\\<exists>p. awalk u p v)", "using \\<open>u = v\\<close>"], ["proof (prove)\nusing this:\n  (u \\<rightarrow>\\<^sup>* u) = (\\<exists>p. awalk u p u)\n  u = v\n\ngoal (1 subgoal):\n 1. (u \\<rightarrow>\\<^sup>* v) = (\\<exists>p. awalk u p v)", "by simp"], ["proof (state)\nthis:\n  (u \\<rightarrow>\\<^sup>* v) = (\\<exists>p. awalk u p v)\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow>\n    (u \\<rightarrow>\\<^sup>* v) = (\\<exists>p. awalk u p v)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow>\n    (u \\<rightarrow>\\<^sup>* v) = (\\<exists>p. awalk u p v)", "assume \"u \\<noteq> v\""], ["proof (state)\nthis:\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow>\n    (u \\<rightarrow>\\<^sup>* v) = (\\<exists>p. awalk u p v)", "then"], ["proof (chain)\npicking this:\n  u \\<noteq> v", "have \"u \\<rightarrow>\\<^sup>* v \\<longleftrightarrow> u \\<rightarrow>\\<^sup>+ v\""], ["proof (prove)\nusing this:\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. (u \\<rightarrow>\\<^sup>* v) = (u \\<rightarrow>\\<^sup>+ v)", "by auto"], ["proof (state)\nthis:\n  (u \\<rightarrow>\\<^sup>* v) = (u \\<rightarrow>\\<^sup>+ v)\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow>\n    (u \\<rightarrow>\\<^sup>* v) = (\\<exists>p. awalk u p v)", "also"], ["proof (state)\nthis:\n  (u \\<rightarrow>\\<^sup>* v) = (u \\<rightarrow>\\<^sup>+ v)\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow>\n    (u \\<rightarrow>\\<^sup>* v) = (\\<exists>p. awalk u p v)", "have \"\\<dots> \\<longleftrightarrow> (\\<exists>p. awalk u p v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u \\<rightarrow>\\<^sup>+ v) = (\\<exists>p. awalk u p v)", "using \\<open>u \\<noteq> v\\<close>"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. (u \\<rightarrow>\\<^sup>+ v) = (\\<exists>p. awalk u p v)", "unfolding reachable1_awalk"], ["proof (prove)\nusing this:\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. (\\<exists>p. awalk u p v \\<and> p \\<noteq> []) =\n    (\\<exists>p. awalk u p v)", "by force"], ["proof (state)\nthis:\n  (u \\<rightarrow>\\<^sup>+ v) = (\\<exists>p. awalk u p v)\n\ngoal (1 subgoal):\n 1. u \\<noteq> v \\<Longrightarrow>\n    (u \\<rightarrow>\\<^sup>* v) = (\\<exists>p. awalk u p v)", "finally"], ["proof (chain)\npicking this:\n  (u \\<rightarrow>\\<^sup>* v) = (\\<exists>p. awalk u p v)", "show ?thesis"], ["proof (prove)\nusing this:\n  (u \\<rightarrow>\\<^sup>* v) = (\\<exists>p. awalk u p v)\n\ngoal (1 subgoal):\n 1. (u \\<rightarrow>\\<^sup>* v) = (\\<exists>p. awalk u p v)", "."], ["proof (state)\nthis:\n  (u \\<rightarrow>\\<^sup>* v) = (\\<exists>p. awalk u p v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reachable_awalkI[intro?]:\n  assumes \"awalk u p v\"\n  shows \"u \\<rightarrow>\\<^sup>* v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>* v", "unfolding reachable_awalk"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. awalk u p v", "using assms"], ["proof (prove)\nusing this:\n  awalk u p v\n\ngoal (1 subgoal):\n 1. \\<exists>p. awalk u p v", "by auto"], ["", "lemma reachable1_awalkI:\n  \"awalk v p w \\<Longrightarrow> p \\<noteq> [] \\<Longrightarrow> v \\<rightarrow>\\<^sup>+ w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>awalk v p w; p \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> v \\<rightarrow>\\<^sup>+ w", "by (auto simp add: reachable1_awalk)"], ["", "lemma reachable_arc_trans:\n  assumes \"u \\<rightarrow>\\<^sup>* v\" \"arc e (v,w)\"\n  shows \"u \\<rightarrow>\\<^sup>* w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>* w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>* w", "from \\<open>u \\<rightarrow>\\<^sup>* v\\<close>"], ["proof (chain)\npicking this:\n  u \\<rightarrow>\\<^sup>* v", "obtain p where \"awalk u p v\""], ["proof (prove)\nusing this:\n  u \\<rightarrow>\\<^sup>* v\n\ngoal (1 subgoal):\n 1. (\\<And>p. awalk u p v \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto simp: reachable_awalk)"], ["proof (state)\nthis:\n  awalk u p v\n\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>* w", "moreover"], ["proof (state)\nthis:\n  awalk u p v\n\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>* w", "have \"awalk v [e] w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk v [e] w", "using \\<open>arc e (v,w)\\<close>"], ["proof (prove)\nusing this:\n  arc e (v, w)\n\ngoal (1 subgoal):\n 1. awalk v [e] w", "by (auto simp: arc_def awalk_def)"], ["proof (state)\nthis:\n  awalk v [e] w\n\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>* w", "ultimately"], ["proof (chain)\npicking this:\n  awalk u p v\n  awalk v [e] w", "have \"awalk u (p @ [e]) w\""], ["proof (prove)\nusing this:\n  awalk u p v\n  awalk v [e] w\n\ngoal (1 subgoal):\n 1. awalk u (p @ [e]) w", "by (rule awalk_appendI)"], ["proof (state)\nthis:\n  awalk u (p @ [e]) w\n\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>* w", "then"], ["proof (chain)\npicking this:\n  awalk u (p @ [e]) w", "show ?thesis"], ["proof (prove)\nusing this:\n  awalk u (p @ [e]) w\n\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>* w", ".."], ["proof (state)\nthis:\n  u \\<rightarrow>\\<^sup>* w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma awalk_verts_reachable_from:\n  assumes \"awalk u p v\" \"w \\<in> set (awalk_verts u p)\" shows \"u \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>* w", "proof  -"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>* w", "obtain s where \"awalk u s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s. awalk u s w \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using awalk_decomp[OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>q r. p = q @ r \\<and> awalk u q w \\<and> awalk w r v\n\ngoal (1 subgoal):\n 1. (\\<And>s. awalk u s w \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  awalk u s w\n\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>* w", "then"], ["proof (chain)\npicking this:\n  awalk u s w", "show ?thesis"], ["proof (prove)\nusing this:\n  awalk u s w\n\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>* w", "by (metis reachable_awalk)"], ["proof (state)\nthis:\n  u \\<rightarrow>\\<^sup>* w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma awalk_verts_reachable_to:\n  assumes \"awalk u p v\" \"w \\<in> set (awalk_verts u p)\" shows \"w \\<rightarrow>\\<^sup>*\\<^bsub>G\\<^esub> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<rightarrow>\\<^sup>* v", "proof  -"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<rightarrow>\\<^sup>* v", "obtain s where \"awalk w s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s. awalk w s v \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using awalk_decomp[OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>q r. p = q @ r \\<and> awalk u q w \\<and> awalk w r v\n\ngoal (1 subgoal):\n 1. (\\<And>s. awalk w s v \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  awalk w s v\n\ngoal (1 subgoal):\n 1. w \\<rightarrow>\\<^sup>* v", "then"], ["proof (chain)\npicking this:\n  awalk w s v", "show ?thesis"], ["proof (prove)\nusing this:\n  awalk w s v\n\ngoal (1 subgoal):\n 1. w \\<rightarrow>\\<^sup>* v", "by (metis reachable_awalk)"], ["proof (state)\nthis:\n  w \\<rightarrow>\\<^sup>* v\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Paths\\<close>"], ["", "lemma (in fin_digraph) length_apath_less:\n  assumes \"apath u p v\"\n  shows \"length p < card (verts G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length p < card (verts G)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length p < card (verts G)", "have \"length p < length (awalk_verts u p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length p < length (awalk_verts u p)", "unfolding awalk_verts_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. length p\n    < length (if p = [] then [u] else map (tail G) p @ [head G (last p)])", "by (auto simp: awalk_verts_conv)"], ["proof (state)\nthis:\n  length p < length (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. length p < card (verts G)", "also"], ["proof (state)\nthis:\n  length p < length (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. length p < card (verts G)", "have \"length (awalk_verts u p) = card (set (awalk_verts u p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (awalk_verts u p) = card (set (awalk_verts u p))", "using \\<open>apath u p v\\<close>"], ["proof (prove)\nusing this:\n  apath u p v\n\ngoal (1 subgoal):\n 1. length (awalk_verts u p) = card (set (awalk_verts u p))", "by (auto simp: apath_def distinct_card)"], ["proof (state)\nthis:\n  length (awalk_verts u p) = card (set (awalk_verts u p))\n\ngoal (1 subgoal):\n 1. length p < card (verts G)", "also"], ["proof (state)\nthis:\n  length (awalk_verts u p) = card (set (awalk_verts u p))\n\ngoal (1 subgoal):\n 1. length p < card (verts G)", "have \"\\<dots> \\<le> card (verts G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (set (awalk_verts u p)) \\<le> card (verts G)", "using \\<open>apath u p v\\<close>"], ["proof (prove)\nusing this:\n  apath u p v\n\ngoal (1 subgoal):\n 1. card (set (awalk_verts u p)) \\<le> card (verts G)", "unfolding apath_def awalk_conv"], ["proof (prove)\nusing this:\n  (set (awalk_verts u p) \\<subseteq> verts G \\<and>\n   set p \\<subseteq> arcs G \\<and>\n   awhd u p = u \\<and> awlast u p = v \\<and> cas u p v) \\<and>\n  distinct (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. card (set (awalk_verts u p)) \\<le> card (verts G)", "by (auto intro: card_mono)"], ["proof (state)\nthis:\n  card (set (awalk_verts u p)) \\<le> card (verts G)\n\ngoal (1 subgoal):\n 1. length p < card (verts G)", "finally"], ["proof (chain)\npicking this:\n  length p < card (verts G)", "show ?thesis"], ["proof (prove)\nusing this:\n  length p < card (verts G)\n\ngoal (1 subgoal):\n 1. length p < card (verts G)", "."], ["proof (state)\nthis:\n  length p < card (verts G)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in fin_digraph) length_apath:\n  assumes \"apath u p v\"\n  shows \"length p \\<le> card (verts G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length p \\<le> card (verts G)", "using length_apath_less[OF assms]"], ["proof (prove)\nusing this:\n  length p < card (verts G)\n\ngoal (1 subgoal):\n 1. length p \\<le> card (verts G)", "by auto"], ["", "lemma (in fin_digraph) apaths_finite_triple:\n  shows \"finite {(u,p,v). apath u p v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {(u, p, v). apath u p v}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {(u, p, v). apath u p v}", "have \"\\<And>u p v. awalk u p v \\<Longrightarrow> distinct (awalk_verts u p) \\<Longrightarrow>length p \\<le> card (verts G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u p v.\n       \\<lbrakk>awalk u p v; distinct (awalk_verts u p)\\<rbrakk>\n       \\<Longrightarrow> length p \\<le> card (verts G)", "by (rule length_apath) (auto simp: apath_def)"], ["proof (state)\nthis:\n  \\<lbrakk>awalk ?u ?p ?v; distinct (awalk_verts ?u ?p)\\<rbrakk>\n  \\<Longrightarrow> length ?p \\<le> card (verts G)\n\ngoal (1 subgoal):\n 1. finite {(u, p, v). apath u p v}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>awalk ?u ?p ?v; distinct (awalk_verts ?u ?p)\\<rbrakk>\n  \\<Longrightarrow> length ?p \\<le> card (verts G)", "have \"{(u,p,v). apath u p v} \\<subseteq> verts G \\<times> {es. set es \\<subseteq> arcs G \\<and> length es \\<le> card (verts G)} \\<times> verts G\""], ["proof (prove)\nusing this:\n  \\<lbrakk>awalk ?u ?p ?v; distinct (awalk_verts ?u ?p)\\<rbrakk>\n  \\<Longrightarrow> length ?p \\<le> card (verts G)\n\ngoal (1 subgoal):\n 1. {(u, p, v). apath u p v}\n    \\<subseteq> verts G \\<times>\n                {es.\n                 set es \\<subseteq> arcs G \\<and>\n                 length es \\<le> card (verts G)} \\<times>\n                verts G", "by (auto simp: apath_def)"], ["proof (state)\nthis:\n  {(u, p, v). apath u p v}\n  \\<subseteq> verts G \\<times>\n              {es.\n               set es \\<subseteq> arcs G \\<and>\n               length es \\<le> card (verts G)} \\<times>\n              verts G\n\ngoal (1 subgoal):\n 1. finite {(u, p, v). apath u p v}", "moreover"], ["proof (state)\nthis:\n  {(u, p, v). apath u p v}\n  \\<subseteq> verts G \\<times>\n              {es.\n               set es \\<subseteq> arcs G \\<and>\n               length es \\<le> card (verts G)} \\<times>\n              verts G\n\ngoal (1 subgoal):\n 1. finite {(u, p, v). apath u p v}", "have \"finite ...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (verts G \\<times>\n      {es.\n       set es \\<subseteq> arcs G \\<and>\n       length es \\<le> card (verts G)} \\<times>\n      verts G)", "using finite_verts finite_arcs"], ["proof (prove)\nusing this:\n  finite (verts G)\n  finite (arcs G)\n\ngoal (1 subgoal):\n 1. finite\n     (verts G \\<times>\n      {es.\n       set es \\<subseteq> arcs G \\<and>\n       length es \\<le> card (verts G)} \\<times>\n      verts G)", "by (intro finite_cartesian_product finite_lists_length_le)"], ["proof (state)\nthis:\n  finite\n   (verts G \\<times>\n    {es.\n     set es \\<subseteq> arcs G \\<and>\n     length es \\<le> card (verts G)} \\<times>\n    verts G)\n\ngoal (1 subgoal):\n 1. finite {(u, p, v). apath u p v}", "ultimately"], ["proof (chain)\npicking this:\n  {(u, p, v). apath u p v}\n  \\<subseteq> verts G \\<times>\n              {es.\n               set es \\<subseteq> arcs G \\<and>\n               length es \\<le> card (verts G)} \\<times>\n              verts G\n  finite\n   (verts G \\<times>\n    {es.\n     set es \\<subseteq> arcs G \\<and>\n     length es \\<le> card (verts G)} \\<times>\n    verts G)", "show ?thesis"], ["proof (prove)\nusing this:\n  {(u, p, v). apath u p v}\n  \\<subseteq> verts G \\<times>\n              {es.\n               set es \\<subseteq> arcs G \\<and>\n               length es \\<le> card (verts G)} \\<times>\n              verts G\n  finite\n   (verts G \\<times>\n    {es.\n     set es \\<subseteq> arcs G \\<and>\n     length es \\<le> card (verts G)} \\<times>\n    verts G)\n\ngoal (1 subgoal):\n 1. finite {(u, p, v). apath u p v}", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite {(u, p, v). apath u p v}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in fin_digraph) apaths_finite:\n  shows \"finite {p. apath u p v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {p. apath u p v}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {p. apath u p v}", "have \"{p. apath u p v} \\<subseteq> (fst o snd) ` {(u,p,v). apath u p v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. apath u p v}\n    \\<subseteq> (fst \\<circ> snd) ` {(u, p, v). apath u p v}", "by force"], ["proof (state)\nthis:\n  {p. apath u p v} \\<subseteq> (fst \\<circ> snd) ` {(u, p, v). apath u p v}\n\ngoal (1 subgoal):\n 1. finite {p. apath u p v}", "with apaths_finite_triple"], ["proof (chain)\npicking this:\n  finite {(u, p, v). apath u p v}\n  {p. apath u p v} \\<subseteq> (fst \\<circ> snd) ` {(u, p, v). apath u p v}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {(u, p, v). apath u p v}\n  {p. apath u p v} \\<subseteq> (fst \\<circ> snd) ` {(u, p, v). apath u p v}\n\ngoal (1 subgoal):\n 1. finite {p. apath u p v}", "by (rule finite_surj)"], ["proof (state)\nthis:\n  finite {p. apath u p v}\n\ngoal:\nNo subgoals!", "qed"], ["", "fun is_awalk_cyc_decomp :: \"'b awalk =>\n  ('b awalk \\<times> 'b awalk \\<times> 'b awalk) \\<Rightarrow> bool\" where\n  \"is_awalk_cyc_decomp p (q,r,s) \\<longleftrightarrow> p = q @ r @ s\n    \\<and> (\\<exists>u v w. awalk u q v \\<and> awalk v r v \\<and> awalk v s w)\n    \\<and> 0 <length r\n    \\<and> (\\<exists>u. distinct (awalk_verts u q))\""], ["", "definition awalk_cyc_decomp :: \"'b awalk\n    \\<Rightarrow> 'b awalk \\<times> 'b awalk \\<times> 'b awalk\" where\n  \"awalk_cyc_decomp p = (SOME qrs. is_awalk_cyc_decomp p qrs)\""], ["", "function awalk_to_apath :: \"'b awalk \\<Rightarrow> 'b awalk\" where\n  \"awalk_to_apath p = (if \\<not>(\\<exists>u. distinct (awalk_verts u p)) \\<and> (\\<exists>u v. awalk u p v)\n     then (let (q,r,s) = awalk_cyc_decomp p in awalk_to_apath (q @ s))\n     else p)\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>p. x = p \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>p pa.\n       p = pa \\<Longrightarrow>\n       (if (\\<nexists>u. distinct (awalk_verts u p)) \\<and>\n           (\\<exists>u. Ex (awalk u p))\n        then let (q, r, s) = awalk_cyc_decomp p\n             in awalk_to_apath_sumC (q @ s)\n        else p) =\n       (if (\\<nexists>u. distinct (awalk_verts u pa)) \\<and>\n           (\\<exists>u. Ex (awalk u pa))\n        then let (q, r, s) = awalk_cyc_decomp pa\n             in awalk_to_apath_sumC (q @ s)\n        else pa)", "by auto"], ["", "lemma awalk_cyc_decomp_has_prop:\n  assumes \"awalk u p v\" and \"\\<not>distinct (awalk_verts u p)\"\n  shows \"is_awalk_cyc_decomp p (awalk_cyc_decomp p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_awalk_cyc_decomp p (awalk_cyc_decomp p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_awalk_cyc_decomp p (awalk_cyc_decomp p)", "obtain q r s where *: \"p = q @ r @ s \\<and> distinct (awalk_verts u q)\n      \\<and> 0 < length r\n      \\<and> (\\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q r s.\n        p = q @ r @ s \\<and>\n        distinct (awalk_verts u q) \\<and>\n        0 < length r \\<and>\n        (\\<exists>w.\n            awalk u q w \\<and>\n            awalk w r w \\<and> awalk w s v) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (atomize_elim) (rule awalk_not_distinct_decomp[OF assms])"], ["proof (state)\nthis:\n  p = q @ r @ s \\<and>\n  distinct (awalk_verts u q) \\<and>\n  0 < length r \\<and>\n  (\\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v)\n\ngoal (1 subgoal):\n 1. is_awalk_cyc_decomp p (awalk_cyc_decomp p)", "then"], ["proof (chain)\npicking this:\n  p = q @ r @ s \\<and>\n  distinct (awalk_verts u q) \\<and>\n  0 < length r \\<and>\n  (\\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v)", "have \"\\<exists>x. is_awalk_cyc_decomp p x\""], ["proof (prove)\nusing this:\n  p = q @ r @ s \\<and>\n  distinct (awalk_verts u q) \\<and>\n  0 < length r \\<and>\n  (\\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v)\n\ngoal (1 subgoal):\n 1. \\<exists>x. is_awalk_cyc_decomp p x", "by (intro exI[where x=\"(q,r,s)\"]) auto"], ["proof (state)\nthis:\n  \\<exists>x. is_awalk_cyc_decomp p x\n\ngoal (1 subgoal):\n 1. is_awalk_cyc_decomp p (awalk_cyc_decomp p)", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. is_awalk_cyc_decomp p x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>x. is_awalk_cyc_decomp p x\n\ngoal (1 subgoal):\n 1. is_awalk_cyc_decomp p (awalk_cyc_decomp p)", "unfolding awalk_cyc_decomp_def"], ["proof (prove)\nusing this:\n  \\<exists>x. is_awalk_cyc_decomp p x\n\ngoal (1 subgoal):\n 1. is_awalk_cyc_decomp p (Eps (is_awalk_cyc_decomp p))", ".."], ["proof (state)\nthis:\n  is_awalk_cyc_decomp p (awalk_cyc_decomp p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma awalk_cyc_decompE:\n  assumes dec: \"awalk_cyc_decomp p = (q,r,s)\"\n  assumes p_props: \"awalk u p v\" \"\\<not>distinct (awalk_verts u p)\"\n  obtains \"p = q @ r @ s\" \"distinct (awalk_verts u q)\" \"\\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v\" \"closed_w r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>p = q @ r @ s; distinct (awalk_verts u q);\n      \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v;\n      closed_w r\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. (\\<lbrakk>p = q @ r @ s; distinct (awalk_verts u q);\n      \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v;\n      closed_w r\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    p = q @ r @ s\n 2. (\\<lbrakk>p = q @ r @ s; distinct (awalk_verts u q);\n      \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v;\n      closed_w r\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    distinct (awalk_verts u q)\n 3. (\\<lbrakk>p = q @ r @ s; distinct (awalk_verts u q);\n      \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v;\n      closed_w r\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v\n 4. (\\<lbrakk>p = q @ r @ s; distinct (awalk_verts u q);\n      \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v;\n      closed_w r\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    closed_w r", "show \"p = q @ r @ s\" \"distinct (awalk_verts u q)\" \"closed_w r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q @ r @ s &&& distinct (awalk_verts u q) &&& closed_w r", "using awalk_cyc_decomp_has_prop[OF p_props] and dec"], ["proof (prove)\nusing this:\n  is_awalk_cyc_decomp p (awalk_cyc_decomp p)\n  awalk_cyc_decomp p = (q, r, s)\n\ngoal (1 subgoal):\n 1. p = q @ r @ s &&& distinct (awalk_verts u q) &&& closed_w r", "by (auto simp: closed_w_def awalk_verts_conv)"], ["proof (state)\nthis:\n  p = q @ r @ s\n  distinct (awalk_verts u q)\n  closed_w r\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>p = q @ r @ s; distinct (awalk_verts u q);\n      \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v;\n      closed_w r\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v", "then"], ["proof (chain)\npicking this:\n  p = q @ r @ s\n  distinct (awalk_verts u q)\n  closed_w r", "have \"p \\<noteq> []\""], ["proof (prove)\nusing this:\n  p = q @ r @ s\n  distinct (awalk_verts u q)\n  closed_w r\n\ngoal (1 subgoal):\n 1. p \\<noteq> []", "by (auto simp: closed_w_def)"], ["proof (state)\nthis:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>p = q @ r @ s; distinct (awalk_verts u q);\n      \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v;\n      closed_w r\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v", "(* TODO: Can we find some general rules to prove the last property?*)"], ["proof (state)\nthis:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>p = q @ r @ s; distinct (awalk_verts u q);\n      \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v;\n      closed_w r\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v", "obtain u' w' v' where obt_awalk: \"awalk u' q w'\" \"awalk w' r w'\" \"awalk w' s v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u' w' v'.\n        \\<lbrakk>awalk u' q w'; awalk w' r w'; awalk w' s v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using awalk_cyc_decomp_has_prop[OF p_props] and dec"], ["proof (prove)\nusing this:\n  is_awalk_cyc_decomp p (awalk_cyc_decomp p)\n  awalk_cyc_decomp p = (q, r, s)\n\ngoal (1 subgoal):\n 1. (\\<And>u' w' v'.\n        \\<lbrakk>awalk u' q w'; awalk w' r w'; awalk w' s v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  awalk u' q w'\n  awalk w' r w'\n  awalk w' s v'\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>p = q @ r @ s; distinct (awalk_verts u q);\n      \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v;\n      closed_w r\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v", "then"], ["proof (chain)\npicking this:\n  awalk u' q w'\n  awalk w' r w'\n  awalk w' s v'", "have \"awalk u' p v'\""], ["proof (prove)\nusing this:\n  awalk u' q w'\n  awalk w' r w'\n  awalk w' s v'\n\ngoal (1 subgoal):\n 1. awalk u' p v'", "using \\<open>p = q @ r @ s\\<close>"], ["proof (prove)\nusing this:\n  awalk u' q w'\n  awalk w' r w'\n  awalk w' s v'\n  p = q @ r @ s\n\ngoal (1 subgoal):\n 1. awalk u' p v'", "by simp"], ["proof (state)\nthis:\n  awalk u' p v'\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>p = q @ r @ s; distinct (awalk_verts u q);\n      \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v;\n      closed_w r\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v", "then"], ["proof (chain)\npicking this:\n  awalk u' p v'", "have \"u = u'\" and \"v = v'\""], ["proof (prove)\nusing this:\n  awalk u' p v'\n\ngoal (1 subgoal):\n 1. u = u' &&& v = v'", "using \\<open>p \\<noteq> []\\<close> \\<open>awalk u p v\\<close>"], ["proof (prove)\nusing this:\n  awalk u' p v'\n  p \\<noteq> []\n  awalk u p v\n\ngoal (1 subgoal):\n 1. u = u' &&& v = v'", "by (metis awalk_ends)+"], ["proof (state)\nthis:\n  u = u'\n  v = v'\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>p = q @ r @ s; distinct (awalk_verts u q);\n      \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v;\n      closed_w r\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v", "then"], ["proof (chain)\npicking this:\n  u = u'\n  v = v'", "have \"awalk u q w'\" \"awalk w' r w'\" \"awalk w' s v\""], ["proof (prove)\nusing this:\n  u = u'\n  v = v'\n\ngoal (1 subgoal):\n 1. awalk u q w' &&& awalk w' r w' &&& awalk w' s v", "using obt_awalk"], ["proof (prove)\nusing this:\n  u = u'\n  v = v'\n  awalk u' q w'\n  awalk w' r w'\n  awalk w' s v'\n\ngoal (1 subgoal):\n 1. awalk u q w' &&& awalk w' r w' &&& awalk w' s v", "by auto"], ["proof (state)\nthis:\n  awalk u q w'\n  awalk w' r w'\n  awalk w' s v\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>p = q @ r @ s; distinct (awalk_verts u q);\n      \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v;\n      closed_w r\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v", "then"], ["proof (chain)\npicking this:\n  awalk u q w'\n  awalk w' r w'\n  awalk w' s v", "show \"\\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v\""], ["proof (prove)\nusing this:\n  awalk u q w'\n  awalk w' r w'\n  awalk w' s v\n\ngoal (1 subgoal):\n 1. \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v", "by auto"], ["proof (state)\nthis:\n  \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma awalk_cyc_decompE':\n  assumes p_props: \"awalk u p v\" \"\\<not>distinct (awalk_verts u p)\"\n  obtains q r s where \"p = q @ r @ s\" \"distinct (awalk_verts u q)\" \"\\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v\" \"closed_w r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q r s.\n        \\<lbrakk>p = q @ r @ s; distinct (awalk_verts u q);\n         \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v;\n         closed_w r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>q r s.\n        \\<lbrakk>p = q @ r @ s; distinct (awalk_verts u q);\n         \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v;\n         closed_w r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain q r s where \"awalk_cyc_decomp p = (q,r,s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q r s.\n        awalk_cyc_decomp p = (q, r, s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"awalk_cyc_decomp p\") auto"], ["proof (state)\nthis:\n  awalk_cyc_decomp p = (q, r, s)\n\ngoal (1 subgoal):\n 1. (\\<And>q r s.\n        \\<lbrakk>p = q @ r @ s; distinct (awalk_verts u q);\n         \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v;\n         closed_w r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  awalk_cyc_decomp p = (q, r, s)", "have \"p = q @ r @ s\" \"distinct (awalk_verts u q)\" \"\\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v\" \"closed_w r\""], ["proof (prove)\nusing this:\n  awalk_cyc_decomp p = (q, r, s)\n\ngoal (1 subgoal):\n 1. (p = q @ r @ s &&& distinct (awalk_verts u q)) &&&\n    \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v &&&\n    closed_w r", "using assms"], ["proof (prove)\nusing this:\n  awalk_cyc_decomp p = (q, r, s)\n  awalk u p v\n  \\<not> distinct (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. (p = q @ r @ s &&& distinct (awalk_verts u q)) &&&\n    \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v &&&\n    closed_w r", "by (auto elim: awalk_cyc_decompE)"], ["proof (state)\nthis:\n  p = q @ r @ s\n  distinct (awalk_verts u q)\n  \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v\n  closed_w r\n\ngoal (1 subgoal):\n 1. (\\<And>q r s.\n        \\<lbrakk>p = q @ r @ s; distinct (awalk_verts u q);\n         \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v;\n         closed_w r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  p = q @ r @ s\n  distinct (awalk_verts u q)\n  \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v\n  closed_w r", "show ?thesis"], ["proof (prove)\nusing this:\n  p = q @ r @ s\n  distinct (awalk_verts u q)\n  \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v\n  closed_w r\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "termination awalk_to_apath"], ["proof (prove)\ngoal (1 subgoal):\n 1. All awalk_to_apath_dom", "proof (relation \"measure length\")"], ["proof (state)\ngoal (2 subgoals):\n 1. wf (measure length)\n 2. \\<And>p x xa y xb ya.\n       \\<lbrakk>(\\<nexists>u. distinct (awalk_verts u p)) \\<and>\n                (\\<exists>u. Ex (awalk u p));\n        x = awalk_cyc_decomp p; (xa, y) = x; (xb, ya) = y\\<rbrakk>\n       \\<Longrightarrow> (xa @ ya, p) \\<in> measure length", "fix G p qrs rs q r s"], ["proof (state)\ngoal (2 subgoals):\n 1. wf (measure length)\n 2. \\<And>p x xa y xb ya.\n       \\<lbrakk>(\\<nexists>u. distinct (awalk_verts u p)) \\<and>\n                (\\<exists>u. Ex (awalk u p));\n        x = awalk_cyc_decomp p; (xa, y) = x; (xb, ya) = y\\<rbrakk>\n       \\<Longrightarrow> (xa @ ya, p) \\<in> measure length", "have X: \"\\<And>x y. closed_w r \\<Longrightarrow> awalk x r y \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>closed_w r; awalk x r y\\<rbrakk> \\<Longrightarrow> x = y", "unfolding closed_w_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<exists>u. awalk u r u \\<and> 0 < length r;\n        awalk x r y\\<rbrakk>\n       \\<Longrightarrow> x = y", "by (blast dest: awalk_ends)"], ["proof (state)\nthis:\n  \\<lbrakk>closed_w r; awalk ?x r ?y\\<rbrakk> \\<Longrightarrow> ?x = ?y\n\ngoal (2 subgoals):\n 1. wf (measure length)\n 2. \\<And>p x xa y xb ya.\n       \\<lbrakk>(\\<nexists>u. distinct (awalk_verts u p)) \\<and>\n                (\\<exists>u. Ex (awalk u p));\n        x = awalk_cyc_decomp p; (xa, y) = x; (xb, ya) = y\\<rbrakk>\n       \\<Longrightarrow> (xa @ ya, p) \\<in> measure length", "assume \"\\<not>(\\<exists>u. distinct (awalk_verts u p)) \\<and>(\\<exists>u v. awalk u p v)\"\n    and **:\"qrs = awalk_cyc_decomp p\" \"(q, rs) = qrs\" \"(r, s) = rs\""], ["proof (state)\nthis:\n  (\\<nexists>u. distinct (awalk_verts u p)) \\<and>\n  (\\<exists>u v. awalk u p v)\n  qrs = awalk_cyc_decomp p\n  (q, rs) = qrs\n  (r, s) = rs\n\ngoal (2 subgoals):\n 1. wf (measure length)\n 2. \\<And>p x xa y xb ya.\n       \\<lbrakk>(\\<nexists>u. distinct (awalk_verts u p)) \\<and>\n                (\\<exists>u. Ex (awalk u p));\n        x = awalk_cyc_decomp p; (xa, y) = x; (xb, ya) = y\\<rbrakk>\n       \\<Longrightarrow> (xa @ ya, p) \\<in> measure length", "then"], ["proof (chain)\npicking this:\n  (\\<nexists>u. distinct (awalk_verts u p)) \\<and>\n  (\\<exists>u v. awalk u p v)\n  qrs = awalk_cyc_decomp p\n  (q, rs) = qrs\n  (r, s) = rs", "obtain u v where *: \"awalk u p v\" \"\\<not>distinct (awalk_verts u p)\""], ["proof (prove)\nusing this:\n  (\\<nexists>u. distinct (awalk_verts u p)) \\<and>\n  (\\<exists>u v. awalk u p v)\n  qrs = awalk_cyc_decomp p\n  (q, rs) = qrs\n  (r, s) = rs\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>awalk u p v; \\<not> distinct (awalk_verts u p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p) auto"], ["proof (state)\nthis:\n  awalk u p v\n  \\<not> distinct (awalk_verts u p)\n\ngoal (2 subgoals):\n 1. wf (measure length)\n 2. \\<And>p x xa y xb ya.\n       \\<lbrakk>(\\<nexists>u. distinct (awalk_verts u p)) \\<and>\n                (\\<exists>u. Ex (awalk u p));\n        x = awalk_cyc_decomp p; (xa, y) = x; (xb, ya) = y\\<rbrakk>\n       \\<Longrightarrow> (xa @ ya, p) \\<in> measure length", "then"], ["proof (chain)\npicking this:\n  awalk u p v\n  \\<not> distinct (awalk_verts u p)", "have \"awalk_cyc_decomp p = (q,r,s)\""], ["proof (prove)\nusing this:\n  awalk u p v\n  \\<not> distinct (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. awalk_cyc_decomp p = (q, r, s)", "using **"], ["proof (prove)\nusing this:\n  awalk u p v\n  \\<not> distinct (awalk_verts u p)\n  qrs = awalk_cyc_decomp p\n  (q, rs) = qrs\n  (r, s) = rs\n\ngoal (1 subgoal):\n 1. awalk_cyc_decomp p = (q, r, s)", "by simp"], ["proof (state)\nthis:\n  awalk_cyc_decomp p = (q, r, s)\n\ngoal (2 subgoals):\n 1. wf (measure length)\n 2. \\<And>p x xa y xb ya.\n       \\<lbrakk>(\\<nexists>u. distinct (awalk_verts u p)) \\<and>\n                (\\<exists>u. Ex (awalk u p));\n        x = awalk_cyc_decomp p; (xa, y) = x; (xb, ya) = y\\<rbrakk>\n       \\<Longrightarrow> (xa @ ya, p) \\<in> measure length", "then"], ["proof (chain)\npicking this:\n  awalk_cyc_decomp p = (q, r, s)", "have \"is_awalk_cyc_decomp p (q,r,s)\""], ["proof (prove)\nusing this:\n  awalk_cyc_decomp p = (q, r, s)\n\ngoal (1 subgoal):\n 1. is_awalk_cyc_decomp p (q, r, s)", "apply (rule awalk_cyc_decompE[OF _ *])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = q @ r @ s; distinct (awalk_verts u q);\n     \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v;\n     closed_w r\\<rbrakk>\n    \\<Longrightarrow> is_awalk_cyc_decomp p (q, r, s)", "using X[of \"awlast u q\"  \"awlast (awlast u q) r\"] *(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>closed_w r; awalk (awlast u q) r (awlast (awlast u q) r)\\<rbrakk>\n  \\<Longrightarrow> awlast u q = awlast (awlast u q) r\n  awalk u p v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p = q @ r @ s; distinct (awalk_verts u q);\n     \\<exists>w. awalk u q w \\<and> awalk w r w \\<and> awalk w s v;\n     closed_w r\\<rbrakk>\n    \\<Longrightarrow> is_awalk_cyc_decomp p (q, r, s)", "by (auto simp: closed_w_def)"], ["proof (state)\nthis:\n  is_awalk_cyc_decomp p (q, r, s)\n\ngoal (2 subgoals):\n 1. wf (measure length)\n 2. \\<And>p x xa y xb ya.\n       \\<lbrakk>(\\<nexists>u. distinct (awalk_verts u p)) \\<and>\n                (\\<exists>u. Ex (awalk u p));\n        x = awalk_cyc_decomp p; (xa, y) = x; (xb, ya) = y\\<rbrakk>\n       \\<Longrightarrow> (xa @ ya, p) \\<in> measure length", "then"], ["proof (chain)\npicking this:\n  is_awalk_cyc_decomp p (q, r, s)", "show \"(q @ s, p) \\<in> measure length\""], ["proof (prove)\nusing this:\n  is_awalk_cyc_decomp p (q, r, s)\n\ngoal (1 subgoal):\n 1. (q @ s, p) \\<in> measure length", "by (auto simp: closed_w_def)"], ["proof (state)\nthis:\n  (q @ s, p) \\<in> measure length\n\ngoal (1 subgoal):\n 1. wf (measure length)", "qed simp"], ["", "declare awalk_to_apath.simps[simp del]"], ["", "lemma awalk_to_apath_induct[consumes 1, case_names path decomp]:\n  assumes awalk: \"awalk u p v\"\n  assumes dist: \"\\<And>p. awalk u p v \\<Longrightarrow> distinct (awalk_verts u p) \\<Longrightarrow> P p\"\n  assumes dec: \"\\<And>p q r s. \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q,r,s);\n    \\<not>distinct (awalk_verts u p); P (q @ s)\\<rbrakk> \\<Longrightarrow> P p\"\n  shows \"P p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "using awalk"], ["proof (prove)\nusing this:\n  awalk u p v\n\ngoal (1 subgoal):\n 1. P p", "proof (induct \"length p\" arbitrary: p rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>length pa < length p; awalk u pa v\\<rbrakk>\n                   \\<Longrightarrow> P pa;\n        awalk u p v\\<rbrakk>\n       \\<Longrightarrow> P p", "case less"], ["proof (state)\nthis:\n  \\<lbrakk>length ?p < length p; awalk u ?p v\\<rbrakk>\n  \\<Longrightarrow> P ?p\n  awalk u p v\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>pa.\n                   \\<lbrakk>length pa < length p; awalk u pa v\\<rbrakk>\n                   \\<Longrightarrow> P pa;\n        awalk u p v\\<rbrakk>\n       \\<Longrightarrow> P p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P p", "proof (cases \"distinct (awalk_verts u p)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct (awalk_verts u p) \\<Longrightarrow> P p\n 2. \\<not> distinct (awalk_verts u p) \\<Longrightarrow> P p", "case True"], ["proof (state)\nthis:\n  distinct (awalk_verts u p)\n\ngoal (2 subgoals):\n 1. distinct (awalk_verts u p) \\<Longrightarrow> P p\n 2. \\<not> distinct (awalk_verts u p) \\<Longrightarrow> P p", "then"], ["proof (chain)\npicking this:\n  distinct (awalk_verts u p)", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. P p", "by (auto intro: dist less.prems)"], ["proof (state)\nthis:\n  P p\n\ngoal (1 subgoal):\n 1. \\<not> distinct (awalk_verts u p) \\<Longrightarrow> P p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> distinct (awalk_verts u p) \\<Longrightarrow> P p", "case False"], ["proof (state)\nthis:\n  \\<not> distinct (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (awalk_verts u p) \\<Longrightarrow> P p", "obtain q r s where p_cdecomp: \"awalk_cyc_decomp p = (q,r,s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q r s.\n        awalk_cyc_decomp p = (q, r, s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"awalk_cyc_decomp p\") auto"], ["proof (state)\nthis:\n  awalk_cyc_decomp p = (q, r, s)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (awalk_verts u p) \\<Longrightarrow> P p", "then"], ["proof (chain)\npicking this:\n  awalk_cyc_decomp p = (q, r, s)", "have \"is_awalk_cyc_decomp p (q,r,s)\" \"p = q @ r @ s\""], ["proof (prove)\nusing this:\n  awalk_cyc_decomp p = (q, r, s)\n\ngoal (1 subgoal):\n 1. is_awalk_cyc_decomp p (q, r, s) &&& p = q @ r @ s", "using awalk_cyc_decomp_has_prop[OF less.prems(1) False]"], ["proof (prove)\nusing this:\n  awalk_cyc_decomp p = (q, r, s)\n  is_awalk_cyc_decomp p (awalk_cyc_decomp p)\n\ngoal (1 subgoal):\n 1. is_awalk_cyc_decomp p (q, r, s) &&& p = q @ r @ s", "by auto"], ["proof (state)\nthis:\n  is_awalk_cyc_decomp p (q, r, s)\n  p = q @ r @ s\n\ngoal (1 subgoal):\n 1. \\<not> distinct (awalk_verts u p) \\<Longrightarrow> P p", "then"], ["proof (chain)\npicking this:\n  is_awalk_cyc_decomp p (q, r, s)\n  p = q @ r @ s", "have \"length (q @ s) < length p\" \"awalk u (q @ s) v\""], ["proof (prove)\nusing this:\n  is_awalk_cyc_decomp p (q, r, s)\n  p = q @ r @ s\n\ngoal (1 subgoal):\n 1. length (q @ s) < length p &&& awalk u (q @ s) v", "using less.prems"], ["proof (prove)\nusing this:\n  is_awalk_cyc_decomp p (q, r, s)\n  p = q @ r @ s\n  awalk u p v\n\ngoal (1 subgoal):\n 1. length (q @ s) < length p &&& awalk u (q @ s) v", "by (auto dest!: awalk_ends_eqD)"], ["proof (state)\nthis:\n  length (q @ s) < length p\n  awalk u (q @ s) v\n\ngoal (1 subgoal):\n 1. \\<not> distinct (awalk_verts u p) \\<Longrightarrow> P p", "then"], ["proof (chain)\npicking this:\n  length (q @ s) < length p\n  awalk u (q @ s) v", "have \"P (q @ s)\""], ["proof (prove)\nusing this:\n  length (q @ s) < length p\n  awalk u (q @ s) v\n\ngoal (1 subgoal):\n 1. P (q @ s)", "by (auto intro: less)"], ["proof (state)\nthis:\n  P (q @ s)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (awalk_verts u p) \\<Longrightarrow> P p", "with p_cdecomp False"], ["proof (chain)\npicking this:\n  awalk_cyc_decomp p = (q, r, s)\n  \\<not> distinct (awalk_verts u p)\n  P (q @ s)", "show ?thesis"], ["proof (prove)\nusing this:\n  awalk_cyc_decomp p = (q, r, s)\n  \\<not> distinct (awalk_verts u p)\n  P (q @ s)\n\ngoal (1 subgoal):\n 1. P p", "by (auto intro: dec less.prems)"], ["proof (state)\nthis:\n  P p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma step_awalk_to_apath:\n  assumes awalk: \"awalk u p v\"\n    and decomp: \"awalk_cyc_decomp p = (q, r, s)\"\n    and dist: \"\\<not> distinct (awalk_verts u p)\"\n  shows \"awalk_to_apath p = awalk_to_apath (q @ s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. awalk_to_apath p = awalk_to_apath (q @ s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. awalk_to_apath p = awalk_to_apath (q @ s)", "from dist"], ["proof (chain)\npicking this:\n  \\<not> distinct (awalk_verts u p)", "have \"\\<not>(\\<exists>u. distinct (awalk_verts u p))\""], ["proof (prove)\nusing this:\n  \\<not> distinct (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. \\<nexists>u. distinct (awalk_verts u p)", "by (auto simp: awalk_verts_conv)"], ["proof (state)\nthis:\n  \\<nexists>u. distinct (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. awalk_to_apath p = awalk_to_apath (q @ s)", "with awalk and decomp"], ["proof (chain)\npicking this:\n  awalk u p v\n  awalk_cyc_decomp p = (q, r, s)\n  \\<nexists>u. distinct (awalk_verts u p)", "show \"awalk_to_apath p = awalk_to_apath (q @ s)\""], ["proof (prove)\nusing this:\n  awalk u p v\n  awalk_cyc_decomp p = (q, r, s)\n  \\<nexists>u. distinct (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. awalk_to_apath p = awalk_to_apath (q @ s)", "by (auto simp: awalk_to_apath.simps)"], ["proof (state)\nthis:\n  awalk_to_apath p = awalk_to_apath (q @ s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma apath_awalk_to_apath:\n  assumes \"awalk u p v\"\n  shows \"apath u (awalk_to_apath p) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apath u (awalk_to_apath p) v", "using assms"], ["proof (prove)\nusing this:\n  awalk u p v\n\ngoal (1 subgoal):\n 1. apath u (awalk_to_apath p) v", "proof (induct rule: awalk_to_apath_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>awalk u p v; distinct (awalk_verts u p)\\<rbrakk>\n       \\<Longrightarrow> apath u (awalk_to_apath p) v\n 2. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        apath u (awalk_to_apath (q @ s)) v\\<rbrakk>\n       \\<Longrightarrow> apath u (awalk_to_apath p) v", "case (path p)"], ["proof (state)\nthis:\n  awalk u p v\n  distinct (awalk_verts u p)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>awalk u p v; distinct (awalk_verts u p)\\<rbrakk>\n       \\<Longrightarrow> apath u (awalk_to_apath p) v\n 2. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        apath u (awalk_to_apath (q @ s)) v\\<rbrakk>\n       \\<Longrightarrow> apath u (awalk_to_apath p) v", "then"], ["proof (chain)\npicking this:\n  awalk u p v\n  distinct (awalk_verts u p)", "have \"awalk_to_apath p = p\""], ["proof (prove)\nusing this:\n  awalk u p v\n  distinct (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. awalk_to_apath p = p", "by (auto simp: awalk_to_apath.simps)"], ["proof (state)\nthis:\n  awalk_to_apath p = p\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>awalk u p v; distinct (awalk_verts u p)\\<rbrakk>\n       \\<Longrightarrow> apath u (awalk_to_apath p) v\n 2. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        apath u (awalk_to_apath (q @ s)) v\\<rbrakk>\n       \\<Longrightarrow> apath u (awalk_to_apath p) v", "then"], ["proof (chain)\npicking this:\n  awalk_to_apath p = p", "show ?case"], ["proof (prove)\nusing this:\n  awalk_to_apath p = p\n\ngoal (1 subgoal):\n 1. apath u (awalk_to_apath p) v", "using path"], ["proof (prove)\nusing this:\n  awalk_to_apath p = p\n  awalk u p v\n  distinct (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. apath u (awalk_to_apath p) v", "by (auto simp: apath_def)"], ["proof (state)\nthis:\n  apath u (awalk_to_apath p) v\n\ngoal (1 subgoal):\n 1. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        apath u (awalk_to_apath (q @ s)) v\\<rbrakk>\n       \\<Longrightarrow> apath u (awalk_to_apath p) v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        apath u (awalk_to_apath (q @ s)) v\\<rbrakk>\n       \\<Longrightarrow> apath u (awalk_to_apath p) v", "case (decomp p q r s)"], ["proof (state)\nthis:\n  awalk u p v\n  awalk_cyc_decomp p = (q, r, s)\n  \\<not> distinct (awalk_verts u p)\n  apath u (awalk_to_apath (q @ s)) v\n\ngoal (1 subgoal):\n 1. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        apath u (awalk_to_apath (q @ s)) v\\<rbrakk>\n       \\<Longrightarrow> apath u (awalk_to_apath p) v", "then"], ["proof (chain)\npicking this:\n  awalk u p v\n  awalk_cyc_decomp p = (q, r, s)\n  \\<not> distinct (awalk_verts u p)\n  apath u (awalk_to_apath (q @ s)) v", "show ?case"], ["proof (prove)\nusing this:\n  awalk u p v\n  awalk_cyc_decomp p = (q, r, s)\n  \\<not> distinct (awalk_verts u p)\n  apath u (awalk_to_apath (q @ s)) v\n\ngoal (1 subgoal):\n 1. apath u (awalk_to_apath p) v", "using step_awalk_to_apath[of _ p _ q r s]"], ["proof (prove)\nusing this:\n  awalk u p v\n  awalk_cyc_decomp p = (q, r, s)\n  \\<not> distinct (awalk_verts u p)\n  apath u (awalk_to_apath (q @ s)) v\n  \\<lbrakk>awalk ?u p ?v; awalk_cyc_decomp p = (q, r, s);\n   \\<not> distinct (awalk_verts ?u p)\\<rbrakk>\n  \\<Longrightarrow> awalk_to_apath p = awalk_to_apath (q @ s)\n\ngoal (1 subgoal):\n 1. apath u (awalk_to_apath p) v", "by simp"], ["proof (state)\nthis:\n  apath u (awalk_to_apath p) v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in wf_digraph) awalk_to_apath_subset:\n  assumes \"awalk u p v\"\n  shows \"set (awalk_to_apath p) \\<subseteq> set p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (awalk_to_apath p) \\<subseteq> set p", "using assms"], ["proof (prove)\nusing this:\n  awalk u p v\n\ngoal (1 subgoal):\n 1. set (awalk_to_apath p) \\<subseteq> set p", "proof (induct rule: awalk_to_apath_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>awalk u p v; distinct (awalk_verts u p)\\<rbrakk>\n       \\<Longrightarrow> set (awalk_to_apath p) \\<subseteq> set p\n 2. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        set (awalk_to_apath (q @ s)) \\<subseteq> set (q @ s)\\<rbrakk>\n       \\<Longrightarrow> set (awalk_to_apath p) \\<subseteq> set p", "case (path p)"], ["proof (state)\nthis:\n  awalk u p v\n  distinct (awalk_verts u p)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>awalk u p v; distinct (awalk_verts u p)\\<rbrakk>\n       \\<Longrightarrow> set (awalk_to_apath p) \\<subseteq> set p\n 2. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        set (awalk_to_apath (q @ s)) \\<subseteq> set (q @ s)\\<rbrakk>\n       \\<Longrightarrow> set (awalk_to_apath p) \\<subseteq> set p", "then"], ["proof (chain)\npicking this:\n  awalk u p v\n  distinct (awalk_verts u p)", "have \"awalk_to_apath p = p\""], ["proof (prove)\nusing this:\n  awalk u p v\n  distinct (awalk_verts u p)\n\ngoal (1 subgoal):\n 1. awalk_to_apath p = p", "by (auto simp: awalk_to_apath.simps)"], ["proof (state)\nthis:\n  awalk_to_apath p = p\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>awalk u p v; distinct (awalk_verts u p)\\<rbrakk>\n       \\<Longrightarrow> set (awalk_to_apath p) \\<subseteq> set p\n 2. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        set (awalk_to_apath (q @ s)) \\<subseteq> set (q @ s)\\<rbrakk>\n       \\<Longrightarrow> set (awalk_to_apath p) \\<subseteq> set p", "then"], ["proof (chain)\npicking this:\n  awalk_to_apath p = p", "show ?case"], ["proof (prove)\nusing this:\n  awalk_to_apath p = p\n\ngoal (1 subgoal):\n 1. set (awalk_to_apath p) \\<subseteq> set p", "by simp"], ["proof (state)\nthis:\n  set (awalk_to_apath p) \\<subseteq> set p\n\ngoal (1 subgoal):\n 1. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        set (awalk_to_apath (q @ s)) \\<subseteq> set (q @ s)\\<rbrakk>\n       \\<Longrightarrow> set (awalk_to_apath p) \\<subseteq> set p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        set (awalk_to_apath (q @ s)) \\<subseteq> set (q @ s)\\<rbrakk>\n       \\<Longrightarrow> set (awalk_to_apath p) \\<subseteq> set p", "case (decomp p q r s)"], ["proof (state)\nthis:\n  awalk u p v\n  awalk_cyc_decomp p = (q, r, s)\n  \\<not> distinct (awalk_verts u p)\n  set (awalk_to_apath (q @ s)) \\<subseteq> set (q @ s)\n\ngoal (1 subgoal):\n 1. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        set (awalk_to_apath (q @ s)) \\<subseteq> set (q @ s)\\<rbrakk>\n       \\<Longrightarrow> set (awalk_to_apath p) \\<subseteq> set p", "have *: \"\\<not>(\\<exists>u. distinct (awalk_verts u p)) \\<and> (\\<exists>u v. awalk u p v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>u. distinct (awalk_verts u p)) \\<and>\n    (\\<exists>u v. awalk u p v)", "using decomp"], ["proof (prove)\nusing this:\n  awalk u p v\n  awalk_cyc_decomp p = (q, r, s)\n  \\<not> distinct (awalk_verts u p)\n  set (awalk_to_apath (q @ s)) \\<subseteq> set (q @ s)\n\ngoal (1 subgoal):\n 1. (\\<nexists>u. distinct (awalk_verts u p)) \\<and>\n    (\\<exists>u v. awalk u p v)", "by (cases p) auto"], ["proof (state)\nthis:\n  (\\<nexists>u. distinct (awalk_verts u p)) \\<and>\n  (\\<exists>u v. awalk u p v)\n\ngoal (1 subgoal):\n 1. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        set (awalk_to_apath (q @ s)) \\<subseteq> set (q @ s)\\<rbrakk>\n       \\<Longrightarrow> set (awalk_to_apath p) \\<subseteq> set p", "have \"set (awalk_to_apath (q @ s)) \\<subseteq> set p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (awalk_to_apath (q @ s)) \\<subseteq> set p", "using decomp"], ["proof (prove)\nusing this:\n  awalk u p v\n  awalk_cyc_decomp p = (q, r, s)\n  \\<not> distinct (awalk_verts u p)\n  set (awalk_to_apath (q @ s)) \\<subseteq> set (q @ s)\n\ngoal (1 subgoal):\n 1. set (awalk_to_apath (q @ s)) \\<subseteq> set p", "by (auto elim!: awalk_cyc_decompE)"], ["proof (state)\nthis:\n  set (awalk_to_apath (q @ s)) \\<subseteq> set p\n\ngoal (1 subgoal):\n 1. \\<And>p q r s.\n       \\<lbrakk>awalk u p v; awalk_cyc_decomp p = (q, r, s);\n        \\<not> distinct (awalk_verts u p);\n        set (awalk_to_apath (q @ s)) \\<subseteq> set (q @ s)\\<rbrakk>\n       \\<Longrightarrow> set (awalk_to_apath p) \\<subseteq> set p", "then"], ["proof (chain)\npicking this:\n  set (awalk_to_apath (q @ s)) \\<subseteq> set p", "show ?case"], ["proof (prove)\nusing this:\n  set (awalk_to_apath (q @ s)) \\<subseteq> set p\n\ngoal (1 subgoal):\n 1. set (awalk_to_apath p) \\<subseteq> set p", "by (subst awalk_to_apath.simps) (simp only: * simp_thms if_True decomp Let_def prod.simps)"], ["proof (state)\nthis:\n  set (awalk_to_apath p) \\<subseteq> set p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reachable_apath:\n  \"u \\<rightarrow>\\<^sup>* v \\<longleftrightarrow> (\\<exists>p. apath u p v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u \\<rightarrow>\\<^sup>* v) = (\\<exists>p. apath u p v)", "by (auto intro: awalkI_apath apath_awalk_to_apath simp: reachable_awalk)"], ["", "lemma no_loops_in_apath:\n  assumes \"apath u p v\" \"a \\<in> set p\" shows \"tail G a \\<noteq> head G a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tail G a \\<noteq> head G a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tail G a \\<noteq> head G a", "from \\<open>a \\<in> set p\\<close>"], ["proof (chain)\npicking this:\n  a \\<in> set p", "obtain p1 p2 where \"p = p1 @ a # p2\""], ["proof (prove)\nusing this:\n  a \\<in> set p\n\ngoal (1 subgoal):\n 1. (\\<And>p1 p2.\n        p = p1 @ a # p2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_set_conv_decomp)"], ["proof (state)\nthis:\n  p = p1 @ a # p2\n\ngoal (1 subgoal):\n 1. tail G a \\<noteq> head G a", "with \\<open>apath u p v\\<close>"], ["proof (chain)\npicking this:\n  apath u p v\n  p = p1 @ a # p2", "have \"apath (tail G a) ([a] @ p2) (v)\""], ["proof (prove)\nusing this:\n  apath u p v\n  p = p1 @ a # p2\n\ngoal (1 subgoal):\n 1. apath (tail G a) ([a] @ p2) v", "by (auto simp: apath_append_iff apath_Cons_iff apath_Nil_iff)"], ["proof (state)\nthis:\n  apath (tail G a) ([a] @ p2) v\n\ngoal (1 subgoal):\n 1. tail G a \\<noteq> head G a", "then"], ["proof (chain)\npicking this:\n  apath (tail G a) ([a] @ p2) v", "have \"apath (tail G a) [a] (head G a)\""], ["proof (prove)\nusing this:\n  apath (tail G a) ([a] @ p2) v\n\ngoal (1 subgoal):\n 1. apath (tail G a) [a] (head G a)", "by - (drule apath_append_iff[THEN iffD1], simp)"], ["proof (state)\nthis:\n  apath (tail G a) [a] (head G a)\n\ngoal (1 subgoal):\n 1. tail G a \\<noteq> head G a", "then"], ["proof (chain)\npicking this:\n  apath (tail G a) [a] (head G a)", "show ?thesis"], ["proof (prove)\nusing this:\n  apath (tail G a) [a] (head G a)\n\ngoal (1 subgoal):\n 1. tail G a \\<noteq> head G a", "by (auto simp:  apath_Cons_iff)"], ["proof (state)\nthis:\n  tail G a \\<noteq> head G a\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}