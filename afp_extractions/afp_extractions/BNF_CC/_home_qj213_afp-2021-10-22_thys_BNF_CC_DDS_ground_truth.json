{"file_name": "/home/qj213/afp-2021-10-22/thys/BNF_CC/DDS.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/BNF_CC", "problem_names": ["lemma map_dds_id: \"map_dds id id S = S\"", "lemma map_dds_comp: \"map_dds f g (map_dds f' g' S) = map_dds (f' \\<circ> f) (g \\<circ> g') S\"", "lemma rel_dds'_rel_dds: \"rel_dds' B = rel_dds (=) B\"", "lemma rel_dds_eq [relator_eq]: \"rel_dds (=) (=) = (=)\"", "lemma rel_dds_mono [relator_mono]: \"rel_dds A B \\<le> rel_dds A' B'\" if \"A' \\<le> A\" \"B \\<le> B'\"", "lemma rel_dds_conversep: \"rel_dds A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> = (rel_dds A B)\\<inverse>\\<inverse>\"", "lemma DDS_parametric [transfer_rule]:\n  \"((A ===> rel_prod B (rel_dds A B)) ===> rel_dds A B) DDS DDS\"", "lemma run_parametric [transfer_rule]:\n  \"(rel_dds A B ===> A ===> rel_prod B (rel_dds A B)) run run\"", "lemma corec_dds_parametric [transfer_rule]:\n  \"((S ===> A ===> rel_prod B (rel_sum (rel_dds A B) S)) ===> S ===> rel_dds A B) corec_dds corec_dds\"", "lemma map_dds_parametric [transfer_rule]:\n  \"((A' ===> A) ===> (B ===> B') ===> rel_dds A B ===> rel_dds A' B') map_dds map_dds\"", "lemmas map_dds_rel_cong = map_dds_parametric[unfolded rel_fun_def, rule_format, rotated -1]", "lemma rel_dds_Grp:\n  \"rel_dds (Grp UNIV f)\\<inverse>\\<inverse> (Grp UNIV g) = Grp UNIV (map_dds f g)\"", "lemma rel_dds_pos_distr [relator_distr]:\n  \"rel_dds A B OO rel_dds C D \\<le> rel_dds (A OO C) (B OO D)\"", "lemma Quotient_dds [quot_map]:\n  assumes \"Quotient R1 Abs1 Rep1 T1\" and \"Quotient R2 Abs2 Rep2 T2\"\n  shows \"Quotient (rel_dds R1 R2) (map_dds Rep1 Abs2) (map_dds Abs1 Rep2) (rel_dds T1 T2)\"", "lemma dds_of_parametric [transfer_rule]:\n  \"((S ===> A ===> rel_prod B S) ===> S ===> rel_dds A B) dds_of dds_of\"", "lemma compose_parametric [transfer_rule]:\n  \"(rel_dds A B ===> rel_dds B C ===> rel_dds A C) (\\<bullet>) (\\<bullet>)\"", "lemma \"map_dds f g S1 \\<bullet> S2 = map_dds f id (S1 \\<bullet> map_dds g id S2)\"", "lemma compose_map1: \"map_dds f g S1 \\<bullet> S2 = map_dds f id (S1 \\<bullet> map_dds g id S2)\"\n  for S1 :: \"('a, 'b) dds\" and S2 :: \"('b, 'c) dds\"", "lemma compose_map2: \"S1 \\<bullet> map_dds f g S2 = map_dds id g (map_dds id f S1 \\<bullet> S2)\"\n  for S1 :: \"('a, 'b) dds\" and S2 :: \"('b, 'c) dds\"", "lemma parallel_parametric [transfer_rule]:\n  \"(rel_dds A B ===> rel_dds C D ===> rel_dds (rel_sum A C) (rel_sum B D)) (\\<parallel>) (\\<parallel>)\"", "lemma map_parallel:\n  \"map_dds f h S1 \\<parallel> map_dds g k S2 = map_dds (map_sum f g) (map_sum h k) (S1 \\<parallel> S2)\"", "lemma finite_Image:\n  \"finite A \\<Longrightarrow> finite (R `` A) \\<longleftrightarrow> (\\<forall>x\\<in>A. finite {y. (x, y) \\<in> R})\"", "lemmas fImage_iff = Image_iff[Transfer.transferred]", "lemmas fImageI [intro] = ImageI[Transfer.transferred]", "lemmas fImageE [elim!] = ImageE[Transfer.transferred]", "lemmas rev_fImageI = rev_ImageI[Transfer.transferred]", "lemmas fImage_mono = Image_mono[Transfer.transferred]", "lemma traverse_refinement: \\<comment> \\<open>This is the refinement lemma.\\<close>\n  \"(list_fset_rel ===> rel_dds list_fset_rel list_fset_rel) traverse_impl traverse\"", "lemma fset_of_list_parametric [transfer_rule]:\n  \"(list_all2 A ===> rel_fset A) fset_of_list fset_of_list\"", "lemma traverse_impl_parametric [transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\"\n  shows \"(list_all2 (rel_prod A A) ===> rel_dds (list_all2 A) (list_all2 A)) traverse_impl traverse_impl\"", "lemma accumulate_mono: \"rel_dds (|\\<subseteq>|) (|\\<subseteq>|) accumulate accumulate\"", "lemma traverse_mono: \"((|\\<subseteq>|) ===> rel_dds (=) (|\\<subseteq>|)) traverse traverse\"", "lemma\n  assumes \"G |\\<subseteq>| H\"\n  shows \"rel_dds (=) (|\\<subseteq>|) (traverse G \\<bullet> accumulate) (traverse H \\<bullet> accumulate)\"", "lemma seen_mono: \"rel_dds (|\\<subseteq>|) (|\\<subseteq>|) seen seen\"", "lemma\n  assumes \"G |\\<subseteq>| H\"\n  shows \"rel_dds (=) (|\\<subseteq>|) (traverse G \\<bullet> seen) (traverse H \\<bullet> seen)\""], "translations": [["", "lemma map_dds_id: \"map_dds id id S = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_dds id id S = S", "by(coinduction arbitrary: S)(auto simp add: rel_fun_def prod.rel_map intro: prod.rel_refl_strong)"], ["", "lemma map_dds_comp: \"map_dds f g (map_dds f' g' S) = map_dds (f' \\<circ> f) (g \\<circ> g') S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_dds f g (map_dds f' g' S) = map_dds (f' \\<circ> f) (g \\<circ> g') S", "by(coinduction arbitrary: S)(auto simp add: rel_fun_def prod.rel_map intro: prod.rel_refl_strong)"], ["", "coinductive rel_dds :: \"('a \\<Rightarrow> 'a' \\<Rightarrow> bool) \\<Rightarrow> ('b \\<Rightarrow> 'b' \\<Rightarrow> bool) \\<Rightarrow> ('a, 'b) dds \\<Rightarrow> ('a', 'b') dds \\<Rightarrow> bool\"\n  for A B where\n  \"rel_dds A B S S'\" if \"rel_fun A (rel_prod B (rel_dds A B)) (run S) (run S')\""], ["", "lemma rel_dds'_rel_dds: \"rel_dds' B = rel_dds (=) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dds' B = rel_dds (=) B", "apply (intro ext iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa. rel_dds' B x xa \\<Longrightarrow> rel_dds (=) B x xa\n 2. \\<And>x xa. rel_dds (=) B x xa \\<Longrightarrow> rel_dds' B x xa", "apply (erule rel_dds.coinduct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa x1 x2.\n       rel_dds' B x1 x2 \\<Longrightarrow>\n       \\<exists>S S'.\n          x1 = S \\<and>\n          x2 = S' \\<and>\n          ((=) ===>\n           rel_prod B\n            (\\<lambda>uu_ uua_.\n                rel_dds' B uu_ uua_ \\<or> rel_dds (=) B uu_ uua_))\n           (run S) (run S')\n 2. \\<And>x xa. rel_dds (=) B x xa \\<Longrightarrow> rel_dds' B x xa", "apply (erule dds.rel_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa x1 x2 xaa ya.\n       \\<lbrakk>x1 = DDS xaa; x2 = DDS ya;\n        ((=) ===> rel_prod B (rel_dds' B)) xaa ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S S'.\n                            x1 = S \\<and>\n                            x2 = S' \\<and>\n                            ((=) ===>\n                             rel_prod B\n                              (\\<lambda>uu_ uua_.\n                                  rel_dds' B uu_ uua_ \\<or>\n                                  rel_dds (=) B uu_ uua_))\n                             (run S) (run S')\n 2. \\<And>x xa. rel_dds (=) B x xa \\<Longrightarrow> rel_dds' B x xa", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 xaa ya.\n       \\<lbrakk>x1 = DDS xaa; x2 = DDS ya;\n        ((=) ===> rel_prod B (rel_dds' B)) xaa ya\\<rbrakk>\n       \\<Longrightarrow> ((=) ===>\n                          rel_prod B\n                           (\\<lambda>uu_ uua_.\n                               rel_dds' B uu_ uua_ \\<or>\n                               rel_dds (=) B uu_ uua_))\n                          xaa ya\n 2. \\<And>x xa. rel_dds (=) B x xa \\<Longrightarrow> rel_dds' B x xa", "apply (erule rel_fun_mono[THEN predicate2D, OF order_refl, rotated -1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 xaa ya.\n       \\<lbrakk>x1 = DDS xaa; x2 = DDS ya\\<rbrakk>\n       \\<Longrightarrow> rel_prod B (rel_dds' B)\n                         \\<le> rel_prod B\n                                (\\<lambda>uu_ uua_.\n                                    rel_dds' B uu_ uua_ \\<or>\n                                    rel_dds (=) B uu_ uua_)\n 2. \\<And>x xa. rel_dds (=) B x xa \\<Longrightarrow> rel_dds' B x xa", "apply (rule prod.rel_mono[OF order_refl])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 xaa ya.\n       \\<lbrakk>x1 = DDS xaa; x2 = DDS ya\\<rbrakk>\n       \\<Longrightarrow> rel_dds' B\n                         \\<le> (\\<lambda>uu_ uua_.\n                                   rel_dds' B uu_ uua_ \\<or>\n                                   rel_dds (=) B uu_ uua_)\n 2. \\<And>x xa. rel_dds (=) B x xa \\<Longrightarrow> rel_dds' B x xa", "apply (blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa. rel_dds (=) B x xa \\<Longrightarrow> rel_dds' B x xa", "apply (erule dds.rel_coinduct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa dds dds'.\n       rel_dds (=) B dds dds' \\<Longrightarrow>\n       ((=) ===> rel_prod B (rel_dds (=) B)) (run dds) (run dds')", "apply (erule rel_dds.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa dds dds' S S'.\n       \\<lbrakk>dds = S; dds' = S';\n        ((=) ===> rel_prod B (rel_dds (=) B)) (run S) (run S')\\<rbrakk>\n       \\<Longrightarrow> ((=) ===> rel_prod B (rel_dds (=) B)) (run dds)\n                          (run dds')", "apply (simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rel_dds_eq [relator_eq]: \"rel_dds (=) (=) = (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dds (=) (=) = (=)", "apply(rule ext iffI)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa. rel_dds (=) (=) x xa \\<Longrightarrow> x = xa\n 2. \\<And>x xa. x = xa \\<Longrightarrow> rel_dds (=) (=) x xa", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dds (=) (=) x_ xa_ \\<Longrightarrow> x_ = xa_", "by(erule dds.coinduct)(erule rel_dds.cases; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa. x = xa \\<Longrightarrow> rel_dds (=) (=) x xa", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ = xa_ \\<Longrightarrow> rel_dds (=) (=) x_ xa_", "by(erule rel_dds.coinduct)(auto simp add: rel_fun_def intro!: prod.rel_refl_strong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rel_dds_mono [relator_mono]: \"rel_dds A B \\<le> rel_dds A' B'\" if \"A' \\<le> A\" \"B \\<le> B'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dds A B \\<le> rel_dds A' B'", "apply(rule predicate2I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. rel_dds A B x y \\<Longrightarrow> rel_dds A' B' x y", "apply(erule rel_dds.coinduct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y x1 x2.\n       rel_dds A B x1 x2 \\<Longrightarrow>\n       \\<exists>S S'.\n          x1 = S \\<and>\n          x2 = S' \\<and>\n          (A' ===>\n           rel_prod B'\n            (\\<lambda>uu_ uua_.\n                rel_dds A B uu_ uua_ \\<or> rel_dds A' B' uu_ uua_))\n           (run S) (run S')", "apply(erule rel_dds.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y x1 x2 S S'.\n       \\<lbrakk>x1 = S; x2 = S';\n        (A ===> rel_prod B (rel_dds A B)) (run S) (run S')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S S'.\n                            x1 = S \\<and>\n                            x2 = S' \\<and>\n                            (A' ===>\n                             rel_prod B'\n                              (\\<lambda>uu_ uua_.\n                                  rel_dds A B uu_ uua_ \\<or>\n                                  rel_dds A' B' uu_ uua_))\n                             (run S) (run S')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 S S'.\n       \\<lbrakk>x1 = S; x2 = S';\n        (A ===> rel_prod B (rel_dds A B)) (run S) (run S')\\<rbrakk>\n       \\<Longrightarrow> (A' ===>\n                          rel_prod B'\n                           (\\<lambda>uu_ uua_.\n                               rel_dds A B uu_ uua_ \\<or>\n                               rel_dds A' B' uu_ uua_))\n                          (run S) (run S')", "apply(erule BNF_Def.rel_fun_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S S' x y.\n       \\<lbrakk>x1 = S; x2 = S'\\<rbrakk>\n       \\<Longrightarrow> A' x y \\<longrightarrow> A x y\n 2. \\<And>x1 x2 S S' x y.\n       \\<lbrakk>x1 = S; x2 = S'; rel_prod B (rel_dds A B) x y\\<rbrakk>\n       \\<Longrightarrow> rel_prod B'\n                          (\\<lambda>uu_ uua_.\n                              rel_dds A B uu_ uua_ \\<or>\n                              rel_dds A' B' uu_ uua_)\n                          x y", "apply(auto intro: that[THEN predicate2D])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rel_dds_conversep: \"rel_dds A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> = (rel_dds A B)\\<inverse>\\<inverse>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dds A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> =\n    (rel_dds A B)\\<inverse>\\<inverse>", "apply(intro ext iffI; simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       rel_dds A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> x\n        xa \\<Longrightarrow>\n       rel_dds A B xa x\n 2. \\<And>x xa.\n       rel_dds A B xa x \\<Longrightarrow>\n       rel_dds A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> x xa", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dds A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> x_\n     xa_ \\<Longrightarrow>\n    rel_dds A B xa_ x_", "apply(erule rel_dds.coinduct; erule rel_dds.cases; simp del: conversep_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 S S'.\n       \\<lbrakk>x2 = S; x1 = S';\n        (A\\<inverse>\\<inverse> ===>\n         rel_prod B\\<inverse>\\<inverse>\n          (rel_dds A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>))\n         (run S) (run S')\\<rbrakk>\n       \\<Longrightarrow> (A ===>\n                          rel_prod B\n                           (\\<lambda>uu_ uua_.\n                               rel_dds A\\<inverse>\\<inverse>\n                                B\\<inverse>\\<inverse> uua_ uu_ \\<or>\n                               rel_dds A B uu_ uua_))\n                          (run S') (run S)", "apply(rewrite conversep_iff[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 S S'.\n       \\<lbrakk>x2 = S; x1 = S';\n        (A\\<inverse>\\<inverse> ===>\n         rel_prod B\\<inverse>\\<inverse>\n          (rel_dds A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>))\n         (run S) (run S')\\<rbrakk>\n       \\<Longrightarrow> (A ===>\n                          rel_prod B\n                           (\\<lambda>uu_ uua_.\n                               rel_dds A\\<inverse>\\<inverse>\n                                B\\<inverse>\\<inverse> uua_ uu_ \\<or>\n                               rel_dds A B uu_ uua_))\\<inverse>\\<inverse>\n                          (run S) (run S')", "apply(fold rel_fun_conversep prod.rel_conversep)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 S S'.\n       \\<lbrakk>x2 = S; x1 = S';\n        (A\\<inverse>\\<inverse> ===>\n         rel_prod B\\<inverse>\\<inverse>\n          (rel_dds A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>))\n         (run S) (run S')\\<rbrakk>\n       \\<Longrightarrow> (A\\<inverse>\\<inverse> ===>\n                          rel_prod B\\<inverse>\\<inverse>\n                           (\\<lambda>uu_ uua_.\n                               rel_dds A\\<inverse>\\<inverse>\n                                B\\<inverse>\\<inverse> uua_ uu_ \\<or>\n                               rel_dds A B uu_ uua_)\\<inverse>\\<inverse>)\n                          (run S) (run S')", "apply(erule BNF_Def.rel_fun_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S S' x y.\n       \\<lbrakk>x2 = S; x1 = S'\\<rbrakk>\n       \\<Longrightarrow> A\\<inverse>\\<inverse> x y \\<longrightarrow>\n                         A\\<inverse>\\<inverse> x y\n 2. \\<And>x1 x2 S S' x y.\n       \\<lbrakk>x2 = S; x1 = S';\n        rel_prod B\\<inverse>\\<inverse>\n         (rel_dds A\\<inverse>\\<inverse> B\\<inverse>\\<inverse>) x y\\<rbrakk>\n       \\<Longrightarrow> rel_prod B\\<inverse>\\<inverse>\n                          (\\<lambda>uu_ uua_.\n                              rel_dds A\\<inverse>\\<inverse>\n                               B\\<inverse>\\<inverse> uua_ uu_ \\<or>\n                              rel_dds A B uu_ uua_)\\<inverse>\\<inverse>\n                          x y", "apply(auto simp del: conversep_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       rel_dds A B xa x \\<Longrightarrow>\n       rel_dds A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> x xa", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dds A B xa_ x_ \\<Longrightarrow>\n    rel_dds A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> x_ xa_", "apply(erule rel_dds.coinduct; erule rel_dds.cases; clarsimp simp del: conversep_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S S'.\n       (A ===> rel_prod B (rel_dds A B)) (run S) (run S') \\<Longrightarrow>\n       (A\\<inverse>\\<inverse> ===>\n        rel_prod B\\<inverse>\\<inverse>\n         (\\<lambda>uu_ uua_.\n             rel_dds A B uua_ uu_ \\<or>\n             rel_dds A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> uu_ uua_))\n        (run S') (run S)", "apply(rewrite in asm conversep_iff[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S S'.\n       (A ===> rel_prod B (rel_dds A B))\\<inverse>\\<inverse> (run S')\n        (run S) \\<Longrightarrow>\n       (A\\<inverse>\\<inverse> ===>\n        rel_prod B\\<inverse>\\<inverse>\n         (\\<lambda>uu_ uua_.\n             rel_dds A B uua_ uu_ \\<or>\n             rel_dds A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> uu_ uua_))\n        (run S') (run S)", "apply(fold rel_fun_conversep prod.rel_conversep)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S S'.\n       (A\\<inverse>\\<inverse> ===>\n        rel_prod B\\<inverse>\\<inverse> (rel_dds A B)\\<inverse>\\<inverse>)\n        (run S') (run S) \\<Longrightarrow>\n       (A\\<inverse>\\<inverse> ===>\n        rel_prod B\\<inverse>\\<inverse>\n         (\\<lambda>uu_ uua_.\n             rel_dds A B uua_ uu_ \\<or>\n             rel_dds A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> uu_ uua_))\n        (run S') (run S)", "apply(erule BNF_Def.rel_fun_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>S S' x y.\n       A\\<inverse>\\<inverse> x y \\<longrightarrow> A\\<inverse>\\<inverse> x y\n 2. \\<And>S S' x y.\n       rel_prod B\\<inverse>\\<inverse> (rel_dds A B)\\<inverse>\\<inverse> x\n        y \\<Longrightarrow>\n       rel_prod B\\<inverse>\\<inverse>\n        (\\<lambda>uu_ uua_.\n            rel_dds A B uua_ uu_ \\<or>\n            rel_dds A\\<inverse>\\<inverse> B\\<inverse>\\<inverse> uu_ uua_)\n        x y", "apply(auto simp del: conversep_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma DDS_parametric [transfer_rule]:\n  \"((A ===> rel_prod B (rel_dds A B)) ===> rel_dds A B) DDS DDS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> rel_prod B (rel_dds A B)) ===> rel_dds A B) DDS DDS", "by(auto intro!: rel_dds.intros)"], ["", "lemma run_parametric [transfer_rule]:\n  \"(rel_dds A B ===> A ===> rel_prod B (rel_dds A B)) run run\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_dds A B ===> A ===> rel_prod B (rel_dds A B)) run run", "by(auto elim: rel_dds.cases)"], ["", "lemma corec_dds_parametric [transfer_rule]:\n  \"((S ===> A ===> rel_prod B (rel_sum (rel_dds A B) S)) ===> S ===> rel_dds A B) corec_dds corec_dds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> A ===> rel_prod B (rel_sum (rel_dds A B) S)) ===>\n     S ===> rel_dds A B)\n     corec_dds corec_dds", "apply(rule rel_funI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>(S ===> A ===> rel_prod B (rel_sum (rel_dds A B) S)) x y;\n        S xa ya\\<rbrakk>\n       \\<Longrightarrow> rel_dds A B (corec_dds x xa) (corec_dds y ya)", "subgoal premises prems for f g s s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dds A B (corec_dds f s) (corec_dds g s')", "using prems(2)"], ["proof (prove)\nusing this:\n  S s s'\n\ngoal (1 subgoal):\n 1. rel_dds A B (corec_dds f s) (corec_dds g s')", "apply(coinduction arbitrary: s s')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       S s s' \\<Longrightarrow>\n       \\<exists>Sa S'.\n          corec_dds f s = Sa \\<and>\n          corec_dds g s' = S' \\<and>\n          (A ===>\n           rel_prod B\n            (\\<lambda>uu_ uua_.\n                (\\<exists>s s'.\n                    uu_ = corec_dds f s \\<and>\n                    uua_ = corec_dds g s' \\<and> S s s') \\<or>\n                rel_dds A B uu_ uua_))\n           (run Sa) (run S')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       S s s' \\<Longrightarrow>\n       (A ===>\n        rel_prod B\n         (\\<lambda>uu_ uua_.\n             (\\<exists>s.\n                 uu_ = corec_dds f s \\<and>\n                 (\\<exists>s'. uua_ = corec_dds g s' \\<and> S s s')) \\<or>\n             rel_dds A B uu_ uua_))\n        (map_prod id\n          (\\<lambda>x.\n              case x of Inl dds \\<Rightarrow> dds\n              | Inr a \\<Rightarrow> corec_dds f a) \\<circ>\n         f s)\n        (map_prod id (case_sum (\\<lambda>dds. dds) (corec_dds g)) \\<circ>\n         g s')", "apply(rule comp_transfer[THEN rel_funD, THEN rel_funD, rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'. S s s' \\<Longrightarrow> (A ===> ?B5 s s') (f s) (g s')\n 2. \\<And>s s'.\n       S s s' \\<Longrightarrow>\n       (?B5 s s' ===>\n        rel_prod B\n         (\\<lambda>uu_ uua_.\n             (\\<exists>s.\n                 uu_ = corec_dds f s \\<and>\n                 (\\<exists>s'. uua_ = corec_dds g s' \\<and> S s s')) \\<or>\n             rel_dds A B uu_ uua_))\n        (map_prod id\n          (\\<lambda>x.\n              case x of Inl dds \\<Rightarrow> dds\n              | Inr a \\<Rightarrow> corec_dds f a))\n        (map_prod id (case_sum (\\<lambda>dds. dds) (corec_dds g)))", "apply(erule prems(1)[THEN rel_funD])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       S s s' \\<Longrightarrow>\n       (rel_prod B (rel_sum (rel_dds A B) S) ===>\n        rel_prod B\n         (\\<lambda>uu_ uua_.\n             (\\<exists>s.\n                 uu_ = corec_dds f s \\<and>\n                 (\\<exists>s'. uua_ = corec_dds g s' \\<and> S s s')) \\<or>\n             rel_dds A B uu_ uua_))\n        (map_prod id\n          (\\<lambda>x.\n              case x of Inl dds \\<Rightarrow> dds\n              | Inr a \\<Rightarrow> corec_dds f a))\n        (map_prod id (case_sum (\\<lambda>dds. dds) (corec_dds g)))", "apply(rule prod.map_transfer[THEN rel_funD, THEN rel_funD, OF id_transfer])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       S s s' \\<Longrightarrow>\n       (rel_sum (rel_dds A B) S ===>\n        (\\<lambda>uu_ uua_.\n            (\\<exists>s.\n                uu_ = corec_dds f s \\<and>\n                (\\<exists>s'. uua_ = corec_dds g s' \\<and> S s s')) \\<or>\n            rel_dds A B uu_ uua_))\n        (\\<lambda>x.\n            case x of Inl dds \\<Rightarrow> dds\n            | Inr a \\<Rightarrow> corec_dds f a)\n        (case_sum (\\<lambda>dds. dds) (corec_dds g))", "apply(fastforce elim!: rel_sum.cases)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_dds_parametric [transfer_rule]:\n  \"((A' ===> A) ===> (B ===> B') ===> rel_dds A B ===> rel_dds A' B') map_dds map_dds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A' ===> A) ===> (B ===> B') ===> rel_dds A B ===> rel_dds A' B')\n     map_dds map_dds", "unfolding map_dds_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A' ===> A) ===> (B ===> B') ===> rel_dds A B ===> rel_dds A' B')\n     (\\<lambda>uu uua uub.\n         corec_dds\n          (\\<lambda>(f, g, S) a.\n              map_prod g (\\<lambda>uu. Inr (f, g, uu)) (run S (f a)))\n          (uu, uua, uub))\n     (\\<lambda>uu uua uub.\n         corec_dds\n          (\\<lambda>(f, g, S) a.\n              map_prod g (\\<lambda>uu. Inr (f, g, uu)) (run S (f a)))\n          (uu, uua, uub))", "by transfer_prover"], ["", "lemmas map_dds_rel_cong = map_dds_parametric[unfolded rel_fun_def, rule_format, rotated -1]"], ["", "lemma rel_dds_Grp:\n  \"rel_dds (Grp UNIV f)\\<inverse>\\<inverse> (Grp UNIV g) = Grp UNIV (map_dds f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dds (Grp UNIV f)\\<inverse>\\<inverse> (Grp UNIV g) =\n    Grp UNIV (map_dds f g)", "apply(rule ext iffI)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       rel_dds (Grp UNIV f)\\<inverse>\\<inverse> (Grp UNIV g) x\n        xa \\<Longrightarrow>\n       Grp UNIV (map_dds f g) x xa\n 2. \\<And>x xa.\n       Grp UNIV (map_dds f g) x xa \\<Longrightarrow>\n       rel_dds (Grp UNIV f)\\<inverse>\\<inverse> (Grp UNIV g) x xa", "apply(simp add: Grp_apply)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       rel_dds (Grp UNIV f)\\<inverse>\\<inverse> (Grp UNIV g) x\n        xa \\<Longrightarrow>\n       xa = map_dds f g x\n 2. \\<And>x xa.\n       Grp UNIV (map_dds f g) x xa \\<Longrightarrow>\n       rel_dds (Grp UNIV f)\\<inverse>\\<inverse> (Grp UNIV g) x xa", "apply(rule sym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       rel_dds (Grp UNIV f)\\<inverse>\\<inverse> (Grp UNIV g) x\n        xa \\<Longrightarrow>\n       map_dds f g x = xa\n 2. \\<And>x xa.\n       Grp UNIV (map_dds f g) x xa \\<Longrightarrow>\n       rel_dds (Grp UNIV f)\\<inverse>\\<inverse> (Grp UNIV g) x xa", "apply(fold rel_dds_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       rel_dds (Grp UNIV f)\\<inverse>\\<inverse> (Grp UNIV g) x\n        xa \\<Longrightarrow>\n       rel_dds (=) (=) (map_dds f g x) xa\n 2. \\<And>x xa.\n       Grp UNIV (map_dds f g) x xa \\<Longrightarrow>\n       rel_dds (Grp UNIV f)\\<inverse>\\<inverse> (Grp UNIV g) x xa", "apply(rewrite in \"rel_dds _ _ _ \\<hole>\" map_dds_id[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       rel_dds (Grp UNIV f)\\<inverse>\\<inverse> (Grp UNIV g) x\n        xa \\<Longrightarrow>\n       rel_dds (=) (=) (map_dds f g x) (map_dds id id xa)\n 2. \\<And>x xa.\n       Grp UNIV (map_dds f g) x xa \\<Longrightarrow>\n       rel_dds (Grp UNIV f)\\<inverse>\\<inverse> (Grp UNIV g) x xa", "apply(erule map_dds_parametric[THEN rel_funD, THEN rel_funD, THEN rel_funD, rotated -1];\n      simp add: Grp_apply rel_fun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       Grp UNIV (map_dds f g) x xa \\<Longrightarrow>\n       rel_dds (Grp UNIV f)\\<inverse>\\<inverse> (Grp UNIV g) x xa", "apply(erule GrpE; clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       rel_dds (Grp UNIV f)\\<inverse>\\<inverse> (Grp UNIV g) x\n        (map_dds f g x)", "apply(rewrite in \"rel_dds _ _ \\<hole>\" map_dds_id[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       rel_dds (Grp UNIV f)\\<inverse>\\<inverse> (Grp UNIV g)\n        (map_dds id id x) (map_dds f g x)", "apply(rule map_dds_parametric[THEN rel_funD, THEN rel_funD, THEN rel_funD, rotated -1])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. rel_dds (?A84 x) (?B84 x) x x\n 2. \\<And>x. ((Grp UNIV f)\\<inverse>\\<inverse> ===> ?A84 x) id f\n 3. \\<And>x. (?B84 x ===> Grp UNIV g) id g", "apply(subst rel_dds_eq; simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. ((Grp UNIV f)\\<inverse>\\<inverse> ===> (=)) id f\n 2. \\<And>x. ((=) ===> Grp UNIV g) id g", "apply(simp_all add: Grp_apply rel_fun_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rel_dds_pos_distr [relator_distr]:\n  \"rel_dds A B OO rel_dds C D \\<le> rel_dds (A OO C) (B OO D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dds A B OO rel_dds C D \\<le> rel_dds (A OO C) (B OO D)", "apply (rule predicate2I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (rel_dds A B OO rel_dds C D) x y \\<Longrightarrow>\n       rel_dds (A OO C) (B OO D) x y", "apply (erule relcomppE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y b.\n       \\<lbrakk>rel_dds A B x b; rel_dds C D b y\\<rbrakk>\n       \\<Longrightarrow> rel_dds (A OO C) (B OO D) x y", "subgoal for x y z"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rel_dds A B x z; rel_dds C D z y\\<rbrakk>\n    \\<Longrightarrow> rel_dds (A OO C) (B OO D) x y", "apply (coinduction arbitrary: x y z)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>rel_dds A B x z; rel_dds C D z y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S S'.\n                            x = S \\<and>\n                            y = S' \\<and>\n                            (A OO C ===>\n                             rel_prod (B OO D)\n                              (\\<lambda>uu_ uua_.\n                                  (\\<exists>x y z.\nuu_ = x \\<and> uua_ = y \\<and> rel_dds A B x z \\<and> rel_dds C D z y) \\<or>\n                                  rel_dds (A OO C) (B OO D) uu_ uua_))\n                             (run S) (run S')", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>rel_dds A B x z; rel_dds C D z y\\<rbrakk>\n       \\<Longrightarrow> (A OO C ===>\n                          rel_prod (B OO D)\n                           (\\<lambda>uu_ uua_.\n                               (\\<exists>z.\n                                   rel_dds A B uu_ z \\<and>\n                                   rel_dds C D z uua_) \\<or>\n                               rel_dds (A OO C) (B OO D) uu_ uua_))\n                          (run x) (run y)", "apply (rule rel_fun_mono[THEN predicate2D, OF order_refl,\n          of \"rel_prod B (rel_dds A B) OO rel_prod D (rel_dds C D)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>rel_dds A B x z; rel_dds C D z y\\<rbrakk>\n       \\<Longrightarrow> rel_prod B (rel_dds A B) OO\n                         rel_prod D (rel_dds C D)\n                         \\<le> rel_prod (B OO D)\n                                (\\<lambda>uu_ uua_.\n                                    (\\<exists>z.\n  rel_dds A B uu_ z \\<and> rel_dds C D z uua_) \\<or>\n                                    rel_dds (A OO C) (B OO D) uu_ uua_)\n 2. \\<And>x y z.\n       \\<lbrakk>rel_dds A B x z; rel_dds C D z y\\<rbrakk>\n       \\<Longrightarrow> (A OO C ===>\n                          rel_prod B (rel_dds A B) OO\n                          rel_prod D (rel_dds C D))\n                          (run x) (run y)", "apply (rule order_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>rel_dds A B x z; rel_dds C D z y\\<rbrakk>\n       \\<Longrightarrow> rel_prod B (rel_dds A B) OO\n                         rel_prod D (rel_dds C D)\n                         \\<le> ?y7 x y z\n 2. \\<And>x y z.\n       \\<lbrakk>rel_dds A B x z; rel_dds C D z y\\<rbrakk>\n       \\<Longrightarrow> ?y7 x y z\n                         \\<le> rel_prod (B OO D)\n                                (\\<lambda>uu_ uua_.\n                                    (\\<exists>z.\n  rel_dds A B uu_ z \\<and> rel_dds C D z uua_) \\<or>\n                                    rel_dds (A OO C) (B OO D) uu_ uua_)\n 3. \\<And>x y z.\n       \\<lbrakk>rel_dds A B x z; rel_dds C D z y\\<rbrakk>\n       \\<Longrightarrow> (A OO C ===>\n                          rel_prod B (rel_dds A B) OO\n                          rel_prod D (rel_dds C D))\n                          (run x) (run y)", "apply (rule prod.rel_compp[symmetric, THEN eq_refl])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>rel_dds A B x z; rel_dds C D z y\\<rbrakk>\n       \\<Longrightarrow> rel_prod (B OO D) (rel_dds A B OO rel_dds C D)\n                         \\<le> rel_prod (B OO D)\n                                (\\<lambda>uu_ uua_.\n                                    (\\<exists>z.\n  rel_dds A B uu_ z \\<and> rel_dds C D z uua_) \\<or>\n                                    rel_dds (A OO C) (B OO D) uu_ uua_)\n 2. \\<And>x y z.\n       \\<lbrakk>rel_dds A B x z; rel_dds C D z y\\<rbrakk>\n       \\<Longrightarrow> (A OO C ===>\n                          rel_prod B (rel_dds A B) OO\n                          rel_prod D (rel_dds C D))\n                          (run x) (run y)", "apply (rule prod.rel_mono[OF order_refl])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>rel_dds A B x z; rel_dds C D z y\\<rbrakk>\n       \\<Longrightarrow> rel_dds A B OO rel_dds C D\n                         \\<le> (\\<lambda>uu_ uua_.\n                                   (\\<exists>z.\n rel_dds A B uu_ z \\<and> rel_dds C D z uua_) \\<or>\n                                   rel_dds (A OO C) (B OO D) uu_ uua_)\n 2. \\<And>x y z.\n       \\<lbrakk>rel_dds A B x z; rel_dds C D z y\\<rbrakk>\n       \\<Longrightarrow> (A OO C ===>\n                          rel_prod B (rel_dds A B) OO\n                          rel_prod D (rel_dds C D))\n                          (run x) (run y)", "apply (blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>rel_dds A B x z; rel_dds C D z y\\<rbrakk>\n       \\<Longrightarrow> (A OO C ===>\n                          rel_prod B (rel_dds A B) OO\n                          rel_prod D (rel_dds C D))\n                          (run x) (run y)", "apply (rule rel_fun_pos_distr[THEN predicate2D])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>rel_dds A B x z; rel_dds C D z y\\<rbrakk>\n       \\<Longrightarrow> rel_fun_pos_distr_cond A C (?uu26 x y z)\n 2. \\<And>x y z.\n       \\<lbrakk>rel_dds A B x z; rel_dds C D z y\\<rbrakk>\n       \\<Longrightarrow> ((A ===> rel_prod B (rel_dds A B)) OO\n                          (C ===> rel_prod D (rel_dds C D)))\n                          (run x) (run y)", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>rel_dds A B x z; rel_dds C D z y\\<rbrakk>\n       \\<Longrightarrow> ((A ===> rel_prod B (rel_dds A B)) OO\n                          (C ===> rel_prod D (rel_dds C D)))\n                          (run x) (run y)", "apply (rule relcomppI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>rel_dds A B x z; rel_dds C D z y\\<rbrakk>\n       \\<Longrightarrow> (A ===> rel_prod B (rel_dds A B)) (run x)\n                          (?b29 x y z)\n 2. \\<And>x y z.\n       \\<lbrakk>rel_dds A B x z; rel_dds C D z y\\<rbrakk>\n       \\<Longrightarrow> (C ===> rel_prod D (rel_dds C D)) (?b29 x y z)\n                          (run y)", "apply (auto elim: rel_dds.cases)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Quotient_dds [quot_map]:\n  assumes \"Quotient R1 Abs1 Rep1 T1\" and \"Quotient R2 Abs2 Rep2 T2\"\n  shows \"Quotient (rel_dds R1 R2) (map_dds Rep1 Abs2) (map_dds Abs1 Rep2) (rel_dds T1 T2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Quotient (rel_dds R1 R2) (map_dds Rep1 Abs2) (map_dds Abs1 Rep2)\n     (rel_dds T1 T2)", "unfolding Quotient_alt_def5"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dds T1 T2 \\<le> Grp UNIV (map_dds Rep1 Abs2) \\<and>\n    Grp UNIV (map_dds Abs1 Rep2)\n    \\<le> (rel_dds T1 T2)\\<inverse>\\<inverse> \\<and>\n    rel_dds R1 R2 = rel_dds T1 T2 OO (rel_dds T1 T2)\\<inverse>\\<inverse>", "proof (intro conjI, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. rel_dds T1 T2 \\<le> Grp UNIV (map_dds Rep1 Abs2)\n 2. Grp UNIV (map_dds Abs1 Rep2) \\<le> (rel_dds T1 T2)\\<inverse>\\<inverse>\n 3. rel_dds R1 R2 = rel_dds T1 T2 OO (rel_dds T1 T2)\\<inverse>\\<inverse>", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. rel_dds T1 T2 \\<le> Grp UNIV (map_dds Rep1 Abs2)\n 2. Grp UNIV (map_dds Abs1 Rep2) \\<le> (rel_dds T1 T2)\\<inverse>\\<inverse>\n 3. rel_dds R1 R2 = rel_dds T1 T2 OO (rel_dds T1 T2)\\<inverse>\\<inverse>", "have \"rel_dds T1 T2 \\<le> rel_dds (Grp UNIV Rep1)\\<inverse>\\<inverse> (Grp UNIV Abs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dds T1 T2\n    \\<le> rel_dds (Grp UNIV Rep1)\\<inverse>\\<inverse> (Grp UNIV Abs2)", "apply (rule rel_dds_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (Grp UNIV Rep1)\\<inverse>\\<inverse> \\<le> T1\n 2. T2 \\<le> Grp UNIV Abs2", "apply (rule assms(1)[unfolded Quotient_alt_def5, THEN conjunct2, THEN conjunct1,\n          unfolded conversep_le_swap])"], ["proof (prove)\ngoal (1 subgoal):\n 1. T2 \\<le> Grp UNIV Abs2", "apply (rule assms(2)[unfolded Quotient_alt_def5, THEN conjunct1])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_dds T1 T2\n  \\<le> rel_dds (Grp UNIV Rep1)\\<inverse>\\<inverse> (Grp UNIV Abs2)\n\ngoal (3 subgoals):\n 1. rel_dds T1 T2 \\<le> Grp UNIV (map_dds Rep1 Abs2)\n 2. Grp UNIV (map_dds Abs1 Rep2) \\<le> (rel_dds T1 T2)\\<inverse>\\<inverse>\n 3. rel_dds R1 R2 = rel_dds T1 T2 OO (rel_dds T1 T2)\\<inverse>\\<inverse>", "also"], ["proof (state)\nthis:\n  rel_dds T1 T2\n  \\<le> rel_dds (Grp UNIV Rep1)\\<inverse>\\<inverse> (Grp UNIV Abs2)\n\ngoal (3 subgoals):\n 1. rel_dds T1 T2 \\<le> Grp UNIV (map_dds Rep1 Abs2)\n 2. Grp UNIV (map_dds Abs1 Rep2) \\<le> (rel_dds T1 T2)\\<inverse>\\<inverse>\n 3. rel_dds R1 R2 = rel_dds T1 T2 OO (rel_dds T1 T2)\\<inverse>\\<inverse>", "have \"... = Grp UNIV (map_dds Rep1 Abs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dds (Grp UNIV Rep1)\\<inverse>\\<inverse> (Grp UNIV Abs2) =\n    Grp UNIV (map_dds Rep1 Abs2)", "using rel_dds_Grp"], ["proof (prove)\nusing this:\n  rel_dds (Grp UNIV ?f)\\<inverse>\\<inverse> (Grp UNIV ?g) =\n  Grp UNIV (map_dds ?f ?g)\n\ngoal (1 subgoal):\n 1. rel_dds (Grp UNIV Rep1)\\<inverse>\\<inverse> (Grp UNIV Abs2) =\n    Grp UNIV (map_dds Rep1 Abs2)", "."], ["proof (state)\nthis:\n  rel_dds (Grp UNIV Rep1)\\<inverse>\\<inverse> (Grp UNIV Abs2) =\n  Grp UNIV (map_dds Rep1 Abs2)\n\ngoal (3 subgoals):\n 1. rel_dds T1 T2 \\<le> Grp UNIV (map_dds Rep1 Abs2)\n 2. Grp UNIV (map_dds Abs1 Rep2) \\<le> (rel_dds T1 T2)\\<inverse>\\<inverse>\n 3. rel_dds R1 R2 = rel_dds T1 T2 OO (rel_dds T1 T2)\\<inverse>\\<inverse>", "finally"], ["proof (chain)\npicking this:\n  rel_dds T1 T2 \\<le> Grp UNIV (map_dds Rep1 Abs2)", "show ?case"], ["proof (prove)\nusing this:\n  rel_dds T1 T2 \\<le> Grp UNIV (map_dds Rep1 Abs2)\n\ngoal (1 subgoal):\n 1. rel_dds T1 T2 \\<le> Grp UNIV (map_dds Rep1 Abs2)", "."], ["proof (state)\nthis:\n  rel_dds T1 T2 \\<le> Grp UNIV (map_dds Rep1 Abs2)\n\ngoal (2 subgoals):\n 1. Grp UNIV (map_dds Abs1 Rep2) \\<le> (rel_dds T1 T2)\\<inverse>\\<inverse>\n 2. rel_dds R1 R2 = rel_dds T1 T2 OO (rel_dds T1 T2)\\<inverse>\\<inverse>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. Grp UNIV (map_dds Abs1 Rep2) \\<le> (rel_dds T1 T2)\\<inverse>\\<inverse>\n 2. rel_dds R1 R2 = rel_dds T1 T2 OO (rel_dds T1 T2)\\<inverse>\\<inverse>", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. Grp UNIV (map_dds Abs1 Rep2) \\<le> (rel_dds T1 T2)\\<inverse>\\<inverse>\n 2. rel_dds R1 R2 = rel_dds T1 T2 OO (rel_dds T1 T2)\\<inverse>\\<inverse>", "have \"Grp UNIV (map_dds Abs1 Rep2) = rel_dds (Grp UNIV Abs1)\\<inverse>\\<inverse> (Grp UNIV Rep2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Grp UNIV (map_dds Abs1 Rep2) =\n    rel_dds (Grp UNIV Abs1)\\<inverse>\\<inverse> (Grp UNIV Rep2)", "using rel_dds_Grp[symmetric]"], ["proof (prove)\nusing this:\n  Grp UNIV (map_dds ?f ?g) =\n  rel_dds (Grp UNIV ?f)\\<inverse>\\<inverse> (Grp UNIV ?g)\n\ngoal (1 subgoal):\n 1. Grp UNIV (map_dds Abs1 Rep2) =\n    rel_dds (Grp UNIV Abs1)\\<inverse>\\<inverse> (Grp UNIV Rep2)", "."], ["proof (state)\nthis:\n  Grp UNIV (map_dds Abs1 Rep2) =\n  rel_dds (Grp UNIV Abs1)\\<inverse>\\<inverse> (Grp UNIV Rep2)\n\ngoal (2 subgoals):\n 1. Grp UNIV (map_dds Abs1 Rep2) \\<le> (rel_dds T1 T2)\\<inverse>\\<inverse>\n 2. rel_dds R1 R2 = rel_dds T1 T2 OO (rel_dds T1 T2)\\<inverse>\\<inverse>", "also"], ["proof (state)\nthis:\n  Grp UNIV (map_dds Abs1 Rep2) =\n  rel_dds (Grp UNIV Abs1)\\<inverse>\\<inverse> (Grp UNIV Rep2)\n\ngoal (2 subgoals):\n 1. Grp UNIV (map_dds Abs1 Rep2) \\<le> (rel_dds T1 T2)\\<inverse>\\<inverse>\n 2. rel_dds R1 R2 = rel_dds T1 T2 OO (rel_dds T1 T2)\\<inverse>\\<inverse>", "have \"... \\<le> rel_dds T1\\<inverse>\\<inverse> T2\\<inverse>\\<inverse>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dds (Grp UNIV Abs1)\\<inverse>\\<inverse> (Grp UNIV Rep2)\n    \\<le> rel_dds T1\\<inverse>\\<inverse> T2\\<inverse>\\<inverse>", "apply (rule rel_dds_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. T1\\<inverse>\\<inverse> \\<le> (Grp UNIV Abs1)\\<inverse>\\<inverse>\n 2. Grp UNIV Rep2 \\<le> T2\\<inverse>\\<inverse>", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. T1 \\<le> Grp UNIV Abs1\n 2. Grp UNIV Rep2 \\<le> T2\\<inverse>\\<inverse>", "apply (rule assms(1)[unfolded Quotient_alt_def5, THEN conjunct1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Grp UNIV Rep2 \\<le> T2\\<inverse>\\<inverse>", "apply (rule assms(2)[unfolded Quotient_alt_def5, THEN conjunct2, THEN conjunct1])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_dds (Grp UNIV Abs1)\\<inverse>\\<inverse> (Grp UNIV Rep2)\n  \\<le> rel_dds T1\\<inverse>\\<inverse> T2\\<inverse>\\<inverse>\n\ngoal (2 subgoals):\n 1. Grp UNIV (map_dds Abs1 Rep2) \\<le> (rel_dds T1 T2)\\<inverse>\\<inverse>\n 2. rel_dds R1 R2 = rel_dds T1 T2 OO (rel_dds T1 T2)\\<inverse>\\<inverse>", "finally"], ["proof (chain)\npicking this:\n  Grp UNIV (map_dds Abs1 Rep2)\n  \\<le> rel_dds T1\\<inverse>\\<inverse> T2\\<inverse>\\<inverse>", "show ?case"], ["proof (prove)\nusing this:\n  Grp UNIV (map_dds Abs1 Rep2)\n  \\<le> rel_dds T1\\<inverse>\\<inverse> T2\\<inverse>\\<inverse>\n\ngoal (1 subgoal):\n 1. Grp UNIV (map_dds Abs1 Rep2) \\<le> (rel_dds T1 T2)\\<inverse>\\<inverse>", "by (simp add: rel_dds_conversep)"], ["proof (state)\nthis:\n  Grp UNIV (map_dds Abs1 Rep2) \\<le> (rel_dds T1 T2)\\<inverse>\\<inverse>\n\ngoal (1 subgoal):\n 1. rel_dds R1 R2 = rel_dds T1 T2 OO (rel_dds T1 T2)\\<inverse>\\<inverse>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_dds R1 R2 = rel_dds T1 T2 OO (rel_dds T1 T2)\\<inverse>\\<inverse>", "case 3"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. rel_dds R1 R2 = rel_dds T1 T2 OO (rel_dds T1 T2)\\<inverse>\\<inverse>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dds R1 R2 = rel_dds T1 T2 OO (rel_dds T1 T2)\\<inverse>\\<inverse>", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rel_dds R1 R2 \\<le> rel_dds T1 T2 OO (rel_dds T1 T2)\\<inverse>\\<inverse>\n 2. rel_dds T1 T2 OO (rel_dds T1 T2)\\<inverse>\\<inverse> \\<le> rel_dds R1 R2", "apply (rule predicate2I)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       rel_dds R1 R2 x y \\<Longrightarrow>\n       (rel_dds T1 T2 OO (rel_dds T1 T2)\\<inverse>\\<inverse>) x y\n 2. rel_dds T1 T2 OO (rel_dds T1 T2)\\<inverse>\\<inverse> \\<le> rel_dds R1 R2", "apply (rule relcomppI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y. rel_dds R1 R2 x y \\<Longrightarrow> rel_dds T1 T2 x (?b5 x y)\n 2. \\<And>x y.\n       rel_dds R1 R2 x y \\<Longrightarrow>\n       (rel_dds T1 T2)\\<inverse>\\<inverse> (?b5 x y) y\n 3. rel_dds T1 T2 OO (rel_dds T1 T2)\\<inverse>\\<inverse> \\<le> rel_dds R1 R2", "apply (subst map_dds_id[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       rel_dds R1 R2 x y \\<Longrightarrow>\n       rel_dds T1 T2 (map_dds id id x) (?b10 x x y (?y9 x y))\n 2. \\<And>x y.\n       rel_dds R1 R2 x y \\<Longrightarrow>\n       (rel_dds T1 T2)\\<inverse>\\<inverse> (?b10 x x y (?y9 x y)) y\n 3. rel_dds T1 T2 OO (rel_dds T1 T2)\\<inverse>\\<inverse> \\<le> rel_dds R1 R2", "apply (erule map_dds_rel_cong)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y xa ya. T1 xa ya \\<Longrightarrow> R1 (id xa) (?y14 x x y y ya)\n 2. \\<And>x y xa ya.\n       R2 xa ya \\<Longrightarrow> T2 (id xa) (?ya13 x x y y ya)\n 3. \\<And>x y.\n       rel_dds R1 R2 x y \\<Longrightarrow>\n       (rel_dds T1 T2)\\<inverse>\\<inverse>\n        (map_dds (?y14 x x y y) (?ya13 x x y y) y) y\n 4. rel_dds T1 T2 OO (rel_dds T1 T2)\\<inverse>\\<inverse> \\<le> rel_dds R1 R2", "apply (simp_all)[2]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y xa ya. T1 xa ya \\<Longrightarrow> R1 xa (?y14 x x y y ya)\n 2. \\<And>x y xa ya. R2 xa ya \\<Longrightarrow> T2 xa (?ya13 x x y y ya)\n 3. \\<And>x y.\n       rel_dds R1 R2 x y \\<Longrightarrow>\n       (rel_dds T1 T2)\\<inverse>\\<inverse>\n        (map_dds (?y14 x x y y) (?ya13 x x y y) y) y\n 4. rel_dds T1 T2 OO (rel_dds T1 T2)\\<inverse>\\<inverse> \\<le> rel_dds R1 R2", "apply (erule assms(1)[THEN Quotient_rep_equiv1])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y xa ya. R2 xa ya \\<Longrightarrow> T2 xa (?ya13 x x y y ya)\n 2. \\<And>x y.\n       rel_dds R1 R2 x y \\<Longrightarrow>\n       (rel_dds T1 T2)\\<inverse>\\<inverse> (map_dds Rep1 (?ya13 x x y y) y)\n        y\n 3. rel_dds T1 T2 OO (rel_dds T1 T2)\\<inverse>\\<inverse> \\<le> rel_dds R1 R2", "apply (erule assms(2)[THEN Quotient_equiv_abs1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       rel_dds R1 R2 x y \\<Longrightarrow>\n       (rel_dds T1 T2)\\<inverse>\\<inverse> (map_dds Rep1 Abs2 y) y\n 2. rel_dds T1 T2 OO (rel_dds T1 T2)\\<inverse>\\<inverse> \\<le> rel_dds R1 R2", "apply (subst rel_dds_conversep[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       rel_dds R1 R2 x y \\<Longrightarrow>\n       rel_dds T1\\<inverse>\\<inverse> T2\\<inverse>\\<inverse>\n        (map_dds Rep1 Abs2 y) y\n 2. rel_dds T1 T2 OO (rel_dds T1 T2)\\<inverse>\\<inverse> \\<le> rel_dds R1 R2", "subgoal for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dds R1 R2 x y \\<Longrightarrow>\n    rel_dds T1\\<inverse>\\<inverse> T2\\<inverse>\\<inverse>\n     (map_dds Rep1 Abs2 y) y", "apply (subgoal_tac \"map_dds Rep1 Abs2 y = map_dds Rep1 Abs2 x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rel_dds R1 R2 x y;\n     map_dds Rep1 Abs2 y = map_dds Rep1 Abs2 x\\<rbrakk>\n    \\<Longrightarrow> rel_dds T1\\<inverse>\\<inverse> T2\\<inverse>\\<inverse>\n                       (map_dds Rep1 Abs2 y) y\n 2. rel_dds R1 R2 x y \\<Longrightarrow>\n    map_dds Rep1 Abs2 y = map_dds Rep1 Abs2 x", "apply (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rel_dds R1 R2 x y;\n     map_dds Rep1 Abs2 y = map_dds Rep1 Abs2 x\\<rbrakk>\n    \\<Longrightarrow> rel_dds T1\\<inverse>\\<inverse> T2\\<inverse>\\<inverse>\n                       (map_dds Rep1 Abs2 x) y\n 2. rel_dds R1 R2 x y \\<Longrightarrow>\n    map_dds Rep1 Abs2 y = map_dds Rep1 Abs2 x", "apply (subst (3) map_dds_id[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rel_dds R1 R2 x y;\n     map_dds Rep1 Abs2 y = map_dds Rep1 Abs2 x\\<rbrakk>\n    \\<Longrightarrow> rel_dds T1\\<inverse>\\<inverse> T2\\<inverse>\\<inverse>\n                       (map_dds Rep1 Abs2 x) (map_dds id id y)\n 2. rel_dds R1 R2 x y \\<Longrightarrow>\n    map_dds Rep1 Abs2 y = map_dds Rep1 Abs2 x", "apply (erule map_dds_rel_cong)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa ya.\n       \\<lbrakk>map_dds Rep1 Abs2 y = map_dds Rep1 Abs2 x;\n        T1\\<inverse>\\<inverse> xa ya\\<rbrakk>\n       \\<Longrightarrow> R1 (Rep1 xa) (id ya)\n 2. \\<And>xa ya.\n       \\<lbrakk>map_dds Rep1 Abs2 y = map_dds Rep1 Abs2 x; R2 xa ya\\<rbrakk>\n       \\<Longrightarrow> T2\\<inverse>\\<inverse> (Abs2 xa) (id ya)\n 3. rel_dds R1 R2 x y \\<Longrightarrow>\n    map_dds Rep1 Abs2 y = map_dds Rep1 Abs2 x", "apply (simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa ya.\n       \\<lbrakk>map_dds Rep1 Abs2 y = map_dds Rep1 Abs2 x; T1 ya xa\\<rbrakk>\n       \\<Longrightarrow> R1 (Rep1 xa) ya\n 2. \\<And>xa ya.\n       \\<lbrakk>map_dds Rep1 Abs2 y = map_dds Rep1 Abs2 x; R2 xa ya\\<rbrakk>\n       \\<Longrightarrow> T2 ya (Abs2 xa)\n 3. rel_dds R1 R2 x y \\<Longrightarrow>\n    map_dds Rep1 Abs2 y = map_dds Rep1 Abs2 x", "apply (erule assms(1)[THEN Quotient_rep_equiv2])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa ya.\n       \\<lbrakk>map_dds Rep1 Abs2 y = map_dds Rep1 Abs2 x; R2 xa ya\\<rbrakk>\n       \\<Longrightarrow> T2 ya (Abs2 xa)\n 2. rel_dds R1 R2 x y \\<Longrightarrow>\n    map_dds Rep1 Abs2 y = map_dds Rep1 Abs2 x", "apply (erule assms(2)[THEN Quotient_equiv_abs2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dds R1 R2 x y \\<Longrightarrow>\n    map_dds Rep1 Abs2 y = map_dds Rep1 Abs2 x", "apply (rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dds R1 R2 x y \\<Longrightarrow>\n    map_dds Rep1 Abs2 x = map_dds Rep1 Abs2 y", "apply (subst rel_dds_eq[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dds R1 R2 x y \\<Longrightarrow>\n    rel_dds (=) (=) (map_dds Rep1 Abs2 x) (map_dds Rep1 Abs2 y)", "apply (erule map_dds_rel_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. x = y \\<Longrightarrow> R1 (Rep1 x) (Rep1 y)\n 2. \\<And>x y. R2 x y \\<Longrightarrow> Abs2 x = Abs2 y", "apply (simp, rule assms(1)[THEN Quotient_rep_reflp])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. R2 x y \\<Longrightarrow> Abs2 x = Abs2 y", "apply (erule assms(2)[THEN Quotient_rel_abs])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dds T1 T2 OO (rel_dds T1 T2)\\<inverse>\\<inverse> \\<le> rel_dds R1 R2", "apply (unfold rel_dds_conversep[symmetric]\n        assms[unfolded Quotient_alt_def5, THEN conjunct2, THEN conjunct2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dds T1 T2 OO rel_dds T1\\<inverse>\\<inverse> T2\\<inverse>\\<inverse>\n    \\<le> rel_dds (T1 OO T1\\<inverse>\\<inverse>)\n           (T2 OO T2\\<inverse>\\<inverse>)", "apply (rule rel_dds_pos_distr)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_dds R1 R2 = rel_dds T1 T2 OO (rel_dds T1 T2)\\<inverse>\\<inverse>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>This is just the co-iterator.\\<close>"], ["", "primcorec dds_of :: \"('s \\<Rightarrow> 'a \\<Rightarrow> ('b \\<times> 's)) \\<Rightarrow> 's \\<Rightarrow> ('a, 'b) dds\" where\n  \"run (dds_of f s) = map_prod id (dds_of f) \\<circ> f s\""], ["", "lemma dds_of_parametric [transfer_rule]:\n  \"((S ===> A ===> rel_prod B S) ===> S ===> rel_dds A B) dds_of dds_of\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> A ===> rel_prod B S) ===> S ===> rel_dds A B) dds_of dds_of", "unfolding dds_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> A ===> rel_prod B S) ===> S ===> rel_dds A B)\n     (\\<lambda>uu uua.\n         corec_dds\n          (\\<lambda>(f, s).\n              map_prod id (\\<lambda>uu. Inr (f, uu)) \\<circ> f s)\n          (uu, uua))\n     (\\<lambda>uu uua.\n         corec_dds\n          (\\<lambda>(f, s).\n              map_prod id (\\<lambda>uu. Inr (f, uu)) \\<circ> f s)\n          (uu, uua))", "by transfer_prover"], ["", "subsection \\<open>Evenness of partial sums\\<close>"], ["", "definition even_psum :: \"(int, bool) dds\" where\n  \"even_psum = dds_of (\\<lambda>psum n. (even (psum + n), psum + n)) 0\""], ["", "definition even_psum_nat :: \"(nat, bool) dds\" where\n  \"even_psum_nat = map_dds int id even_psum\""], ["", "subsection \\<open>Composition\\<close>"], ["", "primcorec compose :: \"('a, 'b) dds \\<Rightarrow> ('b, 'c) dds \\<Rightarrow> ('a, 'c) dds\" (infixl \"\\<bullet>\" 120) where\n  \"run (S1 \\<bullet> S2) = (\\<lambda>a. let (b, S1') = run S1 a; (c, S2') = run S2 b in (c, S1' \\<bullet> S2'))\""], ["", "lemma compose_parametric [transfer_rule]:\n  \"(rel_dds A B ===> rel_dds B C ===> rel_dds A C) (\\<bullet>) (\\<bullet>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_dds A B ===> rel_dds B C ===> rel_dds A C) (\\<bullet>) (\\<bullet>)", "unfolding compose_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_dds A B ===> rel_dds B C ===> rel_dds A C)\n     (\\<lambda>uu uua.\n         corec_dds\n          (\\<lambda>(S1, S2) a.\n              (id (fst (run S2 (fst (run S1 a)))),\n               Inr (snd (run S1 a), snd (run S2 (fst (run S1 a))))))\n          (uu, uua))\n     (\\<lambda>uu uua.\n         corec_dds\n          (\\<lambda>(S1, S2) a.\n              (id (fst (run S2 (fst (run S1 a)))),\n               Inr (snd (run S1 a), snd (run S2 (fst (run S1 a))))))\n          (uu, uua))", "by transfer_prover"], ["", "text \\<open>\n  For the following lemma, a direct proof by induction is easy as the inner functor of\n  the @{type dds} codatatype is fairly simple.\n\\<close>"], ["", "lemma \"map_dds f g S1 \\<bullet> S2 = map_dds f id (S1 \\<bullet> map_dds g id S2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_dds f g S1 \\<bullet> S2 =\n    map_dds f id (S1 \\<bullet> map_dds g id S2)", "apply(coinduction arbitrary: S1 S2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S1 S2.\n       ((=) ===>\n        rel_prod (=)\n         (\\<lambda>dds__ dds'__.\n             \\<exists>S1 S2.\n                dds__ = map_dds f g S1 \\<bullet> S2 \\<and>\n                dds'__ = map_dds f id (S1 \\<bullet> map_dds g id S2)))\n        (run (map_dds f g S1 \\<bullet> S2))\n        (run (map_dds f id (S1 \\<bullet> map_dds g id S2)))", "apply(auto simp add: case_prod_map_prod rel_fun_def split: prod.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>However, we can also follow the systematic route via parametricity:\\<close>"], ["", "lemma compose_map1: \"map_dds f g S1 \\<bullet> S2 = map_dds f id (S1 \\<bullet> map_dds g id S2)\"\n  for S1 :: \"('a, 'b) dds\" and S2 :: \"('b, 'c) dds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_dds f g S1 \\<bullet> S2 =\n    map_dds f id (S1 \\<bullet> map_dds g id S2)", "using compose_parametric[of \"(Grp UNIV f)\\<inverse>\\<inverse>\" \"Grp UNIV g\" \"Grp UNIV id :: 'c \\<Rightarrow> 'c \\<Rightarrow> bool\"]"], ["proof (prove)\nusing this:\n  (rel_dds (Grp UNIV f)\\<inverse>\\<inverse> (Grp UNIV g) ===>\n   rel_dds (Grp UNIV g) (Grp UNIV id) ===>\n   rel_dds (Grp UNIV f)\\<inverse>\\<inverse> (Grp UNIV id))\n   (\\<bullet>) (\\<bullet>)\n\ngoal (1 subgoal):\n 1. map_dds f g S1 \\<bullet> S2 =\n    map_dds f id (S1 \\<bullet> map_dds g id S2)", "apply(rewrite in \"_ ===> rel_dds \\<hole> _ ===> _\" in asm conversep_conversep[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_dds (Grp UNIV f)\\<inverse>\\<inverse> (Grp UNIV g) ===>\n     rel_dds (Grp UNIV g)\\<inverse>\\<inverse>\\<inverse>\\<inverse>\n      (Grp UNIV id) ===>\n     rel_dds (Grp UNIV f)\\<inverse>\\<inverse> (Grp UNIV id))\n     (\\<bullet>) (\\<bullet>) \\<Longrightarrow>\n    map_dds f g S1 \\<bullet> S2 =\n    map_dds f id (S1 \\<bullet> map_dds g id S2)", "apply(rewrite in \"_ ===> rel_dds _ \\<hole> ===> _\" in asm conversep_Grp_id[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_dds (Grp UNIV f)\\<inverse>\\<inverse> (Grp UNIV g) ===>\n     rel_dds (Grp UNIV g)\\<inverse>\\<inverse>\\<inverse>\\<inverse>\n      (Grp UNIV id)\\<inverse>\\<inverse> ===>\n     rel_dds (Grp UNIV f)\\<inverse>\\<inverse> (Grp UNIV id))\n     (\\<bullet>) (\\<bullet>) \\<Longrightarrow>\n    map_dds f g S1 \\<bullet> S2 =\n    map_dds f id (S1 \\<bullet> map_dds g id S2)", "apply(simp only: rel_dds_conversep rel_dds_Grp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Grp UNIV (map_dds f g) ===>\n     (Grp UNIV (map_dds g id))\\<inverse>\\<inverse> ===>\n     Grp UNIV (map_dds f id))\n     (\\<bullet>) (\\<bullet>) \\<Longrightarrow>\n    map_dds f g S1 \\<bullet> S2 =\n    map_dds f id (S1 \\<bullet> map_dds g id S2)", "apply(simp add: rel_fun_def Grp_apply)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma compose_map2: \"S1 \\<bullet> map_dds f g S2 = map_dds id g (map_dds id f S1 \\<bullet> S2)\"\n  for S1 :: \"('a, 'b) dds\" and S2 :: \"('b, 'c) dds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S1 \\<bullet> map_dds f g S2 =\n    map_dds id g (map_dds id f S1 \\<bullet> S2)", "using compose_parametric[of \"Grp UNIV id :: 'a \\<Rightarrow> 'a \\<Rightarrow> bool\" \"(Grp UNIV f)\\<inverse>\\<inverse>\" \"Grp UNIV g\"]"], ["proof (prove)\nusing this:\n  (rel_dds (Grp UNIV id) (Grp UNIV f)\\<inverse>\\<inverse> ===>\n   rel_dds (Grp UNIV f)\\<inverse>\\<inverse> (Grp UNIV g) ===>\n   rel_dds (Grp UNIV id) (Grp UNIV g))\n   (\\<bullet>) (\\<bullet>)\n\ngoal (1 subgoal):\n 1. S1 \\<bullet> map_dds f g S2 =\n    map_dds id g (map_dds id f S1 \\<bullet> S2)", "apply(rewrite in \"rel_dds \\<hole> _ ===> _\" in asm conversep_conversep[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_dds (Grp UNIV id)\\<inverse>\\<inverse>\\<inverse>\\<inverse>\n      (Grp UNIV f)\\<inverse>\\<inverse> ===>\n     rel_dds (Grp UNIV f)\\<inverse>\\<inverse> (Grp UNIV g) ===>\n     rel_dds (Grp UNIV id) (Grp UNIV g))\n     (\\<bullet>) (\\<bullet>) \\<Longrightarrow>\n    S1 \\<bullet> map_dds f g S2 =\n    map_dds id g (map_dds id f S1 \\<bullet> S2)", "apply(rewrite in \"_ ===> _ ===> rel_dds \\<hole> _\" in asm conversep_Grp_id[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_dds (Grp UNIV id)\\<inverse>\\<inverse>\\<inverse>\\<inverse>\n      (Grp UNIV f)\\<inverse>\\<inverse> ===>\n     rel_dds (Grp UNIV f)\\<inverse>\\<inverse> (Grp UNIV g) ===>\n     rel_dds (Grp UNIV id)\\<inverse>\\<inverse> (Grp UNIV g))\n     (\\<bullet>) (\\<bullet>) \\<Longrightarrow>\n    S1 \\<bullet> map_dds f g S2 =\n    map_dds id g (map_dds id f S1 \\<bullet> S2)", "apply(simp only: rel_dds_conversep rel_dds_Grp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Grp UNIV (map_dds id f))\\<inverse>\\<inverse> ===>\n     Grp UNIV (map_dds f g) ===> Grp UNIV (map_dds id g))\n     (\\<bullet>) (\\<bullet>) \\<Longrightarrow>\n    S1 \\<bullet> map_dds f g S2 =\n    map_dds id g (map_dds id f S1 \\<bullet> S2)", "apply(simp add: rel_fun_def Grp_apply)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "primcorec parallel :: \"('a, 'b) dds \\<Rightarrow> ('c, 'd) dds \\<Rightarrow> ('a + 'c, 'b + 'd) dds\" (infixr \"\\<parallel>\" 130) where\n  \"run (S1 \\<parallel> S2) = (\\<lambda>x. case x of\n     Inl a \\<Rightarrow> let (b, S1') = run S1 a in (Inl b, S1' \\<parallel> S2)\n   | Inr c \\<Rightarrow> let (d, S2') = run S2 c in (Inr d, S1 \\<parallel> S2'))\""], ["", "lemma parallel_parametric [transfer_rule]:\n  \"(rel_dds A B ===> rel_dds C D ===> rel_dds (rel_sum A C) (rel_sum B D)) (\\<parallel>) (\\<parallel>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_dds A B ===> rel_dds C D ===> rel_dds (rel_sum A C) (rel_sum B D))\n     (\\<parallel>) (\\<parallel>)", "unfolding parallel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_dds A B ===> rel_dds C D ===> rel_dds (rel_sum A C) (rel_sum B D))\n     (\\<lambda>uu uua.\n         corec_dds\n          (\\<lambda>(S1, S2) x.\n              case x of\n              Inl a \\<Rightarrow>\n                (id (Inl (fst (run S1 a))), Inr (snd (run S1 a), S2))\n              | Inr c \\<Rightarrow>\n                  (id (Inr (fst (run S2 c))), Inr (S1, snd (run S2 c))))\n          (uu, uua))\n     (\\<lambda>uu uua.\n         corec_dds\n          (\\<lambda>(S1, S2) x.\n              case x of\n              Inl a \\<Rightarrow>\n                (id (Inl (fst (run S1 a))), Inr (snd (run S1 a), S2))\n              | Inr c \\<Rightarrow>\n                  (id (Inr (fst (run S2 c))), Inr (S1, snd (run S2 c))))\n          (uu, uua))", "by transfer_prover"], ["", "lemma map_parallel:\n  \"map_dds f h S1 \\<parallel> map_dds g k S2 = map_dds (map_sum f g) (map_sum h k) (S1 \\<parallel> S2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_dds f h S1 \\<parallel> map_dds g k S2 =\n    map_dds (map_sum f g) (map_sum h k) (S1 \\<parallel> S2)", "using parallel_parametric[where A=\"(Grp UNIV f)\\<inverse>\\<inverse>\" and B=\"Grp UNIV h\" and\n      C=\"(Grp UNIV g)\\<inverse>\\<inverse>\" and D=\"Grp UNIV k\"]"], ["proof (prove)\nusing this:\n  (rel_dds (Grp UNIV f)\\<inverse>\\<inverse> (Grp UNIV h) ===>\n   rel_dds (Grp UNIV g)\\<inverse>\\<inverse> (Grp UNIV k) ===>\n   rel_dds\n    (rel_sum (Grp UNIV f)\\<inverse>\\<inverse>\n      (Grp UNIV g)\\<inverse>\\<inverse>)\n    (rel_sum (Grp UNIV h) (Grp UNIV k)))\n   (\\<parallel>) (\\<parallel>)\n\ngoal (1 subgoal):\n 1. map_dds f h S1 \\<parallel> map_dds g k S2 =\n    map_dds (map_sum f g) (map_sum h k) (S1 \\<parallel> S2)", "by(simp add: sum.rel_conversep sum.rel_Grp rel_dds_Grp)(simp add: rel_fun_def Grp_apply)"], ["", "subsection \\<open>Graph traversal: refinement and quotients\\<close>"], ["", "lemma finite_Image:\n  \"finite A \\<Longrightarrow> finite (R `` A) \\<longleftrightarrow> (\\<forall>x\\<in>A. finite {y. (x, y) \\<in> R})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow>\n    finite (R `` A) = (\\<forall>x\\<in>A. finite {y. (x, y) \\<in> R})", "by(simp add: Image_def)"], ["", "context includes fset.lifting begin"], ["", "lift_definition fImage :: \"('a \\<times> 'b) fset \\<Rightarrow> 'a fset \\<Rightarrow> 'b fset\" is Image parametric Image_parametric"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>set1 set2.\n       \\<lbrakk>finite set1; finite set2\\<rbrakk>\n       \\<Longrightarrow> finite (set1 `` set2)", "by(auto simp add: finite_Image intro: finite_subset[OF _ finite_imageI])"], ["", "lemmas fImage_iff = Image_iff[Transfer.transferred]"], ["", "lemmas fImageI [intro] = ImageI[Transfer.transferred]"], ["", "lemmas fImageE [elim!] = ImageE[Transfer.transferred]"], ["", "lemmas rev_fImageI = rev_ImageI[Transfer.transferred]"], ["", "lemmas fImage_mono = Image_mono[Transfer.transferred]"], ["", "lifting_update fset.lifting"], ["", "lifting_forget fset.lifting"], ["", "end"], ["", "type_synonym 'a graph = \"('a \\<times> 'a) fset\""], ["", "definition traverse :: \"'a graph \\<Rightarrow> ('a fset, 'a fset) dds\" where\n  \"traverse E = dds_of (\\<lambda>visited A. ((fImage E A) |-| visited, visited |\\<union>| A)) {||}\""], ["", "type_synonym 'a graph' = \"('a \\<times> 'a) list\""], ["", "definition traverse_impl :: \"'a graph' \\<Rightarrow> ('a list, 'a list) dds\" where\n  \"traverse_impl E =\n   dds_of (\\<lambda>visited A. (map snd [(x, y)\\<leftarrow>E . x \\<in> set A \\<and> y |\\<notin>| visited],\n    visited |\\<union>| fset_of_list A)) {||}\""], ["", "definition list_fset_rel :: \"'a list \\<Rightarrow> 'a fset \\<Rightarrow> bool\" where\n  \"list_fset_rel xs A \\<longleftrightarrow> fset_of_list xs = A\""], ["", "lemma traverse_refinement: \\<comment> \\<open>This is the refinement lemma.\\<close>\n  \"(list_fset_rel ===> rel_dds list_fset_rel list_fset_rel) traverse_impl traverse\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_fset_rel ===> rel_dds list_fset_rel list_fset_rel) traverse_impl\n     traverse", "unfolding traverse_impl_def traverse_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_fset_rel ===> rel_dds list_fset_rel list_fset_rel)\n     (\\<lambda>E.\n         dds_of\n          (\\<lambda>visited A.\n              (map snd\n                (filter\n                  (\\<lambda>(x, y).\n                      x \\<in> set A \\<and> y |\\<notin>| visited)\n                  E),\n               visited |\\<union>| fset_of_list A))\n          {||})\n     (\\<lambda>E.\n         dds_of\n          (\\<lambda>visited A.\n              (fImage E A |-| visited, visited |\\<union>| A))\n          {||})", "apply(rule rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       list_fset_rel x y \\<Longrightarrow>\n       rel_dds list_fset_rel list_fset_rel\n        (dds_of\n          (\\<lambda>visited A.\n              (map snd\n                (filter\n                  (\\<lambda>(x, y).\n                      x \\<in> set A \\<and> y |\\<notin>| visited)\n                  x),\n               visited |\\<union>| fset_of_list A))\n          {||})\n        (dds_of\n          (\\<lambda>visited A.\n              (fImage y A |-| visited, visited |\\<union>| A))\n          {||})", "apply(rule dds_of_parametric[where S=\"(=)\", THEN rel_funD, THEN rel_funD])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       list_fset_rel x y \\<Longrightarrow>\n       ((=) ===> list_fset_rel ===> rel_prod list_fset_rel (=))\n        (\\<lambda>visited A.\n            (map snd\n              (filter\n                (\\<lambda>(x, y). x \\<in> set A \\<and> y |\\<notin>| visited)\n                x),\n             visited |\\<union>| fset_of_list A))\n        (\\<lambda>visited A. (fImage y A |-| visited, visited |\\<union>| A))\n 2. \\<And>x y. list_fset_rel x y \\<Longrightarrow> {||} = {||}", "apply(auto simp add: rel_fun_def list_fset_rel_def fset_of_list_elem intro: rev_fimage_eqI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fset_of_list_parametric [transfer_rule]:\n  \"(list_all2 A ===> rel_fset A) fset_of_list fset_of_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_all2 A ===> rel_fset A) fset_of_list fset_of_list", "including fset.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_all2 A ===> rel_fset A) fset_of_list fset_of_list", "unfolding rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       list_all2 A x y \\<longrightarrow>\n       rel_fset A (fset_of_list x) (fset_of_list y)", "by transfer(rule list.set_transfer[unfolded rel_fun_def])"], ["", "lemma traverse_impl_parametric [transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\"\n  shows \"(list_all2 (rel_prod A A) ===> rel_dds (list_all2 A) (list_all2 A)) traverse_impl traverse_impl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_all2 (rel_prod A A) ===> rel_dds (list_all2 A) (list_all2 A))\n     traverse_impl traverse_impl", "unfolding traverse_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_all2 (rel_prod A A) ===> rel_dds (list_all2 A) (list_all2 A))\n     (\\<lambda>E.\n         dds_of\n          (\\<lambda>visited A.\n              (map snd\n                (filter\n                  (\\<lambda>(x, y).\n                      x \\<in> set A \\<and> y |\\<notin>| visited)\n                  E),\n               visited |\\<union>| fset_of_list A))\n          {||})\n     (\\<lambda>E.\n         dds_of\n          (\\<lambda>visited A.\n              (map snd\n                (filter\n                  (\\<lambda>(x, y).\n                      x \\<in> set A \\<and> y |\\<notin>| visited)\n                  E),\n               visited |\\<union>| fset_of_list A))\n          {||})", "by transfer_prover"], ["", "text \\<open>\n  By constructing finite sets as a quotient of lists, we can synthesise an abstract version\n  of @{const traverse_impl} automatically, together with a polymorphic refinement lemma.\n\\<close>"], ["", "quotient_type 'a fset' = \"'a list\" / \"vimage2p set set (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivp (vimage2p set set (=))", "by (auto intro: equivpI reflpI sympI transpI simp add: vimage2p_def)"], ["", "lift_definition traverse'' :: \"('a \\<times> 'a) fset' \\<Rightarrow> ('a fset', 'a fset') dds\"\n  is \"traverse_impl :: 'a graph' \\<Rightarrow> _\" parametric traverse_impl_parametric"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list1 list2.\n       vimage2p set set (=) list1 list2 \\<Longrightarrow>\n       rel_dds (vimage2p set set (=)) (vimage2p set set (=))\n        (traverse_impl list1) (traverse_impl list2)", "unfolding traverse_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list1 list2.\n       vimage2p set set (=) list1 list2 \\<Longrightarrow>\n       rel_dds (vimage2p set set (=)) (vimage2p set set (=))\n        (dds_of\n          (\\<lambda>visited A.\n              (map snd\n                (filter\n                  (\\<lambda>(x, y).\n                      x \\<in> set A \\<and> y |\\<notin>| visited)\n                  list1),\n               visited |\\<union>| fset_of_list A))\n          {||})\n        (dds_of\n          (\\<lambda>visited A.\n              (map snd\n                (filter\n                  (\\<lambda>(x, y).\n                      x \\<in> set A \\<and> y |\\<notin>| visited)\n                  list2),\n               visited |\\<union>| fset_of_list A))\n          {||})", "apply (rule dds_of_parametric[where S=\"(=)\", THEN rel_funD, THEN rel_funD])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>list1 list2.\n       vimage2p set set (=) list1 list2 \\<Longrightarrow>\n       ((=) ===>\n        vimage2p set set (=) ===> rel_prod (vimage2p set set (=)) (=))\n        (\\<lambda>visited A.\n            (map snd\n              (filter\n                (\\<lambda>(x, y). x \\<in> set A \\<and> y |\\<notin>| visited)\n                list1),\n             visited |\\<union>| fset_of_list A))\n        (\\<lambda>visited A.\n            (map snd\n              (filter\n                (\\<lambda>(x, y). x \\<in> set A \\<and> y |\\<notin>| visited)\n                list2),\n             visited |\\<union>| fset_of_list A))\n 2. \\<And>list1 list2.\n       vimage2p set set (=) list1 list2 \\<Longrightarrow> {||} = {||}", "apply (auto simp add: rel_fun_def vimage2p_def fset_of_list_elem)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Generalised rewriting\\<close>"], ["", "definition accumulate :: \"('a fset, 'a fset) dds\" where\n  \"accumulate = dds_of (\\<lambda>A X. (A |\\<union>| X, A |\\<union>| X)) {||}\""], ["", "lemma accumulate_mono: \"rel_dds (|\\<subseteq>|) (|\\<subseteq>|) accumulate accumulate\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dds (|\\<subseteq>|) (|\\<subseteq>|) accumulate accumulate", "unfolding accumulate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dds (|\\<subseteq>|) (|\\<subseteq>|)\n     (dds_of (\\<lambda>A X. (A |\\<union>| X, A |\\<union>| X)) {||})\n     (dds_of (\\<lambda>A X. (A |\\<union>| X, A |\\<union>| X)) {||})", "apply (rule dds_of_parametric[THEN rel_funD, THEN rel_funD, of \"(|\\<subseteq>|)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. ((|\\<subseteq>|) ===>\n     (|\\<subseteq>|) ===> rel_prod (|\\<subseteq>|) (|\\<subseteq>|))\n     (\\<lambda>A X. (A |\\<union>| X, A |\\<union>| X))\n     (\\<lambda>A X. (A |\\<union>| X, A |\\<union>| X))\n 2. {||} |\\<subseteq>| {||}", "apply (intro rel_funI rel_prod.intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x |\\<subseteq>| y; xa |\\<subseteq>| ya\\<rbrakk>\n       \\<Longrightarrow> x |\\<union>| xa |\\<subseteq>| y |\\<union>| ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>x |\\<subseteq>| y; xa |\\<subseteq>| ya\\<rbrakk>\n       \\<Longrightarrow> x |\\<union>| xa |\\<subseteq>| y |\\<union>| ya\n 3. {||} |\\<subseteq>| {||}", "apply (erule (1) funion_mono)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. {||} |\\<subseteq>| {||}", "apply (simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma traverse_mono: \"((|\\<subseteq>|) ===> rel_dds (=) (|\\<subseteq>|)) traverse traverse\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((|\\<subseteq>|) ===> rel_dds (=) (|\\<subseteq>|)) traverse traverse", "unfolding traverse_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((|\\<subseteq>|) ===> rel_dds (=) (|\\<subseteq>|))\n     (\\<lambda>E.\n         dds_of\n          (\\<lambda>visited A.\n              (fImage E A |-| visited, visited |\\<union>| A))\n          {||})\n     (\\<lambda>E.\n         dds_of\n          (\\<lambda>visited A.\n              (fImage E A |-| visited, visited |\\<union>| A))\n          {||})", "apply (rule rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x |\\<subseteq>| y \\<Longrightarrow>\n       rel_dds (=) (|\\<subseteq>|)\n        (dds_of\n          (\\<lambda>visited A.\n              (fImage x A |-| visited, visited |\\<union>| A))\n          {||})\n        (dds_of\n          (\\<lambda>visited A.\n              (fImage y A |-| visited, visited |\\<union>| A))\n          {||})", "apply (rule dds_of_parametric[THEN rel_funD, THEN rel_funD, of \"(=)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       x |\\<subseteq>| y \\<Longrightarrow>\n       ((=) ===> (=) ===> rel_prod (|\\<subseteq>|) (=))\n        (\\<lambda>visited A. (fImage x A |-| visited, visited |\\<union>| A))\n        (\\<lambda>visited A. (fImage y A |-| visited, visited |\\<union>| A))\n 2. \\<And>x y. x |\\<subseteq>| y \\<Longrightarrow> {||} = {||}", "apply (intro rel_funI rel_prod.intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>x |\\<subseteq>| y; xa = ya; xb = yb\\<rbrakk>\n       \\<Longrightarrow> fImage x xb |-| xa |\\<subseteq>| fImage y yb |-| ya\n 2. \\<And>x y xa ya xb yb.\n       \\<lbrakk>x |\\<subseteq>| y; xa = ya; xb = yb\\<rbrakk>\n       \\<Longrightarrow> xa |\\<union>| xb = ya |\\<union>| yb\n 3. \\<And>x y. x |\\<subseteq>| y \\<Longrightarrow> {||} = {||}", "apply (simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>x |\\<subseteq>| y; xa = ya; xb = yb\\<rbrakk>\n       \\<Longrightarrow> fImage x yb |-| ya |\\<subseteq>| fImage y yb |-| ya\n 2. \\<And>x y xa ya xb yb.\n       \\<lbrakk>x |\\<subseteq>| y; xa = ya; xb = yb\\<rbrakk>\n       \\<Longrightarrow> xa |\\<union>| xb = ya |\\<union>| yb\n 3. \\<And>x y. x |\\<subseteq>| y \\<Longrightarrow> {||} = {||}", "apply (rule fminus_mono)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>x |\\<subseteq>| y; xa = ya; xb = yb\\<rbrakk>\n       \\<Longrightarrow> fImage x yb |\\<subseteq>| fImage y yb\n 2. \\<And>x y xa ya xb yb.\n       \\<lbrakk>x |\\<subseteq>| y; xa = ya; xb = yb\\<rbrakk>\n       \\<Longrightarrow> ya |\\<subseteq>| ya\n 3. \\<And>x y xa ya xb yb.\n       \\<lbrakk>x |\\<subseteq>| y; xa = ya; xb = yb\\<rbrakk>\n       \\<Longrightarrow> xa |\\<union>| xb = ya |\\<union>| yb\n 4. \\<And>x y. x |\\<subseteq>| y \\<Longrightarrow> {||} = {||}", "apply (erule fImage_mono)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>xa = ya; xb = yb\\<rbrakk>\n       \\<Longrightarrow> yb |\\<subseteq>| yb\n 2. \\<And>x y xa ya xb yb.\n       \\<lbrakk>x |\\<subseteq>| y; xa = ya; xb = yb\\<rbrakk>\n       \\<Longrightarrow> ya |\\<subseteq>| ya\n 3. \\<And>x y xa ya xb yb.\n       \\<lbrakk>x |\\<subseteq>| y; xa = ya; xb = yb\\<rbrakk>\n       \\<Longrightarrow> xa |\\<union>| xb = ya |\\<union>| yb\n 4. \\<And>x y. x |\\<subseteq>| y \\<Longrightarrow> {||} = {||}", "apply (simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma\n  assumes \"G |\\<subseteq>| H\"\n  shows \"rel_dds (=) (|\\<subseteq>|) (traverse G \\<bullet> accumulate) (traverse H \\<bullet> accumulate)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dds (=) (|\\<subseteq>|) (traverse G \\<bullet> accumulate)\n     (traverse H \\<bullet> accumulate)", "apply (rule compose_parametric[THEN rel_funD, THEN rel_funD])"], ["proof (prove)\ngoal (2 subgoals):\n 1. rel_dds (=) ?B2 (traverse G) (traverse H)\n 2. rel_dds ?B2 (|\\<subseteq>|) accumulate accumulate", "apply (rule traverse_mono[THEN rel_funD])"], ["proof (prove)\ngoal (2 subgoals):\n 1. G |\\<subseteq>| H\n 2. rel_dds (|\\<subseteq>|) (|\\<subseteq>|) accumulate accumulate", "apply (rule assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dds (|\\<subseteq>|) (|\\<subseteq>|) accumulate accumulate", "apply (rule accumulate_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition seen :: \"('a fset, 'a fset) dds\" where\n  \"seen = dds_of (\\<lambda>S X. (S |\\<inter>| X, S |\\<union>| X)) {||}\""], ["", "lemma seen_mono: \"rel_dds (|\\<subseteq>|) (|\\<subseteq>|) seen seen\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dds (|\\<subseteq>|) (|\\<subseteq>|) seen seen", "unfolding seen_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dds (|\\<subseteq>|) (|\\<subseteq>|)\n     (dds_of (\\<lambda>S X. (S |\\<inter>| X, S |\\<union>| X)) {||})\n     (dds_of (\\<lambda>S X. (S |\\<inter>| X, S |\\<union>| X)) {||})", "apply (rule dds_of_parametric[THEN rel_funD, THEN rel_funD, of \"(|\\<subseteq>|)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. ((|\\<subseteq>|) ===>\n     (|\\<subseteq>|) ===> rel_prod (|\\<subseteq>|) (|\\<subseteq>|))\n     (\\<lambda>S X. (S |\\<inter>| X, S |\\<union>| X))\n     (\\<lambda>S X. (S |\\<inter>| X, S |\\<union>| X))\n 2. {||} |\\<subseteq>| {||}", "apply (intro rel_funI rel_prod.intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>x |\\<subseteq>| y; xa |\\<subseteq>| ya\\<rbrakk>\n       \\<Longrightarrow> x |\\<inter>| xa |\\<subseteq>| y |\\<inter>| ya\n 2. \\<And>x y xa ya.\n       \\<lbrakk>x |\\<subseteq>| y; xa |\\<subseteq>| ya\\<rbrakk>\n       \\<Longrightarrow> x |\\<union>| xa |\\<subseteq>| y |\\<union>| ya\n 3. {||} |\\<subseteq>| {||}", "apply (erule (1) finter_mono funion_mono)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. {||} |\\<subseteq>| {||}", "apply (simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma\n  assumes \"G |\\<subseteq>| H\"\n  shows \"rel_dds (=) (|\\<subseteq>|) (traverse G \\<bullet> seen) (traverse H \\<bullet> seen)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dds (=) (|\\<subseteq>|) (traverse G \\<bullet> seen)\n     (traverse H \\<bullet> seen)", "apply (rule compose_parametric[THEN rel_funD, THEN rel_funD])"], ["proof (prove)\ngoal (2 subgoals):\n 1. rel_dds (=) ?B2 (traverse G) (traverse H)\n 2. rel_dds ?B2 (|\\<subseteq>|) seen seen", "apply (rule traverse_mono[THEN rel_funD])"], ["proof (prove)\ngoal (2 subgoals):\n 1. G |\\<subseteq>| H\n 2. rel_dds (|\\<subseteq>|) (|\\<subseteq>|) seen seen", "apply (rule assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_dds (|\\<subseteq>|) (|\\<subseteq>|) seen seen", "apply (rule seen_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}