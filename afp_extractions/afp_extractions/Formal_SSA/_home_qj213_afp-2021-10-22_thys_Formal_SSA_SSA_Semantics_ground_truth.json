{"file_name": "/home/qj213/afp-2021-10-22/thys/Formal_SSA/SSA_Semantics.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Formal_SSA", "problem_names": ["lemma ssaBS_I:\n    assumes \"g \\<turnstile> Entry g-ns\\<rightarrow>n\"\n    obtains s where \"g \\<turnstile> ns\\<Down>\\<^sub>ss\"", "lemma ssaBS_nonempty[simp]: \"\\<not> (g \\<turnstile> []\\<Down>\\<^sub>ss)\"", "lemma ssaBS_hd[simp]: \"g \\<turnstile> ns\\<Down>\\<^sub>ss \\<Longrightarrow> hd ns = Entry g\"", "lemma equiv_aux:\n    assumes \"g \\<turnstile> ns\\<Down>s\" \"g \\<turnstile> ns\\<Down>\\<^sub>ss'\" \"g \\<turnstile> last ns-ms\\<rightarrow>m\" \"v \\<in> allUses g m\" \"\\<forall>n \\<in> set (tl ms). var g v \\<notin> var g ` allDefs g n\"\n    shows \"s (var g v) = s' v\"", "theorem equiv:\n    assumes \"g \\<turnstile> ns\\<Down>s\" \"g \\<turnstile> ns\\<Down>\\<^sub>ss'\" \"v \\<in> uses g (last ns)\"\n    shows \"s (var g v) = s' v\""], "translations": [["", "lemma ssaBS_I:\n    assumes \"g \\<turnstile> Entry g-ns\\<rightarrow>n\"\n    obtains s where \"g \\<turnstile> ns\\<Down>\\<^sub>ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        g \\<turnstile> ns\\<Down>\\<^sub>s s \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  g \\<turnstile> Entry g-ns\\<rightarrow>n\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        g \\<turnstile> ns\\<Down>\\<^sub>s s \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof (atomize_elim, induction rule:old.path2_rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>Entry g \\<in> set (\\<alpha>n g);\n     g \\<turnstile> Entry g-[Entry g]\\<rightarrow>Entry g\\<rbrakk>\n    \\<Longrightarrow> Ex (ssaBS g [Entry g])\n 2. \\<And>ns m' m.\n       \\<lbrakk>g \\<turnstile> Entry g-ns\\<rightarrow>m';\n        g \\<turnstile> Entry g-ns\\<rightarrow>m' \\<Longrightarrow>\n        Ex (ssaBS g ns);\n        m' \\<in> set (old.predecessors g m);\n        g \\<turnstile> Entry g-ns @ [m]\\<rightarrow>m\\<rbrakk>\n       \\<Longrightarrow> Ex (ssaBS g (ns @ [m]))", "case (snoc ns m' m)"], ["proof (state)\nthis:\n  g \\<turnstile> Entry g-ns\\<rightarrow>m'\n  m' \\<in> set (old.predecessors g m)\n  g \\<turnstile> Entry g-ns\\<rightarrow>m' \\<Longrightarrow>\n  \\<exists>a. g \\<turnstile> ns\\<Down>\\<^sub>s a\n  g \\<turnstile> Entry g-ns @ [m]\\<rightarrow>m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Entry g \\<in> set (\\<alpha>n g);\n     g \\<turnstile> Entry g-[Entry g]\\<rightarrow>Entry g\\<rbrakk>\n    \\<Longrightarrow> Ex (ssaBS g [Entry g])\n 2. \\<And>ns m' m.\n       \\<lbrakk>g \\<turnstile> Entry g-ns\\<rightarrow>m';\n        g \\<turnstile> Entry g-ns\\<rightarrow>m' \\<Longrightarrow>\n        Ex (ssaBS g ns);\n        m' \\<in> set (old.predecessors g m);\n        g \\<turnstile> Entry g-ns @ [m]\\<rightarrow>m\\<rbrakk>\n       \\<Longrightarrow> Ex (ssaBS g (ns @ [m]))", "then"], ["proof (chain)\npicking this:\n  g \\<turnstile> Entry g-ns\\<rightarrow>m'\n  m' \\<in> set (old.predecessors g m)\n  g \\<turnstile> Entry g-ns\\<rightarrow>m' \\<Longrightarrow>\n  \\<exists>a. g \\<turnstile> ns\\<Down>\\<^sub>s a\n  g \\<turnstile> Entry g-ns @ [m]\\<rightarrow>m", "obtain s where s: \"g \\<turnstile> ns\\<Down>\\<^sub>ss\""], ["proof (prove)\nusing this:\n  g \\<turnstile> Entry g-ns\\<rightarrow>m'\n  m' \\<in> set (old.predecessors g m)\n  g \\<turnstile> Entry g-ns\\<rightarrow>m' \\<Longrightarrow>\n  \\<exists>a. g \\<turnstile> ns\\<Down>\\<^sub>s a\n  g \\<turnstile> Entry g-ns @ [m]\\<rightarrow>m\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        g \\<turnstile> ns\\<Down>\\<^sub>s s \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  g \\<turnstile> ns\\<Down>\\<^sub>s s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Entry g \\<in> set (\\<alpha>n g);\n     g \\<turnstile> Entry g-[Entry g]\\<rightarrow>Entry g\\<rbrakk>\n    \\<Longrightarrow> Ex (ssaBS g [Entry g])\n 2. \\<And>ns m' m.\n       \\<lbrakk>g \\<turnstile> Entry g-ns\\<rightarrow>m';\n        g \\<turnstile> Entry g-ns\\<rightarrow>m' \\<Longrightarrow>\n        Ex (ssaBS g ns);\n        m' \\<in> set (old.predecessors g m);\n        g \\<turnstile> Entry g-ns @ [m]\\<rightarrow>m\\<rbrakk>\n       \\<Longrightarrow> Ex (ssaBS g (ns @ [m]))", "from snoc.hyps(2)"], ["proof (chain)\npicking this:\n  m' \\<in> set (old.predecessors g m)", "obtain i where \"m' = old.predecessors g m ! i\" \"i < length (old.predecessors g m)\""], ["proof (prove)\nusing this:\n  m' \\<in> set (old.predecessors g m)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>m' = old.predecessors g m ! i;\n         i < length (old.predecessors g m)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp:in_set_conv_nth)"], ["proof (state)\nthis:\n  m' = old.predecessors g m ! i\n  i < length (old.predecessors g m)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Entry g \\<in> set (\\<alpha>n g);\n     g \\<turnstile> Entry g-[Entry g]\\<rightarrow>Entry g\\<rbrakk>\n    \\<Longrightarrow> Ex (ssaBS g [Entry g])\n 2. \\<And>ns m' m.\n       \\<lbrakk>g \\<turnstile> Entry g-ns\\<rightarrow>m';\n        g \\<turnstile> Entry g-ns\\<rightarrow>m' \\<Longrightarrow>\n        Ex (ssaBS g ns);\n        m' \\<in> set (old.predecessors g m);\n        g \\<turnstile> Entry g-ns @ [m]\\<rightarrow>m\\<rbrakk>\n       \\<Longrightarrow> Ex (ssaBS g (ns @ [m]))", "with snoc.hyps snoc.prems s"], ["proof (chain)\npicking this:\n  g \\<turnstile> Entry g-ns\\<rightarrow>m'\n  m' \\<in> set (old.predecessors g m)\n  g \\<turnstile> Entry g-ns @ [m]\\<rightarrow>m\n  g \\<turnstile> ns\\<Down>\\<^sub>s s\n  m' = old.predecessors g m ! i\n  i < length (old.predecessors g m)", "show ?case"], ["proof (prove)\nusing this:\n  g \\<turnstile> Entry g-ns\\<rightarrow>m'\n  m' \\<in> set (old.predecessors g m)\n  g \\<turnstile> Entry g-ns @ [m]\\<rightarrow>m\n  g \\<turnstile> ns\\<Down>\\<^sub>s s\n  m' = old.predecessors g m ! i\n  i < length (old.predecessors g m)\n\ngoal (1 subgoal):\n 1. \\<exists>a. g \\<turnstile> ns @ [m]\\<Down>\\<^sub>s a", "by -(rule exI, erule ssaBS.snoc, auto dest:old.path2_last)"], ["proof (state)\nthis:\n  \\<exists>a. g \\<turnstile> ns @ [m]\\<Down>\\<^sub>s a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Entry g \\<in> set (\\<alpha>n g);\n     g \\<turnstile> Entry g-[Entry g]\\<rightarrow>Entry g\\<rbrakk>\n    \\<Longrightarrow> Ex (ssaBS g [Entry g])", "qed (auto intro: ssaBS.empty)"], ["", "lemma ssaBS_nonempty[simp]: \"\\<not> (g \\<turnstile> []\\<Down>\\<^sub>ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> g \\<turnstile> []\\<Down>\\<^sub>s s", "by (rule notI, cases rule: ssaBS.cases, auto)"], ["", "lemma ssaBS_hd[simp]: \"g \\<turnstile> ns\\<Down>\\<^sub>ss \\<Longrightarrow> hd ns = Entry g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<turnstile> ns\\<Down>\\<^sub>s s \\<Longrightarrow> hd ns = Entry g", "by (induction rule: ssaBS.induct, auto simp: hd_append)"], ["", "lemma equiv_aux:\n    assumes \"g \\<turnstile> ns\\<Down>s\" \"g \\<turnstile> ns\\<Down>\\<^sub>ss'\" \"g \\<turnstile> last ns-ms\\<rightarrow>m\" \"v \\<in> allUses g m\" \"\\<forall>n \\<in> set (tl ms). var g v \\<notin> var g ` allDefs g n\"\n    shows \"s (var g v) = s' v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s (var g v) = s' v", "using assms(2) assms(1,3-)"], ["proof (prove)\nusing this:\n  g \\<turnstile> ns\\<Down>\\<^sub>s s'\n  g \\<turnstile> ns\\<Down>s\n  g \\<turnstile> last ns-ms\\<rightarrow>m\n  v \\<in> allUses g m\n  \\<forall>n\\<in>set (tl ms). var g v \\<notin> var g ` allDefs g n\n\ngoal (1 subgoal):\n 1. s (var g v) = s' v", "proof (induction arbitrary: v s ms m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v s ms m.\n       \\<lbrakk>g \\<turnstile> [Entry g]\\<Down>s;\n        g \\<turnstile> last [Entry g]-ms\\<rightarrow>m; v \\<in> allUses g m;\n        \\<forall>n\\<in>set (tl ms).\n           var g v \\<notin> var g ` allDefs g n\\<rbrakk>\n       \\<Longrightarrow> s (var g v) = ssaStep g (Entry g) 0 Map.empty v\n 2. \\<And>ns s m i v sa ms ma.\n       \\<lbrakk>g \\<turnstile> ns\\<Down>\\<^sub>s s;\n        \\<And>v sa ms m.\n           \\<lbrakk>g \\<turnstile> ns\\<Down>sa;\n            g \\<turnstile> last ns-ms\\<rightarrow>m; v \\<in> allUses g m;\n            \\<forall>n\\<in>set (tl ms).\n               var g v \\<notin> var g ` allDefs g n\\<rbrakk>\n           \\<Longrightarrow> sa (var g v) = s v;\n        last ns = old.predecessors g m ! i; m \\<in> set (\\<alpha>n g);\n        i < length (old.predecessors g m); g \\<turnstile> ns @ [m]\\<Down>sa;\n        g \\<turnstile> last (ns @ [m])-ms\\<rightarrow>ma;\n        v \\<in> allUses g ma;\n        \\<forall>n\\<in>set (tl ms).\n           var g v \\<notin> var g ` allDefs g n\\<rbrakk>\n       \\<Longrightarrow> sa (var g v) = ssaStep g m i s v", "case empty"], ["proof (state)\nthis:\n  g \\<turnstile> [Entry g]\\<Down>s\n  g \\<turnstile> last [Entry g]-ms\\<rightarrow>m\n  v \\<in> allUses g m\n  \\<forall>n\\<in>set (tl ms). var g v \\<notin> var g ` allDefs g n\n\ngoal (2 subgoals):\n 1. \\<And>v s ms m.\n       \\<lbrakk>g \\<turnstile> [Entry g]\\<Down>s;\n        g \\<turnstile> last [Entry g]-ms\\<rightarrow>m; v \\<in> allUses g m;\n        \\<forall>n\\<in>set (tl ms).\n           var g v \\<notin> var g ` allDefs g n\\<rbrakk>\n       \\<Longrightarrow> s (var g v) = ssaStep g (Entry g) 0 Map.empty v\n 2. \\<And>ns s m i v sa ms ma.\n       \\<lbrakk>g \\<turnstile> ns\\<Down>\\<^sub>s s;\n        \\<And>v sa ms m.\n           \\<lbrakk>g \\<turnstile> ns\\<Down>sa;\n            g \\<turnstile> last ns-ms\\<rightarrow>m; v \\<in> allUses g m;\n            \\<forall>n\\<in>set (tl ms).\n               var g v \\<notin> var g ` allDefs g n\\<rbrakk>\n           \\<Longrightarrow> sa (var g v) = s v;\n        last ns = old.predecessors g m ! i; m \\<in> set (\\<alpha>n g);\n        i < length (old.predecessors g m); g \\<turnstile> ns @ [m]\\<Down>sa;\n        g \\<turnstile> last (ns @ [m])-ms\\<rightarrow>ma;\n        v \\<in> allUses g ma;\n        \\<forall>n\\<in>set (tl ms).\n           var g v \\<notin> var g ` allDefs g n\\<rbrakk>\n       \\<Longrightarrow> sa (var g v) = ssaStep g m i s v", "have \"v \\<in> defs g (Entry g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> defs g (Entry g)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> defs g (Entry g)", "from empty.prems(2,3)"], ["proof (chain)\npicking this:\n  g \\<turnstile> last [Entry g]-ms\\<rightarrow>m\n  v \\<in> allUses g m", "have \"defAss g m v\""], ["proof (prove)\nusing this:\n  g \\<turnstile> last [Entry g]-ms\\<rightarrow>m\n  v \\<in> allUses g m\n\ngoal (1 subgoal):\n 1. defAss g m v", "by - (rule allUses_def_ass, auto)"], ["proof (state)\nthis:\n  defAss g m v\n\ngoal (1 subgoal):\n 1. v \\<in> defs g (Entry g)", "with empty.prems(2)"], ["proof (chain)\npicking this:\n  g \\<turnstile> last [Entry g]-ms\\<rightarrow>m\n  defAss g m v", "obtain n where n: \"n \\<in> set ms\" \"v \\<in> allDefs g n\""], ["proof (prove)\nusing this:\n  g \\<turnstile> last [Entry g]-ms\\<rightarrow>m\n  defAss g m v\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>n \\<in> set ms; v \\<in> allDefs g n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by - (drule defAssD, auto)"], ["proof (state)\nthis:\n  n \\<in> set ms\n  v \\<in> allDefs g n\n\ngoal (1 subgoal):\n 1. v \\<in> defs g (Entry g)", "with empty.prems(4)"], ["proof (chain)\npicking this:\n  \\<forall>n\\<in>set (tl ms). var g v \\<notin> var g ` allDefs g n\n  n \\<in> set ms\n  v \\<in> allDefs g n", "have \"n \\<notin> set (tl ms)\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>set (tl ms). var g v \\<notin> var g ` allDefs g n\n  n \\<in> set ms\n  v \\<in> allDefs g n\n\ngoal (1 subgoal):\n 1. n \\<notin> set (tl ms)", "by auto"], ["proof (state)\nthis:\n  n \\<notin> set (tl ms)\n\ngoal (1 subgoal):\n 1. v \\<in> defs g (Entry g)", "with empty.prems(2) n"], ["proof (chain)\npicking this:\n  g \\<turnstile> last [Entry g]-ms\\<rightarrow>m\n  n \\<in> set ms\n  v \\<in> allDefs g n\n  n \\<notin> set (tl ms)", "have \"n = Entry g\""], ["proof (prove)\nusing this:\n  g \\<turnstile> last [Entry g]-ms\\<rightarrow>m\n  n \\<in> set ms\n  v \\<in> allDefs g n\n  n \\<notin> set (tl ms)\n\ngoal (1 subgoal):\n 1. n = Entry g", "by (cases ms, auto dest: old.path2_hd)"], ["proof (state)\nthis:\n  n = Entry g\n\ngoal (1 subgoal):\n 1. v \\<in> defs g (Entry g)", "with n(2)"], ["proof (chain)\npicking this:\n  v \\<in> allDefs g n\n  n = Entry g", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> allDefs g n\n  n = Entry g\n\ngoal (1 subgoal):\n 1. v \\<in> defs g (Entry g)", "by (auto simp: allDefs_def)"], ["proof (state)\nthis:\n  v \\<in> defs g (Entry g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<in> defs g (Entry g)\n\ngoal (2 subgoals):\n 1. \\<And>v s ms m.\n       \\<lbrakk>g \\<turnstile> [Entry g]\\<Down>s;\n        g \\<turnstile> last [Entry g]-ms\\<rightarrow>m; v \\<in> allUses g m;\n        \\<forall>n\\<in>set (tl ms).\n           var g v \\<notin> var g ` allDefs g n\\<rbrakk>\n       \\<Longrightarrow> s (var g v) = ssaStep g (Entry g) 0 Map.empty v\n 2. \\<And>ns s m i v sa ms ma.\n       \\<lbrakk>g \\<turnstile> ns\\<Down>\\<^sub>s s;\n        \\<And>v sa ms m.\n           \\<lbrakk>g \\<turnstile> ns\\<Down>sa;\n            g \\<turnstile> last ns-ms\\<rightarrow>m; v \\<in> allUses g m;\n            \\<forall>n\\<in>set (tl ms).\n               var g v \\<notin> var g ` allDefs g n\\<rbrakk>\n           \\<Longrightarrow> sa (var g v) = s v;\n        last ns = old.predecessors g m ! i; m \\<in> set (\\<alpha>n g);\n        i < length (old.predecessors g m); g \\<turnstile> ns @ [m]\\<Down>sa;\n        g \\<turnstile> last (ns @ [m])-ms\\<rightarrow>ma;\n        v \\<in> allUses g ma;\n        \\<forall>n\\<in>set (tl ms).\n           var g v \\<notin> var g ` allDefs g n\\<rbrakk>\n       \\<Longrightarrow> sa (var g v) = ssaStep g m i s v", "with empty.prems(1)"], ["proof (chain)\npicking this:\n  g \\<turnstile> [Entry g]\\<Down>s\n  v \\<in> defs g (Entry g)", "show ?case"], ["proof (prove)\nusing this:\n  g \\<turnstile> [Entry g]\\<Down>s\n  v \\<in> defs g (Entry g)\n\ngoal (1 subgoal):\n 1. s (var g v) = ssaStep g (Entry g) 0 Map.empty v", "by - (erule bs.cases, auto simp: step_def ssaStep_def oldDefs_def split: option.split)"], ["proof (state)\nthis:\n  s (var g v) = ssaStep g (Entry g) 0 Map.empty v\n\ngoal (1 subgoal):\n 1. \\<And>ns s m i v sa ms ma.\n       \\<lbrakk>g \\<turnstile> ns\\<Down>\\<^sub>s s;\n        \\<And>v sa ms m.\n           \\<lbrakk>g \\<turnstile> ns\\<Down>sa;\n            g \\<turnstile> last ns-ms\\<rightarrow>m; v \\<in> allUses g m;\n            \\<forall>n\\<in>set (tl ms).\n               var g v \\<notin> var g ` allDefs g n\\<rbrakk>\n           \\<Longrightarrow> sa (var g v) = s v;\n        last ns = old.predecessors g m ! i; m \\<in> set (\\<alpha>n g);\n        i < length (old.predecessors g m); g \\<turnstile> ns @ [m]\\<Down>sa;\n        g \\<turnstile> last (ns @ [m])-ms\\<rightarrow>ma;\n        v \\<in> allUses g ma;\n        \\<forall>n\\<in>set (tl ms).\n           var g v \\<notin> var g ` allDefs g n\\<rbrakk>\n       \\<Longrightarrow> sa (var g v) = ssaStep g m i s v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ns s m i v sa ms ma.\n       \\<lbrakk>g \\<turnstile> ns\\<Down>\\<^sub>s s;\n        \\<And>v sa ms m.\n           \\<lbrakk>g \\<turnstile> ns\\<Down>sa;\n            g \\<turnstile> last ns-ms\\<rightarrow>m; v \\<in> allUses g m;\n            \\<forall>n\\<in>set (tl ms).\n               var g v \\<notin> var g ` allDefs g n\\<rbrakk>\n           \\<Longrightarrow> sa (var g v) = s v;\n        last ns = old.predecessors g m ! i; m \\<in> set (\\<alpha>n g);\n        i < length (old.predecessors g m); g \\<turnstile> ns @ [m]\\<Down>sa;\n        g \\<turnstile> last (ns @ [m])-ms\\<rightarrow>ma;\n        v \\<in> allUses g ma;\n        \\<forall>n\\<in>set (tl ms).\n           var g v \\<notin> var g ` allDefs g n\\<rbrakk>\n       \\<Longrightarrow> sa (var g v) = ssaStep g m i s v", "case (snoc ns s' n i)"], ["proof (state)\nthis:\n  g \\<turnstile> ns\\<Down>\\<^sub>s s'\n  last ns = old.predecessors g n ! i\n  n \\<in> set (\\<alpha>n g)\n  i < length (old.predecessors g n)\n  \\<lbrakk>g \\<turnstile> ns\\<Down>?s1;\n   g \\<turnstile> last ns-?ms1\\<rightarrow>?m1; ?v1 \\<in> allUses g ?m1;\n   \\<forall>n\\<in>set (tl ?ms1).\n      var g ?v1 \\<notin> var g ` allDefs g n\\<rbrakk>\n  \\<Longrightarrow> ?s1 (var g ?v1) = s' ?v1\n  g \\<turnstile> ns @ [n]\\<Down>s\n  g \\<turnstile> last (ns @ [n])-ms\\<rightarrow>m\n  v \\<in> allUses g m\n  \\<forall>n\\<in>set (tl ms). var g v \\<notin> var g ` allDefs g n\n\ngoal (1 subgoal):\n 1. \\<And>ns s m i v sa ms ma.\n       \\<lbrakk>g \\<turnstile> ns\\<Down>\\<^sub>s s;\n        \\<And>v sa ms m.\n           \\<lbrakk>g \\<turnstile> ns\\<Down>sa;\n            g \\<turnstile> last ns-ms\\<rightarrow>m; v \\<in> allUses g m;\n            \\<forall>n\\<in>set (tl ms).\n               var g v \\<notin> var g ` allDefs g n\\<rbrakk>\n           \\<Longrightarrow> sa (var g v) = s v;\n        last ns = old.predecessors g m ! i; m \\<in> set (\\<alpha>n g);\n        i < length (old.predecessors g m); g \\<turnstile> ns @ [m]\\<Down>sa;\n        g \\<turnstile> last (ns @ [m])-ms\\<rightarrow>ma;\n        v \\<in> allUses g ma;\n        \\<forall>n\\<in>set (tl ms).\n           var g v \\<notin> var g ` allDefs g n\\<rbrakk>\n       \\<Longrightarrow> sa (var g v) = ssaStep g m i s v", "from snoc.prems(2)"], ["proof (chain)\npicking this:\n  g \\<turnstile> last (ns @ [n])-ms\\<rightarrow>m", "have[simp]: \"n \\<in> set (\\<alpha>n g)\" \"m \\<in> set (\\<alpha>n g)\""], ["proof (prove)\nusing this:\n  g \\<turnstile> last (ns @ [n])-ms\\<rightarrow>m\n\ngoal (1 subgoal):\n 1. n \\<in> set (\\<alpha>n g) &&& m \\<in> set (\\<alpha>n g)", "by auto"], ["proof (state)\nthis:\n  n \\<in> set (\\<alpha>n g)\n  m \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. \\<And>ns s m i v sa ms ma.\n       \\<lbrakk>g \\<turnstile> ns\\<Down>\\<^sub>s s;\n        \\<And>v sa ms m.\n           \\<lbrakk>g \\<turnstile> ns\\<Down>sa;\n            g \\<turnstile> last ns-ms\\<rightarrow>m; v \\<in> allUses g m;\n            \\<forall>n\\<in>set (tl ms).\n               var g v \\<notin> var g ` allDefs g n\\<rbrakk>\n           \\<Longrightarrow> sa (var g v) = s v;\n        last ns = old.predecessors g m ! i; m \\<in> set (\\<alpha>n g);\n        i < length (old.predecessors g m); g \\<turnstile> ns @ [m]\\<Down>sa;\n        g \\<turnstile> last (ns @ [m])-ms\\<rightarrow>ma;\n        v \\<in> allUses g ma;\n        \\<forall>n\\<in>set (tl ms).\n           var g v \\<notin> var g ` allDefs g n\\<rbrakk>\n       \\<Longrightarrow> sa (var g v) = ssaStep g m i s v", "from snoc.prems(2,3)"], ["proof (chain)\npicking this:\n  g \\<turnstile> last (ns @ [n])-ms\\<rightarrow>m\n  v \\<in> allUses g m", "have[simp]: \"v \\<in> allVars g\""], ["proof (prove)\nusing this:\n  g \\<turnstile> last (ns @ [n])-ms\\<rightarrow>m\n  v \\<in> allUses g m\n\ngoal (1 subgoal):\n 1. v \\<in> allVars g", "by - (rule allUses_in_allVars, auto)"], ["proof (state)\nthis:\n  v \\<in> allVars g\n\ngoal (1 subgoal):\n 1. \\<And>ns s m i v sa ms ma.\n       \\<lbrakk>g \\<turnstile> ns\\<Down>\\<^sub>s s;\n        \\<And>v sa ms m.\n           \\<lbrakk>g \\<turnstile> ns\\<Down>sa;\n            g \\<turnstile> last ns-ms\\<rightarrow>m; v \\<in> allUses g m;\n            \\<forall>n\\<in>set (tl ms).\n               var g v \\<notin> var g ` allDefs g n\\<rbrakk>\n           \\<Longrightarrow> sa (var g v) = s v;\n        last ns = old.predecessors g m ! i; m \\<in> set (\\<alpha>n g);\n        i < length (old.predecessors g m); g \\<turnstile> ns @ [m]\\<Down>sa;\n        g \\<turnstile> last (ns @ [m])-ms\\<rightarrow>ma;\n        v \\<in> allUses g ma;\n        \\<forall>n\\<in>set (tl ms).\n           var g v \\<notin> var g ` allDefs g n\\<rbrakk>\n       \\<Longrightarrow> sa (var g v) = ssaStep g m i s v", "from snoc.hyps(4)"], ["proof (chain)\npicking this:\n  i < length (old.predecessors g n)", "have[simp]: \"n \\<noteq> Entry g\""], ["proof (prove)\nusing this:\n  i < length (old.predecessors g n)\n\ngoal (1 subgoal):\n 1. n \\<noteq> Entry g", "by (auto simp: Entry_no_predecessor)"], ["proof (state)\nthis:\n  n \\<noteq> Entry g\n\ngoal (1 subgoal):\n 1. \\<And>ns s m i v sa ms ma.\n       \\<lbrakk>g \\<turnstile> ns\\<Down>\\<^sub>s s;\n        \\<And>v sa ms m.\n           \\<lbrakk>g \\<turnstile> ns\\<Down>sa;\n            g \\<turnstile> last ns-ms\\<rightarrow>m; v \\<in> allUses g m;\n            \\<forall>n\\<in>set (tl ms).\n               var g v \\<notin> var g ` allDefs g n\\<rbrakk>\n           \\<Longrightarrow> sa (var g v) = s v;\n        last ns = old.predecessors g m ! i; m \\<in> set (\\<alpha>n g);\n        i < length (old.predecessors g m); g \\<turnstile> ns @ [m]\\<Down>sa;\n        g \\<turnstile> last (ns @ [m])-ms\\<rightarrow>ma;\n        v \\<in> allUses g ma;\n        \\<forall>n\\<in>set (tl ms).\n           var g v \\<notin> var g ` allDefs g n\\<rbrakk>\n       \\<Longrightarrow> sa (var g v) = ssaStep g m i s v", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. s (var g v) = ssaStep g n i s' v", "proof (cases \"var g v \\<in> var g ` allDefs g n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. var g v \\<in> var g ` allDefs g n \\<Longrightarrow>\n    s (var g v) = ssaStep g n i s' v\n 2. var g v \\<notin> var g ` allDefs g n \\<Longrightarrow>\n    s (var g v) = ssaStep g n i s' v", "case True"], ["proof (state)\nthis:\n  var g v \\<in> var g ` allDefs g n\n\ngoal (2 subgoals):\n 1. var g v \\<in> var g ` allDefs g n \\<Longrightarrow>\n    s (var g v) = ssaStep g n i s' v\n 2. var g v \\<notin> var g ` allDefs g n \\<Longrightarrow>\n    s (var g v) = ssaStep g n i s' v", "have[simp]: \"defNode g v = n\" (is \"?n\\<^sub>v = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. defNode g v = n", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. defNode g v = n", "from True"], ["proof (chain)\npicking this:\n  var g v \\<in> var g ` allDefs g n", "obtain v' where v': \"v' \\<in> allDefs g n\" \"var g v' = var g v\""], ["proof (prove)\nusing this:\n  var g v \\<in> var g ` allDefs g n\n\ngoal (1 subgoal):\n 1. (\\<And>v'.\n        \\<lbrakk>v' \\<in> allDefs g n; var g v' = var g v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v' \\<in> allDefs g n\n  var g v' = var g v\n\ngoal (1 subgoal):\n 1. defNode g v = n", "from snoc.prems(3)"], ["proof (chain)\npicking this:\n  v \\<in> allUses g m", "have \"defAss g m v\""], ["proof (prove)\nusing this:\n  v \\<in> allUses g m\n\ngoal (1 subgoal):\n 1. defAss g m v", "by - (rule allUses_def_ass, auto)"], ["proof (state)\nthis:\n  defAss g m v\n\ngoal (1 subgoal):\n 1. defNode g v = n", "moreover"], ["proof (state)\nthis:\n  defAss g m v\n\ngoal (1 subgoal):\n 1. defNode g v = n", "from snoc.prems(1)"], ["proof (chain)\npicking this:\n  g \\<turnstile> ns @ [n]\\<Down>s", "obtain ns' where ns': \"g \\<turnstile> Entry g-ns'\\<rightarrow>n\" \"set ns' \\<subseteq> set (ns@[n])\" \"distinct ns'\""], ["proof (prove)\nusing this:\n  g \\<turnstile> ns @ [n]\\<Down>s\n\ngoal (1 subgoal):\n 1. (\\<And>ns'.\n        \\<lbrakk>g \\<turnstile> Entry g-ns'\\<rightarrow>n;\n         set ns' \\<subseteq> set (ns @ [n]); distinct ns'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: bs.cases intro: old.simple_path2)"], ["proof (state)\nthis:\n  g \\<turnstile> Entry g-ns'\\<rightarrow>n\n  set ns' \\<subseteq> set (ns @ [n])\n  distinct ns'\n\ngoal (1 subgoal):\n 1. defNode g v = n", "ultimately"], ["proof (chain)\npicking this:\n  defAss g m v\n  g \\<turnstile> Entry g-ns'\\<rightarrow>n\n  set ns' \\<subseteq> set (ns @ [n])\n  distinct ns'", "have \"?n\\<^sub>v \\<in> set (ns'@tl ms)\""], ["proof (prove)\nusing this:\n  defAss g m v\n  g \\<turnstile> Entry g-ns'\\<rightarrow>n\n  set ns' \\<subseteq> set (ns @ [n])\n  distinct ns'\n\ngoal (1 subgoal):\n 1. defNode g v \\<in> set (ns' @ tl ms)", "using snoc.prems(2)"], ["proof (prove)\nusing this:\n  defAss g m v\n  g \\<turnstile> Entry g-ns'\\<rightarrow>n\n  set ns' \\<subseteq> set (ns @ [n])\n  distinct ns'\n  g \\<turnstile> last (ns @ [n])-ms\\<rightarrow>m\n\ngoal (1 subgoal):\n 1. defNode g v \\<in> set (ns' @ tl ms)", "by - (drule defAss_defNode, auto elim!: bs.cases dest: old.path2_app)"], ["proof (state)\nthis:\n  defNode g v \\<in> set (ns' @ tl ms)\n\ngoal (1 subgoal):\n 1. defNode g v = n", "moreover"], ["proof (state)\nthis:\n  defNode g v \\<in> set (ns' @ tl ms)\n\ngoal (1 subgoal):\n 1. defNode g v = n", "{"], ["proof (state)\nthis:\n  defNode g v \\<in> set (ns' @ tl ms)\n\ngoal (1 subgoal):\n 1. defNode g v = n", "let ?n'' = \"last (butlast ns')\""], ["proof (state)\ngoal (1 subgoal):\n 1. defNode g v = n", "assume asm: \"?n\\<^sub>v \\<in> set (butlast ns')\""], ["proof (state)\nthis:\n  defNode g v \\<in> set (butlast ns')\n\ngoal (1 subgoal):\n 1. defNode g v = n", "with ns'(1,3)"], ["proof (chain)\npicking this:\n  g \\<turnstile> Entry g-ns'\\<rightarrow>n\n  distinct ns'\n  defNode g v \\<in> set (butlast ns')", "have[simp]: \"?n\\<^sub>v \\<noteq> n\""], ["proof (prove)\nusing this:\n  g \\<turnstile> Entry g-ns'\\<rightarrow>n\n  distinct ns'\n  defNode g v \\<in> set (butlast ns')\n\ngoal (1 subgoal):\n 1. defNode g v \\<noteq> n", "by (cases ns' rule: rev_cases, auto dest!: old.path2_last)"], ["proof (state)\nthis:\n  defNode g v \\<noteq> n\n\ngoal (1 subgoal):\n 1. defNode g v = n", "from ns'(1)"], ["proof (chain)\npicking this:\n  g \\<turnstile> Entry g-ns'\\<rightarrow>n", "have \"length ns' \\<ge> 2\""], ["proof (prove)\nusing this:\n  g \\<turnstile> Entry g-ns'\\<rightarrow>n\n\ngoal (1 subgoal):\n 1. 2 \\<le> length ns'", "by auto"], ["proof (state)\nthis:\n  2 \\<le> length ns'\n\ngoal (1 subgoal):\n 1. defNode g v = n", "with ns'"], ["proof (chain)\npicking this:\n  g \\<turnstile> Entry g-ns'\\<rightarrow>n\n  set ns' \\<subseteq> set (ns @ [n])\n  distinct ns'\n  2 \\<le> length ns'", "have bns': \"g \\<turnstile> Entry g-butlast ns'\\<rightarrow>?n''\" \"?n'' \\<in> set (old.predecessors g n)\""], ["proof (prove)\nusing this:\n  g \\<turnstile> Entry g-ns'\\<rightarrow>n\n  set ns' \\<subseteq> set (ns @ [n])\n  distinct ns'\n  2 \\<le> length ns'\n\ngoal (1 subgoal):\n 1. g \\<turnstile> Entry g-butlast ns'\\<rightarrow>last (butlast ns') &&&\n    last (butlast ns') \\<in> set (old.predecessors g n)", "by (auto elim: old.path2_unsnoc)"], ["proof (state)\nthis:\n  g \\<turnstile> Entry g-butlast ns'\\<rightarrow>last (butlast ns')\n  last (butlast ns') \\<in> set (old.predecessors g n)\n\ngoal (1 subgoal):\n 1. defNode g v = n", "with asm"], ["proof (chain)\npicking this:\n  defNode g v \\<in> set (butlast ns')\n  g \\<turnstile> Entry g-butlast ns'\\<rightarrow>last (butlast ns')\n  last (butlast ns') \\<in> set (old.predecessors g n)", "obtain ns'' where ns'': \"g \\<turnstile> ?n\\<^sub>v-ns''\\<rightarrow>?n''\" \"suffix ns'' (butlast ns')\" \"?n\\<^sub>v \\<notin> set (tl ns'')\""], ["proof (prove)\nusing this:\n  defNode g v \\<in> set (butlast ns')\n  g \\<turnstile> Entry g-butlast ns'\\<rightarrow>last (butlast ns')\n  last (butlast ns') \\<in> set (old.predecessors g n)\n\ngoal (1 subgoal):\n 1. (\\<And>ns''.\n        \\<lbrakk>g \\<turnstile> defNode g\n                                 v-ns''\\<rightarrow>last (butlast ns');\n         suffix ns'' (butlast ns');\n         defNode g v \\<notin> set (tl ns'')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by - (rule old.path2_split_first_last, auto)"], ["proof (state)\nthis:\n  g \\<turnstile> defNode g v-ns''\\<rightarrow>last (butlast ns')\n  suffix ns'' (butlast ns')\n  defNode g v \\<notin> set (tl ns'')\n\ngoal (1 subgoal):\n 1. defNode g v = n", "with bns' snoc.prems(2)"], ["proof (chain)\npicking this:\n  g \\<turnstile> Entry g-butlast ns'\\<rightarrow>last (butlast ns')\n  last (butlast ns') \\<in> set (old.predecessors g n)\n  g \\<turnstile> last (ns @ [n])-ms\\<rightarrow>m\n  g \\<turnstile> defNode g v-ns''\\<rightarrow>last (butlast ns')\n  suffix ns'' (butlast ns')\n  defNode g v \\<notin> set (tl ns'')", "have \"g \\<turnstile> ?n\\<^sub>v-(ns''@[n])@tl ms\\<rightarrow>m\""], ["proof (prove)\nusing this:\n  g \\<turnstile> Entry g-butlast ns'\\<rightarrow>last (butlast ns')\n  last (butlast ns') \\<in> set (old.predecessors g n)\n  g \\<turnstile> last (ns @ [n])-ms\\<rightarrow>m\n  g \\<turnstile> defNode g v-ns''\\<rightarrow>last (butlast ns')\n  suffix ns'' (butlast ns')\n  defNode g v \\<notin> set (tl ns'')\n\ngoal (1 subgoal):\n 1. g \\<turnstile> defNode g v-(ns'' @ [n]) @ tl ms\\<rightarrow>m", "by - (rule old.path2_app, auto)"], ["proof (state)\nthis:\n  g \\<turnstile> defNode g v-(ns'' @ [n]) @ tl ms\\<rightarrow>m\n\ngoal (1 subgoal):\n 1. defNode g v = n", "hence \"defNode g v' \\<notin> set (tl (ns''@[n]@tl ms))\""], ["proof (prove)\nusing this:\n  g \\<turnstile> defNode g v-(ns'' @ [n]) @ tl ms\\<rightarrow>m\n\ngoal (1 subgoal):\n 1. defNode g v' \\<notin> set (tl (ns'' @ [n] @ tl ms))", "using v' snoc.prems(3,4) bns'(2) ns''(1,3)"], ["proof (prove)\nusing this:\n  g \\<turnstile> defNode g v-(ns'' @ [n]) @ tl ms\\<rightarrow>m\n  v' \\<in> allDefs g n\n  var g v' = var g v\n  v \\<in> allUses g m\n  \\<forall>n\\<in>set (tl ms). var g v \\<notin> var g ` allDefs g n\n  last (butlast ns') \\<in> set (old.predecessors g n)\n  g \\<turnstile> defNode g v-ns''\\<rightarrow>last (butlast ns')\n  defNode g v \\<notin> set (tl ns'')\n\ngoal (1 subgoal):\n 1. defNode g v' \\<notin> set (tl (ns'' @ [n] @ tl ms))", "by - (rule conventional''[of g v _ m], auto intro!: old.path2_app simp: old.path2_not_Nil)"], ["proof (state)\nthis:\n  defNode g v' \\<notin> set (tl (ns'' @ [n] @ tl ms))\n\ngoal (1 subgoal):\n 1. defNode g v = n", "with ns' ns''(1) v'(1)"], ["proof (chain)\npicking this:\n  g \\<turnstile> Entry g-ns'\\<rightarrow>n\n  set ns' \\<subseteq> set (ns @ [n])\n  distinct ns'\n  g \\<turnstile> defNode g v-ns''\\<rightarrow>last (butlast ns')\n  v' \\<in> allDefs g n\n  defNode g v' \\<notin> set (tl (ns'' @ [n] @ tl ms))", "have False"], ["proof (prove)\nusing this:\n  g \\<turnstile> Entry g-ns'\\<rightarrow>n\n  set ns' \\<subseteq> set (ns @ [n])\n  distinct ns'\n  g \\<turnstile> defNode g v-ns''\\<rightarrow>last (butlast ns')\n  v' \\<in> allDefs g n\n  defNode g v' \\<notin> set (tl (ns'' @ [n] @ tl ms))\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: old.path2_not_Nil)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. defNode g v = n", "}"], ["proof (state)\nthis:\n  defNode g v \\<in> set (butlast ns') \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. defNode g v = n", "ultimately"], ["proof (chain)\npicking this:\n  defNode g v \\<in> set (ns' @ tl ms)\n  defNode g v \\<in> set (butlast ns') \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  defNode g v \\<in> set (ns' @ tl ms)\n  defNode g v \\<in> set (butlast ns') \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. defNode g v = n", "using snoc.prems(4) ns'(1)"], ["proof (prove)\nusing this:\n  defNode g v \\<in> set (ns' @ tl ms)\n  defNode g v \\<in> set (butlast ns') \\<Longrightarrow> False\n  \\<forall>n\\<in>set (tl ms). var g v \\<notin> var g ` allDefs g n\n  g \\<turnstile> Entry g-ns'\\<rightarrow>n\n\ngoal (1 subgoal):\n 1. defNode g v = n", "by (cases ns' rule: rev_cases, auto dest: old.path2_last)"], ["proof (state)\nthis:\n  defNode g v = n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  defNode g v = n\n\ngoal (2 subgoals):\n 1. var g v \\<in> var g ` allDefs g n \\<Longrightarrow>\n    s (var g v) = ssaStep g n i s' v\n 2. var g v \\<notin> var g ` allDefs g n \\<Longrightarrow>\n    s (var g v) = ssaStep g n i s' v", "from \\<open>v \\<in> allVars g\\<close>"], ["proof (chain)\npicking this:\n  v \\<in> allVars g", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> allVars g\n\ngoal (1 subgoal):\n 1. s (var g v) = ssaStep g n i s' v", "proof (cases rule: defNode_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> defs g (defNode g v) \\<Longrightarrow>\n    s (var g v) = ssaStep g n i s' v\n 2. phi g v \\<noteq> None \\<Longrightarrow> s (var g v) = ssaStep g n i s' v", "case simpleDef"], ["proof (state)\nthis:\n  v \\<in> defs g (defNode g v)\n\ngoal (2 subgoals):\n 1. v \\<in> defs g (defNode g v) \\<Longrightarrow>\n    s (var g v) = ssaStep g n i s' v\n 2. phi g v \\<noteq> None \\<Longrightarrow> s (var g v) = ssaStep g n i s' v", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> defs g (defNode g v)\n\ngoal (1 subgoal):\n 1. s (var g v) = ssaStep g n i s' v", "using snoc.prems(1)"], ["proof (prove)\nusing this:\n  v \\<in> defs g (defNode g v)\n  g \\<turnstile> ns @ [n]\\<Down>s\n\ngoal (1 subgoal):\n 1. s (var g v) = ssaStep g n i s' v", "by - (erule bs.cases, auto simp: step_def ssaStep_def oldDefs_def)"], ["proof (state)\nthis:\n  s (var g v) = ssaStep g n i s' v\n\ngoal (1 subgoal):\n 1. phi g v \\<noteq> None \\<Longrightarrow> s (var g v) = ssaStep g n i s' v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. phi g v \\<noteq> None \\<Longrightarrow> s (var g v) = ssaStep g n i s' v", "case phi"], ["proof (state)\nthis:\n  phi g v \\<noteq> None\n\ngoal (1 subgoal):\n 1. phi g v \\<noteq> None \\<Longrightarrow> s (var g v) = ssaStep g n i s' v", "{"], ["proof (state)\nthis:\n  phi g v \\<noteq> None\n\ngoal (1 subgoal):\n 1. phi g v \\<noteq> None \\<Longrightarrow> s (var g v) = ssaStep g n i s' v", "fix v'"], ["proof (state)\ngoal (1 subgoal):\n 1. phi g v \\<noteq> None \\<Longrightarrow> s (var g v) = ssaStep g n i s' v", "assume asm: \"v' \\<in> defs g n\" \"var g v = var g v'\""], ["proof (state)\nthis:\n  v' \\<in> defs g n\n  var g v = var g v'\n\ngoal (1 subgoal):\n 1. phi g v \\<noteq> None \\<Longrightarrow> s (var g v) = ssaStep g n i s' v", "with phi"], ["proof (chain)\npicking this:\n  phi g v \\<noteq> None\n  v' \\<in> defs g n\n  var g v = var g v'", "have \"v' = v\""], ["proof (prove)\nusing this:\n  phi g v \\<noteq> None\n  v' \\<in> defs g n\n  var g v = var g v'\n\ngoal (1 subgoal):\n 1. v' = v", "using allDefs_var_disjoint[of n g v' v]"], ["proof (prove)\nusing this:\n  phi g v \\<noteq> None\n  v' \\<in> defs g n\n  var g v = var g v'\n  \\<lbrakk>n \\<in> set (\\<alpha>n g); v' \\<in> allDefs g n;\n   v \\<in> allDefs g n; v' \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> var g v \\<noteq> var g v'\n\ngoal (1 subgoal):\n 1. v' = v", "by (cases, auto dest!: phi_phiDefs)"], ["proof (state)\nthis:\n  v' = v\n\ngoal (1 subgoal):\n 1. phi g v \\<noteq> None \\<Longrightarrow> s (var g v) = ssaStep g n i s' v", "with asm(1) phi"], ["proof (chain)\npicking this:\n  v' \\<in> defs g n\n  phi g v \\<noteq> None\n  v' = v", "have False"], ["proof (prove)\nusing this:\n  v' \\<in> defs g n\n  phi g v \\<noteq> None\n  v' = v\n\ngoal (1 subgoal):\n 1. False", "using simpleDefs_phiDefs_disjoint[of n g]"], ["proof (prove)\nusing this:\n  v' \\<in> defs g n\n  phi g v \\<noteq> None\n  v' = v\n  n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n  defs g n \\<inter> phiDefs g n = {}\n\ngoal (1 subgoal):\n 1. False", "by (auto dest!: phi_phiDefs)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. phi g v \\<noteq> None \\<Longrightarrow> s (var g v) = ssaStep g n i s' v", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?v'3 \\<in> defs g n; var g v = var g ?v'3\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. phi g v \\<noteq> None \\<Longrightarrow> s (var g v) = ssaStep g n i s' v", "note 1 = this"], ["proof (state)\nthis:\n  \\<lbrakk>?v'3 \\<in> defs g n; var g v = var g ?v'3\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. phi g v \\<noteq> None \\<Longrightarrow> s (var g v) = ssaStep g n i s' v", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?v'3 \\<in> defs g n; var g v = var g ?v'3\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. phi g v \\<noteq> None \\<Longrightarrow> s (var g v) = ssaStep g n i s' v", "fix vs"], ["proof (state)\ngoal (1 subgoal):\n 1. phi g v \\<noteq> None \\<Longrightarrow> s (var g v) = ssaStep g n i s' v", "assume asm: \"g \\<turnstile> Entry g-ns @ [n]\\<rightarrow>n\" \"phis g (n, v) = Some vs\" \"var g v \\<notin> var g ` defs g n\""], ["proof (state)\nthis:\n  g \\<turnstile> Entry g-ns @ [n]\\<rightarrow>n\n  phis g (n, v) = Some vs\n  var g v \\<notin> var g ` defs g n\n\ngoal (1 subgoal):\n 1. phi g v \\<noteq> None \\<Longrightarrow> s (var g v) = ssaStep g n i s' v", "let ?n' = \"last ns\""], ["proof (state)\ngoal (1 subgoal):\n 1. phi g v \\<noteq> None \\<Longrightarrow> s (var g v) = ssaStep g n i s' v", "from asm(1)"], ["proof (chain)\npicking this:\n  g \\<turnstile> Entry g-ns @ [n]\\<rightarrow>n", "have \"length ns \\<ge> 1\""], ["proof (prove)\nusing this:\n  g \\<turnstile> Entry g-ns @ [n]\\<rightarrow>n\n\ngoal (1 subgoal):\n 1. 1 \\<le> length ns", "by (cases ns, auto simp: old.path2_def)"], ["proof (state)\nthis:\n  1 \\<le> length ns\n\ngoal (1 subgoal):\n 1. phi g v \\<noteq> None \\<Longrightarrow> s (var g v) = ssaStep g n i s' v", "hence \"g \\<turnstile> Entry g-ns\\<rightarrow>?n'\""], ["proof (prove)\nusing this:\n  1 \\<le> length ns\n\ngoal (1 subgoal):\n 1. g \\<turnstile> Entry g-ns\\<rightarrow>last ns", "by - (rule old.path2_unsnoc[OF asm(1)], auto)"], ["proof (state)\nthis:\n  g \\<turnstile> Entry g-ns\\<rightarrow>last ns\n\ngoal (1 subgoal):\n 1. phi g v \\<noteq> None \\<Longrightarrow> s (var g v) = ssaStep g n i s' v", "moreover"], ["proof (state)\nthis:\n  g \\<turnstile> Entry g-ns\\<rightarrow>last ns\n\ngoal (1 subgoal):\n 1. phi g v \\<noteq> None \\<Longrightarrow> s (var g v) = ssaStep g n i s' v", "have \"vs ! i \\<in> phiUses g ?n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs ! i \\<in> phiUses g (last ns)", "using snoc.hyps(2,4) phis_wf[OF asm(2)]"], ["proof (prove)\nusing this:\n  last ns = old.predecessors g n ! i\n  i < length (old.predecessors g n)\n  length (old.predecessors g n) = length vs\n\ngoal (1 subgoal):\n 1. vs ! i \\<in> phiUses g (last ns)", "by - (rule phiUsesI[OF _ asm(2)], auto simp: set_zip)"], ["proof (state)\nthis:\n  vs ! i \\<in> phiUses g (last ns)\n\ngoal (1 subgoal):\n 1. phi g v \\<noteq> None \\<Longrightarrow> s (var g v) = ssaStep g n i s' v", "ultimately"], ["proof (chain)\npicking this:\n  g \\<turnstile> Entry g-ns\\<rightarrow>last ns\n  vs ! i \\<in> phiUses g (last ns)", "have \"fold (step g) ns Map.empty (var g (vs ! i)) = s' (vs ! i)\""], ["proof (prove)\nusing this:\n  g \\<turnstile> Entry g-ns\\<rightarrow>last ns\n  vs ! i \\<in> phiUses g (last ns)\n\ngoal (1 subgoal):\n 1. fold (step g) ns Map.empty (var g (vs ! i)) = s' (vs ! i)", "by - (rule snoc.IH[where ms1=\"[?n']\" and m1=\"?n'\"], auto intro!: bs.intros)"], ["proof (state)\nthis:\n  fold (step g) ns Map.empty (var g (vs ! i)) = s' (vs ! i)\n\ngoal (1 subgoal):\n 1. phi g v \\<noteq> None \\<Longrightarrow> s (var g v) = ssaStep g n i s' v", "hence \"fold (step g) ns Map.empty (var g v) = s' (vs ! i)\""], ["proof (prove)\nusing this:\n  fold (step g) ns Map.empty (var g (vs ! i)) = s' (vs ! i)\n\ngoal (1 subgoal):\n 1. fold (step g) ns Map.empty (var g v) = s' (vs ! i)", "using phis_same_var[OF asm(2), of \"vs ! i\"] snoc.hyps(4) phis_wf[OF asm(2)]"], ["proof (prove)\nusing this:\n  fold (step g) ns Map.empty (var g (vs ! i)) = s' (vs ! i)\n  vs ! i \\<in> set vs \\<Longrightarrow> var g (vs ! i) = var g v\n  i < length (old.predecessors g n)\n  length (old.predecessors g n) = length vs\n\ngoal (1 subgoal):\n 1. fold (step g) ns Map.empty (var g v) = s' (vs ! i)", "by auto"], ["proof (state)\nthis:\n  fold (step g) ns Map.empty (var g v) = s' (vs ! i)\n\ngoal (1 subgoal):\n 1. phi g v \\<noteq> None \\<Longrightarrow> s (var g v) = ssaStep g n i s' v", "}"], ["proof (state)\nthis:\n  \\<lbrakk>g \\<turnstile> Entry g-ns @ [n]\\<rightarrow>n;\n   phis g (n, v) = Some ?vs3; var g v \\<notin> var g ` defs g n\\<rbrakk>\n  \\<Longrightarrow> fold (step g) ns Map.empty (var g v) = s' (?vs3 ! i)\n\ngoal (1 subgoal):\n 1. phi g v \\<noteq> None \\<Longrightarrow> s (var g v) = ssaStep g n i s' v", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>g \\<turnstile> Entry g-ns @ [n]\\<rightarrow>n;\n   phis g (n, v) = Some ?vs3; var g v \\<notin> var g ` defs g n\\<rbrakk>\n  \\<Longrightarrow> fold (step g) ns Map.empty (var g v) = s' (?vs3 ! i)\n\ngoal (1 subgoal):\n 1. s (var g v) = ssaStep g n i s' v", "using phi snoc.prems(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>g \\<turnstile> Entry g-ns @ [n]\\<rightarrow>n;\n   phis g (n, v) = Some ?vs3; var g v \\<notin> var g ` defs g n\\<rbrakk>\n  \\<Longrightarrow> fold (step g) ns Map.empty (var g v) = s' (?vs3 ! i)\n  phi g v \\<noteq> None\n  g \\<turnstile> ns @ [n]\\<Down>s\n\ngoal (1 subgoal):\n 1. s (var g v) = ssaStep g n i s' v", "by - (erule bs.cases, auto dest!: 1 simp: step_def ssaStep_def oldDefs_def phi_def)"], ["proof (state)\nthis:\n  s (var g v) = ssaStep g n i s' v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s (var g v) = ssaStep g n i s' v\n\ngoal (1 subgoal):\n 1. var g v \\<notin> var g ` allDefs g n \\<Longrightarrow>\n    s (var g v) = ssaStep g n i s' v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. var g v \\<notin> var g ` allDefs g n \\<Longrightarrow>\n    s (var g v) = ssaStep g n i s' v", "case False"], ["proof (state)\nthis:\n  var g v \\<notin> var g ` allDefs g n\n\ngoal (1 subgoal):\n 1. var g v \\<notin> var g ` allDefs g n \\<Longrightarrow>\n    s (var g v) = ssaStep g n i s' v", "hence \"phis g (n, v) = None\""], ["proof (prove)\nusing this:\n  var g v \\<notin> var g ` allDefs g n\n\ngoal (1 subgoal):\n 1. phis g (n, v) = None", "by (auto simp: allDefs_def phiDefs_def)"], ["proof (state)\nthis:\n  phis g (n, v) = None\n\ngoal (1 subgoal):\n 1. var g v \\<notin> var g ` allDefs g n \\<Longrightarrow>\n    s (var g v) = ssaStep g n i s' v", "moreover"], ["proof (state)\nthis:\n  phis g (n, v) = None\n\ngoal (1 subgoal):\n 1. var g v \\<notin> var g ` allDefs g n \\<Longrightarrow>\n    s (var g v) = ssaStep g n i s' v", "have \"fold (step g) ns Map.empty (var g v) = s' v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (step g) ns Map.empty (var g v) = s' v", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. fold (step g) ns Map.empty (var g v) = s' v", "from snoc.hyps(1)"], ["proof (chain)\npicking this:\n  g \\<turnstile> ns\\<Down>\\<^sub>s s'", "have \"length ns \\<ge> 1\""], ["proof (prove)\nusing this:\n  g \\<turnstile> ns\\<Down>\\<^sub>s s'\n\ngoal (1 subgoal):\n 1. 1 \\<le> length ns", "by (cases ns, auto)"], ["proof (state)\nthis:\n  1 \\<le> length ns\n\ngoal (1 subgoal):\n 1. fold (step g) ns Map.empty (var g v) = s' v", "moreover"], ["proof (state)\nthis:\n  1 \\<le> length ns\n\ngoal (1 subgoal):\n 1. fold (step g) ns Map.empty (var g v) = s' v", "from snoc.prems(2,4) False"], ["proof (chain)\npicking this:\n  g \\<turnstile> last (ns @ [n])-ms\\<rightarrow>m\n  \\<forall>n\\<in>set (tl ms). var g v \\<notin> var g ` allDefs g n\n  var g v \\<notin> var g ` allDefs g n", "have \"\\<forall>n \\<in> set ms. var g v \\<notin> var g ` allDefs g n\""], ["proof (prove)\nusing this:\n  g \\<turnstile> last (ns @ [n])-ms\\<rightarrow>m\n  \\<forall>n\\<in>set (tl ms). var g v \\<notin> var g ` allDefs g n\n  var g v \\<notin> var g ` allDefs g n\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>set ms. var g v \\<notin> var g ` allDefs g n", "by (cases ms, auto simp: phiDefs_def dest: old.path2_hd)"], ["proof (state)\nthis:\n  \\<forall>n\\<in>set ms. var g v \\<notin> var g ` allDefs g n\n\ngoal (1 subgoal):\n 1. fold (step g) ns Map.empty (var g v) = s' v", "ultimately"], ["proof (chain)\npicking this:\n  1 \\<le> length ns\n  \\<forall>n\\<in>set ms. var g v \\<notin> var g ` allDefs g n", "show ?thesis"], ["proof (prove)\nusing this:\n  1 \\<le> length ns\n  \\<forall>n\\<in>set ms. var g v \\<notin> var g ` allDefs g n\n\ngoal (1 subgoal):\n 1. fold (step g) ns Map.empty (var g v) = s' v", "using snoc.prems(1,2,3)"], ["proof (prove)\nusing this:\n  1 \\<le> length ns\n  \\<forall>n\\<in>set ms. var g v \\<notin> var g ` allDefs g n\n  g \\<turnstile> ns @ [n]\\<Down>s\n  g \\<turnstile> last (ns @ [n])-ms\\<rightarrow>m\n  v \\<in> allUses g m\n\ngoal (1 subgoal):\n 1. fold (step g) ns Map.empty (var g v) = s' v", "by - (rule snoc.IH[where ms1=\"last ns#ms\"], auto elim!: bs.cases intro!: bs.intros elim: old.path2_unsnoc intro!: old.Cons_path2)"], ["proof (state)\nthis:\n  fold (step g) ns Map.empty (var g v) = s' v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fold (step g) ns Map.empty (var g v) = s' v\n\ngoal (1 subgoal):\n 1. var g v \\<notin> var g ` allDefs g n \\<Longrightarrow>\n    s (var g v) = ssaStep g n i s' v", "ultimately"], ["proof (chain)\npicking this:\n  phis g (n, v) = None\n  fold (step g) ns Map.empty (var g v) = s' v", "show ?thesis"], ["proof (prove)\nusing this:\n  phis g (n, v) = None\n  fold (step g) ns Map.empty (var g v) = s' v\n\ngoal (1 subgoal):\n 1. s (var g v) = ssaStep g n i s' v", "using snoc.prems(1) False"], ["proof (prove)\nusing this:\n  phis g (n, v) = None\n  fold (step g) ns Map.empty (var g v) = s' v\n  g \\<turnstile> ns @ [n]\\<Down>s\n  var g v \\<notin> var g ` allDefs g n\n\ngoal (1 subgoal):\n 1. s (var g v) = ssaStep g n i s' v", "by - (erule bs.cases, auto simp: step_def ssaStep_def oldDefs_def)"], ["proof (state)\nthis:\n  s (var g v) = ssaStep g n i s' v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s (var g v) = ssaStep g n i s' v\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem equiv:\n    assumes \"g \\<turnstile> ns\\<Down>s\" \"g \\<turnstile> ns\\<Down>\\<^sub>ss'\" \"v \\<in> uses g (last ns)\"\n    shows \"s (var g v) = s' v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s (var g v) = s' v", "using assms"], ["proof (prove)\nusing this:\n  g \\<turnstile> ns\\<Down>s\n  g \\<turnstile> ns\\<Down>\\<^sub>s s'\n  v \\<in> uses g (last ns)\n\ngoal (1 subgoal):\n 1. s (var g v) = s' v", "by - (rule equiv_aux[where ms=\"[last ns]\"], auto elim!: bs.cases)"], ["", "end"], ["", "end"]]}