{"file_name": "/home/qj213/afp-2021-10-22/thys/Formal_SSA/RBT_Mapping_Exts.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Formal_SSA", "problem_names": ["lemma restrict_mapping_code [code]:\n  \"restrict_mapping f (RBT_Set.Set r) = RBT_Mapping.Mapping (RBT.map (\\<lambda>a _. f a) r)\"", "lemma map_keys_code:\n  assumes \"inj f\"\n  shows \"map_keys f (RBT_Mapping.Mapping t) = RBT.fold (\\<lambda>x v m. Mapping.update (f x) v m) t Mapping.empty\"", "lemma map_values_code [code]:\n  \"map_values f (RBT_Mapping.Mapping t) = RBT.fold (\\<lambda>x v m. case (f x v) of None \\<Rightarrow> m | Some v' \\<Rightarrow> Mapping.update x v' m) t Mapping.empty\"", "lemma [code_unfold]: \"set (RBT.keys t) = RBT_Set.Set (RBT.map (\\<lambda>_ _. ()) t)\"", "lemma mmap_rbt_code [code]: \"mmap f (RBT_Mapping.Mapping t) = RBT_Mapping.Mapping (RBT.map (\\<lambda>_. f) t)\"", "lemma mapping_add_code [code]: \"mapping_add (RBT_Mapping.Mapping t1) (RBT_Mapping.Mapping t2) = RBT_Mapping.Mapping (RBT.union t1 t2)\""], "translations": [["", "lemma restrict_mapping_code [code]:\n  \"restrict_mapping f (RBT_Set.Set r) = RBT_Mapping.Mapping (RBT.map (\\<lambda>a _. f a) r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict_mapping f (RBT_Set.Set r) =\n    RBT_Mapping.Mapping (RBT.map (\\<lambda>a _. f a) r)", "by transfer (auto simp: RBT_Set.Set_def restrict_map_def)"], ["", "lemma map_keys_code:\n  assumes \"inj f\"\n  shows \"map_keys f (RBT_Mapping.Mapping t) = RBT.fold (\\<lambda>x v m. Mapping.update (f x) v m) t Mapping.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_keys f (RBT_Mapping.Mapping t) =\n    RBT.fold (\\<lambda>x. Mapping.update (f x)) t Mapping.empty", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. map_keys f (RBT_Mapping.Mapping t) =\n    RBT.fold (\\<lambda>x. Mapping.update (f x)) t Mapping.empty", "have[simp]: \"\\<And>x. {y. f y = f x} = {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. {y. f y = f x} = {x}", "using assms"], ["proof (prove)\nusing this:\n  inj f\n\ngoal (1 subgoal):\n 1. \\<And>x. {y. f y = f x} = {x}", "by (auto simp: inj_on_def)"], ["proof (state)\nthis:\n  {y. f y = f ?x} = {?x}\n\ngoal (1 subgoal):\n 1. map_keys f (RBT_Mapping.Mapping t) =\n    RBT.fold (\\<lambda>x. Mapping.update (f x)) t Mapping.empty", "have[simp]: \"distinct (map fst (rev (RBT.entries t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (rev (RBT.entries t)))", "apply (subst rev_map[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (rev (map fst (RBT.entries t)))", "apply (subst distinct_rev)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (RBT.entries t))", "apply (rule distinct_entries)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  distinct (map fst (rev (RBT.entries t)))\n\ngoal (1 subgoal):\n 1. map_keys f (RBT_Mapping.Mapping t) =\n    RBT.fold (\\<lambda>x. Mapping.update (f x)) t Mapping.empty", "{"], ["proof (state)\nthis:\n  distinct (map fst (rev (RBT.entries t)))\n\ngoal (1 subgoal):\n 1. map_keys f (RBT_Mapping.Mapping t) =\n    RBT.fold (\\<lambda>x. Mapping.update (f x)) t Mapping.empty", "fix k v"], ["proof (state)\ngoal (1 subgoal):\n 1. map_keys f (RBT_Mapping.Mapping t) =\n    RBT.fold (\\<lambda>x. Mapping.update (f x)) t Mapping.empty", "fix xs :: \"('a \\<times> 'c) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. map_keys f (RBT_Mapping.Mapping t) =\n    RBT.fold (\\<lambda>x. Mapping.update (f x)) t Mapping.empty", "assume asm: \"distinct (map fst xs)\""], ["proof (state)\nthis:\n  distinct (map fst xs)\n\ngoal (1 subgoal):\n 1. map_keys f (RBT_Mapping.Mapping t) =\n    RBT.fold (\\<lambda>x. Mapping.update (f x)) t Mapping.empty", "hence\n      \"(k, v) \\<in> set xs \\<Longrightarrow> Some v = foldr (\\<lambda>(x, v) m. m(f x \\<mapsto> v)) xs Map.empty (f k)\"\n      \"k \\<notin> fst ` set xs \\<Longrightarrow> None = foldr (\\<lambda>(x, v) m. m(f x \\<mapsto> v)) xs Map.empty (f k)\"\n      \"\\<And>x. x \\<notin> f ` UNIV \\<Longrightarrow> None = foldr (\\<lambda>(x, v) m. m(f x \\<mapsto> v)) xs Map.empty x\""], ["proof (prove)\nusing this:\n  distinct (map fst xs)\n\ngoal (1 subgoal):\n 1. ((k, v) \\<in> set xs \\<Longrightarrow>\n     Some v =\n     foldr (\\<lambda>(x, v) m. m(f x \\<mapsto> v)) xs Map.empty (f k)) &&&\n    (k \\<notin> fst ` set xs \\<Longrightarrow>\n     None =\n     foldr (\\<lambda>(x, v) m. m(f x \\<mapsto> v)) xs Map.empty (f k)) &&&\n    (\\<And>x.\n        x \\<notin> range f \\<Longrightarrow>\n        None = foldr (\\<lambda>(x, v) m. m(f x \\<mapsto> v)) xs Map.empty x)", "by (induction xs) (auto simp: image_def dest!: injD[OF assms])"], ["proof (state)\nthis:\n  (k, v) \\<in> set xs \\<Longrightarrow>\n  Some v = foldr (\\<lambda>(x, v) m. m(f x \\<mapsto> v)) xs Map.empty (f k)\n  k \\<notin> fst ` set xs \\<Longrightarrow>\n  None = foldr (\\<lambda>(x, v) m. m(f x \\<mapsto> v)) xs Map.empty (f k)\n  ?x \\<notin> range f \\<Longrightarrow>\n  None = foldr (\\<lambda>(x, v) m. m(f x \\<mapsto> v)) xs Map.empty ?x\n\ngoal (1 subgoal):\n 1. map_keys f (RBT_Mapping.Mapping t) =\n    RBT.fold (\\<lambda>x. Mapping.update (f x)) t Mapping.empty", "}"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (map fst ?xs3); (?k3, ?v3) \\<in> set ?xs3\\<rbrakk>\n  \\<Longrightarrow> Some ?v3 =\n                    foldr (\\<lambda>(x, v) m. m(f x \\<mapsto> v)) ?xs3\n                     Map.empty (f ?k3)\n  \\<lbrakk>distinct (map fst ?xs3); ?k3 \\<notin> fst ` set ?xs3\\<rbrakk>\n  \\<Longrightarrow> None =\n                    foldr (\\<lambda>(x, v) m. m(f x \\<mapsto> v)) ?xs3\n                     Map.empty (f ?k3)\n  \\<lbrakk>distinct (map fst ?xs3); ?x \\<notin> range f\\<rbrakk>\n  \\<Longrightarrow> None =\n                    foldr (\\<lambda>(x, v) m. m(f x \\<mapsto> v)) ?xs3\n                     Map.empty ?x\n\ngoal (1 subgoal):\n 1. map_keys f (RBT_Mapping.Mapping t) =\n    RBT.fold (\\<lambda>x. Mapping.update (f x)) t Mapping.empty", "note a = this[unfolded foldr_conv_fold, where xs3=\"rev _\", simplified]"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (map fst (rev ?uu7)); (?k3, ?v3) \\<in> set ?uu7\\<rbrakk>\n  \\<Longrightarrow> Some ?v3 =\n                    fold (\\<lambda>(x, v) m. m(f x \\<mapsto> v)) ?uu7\n                     Map.empty (f ?k3)\n  \\<lbrakk>distinct (map fst (rev ?uu7));\n   ?k3 \\<notin> fst ` set ?uu7\\<rbrakk>\n  \\<Longrightarrow> None =\n                    fold (\\<lambda>(x, v) m. m(f x \\<mapsto> v)) ?uu7\n                     Map.empty (f ?k3)\n  \\<lbrakk>distinct (map fst (rev ?uu4)); ?x \\<notin> range f\\<rbrakk>\n  \\<Longrightarrow> None =\n                    fold (\\<lambda>(x, v) m. m(f x \\<mapsto> v)) ?uu4\n                     Map.empty ?x\n\ngoal (1 subgoal):\n 1. map_keys f (RBT_Mapping.Mapping t) =\n    RBT.fold (\\<lambda>x. Mapping.update (f x)) t Mapping.empty", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_keys f (RBT_Mapping.Mapping t) =\n    RBT.fold (\\<lambda>x. Mapping.update (f x)) t Mapping.empty", "unfolding RBT.fold_fold"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_keys f (RBT_Mapping.Mapping t) =\n    fold (\\<lambda>(x, y). Mapping.update (f x) y) (RBT.entries t)\n     Mapping.empty", "apply (transfer fixing: t f)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        if f -` {x} \\<noteq> {} then RBT.lookup t (THE k. f -` {x} = {k})\n        else None) =\n    fold (\\<lambda>(x, v) m. m(f x \\<mapsto> v)) (RBT.entries t) Map.empty", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (if f -` {x} \\<noteq> {} then RBT.lookup t (THE k. f -` {x} = {k})\n        else None) =\n       fold (\\<lambda>(x, v) m. m(f x \\<mapsto> v)) (RBT.entries t)\n        Map.empty x", "apply (auto simp: vimage_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       RBT.lookup t xa =\n       fold (\\<lambda>(x, v) m. m(f x \\<mapsto> v)) (RBT.entries t)\n        Map.empty (f xa)\n 2. \\<And>x.\n       \\<forall>xa. f xa \\<noteq> x \\<Longrightarrow>\n       None =\n       fold (\\<lambda>(x, v) m. m(f x \\<mapsto> v)) (RBT.entries t)\n        Map.empty x", "apply (rename_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       RBT.lookup t x =\n       fold (\\<lambda>(x, v) m. m(f x \\<mapsto> v)) (RBT.entries t)\n        Map.empty (f x)\n 2. \\<And>x.\n       \\<forall>xa. f xa \\<noteq> x \\<Longrightarrow>\n       None =\n       fold (\\<lambda>(x, v) m. m(f x \\<mapsto> v)) (RBT.entries t)\n        Map.empty x", "apply (case_tac \"RBT.lookup t x\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       RBT.lookup t x = None \\<Longrightarrow>\n       RBT.lookup t x =\n       fold (\\<lambda>(x, v) m. m(f x \\<mapsto> v)) (RBT.entries t)\n        Map.empty (f x)\n 2. \\<And>x a.\n       RBT.lookup t x = Some a \\<Longrightarrow>\n       RBT.lookup t x =\n       fold (\\<lambda>(x, v) m. m(f x \\<mapsto> v)) (RBT.entries t)\n        Map.empty (f x)\n 3. \\<And>x.\n       \\<forall>xa. f xa \\<noteq> x \\<Longrightarrow>\n       None =\n       fold (\\<lambda>(x, v) m. m(f x \\<mapsto> v)) (RBT.entries t)\n        Map.empty x", "apply (auto simp: lookup_in_tree[symmetric] intro!: a(2))[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a.\n       RBT.lookup t x = Some a \\<Longrightarrow>\n       RBT.lookup t x =\n       fold (\\<lambda>(x, v) m. m(f x \\<mapsto> v)) (RBT.entries t)\n        Map.empty (f x)\n 2. \\<And>x.\n       \\<forall>xa. f xa \\<noteq> x \\<Longrightarrow>\n       None =\n       fold (\\<lambda>(x, v) m. m(f x \\<mapsto> v)) (RBT.entries t)\n        Map.empty x", "apply (auto dest!: lookup_in_tree[THEN iffD1] intro!: a(1))[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>xa. f xa \\<noteq> x \\<Longrightarrow>\n       None =\n       fold (\\<lambda>(x, v) m. m(f x \\<mapsto> v)) (RBT.entries t)\n        Map.empty x", "apply (rule a(3); auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map_keys f (RBT_Mapping.Mapping t) =\n  RBT.fold (\\<lambda>x. Mapping.update (f x)) t Mapping.empty\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_values_code [code]:\n  \"map_values f (RBT_Mapping.Mapping t) = RBT.fold (\\<lambda>x v m. case (f x v) of None \\<Rightarrow> m | Some v' \\<Rightarrow> Mapping.update x v' m) t Mapping.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_values f (RBT_Mapping.Mapping t) =\n    RBT.fold\n     (\\<lambda>x v m.\n         case f x v of None \\<Rightarrow> m\n         | Some v' \\<Rightarrow> Mapping.update x v' m)\n     t Mapping.empty", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_values f (RBT_Mapping.Mapping t) =\n    RBT.fold\n     (\\<lambda>x v m.\n         case f x v of None \\<Rightarrow> m\n         | Some v' \\<Rightarrow> Mapping.update x v' m)\n     t Mapping.empty", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. map_values f (RBT_Mapping.Mapping t) =\n    RBT.fold\n     (\\<lambda>x v m.\n         case f x v of None \\<Rightarrow> m\n         | Some v' \\<Rightarrow> Mapping.update x v' m)\n     t Mapping.empty", "fix xs m"], ["proof (state)\ngoal (1 subgoal):\n 1. map_values f (RBT_Mapping.Mapping t) =\n    RBT.fold\n     (\\<lambda>x v m.\n         case f x v of None \\<Rightarrow> m\n         | Some v' \\<Rightarrow> Mapping.update x v' m)\n     t Mapping.empty", "assume \"distinct (map fst (xs::('a \\<times> 'c) list))\""], ["proof (state)\nthis:\n  distinct (map fst xs)\n\ngoal (1 subgoal):\n 1. map_values f (RBT_Mapping.Mapping t) =\n    RBT.fold\n     (\\<lambda>x v m.\n         case f x v of None \\<Rightarrow> m\n         | Some v' \\<Rightarrow> Mapping.update x v' m)\n     t Mapping.empty", "hence \"fold (\\<lambda>p m. case f (fst p) (snd p) of None \\<Rightarrow> m | Some v' \\<Rightarrow> m(fst p \\<mapsto> v')) xs m\n       = m ++ (\\<lambda>x. Option.bind (map_of xs x) (f x))\""], ["proof (prove)\nusing this:\n  distinct (map fst xs)\n\ngoal (1 subgoal):\n 1. fold\n     (\\<lambda>p m.\n         case f (fst p) (snd p) of None \\<Rightarrow> m\n         | Some v' \\<Rightarrow> m(fst p \\<mapsto> v'))\n     xs m =\n    m ++ (\\<lambda>x. Option.bind (map_of xs x) (f x))", "by (induction xs arbitrary: m) (auto intro: rev_image_eqI split: bind_split option.splits simp: map_add_def fun_eq_iff)"], ["proof (state)\nthis:\n  fold\n   (\\<lambda>p m.\n       case f (fst p) (snd p) of None \\<Rightarrow> m\n       | Some v' \\<Rightarrow> m(fst p \\<mapsto> v'))\n   xs m =\n  m ++ (\\<lambda>x. Option.bind (map_of xs x) (f x))\n\ngoal (1 subgoal):\n 1. map_values f (RBT_Mapping.Mapping t) =\n    RBT.fold\n     (\\<lambda>x v m.\n         case f x v of None \\<Rightarrow> m\n         | Some v' \\<Rightarrow> Mapping.update x v' m)\n     t Mapping.empty", "}"], ["proof (state)\nthis:\n  distinct (map fst ?xs2) \\<Longrightarrow>\n  fold\n   (\\<lambda>p m.\n       case f (fst p) (snd p) of None \\<Rightarrow> m\n       | Some v' \\<Rightarrow> m(fst p \\<mapsto> v'))\n   ?xs2 ?m2 =\n  ?m2 ++ (\\<lambda>x. Option.bind (map_of ?xs2 x) (f x))\n\ngoal (1 subgoal):\n 1. map_values f (RBT_Mapping.Mapping t) =\n    RBT.fold\n     (\\<lambda>x v m.\n         case f x v of None \\<Rightarrow> m\n         | Some v' \\<Rightarrow> Mapping.update x v' m)\n     t Mapping.empty", "note bind_map_of_fold = this"], ["proof (state)\nthis:\n  distinct (map fst ?xs2) \\<Longrightarrow>\n  fold\n   (\\<lambda>p m.\n       case f (fst p) (snd p) of None \\<Rightarrow> m\n       | Some v' \\<Rightarrow> m(fst p \\<mapsto> v'))\n   ?xs2 ?m2 =\n  ?m2 ++ (\\<lambda>x. Option.bind (map_of ?xs2 x) (f x))\n\ngoal (1 subgoal):\n 1. map_values f (RBT_Mapping.Mapping t) =\n    RBT.fold\n     (\\<lambda>x v m.\n         case f x v of None \\<Rightarrow> m\n         | Some v' \\<Rightarrow> Mapping.update x v' m)\n     t Mapping.empty", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_values f (RBT_Mapping.Mapping t) =\n    RBT.fold\n     (\\<lambda>x v m.\n         case f x v of None \\<Rightarrow> m\n         | Some v' \\<Rightarrow> Mapping.update x v' m)\n     t Mapping.empty", "unfolding RBT.fold_fold"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_values f (RBT_Mapping.Mapping t) =\n    fold\n     (\\<lambda>(x, v) m.\n         case f x v of None \\<Rightarrow> m\n         | Some v' \\<Rightarrow> Mapping.update x v' m)\n     (RBT.entries t) Mapping.empty", "apply (transfer fixing: t f)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. Option.bind (RBT.lookup t x) (f x)) =\n    fold\n     (\\<lambda>(x, v) m.\n         case f x v of None \\<Rightarrow> m\n         | Some v' \\<Rightarrow> m(x \\<mapsto> v'))\n     (RBT.entries t) Map.empty", "apply (simp add: split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. Option.bind (RBT.lookup t x) (f x)) =\n    fold\n     (\\<lambda>p m.\n         case f (fst p) (snd p) of None \\<Rightarrow> m\n         | Some v' \\<Rightarrow> m(fst p \\<mapsto> v'))\n     (RBT.entries t) Map.empty", "apply (rule bind_map_of_fold [of \"RBT.entries t\" Map.empty, simplified, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (RBT.entries t))", "using RBT.distinct_entries distinct_map"], ["proof (prove)\nusing this:\n  distinct (map fst (RBT.entries ?t))\n  distinct (map ?f ?xs) = (distinct ?xs \\<and> inj_on ?f (set ?xs))\n\ngoal (1 subgoal):\n 1. distinct (map fst (RBT.entries t))", "by auto"], ["proof (state)\nthis:\n  map_values f (RBT_Mapping.Mapping t) =\n  RBT.fold\n   (\\<lambda>x v m.\n       case f x v of None \\<Rightarrow> m\n       | Some v' \\<Rightarrow> Mapping.update x v' m)\n   t Mapping.empty\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma [code_unfold]: \"set (RBT.keys t) = RBT_Set.Set (RBT.map (\\<lambda>_ _. ()) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (RBT.keys t) = RBT_Set.Set (RBT.map (\\<lambda>_ _. ()) t)", "by (auto simp: RBT_Set.Set_def RBT.keys_def_alt RBT.lookup_in_tree elim: rev_image_eqI)"], ["", "lemma mmap_rbt_code [code]: \"mmap f (RBT_Mapping.Mapping t) = RBT_Mapping.Mapping (RBT.map (\\<lambda>_. f) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mmap f (RBT_Mapping.Mapping t) =\n    RBT_Mapping.Mapping (RBT.map (\\<lambda>_. f) t)", "unfolding mmap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.map id f (RBT_Mapping.Mapping t) =\n    RBT_Mapping.Mapping (RBT.map (\\<lambda>_. f) t)", "by transfer auto"], ["", "lemma mapping_add_code [code]: \"mapping_add (RBT_Mapping.Mapping t1) (RBT_Mapping.Mapping t2) = RBT_Mapping.Mapping (RBT.union t1 t2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mapping_add (RBT_Mapping.Mapping t1) (RBT_Mapping.Mapping t2) =\n    RBT_Mapping.Mapping (RBT.union t1 t2)", "by transfer (simp add: lookup_union)"], ["", "end"]]}