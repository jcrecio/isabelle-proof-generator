{"file_name": "/home/qj213/afp-2021-10-22/thys/Formal_SSA/Construct_SSA.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Formal_SSA", "problem_names": ["lemma phiDefNodes_aux_cases:\n    obtains (nonrec) \"phiDefNodes_aux g v unvisited n = {}\" \"(n \\<notin> set unvisited \\<or> v \\<in> defs g n)\"\n    | (rec) \"phiDefNodes_aux g v unvisited n = fold union (map (phiDefNodes_aux g v (removeAll n unvisited)) (predecessors g n))\n          (if length (predecessors g n) = 1 then {} else {n})\"\n       \"n \\<in> set unvisited\" \"v \\<notin> defs g n\"", "lemma phiDefNode_aux_is_join_node:\n    assumes \"n \\<in> phiDefNodes_aux g v un m\"\n    shows \"length (predecessors g n) \\<noteq> 1\"", "lemma phiDefNode_is_join_node:\n    assumes \"n \\<in> phiDefNodes g v\"\n    shows \"length (predecessors g n) \\<noteq> 1\"", "lemma unvisitedPath_removeLast:\n    assumes \"unvisitedPath un ns\" \"length ns \\<ge> 2\"\n    shows \"unvisitedPath (removeAll (last ns) un) (butlast ns)\"", "lemma phiDefNodes_auxI:\n    assumes \"g \\<turnstile> n-ns\\<rightarrow>m\" \"unvisitedPath un ns\" \"\\<forall>n \\<in> set ns. v \\<notin> defs g n\" \"length (predecessors g n) \\<noteq> 1\"\n    shows \"n \\<in> phiDefNodes_aux g v un m\"", "lemma phiDefNodes_auxE:\n    assumes \"n \\<in> phiDefNodes_aux g v un m\" \"m \\<in> set (\\<alpha>n g)\"\n    obtains ns where \"g \\<turnstile> n-ns\\<rightarrow>m\" \"\\<forall>n \\<in> set ns. v \\<notin> defs g n\" \"length (predecessors g n) \\<noteq> 1\" \"unvisitedPath un ns\"", "lemma phiDefNodesE:\n    assumes \"n \\<in> phiDefNodes g v\"\n    obtains ns m where \"g \\<turnstile> n-ns\\<rightarrow>m\" \"\\<forall>n \\<in> set ns. v \\<notin> defs g n\" \"v \\<in> uses g m\"", "lemma phiDefNodes_\\<alpha>n[simp]: \"n \\<in> phiDefNodes g v \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\"", "lemma phiDefNodesI:\n    assumes \"g \\<turnstile> n-ns\\<rightarrow>m\" \"v \\<in> uses g m\" \"\\<forall>n \\<in> set ns. v \\<notin> defs g n\" \"length (predecessors g n) \\<noteq> 1\"\n    shows \"n \\<in> phiDefNodes g v\"", "lemma lookupDef_cases[consumes 1]:\n    assumes \"n \\<in> set (\\<alpha>n g)\"\n    obtains (SimpleDef) \"v \\<in> defs g n\" \"lookupDef g n v = (v,n,SimpleDef)\"\n          | (PhiDef)    \"v \\<notin> defs g n\" \"length (predecessors g n) \\<noteq> 1\" \"lookupDef g n v = (v,n,PhiDef)\"\n          | (rec) m where \"v \\<notin> defs g n\" \"predecessors g n = [m]\" \"m \\<in> set (\\<alpha>n g)\" \"lookupDef g n v = lookupDef g m v\"", "lemma lookupDef_cases'[consumes 1]:\n    assumes \"n \\<in> set (\\<alpha>n g)\"\n    obtains (SimpleDef) \"v \\<in> defs g n\" \"defNode (lookupDef g n v) = n\" \"defKind (lookupDef g n v) = SimpleDef\"\n          | (PhiDef)    \"v \\<notin> defs g n\" \"length (predecessors g n) \\<noteq> 1\" \"lookupDefNode g n v = n\" \"defKind (lookupDef g n v) = PhiDef\"\n          | (rec) m where \"v \\<notin> defs g n\" \"predecessors g n = [m]\" \"m \\<in> set (\\<alpha>n g)\" \"lookupDef g n v = lookupDef g m v\"", "lemma lookupDefE:\n    assumes \"lookupDef g n v = v'\" \"n \\<in> set (\\<alpha>n g)\"\n    obtains (SimpleDef) \"v \\<in> defs g n\" \"v' = (v,n,SimpleDef)\"\n          | (PhiDef)    \"v \\<notin> defs g n\" \"length (predecessors g n) \\<noteq> 1\" \"v' = (v,n,PhiDef)\"\n          | (rec) m where \"v \\<notin> defs g n\" \"predecessors g n = [m]\" \"m \\<in> set (\\<alpha>n g)\" \"v' = lookupDef g m v\"", "lemma lookupDef_induct[consumes 1, case_names SimpleDef PhiDef rec]:\n    assumes \"n \\<in> set (\\<alpha>n g)\"\n            \"\\<And>n. \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> defs g n; lookupDef g n v = (v,n,SimpleDef)\\<rbrakk> \\<Longrightarrow> P n\"\n            \"\\<And>n. \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<notin> defs g n; length (predecessors g n) \\<noteq> 1; lookupDef g n v = (v,n,PhiDef)\\<rbrakk> \\<Longrightarrow> P n\"\n            \"\\<And>n m. \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m]; m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v; P m\\<rbrakk> \\<Longrightarrow> P n\"\n    shows \"P n\"", "lemma lookupDef_induct'[consumes 2, case_names SimpleDef PhiDef rec]:\n    assumes \"n \\<in> set (\\<alpha>n g)\" \"lookupDef g n v = (v,n',def)\"\n            \"\\<lbrakk>v \\<in> defs g n'; def = SimpleDef\\<rbrakk> \\<Longrightarrow> P n'\"\n            \"\\<lbrakk>v \\<notin> defs g n'; length (predecessors g n') \\<noteq> 1; def = PhiDef\\<rbrakk> \\<Longrightarrow> P n'\"\n            \"\\<And>n m. \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m]; m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v; P m\\<rbrakk> \\<Longrightarrow> P n\"\n    shows \"P n\"", "lemma lookupDef_looksup[simp]:\n    assumes \"lookupDef g n v = (v',n',def)\" \"n \\<in> set (\\<alpha>n g)\"\n    shows \"v' = v\"", "lemma lookupDef_looksup':\n    assumes \"(v',n',def) = lookupDef g n v\" \"n \\<in> set (\\<alpha>n g)\"\n    shows \"v' = v\"", "lemma lookupDef_looksup'':\n    assumes \"n \\<in> set (\\<alpha>n g)\"\n    obtains n' \"def\" where \"lookupDef g n v = (v,n',def)\"", "lemma lookupDef_fst[simp]: \"n \\<in> set (\\<alpha>n g) \\<Longrightarrow> fst (lookupDef g n v) = v\"", "lemma lookupDef_to_\\<alpha>n:\n    assumes \"lookupDef g n v = (v',n',def)\" \"n \\<in> set (\\<alpha>n g)\"\n    shows \"n' \\<in> set (\\<alpha>n g)\"", "lemma lookupDef_to_\\<alpha>n'[simp]:\n    assumes \"lookupDef g n v = val\" \"n \\<in> set (\\<alpha>n g)\"\n    shows \"defNode val \\<in> set (\\<alpha>n g)\"", "lemma lookupDef_induct''[consumes 2, case_names SimpleDef PhiDef rec]:\n    assumes \"lookupDef g n v = val\" \"n \\<in> set (\\<alpha>n g)\"\n            \"\\<lbrakk>v \\<in> defs g (defNode val); defKind val = SimpleDef\\<rbrakk> \\<Longrightarrow> P (defNode val)\"\n            \"\\<lbrakk>v \\<notin> defs g (defNode val); length (predecessors g (defNode val)) \\<noteq> 1; defKind val = PhiDef\\<rbrakk> \\<Longrightarrow> P (defNode val)\"\n            \"\\<And>n m. \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m]; m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v; P m\\<rbrakk> \\<Longrightarrow> P n\"\n    shows \"P n\"", "lemma defs'_finite: \"finite (defs' g n)\"", "lemma uses'_finite: \"finite (uses' g n)\"", "lemma defs'_uses'_disjoint: \"n \\<in> set (\\<alpha>n g) \\<Longrightarrow> defs' g n \\<inter> uses' g n = {}\"", "lemma allDefs'_disjoint: \" n \\<in> set (\\<alpha>n g) \\<Longrightarrow> m \\<in> set (\\<alpha>n g) \\<Longrightarrow> n \\<noteq> m\n    \\<Longrightarrow> (defs' g n \\<union> {v. (n, v) \\<in> dom (phis' g)}) \\<inter> (defs' g m \\<union> {v. (m, v) \\<in> dom (phis' g)}) = {}\"", "lemma phiDefNodes_aux_finite: \"finite (phiDefNodes_aux g v un m)\"", "lemma phis'_finite: \"finite (dom (phis' g))\"", "lemma phis'_wf: \"phis' g (n, v) = Some args \\<Longrightarrow> length (predecessors g n) = length args\"", "lemma simpleDefs_phiDefs_disjoint: \"n \\<in> set (\\<alpha>n g) \\<Longrightarrow> defs' g n \\<inter> {v. (n, v) \\<in> dom (phis' g)} = {}\"", "lemma oldDefs_correct: \"defs g n = var g ` defs' g n\"", "lemma oldUses_correct: \"n \\<in> set (\\<alpha>n g) \\<Longrightarrow> uses g n = var g ` uses' g n\"", "lemmas base_SSA_defs = CFG_SSA_base.CFG_SSA_defs", "lemma no_disjoint_cycle[simp]:\n    assumes \"g \\<turnstile> n-ns\\<rightarrow>n\" \"distinct ns\"\n    shows \"ns = [n]\"", "lemma lookupDef_path:\n    assumes \"m \\<in> set (\\<alpha>n g)\"\n    obtains ns where  \"g \\<turnstile> lookupDefNode g m v-ns\\<rightarrow>m\" \"(\\<forall>x \\<in> set (tl ns). v \\<notin> defs g x)\"", "lemma lookupDef_path_conventional:\n    assumes \"g \\<turnstile> n-ns\\<rightarrow>m\" \"n = lookupDefNode g m v\" \"n \\<notin> set (tl ns)\" \"x \\<in> set (tl ns)\" \"v' \\<in> braun_ssa.allDefs g x\"\n    shows \"var g v' \\<noteq> v\"", "lemma allUse_lookupDef:\n    assumes \"v \\<in> braun_ssa.allUses g m\" \"m \\<in> set (\\<alpha>n g)\"\n    shows \"lookupDef g m (var g v) = v\"", "lemma phis'_fst:\n    assumes \"phis' g (n,v) = Some vs\" \"v' \\<in> set vs\"\n    shows \"var g v' = var g v\"", "lemma allUse_simpleUse:\n    assumes \"v \\<in> braun_ssa.allUses g m\" \"m \\<in> set (\\<alpha>n g)\"\n    obtains ms m' where \"g \\<turnstile> m-ms\\<rightarrow>m'\" \"var g v \\<in> uses g m'\" \"\\<forall>x \\<in> set (tl ms). var g v \\<notin> defs g x\"", "lemma defs': \"v \\<in> defs' g n \\<longleftrightarrow> var g v \\<in> defs g n \\<and> defKind v = SimpleDef \\<and> defNode v = n\"", "lemma use_implies_allDef:\n    assumes \"lookupDef g m (var g v) = v\"  \"m \\<in> set (\\<alpha>n g)\" \"var g v \\<in> uses g m'\" \"g \\<turnstile> m-ms\\<rightarrow>m'\" \"\\<forall>x \\<in> set (tl ms). var g v \\<notin> defs g x\"\n    shows \"v \\<in> braun_ssa.allDefs g (defNode v)\"", "lemma allUse_defNode_in_\\<alpha>n[simp]:\n    assumes \"v \\<in> braun_ssa.allUses g m\" \"m \\<in> set (\\<alpha>n g)\"\n    shows \"defNode v \\<in> set (\\<alpha>n g)\"", "lemma allUse_implies_allDef:\n    assumes \"v \\<in> braun_ssa.allUses g m\" \"m \\<in> set (\\<alpha>n g)\"\n    shows \"v \\<in> braun_ssa.allDefs g (defNode v)\"", "lemma conventional:\n    assumes \"g \\<turnstile> n-ns\\<rightarrow>m\" \"n \\<notin> set (tl ns)\" \"v \\<in> braun_ssa.allDefs g n\" \"v \\<in> braun_ssa.allUses g m\"\n      \"x \\<in> set (tl ns)\" \"v' \\<in> braun_ssa.allDefs g x\"\n    shows \"var g v' \\<noteq> var g v\"", "lemma allDefs_var_disjoint_aux: \"n \\<in> set (\\<alpha>n g) \\<Longrightarrow> v \\<in> defs g n \\<Longrightarrow> n \\<notin> phiDefNodes g v\"", "lemma allDefs_var_disjoint: \"\\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> braun_ssa.allDefs g n; v' \\<in> braun_ssa.allDefs g n; v \\<noteq> v'\\<rbrakk> \\<Longrightarrow> var g v' \\<noteq> var g v\"", "lemma[simp]: \"n \\<in> set (\\<alpha>n g) \\<Longrightarrow> v \\<in> defs g n \\<Longrightarrow> lookupDefNode g n v = n\"", "lemma[simp]: \"n \\<in> set (\\<alpha>n g) \\<Longrightarrow> length (predecessors g n) \\<noteq> 1 \\<Longrightarrow> lookupDefNode g n v = n\"", "lemma lookupDef_idem[simp]:\n    assumes \"n \\<in> set (\\<alpha>n g)\"\n    shows \"lookupDef g (lookupDefNode g n v) v = lookupDef g n v\"", "lemma def_ass_allUses_aux:\n    assumes \"g \\<turnstile> Entry g-ns\\<rightarrow>n\"\n    shows \"lookupDefNode g n (var g v) \\<in> set ns\"", "lemma def_ass_allUses:\n    assumes \"v \\<in> braun_ssa.allUses g n\" \"n \\<in> set (\\<alpha>n g)\"\n    shows \"braun_ssa.defAss g n v\"", "lemma Empty_no_phis:\n    shows \"phis' g (Entry g, v) = None\"", "lemma braun_ssa_CFG_SSA_wf:\n    \"CFG_SSA_wf \\<alpha>e \\<alpha>n invar inEdges' Entry defs' uses' phis'\"", "lemma braun_ssa_CFG_SSA_Transformed:\n    \"CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry defs uses defs' uses' phis' var\"", "lemma PhiDef_defNode_eq:\n    assumes \"n \\<in> set (\\<alpha>n g)\" \"n \\<in> phiDefNodes g v\" \"v \\<in> vars g\"\n    shows \"braun_ssa.defNode g (v,n,PhiDef) = n\"", "lemma phiDefNodes_aux_pruned_aux:\n    assumes \"n \\<in> phiDefNodes_aux g v (\\<alpha>n g) nUse\" \"v \\<in> uses g nUse\" \"g \\<turnstile> n-ns\\<rightarrow>m\" \"g \\<turnstile>m-ms\\<rightarrow>nUse\" \"braun_ssa.liveVal g (lookupDef g m v)\" \"\\<forall>n \\<in> set (ns@ms). v \\<notin> defs g n\"\n    shows \"braun_ssa.liveVal g (v,n,PhiDef)\"", "lemma phiDefNodes_aux_pruned:\n    assumes \"m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n\" \"n \\<in> set (\\<alpha>n g)\" \"v \\<in> uses g n\"\n    shows \"braun_ssa.liveVal g (v, m, PhiDef)\"", "theorem phis'_pruned: \"braun_ssa.pruned g\""], "translations": [["", "lemma phiDefNodes_aux_cases:\n    obtains (nonrec) \"phiDefNodes_aux g v unvisited n = {}\" \"(n \\<notin> set unvisited \\<or> v \\<in> defs g n)\"\n    | (rec) \"phiDefNodes_aux g v unvisited n = fold union (map (phiDefNodes_aux g v (removeAll n unvisited)) (predecessors g n))\n          (if length (predecessors g n) = 1 then {} else {n})\"\n       \"n \\<in> set unvisited\" \"v \\<notin> defs g n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>phiDefNodes_aux g v unvisited n = {};\n              n \\<notin> set unvisited \\<or> v \\<in> defs g n\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>phiDefNodes_aux g v unvisited n =\n              fold (\\<union>)\n               (map (phiDefNodes_aux g v (removeAll n unvisited))\n                 (predecessors g n))\n               (if length (predecessors g n) = 1 then {} else {n});\n      n \\<in> set unvisited; v \\<notin> defs g n\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof (cases \"n \\<in> set unvisited \\<and> v \\<notin> defs g n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>phiDefNodes_aux g v unvisited n = {};\n              n \\<notin> set unvisited \\<or> v \\<in> defs g n\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>phiDefNodes_aux g v unvisited n =\n              fold (\\<union>)\n               (map (phiDefNodes_aux g v (removeAll n unvisited))\n                 (predecessors g n))\n               (if length (predecessors g n) = 1 then {} else {n});\n      n \\<in> set unvisited; v \\<notin> defs g n\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     n \\<in> set unvisited \\<and> v \\<notin> defs g n\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<lbrakk>phiDefNodes_aux g v unvisited n = {};\n              n \\<notin> set unvisited \\<or> v \\<in> defs g n\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>phiDefNodes_aux g v unvisited n =\n              fold (\\<union>)\n               (map (phiDefNodes_aux g v (removeAll n unvisited))\n                 (predecessors g n))\n               (if length (predecessors g n) = 1 then {} else {n});\n      n \\<in> set unvisited; v \\<notin> defs g n\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<not> (n \\<in> set unvisited \\<and> v \\<notin> defs g n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  n \\<in> set unvisited \\<and> v \\<notin> defs g n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>phiDefNodes_aux g v unvisited n = {};\n              n \\<notin> set unvisited \\<or> v \\<in> defs g n\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>phiDefNodes_aux g v unvisited n =\n              fold (\\<union>)\n               (map (phiDefNodes_aux g v (removeAll n unvisited))\n                 (predecessors g n))\n               (if length (predecessors g n) = 1 then {} else {n});\n      n \\<in> set unvisited; v \\<notin> defs g n\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     n \\<in> set unvisited \\<and> v \\<notin> defs g n\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<lbrakk>phiDefNodes_aux g v unvisited n = {};\n              n \\<notin> set unvisited \\<or> v \\<in> defs g n\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>phiDefNodes_aux g v unvisited n =\n              fold (\\<union>)\n               (map (phiDefNodes_aux g v (removeAll n unvisited))\n                 (predecessors g n))\n               (if length (predecessors g n) = 1 then {} else {n});\n      n \\<in> set unvisited; v \\<notin> defs g n\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<not> (n \\<in> set unvisited \\<and> v \\<notin> defs g n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  n \\<in> set unvisited \\<and> v \\<notin> defs g n\n\ngoal (1 subgoal):\n 1. thesis", "using rec"], ["proof (prove)\nusing this:\n  n \\<in> set unvisited \\<and> v \\<notin> defs g n\n  \\<lbrakk>phiDefNodes_aux g v unvisited n =\n           fold (\\<union>)\n            (map (phiDefNodes_aux g v (removeAll n unvisited))\n              (predecessors g n))\n            (if length (predecessors g n) = 1 then {} else {n});\n   n \\<in> set unvisited; v \\<notin> defs g n\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (simp add:phiDefNodes_aux.simps)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>phiDefNodes_aux g v unvisited n = {};\n              n \\<notin> set unvisited \\<or> v \\<in> defs g n\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>phiDefNodes_aux g v unvisited n =\n              fold (\\<union>)\n               (map (phiDefNodes_aux g v (removeAll n unvisited))\n                 (predecessors g n))\n               (if length (predecessors g n) = 1 then {} else {n});\n      n \\<in> set unvisited; v \\<notin> defs g n\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<not> (n \\<in> set unvisited \\<and> v \\<notin> defs g n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>phiDefNodes_aux g v unvisited n = {};\n              n \\<notin> set unvisited \\<or> v \\<in> defs g n\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>phiDefNodes_aux g v unvisited n =\n              fold (\\<union>)\n               (map (phiDefNodes_aux g v (removeAll n unvisited))\n                 (predecessors g n))\n               (if length (predecessors g n) = 1 then {} else {n});\n      n \\<in> set unvisited; v \\<notin> defs g n\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<not> (n \\<in> set unvisited \\<and> v \\<notin> defs g n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  \\<not> (n \\<in> set unvisited \\<and> v \\<notin> defs g n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>phiDefNodes_aux g v unvisited n = {};\n              n \\<notin> set unvisited \\<or> v \\<in> defs g n\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>phiDefNodes_aux g v unvisited n =\n              fold (\\<union>)\n               (map (phiDefNodes_aux g v (removeAll n unvisited))\n                 (predecessors g n))\n               (if length (predecessors g n) = 1 then {} else {n});\n      n \\<in> set unvisited; v \\<notin> defs g n\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<not> (n \\<in> set unvisited \\<and> v \\<notin> defs g n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (n \\<in> set unvisited \\<and> v \\<notin> defs g n)\n\ngoal (1 subgoal):\n 1. thesis", "using nonrec"], ["proof (prove)\nusing this:\n  \\<not> (n \\<in> set unvisited \\<and> v \\<notin> defs g n)\n  \\<lbrakk>phiDefNodes_aux g v unvisited n = {};\n   n \\<notin> set unvisited \\<or> v \\<in> defs g n\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (simp add:phiDefNodes_aux.simps)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma phiDefNode_aux_is_join_node:\n    assumes \"n \\<in> phiDefNodes_aux g v un m\"\n    shows \"length (predecessors g n) \\<noteq> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (predecessors g n) \\<noteq> 1", "using assms"], ["proof (prove)\nusing this:\n  n \\<in> phiDefNodes_aux g v un m\n\ngoal (1 subgoal):\n 1. length (predecessors g n) \\<noteq> 1", "proof (induction un arbitrary: m rule:removeAll_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs m.\n       \\<lbrakk>\\<And>x m.\n                   \\<lbrakk>x \\<in> set xs;\n                    n \\<in> phiDefNodes_aux g v (removeAll x xs) m\\<rbrakk>\n                   \\<Longrightarrow> length (predecessors g n) \\<noteq> 1;\n        n \\<in> phiDefNodes_aux g v xs m\\<rbrakk>\n       \\<Longrightarrow> length (predecessors g n) \\<noteq> 1", "case (1 un m)"], ["proof (state)\nthis:\n  \\<lbrakk>?x1 \\<in> set un;\n   n \\<in> phiDefNodes_aux g v (removeAll ?x1 un) ?m1\\<rbrakk>\n  \\<Longrightarrow> length (predecessors g n) \\<noteq> 1\n  n \\<in> phiDefNodes_aux g v un m\n\ngoal (1 subgoal):\n 1. \\<And>xs m.\n       \\<lbrakk>\\<And>x m.\n                   \\<lbrakk>x \\<in> set xs;\n                    n \\<in> phiDefNodes_aux g v (removeAll x xs) m\\<rbrakk>\n                   \\<Longrightarrow> length (predecessors g n) \\<noteq> 1;\n        n \\<in> phiDefNodes_aux g v xs m\\<rbrakk>\n       \\<Longrightarrow> length (predecessors g n) \\<noteq> 1", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x1 \\<in> set un;\n   n \\<in> phiDefNodes_aux g v (removeAll ?x1 un) ?m1\\<rbrakk>\n  \\<Longrightarrow> length (predecessors g n) \\<noteq> 1\n  n \\<in> phiDefNodes_aux g v un m\n\ngoal (1 subgoal):\n 1. length (predecessors g n) \\<noteq> 1", "proof (cases un v g m rule:phiDefNodes_aux_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x m.\n                \\<lbrakk>x \\<in> set un;\n                 n \\<in> phiDefNodes_aux g v (removeAll x un) m\\<rbrakk>\n                \\<Longrightarrow> length (predecessors g n) \\<noteq> 1;\n     n \\<in> phiDefNodes_aux g v un m; phiDefNodes_aux g v un m = {};\n     m \\<notin> set un \\<or> v \\<in> defs g m\\<rbrakk>\n    \\<Longrightarrow> length (predecessors g n) \\<noteq> 1\n 2. \\<lbrakk>\\<And>x m.\n                \\<lbrakk>x \\<in> set un;\n                 n \\<in> phiDefNodes_aux g v (removeAll x un) m\\<rbrakk>\n                \\<Longrightarrow> length (predecessors g n) \\<noteq> 1;\n     n \\<in> phiDefNodes_aux g v un m;\n     phiDefNodes_aux g v un m =\n     fold (\\<union>)\n      (map (phiDefNodes_aux g v (removeAll m un)) (predecessors g m))\n      (if length (predecessors g m) = 1 then {} else {m});\n     m \\<in> set un; v \\<notin> defs g m\\<rbrakk>\n    \\<Longrightarrow> length (predecessors g n) \\<noteq> 1", "case rec"], ["proof (state)\nthis:\n  phiDefNodes_aux g v un m =\n  fold (\\<union>)\n   (map (phiDefNodes_aux g v (removeAll m un)) (predecessors g m))\n   (if length (predecessors g m) = 1 then {} else {m})\n  m \\<in> set un\n  v \\<notin> defs g m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x m.\n                \\<lbrakk>x \\<in> set un;\n                 n \\<in> phiDefNodes_aux g v (removeAll x un) m\\<rbrakk>\n                \\<Longrightarrow> length (predecessors g n) \\<noteq> 1;\n     n \\<in> phiDefNodes_aux g v un m; phiDefNodes_aux g v un m = {};\n     m \\<notin> set un \\<or> v \\<in> defs g m\\<rbrakk>\n    \\<Longrightarrow> length (predecessors g n) \\<noteq> 1\n 2. \\<lbrakk>\\<And>x m.\n                \\<lbrakk>x \\<in> set un;\n                 n \\<in> phiDefNodes_aux g v (removeAll x un) m\\<rbrakk>\n                \\<Longrightarrow> length (predecessors g n) \\<noteq> 1;\n     n \\<in> phiDefNodes_aux g v un m;\n     phiDefNodes_aux g v un m =\n     fold (\\<union>)\n      (map (phiDefNodes_aux g v (removeAll m un)) (predecessors g m))\n      (if length (predecessors g m) = 1 then {} else {m});\n     m \\<in> set un; v \\<notin> defs g m\\<rbrakk>\n    \\<Longrightarrow> length (predecessors g n) \\<noteq> 1", "with 1"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x1 \\<in> set un;\n   n \\<in> phiDefNodes_aux g v (removeAll ?x1 un) ?m1\\<rbrakk>\n  \\<Longrightarrow> length (predecessors g n) \\<noteq> 1\n  n \\<in> phiDefNodes_aux g v un m\n  phiDefNodes_aux g v un m =\n  fold (\\<union>)\n   (map (phiDefNodes_aux g v (removeAll m un)) (predecessors g m))\n   (if length (predecessors g m) = 1 then {} else {m})\n  m \\<in> set un\n  v \\<notin> defs g m", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x1 \\<in> set un;\n   n \\<in> phiDefNodes_aux g v (removeAll ?x1 un) ?m1\\<rbrakk>\n  \\<Longrightarrow> length (predecessors g n) \\<noteq> 1\n  n \\<in> phiDefNodes_aux g v un m\n  phiDefNodes_aux g v un m =\n  fold (\\<union>)\n   (map (phiDefNodes_aux g v (removeAll m un)) (predecessors g m))\n   (if length (predecessors g m) = 1 then {} else {m})\n  m \\<in> set un\n  v \\<notin> defs g m\n\ngoal (1 subgoal):\n 1. length (predecessors g n) \\<noteq> 1", "by (fastforce elim!:fold_union_elem split:if_split_asm)"], ["proof (state)\nthis:\n  length (predecessors g n) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x m.\n                \\<lbrakk>x \\<in> set un;\n                 n \\<in> phiDefNodes_aux g v (removeAll x un) m\\<rbrakk>\n                \\<Longrightarrow> length (predecessors g n) \\<noteq> 1;\n     n \\<in> phiDefNodes_aux g v un m; phiDefNodes_aux g v un m = {};\n     m \\<notin> set un \\<or> v \\<in> defs g m\\<rbrakk>\n    \\<Longrightarrow> length (predecessors g n) \\<noteq> 1", "qed auto"], ["proof (state)\nthis:\n  length (predecessors g n) \\<noteq> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma phiDefNode_is_join_node:\n    assumes \"n \\<in> phiDefNodes g v\"\n    shows \"length (predecessors g n) \\<noteq> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (predecessors g n) \\<noteq> 1", "using assms"], ["proof (prove)\nusing this:\n  n \\<in> phiDefNodes g v\n\ngoal (1 subgoal):\n 1. length (predecessors g n) \\<noteq> 1", "unfolding phiDefNodes_def"], ["proof (prove)\nusing this:\n  n \\<in> fold (\\<union>)\n           (concat\n             (map (\\<lambda>n.\n                      if v \\<in> uses g n\n                      then [phiDefNodes_aux g v (\\<alpha>n g) n] else [])\n               (\\<alpha>n g)))\n           {}\n\ngoal (1 subgoal):\n 1. length (predecessors g n) \\<noteq> 1", "by (auto elim!:fold_union_elem dest!:phiDefNode_aux_is_join_node)"], ["", "abbreviation unvisitedPath :: \"'node list \\<Rightarrow> 'node list \\<Rightarrow> bool\" where\n    \"unvisitedPath un ns \\<equiv> distinct ns \\<and> set ns \\<subseteq> set un\""], ["", "lemma unvisitedPath_removeLast:\n    assumes \"unvisitedPath un ns\" \"length ns \\<ge> 2\"\n    shows \"unvisitedPath (removeAll (last ns) un) (butlast ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unvisitedPath (removeAll (last ns) un) (butlast ns)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. unvisitedPath (removeAll (last ns) un) (butlast ns)", "let ?n = \"last ns\""], ["proof (state)\ngoal (1 subgoal):\n 1. unvisitedPath (removeAll (last ns) un) (butlast ns)", "let ?ns' = \"butlast ns\""], ["proof (state)\ngoal (1 subgoal):\n 1. unvisitedPath (removeAll (last ns) un) (butlast ns)", "let ?un' = \"removeAll ?n un\""], ["proof (state)\ngoal (1 subgoal):\n 1. unvisitedPath (removeAll (last ns) un) (butlast ns)", "let ?n' = \"last ?ns'\""], ["proof (state)\ngoal (1 subgoal):\n 1. unvisitedPath (removeAll (last ns) un) (butlast ns)", "from assms(2)"], ["proof (chain)\npicking this:\n  2 \\<le> length ns", "have [simp]: \"?n = ns ! (length ns - 1)\""], ["proof (prove)\nusing this:\n  2 \\<le> length ns\n\ngoal (1 subgoal):\n 1. last ns = ns ! (length ns - 1)", "by -(rule last_conv_nth, auto)"], ["proof (state)\nthis:\n  last ns = ns ! (length ns - 1)\n\ngoal (1 subgoal):\n 1. unvisitedPath (removeAll (last ns) un) (butlast ns)", "from assms(1)"], ["proof (chain)\npicking this:\n  unvisitedPath un ns", "have \"distinct ?ns'\""], ["proof (prove)\nusing this:\n  unvisitedPath un ns\n\ngoal (1 subgoal):\n 1. distinct (butlast ns)", "by -(rule distinct_butlast, simp)"], ["proof (state)\nthis:\n  distinct (butlast ns)\n\ngoal (1 subgoal):\n 1. unvisitedPath (removeAll (last ns) un) (butlast ns)", "moreover"], ["proof (state)\nthis:\n  distinct (butlast ns)\n\ngoal (1 subgoal):\n 1. unvisitedPath (removeAll (last ns) un) (butlast ns)", "have \"set ?ns' \\<subseteq> set ?un'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (butlast ns) \\<subseteq> set (removeAll (last ns) un)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (butlast ns) \\<Longrightarrow>\n       x \\<in> set (removeAll (last ns) un)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (butlast ns) \\<Longrightarrow>\n       x \\<in> set (removeAll (last ns) un)", "assume assm: \"n \\<in> set ?ns'\""], ["proof (state)\nthis:\n  n \\<in> set (butlast ns)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (butlast ns) \\<Longrightarrow>\n       x \\<in> set (removeAll (last ns) un)", "then"], ["proof (chain)\npicking this:\n  n \\<in> set (butlast ns)", "obtain i where \"n = ?ns' ! i\" \"i < length ?ns'\""], ["proof (prove)\nusing this:\n  n \\<in> set (butlast ns)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>n = butlast ns ! i; i < length (butlast ns)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add:in_set_conv_nth)"], ["proof (state)\nthis:\n  n = butlast ns ! i\n  i < length (butlast ns)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (butlast ns) \\<Longrightarrow>\n       x \\<in> set (removeAll (last ns) un)", "hence i: \"n = ns ! i\" \"i < length ns - 1\""], ["proof (prove)\nusing this:\n  n = butlast ns ! i\n  i < length (butlast ns)\n\ngoal (1 subgoal):\n 1. n = ns ! i &&& i < length ns - 1", "by (auto simp add:nth_butlast)"], ["proof (state)\nthis:\n  n = ns ! i\n  i < length ns - 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (butlast ns) \\<Longrightarrow>\n       x \\<in> set (removeAll (last ns) un)", "with assms"], ["proof (chain)\npicking this:\n  unvisitedPath un ns\n  2 \\<le> length ns\n  n = ns ! i\n  i < length ns - 1", "have 1: \"n \\<noteq> ?n\""], ["proof (prove)\nusing this:\n  unvisitedPath un ns\n  2 \\<le> length ns\n  n = ns ! i\n  i < length ns - 1\n\ngoal (1 subgoal):\n 1. n \\<noteq> last ns", "by (auto iff:nth_eq_iff_index_eq)"], ["proof (state)\nthis:\n  n \\<noteq> last ns\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (butlast ns) \\<Longrightarrow>\n       x \\<in> set (removeAll (last ns) un)", "from i assms(1)"], ["proof (chain)\npicking this:\n  n = ns ! i\n  i < length ns - 1\n  unvisitedPath un ns", "have \"n \\<in> set un\""], ["proof (prove)\nusing this:\n  n = ns ! i\n  i < length ns - 1\n  unvisitedPath un ns\n\ngoal (1 subgoal):\n 1. n \\<in> set un", "by auto"], ["proof (state)\nthis:\n  n \\<in> set un\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (butlast ns) \\<Longrightarrow>\n       x \\<in> set (removeAll (last ns) un)", "with \\<open>n \\<in> set ?ns'\\<close> assms(1) 1"], ["proof (chain)\npicking this:\n  n \\<in> set (butlast ns)\n  unvisitedPath un ns\n  n \\<noteq> last ns\n  n \\<in> set un", "show \"n \\<in> set ?un'\""], ["proof (prove)\nusing this:\n  n \\<in> set (butlast ns)\n  unvisitedPath un ns\n  n \\<noteq> last ns\n  n \\<in> set un\n\ngoal (1 subgoal):\n 1. n \\<in> set (removeAll (last ns) un)", "by auto"], ["proof (state)\nthis:\n  n \\<in> set (removeAll (last ns) un)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (butlast ns) \\<subseteq> set (removeAll (last ns) un)\n\ngoal (1 subgoal):\n 1. unvisitedPath (removeAll (last ns) un) (butlast ns)", "ultimately"], ["proof (chain)\npicking this:\n  distinct (butlast ns)\n  set (butlast ns) \\<subseteq> set (removeAll (last ns) un)", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct (butlast ns)\n  set (butlast ns) \\<subseteq> set (removeAll (last ns) un)\n\ngoal (1 subgoal):\n 1. unvisitedPath (removeAll (last ns) un) (butlast ns)", "by simp"], ["proof (state)\nthis:\n  unvisitedPath (removeAll (last ns) un) (butlast ns)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma phiDefNodes_auxI:\n    assumes \"g \\<turnstile> n-ns\\<rightarrow>m\" \"unvisitedPath un ns\" \"\\<forall>n \\<in> set ns. v \\<notin> defs g n\" \"length (predecessors g n) \\<noteq> 1\"\n    shows \"n \\<in> phiDefNodes_aux g v un m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> phiDefNodes_aux g v un m", "using assms(1,2,3)"], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  unvisitedPath un ns\n  \\<forall>n\\<in>set ns. v \\<notin> defs g n\n\ngoal (1 subgoal):\n 1. n \\<in> phiDefNodes_aux g v un m", "proof (induction un arbitrary: m ns rule:removeAll_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs m ns.\n       \\<lbrakk>\\<And>x m ns.\n                   \\<lbrakk>x \\<in> set xs;\n                    g \\<turnstile> n-ns\\<rightarrow>m;\n                    unvisitedPath (removeAll x xs) ns;\n                    \\<forall>n\\<in>set ns. v \\<notin> defs g n\\<rbrakk>\n                   \\<Longrightarrow> n \\<in> phiDefNodes_aux g v\n        (removeAll x xs) m;\n        g \\<turnstile> n-ns\\<rightarrow>m; unvisitedPath xs ns;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n\\<rbrakk>\n       \\<Longrightarrow> n \\<in> phiDefNodes_aux g v xs m", "case (1 un)"], ["proof (state)\nthis:\n  \\<lbrakk>?x1 \\<in> set un; g \\<turnstile> n-?ns1\\<rightarrow>?m1;\n   unvisitedPath (removeAll ?x1 un) ?ns1;\n   \\<forall>n\\<in>set ?ns1. v \\<notin> defs g n\\<rbrakk>\n  \\<Longrightarrow> n \\<in> phiDefNodes_aux g v (removeAll ?x1 un) ?m1\n  g \\<turnstile> n-ns\\<rightarrow>m\n  unvisitedPath un ns\n  \\<forall>n\\<in>set ns. v \\<notin> defs g n\n\ngoal (1 subgoal):\n 1. \\<And>xs m ns.\n       \\<lbrakk>\\<And>x m ns.\n                   \\<lbrakk>x \\<in> set xs;\n                    g \\<turnstile> n-ns\\<rightarrow>m;\n                    unvisitedPath (removeAll x xs) ns;\n                    \\<forall>n\\<in>set ns. v \\<notin> defs g n\\<rbrakk>\n                   \\<Longrightarrow> n \\<in> phiDefNodes_aux g v\n        (removeAll x xs) m;\n        g \\<turnstile> n-ns\\<rightarrow>m; unvisitedPath xs ns;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n\\<rbrakk>\n       \\<Longrightarrow> n \\<in> phiDefNodes_aux g v xs m", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> phiDefNodes_aux g v un m", "proof (cases un v g m rule:phiDefNodes_aux_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>phiDefNodes_aux g v un m = {};\n     m \\<notin> set un \\<or> v \\<in> defs g m\\<rbrakk>\n    \\<Longrightarrow> n \\<in> phiDefNodes_aux g v un m\n 2. \\<lbrakk>phiDefNodes_aux g v un m =\n             fold (\\<union>)\n              (map (phiDefNodes_aux g v (removeAll m un))\n                (predecessors g m))\n              (if length (predecessors g m) = 1 then {} else {m});\n     m \\<in> set un; v \\<notin> defs g m\\<rbrakk>\n    \\<Longrightarrow> n \\<in> phiDefNodes_aux g v un m", "case nonrec"], ["proof (state)\nthis:\n  phiDefNodes_aux g v un m = {}\n  m \\<notin> set un \\<or> v \\<in> defs g m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>phiDefNodes_aux g v un m = {};\n     m \\<notin> set un \\<or> v \\<in> defs g m\\<rbrakk>\n    \\<Longrightarrow> n \\<in> phiDefNodes_aux g v un m\n 2. \\<lbrakk>phiDefNodes_aux g v un m =\n             fold (\\<union>)\n              (map (phiDefNodes_aux g v (removeAll m un))\n                (predecessors g m))\n              (if length (predecessors g m) = 1 then {} else {m});\n     m \\<in> set un; v \\<notin> defs g m\\<rbrakk>\n    \\<Longrightarrow> n \\<in> phiDefNodes_aux g v un m", "from \"1.prems\"(1)"], ["proof (chain)\npicking this:\n  g \\<turnstile> n-ns\\<rightarrow>m", "have \"m \\<in> set ns\""], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n\ngoal (1 subgoal):\n 1. m \\<in> set ns", "unfolding path2_def"], ["proof (prove)\nusing this:\n  local.path g ns \\<and> n = hd ns \\<and> m = last ns\n\ngoal (1 subgoal):\n 1. m \\<in> set ns", "by auto"], ["proof (state)\nthis:\n  m \\<in> set ns\n\ngoal (2 subgoals):\n 1. \\<lbrakk>phiDefNodes_aux g v un m = {};\n     m \\<notin> set un \\<or> v \\<in> defs g m\\<rbrakk>\n    \\<Longrightarrow> n \\<in> phiDefNodes_aux g v un m\n 2. \\<lbrakk>phiDefNodes_aux g v un m =\n             fold (\\<union>)\n              (map (phiDefNodes_aux g v (removeAll m un))\n                (predecessors g m))\n              (if length (predecessors g m) = 1 then {} else {m});\n     m \\<in> set un; v \\<notin> defs g m\\<rbrakk>\n    \\<Longrightarrow> n \\<in> phiDefNodes_aux g v un m", "with nonrec"], ["proof (chain)\npicking this:\n  phiDefNodes_aux g v un m = {}\n  m \\<notin> set un \\<or> v \\<in> defs g m\n  m \\<in> set ns", "show ?thesis"], ["proof (prove)\nusing this:\n  phiDefNodes_aux g v un m = {}\n  m \\<notin> set un \\<or> v \\<in> defs g m\n  m \\<in> set ns\n\ngoal (1 subgoal):\n 1. n \\<in> phiDefNodes_aux g v un m", "using \"1.prems\"(2,3)"], ["proof (prove)\nusing this:\n  phiDefNodes_aux g v un m = {}\n  m \\<notin> set un \\<or> v \\<in> defs g m\n  m \\<in> set ns\n  unvisitedPath un ns\n  \\<forall>n\\<in>set ns. v \\<notin> defs g n\n\ngoal (1 subgoal):\n 1. n \\<in> phiDefNodes_aux g v un m", "by auto"], ["proof (state)\nthis:\n  n \\<in> phiDefNodes_aux g v un m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>phiDefNodes_aux g v un m =\n             fold (\\<union>)\n              (map (phiDefNodes_aux g v (removeAll m un))\n                (predecessors g m))\n              (if length (predecessors g m) = 1 then {} else {m});\n     m \\<in> set un; v \\<notin> defs g m\\<rbrakk>\n    \\<Longrightarrow> n \\<in> phiDefNodes_aux g v un m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>phiDefNodes_aux g v un m =\n             fold (\\<union>)\n              (map (phiDefNodes_aux g v (removeAll m un))\n                (predecessors g m))\n              (if length (predecessors g m) = 1 then {} else {m});\n     m \\<in> set un; v \\<notin> defs g m\\<rbrakk>\n    \\<Longrightarrow> n \\<in> phiDefNodes_aux g v un m", "case rec"], ["proof (state)\nthis:\n  phiDefNodes_aux g v un m =\n  fold (\\<union>)\n   (map (phiDefNodes_aux g v (removeAll m un)) (predecessors g m))\n   (if length (predecessors g m) = 1 then {} else {m})\n  m \\<in> set un\n  v \\<notin> defs g m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>phiDefNodes_aux g v un m =\n             fold (\\<union>)\n              (map (phiDefNodes_aux g v (removeAll m un))\n                (predecessors g m))\n              (if length (predecessors g m) = 1 then {} else {m});\n     m \\<in> set un; v \\<notin> defs g m\\<rbrakk>\n    \\<Longrightarrow> n \\<in> phiDefNodes_aux g v un m", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> phiDefNodes_aux g v un m", "proof (cases \"n = m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = m \\<Longrightarrow> n \\<in> phiDefNodes_aux g v un m\n 2. n \\<noteq> m \\<Longrightarrow> n \\<in> phiDefNodes_aux g v un m", "case True"], ["proof (state)\nthis:\n  n = m\n\ngoal (2 subgoals):\n 1. n = m \\<Longrightarrow> n \\<in> phiDefNodes_aux g v un m\n 2. n \\<noteq> m \\<Longrightarrow> n \\<in> phiDefNodes_aux g v un m", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = m\n\ngoal (1 subgoal):\n 1. n \\<in> phiDefNodes_aux g v un m", "using rec assms(4)"], ["proof (prove)\nusing this:\n  n = m\n  phiDefNodes_aux g v un m =\n  fold (\\<union>)\n   (map (phiDefNodes_aux g v (removeAll m un)) (predecessors g m))\n   (if length (predecessors g m) = 1 then {} else {m})\n  m \\<in> set un\n  v \\<notin> defs g m\n  length (predecessors g n) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. n \\<in> phiDefNodes_aux g v un m", "by -(subst rec(1), rule fold_union_elemI[of _ \"{m}\"], auto)"], ["proof (state)\nthis:\n  n \\<in> phiDefNodes_aux g v un m\n\ngoal (1 subgoal):\n 1. n \\<noteq> m \\<Longrightarrow> n \\<in> phiDefNodes_aux g v un m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> m \\<Longrightarrow> n \\<in> phiDefNodes_aux g v un m", "case False"], ["proof (state)\nthis:\n  n \\<noteq> m\n\ngoal (1 subgoal):\n 1. n \\<noteq> m \\<Longrightarrow> n \\<in> phiDefNodes_aux g v un m", "let ?ns' = \"butlast ns\""], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> m \\<Longrightarrow> n \\<in> phiDefNodes_aux g v un m", "let ?m' = \"last ?ns'\""], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> m \\<Longrightarrow> n \\<in> phiDefNodes_aux g v un m", "from \"1.prems\"(1)"], ["proof (chain)\npicking this:\n  g \\<turnstile> n-ns\\<rightarrow>m", "have [simp]: \"m = last ns\""], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n\ngoal (1 subgoal):\n 1. m = last ns", "unfolding path2_def"], ["proof (prove)\nusing this:\n  local.path g ns \\<and> n = hd ns \\<and> m = last ns\n\ngoal (1 subgoal):\n 1. m = last ns", "by simp"], ["proof (state)\nthis:\n  m = last ns\n\ngoal (1 subgoal):\n 1. n \\<noteq> m \\<Longrightarrow> n \\<in> phiDefNodes_aux g v un m", "with 1(2) False"], ["proof (chain)\npicking this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  n \\<noteq> m\n  m = last ns", "have ns': \"g \\<turnstile> n-?ns'\\<rightarrow>?m'\" \"?m' \\<in> set (predecessors g m)\""], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  n \\<noteq> m\n  m = last ns\n\ngoal (1 subgoal):\n 1. g \\<turnstile> n-butlast ns\\<rightarrow>last (butlast ns) &&&\n    last (butlast ns) \\<in> set (predecessors g m)", "by (auto intro: path2_unsnoc)"], ["proof (state)\nthis:\n  g \\<turnstile> n-butlast ns\\<rightarrow>last (butlast ns)\n  last (butlast ns) \\<in> set (predecessors g m)\n\ngoal (1 subgoal):\n 1. n \\<noteq> m \\<Longrightarrow> n \\<in> phiDefNodes_aux g v un m", "have \"n \\<in> phiDefNodes_aux g v (removeAll m un) ?m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> phiDefNodes_aux g v (removeAll m un) (last (butlast ns))", "using rec(2) ns'"], ["proof (prove)\nusing this:\n  m \\<in> set un\n  g \\<turnstile> n-butlast ns\\<rightarrow>last (butlast ns)\n  last (butlast ns) \\<in> set (predecessors g m)\n\ngoal (1 subgoal):\n 1. n \\<in> phiDefNodes_aux g v (removeAll m un) (last (butlast ns))", "apply-"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<in> set un;\n     g \\<turnstile> n-butlast ns\\<rightarrow>last (butlast ns);\n     last (butlast ns) \\<in> set (predecessors g m)\\<rbrakk>\n    \\<Longrightarrow> n \\<in> phiDefNodes_aux g v (removeAll m un)\n                               (last (butlast ns))", "proof (rule \"1.IH\")"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>m \\<in> set un;\n     g \\<turnstile> n-butlast ns\\<rightarrow>last (butlast ns);\n     last (butlast ns) \\<in> set (predecessors g m)\\<rbrakk>\n    \\<Longrightarrow> m \\<in> set un\n 2. \\<lbrakk>m \\<in> set un;\n     g \\<turnstile> n-butlast ns\\<rightarrow>last (butlast ns);\n     last (butlast ns) \\<in> set (predecessors g m)\\<rbrakk>\n    \\<Longrightarrow> g \\<turnstile> n-?ns4\\<rightarrow>last (butlast ns)\n 3. \\<lbrakk>m \\<in> set un;\n     g \\<turnstile> n-butlast ns\\<rightarrow>last (butlast ns);\n     last (butlast ns) \\<in> set (predecessors g m)\\<rbrakk>\n    \\<Longrightarrow> unvisitedPath (removeAll m un) ?ns4\n 4. \\<lbrakk>m \\<in> set un;\n     g \\<turnstile> n-butlast ns\\<rightarrow>last (butlast ns);\n     last (butlast ns) \\<in> set (predecessors g m)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n\\<in>set ?ns4. v \\<notin> defs g n", "from \"1.prems\"(1) False"], ["proof (chain)\npicking this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  n \\<noteq> m", "have \"length ns \\<ge> 2\""], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  n \\<noteq> m\n\ngoal (1 subgoal):\n 1. 2 \\<le> length ns", "by (auto simp del:\\<open>m = last ns\\<close>)"], ["proof (state)\nthis:\n  2 \\<le> length ns\n\ngoal (4 subgoals):\n 1. \\<lbrakk>m \\<in> set un;\n     g \\<turnstile> n-butlast ns\\<rightarrow>last (butlast ns);\n     last (butlast ns) \\<in> set (predecessors g m)\\<rbrakk>\n    \\<Longrightarrow> m \\<in> set un\n 2. \\<lbrakk>m \\<in> set un;\n     g \\<turnstile> n-butlast ns\\<rightarrow>last (butlast ns);\n     last (butlast ns) \\<in> set (predecessors g m)\\<rbrakk>\n    \\<Longrightarrow> g \\<turnstile> n-?ns4\\<rightarrow>last (butlast ns)\n 3. \\<lbrakk>m \\<in> set un;\n     g \\<turnstile> n-butlast ns\\<rightarrow>last (butlast ns);\n     last (butlast ns) \\<in> set (predecessors g m)\\<rbrakk>\n    \\<Longrightarrow> unvisitedPath (removeAll m un) ?ns4\n 4. \\<lbrakk>m \\<in> set un;\n     g \\<turnstile> n-butlast ns\\<rightarrow>last (butlast ns);\n     last (butlast ns) \\<in> set (predecessors g m)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n\\<in>set ?ns4. v \\<notin> defs g n", "with \"1.prems\"(2)"], ["proof (chain)\npicking this:\n  unvisitedPath un ns\n  2 \\<le> length ns", "show \"unvisitedPath (removeAll m un) ?ns'\""], ["proof (prove)\nusing this:\n  unvisitedPath un ns\n  2 \\<le> length ns\n\ngoal (1 subgoal):\n 1. unvisitedPath (removeAll m un) (butlast ns)", "by (subst \\<open>m = last ns\\<close>, rule unvisitedPath_removeLast)"], ["proof (state)\nthis:\n  unvisitedPath (removeAll m un) (butlast ns)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>m \\<in> set un;\n     g \\<turnstile> n-butlast ns\\<rightarrow>last (butlast ns);\n     last (butlast ns) \\<in> set (predecessors g m)\\<rbrakk>\n    \\<Longrightarrow> m \\<in> set un\n 2. \\<lbrakk>m \\<in> set un;\n     g \\<turnstile> n-butlast ns\\<rightarrow>last (butlast ns);\n     last (butlast ns) \\<in> set (predecessors g m)\\<rbrakk>\n    \\<Longrightarrow> g \\<turnstile> n-butlast\n  ns\\<rightarrow>last (butlast ns)\n 3. \\<lbrakk>m \\<in> set un;\n     g \\<turnstile> n-butlast ns\\<rightarrow>last (butlast ns);\n     last (butlast ns) \\<in> set (predecessors g m)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n\\<in>set (butlast ns). v \\<notin> defs g n", "from \"1.prems\"(3)"], ["proof (chain)\npicking this:\n  \\<forall>n\\<in>set ns. v \\<notin> defs g n", "show \"\\<forall>n \\<in> set ?ns'. v \\<notin> defs g n\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>set ns. v \\<notin> defs g n\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>set (butlast ns). v \\<notin> defs g n", "by (auto intro:in_set_butlastD)"], ["proof (state)\nthis:\n  \\<forall>n\\<in>set (butlast ns). v \\<notin> defs g n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>m \\<in> set un;\n     g \\<turnstile> n-butlast ns\\<rightarrow>last (butlast ns);\n     last (butlast ns) \\<in> set (predecessors g m)\\<rbrakk>\n    \\<Longrightarrow> m \\<in> set un\n 2. \\<lbrakk>m \\<in> set un;\n     g \\<turnstile> n-butlast ns\\<rightarrow>last (butlast ns);\n     last (butlast ns) \\<in> set (predecessors g m)\\<rbrakk>\n    \\<Longrightarrow> g \\<turnstile> n-butlast\n  ns\\<rightarrow>last (butlast ns)", "qed"], ["proof (state)\nthis:\n  n \\<in> phiDefNodes_aux g v (removeAll m un) (last (butlast ns))\n\ngoal (1 subgoal):\n 1. n \\<noteq> m \\<Longrightarrow> n \\<in> phiDefNodes_aux g v un m", "with ns'(2)"], ["proof (chain)\npicking this:\n  last (butlast ns) \\<in> set (predecessors g m)\n  n \\<in> phiDefNodes_aux g v (removeAll m un) (last (butlast ns))", "show ?thesis"], ["proof (prove)\nusing this:\n  last (butlast ns) \\<in> set (predecessors g m)\n  n \\<in> phiDefNodes_aux g v (removeAll m un) (last (butlast ns))\n\ngoal (1 subgoal):\n 1. n \\<in> phiDefNodes_aux g v un m", "by -(subst rec, rule fold_union_elemI, auto)"], ["proof (state)\nthis:\n  n \\<in> phiDefNodes_aux g v un m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<in> phiDefNodes_aux g v un m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<in> phiDefNodes_aux g v un m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma phiDefNodes_auxE:\n    assumes \"n \\<in> phiDefNodes_aux g v un m\" \"m \\<in> set (\\<alpha>n g)\"\n    obtains ns where \"g \\<turnstile> n-ns\\<rightarrow>m\" \"\\<forall>n \\<in> set ns. v \\<notin> defs g n\" \"length (predecessors g n) \\<noteq> 1\" \"unvisitedPath un ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m;\n         \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n         length (predecessors g n) \\<noteq> 1; unvisitedPath un ns\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  n \\<in> phiDefNodes_aux g v un m\n  m \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m;\n         \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n         length (predecessors g n) \\<noteq> 1; unvisitedPath un ns\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (atomize_elim, induction un arbitrary:m rule:removeAll_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs m.\n       \\<lbrakk>\\<And>x m.\n                   \\<lbrakk>x \\<in> set xs;\n                    n \\<in> phiDefNodes_aux g v (removeAll x xs) m;\n                    m \\<in> set (\\<alpha>n g);\n                    n \\<in> phiDefNodes_aux g v (removeAll x xs) m;\n                    m \\<in> set (\\<alpha>n g)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ns.\n  g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n  (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n  length (predecessors g n) \\<noteq> 1 \\<and>\n  unvisitedPath (removeAll x xs) ns;\n        n \\<in> phiDefNodes_aux g v xs m; m \\<in> set (\\<alpha>n g);\n        n \\<in> phiDefNodes_aux g v xs m; m \\<in> set (\\<alpha>n g)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n                            (\\<forall>n\\<in>set ns.\n                                v \\<notin> defs g n) \\<and>\n                            length (predecessors g n) \\<noteq> 1 \\<and>\n                            unvisitedPath xs ns", "case (1 un)"], ["proof (state)\nthis:\n  \\<lbrakk>?x1 \\<in> set un;\n   n \\<in> phiDefNodes_aux g v (removeAll ?x1 un) ?m1;\n   ?m1 \\<in> set (\\<alpha>n g);\n   n \\<in> phiDefNodes_aux g v (removeAll ?x1 un) ?m1;\n   ?m1 \\<in> set (\\<alpha>n g)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ns.\n                       g \\<turnstile> n-ns\\<rightarrow>?m1 \\<and>\n                       (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n                       length (predecessors g n) \\<noteq> 1 \\<and>\n                       unvisitedPath (removeAll ?x1 un) ns\n  n \\<in> phiDefNodes_aux g v un m\n  m \\<in> set (\\<alpha>n g)\n  n \\<in> phiDefNodes_aux g v un m\n  m \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. \\<And>xs m.\n       \\<lbrakk>\\<And>x m.\n                   \\<lbrakk>x \\<in> set xs;\n                    n \\<in> phiDefNodes_aux g v (removeAll x xs) m;\n                    m \\<in> set (\\<alpha>n g);\n                    n \\<in> phiDefNodes_aux g v (removeAll x xs) m;\n                    m \\<in> set (\\<alpha>n g)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ns.\n  g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n  (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n  length (predecessors g n) \\<noteq> 1 \\<and>\n  unvisitedPath (removeAll x xs) ns;\n        n \\<in> phiDefNodes_aux g v xs m; m \\<in> set (\\<alpha>n g);\n        n \\<in> phiDefNodes_aux g v xs m; m \\<in> set (\\<alpha>n g)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n                            (\\<forall>n\\<in>set ns.\n                                v \\<notin> defs g n) \\<and>\n                            length (predecessors g n) \\<noteq> 1 \\<and>\n                            unvisitedPath xs ns", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n       (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n       length (predecessors g n) \\<noteq> 1 \\<and> unvisitedPath un ns", "proof (cases un v g m rule:phiDefNodes_aux_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>phiDefNodes_aux g v un m = {};\n     m \\<notin> set un \\<or> v \\<in> defs g m\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ns.\n                         g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n                         (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n                         length (predecessors g n) \\<noteq> 1 \\<and>\n                         unvisitedPath un ns\n 2. \\<lbrakk>phiDefNodes_aux g v un m =\n             fold (\\<union>)\n              (map (phiDefNodes_aux g v (removeAll m un))\n                (predecessors g m))\n              (if length (predecessors g m) = 1 then {} else {m});\n     m \\<in> set un; v \\<notin> defs g m\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ns.\n                         g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n                         (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n                         length (predecessors g n) \\<noteq> 1 \\<and>\n                         unvisitedPath un ns", "case nonrec"], ["proof (state)\nthis:\n  phiDefNodes_aux g v un m = {}\n  m \\<notin> set un \\<or> v \\<in> defs g m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>phiDefNodes_aux g v un m = {};\n     m \\<notin> set un \\<or> v \\<in> defs g m\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ns.\n                         g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n                         (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n                         length (predecessors g n) \\<noteq> 1 \\<and>\n                         unvisitedPath un ns\n 2. \\<lbrakk>phiDefNodes_aux g v un m =\n             fold (\\<union>)\n              (map (phiDefNodes_aux g v (removeAll m un))\n                (predecessors g m))\n              (if length (predecessors g m) = 1 then {} else {m});\n     m \\<in> set un; v \\<notin> defs g m\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ns.\n                         g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n                         (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n                         length (predecessors g n) \\<noteq> 1 \\<and>\n                         unvisitedPath un ns", "thus ?thesis"], ["proof (prove)\nusing this:\n  phiDefNodes_aux g v un m = {}\n  m \\<notin> set un \\<or> v \\<in> defs g m\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n       (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n       length (predecessors g n) \\<noteq> 1 \\<and> unvisitedPath un ns", "using \"1.prems\""], ["proof (prove)\nusing this:\n  phiDefNodes_aux g v un m = {}\n  m \\<notin> set un \\<or> v \\<in> defs g m\n  n \\<in> phiDefNodes_aux g v un m\n  m \\<in> set (\\<alpha>n g)\n  n \\<in> phiDefNodes_aux g v un m\n  m \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n       (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n       length (predecessors g n) \\<noteq> 1 \\<and> unvisitedPath un ns", "by simp"], ["proof (state)\nthis:\n  \\<exists>ns.\n     g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n     (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n     length (predecessors g n) \\<noteq> 1 \\<and> unvisitedPath un ns\n\ngoal (1 subgoal):\n 1. \\<lbrakk>phiDefNodes_aux g v un m =\n             fold (\\<union>)\n              (map (phiDefNodes_aux g v (removeAll m un))\n                (predecessors g m))\n              (if length (predecessors g m) = 1 then {} else {m});\n     m \\<in> set un; v \\<notin> defs g m\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ns.\n                         g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n                         (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n                         length (predecessors g n) \\<noteq> 1 \\<and>\n                         unvisitedPath un ns", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>phiDefNodes_aux g v un m =\n             fold (\\<union>)\n              (map (phiDefNodes_aux g v (removeAll m un))\n                (predecessors g m))\n              (if length (predecessors g m) = 1 then {} else {m});\n     m \\<in> set un; v \\<notin> defs g m\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ns.\n                         g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n                         (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n                         length (predecessors g n) \\<noteq> 1 \\<and>\n                         unvisitedPath un ns", "case rec"], ["proof (state)\nthis:\n  phiDefNodes_aux g v un m =\n  fold (\\<union>)\n   (map (phiDefNodes_aux g v (removeAll m un)) (predecessors g m))\n   (if length (predecessors g m) = 1 then {} else {m})\n  m \\<in> set un\n  v \\<notin> defs g m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>phiDefNodes_aux g v un m =\n             fold (\\<union>)\n              (map (phiDefNodes_aux g v (removeAll m un))\n                (predecessors g m))\n              (if length (predecessors g m) = 1 then {} else {m});\n     m \\<in> set un; v \\<notin> defs g m\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ns.\n                         g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n                         (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n                         length (predecessors g n) \\<noteq> 1 \\<and>\n                         unvisitedPath un ns", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n       (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n       length (predecessors g n) \\<noteq> 1 \\<and> unvisitedPath un ns", "proof (cases \"n \\<in> (if length (predecessors g m) = 1 then {} else {m})\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n \\<in> (if length (predecessors g m) = 1 then {}\n             else {m}) \\<Longrightarrow>\n    \\<exists>ns.\n       g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n       (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n       length (predecessors g n) \\<noteq> 1 \\<and> unvisitedPath un ns\n 2. n \\<notin> (if length (predecessors g m) = 1 then {}\n                else {m}) \\<Longrightarrow>\n    \\<exists>ns.\n       g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n       (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n       length (predecessors g n) \\<noteq> 1 \\<and> unvisitedPath un ns", "case True"], ["proof (state)\nthis:\n  n \\<in> (if length (predecessors g m) = 1 then {} else {m})\n\ngoal (2 subgoals):\n 1. n \\<in> (if length (predecessors g m) = 1 then {}\n             else {m}) \\<Longrightarrow>\n    \\<exists>ns.\n       g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n       (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n       length (predecessors g n) \\<noteq> 1 \\<and> unvisitedPath un ns\n 2. n \\<notin> (if length (predecessors g m) = 1 then {}\n                else {m}) \\<Longrightarrow>\n    \\<exists>ns.\n       g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n       (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n       length (predecessors g n) \\<noteq> 1 \\<and> unvisitedPath un ns", "hence \"n = m\""], ["proof (prove)\nusing this:\n  n \\<in> (if length (predecessors g m) = 1 then {} else {m})\n\ngoal (1 subgoal):\n 1. n = m", "by (simp split:if_split_asm)"], ["proof (state)\nthis:\n  n = m\n\ngoal (2 subgoals):\n 1. n \\<in> (if length (predecessors g m) = 1 then {}\n             else {m}) \\<Longrightarrow>\n    \\<exists>ns.\n       g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n       (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n       length (predecessors g n) \\<noteq> 1 \\<and> unvisitedPath un ns\n 2. n \\<notin> (if length (predecessors g m) = 1 then {}\n                else {m}) \\<Longrightarrow>\n    \\<exists>ns.\n       g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n       (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n       length (predecessors g n) \\<noteq> 1 \\<and> unvisitedPath un ns", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = m\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n       (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n       length (predecessors g n) \\<noteq> 1 \\<and> unvisitedPath un ns", "using \"1.prems\"(2) rec True"], ["proof (prove)\nusing this:\n  n = m\n  m \\<in> set (\\<alpha>n g)\n  phiDefNodes_aux g v un m =\n  fold (\\<union>)\n   (map (phiDefNodes_aux g v (removeAll m un)) (predecessors g m))\n   (if length (predecessors g m) = 1 then {} else {m})\n  m \\<in> set un\n  v \\<notin> defs g m\n  n \\<in> (if length (predecessors g m) = 1 then {} else {m})\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n       (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n       length (predecessors g n) \\<noteq> 1 \\<and> unvisitedPath un ns", "by auto"], ["proof (state)\nthis:\n  \\<exists>ns.\n     g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n     (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n     length (predecessors g n) \\<noteq> 1 \\<and> unvisitedPath un ns\n\ngoal (1 subgoal):\n 1. n \\<notin> (if length (predecessors g m) = 1 then {}\n                else {m}) \\<Longrightarrow>\n    \\<exists>ns.\n       g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n       (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n       length (predecessors g n) \\<noteq> 1 \\<and> unvisitedPath un ns", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<notin> (if length (predecessors g m) = 1 then {}\n                else {m}) \\<Longrightarrow>\n    \\<exists>ns.\n       g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n       (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n       length (predecessors g n) \\<noteq> 1 \\<and> unvisitedPath un ns", "case False"], ["proof (state)\nthis:\n  n \\<notin> (if length (predecessors g m) = 1 then {} else {m})\n\ngoal (1 subgoal):\n 1. n \\<notin> (if length (predecessors g m) = 1 then {}\n                else {m}) \\<Longrightarrow>\n    \\<exists>ns.\n       g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n       (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n       length (predecessors g n) \\<noteq> 1 \\<and> unvisitedPath un ns", "with rec \"1.prems\"(1)"], ["proof (chain)\npicking this:\n  phiDefNodes_aux g v un m =\n  fold (\\<union>)\n   (map (phiDefNodes_aux g v (removeAll m un)) (predecessors g m))\n   (if length (predecessors g m) = 1 then {} else {m})\n  m \\<in> set un\n  v \\<notin> defs g m\n  n \\<in> phiDefNodes_aux g v un m\n  n \\<notin> (if length (predecessors g m) = 1 then {} else {m})", "obtain m' where m': \"n \\<in> phiDefNodes_aux g v (removeAll m un) m'\" \"m' \\<in> set (predecessors g m)\""], ["proof (prove)\nusing this:\n  phiDefNodes_aux g v un m =\n  fold (\\<union>)\n   (map (phiDefNodes_aux g v (removeAll m un)) (predecessors g m))\n   (if length (predecessors g m) = 1 then {} else {m})\n  m \\<in> set un\n  v \\<notin> defs g m\n  n \\<in> phiDefNodes_aux g v un m\n  n \\<notin> (if length (predecessors g m) = 1 then {} else {m})\n\ngoal (1 subgoal):\n 1. (\\<And>m'.\n        \\<lbrakk>n \\<in> phiDefNodes_aux g v (removeAll m un) m';\n         m' \\<in> set (predecessors g m)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!:fold_union_elem)"], ["proof (state)\nthis:\n  n \\<in> phiDefNodes_aux g v (removeAll m un) m'\n  m' \\<in> set (predecessors g m)\n\ngoal (1 subgoal):\n 1. n \\<notin> (if length (predecessors g m) = 1 then {}\n                else {m}) \\<Longrightarrow>\n    \\<exists>ns.\n       g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n       (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n       length (predecessors g n) \\<noteq> 1 \\<and> unvisitedPath un ns", "with \"1.prems\"(2)"], ["proof (chain)\npicking this:\n  m \\<in> set (\\<alpha>n g)\n  n \\<in> phiDefNodes_aux g v (removeAll m un) m'\n  m' \\<in> set (predecessors g m)", "have \"m' \\<in> set (\\<alpha>n g)\""], ["proof (prove)\nusing this:\n  m \\<in> set (\\<alpha>n g)\n  n \\<in> phiDefNodes_aux g v (removeAll m un) m'\n  m' \\<in> set (predecessors g m)\n\ngoal (1 subgoal):\n 1. m' \\<in> set (\\<alpha>n g)", "by auto"], ["proof (state)\nthis:\n  m' \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. n \\<notin> (if length (predecessors g m) = 1 then {}\n                else {m}) \\<Longrightarrow>\n    \\<exists>ns.\n       g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n       (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n       length (predecessors g n) \\<noteq> 1 \\<and> unvisitedPath un ns", "with \"1.IH\"[of m m'] m' rec"], ["proof (chain)\npicking this:\n  \\<lbrakk>m \\<in> set un; n \\<in> phiDefNodes_aux g v (removeAll m un) m';\n   m' \\<in> set (\\<alpha>n g);\n   n \\<in> phiDefNodes_aux g v (removeAll m un) m';\n   m' \\<in> set (\\<alpha>n g)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ns.\n                       g \\<turnstile> n-ns\\<rightarrow>m' \\<and>\n                       (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n                       length (predecessors g n) \\<noteq> 1 \\<and>\n                       unvisitedPath (removeAll m un) ns\n  n \\<in> phiDefNodes_aux g v (removeAll m un) m'\n  m' \\<in> set (predecessors g m)\n  phiDefNodes_aux g v un m =\n  fold (\\<union>)\n   (map (phiDefNodes_aux g v (removeAll m un)) (predecessors g m))\n   (if length (predecessors g m) = 1 then {} else {m})\n  m \\<in> set un\n  v \\<notin> defs g m\n  m' \\<in> set (\\<alpha>n g)", "obtain ns where \"g \\<turnstile> n-ns\\<rightarrow>m'\" \"\\<forall>n \\<in> set ns. v \\<notin> defs g n\" \"length (predecessors g n) \\<noteq> 1\" \"unvisitedPath (removeAll m un) ns\""], ["proof (prove)\nusing this:\n  \\<lbrakk>m \\<in> set un; n \\<in> phiDefNodes_aux g v (removeAll m un) m';\n   m' \\<in> set (\\<alpha>n g);\n   n \\<in> phiDefNodes_aux g v (removeAll m un) m';\n   m' \\<in> set (\\<alpha>n g)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ns.\n                       g \\<turnstile> n-ns\\<rightarrow>m' \\<and>\n                       (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n                       length (predecessors g n) \\<noteq> 1 \\<and>\n                       unvisitedPath (removeAll m un) ns\n  n \\<in> phiDefNodes_aux g v (removeAll m un) m'\n  m' \\<in> set (predecessors g m)\n  phiDefNodes_aux g v un m =\n  fold (\\<union>)\n   (map (phiDefNodes_aux g v (removeAll m un)) (predecessors g m))\n   (if length (predecessors g m) = 1 then {} else {m})\n  m \\<in> set un\n  v \\<notin> defs g m\n  m' \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m';\n         \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n         length (predecessors g n) \\<noteq> 1;\n         unvisitedPath (removeAll m un) ns\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  g \\<turnstile> n-ns\\<rightarrow>m'\n  \\<forall>n\\<in>set ns. v \\<notin> defs g n\n  length (predecessors g n) \\<noteq> 1\n  unvisitedPath (removeAll m un) ns\n\ngoal (1 subgoal):\n 1. n \\<notin> (if length (predecessors g m) = 1 then {}\n                else {m}) \\<Longrightarrow>\n    \\<exists>ns.\n       g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n       (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n       length (predecessors g n) \\<noteq> 1 \\<and> unvisitedPath un ns", "thus ?thesis"], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<rightarrow>m'\n  \\<forall>n\\<in>set ns. v \\<notin> defs g n\n  length (predecessors g n) \\<noteq> 1\n  unvisitedPath (removeAll m un) ns\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n       (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n       length (predecessors g n) \\<noteq> 1 \\<and> unvisitedPath un ns", "using m' rec"], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<rightarrow>m'\n  \\<forall>n\\<in>set ns. v \\<notin> defs g n\n  length (predecessors g n) \\<noteq> 1\n  unvisitedPath (removeAll m un) ns\n  n \\<in> phiDefNodes_aux g v (removeAll m un) m'\n  m' \\<in> set (predecessors g m)\n  phiDefNodes_aux g v un m =\n  fold (\\<union>)\n   (map (phiDefNodes_aux g v (removeAll m un)) (predecessors g m))\n   (if length (predecessors g m) = 1 then {} else {m})\n  m \\<in> set un\n  v \\<notin> defs g m\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n       (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n       length (predecessors g n) \\<noteq> 1 \\<and> unvisitedPath un ns", "by -(rule exI, auto)"], ["proof (state)\nthis:\n  \\<exists>ns.\n     g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n     (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n     length (predecessors g n) \\<noteq> 1 \\<and> unvisitedPath un ns\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns.\n     g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n     (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n     length (predecessors g n) \\<noteq> 1 \\<and> unvisitedPath un ns\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ns.\n     g \\<turnstile> n-ns\\<rightarrow>m \\<and>\n     (\\<forall>n\\<in>set ns. v \\<notin> defs g n) \\<and>\n     length (predecessors g n) \\<noteq> 1 \\<and> unvisitedPath un ns\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma phiDefNodesE:\n    assumes \"n \\<in> phiDefNodes g v\"\n    obtains ns m where \"g \\<turnstile> n-ns\\<rightarrow>m\" \"\\<forall>n \\<in> set ns. v \\<notin> defs g n\" \"v \\<in> uses g m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ns m.\n        \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m;\n         \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n         v \\<in> uses g m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  n \\<in> phiDefNodes g v\n\ngoal (1 subgoal):\n 1. (\\<And>ns m.\n        \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m;\n         \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n         v \\<in> uses g m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!:phiDefNodes_auxE elim!:fold_union_elem simp:phiDefNodes_def)"], ["", "lemma phiDefNodes_\\<alpha>n[simp]: \"n \\<in> phiDefNodes g v \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> phiDefNodes g v \\<Longrightarrow> n \\<in> set (\\<alpha>n g)", "by (erule phiDefNodesE, auto)"], ["", "lemma phiDefNodesI:\n    assumes \"g \\<turnstile> n-ns\\<rightarrow>m\" \"v \\<in> uses g m\" \"\\<forall>n \\<in> set ns. v \\<notin> defs g n\" \"length (predecessors g n) \\<noteq> 1\"\n    shows \"n \\<in> phiDefNodes g v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> phiDefNodes g v", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<in> phiDefNodes g v", "from assms(1)"], ["proof (chain)\npicking this:\n  g \\<turnstile> n-ns\\<rightarrow>m", "have \"m \\<in> set (\\<alpha>n g)\""], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n\ngoal (1 subgoal):\n 1. m \\<in> set (\\<alpha>n g)", "by (rule path2_in_\\<alpha>n, auto)"], ["proof (state)\nthis:\n  m \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. n \\<in> phiDefNodes g v", "from assms"], ["proof (chain)\npicking this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  v \\<in> uses g m\n  \\<forall>n\\<in>set ns. v \\<notin> defs g n\n  length (predecessors g n) \\<noteq> 1", "obtain ns' where \"g \\<turnstile> n-ns'\\<rightarrow>m\" \"distinct ns'\" \"\\<forall>n \\<in> set ns'. v \\<notin> defs g n\""], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  v \\<in> uses g m\n  \\<forall>n\\<in>set ns. v \\<notin> defs g n\n  length (predecessors g n) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. (\\<And>ns'.\n        \\<lbrakk>g \\<turnstile> n-ns'\\<rightarrow>m; distinct ns';\n         \\<forall>n\\<in>set ns'. v \\<notin> defs g n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(rule simple_path2, auto)"], ["proof (state)\nthis:\n  g \\<turnstile> n-ns'\\<rightarrow>m\n  distinct ns'\n  \\<forall>n\\<in>set ns'. v \\<notin> defs g n\n\ngoal (1 subgoal):\n 1. n \\<in> phiDefNodes g v", "with assms(4)"], ["proof (chain)\npicking this:\n  length (predecessors g n) \\<noteq> 1\n  g \\<turnstile> n-ns'\\<rightarrow>m\n  distinct ns'\n  \\<forall>n\\<in>set ns'. v \\<notin> defs g n", "have 1: \"n \\<in> phiDefNodes_aux g v (\\<alpha>n g) m\""], ["proof (prove)\nusing this:\n  length (predecessors g n) \\<noteq> 1\n  g \\<turnstile> n-ns'\\<rightarrow>m\n  distinct ns'\n  \\<forall>n\\<in>set ns'. v \\<notin> defs g n\n\ngoal (1 subgoal):\n 1. n \\<in> phiDefNodes_aux g v (\\<alpha>n g) m", "by -(rule phiDefNodes_auxI, auto intro:path2_in_\\<alpha>n)"], ["proof (state)\nthis:\n  n \\<in> phiDefNodes_aux g v (\\<alpha>n g) m\n\ngoal (1 subgoal):\n 1. n \\<in> phiDefNodes g v", "thus ?thesis"], ["proof (prove)\nusing this:\n  n \\<in> phiDefNodes_aux g v (\\<alpha>n g) m\n\ngoal (1 subgoal):\n 1. n \\<in> phiDefNodes g v", "using assms(2) \\<open>m \\<in> set (\\<alpha>n g)\\<close>"], ["proof (prove)\nusing this:\n  n \\<in> phiDefNodes_aux g v (\\<alpha>n g) m\n  v \\<in> uses g m\n  m \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. n \\<in> phiDefNodes g v", "unfolding phiDefNodes_def"], ["proof (prove)\nusing this:\n  n \\<in> phiDefNodes_aux g v (\\<alpha>n g) m\n  v \\<in> uses g m\n  m \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. n \\<in> fold (\\<union>)\n             (concat\n               (map (\\<lambda>n.\n                        if v \\<in> uses g n\n                        then [phiDefNodes_aux g v (\\<alpha>n g) n] else [])\n                 (\\<alpha>n g)))\n             {}", "by -(rule fold_union_elemI, auto)"], ["proof (state)\nthis:\n  n \\<in> phiDefNodes g v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookupDef_cases[consumes 1]:\n    assumes \"n \\<in> set (\\<alpha>n g)\"\n    obtains (SimpleDef) \"v \\<in> defs g n\" \"lookupDef g n v = (v,n,SimpleDef)\"\n          | (PhiDef)    \"v \\<notin> defs g n\" \"length (predecessors g n) \\<noteq> 1\" \"lookupDef g n v = (v,n,PhiDef)\"\n          | (rec) m where \"v \\<notin> defs g n\" \"predecessors g n = [m]\" \"m \\<in> set (\\<alpha>n g)\" \"lookupDef g n v = lookupDef g m v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>v \\<in> defs g n;\n              lookupDef g n v = (v, n, SimpleDef)\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>v \\<notin> defs g n; length (predecessors g n) \\<noteq> 1;\n      lookupDef g n v = (v, n, PhiDef)\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<And>m.\n        \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n         m \\<in> set (\\<alpha>n g);\n         lookupDef g n v = lookupDef g m v\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof (cases \"v \\<in> defs g n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>v \\<in> defs g n;\n              lookupDef g n v = (v, n, SimpleDef)\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>v \\<notin> defs g n; length (predecessors g n) \\<noteq> 1;\n      lookupDef g n v = (v, n, PhiDef)\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<And>m.\n        \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n         m \\<in> set (\\<alpha>n g);\n         lookupDef g n v = lookupDef g m v\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     v \\<in> defs g n\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<lbrakk>v \\<in> defs g n;\n              lookupDef g n v = (v, n, SimpleDef)\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>v \\<notin> defs g n; length (predecessors g n) \\<noteq> 1;\n      lookupDef g n v = (v, n, PhiDef)\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<And>m.\n        \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n         m \\<in> set (\\<alpha>n g);\n         lookupDef g n v = lookupDef g m v\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     v \\<notin> defs g n\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  v \\<in> defs g n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>v \\<in> defs g n;\n              lookupDef g n v = (v, n, SimpleDef)\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>v \\<notin> defs g n; length (predecessors g n) \\<noteq> 1;\n      lookupDef g n v = (v, n, PhiDef)\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<And>m.\n        \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n         m \\<in> set (\\<alpha>n g);\n         lookupDef g n v = lookupDef g m v\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     v \\<in> defs g n\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<lbrakk>v \\<in> defs g n;\n              lookupDef g n v = (v, n, SimpleDef)\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>v \\<notin> defs g n; length (predecessors g n) \\<noteq> 1;\n      lookupDef g n v = (v, n, PhiDef)\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<And>m.\n        \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n         m \\<in> set (\\<alpha>n g);\n         lookupDef g n v = lookupDef g m v\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     v \\<notin> defs g n\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus thesis"], ["proof (prove)\nusing this:\n  v \\<in> defs g n\n\ngoal (1 subgoal):\n 1. thesis", "using assms SimpleDef"], ["proof (prove)\nusing this:\n  v \\<in> defs g n\n  n \\<in> set (\\<alpha>n g)\n  \\<lbrakk>v \\<in> defs g n; lookupDef g n v = (v, n, SimpleDef)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (simp add:lookupDef.simps)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>v \\<in> defs g n;\n              lookupDef g n v = (v, n, SimpleDef)\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>v \\<notin> defs g n; length (predecessors g n) \\<noteq> 1;\n      lookupDef g n v = (v, n, PhiDef)\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<And>m.\n        \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n         m \\<in> set (\\<alpha>n g);\n         lookupDef g n v = lookupDef g m v\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     v \\<notin> defs g n\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>v \\<in> defs g n;\n              lookupDef g n v = (v, n, SimpleDef)\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>v \\<notin> defs g n; length (predecessors g n) \\<noteq> 1;\n      lookupDef g n v = (v, n, PhiDef)\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<And>m.\n        \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n         m \\<in> set (\\<alpha>n g);\n         lookupDef g n v = lookupDef g m v\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     v \\<notin> defs g n\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  v \\<notin> defs g n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>v \\<in> defs g n;\n              lookupDef g n v = (v, n, SimpleDef)\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>v \\<notin> defs g n; length (predecessors g n) \\<noteq> 1;\n      lookupDef g n v = (v, n, PhiDef)\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<And>m.\n        \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n         m \\<in> set (\\<alpha>n g);\n         lookupDef g n v = lookupDef g m v\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     v \\<notin> defs g n\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus thesis"], ["proof (prove)\nusing this:\n  v \\<notin> defs g n\n\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"length (predecessors g n) = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<notin> defs g n; length (predecessors g n) = 1\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>v \\<notin> defs g n;\n     length (predecessors g n) \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  length (predecessors g n) = 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<notin> defs g n; length (predecessors g n) = 1\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>v \\<notin> defs g n;\n     length (predecessors g n) \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  length (predecessors g n) = 1", "obtain m where m: \"predecessors g n = [m]\""], ["proof (prove)\nusing this:\n  length (predecessors g n) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        predecessors g n = [m] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"predecessors g n\", auto)"], ["proof (state)\nthis:\n  predecessors g n = [m]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<notin> defs g n; length (predecessors g n) = 1\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>v \\<notin> defs g n;\n     length (predecessors g n) \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"m \\<in> set (predecessors g n)\""], ["proof (prove)\nusing this:\n  predecessors g n = [m]\n\ngoal (1 subgoal):\n 1. m \\<in> set (predecessors g n)", "by simp"], ["proof (state)\nthis:\n  m \\<in> set (predecessors g n)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<notin> defs g n; length (predecessors g n) = 1\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>v \\<notin> defs g n;\n     length (predecessors g n) \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus thesis"], ["proof (prove)\nusing this:\n  m \\<in> set (predecessors g n)\n\ngoal (1 subgoal):\n 1. thesis", "using False rec assms m"], ["proof (prove)\nusing this:\n  m \\<in> set (predecessors g n)\n  v \\<notin> defs g n\n  \\<lbrakk>v \\<notin> defs g n; predecessors g n = [?m1];\n   ?m1 \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g ?m1 v\\<rbrakk>\n  \\<Longrightarrow> thesis\n  n \\<in> set (\\<alpha>n g)\n  predecessors g n = [m]\n\ngoal (1 subgoal):\n 1. thesis", "by -(subst(asm) lookupDef.simps, drule predecessor_is_node, auto)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<notin> defs g n;\n     length (predecessors g n) \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<notin> defs g n;\n     length (predecessors g n) \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  length (predecessors g n) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<notin> defs g n;\n     length (predecessors g n) \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus thesis"], ["proof (prove)\nusing this:\n  length (predecessors g n) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. thesis", "using \\<open>v \\<notin> defs g n\\<close> assms"], ["proof (prove)\nusing this:\n  length (predecessors g n) \\<noteq> 1\n  v \\<notin> defs g n\n  n \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. thesis", "by -(rule PhiDef, assumption, assumption, subst lookupDef.simps, auto split:list.split)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookupDef_cases'[consumes 1]:\n    assumes \"n \\<in> set (\\<alpha>n g)\"\n    obtains (SimpleDef) \"v \\<in> defs g n\" \"defNode (lookupDef g n v) = n\" \"defKind (lookupDef g n v) = SimpleDef\"\n          | (PhiDef)    \"v \\<notin> defs g n\" \"length (predecessors g n) \\<noteq> 1\" \"lookupDefNode g n v = n\" \"defKind (lookupDef g n v) = PhiDef\"\n          | (rec) m where \"v \\<notin> defs g n\" \"predecessors g n = [m]\" \"m \\<in> set (\\<alpha>n g)\" \"lookupDef g n v = lookupDef g m v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>v \\<in> defs g n; lookupDefNode g n v = n;\n              defKind (lookupDef g n v) = SimpleDef\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>v \\<notin> defs g n; length (predecessors g n) \\<noteq> 1;\n      lookupDefNode g n v = n; defKind (lookupDef g n v) = PhiDef\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<And>m.\n        \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n         m \\<in> set (\\<alpha>n g);\n         lookupDef g n v = lookupDef g m v\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  n \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>v \\<in> defs g n; lookupDefNode g n v = n;\n              defKind (lookupDef g n v) = SimpleDef\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>v \\<notin> defs g n; length (predecessors g n) \\<noteq> 1;\n      lookupDefNode g n v = n; defKind (lookupDef g n v) = PhiDef\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<And>m.\n        \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n         m \\<in> set (\\<alpha>n g);\n         lookupDef g n v = lookupDef g m v\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (rule lookupDef_cases[of n g v]) simp_all"], ["", "lemma lookupDefE:\n    assumes \"lookupDef g n v = v'\" \"n \\<in> set (\\<alpha>n g)\"\n    obtains (SimpleDef) \"v \\<in> defs g n\" \"v' = (v,n,SimpleDef)\"\n          | (PhiDef)    \"v \\<notin> defs g n\" \"length (predecessors g n) \\<noteq> 1\" \"v' = (v,n,PhiDef)\"\n          | (rec) m where \"v \\<notin> defs g n\" \"predecessors g n = [m]\" \"m \\<in> set (\\<alpha>n g)\" \"v' = lookupDef g m v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>v \\<in> defs g n; v' = (v, n, SimpleDef)\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>v \\<notin> defs g n; length (predecessors g n) \\<noteq> 1;\n      v' = (v, n, PhiDef)\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<And>m.\n        \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n         m \\<in> set (\\<alpha>n g); v' = lookupDef g m v\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  lookupDef g n v = v'\n  n \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>v \\<in> defs g n; v' = (v, n, SimpleDef)\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>v \\<notin> defs g n; length (predecessors g n) \\<noteq> 1;\n      v' = (v, n, PhiDef)\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<And>m.\n        \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n         m \\<in> set (\\<alpha>n g); v' = lookupDef g m v\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by -(atomize_elim, cases rule:lookupDef_cases[of n g v], auto)"], ["", "lemma lookupDef_induct[consumes 1, case_names SimpleDef PhiDef rec]:\n    assumes \"n \\<in> set (\\<alpha>n g)\"\n            \"\\<And>n. \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> defs g n; lookupDef g n v = (v,n,SimpleDef)\\<rbrakk> \\<Longrightarrow> P n\"\n            \"\\<And>n. \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<notin> defs g n; length (predecessors g n) \\<noteq> 1; lookupDef g n v = (v,n,PhiDef)\\<rbrakk> \\<Longrightarrow> P n\"\n            \"\\<And>n m. \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m]; m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v; P m\\<rbrakk> \\<Longrightarrow> P n\"\n    shows \"P n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P n", "apply (induct rule:lookupDef.induct[where P = \"\\<lambda>g' n v'. g'=g \\<and> v'=v \\<and> n \\<in> set (\\<alpha>n g) \\<longrightarrow> P n\", of g v n, simplified (no_asm), THEN mp])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ga n va.\n       (\\<And>x21 x22.\n           \\<lbrakk>\\<not> n \\<notin> set (\\<alpha>n ga);\n            va \\<notin> defs ga n; predecessors ga n = x21 # x22;\n            x22 = []\\<rbrakk>\n           \\<Longrightarrow> ga = g \\<and>\n                             va = v \\<and>\n                             x21 \\<in> set (\\<alpha>n g) \\<longrightarrow>\n                             P x21) \\<Longrightarrow>\n       ga = g \\<and>\n       va = v \\<and> n \\<in> set (\\<alpha>n g) \\<longrightarrow>\n       P n\n 2. n \\<in> set (\\<alpha>n g)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>v \\<notin> defs g n; predecessors g n = [x21];\n                    x22 = []\\<rbrakk>\n                   \\<Longrightarrow> x21\n                                     \\<in> set\n      (\\<alpha>n g) \\<longrightarrow>\n                                     P x21;\n        n \\<in> set (\\<alpha>n g)\\<rbrakk>\n       \\<Longrightarrow> P n\n 2. n \\<in> set (\\<alpha>n g)", "apply (rule_tac v=v and n=n in lookupDef_cases; auto intro: assms lookupDef_cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> set (\\<alpha>n g)", "by (rule assms(1))"], ["", "lemma lookupDef_induct'[consumes 2, case_names SimpleDef PhiDef rec]:\n    assumes \"n \\<in> set (\\<alpha>n g)\" \"lookupDef g n v = (v,n',def)\"\n            \"\\<lbrakk>v \\<in> defs g n'; def = SimpleDef\\<rbrakk> \\<Longrightarrow> P n'\"\n            \"\\<lbrakk>v \\<notin> defs g n'; length (predecessors g n') \\<noteq> 1; def = PhiDef\\<rbrakk> \\<Longrightarrow> P n'\"\n            \"\\<And>n m. \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m]; m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v; P m\\<rbrakk> \\<Longrightarrow> P n\"\n    shows \"P n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P n", "using assms(1,2)"], ["proof (prove)\nusing this:\n  n \\<in> set (\\<alpha>n g)\n  lookupDef g n v = (v, n', def)\n\ngoal (1 subgoal):\n 1. P n", "proof (induction rule:lookupDef_induct[where v=v])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> defs g n;\n        lookupDef g n v = (v, n, SimpleDef);\n        lookupDef g n v = (v, n', def)\\<rbrakk>\n       \\<Longrightarrow> P n\n 2. \\<And>n.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> 1;\n        lookupDef g n v = (v, n, PhiDef);\n        lookupDef g n v = (v, n', def)\\<rbrakk>\n       \\<Longrightarrow> P n\n 3. \\<And>n m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v;\n        lookupDef g m v = (v, n', def) \\<Longrightarrow> P m;\n        lookupDef g n v = (v, n', def)\\<rbrakk>\n       \\<Longrightarrow> P n", "case (SimpleDef n)"], ["proof (state)\nthis:\n  n \\<in> set (\\<alpha>n g)\n  v \\<in> defs g n\n  lookupDef g n v = (v, n, SimpleDef)\n  lookupDef g n v = (v, n', def)\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> defs g n;\n        lookupDef g n v = (v, n, SimpleDef);\n        lookupDef g n v = (v, n', def)\\<rbrakk>\n       \\<Longrightarrow> P n\n 2. \\<And>n.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> 1;\n        lookupDef g n v = (v, n, PhiDef);\n        lookupDef g n v = (v, n', def)\\<rbrakk>\n       \\<Longrightarrow> P n\n 3. \\<And>n m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v;\n        lookupDef g m v = (v, n', def) \\<Longrightarrow> P m;\n        lookupDef g n v = (v, n', def)\\<rbrakk>\n       \\<Longrightarrow> P n", "with assms(2)"], ["proof (chain)\npicking this:\n  lookupDef g n v = (v, n', def)\n  n \\<in> set (\\<alpha>n g)\n  v \\<in> defs g n\n  lookupDef g n v = (v, n, SimpleDef)\n  lookupDef g n v = (v, n', def)", "have \"n = n'\" \"def = SimpleDef\""], ["proof (prove)\nusing this:\n  lookupDef g n v = (v, n', def)\n  n \\<in> set (\\<alpha>n g)\n  v \\<in> defs g n\n  lookupDef g n v = (v, n, SimpleDef)\n  lookupDef g n v = (v, n', def)\n\ngoal (1 subgoal):\n 1. n = n' &&& def = SimpleDef", "by auto"], ["proof (state)\nthis:\n  n = n'\n  def = SimpleDef\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> defs g n;\n        lookupDef g n v = (v, n, SimpleDef);\n        lookupDef g n v = (v, n', def)\\<rbrakk>\n       \\<Longrightarrow> P n\n 2. \\<And>n.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> 1;\n        lookupDef g n v = (v, n, PhiDef);\n        lookupDef g n v = (v, n', def)\\<rbrakk>\n       \\<Longrightarrow> P n\n 3. \\<And>n m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v;\n        lookupDef g m v = (v, n', def) \\<Longrightarrow> P m;\n        lookupDef g n v = (v, n', def)\\<rbrakk>\n       \\<Longrightarrow> P n", "with SimpleDef assms(3)"], ["proof (chain)\npicking this:\n  n \\<in> set (\\<alpha>n g)\n  v \\<in> defs g n\n  lookupDef g n v = (v, n, SimpleDef)\n  lookupDef g n v = (v, n', def)\n  \\<lbrakk>v \\<in> defs g n'; def = SimpleDef\\<rbrakk>\n  \\<Longrightarrow> P n'\n  n = n'\n  def = SimpleDef", "show ?case"], ["proof (prove)\nusing this:\n  n \\<in> set (\\<alpha>n g)\n  v \\<in> defs g n\n  lookupDef g n v = (v, n, SimpleDef)\n  lookupDef g n v = (v, n', def)\n  \\<lbrakk>v \\<in> defs g n'; def = SimpleDef\\<rbrakk>\n  \\<Longrightarrow> P n'\n  n = n'\n  def = SimpleDef\n\ngoal (1 subgoal):\n 1. P n", "by simp"], ["proof (state)\nthis:\n  P n\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> 1;\n        lookupDef g n v = (v, n, PhiDef);\n        lookupDef g n v = (v, n', def)\\<rbrakk>\n       \\<Longrightarrow> P n\n 2. \\<And>n m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v;\n        lookupDef g m v = (v, n', def) \\<Longrightarrow> P m;\n        lookupDef g n v = (v, n', def)\\<rbrakk>\n       \\<Longrightarrow> P n", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> 1;\n        lookupDef g n v = (v, n, PhiDef);\n        lookupDef g n v = (v, n', def)\\<rbrakk>\n       \\<Longrightarrow> P n\n 2. \\<And>n m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v;\n        lookupDef g m v = (v, n', def) \\<Longrightarrow> P m;\n        lookupDef g n v = (v, n', def)\\<rbrakk>\n       \\<Longrightarrow> P n", "case (PhiDef n)"], ["proof (state)\nthis:\n  n \\<in> set (\\<alpha>n g)\n  v \\<notin> defs g n\n  length (predecessors g n) \\<noteq> 1\n  lookupDef g n v = (v, n, PhiDef)\n  lookupDef g n v = (v, n', def)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> 1;\n        lookupDef g n v = (v, n, PhiDef);\n        lookupDef g n v = (v, n', def)\\<rbrakk>\n       \\<Longrightarrow> P n\n 2. \\<And>n m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v;\n        lookupDef g m v = (v, n', def) \\<Longrightarrow> P m;\n        lookupDef g n v = (v, n', def)\\<rbrakk>\n       \\<Longrightarrow> P n", "with assms(2)"], ["proof (chain)\npicking this:\n  lookupDef g n v = (v, n', def)\n  n \\<in> set (\\<alpha>n g)\n  v \\<notin> defs g n\n  length (predecessors g n) \\<noteq> 1\n  lookupDef g n v = (v, n, PhiDef)\n  lookupDef g n v = (v, n', def)", "have \"n = n'\" \"def = PhiDef\""], ["proof (prove)\nusing this:\n  lookupDef g n v = (v, n', def)\n  n \\<in> set (\\<alpha>n g)\n  v \\<notin> defs g n\n  length (predecessors g n) \\<noteq> 1\n  lookupDef g n v = (v, n, PhiDef)\n  lookupDef g n v = (v, n', def)\n\ngoal (1 subgoal):\n 1. n = n' &&& def = PhiDef", "by auto"], ["proof (state)\nthis:\n  n = n'\n  def = PhiDef\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> 1;\n        lookupDef g n v = (v, n, PhiDef);\n        lookupDef g n v = (v, n', def)\\<rbrakk>\n       \\<Longrightarrow> P n\n 2. \\<And>n m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v;\n        lookupDef g m v = (v, n', def) \\<Longrightarrow> P m;\n        lookupDef g n v = (v, n', def)\\<rbrakk>\n       \\<Longrightarrow> P n", "with PhiDef assms(4)"], ["proof (chain)\npicking this:\n  n \\<in> set (\\<alpha>n g)\n  v \\<notin> defs g n\n  length (predecessors g n) \\<noteq> 1\n  lookupDef g n v = (v, n, PhiDef)\n  lookupDef g n v = (v, n', def)\n  \\<lbrakk>v \\<notin> defs g n'; length (predecessors g n') \\<noteq> 1;\n   def = PhiDef\\<rbrakk>\n  \\<Longrightarrow> P n'\n  n = n'\n  def = PhiDef", "show ?case"], ["proof (prove)\nusing this:\n  n \\<in> set (\\<alpha>n g)\n  v \\<notin> defs g n\n  length (predecessors g n) \\<noteq> 1\n  lookupDef g n v = (v, n, PhiDef)\n  lookupDef g n v = (v, n', def)\n  \\<lbrakk>v \\<notin> defs g n'; length (predecessors g n') \\<noteq> 1;\n   def = PhiDef\\<rbrakk>\n  \\<Longrightarrow> P n'\n  n = n'\n  def = PhiDef\n\ngoal (1 subgoal):\n 1. P n", "by simp"], ["proof (state)\nthis:\n  P n\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v;\n        lookupDef g m v = (v, n', def) \\<Longrightarrow> P m;\n        lookupDef g n v = (v, n', def)\\<rbrakk>\n       \\<Longrightarrow> P n", "qed (rule assms(5), simp_all)"], ["", "lemma lookupDef_looksup[simp]:\n    assumes \"lookupDef g n v = (v',n',def)\" \"n \\<in> set (\\<alpha>n g)\"\n    shows \"v' = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v' = v", "using assms(1) assms(2)"], ["proof (prove)\nusing this:\n  lookupDef g n v = (v', n', def)\n  n \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. v' = v", "by (induction rule:lookupDef.induct) (auto elim:lookupDefE)"], ["", "lemma lookupDef_looksup':\n    assumes \"(v',n',def) = lookupDef g n v\" \"n \\<in> set (\\<alpha>n g)\"\n    shows \"v' = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v' = v", "using assms(1)[symmetric] assms(2)"], ["proof (prove)\nusing this:\n  lookupDef g n v = (v', n', def)\n  n \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. v' = v", "by (rule lookupDef_looksup)"], ["", "lemma lookupDef_looksup'':\n    assumes \"n \\<in> set (\\<alpha>n g)\"\n    obtains n' \"def\" where \"lookupDef g n v = (v,n',def)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n' def.\n        lookupDef g n v = (v, n', def) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n' def. lookupDef g n v = (v, n', def)", "using assms"], ["proof (prove)\nusing this:\n  n \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. \\<exists>n' def. lookupDef g n v = (v, n', def)", "by (induction rule:lookupDef.induct) (cases rule:lookupDef_cases, auto)"], ["", "lemma lookupDef_fst[simp]: \"n \\<in> set (\\<alpha>n g) \\<Longrightarrow> fst (lookupDef g n v) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> set (\\<alpha>n g) \\<Longrightarrow> fst (lookupDef g n v) = v", "by (metis fst_conv lookupDef_looksup'')"], ["", "lemma lookupDef_to_\\<alpha>n:\n    assumes \"lookupDef g n v = (v',n',def)\" \"n \\<in> set (\\<alpha>n g)\"\n    shows \"n' \\<in> set (\\<alpha>n g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n' \\<in> set (\\<alpha>n g)", "using assms(2,1)"], ["proof (prove)\nusing this:\n  n \\<in> set (\\<alpha>n g)\n  lookupDef g n v = (v', n', def)\n\ngoal (1 subgoal):\n 1. n' \\<in> set (\\<alpha>n g)", "by (induction rule:lookupDef_induct[of n g v]) simp_all"], ["", "lemma lookupDef_to_\\<alpha>n'[simp]:\n    assumes \"lookupDef g n v = val\" \"n \\<in> set (\\<alpha>n g)\"\n    shows \"defNode val \\<in> set (\\<alpha>n g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. defNode val \\<in> set (\\<alpha>n g)", "using assms"], ["proof (prove)\nusing this:\n  lookupDef g n v = val\n  n \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. defNode val \\<in> set (\\<alpha>n g)", "by (cases val) (auto simp:lookupDef_to_\\<alpha>n)"], ["", "lemma lookupDef_induct''[consumes 2, case_names SimpleDef PhiDef rec]:\n    assumes \"lookupDef g n v = val\" \"n \\<in> set (\\<alpha>n g)\"\n            \"\\<lbrakk>v \\<in> defs g (defNode val); defKind val = SimpleDef\\<rbrakk> \\<Longrightarrow> P (defNode val)\"\n            \"\\<lbrakk>v \\<notin> defs g (defNode val); length (predecessors g (defNode val)) \\<noteq> 1; defKind val = PhiDef\\<rbrakk> \\<Longrightarrow> P (defNode val)\"\n            \"\\<And>n m. \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m]; m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v; P m\\<rbrakk> \\<Longrightarrow> P n\"\n    shows \"P n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P n", "using assms"], ["proof (prove)\nusing this:\n  lookupDef g n v = val\n  n \\<in> set (\\<alpha>n g)\n  \\<lbrakk>v \\<in> defs g (defNode val); defKind val = SimpleDef\\<rbrakk>\n  \\<Longrightarrow> P (defNode val)\n  \\<lbrakk>v \\<notin> defs g (defNode val);\n   length (predecessors g (defNode val)) \\<noteq> 1;\n   defKind val = PhiDef\\<rbrakk>\n  \\<Longrightarrow> P (defNode val)\n  \\<lbrakk>v \\<notin> defs g ?n1; predecessors g ?n1 = [?m1];\n   ?m1 \\<in> set (\\<alpha>n g); lookupDef g ?n1 v = lookupDef g ?m1 v;\n   P ?m1\\<rbrakk>\n  \\<Longrightarrow> P ?n1\n\ngoal (1 subgoal):\n 1. P n", "apply (cases val)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>lookupDef g n v = val; n \\<in> set (\\<alpha>n g);\n        \\<lbrakk>v \\<in> defs g (defNode val);\n         defKind val = SimpleDef\\<rbrakk>\n        \\<Longrightarrow> P (defNode val);\n        \\<lbrakk>v \\<notin> defs g (defNode val);\n         length (predecessors g (defNode val)) \\<noteq> 1;\n         defKind val = PhiDef\\<rbrakk>\n        \\<Longrightarrow> P (defNode val);\n        \\<And>n m.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n            m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v;\n            P m\\<rbrakk>\n           \\<Longrightarrow> P n;\n        val = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> P n", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>lookupDef g n v = (a, b, c); n \\<in> set (\\<alpha>n g);\n        \\<lbrakk>v \\<in> defs g b; c = SimpleDef\\<rbrakk>\n        \\<Longrightarrow> P b;\n        \\<lbrakk>v \\<notin> defs g b;\n         length (predecessors g b) \\<noteq> Suc 0; c = PhiDef\\<rbrakk>\n        \\<Longrightarrow> P b;\n        \\<And>n m.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n            m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v;\n            P m\\<rbrakk>\n           \\<Longrightarrow> P n;\n        val = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> P n", "apply (erule lookupDef_induct')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>lookupDef g n v = (a, b, c);\n        \\<lbrakk>v \\<in> defs g b; c = SimpleDef\\<rbrakk>\n        \\<Longrightarrow> P b;\n        \\<lbrakk>v \\<notin> defs g b;\n         length (predecessors g b) \\<noteq> Suc 0; c = PhiDef\\<rbrakk>\n        \\<Longrightarrow> P b;\n        \\<And>n m.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n            m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v;\n            P m\\<rbrakk>\n           \\<Longrightarrow> P n;\n        val = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n (?v8 a b c) =\n                         (?v8 a b c, ?n'8 a b c, ?def8 a b c)\n 2. \\<And>a b c.\n       \\<lbrakk>lookupDef g n v = (a, b, c);\n        \\<lbrakk>v \\<in> defs g b; c = SimpleDef\\<rbrakk>\n        \\<Longrightarrow> P b;\n        \\<lbrakk>v \\<notin> defs g b;\n         length (predecessors g b) \\<noteq> Suc 0; c = PhiDef\\<rbrakk>\n        \\<Longrightarrow> P b;\n        \\<And>n m.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n            m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v;\n            P m\\<rbrakk>\n           \\<Longrightarrow> P n;\n        val = (a, b, c); ?v8 a b c \\<in> defs g (?n'8 a b c);\n        ?def8 a b c = SimpleDef\\<rbrakk>\n       \\<Longrightarrow> P (?n'8 a b c)\n 3. \\<And>a b c.\n       \\<lbrakk>lookupDef g n v = (a, b, c);\n        \\<lbrakk>v \\<in> defs g b; c = SimpleDef\\<rbrakk>\n        \\<Longrightarrow> P b;\n        \\<lbrakk>v \\<notin> defs g b;\n         length (predecessors g b) \\<noteq> Suc 0; c = PhiDef\\<rbrakk>\n        \\<Longrightarrow> P b;\n        \\<And>n m.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n            m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v;\n            P m\\<rbrakk>\n           \\<Longrightarrow> P n;\n        val = (a, b, c); ?v8 a b c \\<notin> defs g (?n'8 a b c);\n        length (predecessors g (?n'8 a b c)) \\<noteq> 1;\n        ?def8 a b c = PhiDef\\<rbrakk>\n       \\<Longrightarrow> P (?n'8 a b c)\n 4. \\<And>a b c na m.\n       \\<lbrakk>lookupDef g n v = (a, b, c);\n        \\<lbrakk>v \\<in> defs g b; c = SimpleDef\\<rbrakk>\n        \\<Longrightarrow> P b;\n        \\<lbrakk>v \\<notin> defs g b;\n         length (predecessors g b) \\<noteq> Suc 0; c = PhiDef\\<rbrakk>\n        \\<Longrightarrow> P b;\n        \\<And>n m.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n            m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v;\n            P m\\<rbrakk>\n           \\<Longrightarrow> P n;\n        val = (a, b, c); ?v8 a b c \\<notin> defs g na;\n        predecessors g na = [m]; m \\<in> set (\\<alpha>n g);\n        lookupDef g na (?v8 a b c) = lookupDef g m (?v8 a b c); P m\\<rbrakk>\n       \\<Longrightarrow> P na", "using assms(2)"], ["proof (prove)\nusing this:\n  n \\<in> set (\\<alpha>n g)\n\ngoal (4 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>lookupDef g n v = (a, b, c);\n        \\<lbrakk>v \\<in> defs g b; c = SimpleDef\\<rbrakk>\n        \\<Longrightarrow> P b;\n        \\<lbrakk>v \\<notin> defs g b;\n         length (predecessors g b) \\<noteq> Suc 0; c = PhiDef\\<rbrakk>\n        \\<Longrightarrow> P b;\n        \\<And>n m.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n            m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v;\n            P m\\<rbrakk>\n           \\<Longrightarrow> P n;\n        val = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n (?v8 a b c) =\n                         (?v8 a b c, ?n'8 a b c, ?def8 a b c)\n 2. \\<And>a b c.\n       \\<lbrakk>lookupDef g n v = (a, b, c);\n        \\<lbrakk>v \\<in> defs g b; c = SimpleDef\\<rbrakk>\n        \\<Longrightarrow> P b;\n        \\<lbrakk>v \\<notin> defs g b;\n         length (predecessors g b) \\<noteq> Suc 0; c = PhiDef\\<rbrakk>\n        \\<Longrightarrow> P b;\n        \\<And>n m.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n            m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v;\n            P m\\<rbrakk>\n           \\<Longrightarrow> P n;\n        val = (a, b, c); ?v8 a b c \\<in> defs g (?n'8 a b c);\n        ?def8 a b c = SimpleDef\\<rbrakk>\n       \\<Longrightarrow> P (?n'8 a b c)\n 3. \\<And>a b c.\n       \\<lbrakk>lookupDef g n v = (a, b, c);\n        \\<lbrakk>v \\<in> defs g b; c = SimpleDef\\<rbrakk>\n        \\<Longrightarrow> P b;\n        \\<lbrakk>v \\<notin> defs g b;\n         length (predecessors g b) \\<noteq> Suc 0; c = PhiDef\\<rbrakk>\n        \\<Longrightarrow> P b;\n        \\<And>n m.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n            m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v;\n            P m\\<rbrakk>\n           \\<Longrightarrow> P n;\n        val = (a, b, c); ?v8 a b c \\<notin> defs g (?n'8 a b c);\n        length (predecessors g (?n'8 a b c)) \\<noteq> 1;\n        ?def8 a b c = PhiDef\\<rbrakk>\n       \\<Longrightarrow> P (?n'8 a b c)\n 4. \\<And>a b c na m.\n       \\<lbrakk>lookupDef g n v = (a, b, c);\n        \\<lbrakk>v \\<in> defs g b; c = SimpleDef\\<rbrakk>\n        \\<Longrightarrow> P b;\n        \\<lbrakk>v \\<notin> defs g b;\n         length (predecessors g b) \\<noteq> Suc 0; c = PhiDef\\<rbrakk>\n        \\<Longrightarrow> P b;\n        \\<And>n m.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n            m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v;\n            P m\\<rbrakk>\n           \\<Longrightarrow> P n;\n        val = (a, b, c); ?v8 a b c \\<notin> defs g na;\n        predecessors g na = [m]; m \\<in> set (\\<alpha>n g);\n        lookupDef g na (?v8 a b c) = lookupDef g m (?v8 a b c); P m\\<rbrakk>\n       \\<Longrightarrow> P na", "by auto"], ["", "lemma defs'_finite: \"finite (defs' g n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (defs' g n)", "unfolding defs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ((\\<lambda>v. (v, n, SimpleDef)) ` defs g n)", "using defs_finite"], ["proof (prove)\nusing this:\n  finite (defs ?g ?n)\n\ngoal (1 subgoal):\n 1. finite ((\\<lambda>v. (v, n, SimpleDef)) ` defs g n)", "by simp"], ["", "lemma uses'_finite: \"finite (uses' g n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (uses' g n)", "unfolding uses'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (lookupDef g n ` uses g n)", "using uses_finite"], ["proof (prove)\nusing this:\n  finite (uses ?g ?n)\n\ngoal (1 subgoal):\n 1. finite (lookupDef g n ` uses g n)", "by simp"], ["", "lemma defs'_uses'_disjoint: \"n \\<in> set (\\<alpha>n g) \\<Longrightarrow> defs' g n \\<inter> uses' g n = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n    defs' g n \\<inter> uses' g n = {}", "unfolding defs'_def uses'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n    (\\<lambda>v. (v, n, SimpleDef)) ` defs g n \\<inter>\n    lookupDef g n ` uses g n =\n    {}", "using defs_uses_disjoint"], ["proof (prove)\nusing this:\n  ?n \\<in> set (\\<alpha>n ?g) \\<Longrightarrow>\n  defs ?g ?n \\<inter> uses ?g ?n = {}\n\ngoal (1 subgoal):\n 1. n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n    (\\<lambda>v. (v, n, SimpleDef)) ` defs g n \\<inter>\n    lookupDef g n ` uses g n =\n    {}", "by (auto dest:lookupDef_looksup')"], ["", "lemma allDefs'_disjoint: \" n \\<in> set (\\<alpha>n g) \\<Longrightarrow> m \\<in> set (\\<alpha>n g) \\<Longrightarrow> n \\<noteq> m\n    \\<Longrightarrow> (defs' g n \\<union> {v. (n, v) \\<in> dom (phis' g)}) \\<inter> (defs' g m \\<union> {v. (m, v) \\<in> dom (phis' g)}) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n     n \\<noteq> m\\<rbrakk>\n    \\<Longrightarrow> (defs' g n \\<union>\n                       {v. (n, v) \\<in> dom (phis' g)}) \\<inter>\n                      (defs' g m \\<union> {v. (m, v) \\<in> dom (phis' g)}) =\n                      {}", "by (auto split:if_split_asm simp: defs'_def phis'_def)"], ["", "lemma phiDefNodes_aux_finite: \"finite (phiDefNodes_aux g v un m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (phiDefNodes_aux g v un m)", "proof (induction un arbitrary:m rule:removeAll_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs m.\n       (\\<And>x m.\n           x \\<in> set xs \\<Longrightarrow>\n           finite\n            (phiDefNodes_aux g v (removeAll x xs) m)) \\<Longrightarrow>\n       finite (phiDefNodes_aux g v xs m)", "case (1 un)"], ["proof (state)\nthis:\n  ?x1 \\<in> set un \\<Longrightarrow>\n  finite (phiDefNodes_aux g v (removeAll ?x1 un) ?m1)\n\ngoal (1 subgoal):\n 1. \\<And>xs m.\n       (\\<And>x m.\n           x \\<in> set xs \\<Longrightarrow>\n           finite\n            (phiDefNodes_aux g v (removeAll x xs) m)) \\<Longrightarrow>\n       finite (phiDefNodes_aux g v xs m)", "thus ?case"], ["proof (prove)\nusing this:\n  ?x1 \\<in> set un \\<Longrightarrow>\n  finite (phiDefNodes_aux g v (removeAll ?x1 un) ?m1)\n\ngoal (1 subgoal):\n 1. finite (phiDefNodes_aux g v un m)", "by (cases un v g m rule:phiDefNodes_aux_cases) auto"], ["proof (state)\nthis:\n  finite (phiDefNodes_aux g v un m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma phis'_finite: \"finite (dom (phis' g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom (phis' g))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (dom (phis' g))", "let ?super = \"set (\\<alpha>n g) \\<times> vars g \\<times> set (\\<alpha>n g) \\<times> {PhiDef}\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite (dom (phis' g))", "have \"finite ?super\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (set (\\<alpha>n g) \\<times>\n      vars g \\<times> set (\\<alpha>n g) \\<times> {PhiDef})", "by auto"], ["proof (state)\nthis:\n  finite\n   (set (\\<alpha>n g) \\<times>\n    vars g \\<times> set (\\<alpha>n g) \\<times> {PhiDef})\n\ngoal (1 subgoal):\n 1. finite (dom (phis' g))", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite\n   (set (\\<alpha>n g) \\<times>\n    vars g \\<times> set (\\<alpha>n g) \\<times> {PhiDef})\n\ngoal (1 subgoal):\n 1. finite (dom (phis' g))", "by - (rule finite_subset[of _ ?super], auto simp:phis'_def split:if_split_asm)"], ["proof (state)\nthis:\n  finite (dom (phis' g))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma phis'_wf: \"phis' g (n, v) = Some args \\<Longrightarrow> length (predecessors g n) = length args\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phis' g (n, v) = Some args \\<Longrightarrow>\n    length (predecessors g n) = length args", "unfolding phis'_def predecessors_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (n, v) of\n     (n, v, m, def) \\<Rightarrow>\n       if m = n \\<and>\n          n \\<in> phiDefNodes g v \\<and> v \\<in> vars g \\<and> def = PhiDef\n       then Some\n             (map (\\<lambda>m. lookupDef g m v) (map getFrom (inEdges g n)))\n       else None) =\n    Some args \\<Longrightarrow>\n    length (map getFrom (inEdges g n)) = length args", "by (auto split:prod.splits if_split_asm)"], ["", "lemma simpleDefs_phiDefs_disjoint: \"n \\<in> set (\\<alpha>n g) \\<Longrightarrow> defs' g n \\<inter> {v. (n, v) \\<in> dom (phis' g)} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n    defs' g n \\<inter> {v. (n, v) \\<in> dom (phis' g)} = {}", "unfolding phis'_def defs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n    (\\<lambda>v. (v, n, SimpleDef)) ` defs g n \\<inter>\n    {v. (n, v)\n        \\<in> dom (\\<lambda>(n, v, m, def).\n                      if m = n \\<and>\n                         n \\<in> phiDefNodes g v \\<and>\n                         v \\<in> vars g \\<and> def = PhiDef\n                      then Some\n                            (map (\\<lambda>m. lookupDef g m v)\n                              (predecessors g n))\n                      else None)} =\n    {}", "by auto"], ["", "lemma oldDefs_correct: \"defs g n = var g ` defs' g n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. defs g n = var g ` defs' g n", "by (simp add:defs'_def image_image)"], ["", "lemma oldUses_correct: \"n \\<in> set (\\<alpha>n g) \\<Longrightarrow> uses g n = var g ` uses' g n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> set (\\<alpha>n g) \\<Longrightarrow> uses g n = var g ` uses' g n", "by (simp add:uses'_def image_image)"], ["", "lemmas base_SSA_defs = CFG_SSA_base.CFG_SSA_defs"], ["", "sublocale braun_ssa: CFG_SSA \\<alpha>e \\<alpha>n invar inEdges' Entry defs' uses' phis'"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_SSA \\<alpha>e \\<alpha>n invar inEdges' Entry defs' uses' phis'", "apply unfold_locales"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs' g n \\<inter> uses' g n = {}\n 2. \\<And>g n. finite (defs' g n)\n 3. \\<And>v g n.\n       v \\<in> uses' g n \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 4. \\<And>g n. finite (uses' g n)\n 5. \\<And>g. invar g\n 6. \\<And>g. finite (dom (phis' g))\n 7. \\<And>g n v vs.\n       phis' g (n, v) = Some vs \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 8. \\<And>g n v args.\n       phis' g (n, v) = Some args \\<Longrightarrow>\n       length (predecessors g n) = length args\n 9. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs' g n \\<inter> CFG_SSA_base.phiDefs phis' g n = {}\n 10. \\<And>n g m.\n        \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n         n \\<noteq> m\\<rbrakk>\n        \\<Longrightarrow> CFG_SSA_base.allDefs defs' phis' g n \\<inter>\n                          CFG_SSA_base.allDefs defs' phis' g m =\n                          {}", "apply (rule defs'_uses'_disjoint, simp_all)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>g n. finite (defs' g n)\n 2. \\<And>v g n.\n       v \\<in> uses' g n \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 3. \\<And>g n. finite (uses' g n)\n 4. \\<And>g. invar g\n 5. \\<And>g. finite (dom (phis' g))\n 6. \\<And>g n v vs.\n       phis' g (n, v) = Some vs \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 7. \\<And>g n v args.\n       phis' g (n, v) = Some args \\<Longrightarrow>\n       length (predecessors g n) = length args\n 8. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs' g n \\<inter> CFG_SSA_base.phiDefs phis' g n = {}\n 9. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> CFG_SSA_base.allDefs defs' phis' g n \\<inter>\n                         CFG_SSA_base.allDefs defs' phis' g m =\n                         {}", "apply (rule defs'_finite)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>v g n.\n       v \\<in> uses' g n \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 2. \\<And>g n. finite (uses' g n)\n 3. \\<And>g. invar g\n 4. \\<And>g. finite (dom (phis' g))\n 5. \\<And>g n v vs.\n       phis' g (n, v) = Some vs \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 6. \\<And>g n v args.\n       phis' g (n, v) = Some args \\<Longrightarrow>\n       length (predecessors g n) = length args\n 7. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs' g n \\<inter> CFG_SSA_base.phiDefs phis' g n = {}\n 8. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> CFG_SSA_base.allDefs defs' phis' g n \\<inter>\n                         CFG_SSA_base.allDefs defs' phis' g m =\n                         {}", "apply (auto simp add: uses'_def uses_in_\\<alpha>n)[1]"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>g n. finite (uses' g n)\n 2. \\<And>g. invar g\n 3. \\<And>g. finite (dom (phis' g))\n 4. \\<And>g n v vs.\n       phis' g (n, v) = Some vs \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 5. \\<And>g n v args.\n       phis' g (n, v) = Some args \\<Longrightarrow>\n       length (predecessors g n) = length args\n 6. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs' g n \\<inter> CFG_SSA_base.phiDefs phis' g n = {}\n 7. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> CFG_SSA_base.allDefs defs' phis' g n \\<inter>\n                         CFG_SSA_base.allDefs defs' phis' g m =\n                         {}", "apply (rule uses'_finite)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>g. invar g\n 2. \\<And>g. finite (dom (phis' g))\n 3. \\<And>g n v vs.\n       phis' g (n, v) = Some vs \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 4. \\<And>g n v args.\n       phis' g (n, v) = Some args \\<Longrightarrow>\n       length (predecessors g n) = length args\n 5. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs' g n \\<inter> CFG_SSA_base.phiDefs phis' g n = {}\n 6. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> CFG_SSA_base.allDefs defs' phis' g n \\<inter>\n                         CFG_SSA_base.allDefs defs' phis' g m =\n                         {}", "apply (rule invar)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>g. finite (dom (phis' g))\n 2. \\<And>g n v vs.\n       phis' g (n, v) = Some vs \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 3. \\<And>g n v args.\n       phis' g (n, v) = Some args \\<Longrightarrow>\n       length (predecessors g n) = length args\n 4. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs' g n \\<inter> CFG_SSA_base.phiDefs phis' g n = {}\n 5. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> CFG_SSA_base.allDefs defs' phis' g n \\<inter>\n                         CFG_SSA_base.allDefs defs' phis' g m =\n                         {}", "apply (rule phis'_finite)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>g n v vs.\n       phis' g (n, v) = Some vs \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 2. \\<And>g n v args.\n       phis' g (n, v) = Some args \\<Longrightarrow>\n       length (predecessors g n) = length args\n 3. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs' g n \\<inter> CFG_SSA_base.phiDefs phis' g n = {}\n 4. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> CFG_SSA_base.allDefs defs' phis' g n \\<inter>\n                         CFG_SSA_base.allDefs defs' phis' g m =\n                         {}", "apply (auto simp: phis'_def split: if_split_asm)[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>g n v args.\n       phis' g (n, v) = Some args \\<Longrightarrow>\n       length (predecessors g n) = length args\n 2. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs' g n \\<inter> CFG_SSA_base.phiDefs phis' g n = {}\n 3. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> CFG_SSA_base.allDefs defs' phis' g n \\<inter>\n                         CFG_SSA_base.allDefs defs' phis' g m =\n                         {}", "apply (rule phis'_wf, simp_all add: base_SSA_defs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs' g n \\<inter> {v. (n, v) \\<in> dom (phis' g)} = {}\n 2. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> (defs' g n \\<union>\n                          {v. (n, v) \\<in> dom (phis' g)}) \\<inter>\n                         (defs' g m \\<union>\n                          {v. (m, v) \\<in> dom (phis' g)}) =\n                         {}", "apply (erule simpleDefs_phiDefs_disjoint)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> (defs' g n \\<union>\n                          {v. (n, v) \\<in> dom (phis' g)}) \\<inter>\n                         (defs' g m \\<union>\n                          {v. (m, v) \\<in> dom (phis' g)}) =\n                         {}", "apply (erule allDefs'_disjoint, simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "declare (in CFG) invar[rule del]"], ["", "declare (in CFG) Entry_no_predecessor[simp del]"], ["", "context CFG_Construct\nbegin"], ["", "declare invar[intro!]"], ["", "declare Entry_no_predecessor[simp]"], ["", "lemma no_disjoint_cycle[simp]:\n    assumes \"g \\<turnstile> n-ns\\<rightarrow>n\" \"distinct ns\"\n    shows \"ns = [n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ns = [n]", "using assms"], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<rightarrow>n\n  distinct ns\n\ngoal (1 subgoal):\n 1. ns = [n]", "unfolding path2_def"], ["proof (prove)\nusing this:\n  local.path g ns \\<and> n = hd ns \\<and> n = last ns\n  distinct ns\n\ngoal (1 subgoal):\n 1. ns = [n]", "by (metis distinct.simps(2) hd_Cons_tl last_in_set last_tl path_not_Nil)"], ["", "lemma lookupDef_path:\n    assumes \"m \\<in> set (\\<alpha>n g)\"\n    obtains ns where  \"g \\<turnstile> lookupDefNode g m v-ns\\<rightarrow>m\" \"(\\<forall>x \\<in> set (tl ns). v \\<notin> defs g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>g \\<turnstile> lookupDefNode g m v-ns\\<rightarrow>m;\n         \\<forall>x\\<in>set (tl ns). v \\<notin> defs g x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       g \\<turnstile> lookupDefNode g m v-ns\\<rightarrow>m \\<and>\n       (\\<forall>x\\<in>set (tl ns). v \\<notin> defs g x)", "using assms"], ["proof (prove)\nusing this:\n  m \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       g \\<turnstile> lookupDefNode g m v-ns\\<rightarrow>m \\<and>\n       (\\<forall>x\\<in>set (tl ns). v \\<notin> defs g x)", "proof (induction rule:lookupDef_induct[of m g v])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> defs g n;\n        lookupDef g n v = (v, n, SimpleDef)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            g \\<turnstile> lookupDefNode g n\n      v-ns\\<rightarrow>n \\<and>\n                            (\\<forall>x\\<in>set (tl ns).\n                                v \\<notin> defs g x)\n 2. \\<And>n.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> 1;\n        lookupDef g n v = (v, n, PhiDef)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            g \\<turnstile> lookupDefNode g n\n      v-ns\\<rightarrow>n \\<and>\n                            (\\<forall>x\\<in>set (tl ns).\n                                v \\<notin> defs g x)\n 3. \\<And>n m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v;\n        \\<exists>ns.\n           g \\<turnstile> lookupDefNode g m v-ns\\<rightarrow>m \\<and>\n           (\\<forall>x\\<in>set (tl ns). v \\<notin> defs g x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            g \\<turnstile> lookupDefNode g n\n      v-ns\\<rightarrow>n \\<and>\n                            (\\<forall>x\\<in>set (tl ns).\n                                v \\<notin> defs g x)", "case (SimpleDef n)"], ["proof (state)\nthis:\n  n \\<in> set (\\<alpha>n g)\n  v \\<in> defs g n\n  lookupDef g n v = (v, n, SimpleDef)\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> defs g n;\n        lookupDef g n v = (v, n, SimpleDef)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            g \\<turnstile> lookupDefNode g n\n      v-ns\\<rightarrow>n \\<and>\n                            (\\<forall>x\\<in>set (tl ns).\n                                v \\<notin> defs g x)\n 2. \\<And>n.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> 1;\n        lookupDef g n v = (v, n, PhiDef)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            g \\<turnstile> lookupDefNode g n\n      v-ns\\<rightarrow>n \\<and>\n                            (\\<forall>x\\<in>set (tl ns).\n                                v \\<notin> defs g x)\n 3. \\<And>n m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v;\n        \\<exists>ns.\n           g \\<turnstile> lookupDefNode g m v-ns\\<rightarrow>m \\<and>\n           (\\<forall>x\\<in>set (tl ns). v \\<notin> defs g x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            g \\<turnstile> lookupDefNode g n\n      v-ns\\<rightarrow>n \\<and>\n                            (\\<forall>x\\<in>set (tl ns).\n                                v \\<notin> defs g x)", "thus ?case"], ["proof (prove)\nusing this:\n  n \\<in> set (\\<alpha>n g)\n  v \\<in> defs g n\n  lookupDef g n v = (v, n, SimpleDef)\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       g \\<turnstile> lookupDefNode g n v-ns\\<rightarrow>n \\<and>\n       (\\<forall>x\\<in>set (tl ns). v \\<notin> defs g x)", "by -(rule exI[of _ \"[n]\"], auto)"], ["proof (state)\nthis:\n  \\<exists>ns.\n     g \\<turnstile> lookupDefNode g n v-ns\\<rightarrow>n \\<and>\n     (\\<forall>x\\<in>set (tl ns). v \\<notin> defs g x)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> 1;\n        lookupDef g n v = (v, n, PhiDef)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            g \\<turnstile> lookupDefNode g n\n      v-ns\\<rightarrow>n \\<and>\n                            (\\<forall>x\\<in>set (tl ns).\n                                v \\<notin> defs g x)\n 2. \\<And>n m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v;\n        \\<exists>ns.\n           g \\<turnstile> lookupDefNode g m v-ns\\<rightarrow>m \\<and>\n           (\\<forall>x\\<in>set (tl ns). v \\<notin> defs g x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            g \\<turnstile> lookupDefNode g n\n      v-ns\\<rightarrow>n \\<and>\n                            (\\<forall>x\\<in>set (tl ns).\n                                v \\<notin> defs g x)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> 1;\n        lookupDef g n v = (v, n, PhiDef)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            g \\<turnstile> lookupDefNode g n\n      v-ns\\<rightarrow>n \\<and>\n                            (\\<forall>x\\<in>set (tl ns).\n                                v \\<notin> defs g x)\n 2. \\<And>n m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v;\n        \\<exists>ns.\n           g \\<turnstile> lookupDefNode g m v-ns\\<rightarrow>m \\<and>\n           (\\<forall>x\\<in>set (tl ns). v \\<notin> defs g x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            g \\<turnstile> lookupDefNode g n\n      v-ns\\<rightarrow>n \\<and>\n                            (\\<forall>x\\<in>set (tl ns).\n                                v \\<notin> defs g x)", "case (PhiDef n)"], ["proof (state)\nthis:\n  n \\<in> set (\\<alpha>n g)\n  v \\<notin> defs g n\n  length (predecessors g n) \\<noteq> 1\n  lookupDef g n v = (v, n, PhiDef)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> 1;\n        lookupDef g n v = (v, n, PhiDef)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            g \\<turnstile> lookupDefNode g n\n      v-ns\\<rightarrow>n \\<and>\n                            (\\<forall>x\\<in>set (tl ns).\n                                v \\<notin> defs g x)\n 2. \\<And>n m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v;\n        \\<exists>ns.\n           g \\<turnstile> lookupDefNode g m v-ns\\<rightarrow>m \\<and>\n           (\\<forall>x\\<in>set (tl ns). v \\<notin> defs g x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            g \\<turnstile> lookupDefNode g n\n      v-ns\\<rightarrow>n \\<and>\n                            (\\<forall>x\\<in>set (tl ns).\n                                v \\<notin> defs g x)", "thus ?case"], ["proof (prove)\nusing this:\n  n \\<in> set (\\<alpha>n g)\n  v \\<notin> defs g n\n  length (predecessors g n) \\<noteq> 1\n  lookupDef g n v = (v, n, PhiDef)\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       g \\<turnstile> lookupDefNode g n v-ns\\<rightarrow>n \\<and>\n       (\\<forall>x\\<in>set (tl ns). v \\<notin> defs g x)", "by -(rule exI[of _ \"[n]\"], auto)"], ["proof (state)\nthis:\n  \\<exists>ns.\n     g \\<turnstile> lookupDefNode g n v-ns\\<rightarrow>n \\<and>\n     (\\<forall>x\\<in>set (tl ns). v \\<notin> defs g x)\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v;\n        \\<exists>ns.\n           g \\<turnstile> lookupDefNode g m v-ns\\<rightarrow>m \\<and>\n           (\\<forall>x\\<in>set (tl ns). v \\<notin> defs g x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            g \\<turnstile> lookupDefNode g n\n      v-ns\\<rightarrow>n \\<and>\n                            (\\<forall>x\\<in>set (tl ns).\n                                v \\<notin> defs g x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v;\n        \\<exists>ns.\n           g \\<turnstile> lookupDefNode g m v-ns\\<rightarrow>m \\<and>\n           (\\<forall>x\\<in>set (tl ns). v \\<notin> defs g x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            g \\<turnstile> lookupDefNode g n\n      v-ns\\<rightarrow>n \\<and>\n                            (\\<forall>x\\<in>set (tl ns).\n                                v \\<notin> defs g x)", "case (rec m m')"], ["proof (state)\nthis:\n  v \\<notin> defs g m\n  predecessors g m = [m']\n  m' \\<in> set (\\<alpha>n g)\n  lookupDef g m v = lookupDef g m' v\n  \\<exists>ns.\n     g \\<turnstile> lookupDefNode g m' v-ns\\<rightarrow>m' \\<and>\n     (\\<forall>x\\<in>set (tl ns). v \\<notin> defs g x)\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v;\n        \\<exists>ns.\n           g \\<turnstile> lookupDefNode g m v-ns\\<rightarrow>m \\<and>\n           (\\<forall>x\\<in>set (tl ns). v \\<notin> defs g x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            g \\<turnstile> lookupDefNode g n\n      v-ns\\<rightarrow>n \\<and>\n                            (\\<forall>x\\<in>set (tl ns).\n                                v \\<notin> defs g x)", "then"], ["proof (chain)\npicking this:\n  v \\<notin> defs g m\n  predecessors g m = [m']\n  m' \\<in> set (\\<alpha>n g)\n  lookupDef g m v = lookupDef g m' v\n  \\<exists>ns.\n     g \\<turnstile> lookupDefNode g m' v-ns\\<rightarrow>m' \\<and>\n     (\\<forall>x\\<in>set (tl ns). v \\<notin> defs g x)", "obtain ns where \"g \\<turnstile> lookupDefNode g m v-ns\\<rightarrow>m'\" \"\\<forall>x \\<in> set (tl ns). v \\<notin> defs g x\""], ["proof (prove)\nusing this:\n  v \\<notin> defs g m\n  predecessors g m = [m']\n  m' \\<in> set (\\<alpha>n g)\n  lookupDef g m v = lookupDef g m' v\n  \\<exists>ns.\n     g \\<turnstile> lookupDefNode g m' v-ns\\<rightarrow>m' \\<and>\n     (\\<forall>x\\<in>set (tl ns). v \\<notin> defs g x)\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>g \\<turnstile> lookupDefNode g m v-ns\\<rightarrow>m';\n         \\<forall>x\\<in>set (tl ns). v \\<notin> defs g x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  g \\<turnstile> lookupDefNode g m v-ns\\<rightarrow>m'\n  \\<forall>x\\<in>set (tl ns). v \\<notin> defs g x\n\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v;\n        \\<exists>ns.\n           g \\<turnstile> lookupDefNode g m v-ns\\<rightarrow>m \\<and>\n           (\\<forall>x\\<in>set (tl ns). v \\<notin> defs g x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ns.\n                            g \\<turnstile> lookupDefNode g n\n      v-ns\\<rightarrow>n \\<and>\n                            (\\<forall>x\\<in>set (tl ns).\n                                v \\<notin> defs g x)", "with rec.hyps(1,2)"], ["proof (chain)\npicking this:\n  v \\<notin> defs g m\n  predecessors g m = [m']\n  g \\<turnstile> lookupDefNode g m v-ns\\<rightarrow>m'\n  \\<forall>x\\<in>set (tl ns). v \\<notin> defs g x", "show ?case"], ["proof (prove)\nusing this:\n  v \\<notin> defs g m\n  predecessors g m = [m']\n  g \\<turnstile> lookupDefNode g m v-ns\\<rightarrow>m'\n  \\<forall>x\\<in>set (tl ns). v \\<notin> defs g x\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       g \\<turnstile> lookupDefNode g m v-ns\\<rightarrow>m \\<and>\n       (\\<forall>x\\<in>set (tl ns). v \\<notin> defs g x)", "by - (rule exI[of _ \"ns@[m]\"], auto simp: path2_not_Nil)"], ["proof (state)\nthis:\n  \\<exists>ns.\n     g \\<turnstile> lookupDefNode g m v-ns\\<rightarrow>m \\<and>\n     (\\<forall>x\\<in>set (tl ns). v \\<notin> defs g x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookupDef_path_conventional:\n    assumes \"g \\<turnstile> n-ns\\<rightarrow>m\" \"n = lookupDefNode g m v\" \"n \\<notin> set (tl ns)\" \"x \\<in> set (tl ns)\" \"v' \\<in> braun_ssa.allDefs g x\"\n    shows \"var g v' \\<noteq> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var g v' \\<noteq> v", "using assms(1-4)"], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  n = lookupDefNode g m v\n  n \\<notin> set (tl ns)\n  x \\<in> set (tl ns)\n\ngoal (1 subgoal):\n 1. var g v' \\<noteq> v", "proof (induction rule:path2_rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<in> set (\\<alpha>n g); n = lookupDefNode g n v;\n     n \\<notin> set (tl [n]); x \\<in> set (tl [n])\\<rbrakk>\n    \\<Longrightarrow> var g v' \\<noteq> v\n 2. \\<And>ns m' m.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m';\n        \\<lbrakk>n = lookupDefNode g m' v; n \\<notin> set (tl ns);\n         x \\<in> set (tl ns)\\<rbrakk>\n        \\<Longrightarrow> var g v' \\<noteq> v;\n        m' \\<in> set (predecessors g m); n = lookupDefNode g m v;\n        n \\<notin> set (tl (ns @ [m])); x \\<in> set (tl (ns @ [m]))\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> v", "case empty"], ["proof (state)\nthis:\n  n \\<in> set (\\<alpha>n g)\n  n = lookupDefNode g n v\n  n \\<notin> set (tl [n])\n  x \\<in> set (tl [n])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<in> set (\\<alpha>n g); n = lookupDefNode g n v;\n     n \\<notin> set (tl [n]); x \\<in> set (tl [n])\\<rbrakk>\n    \\<Longrightarrow> var g v' \\<noteq> v\n 2. \\<And>ns m' m.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m';\n        \\<lbrakk>n = lookupDefNode g m' v; n \\<notin> set (tl ns);\n         x \\<in> set (tl ns)\\<rbrakk>\n        \\<Longrightarrow> var g v' \\<noteq> v;\n        m' \\<in> set (predecessors g m); n = lookupDefNode g m v;\n        n \\<notin> set (tl (ns @ [m])); x \\<in> set (tl (ns @ [m]))\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> v", "from empty.prems(3)"], ["proof (chain)\npicking this:\n  x \\<in> set (tl [n])", "have False"], ["proof (prove)\nusing this:\n  x \\<in> set (tl [n])\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<in> set (\\<alpha>n g); n = lookupDefNode g n v;\n     n \\<notin> set (tl [n]); x \\<in> set (tl [n])\\<rbrakk>\n    \\<Longrightarrow> var g v' \\<noteq> v\n 2. \\<And>ns m' m.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m';\n        \\<lbrakk>n = lookupDefNode g m' v; n \\<notin> set (tl ns);\n         x \\<in> set (tl ns)\\<rbrakk>\n        \\<Longrightarrow> var g v' \\<noteq> v;\n        m' \\<in> set (predecessors g m); n = lookupDefNode g m v;\n        n \\<notin> set (tl (ns @ [m])); x \\<in> set (tl (ns @ [m]))\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> v", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. var g v' \\<noteq> v", ".."], ["proof (state)\nthis:\n  var g v' \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<And>ns m' m.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m';\n        \\<lbrakk>n = lookupDefNode g m' v; n \\<notin> set (tl ns);\n         x \\<in> set (tl ns)\\<rbrakk>\n        \\<Longrightarrow> var g v' \\<noteq> v;\n        m' \\<in> set (predecessors g m); n = lookupDefNode g m v;\n        n \\<notin> set (tl (ns @ [m])); x \\<in> set (tl (ns @ [m]))\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ns m' m.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m';\n        \\<lbrakk>n = lookupDefNode g m' v; n \\<notin> set (tl ns);\n         x \\<in> set (tl ns)\\<rbrakk>\n        \\<Longrightarrow> var g v' \\<noteq> v;\n        m' \\<in> set (predecessors g m); n = lookupDefNode g m v;\n        n \\<notin> set (tl (ns @ [m])); x \\<in> set (tl (ns @ [m]))\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> v", "case (snoc ns m m')"], ["proof (state)\nthis:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  m \\<in> set (predecessors g m')\n  \\<lbrakk>n = lookupDefNode g m v; n \\<notin> set (tl ns);\n   x \\<in> set (tl ns)\\<rbrakk>\n  \\<Longrightarrow> var g v' \\<noteq> v\n  n = lookupDefNode g m' v\n  n \\<notin> set (tl (ns @ [m']))\n  x \\<in> set (tl (ns @ [m']))\n\ngoal (1 subgoal):\n 1. \\<And>ns m' m.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m';\n        \\<lbrakk>n = lookupDefNode g m' v; n \\<notin> set (tl ns);\n         x \\<in> set (tl ns)\\<rbrakk>\n        \\<Longrightarrow> var g v' \\<noteq> v;\n        m' \\<in> set (predecessors g m); n = lookupDefNode g m v;\n        n \\<notin> set (tl (ns @ [m])); x \\<in> set (tl (ns @ [m]))\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> v", "note snoc.prems(1)[simp]"], ["proof (state)\nthis:\n  n = lookupDefNode g m' v\n\ngoal (1 subgoal):\n 1. \\<And>ns m' m.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m';\n        \\<lbrakk>n = lookupDefNode g m' v; n \\<notin> set (tl ns);\n         x \\<in> set (tl ns)\\<rbrakk>\n        \\<Longrightarrow> var g v' \\<noteq> v;\n        m' \\<in> set (predecessors g m); n = lookupDefNode g m v;\n        n \\<notin> set (tl (ns @ [m])); x \\<in> set (tl (ns @ [m]))\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> v", "from snoc.hyps"], ["proof (chain)\npicking this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  m \\<in> set (predecessors g m')", "have p: \"g \\<turnstile> n-ns@[m']\\<rightarrow>m'\""], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  m \\<in> set (predecessors g m')\n\ngoal (1 subgoal):\n 1. g \\<turnstile> n-ns @ [m']\\<rightarrow>m'", "by auto"], ["proof (state)\nthis:\n  g \\<turnstile> n-ns @ [m']\\<rightarrow>m'\n\ngoal (1 subgoal):\n 1. \\<And>ns m' m.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m';\n        \\<lbrakk>n = lookupDefNode g m' v; n \\<notin> set (tl ns);\n         x \\<in> set (tl ns)\\<rbrakk>\n        \\<Longrightarrow> var g v' \\<noteq> v;\n        m' \\<in> set (predecessors g m); n = lookupDefNode g m v;\n        n \\<notin> set (tl (ns @ [m])); x \\<in> set (tl (ns @ [m]))\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> v", "hence \"m' \\<in> set (\\<alpha>n g)\""], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns @ [m']\\<rightarrow>m'\n\ngoal (1 subgoal):\n 1. m' \\<in> set (\\<alpha>n g)", "by auto"], ["proof (state)\nthis:\n  m' \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. \\<And>ns m' m.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m';\n        \\<lbrakk>n = lookupDefNode g m' v; n \\<notin> set (tl ns);\n         x \\<in> set (tl ns)\\<rbrakk>\n        \\<Longrightarrow> var g v' \\<noteq> v;\n        m' \\<in> set (predecessors g m); n = lookupDefNode g m v;\n        n \\<notin> set (tl (ns @ [m])); x \\<in> set (tl (ns @ [m]))\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> v", "thus ?thesis"], ["proof (prove)\nusing this:\n  m' \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. var g v' \\<noteq> v", "proof (cases rule:lookupDef_cases'[of m' g v])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>v \\<in> defs g m'; lookupDefNode g m' v = m';\n     defKind (lookupDef g m' v) = SimpleDef\\<rbrakk>\n    \\<Longrightarrow> var g v' \\<noteq> v\n 2. \\<lbrakk>v \\<notin> defs g m'; length (predecessors g m') \\<noteq> 1;\n     lookupDefNode g m' v = m'; defKind (lookupDef g m' v) = PhiDef\\<rbrakk>\n    \\<Longrightarrow> var g v' \\<noteq> v\n 3. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g m'; predecessors g m' = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g m' v = lookupDef g m v\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> v", "case SimpleDef"], ["proof (state)\nthis:\n  v \\<in> defs g m'\n  lookupDefNode g m' v = m'\n  defKind (lookupDef g m' v) = SimpleDef\n\ngoal (3 subgoals):\n 1. \\<lbrakk>v \\<in> defs g m'; lookupDefNode g m' v = m';\n     defKind (lookupDef g m' v) = SimpleDef\\<rbrakk>\n    \\<Longrightarrow> var g v' \\<noteq> v\n 2. \\<lbrakk>v \\<notin> defs g m'; length (predecessors g m') \\<noteq> 1;\n     lookupDefNode g m' v = m'; defKind (lookupDef g m' v) = PhiDef\\<rbrakk>\n    \\<Longrightarrow> var g v' \\<noteq> v\n 3. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g m'; predecessors g m' = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g m' v = lookupDef g m v\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> v", "with snoc.prems(2,3)"], ["proof (chain)\npicking this:\n  n \\<notin> set (tl (ns @ [m']))\n  x \\<in> set (tl (ns @ [m']))\n  v \\<in> defs g m'\n  lookupDefNode g m' v = m'\n  defKind (lookupDef g m' v) = SimpleDef", "have False"], ["proof (prove)\nusing this:\n  n \\<notin> set (tl (ns @ [m']))\n  x \\<in> set (tl (ns @ [m']))\n  v \\<in> defs g m'\n  lookupDefNode g m' v = m'\n  defKind (lookupDef g m' v) = SimpleDef\n\ngoal (1 subgoal):\n 1. False", "by (simp add:tl_append split:list.split_asm)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<lbrakk>v \\<in> defs g m'; lookupDefNode g m' v = m';\n     defKind (lookupDef g m' v) = SimpleDef\\<rbrakk>\n    \\<Longrightarrow> var g v' \\<noteq> v\n 2. \\<lbrakk>v \\<notin> defs g m'; length (predecessors g m') \\<noteq> 1;\n     lookupDefNode g m' v = m'; defKind (lookupDef g m' v) = PhiDef\\<rbrakk>\n    \\<Longrightarrow> var g v' \\<noteq> v\n 3. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g m'; predecessors g m' = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g m' v = lookupDef g m v\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> v", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. var g v' \\<noteq> v", ".."], ["proof (state)\nthis:\n  var g v' \\<noteq> v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<notin> defs g m'; length (predecessors g m') \\<noteq> 1;\n     lookupDefNode g m' v = m'; defKind (lookupDef g m' v) = PhiDef\\<rbrakk>\n    \\<Longrightarrow> var g v' \\<noteq> v\n 2. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g m'; predecessors g m' = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g m' v = lookupDef g m v\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> v", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<notin> defs g m'; length (predecessors g m') \\<noteq> 1;\n     lookupDefNode g m' v = m'; defKind (lookupDef g m' v) = PhiDef\\<rbrakk>\n    \\<Longrightarrow> var g v' \\<noteq> v\n 2. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g m'; predecessors g m' = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g m' v = lookupDef g m v\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> v", "case PhiDef"], ["proof (state)\nthis:\n  v \\<notin> defs g m'\n  length (predecessors g m') \\<noteq> 1\n  lookupDefNode g m' v = m'\n  defKind (lookupDef g m' v) = PhiDef\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<notin> defs g m'; length (predecessors g m') \\<noteq> 1;\n     lookupDefNode g m' v = m'; defKind (lookupDef g m' v) = PhiDef\\<rbrakk>\n    \\<Longrightarrow> var g v' \\<noteq> v\n 2. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g m'; predecessors g m' = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g m' v = lookupDef g m v\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> v", "with snoc.prems(2,3)"], ["proof (chain)\npicking this:\n  n \\<notin> set (tl (ns @ [m']))\n  x \\<in> set (tl (ns @ [m']))\n  v \\<notin> defs g m'\n  length (predecessors g m') \\<noteq> 1\n  lookupDefNode g m' v = m'\n  defKind (lookupDef g m' v) = PhiDef", "have False"], ["proof (prove)\nusing this:\n  n \\<notin> set (tl (ns @ [m']))\n  x \\<in> set (tl (ns @ [m']))\n  v \\<notin> defs g m'\n  length (predecessors g m') \\<noteq> 1\n  lookupDefNode g m' v = m'\n  defKind (lookupDef g m' v) = PhiDef\n\ngoal (1 subgoal):\n 1. False", "by (simp add:tl_append split:list.split_asm)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<notin> defs g m'; length (predecessors g m') \\<noteq> 1;\n     lookupDefNode g m' v = m'; defKind (lookupDef g m' v) = PhiDef\\<rbrakk>\n    \\<Longrightarrow> var g v' \\<noteq> v\n 2. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g m'; predecessors g m' = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g m' v = lookupDef g m v\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> v", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. var g v' \\<noteq> v", ".."], ["proof (state)\nthis:\n  var g v' \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g m'; predecessors g m' = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g m' v = lookupDef g m v\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g m'; predecessors g m' = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g m' v = lookupDef g m v\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> v", "case (rec m\\<^sub>2)"], ["proof (state)\nthis:\n  v \\<notin> defs g m'\n  predecessors g m' = [m\\<^sub>2]\n  m\\<^sub>2 \\<in> set (\\<alpha>n g)\n  lookupDef g m' v = lookupDef g m\\<^sub>2 v\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g m'; predecessors g m' = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g m' v = lookupDef g m v\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> v", "from this(2) snoc.hyps(2)"], ["proof (chain)\npicking this:\n  predecessors g m' = [m\\<^sub>2]\n  m \\<in> set (predecessors g m')", "have[simp]: \"m\\<^sub>2 = m\""], ["proof (prove)\nusing this:\n  predecessors g m' = [m\\<^sub>2]\n  m \\<in> set (predecessors g m')\n\ngoal (1 subgoal):\n 1. m\\<^sub>2 = m", "by simp"], ["proof (state)\nthis:\n  m\\<^sub>2 = m\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g m'; predecessors g m' = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g m' v = lookupDef g m v\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. var g v' \\<noteq> v", "proof (cases \"x \\<in> set (tl ns)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> set (tl ns) \\<Longrightarrow> var g v' \\<noteq> v\n 2. x \\<notin> set (tl ns) \\<Longrightarrow> var g v' \\<noteq> v", "case True"], ["proof (state)\nthis:\n  x \\<in> set (tl ns)\n\ngoal (2 subgoals):\n 1. x \\<in> set (tl ns) \\<Longrightarrow> var g v' \\<noteq> v\n 2. x \\<notin> set (tl ns) \\<Longrightarrow> var g v' \\<noteq> v", "with rec(4) snoc.prems(2)"], ["proof (chain)\npicking this:\n  lookupDef g m' v = lookupDef g m\\<^sub>2 v\n  n \\<notin> set (tl (ns @ [m']))\n  x \\<in> set (tl ns)", "show ?thesis"], ["proof (prove)\nusing this:\n  lookupDef g m' v = lookupDef g m\\<^sub>2 v\n  n \\<notin> set (tl (ns @ [m']))\n  x \\<in> set (tl ns)\n\ngoal (1 subgoal):\n 1. var g v' \\<noteq> v", "by - (rule snoc.IH, simp_all add:tl_append split:list.split_asm)"], ["proof (state)\nthis:\n  var g v' \\<noteq> v\n\ngoal (1 subgoal):\n 1. x \\<notin> set (tl ns) \\<Longrightarrow> var g v' \\<noteq> v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> set (tl ns) \\<Longrightarrow> var g v' \\<noteq> v", "case False"], ["proof (state)\nthis:\n  x \\<notin> set (tl ns)\n\ngoal (1 subgoal):\n 1. x \\<notin> set (tl ns) \\<Longrightarrow> var g v' \\<noteq> v", "with snoc.prems(3)"], ["proof (chain)\npicking this:\n  x \\<in> set (tl (ns @ [m']))\n  x \\<notin> set (tl ns)", "have[simp]: \"x = m'\""], ["proof (prove)\nusing this:\n  x \\<in> set (tl (ns @ [m']))\n  x \\<notin> set (tl ns)\n\ngoal (1 subgoal):\n 1. x = m'", "by (simp add:tl_append split:list.split_asm)"], ["proof (state)\nthis:\n  x = m'\n\ngoal (1 subgoal):\n 1. x \\<notin> set (tl ns) \\<Longrightarrow> var g v' \\<noteq> v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. var g v' \\<noteq> v", "proof (cases \"v' \\<in> defs' g x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v' \\<in> defs' g x \\<Longrightarrow> var g v' \\<noteq> v\n 2. v' \\<notin> defs' g x \\<Longrightarrow> var g v' \\<noteq> v", "case True"], ["proof (state)\nthis:\n  v' \\<in> defs' g x\n\ngoal (2 subgoals):\n 1. v' \\<in> defs' g x \\<Longrightarrow> var g v' \\<noteq> v\n 2. v' \\<notin> defs' g x \\<Longrightarrow> var g v' \\<noteq> v", "with rec(1)"], ["proof (chain)\npicking this:\n  v \\<notin> defs g m'\n  v' \\<in> defs' g x", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<notin> defs g m'\n  v' \\<in> defs' g x\n\ngoal (1 subgoal):\n 1. var g v' \\<noteq> v", "by (auto simp add:defs'_def)"], ["proof (state)\nthis:\n  var g v' \\<noteq> v\n\ngoal (1 subgoal):\n 1. v' \\<notin> defs' g x \\<Longrightarrow> var g v' \\<noteq> v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v' \\<notin> defs' g x \\<Longrightarrow> var g v' \\<noteq> v", "case False"], ["proof (state)\nthis:\n  v' \\<notin> defs' g x\n\ngoal (1 subgoal):\n 1. v' \\<notin> defs' g x \\<Longrightarrow> var g v' \\<noteq> v", "with assms(5)"], ["proof (chain)\npicking this:\n  v' \\<in> braun_ssa.allDefs g x\n  v' \\<notin> defs' g x", "have \"v' \\<in> braun_ssa.phiDefs g m'\""], ["proof (prove)\nusing this:\n  v' \\<in> braun_ssa.allDefs g x\n  v' \\<notin> defs' g x\n\ngoal (1 subgoal):\n 1. v' \\<in> braun_ssa.phiDefs g m'", "by (simp add:braun_ssa.allDefs_def)"], ["proof (state)\nthis:\n  v' \\<in> braun_ssa.phiDefs g m'\n\ngoal (1 subgoal):\n 1. v' \\<notin> defs' g x \\<Longrightarrow> var g v' \\<noteq> v", "hence \"m' \\<in> phiDefNodes g (fst v')\""], ["proof (prove)\nusing this:\n  v' \\<in> braun_ssa.phiDefs g m'\n\ngoal (1 subgoal):\n 1. m' \\<in> phiDefNodes g (fst v')", "unfolding braun_ssa.phiDefs_def"], ["proof (prove)\nusing this:\n  v' \\<in> {v. (m', v) \\<in> dom (phis' g)}\n\ngoal (1 subgoal):\n 1. m' \\<in> phiDefNodes g (fst v')", "by (auto simp add: phis'_def split:prod.split_asm if_split_asm)"], ["proof (state)\nthis:\n  m' \\<in> phiDefNodes g (fst v')\n\ngoal (1 subgoal):\n 1. v' \\<notin> defs' g x \\<Longrightarrow> var g v' \\<noteq> v", "with rec(2)"], ["proof (chain)\npicking this:\n  predecessors g m' = [m\\<^sub>2]\n  m' \\<in> phiDefNodes g (fst v')", "show ?thesis"], ["proof (prove)\nusing this:\n  predecessors g m' = [m\\<^sub>2]\n  m' \\<in> phiDefNodes g (fst v')\n\ngoal (1 subgoal):\n 1. var g v' \\<noteq> v", "by (auto dest:phiDefNode_is_join_node)"], ["proof (state)\nthis:\n  var g v' \\<noteq> v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  var g v' \\<noteq> v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  var g v' \\<noteq> v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  var g v' \\<noteq> v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma allUse_lookupDef:\n    assumes \"v \\<in> braun_ssa.allUses g m\" \"m \\<in> set (\\<alpha>n g)\"\n    shows \"lookupDef g m (var g v) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookupDef g m (var g v) = v", "proof (cases \"v \\<in> uses' g m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> uses' g m \\<Longrightarrow> lookupDef g m (var g v) = v\n 2. v \\<notin> uses' g m \\<Longrightarrow> lookupDef g m (var g v) = v", "case True"], ["proof (state)\nthis:\n  v \\<in> uses' g m\n\ngoal (2 subgoals):\n 1. v \\<in> uses' g m \\<Longrightarrow> lookupDef g m (var g v) = v\n 2. v \\<notin> uses' g m \\<Longrightarrow> lookupDef g m (var g v) = v", "then"], ["proof (chain)\npicking this:\n  v \\<in> uses' g m", "obtain v' where v': \"v = lookupDef g m v'\" \"v' \\<in> uses g m\""], ["proof (prove)\nusing this:\n  v \\<in> uses' g m\n\ngoal (1 subgoal):\n 1. (\\<And>v'.\n        \\<lbrakk>v = lookupDef g m v'; v' \\<in> uses g m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add:uses'_def)"], ["proof (state)\nthis:\n  v = lookupDef g m v'\n  v' \\<in> uses g m\n\ngoal (2 subgoals):\n 1. v \\<in> uses' g m \\<Longrightarrow> lookupDef g m (var g v) = v\n 2. v \\<notin> uses' g m \\<Longrightarrow> lookupDef g m (var g v) = v", "with assms(2)"], ["proof (chain)\npicking this:\n  m \\<in> set (\\<alpha>n g)\n  v = lookupDef g m v'\n  v' \\<in> uses g m", "have \"var g v = v'\""], ["proof (prove)\nusing this:\n  m \\<in> set (\\<alpha>n g)\n  v = lookupDef g m v'\n  v' \\<in> uses g m\n\ngoal (1 subgoal):\n 1. var g v = v'", "unfolding var_def"], ["proof (prove)\nusing this:\n  m \\<in> set (\\<alpha>n g)\n  v = lookupDef g m v'\n  v' \\<in> uses g m\n\ngoal (1 subgoal):\n 1. fst v = v'", "by (metis lookupDef_fst)"], ["proof (state)\nthis:\n  var g v = v'\n\ngoal (2 subgoals):\n 1. v \\<in> uses' g m \\<Longrightarrow> lookupDef g m (var g v) = v\n 2. v \\<notin> uses' g m \\<Longrightarrow> lookupDef g m (var g v) = v", "with v'"], ["proof (chain)\npicking this:\n  v = lookupDef g m v'\n  v' \\<in> uses g m\n  var g v = v'", "show ?thesis"], ["proof (prove)\nusing this:\n  v = lookupDef g m v'\n  v' \\<in> uses g m\n  var g v = v'\n\ngoal (1 subgoal):\n 1. lookupDef g m (var g v) = v", "by simp"], ["proof (state)\nthis:\n  lookupDef g m (var g v) = v\n\ngoal (1 subgoal):\n 1. v \\<notin> uses' g m \\<Longrightarrow> lookupDef g m (var g v) = v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> uses' g m \\<Longrightarrow> lookupDef g m (var g v) = v", "case False"], ["proof (state)\nthis:\n  v \\<notin> uses' g m\n\ngoal (1 subgoal):\n 1. v \\<notin> uses' g m \\<Longrightarrow> lookupDef g m (var g v) = v", "with assms(1)"], ["proof (chain)\npicking this:\n  v \\<in> braun_ssa.allUses g m\n  v \\<notin> uses' g m", "obtain  m' v' vs where \"(m,v) \\<in> set (zip (predecessors g m') vs)\" \"phis' g (m', v') = Some vs\""], ["proof (prove)\nusing this:\n  v \\<in> braun_ssa.allUses g m\n  v \\<notin> uses' g m\n\ngoal (1 subgoal):\n 1. (\\<And>m' vs v'.\n        \\<lbrakk>(m, v) \\<in> set (zip (predecessors g m') vs);\n         phis' g (m', v') = Some vs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add:braun_ssa.allUses_def elim:braun_ssa.phiUsesE)"], ["proof (state)\nthis:\n  (m, v) \\<in> set (zip (predecessors g m') vs)\n  phis' g (m', v') = Some vs\n\ngoal (1 subgoal):\n 1. v \\<notin> uses' g m \\<Longrightarrow> lookupDef g m (var g v) = v", "hence l: \"v = lookupDef g m (var g v')\""], ["proof (prove)\nusing this:\n  (m, v) \\<in> set (zip (predecessors g m') vs)\n  phis' g (m', v') = Some vs\n\ngoal (1 subgoal):\n 1. v = lookupDef g m (var g v')", "by (auto simp add:phis'_def split:prod.split_asm if_split_asm elim:in_set_zip_map)"], ["proof (state)\nthis:\n  v = lookupDef g m (var g v')\n\ngoal (1 subgoal):\n 1. v \\<notin> uses' g m \\<Longrightarrow> lookupDef g m (var g v) = v", "with assms(2)"], ["proof (chain)\npicking this:\n  m \\<in> set (\\<alpha>n g)\n  v = lookupDef g m (var g v')", "have \"var g v = var g v'\""], ["proof (prove)\nusing this:\n  m \\<in> set (\\<alpha>n g)\n  v = lookupDef g m (var g v')\n\ngoal (1 subgoal):\n 1. var g v = var g v'", "unfolding var_def"], ["proof (prove)\nusing this:\n  m \\<in> set (\\<alpha>n g)\n  v = lookupDef g m (fst v')\n\ngoal (1 subgoal):\n 1. fst v = fst v'", "by (metis lookupDef_fst)"], ["proof (state)\nthis:\n  var g v = var g v'\n\ngoal (1 subgoal):\n 1. v \\<notin> uses' g m \\<Longrightarrow> lookupDef g m (var g v) = v", "with l"], ["proof (chain)\npicking this:\n  v = lookupDef g m (var g v')\n  var g v = var g v'", "show ?thesis"], ["proof (prove)\nusing this:\n  v = lookupDef g m (var g v')\n  var g v = var g v'\n\ngoal (1 subgoal):\n 1. lookupDef g m (var g v) = v", "by simp"], ["proof (state)\nthis:\n  lookupDef g m (var g v) = v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma phis'_fst:\n    assumes \"phis' g (n,v) = Some vs\" \"v' \\<in> set vs\"\n    shows \"var g v' = var g v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var g v' = var g v", "using assms"], ["proof (prove)\nusing this:\n  phis' g (n, v) = Some vs\n  v' \\<in> set vs\n\ngoal (1 subgoal):\n 1. var g v' = var g v", "by (auto intro!:lookupDef_fst dest!:phiDefNodes_\\<alpha>n simp add:phis'_def split:prod.split_asm if_split_asm)"], ["", "lemma allUse_simpleUse:\n    assumes \"v \\<in> braun_ssa.allUses g m\" \"m \\<in> set (\\<alpha>n g)\"\n    obtains ms m' where \"g \\<turnstile> m-ms\\<rightarrow>m'\" \"var g v \\<in> uses g m'\" \"\\<forall>x \\<in> set (tl ms). var g v \\<notin> defs g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ms m'.\n        \\<lbrakk>g \\<turnstile> m-ms\\<rightarrow>m';\n         var g v \\<in> uses g m';\n         \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"v \\<in> uses' g m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ms m'.\n                \\<lbrakk>g \\<turnstile> m-ms\\<rightarrow>m';\n                 var g v \\<in> uses g m';\n                 \\<forall>x\\<in>set (tl ms).\n                    var g v \\<notin> defs g x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<in> uses' g m\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>ms m'.\n                \\<lbrakk>g \\<turnstile> m-ms\\<rightarrow>m';\n                 var g v \\<in> uses g m';\n                 \\<forall>x\\<in>set (tl ms).\n                    var g v \\<notin> defs g x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<notin> uses' g m\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  v \\<in> uses' g m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ms m'.\n                \\<lbrakk>g \\<turnstile> m-ms\\<rightarrow>m';\n                 var g v \\<in> uses g m';\n                 \\<forall>x\\<in>set (tl ms).\n                    var g v \\<notin> defs g x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<in> uses' g m\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>ms m'.\n                \\<lbrakk>g \\<turnstile> m-ms\\<rightarrow>m';\n                 var g v \\<in> uses g m';\n                 \\<forall>x\\<in>set (tl ms).\n                    var g v \\<notin> defs g x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<notin> uses' g m\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  v \\<in> uses' g m", "obtain v' where v': \"v = lookupDef g m v'\" \"v' \\<in> uses g m\""], ["proof (prove)\nusing this:\n  v \\<in> uses' g m\n\ngoal (1 subgoal):\n 1. (\\<And>v'.\n        \\<lbrakk>v = lookupDef g m v'; v' \\<in> uses g m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add:uses'_def)"], ["proof (state)\nthis:\n  v = lookupDef g m v'\n  v' \\<in> uses g m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ms m'.\n                \\<lbrakk>g \\<turnstile> m-ms\\<rightarrow>m';\n                 var g v \\<in> uses g m';\n                 \\<forall>x\\<in>set (tl ms).\n                    var g v \\<notin> defs g x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<in> uses' g m\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>ms m'.\n                \\<lbrakk>g \\<turnstile> m-ms\\<rightarrow>m';\n                 var g v \\<in> uses g m';\n                 \\<forall>x\\<in>set (tl ms).\n                    var g v \\<notin> defs g x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<notin> uses' g m\\<rbrakk>\n    \\<Longrightarrow> thesis", "with assms(2)"], ["proof (chain)\npicking this:\n  m \\<in> set (\\<alpha>n g)\n  v = lookupDef g m v'\n  v' \\<in> uses g m", "have \"var g v = v'\""], ["proof (prove)\nusing this:\n  m \\<in> set (\\<alpha>n g)\n  v = lookupDef g m v'\n  v' \\<in> uses g m\n\ngoal (1 subgoal):\n 1. var g v = v'", "unfolding var_def"], ["proof (prove)\nusing this:\n  m \\<in> set (\\<alpha>n g)\n  v = lookupDef g m v'\n  v' \\<in> uses g m\n\ngoal (1 subgoal):\n 1. fst v = v'", "by (metis lookupDef_fst)"], ["proof (state)\nthis:\n  var g v = v'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ms m'.\n                \\<lbrakk>g \\<turnstile> m-ms\\<rightarrow>m';\n                 var g v \\<in> uses g m';\n                 \\<forall>x\\<in>set (tl ms).\n                    var g v \\<notin> defs g x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<in> uses' g m\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>ms m'.\n                \\<lbrakk>g \\<turnstile> m-ms\\<rightarrow>m';\n                 var g v \\<in> uses g m';\n                 \\<forall>x\\<in>set (tl ms).\n                    var g v \\<notin> defs g x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<notin> uses' g m\\<rbrakk>\n    \\<Longrightarrow> thesis", "with v' assms(2)"], ["proof (chain)\npicking this:\n  v = lookupDef g m v'\n  v' \\<in> uses g m\n  m \\<in> set (\\<alpha>n g)\n  var g v = v'", "show ?thesis"], ["proof (prove)\nusing this:\n  v = lookupDef g m v'\n  v' \\<in> uses g m\n  m \\<in> set (\\<alpha>n g)\n  var g v = v'\n\ngoal (1 subgoal):\n 1. thesis", "by - (rule that, auto)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ms m'.\n                \\<lbrakk>g \\<turnstile> m-ms\\<rightarrow>m';\n                 var g v \\<in> uses g m';\n                 \\<forall>x\\<in>set (tl ms).\n                    var g v \\<notin> defs g x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<notin> uses' g m\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ms m'.\n                \\<lbrakk>g \\<turnstile> m-ms\\<rightarrow>m';\n                 var g v \\<in> uses g m';\n                 \\<forall>x\\<in>set (tl ms).\n                    var g v \\<notin> defs g x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<notin> uses' g m\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  v \\<notin> uses' g m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ms m'.\n                \\<lbrakk>g \\<turnstile> m-ms\\<rightarrow>m';\n                 var g v \\<in> uses g m';\n                 \\<forall>x\\<in>set (tl ms).\n                    var g v \\<notin> defs g x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<notin> uses' g m\\<rbrakk>\n    \\<Longrightarrow> thesis", "with assms(1)"], ["proof (chain)\npicking this:\n  v \\<in> braun_ssa.allUses g m\n  v \\<notin> uses' g m", "obtain  m' v' vs where phi: \"(m,v) \\<in> set (zip (predecessors g m') vs)\" \"phis' g (m', v') = Some vs\""], ["proof (prove)\nusing this:\n  v \\<in> braun_ssa.allUses g m\n  v \\<notin> uses' g m\n\ngoal (1 subgoal):\n 1. (\\<And>m' vs v'.\n        \\<lbrakk>(m, v) \\<in> set (zip (predecessors g m') vs);\n         phis' g (m', v') = Some vs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add:braun_ssa.allUses_def elim:braun_ssa.phiUsesE)"], ["proof (state)\nthis:\n  (m, v) \\<in> set (zip (predecessors g m') vs)\n  phis' g (m', v') = Some vs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ms m'.\n                \\<lbrakk>g \\<turnstile> m-ms\\<rightarrow>m';\n                 var g v \\<in> uses g m';\n                 \\<forall>x\\<in>set (tl ms).\n                    var g v \\<notin> defs g x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<notin> uses' g m\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence m': \"m' \\<in> phiDefNodes g (var g v')\""], ["proof (prove)\nusing this:\n  (m, v) \\<in> set (zip (predecessors g m') vs)\n  phis' g (m', v') = Some vs\n\ngoal (1 subgoal):\n 1. m' \\<in> phiDefNodes g (var g v')", "by (auto simp add:phis'_def split:prod.split_asm if_split_asm)"], ["proof (state)\nthis:\n  m' \\<in> phiDefNodes g (var g v')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ms m'.\n                \\<lbrakk>g \\<turnstile> m-ms\\<rightarrow>m';\n                 var g v \\<in> uses g m';\n                 \\<forall>x\\<in>set (tl ms).\n                    var g v \\<notin> defs g x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<notin> uses' g m\\<rbrakk>\n    \\<Longrightarrow> thesis", "from phi"], ["proof (chain)\npicking this:\n  (m, v) \\<in> set (zip (predecessors g m') vs)\n  phis' g (m', v') = Some vs", "have[simp]: \"var g v = var g v'\""], ["proof (prove)\nusing this:\n  (m, v) \\<in> set (zip (predecessors g m') vs)\n  phis' g (m', v') = Some vs\n\ngoal (1 subgoal):\n 1. var g v = var g v'", "by - (rule phis'_fst, auto)"], ["proof (state)\nthis:\n  var g v = var g v'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ms m'.\n                \\<lbrakk>g \\<turnstile> m-ms\\<rightarrow>m';\n                 var g v \\<in> uses g m';\n                 \\<forall>x\\<in>set (tl ms).\n                    var g v \\<notin> defs g x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<notin> uses' g m\\<rbrakk>\n    \\<Longrightarrow> thesis", "from m'"], ["proof (chain)\npicking this:\n  m' \\<in> phiDefNodes g (var g v')", "obtain m'' ms where \"g \\<turnstile> m'-ms\\<rightarrow>m''\" \"\\<forall>x \\<in> set ms. var g v' \\<notin> defs g x\" \"var g v' \\<in> uses g m''\""], ["proof (prove)\nusing this:\n  m' \\<in> phiDefNodes g (var g v')\n\ngoal (1 subgoal):\n 1. (\\<And>ms m''.\n        \\<lbrakk>g \\<turnstile> m'-ms\\<rightarrow>m'';\n         \\<forall>x\\<in>set ms. var g v' \\<notin> defs g x;\n         var g v' \\<in> uses g m''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (erule phiDefNodesE)"], ["proof (state)\nthis:\n  g \\<turnstile> m'-ms\\<rightarrow>m''\n  \\<forall>x\\<in>set ms. var g v' \\<notin> defs g x\n  var g v' \\<in> uses g m''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ms m'.\n                \\<lbrakk>g \\<turnstile> m-ms\\<rightarrow>m';\n                 var g v \\<in> uses g m';\n                 \\<forall>x\\<in>set (tl ms).\n                    var g v \\<notin> defs g x\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     v \\<notin> uses' g m\\<rbrakk>\n    \\<Longrightarrow> thesis", "with phi(1)"], ["proof (chain)\npicking this:\n  (m, v) \\<in> set (zip (predecessors g m') vs)\n  g \\<turnstile> m'-ms\\<rightarrow>m''\n  \\<forall>x\\<in>set ms. var g v' \\<notin> defs g x\n  var g v' \\<in> uses g m''", "show ?thesis"], ["proof (prove)\nusing this:\n  (m, v) \\<in> set (zip (predecessors g m') vs)\n  g \\<turnstile> m'-ms\\<rightarrow>m''\n  \\<forall>x\\<in>set ms. var g v' \\<notin> defs g x\n  var g v' \\<in> uses g m''\n\ngoal (1 subgoal):\n 1. thesis", "by - (rule that[of \"m#ms\" m''], auto simp del:var_def)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma defs': \"v \\<in> defs' g n \\<longleftrightarrow> var g v \\<in> defs g n \\<and> defKind v = SimpleDef \\<and> defNode v = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<in> defs' g n) =\n    (var g v \\<in> defs g n \\<and>\n     defKind v = SimpleDef \\<and> defNode v = n)", "by (cases v, auto simp add:defs'_def)"], ["", "lemma use_implies_allDef:\n    assumes \"lookupDef g m (var g v) = v\"  \"m \\<in> set (\\<alpha>n g)\" \"var g v \\<in> uses g m'\" \"g \\<turnstile> m-ms\\<rightarrow>m'\" \"\\<forall>x \\<in> set (tl ms). var g v \\<notin> defs g x\"\n    shows \"v \\<in> braun_ssa.allDefs g (defNode v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> braun_ssa.allDefs g (defNode v)", "using assms"], ["proof (prove)\nusing this:\n  lookupDef g m (var g v) = v\n  m \\<in> set (\\<alpha>n g)\n  var g v \\<in> uses g m'\n  g \\<turnstile> m-ms\\<rightarrow>m'\n  \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\n\ngoal (1 subgoal):\n 1. v \\<in> braun_ssa.allDefs g (defNode v)", "proof (induction arbitrary:ms rule:lookupDef_induct'')"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ms.\n       \\<lbrakk>var g v \\<in> defs g (defNode v); defKind v = SimpleDef;\n        var g v \\<in> uses g m'; g \\<turnstile> defNode v-ms\\<rightarrow>m';\n        \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n       \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v)\n 2. \\<And>ms.\n       \\<lbrakk>var g v \\<notin> defs g (defNode v);\n        length (predecessors g (defNode v)) \\<noteq> 1; defKind v = PhiDef;\n        var g v \\<in> uses g m'; g \\<turnstile> defNode v-ms\\<rightarrow>m';\n        \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n       \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v)\n 3. \\<And>n m ms.\n       \\<lbrakk>var g v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g n (var g v) = lookupDef g m (var g v);\n        \\<And>ms.\n           \\<lbrakk>var g v \\<in> uses g m';\n            g \\<turnstile> m-ms\\<rightarrow>m';\n            \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n           \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v);\n        var g v \\<in> uses g m'; g \\<turnstile> n-ms\\<rightarrow>m';\n        \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n       \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v)", "case SimpleDef"], ["proof (state)\nthis:\n  var g v \\<in> defs g (defNode v)\n  defKind v = SimpleDef\n  var g v \\<in> uses g m'\n  g \\<turnstile> defNode v-ms\\<rightarrow>m'\n  \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\n\ngoal (3 subgoals):\n 1. \\<And>ms.\n       \\<lbrakk>var g v \\<in> defs g (defNode v); defKind v = SimpleDef;\n        var g v \\<in> uses g m'; g \\<turnstile> defNode v-ms\\<rightarrow>m';\n        \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n       \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v)\n 2. \\<And>ms.\n       \\<lbrakk>var g v \\<notin> defs g (defNode v);\n        length (predecessors g (defNode v)) \\<noteq> 1; defKind v = PhiDef;\n        var g v \\<in> uses g m'; g \\<turnstile> defNode v-ms\\<rightarrow>m';\n        \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n       \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v)\n 3. \\<And>n m ms.\n       \\<lbrakk>var g v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g n (var g v) = lookupDef g m (var g v);\n        \\<And>ms.\n           \\<lbrakk>var g v \\<in> uses g m';\n            g \\<turnstile> m-ms\\<rightarrow>m';\n            \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n           \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v);\n        var g v \\<in> uses g m'; g \\<turnstile> n-ms\\<rightarrow>m';\n        \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n       \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v)", "hence \"v \\<in> defs' g (defNode v)\""], ["proof (prove)\nusing this:\n  var g v \\<in> defs g (defNode v)\n  defKind v = SimpleDef\n  var g v \\<in> uses g m'\n  g \\<turnstile> defNode v-ms\\<rightarrow>m'\n  \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\n\ngoal (1 subgoal):\n 1. v \\<in> defs' g (defNode v)", "by (simp add:defs')"], ["proof (state)\nthis:\n  v \\<in> defs' g (defNode v)\n\ngoal (3 subgoals):\n 1. \\<And>ms.\n       \\<lbrakk>var g v \\<in> defs g (defNode v); defKind v = SimpleDef;\n        var g v \\<in> uses g m'; g \\<turnstile> defNode v-ms\\<rightarrow>m';\n        \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n       \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v)\n 2. \\<And>ms.\n       \\<lbrakk>var g v \\<notin> defs g (defNode v);\n        length (predecessors g (defNode v)) \\<noteq> 1; defKind v = PhiDef;\n        var g v \\<in> uses g m'; g \\<turnstile> defNode v-ms\\<rightarrow>m';\n        \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n       \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v)\n 3. \\<And>n m ms.\n       \\<lbrakk>var g v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g n (var g v) = lookupDef g m (var g v);\n        \\<And>ms.\n           \\<lbrakk>var g v \\<in> uses g m';\n            g \\<turnstile> m-ms\\<rightarrow>m';\n            \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n           \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v);\n        var g v \\<in> uses g m'; g \\<turnstile> n-ms\\<rightarrow>m';\n        \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n       \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v)", "thus ?case"], ["proof (prove)\nusing this:\n  v \\<in> defs' g (defNode v)\n\ngoal (1 subgoal):\n 1. v \\<in> braun_ssa.allDefs g (defNode v)", "by (simp add:braun_ssa.allDefs_def)"], ["proof (state)\nthis:\n  v \\<in> braun_ssa.allDefs g (defNode v)\n\ngoal (2 subgoals):\n 1. \\<And>ms.\n       \\<lbrakk>var g v \\<notin> defs g (defNode v);\n        length (predecessors g (defNode v)) \\<noteq> 1; defKind v = PhiDef;\n        var g v \\<in> uses g m'; g \\<turnstile> defNode v-ms\\<rightarrow>m';\n        \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n       \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v)\n 2. \\<And>n m ms.\n       \\<lbrakk>var g v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g n (var g v) = lookupDef g m (var g v);\n        \\<And>ms.\n           \\<lbrakk>var g v \\<in> uses g m';\n            g \\<turnstile> m-ms\\<rightarrow>m';\n            \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n           \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v);\n        var g v \\<in> uses g m'; g \\<turnstile> n-ms\\<rightarrow>m';\n        \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n       \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ms.\n       \\<lbrakk>var g v \\<notin> defs g (defNode v);\n        length (predecessors g (defNode v)) \\<noteq> 1; defKind v = PhiDef;\n        var g v \\<in> uses g m'; g \\<turnstile> defNode v-ms\\<rightarrow>m';\n        \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n       \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v)\n 2. \\<And>n m ms.\n       \\<lbrakk>var g v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g n (var g v) = lookupDef g m (var g v);\n        \\<And>ms.\n           \\<lbrakk>var g v \\<in> uses g m';\n            g \\<turnstile> m-ms\\<rightarrow>m';\n            \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n           \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v);\n        var g v \\<in> uses g m'; g \\<turnstile> n-ms\\<rightarrow>m';\n        \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n       \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v)", "case PhiDef"], ["proof (state)\nthis:\n  var g v \\<notin> defs g (defNode v)\n  length (predecessors g (defNode v)) \\<noteq> 1\n  defKind v = PhiDef\n  var g v \\<in> uses g m'\n  g \\<turnstile> defNode v-ms\\<rightarrow>m'\n  \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\n\ngoal (2 subgoals):\n 1. \\<And>ms.\n       \\<lbrakk>var g v \\<notin> defs g (defNode v);\n        length (predecessors g (defNode v)) \\<noteq> 1; defKind v = PhiDef;\n        var g v \\<in> uses g m'; g \\<turnstile> defNode v-ms\\<rightarrow>m';\n        \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n       \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v)\n 2. \\<And>n m ms.\n       \\<lbrakk>var g v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g n (var g v) = lookupDef g m (var g v);\n        \\<And>ms.\n           \\<lbrakk>var g v \\<in> uses g m';\n            g \\<turnstile> m-ms\\<rightarrow>m';\n            \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n           \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v);\n        var g v \\<in> uses g m'; g \\<turnstile> n-ms\\<rightarrow>m';\n        \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n       \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v)", "from PhiDef.prems(1,2)"], ["proof (chain)\npicking this:\n  var g v \\<in> uses g m'\n  g \\<turnstile> defNode v-ms\\<rightarrow>m'", "have vars: \"var g v \\<in> vars g\""], ["proof (prove)\nusing this:\n  var g v \\<in> uses g m'\n  g \\<turnstile> defNode v-ms\\<rightarrow>m'\n\ngoal (1 subgoal):\n 1. var g v \\<in> vars g", "by auto"], ["proof (state)\nthis:\n  var g v \\<in> vars g\n\ngoal (2 subgoals):\n 1. \\<And>ms.\n       \\<lbrakk>var g v \\<notin> defs g (defNode v);\n        length (predecessors g (defNode v)) \\<noteq> 1; defKind v = PhiDef;\n        var g v \\<in> uses g m'; g \\<turnstile> defNode v-ms\\<rightarrow>m';\n        \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n       \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v)\n 2. \\<And>n m ms.\n       \\<lbrakk>var g v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g n (var g v) = lookupDef g m (var g v);\n        \\<And>ms.\n           \\<lbrakk>var g v \\<in> uses g m';\n            g \\<turnstile> m-ms\\<rightarrow>m';\n            \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n           \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v);\n        var g v \\<in> uses g m'; g \\<turnstile> n-ms\\<rightarrow>m';\n        \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n       \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v)", "from PhiDef.hyps(1) PhiDef.prems(2,3)"], ["proof (chain)\npicking this:\n  var g v \\<notin> defs g (defNode v)\n  g \\<turnstile> defNode v-ms\\<rightarrow>m'\n  \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x", "have \"\\<forall>n\\<in>set ms. var g v \\<notin> defs g n\""], ["proof (prove)\nusing this:\n  var g v \\<notin> defs g (defNode v)\n  g \\<turnstile> defNode v-ms\\<rightarrow>m'\n  \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>set ms. var g v \\<notin> defs g n", "by (metis hd_Cons_tl path2_def path2_not_Nil set_ConsD)"], ["proof (state)\nthis:\n  \\<forall>n\\<in>set ms. var g v \\<notin> defs g n\n\ngoal (2 subgoals):\n 1. \\<And>ms.\n       \\<lbrakk>var g v \\<notin> defs g (defNode v);\n        length (predecessors g (defNode v)) \\<noteq> 1; defKind v = PhiDef;\n        var g v \\<in> uses g m'; g \\<turnstile> defNode v-ms\\<rightarrow>m';\n        \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n       \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v)\n 2. \\<And>n m ms.\n       \\<lbrakk>var g v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g n (var g v) = lookupDef g m (var g v);\n        \\<And>ms.\n           \\<lbrakk>var g v \\<in> uses g m';\n            g \\<turnstile> m-ms\\<rightarrow>m';\n            \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n           \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v);\n        var g v \\<in> uses g m'; g \\<turnstile> n-ms\\<rightarrow>m';\n        \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n       \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v)", "with PhiDef"], ["proof (chain)\npicking this:\n  var g v \\<notin> defs g (defNode v)\n  length (predecessors g (defNode v)) \\<noteq> 1\n  defKind v = PhiDef\n  var g v \\<in> uses g m'\n  g \\<turnstile> defNode v-ms\\<rightarrow>m'\n  \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\n  \\<forall>n\\<in>set ms. var g v \\<notin> defs g n", "have \"defNode v \\<in> phiDefNodes g (var g v)\""], ["proof (prove)\nusing this:\n  var g v \\<notin> defs g (defNode v)\n  length (predecessors g (defNode v)) \\<noteq> 1\n  defKind v = PhiDef\n  var g v \\<in> uses g m'\n  g \\<turnstile> defNode v-ms\\<rightarrow>m'\n  \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\n  \\<forall>n\\<in>set ms. var g v \\<notin> defs g n\n\ngoal (1 subgoal):\n 1. defNode v \\<in> phiDefNodes g (var g v)", "by - (rule phiDefNodesI)"], ["proof (state)\nthis:\n  defNode v \\<in> phiDefNodes g (var g v)\n\ngoal (2 subgoals):\n 1. \\<And>ms.\n       \\<lbrakk>var g v \\<notin> defs g (defNode v);\n        length (predecessors g (defNode v)) \\<noteq> 1; defKind v = PhiDef;\n        var g v \\<in> uses g m'; g \\<turnstile> defNode v-ms\\<rightarrow>m';\n        \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n       \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v)\n 2. \\<And>n m ms.\n       \\<lbrakk>var g v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g n (var g v) = lookupDef g m (var g v);\n        \\<And>ms.\n           \\<lbrakk>var g v \\<in> uses g m';\n            g \\<turnstile> m-ms\\<rightarrow>m';\n            \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n           \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v);\n        var g v \\<in> uses g m'; g \\<turnstile> n-ms\\<rightarrow>m';\n        \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n       \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v)", "with PhiDef.hyps(3) vars"], ["proof (chain)\npicking this:\n  defKind v = PhiDef\n  var g v \\<in> vars g\n  defNode v \\<in> phiDefNodes g (var g v)", "have \"v \\<in> braun_ssa.phiDefs g (defNode v)\""], ["proof (prove)\nusing this:\n  defKind v = PhiDef\n  var g v \\<in> vars g\n  defNode v \\<in> phiDefNodes g (var g v)\n\ngoal (1 subgoal):\n 1. v \\<in> braun_ssa.phiDefs g (defNode v)", "unfolding braun_ssa.phiDefs_def"], ["proof (prove)\nusing this:\n  defKind v = PhiDef\n  var g v \\<in> vars g\n  defNode v \\<in> phiDefNodes g (var g v)\n\ngoal (1 subgoal):\n 1. v \\<in> {va. (defNode v, va) \\<in> dom (phis' g)}", "by (auto simp add: phis'_def split:prod.split)"], ["proof (state)\nthis:\n  v \\<in> braun_ssa.phiDefs g (defNode v)\n\ngoal (2 subgoals):\n 1. \\<And>ms.\n       \\<lbrakk>var g v \\<notin> defs g (defNode v);\n        length (predecessors g (defNode v)) \\<noteq> 1; defKind v = PhiDef;\n        var g v \\<in> uses g m'; g \\<turnstile> defNode v-ms\\<rightarrow>m';\n        \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n       \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v)\n 2. \\<And>n m ms.\n       \\<lbrakk>var g v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g n (var g v) = lookupDef g m (var g v);\n        \\<And>ms.\n           \\<lbrakk>var g v \\<in> uses g m';\n            g \\<turnstile> m-ms\\<rightarrow>m';\n            \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n           \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v);\n        var g v \\<in> uses g m'; g \\<turnstile> n-ms\\<rightarrow>m';\n        \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n       \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v)", "thus ?case"], ["proof (prove)\nusing this:\n  v \\<in> braun_ssa.phiDefs g (defNode v)\n\ngoal (1 subgoal):\n 1. v \\<in> braun_ssa.allDefs g (defNode v)", "by (simp add:braun_ssa.allDefs_def)"], ["proof (state)\nthis:\n  v \\<in> braun_ssa.allDefs g (defNode v)\n\ngoal (1 subgoal):\n 1. \\<And>n m ms.\n       \\<lbrakk>var g v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g n (var g v) = lookupDef g m (var g v);\n        \\<And>ms.\n           \\<lbrakk>var g v \\<in> uses g m';\n            g \\<turnstile> m-ms\\<rightarrow>m';\n            \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n           \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v);\n        var g v \\<in> uses g m'; g \\<turnstile> n-ms\\<rightarrow>m';\n        \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n       \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n m ms.\n       \\<lbrakk>var g v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g n (var g v) = lookupDef g m (var g v);\n        \\<And>ms.\n           \\<lbrakk>var g v \\<in> uses g m';\n            g \\<turnstile> m-ms\\<rightarrow>m';\n            \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n           \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v);\n        var g v \\<in> uses g m'; g \\<turnstile> n-ms\\<rightarrow>m';\n        \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n       \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v)", "case (rec n m)"], ["proof (state)\nthis:\n  var g v \\<notin> defs g n\n  predecessors g n = [m]\n  m \\<in> set (\\<alpha>n g)\n  lookupDef g n (var g v) = lookupDef g m (var g v)\n  \\<lbrakk>var g v \\<in> uses g m'; g \\<turnstile> m-?ms1\\<rightarrow>m';\n   \\<forall>x\\<in>set (tl ?ms1). var g v \\<notin> defs g x\\<rbrakk>\n  \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v)\n  var g v \\<in> uses g m'\n  g \\<turnstile> n-ms\\<rightarrow>m'\n  \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\n\ngoal (1 subgoal):\n 1. \\<And>n m ms.\n       \\<lbrakk>var g v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g n (var g v) = lookupDef g m (var g v);\n        \\<And>ms.\n           \\<lbrakk>var g v \\<in> uses g m';\n            g \\<turnstile> m-ms\\<rightarrow>m';\n            \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n           \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v);\n        var g v \\<in> uses g m'; g \\<turnstile> n-ms\\<rightarrow>m';\n        \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n       \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v)", "from rec.hyps(1) rec.prems(2,3)"], ["proof (chain)\npicking this:\n  var g v \\<notin> defs g n\n  g \\<turnstile> n-ms\\<rightarrow>m'\n  \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x", "have \"\\<forall>n\\<in>set ms. var g v \\<notin> defs g n\""], ["proof (prove)\nusing this:\n  var g v \\<notin> defs g n\n  g \\<turnstile> n-ms\\<rightarrow>m'\n  \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>set ms. var g v \\<notin> defs g n", "by (metis hd_Cons_tl path2_def path2_not_Nil set_ConsD)"], ["proof (state)\nthis:\n  \\<forall>n\\<in>set ms. var g v \\<notin> defs g n\n\ngoal (1 subgoal):\n 1. \\<And>n m ms.\n       \\<lbrakk>var g v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g n (var g v) = lookupDef g m (var g v);\n        \\<And>ms.\n           \\<lbrakk>var g v \\<in> uses g m';\n            g \\<turnstile> m-ms\\<rightarrow>m';\n            \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n           \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v);\n        var g v \\<in> uses g m'; g \\<turnstile> n-ms\\<rightarrow>m';\n        \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n       \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v)", "with rec"], ["proof (chain)\npicking this:\n  var g v \\<notin> defs g n\n  predecessors g n = [m]\n  m \\<in> set (\\<alpha>n g)\n  lookupDef g n (var g v) = lookupDef g m (var g v)\n  \\<lbrakk>var g v \\<in> uses g m'; g \\<turnstile> m-?ms1\\<rightarrow>m';\n   \\<forall>x\\<in>set (tl ?ms1). var g v \\<notin> defs g x\\<rbrakk>\n  \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v)\n  var g v \\<in> uses g m'\n  g \\<turnstile> n-ms\\<rightarrow>m'\n  \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\n  \\<forall>n\\<in>set ms. var g v \\<notin> defs g n", "show ?case"], ["proof (prove)\nusing this:\n  var g v \\<notin> defs g n\n  predecessors g n = [m]\n  m \\<in> set (\\<alpha>n g)\n  lookupDef g n (var g v) = lookupDef g m (var g v)\n  \\<lbrakk>var g v \\<in> uses g m'; g \\<turnstile> m-?ms1\\<rightarrow>m';\n   \\<forall>x\\<in>set (tl ?ms1). var g v \\<notin> defs g x\\<rbrakk>\n  \\<Longrightarrow> v \\<in> braun_ssa.allDefs g (defNode v)\n  var g v \\<in> uses g m'\n  g \\<turnstile> n-ms\\<rightarrow>m'\n  \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\n  \\<forall>n\\<in>set ms. var g v \\<notin> defs g n\n\ngoal (1 subgoal):\n 1. v \\<in> braun_ssa.allDefs g (defNode v)", "by - (rule rec.IH[of \"m#ms\"], auto)"], ["proof (state)\nthis:\n  v \\<in> braun_ssa.allDefs g (defNode v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma allUse_defNode_in_\\<alpha>n[simp]:\n    assumes \"v \\<in> braun_ssa.allUses g m\" \"m \\<in> set (\\<alpha>n g)\"\n    shows \"defNode v \\<in> set (\\<alpha>n g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. defNode v \\<in> set (\\<alpha>n g)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. defNode v \\<in> set (\\<alpha>n g)", "let ?n = \"defNode (lookupDef g m (var g v))\""], ["proof (state)\ngoal (1 subgoal):\n 1. defNode v \\<in> set (\\<alpha>n g)", "from assms(1,2)"], ["proof (chain)\npicking this:\n  v \\<in> braun_ssa.allUses g m\n  m \\<in> set (\\<alpha>n g)", "have l: \"lookupDef g m (var g v) = v\""], ["proof (prove)\nusing this:\n  v \\<in> braun_ssa.allUses g m\n  m \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. lookupDef g m (var g v) = v", "by (rule allUse_lookupDef)"], ["proof (state)\nthis:\n  lookupDef g m (var g v) = v\n\ngoal (1 subgoal):\n 1. defNode v \\<in> set (\\<alpha>n g)", "from assms"], ["proof (chain)\npicking this:\n  v \\<in> braun_ssa.allUses g m\n  m \\<in> set (\\<alpha>n g)", "obtain ns where ns: \"g \\<turnstile> ?n-ns\\<rightarrow>m\""], ["proof (prove)\nusing this:\n  v \\<in> braun_ssa.allUses g m\n  m \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        g \\<turnstile> lookupDefNode g m\n                        (var g v)-ns\\<rightarrow>m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by - (rule lookupDef_path, auto)"], ["proof (state)\nthis:\n  g \\<turnstile> lookupDefNode g m (var g v)-ns\\<rightarrow>m\n\ngoal (1 subgoal):\n 1. defNode v \\<in> set (\\<alpha>n g)", "with l"], ["proof (chain)\npicking this:\n  lookupDef g m (var g v) = v\n  g \\<turnstile> lookupDefNode g m (var g v)-ns\\<rightarrow>m", "show ?thesis"], ["proof (prove)\nusing this:\n  lookupDef g m (var g v) = v\n  g \\<turnstile> lookupDefNode g m (var g v)-ns\\<rightarrow>m\n\ngoal (1 subgoal):\n 1. defNode v \\<in> set (\\<alpha>n g)", "by auto"], ["proof (state)\nthis:\n  defNode v \\<in> set (\\<alpha>n g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma allUse_implies_allDef:\n    assumes \"v \\<in> braun_ssa.allUses g m\" \"m \\<in> set (\\<alpha>n g)\"\n    shows \"v \\<in> braun_ssa.allDefs g (defNode v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> braun_ssa.allDefs g (defNode v)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> braun_ssa.allDefs g (defNode v)", "let ?n = \"defNode (lookupDef g m (var g v))\""], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> braun_ssa.allDefs g (defNode v)", "from assms(1,2)"], ["proof (chain)\npicking this:\n  v \\<in> braun_ssa.allUses g m\n  m \\<in> set (\\<alpha>n g)", "have l: \"lookupDef g m (var g v) = v\""], ["proof (prove)\nusing this:\n  v \\<in> braun_ssa.allUses g m\n  m \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. lookupDef g m (var g v) = v", "by (rule allUse_lookupDef)"], ["proof (state)\nthis:\n  lookupDef g m (var g v) = v\n\ngoal (1 subgoal):\n 1. v \\<in> braun_ssa.allDefs g (defNode v)", "from assms"], ["proof (chain)\npicking this:\n  v \\<in> braun_ssa.allUses g m\n  m \\<in> set (\\<alpha>n g)", "obtain ns where ns: \"g \\<turnstile> ?n-ns\\<rightarrow>m\" \"\\<forall>x \\<in> set (tl ns). var g v \\<notin> defs g x\""], ["proof (prove)\nusing this:\n  v \\<in> braun_ssa.allUses g m\n  m \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>g \\<turnstile> lookupDefNode g m\n                                 (var g v)-ns\\<rightarrow>m;\n         \\<forall>x\\<in>set (tl ns). var g v \\<notin> defs g x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by - (rule lookupDef_path, auto)"], ["proof (state)\nthis:\n  g \\<turnstile> lookupDefNode g m (var g v)-ns\\<rightarrow>m\n  \\<forall>x\\<in>set (tl ns). var g v \\<notin> defs g x\n\ngoal (1 subgoal):\n 1. v \\<in> braun_ssa.allDefs g (defNode v)", "from assms"], ["proof (chain)\npicking this:\n  v \\<in> braun_ssa.allUses g m\n  m \\<in> set (\\<alpha>n g)", "obtain ms m' where \"g \\<turnstile> m-ms\\<rightarrow>m'\" \"var g v \\<in> uses g m'\" \"\\<forall>x \\<in> set (tl ms). var g v \\<notin> defs g x\""], ["proof (prove)\nusing this:\n  v \\<in> braun_ssa.allUses g m\n  m \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. (\\<And>ms m'.\n        \\<lbrakk>g \\<turnstile> m-ms\\<rightarrow>m';\n         var g v \\<in> uses g m';\n         \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by - (rule allUse_simpleUse)"], ["proof (state)\nthis:\n  g \\<turnstile> m-ms\\<rightarrow>m'\n  var g v \\<in> uses g m'\n  \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\n\ngoal (1 subgoal):\n 1. v \\<in> braun_ssa.allDefs g (defNode v)", "hence \"v \\<in> braun_ssa.allDefs g (defNode v)\""], ["proof (prove)\nusing this:\n  g \\<turnstile> m-ms\\<rightarrow>m'\n  var g v \\<in> uses g m'\n  \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\n\ngoal (1 subgoal):\n 1. v \\<in> braun_ssa.allDefs g (defNode v)", "using ns assms(2) l"], ["proof (prove)\nusing this:\n  g \\<turnstile> m-ms\\<rightarrow>m'\n  var g v \\<in> uses g m'\n  \\<forall>x\\<in>set (tl ms). var g v \\<notin> defs g x\n  g \\<turnstile> lookupDefNode g m (var g v)-ns\\<rightarrow>m\n  \\<forall>x\\<in>set (tl ns). var g v \\<notin> defs g x\n  m \\<in> set (\\<alpha>n g)\n  lookupDef g m (var g v) = v\n\ngoal (1 subgoal):\n 1. v \\<in> braun_ssa.allDefs g (defNode v)", "by - (rule use_implies_allDef, auto)"], ["proof (state)\nthis:\n  v \\<in> braun_ssa.allDefs g (defNode v)\n\ngoal (1 subgoal):\n 1. v \\<in> braun_ssa.allDefs g (defNode v)", "with assms(2) l"], ["proof (chain)\npicking this:\n  m \\<in> set (\\<alpha>n g)\n  lookupDef g m (var g v) = v\n  v \\<in> braun_ssa.allDefs g (defNode v)", "show ?thesis"], ["proof (prove)\nusing this:\n  m \\<in> set (\\<alpha>n g)\n  lookupDef g m (var g v) = v\n  v \\<in> braun_ssa.allDefs g (defNode v)\n\ngoal (1 subgoal):\n 1. v \\<in> braun_ssa.allDefs g (defNode v)", "by simp"], ["proof (state)\nthis:\n  v \\<in> braun_ssa.allDefs g (defNode v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma conventional:\n    assumes \"g \\<turnstile> n-ns\\<rightarrow>m\" \"n \\<notin> set (tl ns)\" \"v \\<in> braun_ssa.allDefs g n\" \"v \\<in> braun_ssa.allUses g m\"\n      \"x \\<in> set (tl ns)\" \"v' \\<in> braun_ssa.allDefs g x\"\n    shows \"var g v' \\<noteq> var g v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var g v' \\<noteq> var g v", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. var g v' \\<noteq> var g v", "from assms(1)"], ["proof (chain)\npicking this:\n  g \\<turnstile> n-ns\\<rightarrow>m", "have[simp]: \"m \\<in> set (\\<alpha>n g)\""], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n\ngoal (1 subgoal):\n 1. m \\<in> set (\\<alpha>n g)", "by auto"], ["proof (state)\nthis:\n  m \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. var g v' \\<noteq> var g v", "from assms(4)"], ["proof (chain)\npicking this:\n  v \\<in> braun_ssa.allUses g m", "have[simp]: \"lookupDef g m (var g v) = v\""], ["proof (prove)\nusing this:\n  v \\<in> braun_ssa.allUses g m\n\ngoal (1 subgoal):\n 1. lookupDef g m (var g v) = v", "by - (rule allUse_lookupDef, auto)"], ["proof (state)\nthis:\n  lookupDef g m (var g v) = v\n\ngoal (1 subgoal):\n 1. var g v' \\<noteq> var g v", "from assms(1,4)"], ["proof (chain)\npicking this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  v \\<in> braun_ssa.allUses g m", "have \"v \\<in> braun_ssa.allDefs g (defNode v)\""], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  v \\<in> braun_ssa.allUses g m\n\ngoal (1 subgoal):\n 1. v \\<in> braun_ssa.allDefs g (defNode v)", "by - (rule allUse_implies_allDef, auto)"], ["proof (state)\nthis:\n  v \\<in> braun_ssa.allDefs g (defNode v)\n\ngoal (1 subgoal):\n 1. var g v' \\<noteq> var g v", "with assms(1,3,4) braun_ssa.allDefs_disjoint[of n g \"defNode v\"]"], ["proof (chain)\npicking this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  v \\<in> braun_ssa.allDefs g n\n  v \\<in> braun_ssa.allUses g m\n  \\<lbrakk>n \\<in> set (\\<alpha>n g); defNode v \\<in> set (\\<alpha>n g);\n   n \\<noteq> defNode v\\<rbrakk>\n  \\<Longrightarrow> braun_ssa.allDefs g n \\<inter>\n                    braun_ssa.allDefs g (defNode v) =\n                    {}\n  v \\<in> braun_ssa.allDefs g (defNode v)", "have[simp]: \"defNode v = n\""], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  v \\<in> braun_ssa.allDefs g n\n  v \\<in> braun_ssa.allUses g m\n  \\<lbrakk>n \\<in> set (\\<alpha>n g); defNode v \\<in> set (\\<alpha>n g);\n   n \\<noteq> defNode v\\<rbrakk>\n  \\<Longrightarrow> braun_ssa.allDefs g n \\<inter>\n                    braun_ssa.allDefs g (defNode v) =\n                    {}\n  v \\<in> braun_ssa.allDefs g (defNode v)\n\ngoal (1 subgoal):\n 1. defNode v = n", "by - (rule braun_ssa.allDefs_disjoint', auto)"], ["proof (state)\nthis:\n  defNode v = n\n\ngoal (1 subgoal):\n 1. var g v' \\<noteq> var g v", "from assms"], ["proof (chain)\npicking this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  n \\<notin> set (tl ns)\n  v \\<in> braun_ssa.allDefs g n\n  v \\<in> braun_ssa.allUses g m\n  x \\<in> set (tl ns)\n  v' \\<in> braun_ssa.allDefs g x", "show ?thesis"], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  n \\<notin> set (tl ns)\n  v \\<in> braun_ssa.allDefs g n\n  v \\<in> braun_ssa.allUses g m\n  x \\<in> set (tl ns)\n  v' \\<in> braun_ssa.allDefs g x\n\ngoal (1 subgoal):\n 1. var g v' \\<noteq> var g v", "by - (rule lookupDef_path_conventional[where m=m], simp_all add:uses'_def del:var_def)"], ["proof (state)\nthis:\n  var g v' \\<noteq> var g v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma allDefs_var_disjoint_aux: \"n \\<in> set (\\<alpha>n g) \\<Longrightarrow> v \\<in> defs g n \\<Longrightarrow> n \\<notin> phiDefNodes g v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> defs g n\\<rbrakk>\n    \\<Longrightarrow> n \\<notin> phiDefNodes g v", "by (auto elim!:phiDefNodesE dest:path2_hd_in_ns)"], ["", "lemma allDefs_var_disjoint: \"\\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> braun_ssa.allDefs g n; v' \\<in> braun_ssa.allDefs g n; v \\<noteq> v'\\<rbrakk> \\<Longrightarrow> var g v' \\<noteq> var g v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> braun_ssa.allDefs g n;\n     v' \\<in> braun_ssa.allDefs g n; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> var g v' \\<noteq> var g v", "unfolding braun_ssa.allDefs_def braun_ssa.phiDefs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> set (\\<alpha>n g);\n     v \\<in> defs' g n \\<union> {v. (n, v) \\<in> dom (phis' g)};\n     v' \\<in> defs' g n \\<union> {v. (n, v) \\<in> dom (phis' g)};\n     v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> var g v' \\<noteq> var g v", "by (auto simp: defs'_def phis'_def allDefs_var_disjoint_aux split:prod.splits if_split_asm)"], ["", "lemma[simp]: \"n \\<in> set (\\<alpha>n g) \\<Longrightarrow> v \\<in> defs g n \\<Longrightarrow> lookupDefNode g n v = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> defs g n\\<rbrakk>\n    \\<Longrightarrow> lookupDefNode g n v = n", "by (cases rule:lookupDef_cases[of n g v]) simp_all"], ["", "lemma[simp]: \"n \\<in> set (\\<alpha>n g) \\<Longrightarrow> length (predecessors g n) \\<noteq> 1 \\<Longrightarrow> lookupDefNode g n v = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> set (\\<alpha>n g);\n     length (predecessors g n) \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> lookupDefNode g n v = n", "by (cases rule:lookupDef_cases[of n g v]) simp_all"], ["", "lemma lookupDef_idem[simp]:\n    assumes \"n \\<in> set (\\<alpha>n g)\"\n    shows \"lookupDef g (lookupDefNode g n v) v = lookupDef g n v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookupDef g (lookupDefNode g n v) v = lookupDef g n v", "using assms"], ["proof (prove)\nusing this:\n  n \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. lookupDef g (lookupDefNode g n v) v = lookupDef g n v", "by (induction rule:lookupDef_induct''[of g n v, OF refl]) (simp_all add:assms)"], ["", "end"], ["", "locale CFG_Construct_wf = CFG_Construct \\<alpha>e \\<alpha>n invar inEdges' Entry \"defs\" \"uses\" + CFG_wf \\<alpha>e \\<alpha>n invar inEdges' Entry \"defs\" \"uses\"\nfor\n  \\<alpha>e :: \"'g \\<Rightarrow> ('node::linorder \\<times> 'edgeD \\<times> 'node) set\" and\n  \\<alpha>n :: \"'g \\<Rightarrow> 'node list\" and\n  invar :: \"'g \\<Rightarrow> bool\" and\n  inEdges' :: \"'g \\<Rightarrow> 'node \\<Rightarrow> ('node \\<times> 'edgeD) list\" and\n  Entry::\"'g \\<Rightarrow> 'node\" and\n  \"defs\" :: \"'g \\<Rightarrow> 'node \\<Rightarrow> 'var::linorder set\" and\n  \"uses\" :: \"'g \\<Rightarrow> 'node \\<Rightarrow> 'var set\"\nbegin"], ["", "lemma def_ass_allUses_aux:\n    assumes \"g \\<turnstile> Entry g-ns\\<rightarrow>n\"\n    shows \"lookupDefNode g n (var g v) \\<in> set ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookupDefNode g n (var g v) \\<in> set ns", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. lookupDefNode g n (var g v) \\<in> set ns", "from assms"], ["proof (chain)\npicking this:\n  g \\<turnstile> Entry g-ns\\<rightarrow>n", "have[simp]: \"n \\<in> set (\\<alpha>n g)\""], ["proof (prove)\nusing this:\n  g \\<turnstile> Entry g-ns\\<rightarrow>n\n\ngoal (1 subgoal):\n 1. n \\<in> set (\\<alpha>n g)", "by auto"], ["proof (state)\nthis:\n  n \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. lookupDefNode g n (var g v) \\<in> set ns", "thus ?thesis"], ["proof (prove)\nusing this:\n  n \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. lookupDefNode g n (var g v) \\<in> set ns", "using assms"], ["proof (prove)\nusing this:\n  n \\<in> set (\\<alpha>n g)\n  g \\<turnstile> Entry g-ns\\<rightarrow>n\n\ngoal (1 subgoal):\n 1. lookupDefNode g n (var g v) \\<in> set ns", "proof (induction arbitrary:ns rule:lookupDef_induct''[of g n \"var g v\", OF refl, consumes 1])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ns.\n       \\<lbrakk>var g v \\<in> defs g (lookupDefNode g n (var g v));\n        defKind (lookupDef g n (var g v)) = SimpleDef;\n        g \\<turnstile> Entry\n                        g-ns\\<rightarrow>lookupDefNode g n\n    (var g v)\\<rbrakk>\n       \\<Longrightarrow> lookupDefNode g (lookupDefNode g n (var g v))\n                          (var g v)\n                         \\<in> set ns\n 2. \\<And>ns.\n       \\<lbrakk>var g v \\<notin> defs g (lookupDefNode g n (var g v));\n        length (predecessors g (lookupDefNode g n (var g v))) \\<noteq> 1;\n        defKind (lookupDef g n (var g v)) = PhiDef;\n        g \\<turnstile> Entry\n                        g-ns\\<rightarrow>lookupDefNode g n\n    (var g v)\\<rbrakk>\n       \\<Longrightarrow> lookupDefNode g (lookupDefNode g n (var g v))\n                          (var g v)\n                         \\<in> set ns\n 3. \\<And>n m ns.\n       \\<lbrakk>var g v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g n (var g v) = lookupDef g m (var g v);\n        \\<And>ns.\n           g \\<turnstile> Entry g-ns\\<rightarrow>m \\<Longrightarrow>\n           lookupDefNode g m (var g v) \\<in> set ns;\n        g \\<turnstile> Entry g-ns\\<rightarrow>n\\<rbrakk>\n       \\<Longrightarrow> lookupDefNode g n (var g v) \\<in> set ns", "case (3 m m' ns)"], ["proof (state)\nthis:\n  var g v \\<notin> defs g m\n  predecessors g m = [m']\n  m' \\<in> set (\\<alpha>n g)\n  lookupDef g m (var g v) = lookupDef g m' (var g v)\n  g \\<turnstile> Entry g-?ns1\\<rightarrow>m' \\<Longrightarrow>\n  lookupDefNode g m' (var g v) \\<in> set ?ns1\n  g \\<turnstile> Entry g-ns\\<rightarrow>m\n\ngoal (3 subgoals):\n 1. \\<And>ns.\n       \\<lbrakk>var g v \\<in> defs g (lookupDefNode g n (var g v));\n        defKind (lookupDef g n (var g v)) = SimpleDef;\n        g \\<turnstile> Entry\n                        g-ns\\<rightarrow>lookupDefNode g n\n    (var g v)\\<rbrakk>\n       \\<Longrightarrow> lookupDefNode g (lookupDefNode g n (var g v))\n                          (var g v)\n                         \\<in> set ns\n 2. \\<And>ns.\n       \\<lbrakk>var g v \\<notin> defs g (lookupDefNode g n (var g v));\n        length (predecessors g (lookupDefNode g n (var g v))) \\<noteq> 1;\n        defKind (lookupDef g n (var g v)) = PhiDef;\n        g \\<turnstile> Entry\n                        g-ns\\<rightarrow>lookupDefNode g n\n    (var g v)\\<rbrakk>\n       \\<Longrightarrow> lookupDefNode g (lookupDefNode g n (var g v))\n                          (var g v)\n                         \\<in> set ns\n 3. \\<And>n m ns.\n       \\<lbrakk>var g v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g n (var g v) = lookupDef g m (var g v);\n        \\<And>ns.\n           g \\<turnstile> Entry g-ns\\<rightarrow>m \\<Longrightarrow>\n           lookupDefNode g m (var g v) \\<in> set ns;\n        g \\<turnstile> Entry g-ns\\<rightarrow>n\\<rbrakk>\n       \\<Longrightarrow> lookupDefNode g n (var g v) \\<in> set ns", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookupDefNode g m (var g v) \\<in> set ns", "proof (cases \"length ns \\<ge> 2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 2 \\<le> length ns \\<Longrightarrow>\n    lookupDefNode g m (var g v) \\<in> set ns\n 2. \\<not> 2 \\<le> length ns \\<Longrightarrow>\n    lookupDefNode g m (var g v) \\<in> set ns", "case False"], ["proof (state)\nthis:\n  \\<not> 2 \\<le> length ns\n\ngoal (2 subgoals):\n 1. 2 \\<le> length ns \\<Longrightarrow>\n    lookupDefNode g m (var g v) \\<in> set ns\n 2. \\<not> 2 \\<le> length ns \\<Longrightarrow>\n    lookupDefNode g m (var g v) \\<in> set ns", "with \"3.prems\""], ["proof (chain)\npicking this:\n  g \\<turnstile> Entry g-ns\\<rightarrow>m\n  \\<not> 2 \\<le> length ns", "have \"m = Entry g\""], ["proof (prove)\nusing this:\n  g \\<turnstile> Entry g-ns\\<rightarrow>m\n  \\<not> 2 \\<le> length ns\n\ngoal (1 subgoal):\n 1. m = Entry g", "by (metis path2_nontrivial)"], ["proof (state)\nthis:\n  m = Entry g\n\ngoal (2 subgoals):\n 1. 2 \\<le> length ns \\<Longrightarrow>\n    lookupDefNode g m (var g v) \\<in> set ns\n 2. \\<not> 2 \\<le> length ns \\<Longrightarrow>\n    lookupDefNode g m (var g v) \\<in> set ns", "with \"3.hyps\"(2)"], ["proof (chain)\npicking this:\n  predecessors g m = [m']\n  m = Entry g", "have False"], ["proof (prove)\nusing this:\n  predecessors g m = [m']\n  m = Entry g\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. 2 \\<le> length ns \\<Longrightarrow>\n    lookupDefNode g m (var g v) \\<in> set ns\n 2. \\<not> 2 \\<le> length ns \\<Longrightarrow>\n    lookupDefNode g m (var g v) \\<in> set ns", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. lookupDefNode g m (var g v) \\<in> set ns", ".."], ["proof (state)\nthis:\n  lookupDefNode g m (var g v) \\<in> set ns\n\ngoal (1 subgoal):\n 1. 2 \\<le> length ns \\<Longrightarrow>\n    lookupDefNode g m (var g v) \\<in> set ns", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 \\<le> length ns \\<Longrightarrow>\n    lookupDefNode g m (var g v) \\<in> set ns", "case True"], ["proof (state)\nthis:\n  2 \\<le> length ns\n\ngoal (1 subgoal):\n 1. 2 \\<le> length ns \\<Longrightarrow>\n    lookupDefNode g m (var g v) \\<in> set ns", "with \"3.prems\""], ["proof (chain)\npicking this:\n  g \\<turnstile> Entry g-ns\\<rightarrow>m\n  2 \\<le> length ns", "have \"g \\<turnstile> Entry g-butlast ns\\<rightarrow>m'\""], ["proof (prove)\nusing this:\n  g \\<turnstile> Entry g-ns\\<rightarrow>m\n  2 \\<le> length ns\n\ngoal (1 subgoal):\n 1. g \\<turnstile> Entry g-butlast ns\\<rightarrow>m'", "by (rule path2_unsnoc) (simp add:\"3.hyps\"(2))"], ["proof (state)\nthis:\n  g \\<turnstile> Entry g-butlast ns\\<rightarrow>m'\n\ngoal (1 subgoal):\n 1. 2 \\<le> length ns \\<Longrightarrow>\n    lookupDefNode g m (var g v) \\<in> set ns", "with \"3.hyps\" \"3.IH\"[of \"butlast ns\"]"], ["proof (chain)\npicking this:\n  var g v \\<notin> defs g m\n  predecessors g m = [m']\n  m' \\<in> set (\\<alpha>n g)\n  lookupDef g m (var g v) = lookupDef g m' (var g v)\n  g \\<turnstile> Entry g-butlast ns\\<rightarrow>m' \\<Longrightarrow>\n  lookupDefNode g m' (var g v) \\<in> set (butlast ns)\n  g \\<turnstile> Entry g-butlast ns\\<rightarrow>m'", "show ?thesis"], ["proof (prove)\nusing this:\n  var g v \\<notin> defs g m\n  predecessors g m = [m']\n  m' \\<in> set (\\<alpha>n g)\n  lookupDef g m (var g v) = lookupDef g m' (var g v)\n  g \\<turnstile> Entry g-butlast ns\\<rightarrow>m' \\<Longrightarrow>\n  lookupDefNode g m' (var g v) \\<in> set (butlast ns)\n  g \\<turnstile> Entry g-butlast ns\\<rightarrow>m'\n\ngoal (1 subgoal):\n 1. lookupDefNode g m (var g v) \\<in> set ns", "by (simp add:in_set_butlastD)"], ["proof (state)\nthis:\n  lookupDefNode g m (var g v) \\<in> set ns\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookupDefNode g m (var g v) \\<in> set ns\n\ngoal (2 subgoals):\n 1. \\<And>ns.\n       \\<lbrakk>var g v \\<in> defs g (lookupDefNode g n (var g v));\n        defKind (lookupDef g n (var g v)) = SimpleDef;\n        g \\<turnstile> Entry\n                        g-ns\\<rightarrow>lookupDefNode g n\n    (var g v)\\<rbrakk>\n       \\<Longrightarrow> lookupDefNode g (lookupDefNode g n (var g v))\n                          (var g v)\n                         \\<in> set ns\n 2. \\<And>ns.\n       \\<lbrakk>var g v \\<notin> defs g (lookupDefNode g n (var g v));\n        length (predecessors g (lookupDefNode g n (var g v))) \\<noteq> 1;\n        defKind (lookupDef g n (var g v)) = PhiDef;\n        g \\<turnstile> Entry\n                        g-ns\\<rightarrow>lookupDefNode g n\n    (var g v)\\<rbrakk>\n       \\<Longrightarrow> lookupDefNode g (lookupDefNode g n (var g v))\n                          (var g v)\n                         \\<in> set ns", "qed auto"], ["proof (state)\nthis:\n  lookupDefNode g n (var g v) \\<in> set ns\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma def_ass_allUses:\n    assumes \"v \\<in> braun_ssa.allUses g n\" \"n \\<in> set (\\<alpha>n g)\"\n    shows \"braun_ssa.defAss g n v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun_ssa.defAss g n v", "proof (rule braun_ssa.defAssI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ns.\n       g \\<turnstile> Entry g-ns\\<rightarrow>n \\<Longrightarrow>\n       \\<exists>n\\<in>set ns. v \\<in> braun_ssa.allDefs g n", "fix ns"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ns.\n       g \\<turnstile> Entry g-ns\\<rightarrow>n \\<Longrightarrow>\n       \\<exists>n\\<in>set ns. v \\<in> braun_ssa.allDefs g n", "assume asm: \"g \\<turnstile> Entry g-ns\\<rightarrow>n\""], ["proof (state)\nthis:\n  g \\<turnstile> Entry g-ns\\<rightarrow>n\n\ngoal (1 subgoal):\n 1. \\<And>ns.\n       g \\<turnstile> Entry g-ns\\<rightarrow>n \\<Longrightarrow>\n       \\<exists>n\\<in>set ns. v \\<in> braun_ssa.allDefs g n", "let ?m = \"lookupDefNode g n (var g v)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ns.\n       g \\<turnstile> Entry g-ns\\<rightarrow>n \\<Longrightarrow>\n       \\<exists>n\\<in>set ns. v \\<in> braun_ssa.allDefs g n", "from asm"], ["proof (chain)\npicking this:\n  g \\<turnstile> Entry g-ns\\<rightarrow>n", "have \"?m \\<in> set ns\""], ["proof (prove)\nusing this:\n  g \\<turnstile> Entry g-ns\\<rightarrow>n\n\ngoal (1 subgoal):\n 1. lookupDefNode g n (var g v) \\<in> set ns", "by (rule def_ass_allUses_aux)"], ["proof (state)\nthis:\n  lookupDefNode g n (var g v) \\<in> set ns\n\ngoal (1 subgoal):\n 1. \\<And>ns.\n       g \\<turnstile> Entry g-ns\\<rightarrow>n \\<Longrightarrow>\n       \\<exists>n\\<in>set ns. v \\<in> braun_ssa.allDefs g n", "moreover"], ["proof (state)\nthis:\n  lookupDefNode g n (var g v) \\<in> set ns\n\ngoal (1 subgoal):\n 1. \\<And>ns.\n       g \\<turnstile> Entry g-ns\\<rightarrow>n \\<Longrightarrow>\n       \\<exists>n\\<in>set ns. v \\<in> braun_ssa.allDefs g n", "from assms allUse_lookupDef"], ["proof (chain)\npicking this:\n  v \\<in> braun_ssa.allUses g n\n  n \\<in> set (\\<alpha>n g)\n  \\<lbrakk>?v \\<in> braun_ssa.allUses ?g ?m;\n   ?m \\<in> set (\\<alpha>n ?g)\\<rbrakk>\n  \\<Longrightarrow> lookupDef ?g ?m (var ?g ?v) = ?v", "have \"?m = defNode v\""], ["proof (prove)\nusing this:\n  v \\<in> braun_ssa.allUses g n\n  n \\<in> set (\\<alpha>n g)\n  \\<lbrakk>?v \\<in> braun_ssa.allUses ?g ?m;\n   ?m \\<in> set (\\<alpha>n ?g)\\<rbrakk>\n  \\<Longrightarrow> lookupDef ?g ?m (var ?g ?v) = ?v\n\ngoal (1 subgoal):\n 1. lookupDefNode g n (var g v) = defNode v", "by simp"], ["proof (state)\nthis:\n  lookupDefNode g n (var g v) = defNode v\n\ngoal (1 subgoal):\n 1. \\<And>ns.\n       g \\<turnstile> Entry g-ns\\<rightarrow>n \\<Longrightarrow>\n       \\<exists>n\\<in>set ns. v \\<in> braun_ssa.allDefs g n", "moreover"], ["proof (state)\nthis:\n  lookupDefNode g n (var g v) = defNode v\n\ngoal (1 subgoal):\n 1. \\<And>ns.\n       g \\<turnstile> Entry g-ns\\<rightarrow>n \\<Longrightarrow>\n       \\<exists>n\\<in>set ns. v \\<in> braun_ssa.allDefs g n", "from assms allUse_implies_allDef"], ["proof (chain)\npicking this:\n  v \\<in> braun_ssa.allUses g n\n  n \\<in> set (\\<alpha>n g)\n  \\<lbrakk>?v \\<in> braun_ssa.allUses ?g ?m;\n   ?m \\<in> set (\\<alpha>n ?g)\\<rbrakk>\n  \\<Longrightarrow> ?v \\<in> braun_ssa.allDefs ?g (defNode ?v)", "have \"v \\<in> braun_ssa.allDefs g (defNode v)\""], ["proof (prove)\nusing this:\n  v \\<in> braun_ssa.allUses g n\n  n \\<in> set (\\<alpha>n g)\n  \\<lbrakk>?v \\<in> braun_ssa.allUses ?g ?m;\n   ?m \\<in> set (\\<alpha>n ?g)\\<rbrakk>\n  \\<Longrightarrow> ?v \\<in> braun_ssa.allDefs ?g (defNode ?v)\n\ngoal (1 subgoal):\n 1. v \\<in> braun_ssa.allDefs g (defNode v)", "by simp"], ["proof (state)\nthis:\n  v \\<in> braun_ssa.allDefs g (defNode v)\n\ngoal (1 subgoal):\n 1. \\<And>ns.\n       g \\<turnstile> Entry g-ns\\<rightarrow>n \\<Longrightarrow>\n       \\<exists>n\\<in>set ns. v \\<in> braun_ssa.allDefs g n", "ultimately"], ["proof (chain)\npicking this:\n  lookupDefNode g n (var g v) \\<in> set ns\n  lookupDefNode g n (var g v) = defNode v\n  v \\<in> braun_ssa.allDefs g (defNode v)", "show \"\\<exists>n\\<in>set ns. v \\<in> braun_ssa.allDefs g n\""], ["proof (prove)\nusing this:\n  lookupDefNode g n (var g v) \\<in> set ns\n  lookupDefNode g n (var g v) = defNode v\n  v \\<in> braun_ssa.allDefs g (defNode v)\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<in>set ns. v \\<in> braun_ssa.allDefs g n", "by auto"], ["proof (state)\nthis:\n  \\<exists>n\\<in>set ns. v \\<in> braun_ssa.allDefs g n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Empty_no_phis:\n    shows \"phis' g (Entry g, v) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phis' g (Entry g, v) = None", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. phis' g (Entry g, v) = None", "have \"\\<And>v. Entry g \\<notin> phiDefNodes g v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v. Entry g \\<notin> phiDefNodes g v", "proof (rule, rule phiDefNodesE, assumption)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v ns m.\n       \\<lbrakk>Entry g \\<in> phiDefNodes g v;\n        g \\<turnstile> Entry g-ns\\<rightarrow>m;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        v \\<in> uses g m\\<rbrakk>\n       \\<Longrightarrow> False", "fix v ns m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v ns m.\n       \\<lbrakk>Entry g \\<in> phiDefNodes g v;\n        g \\<turnstile> Entry g-ns\\<rightarrow>m;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        v \\<in> uses g m\\<rbrakk>\n       \\<Longrightarrow> False", "assume asm: \"g \\<turnstile> Entry g-ns\\<rightarrow>m\" \"\\<forall>n\\<in>set ns. v \\<notin> defs g n\" \"v \\<in> uses g m\""], ["proof (state)\nthis:\n  g \\<turnstile> Entry g-ns\\<rightarrow>m\n  \\<forall>n\\<in>set ns. v \\<notin> defs g n\n  v \\<in> uses g m\n\ngoal (1 subgoal):\n 1. \\<And>v ns m.\n       \\<lbrakk>Entry g \\<in> phiDefNodes g v;\n        g \\<turnstile> Entry g-ns\\<rightarrow>m;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        v \\<in> uses g m\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"m \\<in> set (\\<alpha>n g)\""], ["proof (prove)\nusing this:\n  g \\<turnstile> Entry g-ns\\<rightarrow>m\n  \\<forall>n\\<in>set ns. v \\<notin> defs g n\n  v \\<in> uses g m\n\ngoal (1 subgoal):\n 1. m \\<in> set (\\<alpha>n g)", "by auto"], ["proof (state)\nthis:\n  m \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. \\<And>v ns m.\n       \\<lbrakk>Entry g \\<in> phiDefNodes g v;\n        g \\<turnstile> Entry g-ns\\<rightarrow>m;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        v \\<in> uses g m\\<rbrakk>\n       \\<Longrightarrow> False", "from def_ass_uses[of g, THEN bspec[OF _ this], THEN bspec[OF _ asm(3)]] asm"], ["proof (chain)\npicking this:\n  defAss' g m v\n  g \\<turnstile> Entry g-ns\\<rightarrow>m\n  \\<forall>n\\<in>set ns. v \\<notin> defs g n\n  v \\<in> uses g m", "show False"], ["proof (prove)\nusing this:\n  defAss' g m v\n  g \\<turnstile> Entry g-ns\\<rightarrow>m\n  \\<forall>n\\<in>set ns. v \\<notin> defs g n\n  v \\<in> uses g m\n\ngoal (1 subgoal):\n 1. False", "by (auto elim!:defAss'E)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Entry g \\<notin> phiDefNodes g ?v1\n\ngoal (1 subgoal):\n 1. phis' g (Entry g, v) = None", "thus ?thesis"], ["proof (prove)\nusing this:\n  Entry g \\<notin> phiDefNodes g ?v1\n\ngoal (1 subgoal):\n 1. phis' g (Entry g, v) = None", "by (auto simp:phis'_def split:prod.split)"], ["proof (state)\nthis:\n  phis' g (Entry g, v) = None\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma braun_ssa_CFG_SSA_wf:\n    \"CFG_SSA_wf \\<alpha>e \\<alpha>n invar inEdges' Entry defs' uses' phis'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_SSA_wf \\<alpha>e \\<alpha>n invar inEdges' Entry defs' uses' phis'", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v g n.\n       \\<lbrakk>v \\<in> braun_ssa.allUses g n;\n        n \\<in> set (\\<alpha>n g)\\<rbrakk>\n       \\<Longrightarrow> braun_ssa.defAss g n v\n 2. \\<And>g v. phis' g (Entry g, v) = None", "apply (erule def_ass_allUses, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g v. phis' g (Entry g, v) = None", "apply (rule Empty_no_phis)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sublocale braun_ssa: CFG_SSA_wf \\<alpha>e \\<alpha>n invar inEdges' Entry defs' uses' phis'"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_SSA_wf \\<alpha>e \\<alpha>n invar inEdges' Entry defs' uses' phis'", "by (rule braun_ssa_CFG_SSA_wf)"], ["", "lemma braun_ssa_CFG_SSA_Transformed:\n    \"CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry defs uses defs' uses' phis' var\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry defs uses\n     defs' uses' phis' var", "apply unfold_locales"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>g n. defs g n = var g ` defs' g n\n 2. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       uses g n = var g ` uses' g n\n 3. \\<And>g n ns m v x v'.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m; n \\<notin> set (tl ns);\n        v \\<in> braun_ssa.allDefs g n; v \\<in> braun_ssa.allUses g m;\n        x \\<in> set (tl ns); v' \\<in> braun_ssa.allDefs g x\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v\n 4. \\<And>g n v vs v'.\n       \\<lbrakk>phis' g (n, v) = Some vs; v' \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> var g v' = var g v\n 5. \\<And>n g v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> braun_ssa.allDefs g n;\n        v' \\<in> braun_ssa.allDefs g n; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v", "apply (rule oldDefs_correct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       uses g n = var g ` uses' g n\n 2. \\<And>g n ns m v x v'.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m; n \\<notin> set (tl ns);\n        v \\<in> braun_ssa.allDefs g n; v \\<in> braun_ssa.allUses g m;\n        x \\<in> set (tl ns); v' \\<in> braun_ssa.allDefs g x\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v\n 3. \\<And>g n v vs v'.\n       \\<lbrakk>phis' g (n, v) = Some vs; v' \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> var g v' = var g v\n 4. \\<And>n g v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> braun_ssa.allDefs g n;\n        v' \\<in> braun_ssa.allDefs g n; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v", "apply (erule oldUses_correct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>g n ns m v x v'.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m; n \\<notin> set (tl ns);\n        v \\<in> braun_ssa.allDefs g n; v \\<in> braun_ssa.allUses g m;\n        x \\<in> set (tl ns); v' \\<in> braun_ssa.allDefs g x\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. \\<And>g n v vs v'.\n       \\<lbrakk>phis' g (n, v) = Some vs; v' \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> var g v' = var g v\n 3. \\<And>n g v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> braun_ssa.allDefs g n;\n        v' \\<in> braun_ssa.allDefs g n; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v", "apply (erule conventional, simp, simp, simp, simp, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>g n v vs v'.\n       \\<lbrakk>phis' g (n, v) = Some vs; v' \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> var g v' = var g v\n 2. \\<And>n g v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> braun_ssa.allDefs g n;\n        v' \\<in> braun_ssa.allDefs g n; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v", "apply (erule phis'_fst, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n g v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> braun_ssa.allDefs g n;\n        v' \\<in> braun_ssa.allDefs g n; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v", "apply (erule allDefs_var_disjoint, simp, simp, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "sublocale braun_ssa: CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry \"defs\" \"uses\" defs' uses' phis' var"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry defs uses\n     defs' uses' phis' var", "by (rule braun_ssa_CFG_SSA_Transformed)"], ["", "lemma PhiDef_defNode_eq:\n    assumes \"n \\<in> set (\\<alpha>n g)\" \"n \\<in> phiDefNodes g v\" \"v \\<in> vars g\"\n    shows \"braun_ssa.defNode g (v,n,PhiDef) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun_ssa.defNode g (v, n, PhiDef) = n", "using assms"], ["proof (prove)\nusing this:\n  n \\<in> set (\\<alpha>n g)\n  n \\<in> phiDefNodes g v\n  v \\<in> vars g\n\ngoal (1 subgoal):\n 1. braun_ssa.defNode g (v, n, PhiDef) = n", "by - (rule braun_ssa.defNode_eq, rule assms(1), subst braun_ssa.allDefs_def, subst braun_ssa.phiDefs_def, auto simp: phis'_def)"], ["", "lemma phiDefNodes_aux_pruned_aux:\n    assumes \"n \\<in> phiDefNodes_aux g v (\\<alpha>n g) nUse\" \"v \\<in> uses g nUse\" \"g \\<turnstile> n-ns\\<rightarrow>m\" \"g \\<turnstile>m-ms\\<rightarrow>nUse\" \"braun_ssa.liveVal g (lookupDef g m v)\" \"\\<forall>n \\<in> set (ns@ms). v \\<notin> defs g n\"\n    shows \"braun_ssa.liveVal g (v,n,PhiDef)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun_ssa.liveVal g (v, n, PhiDef)", "using assms(3-)"], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  g \\<turnstile> m-ms\\<rightarrow>nUse\n  braun_ssa.liveVal g (lookupDef g m v)\n  \\<forall>n\\<in>set (ns @ ms). v \\<notin> defs g n\n\ngoal (1 subgoal):\n 1. braun_ssa.liveVal g (v, n, PhiDef)", "proof (induction n ns m arbitrary:ms rule:path2_rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ms.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g);\n        g \\<turnstile> n-ms\\<rightarrow>nUse;\n        braun_ssa.liveVal g (lookupDef g n v);\n        \\<forall>n\\<in>set ([n] @ ms). v \\<notin> defs g n\\<rbrakk>\n       \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)\n 2. \\<And>ns m' m ms.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m';\n        \\<And>ms.\n           \\<lbrakk>g \\<turnstile> m'-ms\\<rightarrow>nUse;\n            braun_ssa.liveVal g (lookupDef g m' v);\n            \\<forall>n\\<in>set (ns @ ms). v \\<notin> defs g n\\<rbrakk>\n           \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef);\n        m' \\<in> set (predecessors g m);\n        g \\<turnstile> m-ms\\<rightarrow>nUse;\n        braun_ssa.liveVal g (lookupDef g m v);\n        \\<forall>n\\<in>set ((ns @ [m]) @ ms). v \\<notin> defs g n\\<rbrakk>\n       \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)", "case empty"], ["proof (state)\nthis:\n  n \\<in> set (\\<alpha>n g)\n  g \\<turnstile> n-ms\\<rightarrow>nUse\n  braun_ssa.liveVal g (lookupDef g n v)\n  \\<forall>n\\<in>set ([n] @ ms). v \\<notin> defs g n\n\ngoal (2 subgoals):\n 1. \\<And>ms.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g);\n        g \\<turnstile> n-ms\\<rightarrow>nUse;\n        braun_ssa.liveVal g (lookupDef g n v);\n        \\<forall>n\\<in>set ([n] @ ms). v \\<notin> defs g n\\<rbrakk>\n       \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)\n 2. \\<And>ns m' m ms.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m';\n        \\<And>ms.\n           \\<lbrakk>g \\<turnstile> m'-ms\\<rightarrow>nUse;\n            braun_ssa.liveVal g (lookupDef g m' v);\n            \\<forall>n\\<in>set (ns @ ms). v \\<notin> defs g n\\<rbrakk>\n           \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef);\n        m' \\<in> set (predecessors g m);\n        g \\<turnstile> m-ms\\<rightarrow>nUse;\n        braun_ssa.liveVal g (lookupDef g m v);\n        \\<forall>n\\<in>set ((ns @ [m]) @ ms). v \\<notin> defs g n\\<rbrakk>\n       \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)", "with assms(1)"], ["proof (chain)\npicking this:\n  n \\<in> phiDefNodes_aux g v (\\<alpha>n g) nUse\n  n \\<in> set (\\<alpha>n g)\n  g \\<turnstile> n-ms\\<rightarrow>nUse\n  braun_ssa.liveVal g (lookupDef g n v)\n  \\<forall>n\\<in>set ([n] @ ms). v \\<notin> defs g n", "have \"lookupDef g n v = (v,n,PhiDef)\""], ["proof (prove)\nusing this:\n  n \\<in> phiDefNodes_aux g v (\\<alpha>n g) nUse\n  n \\<in> set (\\<alpha>n g)\n  g \\<turnstile> n-ms\\<rightarrow>nUse\n  braun_ssa.liveVal g (lookupDef g n v)\n  \\<forall>n\\<in>set ([n] @ ms). v \\<notin> defs g n\n\ngoal (1 subgoal):\n 1. lookupDef g n v = (v, n, PhiDef)", "by -(drule phiDefNode_aux_is_join_node, cases rule:lookupDef_cases, auto)"], ["proof (state)\nthis:\n  lookupDef g n v = (v, n, PhiDef)\n\ngoal (2 subgoals):\n 1. \\<And>ms.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g);\n        g \\<turnstile> n-ms\\<rightarrow>nUse;\n        braun_ssa.liveVal g (lookupDef g n v);\n        \\<forall>n\\<in>set ([n] @ ms). v \\<notin> defs g n\\<rbrakk>\n       \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)\n 2. \\<And>ns m' m ms.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m';\n        \\<And>ms.\n           \\<lbrakk>g \\<turnstile> m'-ms\\<rightarrow>nUse;\n            braun_ssa.liveVal g (lookupDef g m' v);\n            \\<forall>n\\<in>set (ns @ ms). v \\<notin> defs g n\\<rbrakk>\n           \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef);\n        m' \\<in> set (predecessors g m);\n        g \\<turnstile> m-ms\\<rightarrow>nUse;\n        braun_ssa.liveVal g (lookupDef g m v);\n        \\<forall>n\\<in>set ((ns @ [m]) @ ms). v \\<notin> defs g n\\<rbrakk>\n       \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)", "with empty.prems(2)"], ["proof (chain)\npicking this:\n  braun_ssa.liveVal g (lookupDef g n v)\n  lookupDef g n v = (v, n, PhiDef)", "show ?case"], ["proof (prove)\nusing this:\n  braun_ssa.liveVal g (lookupDef g n v)\n  lookupDef g n v = (v, n, PhiDef)\n\ngoal (1 subgoal):\n 1. braun_ssa.liveVal g (v, n, PhiDef)", "by simp"], ["proof (state)\nthis:\n  braun_ssa.liveVal g (v, n, PhiDef)\n\ngoal (1 subgoal):\n 1. \\<And>ns m' m ms.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m';\n        \\<And>ms.\n           \\<lbrakk>g \\<turnstile> m'-ms\\<rightarrow>nUse;\n            braun_ssa.liveVal g (lookupDef g m' v);\n            \\<forall>n\\<in>set (ns @ ms). v \\<notin> defs g n\\<rbrakk>\n           \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef);\n        m' \\<in> set (predecessors g m);\n        g \\<turnstile> m-ms\\<rightarrow>nUse;\n        braun_ssa.liveVal g (lookupDef g m v);\n        \\<forall>n\\<in>set ((ns @ [m]) @ ms). v \\<notin> defs g n\\<rbrakk>\n       \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ns m' m ms.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m';\n        \\<And>ms.\n           \\<lbrakk>g \\<turnstile> m'-ms\\<rightarrow>nUse;\n            braun_ssa.liveVal g (lookupDef g m' v);\n            \\<forall>n\\<in>set (ns @ ms). v \\<notin> defs g n\\<rbrakk>\n           \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef);\n        m' \\<in> set (predecessors g m);\n        g \\<turnstile> m-ms\\<rightarrow>nUse;\n        braun_ssa.liveVal g (lookupDef g m v);\n        \\<forall>n\\<in>set ((ns @ [m]) @ ms). v \\<notin> defs g n\\<rbrakk>\n       \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)", "case (snoc ns m m')"], ["proof (state)\nthis:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  m \\<in> set (predecessors g m')\n  \\<lbrakk>g \\<turnstile> m-?ms1\\<rightarrow>nUse;\n   braun_ssa.liveVal g (lookupDef g m v);\n   \\<forall>n\\<in>set (ns @ ?ms1). v \\<notin> defs g n\\<rbrakk>\n  \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)\n  g \\<turnstile> m'-ms\\<rightarrow>nUse\n  braun_ssa.liveVal g (lookupDef g m' v)\n  \\<forall>n\\<in>set ((ns @ [m']) @ ms). v \\<notin> defs g n\n\ngoal (1 subgoal):\n 1. \\<And>ns m' m ms.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m';\n        \\<And>ms.\n           \\<lbrakk>g \\<turnstile> m'-ms\\<rightarrow>nUse;\n            braun_ssa.liveVal g (lookupDef g m' v);\n            \\<forall>n\\<in>set (ns @ ms). v \\<notin> defs g n\\<rbrakk>\n           \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef);\n        m' \\<in> set (predecessors g m);\n        g \\<turnstile> m-ms\\<rightarrow>nUse;\n        braun_ssa.liveVal g (lookupDef g m v);\n        \\<forall>n\\<in>set ((ns @ [m]) @ ms). v \\<notin> defs g n\\<rbrakk>\n       \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)", "from snoc.prems"], ["proof (chain)\npicking this:\n  g \\<turnstile> m'-ms\\<rightarrow>nUse\n  braun_ssa.liveVal g (lookupDef g m' v)\n  \\<forall>n\\<in>set ((ns @ [m']) @ ms). v \\<notin> defs g n", "have \"m' \\<in> set (\\<alpha>n g)\""], ["proof (prove)\nusing this:\n  g \\<turnstile> m'-ms\\<rightarrow>nUse\n  braun_ssa.liveVal g (lookupDef g m' v)\n  \\<forall>n\\<in>set ((ns @ [m']) @ ms). v \\<notin> defs g n\n\ngoal (1 subgoal):\n 1. m' \\<in> set (\\<alpha>n g)", "by auto"], ["proof (state)\nthis:\n  m' \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. \\<And>ns m' m ms.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m';\n        \\<And>ms.\n           \\<lbrakk>g \\<turnstile> m'-ms\\<rightarrow>nUse;\n            braun_ssa.liveVal g (lookupDef g m' v);\n            \\<forall>n\\<in>set (ns @ ms). v \\<notin> defs g n\\<rbrakk>\n           \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef);\n        m' \\<in> set (predecessors g m);\n        g \\<turnstile> m-ms\\<rightarrow>nUse;\n        braun_ssa.liveVal g (lookupDef g m v);\n        \\<forall>n\\<in>set ((ns @ [m]) @ ms). v \\<notin> defs g n\\<rbrakk>\n       \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)", "thus ?case"], ["proof (prove)\nusing this:\n  m' \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. braun_ssa.liveVal g (v, n, PhiDef)", "proof (cases rule:lookupDef_cases[where v=v])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>v \\<in> defs g m';\n     lookupDef g m' v = (v, m', SimpleDef)\\<rbrakk>\n    \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)\n 2. \\<lbrakk>v \\<notin> defs g m'; length (predecessors g m') \\<noteq> 1;\n     lookupDef g m' v = (v, m', PhiDef)\\<rbrakk>\n    \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)\n 3. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g m'; predecessors g m' = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g m' v = lookupDef g m v\\<rbrakk>\n       \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)", "case SimpleDef"], ["proof (state)\nthis:\n  v \\<in> defs g m'\n  lookupDef g m' v = (v, m', SimpleDef)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>v \\<in> defs g m';\n     lookupDef g m' v = (v, m', SimpleDef)\\<rbrakk>\n    \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)\n 2. \\<lbrakk>v \\<notin> defs g m'; length (predecessors g m') \\<noteq> 1;\n     lookupDef g m' v = (v, m', PhiDef)\\<rbrakk>\n    \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)\n 3. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g m'; predecessors g m' = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g m' v = lookupDef g m v\\<rbrakk>\n       \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)", "with snoc.prems(3)"], ["proof (chain)\npicking this:\n  \\<forall>n\\<in>set ((ns @ [m']) @ ms). v \\<notin> defs g n\n  v \\<in> defs g m'\n  lookupDef g m' v = (v, m', SimpleDef)", "have False"], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>set ((ns @ [m']) @ ms). v \\<notin> defs g n\n  v \\<in> defs g m'\n  lookupDef g m' v = (v, m', SimpleDef)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<lbrakk>v \\<in> defs g m';\n     lookupDef g m' v = (v, m', SimpleDef)\\<rbrakk>\n    \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)\n 2. \\<lbrakk>v \\<notin> defs g m'; length (predecessors g m') \\<noteq> 1;\n     lookupDef g m' v = (v, m', PhiDef)\\<rbrakk>\n    \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)\n 3. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g m'; predecessors g m' = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g m' v = lookupDef g m v\\<rbrakk>\n       \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. braun_ssa.liveVal g (v, n, PhiDef)", ".."], ["proof (state)\nthis:\n  braun_ssa.liveVal g (v, n, PhiDef)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<notin> defs g m'; length (predecessors g m') \\<noteq> 1;\n     lookupDef g m' v = (v, m', PhiDef)\\<rbrakk>\n    \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)\n 2. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g m'; predecessors g m' = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g m' v = lookupDef g m v\\<rbrakk>\n       \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<notin> defs g m'; length (predecessors g m') \\<noteq> 1;\n     lookupDef g m' v = (v, m', PhiDef)\\<rbrakk>\n    \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)\n 2. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g m'; predecessors g m' = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g m' v = lookupDef g m v\\<rbrakk>\n       \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)", "have step: \"braun_ssa.liveVal g (lookupDef g m v) \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun_ssa.liveVal g (lookupDef g m v) \\<Longrightarrow>\n    braun_ssa.liveVal g (v, n, PhiDef)", "proof (rule snoc.IH)"], ["proof (state)\ngoal (3 subgoals):\n 1. braun_ssa.liveVal g (lookupDef g m v) \\<Longrightarrow>\n    g \\<turnstile> m-?ms1\\<rightarrow>nUse\n 2. braun_ssa.liveVal g (lookupDef g m v) \\<Longrightarrow>\n    braun_ssa.liveVal g (lookupDef g m v)\n 3. braun_ssa.liveVal g (lookupDef g m v) \\<Longrightarrow>\n    \\<forall>n\\<in>set (ns @ ?ms1). v \\<notin> defs g n", "from snoc.prems(1) snoc.hyps(2)"], ["proof (chain)\npicking this:\n  g \\<turnstile> m'-ms\\<rightarrow>nUse\n  m \\<in> set (predecessors g m')", "show \"g \\<turnstile> m-m#ms\\<rightarrow>nUse\""], ["proof (prove)\nusing this:\n  g \\<turnstile> m'-ms\\<rightarrow>nUse\n  m \\<in> set (predecessors g m')\n\ngoal (1 subgoal):\n 1. g \\<turnstile> m-m # ms\\<rightarrow>nUse", "by auto"], ["proof (state)\nthis:\n  g \\<turnstile> m-m # ms\\<rightarrow>nUse\n\ngoal (2 subgoals):\n 1. braun_ssa.liveVal g (lookupDef g m v) \\<Longrightarrow>\n    braun_ssa.liveVal g (lookupDef g m v)\n 2. braun_ssa.liveVal g (lookupDef g m v) \\<Longrightarrow>\n    \\<forall>n\\<in>set (ns @ m # ms). v \\<notin> defs g n", "from snoc.prems(3) snoc.hyps(1)"], ["proof (chain)\npicking this:\n  \\<forall>n\\<in>set ((ns @ [m']) @ ms). v \\<notin> defs g n\n  g \\<turnstile> n-ns\\<rightarrow>m", "show \"\\<forall>n\\<in> set(ns @ m # ms). v \\<notin> defs g n\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>set ((ns @ [m']) @ ms). v \\<notin> defs g n\n  g \\<turnstile> n-ns\\<rightarrow>m\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>set (ns @ m # ms). v \\<notin> defs g n", "by auto"], ["proof (state)\nthis:\n  \\<forall>n\\<in>set (ns @ m # ms). v \\<notin> defs g n\n\ngoal (1 subgoal):\n 1. braun_ssa.liveVal g (lookupDef g m v) \\<Longrightarrow>\n    braun_ssa.liveVal g (lookupDef g m v)", "qed"], ["proof (state)\nthis:\n  braun_ssa.liveVal g (lookupDef g m v) \\<Longrightarrow>\n  braun_ssa.liveVal g (v, n, PhiDef)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<notin> defs g m'; length (predecessors g m') \\<noteq> 1;\n     lookupDef g m' v = (v, m', PhiDef)\\<rbrakk>\n    \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)\n 2. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g m'; predecessors g m' = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g m' v = lookupDef g m v\\<rbrakk>\n       \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)", "{"], ["proof (state)\nthis:\n  braun_ssa.liveVal g (lookupDef g m v) \\<Longrightarrow>\n  braun_ssa.liveVal g (v, n, PhiDef)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<notin> defs g m'; length (predecessors g m') \\<noteq> 1;\n     lookupDef g m' v = (v, m', PhiDef)\\<rbrakk>\n    \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)\n 2. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g m'; predecessors g m' = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g m' v = lookupDef g m v\\<rbrakk>\n       \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)", "case rec"], ["proof (state)\nthis:\n  v \\<notin> defs g m'\n  predecessors g m' = [m_]\n  m_ \\<in> set (\\<alpha>n g)\n  lookupDef g m' v = lookupDef g m_ v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<notin> defs g m'; length (predecessors g m') \\<noteq> 1;\n     lookupDef g m' v = (v, m', PhiDef)\\<rbrakk>\n    \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)\n 2. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g m'; predecessors g m' = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g m' v = lookupDef g m v\\<rbrakk>\n       \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)", "from snoc.hyps(2) rec(2)"], ["proof (chain)\npicking this:\n  m \\<in> set (predecessors g m')\n  predecessors g m' = [m_]", "have[simp]: \"predecessors g m' = [m]\""], ["proof (prove)\nusing this:\n  m \\<in> set (predecessors g m')\n  predecessors g m' = [m_]\n\ngoal (1 subgoal):\n 1. predecessors g m' = [m]", "by auto"], ["proof (state)\nthis:\n  predecessors g m' = [m]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<notin> defs g m'; length (predecessors g m') \\<noteq> 1;\n     lookupDef g m' v = (v, m', PhiDef)\\<rbrakk>\n    \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)\n 2. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g m'; predecessors g m' = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g m' v = lookupDef g m v\\<rbrakk>\n       \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)", "with rec snoc.prems(2)"], ["proof (chain)\npicking this:\n  v \\<notin> defs g m'\n  predecessors g m' = [m_]\n  m_ \\<in> set (\\<alpha>n g)\n  lookupDef g m' v = lookupDef g m_ v\n  braun_ssa.liveVal g (lookupDef g m' v)\n  predecessors g m' = [m]", "have \"braun_ssa.liveVal g (lookupDef g m v)\""], ["proof (prove)\nusing this:\n  v \\<notin> defs g m'\n  predecessors g m' = [m_]\n  m_ \\<in> set (\\<alpha>n g)\n  lookupDef g m' v = lookupDef g m_ v\n  braun_ssa.liveVal g (lookupDef g m' v)\n  predecessors g m' = [m]\n\ngoal (1 subgoal):\n 1. braun_ssa.liveVal g (lookupDef g m v)", "by auto"], ["proof (state)\nthis:\n  braun_ssa.liveVal g (lookupDef g m v)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<notin> defs g m'; length (predecessors g m') \\<noteq> 1;\n     lookupDef g m' v = (v, m', PhiDef)\\<rbrakk>\n    \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)\n 2. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g m'; predecessors g m' = [m];\n        m \\<in> set (\\<alpha>n g);\n        lookupDef g m' v = lookupDef g m v\\<rbrakk>\n       \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)", "with step"], ["proof (chain)\npicking this:\n  braun_ssa.liveVal g (lookupDef g m v) \\<Longrightarrow>\n  braun_ssa.liveVal g (v, n, PhiDef)\n  braun_ssa.liveVal g (lookupDef g m v)", "show ?thesis"], ["proof (prove)\nusing this:\n  braun_ssa.liveVal g (lookupDef g m v) \\<Longrightarrow>\n  braun_ssa.liveVal g (v, n, PhiDef)\n  braun_ssa.liveVal g (lookupDef g m v)\n\ngoal (1 subgoal):\n 1. braun_ssa.liveVal g (v, n, PhiDef)", "."], ["proof (state)\nthis:\n  braun_ssa.liveVal g (v, n, PhiDef)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<notin> defs g m'; length (predecessors g m') \\<noteq> 1;\n     lookupDef g m' v = (v, m', PhiDef)\\<rbrakk>\n    \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<notin> defs g m'; length (predecessors g m') \\<noteq> 1;\n     lookupDef g m' v = (v, m', PhiDef)\\<rbrakk>\n    \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)", "case PhiDef"], ["proof (state)\nthis:\n  v \\<notin> defs g m'\n  length (predecessors g m') \\<noteq> 1\n  lookupDef g m' v = (v, m', PhiDef)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<notin> defs g m'; length (predecessors g m') \\<noteq> 1;\n     lookupDef g m' v = (v, m', PhiDef)\\<rbrakk>\n    \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)", "with snoc assms(2)"], ["proof (chain)\npicking this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  m \\<in> set (predecessors g m')\n  \\<lbrakk>g \\<turnstile> m-?ms1\\<rightarrow>nUse;\n   braun_ssa.liveVal g (lookupDef g m v);\n   \\<forall>n\\<in>set (ns @ ?ms1). v \\<notin> defs g n\\<rbrakk>\n  \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)\n  g \\<turnstile> m'-ms\\<rightarrow>nUse\n  braun_ssa.liveVal g (lookupDef g m' v)\n  \\<forall>n\\<in>set ((ns @ [m']) @ ms). v \\<notin> defs g n\n  v \\<in> uses g nUse\n  v \\<notin> defs g m'\n  length (predecessors g m') \\<noteq> 1\n  lookupDef g m' v = (v, m', PhiDef)", "have phiDefNode: \"m' \\<in> phiDefNodes g v\""], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  m \\<in> set (predecessors g m')\n  \\<lbrakk>g \\<turnstile> m-?ms1\\<rightarrow>nUse;\n   braun_ssa.liveVal g (lookupDef g m v);\n   \\<forall>n\\<in>set (ns @ ?ms1). v \\<notin> defs g n\\<rbrakk>\n  \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)\n  g \\<turnstile> m'-ms\\<rightarrow>nUse\n  braun_ssa.liveVal g (lookupDef g m' v)\n  \\<forall>n\\<in>set ((ns @ [m']) @ ms). v \\<notin> defs g n\n  v \\<in> uses g nUse\n  v \\<notin> defs g m'\n  length (predecessors g m') \\<noteq> 1\n  lookupDef g m' v = (v, m', PhiDef)\n\ngoal (1 subgoal):\n 1. m' \\<in> phiDefNodes g v", "by -(rule phiDefNodesI, auto)"], ["proof (state)\nthis:\n  m' \\<in> phiDefNodes g v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<notin> defs g m'; length (predecessors g m') \\<noteq> 1;\n     lookupDef g m' v = (v, m', PhiDef)\\<rbrakk>\n    \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)", "from assms(2,4)"], ["proof (chain)\npicking this:\n  v \\<in> uses g nUse\n  g \\<turnstile> m-ms\\<rightarrow>nUse", "have vars: \"v \\<in> vars g\""], ["proof (prove)\nusing this:\n  v \\<in> uses g nUse\n  g \\<turnstile> m-ms\\<rightarrow>nUse\n\ngoal (1 subgoal):\n 1. v \\<in> vars g", "by auto"], ["proof (state)\nthis:\n  v \\<in> vars g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<notin> defs g m'; length (predecessors g m') \\<noteq> 1;\n     lookupDef g m' v = (v, m', PhiDef)\\<rbrakk>\n    \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)", "have \"braun_ssa.liveVal g (lookupDef g m v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun_ssa.liveVal g (lookupDef g m v)", "proof (rule braun_ssa.livePhi)"], ["proof (state)\ngoal (2 subgoals):\n 1. braun_ssa.liveVal g ?v\n 2. braun_ssa.phiArg g ?v (lookupDef g m v)", "from PhiDef(3) snoc.prems(2)"], ["proof (chain)\npicking this:\n  lookupDef g m' v = (v, m', PhiDef)\n  braun_ssa.liveVal g (lookupDef g m' v)", "show \"braun_ssa.liveVal g (v,m',PhiDef)\""], ["proof (prove)\nusing this:\n  lookupDef g m' v = (v, m', PhiDef)\n  braun_ssa.liveVal g (lookupDef g m' v)\n\ngoal (1 subgoal):\n 1. braun_ssa.liveVal g (v, m', PhiDef)", "by simp"], ["proof (state)\nthis:\n  braun_ssa.liveVal g (v, m', PhiDef)\n\ngoal (1 subgoal):\n 1. braun_ssa.phiArg g (v, m', PhiDef) (lookupDef g m v)", "from phiDefNode snoc.hyps(2) vars"], ["proof (chain)\npicking this:\n  m' \\<in> phiDefNodes g v\n  m \\<in> set (predecessors g m')\n  v \\<in> vars g", "show \"braun_ssa.phiArg g (v,m',PhiDef) (lookupDef g m v)\""], ["proof (prove)\nusing this:\n  m' \\<in> phiDefNodes g v\n  m \\<in> set (predecessors g m')\n  v \\<in> vars g\n\ngoal (1 subgoal):\n 1. braun_ssa.phiArg g (v, m', PhiDef) (lookupDef g m v)", "by (subst braun_ssa.phiArg_def, subst braun_ssa.phi_def, subst PhiDef_defNode_eq, auto simp: phis'_def)"], ["proof (state)\nthis:\n  braun_ssa.phiArg g (v, m', PhiDef) (lookupDef g m v)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  braun_ssa.liveVal g (lookupDef g m v)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<notin> defs g m'; length (predecessors g m') \\<noteq> 1;\n     lookupDef g m' v = (v, m', PhiDef)\\<rbrakk>\n    \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)", "thus ?thesis"], ["proof (prove)\nusing this:\n  braun_ssa.liveVal g (lookupDef g m v)\n\ngoal (1 subgoal):\n 1. braun_ssa.liveVal g (v, n, PhiDef)", "by (rule step)"], ["proof (state)\nthis:\n  braun_ssa.liveVal g (v, n, PhiDef)\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>v \\<notin> defs g m'; length (predecessors g m') \\<noteq> 1;\n   lookupDef g m' v = (v, m', PhiDef)\\<rbrakk>\n  \\<Longrightarrow> braun_ssa.liveVal g (v, n, PhiDef)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  braun_ssa.liveVal g (v, n, PhiDef)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma phiDefNodes_aux_pruned:\n    assumes \"m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n\" \"n \\<in> set (\\<alpha>n g)\" \"v \\<in> uses g n\"\n    shows \"braun_ssa.liveVal g (v, m, PhiDef)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun_ssa.liveVal g (v, m, PhiDef)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. braun_ssa.liveVal g (v, m, PhiDef)", "from assms(1,2)"], ["proof (chain)\npicking this:\n  m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n\n  n \\<in> set (\\<alpha>n g)", "obtain ns where ns: \"g \\<turnstile> m-ns\\<rightarrow>n\" \"\\<forall>n \\<in> set ns. v \\<notin> defs g n\""], ["proof (prove)\nusing this:\n  m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n\n  n \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        \\<lbrakk>g \\<turnstile> m-ns\\<rightarrow>n;\n         \\<forall>n\\<in>set ns. v \\<notin> defs g n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule phiDefNodes_auxE)"], ["proof (state)\nthis:\n  g \\<turnstile> m-ns\\<rightarrow>n\n  \\<forall>n\\<in>set ns. v \\<notin> defs g n\n\ngoal (1 subgoal):\n 1. braun_ssa.liveVal g (v, m, PhiDef)", "hence \"v \\<notin> defs g n\""], ["proof (prove)\nusing this:\n  g \\<turnstile> m-ns\\<rightarrow>n\n  \\<forall>n\\<in>set ns. v \\<notin> defs g n\n\ngoal (1 subgoal):\n 1. v \\<notin> defs g n", "by (auto dest:path2_last simp: path2_not_Nil)"], ["proof (state)\nthis:\n  v \\<notin> defs g n\n\ngoal (1 subgoal):\n 1. braun_ssa.liveVal g (v, m, PhiDef)", "with ns assms(1,3)"], ["proof (chain)\npicking this:\n  g \\<turnstile> m-ns\\<rightarrow>n\n  \\<forall>n\\<in>set ns. v \\<notin> defs g n\n  m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n\n  v \\<in> uses g n\n  v \\<notin> defs g n", "show ?thesis"], ["proof (prove)\nusing this:\n  g \\<turnstile> m-ns\\<rightarrow>n\n  \\<forall>n\\<in>set ns. v \\<notin> defs g n\n  m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n\n  v \\<in> uses g n\n  v \\<notin> defs g n\n\ngoal (1 subgoal):\n 1. braun_ssa.liveVal g (v, m, PhiDef)", "apply-"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<turnstile> m-ns\\<rightarrow>n;\n     \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n     m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n; v \\<in> uses g n;\n     v \\<notin> defs g n\\<rbrakk>\n    \\<Longrightarrow> braun_ssa.liveVal g (v, m, PhiDef)", "proof (rule phiDefNodes_aux_pruned_aux)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<lbrakk>g \\<turnstile> m-ns\\<rightarrow>n;\n     \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n     m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n; v \\<in> uses g n;\n     v \\<notin> defs g n\\<rbrakk>\n    \\<Longrightarrow> m \\<in> phiDefNodes_aux g v (\\<alpha>n g) ?nUse5\n 2. \\<lbrakk>g \\<turnstile> m-ns\\<rightarrow>n;\n     \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n     m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n; v \\<in> uses g n;\n     v \\<notin> defs g n\\<rbrakk>\n    \\<Longrightarrow> v \\<in> uses g ?nUse5\n 3. \\<lbrakk>g \\<turnstile> m-ns\\<rightarrow>n;\n     \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n     m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n; v \\<in> uses g n;\n     v \\<notin> defs g n\\<rbrakk>\n    \\<Longrightarrow> g \\<turnstile> m-?ns5\\<rightarrow>?m5\n 4. \\<lbrakk>g \\<turnstile> m-ns\\<rightarrow>n;\n     \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n     m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n; v \\<in> uses g n;\n     v \\<notin> defs g n\\<rbrakk>\n    \\<Longrightarrow> g \\<turnstile> ?m5-?ms5\\<rightarrow>?nUse5\n 5. \\<lbrakk>g \\<turnstile> m-ns\\<rightarrow>n;\n     \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n     m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n; v \\<in> uses g n;\n     v \\<notin> defs g n\\<rbrakk>\n    \\<Longrightarrow> braun_ssa.liveVal g (lookupDef g ?m5 v)\n 6. \\<lbrakk>g \\<turnstile> m-ns\\<rightarrow>n;\n     \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n     m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n; v \\<in> uses g n;\n     v \\<notin> defs g n\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n\\<in>set (?ns5 @ ?ms5). v \\<notin> defs g n", "from assms(2,3)"], ["proof (chain)\npicking this:\n  n \\<in> set (\\<alpha>n g)\n  v \\<in> uses g n", "show \"braun_ssa.liveVal g (lookupDef g n v)\""], ["proof (prove)\nusing this:\n  n \\<in> set (\\<alpha>n g)\n  v \\<in> uses g n\n\ngoal (1 subgoal):\n 1. braun_ssa.liveVal g (lookupDef g n v)", "by -(rule braun_ssa.liveSimple, auto simp add:uses'_def)"], ["proof (state)\nthis:\n  braun_ssa.liveVal g (lookupDef g n v)\n\ngoal (5 subgoals):\n 1. \\<lbrakk>g \\<turnstile> m-ns\\<rightarrow>n;\n     \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n     m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n; v \\<in> uses g n;\n     v \\<notin> defs g n\\<rbrakk>\n    \\<Longrightarrow> m \\<in> phiDefNodes_aux g v (\\<alpha>n g) ?nUse5\n 2. \\<lbrakk>g \\<turnstile> m-ns\\<rightarrow>n;\n     \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n     m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n; v \\<in> uses g n;\n     v \\<notin> defs g n\\<rbrakk>\n    \\<Longrightarrow> v \\<in> uses g ?nUse5\n 3. \\<lbrakk>g \\<turnstile> m-ns\\<rightarrow>n;\n     \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n     m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n; v \\<in> uses g n;\n     v \\<notin> defs g n\\<rbrakk>\n    \\<Longrightarrow> g \\<turnstile> m-?ns5\\<rightarrow>n\n 4. \\<lbrakk>g \\<turnstile> m-ns\\<rightarrow>n;\n     \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n     m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n; v \\<in> uses g n;\n     v \\<notin> defs g n\\<rbrakk>\n    \\<Longrightarrow> g \\<turnstile> n-?ms5\\<rightarrow>?nUse5\n 5. \\<lbrakk>g \\<turnstile> m-ns\\<rightarrow>n;\n     \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n     m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n; v \\<in> uses g n;\n     v \\<notin> defs g n\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n\\<in>set (?ns5 @ ?ms5). v \\<notin> defs g n", "qed auto"], ["proof (state)\nthis:\n  braun_ssa.liveVal g (v, m, PhiDef)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem phis'_pruned: \"braun_ssa.pruned g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. braun_ssa.pruned g", "unfolding braun_ssa.pruned_def braun_ssa.phiDefs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>set (\\<alpha>n g).\n       \\<forall>val.\n          val \\<in> {v. (n, v) \\<in> dom (phis' g)} \\<longrightarrow>\n          braun_ssa.liveVal g val", "apply (subst phis'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>set (\\<alpha>n g).\n       \\<forall>val.\n          val\n          \\<in> {v. (n, v)\n                    \\<in> dom (\\<lambda>(n, v, m, def).\n                                  if m = n \\<and>\n                                     n \\<in> phiDefNodes g v \\<and>\n                                     v \\<in> vars g \\<and> def = PhiDef\n                                  then Some\n  (map (\\<lambda>m. lookupDef g m v) (predecessors g n))\n                                  else None)} \\<longrightarrow>\n          braun_ssa.liveVal g val", "by (auto split:prod.splits if_split_asm simp add:phiDefNodes_def elim!:fold_union_elem phiDefNodes_aux_pruned)"], ["", "declare var_def[simp del]"], ["", "declare no_disjoint_cycle [simp del]"], ["", "declare lookupDef_looksup [simp del]"], ["", "declare lookupDef.simps [code]"], ["", "declare phiDefNodes_aux.simps [code]"], ["", "declare phiDefNodes_def [code]"], ["", "declare defs'_def [code]"], ["", "declare uses'_def [code]"], ["", "declare phis'_def [code]"], ["", "declare predecessors_def [code]"], ["", "end"], ["", "end"]]}