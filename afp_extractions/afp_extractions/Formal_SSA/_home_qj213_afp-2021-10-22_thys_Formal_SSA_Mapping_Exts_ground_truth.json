{"file_name": "/home/qj213/afp-2021-10-22/thys/Formal_SSA/Mapping_Exts.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Formal_SSA", "problem_names": ["lemma lookup_map_keys: \"Mapping.lookup (map_keys f m) x = (if f -` {x} \\<noteq> {} then Mapping.lookup m (THE k. f -` {x} = {k}) else None)\"", "lemma Mapping_Mapping_lookup [simp, code_unfold]: \"Mapping.Mapping (Mapping.lookup m) = m\"", "lemma Mapping_eq_lookup: \"m = m' \\<longleftrightarrow> Mapping.lookup m = Mapping.lookup m'\"", "lemma map_of_map_if_conv:\n  \"map_of (map (\\<lambda>k. (k, f k)) xs) x = (if (x \\<in> set xs) then Some (f x) else None)\"", "lemma Mapping_lookup_map: \"Mapping.lookup (Mapping.map f g m) a = map_option g (Mapping.lookup m (f a))\"", "lemma Mapping_lookup_map_default: \"Mapping.lookup (Mapping.map_default k d f m) k' = (if k = k'\n  then (Some \\<circ> f) (case Mapping.lookup m k of None \\<Rightarrow> d | Some x \\<Rightarrow> x)\n  else Mapping.lookup m k')\"", "lemma Mapping_lookup_mapping_add: \"Mapping.lookup (mapping_add m1 m2) k =\n  case_option (Mapping.lookup m1 k) Some (Mapping.lookup m2 k)\"", "lemma Mapping_lookup_map_values: \"Mapping.lookup (map_values f m) k =\n  Option.bind (Mapping.lookup m k) (f k)\"", "lemma lookup_fold_update [simp]: \"Mapping.lookup (fold (\\<lambda>n. Mapping.update n (g n)) xs m) x\n  = (if (x \\<in> set xs) then Some (g x) else Mapping.lookup m x)\"", "lemma mapping_eq_iff: \"m1 = m2 \\<longleftrightarrow> (\\<forall>k. Mapping.lookup m1 k = Mapping.lookup m2 k)\"", "lemma lookup_delete: \"Mapping.lookup (Mapping.delete k m) k' = (if k = k' then None else Mapping.lookup m k')\"", "lemma keys_map_values: \"Mapping.keys (map_values f m) = Mapping.keys m - {k\\<in>Mapping.keys m. f k (the (Mapping.lookup m k)) = None}\"", "lemma map_default_eq: \"Mapping.map_default k v f m = m \\<longleftrightarrow> (\\<exists>v. Mapping.lookup m k = Some v \\<and> f v = v)\"", "lemma lookup_update_cases: \"Mapping.lookup (Mapping.update k v m) k' = (if k=k' then Some v else Mapping.lookup m k')\""], "translations": [["", "lemma lookup_map_keys: \"Mapping.lookup (map_keys f m) x = (if f -` {x} \\<noteq> {} then Mapping.lookup m (THE k. f -` {x} = {k}) else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup (map_keys f m) x =\n    (if f -` {x} \\<noteq> {} then Mapping.lookup m (THE k. f -` {x} = {k})\n     else None)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f m x.\n       (if f -` {x} \\<noteq> {} then m (THE k. f -` {x} = {k}) else None) =\n       (if f -` {x} \\<noteq> {} then m (THE k. f -` {x} = {k}) else None)", ".."], ["", "lemma Mapping_Mapping_lookup [simp, code_unfold]: \"Mapping.Mapping (Mapping.lookup m) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping (Mapping.lookup m) = m", "by transfer simp"], ["", "declare Mapping.lookup.abs_eq[simp]"], ["", "lemma Mapping_eq_lookup: \"m = m' \\<longleftrightarrow> Mapping.lookup m = Mapping.lookup m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m = m') = (Mapping.lookup m = Mapping.lookup m')", "by transfer simp"], ["", "lemma map_of_map_if_conv:\n  \"map_of (map (\\<lambda>k. (k, f k)) xs) x = (if (x \\<in> set xs) then Some (f x) else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>k. (k, f k)) xs) x =\n    (if x \\<in> set xs then Some (f x) else None)", "by (clarsimp simp: map_of_map_restrict)"], ["", "lemma Mapping_lookup_map: \"Mapping.lookup (Mapping.map f g m) a = map_option g (Mapping.lookup m (f a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup (Mapping.map f g m) a =\n    map_option g (Mapping.lookup m (f a))", "by transfer simp"], ["", "lemma Mapping_lookup_map_default: \"Mapping.lookup (Mapping.map_default k d f m) k' = (if k = k'\n  then (Some \\<circ> f) (case Mapping.lookup m k of None \\<Rightarrow> d | Some x \\<Rightarrow> x)\n  else Mapping.lookup m k')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup (Mapping.map_default k d f m) k' =\n    (if k = k'\n     then (Some \\<circ> f)\n           (case Mapping.lookup m k of None \\<Rightarrow> d\n            | Some x \\<Rightarrow> x)\n     else Mapping.lookup m k')", "unfolding Mapping.map_default_def Mapping.default_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup\n     (Mapping.map_entry k f\n       (if k \\<in> Mapping.keys m then m else Mapping.update k d m))\n     k' =\n    (if k = k'\n     then (Some \\<circ> f)\n           (case Mapping.lookup m k of None \\<Rightarrow> d\n            | Some x \\<Rightarrow> x)\n     else Mapping.lookup m k')", "by transfer auto"], ["", "lemma Mapping_lookup_mapping_add: \"Mapping.lookup (mapping_add m1 m2) k =\n  case_option (Mapping.lookup m1 k) Some (Mapping.lookup m2 k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup (mapping_add m1 m2) k =\n    (case Mapping.lookup m2 k of None \\<Rightarrow> Mapping.lookup m1 k\n     | Some x \\<Rightarrow> Some x)", "by transfer (simp add: map_add_def)"], ["", "lemma Mapping_lookup_map_values: \"Mapping.lookup (map_values f m) k =\n  Option.bind (Mapping.lookup m k) (f k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup (map_values f m) k =\n    Option.bind (Mapping.lookup m k) (f k)", "by transfer simp"], ["", "lemma lookup_fold_update [simp]: \"Mapping.lookup (fold (\\<lambda>n. Mapping.update n (g n)) xs m) x\n  = (if (x \\<in> set xs) then Some (g x) else Mapping.lookup m x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup (fold (\\<lambda>n. Mapping.update n (g n)) xs m) x =\n    (if x \\<in> set xs then Some (g x) else Mapping.lookup m x)", "by transfer (rule fold_update_conv)"], ["", "lemma mapping_eq_iff: \"m1 = m2 \\<longleftrightarrow> (\\<forall>k. Mapping.lookup m1 k = Mapping.lookup m2 k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m1 = m2) = (\\<forall>k. Mapping.lookup m1 k = Mapping.lookup m2 k)", "by transfer auto"], ["", "lemma lookup_delete: \"Mapping.lookup (Mapping.delete k m) k' = (if k = k' then None else Mapping.lookup m k')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup (Mapping.delete k m) k' =\n    (if k = k' then None else Mapping.lookup m k')", "by transfer auto"], ["", "lemma keys_map_values: \"Mapping.keys (map_values f m) = Mapping.keys m - {k\\<in>Mapping.keys m. f k (the (Mapping.lookup m k)) = None}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.keys (map_values f m) =\n    Mapping.keys m -\n    {k \\<in> Mapping.keys m. f k (the (Mapping.lookup m k)) = None}", "by transfer (auto simp add: bind_eq_Some_conv)"], ["", "lemma map_default_eq: \"Mapping.map_default k v f m = m \\<longleftrightarrow> (\\<exists>v. Mapping.lookup m k = Some v \\<and> f v = v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mapping.map_default k v f m = m) =\n    (\\<exists>v. Mapping.lookup m k = Some v \\<and> f v = v)", "apply (clarsimp simp: Mapping.map_default_def Mapping.default_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (k \\<in> Mapping.keys m \\<longrightarrow>\n     (Mapping.map_entry k f m = m) =\n     (\\<exists>v. Mapping.lookup m k = Some v \\<and> f v = v)) \\<and>\n    (k \\<notin> Mapping.keys m \\<longrightarrow>\n     (Mapping.map_entry k f (Mapping.update k v m) = m) =\n     (\\<exists>v. Mapping.lookup m k = Some v \\<and> f v = v))", "by transfer' (auto simp: fun_eq_iff split: if_splits)"], ["", "lemma lookup_update_cases: \"Mapping.lookup (Mapping.update k v m) k' = (if k=k' then Some v else Mapping.lookup m k')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup (Mapping.update k v m) k' =\n    (if k = k' then Some v else Mapping.lookup m k')", "by (cases \"k=k'\", simp_all add: Mapping.lookup_update Mapping.lookup_update_neq)"], ["", "end"]]}