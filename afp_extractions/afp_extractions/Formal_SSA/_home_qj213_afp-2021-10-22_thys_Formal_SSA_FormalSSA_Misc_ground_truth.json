{"file_name": "/home/qj213/afp-2021-10-22/thys/Formal_SSA/FormalSSA_Misc.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Formal_SSA", "problem_names": ["lemma length_1_last_hd: \"length ns = 1 \\<Longrightarrow> last ns = hd ns\"", "lemma not_in_butlast[simp]: \"\\<lbrakk>x \\<in> set ys; x \\<notin> set (butlast ys)\\<rbrakk> \\<Longrightarrow> x = last ys\"", "lemma in_set_butlastI: \"x \\<in> set xs \\<Longrightarrow> x \\<noteq> last xs \\<Longrightarrow> x \\<in> set (butlast xs)\"", "lemma butlast_strict_prefix: \"xs \\<noteq> [] \\<Longrightarrow> strict_prefix (butlast xs) xs\"", "lemma set_tl: \"set (tl xs) \\<subseteq> set xs\"", "lemma in_set_tlD[elim]: \"x \\<in> set (tl xs) \\<Longrightarrow> x \\<in> set xs\"", "lemma suffix_unsnoc:\n  assumes \"suffix xs ys\" \"xs \\<noteq> []\"\n  obtains x where \"xs = butlast xs@[x]\" \"ys = butlast ys@[x]\"", "lemma prefix_split_first:\n  assumes \"x \\<in> set xs\"\n  obtains as where \"prefix (as@[x]) xs\" and \"x \\<notin> set as\"", "lemma in_prefix[elim]:\n  assumes \"prefix xs ys\" and \"x \\<in> set xs\"\n  shows \"x \\<in> set ys\"", "lemma strict_prefix_butlast:\n  assumes \"prefix xs (butlast ys)\" \"ys \\<noteq> []\"\n  shows \"strict_prefix xs ys\"", "lemma prefix_tl_subset: \"prefix xs ys \\<Longrightarrow> set (tl xs) \\<subseteq> set (tl ys)\"", "lemma suffix_tl_subset: \"suffix xs ys \\<Longrightarrow> set (tl xs) \\<subseteq> set (tl ys)\"", "lemma set_tl_append': \"set (tl (xs @ ys)) \\<subseteq> set (tl xs) \\<union> set ys\"", "lemma last_in_tl: \"length xs > 1 \\<Longrightarrow> last xs \\<in> set (tl xs)\"", "lemma concat_join: \"xs \\<noteq> [] \\<Longrightarrow> ys \\<noteq> [] \\<Longrightarrow> last xs = hd ys \\<Longrightarrow> butlast xs@ys = xs@tl ys\"", "lemma fold_induct[case_names Nil Cons]: \"P s \\<Longrightarrow> (\\<And>x s. x \\<in> set xs \\<Longrightarrow> P s \\<Longrightarrow> P (f x s)) \\<Longrightarrow> P (fold f xs s)\"", "lemma fold_union_elem:\n  assumes \"x \\<in> fold (\\<union>) xss xs\"\n  obtains ys where \"x \\<in> ys\" \"ys \\<in> set xss \\<union> {xs}\"", "lemma fold_union_elemI:\n  assumes \"x \\<in> ys\" \"ys \\<in> set xss \\<union> {xs}\"\n  shows \"x \\<in> fold (\\<union>) xss xs\"", "lemma fold_union_elemI':\n  assumes \"x \\<in> xs \\<or> (\\<exists>xs \\<in> set xss. x \\<in> xs)\"\n  shows \"x \\<in> fold (\\<union>) xss xs\"", "lemma fold_union_finite[intro!]:\n  assumes \"finite xs\" \"\\<forall>xs \\<in> set xss. finite xs\"\n  shows \"finite (fold (\\<union>) xss xs)\"", "lemma in_set_zip_map:\n  assumes \"(x,y) \\<in> set (zip xs (map f ys))\"\n  obtains y' where \"(x,y') \\<in> set (zip xs ys)\" \"f y' = y\"", "lemma dom_comp_subset: \"g ` dom (f \\<circ> g) \\<subseteq> dom f\"", "lemma finite_dom_comp:\n  assumes \"finite (dom f)\" \"inj_on g (dom (f \\<circ> g))\"\n  shows \"finite (dom (f \\<circ> g))\"", "lemma the1_list: \"\\<exists>!x \\<in> set xs. P x \\<Longrightarrow> (THE x. x \\<in> set xs \\<and> P x) = hd (filter P xs)\"", "lemma set_zip_leftI:\n  assumes \"length xs = length ys\"\n  assumes \"y \\<in> set ys\"\n  obtains x where \"(x,y) \\<in> set (zip xs ys)\"", "lemma butlast_idx:\n  assumes \"y \\<in> set (butlast xs)\"\n  obtains i where \"xs ! i = y\" \"i < length xs - 1\"", "lemma butlast_idx':\n  assumes \"xs ! i = y\" \"i < length xs - 1\" \"length xs > 1\"\n  shows \"y \\<in> set (butlast xs)\"", "lemma card_eq_1_singleton:\n  assumes \"card A = 1\"\n  obtains x where \"A = {x}\"", "lemma set_take_two:\n  assumes \"card A \\<ge> 2\"\n  obtains x y where \"x \\<in> A\" \"y \\<in> A\" \"x \\<noteq> y\"", "lemma singleton_list_hd_last: \"length xs = 1 \\<Longrightarrow> hd xs = last xs\"", "lemma distinct_hd_tl: \"distinct xs \\<Longrightarrow> hd xs \\<notin> set (tl xs)\"", "lemma set_mono_strict_prefix: \"strict_prefix xs ys \\<Longrightarrow> set xs \\<subseteq> set (butlast ys)\"", "lemma set_butlast_distinct: \"distinct xs \\<Longrightarrow> set (butlast xs) \\<inter> {last xs} = {}\"", "lemma disjoint_elem[elim]: \"A \\<inter> B = {} \\<Longrightarrow> x \\<in> A \\<Longrightarrow> x \\<notin> B\"", "lemma prefix_butlastD[elim]: \"prefix xs (butlast ys) \\<Longrightarrow> prefix xs ys\"", "lemma butlast_prefix: \"prefix xs ys \\<Longrightarrow> prefix (butlast xs) (butlast ys)\"", "lemma hd_in_butlast: \"length xs > 1 \\<Longrightarrow> hd xs \\<in> set (butlast xs)\"", "lemma nonsimple_length_gt_1: \"xs \\<noteq> [] \\<Longrightarrow> hd xs \\<noteq> last xs \\<Longrightarrow> length xs > 1\"", "lemma set_hd_tl: \"xs \\<noteq> [] \\<Longrightarrow> set [hd xs] \\<union> set (tl xs) = set xs\"", "lemma fold_update_conv:\n  \"fold (\\<lambda>n m. m(n \\<mapsto> g n)) xs m x =\n  (if (x \\<in> set xs) then Some (g x) else m x)\"", "lemmas removeAll_le = length_removeAll_less_eq", "lemmas removeAll_less [intro] = length_removeAll_less", "lemma removeAll_induct:\n  assumes \"\\<And>xs. (\\<And>x. x \\<in> set xs \\<Longrightarrow> P (removeAll x xs)) \\<Longrightarrow> P xs\"\n  shows \"P xs\"", "lemma The_Min: \"Ex1 P \\<Longrightarrow> The P = Min {x. P x}\"", "lemma The_Max: \"Ex1 P \\<Longrightarrow> The P = Max {x. P x}\"", "lemma set_sorted_list_of_set_remove [simp]:\n\"set (sorted_list_of_set (Set.remove x A)) = Set.remove x (set (sorted_list_of_set A))\"", "lemma set_minus_one: \"\\<lbrakk>v \\<noteq> v'; v' \\<in> set vs\\<rbrakk> \\<Longrightarrow> set vs - {v'} \\<subseteq> {v} \\<longleftrightarrow> set vs = {v'} \\<or> set vs = {v,v'}\"", "lemma set_single_hd: \"set vs = {v} \\<Longrightarrow> hd vs = v\"", "lemma set_double_filter_hd: \"\\<lbrakk> set vs = {v,v'}; v \\<noteq> v' \\<rbrakk> \\<Longrightarrow> hd [v'\\<leftarrow>vs . v' \\<noteq> v] = v'\"", "lemma map_option_the: \"x = map_option f y \\<Longrightarrow> x \\<noteq> None \\<Longrightarrow> the x = f (the y)\""], "translations": [["", "lemma length_1_last_hd: \"length ns = 1 \\<Longrightarrow> last ns = hd ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ns = 1 \\<Longrightarrow> last ns = hd ns", "by (metis One_nat_def append.simps(1) append_butlast_last_id diff_Suc_Suc diff_zero length_0_conv length_butlast list.sel(1) zero_neq_one)"], ["", "lemma not_in_butlast[simp]: \"\\<lbrakk>x \\<in> set ys; x \\<notin> set (butlast ys)\\<rbrakk> \\<Longrightarrow> x = last ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set ys; x \\<notin> set (butlast ys)\\<rbrakk>\n    \\<Longrightarrow> x = last ys", "apply (cases \"ys = []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> set ys; x \\<notin> set (butlast ys); ys = []\\<rbrakk>\n    \\<Longrightarrow> x = last ys\n 2. \\<lbrakk>x \\<in> set ys; x \\<notin> set (butlast ys);\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> x = last ys", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set ys; x \\<notin> set (butlast ys);\n     ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> x = last ys", "apply (subst(asm) append_butlast_last_id[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<notin> set (butlast ys); ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> ys \\<noteq> []\n 2. \\<lbrakk>x \\<in> set (butlast ys @ [last ys]);\n     x \\<notin> set (butlast ys); ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> x = last ys", "by (simp_all del:append_butlast_last_id)"], ["", "lemma in_set_butlastI: \"x \\<in> set xs \\<Longrightarrow> x \\<noteq> last xs \\<Longrightarrow> x \\<in> set (butlast xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> set xs; x \\<noteq> last xs\\<rbrakk>\n    \\<Longrightarrow> x \\<in> set (butlast xs)", "by (metis append_butlast_last_id append_is_Nil_conv list.distinct(1) rotate1.simps(2) set_ConsD set_rotate1 split_list)"], ["", "lemma butlast_strict_prefix: \"xs \\<noteq> [] \\<Longrightarrow> strict_prefix (butlast xs) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> strict_prefix (butlast xs) xs", "by (metis append_butlast_last_id strict_prefixI')"], ["", "lemma set_tl: \"set (tl xs) \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (tl xs) \\<subseteq> set xs", "by (metis set_mono_suffix suffix_tl)"], ["", "lemma in_set_tlD[elim]: \"x \\<in> set (tl xs) \\<Longrightarrow> x \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (tl xs) \\<Longrightarrow> x \\<in> set xs", "using set_tl[of xs]"], ["proof (prove)\nusing this:\n  set (tl xs) \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. x \\<in> set (tl xs) \\<Longrightarrow> x \\<in> set xs", "by auto"], ["", "lemma suffix_unsnoc:\n  assumes \"suffix xs ys\" \"xs \\<noteq> []\"\n  obtains x where \"xs = butlast xs@[x]\" \"ys = butlast ys@[x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>xs = butlast xs @ [x]; ys = butlast ys @ [x]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis append_butlast_last_id append_is_Nil_conv assms(1) assms(2) last_appendR suffix_def)"], ["", "lemma prefix_split_first:\n  assumes \"x \\<in> set xs\"\n  obtains as where \"prefix (as@[x]) xs\" and \"x \\<notin> set as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>prefix (as @ [x]) xs; x \\<notin> set as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof atomize_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as. prefix (as @ [x]) xs \\<and> x \\<notin> set as", "from assms"], ["proof (chain)\npicking this:\n  x \\<in> set xs", "obtain as bs where \"xs = as@x#bs \\<and> x \\<notin> set as\""], ["proof (prove)\nusing this:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>as bs.\n        xs = as @ x # bs \\<and> x \\<notin> set as \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (atomize_elim, rule split_list_first)"], ["proof (state)\nthis:\n  xs = as @ x # bs \\<and> x \\<notin> set as\n\ngoal (1 subgoal):\n 1. \\<exists>as. prefix (as @ [x]) xs \\<and> x \\<notin> set as", "thus \"\\<exists>as. prefix (as@[x]) xs \\<and> x \\<notin> set as\""], ["proof (prove)\nusing this:\n  xs = as @ x # bs \\<and> x \\<notin> set as\n\ngoal (1 subgoal):\n 1. \\<exists>as. prefix (as @ [x]) xs \\<and> x \\<notin> set as", "by -(rule exI[where x = as], auto)"], ["proof (state)\nthis:\n  \\<exists>as. prefix (as @ [x]) xs \\<and> x \\<notin> set as\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma in_prefix[elim]:\n  assumes \"prefix xs ys\" and \"x \\<in> set xs\"\n  shows \"x \\<in> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set ys", "using assms"], ["proof (prove)\nusing this:\n  prefix xs ys\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. x \\<in> set ys", "by (auto elim!:prefixE)"], ["", "lemma strict_prefix_butlast:\n  assumes \"prefix xs (butlast ys)\" \"ys \\<noteq> []\"\n  shows \"strict_prefix xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_prefix xs ys", "using assms"], ["proof (prove)\nusing this:\n  prefix xs (butlast ys)\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. strict_prefix xs ys", "unfolding append_butlast_last_id[symmetric]"], ["proof (prove)\nusing this:\n  prefix xs (butlast ys)\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. strict_prefix xs ys", "by (auto simp add:less_le butlast_strict_prefix prefix_order.le_less_trans)"], ["", "lemma prefix_tl_subset: \"prefix xs ys \\<Longrightarrow> set (tl xs) \\<subseteq> set (tl ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix xs ys \\<Longrightarrow> set (tl xs) \\<subseteq> set (tl ys)", "by (metis Nil_tl prefix_bot.bot.extremum prefix_def set_mono_prefix tl_append2)"], ["", "lemma suffix_tl_subset: \"suffix xs ys \\<Longrightarrow> set (tl xs) \\<subseteq> set (tl ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. suffix xs ys \\<Longrightarrow> set (tl xs) \\<subseteq> set (tl ys)", "by (metis append_Nil suffix_def set_mono_suffix suffix_tl suffix_order.order_trans tl_append2)"], ["", "lemma set_tl_append': \"set (tl (xs @ ys)) \\<subseteq> set (tl xs) \\<union> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (tl (xs @ ys)) \\<subseteq> set (tl xs) \\<union> set ys", "by (metis list.sel(2) order_refl set_append set_mono_suffix suffix_tl tl_append2)"], ["", "lemma last_in_tl: \"length xs > 1 \\<Longrightarrow> last xs \\<in> set (tl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length xs \\<Longrightarrow> last xs \\<in> set (tl xs)", "by (metis One_nat_def diff_Suc_Suc last_in_set last_tl length_tl less_numeral_extra(4) list.size(3) zero_less_diff)"], ["", "lemma concat_join: \"xs \\<noteq> [] \\<Longrightarrow> ys \\<noteq> [] \\<Longrightarrow> last xs = hd ys \\<Longrightarrow> butlast xs@ys = xs@tl ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; ys \\<noteq> []; last xs = hd ys\\<rbrakk>\n    \\<Longrightarrow> butlast xs @ ys = xs @ tl ys", "by (induction xs, auto)"], ["", "lemma fold_induct[case_names Nil Cons]: \"P s \\<Longrightarrow> (\\<And>x s. x \\<in> set xs \\<Longrightarrow> P s \\<Longrightarrow> P (f x s)) \\<Longrightarrow> P (fold f xs s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P s;\n     \\<And>x s.\n        \\<lbrakk>x \\<in> set xs; P s\\<rbrakk>\n        \\<Longrightarrow> P (f x s)\\<rbrakk>\n    \\<Longrightarrow> P (fold f xs s)", "by (rule fold_invariant [where Q = \"\\<lambda>x. x \\<in> set xs\"]) simp"], ["", "lemma fold_union_elem:\n  assumes \"x \\<in> fold (\\<union>) xss xs\"\n  obtains ys where \"x \\<in> ys\" \"ys \\<in> set xss \\<union> {xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>x \\<in> ys; ys \\<in> set xss \\<union> {xs}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> fold (\\<union>) xss xs\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>x \\<in> ys; ys \\<in> set xss \\<union> {xs}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (induction rule:fold_induct) auto"], ["", "lemma fold_union_elemI:\n  assumes \"x \\<in> ys\" \"ys \\<in> set xss \\<union> {xs}\"\n  shows \"x \\<in> fold (\\<union>) xss xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> fold (\\<union>) xss xs", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> ys\n  ys \\<in> set xss \\<union> {xs}\n\ngoal (1 subgoal):\n 1. x \\<in> fold (\\<union>) xss xs", "by (metis Sup_empty Sup_insert Sup_set_fold Un_insert_right UnionI ccpo_Sup_singleton fold_simps(2) list.simps(15))"], ["", "lemma fold_union_elemI':\n  assumes \"x \\<in> xs \\<or> (\\<exists>xs \\<in> set xss. x \\<in> xs)\"\n  shows \"x \\<in> fold (\\<union>) xss xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> fold (\\<union>) xss xs", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> xs \\<or> (\\<exists>xs\\<in>set xss. x \\<in> xs)\n\ngoal (1 subgoal):\n 1. x \\<in> fold (\\<union>) xss xs", "using fold_union_elemI"], ["proof (prove)\nusing this:\n  x \\<in> xs \\<or> (\\<exists>xs\\<in>set xss. x \\<in> xs)\n  \\<lbrakk>?x \\<in> ?ys; ?ys \\<in> set ?xss \\<union> {?xs}\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> fold (\\<union>) ?xss ?xs\n\ngoal (1 subgoal):\n 1. x \\<in> fold (\\<union>) xss xs", "by fastforce"], ["", "lemma fold_union_finite[intro!]:\n  assumes \"finite xs\" \"\\<forall>xs \\<in> set xss. finite xs\"\n  shows \"finite (fold (\\<union>) xss xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (fold (\\<union>) xss xs)", "using assms"], ["proof (prove)\nusing this:\n  finite xs\n  \\<forall>xs\\<in>set xss. finite xs\n\ngoal (1 subgoal):\n 1. finite (fold (\\<union>) xss xs)", "by - (rule fold_invariant, auto)"], ["", "lemma in_set_zip_map:\n  assumes \"(x,y) \\<in> set (zip xs (map f ys))\"\n  obtains y' where \"(x,y') \\<in> set (zip xs ys)\" \"f y' = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y'.\n        \\<lbrakk>(x, y') \\<in> set (zip xs ys); f y' = y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>y'.\n        \\<lbrakk>(x, y') \\<in> set (zip xs ys); f y' = y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  (x, y) \\<in> set (zip xs (map f ys))", "obtain i where \"x = xs ! i\" \"y = map f ys ! i\" \"i < length xs\" \"i < length ys\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> set (zip xs (map f ys))\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>x = xs ! i; y = map f ys ! i; i < length xs;\n         i < length ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp:set_zip)"], ["proof (state)\nthis:\n  x = xs ! i\n  y = map f ys ! i\n  i < length xs\n  i < length ys\n\ngoal (1 subgoal):\n 1. (\\<And>y'.\n        \\<lbrakk>(x, y') \\<in> set (zip xs ys); f y' = y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus thesis"], ["proof (prove)\nusing this:\n  x = xs ! i\n  y = map f ys ! i\n  i < length xs\n  i < length ys\n\ngoal (1 subgoal):\n 1. thesis", "by - (rule that[of \"ys ! i\"], auto simp:set_zip)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dom_comp_subset: \"g ` dom (f \\<circ> g) \\<subseteq> dom f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g ` dom (f \\<circ> g) \\<subseteq> dom f", "by (auto simp add:dom_def)"], ["", "lemma finite_dom_comp:\n  assumes \"finite (dom f)\" \"inj_on g (dom (f \\<circ> g))\"\n  shows \"finite (dom (f \\<circ> g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom (f \\<circ> g))", "proof (rule finite_imageD)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (?f ` dom (f \\<circ> g))\n 2. inj_on ?f (dom (f \\<circ> g))", "have \"g ` dom (f \\<circ> g) \\<subseteq> dom f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g ` dom (f \\<circ> g) \\<subseteq> dom f", "by auto"], ["proof (state)\nthis:\n  g ` dom (f \\<circ> g) \\<subseteq> dom f\n\ngoal (2 subgoals):\n 1. finite (?f ` dom (f \\<circ> g))\n 2. inj_on ?f (dom (f \\<circ> g))", "with assms(1)"], ["proof (chain)\npicking this:\n  finite (dom f)\n  g ` dom (f \\<circ> g) \\<subseteq> dom f", "show \"finite (g ` dom (f \\<circ> g))\""], ["proof (prove)\nusing this:\n  finite (dom f)\n  g ` dom (f \\<circ> g) \\<subseteq> dom f\n\ngoal (1 subgoal):\n 1. finite (g ` dom (f \\<circ> g))", "by - (rule finite_subset)"], ["proof (state)\nthis:\n  finite (g ` dom (f \\<circ> g))\n\ngoal (1 subgoal):\n 1. inj_on g (dom (f \\<circ> g))", "qed (simp add:assms(2))"], ["", "lemma the1_list: \"\\<exists>!x \\<in> set xs. P x \\<Longrightarrow> (THE x. x \\<in> set xs \\<and> P x) = hd (filter P xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!x. x \\<in> set xs \\<and> P x \\<Longrightarrow>\n    (THE x. x \\<in> set xs \\<and> P x) = hd (filter P xs)", "proof (induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>!x. x \\<in> set [] \\<and> P x \\<Longrightarrow>\n    (THE x. x \\<in> set [] \\<and> P x) = hd (filter P [])\n 2. \\<And>a xs.\n       \\<lbrakk>\\<exists>!x. x \\<in> set xs \\<and> P x \\<Longrightarrow>\n                (THE x. x \\<in> set xs \\<and> P x) = hd (filter P xs);\n        \\<exists>!x. x \\<in> set (a # xs) \\<and> P x\\<rbrakk>\n       \\<Longrightarrow> (THE x. x \\<in> set (a # xs) \\<and> P x) =\n                         hd (filter P (a # xs))", "case (Cons y xs)"], ["proof (state)\nthis:\n  \\<exists>!x. x \\<in> set xs \\<and> P x \\<Longrightarrow>\n  (THE x. x \\<in> set xs \\<and> P x) = hd (filter P xs)\n  \\<exists>!x. x \\<in> set (y # xs) \\<and> P x\n\ngoal (2 subgoals):\n 1. \\<exists>!x. x \\<in> set [] \\<and> P x \\<Longrightarrow>\n    (THE x. x \\<in> set [] \\<and> P x) = hd (filter P [])\n 2. \\<And>a xs.\n       \\<lbrakk>\\<exists>!x. x \\<in> set xs \\<and> P x \\<Longrightarrow>\n                (THE x. x \\<in> set xs \\<and> P x) = hd (filter P xs);\n        \\<exists>!x. x \\<in> set (a # xs) \\<and> P x\\<rbrakk>\n       \\<Longrightarrow> (THE x. x \\<in> set (a # xs) \\<and> P x) =\n                         hd (filter P (a # xs))", "let ?Q = \"\\<lambda>xs x. x \\<in> set xs \\<and> P x\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>!x. x \\<in> set [] \\<and> P x \\<Longrightarrow>\n    (THE x. x \\<in> set [] \\<and> P x) = hd (filter P [])\n 2. \\<And>a xs.\n       \\<lbrakk>\\<exists>!x. x \\<in> set xs \\<and> P x \\<Longrightarrow>\n                (THE x. x \\<in> set xs \\<and> P x) = hd (filter P xs);\n        \\<exists>!x. x \\<in> set (a # xs) \\<and> P x\\<rbrakk>\n       \\<Longrightarrow> (THE x. x \\<in> set (a # xs) \\<and> P x) =\n                         hd (filter P (a # xs))", "from Cons.prems"], ["proof (chain)\npicking this:\n  \\<exists>!x. x \\<in> set (y # xs) \\<and> P x", "obtain x where x: \"?Q (y#xs) x\""], ["proof (prove)\nusing this:\n  \\<exists>!x. x \\<in> set (y # xs) \\<and> P x\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> set (y # xs) \\<and> P x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> set (y # xs) \\<and> P x\n\ngoal (2 subgoals):\n 1. \\<exists>!x. x \\<in> set [] \\<and> P x \\<Longrightarrow>\n    (THE x. x \\<in> set [] \\<and> P x) = hd (filter P [])\n 2. \\<And>a xs.\n       \\<lbrakk>\\<exists>!x. x \\<in> set xs \\<and> P x \\<Longrightarrow>\n                (THE x. x \\<in> set xs \\<and> P x) = hd (filter P xs);\n        \\<exists>!x. x \\<in> set (a # xs) \\<and> P x\\<rbrakk>\n       \\<Longrightarrow> (THE x. x \\<in> set (a # xs) \\<and> P x) =\n                         hd (filter P (a # xs))", "have \"x = hd (filter P (y#xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = hd (filter P (y # xs))", "proof (cases \"x=y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> x = hd (filter P (y # xs))\n 2. x \\<noteq> y \\<Longrightarrow> x = hd (filter P (y # xs))", "case True"], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> x = hd (filter P (y # xs))\n 2. x \\<noteq> y \\<Longrightarrow> x = hd (filter P (y # xs))", "with x"], ["proof (chain)\npicking this:\n  x \\<in> set (y # xs) \\<and> P x\n  x = y", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> set (y # xs) \\<and> P x\n  x = y\n\ngoal (1 subgoal):\n 1. x = hd (filter P (y # xs))", "by auto"], ["proof (state)\nthis:\n  x = hd (filter P (y # xs))\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> x = hd (filter P (y # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> x = hd (filter P (y # xs))", "case False"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> x = hd (filter P (y # xs))", "with Cons.prems x"], ["proof (chain)\npicking this:\n  \\<exists>!x. x \\<in> set (y # xs) \\<and> P x\n  x \\<in> set (y # xs) \\<and> P x\n  x \\<noteq> y", "have 1: \"\\<exists>!x. x \\<in> set xs \\<and> P x\""], ["proof (prove)\nusing this:\n  \\<exists>!x. x \\<in> set (y # xs) \\<and> P x\n  x \\<in> set (y # xs) \\<and> P x\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<exists>!x. x \\<in> set xs \\<and> P x", "by auto"], ["proof (state)\nthis:\n  \\<exists>!x. x \\<in> set xs \\<and> P x\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> x = hd (filter P (y # xs))", "hence \"(THE x. x \\<in> set xs \\<and> P x) = x\""], ["proof (prove)\nusing this:\n  \\<exists>!x. x \\<in> set xs \\<and> P x\n\ngoal (1 subgoal):\n 1. (THE x. x \\<in> set xs \\<and> P x) = x", "using x False"], ["proof (prove)\nusing this:\n  \\<exists>!x. x \\<in> set xs \\<and> P x\n  x \\<in> set (y # xs) \\<and> P x\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. (THE x. x \\<in> set xs \\<and> P x) = x", "by - (rule the1_equality, auto)"], ["proof (state)\nthis:\n  (THE x. x \\<in> set xs \\<and> P x) = x\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> x = hd (filter P (y # xs))", "also"], ["proof (state)\nthis:\n  (THE x. x \\<in> set xs \\<and> P x) = x\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> x = hd (filter P (y # xs))", "from 1"], ["proof (chain)\npicking this:\n  \\<exists>!x. x \\<in> set xs \\<and> P x", "have \"(THE x. x \\<in> set xs \\<and> P x) = hd (filter P xs)\""], ["proof (prove)\nusing this:\n  \\<exists>!x. x \\<in> set xs \\<and> P x\n\ngoal (1 subgoal):\n 1. (THE x. x \\<in> set xs \\<and> P x) = hd (filter P xs)", "by (rule Cons.IH)"], ["proof (state)\nthis:\n  (THE x. x \\<in> set xs \\<and> P x) = hd (filter P xs)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> x = hd (filter P (y # xs))", "finally"], ["proof (chain)\npicking this:\n  hd (filter P xs) = x", "show ?thesis"], ["proof (prove)\nusing this:\n  hd (filter P xs) = x\n\ngoal (1 subgoal):\n 1. x = hd (filter P (y # xs))", "using False x Cons.prems"], ["proof (prove)\nusing this:\n  hd (filter P xs) = x\n  x \\<noteq> y\n  x \\<in> set (y # xs) \\<and> P x\n  \\<exists>!x. x \\<in> set (y # xs) \\<and> P x\n\ngoal (1 subgoal):\n 1. x = hd (filter P (y # xs))", "by auto"], ["proof (state)\nthis:\n  x = hd (filter P (y # xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = hd (filter P (y # xs))\n\ngoal (2 subgoals):\n 1. \\<exists>!x. x \\<in> set [] \\<and> P x \\<Longrightarrow>\n    (THE x. x \\<in> set [] \\<and> P x) = hd (filter P [])\n 2. \\<And>a xs.\n       \\<lbrakk>\\<exists>!x. x \\<in> set xs \\<and> P x \\<Longrightarrow>\n                (THE x. x \\<in> set xs \\<and> P x) = hd (filter P xs);\n        \\<exists>!x. x \\<in> set (a # xs) \\<and> P x\\<rbrakk>\n       \\<Longrightarrow> (THE x. x \\<in> set (a # xs) \\<and> P x) =\n                         hd (filter P (a # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  x = hd (filter P (y # xs))\n\ngoal (1 subgoal):\n 1. (THE x. x \\<in> set (y # xs) \\<and> P x) = hd (filter P (y # xs))", "using x"], ["proof (prove)\nusing this:\n  x = hd (filter P (y # xs))\n  x \\<in> set (y # xs) \\<and> P x\n\ngoal (1 subgoal):\n 1. (THE x. x \\<in> set (y # xs) \\<and> P x) = hd (filter P (y # xs))", "by - (rule the1_equality[OF Cons.prems], auto)"], ["proof (state)\nthis:\n  (THE x. x \\<in> set (y # xs) \\<and> P x) = hd (filter P (y # xs))\n\ngoal (1 subgoal):\n 1. \\<exists>!x. x \\<in> set [] \\<and> P x \\<Longrightarrow>\n    (THE x. x \\<in> set [] \\<and> P x) = hd (filter P [])", "qed auto"], ["", "lemma set_zip_leftI:\n  assumes \"length xs = length ys\"\n  assumes \"y \\<in> set ys\"\n  obtains x where \"(x,y) \\<in> set (zip xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        (x, y) \\<in> set (zip xs ys) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        (x, y) \\<in> set (zip xs ys) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from assms(2)"], ["proof (chain)\npicking this:\n  y \\<in> set ys", "obtain i where \"y = ys ! i\" \"i < length ys\""], ["proof (prove)\nusing this:\n  y \\<in> set ys\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>y = ys ! i; i < length ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  y = ys ! i\n  i < length ys\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        (x, y) \\<in> set (zip xs ys) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "with assms(1)"], ["proof (chain)\npicking this:\n  length xs = length ys\n  y = ys ! i\n  i < length ys", "show thesis"], ["proof (prove)\nusing this:\n  length xs = length ys\n  y = ys ! i\n  i < length ys\n\ngoal (1 subgoal):\n 1. thesis", "by - (rule that[of \"xs ! i\"], auto simp add:set_zip)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma butlast_idx:\n  assumes \"y \\<in> set (butlast xs)\"\n  obtains i where \"xs ! i = y\" \"i < length xs - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>xs ! i = y; i < length xs - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. xs ! i = y \\<and> i < length xs - 1", "using assms"], ["proof (prove)\nusing this:\n  y \\<in> set (butlast xs)\n\ngoal (1 subgoal):\n 1. \\<exists>i. xs ! i = y \\<and> i < length xs - 1", "proof (induction xs arbitrary:y)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> set (butlast []) \\<Longrightarrow>\n       \\<exists>i. [] ! i = y \\<and> i < length [] - 1\n 2. \\<And>a xs y.\n       \\<lbrakk>\\<And>y.\n                   y \\<in> set (butlast xs) \\<Longrightarrow>\n                   \\<exists>i. xs ! i = y \\<and> i < length xs - 1;\n        y \\<in> set (butlast (a # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            (a # xs) ! i = y \\<and> i < length (a # xs) - 1", "case (Cons x xs)"], ["proof (state)\nthis:\n  ?y \\<in> set (butlast xs) \\<Longrightarrow>\n  \\<exists>i. xs ! i = ?y \\<and> i < length xs - 1\n  y \\<in> set (butlast (x # xs))\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> set (butlast []) \\<Longrightarrow>\n       \\<exists>i. [] ! i = y \\<and> i < length [] - 1\n 2. \\<And>a xs y.\n       \\<lbrakk>\\<And>y.\n                   y \\<in> set (butlast xs) \\<Longrightarrow>\n                   \\<exists>i. xs ! i = y \\<and> i < length xs - 1;\n        y \\<in> set (butlast (a # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            (a # xs) ! i = y \\<and> i < length (a # xs) - 1", "from Cons.prems"], ["proof (chain)\npicking this:\n  y \\<in> set (butlast (x # xs))", "have[simp]: \"xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  y \\<in> set (butlast (x # xs))\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by (simp split:if_split_asm)"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> set (butlast []) \\<Longrightarrow>\n       \\<exists>i. [] ! i = y \\<and> i < length [] - 1\n 2. \\<And>a xs y.\n       \\<lbrakk>\\<And>y.\n                   y \\<in> set (butlast xs) \\<Longrightarrow>\n                   \\<exists>i. xs ! i = y \\<and> i < length xs - 1;\n        y \\<in> set (butlast (a # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            (a # xs) ! i = y \\<and> i < length (a # xs) - 1", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. (x # xs) ! i = y \\<and> i < length (x # xs) - 1", "proof (cases \"y = x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow>\n    \\<exists>i. (x # xs) ! i = y \\<and> i < length (x # xs) - 1\n 2. y \\<noteq> x \\<Longrightarrow>\n    \\<exists>i. (x # xs) ! i = y \\<and> i < length (x # xs) - 1", "case True"], ["proof (state)\nthis:\n  y = x\n\ngoal (2 subgoals):\n 1. y = x \\<Longrightarrow>\n    \\<exists>i. (x # xs) ! i = y \\<and> i < length (x # xs) - 1\n 2. y \\<noteq> x \\<Longrightarrow>\n    \\<exists>i. (x # xs) ! i = y \\<and> i < length (x # xs) - 1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. (x # xs) ! i = y \\<and> i < length (x # xs) - 1", "by (rule exI[where x=0], simp_all add:True)"], ["proof (state)\nthis:\n  \\<exists>i. (x # xs) ! i = y \\<and> i < length (x # xs) - 1\n\ngoal (1 subgoal):\n 1. y \\<noteq> x \\<Longrightarrow>\n    \\<exists>i. (x # xs) ! i = y \\<and> i < length (x # xs) - 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<noteq> x \\<Longrightarrow>\n    \\<exists>i. (x # xs) ! i = y \\<and> i < length (x # xs) - 1", "case False"], ["proof (state)\nthis:\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. y \\<noteq> x \\<Longrightarrow>\n    \\<exists>i. (x # xs) ! i = y \\<and> i < length (x # xs) - 1", "with Cons.prems"], ["proof (chain)\npicking this:\n  y \\<in> set (butlast (x # xs))\n  y \\<noteq> x", "have \"y \\<in> set (butlast xs)\""], ["proof (prove)\nusing this:\n  y \\<in> set (butlast (x # xs))\n  y \\<noteq> x\n\ngoal (1 subgoal):\n 1. y \\<in> set (butlast xs)", "by simp"], ["proof (state)\nthis:\n  y \\<in> set (butlast xs)\n\ngoal (1 subgoal):\n 1. y \\<noteq> x \\<Longrightarrow>\n    \\<exists>i. (x # xs) ! i = y \\<and> i < length (x # xs) - 1", "from Cons.IH[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>i. xs ! i = y \\<and> i < length xs - 1", "obtain i where \"y = xs ! i\" and \"i < length xs - 1\""], ["proof (prove)\nusing this:\n  \\<exists>i. xs ! i = y \\<and> i < length xs - 1\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>y = xs ! i; i < length xs - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y = xs ! i\n  i < length xs - 1\n\ngoal (1 subgoal):\n 1. y \\<noteq> x \\<Longrightarrow>\n    \\<exists>i. (x # xs) ! i = y \\<and> i < length (x # xs) - 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = xs ! i\n  i < length xs - 1\n\ngoal (1 subgoal):\n 1. \\<exists>i. (x # xs) ! i = y \\<and> i < length (x # xs) - 1", "by - (rule exI[where x=\"Suc i\"], simp)"], ["proof (state)\nthis:\n  \\<exists>i. (x # xs) ! i = y \\<and> i < length (x # xs) - 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i. (x # xs) ! i = y \\<and> i < length (x # xs) - 1\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> set (butlast []) \\<Longrightarrow>\n       \\<exists>i. [] ! i = y \\<and> i < length [] - 1", "qed simp"], ["", "lemma butlast_idx':\n  assumes \"xs ! i = y\" \"i < length xs - 1\" \"length xs > 1\"\n  shows \"y \\<in> set (butlast xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> set (butlast xs)", "using assms"], ["proof (prove)\nusing this:\n  xs ! i = y\n  i < length xs - 1\n  1 < length xs\n\ngoal (1 subgoal):\n 1. y \\<in> set (butlast xs)", "proof (induction xs arbitrary:i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>[] ! i = y; i < length [] - 1; 1 < length []\\<rbrakk>\n       \\<Longrightarrow> y \\<in> set (butlast [])\n 2. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>xs ! i = y; i < length xs - 1;\n                    1 < length xs\\<rbrakk>\n                   \\<Longrightarrow> y \\<in> set (butlast xs);\n        (a # xs) ! i = y; i < length (a # xs) - 1;\n        1 < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> y \\<in> set (butlast (a # xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>xs ! ?i = y; ?i < length xs - 1; 1 < length xs\\<rbrakk>\n  \\<Longrightarrow> y \\<in> set (butlast xs)\n  (x # xs) ! i = y\n  i < length (x # xs) - 1\n  1 < length (x # xs)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>[] ! i = y; i < length [] - 1; 1 < length []\\<rbrakk>\n       \\<Longrightarrow> y \\<in> set (butlast [])\n 2. \\<And>a xs i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>xs ! i = y; i < length xs - 1;\n                    1 < length xs\\<rbrakk>\n                   \\<Longrightarrow> y \\<in> set (butlast xs);\n        (a # xs) ! i = y; i < length (a # xs) - 1;\n        1 < length (a # xs)\\<rbrakk>\n       \\<Longrightarrow> y \\<in> set (butlast (a # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> set (butlast (x # xs))", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> y \\<in> set (butlast (x # xs))\n 2. \\<And>nat. i = Suc nat \\<Longrightarrow> y \\<in> set (butlast (x # xs))", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> y \\<in> set (butlast (x # xs))\n 2. \\<And>nat. i = Suc nat \\<Longrightarrow> y \\<in> set (butlast (x # xs))", "with Cons.prems(1,3)"], ["proof (chain)\npicking this:\n  (x # xs) ! i = y\n  1 < length (x # xs)\n  i = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  (x # xs) ! i = y\n  1 < length (x # xs)\n  i = 0\n\ngoal (1 subgoal):\n 1. y \\<in> set (butlast (x # xs))", "by simp"], ["proof (state)\nthis:\n  y \\<in> set (butlast (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> y \\<in> set (butlast (x # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> y \\<in> set (butlast (x # xs))", "case (Suc j)"], ["proof (state)\nthis:\n  i = Suc j\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> y \\<in> set (butlast (x # xs))", "with Cons.prems(1)[symmetric] Cons.prems(2,3)"], ["proof (chain)\npicking this:\n  y = (x # xs) ! i\n  i < length (x # xs) - 1\n  1 < length (x # xs)\n  i = Suc j", "have \"y \\<in> set (butlast xs)\""], ["proof (prove)\nusing this:\n  y = (x # xs) ! i\n  i < length (x # xs) - 1\n  1 < length (x # xs)\n  i = Suc j\n\ngoal (1 subgoal):\n 1. y \\<in> set (butlast xs)", "by - (rule Cons.IH, auto)"], ["proof (state)\nthis:\n  y \\<in> set (butlast xs)\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> y \\<in> set (butlast (x # xs))", "with Cons.prems(3)"], ["proof (chain)\npicking this:\n  1 < length (x # xs)\n  y \\<in> set (butlast xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  1 < length (x # xs)\n  y \\<in> set (butlast xs)\n\ngoal (1 subgoal):\n 1. y \\<in> set (butlast (x # xs))", "by simp"], ["proof (state)\nthis:\n  y \\<in> set (butlast (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y \\<in> set (butlast (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>[] ! i = y; i < length [] - 1; 1 < length []\\<rbrakk>\n       \\<Longrightarrow> y \\<in> set (butlast [])", "qed simp"], ["", "lemma card_eq_1_singleton:\n  assumes \"card A = 1\"\n  obtains x where \"A = {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. A = {x} \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using assms[simplified]"], ["proof (prove)\nusing this:\n  card A = Suc 0\n\ngoal (1 subgoal):\n 1. (\\<And>x. A = {x} \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by - (drule card_eq_SucD, auto)"], ["", "lemma set_take_two:\n  assumes \"card A \\<ge> 2\"\n  obtains x y where \"x \\<in> A\" \"y \\<in> A\" \"x \\<noteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<in> A; y \\<in> A; x \\<noteq> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<in> A; y \\<in> A; x \\<noteq> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  2 \\<le> card A", "obtain k where \"card A = Suc (Suc k)\""], ["proof (prove)\nusing this:\n  2 \\<le> card A\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        card A = Suc (Suc k) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: le_iff_add)"], ["proof (state)\nthis:\n  card A = Suc (Suc k)\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<in> A; y \\<in> A; x \\<noteq> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from card_eq_SucD[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>b B.\n     A = insert b B \\<and>\n     b \\<notin> B \\<and>\n     card B = Suc k \\<and> (Suc k = 0 \\<longrightarrow> B = {})", "obtain x B where x: \"A = insert x B\" \"x \\<notin> B\" \"card B = Suc k\""], ["proof (prove)\nusing this:\n  \\<exists>b B.\n     A = insert b B \\<and>\n     b \\<notin> B \\<and>\n     card B = Suc k \\<and> (Suc k = 0 \\<longrightarrow> B = {})\n\ngoal (1 subgoal):\n 1. (\\<And>x B.\n        \\<lbrakk>A = insert x B; x \\<notin> B; card B = Suc k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A = insert x B\n  x \\<notin> B\n  card B = Suc k\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<in> A; y \\<in> A; x \\<noteq> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from card_eq_SucD[OF this(3)]"], ["proof (chain)\npicking this:\n  \\<exists>b Ba.\n     B = insert b Ba \\<and>\n     b \\<notin> Ba \\<and>\n     card Ba = k \\<and> (k = 0 \\<longrightarrow> Ba = {})", "obtain y where y: \"y \\<in> B\""], ["proof (prove)\nusing this:\n  \\<exists>b Ba.\n     B = insert b Ba \\<and>\n     b \\<notin> Ba \\<and>\n     card Ba = k \\<and> (k = 0 \\<longrightarrow> Ba = {})\n\ngoal (1 subgoal):\n 1. (\\<And>y. y \\<in> B \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  y \\<in> B\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<in> A; y \\<in> A; x \\<noteq> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from x y"], ["proof (chain)\npicking this:\n  A = insert x B\n  x \\<notin> B\n  card B = Suc k\n  y \\<in> B", "show ?thesis"], ["proof (prove)\nusing this:\n  A = insert x B\n  x \\<notin> B\n  card B = Suc k\n  y \\<in> B\n\ngoal (1 subgoal):\n 1. thesis", "by - (rule that[of x y], auto)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma singleton_list_hd_last: \"length xs = 1 \\<Longrightarrow> hd xs = last xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = 1 \\<Longrightarrow> hd xs = last xs", "by (metis One_nat_def impossible_Cons last.simps length_0_conv less_nat_zero_code list.sel(1) nat_less_le neq_Nil_conv not_less_eq_eq)"], ["", "lemma distinct_hd_tl: \"distinct xs \\<Longrightarrow> hd xs \\<notin> set (tl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs \\<Longrightarrow> hd xs \\<notin> set (tl xs)", "by (metis distinct.simps(2) hd_Cons_tl in_set_member list.sel(2) member_rec(2))"], ["", "lemma set_mono_strict_prefix: \"strict_prefix xs ys \\<Longrightarrow> set xs \\<subseteq> set (butlast ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_prefix xs ys \\<Longrightarrow>\n    set xs \\<subseteq> set (butlast ys)", "by (metis append_butlast_last_id strict_prefixE strict_prefix_simps(1) prefix_snoc set_mono_prefix)"], ["", "lemma set_butlast_distinct: \"distinct xs \\<Longrightarrow> set (butlast xs) \\<inter> {last xs} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs \\<Longrightarrow> set (butlast xs) \\<inter> {last xs} = {}", "by (metis append_butlast_last_id butlast.simps(1) distinct_append inf_bot_right inf_commute list.set(1) set_simps(2))"], ["", "lemma disjoint_elem[elim]: \"A \\<inter> B = {} \\<Longrightarrow> x \\<in> A \\<Longrightarrow> x \\<notin> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<inter> B = {}; x \\<in> A\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> B", "by auto"], ["", "lemma prefix_butlastD[elim]: \"prefix xs (butlast ys) \\<Longrightarrow> prefix xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix xs (butlast ys) \\<Longrightarrow> prefix xs ys", "using strict_prefix_butlast"], ["proof (prove)\nusing this:\n  \\<lbrakk>prefix ?xs (butlast ?ys); ?ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> strict_prefix ?xs ?ys\n\ngoal (1 subgoal):\n 1. prefix xs (butlast ys) \\<Longrightarrow> prefix xs ys", "by fastforce"], ["", "lemma butlast_prefix: \"prefix xs ys \\<Longrightarrow> prefix (butlast xs) (butlast ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix xs ys \\<Longrightarrow> prefix (butlast xs) (butlast ys)", "by (induction xs ys rule: list_induct2'; auto)"], ["", "lemma hd_in_butlast: \"length xs > 1 \\<Longrightarrow> hd xs \\<in> set (butlast xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < length xs \\<Longrightarrow> hd xs \\<in> set (butlast xs)", "by (metis butlast.simps(2) dual_order.strict_iff_order hd_Cons_tl hd_in_set length_greater_0_conv length_tl less_le_trans list.distinct(1) list.sel(1) neq0_conv zero_less_diff)"], ["", "lemma nonsimple_length_gt_1: \"xs \\<noteq> [] \\<Longrightarrow> hd xs \\<noteq> last xs \\<Longrightarrow> length xs > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> []; hd xs \\<noteq> last xs\\<rbrakk>\n    \\<Longrightarrow> 1 < length xs", "by (metis length_0_conv less_one nat_neq_iff singleton_list_hd_last)"], ["", "lemma set_hd_tl: \"xs \\<noteq> [] \\<Longrightarrow> set [hd xs] \\<union> set (tl xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    set [hd xs] \\<union> set (tl xs) = set xs", "by (metis inf_sup_aci(5) rotate1_hd_tl set_append set_rotate1)"], ["", "lemma fold_update_conv:\n  \"fold (\\<lambda>n m. m(n \\<mapsto> g n)) xs m x =\n  (if (x \\<in> set xs) then Some (g x) else m x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>n m. m(n \\<mapsto> g n)) xs m x =\n    (if x \\<in> set xs then Some (g x) else m x)", "by (induction xs arbitrary: m) auto"], ["", "lemmas removeAll_le = length_removeAll_less_eq"], ["", "lemmas removeAll_less [intro] = length_removeAll_less"], ["", "lemma removeAll_induct:\n  assumes \"\\<And>xs. (\\<And>x. x \\<in> set xs \\<Longrightarrow> P (removeAll x xs)) \\<Longrightarrow> P xs\"\n  shows \"P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "by (induct xs rule:length_induct, rule assms) auto"], ["", "lemma The_Min: \"Ex1 P \\<Longrightarrow> The P = Min {x. P x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex1 P \\<Longrightarrow> The P = Min {x. P x}", "apply (rule the_equality)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Ex1 P \\<Longrightarrow> P (Min {x. P x})\n 2. \\<And>x. \\<lbrakk>Ex1 P; P x\\<rbrakk> \\<Longrightarrow> x = Min {x. P x}", "apply (metis (mono_tags) Min.infinite Min_in Min_singleton all_not_in_conv finite_subset insert_iff mem_Collect_eq subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. \\<lbrakk>Ex1 P; P x\\<rbrakk> \\<Longrightarrow> x = Min {x. P x}", "by (metis (erased, hide_lams) Least_Min Least_equality Set.set_insert ex_in_conv finite.emptyI finite_insert insert_iff mem_Collect_eq order_refl)"], ["", "lemma The_Max: \"Ex1 P \\<Longrightarrow> The P = Max {x. P x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex1 P \\<Longrightarrow> The P = Max {x. P x}", "apply (rule the_equality)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Ex1 P \\<Longrightarrow> P (Max {x. P x})\n 2. \\<And>x. \\<lbrakk>Ex1 P; P x\\<rbrakk> \\<Longrightarrow> x = Max {x. P x}", "apply (metis (mono_tags) Max.infinite Max_in Max_singleton all_not_in_conv finite_subset insert_iff mem_Collect_eq subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. \\<lbrakk>Ex1 P; P x\\<rbrakk> \\<Longrightarrow> x = Max {x. P x}", "by (metis Max_singleton Min_singleton Nitpick.Ex1_unfold The_Min the_equality)"], ["", "lemma set_sorted_list_of_set_remove [simp]:\n\"set (sorted_list_of_set (Set.remove x A)) = Set.remove x (set (sorted_list_of_set A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (sorted_list_of_set (Set.remove x A)) =\n    Set.remove x (set (sorted_list_of_set A))", "unfolding Set.remove_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (sorted_list_of_set (A - {x})) = set (sorted_list_of_set A) - {x}", "by (cases \"finite A\"; simp)"], ["", "lemma set_minus_one: \"\\<lbrakk>v \\<noteq> v'; v' \\<in> set vs\\<rbrakk> \\<Longrightarrow> set vs - {v'} \\<subseteq> {v} \\<longleftrightarrow> set vs = {v'} \\<or> set vs = {v,v'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<noteq> v'; v' \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> (set vs - {v'} \\<subseteq> {v}) =\n                      (set vs = {v'} \\<or> set vs = {v, v'})", "by auto"], ["", "lemma set_single_hd: \"set vs = {v} \\<Longrightarrow> hd vs = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set vs = {v} \\<Longrightarrow> hd vs = v", "by (induction vs; auto)"], ["", "lemma set_double_filter_hd: \"\\<lbrakk> set vs = {v,v'}; v \\<noteq> v' \\<rbrakk> \\<Longrightarrow> hd [v'\\<leftarrow>vs . v' \\<noteq> v] = v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set vs = {v, v'}; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> hd (filter (\\<lambda>v'. v' \\<noteq> v) vs) = v'", "apply (induction vs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>set [] = {v, v'}; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> hd (filter (\\<lambda>v'. v' \\<noteq> v) []) = v'\n 2. \\<And>a vs.\n       \\<lbrakk>\\<lbrakk>set vs = {v, v'}; v \\<noteq> v'\\<rbrakk>\n                \\<Longrightarrow> hd (filter (\\<lambda>v'. v' \\<noteq> v)\n vs) =\n                                  v';\n        set (a # vs) = {v, v'}; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> hd (filter (\\<lambda>v'. v' \\<noteq> v) (a # vs)) =\n                         v'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a vs.\n       \\<lbrakk>\\<lbrakk>set vs = {v, v'}; v \\<noteq> v'\\<rbrakk>\n                \\<Longrightarrow> hd (filter (\\<lambda>v'. v' \\<noteq> v)\n vs) =\n                                  v';\n        set (a # vs) = {v, v'}; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> hd (filter (\\<lambda>v'. v' \\<noteq> v) (a # vs)) =\n                         v'", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>vs.\n       \\<lbrakk>set vs = {v, v'} \\<Longrightarrow>\n                hd (filter (\\<lambda>v'. v' \\<noteq> v) vs) = v';\n        insert v (set vs) = {v, v'}; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> hd (filter (\\<lambda>v'. v' \\<noteq> v) vs) = v'", "apply (case_tac \"v \\<in> set vs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>vs.\n       \\<lbrakk>set vs = {v, v'} \\<Longrightarrow>\n                hd (filter (\\<lambda>v'. v' \\<noteq> v) vs) = v';\n        insert v (set vs) = {v, v'}; v \\<noteq> v'; v \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> hd (filter (\\<lambda>v'. v' \\<noteq> v) vs) = v'\n 2. \\<And>vs.\n       \\<lbrakk>set vs = {v, v'} \\<Longrightarrow>\n                hd (filter (\\<lambda>v'. v' \\<noteq> v) vs) = v';\n        insert v (set vs) = {v, v'}; v \\<noteq> v';\n        v \\<notin> set vs\\<rbrakk>\n       \\<Longrightarrow> hd (filter (\\<lambda>v'. v' \\<noteq> v) vs) = v'", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>vs.\n       \\<lbrakk>set vs = {v, v'} \\<Longrightarrow>\n                hd (filter (\\<lambda>v'. v' \\<noteq> v) vs) = v';\n        insert v (set vs) = {v, v'}; v \\<noteq> v';\n        v \\<notin> set vs\\<rbrakk>\n       \\<Longrightarrow> hd (filter (\\<lambda>v'. v' \\<noteq> v) vs) = v'\n 2. \\<And>vs.\n       \\<lbrakk>set vs = {v, v'} \\<Longrightarrow>\n                hd (filter (\\<lambda>v'. v' \\<noteq> v) vs) = v';\n        insert v (set vs) = {v, v'}; v \\<noteq> v'; v \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> hd (filter (\\<lambda>v'. v' \\<noteq> v) vs) = v'", "apply (subgoal_tac \"set vs = {v'}\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>vs.\n       \\<lbrakk>set vs = {v, v'} \\<Longrightarrow>\n                hd (filter (\\<lambda>v'. v' \\<noteq> v) vs) = v';\n        insert v (set vs) = {v, v'}; v \\<noteq> v'; v \\<notin> set vs;\n        set vs = {v'}\\<rbrakk>\n       \\<Longrightarrow> hd (filter (\\<lambda>v'. v' \\<noteq> v) vs) = v'\n 2. \\<And>vs.\n       \\<lbrakk>set vs = {v, v'} \\<Longrightarrow>\n                hd (filter (\\<lambda>v'. v' \\<noteq> v) vs) = v';\n        insert v (set vs) = {v, v'}; v \\<noteq> v';\n        v \\<notin> set vs\\<rbrakk>\n       \\<Longrightarrow> set vs = {v'}\n 3. \\<And>vs.\n       \\<lbrakk>set vs = {v, v'} \\<Longrightarrow>\n                hd (filter (\\<lambda>v'. v' \\<noteq> v) vs) = v';\n        insert v (set vs) = {v, v'}; v \\<noteq> v'; v \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> hd (filter (\\<lambda>v'. v' \\<noteq> v) vs) = v'", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>vs.\n       \\<lbrakk>set vs = {v, v'} \\<Longrightarrow>\n                hd (filter (\\<lambda>v'. v' \\<noteq> v) vs) = v';\n        insert v (set vs) = {v, v'}; v \\<noteq> v';\n        v \\<notin> set vs\\<rbrakk>\n       \\<Longrightarrow> set vs = {v'}\n 2. \\<And>vs.\n       \\<lbrakk>set vs = {v, v'} \\<Longrightarrow>\n                hd (filter (\\<lambda>v'. v' \\<noteq> v) vs) = v';\n        insert v (set vs) = {v, v'}; v \\<noteq> v'; v \\<notin> set vs;\n        set vs = {v'}\\<rbrakk>\n       \\<Longrightarrow> hd (filter (\\<lambda>v'. v' \\<noteq> v) vs) = v'\n 3. \\<And>vs.\n       \\<lbrakk>set vs = {v, v'} \\<Longrightarrow>\n                hd (filter (\\<lambda>v'. v' \\<noteq> v) vs) = v';\n        insert v (set vs) = {v, v'}; v \\<noteq> v'; v \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> hd (filter (\\<lambda>v'. v' \\<noteq> v) vs) = v'", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>vs.\n       \\<lbrakk>set vs = {v, v'} \\<Longrightarrow>\n                hd (filter (\\<lambda>v'. v' \\<noteq> v) vs) = v';\n        insert v (set vs) = {v, v'}; v \\<noteq> v'; v \\<notin> set vs;\n        set vs = {v'}\\<rbrakk>\n       \\<Longrightarrow> hd (filter (\\<lambda>v'. v' \\<noteq> v) vs) = v'\n 2. \\<And>vs.\n       \\<lbrakk>set vs = {v, v'} \\<Longrightarrow>\n                hd (filter (\\<lambda>v'. v' \\<noteq> v) vs) = v';\n        insert v (set vs) = {v, v'}; v \\<noteq> v'; v \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> hd (filter (\\<lambda>v'. v' \\<noteq> v) vs) = v'", "apply (clarsimp simp: set_single_hd)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>vs.\n       \\<lbrakk>set vs = {v, v'} \\<Longrightarrow>\n                hd (filter (\\<lambda>v'. v' \\<noteq> v) vs) = v';\n        insert v (set vs) = {v, v'}; v \\<noteq> v'; v \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> hd (filter (\\<lambda>v'. v' \\<noteq> v) vs) = v'", "by fastforce"], ["", "lemma map_option_the: \"x = map_option f y \\<Longrightarrow> x \\<noteq> None \\<Longrightarrow> the x = f (the y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = map_option f y; x \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> the x = f (the y)", "by (auto simp: map_option_case split: option.split prod.splits)"], ["", "end"]]}