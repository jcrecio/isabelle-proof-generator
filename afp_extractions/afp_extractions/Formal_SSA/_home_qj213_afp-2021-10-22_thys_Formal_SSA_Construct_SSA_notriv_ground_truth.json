{"file_name": "/home/qj213/afp-2021-10-22/thys/Formal_SSA/Construct_SSA_notriv.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Formal_SSA", "problem_names": ["lemma chooseNext':\"redundant g \\<Longrightarrow> chooseNext' g \\<in> dom (phis g) \\<and> trivial g (chooseNext g)\"", "lemma chooseNext: \"redundant g \\<Longrightarrow> chooseNext g \\<in> allVars g \\<and> trivial g (chooseNext g)\"", "lemmas chooseNext_in_allVars[simp] = chooseNext[THEN conjunct1]", "lemma isTrivialPhi_det: \"trivial g v \\<Longrightarrow> \\<exists>!v'. isTrivialPhi g v v'\"", "lemma trivialPhi_strict_dom:\n    assumes[simp]: \"v \\<in> allVars g\" and triv: \"isTrivialPhi g v v'\"\n    shows \"strict_def_dom g v' v\"", "lemma isTrivialPhi_asymmetric:\n  assumes \"isTrivialPhi g a b\"\n    and \"isTrivialPhi g b a\"\n  shows \"False\"", "lemma substitution[intro]: \"redundant g \\<Longrightarrow> isTrivialPhi g (chooseNext g) (substitution g)\"", "lemma trivialPhi_in_allVars[simp]:\n    assumes \"isTrivialPhi g v v'\" and[simp]: \"v \\<in> allVars g\"\n    shows \"v' \\<in> allVars g\"", "lemma substitution_in_allVars[simp]:\n    assumes \"redundant g\"\n    shows \"substitution g \\<in> allVars g\"", "lemma defs_uses_disjoint_inv:\n    assumes[simp]: \"n \\<in> set (\\<alpha>n g)\" \"redundant g\"\n    shows \"defs g n \\<inter> uses' g n = {}\"", "lemma liveVal'_suffix:\n    assumes \"liveVal' g vs\" \"suffix vs' vs\" \"vs' \\<noteq> []\"\n    shows \"liveVal' g vs'\"", "lemma liveVal'I:\n    assumes \"liveVal g v\"\n    obtains vs where \"liveVal' g (v#vs)\"", "lemma liveVal'D:\n    assumes \"liveVal' g vs\" \"vs = v#vs'\"\n    shows \"liveVal g v\"", "lemma simpleDefs_phiDefs_disjoint_inv:\n    assumes \"n \\<in> set (\\<alpha>n g)\"\n    shows \"defs g n \\<inter> step.phiDefs g n = {}\"", "lemma allDefs_disjoint_inv:\n    assumes \"n \\<in> set (\\<alpha>n g)\" \"m \\<in> set (\\<alpha>n g)\" \"n \\<noteq> m\"\n    shows \"step.allDefs g n \\<inter> step.allDefs g m = {}\"", "lemma phis_finite_inv:\n    shows \"finite (dom (phis' g))\"", "lemma phis_wf_inv:\n    assumes \"phis' g (n, v) = Some args\"\n    shows \"length (old.predecessors g n) = length args\"", "lemma allUses_narrows:\n    assumes \"n \\<in> set (\\<alpha>n g)\"\n    shows \"step.allUses g n \\<subseteq> substNext g ` allUses g n\"", "lemma allDefs_narrows[simp]: \"v \\<in> step.allDefs g n \\<Longrightarrow> v \\<in> allDefs g n\"", "lemma allUses_def_ass_inv:\n    assumes \"v' \\<in> step.allUses g n\" \"n \\<in> set (\\<alpha>n g)\"\n    shows \"step.defAss g n v'\"", "lemma Entry_no_phis_inv: \"phis' g (Entry g, v) = None\"", "lemma chooseNext_eliminated: \"chooseNext g \\<notin> step.allDefs g (defNode g (chooseNext g))\"", "lemma oldUses_inv:\n    assumes \"n \\<in> set (\\<alpha>n g)\"\n    shows \"oldUses g n = var g ` u_g g n\"", "lemma conventional_inv:\n    assumes \"g \\<turnstile> n-ns\\<rightarrow>m\" \"n \\<notin> set (tl ns)\" \"v \\<in> step.allDefs g n\" \"v \\<in> step.allUses g m\" \"x \\<in> set (tl ns)\" \"v' \\<in> step.allDefs g x\"\n    shows \"var g v' \\<noteq> var g v\"", "lemma[simp]: \"var g (substNext g v) = var g v\"", "lemma phis_same_var_inv:\n    assumes \"phis' g (n,v) = Some vs\" \"v' \\<in> set vs\"\n    shows \"var g v' = var g v\"", "lemma allDefs_var_disjoint_inv: \"\\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> step.allDefs g n; v' \\<in> step.allDefs g n; v \\<noteq> v'\\<rbrakk> \\<Longrightarrow> var g v' \\<noteq> var g v\"", "lemma step_CFG_SSA_Transformed_notriv: \"CFG_SSA_Transformed_notriv \\<alpha>e \\<alpha>n invar inEdges' Entry oldDefs oldUses defs u_g p_g var chooseNext_all\"", "lemma step_defNode: \"v \\<in> allVars g \\<Longrightarrow> v \\<noteq> chooseNext g \\<Longrightarrow> step.defNode g v = defNode g v\"", "lemma step_phi: \"v \\<in> allVars g \\<Longrightarrow> v \\<noteq> chooseNext g \\<Longrightarrow> step.phi g v = map_option (map (substNext g)) (phi g v)\"", "lemma liveVal'_inv:\n    assumes \"liveVal' g (v#vs)\" \"v \\<noteq> chooseNext g\"\n    obtains vs' where \"step.liveVal' g (v#vs')\"", "lemma liveVal_inv:\n    assumes \"liveVal g v\" \"v \\<noteq> chooseNext g\"\n    shows \"step.liveVal g v\"", "lemma pruned_inv:\n    assumes \"pruned g\"\n    shows \"step.pruned g\"", "lemma uninst_allVars_simps [simp]:\n    \"uninst.allVars u (\\<lambda>_. p g) g = uninst.allVars u p g\"\n    \"uninst.allVars (\\<lambda>_. u g) p g = uninst.allVars u p g\"\n    \"uninst.allVars (uses(g:=u g)) p g = uninst.allVars u p g\"\n    \"uninst.allVars u (phis(g:=p g)) g = uninst.allVars u p g\"", "lemma uninst_trivial_simps [simp]:\n    \"uninst.trivial u (\\<lambda>_. p g) g = uninst.trivial u p g\"\n    \"uninst.trivial (\\<lambda>_. u g) p g = uninst.trivial u p g\"\n    \"uninst.trivial (uses(g:=u g)) p g = uninst.trivial u p g\"\n    \"uninst.trivial u (phis(g:=p g)) g = uninst.trivial u p g\"", "lemma substAll_wf:\n    assumes[simp]: \"redundant g\"\n    shows \"card (dom (phis' g)) < card (dom (phis g))\"", "lemma step_preserves_inst:\n    assumes \"inst' g (u,p)\"\n      and \"CFG_SSA_wf_base.redundant \\<alpha>n inEdges' defs (uses(g:=u)) (phis(g:=p)) g\"\n    shows \"inst' g (step g (u,p))\"", "lemma substAll:\n    assumes \"P (uses g, phis g)\"\n    assumes \"\\<And>x. P x \\<Longrightarrow> inst' g x \\<Longrightarrow> cond g x \\<Longrightarrow> P (step g x)\"\n    assumes \"\\<And>x. P x \\<Longrightarrow> inst' g x \\<Longrightarrow> \\<not>cond g x \\<Longrightarrow> Q (fst x) (snd x)\"\n    shows \"inst g (uses'_all g) (phis'_all g)\" \"Q (uses'_all g) (phis'_all g)\"", "theorem not_redundant: \"\\<not>notriv.redundant g\"", "theorem pruned_invariant:\n    assumes \"pruned g\"\n    shows \"notriv.pruned g\""], "translations": [["", "lemma chooseNext':\"redundant g \\<Longrightarrow> chooseNext' g \\<in> dom (phis g) \\<and> trivial g (chooseNext g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redundant g \\<Longrightarrow>\n    chooseNext' g \\<in> dom (phis g) \\<and> trivial g (chooseNext g)", "by (rule chooseNext_all, unfold_locales)"], ["", "lemma chooseNext: \"redundant g \\<Longrightarrow> chooseNext g \\<in> allVars g \\<and> trivial g (chooseNext g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redundant g \\<Longrightarrow>\n    chooseNext g \\<in> allVars g \\<and> trivial g (chooseNext g)", "by (drule chooseNext', auto simp: trivial_in_allVars)"], ["", "lemmas chooseNext_in_allVars[simp] = chooseNext[THEN conjunct1]"], ["", "lemma isTrivialPhi_det: \"trivial g v \\<Longrightarrow> \\<exists>!v'. isTrivialPhi g v v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trivial g v \\<Longrightarrow> \\<exists>!v'. isTrivialPhi g v v'", "proof(rule ex_ex1I)"], ["proof (state)\ngoal (2 subgoals):\n 1. trivial g v \\<Longrightarrow> \\<exists>v'. isTrivialPhi g v v'\n 2. \\<And>v' y.\n       \\<lbrakk>trivial g v; isTrivialPhi g v v';\n        isTrivialPhi g v y\\<rbrakk>\n       \\<Longrightarrow> v' = y", "fix v' v''"], ["proof (state)\ngoal (2 subgoals):\n 1. trivial g v \\<Longrightarrow> \\<exists>v'. isTrivialPhi g v v'\n 2. \\<And>v' y.\n       \\<lbrakk>trivial g v; isTrivialPhi g v v';\n        isTrivialPhi g v y\\<rbrakk>\n       \\<Longrightarrow> v' = y", "assume \"isTrivialPhi g v v'\" \"isTrivialPhi g v v''\""], ["proof (state)\nthis:\n  isTrivialPhi g v v'\n  isTrivialPhi g v v''\n\ngoal (2 subgoals):\n 1. trivial g v \\<Longrightarrow> \\<exists>v'. isTrivialPhi g v v'\n 2. \\<And>v' y.\n       \\<lbrakk>trivial g v; isTrivialPhi g v v';\n        isTrivialPhi g v y\\<rbrakk>\n       \\<Longrightarrow> v' = y", "from this[unfolded isTrivialPhi_def, THEN conjunct2]"], ["proof (chain)\npicking this:\n  case phi g v of None \\<Rightarrow> False\n  | Some vs \\<Rightarrow> set vs = {v, v'} \\<or> set vs = {v'}\n  case phi g v of None \\<Rightarrow> False\n  | Some vs \\<Rightarrow> set vs = {v, v''} \\<or> set vs = {v''}", "show \"v' = v''\""], ["proof (prove)\nusing this:\n  case phi g v of None \\<Rightarrow> False\n  | Some vs \\<Rightarrow> set vs = {v, v'} \\<or> set vs = {v'}\n  case phi g v of None \\<Rightarrow> False\n  | Some vs \\<Rightarrow> set vs = {v, v''} \\<or> set vs = {v''}\n\ngoal (1 subgoal):\n 1. v' = v''", "by (auto simp:isTrivialPhi_def doubleton_eq_iff split:option.splits)"], ["proof (state)\nthis:\n  v' = v''\n\ngoal (1 subgoal):\n 1. trivial g v \\<Longrightarrow> \\<exists>v'. isTrivialPhi g v v'", "qed (auto simp: trivial_def)"], ["", "lemma trivialPhi_strict_dom:\n    assumes[simp]: \"v \\<in> allVars g\" and triv: \"isTrivialPhi g v v'\"\n    shows \"strict_def_dom g v' v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. defNode g v' \\<noteq> defNode g v \\<and> def_dominates g v' v", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. defNode g v' \\<noteq> defNode g v\n 2. def_dominates g v' v", "let ?n = \"defNode g v\""], ["proof (state)\ngoal (2 subgoals):\n 1. defNode g v' \\<noteq> defNode g v\n 2. def_dominates g v' v", "let ?n' = \"defNode g v'\""], ["proof (state)\ngoal (2 subgoals):\n 1. defNode g v' \\<noteq> defNode g v\n 2. def_dominates g v' v", "from triv"], ["proof (chain)\npicking this:\n  isTrivialPhi g v v'", "obtain vs where vs: \"phi g v = Some vs\" \"(set vs = {v'} \\<or> set vs = {v,v'})\""], ["proof (prove)\nusing this:\n  isTrivialPhi g v v'\n\ngoal (1 subgoal):\n 1. (\\<And>vs.\n        \\<lbrakk>phi g v = Some vs;\n         set vs = {v'} \\<or> set vs = {v, v'}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp:isTrivialPhi_def split:option.splits)"], ["proof (state)\nthis:\n  phi g v = Some vs\n  set vs = {v'} \\<or> set vs = {v, v'}\n\ngoal (2 subgoals):\n 1. defNode g v' \\<noteq> defNode g v\n 2. def_dominates g v' v", "hence \"?n \\<noteq> Entry g\""], ["proof (prove)\nusing this:\n  phi g v = Some vs\n  set vs = {v'} \\<or> set vs = {v, v'}\n\ngoal (1 subgoal):\n 1. defNode g v \\<noteq> Entry g", "by auto"], ["proof (state)\nthis:\n  defNode g v \\<noteq> Entry g\n\ngoal (2 subgoals):\n 1. defNode g v' \\<noteq> defNode g v\n 2. def_dominates g v' v", "have other_preds_dominated: \"\\<And>m. m \\<in> set (old.predecessors g ?n) \\<Longrightarrow> v' \\<notin> phiUses g m \\<Longrightarrow> old.dominates g ?n m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<in> set (old.predecessors g (defNode g v));\n        v' \\<notin> phiUses g m\\<rbrakk>\n       \\<Longrightarrow> old.dominates g (defNode g v) m", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<in> set (old.predecessors g (defNode g v));\n        v' \\<notin> phiUses g m\\<rbrakk>\n       \\<Longrightarrow> old.dominates g (defNode g v) m", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<in> set (old.predecessors g (defNode g v));\n        v' \\<notin> phiUses g m\\<rbrakk>\n       \\<Longrightarrow> old.dominates g (defNode g v) m", "assume m: \"m \\<in> set (old.predecessors g ?n)\" \"v' \\<notin> phiUses g m\""], ["proof (state)\nthis:\n  m \\<in> set (old.predecessors g (defNode g v))\n  v' \\<notin> phiUses g m\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<in> set (old.predecessors g (defNode g v));\n        v' \\<notin> phiUses g m\\<rbrakk>\n       \\<Longrightarrow> old.dominates g (defNode g v) m", "hence[simp]: \"m \\<in> set (\\<alpha>n g)\""], ["proof (prove)\nusing this:\n  m \\<in> set (old.predecessors g (defNode g v))\n  v' \\<notin> phiUses g m\n\ngoal (1 subgoal):\n 1. m \\<in> set (\\<alpha>n g)", "by auto"], ["proof (state)\nthis:\n  m \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<in> set (old.predecessors g (defNode g v));\n        v' \\<notin> phiUses g m\\<rbrakk>\n       \\<Longrightarrow> old.dominates g (defNode g v) m", "show \"old.dominates g ?n m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. old.dominates g (defNode g v) m", "proof (cases \"v \\<in> phiUses g m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> phiUses g m \\<Longrightarrow> old.dominates g (defNode g v) m\n 2. v \\<notin> phiUses g m \\<Longrightarrow> old.dominates g (defNode g v) m", "case True"], ["proof (state)\nthis:\n  v \\<in> phiUses g m\n\ngoal (2 subgoals):\n 1. v \\<in> phiUses g m \\<Longrightarrow> old.dominates g (defNode g v) m\n 2. v \\<notin> phiUses g m \\<Longrightarrow> old.dominates g (defNode g v) m", "hence \"v \\<in> allUses g m\""], ["proof (prove)\nusing this:\n  v \\<in> phiUses g m\n\ngoal (1 subgoal):\n 1. v \\<in> allUses g m", "by simp"], ["proof (state)\nthis:\n  v \\<in> allUses g m\n\ngoal (2 subgoals):\n 1. v \\<in> phiUses g m \\<Longrightarrow> old.dominates g (defNode g v) m\n 2. v \\<notin> phiUses g m \\<Longrightarrow> old.dominates g (defNode g v) m", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> allUses g m\n\ngoal (1 subgoal):\n 1. old.dominates g (defNode g v) m", "by (rule allUses_dominated) simp_all"], ["proof (state)\nthis:\n  old.dominates g (defNode g v) m\n\ngoal (1 subgoal):\n 1. v \\<notin> phiUses g m \\<Longrightarrow> old.dominates g (defNode g v) m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> phiUses g m \\<Longrightarrow> old.dominates g (defNode g v) m", "case False"], ["proof (state)\nthis:\n  v \\<notin> phiUses g m\n\ngoal (1 subgoal):\n 1. v \\<notin> phiUses g m \\<Longrightarrow> old.dominates g (defNode g v) m", "with vs"], ["proof (chain)\npicking this:\n  phi g v = Some vs\n  set vs = {v'} \\<or> set vs = {v, v'}\n  v \\<notin> phiUses g m", "have  \"v' \\<in> phiUses g m\""], ["proof (prove)\nusing this:\n  phi g v = Some vs\n  set vs = {v'} \\<or> set vs = {v, v'}\n  v \\<notin> phiUses g m\n\ngoal (1 subgoal):\n 1. v' \\<in> phiUses g m", "by - (rule phiUses_exI[OF m(1)], auto simp:phi_def)"], ["proof (state)\nthis:\n  v' \\<in> phiUses g m\n\ngoal (1 subgoal):\n 1. v \\<notin> phiUses g m \\<Longrightarrow> old.dominates g (defNode g v) m", "with m(2)"], ["proof (chain)\npicking this:\n  v' \\<notin> phiUses g m\n  v' \\<in> phiUses g m", "show ?thesis"], ["proof (prove)\nusing this:\n  v' \\<notin> phiUses g m\n  v' \\<in> phiUses g m\n\ngoal (1 subgoal):\n 1. old.dominates g (defNode g v) m", "by simp"], ["proof (state)\nthis:\n  old.dominates g (defNode g v) m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  old.dominates g (defNode g v) m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?m1 \\<in> set (old.predecessors g (defNode g v));\n   v' \\<notin> phiUses g ?m1\\<rbrakk>\n  \\<Longrightarrow> old.dominates g (defNode g v) ?m1\n\ngoal (2 subgoals):\n 1. defNode g v' \\<noteq> defNode g v\n 2. def_dominates g v' v", "show \"?n' \\<noteq> ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. defNode g v' \\<noteq> defNode g v", "proof (rule notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. defNode g v' = defNode g v \\<Longrightarrow> False", "assume asm: \"?n' = ?n\""], ["proof (state)\nthis:\n  defNode g v' = defNode g v\n\ngoal (1 subgoal):\n 1. defNode g v' = defNode g v \\<Longrightarrow> False", "have \"\\<And>m. m \\<in> set (old.predecessors g ?n) \\<Longrightarrow> v' \\<in> phiUses g m \\<Longrightarrow> old.dominates g ?n m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<in> set (old.predecessors g (defNode g v));\n        v' \\<in> phiUses g m\\<rbrakk>\n       \\<Longrightarrow> old.dominates g (defNode g v) m", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<in> set (old.predecessors g (defNode g v));\n        v' \\<in> phiUses g m\\<rbrakk>\n       \\<Longrightarrow> old.dominates g (defNode g v) m", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<in> set (old.predecessors g (defNode g v));\n        v' \\<in> phiUses g m\\<rbrakk>\n       \\<Longrightarrow> old.dominates g (defNode g v) m", "assume \"m \\<in> set (old.predecessors g ?n)\" \"v' \\<in> phiUses g m\""], ["proof (state)\nthis:\n  m \\<in> set (old.predecessors g (defNode g v))\n  v' \\<in> phiUses g m\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<in> set (old.predecessors g (defNode g v));\n        v' \\<in> phiUses g m\\<rbrakk>\n       \\<Longrightarrow> old.dominates g (defNode g v) m", "hence \"old.dominates g ?n' m\""], ["proof (prove)\nusing this:\n  m \\<in> set (old.predecessors g (defNode g v))\n  v' \\<in> phiUses g m\n\ngoal (1 subgoal):\n 1. old.dominates g (defNode g v') m", "by - (rule allUses_dominated, auto)"], ["proof (state)\nthis:\n  old.dominates g (defNode g v') m\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<in> set (old.predecessors g (defNode g v));\n        v' \\<in> phiUses g m\\<rbrakk>\n       \\<Longrightarrow> old.dominates g (defNode g v) m", "thus \"?thesis m\""], ["proof (prove)\nusing this:\n  old.dominates g (defNode g v') m\n\ngoal (1 subgoal):\n 1. old.dominates g (defNode g v) m", "by (simp add:asm)"], ["proof (state)\nthis:\n  old.dominates g (defNode g v) m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?m1 \\<in> set (old.predecessors g (defNode g v));\n   v' \\<in> phiUses g ?m1\\<rbrakk>\n  \\<Longrightarrow> old.dominates g (defNode g v) ?m1\n\ngoal (1 subgoal):\n 1. defNode g v' = defNode g v \\<Longrightarrow> False", "with non_dominated_predecessor[of ?n g] other_preds_dominated \\<open>?n \\<noteq> Entry g\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>defNode g v \\<in> set (\\<alpha>n g);\n   defNode g v \\<noteq> Entry g;\n   \\<And>m.\n      \\<lbrakk>m \\<in> set (old.predecessors g (defNode g v));\n       \\<not> old.dominates g (defNode g v) m\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<lbrakk>?m1 \\<in> set (old.predecessors g (defNode g v));\n   v' \\<notin> phiUses g ?m1\\<rbrakk>\n  \\<Longrightarrow> old.dominates g (defNode g v) ?m1\n  defNode g v \\<noteq> Entry g\n  \\<lbrakk>?m1 \\<in> set (old.predecessors g (defNode g v));\n   v' \\<in> phiUses g ?m1\\<rbrakk>\n  \\<Longrightarrow> old.dominates g (defNode g v) ?m1", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>defNode g v \\<in> set (\\<alpha>n g);\n   defNode g v \\<noteq> Entry g;\n   \\<And>m.\n      \\<lbrakk>m \\<in> set (old.predecessors g (defNode g v));\n       \\<not> old.dominates g (defNode g v) m\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<lbrakk>?m1 \\<in> set (old.predecessors g (defNode g v));\n   v' \\<notin> phiUses g ?m1\\<rbrakk>\n  \\<Longrightarrow> old.dominates g (defNode g v) ?m1\n  defNode g v \\<noteq> Entry g\n  \\<lbrakk>?m1 \\<in> set (old.predecessors g (defNode g v));\n   v' \\<in> phiUses g ?m1\\<rbrakk>\n  \\<Longrightarrow> old.dominates g (defNode g v) ?m1\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  defNode g v' \\<noteq> defNode g v\n\ngoal (1 subgoal):\n 1. def_dominates g v' v", "show \"old.dominates g ?n' ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. def_dominates g v' v", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. defNode g v \\<in> set (\\<alpha>n g)\n 2. \\<And>ns.\n       g \\<turnstile> Entry g-ns\\<rightarrow>defNode g v \\<Longrightarrow>\n       defNode g v' \\<in> set ns", "fix ns"], ["proof (state)\ngoal (2 subgoals):\n 1. defNode g v \\<in> set (\\<alpha>n g)\n 2. \\<And>ns.\n       g \\<turnstile> Entry g-ns\\<rightarrow>defNode g v \\<Longrightarrow>\n       defNode g v' \\<in> set ns", "assume asm: \"g \\<turnstile> Entry g-ns\\<rightarrow>?n\""], ["proof (state)\nthis:\n  g \\<turnstile> Entry g-ns\\<rightarrow>defNode g v\n\ngoal (2 subgoals):\n 1. defNode g v \\<in> set (\\<alpha>n g)\n 2. \\<And>ns.\n       g \\<turnstile> Entry g-ns\\<rightarrow>defNode g v \\<Longrightarrow>\n       defNode g v' \\<in> set ns", "from \\<open>?n \\<noteq> Entry g\\<close>"], ["proof (chain)\npicking this:\n  defNode g v \\<noteq> Entry g", "obtain m ns'\n        where ns': \"g \\<turnstile> Entry g-ns'\\<rightarrow>m\" \"m \\<in> set (old.predecessors g ?n)\" \"?n \\<notin> set ns'\" \"set ns' \\<subseteq> set ns\""], ["proof (prove)\nusing this:\n  defNode g v \\<noteq> Entry g\n\ngoal (1 subgoal):\n 1. (\\<And>ns' m.\n        \\<lbrakk>g \\<turnstile> Entry g-ns'\\<rightarrow>m;\n         m \\<in> set (old.predecessors g (defNode g v));\n         defNode g v \\<notin> set ns'; set ns' \\<subseteq> set ns\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by - (rule old.simple_path2_unsnoc[OF asm], auto)"], ["proof (state)\nthis:\n  g \\<turnstile> Entry g-ns'\\<rightarrow>m\n  m \\<in> set (old.predecessors g (defNode g v))\n  defNode g v \\<notin> set ns'\n  set ns' \\<subseteq> set ns\n\ngoal (2 subgoals):\n 1. defNode g v \\<in> set (\\<alpha>n g)\n 2. \\<And>ns.\n       g \\<turnstile> Entry g-ns\\<rightarrow>defNode g v \\<Longrightarrow>\n       defNode g v' \\<in> set ns", "hence[simp]: \"m \\<in> set (\\<alpha>n g)\""], ["proof (prove)\nusing this:\n  g \\<turnstile> Entry g-ns'\\<rightarrow>m\n  m \\<in> set (old.predecessors g (defNode g v))\n  defNode g v \\<notin> set ns'\n  set ns' \\<subseteq> set ns\n\ngoal (1 subgoal):\n 1. m \\<in> set (\\<alpha>n g)", "by auto"], ["proof (state)\nthis:\n  m \\<in> set (\\<alpha>n g)\n\ngoal (2 subgoals):\n 1. defNode g v \\<in> set (\\<alpha>n g)\n 2. \\<And>ns.\n       g \\<turnstile> Entry g-ns\\<rightarrow>defNode g v \\<Longrightarrow>\n       defNode g v' \\<in> set ns", "from ns'"], ["proof (chain)\npicking this:\n  g \\<turnstile> Entry g-ns'\\<rightarrow>m\n  m \\<in> set (old.predecessors g (defNode g v))\n  defNode g v \\<notin> set ns'\n  set ns' \\<subseteq> set ns", "have \"\\<not>old.dominates g ?n m\""], ["proof (prove)\nusing this:\n  g \\<turnstile> Entry g-ns'\\<rightarrow>m\n  m \\<in> set (old.predecessors g (defNode g v))\n  defNode g v \\<notin> set ns'\n  set ns' \\<subseteq> set ns\n\ngoal (1 subgoal):\n 1. \\<not> old.dominates g (defNode g v) m", "by (auto elim:old.dominatesE)"], ["proof (state)\nthis:\n  \\<not> old.dominates g (defNode g v) m\n\ngoal (2 subgoals):\n 1. defNode g v \\<in> set (\\<alpha>n g)\n 2. \\<And>ns.\n       g \\<turnstile> Entry g-ns\\<rightarrow>defNode g v \\<Longrightarrow>\n       defNode g v' \\<in> set ns", "with other_preds_dominated[of m] ns'(2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>m \\<in> set (old.predecessors g (defNode g v));\n   v' \\<notin> phiUses g m\\<rbrakk>\n  \\<Longrightarrow> old.dominates g (defNode g v) m\n  m \\<in> set (old.predecessors g (defNode g v))\n  \\<not> old.dominates g (defNode g v) m", "have \"v' \\<in> phiUses g m\""], ["proof (prove)\nusing this:\n  \\<lbrakk>m \\<in> set (old.predecessors g (defNode g v));\n   v' \\<notin> phiUses g m\\<rbrakk>\n  \\<Longrightarrow> old.dominates g (defNode g v) m\n  m \\<in> set (old.predecessors g (defNode g v))\n  \\<not> old.dominates g (defNode g v) m\n\ngoal (1 subgoal):\n 1. v' \\<in> phiUses g m", "by auto"], ["proof (state)\nthis:\n  v' \\<in> phiUses g m\n\ngoal (2 subgoals):\n 1. defNode g v \\<in> set (\\<alpha>n g)\n 2. \\<And>ns.\n       g \\<turnstile> Entry g-ns\\<rightarrow>defNode g v \\<Longrightarrow>\n       defNode g v' \\<in> set ns", "hence \"old.dominates g ?n' m\""], ["proof (prove)\nusing this:\n  v' \\<in> phiUses g m\n\ngoal (1 subgoal):\n 1. old.dominates g (defNode g v') m", "by - (rule allUses_dominated, auto)"], ["proof (state)\nthis:\n  old.dominates g (defNode g v') m\n\ngoal (2 subgoals):\n 1. defNode g v \\<in> set (\\<alpha>n g)\n 2. \\<And>ns.\n       g \\<turnstile> Entry g-ns\\<rightarrow>defNode g v \\<Longrightarrow>\n       defNode g v' \\<in> set ns", "with ns'(1)"], ["proof (chain)\npicking this:\n  g \\<turnstile> Entry g-ns'\\<rightarrow>m\n  old.dominates g (defNode g v') m", "have \"?n' \\<in> set ns'\""], ["proof (prove)\nusing this:\n  g \\<turnstile> Entry g-ns'\\<rightarrow>m\n  old.dominates g (defNode g v') m\n\ngoal (1 subgoal):\n 1. defNode g v' \\<in> set ns'", "by - (erule old.dominatesE)"], ["proof (state)\nthis:\n  defNode g v' \\<in> set ns'\n\ngoal (2 subgoals):\n 1. defNode g v \\<in> set (\\<alpha>n g)\n 2. \\<And>ns.\n       g \\<turnstile> Entry g-ns\\<rightarrow>defNode g v \\<Longrightarrow>\n       defNode g v' \\<in> set ns", "with ns'(4)"], ["proof (chain)\npicking this:\n  set ns' \\<subseteq> set ns\n  defNode g v' \\<in> set ns'", "show \"?n' \\<in> set ns\""], ["proof (prove)\nusing this:\n  set ns' \\<subseteq> set ns\n  defNode g v' \\<in> set ns'\n\ngoal (1 subgoal):\n 1. defNode g v' \\<in> set ns", "by auto"], ["proof (state)\nthis:\n  defNode g v' \\<in> set ns\n\ngoal (1 subgoal):\n 1. defNode g v \\<in> set (\\<alpha>n g)", "qed auto"], ["proof (state)\nthis:\n  def_dominates g v' v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isTrivialPhi_asymmetric:\n  assumes \"isTrivialPhi g a b\"\n    and \"isTrivialPhi g b a\"\n  shows \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  isTrivialPhi g a b\n  isTrivialPhi g b a\n\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>isTrivialPhi g a b; isTrivialPhi g b a\\<rbrakk>\n    \\<Longrightarrow> False", "from \\<open>isTrivialPhi g a b\\<close>"], ["proof (chain)\npicking this:\n  isTrivialPhi g a b", "have \"b \\<in> allVars g\""], ["proof (prove)\nusing this:\n  isTrivialPhi g a b\n\ngoal (1 subgoal):\n 1. b \\<in> allVars g", "unfolding isTrivialPhi_def"], ["proof (prove)\nusing this:\n  b \\<noteq> a \\<and>\n  (case phi g a of None \\<Rightarrow> False\n   | Some vs \\<Rightarrow> set vs = {a, b} \\<or> set vs = {b})\n\ngoal (1 subgoal):\n 1. b \\<in> allVars g", "by (fastforce intro!: phiArg_in_allVars simp: phiArg_def split: option.splits)"], ["proof (state)\nthis:\n  b \\<in> allVars g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isTrivialPhi g a b; isTrivialPhi g b a\\<rbrakk>\n    \\<Longrightarrow> False", "from \\<open>isTrivialPhi g b a\\<close>"], ["proof (chain)\npicking this:\n  isTrivialPhi g b a", "have \"a \\<in> allVars g\""], ["proof (prove)\nusing this:\n  isTrivialPhi g b a\n\ngoal (1 subgoal):\n 1. a \\<in> allVars g", "unfolding isTrivialPhi_def"], ["proof (prove)\nusing this:\n  a \\<noteq> b \\<and>\n  (case phi g b of None \\<Rightarrow> False\n   | Some vs \\<Rightarrow> set vs = {b, a} \\<or> set vs = {a})\n\ngoal (1 subgoal):\n 1. a \\<in> allVars g", "by (fastforce intro!: phiArg_in_allVars simp: phiArg_def split: option.splits)"], ["proof (state)\nthis:\n  a \\<in> allVars g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isTrivialPhi g a b; isTrivialPhi g b a\\<rbrakk>\n    \\<Longrightarrow> False", "from trivialPhi_strict_dom [OF \\<open>a \\<in> allVars g\\<close> assms(1)]\n       trivialPhi_strict_dom [OF \\<open>b \\<in> allVars g\\<close> assms(2)]"], ["proof (chain)\npicking this:\n  defNode g b \\<noteq> defNode g a \\<and> def_dominates g b a\n  defNode g a \\<noteq> defNode g b \\<and> def_dominates g a b", "show ?thesis"], ["proof (prove)\nusing this:\n  defNode g b \\<noteq> defNode g a \\<and> def_dominates g b a\n  defNode g a \\<noteq> defNode g b \\<and> def_dominates g a b\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma substitution[intro]: \"redundant g \\<Longrightarrow> isTrivialPhi g (chooseNext g) (substitution g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redundant g \\<Longrightarrow>\n    isTrivialPhi g (chooseNext g) (substitution g)", "unfolding substitution_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. redundant g \\<Longrightarrow>\n    isTrivialPhi g (chooseNext g) (THE v'. isTrivialPhi g (chooseNext g) v')", "by (rule theI', rule isTrivialPhi_det, simp add: chooseNext)"], ["", "lemma trivialPhi_in_allVars[simp]:\n    assumes \"isTrivialPhi g v v'\" and[simp]: \"v \\<in> allVars g\"\n    shows \"v' \\<in> allVars g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v' \\<in> allVars g", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. v' \\<in> allVars g", "from assms(1)"], ["proof (chain)\npicking this:\n  isTrivialPhi g v v'", "have \"phiArg g v v'\""], ["proof (prove)\nusing this:\n  isTrivialPhi g v v'\n\ngoal (1 subgoal):\n 1. phiArg g v v'", "unfolding phiArg_def"], ["proof (prove)\nusing this:\n  isTrivialPhi g v v'\n\ngoal (1 subgoal):\n 1. \\<exists>vs. phi g v = Some vs \\<and> v' \\<in> set vs", "by (auto simp:isTrivialPhi_def split:option.splits)"], ["proof (state)\nthis:\n  phiArg g v v'\n\ngoal (1 subgoal):\n 1. v' \\<in> allVars g", "thus \"v' \\<in> allVars g\""], ["proof (prove)\nusing this:\n  phiArg g v v'\n\ngoal (1 subgoal):\n 1. v' \\<in> allVars g", "by - (rule phiArg_in_allVars, auto)"], ["proof (state)\nthis:\n  v' \\<in> allVars g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma substitution_in_allVars[simp]:\n    assumes \"redundant g\"\n    shows \"substitution g \\<in> allVars g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. substitution g \\<in> allVars g", "using assms"], ["proof (prove)\nusing this:\n  redundant g\n\ngoal (1 subgoal):\n 1. substitution g \\<in> allVars g", "by - (rule trivialPhi_in_allVars, auto)"], ["", "lemma defs_uses_disjoint_inv:\n    assumes[simp]: \"n \\<in> set (\\<alpha>n g)\" \"redundant g\"\n    shows \"defs g n \\<inter> uses' g n = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. defs g n \\<inter> uses' g n = {}", "proof (rule equals0I)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> defs g n \\<inter> uses' g n \\<Longrightarrow> False", "fix v'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> defs g n \\<inter> uses' g n \\<Longrightarrow> False", "assume asm: \"v' \\<in> defs g n \\<inter> uses' g n\""], ["proof (state)\nthis:\n  v' \\<in> defs g n \\<inter> uses' g n\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> defs g n \\<inter> uses' g n \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  v' \\<in> defs g n \\<inter> uses' g n", "obtain v where v: \"v \\<in> uses g n\" \"v' = substNext g v\" and v': \"v' \\<in> defs g n\""], ["proof (prove)\nusing this:\n  v' \\<in> defs g n \\<inter> uses' g n\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> uses g n; v' = substNext g v;\n         v' \\<in> defs g n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<in> uses g n\n  v' = substNext g v\n  v' \\<in> defs g n\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> defs g n \\<inter> uses' g n \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"v = chooseNext g\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v = chooseNext g \\<Longrightarrow> False\n 2. v \\<noteq> chooseNext g \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  v \\<noteq> chooseNext g\n\ngoal (2 subgoals):\n 1. v = chooseNext g \\<Longrightarrow> False\n 2. v \\<noteq> chooseNext g \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<noteq> chooseNext g\n\ngoal (1 subgoal):\n 1. False", "using v v' defs_uses_disjoint[of n g]"], ["proof (prove)\nusing this:\n  v \\<noteq> chooseNext g\n  v \\<in> uses g n\n  v' = substNext g v\n  v' \\<in> defs g n\n  n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n  defs g n \\<inter> uses g n = {}\n\ngoal (1 subgoal):\n 1. False", "by (auto simp:substNext_def split:if_split_asm)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. v = chooseNext g \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v = chooseNext g \\<Longrightarrow> False", "case [simp]: True"], ["proof (state)\nthis:\n  v = chooseNext g\n\ngoal (1 subgoal):\n 1. v = chooseNext g \\<Longrightarrow> False", "from v'"], ["proof (chain)\npicking this:\n  v' \\<in> defs g n", "have n_defNode: \"n = defNode g v'\""], ["proof (prove)\nusing this:\n  v' \\<in> defs g n\n\ngoal (1 subgoal):\n 1. n = defNode g v'", "by - (rule defNode_eq[symmetric], auto)"], ["proof (state)\nthis:\n  n = defNode g v'\n\ngoal (1 subgoal):\n 1. v = chooseNext g \\<Longrightarrow> False", "from v(1)"], ["proof (chain)\npicking this:\n  v \\<in> uses g n", "have[simp]: \"v \\<in> allVars g\""], ["proof (prove)\nusing this:\n  v \\<in> uses g n\n\ngoal (1 subgoal):\n 1. v \\<in> allVars g", "by - (rule allUses_in_allVars[where n=n], auto)"], ["proof (state)\nthis:\n  v \\<in> allVars g\n\ngoal (1 subgoal):\n 1. v = chooseNext g \\<Longrightarrow> False", "let ?n' = \"defNode g v\""], ["proof (state)\ngoal (1 subgoal):\n 1. v = chooseNext g \\<Longrightarrow> False", "have \"old.strict_dom g n ?n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> defNode g v \\<and> old.dominates g n (defNode g v)", "by (simp only:n_defNode v(2), rule trivialPhi_strict_dom, auto simp:substNext_def)"], ["proof (state)\nthis:\n  n \\<noteq> defNode g v \\<and> old.dominates g n (defNode g v)\n\ngoal (1 subgoal):\n 1. v = chooseNext g \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  n \\<noteq> defNode g v \\<and> old.dominates g n (defNode g v)\n\ngoal (1 subgoal):\n 1. v = chooseNext g \\<Longrightarrow> False", "from v(1)"], ["proof (chain)\npicking this:\n  v \\<in> uses g n", "have \"old.dominates g ?n' n\""], ["proof (prove)\nusing this:\n  v \\<in> uses g n\n\ngoal (1 subgoal):\n 1. old.dominates g (defNode g v) n", "by - (rule allUses_dominated, auto)"], ["proof (state)\nthis:\n  old.dominates g (defNode g v) n\n\ngoal (1 subgoal):\n 1. v = chooseNext g \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  n \\<noteq> defNode g v \\<and> old.dominates g n (defNode g v)\n  old.dominates g (defNode g v) n", "show False"], ["proof (prove)\nusing this:\n  n \\<noteq> defNode g v \\<and> old.dominates g n (defNode g v)\n  old.dominates g (defNode g v) n\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context CFG_SSA_wf\nbegin"], ["", "inductive liveVal' :: \"'g \\<Rightarrow> 'val list \\<Rightarrow> bool\"\n    for g :: 'g\n  where\n    liveSimple': \"\\<lbrakk>n \\<in> set (\\<alpha>n g); val \\<in> uses g n\\<rbrakk> \\<Longrightarrow> liveVal' g [val]\"\n  | livePhi': \"\\<lbrakk>liveVal' g (v#vs); phiArg g v v'\\<rbrakk> \\<Longrightarrow> liveVal' g (v'#v#vs)\""], ["", "lemma liveVal'_suffix:\n    assumes \"liveVal' g vs\" \"suffix vs' vs\" \"vs' \\<noteq> []\"\n    shows \"liveVal' g vs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liveVal' g vs'", "using assms"], ["proof (prove)\nusing this:\n  liveVal' g vs\n  suffix vs' vs\n  vs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. liveVal' g vs'", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n val.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); val \\<in> uses g n;\n        suffix vs' [val]; vs' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> liveVal' g vs'\n 2. \\<And>v vs v'.\n       \\<lbrakk>liveVal' g (v # vs);\n        \\<lbrakk>suffix vs' (v # vs); vs' \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> liveVal' g vs';\n        phiArg g v v'; suffix vs' (v' # v # vs); vs' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> liveVal' g vs'", "case (liveSimple' n v)"], ["proof (state)\nthis:\n  n \\<in> set (\\<alpha>n g)\n  v \\<in> uses g n\n  suffix vs' [v]\n  vs' \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>n val.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); val \\<in> uses g n;\n        suffix vs' [val]; vs' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> liveVal' g vs'\n 2. \\<And>v vs v'.\n       \\<lbrakk>liveVal' g (v # vs);\n        \\<lbrakk>suffix vs' (v # vs); vs' \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> liveVal' g vs';\n        phiArg g v v'; suffix vs' (v' # v # vs); vs' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> liveVal' g vs'", "from liveSimple'.prems"], ["proof (chain)\npicking this:\n  suffix vs' [v]\n  vs' \\<noteq> []", "have \"vs' = [v]\""], ["proof (prove)\nusing this:\n  suffix vs' [v]\n  vs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. vs' = [v]", "by (metis append_Nil butlast.simps(2) suffixI suffix_order.antisym suffix_unsnoc)"], ["proof (state)\nthis:\n  vs' = [v]\n\ngoal (2 subgoals):\n 1. \\<And>n val.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); val \\<in> uses g n;\n        suffix vs' [val]; vs' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> liveVal' g vs'\n 2. \\<And>v vs v'.\n       \\<lbrakk>liveVal' g (v # vs);\n        \\<lbrakk>suffix vs' (v # vs); vs' \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> liveVal' g vs';\n        phiArg g v v'; suffix vs' (v' # v # vs); vs' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> liveVal' g vs'", "with liveSimple'.hyps"], ["proof (chain)\npicking this:\n  n \\<in> set (\\<alpha>n g)\n  v \\<in> uses g n\n  vs' = [v]", "show ?case"], ["proof (prove)\nusing this:\n  n \\<in> set (\\<alpha>n g)\n  v \\<in> uses g n\n  vs' = [v]\n\ngoal (1 subgoal):\n 1. liveVal' g vs'", "by (auto intro: liveVal'.liveSimple')"], ["proof (state)\nthis:\n  liveVal' g vs'\n\ngoal (1 subgoal):\n 1. \\<And>v vs v'.\n       \\<lbrakk>liveVal' g (v # vs);\n        \\<lbrakk>suffix vs' (v # vs); vs' \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> liveVal' g vs';\n        phiArg g v v'; suffix vs' (v' # v # vs); vs' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> liveVal' g vs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v vs v'.\n       \\<lbrakk>liveVal' g (v # vs);\n        \\<lbrakk>suffix vs' (v # vs); vs' \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> liveVal' g vs';\n        phiArg g v v'; suffix vs' (v' # v # vs); vs' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> liveVal' g vs'", "case (livePhi' v vs v')"], ["proof (state)\nthis:\n  liveVal' g (v # vs)\n  phiArg g v v'\n  \\<lbrakk>suffix vs' (v # vs); vs' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> liveVal' g vs'\n  suffix vs' (v' # v # vs)\n  vs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>v vs v'.\n       \\<lbrakk>liveVal' g (v # vs);\n        \\<lbrakk>suffix vs' (v # vs); vs' \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> liveVal' g vs';\n        phiArg g v v'; suffix vs' (v' # v # vs); vs' \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> liveVal' g vs'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. liveVal' g vs'", "proof (cases \"vs' = v' # v # vs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. vs' = v' # v # vs \\<Longrightarrow> liveVal' g vs'\n 2. vs' \\<noteq> v' # v # vs \\<Longrightarrow> liveVal' g vs'", "case True"], ["proof (state)\nthis:\n  vs' = v' # v # vs\n\ngoal (2 subgoals):\n 1. vs' = v' # v # vs \\<Longrightarrow> liveVal' g vs'\n 2. vs' \\<noteq> v' # v # vs \\<Longrightarrow> liveVal' g vs'", "with livePhi'"], ["proof (chain)\npicking this:\n  liveVal' g (v # vs)\n  phiArg g v v'\n  \\<lbrakk>suffix vs' (v # vs); vs' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> liveVal' g vs'\n  suffix vs' (v' # v # vs)\n  vs' \\<noteq> []\n  vs' = v' # v # vs", "show ?thesis"], ["proof (prove)\nusing this:\n  liveVal' g (v # vs)\n  phiArg g v v'\n  \\<lbrakk>suffix vs' (v # vs); vs' \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> liveVal' g vs'\n  suffix vs' (v' # v # vs)\n  vs' \\<noteq> []\n  vs' = v' # v # vs\n\ngoal (1 subgoal):\n 1. liveVal' g vs'", "by - (auto intro: liveVal'.livePhi')"], ["proof (state)\nthis:\n  liveVal' g vs'\n\ngoal (1 subgoal):\n 1. vs' \\<noteq> v' # v # vs \\<Longrightarrow> liveVal' g vs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. vs' \\<noteq> v' # v # vs \\<Longrightarrow> liveVal' g vs'", "case False"], ["proof (state)\nthis:\n  vs' \\<noteq> v' # v # vs\n\ngoal (1 subgoal):\n 1. vs' \\<noteq> v' # v # vs \\<Longrightarrow> liveVal' g vs'", "with livePhi'.prems"], ["proof (chain)\npicking this:\n  suffix vs' (v' # v # vs)\n  vs' \\<noteq> []\n  vs' \\<noteq> v' # v # vs", "have \"suffix vs' (v#vs)\""], ["proof (prove)\nusing this:\n  suffix vs' (v' # v # vs)\n  vs' \\<noteq> []\n  vs' \\<noteq> v' # v # vs\n\ngoal (1 subgoal):\n 1. suffix vs' (v # vs)", "by (metis list.sel(3) self_append_conv2 suffixI suffix_take tl_append2)"], ["proof (state)\nthis:\n  suffix vs' (v # vs)\n\ngoal (1 subgoal):\n 1. vs' \\<noteq> v' # v # vs \\<Longrightarrow> liveVal' g vs'", "with livePhi'.prems(2)"], ["proof (chain)\npicking this:\n  vs' \\<noteq> []\n  suffix vs' (v # vs)", "show ?thesis"], ["proof (prove)\nusing this:\n  vs' \\<noteq> []\n  suffix vs' (v # vs)\n\ngoal (1 subgoal):\n 1. liveVal' g vs'", "by - (rule livePhi'.IH)"], ["proof (state)\nthis:\n  liveVal' g vs'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  liveVal' g vs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma liveVal'I:\n    assumes \"liveVal g v\"\n    obtains vs where \"liveVal' g (v#vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>vs.\n        liveVal' g (v # vs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  liveVal g v\n\ngoal (1 subgoal):\n 1. (\\<And>vs.\n        liveVal' g (v # vs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n val.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); val \\<in> uses g n;\n        \\<And>vs. liveVal' g (val # vs) \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>v v'.\n       \\<lbrakk>liveVal g v;\n        (\\<And>vs.\n            liveVal' g (v # vs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n        thesis;\n        phiArg g v v';\n        \\<And>vs. liveVal' g (v' # vs) \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (liveSimple n v)"], ["proof (state)\nthis:\n  n \\<in> set (\\<alpha>n g)\n  v \\<in> uses g n\n  liveVal' g (v # ?vs1) \\<Longrightarrow> thesis\n\ngoal (2 subgoals):\n 1. \\<And>n val.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); val \\<in> uses g n;\n        \\<And>vs. liveVal' g (val # vs) \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>v v'.\n       \\<lbrakk>liveVal g v;\n        (\\<And>vs.\n            liveVal' g (v # vs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n        thesis;\n        phiArg g v v';\n        \\<And>vs. liveVal' g (v' # vs) \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "thus thesis"], ["proof (prove)\nusing this:\n  n \\<in> set (\\<alpha>n g)\n  v \\<in> uses g n\n  liveVal' g (v # ?vs1) \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by - (rule liveSimple(3), rule liveSimple')"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>liveVal g v;\n        (\\<And>vs.\n            liveVal' g (v # vs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n        thesis;\n        phiArg g v v';\n        \\<And>vs. liveVal' g (v' # vs) \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>liveVal g v;\n        (\\<And>vs.\n            liveVal' g (v # vs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n        thesis;\n        phiArg g v v';\n        \\<And>vs. liveVal' g (v' # vs) \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (livePhi v v')"], ["proof (state)\nthis:\n  liveVal g v\n  phiArg g v v'\n  (\\<And>vs. liveVal' g (v # vs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n  thesis\n  liveVal' g (v' # ?vs1) \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<And>v v'.\n       \\<lbrakk>liveVal g v;\n        (\\<And>vs.\n            liveVal' g (v # vs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n        thesis;\n        phiArg g v v';\n        \\<And>vs. liveVal' g (v' # vs) \\<Longrightarrow> thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule livePhi.IH)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vs. liveVal' g (v # vs) \\<Longrightarrow> thesis", "fix vs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vs. liveVal' g (v # vs) \\<Longrightarrow> thesis", "assume asm: \"liveVal' g (v#vs)\""], ["proof (state)\nthis:\n  liveVal' g (v # vs)\n\ngoal (1 subgoal):\n 1. \\<And>vs. liveVal' g (v # vs) \\<Longrightarrow> thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"v' \\<in> set (v#vs)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v' \\<in> set (v # vs) \\<Longrightarrow> thesis\n 2. v' \\<notin> set (v # vs) \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  v' \\<notin> set (v # vs)\n\ngoal (2 subgoals):\n 1. v' \\<in> set (v # vs) \\<Longrightarrow> thesis\n 2. v' \\<notin> set (v # vs) \\<Longrightarrow> thesis", "with livePhi.hyps asm"], ["proof (chain)\npicking this:\n  liveVal g v\n  phiArg g v v'\n  liveVal' g (v # vs)\n  v' \\<notin> set (v # vs)", "show thesis"], ["proof (prove)\nusing this:\n  liveVal g v\n  phiArg g v v'\n  liveVal' g (v # vs)\n  v' \\<notin> set (v # vs)\n\ngoal (1 subgoal):\n 1. thesis", "by - (rule livePhi.prems, rule livePhi')"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. v' \\<in> set (v # vs) \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v' \\<in> set (v # vs) \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  v' \\<in> set (v # vs)\n\ngoal (1 subgoal):\n 1. v' \\<in> set (v # vs) \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  v' \\<in> set (v # vs)", "obtain vs' where \"suffix (v'#vs') (v#vs)\""], ["proof (prove)\nusing this:\n  v' \\<in> set (v # vs)\n\ngoal (1 subgoal):\n 1. (\\<And>vs'.\n        suffix (v' # vs') (v # vs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by - (drule split_list_last, auto simp: Sublist.suffix_def)"], ["proof (state)\nthis:\n  suffix (v' # vs') (v # vs)\n\ngoal (1 subgoal):\n 1. v' \\<in> set (v # vs) \\<Longrightarrow> thesis", "with asm"], ["proof (chain)\npicking this:\n  liveVal' g (v # vs)\n  suffix (v' # vs') (v # vs)", "show thesis"], ["proof (prove)\nusing this:\n  liveVal' g (v # vs)\n  suffix (v' # vs') (v # vs)\n\ngoal (1 subgoal):\n 1. thesis", "by - (rule livePhi.prems, rule liveVal'_suffix, simp_all)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma liveVal'D:\n    assumes \"liveVal' g vs\" \"vs = v#vs'\"\n    shows \"liveVal g v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liveVal g v", "using assms"], ["proof (prove)\nusing this:\n  liveVal' g vs\n  vs = v # vs'\n\ngoal (1 subgoal):\n 1. liveVal g v", "proof (induction arbitrary: v vs')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n val v vs'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); val \\<in> uses g n;\n        [val] = v # vs'\\<rbrakk>\n       \\<Longrightarrow> liveVal g v\n 2. \\<And>v vs v' va vs'.\n       \\<lbrakk>liveVal' g (v # vs);\n        \\<And>va vs'. v # vs = va # vs' \\<Longrightarrow> liveVal g va;\n        phiArg g v v'; v' # v # vs = va # vs'\\<rbrakk>\n       \\<Longrightarrow> liveVal g va", "case (liveSimple' n vs)"], ["proof (state)\nthis:\n  n \\<in> set (\\<alpha>n g)\n  vs \\<in> uses g n\n  [vs] = v # vs'\n\ngoal (2 subgoals):\n 1. \\<And>n val v vs'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); val \\<in> uses g n;\n        [val] = v # vs'\\<rbrakk>\n       \\<Longrightarrow> liveVal g v\n 2. \\<And>v vs v' va vs'.\n       \\<lbrakk>liveVal' g (v # vs);\n        \\<And>va vs'. v # vs = va # vs' \\<Longrightarrow> liveVal g va;\n        phiArg g v v'; v' # v # vs = va # vs'\\<rbrakk>\n       \\<Longrightarrow> liveVal g va", "thus ?case"], ["proof (prove)\nusing this:\n  n \\<in> set (\\<alpha>n g)\n  vs \\<in> uses g n\n  [vs] = v # vs'\n\ngoal (1 subgoal):\n 1. liveVal g v", "by - (rule liveSimple, auto)"], ["proof (state)\nthis:\n  liveVal g v\n\ngoal (1 subgoal):\n 1. \\<And>v vs v' va vs'.\n       \\<lbrakk>liveVal' g (v # vs);\n        \\<And>va vs'. v # vs = va # vs' \\<Longrightarrow> liveVal g va;\n        phiArg g v v'; v' # v # vs = va # vs'\\<rbrakk>\n       \\<Longrightarrow> liveVal g va", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v vs v' va vs'.\n       \\<lbrakk>liveVal' g (v # vs);\n        \\<And>va vs'. v # vs = va # vs' \\<Longrightarrow> liveVal g va;\n        phiArg g v v'; v' # v # vs = va # vs'\\<rbrakk>\n       \\<Longrightarrow> liveVal g va", "case (livePhi' v\\<^sub>2 vs v')"], ["proof (state)\nthis:\n  liveVal' g (v\\<^sub>2 # vs)\n  phiArg g v\\<^sub>2 v'\n  v\\<^sub>2 # vs = ?v1 # ?vs'1 \\<Longrightarrow> liveVal g ?v1\n  v' # v\\<^sub>2 # vs = v # vs'\n\ngoal (1 subgoal):\n 1. \\<And>v vs v' va vs'.\n       \\<lbrakk>liveVal' g (v # vs);\n        \\<And>va vs'. v # vs = va # vs' \\<Longrightarrow> liveVal g va;\n        phiArg g v v'; v' # v # vs = va # vs'\\<rbrakk>\n       \\<Longrightarrow> liveVal g va", "thus ?case"], ["proof (prove)\nusing this:\n  liveVal' g (v\\<^sub>2 # vs)\n  phiArg g v\\<^sub>2 v'\n  v\\<^sub>2 # vs = ?v1 # ?vs'1 \\<Longrightarrow> liveVal g ?v1\n  v' # v\\<^sub>2 # vs = v # vs'\n\ngoal (1 subgoal):\n 1. liveVal g v", "by - (rule livePhi, auto)"], ["proof (state)\nthis:\n  liveVal g v\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale CFG_SSA_step = CFG_SSA_Transformed_notriv \\<alpha>e \\<alpha>n invar inEdges' Entry oldDefs oldUses \"defs\" \"uses\" phis var chooseNext_all\nfor\n  \\<alpha>e :: \"'g \\<Rightarrow> ('node::linorder \\<times> 'edgeD \\<times> 'node) set\" and\n  \\<alpha>n :: \"'g \\<Rightarrow> 'node list\" and\n  invar :: \"'g \\<Rightarrow> bool\" and\n  inEdges' :: \"'g \\<Rightarrow> 'node \\<Rightarrow> ('node \\<times> 'edgeD) list\" and\n  Entry::\"'g \\<Rightarrow> 'node\" and\n  \"oldDefs\" :: \"'g \\<Rightarrow> 'node \\<Rightarrow> 'var::linorder set\" and\n  \"oldUses\" :: \"'g \\<Rightarrow> 'node \\<Rightarrow> 'var set\" and\n  \"defs\" :: \"'g \\<Rightarrow> 'node \\<Rightarrow> 'val::linorder set\" and\n  \"uses\" :: \"'g \\<Rightarrow> 'node \\<Rightarrow> 'val set\" and\n  phis :: \"'g \\<Rightarrow> ('node, 'val) phis\" and\n  var :: \"'g \\<Rightarrow> 'val \\<Rightarrow> 'var\" and\n  chooseNext_all :: \"('node \\<Rightarrow> 'val set) \\<Rightarrow> ('node, 'val) phis \\<Rightarrow> 'g \\<Rightarrow> ('node \\<times> 'val)\" and\n  g :: \"'g\" +\nassumes redundant[simp]: \"redundant g\"\nbegin"], ["", "abbreviation \"u_g \\<equiv> uses(g:=uses' g)\""], ["", "abbreviation \"p_g \\<equiv> phis(g:=phis' g)\""], ["", "sublocale step: CFG_SSA_Transformed_notriv_base \\<alpha>e \\<alpha>n invar inEdges' Entry oldDefs oldUses \"defs\" u_g p_g var chooseNext_all"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma simpleDefs_phiDefs_disjoint_inv:\n    assumes \"n \\<in> set (\\<alpha>n g)\"\n    shows \"defs g n \\<inter> step.phiDefs g n = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. defs g n \\<inter> step.phiDefs g n = {}", "using simpleDefs_phiDefs_disjoint[OF assms]"], ["proof (prove)\nusing this:\n  defs g n \\<inter> phiDefs g n = {}\n\ngoal (1 subgoal):\n 1. defs g n \\<inter> step.phiDefs g n = {}", "by (auto simp: phiDefs_def step.phiDefs_def dom_def split:option.splits)"], ["", "lemma allDefs_disjoint_inv:\n    assumes \"n \\<in> set (\\<alpha>n g)\" \"m \\<in> set (\\<alpha>n g)\" \"n \\<noteq> m\"\n    shows \"step.allDefs g n \\<inter> step.allDefs g m = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step.allDefs g n \\<inter> step.allDefs g m = {}", "using allDefs_disjoint[OF assms]"], ["proof (prove)\nusing this:\n  allDefs g n \\<inter> allDefs g m = {}\n\ngoal (1 subgoal):\n 1. step.allDefs g n \\<inter> step.allDefs g m = {}", "by (auto simp: CFG_SSA_defs step.CFG_SSA_defs dom_def split:option.splits)"], ["", "lemma phis_finite_inv:\n    shows \"finite (dom (phis' g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom (phis' g))", "using phis_finite[of g]"], ["proof (prove)\nusing this:\n  finite (dom (phis g))\n\ngoal (1 subgoal):\n 1. finite (dom (phis' g))", "by - (rule finite_subset, auto split:if_split_asm)"], ["", "lemma phis_wf_inv:\n    assumes \"phis' g (n, v) = Some args\"\n    shows \"length (old.predecessors g n) = length args\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (old.predecessors g n) = length args", "using phis_wf[of g] assms"], ["proof (prove)\nusing this:\n  phis g (?n, ?v) = Some ?args \\<Longrightarrow>\n  length (old.predecessors g ?n) = length ?args\n  phis' g (n, v) = Some args\n\ngoal (1 subgoal):\n 1. length (old.predecessors g n) = length args", "by (auto split:if_split_asm)"], ["", "sublocale step: CFG_SSA \\<alpha>e \\<alpha>n invar inEdges' Entry \"defs\" u_g p_g"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_SSA \\<alpha>e \\<alpha>n invar inEdges' Entry defs u_g p_g", "apply unfold_locales"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> u_g g n = {}\n 2. \\<And>g n. finite (defs g n)\n 3. \\<And>v g n. v \\<in> u_g g n \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 4. \\<And>g n. finite (u_g g n)\n 5. \\<And>g. invar g\n 6. \\<And>g. finite (dom (p_g g))\n 7. \\<And>g n v vs.\n       p_g g (n, v) = Some vs \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 8. \\<And>g n v args.\n       p_g g (n, v) = Some args \\<Longrightarrow>\n       length (old.predecessors g n) = length args\n 9. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> step.phiDefs g n = {}\n 10. \\<And>n g m.\n        \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n         n \\<noteq> m\\<rbrakk>\n        \\<Longrightarrow> step.allDefs g n \\<inter> step.allDefs g m = {}", "apply (rename_tac g')"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>n g'.\n       n \\<in> set (\\<alpha>n g') \\<Longrightarrow>\n       defs g' n \\<inter> u_g g' n = {}\n 2. \\<And>g n. finite (defs g n)\n 3. \\<And>v g n. v \\<in> u_g g n \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 4. \\<And>g n. finite (u_g g n)\n 5. \\<And>g. invar g\n 6. \\<And>g. finite (dom (p_g g))\n 7. \\<And>g n v vs.\n       p_g g (n, v) = Some vs \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 8. \\<And>g n v args.\n       p_g g (n, v) = Some args \\<Longrightarrow>\n       length (old.predecessors g n) = length args\n 9. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> step.phiDefs g n = {}\n 10. \\<And>n g m.\n        \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n         n \\<noteq> m\\<rbrakk>\n        \\<Longrightarrow> step.allDefs g n \\<inter> step.allDefs g m = {}", "apply (case_tac \"g'=g\")"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>n g'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g'); g' = g\\<rbrakk>\n       \\<Longrightarrow> defs g' n \\<inter> u_g g' n = {}\n 2. \\<And>n g'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g'); g' \\<noteq> g\\<rbrakk>\n       \\<Longrightarrow> defs g' n \\<inter> u_g g' n = {}\n 3. \\<And>g n. finite (defs g n)\n 4. \\<And>v g n. v \\<in> u_g g n \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 5. \\<And>g n. finite (u_g g n)\n 6. \\<And>g. invar g\n 7. \\<And>g. finite (dom (p_g g))\n 8. \\<And>g n v vs.\n       p_g g (n, v) = Some vs \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 9. \\<And>g n v args.\n       p_g g (n, v) = Some args \\<Longrightarrow>\n       length (old.predecessors g n) = length args\n 10. \\<And>n g.\n        n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n        defs g n \\<inter> step.phiDefs g n = {}\nA total of 11 subgoals...", "apply (simp add:defs_uses_disjoint_inv[simplified])"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>n g'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g'); g' \\<noteq> g\\<rbrakk>\n       \\<Longrightarrow> defs g' n \\<inter> u_g g' n = {}\n 2. \\<And>g n. finite (defs g n)\n 3. \\<And>v g n. v \\<in> u_g g n \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 4. \\<And>g n. finite (u_g g n)\n 5. \\<And>g. invar g\n 6. \\<And>g. finite (dom (p_g g))\n 7. \\<And>g n v vs.\n       p_g g (n, v) = Some vs \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 8. \\<And>g n v args.\n       p_g g (n, v) = Some args \\<Longrightarrow>\n       length (old.predecessors g n) = length args\n 9. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> step.phiDefs g n = {}\n 10. \\<And>n g m.\n        \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n         n \\<noteq> m\\<rbrakk>\n        \\<Longrightarrow> step.allDefs g n \\<inter> step.allDefs g m = {}", "apply (simp add:defs_uses_disjoint)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>g n. finite (defs g n)\n 2. \\<And>v g n. v \\<in> u_g g n \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 3. \\<And>g n. finite (u_g g n)\n 4. \\<And>g. invar g\n 5. \\<And>g. finite (dom (p_g g))\n 6. \\<And>g n v vs.\n       p_g g (n, v) = Some vs \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 7. \\<And>g n v args.\n       p_g g (n, v) = Some args \\<Longrightarrow>\n       length (old.predecessors g n) = length args\n 8. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> step.phiDefs g n = {}\n 9. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> step.allDefs g n \\<inter> step.allDefs g m = {}", "apply (rule defs_finite)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>v g n. v \\<in> u_g g n \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 2. \\<And>g n. finite (u_g g n)\n 3. \\<And>g. invar g\n 4. \\<And>g. finite (dom (p_g g))\n 5. \\<And>g n v vs.\n       p_g g (n, v) = Some vs \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 6. \\<And>g n v args.\n       p_g g (n, v) = Some args \\<Longrightarrow>\n       length (old.predecessors g n) = length args\n 7. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> step.phiDefs g n = {}\n 8. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> step.allDefs g n \\<inter> step.allDefs g m = {}", "apply (auto simp: uses_in_\\<alpha>n split: if_split_asm)[1]"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>g n. finite (u_g g n)\n 2. \\<And>g. invar g\n 3. \\<And>g. finite (dom (p_g g))\n 4. \\<And>g n v vs.\n       p_g g (n, v) = Some vs \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 5. \\<And>g n v args.\n       p_g g (n, v) = Some args \\<Longrightarrow>\n       length (old.predecessors g n) = length args\n 6. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> step.phiDefs g n = {}\n 7. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> step.allDefs g n \\<inter> step.allDefs g m = {}", "apply (rename_tac g' n)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>g' n. finite (u_g g' n)\n 2. \\<And>g. invar g\n 3. \\<And>g. finite (dom (p_g g))\n 4. \\<And>g n v vs.\n       p_g g (n, v) = Some vs \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 5. \\<And>g n v args.\n       p_g g (n, v) = Some args \\<Longrightarrow>\n       length (old.predecessors g n) = length args\n 6. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> step.phiDefs g n = {}\n 7. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> step.allDefs g n \\<inter> step.allDefs g m = {}", "apply (case_tac \"g'=g\")"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>g' n. g' = g \\<Longrightarrow> finite (u_g g' n)\n 2. \\<And>g' n. g' \\<noteq> g \\<Longrightarrow> finite (u_g g' n)\n 3. \\<And>g. invar g\n 4. \\<And>g. finite (dom (p_g g))\n 5. \\<And>g n v vs.\n       p_g g (n, v) = Some vs \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 6. \\<And>g n v args.\n       p_g g (n, v) = Some args \\<Longrightarrow>\n       length (old.predecessors g n) = length args\n 7. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> step.phiDefs g n = {}\n 8. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> step.allDefs g n \\<inter> step.allDefs g m = {}", "apply simp"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>g' n. g' \\<noteq> g \\<Longrightarrow> finite (u_g g' n)\n 2. \\<And>g. invar g\n 3. \\<And>g. finite (dom (p_g g))\n 4. \\<And>g n v vs.\n       p_g g (n, v) = Some vs \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 5. \\<And>g n v args.\n       p_g g (n, v) = Some args \\<Longrightarrow>\n       length (old.predecessors g n) = length args\n 6. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> step.phiDefs g n = {}\n 7. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> step.allDefs g n \\<inter> step.allDefs g m = {}", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>g. invar g\n 2. \\<And>g. finite (dom (p_g g))\n 3. \\<And>g n v vs.\n       p_g g (n, v) = Some vs \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 4. \\<And>g n v args.\n       p_g g (n, v) = Some args \\<Longrightarrow>\n       length (old.predecessors g n) = length args\n 5. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> step.phiDefs g n = {}\n 6. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> step.allDefs g n \\<inter> step.allDefs g m = {}", "apply (rule invar)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>g. finite (dom (p_g g))\n 2. \\<And>g n v vs.\n       p_g g (n, v) = Some vs \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 3. \\<And>g n v args.\n       p_g g (n, v) = Some args \\<Longrightarrow>\n       length (old.predecessors g n) = length args\n 4. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> step.phiDefs g n = {}\n 5. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> step.allDefs g n \\<inter> step.allDefs g m = {}", "apply (rename_tac g')"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>g'. finite (dom (p_g g'))\n 2. \\<And>g n v vs.\n       p_g g (n, v) = Some vs \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 3. \\<And>g n v args.\n       p_g g (n, v) = Some args \\<Longrightarrow>\n       length (old.predecessors g n) = length args\n 4. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> step.phiDefs g n = {}\n 5. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> step.allDefs g n \\<inter> step.allDefs g m = {}", "apply (case_tac \"g'=g\")"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>g'. g' = g \\<Longrightarrow> finite (dom (p_g g'))\n 2. \\<And>g'. g' \\<noteq> g \\<Longrightarrow> finite (dom (p_g g'))\n 3. \\<And>g n v vs.\n       p_g g (n, v) = Some vs \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 4. \\<And>g n v args.\n       p_g g (n, v) = Some args \\<Longrightarrow>\n       length (old.predecessors g n) = length args\n 5. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> step.phiDefs g n = {}\n 6. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> step.allDefs g n \\<inter> step.allDefs g m = {}", "apply (simp add:phis_finite_inv)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>g'. g' \\<noteq> g \\<Longrightarrow> finite (dom (p_g g'))\n 2. \\<And>g n v vs.\n       p_g g (n, v) = Some vs \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 3. \\<And>g n v args.\n       p_g g (n, v) = Some args \\<Longrightarrow>\n       length (old.predecessors g n) = length args\n 4. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> step.phiDefs g n = {}\n 5. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> step.allDefs g n \\<inter> step.allDefs g m = {}", "apply (simp add:phis_finite)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>g n v vs.\n       p_g g (n, v) = Some vs \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 2. \\<And>g n v args.\n       p_g g (n, v) = Some args \\<Longrightarrow>\n       length (old.predecessors g n) = length args\n 3. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> step.phiDefs g n = {}\n 4. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> step.allDefs g n \\<inter> step.allDefs g m = {}", "apply (auto simp: phis_in_\\<alpha>n split: if_split_asm)[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>g n v args.\n       p_g g (n, v) = Some args \\<Longrightarrow>\n       length (old.predecessors g n) = length args\n 2. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> step.phiDefs g n = {}\n 3. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> step.allDefs g n \\<inter> step.allDefs g m = {}", "apply (rename_tac g' n v args)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>g' n v args.\n       p_g g' (n, v) = Some args \\<Longrightarrow>\n       length (old.predecessors g' n) = length args\n 2. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> step.phiDefs g n = {}\n 3. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> step.allDefs g n \\<inter> step.allDefs g m = {}", "apply (case_tac \"g'=g\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>g' n v args.\n       \\<lbrakk>p_g g' (n, v) = Some args; g' = g\\<rbrakk>\n       \\<Longrightarrow> length (old.predecessors g' n) = length args\n 2. \\<And>g' n v args.\n       \\<lbrakk>p_g g' (n, v) = Some args; g' \\<noteq> g\\<rbrakk>\n       \\<Longrightarrow> length (old.predecessors g' n) = length args\n 3. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> step.phiDefs g n = {}\n 4. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> step.allDefs g n \\<inter> step.allDefs g m = {}", "apply (simp add:phis_wf_inv)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>g' n v args.\n       \\<lbrakk>p_g g' (n, v) = Some args; g' \\<noteq> g\\<rbrakk>\n       \\<Longrightarrow> length (old.predecessors g' n) = length args\n 2. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> step.phiDefs g n = {}\n 3. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> step.allDefs g n \\<inter> step.allDefs g m = {}", "apply (simp add:phis_wf)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> step.phiDefs g n = {}\n 2. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> step.allDefs g n \\<inter> step.allDefs g m = {}", "apply (rename_tac g')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n g'.\n       n \\<in> set (\\<alpha>n g') \\<Longrightarrow>\n       defs g' n \\<inter> step.phiDefs g' n = {}\n 2. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> step.allDefs g n \\<inter> step.allDefs g m = {}", "apply (case_tac \"g'=g\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n g'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g'); g' = g\\<rbrakk>\n       \\<Longrightarrow> defs g' n \\<inter> step.phiDefs g' n = {}\n 2. \\<And>n g'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g'); g' \\<noteq> g\\<rbrakk>\n       \\<Longrightarrow> defs g' n \\<inter> step.phiDefs g' n = {}\n 3. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> step.allDefs g n \\<inter> step.allDefs g m = {}", "apply (simp add: simpleDefs_phiDefs_disjoint_inv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n g'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g'); g' \\<noteq> g\\<rbrakk>\n       \\<Longrightarrow> defs g' n \\<inter> step.phiDefs g' n = {}\n 2. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> step.allDefs g n \\<inter> step.allDefs g m = {}", "apply (simp add: simpleDefs_phiDefs_disjoint[unfolded CFG_SSA_defs] step.CFG_SSA_defs )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> step.allDefs g n \\<inter> step.allDefs g m = {}", "apply (rename_tac g' m)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n g' m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g'); m \\<in> set (\\<alpha>n g');\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> step.allDefs g' n \\<inter> step.allDefs g' m = {}", "apply (case_tac \"g'=g\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n g' m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g'); m \\<in> set (\\<alpha>n g');\n        n \\<noteq> m; g' = g\\<rbrakk>\n       \\<Longrightarrow> step.allDefs g' n \\<inter> step.allDefs g' m = {}\n 2. \\<And>n g' m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g'); m \\<in> set (\\<alpha>n g');\n        n \\<noteq> m; g' \\<noteq> g\\<rbrakk>\n       \\<Longrightarrow> step.allDefs g' n \\<inter> step.allDefs g' m = {}", "apply (simp add: allDefs_disjoint_inv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n g' m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g'); m \\<in> set (\\<alpha>n g');\n        n \\<noteq> m; g' \\<noteq> g\\<rbrakk>\n       \\<Longrightarrow> step.allDefs g' n \\<inter> step.allDefs g' m = {}", "apply (simp add: allDefs_disjoint[unfolded CFG_SSA_defs] step.CFG_SSA_defs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma allUses_narrows:\n    assumes \"n \\<in> set (\\<alpha>n g)\"\n    shows \"step.allUses g n \\<subseteq> substNext g ` allUses g n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step.allUses g n \\<subseteq> substNext g ` allUses g n", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. step.allUses g n \\<subseteq> substNext g ` allUses g n", "have \"\\<And>n' v' z b. phis g (n', v') = Some z \\<Longrightarrow> (n, b) \\<in> set (zip (old.predecessors g n') z) \\<Longrightarrow> b \\<notin> phiUses g n \\<Longrightarrow> b \\<in> uses g n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n' v' z b.\n       \\<lbrakk>phis g (n', v') = Some z;\n        (n, b) \\<in> set (zip (old.predecessors g n') z);\n        b \\<notin> phiUses g n\\<rbrakk>\n       \\<Longrightarrow> b \\<in> uses g n", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n' v' z b.\n       \\<lbrakk>phis g (n', v') = Some z;\n        (n, b) \\<in> set (zip (old.predecessors g n') z);\n        b \\<notin> phiUses g n\\<rbrakk>\n       \\<Longrightarrow> b \\<in> uses g n", "fix n' v' z b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n' v' z b.\n       \\<lbrakk>phis g (n', v') = Some z;\n        (n, b) \\<in> set (zip (old.predecessors g n') z);\n        b \\<notin> phiUses g n\\<rbrakk>\n       \\<Longrightarrow> b \\<in> uses g n", "assume \"(n, b) \\<in> set (zip (old.predecessors g n') (z :: 'val list))\""], ["proof (state)\nthis:\n  (n, b) \\<in> set (zip (old.predecessors g n') z)\n\ngoal (1 subgoal):\n 1. \\<And>n' v' z b.\n       \\<lbrakk>phis g (n', v') = Some z;\n        (n, b) \\<in> set (zip (old.predecessors g n') z);\n        b \\<notin> phiUses g n\\<rbrakk>\n       \\<Longrightarrow> b \\<in> uses g n", "with assms(1)"], ["proof (chain)\npicking this:\n  n \\<in> set (\\<alpha>n g)\n  (n, b) \\<in> set (zip (old.predecessors g n') z)", "have \"n' \\<in> set (\\<alpha>n g)\""], ["proof (prove)\nusing this:\n  n \\<in> set (\\<alpha>n g)\n  (n, b) \\<in> set (zip (old.predecessors g n') z)\n\ngoal (1 subgoal):\n 1. n' \\<in> set (\\<alpha>n g)", "by auto"], ["proof (state)\nthis:\n  n' \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. \\<And>n' v' z b.\n       \\<lbrakk>phis g (n', v') = Some z;\n        (n, b) \\<in> set (zip (old.predecessors g n') z);\n        b \\<notin> phiUses g n\\<rbrakk>\n       \\<Longrightarrow> b \\<in> uses g n", "thus \"phis g (n', v') = Some z \\<Longrightarrow> (n, b) \\<in> set (zip (old.predecessors g n') z) \\<Longrightarrow> b \\<notin> phiUses g n \\<Longrightarrow> b \\<in> uses g n\""], ["proof (prove)\nusing this:\n  n' \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>phis g (n', v') = Some z;\n     (n, b) \\<in> set (zip (old.predecessors g n') z);\n     b \\<notin> phiUses g n\\<rbrakk>\n    \\<Longrightarrow> b \\<in> uses g n", "by (auto intro:phiUsesI)"], ["proof (state)\nthis:\n  \\<lbrakk>phis g (n', v') = Some z;\n   (n, b) \\<in> set (zip (old.predecessors g n') z);\n   b \\<notin> phiUses g n\\<rbrakk>\n  \\<Longrightarrow> b \\<in> uses g n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>phis g (?n'1, ?v'1) = Some ?z1;\n   (n, ?b1) \\<in> set (zip (old.predecessors g ?n'1) ?z1);\n   ?b1 \\<notin> phiUses g n\\<rbrakk>\n  \\<Longrightarrow> ?b1 \\<in> uses g n\n\ngoal (1 subgoal):\n 1. step.allUses g n \\<subseteq> substNext g ` allUses g n", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>phis g (?n'1, ?v'1) = Some ?z1;\n   (n, ?b1) \\<in> set (zip (old.predecessors g ?n'1) ?z1);\n   ?b1 \\<notin> phiUses g n\\<rbrakk>\n  \\<Longrightarrow> ?b1 \\<in> uses g n\n\ngoal (1 subgoal):\n 1. step.allUses g n \\<subseteq> substNext g ` allUses g n", "by (auto simp:step.allUses_def allUses_def zip_map2 intro!:imageI elim!:step.phiUsesE phiUsesE split:if_split_asm)"], ["proof (state)\nthis:\n  step.allUses g n \\<subseteq> substNext g ` allUses g n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma allDefs_narrows[simp]: \"v \\<in> step.allDefs g n \\<Longrightarrow> v \\<in> allDefs g n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> step.allDefs g n \\<Longrightarrow> v \\<in> allDefs g n", "by (auto simp:step.allDefs_def step.phiDefs_def phiDefs_def allDefs_def split:if_split_asm)"], ["", "lemma allUses_def_ass_inv:\n    assumes \"v' \\<in> step.allUses g n\" \"n \\<in> set (\\<alpha>n g)\"\n    shows \"step.defAss g n v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step.defAss g n v'", "proof (rule step.defAssI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ns.\n       g \\<turnstile> Entry g-ns\\<rightarrow>n \\<Longrightarrow>\n       \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n", "fix ns"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ns.\n       g \\<turnstile> Entry g-ns\\<rightarrow>n \\<Longrightarrow>\n       \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n", "assume asm: \"g \\<turnstile> Entry g-ns\\<rightarrow>n\""], ["proof (state)\nthis:\n  g \\<turnstile> Entry g-ns\\<rightarrow>n\n\ngoal (1 subgoal):\n 1. \\<And>ns.\n       g \\<turnstile> Entry g-ns\\<rightarrow>n \\<Longrightarrow>\n       \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n", "from assms"], ["proof (chain)\npicking this:\n  v' \\<in> step.allUses g n\n  n \\<in> set (\\<alpha>n g)", "obtain v where v': \"v' = substNext g v\" and[simp]: \"v \\<in> allUses g n\""], ["proof (prove)\nusing this:\n  v' \\<in> step.allUses g n\n  n \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v' = substNext g v; v \\<in> allUses g n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using allUses_narrows"], ["proof (prove)\nusing this:\n  v' \\<in> step.allUses g n\n  n \\<in> set (\\<alpha>n g)\n  ?n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n  step.allUses g ?n \\<subseteq> substNext g ` allUses g ?n\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v' = substNext g v; v \\<in> allUses g n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v' = substNext g v\n  v \\<in> allUses g n\n\ngoal (1 subgoal):\n 1. \\<And>ns.\n       g \\<turnstile> Entry g-ns\\<rightarrow>n \\<Longrightarrow>\n       \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n", "with assms(2)"], ["proof (chain)\npicking this:\n  n \\<in> set (\\<alpha>n g)\n  v' = substNext g v\n  v \\<in> allUses g n", "have[simp]: \"v \\<in> allVars g\""], ["proof (prove)\nusing this:\n  n \\<in> set (\\<alpha>n g)\n  v' = substNext g v\n  v \\<in> allUses g n\n\ngoal (1 subgoal):\n 1. v \\<in> allVars g", "by - (rule allUses_in_allVars)"], ["proof (state)\nthis:\n  v \\<in> allVars g\n\ngoal (1 subgoal):\n 1. \\<And>ns.\n       g \\<turnstile> Entry g-ns\\<rightarrow>n \\<Longrightarrow>\n       \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n", "have[simp]: \"v' \\<in> allVars g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v' \\<in> allVars g", "by (simp add:substNext_def v')"], ["proof (state)\nthis:\n  v' \\<in> allVars g\n\ngoal (1 subgoal):\n 1. \\<And>ns.\n       g \\<turnstile> Entry g-ns\\<rightarrow>n \\<Longrightarrow>\n       \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n", "let ?n\\<^sub>v = \"defNode g v\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ns.\n       g \\<turnstile> Entry g-ns\\<rightarrow>n \\<Longrightarrow>\n       \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n", "let ?n\\<^sub>v\\<^sub>' = \"defNode g v'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ns.\n       g \\<turnstile> Entry g-ns\\<rightarrow>n \\<Longrightarrow>\n       \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n", "from assms(2) asm"], ["proof (chain)\npicking this:\n  n \\<in> set (\\<alpha>n g)\n  g \\<turnstile> Entry g-ns\\<rightarrow>n", "have 1: \"?n\\<^sub>v \\<in> set ns\""], ["proof (prove)\nusing this:\n  n \\<in> set (\\<alpha>n g)\n  g \\<turnstile> Entry g-ns\\<rightarrow>n\n\ngoal (1 subgoal):\n 1. defNode g v \\<in> set ns", "using allUses_def_ass[of v g n]"], ["proof (prove)\nusing this:\n  n \\<in> set (\\<alpha>n g)\n  g \\<turnstile> Entry g-ns\\<rightarrow>n\n  \\<lbrakk>v \\<in> allUses g n; n \\<in> set (\\<alpha>n g)\\<rbrakk>\n  \\<Longrightarrow> defAss g n v\n\ngoal (1 subgoal):\n 1. defNode g v \\<in> set ns", "by (simp add:defAss_defNode)"], ["proof (state)\nthis:\n  defNode g v \\<in> set ns\n\ngoal (1 subgoal):\n 1. \\<And>ns.\n       g \\<turnstile> Entry g-ns\\<rightarrow>n \\<Longrightarrow>\n       \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n", "then"], ["proof (chain)\npicking this:\n  defNode g v \\<in> set ns", "obtain ns\\<^sub>v where ns\\<^sub>v: \"prefix (ns\\<^sub>v@[?n\\<^sub>v]) ns\""], ["proof (prove)\nusing this:\n  defNode g v \\<in> set ns\n\ngoal (1 subgoal):\n 1. (\\<And>ns\\<^sub>v.\n        prefix (ns\\<^sub>v @ [defNode g v]) ns \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule prefix_split_first)"], ["proof (state)\nthis:\n  prefix (ns\\<^sub>v @ [defNode g v]) ns\n\ngoal (1 subgoal):\n 1. \\<And>ns.\n       g \\<turnstile> Entry g-ns\\<rightarrow>n \\<Longrightarrow>\n       \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n", "with asm"], ["proof (chain)\npicking this:\n  g \\<turnstile> Entry g-ns\\<rightarrow>n\n  prefix (ns\\<^sub>v @ [defNode g v]) ns", "have 2: \"g \\<turnstile> Entry g-ns\\<^sub>v@[?n\\<^sub>v]\\<rightarrow>?n\\<^sub>v\""], ["proof (prove)\nusing this:\n  g \\<turnstile> Entry g-ns\\<rightarrow>n\n  prefix (ns\\<^sub>v @ [defNode g v]) ns\n\ngoal (1 subgoal):\n 1. g \\<turnstile> Entry\n                    g-ns\\<^sub>v @ [defNode g v]\\<rightarrow>defNode g v", "by auto"], ["proof (state)\nthis:\n  g \\<turnstile> Entry g-ns\\<^sub>v @ [defNode g v]\\<rightarrow>defNode g v\n\ngoal (1 subgoal):\n 1. \\<And>ns.\n       g \\<turnstile> Entry g-ns\\<rightarrow>n \\<Longrightarrow>\n       \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n", "show \"\\<exists>n \\<in> set ns. v' \\<in> step.allDefs g n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n", "proof (cases \"v = chooseNext g\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v = chooseNext g \\<Longrightarrow>\n    \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n\n 2. v \\<noteq> chooseNext g \\<Longrightarrow>\n    \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n", "case True"], ["proof (state)\nthis:\n  v = chooseNext g\n\ngoal (2 subgoals):\n 1. v = chooseNext g \\<Longrightarrow>\n    \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n\n 2. v \\<noteq> chooseNext g \\<Longrightarrow>\n    \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n", "hence dom: \"strict_def_dom g v' v\""], ["proof (prove)\nusing this:\n  v = chooseNext g\n\ngoal (1 subgoal):\n 1. defNode g v' \\<noteq> defNode g v \\<and> def_dominates g v' v", "using substitution[of g]"], ["proof (prove)\nusing this:\n  v = chooseNext g\n  redundant g \\<Longrightarrow>\n  isTrivialPhi g (chooseNext g) (substitution g)\n\ngoal (1 subgoal):\n 1. defNode g v' \\<noteq> defNode g v \\<and> def_dominates g v' v", "by - (rule trivialPhi_strict_dom, simp_all add:substNext_def v')"], ["proof (state)\nthis:\n  defNode g v' \\<noteq> defNode g v \\<and> def_dominates g v' v\n\ngoal (2 subgoals):\n 1. v = chooseNext g \\<Longrightarrow>\n    \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n\n 2. v \\<noteq> chooseNext g \\<Longrightarrow>\n    \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n", "hence[simp]: \"v' \\<noteq> v\""], ["proof (prove)\nusing this:\n  defNode g v' \\<noteq> defNode g v \\<and> def_dominates g v' v\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v", "by auto"], ["proof (state)\nthis:\n  v' \\<noteq> v\n\ngoal (2 subgoals):\n 1. v = chooseNext g \\<Longrightarrow>\n    \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n\n 2. v \\<noteq> chooseNext g \\<Longrightarrow>\n    \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n", "have \"v' \\<in> allDefs g ?n\\<^sub>v\\<^sub>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v' \\<in> allDefs g (defNode g v')", "by simp"], ["proof (state)\nthis:\n  v' \\<in> allDefs g (defNode g v')\n\ngoal (2 subgoals):\n 1. v = chooseNext g \\<Longrightarrow>\n    \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n\n 2. v \\<noteq> chooseNext g \\<Longrightarrow>\n    \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n", "hence \"v' \\<in> step.allDefs g ?n\\<^sub>v\\<^sub>'\""], ["proof (prove)\nusing this:\n  v' \\<in> allDefs g (defNode g v')\n\ngoal (1 subgoal):\n 1. v' \\<in> step.allDefs g (defNode g v')", "unfolding step.allDefs_def step.phiDefs_def allDefs_def phiDefs_def"], ["proof (prove)\nusing this:\n  v' \\<in> defs g (defNode g v') \\<union>\n           {v. (defNode g v', v) \\<in> dom (phis g)}\n\ngoal (1 subgoal):\n 1. v' \\<in> defs g (defNode g v') \\<union>\n             {v. (defNode g v', v) \\<in> dom (p_g g)}", "by (auto simp:True[symmetric])"], ["proof (state)\nthis:\n  v' \\<in> step.allDefs g (defNode g v')\n\ngoal (2 subgoals):\n 1. v = chooseNext g \\<Longrightarrow>\n    \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n\n 2. v \\<noteq> chooseNext g \\<Longrightarrow>\n    \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n", "moreover"], ["proof (state)\nthis:\n  v' \\<in> step.allDefs g (defNode g v')\n\ngoal (2 subgoals):\n 1. v = chooseNext g \\<Longrightarrow>\n    \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n\n 2. v \\<noteq> chooseNext g \\<Longrightarrow>\n    \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n", "have \"?n\\<^sub>v\\<^sub>' \\<in> set ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. defNode g v' \\<in> set ns", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. defNode g v' \\<in> set ns", "from dom"], ["proof (chain)\npicking this:\n  defNode g v' \\<noteq> defNode g v \\<and> def_dominates g v' v", "have \"def_dominates g v' v\""], ["proof (prove)\nusing this:\n  defNode g v' \\<noteq> defNode g v \\<and> def_dominates g v' v\n\ngoal (1 subgoal):\n 1. def_dominates g v' v", "by auto"], ["proof (state)\nthis:\n  def_dominates g v' v\n\ngoal (1 subgoal):\n 1. defNode g v' \\<in> set ns", "hence \"?n\\<^sub>v\\<^sub>' \\<in> set (ns\\<^sub>v@[?n\\<^sub>v])\""], ["proof (prove)\nusing this:\n  def_dominates g v' v\n\ngoal (1 subgoal):\n 1. defNode g v' \\<in> set (ns\\<^sub>v @ [defNode g v])", "using 2"], ["proof (prove)\nusing this:\n  def_dominates g v' v\n  g \\<turnstile> Entry g-ns\\<^sub>v @ [defNode g v]\\<rightarrow>defNode g v\n\ngoal (1 subgoal):\n 1. defNode g v' \\<in> set (ns\\<^sub>v @ [defNode g v])", "by -(erule old.dominatesE)"], ["proof (state)\nthis:\n  defNode g v' \\<in> set (ns\\<^sub>v @ [defNode g v])\n\ngoal (1 subgoal):\n 1. defNode g v' \\<in> set ns", "with ns\\<^sub>v"], ["proof (chain)\npicking this:\n  prefix (ns\\<^sub>v @ [defNode g v]) ns\n  defNode g v' \\<in> set (ns\\<^sub>v @ [defNode g v])", "show ?thesis"], ["proof (prove)\nusing this:\n  prefix (ns\\<^sub>v @ [defNode g v]) ns\n  defNode g v' \\<in> set (ns\\<^sub>v @ [defNode g v])\n\ngoal (1 subgoal):\n 1. defNode g v' \\<in> set ns", "by auto"], ["proof (state)\nthis:\n  defNode g v' \\<in> set ns\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  defNode g v' \\<in> set ns\n\ngoal (2 subgoals):\n 1. v = chooseNext g \\<Longrightarrow>\n    \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n\n 2. v \\<noteq> chooseNext g \\<Longrightarrow>\n    \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n", "ultimately"], ["proof (chain)\npicking this:\n  v' \\<in> step.allDefs g (defNode g v')\n  defNode g v' \\<in> set ns", "show ?thesis"], ["proof (prove)\nusing this:\n  v' \\<in> step.allDefs g (defNode g v')\n  defNode g v' \\<in> set ns\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n", "by auto"], ["proof (state)\nthis:\n  \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n\n\ngoal (1 subgoal):\n 1. v \\<noteq> chooseNext g \\<Longrightarrow>\n    \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<noteq> chooseNext g \\<Longrightarrow>\n    \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n", "case [simp]: False"], ["proof (state)\nthis:\n  v \\<noteq> chooseNext g\n\ngoal (1 subgoal):\n 1. v \\<noteq> chooseNext g \\<Longrightarrow>\n    \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n", "have[simp]: \"v' = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v' = v", "by (simp add:v' substNext_def)"], ["proof (state)\nthis:\n  v' = v\n\ngoal (1 subgoal):\n 1. v \\<noteq> chooseNext g \\<Longrightarrow>\n    \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n", "have \"v \\<in> allDefs g ?n\\<^sub>v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> allDefs g (defNode g v)", "by simp"], ["proof (state)\nthis:\n  v \\<in> allDefs g (defNode g v)\n\ngoal (1 subgoal):\n 1. v \\<noteq> chooseNext g \\<Longrightarrow>\n    \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> allDefs g (defNode g v)\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n", "by - (rule bexI[of _ ?n\\<^sub>v\\<^sub>'], auto simp:allDefs_def step.allDefs_def step.phiDefs_def 1 phiDefs_def)"], ["proof (state)\nthis:\n  \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>n\\<in>set ns. v' \\<in> step.allDefs g n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Entry_no_phis_inv: \"phis' g (Entry g, v) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phis' g (Entry g, v) = None", "by (simp add:Entry_no_phis)"], ["", "sublocale step: CFG_SSA_wf \\<alpha>e \\<alpha>n invar inEdges' Entry \"defs\" u_g p_g"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_SSA_wf \\<alpha>e \\<alpha>n invar inEdges' Entry defs u_g p_g", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v g n.\n       \\<lbrakk>v \\<in> step.allUses g n; n \\<in> set (\\<alpha>n g)\\<rbrakk>\n       \\<Longrightarrow> step.defAss g n v\n 2. \\<And>g v. p_g g (Entry g, v) = None", "apply (rename_tac g' n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v g' n.\n       \\<lbrakk>v \\<in> step.allUses g' n;\n        n \\<in> set (\\<alpha>n g')\\<rbrakk>\n       \\<Longrightarrow> step.defAss g' n v\n 2. \\<And>g v. p_g g (Entry g, v) = None", "apply (case_tac \"g'=g\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v g' n.\n       \\<lbrakk>v \\<in> step.allUses g' n; n \\<in> set (\\<alpha>n g');\n        g' = g\\<rbrakk>\n       \\<Longrightarrow> step.defAss g' n v\n 2. \\<And>v g' n.\n       \\<lbrakk>v \\<in> step.allUses g' n; n \\<in> set (\\<alpha>n g');\n        g' \\<noteq> g\\<rbrakk>\n       \\<Longrightarrow> step.defAss g' n v\n 3. \\<And>g v. p_g g (Entry g, v) = None", "apply (simp add:allUses_def_ass_inv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v g' n.\n       \\<lbrakk>v \\<in> step.allUses g' n; n \\<in> set (\\<alpha>n g');\n        g' \\<noteq> g\\<rbrakk>\n       \\<Longrightarrow> step.defAss g' n v\n 2. \\<And>g v. p_g g (Entry g, v) = None", "apply (simp add:allUses_def_ass[unfolded CFG_SSA_defs, simplified] step.CFG_SSA_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g v. p_g g (Entry g, v) = None", "apply (rename_tac g' v)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g' v. p_g g' (Entry g', v) = None", "apply (case_tac \"g'=g\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>g' v. g' = g \\<Longrightarrow> p_g g' (Entry g', v) = None\n 2. \\<And>g' v. g' \\<noteq> g \\<Longrightarrow> p_g g' (Entry g', v) = None", "apply (simp add:Entry_no_phis_inv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g' v. g' \\<noteq> g \\<Longrightarrow> p_g g' (Entry g', v) = None", "apply (simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma chooseNext_eliminated: \"chooseNext g \\<notin> step.allDefs g (defNode g (chooseNext g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chooseNext g \\<notin> step.allDefs g (defNode g (chooseNext g))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. chooseNext g \\<notin> step.allDefs g (defNode g (chooseNext g))", "let ?v = \"chooseNext g\""], ["proof (state)\ngoal (1 subgoal):\n 1. chooseNext g \\<notin> step.allDefs g (defNode g (chooseNext g))", "let ?n = \"defNode g ?v\""], ["proof (state)\ngoal (1 subgoal):\n 1. chooseNext g \\<notin> step.allDefs g (defNode g (chooseNext g))", "from chooseNext[OF redundant]"], ["proof (chain)\npicking this:\n  chooseNext g \\<in> allVars g \\<and> trivial g (chooseNext g)", "have \"?v \\<in> phiDefs g ?n\" \"?n \\<in> set (\\<alpha>n g)\""], ["proof (prove)\nusing this:\n  chooseNext g \\<in> allVars g \\<and> trivial g (chooseNext g)\n\ngoal (1 subgoal):\n 1. chooseNext g \\<in> phiDefs g (defNode g (chooseNext g)) &&&\n    defNode g (chooseNext g) \\<in> set (\\<alpha>n g)", "by (auto simp: trivial_def isTrivialPhi_def phiDefs_def phi_def split: option.splits)"], ["proof (state)\nthis:\n  chooseNext g \\<in> phiDefs g (defNode g (chooseNext g))\n  defNode g (chooseNext g) \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. chooseNext g \\<notin> step.allDefs g (defNode g (chooseNext g))", "hence \"?v \\<notin> defs g ?n\""], ["proof (prove)\nusing this:\n  chooseNext g \\<in> phiDefs g (defNode g (chooseNext g))\n  defNode g (chooseNext g) \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. chooseNext g \\<notin> defs g (defNode g (chooseNext g))", "using simpleDefs_phiDefs_disjoint[of ?n g]"], ["proof (prove)\nusing this:\n  chooseNext g \\<in> phiDefs g (defNode g (chooseNext g))\n  defNode g (chooseNext g) \\<in> set (\\<alpha>n g)\n  defNode g (chooseNext g) \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n  defs g (defNode g (chooseNext g)) \\<inter>\n  phiDefs g (defNode g (chooseNext g)) =\n  {}\n\ngoal (1 subgoal):\n 1. chooseNext g \\<notin> defs g (defNode g (chooseNext g))", "by auto"], ["proof (state)\nthis:\n  chooseNext g \\<notin> defs g (defNode g (chooseNext g))\n\ngoal (1 subgoal):\n 1. chooseNext g \\<notin> step.allDefs g (defNode g (chooseNext g))", "thus ?thesis"], ["proof (prove)\nusing this:\n  chooseNext g \\<notin> defs g (defNode g (chooseNext g))\n\ngoal (1 subgoal):\n 1. chooseNext g \\<notin> step.allDefs g (defNode g (chooseNext g))", "by (auto simp:step.allDefs_def step.phiDefs_def)"], ["proof (state)\nthis:\n  chooseNext g \\<notin> step.allDefs g (defNode g (chooseNext g))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma oldUses_inv:\n    assumes \"n \\<in> set (\\<alpha>n g)\"\n    shows \"oldUses g n = var g ` u_g g n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oldUses g n = var g ` u_g g n", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. oldUses g n = var g ` u_g g n", "have \"var g (substitution g) = var g (chooseNext g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var g (substitution g) = var g (chooseNext g)", "using substitution[of g]"], ["proof (prove)\nusing this:\n  redundant g \\<Longrightarrow>\n  isTrivialPhi g (chooseNext g) (substitution g)\n\ngoal (1 subgoal):\n 1. var g (substitution g) = var g (chooseNext g)", "by - (rule phiArg_same_var, auto simp: isTrivialPhi_def phiArg_def split: option.splits)"], ["proof (state)\nthis:\n  var g (substitution g) = var g (chooseNext g)\n\ngoal (1 subgoal):\n 1. oldUses g n = var g ` u_g g n", "thus ?thesis"], ["proof (prove)\nusing this:\n  var g (substitution g) = var g (chooseNext g)\n\ngoal (1 subgoal):\n 1. oldUses g n = var g ` u_g g n", "using assms"], ["proof (prove)\nusing this:\n  var g (substitution g) = var g (chooseNext g)\n  n \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. oldUses g n = var g ` u_g g n", "by (auto simp: substNext_def oldUses_def image_Un)"], ["proof (state)\nthis:\n  oldUses g n = var g ` u_g g n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma conventional_inv:\n    assumes \"g \\<turnstile> n-ns\\<rightarrow>m\" \"n \\<notin> set (tl ns)\" \"v \\<in> step.allDefs g n\" \"v \\<in> step.allUses g m\" \"x \\<in> set (tl ns)\" \"v' \\<in> step.allDefs g x\"\n    shows \"var g v' \\<noteq> var g v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var g v' \\<noteq> var g v", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. var g v' \\<noteq> var g v", "from assms(1,3)"], ["proof (chain)\npicking this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  v \\<in> step.allDefs g n", "have[simp]: \"n = defNode g v\" \"v \\<in> allDefs g n\""], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  v \\<in> step.allDefs g n\n\ngoal (1 subgoal):\n 1. n = defNode g v &&& v \\<in> allDefs g n", "by - (rule defNode_eq[symmetric], auto)"], ["proof (state)\nthis:\n  n = defNode g v\n  v \\<in> allDefs g n\n\ngoal (1 subgoal):\n 1. var g v' \\<noteq> var g v", "from assms(1)"], ["proof (chain)\npicking this:\n  g \\<turnstile> n-ns\\<rightarrow>m", "have[simp]: \"m \\<in> set (\\<alpha>n g)\""], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n\ngoal (1 subgoal):\n 1. m \\<in> set (\\<alpha>n g)", "by auto"], ["proof (state)\nthis:\n  m \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. var g v' \\<noteq> var g v", "from assms(4)"], ["proof (chain)\npicking this:\n  v \\<in> step.allUses g m", "obtain v\\<^sub>0 where v\\<^sub>0: \"v = substNext g v\\<^sub>0\" \"v\\<^sub>0 \\<in> allUses g m\""], ["proof (prove)\nusing this:\n  v \\<in> step.allUses g m\n\ngoal (1 subgoal):\n 1. (\\<And>v\\<^sub>0.\n        \\<lbrakk>v = substNext g v\\<^sub>0;\n         v\\<^sub>0 \\<in> allUses g m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using allUses_narrows[of m]"], ["proof (prove)\nusing this:\n  v \\<in> step.allUses g m\n  m \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n  step.allUses g m \\<subseteq> substNext g ` allUses g m\n\ngoal (1 subgoal):\n 1. (\\<And>v\\<^sub>0.\n        \\<lbrakk>v = substNext g v\\<^sub>0;\n         v\\<^sub>0 \\<in> allUses g m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v = substNext g v\\<^sub>0\n  v\\<^sub>0 \\<in> allUses g m\n\ngoal (1 subgoal):\n 1. var g v' \\<noteq> var g v", "hence[simp]: \"v\\<^sub>0 \\<in> allVars g\""], ["proof (prove)\nusing this:\n  v = substNext g v\\<^sub>0\n  v\\<^sub>0 \\<in> allUses g m\n\ngoal (1 subgoal):\n 1. v\\<^sub>0 \\<in> allVars g", "using assms(1)"], ["proof (prove)\nusing this:\n  v = substNext g v\\<^sub>0\n  v\\<^sub>0 \\<in> allUses g m\n  g \\<turnstile> n-ns\\<rightarrow>m\n\ngoal (1 subgoal):\n 1. v\\<^sub>0 \\<in> allVars g", "by auto"], ["proof (state)\nthis:\n  v\\<^sub>0 \\<in> allVars g\n\ngoal (1 subgoal):\n 1. var g v' \\<noteq> var g v", "let ?n\\<^sub>0 = \"defNode g v\\<^sub>0\""], ["proof (state)\ngoal (1 subgoal):\n 1. var g v' \\<noteq> var g v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. var g v' \\<noteq> var g v", "proof (cases \"v\\<^sub>0 = chooseNext g\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v\\<^sub>0 = chooseNext g \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. v\\<^sub>0 \\<noteq> chooseNext g \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "case False"], ["proof (state)\nthis:\n  v\\<^sub>0 \\<noteq> chooseNext g\n\ngoal (2 subgoals):\n 1. v\\<^sub>0 = chooseNext g \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. v\\<^sub>0 \\<noteq> chooseNext g \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "with v\\<^sub>0"], ["proof (chain)\npicking this:\n  v = substNext g v\\<^sub>0\n  v\\<^sub>0 \\<in> allUses g m\n  v\\<^sub>0 \\<noteq> chooseNext g", "have \"v = v\\<^sub>0\""], ["proof (prove)\nusing this:\n  v = substNext g v\\<^sub>0\n  v\\<^sub>0 \\<in> allUses g m\n  v\\<^sub>0 \\<noteq> chooseNext g\n\ngoal (1 subgoal):\n 1. v = v\\<^sub>0", "by (simp add:substNext_def split:if_split_asm)"], ["proof (state)\nthis:\n  v = v\\<^sub>0\n\ngoal (2 subgoals):\n 1. v\\<^sub>0 = chooseNext g \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. v\\<^sub>0 \\<noteq> chooseNext g \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "with assms v\\<^sub>0"], ["proof (chain)\npicking this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  n \\<notin> set (tl ns)\n  v \\<in> step.allDefs g n\n  v \\<in> step.allUses g m\n  x \\<in> set (tl ns)\n  v' \\<in> step.allDefs g x\n  v = substNext g v\\<^sub>0\n  v\\<^sub>0 \\<in> allUses g m\n  v = v\\<^sub>0", "show ?thesis"], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  n \\<notin> set (tl ns)\n  v \\<in> step.allDefs g n\n  v \\<in> step.allUses g m\n  x \\<in> set (tl ns)\n  v' \\<in> step.allDefs g x\n  v = substNext g v\\<^sub>0\n  v\\<^sub>0 \\<in> allUses g m\n  v = v\\<^sub>0\n\ngoal (1 subgoal):\n 1. var g v' \\<noteq> var g v", "by - (rule conventional, auto)"], ["proof (state)\nthis:\n  var g v' \\<noteq> var g v\n\ngoal (1 subgoal):\n 1. v\\<^sub>0 = chooseNext g \\<Longrightarrow> var g v' \\<noteq> var g v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v\\<^sub>0 = chooseNext g \\<Longrightarrow> var g v' \\<noteq> var g v", "case True"], ["proof (state)\nthis:\n  v\\<^sub>0 = chooseNext g\n\ngoal (1 subgoal):\n 1. v\\<^sub>0 = chooseNext g \\<Longrightarrow> var g v' \\<noteq> var g v", "hence dom: \"strict_def_dom g v v\\<^sub>0\""], ["proof (prove)\nusing this:\n  v\\<^sub>0 = chooseNext g\n\ngoal (1 subgoal):\n 1. defNode g v \\<noteq> defNode g v\\<^sub>0 \\<and>\n    def_dominates g v v\\<^sub>0", "using substitution[of g]"], ["proof (prove)\nusing this:\n  v\\<^sub>0 = chooseNext g\n  redundant g \\<Longrightarrow>\n  isTrivialPhi g (chooseNext g) (substitution g)\n\ngoal (1 subgoal):\n 1. defNode g v \\<noteq> defNode g v\\<^sub>0 \\<and>\n    def_dominates g v v\\<^sub>0", "by - (rule trivialPhi_strict_dom, simp_all add:substNext_def v\\<^sub>0)"], ["proof (state)\nthis:\n  defNode g v \\<noteq> defNode g v\\<^sub>0 \\<and>\n  def_dominates g v v\\<^sub>0\n\ngoal (1 subgoal):\n 1. v\\<^sub>0 = chooseNext g \\<Longrightarrow> var g v' \\<noteq> var g v", "from v\\<^sub>0(2)"], ["proof (chain)\npicking this:\n  v\\<^sub>0 \\<in> allUses g m", "have \"old.dominates g ?n\\<^sub>0 m\""], ["proof (prove)\nusing this:\n  v\\<^sub>0 \\<in> allUses g m\n\ngoal (1 subgoal):\n 1. old.dominates g (defNode g v\\<^sub>0) m", "using assms(1)"], ["proof (prove)\nusing this:\n  v\\<^sub>0 \\<in> allUses g m\n  g \\<turnstile> n-ns\\<rightarrow>m\n\ngoal (1 subgoal):\n 1. old.dominates g (defNode g v\\<^sub>0) m", "by - (rule allUses_dominated, auto)"], ["proof (state)\nthis:\n  old.dominates g (defNode g v\\<^sub>0) m\n\ngoal (1 subgoal):\n 1. v\\<^sub>0 = chooseNext g \\<Longrightarrow> var g v' \\<noteq> var g v", "with assms(1) dom"], ["proof (chain)\npicking this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  defNode g v \\<noteq> defNode g v\\<^sub>0 \\<and>\n  def_dominates g v v\\<^sub>0\n  old.dominates g (defNode g v\\<^sub>0) m", "have \"?n\\<^sub>0 \\<in> set ns\""], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  defNode g v \\<noteq> defNode g v\\<^sub>0 \\<and>\n  def_dominates g v v\\<^sub>0\n  old.dominates g (defNode g v\\<^sub>0) m\n\ngoal (1 subgoal):\n 1. defNode g v\\<^sub>0 \\<in> set ns", "by - (rule old.dominates_mid, auto)"], ["proof (state)\nthis:\n  defNode g v\\<^sub>0 \\<in> set ns\n\ngoal (1 subgoal):\n 1. v\\<^sub>0 = chooseNext g \\<Longrightarrow> var g v' \\<noteq> var g v", "with assms(1)"], ["proof (chain)\npicking this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  defNode g v\\<^sub>0 \\<in> set ns", "obtain ns\\<^sub>1 ns\\<^sub>3 ns\\<^sub>2 where\n        ns: \"ns = ns\\<^sub>1@ns\\<^sub>3@ns\\<^sub>2\" and\n        ns\\<^sub>1: \"g \\<turnstile> n-ns\\<^sub>1@[?n\\<^sub>0]\\<rightarrow>?n\\<^sub>0\"  \"?n\\<^sub>0 \\<notin> set ns\\<^sub>1\" and\n        ns\\<^sub>3: \"g \\<turnstile> ?n\\<^sub>0-ns\\<^sub>3\\<rightarrow>?n\\<^sub>0\" and\n        ns\\<^sub>2: \"g \\<turnstile> ?n\\<^sub>0-?n\\<^sub>0#ns\\<^sub>2\\<rightarrow>m\" \"?n\\<^sub>0 \\<notin> set ns\\<^sub>2\""], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  defNode g v\\<^sub>0 \\<in> set ns\n\ngoal (1 subgoal):\n 1. (\\<And>ns\\<^sub>1 ns\\<^sub>3 ns\\<^sub>2.\n        \\<lbrakk>ns = ns\\<^sub>1 @ ns\\<^sub>3 @ ns\\<^sub>2;\n         g \\<turnstile> n-ns\\<^sub>1 @\n                          [defNode g\n                            v\\<^sub>0]\\<rightarrow>defNode g v\\<^sub>0;\n         defNode g v\\<^sub>0 \\<notin> set ns\\<^sub>1;\n         g \\<turnstile> defNode g\n                         v\\<^sub>0-ns\\<^sub>3\\<rightarrow>defNode g\n                     v\\<^sub>0;\n         g \\<turnstile> defNode g\n                         v\\<^sub>0-defNode g v\\<^sub>0 #\n                                   ns\\<^sub>2\\<rightarrow>m;\n         defNode g v\\<^sub>0 \\<notin> set ns\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule old.path2_split_first_last)"], ["proof (state)\nthis:\n  ns = ns\\<^sub>1 @ ns\\<^sub>3 @ ns\\<^sub>2\n  g \\<turnstile> n-ns\\<^sub>1 @\n                   [defNode g v\\<^sub>0]\\<rightarrow>defNode g v\\<^sub>0\n  defNode g v\\<^sub>0 \\<notin> set ns\\<^sub>1\n  g \\<turnstile> defNode g\n                  v\\<^sub>0-ns\\<^sub>3\\<rightarrow>defNode g v\\<^sub>0\n  g \\<turnstile> defNode g\n                  v\\<^sub>0-defNode g v\\<^sub>0 # ns\\<^sub>2\\<rightarrow>m\n  defNode g v\\<^sub>0 \\<notin> set ns\\<^sub>2\n\ngoal (1 subgoal):\n 1. v\\<^sub>0 = chooseNext g \\<Longrightarrow> var g v' \\<noteq> var g v", "have[simp]: \"ns\\<^sub>1 \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ns\\<^sub>1 \\<noteq> []", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ns\\<^sub>1 = [] \\<Longrightarrow> False", "assume \"ns\\<^sub>1 = []\""], ["proof (state)\nthis:\n  ns\\<^sub>1 = []\n\ngoal (1 subgoal):\n 1. ns\\<^sub>1 = [] \\<Longrightarrow> False", "hence \"?n\\<^sub>0 = n\" \"hd ns = n\""], ["proof (prove)\nusing this:\n  ns\\<^sub>1 = []\n\ngoal (1 subgoal):\n 1. defNode g v\\<^sub>0 = n &&& hd ns = n", "using assms(1) ns\\<^sub>3"], ["proof (prove)\nusing this:\n  ns\\<^sub>1 = []\n  g \\<turnstile> n-ns\\<rightarrow>m\n  g \\<turnstile> defNode g\n                  v\\<^sub>0-ns\\<^sub>3\\<rightarrow>defNode g v\\<^sub>0\n\ngoal (1 subgoal):\n 1. defNode g v\\<^sub>0 = n &&& hd ns = n", "by (auto simp:ns old.path2_def)"], ["proof (state)\nthis:\n  defNode g v\\<^sub>0 = n\n  hd ns = n\n\ngoal (1 subgoal):\n 1. ns\\<^sub>1 = [] \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  defNode g v\\<^sub>0 = n\n  hd ns = n\n\ngoal (1 subgoal):\n 1. False", "by (metis \\<open>n = defNode g v\\<close> dom)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ns\\<^sub>1 \\<noteq> []\n\ngoal (1 subgoal):\n 1. v\\<^sub>0 = chooseNext g \\<Longrightarrow> var g v' \\<noteq> var g v", "hence \"length (ns\\<^sub>1@[?n\\<^sub>0]) \\<ge> 2\""], ["proof (prove)\nusing this:\n  ns\\<^sub>1 \\<noteq> []\n\ngoal (1 subgoal):\n 1. 2 \\<le> length (ns\\<^sub>1 @ [defNode g v\\<^sub>0])", "by (cases ns\\<^sub>1, auto)"], ["proof (state)\nthis:\n  2 \\<le> length (ns\\<^sub>1 @ [defNode g v\\<^sub>0])\n\ngoal (1 subgoal):\n 1. v\\<^sub>0 = chooseNext g \\<Longrightarrow> var g v' \\<noteq> var g v", "with ns\\<^sub>1"], ["proof (chain)\npicking this:\n  g \\<turnstile> n-ns\\<^sub>1 @\n                   [defNode g v\\<^sub>0]\\<rightarrow>defNode g v\\<^sub>0\n  defNode g v\\<^sub>0 \\<notin> set ns\\<^sub>1\n  2 \\<le> length (ns\\<^sub>1 @ [defNode g v\\<^sub>0])", "have 1: \"g \\<turnstile> n-ns\\<^sub>1\\<rightarrow>last ns\\<^sub>1\" \"last ns\\<^sub>1 \\<in> set (old.predecessors g ?n\\<^sub>0)\""], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<^sub>1 @\n                   [defNode g v\\<^sub>0]\\<rightarrow>defNode g v\\<^sub>0\n  defNode g v\\<^sub>0 \\<notin> set ns\\<^sub>1\n  2 \\<le> length (ns\\<^sub>1 @ [defNode g v\\<^sub>0])\n\ngoal (1 subgoal):\n 1. g \\<turnstile> n-ns\\<^sub>1\\<rightarrow>last ns\\<^sub>1 &&&\n    last ns\\<^sub>1 \\<in> set (old.predecessors g (defNode g v\\<^sub>0))", "by - (erule old.path2_unsnoc, simp, simp, erule old.path2_unsnoc, auto)"], ["proof (state)\nthis:\n  g \\<turnstile> n-ns\\<^sub>1\\<rightarrow>last ns\\<^sub>1\n  last ns\\<^sub>1 \\<in> set (old.predecessors g (defNode g v\\<^sub>0))\n\ngoal (1 subgoal):\n 1. v\\<^sub>0 = chooseNext g \\<Longrightarrow> var g v' \\<noteq> var g v", "from \\<open>v\\<^sub>0 = chooseNext g\\<close> v\\<^sub>0"], ["proof (chain)\npicking this:\n  v\\<^sub>0 = chooseNext g\n  v = substNext g v\\<^sub>0\n  v\\<^sub>0 \\<in> allUses g m", "have triv: \"isTrivialPhi g v\\<^sub>0 v\""], ["proof (prove)\nusing this:\n  v\\<^sub>0 = chooseNext g\n  v = substNext g v\\<^sub>0\n  v\\<^sub>0 \\<in> allUses g m\n\ngoal (1 subgoal):\n 1. isTrivialPhi g v\\<^sub>0 v", "using substitution[of g]"], ["proof (prove)\nusing this:\n  v\\<^sub>0 = chooseNext g\n  v = substNext g v\\<^sub>0\n  v\\<^sub>0 \\<in> allUses g m\n  redundant g \\<Longrightarrow>\n  isTrivialPhi g (chooseNext g) (substitution g)\n\ngoal (1 subgoal):\n 1. isTrivialPhi g v\\<^sub>0 v", "by (auto simp:substNext_def)"], ["proof (state)\nthis:\n  isTrivialPhi g v\\<^sub>0 v\n\ngoal (1 subgoal):\n 1. v\\<^sub>0 = chooseNext g \\<Longrightarrow> var g v' \\<noteq> var g v", "then"], ["proof (chain)\npicking this:\n  isTrivialPhi g v\\<^sub>0 v", "obtain vs where vs: \"phi g v\\<^sub>0 = Some vs\" \"set vs = {v\\<^sub>0,v} \\<or> set vs = {v}\""], ["proof (prove)\nusing this:\n  isTrivialPhi g v\\<^sub>0 v\n\ngoal (1 subgoal):\n 1. (\\<And>vs.\n        \\<lbrakk>phi g v\\<^sub>0 = Some vs;\n         set vs = {v\\<^sub>0, v} \\<or> set vs = {v}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp:isTrivialPhi_def split:option.splits)"], ["proof (state)\nthis:\n  phi g v\\<^sub>0 = Some vs\n  set vs = {v\\<^sub>0, v} \\<or> set vs = {v}\n\ngoal (1 subgoal):\n 1. v\\<^sub>0 = chooseNext g \\<Longrightarrow> var g v' \\<noteq> var g v", "hence[simp]: \"var g v\\<^sub>0 = var g v\""], ["proof (prove)\nusing this:\n  phi g v\\<^sub>0 = Some vs\n  set vs = {v\\<^sub>0, v} \\<or> set vs = {v}\n\ngoal (1 subgoal):\n 1. var g v\\<^sub>0 = var g v", "by - (rule phiArg_same_var[symmetric], auto simp: phiArg_def)"], ["proof (state)\nthis:\n  var g v\\<^sub>0 = var g v\n\ngoal (1 subgoal):\n 1. v\\<^sub>0 = chooseNext g \\<Longrightarrow> var g v' \\<noteq> var g v", "have[simp]: \"v \\<in> phiUses g (last ns\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> phiUses g (last ns\\<^sub>1)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> phiUses g (last ns\\<^sub>1)", "from vs ns\\<^sub>1 1"], ["proof (chain)\npicking this:\n  phi g v\\<^sub>0 = Some vs\n  set vs = {v\\<^sub>0, v} \\<or> set vs = {v}\n  g \\<turnstile> n-ns\\<^sub>1 @\n                   [defNode g v\\<^sub>0]\\<rightarrow>defNode g v\\<^sub>0\n  defNode g v\\<^sub>0 \\<notin> set ns\\<^sub>1\n  g \\<turnstile> n-ns\\<^sub>1\\<rightarrow>last ns\\<^sub>1\n  last ns\\<^sub>1 \\<in> set (old.predecessors g (defNode g v\\<^sub>0))", "have \"v \\<in> phiUses g (last ns\\<^sub>1) \\<or> v\\<^sub>0 \\<in> phiUses g (last ns\\<^sub>1)\""], ["proof (prove)\nusing this:\n  phi g v\\<^sub>0 = Some vs\n  set vs = {v\\<^sub>0, v} \\<or> set vs = {v}\n  g \\<turnstile> n-ns\\<^sub>1 @\n                   [defNode g v\\<^sub>0]\\<rightarrow>defNode g v\\<^sub>0\n  defNode g v\\<^sub>0 \\<notin> set ns\\<^sub>1\n  g \\<turnstile> n-ns\\<^sub>1\\<rightarrow>last ns\\<^sub>1\n  last ns\\<^sub>1 \\<in> set (old.predecessors g (defNode g v\\<^sub>0))\n\ngoal (1 subgoal):\n 1. v \\<in> phiUses g (last ns\\<^sub>1) \\<or>\n    v\\<^sub>0 \\<in> phiUses g (last ns\\<^sub>1)", "by - (rule phiUses_exI[of \"last ns\\<^sub>1\" g ?n\\<^sub>0 v\\<^sub>0 vs], auto simp:phi_def)"], ["proof (state)\nthis:\n  v \\<in> phiUses g (last ns\\<^sub>1) \\<or>\n  v\\<^sub>0 \\<in> phiUses g (last ns\\<^sub>1)\n\ngoal (1 subgoal):\n 1. v \\<in> phiUses g (last ns\\<^sub>1)", "moreover"], ["proof (state)\nthis:\n  v \\<in> phiUses g (last ns\\<^sub>1) \\<or>\n  v\\<^sub>0 \\<in> phiUses g (last ns\\<^sub>1)\n\ngoal (1 subgoal):\n 1. v \\<in> phiUses g (last ns\\<^sub>1)", "have \"v\\<^sub>0 \\<notin> phiUses g (last ns\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>0 \\<notin> phiUses g (last ns\\<^sub>1)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. v\\<^sub>0 \\<in> phiUses g (last ns\\<^sub>1) \\<Longrightarrow> False", "assume asm: \"v\\<^sub>0 \\<in> phiUses g (last ns\\<^sub>1)\""], ["proof (state)\nthis:\n  v\\<^sub>0 \\<in> phiUses g (last ns\\<^sub>1)\n\ngoal (1 subgoal):\n 1. v\\<^sub>0 \\<in> phiUses g (last ns\\<^sub>1) \\<Longrightarrow> False", "from True"], ["proof (chain)\npicking this:\n  v\\<^sub>0 = chooseNext g", "have \"last ns\\<^sub>1 \\<in> set ns\\<^sub>1\""], ["proof (prove)\nusing this:\n  v\\<^sub>0 = chooseNext g\n\ngoal (1 subgoal):\n 1. last ns\\<^sub>1 \\<in> set ns\\<^sub>1", "by - (rule last_in_set, auto)"], ["proof (state)\nthis:\n  last ns\\<^sub>1 \\<in> set ns\\<^sub>1\n\ngoal (1 subgoal):\n 1. v\\<^sub>0 \\<in> phiUses g (last ns\\<^sub>1) \\<Longrightarrow> False", "hence \"last ns\\<^sub>1 \\<in> set (\\<alpha>n g)\""], ["proof (prove)\nusing this:\n  last ns\\<^sub>1 \\<in> set ns\\<^sub>1\n\ngoal (1 subgoal):\n 1. last ns\\<^sub>1 \\<in> set (\\<alpha>n g)", "by - (rule old.path2_in_\\<alpha>n[OF ns\\<^sub>1(1)], auto)"], ["proof (state)\nthis:\n  last ns\\<^sub>1 \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. v\\<^sub>0 \\<in> phiUses g (last ns\\<^sub>1) \\<Longrightarrow> False", "with asm ns\\<^sub>1"], ["proof (chain)\npicking this:\n  v\\<^sub>0 \\<in> phiUses g (last ns\\<^sub>1)\n  g \\<turnstile> n-ns\\<^sub>1 @\n                   [defNode g v\\<^sub>0]\\<rightarrow>defNode g v\\<^sub>0\n  defNode g v\\<^sub>0 \\<notin> set ns\\<^sub>1\n  last ns\\<^sub>1 \\<in> set (\\<alpha>n g)", "have \"old.dominates g ?n\\<^sub>0 (last ns\\<^sub>1)\""], ["proof (prove)\nusing this:\n  v\\<^sub>0 \\<in> phiUses g (last ns\\<^sub>1)\n  g \\<turnstile> n-ns\\<^sub>1 @\n                   [defNode g v\\<^sub>0]\\<rightarrow>defNode g v\\<^sub>0\n  defNode g v\\<^sub>0 \\<notin> set ns\\<^sub>1\n  last ns\\<^sub>1 \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. old.dominates g (defNode g v\\<^sub>0) (last ns\\<^sub>1)", "by - (rule allUses_dominated, auto)"], ["proof (state)\nthis:\n  old.dominates g (defNode g v\\<^sub>0) (last ns\\<^sub>1)\n\ngoal (1 subgoal):\n 1. v\\<^sub>0 \\<in> phiUses g (last ns\\<^sub>1) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  old.dominates g (defNode g v\\<^sub>0) (last ns\\<^sub>1)\n\ngoal (1 subgoal):\n 1. v\\<^sub>0 \\<in> phiUses g (last ns\\<^sub>1) \\<Longrightarrow> False", "have \"strict_def_dom g v v\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. defNode g v \\<noteq> defNode g v\\<^sub>0 \\<and>\n    def_dominates g v v\\<^sub>0", "using triv"], ["proof (prove)\nusing this:\n  isTrivialPhi g v\\<^sub>0 v\n\ngoal (1 subgoal):\n 1. defNode g v \\<noteq> defNode g v\\<^sub>0 \\<and>\n    def_dominates g v v\\<^sub>0", "by - (rule trivialPhi_strict_dom, auto)"], ["proof (state)\nthis:\n  defNode g v \\<noteq> defNode g v\\<^sub>0 \\<and>\n  def_dominates g v v\\<^sub>0\n\ngoal (1 subgoal):\n 1. v\\<^sub>0 \\<in> phiUses g (last ns\\<^sub>1) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  old.dominates g (defNode g v\\<^sub>0) (last ns\\<^sub>1)\n  defNode g v \\<noteq> defNode g v\\<^sub>0 \\<and>\n  def_dominates g v v\\<^sub>0", "have \"?n\\<^sub>0 \\<in> set ns\\<^sub>1\""], ["proof (prove)\nusing this:\n  old.dominates g (defNode g v\\<^sub>0) (last ns\\<^sub>1)\n  defNode g v \\<noteq> defNode g v\\<^sub>0 \\<and>\n  def_dominates g v v\\<^sub>0\n\ngoal (1 subgoal):\n 1. defNode g v\\<^sub>0 \\<in> set ns\\<^sub>1", "using 1(1)"], ["proof (prove)\nusing this:\n  old.dominates g (defNode g v\\<^sub>0) (last ns\\<^sub>1)\n  defNode g v \\<noteq> defNode g v\\<^sub>0 \\<and>\n  def_dominates g v v\\<^sub>0\n  g \\<turnstile> n-ns\\<^sub>1\\<rightarrow>last ns\\<^sub>1\n\ngoal (1 subgoal):\n 1. defNode g v\\<^sub>0 \\<in> set ns\\<^sub>1", "by - (rule old.dominates_mid, auto)"], ["proof (state)\nthis:\n  defNode g v\\<^sub>0 \\<in> set ns\\<^sub>1\n\ngoal (1 subgoal):\n 1. v\\<^sub>0 \\<in> phiUses g (last ns\\<^sub>1) \\<Longrightarrow> False", "with ns\\<^sub>1(2)"], ["proof (chain)\npicking this:\n  defNode g v\\<^sub>0 \\<notin> set ns\\<^sub>1\n  defNode g v\\<^sub>0 \\<in> set ns\\<^sub>1", "show False"], ["proof (prove)\nusing this:\n  defNode g v\\<^sub>0 \\<notin> set ns\\<^sub>1\n  defNode g v\\<^sub>0 \\<in> set ns\\<^sub>1\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v\\<^sub>0 \\<notin> phiUses g (last ns\\<^sub>1)\n\ngoal (1 subgoal):\n 1. v \\<in> phiUses g (last ns\\<^sub>1)", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> phiUses g (last ns\\<^sub>1) \\<or>\n  v\\<^sub>0 \\<in> phiUses g (last ns\\<^sub>1)\n  v\\<^sub>0 \\<notin> phiUses g (last ns\\<^sub>1)", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> phiUses g (last ns\\<^sub>1) \\<or>\n  v\\<^sub>0 \\<in> phiUses g (last ns\\<^sub>1)\n  v\\<^sub>0 \\<notin> phiUses g (last ns\\<^sub>1)\n\ngoal (1 subgoal):\n 1. v \\<in> phiUses g (last ns\\<^sub>1)", "by simp"], ["proof (state)\nthis:\n  v \\<in> phiUses g (last ns\\<^sub>1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<in> phiUses g (last ns\\<^sub>1)\n\ngoal (1 subgoal):\n 1. v\\<^sub>0 = chooseNext g \\<Longrightarrow> var g v' \\<noteq> var g v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. var g v' \\<noteq> var g v", "proof (cases \"x \\<in> set (tl ns\\<^sub>1)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> set (tl ns\\<^sub>1) \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. x \\<notin> set (tl ns\\<^sub>1) \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "case True"], ["proof (state)\nthis:\n  x \\<in> set (tl ns\\<^sub>1)\n\ngoal (2 subgoals):\n 1. x \\<in> set (tl ns\\<^sub>1) \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. x \\<notin> set (tl ns\\<^sub>1) \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> set (tl ns\\<^sub>1)\n\ngoal (1 subgoal):\n 1. var g v' \\<noteq> var g v", "using assms(2,3,6)"], ["proof (prove)\nusing this:\n  x \\<in> set (tl ns\\<^sub>1)\n  n \\<notin> set (tl ns)\n  v \\<in> step.allDefs g n\n  v' \\<in> step.allDefs g x\n\ngoal (1 subgoal):\n 1. var g v' \\<noteq> var g v", "by - (rule conventional[where x=x, OF 1(1)], auto simp:ns)"], ["proof (state)\nthis:\n  var g v' \\<noteq> var g v\n\ngoal (1 subgoal):\n 1. x \\<notin> set (tl ns\\<^sub>1) \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> set (tl ns\\<^sub>1) \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "case False"], ["proof (state)\nthis:\n  x \\<notin> set (tl ns\\<^sub>1)\n\ngoal (1 subgoal):\n 1. x \\<notin> set (tl ns\\<^sub>1) \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. var g v' \\<noteq> var g v", "proof (cases \"var g v' = var g v\\<^sub>0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "case [simp]: True"], ["proof (state)\nthis:\n  var g v' = var g v\\<^sub>0\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "{"], ["proof (state)\nthis:\n  var g v' = var g v\\<^sub>0\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "assume asm: \"x \\<in> set ns\\<^sub>3\""], ["proof (state)\nthis:\n  x \\<in> set ns\\<^sub>3\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "with assms(6)[THEN allDefs_narrows]"], ["proof (chain)\npicking this:\n  v' \\<in> allDefs g x\n  x \\<in> set ns\\<^sub>3", "have[simp]: \"x = defNode g v'\""], ["proof (prove)\nusing this:\n  v' \\<in> allDefs g x\n  x \\<in> set ns\\<^sub>3\n\ngoal (1 subgoal):\n 1. x = defNode g v'", "using ns\\<^sub>3"], ["proof (prove)\nusing this:\n  v' \\<in> allDefs g x\n  x \\<in> set ns\\<^sub>3\n  g \\<turnstile> defNode g\n                  v\\<^sub>0-ns\\<^sub>3\\<rightarrow>defNode g v\\<^sub>0\n\ngoal (1 subgoal):\n 1. x = defNode g v'", "by - (rule defNode_eq[symmetric], auto)"], ["proof (state)\nthis:\n  x = defNode g v'\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "{"], ["proof (state)\nthis:\n  x = defNode g v'\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "assume \"v' = v\\<^sub>0\""], ["proof (state)\nthis:\n  v' = v\\<^sub>0\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "hence False"], ["proof (prove)\nusing this:\n  v' = v\\<^sub>0\n\ngoal (1 subgoal):\n 1. False", "using assms(6) \\<open>v\\<^sub>0 = chooseNext g\\<close> simpleDefs_phiDefs_disjoint[of x g] vs(1)"], ["proof (prove)\nusing this:\n  v' = v\\<^sub>0\n  v' \\<in> step.allDefs g x\n  v\\<^sub>0 = chooseNext g\n  x \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n  defs g x \\<inter> phiDefs g x = {}\n  phi g v\\<^sub>0 = Some vs\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: step.allDefs_def step.phiDefs_def)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "}"], ["proof (state)\nthis:\n  v' = v\\<^sub>0 \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "moreover"], ["proof (state)\nthis:\n  v' = v\\<^sub>0 \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "{"], ["proof (state)\nthis:\n  v' = v\\<^sub>0 \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "assume \"v' \\<noteq> v\\<^sub>0\""], ["proof (state)\nthis:\n  v' \\<noteq> v\\<^sub>0\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "hence \"x \\<noteq> ?n\\<^sub>0\""], ["proof (prove)\nusing this:\n  v' \\<noteq> v\\<^sub>0\n\ngoal (1 subgoal):\n 1. x \\<noteq> defNode g v\\<^sub>0", "using allDefs_var_disjoint[OF _ assms(6)[THEN allDefs_narrows], of v\\<^sub>0]"], ["proof (prove)\nusing this:\n  v' \\<noteq> v\\<^sub>0\n  \\<lbrakk>x \\<in> set (\\<alpha>n g); v\\<^sub>0 \\<in> allDefs g x;\n   v' \\<noteq> v\\<^sub>0\\<rbrakk>\n  \\<Longrightarrow> var g v\\<^sub>0 \\<noteq> var g v'\n\ngoal (1 subgoal):\n 1. x \\<noteq> defNode g v\\<^sub>0", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> defNode g v\\<^sub>0\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "from ns\\<^sub>3 asm ns"], ["proof (chain)\npicking this:\n  g \\<turnstile> defNode g\n                  v\\<^sub>0-ns\\<^sub>3\\<rightarrow>defNode g v\\<^sub>0\n  x \\<in> set ns\\<^sub>3\n  ns = ns\\<^sub>1 @ ns\\<^sub>3 @ ns\\<^sub>2", "obtain ns\\<^sub>3 where ns\\<^sub>3: \"g \\<turnstile> ?n\\<^sub>0-ns\\<^sub>3\\<rightarrow>?n\\<^sub>0\" \"?n\\<^sub>0 \\<notin> set (tl (butlast ns\\<^sub>3))\" \"x \\<in> set ns\\<^sub>3\" \"set ns\\<^sub>3 \\<subseteq> set (tl ns)\""], ["proof (prove)\nusing this:\n  g \\<turnstile> defNode g\n                  v\\<^sub>0-ns\\<^sub>3\\<rightarrow>defNode g v\\<^sub>0\n  x \\<in> set ns\\<^sub>3\n  ns = ns\\<^sub>1 @ ns\\<^sub>3 @ ns\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>ns\\<^sub>3.\n        \\<lbrakk>g \\<turnstile> defNode g\n                                 v\\<^sub>0-ns\\<^sub>3\\<rightarrow>defNode g\n                             v\\<^sub>0;\n         defNode g v\\<^sub>0 \\<notin> set (tl (butlast ns\\<^sub>3));\n         x \\<in> set ns\\<^sub>3;\n         set ns\\<^sub>3 \\<subseteq> set (tl ns)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by - (rule old.path2_simple_loop, auto)"], ["proof (state)\nthis:\n  g \\<turnstile> defNode g\n                  v\\<^sub>0-ns\\<^sub>3\\<rightarrow>defNode g v\\<^sub>0\n  defNode g v\\<^sub>0 \\<notin> set (tl (butlast ns\\<^sub>3))\n  x \\<in> set ns\\<^sub>3\n  set ns\\<^sub>3 \\<subseteq> set (tl ns)\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "with \\<open>x \\<noteq> ?n\\<^sub>0\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> defNode g v\\<^sub>0\n  g \\<turnstile> defNode g\n                  v\\<^sub>0-ns\\<^sub>3\\<rightarrow>defNode g v\\<^sub>0\n  defNode g v\\<^sub>0 \\<notin> set (tl (butlast ns\\<^sub>3))\n  x \\<in> set ns\\<^sub>3\n  set ns\\<^sub>3 \\<subseteq> set (tl ns)", "have \"length ns\\<^sub>3 > 1\""], ["proof (prove)\nusing this:\n  x \\<noteq> defNode g v\\<^sub>0\n  g \\<turnstile> defNode g\n                  v\\<^sub>0-ns\\<^sub>3\\<rightarrow>defNode g v\\<^sub>0\n  defNode g v\\<^sub>0 \\<notin> set (tl (butlast ns\\<^sub>3))\n  x \\<in> set ns\\<^sub>3\n  set ns\\<^sub>3 \\<subseteq> set (tl ns)\n\ngoal (1 subgoal):\n 1. 1 < length ns\\<^sub>3", "by (metis empty_iff graph_path_base.path2_def hd_Cons_tl insert_iff length_greater_0_conv length_tl list.set(1) list.set(2) zero_less_diff)"], ["proof (state)\nthis:\n  1 < length ns\\<^sub>3\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "with ns\\<^sub>3"], ["proof (chain)\npicking this:\n  g \\<turnstile> defNode g\n                  v\\<^sub>0-ns\\<^sub>3\\<rightarrow>defNode g v\\<^sub>0\n  defNode g v\\<^sub>0 \\<notin> set (tl (butlast ns\\<^sub>3))\n  x \\<in> set ns\\<^sub>3\n  set ns\\<^sub>3 \\<subseteq> set (tl ns)\n  1 < length ns\\<^sub>3", "obtain ns' m where ns': \"g \\<turnstile> ?n\\<^sub>0-ns'\\<rightarrow>m\" \"m \\<in> set (old.predecessors g ?n\\<^sub>0)\" \"ns' = butlast ns\\<^sub>3\""], ["proof (prove)\nusing this:\n  g \\<turnstile> defNode g\n                  v\\<^sub>0-ns\\<^sub>3\\<rightarrow>defNode g v\\<^sub>0\n  defNode g v\\<^sub>0 \\<notin> set (tl (butlast ns\\<^sub>3))\n  x \\<in> set ns\\<^sub>3\n  set ns\\<^sub>3 \\<subseteq> set (tl ns)\n  1 < length ns\\<^sub>3\n\ngoal (1 subgoal):\n 1. (\\<And>ns' m.\n        \\<lbrakk>g \\<turnstile> defNode g v\\<^sub>0-ns'\\<rightarrow>m;\n         m \\<in> set (old.predecessors g (defNode g v\\<^sub>0));\n         ns' = butlast ns\\<^sub>3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by - (rule old.path2_unsnoc, auto)"], ["proof (state)\nthis:\n  g \\<turnstile> defNode g v\\<^sub>0-ns'\\<rightarrow>m\n  m \\<in> set (old.predecessors g (defNode g v\\<^sub>0))\n  ns' = butlast ns\\<^sub>3\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "with vs ns\\<^sub>3"], ["proof (chain)\npicking this:\n  phi g v\\<^sub>0 = Some vs\n  set vs = {v\\<^sub>0, v} \\<or> set vs = {v}\n  g \\<turnstile> defNode g\n                  v\\<^sub>0-ns\\<^sub>3\\<rightarrow>defNode g v\\<^sub>0\n  defNode g v\\<^sub>0 \\<notin> set (tl (butlast ns\\<^sub>3))\n  x \\<in> set ns\\<^sub>3\n  set ns\\<^sub>3 \\<subseteq> set (tl ns)\n  g \\<turnstile> defNode g v\\<^sub>0-ns'\\<rightarrow>m\n  m \\<in> set (old.predecessors g (defNode g v\\<^sub>0))\n  ns' = butlast ns\\<^sub>3", "have \"v \\<in> phiUses g m \\<or> v\\<^sub>0 \\<in> phiUses g m\""], ["proof (prove)\nusing this:\n  phi g v\\<^sub>0 = Some vs\n  set vs = {v\\<^sub>0, v} \\<or> set vs = {v}\n  g \\<turnstile> defNode g\n                  v\\<^sub>0-ns\\<^sub>3\\<rightarrow>defNode g v\\<^sub>0\n  defNode g v\\<^sub>0 \\<notin> set (tl (butlast ns\\<^sub>3))\n  x \\<in> set ns\\<^sub>3\n  set ns\\<^sub>3 \\<subseteq> set (tl ns)\n  g \\<turnstile> defNode g v\\<^sub>0-ns'\\<rightarrow>m\n  m \\<in> set (old.predecessors g (defNode g v\\<^sub>0))\n  ns' = butlast ns\\<^sub>3\n\ngoal (1 subgoal):\n 1. v \\<in> phiUses g m \\<or> v\\<^sub>0 \\<in> phiUses g m", "by - (rule phiUses_exI[of m g ?n\\<^sub>0 v\\<^sub>0 vs], auto simp:phi_def)"], ["proof (state)\nthis:\n  v \\<in> phiUses g m \\<or> v\\<^sub>0 \\<in> phiUses g m\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "moreover"], ["proof (state)\nthis:\n  v \\<in> phiUses g m \\<or> v\\<^sub>0 \\<in> phiUses g m\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "{"], ["proof (state)\nthis:\n  v \\<in> phiUses g m \\<or> v\\<^sub>0 \\<in> phiUses g m\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "assume \"v \\<in> phiUses g m\""], ["proof (state)\nthis:\n  v \\<in> phiUses g m\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "have \"var g v\\<^sub>0 \\<noteq> var g v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var g v\\<^sub>0 \\<noteq> var g v", "proof (rule conventional)"], ["proof (state)\ngoal (6 subgoals):\n 1. g \\<turnstile> ?n-?ns\\<rightarrow>?m\n 2. ?n \\<notin> set (tl ?ns)\n 3. v \\<in> allDefs g ?n\n 4. v \\<in> allUses g ?m\n 5. ?x \\<in> set (tl ?ns)\n 6. v\\<^sub>0 \\<in> allDefs g ?x", "show \"g \\<turnstile> n-ns\\<^sub>1 @ ns'\\<rightarrow>m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<turnstile> n-ns\\<^sub>1 @ ns'\\<rightarrow>m", "using old.path2_app'[OF ns\\<^sub>1(1) ns'(1)]"], ["proof (prove)\nusing this:\n  g \\<turnstile> n-butlast (ns\\<^sub>1 @ [defNode g v\\<^sub>0]) @\n                   ns'\\<rightarrow>m\n\ngoal (1 subgoal):\n 1. g \\<turnstile> n-ns\\<^sub>1 @ ns'\\<rightarrow>m", "by simp"], ["proof (state)\nthis:\n  g \\<turnstile> n-ns\\<^sub>1 @ ns'\\<rightarrow>m\n\ngoal (5 subgoals):\n 1. n \\<notin> set (tl (ns\\<^sub>1 @ ns'))\n 2. v \\<in> allDefs g n\n 3. v \\<in> allUses g m\n 4. ?x \\<in> set (tl (ns\\<^sub>1 @ ns'))\n 5. v\\<^sub>0 \\<in> allDefs g ?x", "have \"n \\<notin> set (tl ns\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<notin> set (tl ns\\<^sub>1)", "using ns assms(2)"], ["proof (prove)\nusing this:\n  ns = ns\\<^sub>1 @ ns\\<^sub>3__ @ ns\\<^sub>2\n  n \\<notin> set (tl ns)\n\ngoal (1 subgoal):\n 1. n \\<notin> set (tl ns\\<^sub>1)", "by auto"], ["proof (state)\nthis:\n  n \\<notin> set (tl ns\\<^sub>1)\n\ngoal (5 subgoals):\n 1. n \\<notin> set (tl (ns\\<^sub>1 @ ns'))\n 2. v \\<in> allDefs g n\n 3. v \\<in> allUses g m\n 4. ?x \\<in> set (tl (ns\\<^sub>1 @ ns'))\n 5. v\\<^sub>0 \\<in> allDefs g ?x", "moreover"], ["proof (state)\nthis:\n  n \\<notin> set (tl ns\\<^sub>1)\n\ngoal (5 subgoals):\n 1. n \\<notin> set (tl (ns\\<^sub>1 @ ns'))\n 2. v \\<in> allDefs g n\n 3. v \\<in> allUses g m\n 4. ?x \\<in> set (tl (ns\\<^sub>1 @ ns'))\n 5. v\\<^sub>0 \\<in> allDefs g ?x", "have \"n \\<notin> set ns'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<notin> set ns'", "using ns'(3) ns\\<^sub>3(4) assms(2)"], ["proof (prove)\nusing this:\n  ns' = butlast ns\\<^sub>3\n  set ns\\<^sub>3 \\<subseteq> set (tl ns)\n  n \\<notin> set (tl ns)\n\ngoal (1 subgoal):\n 1. n \\<notin> set ns'", "by (auto dest: in_set_butlastD)"], ["proof (state)\nthis:\n  n \\<notin> set ns'\n\ngoal (5 subgoals):\n 1. n \\<notin> set (tl (ns\\<^sub>1 @ ns'))\n 2. v \\<in> allDefs g n\n 3. v \\<in> allUses g m\n 4. ?x \\<in> set (tl (ns\\<^sub>1 @ ns'))\n 5. v\\<^sub>0 \\<in> allDefs g ?x", "ultimately"], ["proof (chain)\npicking this:\n  n \\<notin> set (tl ns\\<^sub>1)\n  n \\<notin> set ns'", "show \"n \\<notin> set (tl (ns\\<^sub>1 @ ns'))\""], ["proof (prove)\nusing this:\n  n \\<notin> set (tl ns\\<^sub>1)\n  n \\<notin> set ns'\n\ngoal (1 subgoal):\n 1. n \\<notin> set (tl (ns\\<^sub>1 @ ns'))", "by simp"], ["proof (state)\nthis:\n  n \\<notin> set (tl (ns\\<^sub>1 @ ns'))\n\ngoal (4 subgoals):\n 1. v \\<in> allDefs g n\n 2. v \\<in> allUses g m\n 3. ?x \\<in> set (tl (ns\\<^sub>1 @ ns'))\n 4. v\\<^sub>0 \\<in> allDefs g ?x", "show \"v \\<in> allDefs g n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> allDefs g n", "using \\<open>v \\<in> allDefs g n\\<close>"], ["proof (prove)\nusing this:\n  v \\<in> allDefs g n\n\ngoal (1 subgoal):\n 1. v \\<in> allDefs g n", "."], ["proof (state)\nthis:\n  v \\<in> allDefs g n\n\ngoal (3 subgoals):\n 1. v \\<in> allUses g m\n 2. ?x \\<in> set (tl (ns\\<^sub>1 @ ns'))\n 3. v\\<^sub>0 \\<in> allDefs g ?x", "show \"?n\\<^sub>0 \\<in> set (tl (ns\\<^sub>1 @ ns'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. defNode g v\\<^sub>0 \\<in> set (tl (ns\\<^sub>1 @ ns'))", "using ns'(1)"], ["proof (prove)\nusing this:\n  g \\<turnstile> defNode g v\\<^sub>0-ns'\\<rightarrow>m\n\ngoal (1 subgoal):\n 1. defNode g v\\<^sub>0 \\<in> set (tl (ns\\<^sub>1 @ ns'))", "by (auto simp: old.path2_def)"], ["proof (state)\nthis:\n  defNode g v\\<^sub>0 \\<in> set (tl (ns\\<^sub>1 @ ns'))\n\ngoal (2 subgoals):\n 1. v \\<in> allUses g m\n 2. v\\<^sub>0 \\<in> allDefs g (defNode g v\\<^sub>0)", "qed (auto simp: \\<open>v \\<in> phiUses g m\\<close>)"], ["proof (state)\nthis:\n  var g v\\<^sub>0 \\<noteq> var g v\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "hence False"], ["proof (prove)\nusing this:\n  var g v\\<^sub>0 \\<noteq> var g v\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "}"], ["proof (state)\nthis:\n  v \\<in> phiUses g m \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "moreover"], ["proof (state)\nthis:\n  v \\<in> phiUses g m \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "{"], ["proof (state)\nthis:\n  v \\<in> phiUses g m \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "assume \"v\\<^sub>0 \\<in> phiUses g m\""], ["proof (state)\nthis:\n  v\\<^sub>0 \\<in> phiUses g m\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "moreover"], ["proof (state)\nthis:\n  v\\<^sub>0 \\<in> phiUses g m\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "from ns\\<^sub>3(1,3) \\<open>x \\<noteq> ?n\\<^sub>0\\<close> \\<open>length ns\\<^sub>3 > 1\\<close>"], ["proof (chain)\npicking this:\n  g \\<turnstile> defNode g\n                  v\\<^sub>0-ns\\<^sub>3\\<rightarrow>defNode g v\\<^sub>0\n  x \\<in> set ns\\<^sub>3\n  x \\<noteq> defNode g v\\<^sub>0\n  1 < length ns\\<^sub>3", "have \"x \\<in> set (tl (butlast ns\\<^sub>3))\""], ["proof (prove)\nusing this:\n  g \\<turnstile> defNode g\n                  v\\<^sub>0-ns\\<^sub>3\\<rightarrow>defNode g v\\<^sub>0\n  x \\<in> set ns\\<^sub>3\n  x \\<noteq> defNode g v\\<^sub>0\n  1 < length ns\\<^sub>3\n\ngoal (1 subgoal):\n 1. x \\<in> set (tl (butlast ns\\<^sub>3))", "by (cases ns\\<^sub>3, auto simp: old.path2_def intro: in_set_butlastI)"], ["proof (state)\nthis:\n  x \\<in> set (tl (butlast ns\\<^sub>3))\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "ultimately"], ["proof (chain)\npicking this:\n  v\\<^sub>0 \\<in> phiUses g m\n  x \\<in> set (tl (butlast ns\\<^sub>3))", "have \"var g v' \\<noteq> var g v\\<^sub>0\""], ["proof (prove)\nusing this:\n  v\\<^sub>0 \\<in> phiUses g m\n  x \\<in> set (tl (butlast ns\\<^sub>3))\n\ngoal (1 subgoal):\n 1. var g v' \\<noteq> var g v\\<^sub>0", "using assms(6)[THEN allDefs_narrows] ns\\<^sub>3(2,3) ns'(3)"], ["proof (prove)\nusing this:\n  v\\<^sub>0 \\<in> phiUses g m\n  x \\<in> set (tl (butlast ns\\<^sub>3))\n  v' \\<in> allDefs g x\n  defNode g v\\<^sub>0 \\<notin> set (tl (butlast ns\\<^sub>3))\n  x \\<in> set ns\\<^sub>3\n  ns' = butlast ns\\<^sub>3\n\ngoal (1 subgoal):\n 1. var g v' \\<noteq> var g v\\<^sub>0", "by - (rule conventional[OF ns'(1)], auto)"], ["proof (state)\nthis:\n  var g v' \\<noteq> var g v\\<^sub>0\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "hence False"], ["proof (prove)\nusing this:\n  var g v' \\<noteq> var g v\\<^sub>0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "}"], ["proof (state)\nthis:\n  v\\<^sub>0 \\<in> phiUses g m \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> phiUses g m \\<or> v\\<^sub>0 \\<in> phiUses g m\n  v \\<in> phiUses g m \\<Longrightarrow> False\n  v\\<^sub>0 \\<in> phiUses g m \\<Longrightarrow> False", "have False"], ["proof (prove)\nusing this:\n  v \\<in> phiUses g m \\<or> v\\<^sub>0 \\<in> phiUses g m\n  v \\<in> phiUses g m \\<Longrightarrow> False\n  v\\<^sub>0 \\<in> phiUses g m \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "}"], ["proof (state)\nthis:\n  v' \\<noteq> v\\<^sub>0 \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "ultimately"], ["proof (chain)\npicking this:\n  v' = v\\<^sub>0 \\<Longrightarrow> False\n  v' \\<noteq> v\\<^sub>0 \\<Longrightarrow> False", "have False"], ["proof (prove)\nusing this:\n  v' = v\\<^sub>0 \\<Longrightarrow> False\n  v' \\<noteq> v\\<^sub>0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "}"], ["proof (state)\nthis:\n  x \\<in> set ns\\<^sub>3 \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "moreover"], ["proof (state)\nthis:\n  x \\<in> set ns\\<^sub>3 \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "{"], ["proof (state)\nthis:\n  x \\<in> set ns\\<^sub>3 \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "assume asm: \"x \\<notin> set ns\\<^sub>3\""], ["proof (state)\nthis:\n  x \\<notin> set ns\\<^sub>3\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "have \"var g v' \\<noteq> var g v\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var g v' \\<noteq> var g v\\<^sub>0", "proof (cases \"x = ?n\\<^sub>0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = defNode g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v\\<^sub>0\n 2. x \\<noteq> defNode g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v\\<^sub>0", "case True"], ["proof (state)\nthis:\n  x = defNode g v\\<^sub>0\n\ngoal (2 subgoals):\n 1. x = defNode g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v\\<^sub>0\n 2. x \\<noteq> defNode g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v\\<^sub>0", "moreover"], ["proof (state)\nthis:\n  x = defNode g v\\<^sub>0\n\ngoal (2 subgoals):\n 1. x = defNode g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v\\<^sub>0\n 2. x \\<noteq> defNode g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v\\<^sub>0", "have \"v\\<^sub>0 \\<notin> step.allDefs g ?n\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v\\<^sub>0 \\<notin> step.allDefs g (defNode g v\\<^sub>0)", "by (auto simp:\\<open>v\\<^sub>0 = chooseNext g\\<close> chooseNext_eliminated)"], ["proof (state)\nthis:\n  v\\<^sub>0 \\<notin> step.allDefs g (defNode g v\\<^sub>0)\n\ngoal (2 subgoals):\n 1. x = defNode g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v\\<^sub>0\n 2. x \\<noteq> defNode g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v\\<^sub>0", "ultimately"], ["proof (chain)\npicking this:\n  x = defNode g v\\<^sub>0\n  v\\<^sub>0 \\<notin> step.allDefs g (defNode g v\\<^sub>0)", "show ?thesis"], ["proof (prove)\nusing this:\n  x = defNode g v\\<^sub>0\n  v\\<^sub>0 \\<notin> step.allDefs g (defNode g v\\<^sub>0)\n\ngoal (1 subgoal):\n 1. var g v' \\<noteq> var g v\\<^sub>0", "using assms(6) vs(1)"], ["proof (prove)\nusing this:\n  x = defNode g v\\<^sub>0\n  v\\<^sub>0 \\<notin> step.allDefs g (defNode g v\\<^sub>0)\n  v' \\<in> step.allDefs g x\n  phi g v\\<^sub>0 = Some vs\n\ngoal (1 subgoal):\n 1. var g v' \\<noteq> var g v\\<^sub>0", "by - (rule allDefs_var_disjoint[of x g], auto)"], ["proof (state)\nthis:\n  var g v' \\<noteq> var g v\\<^sub>0\n\ngoal (1 subgoal):\n 1. x \\<noteq> defNode g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v\\<^sub>0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> defNode g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v\\<^sub>0", "case False"], ["proof (state)\nthis:\n  x \\<noteq> defNode g v\\<^sub>0\n\ngoal (1 subgoal):\n 1. x \\<noteq> defNode g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v\\<^sub>0", "with \\<open>x \\<notin> set (tl ns\\<^sub>1)\\<close> assms(5) asm"], ["proof (chain)\npicking this:\n  x \\<notin> set (tl ns\\<^sub>1)\n  x \\<in> set (tl ns)\n  x \\<notin> set ns\\<^sub>3\n  x \\<noteq> defNode g v\\<^sub>0", "have \"x \\<in> set ns\\<^sub>2\""], ["proof (prove)\nusing this:\n  x \\<notin> set (tl ns\\<^sub>1)\n  x \\<in> set (tl ns)\n  x \\<notin> set ns\\<^sub>3\n  x \\<noteq> defNode g v\\<^sub>0\n\ngoal (1 subgoal):\n 1. x \\<in> set ns\\<^sub>2", "by (auto simp:ns)"], ["proof (state)\nthis:\n  x \\<in> set ns\\<^sub>2\n\ngoal (1 subgoal):\n 1. x \\<noteq> defNode g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v\\<^sub>0", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> set ns\\<^sub>2\n\ngoal (1 subgoal):\n 1. var g v' \\<noteq> var g v\\<^sub>0", "using assms(2,6) v\\<^sub>0(2) ns\\<^sub>2(2)"], ["proof (prove)\nusing this:\n  x \\<in> set ns\\<^sub>2\n  n \\<notin> set (tl ns)\n  v' \\<in> step.allDefs g x\n  v\\<^sub>0 \\<in> allUses g m\n  defNode g v\\<^sub>0 \\<notin> set ns\\<^sub>2\n\ngoal (1 subgoal):\n 1. var g v' \\<noteq> var g v\\<^sub>0", "by - (rule conventional[OF ns\\<^sub>2(1), where x=x], auto simp:ns)"], ["proof (state)\nthis:\n  var g v' \\<noteq> var g v\\<^sub>0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  var g v' \\<noteq> var g v\\<^sub>0\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "}"], ["proof (state)\nthis:\n  x \\<notin> set ns\\<^sub>3 \\<Longrightarrow>\n  var g v' \\<noteq> var g v\\<^sub>0\n\ngoal (2 subgoals):\n 1. var g v' = var g v\\<^sub>0 \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> set ns\\<^sub>3 \\<Longrightarrow> False\n  x \\<notin> set ns\\<^sub>3 \\<Longrightarrow>\n  var g v' \\<noteq> var g v\\<^sub>0", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> set ns\\<^sub>3 \\<Longrightarrow> False\n  x \\<notin> set ns\\<^sub>3 \\<Longrightarrow>\n  var g v' \\<noteq> var g v\\<^sub>0\n\ngoal (1 subgoal):\n 1. var g v' \\<noteq> var g v", "by auto"], ["proof (state)\nthis:\n  var g v' \\<noteq> var g v\n\ngoal (1 subgoal):\n 1. var g v' \\<noteq> var g v\\<^sub>0 \\<Longrightarrow>\n    var g v' \\<noteq> var g v", "qed auto"], ["proof (state)\nthis:\n  var g v' \\<noteq> var g v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  var g v' \\<noteq> var g v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  var g v' \\<noteq> var g v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma[simp]: \"var g (substNext g v) = var g v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var g (substNext g v) = var g v", "using substitution[OF redundant]"], ["proof (prove)\nusing this:\n  isTrivialPhi g (chooseNext g) (substitution g)\n\ngoal (1 subgoal):\n 1. var g (substNext g v) = var g v", "by (auto simp:substNext_def isTrivialPhi_def phi_def split:option.splits)"], ["", "lemma phis_same_var_inv:\n    assumes \"phis' g (n,v) = Some vs\" \"v' \\<in> set vs\"\n    shows \"var g v' = var g v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. var g v' = var g v", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. var g v' = var g v", "from assms"], ["proof (chain)\npicking this:\n  phis' g (n, v) = Some vs\n  v' \\<in> set vs", "obtain vs\\<^sub>0 v\\<^sub>0 where 1: \"phis g (n,v) = Some vs\\<^sub>0\" \"v\\<^sub>0 \\<in> set vs\\<^sub>0\" \"v' = substNext g v\\<^sub>0\""], ["proof (prove)\nusing this:\n  phis' g (n, v) = Some vs\n  v' \\<in> set vs\n\ngoal (1 subgoal):\n 1. (\\<And>vs\\<^sub>0 v\\<^sub>0.\n        \\<lbrakk>phis g (n, v) = Some vs\\<^sub>0;\n         v\\<^sub>0 \\<in> set vs\\<^sub>0; v' = substNext g v\\<^sub>0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto split:if_split_asm)"], ["proof (state)\nthis:\n  phis g (n, v) = Some vs\\<^sub>0\n  v\\<^sub>0 \\<in> set vs\\<^sub>0\n  v' = substNext g v\\<^sub>0\n\ngoal (1 subgoal):\n 1. var g v' = var g v", "hence \"var g v\\<^sub>0 = var g v\""], ["proof (prove)\nusing this:\n  phis g (n, v) = Some vs\\<^sub>0\n  v\\<^sub>0 \\<in> set vs\\<^sub>0\n  v' = substNext g v\\<^sub>0\n\ngoal (1 subgoal):\n 1. var g v\\<^sub>0 = var g v", "by auto"], ["proof (state)\nthis:\n  var g v\\<^sub>0 = var g v\n\ngoal (1 subgoal):\n 1. var g v' = var g v", "with 1"], ["proof (chain)\npicking this:\n  phis g (n, v) = Some vs\\<^sub>0\n  v\\<^sub>0 \\<in> set vs\\<^sub>0\n  v' = substNext g v\\<^sub>0\n  var g v\\<^sub>0 = var g v", "show ?thesis"], ["proof (prove)\nusing this:\n  phis g (n, v) = Some vs\\<^sub>0\n  v\\<^sub>0 \\<in> set vs\\<^sub>0\n  v' = substNext g v\\<^sub>0\n  var g v\\<^sub>0 = var g v\n\ngoal (1 subgoal):\n 1. var g v' = var g v", "by auto"], ["proof (state)\nthis:\n  var g v' = var g v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma allDefs_var_disjoint_inv: \"\\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> step.allDefs g n; v' \\<in> step.allDefs g n; v \\<noteq> v'\\<rbrakk> \\<Longrightarrow> var g v' \\<noteq> var g v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> step.allDefs g n;\n     v' \\<in> step.allDefs g n; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> var g v' \\<noteq> var g v", "using allDefs_var_disjoint"], ["proof (prove)\nusing this:\n  \\<lbrakk>?n \\<in> set (\\<alpha>n ?g); ?v \\<in> allDefs ?g ?n;\n   ?v' \\<in> allDefs ?g ?n; ?v \\<noteq> ?v'\\<rbrakk>\n  \\<Longrightarrow> var ?g ?v' \\<noteq> var ?g ?v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> step.allDefs g n;\n     v' \\<in> step.allDefs g n; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> var g v' \\<noteq> var g v", "by (auto simp:step.allDefs_def)"], ["", "lemma step_CFG_SSA_Transformed_notriv: \"CFG_SSA_Transformed_notriv \\<alpha>e \\<alpha>n invar inEdges' Entry oldDefs oldUses defs u_g p_g var chooseNext_all\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_SSA_Transformed_notriv \\<alpha>e \\<alpha>n invar inEdges' Entry\n     oldDefs oldUses defs u_g p_g var chooseNext_all", "apply unfold_locales"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>g n. oldDefs g n = var g ` defs g n\n 2. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       oldUses g n = var g ` u_g g n\n 3. \\<And>g n ns m v x v'.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m; n \\<notin> set (tl ns);\n        v \\<in> step.allDefs g n; v \\<in> step.allUses g m;\n        x \\<in> set (tl ns); v' \\<in> step.allDefs g x\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v\n 4. \\<And>g n v vs v'.\n       \\<lbrakk>p_g g (n, v) = Some vs; v' \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> var g v' = var g v\n 5. \\<And>n g v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> step.allDefs g n;\n        v' \\<in> step.allDefs g n; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v\n 6. \\<And>u p g.\n       \\<lbrakk>CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry\n                 oldDefs oldUses defs u p var;\n        CFG_SSA_wf_base.redundant \\<alpha>n inEdges' defs u p g\\<rbrakk>\n       \\<Longrightarrow> chooseNext_all (u g) (p g) g \\<in> dom (p g) \\<and>\n                         CFG_SSA_wf_base.trivial \\<alpha>n inEdges' defs u p\n                          g (snd (chooseNext_all (u g) (p g) g))", "apply (rule oldDefs_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       oldUses g n = var g ` u_g g n\n 2. \\<And>g n ns m v x v'.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m; n \\<notin> set (tl ns);\n        v \\<in> step.allDefs g n; v \\<in> step.allUses g m;\n        x \\<in> set (tl ns); v' \\<in> step.allDefs g x\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v\n 3. \\<And>g n v vs v'.\n       \\<lbrakk>p_g g (n, v) = Some vs; v' \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> var g v' = var g v\n 4. \\<And>n g v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> step.allDefs g n;\n        v' \\<in> step.allDefs g n; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v\n 5. \\<And>u p g.\n       \\<lbrakk>CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry\n                 oldDefs oldUses defs u p var;\n        CFG_SSA_wf_base.redundant \\<alpha>n inEdges' defs u p g\\<rbrakk>\n       \\<Longrightarrow> chooseNext_all (u g) (p g) g \\<in> dom (p g) \\<and>\n                         CFG_SSA_wf_base.trivial \\<alpha>n inEdges' defs u p\n                          g (snd (chooseNext_all (u g) (p g) g))", "apply (rename_tac g')"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>n g'.\n       n \\<in> set (\\<alpha>n g') \\<Longrightarrow>\n       oldUses g' n = var g' ` u_g g' n\n 2. \\<And>g n ns m v x v'.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m; n \\<notin> set (tl ns);\n        v \\<in> step.allDefs g n; v \\<in> step.allUses g m;\n        x \\<in> set (tl ns); v' \\<in> step.allDefs g x\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v\n 3. \\<And>g n v vs v'.\n       \\<lbrakk>p_g g (n, v) = Some vs; v' \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> var g v' = var g v\n 4. \\<And>n g v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> step.allDefs g n;\n        v' \\<in> step.allDefs g n; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v\n 5. \\<And>u p g.\n       \\<lbrakk>CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry\n                 oldDefs oldUses defs u p var;\n        CFG_SSA_wf_base.redundant \\<alpha>n inEdges' defs u p g\\<rbrakk>\n       \\<Longrightarrow> chooseNext_all (u g) (p g) g \\<in> dom (p g) \\<and>\n                         CFG_SSA_wf_base.trivial \\<alpha>n inEdges' defs u p\n                          g (snd (chooseNext_all (u g) (p g) g))", "apply (case_tac \"g'=g\")"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>n g'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g'); g' = g\\<rbrakk>\n       \\<Longrightarrow> oldUses g' n = var g' ` u_g g' n\n 2. \\<And>n g'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g'); g' \\<noteq> g\\<rbrakk>\n       \\<Longrightarrow> oldUses g' n = var g' ` u_g g' n\n 3. \\<And>g n ns m v x v'.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m; n \\<notin> set (tl ns);\n        v \\<in> step.allDefs g n; v \\<in> step.allUses g m;\n        x \\<in> set (tl ns); v' \\<in> step.allDefs g x\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v\n 4. \\<And>g n v vs v'.\n       \\<lbrakk>p_g g (n, v) = Some vs; v' \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> var g v' = var g v\n 5. \\<And>n g v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> step.allDefs g n;\n        v' \\<in> step.allDefs g n; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v\n 6. \\<And>u p g.\n       \\<lbrakk>CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry\n                 oldDefs oldUses defs u p var;\n        CFG_SSA_wf_base.redundant \\<alpha>n inEdges' defs u p g\\<rbrakk>\n       \\<Longrightarrow> chooseNext_all (u g) (p g) g \\<in> dom (p g) \\<and>\n                         CFG_SSA_wf_base.trivial \\<alpha>n inEdges' defs u p\n                          g (snd (chooseNext_all (u g) (p g) g))", "apply (simp add:oldUses_inv)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>n g'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g'); g' \\<noteq> g\\<rbrakk>\n       \\<Longrightarrow> oldUses g' n = var g' ` u_g g' n\n 2. \\<And>g n ns m v x v'.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m; n \\<notin> set (tl ns);\n        v \\<in> step.allDefs g n; v \\<in> step.allUses g m;\n        x \\<in> set (tl ns); v' \\<in> step.allDefs g x\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v\n 3. \\<And>g n v vs v'.\n       \\<lbrakk>p_g g (n, v) = Some vs; v' \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> var g v' = var g v\n 4. \\<And>n g v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> step.allDefs g n;\n        v' \\<in> step.allDefs g n; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v\n 5. \\<And>u p g.\n       \\<lbrakk>CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry\n                 oldDefs oldUses defs u p var;\n        CFG_SSA_wf_base.redundant \\<alpha>n inEdges' defs u p g\\<rbrakk>\n       \\<Longrightarrow> chooseNext_all (u g) (p g) g \\<in> dom (p g) \\<and>\n                         CFG_SSA_wf_base.trivial \\<alpha>n inEdges' defs u p\n                          g (snd (chooseNext_all (u g) (p g) g))", "apply (simp add:oldUses_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>g n ns m v x v'.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m; n \\<notin> set (tl ns);\n        v \\<in> step.allDefs g n; v \\<in> step.allUses g m;\n        x \\<in> set (tl ns); v' \\<in> step.allDefs g x\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. \\<And>g n v vs v'.\n       \\<lbrakk>p_g g (n, v) = Some vs; v' \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> var g v' = var g v\n 3. \\<And>n g v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> step.allDefs g n;\n        v' \\<in> step.allDefs g n; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v\n 4. \\<And>u p g.\n       \\<lbrakk>CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry\n                 oldDefs oldUses defs u p var;\n        CFG_SSA_wf_base.redundant \\<alpha>n inEdges' defs u p g\\<rbrakk>\n       \\<Longrightarrow> chooseNext_all (u g) (p g) g \\<in> dom (p g) \\<and>\n                         CFG_SSA_wf_base.trivial \\<alpha>n inEdges' defs u p\n                          g (snd (chooseNext_all (u g) (p g) g))", "apply (rename_tac g' n ns m v x v')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>g' n ns m v x v'.\n       \\<lbrakk>g' \\<turnstile> n-ns\\<rightarrow>m; n \\<notin> set (tl ns);\n        v \\<in> step.allDefs g' n; v \\<in> step.allUses g' m;\n        x \\<in> set (tl ns); v' \\<in> step.allDefs g' x\\<rbrakk>\n       \\<Longrightarrow> var g' v' \\<noteq> var g' v\n 2. \\<And>g n v vs v'.\n       \\<lbrakk>p_g g (n, v) = Some vs; v' \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> var g v' = var g v\n 3. \\<And>n g v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> step.allDefs g n;\n        v' \\<in> step.allDefs g n; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v\n 4. \\<And>u p g.\n       \\<lbrakk>CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry\n                 oldDefs oldUses defs u p var;\n        CFG_SSA_wf_base.redundant \\<alpha>n inEdges' defs u p g\\<rbrakk>\n       \\<Longrightarrow> chooseNext_all (u g) (p g) g \\<in> dom (p g) \\<and>\n                         CFG_SSA_wf_base.trivial \\<alpha>n inEdges' defs u p\n                          g (snd (chooseNext_all (u g) (p g) g))", "apply (case_tac \"g'=g\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>g' n ns m v x v'.\n       \\<lbrakk>g' \\<turnstile> n-ns\\<rightarrow>m; n \\<notin> set (tl ns);\n        v \\<in> step.allDefs g' n; v \\<in> step.allUses g' m;\n        x \\<in> set (tl ns); v' \\<in> step.allDefs g' x; g' = g\\<rbrakk>\n       \\<Longrightarrow> var g' v' \\<noteq> var g' v\n 2. \\<And>g' n ns m v x v'.\n       \\<lbrakk>g' \\<turnstile> n-ns\\<rightarrow>m; n \\<notin> set (tl ns);\n        v \\<in> step.allDefs g' n; v \\<in> step.allUses g' m;\n        x \\<in> set (tl ns); v' \\<in> step.allDefs g' x;\n        g' \\<noteq> g\\<rbrakk>\n       \\<Longrightarrow> var g' v' \\<noteq> var g' v\n 3. \\<And>g n v vs v'.\n       \\<lbrakk>p_g g (n, v) = Some vs; v' \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> var g v' = var g v\n 4. \\<And>n g v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> step.allDefs g n;\n        v' \\<in> step.allDefs g n; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v\n 5. \\<And>u p g.\n       \\<lbrakk>CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry\n                 oldDefs oldUses defs u p var;\n        CFG_SSA_wf_base.redundant \\<alpha>n inEdges' defs u p g\\<rbrakk>\n       \\<Longrightarrow> chooseNext_all (u g) (p g) g \\<in> dom (p g) \\<and>\n                         CFG_SSA_wf_base.trivial \\<alpha>n inEdges' defs u p\n                          g (snd (chooseNext_all (u g) (p g) g))", "apply (simp add:conventional_inv)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>g' n ns m v x v'.\n       \\<lbrakk>g' \\<turnstile> n-ns\\<rightarrow>m; n \\<notin> set (tl ns);\n        v \\<in> step.allDefs g' n; v \\<in> step.allUses g' m;\n        x \\<in> set (tl ns); v' \\<in> step.allDefs g' x;\n        g' \\<noteq> g\\<rbrakk>\n       \\<Longrightarrow> var g' v' \\<noteq> var g' v\n 2. \\<And>g n v vs v'.\n       \\<lbrakk>p_g g (n, v) = Some vs; v' \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> var g v' = var g v\n 3. \\<And>n g v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> step.allDefs g n;\n        v' \\<in> step.allDefs g n; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v\n 4. \\<And>u p g.\n       \\<lbrakk>CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry\n                 oldDefs oldUses defs u p var;\n        CFG_SSA_wf_base.redundant \\<alpha>n inEdges' defs u p g\\<rbrakk>\n       \\<Longrightarrow> chooseNext_all (u g) (p g) g \\<in> dom (p g) \\<and>\n                         CFG_SSA_wf_base.trivial \\<alpha>n inEdges' defs u p\n                          g (snd (chooseNext_all (u g) (p g) g))", "apply (simp add:conventional[unfolded CFG_SSA_defs, simplified] step.CFG_SSA_defs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>g n v vs v'.\n       \\<lbrakk>p_g g (n, v) = Some vs; v' \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> var g v' = var g v\n 2. \\<And>n g v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> step.allDefs g n;\n        v' \\<in> step.allDefs g n; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v\n 3. \\<And>u p g.\n       \\<lbrakk>CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry\n                 oldDefs oldUses defs u p var;\n        CFG_SSA_wf_base.redundant \\<alpha>n inEdges' defs u p g\\<rbrakk>\n       \\<Longrightarrow> chooseNext_all (u g) (p g) g \\<in> dom (p g) \\<and>\n                         CFG_SSA_wf_base.trivial \\<alpha>n inEdges' defs u p\n                          g (snd (chooseNext_all (u g) (p g) g))", "apply (rename_tac g' n v vs v')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>g' n v vs v'.\n       \\<lbrakk>p_g g' (n, v) = Some vs; v' \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> var g' v' = var g' v\n 2. \\<And>n g v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> step.allDefs g n;\n        v' \\<in> step.allDefs g n; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v\n 3. \\<And>u p g.\n       \\<lbrakk>CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry\n                 oldDefs oldUses defs u p var;\n        CFG_SSA_wf_base.redundant \\<alpha>n inEdges' defs u p g\\<rbrakk>\n       \\<Longrightarrow> chooseNext_all (u g) (p g) g \\<in> dom (p g) \\<and>\n                         CFG_SSA_wf_base.trivial \\<alpha>n inEdges' defs u p\n                          g (snd (chooseNext_all (u g) (p g) g))", "apply (case_tac \"g'=g\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>g' n v vs v'.\n       \\<lbrakk>p_g g' (n, v) = Some vs; v' \\<in> set vs; g' = g\\<rbrakk>\n       \\<Longrightarrow> var g' v' = var g' v\n 2. \\<And>g' n v vs v'.\n       \\<lbrakk>p_g g' (n, v) = Some vs; v' \\<in> set vs;\n        g' \\<noteq> g\\<rbrakk>\n       \\<Longrightarrow> var g' v' = var g' v\n 3. \\<And>n g v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> step.allDefs g n;\n        v' \\<in> step.allDefs g n; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v\n 4. \\<And>u p g.\n       \\<lbrakk>CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry\n                 oldDefs oldUses defs u p var;\n        CFG_SSA_wf_base.redundant \\<alpha>n inEdges' defs u p g\\<rbrakk>\n       \\<Longrightarrow> chooseNext_all (u g) (p g) g \\<in> dom (p g) \\<and>\n                         CFG_SSA_wf_base.trivial \\<alpha>n inEdges' defs u p\n                          g (snd (chooseNext_all (u g) (p g) g))", "apply (simp add:phis_same_var_inv)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>g' n v vs v'.\n       \\<lbrakk>p_g g' (n, v) = Some vs; v' \\<in> set vs;\n        g' \\<noteq> g\\<rbrakk>\n       \\<Longrightarrow> var g' v' = var g' v\n 2. \\<And>n g v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> step.allDefs g n;\n        v' \\<in> step.allDefs g n; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v\n 3. \\<And>u p g.\n       \\<lbrakk>CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry\n                 oldDefs oldUses defs u p var;\n        CFG_SSA_wf_base.redundant \\<alpha>n inEdges' defs u p g\\<rbrakk>\n       \\<Longrightarrow> chooseNext_all (u g) (p g) g \\<in> dom (p g) \\<and>\n                         CFG_SSA_wf_base.trivial \\<alpha>n inEdges' defs u p\n                          g (snd (chooseNext_all (u g) (p g) g))", "apply (simp add:phis_same_var)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n g v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> step.allDefs g n;\n        v' \\<in> step.allDefs g n; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v\n 2. \\<And>u p g.\n       \\<lbrakk>CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry\n                 oldDefs oldUses defs u p var;\n        CFG_SSA_wf_base.redundant \\<alpha>n inEdges' defs u p g\\<rbrakk>\n       \\<Longrightarrow> chooseNext_all (u g) (p g) g \\<in> dom (p g) \\<and>\n                         CFG_SSA_wf_base.trivial \\<alpha>n inEdges' defs u p\n                          g (snd (chooseNext_all (u g) (p g) g))", "apply (rename_tac g' v v')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n g' v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g'); v \\<in> step.allDefs g' n;\n        v' \\<in> step.allDefs g' n; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> var g' v' \\<noteq> var g' v\n 2. \\<And>u p g.\n       \\<lbrakk>CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry\n                 oldDefs oldUses defs u p var;\n        CFG_SSA_wf_base.redundant \\<alpha>n inEdges' defs u p g\\<rbrakk>\n       \\<Longrightarrow> chooseNext_all (u g) (p g) g \\<in> dom (p g) \\<and>\n                         CFG_SSA_wf_base.trivial \\<alpha>n inEdges' defs u p\n                          g (snd (chooseNext_all (u g) (p g) g))", "apply (case_tac \"g'=g\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n g' v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g'); v \\<in> step.allDefs g' n;\n        v' \\<in> step.allDefs g' n; v \\<noteq> v'; g' = g\\<rbrakk>\n       \\<Longrightarrow> var g' v' \\<noteq> var g' v\n 2. \\<And>n g' v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g'); v \\<in> step.allDefs g' n;\n        v' \\<in> step.allDefs g' n; v \\<noteq> v'; g' \\<noteq> g\\<rbrakk>\n       \\<Longrightarrow> var g' v' \\<noteq> var g' v\n 3. \\<And>u p g.\n       \\<lbrakk>CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry\n                 oldDefs oldUses defs u p var;\n        CFG_SSA_wf_base.redundant \\<alpha>n inEdges' defs u p g\\<rbrakk>\n       \\<Longrightarrow> chooseNext_all (u g) (p g) g \\<in> dom (p g) \\<and>\n                         CFG_SSA_wf_base.trivial \\<alpha>n inEdges' defs u p\n                          g (snd (chooseNext_all (u g) (p g) g))", "apply (simp add:allDefs_var_disjoint_inv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n g' v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g'); v \\<in> step.allDefs g' n;\n        v' \\<in> step.allDefs g' n; v \\<noteq> v'; g' \\<noteq> g\\<rbrakk>\n       \\<Longrightarrow> var g' v' \\<noteq> var g' v\n 2. \\<And>u p g.\n       \\<lbrakk>CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry\n                 oldDefs oldUses defs u p var;\n        CFG_SSA_wf_base.redundant \\<alpha>n inEdges' defs u p g\\<rbrakk>\n       \\<Longrightarrow> chooseNext_all (u g) (p g) g \\<in> dom (p g) \\<and>\n                         CFG_SSA_wf_base.trivial \\<alpha>n inEdges' defs u p\n                          g (snd (chooseNext_all (u g) (p g) g))", "apply (simp add:allDefs_var_disjoint[unfolded allDefs_def phiDefs_def, simplified] step.allDefs_def step.phiDefs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u p g.\n       \\<lbrakk>CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry\n                 oldDefs oldUses defs u p var;\n        CFG_SSA_wf_base.redundant \\<alpha>n inEdges' defs u p g\\<rbrakk>\n       \\<Longrightarrow> chooseNext_all (u g) (p g) g \\<in> dom (p g) \\<and>\n                         CFG_SSA_wf_base.trivial \\<alpha>n inEdges' defs u p\n                          g (snd (chooseNext_all (u g) (p g) g))", "by (rule chooseNext_all)"], ["", "sublocale step: CFG_SSA_Transformed_notriv \\<alpha>e \\<alpha>n invar inEdges' Entry oldDefs oldUses \"defs\" u_g p_g var chooseNext_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_SSA_Transformed_notriv \\<alpha>e \\<alpha>n invar inEdges' Entry\n     oldDefs oldUses defs u_g p_g var chooseNext_all", "by (rule step_CFG_SSA_Transformed_notriv)"], ["", "lemma step_defNode: \"v \\<in> allVars g \\<Longrightarrow> v \\<noteq> chooseNext g \\<Longrightarrow> step.defNode g v = defNode g v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> allVars g; v \\<noteq> chooseNext g\\<rbrakk>\n    \\<Longrightarrow> step.defNode g v = defNode g v", "by (auto simp: step.CFG_SSA_wf_defs dom_def CFG_SSA_wf_defs)"], ["", "lemma step_phi: \"v \\<in> allVars g \\<Longrightarrow> v \\<noteq> chooseNext g \\<Longrightarrow> step.phi g v = map_option (map (substNext g)) (phi g v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> allVars g; v \\<noteq> chooseNext g\\<rbrakk>\n    \\<Longrightarrow> step.phi g v =\n                      map_option (map (substNext g)) (phi g v)", "by (auto simp: step.phi_def step_defNode phi_def)"], ["", "lemma liveVal'_inv:\n    assumes \"liveVal' g (v#vs)\" \"v \\<noteq> chooseNext g\"\n    obtains vs' where \"step.liveVal' g (v#vs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>vs'.\n        step.liveVal' g (v # vs') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  liveVal' g (v # vs)\n  v \\<noteq> chooseNext g\n\ngoal (1 subgoal):\n 1. (\\<And>vs'.\n        step.liveVal' g (v # vs') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof (induction \"length vs\" arbitrary: v vs rule: nat_less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vs v.\n       \\<lbrakk>\\<forall>m<length vs.\n                   \\<forall>x.\n                      m = length x \\<longrightarrow>\n                      (\\<forall>xa.\n                          (\\<forall>x.\n                              step.liveVal' g (xa # x) \\<longrightarrow>\n                              thesis) \\<longrightarrow>\n                          liveVal' g (xa # x) \\<longrightarrow>\n                          xa \\<noteq> chooseNext g \\<longrightarrow>\n                          thesis);\n        \\<And>vs'. step.liveVal' g (v # vs') \\<Longrightarrow> thesis;\n        liveVal' g (v # vs); v \\<noteq> chooseNext g\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (1 vs v)"], ["proof (state)\nthis:\n  \\<forall>m<length vs.\n     \\<forall>x.\n        m = length x \\<longrightarrow>\n        (\\<forall>xa.\n            (\\<forall>x.\n                step.liveVal' g (xa # x) \\<longrightarrow>\n                thesis) \\<longrightarrow>\n            liveVal' g (xa # x) \\<longrightarrow>\n            xa \\<noteq> chooseNext g \\<longrightarrow> thesis)\n  step.liveVal' g (v # ?vs'1) \\<Longrightarrow> thesis\n  liveVal' g (v # vs)\n  v \\<noteq> chooseNext g\n\ngoal (1 subgoal):\n 1. \\<And>vs v.\n       \\<lbrakk>\\<forall>m<length vs.\n                   \\<forall>x.\n                      m = length x \\<longrightarrow>\n                      (\\<forall>xa.\n                          (\\<forall>x.\n                              step.liveVal' g (xa # x) \\<longrightarrow>\n                              thesis) \\<longrightarrow>\n                          liveVal' g (xa # x) \\<longrightarrow>\n                          xa \\<noteq> chooseNext g \\<longrightarrow>\n                          thesis);\n        \\<And>vs'. step.liveVal' g (v # vs') \\<Longrightarrow> thesis;\n        liveVal' g (v # vs); v \\<noteq> chooseNext g\\<rbrakk>\n       \\<Longrightarrow> thesis", "from \"1.prems\"(2)"], ["proof (chain)\npicking this:\n  liveVal' g (v # vs)", "show thesis"], ["proof (prove)\nusing this:\n  liveVal' g (v # vs)\n\ngoal (1 subgoal):\n 1. thesis", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>vs = []; n \\<in> set (\\<alpha>n g);\n        v \\<in> uses g n\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>v vs.\n       \\<lbrakk>vs = v # vs; liveVal' g (v # vs); phiArg g v v\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (liveSimple' n)"], ["proof (state)\nthis:\n  vs = []\n  n \\<in> set (\\<alpha>n g)\n  v \\<in> uses g n\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>vs = []; n \\<in> set (\\<alpha>n g);\n        v \\<in> uses g n\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>v vs.\n       \\<lbrakk>vs = v # vs; liveVal' g (v # vs); phiArg g v v\\<rbrakk>\n       \\<Longrightarrow> thesis", "with \"1.prems\"(3)"], ["proof (chain)\npicking this:\n  v \\<noteq> chooseNext g\n  vs = []\n  n \\<in> set (\\<alpha>n g)\n  v \\<in> uses g n", "show thesis"], ["proof (prove)\nusing this:\n  v \\<noteq> chooseNext g\n  vs = []\n  n \\<in> set (\\<alpha>n g)\n  v \\<in> uses g n\n\ngoal (1 subgoal):\n 1. thesis", "by - (rule \"1.prems\"(1), rule step.liveSimple', auto simp: substNext_def)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>v vs.\n       \\<lbrakk>vs = v # vs; liveVal' g (v # vs); phiArg g v v\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v vs.\n       \\<lbrakk>vs = v # vs; liveVal' g (v # vs); phiArg g v v\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (livePhi' v' vs')"], ["proof (state)\nthis:\n  vs = v' # vs'\n  liveVal' g (v' # vs')\n  phiArg g v' v\n\ngoal (1 subgoal):\n 1. \\<And>v vs.\n       \\<lbrakk>vs = v # vs; liveVal' g (v # vs); phiArg g v v\\<rbrakk>\n       \\<Longrightarrow> thesis", "from this(2)"], ["proof (chain)\npicking this:\n  liveVal' g (v' # vs')", "have[simp]: \"v' \\<in> allVars g\""], ["proof (prove)\nusing this:\n  liveVal' g (v' # vs')\n\ngoal (1 subgoal):\n 1. v' \\<in> allVars g", "by - (drule liveVal'D, rule, rule liveVal_in_allVars)"], ["proof (state)\nthis:\n  v' \\<in> allVars g\n\ngoal (1 subgoal):\n 1. \\<And>v vs.\n       \\<lbrakk>vs = v # vs; liveVal' g (v # vs); phiArg g v v\\<rbrakk>\n       \\<Longrightarrow> thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases \"chooseNext g = v'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. chooseNext g = v' \\<Longrightarrow> thesis\n 2. chooseNext g \\<noteq> v' \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  chooseNext g \\<noteq> v'\n\ngoal (2 subgoals):\n 1. chooseNext g = v' \\<Longrightarrow> thesis\n 2. chooseNext g \\<noteq> v' \\<Longrightarrow> thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule \"1.hyps\"[rule_format, of \"length vs'\" vs' v'])"], ["proof (state)\ngoal (5 subgoals):\n 1. length vs' < length vs\n 2. length vs' = length vs'\n 3. \\<And>x. step.liveVal' g (v' # x) \\<Longrightarrow> thesis\n 4. liveVal' g (v' # vs')\n 5. v' \\<noteq> chooseNext g", "fix vs'\\<^sub>2"], ["proof (state)\ngoal (5 subgoals):\n 1. length vs' < length vs\n 2. length vs' = length vs'\n 3. \\<And>x. step.liveVal' g (v' # x) \\<Longrightarrow> thesis\n 4. liveVal' g (v' # vs')\n 5. v' \\<noteq> chooseNext g", "assume asm: \"step.liveVal' g (v'#vs'\\<^sub>2)\""], ["proof (state)\nthis:\n  step.liveVal' g (v' # vs'\\<^sub>2)\n\ngoal (5 subgoals):\n 1. length vs' < length vs\n 2. length vs' = length vs'\n 3. \\<And>x. step.liveVal' g (v' # x) \\<Longrightarrow> thesis\n 4. liveVal' g (v' # vs')\n 5. v' \\<noteq> chooseNext g", "have \"step.phiArg g v' v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step.phiArg g v' v", "using livePhi'(3) False \"1.prems\"(3)"], ["proof (prove)\nusing this:\n  phiArg g v' v\n  chooseNext g \\<noteq> v'\n  v \\<noteq> chooseNext g\n\ngoal (1 subgoal):\n 1. step.phiArg g v' v", "by (auto simp: step.phiArg_def phiArg_def step_phi substNext_def)"], ["proof (state)\nthis:\n  step.phiArg g v' v\n\ngoal (5 subgoals):\n 1. length vs' < length vs\n 2. length vs' = length vs'\n 3. \\<And>x. step.liveVal' g (v' # x) \\<Longrightarrow> thesis\n 4. liveVal' g (v' # vs')\n 5. v' \\<noteq> chooseNext g", "thus thesis"], ["proof (prove)\nusing this:\n  step.phiArg g v' v\n\ngoal (1 subgoal):\n 1. thesis", "by - (rule \"1.prems\"(1), rule step.livePhi', rule asm)"], ["proof (state)\nthis:\n  thesis\n\ngoal (4 subgoals):\n 1. length vs' < length vs\n 2. length vs' = length vs'\n 3. liveVal' g (v' # vs')\n 4. v' \\<noteq> chooseNext g", "qed (auto simp: livePhi' False[symmetric])"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. chooseNext g = v' \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. chooseNext g = v' \\<Longrightarrow> thesis", "case [simp]: True"], ["proof (state)\nthis:\n  chooseNext g = v'\n\ngoal (1 subgoal):\n 1. chooseNext g = v' \\<Longrightarrow> thesis", "with \"1.prems\"(3)"], ["proof (chain)\npicking this:\n  v \\<noteq> chooseNext g\n  chooseNext g = v'", "have[simp]: \"v \\<noteq> v'\""], ["proof (prove)\nusing this:\n  v \\<noteq> chooseNext g\n  chooseNext g = v'\n\ngoal (1 subgoal):\n 1. v \\<noteq> v'", "by simp"], ["proof (state)\nthis:\n  v \\<noteq> v'\n\ngoal (1 subgoal):\n 1. chooseNext g = v' \\<Longrightarrow> thesis", "from True"], ["proof (chain)\npicking this:\n  chooseNext g = v'", "have \"trivial g v'\""], ["proof (prove)\nusing this:\n  chooseNext g = v'\n\ngoal (1 subgoal):\n 1. trivial g v'", "using chooseNext[OF redundant]"], ["proof (prove)\nusing this:\n  chooseNext g = v'\n  chooseNext g \\<in> allVars g \\<and> trivial g (chooseNext g)\n\ngoal (1 subgoal):\n 1. trivial g v'", "by auto"], ["proof (state)\nthis:\n  trivial g v'\n\ngoal (1 subgoal):\n 1. chooseNext g = v' \\<Longrightarrow> thesis", "with \\<open>phiArg g v' v\\<close>"], ["proof (chain)\npicking this:\n  phiArg g v' v\n  trivial g v'", "have \"isTrivialPhi g v' v\""], ["proof (prove)\nusing this:\n  phiArg g v' v\n  trivial g v'\n\ngoal (1 subgoal):\n 1. isTrivialPhi g v' v", "by (auto simp: phiArg_def trivial_def isTrivialPhi_def)"], ["proof (state)\nthis:\n  isTrivialPhi g v' v\n\ngoal (1 subgoal):\n 1. chooseNext g = v' \\<Longrightarrow> thesis", "hence[simp]: \"substitution g = v\""], ["proof (prove)\nusing this:\n  isTrivialPhi g v' v\n\ngoal (1 subgoal):\n 1. substitution g = v", "unfolding substitution_def"], ["proof (prove)\nusing this:\n  isTrivialPhi g v' v\n\ngoal (1 subgoal):\n 1. (THE v'. isTrivialPhi g (chooseNext g) v') = v", "by - (rule the1_equality, auto intro!: isTrivialPhi_det[unfolded trivial_def])"], ["proof (state)\nthis:\n  substitution g = v\n\ngoal (1 subgoal):\n 1. chooseNext g = v' \\<Longrightarrow> thesis", "obtain vs'\\<^sub>2 where vs'\\<^sub>2: \"suffix (v'#vs'\\<^sub>2) (v'#vs')\" \"v' \\<notin> set vs'\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>vs'\\<^sub>2.\n        \\<lbrakk>suffix (v' # vs'\\<^sub>2) (v' # vs');\n         v' \\<notin> set vs'\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using split_list_last[of v' \"v'#vs'\"]"], ["proof (prove)\nusing this:\n  v' \\<in> set (v' # vs') \\<Longrightarrow>\n  \\<exists>ys zs. v' # vs' = ys @ v' # zs \\<and> v' \\<notin> set zs\n\ngoal (1 subgoal):\n 1. (\\<And>vs'\\<^sub>2.\n        \\<lbrakk>suffix (v' # vs'\\<^sub>2) (v' # vs');\n         v' \\<notin> set vs'\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Sublist.suffix_def)"], ["proof (state)\nthis:\n  suffix (v' # vs'\\<^sub>2) (v' # vs')\n  v' \\<notin> set vs'\\<^sub>2\n\ngoal (1 subgoal):\n 1. chooseNext g = v' \\<Longrightarrow> thesis", "with \\<open>liveVal' g (v'#vs')\\<close>"], ["proof (chain)\npicking this:\n  liveVal' g (v' # vs')\n  suffix (v' # vs'\\<^sub>2) (v' # vs')\n  v' \\<notin> set vs'\\<^sub>2", "have \"liveVal' g (v'#vs'\\<^sub>2)\""], ["proof (prove)\nusing this:\n  liveVal' g (v' # vs')\n  suffix (v' # vs'\\<^sub>2) (v' # vs')\n  v' \\<notin> set vs'\\<^sub>2\n\ngoal (1 subgoal):\n 1. liveVal' g (v' # vs'\\<^sub>2)", "by - (rule liveVal'_suffix, simp_all)"], ["proof (state)\nthis:\n  liveVal' g (v' # vs'\\<^sub>2)\n\ngoal (1 subgoal):\n 1. chooseNext g = v' \\<Longrightarrow> thesis", "thus thesis"], ["proof (prove)\nusing this:\n  liveVal' g (v' # vs'\\<^sub>2)\n\ngoal (1 subgoal):\n 1. thesis", "proof (cases rule: liveVal'.cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>vs'\\<^sub>2 = []; n \\<in> set (\\<alpha>n g);\n        v' \\<in> uses g n\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>v vs.\n       \\<lbrakk>vs'\\<^sub>2 = v # vs; liveVal' g (v # vs);\n        phiArg g v v'\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (liveSimple' n)"], ["proof (state)\nthis:\n  vs'\\<^sub>2 = []\n  n \\<in> set (\\<alpha>n g)\n  v' \\<in> uses g n\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>vs'\\<^sub>2 = []; n \\<in> set (\\<alpha>n g);\n        v' \\<in> uses g n\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>v vs.\n       \\<lbrakk>vs'\\<^sub>2 = v # vs; liveVal' g (v # vs);\n        phiArg g v v'\\<rbrakk>\n       \\<Longrightarrow> thesis", "hence \"v \\<in> uses' g n\""], ["proof (prove)\nusing this:\n  vs'\\<^sub>2 = []\n  n \\<in> set (\\<alpha>n g)\n  v' \\<in> uses g n\n\ngoal (1 subgoal):\n 1. v \\<in> uses' g n", "by (auto simp: substNext_def)"], ["proof (state)\nthis:\n  v \\<in> uses' g n\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>vs'\\<^sub>2 = []; n \\<in> set (\\<alpha>n g);\n        v' \\<in> uses g n\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>v vs.\n       \\<lbrakk>vs'\\<^sub>2 = v # vs; liveVal' g (v # vs);\n        phiArg g v v'\\<rbrakk>\n       \\<Longrightarrow> thesis", "with liveSimple'"], ["proof (chain)\npicking this:\n  vs'\\<^sub>2 = []\n  n \\<in> set (\\<alpha>n g)\n  v' \\<in> uses g n\n  v \\<in> uses' g n", "show thesis"], ["proof (prove)\nusing this:\n  vs'\\<^sub>2 = []\n  n \\<in> set (\\<alpha>n g)\n  v' \\<in> uses g n\n  v \\<in> uses' g n\n\ngoal (1 subgoal):\n 1. thesis", "by - (rule \"1.prems\"(1), rule step.liveSimple', auto)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>v vs.\n       \\<lbrakk>vs'\\<^sub>2 = v # vs; liveVal' g (v # vs);\n        phiArg g v v'\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v vs.\n       \\<lbrakk>vs'\\<^sub>2 = v # vs; liveVal' g (v # vs);\n        phiArg g v v'\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (livePhi' v'' vs'')"], ["proof (state)\nthis:\n  vs'\\<^sub>2 = v'' # vs''\n  liveVal' g (v'' # vs'')\n  phiArg g v'' v'\n\ngoal (1 subgoal):\n 1. \\<And>v vs.\n       \\<lbrakk>vs'\\<^sub>2 = v # vs; liveVal' g (v # vs);\n        phiArg g v v'\\<rbrakk>\n       \\<Longrightarrow> thesis", "from this(2)"], ["proof (chain)\npicking this:\n  liveVal' g (v'' # vs'')", "have[simp]: \"v'' \\<in> allVars g\""], ["proof (prove)\nusing this:\n  liveVal' g (v'' # vs'')\n\ngoal (1 subgoal):\n 1. v'' \\<in> allVars g", "by - (drule liveVal'D, rule, rule liveVal_in_allVars)"], ["proof (state)\nthis:\n  v'' \\<in> allVars g\n\ngoal (1 subgoal):\n 1. \\<And>v vs.\n       \\<lbrakk>vs'\\<^sub>2 = v # vs; liveVal' g (v # vs);\n        phiArg g v v'\\<rbrakk>\n       \\<Longrightarrow> thesis", "from vs'\\<^sub>2(2) livePhi'(1)"], ["proof (chain)\npicking this:\n  v' \\<notin> set vs'\\<^sub>2\n  vs'\\<^sub>2 = v'' # vs''", "have[simp]: \"v'' \\<noteq> v'\""], ["proof (prove)\nusing this:\n  v' \\<notin> set vs'\\<^sub>2\n  vs'\\<^sub>2 = v'' # vs''\n\ngoal (1 subgoal):\n 1. v'' \\<noteq> v'", "by auto"], ["proof (state)\nthis:\n  v'' \\<noteq> v'\n\ngoal (1 subgoal):\n 1. \\<And>v vs.\n       \\<lbrakk>vs'\\<^sub>2 = v # vs; liveVal' g (v # vs);\n        phiArg g v v'\\<rbrakk>\n       \\<Longrightarrow> thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule \"1.hyps\"[rule_format, of \"length vs''\" vs'' v''])"], ["proof (state)\ngoal (5 subgoals):\n 1. length vs'' < length vs\n 2. length vs'' = length vs''\n 3. \\<And>x. step.liveVal' g (v'' # x) \\<Longrightarrow> thesis\n 4. liveVal' g (v'' # vs'')\n 5. v'' \\<noteq> chooseNext g", "show \"length vs'' < length vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length vs'' < length vs", "using \\<open>vs = v'#vs'\\<close> livePhi'(1) vs'\\<^sub>2(1)[THEN suffix_ConsD2]"], ["proof (prove)\nusing this:\n  vs = v' # vs'\n  vs'\\<^sub>2 = v'' # vs''\n  suffix vs'\\<^sub>2 vs'\n\ngoal (1 subgoal):\n 1. length vs'' < length vs", "by (auto simp: Sublist.suffix_def)"], ["proof (state)\nthis:\n  length vs'' < length vs\n\ngoal (4 subgoals):\n 1. length vs'' = length vs''\n 2. \\<And>x. step.liveVal' g (v'' # x) \\<Longrightarrow> thesis\n 3. liveVal' g (v'' # vs'')\n 4. v'' \\<noteq> chooseNext g", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. length vs'' = length vs''\n 2. \\<And>x. step.liveVal' g (v'' # x) \\<Longrightarrow> thesis\n 3. liveVal' g (v'' # vs'')\n 4. v'' \\<noteq> chooseNext g", "fix vs''\\<^sub>2"], ["proof (state)\ngoal (4 subgoals):\n 1. length vs'' = length vs''\n 2. \\<And>x. step.liveVal' g (v'' # x) \\<Longrightarrow> thesis\n 3. liveVal' g (v'' # vs'')\n 4. v'' \\<noteq> chooseNext g", "assume asm: \"step.liveVal' g (v''#vs''\\<^sub>2)\""], ["proof (state)\nthis:\n  step.liveVal' g (v'' # vs''\\<^sub>2)\n\ngoal (4 subgoals):\n 1. length vs'' = length vs''\n 2. \\<And>x. step.liveVal' g (v'' # x) \\<Longrightarrow> thesis\n 3. liveVal' g (v'' # vs'')\n 4. v'' \\<noteq> chooseNext g", "from livePhi' \\<open>phiArg g v' v\\<close>"], ["proof (chain)\npicking this:\n  vs'\\<^sub>2 = v'' # vs''\n  liveVal' g (v'' # vs'')\n  phiArg g v'' v'\n  phiArg g v' v", "have \"step.phiArg g v'' v\""], ["proof (prove)\nusing this:\n  vs'\\<^sub>2 = v'' # vs''\n  liveVal' g (v'' # vs'')\n  phiArg g v'' v'\n  phiArg g v' v\n\ngoal (1 subgoal):\n 1. step.phiArg g v'' v", "by (auto simp: phiArg_def step.phiArg_def step_phi substNext_def)"], ["proof (state)\nthis:\n  step.phiArg g v'' v\n\ngoal (4 subgoals):\n 1. length vs'' = length vs''\n 2. \\<And>x. step.liveVal' g (v'' # x) \\<Longrightarrow> thesis\n 3. liveVal' g (v'' # vs'')\n 4. v'' \\<noteq> chooseNext g", "thus thesis"], ["proof (prove)\nusing this:\n  step.phiArg g v'' v\n\ngoal (1 subgoal):\n 1. thesis", "by - (rule \"1.prems\"(1), rule step.livePhi', rule asm)"], ["proof (state)\nthis:\n  thesis\n\ngoal (3 subgoals):\n 1. length vs'' = length vs''\n 2. liveVal' g (v'' # vs'')\n 3. v'' \\<noteq> chooseNext g", "qed (auto simp: livePhi'(2))"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma liveVal_inv:\n    assumes \"liveVal g v\" \"v \\<noteq> chooseNext g\"\n    shows \"step.liveVal g v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step.liveVal g v", "apply (rule liveVal'I[OF assms(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>vs. liveVal' g (v # vs) \\<Longrightarrow> step.liveVal g v", "apply (erule liveVal'_inv[OF _ assms(2)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>vs vs'.\n       step.liveVal' g (v # vs') \\<Longrightarrow> step.liveVal g v", "apply (rule step.liveVal'D)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>vs vs'.\n       step.liveVal' g (v # vs') \\<Longrightarrow>\n       step.liveVal' g (?vs5 vs vs')\n 2. \\<And>vs vs'.\n       step.liveVal' g (v # vs') \\<Longrightarrow>\n       ?vs5 vs vs' = v # ?vs'5 vs vs'", "by simp_all"], ["", "lemma pruned_inv:\n    assumes \"pruned g\"\n    shows \"step.pruned g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step.pruned g", "proof (rule step.pruned_def[THEN iffD2, rule_format])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n val.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g);\n        val \\<in> step.phiDefs g n\\<rbrakk>\n       \\<Longrightarrow> step.liveVal g val", "fix n v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n val.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g);\n        val \\<in> step.phiDefs g n\\<rbrakk>\n       \\<Longrightarrow> step.liveVal g val", "assume \"v \\<in> step.phiDefs g n\" and[simp]: \"n \\<in> set (\\<alpha>n g)\""], ["proof (state)\nthis:\n  v \\<in> step.phiDefs g n\n  n \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. \\<And>n val.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g);\n        val \\<in> step.phiDefs g n\\<rbrakk>\n       \\<Longrightarrow> step.liveVal g val", "hence \"v \\<in> phiDefs g n\" \"v \\<noteq> chooseNext g\""], ["proof (prove)\nusing this:\n  v \\<in> step.phiDefs g n\n  n \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. v \\<in> phiDefs g n &&& v \\<noteq> chooseNext g", "by (auto simp: step.CFG_SSA_defs CFG_SSA_defs split: if_split_asm)"], ["proof (state)\nthis:\n  v \\<in> phiDefs g n\n  v \\<noteq> chooseNext g\n\ngoal (1 subgoal):\n 1. \\<And>n val.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g);\n        val \\<in> step.phiDefs g n\\<rbrakk>\n       \\<Longrightarrow> step.liveVal g val", "hence \"liveVal g v\""], ["proof (prove)\nusing this:\n  v \\<in> phiDefs g n\n  v \\<noteq> chooseNext g\n\ngoal (1 subgoal):\n 1. liveVal g v", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> phiDefs g n\n  v \\<noteq> chooseNext g\n  pruned g\n\ngoal (1 subgoal):\n 1. liveVal g v", "by (auto simp: pruned_def)"], ["proof (state)\nthis:\n  liveVal g v\n\ngoal (1 subgoal):\n 1. \\<And>n val.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g);\n        val \\<in> step.phiDefs g n\\<rbrakk>\n       \\<Longrightarrow> step.liveVal g val", "thus \"step.liveVal g v\""], ["proof (prove)\nusing this:\n  liveVal g v\n\ngoal (1 subgoal):\n 1. step.liveVal g v", "using \\<open>v \\<noteq> chooseNext g\\<close>"], ["proof (prove)\nusing this:\n  liveVal g v\n  v \\<noteq> chooseNext g\n\ngoal (1 subgoal):\n 1. step.liveVal g v", "by (rule liveVal_inv)"], ["proof (state)\nthis:\n  step.liveVal g v\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context CFG_SSA_Transformed_notriv_base\nbegin"], ["", "abbreviation \"inst g u p \\<equiv> CFG_SSA_Transformed_notriv \\<alpha>e \\<alpha>n invar inEdges' Entry oldDefs oldUses defs (uses(g:=u)) (phis(g:=p)) var chooseNext_all\""], ["", "abbreviation \"inst' g \\<equiv> \\<lambda>(u,p). inst g u p\""], ["", "interpretation uninst: CFG_SSA_Transformed_notriv_base \\<alpha>e \\<alpha>n invar inEdges' Entry oldDefs oldUses \"defs\" u p var chooseNext_all\n  for u and p"], ["proof (prove)\ngoal:\nNo subgoals!", "by unfold_locales"], ["", "definition \"cond g \\<equiv> \\<lambda>(u,p). uninst.redundant (uses(g:=u)) (phis(g:=p)) g\""], ["", "definition \"step g \\<equiv> \\<lambda>(u,p). (uninst.uses' (uses(g:=u)) (phis(g:=p)) g,\n                                uninst.phis' (uses(g:=u)) (phis(g:=p)) g)\""], ["", "definition[code]: \"substAll g \\<equiv> while (cond g) (step g) (uses g,phis g)\""], ["", "definition[code]: \"uses'_all g \\<equiv> fst (substAll g)\""], ["", "definition[code]: \"phis'_all g \\<equiv> snd (substAll g)\""], ["", "lemma uninst_allVars_simps [simp]:\n    \"uninst.allVars u (\\<lambda>_. p g) g = uninst.allVars u p g\"\n    \"uninst.allVars (\\<lambda>_. u g) p g = uninst.allVars u p g\"\n    \"uninst.allVars (uses(g:=u g)) p g = uninst.allVars u p g\"\n    \"uninst.allVars u (phis(g:=p g)) g = uninst.allVars u p g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uninst.allVars u (\\<lambda>_. p g) g = uninst.allVars u p g &&&\n     uninst.allVars (\\<lambda>_. u g) p g = uninst.allVars u p g) &&&\n    uninst.allVars (uses(g := u g)) p g = uninst.allVars u p g &&&\n    uninst.allVars u (phis(g := p g)) g = uninst.allVars u p g", "unfolding uninst.allVars_def uninst.allDefs_def uninst.allUses_def uninst.phiDefs_def uninst.phiUses_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Union>n\\<in>set (\\<alpha>n g).\n         defs g n \\<union> {v. (n, v) \\<in> dom (p g)} \\<union>\n         (u g n \\<union>\n          (\\<Union>n'\\<in>set (old.successors g n).\n              \\<Union>v'\\<in>{v. (n', v) \\<in> dom (p g)}.\n                 snd `\n                 Set.filter (\\<lambda>(n'', v). n'' = n)\n                  (set (zip (old.predecessors g n')\n                         (the (p g (n', v')))))))) =\n     (\\<Union>n\\<in>set (\\<alpha>n g).\n         defs g n \\<union> {v. (n, v) \\<in> dom (p g)} \\<union>\n         (u g n \\<union>\n          (\\<Union>n'\\<in>set (old.successors g n).\n              \\<Union>v'\\<in>{v. (n', v) \\<in> dom (p g)}.\n                 snd `\n                 Set.filter (\\<lambda>(n'', v). n'' = n)\n                  (set (zip (old.predecessors g n')\n                         (the (p g (n', v')))))))) &&&\n     (\\<Union>n\\<in>set (\\<alpha>n g).\n         defs g n \\<union> {v. (n, v) \\<in> dom (p g)} \\<union>\n         (u g n \\<union>\n          (\\<Union>n'\\<in>set (old.successors g n).\n              \\<Union>v'\\<in>{v. (n', v) \\<in> dom (p g)}.\n                 snd `\n                 Set.filter (\\<lambda>(n'', v). n'' = n)\n                  (set (zip (old.predecessors g n')\n                         (the (p g (n', v')))))))) =\n     (\\<Union>n\\<in>set (\\<alpha>n g).\n         defs g n \\<union> {v. (n, v) \\<in> dom (p g)} \\<union>\n         (u g n \\<union>\n          (\\<Union>n'\\<in>set (old.successors g n).\n              \\<Union>v'\\<in>{v. (n', v) \\<in> dom (p g)}.\n                 snd `\n                 Set.filter (\\<lambda>(n'', v). n'' = n)\n                  (set (zip (old.predecessors g n')\n                         (the (p g (n', v'))))))))) &&&\n    (\\<Union>n\\<in>set (\\<alpha>n g).\n        defs g n \\<union> {v. (n, v) \\<in> dom (p g)} \\<union>\n        ((uses(g := u g)) g n \\<union>\n         (\\<Union>n'\\<in>set (old.successors g n).\n             \\<Union>v'\\<in>{v. (n', v) \\<in> dom (p g)}.\n                snd `\n                Set.filter (\\<lambda>(n'', v). n'' = n)\n                 (set (zip (old.predecessors g n')\n                        (the (p g (n', v')))))))) =\n    (\\<Union>n\\<in>set (\\<alpha>n g).\n        defs g n \\<union> {v. (n, v) \\<in> dom (p g)} \\<union>\n        (u g n \\<union>\n         (\\<Union>n'\\<in>set (old.successors g n).\n             \\<Union>v'\\<in>{v. (n', v) \\<in> dom (p g)}.\n                snd `\n                Set.filter (\\<lambda>(n'', v). n'' = n)\n                 (set (zip (old.predecessors g n')\n                        (the (p g (n', v')))))))) &&&\n    (\\<Union>n\\<in>set (\\<alpha>n g).\n        defs g n \\<union>\n        {v. (n, v) \\<in> dom ((phis(g := p g)) g)} \\<union>\n        (u g n \\<union>\n         (\\<Union>n'\\<in>set (old.successors g n).\n             \\<Union>v'\\<in>{v. (n', v) \\<in> dom ((phis(g := p g)) g)}.\n                snd `\n                Set.filter (\\<lambda>(n'', v). n'' = n)\n                 (set (zip (old.predecessors g n')\n                        (the ((phis(g := p g)) g (n', v')))))))) =\n    (\\<Union>n\\<in>set (\\<alpha>n g).\n        defs g n \\<union> {v. (n, v) \\<in> dom (p g)} \\<union>\n        (u g n \\<union>\n         (\\<Union>n'\\<in>set (old.successors g n).\n             \\<Union>v'\\<in>{v. (n', v) \\<in> dom (p g)}.\n                snd `\n                Set.filter (\\<lambda>(n'', v). n'' = n)\n                 (set (zip (old.predecessors g n') (the (p g (n', v'))))))))", "by simp_all"], ["", "lemma uninst_trivial_simps [simp]:\n    \"uninst.trivial u (\\<lambda>_. p g) g = uninst.trivial u p g\"\n    \"uninst.trivial (\\<lambda>_. u g) p g = uninst.trivial u p g\"\n    \"uninst.trivial (uses(g:=u g)) p g = uninst.trivial u p g\"\n    \"uninst.trivial u (phis(g:=p g)) g = uninst.trivial u p g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uninst.trivial u (\\<lambda>_. p g) g = uninst.trivial u p g &&&\n     uninst.trivial (\\<lambda>_. u g) p g = uninst.trivial u p g) &&&\n    uninst.trivial (uses(g := u g)) p g = uninst.trivial u p g &&&\n    uninst.trivial u (phis(g := p g)) g = uninst.trivial u p g", "unfolding uninst.trivial_def [abs_def] uninst.isTrivialPhi_def uninst.phi_def uninst.defNode_code\n      uninst.allDefs_def uninst.phiDefs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>v.\n         \\<exists>v'\\<in>uninst.allVars u (\\<lambda>_. p g) g.\n            v' \\<noteq> v \\<and>\n            (case p g (hd (filter\n                            (\\<lambda>n.\n                                v \\<in> defs g n \\<union>\n  {v. (n, v) \\<in> dom (p g)})\n                            (\\<alpha>n g)),\n                       v) of\n             None \\<Rightarrow> False\n             | Some vs \\<Rightarrow>\n                 set vs = {v, v'} \\<or> set vs = {v'})) =\n     (\\<lambda>v.\n         \\<exists>v'\\<in>uninst.allVars u p g.\n            v' \\<noteq> v \\<and>\n            (case p g (hd (filter\n                            (\\<lambda>n.\n                                v \\<in> defs g n \\<union>\n  {v. (n, v) \\<in> dom (p g)})\n                            (\\<alpha>n g)),\n                       v) of\n             None \\<Rightarrow> False\n             | Some vs \\<Rightarrow>\n                 set vs = {v, v'} \\<or> set vs = {v'})) &&&\n     (\\<lambda>v.\n         \\<exists>v'\\<in>uninst.allVars (\\<lambda>_. u g) p g.\n            v' \\<noteq> v \\<and>\n            (case p g (hd (filter\n                            (\\<lambda>n.\n                                v \\<in> defs g n \\<union>\n  {v. (n, v) \\<in> dom (p g)})\n                            (\\<alpha>n g)),\n                       v) of\n             None \\<Rightarrow> False\n             | Some vs \\<Rightarrow>\n                 set vs = {v, v'} \\<or> set vs = {v'})) =\n     (\\<lambda>v.\n         \\<exists>v'\\<in>uninst.allVars u p g.\n            v' \\<noteq> v \\<and>\n            (case p g (hd (filter\n                            (\\<lambda>n.\n                                v \\<in> defs g n \\<union>\n  {v. (n, v) \\<in> dom (p g)})\n                            (\\<alpha>n g)),\n                       v) of\n             None \\<Rightarrow> False\n             | Some vs \\<Rightarrow>\n                 set vs = {v, v'} \\<or> set vs = {v'}))) &&&\n    (\\<lambda>v.\n        \\<exists>v'\\<in>uninst.allVars (uses(g := u g)) p g.\n           v' \\<noteq> v \\<and>\n           (case p g (hd (filter\n                           (\\<lambda>n.\n                               v \\<in> defs g n \\<union>\n {v. (n, v) \\<in> dom (p g)})\n                           (\\<alpha>n g)),\n                      v) of\n            None \\<Rightarrow> False\n            | Some vs \\<Rightarrow> set vs = {v, v'} \\<or> set vs = {v'})) =\n    (\\<lambda>v.\n        \\<exists>v'\\<in>uninst.allVars u p g.\n           v' \\<noteq> v \\<and>\n           (case p g (hd (filter\n                           (\\<lambda>n.\n                               v \\<in> defs g n \\<union>\n {v. (n, v) \\<in> dom (p g)})\n                           (\\<alpha>n g)),\n                      v) of\n            None \\<Rightarrow> False\n            | Some vs \\<Rightarrow>\n                set vs = {v, v'} \\<or> set vs = {v'})) &&&\n    (\\<lambda>v.\n        \\<exists>v'\\<in>uninst.allVars u (phis(g := p g)) g.\n           v' \\<noteq> v \\<and>\n           (case (phis(g := p g)) g\n                  (hd (filter\n                        (\\<lambda>n.\n                            v \\<in> defs g n \\<union>\n                                    {v. (n, v)\n  \\<in> dom ((phis(g := p g)) g)})\n                        (\\<alpha>n g)),\n                   v) of\n            None \\<Rightarrow> False\n            | Some vs \\<Rightarrow> set vs = {v, v'} \\<or> set vs = {v'})) =\n    (\\<lambda>v.\n        \\<exists>v'\\<in>uninst.allVars u p g.\n           v' \\<noteq> v \\<and>\n           (case p g (hd (filter\n                           (\\<lambda>n.\n                               v \\<in> defs g n \\<union>\n {v. (n, v) \\<in> dom (p g)})\n                           (\\<alpha>n g)),\n                      v) of\n            None \\<Rightarrow> False\n            | Some vs \\<Rightarrow> set vs = {v, v'} \\<or> set vs = {v'}))", "by simp_all"], ["", "end"], ["", "context CFG_SSA_Transformed_notriv\nbegin"], ["", "declare fun_upd_apply[simp del] fun_upd_same[simp]"], ["", "lemma substAll_wf:\n    assumes[simp]: \"redundant g\"\n    shows \"card (dom (phis' g)) < card (dom (phis g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (dom (phis' g)) < card (dom (phis g))", "proof (rule psubset_card_mono)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (dom (phis g))\n 2. dom (phis' g) \\<subset> dom (phis g)", "let ?v = \"chooseNext g\""], ["proof (state)\ngoal (2 subgoals):\n 1. finite (dom (phis g))\n 2. dom (phis' g) \\<subset> dom (phis g)", "from chooseNext[of g]"], ["proof (chain)\npicking this:\n  redundant g \\<Longrightarrow>\n  chooseNext g \\<in> allVars g \\<and> trivial g (chooseNext g)", "obtain n where \"(n,?v) \\<in> dom (phis g)\""], ["proof (prove)\nusing this:\n  redundant g \\<Longrightarrow>\n  chooseNext g \\<in> allVars g \\<and> trivial g (chooseNext g)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        (n, chooseNext g) \\<in> dom (phis g) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: trivial_def isTrivialPhi_def phi_def split:option.splits)"], ["proof (state)\nthis:\n  (n, chooseNext g) \\<in> dom (phis g)\n\ngoal (2 subgoals):\n 1. finite (dom (phis g))\n 2. dom (phis' g) \\<subset> dom (phis g)", "moreover"], ["proof (state)\nthis:\n  (n, chooseNext g) \\<in> dom (phis g)\n\ngoal (2 subgoals):\n 1. finite (dom (phis g))\n 2. dom (phis' g) \\<subset> dom (phis g)", "have \"(n,?v) \\<notin> dom (phis' g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n, chooseNext g) \\<notin> dom (phis' g)", "by auto"], ["proof (state)\nthis:\n  (n, chooseNext g) \\<notin> dom (phis' g)\n\ngoal (2 subgoals):\n 1. finite (dom (phis g))\n 2. dom (phis' g) \\<subset> dom (phis g)", "ultimately"], ["proof (chain)\npicking this:\n  (n, chooseNext g) \\<in> dom (phis g)\n  (n, chooseNext g) \\<notin> dom (phis' g)", "have \"dom (phis' g) \\<noteq> dom (phis g)\""], ["proof (prove)\nusing this:\n  (n, chooseNext g) \\<in> dom (phis g)\n  (n, chooseNext g) \\<notin> dom (phis' g)\n\ngoal (1 subgoal):\n 1. dom (phis' g) \\<noteq> dom (phis g)", "by auto"], ["proof (state)\nthis:\n  dom (phis' g) \\<noteq> dom (phis g)\n\ngoal (2 subgoals):\n 1. finite (dom (phis g))\n 2. dom (phis' g) \\<subset> dom (phis g)", "thus \"dom (phis' g) \\<subset> dom (phis g)\""], ["proof (prove)\nusing this:\n  dom (phis' g) \\<noteq> dom (phis g)\n\ngoal (1 subgoal):\n 1. dom (phis' g) \\<subset> dom (phis g)", "by (auto split:if_split_asm)"], ["proof (state)\nthis:\n  dom (phis' g) \\<subset> dom (phis g)\n\ngoal (1 subgoal):\n 1. finite (dom (phis g))", "qed (rule phis_finite)"], ["", "lemma step_preserves_inst:\n    assumes \"inst' g (u,p)\"\n      and \"CFG_SSA_wf_base.redundant \\<alpha>n inEdges' defs (uses(g:=u)) (phis(g:=p)) g\"\n    shows \"inst' g (step g (u,p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inst' g (step g (u, p))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. inst' g (step g (u, p))", "from assms(1)"], ["proof (chain)\npicking this:\n  inst' g (u, p)", "interpret i: CFG_SSA_Transformed_notriv \\<alpha>e \\<alpha>n invar inEdges' Entry oldDefs oldUses \"defs\" \"uses(g:=u)\" \"phis(g:=p)\" var"], ["proof (prove)\nusing this:\n  inst' g (u, p)\n\ngoal (1 subgoal):\n 1. inst g u p", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. inst' g (step g (u, p))", "from assms(2)"], ["proof (chain)\npicking this:\n  i.redundant g", "interpret step: CFG_SSA_step \\<alpha>e \\<alpha>n invar inEdges' Entry oldDefs oldUses \"defs\" \"uses(g:=u)\" \"phis(g:=p)\" var chooseNext_all"], ["proof (prove)\nusing this:\n  i.redundant g\n\ngoal (1 subgoal):\n 1. CFG_SSA_step \\<alpha>e \\<alpha>n invar inEdges' Entry oldDefs oldUses\n     defs (uses(g := u)) (phis(g := p)) var chooseNext_all g", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. inst' g (step g (u, p))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. inst' g (step g (u, p))", "using step.step_CFG_SSA_Transformed_notriv[simplified]"], ["proof (prove)\nusing this:\n  inst g (i.uses' g) (i.phis' g)\n\ngoal (1 subgoal):\n 1. inst' g (step g (u, p))", "by (simp add: step_def)"], ["proof (state)\nthis:\n  inst' g (step g (u, p))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma substAll:\n    assumes \"P (uses g, phis g)\"\n    assumes \"\\<And>x. P x \\<Longrightarrow> inst' g x \\<Longrightarrow> cond g x \\<Longrightarrow> P (step g x)\"\n    assumes \"\\<And>x. P x \\<Longrightarrow> inst' g x \\<Longrightarrow> \\<not>cond g x \\<Longrightarrow> Q (fst x) (snd x)\"\n    shows \"inst g (uses'_all g) (phis'_all g)\" \"Q (uses'_all g) (phis'_all g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inst g (uses'_all g) (phis'_all g) &&& Q (uses'_all g) (phis'_all g)", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. inst g (uses'_all g) (phis'_all g)\n 2. Q (uses'_all g) (phis'_all g)", "note uses'_def[simp del]"], ["proof (state)\nthis:\n  uses' ?g ?n \\<equiv> substNext ?g ` uses ?g ?n\n\ngoal (2 subgoals):\n 1. inst g (uses'_all g) (phis'_all g)\n 2. Q (uses'_all g) (phis'_all g)", "note phis'_def[simp del]"], ["proof (state)\nthis:\n  phis' ?g ?x \\<equiv>\n  case ?x of\n  (n, v) \\<Rightarrow>\n    if v = chooseNext ?g then None\n    else map_option (map (substNext ?g)) (phis ?g (n, v))\n\ngoal (2 subgoals):\n 1. inst g (uses'_all g) (phis'_all g)\n 2. Q (uses'_all g) (phis'_all g)", "have 2: \"\\<And>f x. f x = f (fst x, snd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f x. f x = f (fst x, snd x)", "by simp"], ["proof (state)\nthis:\n  ?f1 ?x1 = ?f1 (fst ?x1, snd ?x1)\n\ngoal (2 subgoals):\n 1. inst g (uses'_all g) (phis'_all g)\n 2. Q (uses'_all g) (phis'_all g)", "have \"inst' g (substAll g) \\<and> Q (uses'_all g) (phis'_all g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inst' g (substAll g) \\<and> Q (uses'_all g) (phis'_all g)", "unfolding substAll_def uses'_all_def phis'_all_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inst' g (while (cond g) (step g) (uses g, phis g)) \\<and>\n    Q (fst (while (cond g) (step g) (uses g, phis g)))\n     (snd (while (cond g) (step g) (uses g, phis g)))", "apply (rule while_rule[where P=\"\\<lambda>x. inst' g x \\<and> P x\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. inst' g (uses g, phis g) \\<and> P (uses g, phis g)\n 2. \\<And>s.\n       \\<lbrakk>inst' g s \\<and> P s; cond g s\\<rbrakk>\n       \\<Longrightarrow> inst' g (step g s) \\<and> P (step g s)\n 3. \\<And>s.\n       \\<lbrakk>inst' g s \\<and> P s; \\<not> cond g s\\<rbrakk>\n       \\<Longrightarrow> inst' g s \\<and> Q (fst s) (snd s)\n 4. wf ?r\n 5. \\<And>s.\n       \\<lbrakk>inst' g s \\<and> P s; cond g s\\<rbrakk>\n       \\<Longrightarrow> (step g s, s) \\<in> ?r", "apply (rule conjI)"], ["proof (prove)\ngoal (6 subgoals):\n 1. inst' g (uses g, phis g)\n 2. P (uses g, phis g)\n 3. \\<And>s.\n       \\<lbrakk>inst' g s \\<and> P s; cond g s\\<rbrakk>\n       \\<Longrightarrow> inst' g (step g s) \\<and> P (step g s)\n 4. \\<And>s.\n       \\<lbrakk>inst' g s \\<and> P s; \\<not> cond g s\\<rbrakk>\n       \\<Longrightarrow> inst' g s \\<and> Q (fst s) (snd s)\n 5. wf ?r\n 6. \\<And>s.\n       \\<lbrakk>inst' g s \\<and> P s; cond g s\\<rbrakk>\n       \\<Longrightarrow> (step g s, s) \\<in> ?r", "apply (simp, unfold_locales)"], ["proof (prove)\ngoal (5 subgoals):\n 1. P (uses g, phis g)\n 2. \\<And>s.\n       \\<lbrakk>inst' g s \\<and> P s; cond g s\\<rbrakk>\n       \\<Longrightarrow> inst' g (step g s) \\<and> P (step g s)\n 3. \\<And>s.\n       \\<lbrakk>inst' g s \\<and> P s; \\<not> cond g s\\<rbrakk>\n       \\<Longrightarrow> inst' g s \\<and> Q (fst s) (snd s)\n 4. wf ?r\n 5. \\<And>s.\n       \\<lbrakk>inst' g s \\<and> P s; cond g s\\<rbrakk>\n       \\<Longrightarrow> (step g s, s) \\<in> ?r", "apply (rule assms(1))"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>inst' g s \\<and> P s; cond g s\\<rbrakk>\n       \\<Longrightarrow> inst' g (step g s) \\<and> P (step g s)\n 2. \\<And>s.\n       \\<lbrakk>inst' g s \\<and> P s; \\<not> cond g s\\<rbrakk>\n       \\<Longrightarrow> inst' g s \\<and> Q (fst s) (snd s)\n 3. wf ?r\n 4. \\<And>s.\n       \\<lbrakk>inst' g s \\<and> P s; cond g s\\<rbrakk>\n       \\<Longrightarrow> (step g s, s) \\<in> ?r", "apply (rule conjI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>inst' g s \\<and> P s; cond g s\\<rbrakk>\n       \\<Longrightarrow> inst' g (step g s)\n 2. \\<And>s.\n       \\<lbrakk>inst' g s \\<and> P s; cond g s\\<rbrakk>\n       \\<Longrightarrow> P (step g s)\n 3. \\<And>s.\n       \\<lbrakk>inst' g s \\<and> P s; \\<not> cond g s\\<rbrakk>\n       \\<Longrightarrow> inst' g s \\<and> Q (fst s) (snd s)\n 4. wf ?r\n 5. \\<And>s.\n       \\<lbrakk>inst' g s \\<and> P s; cond g s\\<rbrakk>\n       \\<Longrightarrow> (step g s, s) \\<in> ?r", "apply (clarsimp simp: cond_def step_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>CFG_SSA_wf_base.redundant \\<alpha>n inEdges' defs\n                 (uses(g := a)) (phis(g := b)) g;\n        inst g a b; P (a, b)\\<rbrakk>\n       \\<Longrightarrow> inst g\n                          (CFG_SSA_Transformed_notriv_base.uses' \\<alpha>n\n                            defs (uses(g := a)) (phis(g := b))\n                            chooseNext_all g)\n                          (CFG_SSA_Transformed_notriv_base.phis' \\<alpha>n\n                            defs (uses(g := a)) (phis(g := b))\n                            chooseNext_all g)\n 2. \\<And>s.\n       \\<lbrakk>inst' g s \\<and> P s; cond g s\\<rbrakk>\n       \\<Longrightarrow> P (step g s)\n 3. \\<And>s.\n       \\<lbrakk>inst' g s \\<and> P s; \\<not> cond g s\\<rbrakk>\n       \\<Longrightarrow> inst' g s \\<and> Q (fst s) (snd s)\n 4. wf ?r\n 5. \\<And>s.\n       \\<lbrakk>inst' g s \\<and> P s; cond g s\\<rbrakk>\n       \\<Longrightarrow> (step g s, s) \\<in> ?r", "apply (rule step_preserves_inst [unfolded step_def, simplified], assumption+)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>inst' g s \\<and> P s; cond g s\\<rbrakk>\n       \\<Longrightarrow> P (step g s)\n 2. \\<And>s.\n       \\<lbrakk>inst' g s \\<and> P s; \\<not> cond g s\\<rbrakk>\n       \\<Longrightarrow> inst' g s \\<and> Q (fst s) (snd s)\n 3. wf ?r\n 4. \\<And>s.\n       \\<lbrakk>inst' g s \\<and> P s; cond g s\\<rbrakk>\n       \\<Longrightarrow> (step g s, s) \\<in> ?r", "proof-"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>inst' g s \\<and> P s; cond g s\\<rbrakk>\n       \\<Longrightarrow> P (step g s)\n 2. \\<And>s.\n       \\<lbrakk>inst' g s \\<and> P s; \\<not> cond g s\\<rbrakk>\n       \\<Longrightarrow> inst' g s \\<and> Q (fst s) (snd s)\n 3. wf ?r\n 4. \\<And>s.\n       \\<lbrakk>inst' g s \\<and> P s; cond g s\\<rbrakk>\n       \\<Longrightarrow> (step g s, s) \\<in> ?r", "show \"wf {(y,x). (inst' g x \\<and> cond g x) \\<and> y = step g x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(y, x). (inst' g x \\<and> cond g x) \\<and> y = step g x}", "apply (rule wf_if_measure[where f=\"\\<lambda>(u,p). card (dom p)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       inst' g x \\<and> cond g x \\<Longrightarrow>\n       (case step g x of (u, p) \\<Rightarrow> card (dom p))\n       < (case x of (u, p) \\<Rightarrow> card (dom p))", "apply (clarsimp simp: cond_def step_def split:prod.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>inst g x1 x2;\n        CFG_SSA_wf_base.redundant \\<alpha>n inEdges' defs (uses(g := x1))\n         (phis(g := x2)) g\\<rbrakk>\n       \\<Longrightarrow> card\n                          (dom (CFG_SSA_Transformed_notriv_base.phis'\n                                 \\<alpha>n defs (uses(g := x1))\n                                 (phis(g := x2)) chooseNext_all g))\n                         < card (dom x2)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>inst g x1 x2;\n        CFG_SSA_wf_base.redundant \\<alpha>n inEdges' defs (uses(g := x1))\n         (phis(g := x2)) g\\<rbrakk>\n       \\<Longrightarrow> card\n                          (dom (CFG_SSA_Transformed_notriv_base.phis'\n                                 \\<alpha>n defs (uses(g := x1))\n                                 (phis(g := x2)) chooseNext_all g))\n                         < card (dom x2)", "fix u p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>inst g x1 x2;\n        CFG_SSA_wf_base.redundant \\<alpha>n inEdges' defs (uses(g := x1))\n         (phis(g := x2)) g\\<rbrakk>\n       \\<Longrightarrow> card\n                          (dom (CFG_SSA_Transformed_notriv_base.phis'\n                                 \\<alpha>n defs (uses(g := x1))\n                                 (phis(g := x2)) chooseNext_all g))\n                         < card (dom x2)", "assume \"inst g u p\""], ["proof (state)\nthis:\n  inst g u p\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>inst g x1 x2;\n        CFG_SSA_wf_base.redundant \\<alpha>n inEdges' defs (uses(g := x1))\n         (phis(g := x2)) g\\<rbrakk>\n       \\<Longrightarrow> card\n                          (dom (CFG_SSA_Transformed_notriv_base.phis'\n                                 \\<alpha>n defs (uses(g := x1))\n                                 (phis(g := x2)) chooseNext_all g))\n                         < card (dom x2)", "then"], ["proof (chain)\npicking this:\n  inst g u p", "interpret i: CFG_SSA_Transformed_notriv \\<alpha>e \\<alpha>n invar inEdges' Entry oldDefs oldUses \"defs\" \"uses(g:=u)\" \"phis(g:=p)\""], ["proof (prove)\nusing this:\n  inst g u p\n\ngoal (1 subgoal):\n 1. inst g u p", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>inst g x1 x2;\n        CFG_SSA_wf_base.redundant \\<alpha>n inEdges' defs (uses(g := x1))\n         (phis(g := x2)) g\\<rbrakk>\n       \\<Longrightarrow> card\n                          (dom (CFG_SSA_Transformed_notriv_base.phis'\n                                 \\<alpha>n defs (uses(g := x1))\n                                 (phis(g := x2)) chooseNext_all g))\n                         < card (dom x2)", "assume \"i.redundant g\""], ["proof (state)\nthis:\n  i.redundant g\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>inst g x1 x2;\n        CFG_SSA_wf_base.redundant \\<alpha>n inEdges' defs (uses(g := x1))\n         (phis(g := x2)) g\\<rbrakk>\n       \\<Longrightarrow> card\n                          (dom (CFG_SSA_Transformed_notriv_base.phis'\n                                 \\<alpha>n defs (uses(g := x1))\n                                 (phis(g := x2)) chooseNext_all g))\n                         < card (dom x2)", "thus \"card (dom (i.phis' g)) < card (dom p)\""], ["proof (prove)\nusing this:\n  i.redundant g\n\ngoal (1 subgoal):\n 1. card (dom (i.phis' g)) < card (dom p)", "by (rule i.substAll_wf[of g, simplified])"], ["proof (state)\nthis:\n  card (dom (i.phis' g)) < card (dom p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wf {(y, x). (inst' g x \\<and> cond g x) \\<and> y = step g x}\n\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>inst' g s \\<and> P s; cond g s\\<rbrakk>\n       \\<Longrightarrow> P (step g s)\n 2. \\<And>s.\n       \\<lbrakk>inst' g s \\<and> P s; \\<not> cond g s\\<rbrakk>\n       \\<Longrightarrow> inst' g s \\<and> Q (fst s) (snd s)\n 3. \\<And>s.\n       \\<lbrakk>inst' g s \\<and> P s; cond g s\\<rbrakk>\n       \\<Longrightarrow> (step g s, s)\n                         \\<in> {(y, x).\n                                (inst' g x \\<and> cond g x) \\<and>\n                                y = step g x}", "qed (auto intro: assms(2,3))"], ["proof (state)\nthis:\n  inst' g (substAll g) \\<and> Q (uses'_all g) (phis'_all g)\n\ngoal (2 subgoals):\n 1. inst g (uses'_all g) (phis'_all g)\n 2. Q (uses'_all g) (phis'_all g)", "thus \"inst g (uses'_all g) (phis'_all g)\" \"Q (uses'_all g) (phis'_all g)\""], ["proof (prove)\nusing this:\n  inst' g (substAll g) \\<and> Q (uses'_all g) (phis'_all g)\n\ngoal (1 subgoal):\n 1. inst g (uses'_all g) (phis'_all g) &&& Q (uses'_all g) (phis'_all g)", "by (auto simp: uses'_all_def phis'_all_def)"], ["proof (state)\nthis:\n  inst g (uses'_all g) (phis'_all g)\n  Q (uses'_all g) (phis'_all g)\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale notriv: CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry oldDefs oldUses \"defs\" uses'_all phis'_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry oldDefs\n     oldUses defs uses'_all phis'_all var", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry oldDefs\n     oldUses defs uses'_all phis'_all var", "interpret ssa: CFG_SSA \\<alpha>e \\<alpha>n invar inEdges' Entry \"defs\" uses'_all phis'_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_SSA \\<alpha>e \\<alpha>n invar inEdges' Entry defs uses'_all\n     phis'_all", "proof"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> uses'_all g n = {}\n 2. \\<And>g n. finite (defs g n)\n 3. \\<And>v g n.\n       v \\<in> uses'_all g n \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 4. \\<And>g n. finite (uses'_all g n)\n 5. \\<And>g. invar g\n 6. \\<And>g. finite (dom (phis'_all g))\n 7. \\<And>g n v vs.\n       phis'_all g (n, v) = Some vs \\<Longrightarrow>\n       n \\<in> set (\\<alpha>n g)\n 8. \\<And>g n v args.\n       phis'_all g (n, v) = Some args \\<Longrightarrow>\n       length (old.predecessors g n) = length args\n 9. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> CFG_SSA_base.phiDefs phis'_all g n = {}\n 10. \\<And>n g m.\n        \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n         n \\<noteq> m\\<rbrakk>\n        \\<Longrightarrow> CFG_SSA_base.allDefs defs phis'_all g n \\<inter>\n                          CFG_SSA_base.allDefs defs phis'_all g m =\n                          {}", "fix g"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> uses'_all g n = {}\n 2. \\<And>g n. finite (defs g n)\n 3. \\<And>v g n.\n       v \\<in> uses'_all g n \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 4. \\<And>g n. finite (uses'_all g n)\n 5. \\<And>g. invar g\n 6. \\<And>g. finite (dom (phis'_all g))\n 7. \\<And>g n v vs.\n       phis'_all g (n, v) = Some vs \\<Longrightarrow>\n       n \\<in> set (\\<alpha>n g)\n 8. \\<And>g n v args.\n       phis'_all g (n, v) = Some args \\<Longrightarrow>\n       length (old.predecessors g n) = length args\n 9. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> CFG_SSA_base.phiDefs phis'_all g n = {}\n 10. \\<And>n g m.\n        \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n         n \\<noteq> m\\<rbrakk>\n        \\<Longrightarrow> CFG_SSA_base.allDefs defs phis'_all g n \\<inter>\n                          CFG_SSA_base.allDefs defs phis'_all g m =\n                          {}", "interpret i: CFG_SSA_Transformed_notriv \\<alpha>e \\<alpha>n invar inEdges' Entry oldDefs oldUses \"defs\" \"uses(g:=uses'_all g)\" \"phis(g:=phis'_all g)\" var"], ["proof (prove)\ngoal (1 subgoal):\n 1. inst g (uses'_all g) (phis'_all g)", "by (rule substAll, auto)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> uses'_all g n = {}\n 2. \\<And>g n. finite (defs g n)\n 3. \\<And>v g n.\n       v \\<in> uses'_all g n \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 4. \\<And>g n. finite (uses'_all g n)\n 5. \\<And>g. invar g\n 6. \\<And>g. finite (dom (phis'_all g))\n 7. \\<And>g n v vs.\n       phis'_all g (n, v) = Some vs \\<Longrightarrow>\n       n \\<in> set (\\<alpha>n g)\n 8. \\<And>g n v args.\n       phis'_all g (n, v) = Some args \\<Longrightarrow>\n       length (old.predecessors g n) = length args\n 9. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> CFG_SSA_base.phiDefs phis'_all g n = {}\n 10. \\<And>n g m.\n        \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n         n \\<noteq> m\\<rbrakk>\n        \\<Longrightarrow> CFG_SSA_base.allDefs defs phis'_all g n \\<inter>\n                          CFG_SSA_base.allDefs defs phis'_all g m =\n                          {}", "interpret uninst: CFG_SSA_Transformed_notriv_base \\<alpha>e \\<alpha>n invar inEdges' Entry oldDefs oldUses \"defs\" u p var chooseNext_all\n      for u and p"], ["proof (prove)\ngoal:\nNo subgoals!", "by unfold_locales"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> uninst.uses'_all uses phis g n = {}\n 2. \\<And>g n. finite (defs g n)\n 3. \\<And>v g n.\n       v \\<in> uninst.uses'_all uses phis g n \\<Longrightarrow>\n       n \\<in> set (\\<alpha>n g)\n 4. \\<And>g n. finite (uninst.uses'_all uses phis g n)\n 5. \\<And>g. invar g\n 6. \\<And>g. finite (dom (uninst.phis'_all uses phis g))\n 7. \\<And>g n v vs.\n       uninst.phis'_all uses phis g (n, v) = Some vs \\<Longrightarrow>\n       n \\<in> set (\\<alpha>n g)\n 8. \\<And>g n v args.\n       uninst.phis'_all uses phis g (n, v) = Some args \\<Longrightarrow>\n       length (old.predecessors g n) = length args\n 9. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> uninst.phiDefs (uninst.phis'_all uses phis) g n =\n       {}\n 10. \\<And>n g m.\n        \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n         n \\<noteq> m\\<rbrakk>\n        \\<Longrightarrow> uninst.allDefs (uninst.phis'_all uses phis) g\n                           n \\<inter>\n                          uninst.allDefs (uninst.phis'_all uses phis) g m =\n                          {}", "fix n v args m"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> uninst.uses'_all uses phis g n = {}\n 2. \\<And>g n. finite (defs g n)\n 3. \\<And>v g n.\n       v \\<in> uninst.uses'_all uses phis g n \\<Longrightarrow>\n       n \\<in> set (\\<alpha>n g)\n 4. \\<And>g n. finite (uninst.uses'_all uses phis g n)\n 5. \\<And>g. invar g\n 6. \\<And>g. finite (dom (uninst.phis'_all uses phis g))\n 7. \\<And>g n v vs.\n       uninst.phis'_all uses phis g (n, v) = Some vs \\<Longrightarrow>\n       n \\<in> set (\\<alpha>n g)\n 8. \\<And>g n v args.\n       uninst.phis'_all uses phis g (n, v) = Some args \\<Longrightarrow>\n       length (old.predecessors g n) = length args\n 9. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> uninst.phiDefs (uninst.phis'_all uses phis) g n =\n       {}\n 10. \\<And>n g m.\n        \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n         n \\<noteq> m\\<rbrakk>\n        \\<Longrightarrow> uninst.allDefs (uninst.phis'_all uses phis) g\n                           n \\<inter>\n                          uninst.allDefs (uninst.phis'_all uses phis) g m =\n                          {}", "show \"finite (defs g n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (defs g n)", "by (rule defs_finite)"], ["proof (state)\nthis:\n  finite (defs g n)\n\ngoal (9 subgoals):\n 1. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> uninst.uses'_all uses phis g n = {}\n 2. \\<And>v g n.\n       v \\<in> uninst.uses'_all uses phis g n \\<Longrightarrow>\n       n \\<in> set (\\<alpha>n g)\n 3. \\<And>g n. finite (uninst.uses'_all uses phis g n)\n 4. \\<And>g. invar g\n 5. \\<And>g. finite (dom (uninst.phis'_all uses phis g))\n 6. \\<And>g n v vs.\n       uninst.phis'_all uses phis g (n, v) = Some vs \\<Longrightarrow>\n       n \\<in> set (\\<alpha>n g)\n 7. \\<And>g n v args.\n       uninst.phis'_all uses phis g (n, v) = Some args \\<Longrightarrow>\n       length (old.predecessors g n) = length args\n 8. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> uninst.phiDefs (uninst.phis'_all uses phis) g n =\n       {}\n 9. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> uninst.allDefs (uninst.phis'_all uses phis) g\n                          n \\<inter>\n                         uninst.allDefs (uninst.phis'_all uses phis) g m =\n                         {}", "show \"v \\<in> uses'_all g n \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> uninst.uses'_all uses phis g n \\<Longrightarrow>\n    n \\<in> set (\\<alpha>n g)", "by (rule i.uses_in_\\<alpha>n[of _ g, simplified])"], ["proof (state)\nthis:\n  v \\<in> uninst.uses'_all uses phis g n \\<Longrightarrow>\n  n \\<in> set (\\<alpha>n g)\n\ngoal (8 subgoals):\n 1. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> uninst.uses'_all uses phis g n = {}\n 2. \\<And>g n. finite (uninst.uses'_all uses phis g n)\n 3. \\<And>g. invar g\n 4. \\<And>g. finite (dom (uninst.phis'_all uses phis g))\n 5. \\<And>g n v vs.\n       uninst.phis'_all uses phis g (n, v) = Some vs \\<Longrightarrow>\n       n \\<in> set (\\<alpha>n g)\n 6. \\<And>g n v args.\n       uninst.phis'_all uses phis g (n, v) = Some args \\<Longrightarrow>\n       length (old.predecessors g n) = length args\n 7. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> uninst.phiDefs (uninst.phis'_all uses phis) g n =\n       {}\n 8. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> uninst.allDefs (uninst.phis'_all uses phis) g\n                          n \\<inter>\n                         uninst.allDefs (uninst.phis'_all uses phis) g m =\n                         {}", "show \"finite (uses'_all g n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (uninst.uses'_all uses phis g n)", "by (rule i.uses_finite[of g, simplified])"], ["proof (state)\nthis:\n  finite (uninst.uses'_all uses phis g n)\n\ngoal (7 subgoals):\n 1. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> uninst.uses'_all uses phis g n = {}\n 2. \\<And>g. invar g\n 3. \\<And>g. finite (dom (uninst.phis'_all uses phis g))\n 4. \\<And>g n v vs.\n       uninst.phis'_all uses phis g (n, v) = Some vs \\<Longrightarrow>\n       n \\<in> set (\\<alpha>n g)\n 5. \\<And>g n v args.\n       uninst.phis'_all uses phis g (n, v) = Some args \\<Longrightarrow>\n       length (old.predecessors g n) = length args\n 6. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> uninst.phiDefs (uninst.phis'_all uses phis) g n =\n       {}\n 7. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> uninst.allDefs (uninst.phis'_all uses phis) g\n                          n \\<inter>\n                         uninst.allDefs (uninst.phis'_all uses phis) g m =\n                         {}", "show \"invar g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar g", "by (rule invar)"], ["proof (state)\nthis:\n  invar g\n\ngoal (6 subgoals):\n 1. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> uninst.uses'_all uses phis g n = {}\n 2. \\<And>g. finite (dom (uninst.phis'_all uses phis g))\n 3. \\<And>g n v vs.\n       uninst.phis'_all uses phis g (n, v) = Some vs \\<Longrightarrow>\n       n \\<in> set (\\<alpha>n g)\n 4. \\<And>g n v args.\n       uninst.phis'_all uses phis g (n, v) = Some args \\<Longrightarrow>\n       length (old.predecessors g n) = length args\n 5. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> uninst.phiDefs (uninst.phis'_all uses phis) g n =\n       {}\n 6. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> uninst.allDefs (uninst.phis'_all uses phis) g\n                          n \\<inter>\n                         uninst.allDefs (uninst.phis'_all uses phis) g m =\n                         {}", "show \"finite (dom (phis'_all g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom (uninst.phis'_all uses phis g))", "by (rule i.phis_finite[of g, simplified])"], ["proof (state)\nthis:\n  finite (dom (uninst.phis'_all uses phis g))\n\ngoal (5 subgoals):\n 1. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> uninst.uses'_all uses phis g n = {}\n 2. \\<And>g n v vs.\n       uninst.phis'_all uses phis g (n, v) = Some vs \\<Longrightarrow>\n       n \\<in> set (\\<alpha>n g)\n 3. \\<And>g n v args.\n       uninst.phis'_all uses phis g (n, v) = Some args \\<Longrightarrow>\n       length (old.predecessors g n) = length args\n 4. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> uninst.phiDefs (uninst.phis'_all uses phis) g n =\n       {}\n 5. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> uninst.allDefs (uninst.phis'_all uses phis) g\n                          n \\<inter>\n                         uninst.allDefs (uninst.phis'_all uses phis) g m =\n                         {}", "show \"phis'_all g (n, v) = Some args \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uninst.phis'_all uses phis g (n, v) = Some args \\<Longrightarrow>\n    n \\<in> set (\\<alpha>n g)", "using i.phis_in_\\<alpha>n[of g]"], ["proof (prove)\nusing this:\n  (phis(g := uninst.phis'_all uses phis g)) g (?n, ?v) =\n  Some ?vs \\<Longrightarrow>\n  ?n \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. uninst.phis'_all uses phis g (n, v) = Some args \\<Longrightarrow>\n    n \\<in> set (\\<alpha>n g)", "by simp"], ["proof (state)\nthis:\n  uninst.phis'_all uses phis g (n, v) = Some args \\<Longrightarrow>\n  n \\<in> set (\\<alpha>n g)\n\ngoal (4 subgoals):\n 1. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> uninst.uses'_all uses phis g n = {}\n 2. \\<And>g n v args.\n       uninst.phis'_all uses phis g (n, v) = Some args \\<Longrightarrow>\n       length (old.predecessors g n) = length args\n 3. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> uninst.phiDefs (uninst.phis'_all uses phis) g n =\n       {}\n 4. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> uninst.allDefs (uninst.phis'_all uses phis) g\n                          n \\<inter>\n                         uninst.allDefs (uninst.phis'_all uses phis) g m =\n                         {}", "show \"phis'_all g (n, v) = Some args \\<Longrightarrow> length (old.predecessors g n) = length args\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uninst.phis'_all uses phis g (n, v) = Some args \\<Longrightarrow>\n    length (old.predecessors g n) = length args", "using i.phis_wf[of g]"], ["proof (prove)\nusing this:\n  (phis(g := uninst.phis'_all uses phis g)) g (?n, ?v) =\n  Some ?args \\<Longrightarrow>\n  length (old.predecessors g ?n) = length ?args\n\ngoal (1 subgoal):\n 1. uninst.phis'_all uses phis g (n, v) = Some args \\<Longrightarrow>\n    length (old.predecessors g n) = length args", "by simp"], ["proof (state)\nthis:\n  uninst.phis'_all uses phis g (n, v) = Some args \\<Longrightarrow>\n  length (old.predecessors g n) = length args\n\ngoal (3 subgoals):\n 1. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> uninst.uses'_all uses phis g n = {}\n 2. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> uninst.phiDefs (uninst.phis'_all uses phis) g n =\n       {}\n 3. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> uninst.allDefs (uninst.phis'_all uses phis) g\n                          n \\<inter>\n                         uninst.allDefs (uninst.phis'_all uses phis) g m =\n                         {}", "show \"n \\<in> set (\\<alpha>n g) \\<Longrightarrow> defs g n \\<inter> uninst.phiDefs phis'_all g n = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n    defs g n \\<inter> uninst.phiDefs (uninst.phis'_all uses phis) g n = {}", "using i.simpleDefs_phiDefs_disjoint[of n g]"], ["proof (prove)\nusing this:\n  n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n  defs g n \\<inter> i.phiDefs g n = {}\n\ngoal (1 subgoal):\n 1. n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n    defs g n \\<inter> uninst.phiDefs (uninst.phis'_all uses phis) g n = {}", "by (simp add: uninst.CFG_SSA_defs)"], ["proof (state)\nthis:\n  n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n  defs g n \\<inter> uninst.phiDefs (uninst.phis'_all uses phis) g n = {}\n\ngoal (2 subgoals):\n 1. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> uninst.uses'_all uses phis g n = {}\n 2. \\<And>n g m.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n        n \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> uninst.allDefs (uninst.phis'_all uses phis) g\n                          n \\<inter>\n                         uninst.allDefs (uninst.phis'_all uses phis) g m =\n                         {}", "show \"n \\<in> set (\\<alpha>n g) \\<Longrightarrow> m \\<in> set (\\<alpha>n g) \\<Longrightarrow> n \\<noteq> m \\<Longrightarrow> uninst.allDefs phis'_all g n \\<inter> uninst.allDefs phis'_all g m = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n     n \\<noteq> m\\<rbrakk>\n    \\<Longrightarrow> uninst.allDefs (uninst.phis'_all uses phis) g\n                       n \\<inter>\n                      uninst.allDefs (uninst.phis'_all uses phis) g m =\n                      {}", "using i.allDefs_disjoint[of n g]"], ["proof (prove)\nusing this:\n  \\<lbrakk>n \\<in> set (\\<alpha>n g); ?m \\<in> set (\\<alpha>n g);\n   n \\<noteq> ?m\\<rbrakk>\n  \\<Longrightarrow> i.allDefs g n \\<inter> i.allDefs g ?m = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n     n \\<noteq> m\\<rbrakk>\n    \\<Longrightarrow> uninst.allDefs (uninst.phis'_all uses phis) g\n                       n \\<inter>\n                      uninst.allDefs (uninst.phis'_all uses phis) g m =\n                      {}", "by (simp add: uninst.CFG_SSA_defs)"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<in> set (\\<alpha>n g); m \\<in> set (\\<alpha>n g);\n   n \\<noteq> m\\<rbrakk>\n  \\<Longrightarrow> uninst.allDefs (uninst.phis'_all uses phis) g n \\<inter>\n                    uninst.allDefs (uninst.phis'_all uses phis) g m =\n                    {}\n\ngoal (1 subgoal):\n 1. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       defs g n \\<inter> uninst.uses'_all uses phis g n = {}", "show \"n \\<in> set (\\<alpha>n g) \\<Longrightarrow> defs g n \\<inter> uses'_all g n = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n    defs g n \\<inter> uninst.uses'_all uses phis g n = {}", "using i.defs_uses_disjoint[of n g]"], ["proof (prove)\nusing this:\n  n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n  defs g n \\<inter> (uses(g := uninst.uses'_all uses phis g)) g n = {}\n\ngoal (1 subgoal):\n 1. n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n    defs g n \\<inter> uninst.uses'_all uses phis g n = {}", "by simp"], ["proof (state)\nthis:\n  n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n  defs g n \\<inter> uninst.uses'_all uses phis g n = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry oldDefs\n     oldUses defs uses'_all phis'_all var", "interpret uninst: CFG_SSA_Transformed_notriv_base \\<alpha>e \\<alpha>n invar inEdges' Entry oldDefs oldUses \"defs\" u p var chooseNext_all\n    for u and p"], ["proof (prove)\ngoal:\nNo subgoals!", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry oldDefs\n     oldUses defs (uninst.uses'_all uses phis) (uninst.phis'_all uses phis)\n     var", "show \"CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry oldDefs oldUses defs uses'_all phis'_all var\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry oldDefs\n     oldUses defs (uninst.uses'_all uses phis) (uninst.phis'_all uses phis)\n     var", "proof"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>v g n.\n       \\<lbrakk>v \\<in> ssa.allUses g n; n \\<in> set (\\<alpha>n g)\\<rbrakk>\n       \\<Longrightarrow> ssa.defAss g n v\n 2. \\<And>g v. uninst.phis'_all uses phis g (Entry g, v) = None\n 3. \\<And>g n. oldDefs g n = var g ` defs g n\n 4. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       oldUses g n = var g ` uninst.uses'_all uses phis g n\n 5. \\<And>g n ns m v x v'.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m; n \\<notin> set (tl ns);\n        v \\<in> ssa.allDefs g n; v \\<in> ssa.allUses g m;\n        x \\<in> set (tl ns); v' \\<in> ssa.allDefs g x\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v\n 6. \\<And>g n v vs v'.\n       \\<lbrakk>uninst.phis'_all uses phis g (n, v) = Some vs;\n        v' \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> var g v' = var g v\n 7. \\<And>n g v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> ssa.allDefs g n;\n        v' \\<in> ssa.allDefs g n; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v", "fix g n v ns m x v' vs"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>v g n.\n       \\<lbrakk>v \\<in> ssa.allUses g n; n \\<in> set (\\<alpha>n g)\\<rbrakk>\n       \\<Longrightarrow> ssa.defAss g n v\n 2. \\<And>g v. uninst.phis'_all uses phis g (Entry g, v) = None\n 3. \\<And>g n. oldDefs g n = var g ` defs g n\n 4. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       oldUses g n = var g ` uninst.uses'_all uses phis g n\n 5. \\<And>g n ns m v x v'.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m; n \\<notin> set (tl ns);\n        v \\<in> ssa.allDefs g n; v \\<in> ssa.allUses g m;\n        x \\<in> set (tl ns); v' \\<in> ssa.allDefs g x\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v\n 6. \\<And>g n v vs v'.\n       \\<lbrakk>uninst.phis'_all uses phis g (n, v) = Some vs;\n        v' \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> var g v' = var g v\n 7. \\<And>n g v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> ssa.allDefs g n;\n        v' \\<in> ssa.allDefs g n; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v", "interpret i: CFG_SSA_Transformed_notriv \\<alpha>e \\<alpha>n invar inEdges' Entry oldDefs oldUses \"defs\" \"uses(g:=uses'_all g)\" \"phis(g:=phis'_all g)\" var"], ["proof (prove)\ngoal (1 subgoal):\n 1. uninst.inst uses phis g (uninst.uses'_all uses phis g)\n     (uninst.phis'_all uses phis g)", "by (rule substAll, auto)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>v g n.\n       \\<lbrakk>v \\<in> ssa.allUses g n; n \\<in> set (\\<alpha>n g)\\<rbrakk>\n       \\<Longrightarrow> ssa.defAss g n v\n 2. \\<And>g v. uninst.phis'_all uses phis g (Entry g, v) = None\n 3. \\<And>g n. oldDefs g n = var g ` defs g n\n 4. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       oldUses g n = var g ` uninst.uses'_all uses phis g n\n 5. \\<And>g n ns m v x v'.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m; n \\<notin> set (tl ns);\n        v \\<in> ssa.allDefs g n; v \\<in> ssa.allUses g m;\n        x \\<in> set (tl ns); v' \\<in> ssa.allDefs g x\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v\n 6. \\<And>g n v vs v'.\n       \\<lbrakk>uninst.phis'_all uses phis g (n, v) = Some vs;\n        v' \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> var g v' = var g v\n 7. \\<And>n g v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> ssa.allDefs g n;\n        v' \\<in> ssa.allDefs g n; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v", "show \"oldDefs g n = var g ` defs g n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oldDefs g n = var g ` defs g n", "by (rule oldDefs_def)"], ["proof (state)\nthis:\n  oldDefs g n = var g ` defs g n\n\ngoal (6 subgoals):\n 1. \\<And>v g n.\n       \\<lbrakk>v \\<in> ssa.allUses g n; n \\<in> set (\\<alpha>n g)\\<rbrakk>\n       \\<Longrightarrow> ssa.defAss g n v\n 2. \\<And>g v. uninst.phis'_all uses phis g (Entry g, v) = None\n 3. \\<And>n g.\n       n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       oldUses g n = var g ` uninst.uses'_all uses phis g n\n 4. \\<And>g n ns m v x v'.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m; n \\<notin> set (tl ns);\n        v \\<in> ssa.allDefs g n; v \\<in> ssa.allUses g m;\n        x \\<in> set (tl ns); v' \\<in> ssa.allDefs g x\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v\n 5. \\<And>g n v vs v'.\n       \\<lbrakk>uninst.phis'_all uses phis g (n, v) = Some vs;\n        v' \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> var g v' = var g v\n 6. \\<And>n g v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> ssa.allDefs g n;\n        v' \\<in> ssa.allDefs g n; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v", "show \"n \\<in> set (\\<alpha>n g) \\<Longrightarrow> oldUses g n = var g ` uses'_all g n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n    oldUses g n = var g ` uninst.uses'_all uses phis g n", "using i.oldUses_def[of n g]"], ["proof (prove)\nusing this:\n  n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n  oldUses g n = var g ` (uses(g := uninst.uses'_all uses phis g)) g n\n\ngoal (1 subgoal):\n 1. n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n    oldUses g n = var g ` uninst.uses'_all uses phis g n", "by simp"], ["proof (state)\nthis:\n  n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n  oldUses g n = var g ` uninst.uses'_all uses phis g n\n\ngoal (5 subgoals):\n 1. \\<And>v g n.\n       \\<lbrakk>v \\<in> ssa.allUses g n; n \\<in> set (\\<alpha>n g)\\<rbrakk>\n       \\<Longrightarrow> ssa.defAss g n v\n 2. \\<And>g v. uninst.phis'_all uses phis g (Entry g, v) = None\n 3. \\<And>g n ns m v x v'.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m; n \\<notin> set (tl ns);\n        v \\<in> ssa.allDefs g n; v \\<in> ssa.allUses g m;\n        x \\<in> set (tl ns); v' \\<in> ssa.allDefs g x\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v\n 4. \\<And>g n v vs v'.\n       \\<lbrakk>uninst.phis'_all uses phis g (n, v) = Some vs;\n        v' \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> var g v' = var g v\n 5. \\<And>n g v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> ssa.allDefs g n;\n        v' \\<in> ssa.allDefs g n; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v", "show \"v \\<in> ssa.allUses g n \\<Longrightarrow> n \\<in> set (\\<alpha>n g) \\<Longrightarrow> ssa.defAss g n v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> ssa.allUses g n; n \\<in> set (\\<alpha>n g)\\<rbrakk>\n    \\<Longrightarrow> ssa.defAss g n v", "using i.allUses_def_ass[of v g n]"], ["proof (prove)\nusing this:\n  \\<lbrakk>v \\<in> uninst.allUses (uses(g := uninst.uses'_all uses phis g))\n                    (phis(g := uninst.phis'_all uses phis g)) g n;\n   n \\<in> set (\\<alpha>n g)\\<rbrakk>\n  \\<Longrightarrow> uninst.defAss (phis(g := uninst.phis'_all uses phis g))\n                     g n v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> ssa.allUses g n; n \\<in> set (\\<alpha>n g)\\<rbrakk>\n    \\<Longrightarrow> ssa.defAss g n v", "by (simp add: uninst.CFG_SSA_defs)"], ["proof (state)\nthis:\n  \\<lbrakk>v \\<in> ssa.allUses g n; n \\<in> set (\\<alpha>n g)\\<rbrakk>\n  \\<Longrightarrow> ssa.defAss g n v\n\ngoal (4 subgoals):\n 1. \\<And>g v. uninst.phis'_all uses phis g (Entry g, v) = None\n 2. \\<And>g n ns m v x v'.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m; n \\<notin> set (tl ns);\n        v \\<in> ssa.allDefs g n; v \\<in> ssa.allUses g m;\n        x \\<in> set (tl ns); v' \\<in> ssa.allDefs g x\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v\n 3. \\<And>g n v vs v'.\n       \\<lbrakk>uninst.phis'_all uses phis g (n, v) = Some vs;\n        v' \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> var g v' = var g v\n 4. \\<And>n g v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> ssa.allDefs g n;\n        v' \\<in> ssa.allDefs g n; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v", "show \"old.path2 g n ns m \\<Longrightarrow> n \\<notin> set (tl ns) \\<Longrightarrow> v \\<in> ssa.allDefs g n \\<Longrightarrow> v \\<in> ssa.allUses g m \\<Longrightarrow> x \\<in> set (tl ns) \\<Longrightarrow> v' \\<in> ssa.allDefs g x \\<Longrightarrow> var g v' \\<noteq> var g v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m; n \\<notin> set (tl ns);\n     v \\<in> ssa.allDefs g n; v \\<in> ssa.allUses g m; x \\<in> set (tl ns);\n     v' \\<in> ssa.allDefs g x\\<rbrakk>\n    \\<Longrightarrow> var g v' \\<noteq> var g v", "using i.conventional[of g n ns m v x v']"], ["proof (prove)\nusing this:\n  \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m; n \\<notin> set (tl ns);\n   v \\<in> uninst.allDefs (phis(g := uninst.phis'_all uses phis g)) g n;\n   v \\<in> uninst.allUses (uses(g := uninst.uses'_all uses phis g))\n            (phis(g := uninst.phis'_all uses phis g)) g m;\n   x \\<in> set (tl ns);\n   v' \\<in> uninst.allDefs (phis(g := uninst.phis'_all uses phis g)) g\n             x\\<rbrakk>\n  \\<Longrightarrow> var g v' \\<noteq> var g v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m; n \\<notin> set (tl ns);\n     v \\<in> ssa.allDefs g n; v \\<in> ssa.allUses g m; x \\<in> set (tl ns);\n     v' \\<in> ssa.allDefs g x\\<rbrakk>\n    \\<Longrightarrow> var g v' \\<noteq> var g v", "by (simp add: uninst.CFG_SSA_defs)"], ["proof (state)\nthis:\n  \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m; n \\<notin> set (tl ns);\n   v \\<in> ssa.allDefs g n; v \\<in> ssa.allUses g m; x \\<in> set (tl ns);\n   v' \\<in> ssa.allDefs g x\\<rbrakk>\n  \\<Longrightarrow> var g v' \\<noteq> var g v\n\ngoal (3 subgoals):\n 1. \\<And>g v. uninst.phis'_all uses phis g (Entry g, v) = None\n 2. \\<And>g n v vs v'.\n       \\<lbrakk>uninst.phis'_all uses phis g (n, v) = Some vs;\n        v' \\<in> set vs\\<rbrakk>\n       \\<Longrightarrow> var g v' = var g v\n 3. \\<And>n g v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> ssa.allDefs g n;\n        v' \\<in> ssa.allDefs g n; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v", "show \"phis'_all g (n, v) = Some vs \\<Longrightarrow> v' \\<in> set vs \\<Longrightarrow> var g v' = var g v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>uninst.phis'_all uses phis g (n, v) = Some vs;\n     v' \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> var g v' = var g v", "using i.phis_same_var[of g n v]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(phis(g := uninst.phis'_all uses phis g)) g (n, v) = Some ?vs;\n   ?v' \\<in> set ?vs\\<rbrakk>\n  \\<Longrightarrow> var g ?v' = var g v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>uninst.phis'_all uses phis g (n, v) = Some vs;\n     v' \\<in> set vs\\<rbrakk>\n    \\<Longrightarrow> var g v' = var g v", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>uninst.phis'_all uses phis g (n, v) = Some vs;\n   v' \\<in> set vs\\<rbrakk>\n  \\<Longrightarrow> var g v' = var g v\n\ngoal (2 subgoals):\n 1. \\<And>g v. uninst.phis'_all uses phis g (Entry g, v) = None\n 2. \\<And>n g v v'.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> ssa.allDefs g n;\n        v' \\<in> ssa.allDefs g n; v \\<noteq> v'\\<rbrakk>\n       \\<Longrightarrow> var g v' \\<noteq> var g v", "show \"n \\<in> set (\\<alpha>n g) \\<Longrightarrow> v \\<in> ssa.allDefs g n \\<Longrightarrow> v' \\<in> ssa.allDefs g n \\<Longrightarrow> v \\<noteq> v' \\<Longrightarrow> var g v' \\<noteq> var g v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> ssa.allDefs g n;\n     v' \\<in> ssa.allDefs g n; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> var g v' \\<noteq> var g v", "using i.allDefs_var_disjoint"], ["proof (prove)\nusing this:\n  \\<lbrakk>?n \\<in> set (\\<alpha>n ?g);\n   ?v \\<in> uninst.allDefs (phis(g := uninst.phis'_all uses phis g)) ?g ?n;\n   ?v' \\<in> uninst.allDefs (phis(g := uninst.phis'_all uses phis g)) ?g ?n;\n   ?v \\<noteq> ?v'\\<rbrakk>\n  \\<Longrightarrow> var ?g ?v' \\<noteq> var ?g ?v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> ssa.allDefs g n;\n     v' \\<in> ssa.allDefs g n; v \\<noteq> v'\\<rbrakk>\n    \\<Longrightarrow> var g v' \\<noteq> var g v", "by (simp add: uninst.CFG_SSA_defs)"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> ssa.allDefs g n;\n   v' \\<in> ssa.allDefs g n; v \\<noteq> v'\\<rbrakk>\n  \\<Longrightarrow> var g v' \\<noteq> var g v\n\ngoal (1 subgoal):\n 1. \\<And>g v. uninst.phis'_all uses phis g (Entry g, v) = None", "show \"phis'_all g (Entry g, v) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uninst.phis'_all uses phis g (Entry g, v) = None", "using i.Entry_no_phis[of g v]"], ["proof (prove)\nusing this:\n  (phis(g := uninst.phis'_all uses phis g)) g (Entry g, v) = None\n\ngoal (1 subgoal):\n 1. uninst.phis'_all uses phis g (Entry g, v) = None", "by simp"], ["proof (state)\nthis:\n  uninst.phis'_all uses phis g (Entry g, v) = None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry oldDefs\n   oldUses defs (uninst.uses'_all uses phis) (uninst.phis'_all uses phis)\n   var\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem not_redundant: \"\\<not>notriv.redundant g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> notriv.redundant g", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> notriv.redundant g", "interpret uninst: CFG_SSA_Transformed_notriv_base \\<alpha>e \\<alpha>n invar inEdges' Entry oldDefs oldUses \"defs\" u p var chooseNext_all\n    for u and p"], ["proof (prove)\ngoal:\nNo subgoals!", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> notriv.redundant g", "have 1: \"\\<And>u p. uninst.redundant (uses(g:=u g)) (phis(g:=p g)) g \\<longleftrightarrow> uninst.redundant u p g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u p.\n       uninst.redundant (uses(g := u g)) (phis(g := p g)) g =\n       uninst.redundant u p g", "by (simp add: uninst.CFG_SSA_wf_defs)"], ["proof (state)\nthis:\n  uninst.redundant (uses(g := ?u1 g)) (phis(g := ?p1 g)) g =\n  uninst.redundant ?u1 ?p1 g\n\ngoal (1 subgoal):\n 1. \\<not> notriv.redundant g", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> notriv.redundant g", "by (rule substAll(2)[where Q=\"\\<lambda>u p. \\<not>uninst.redundant (uses(g:=u)) (phis(g:=p)) g\" and P=\"\\<lambda>_. True\" and g=g, simplified cond_def substAll_def 1], auto)"], ["proof (state)\nthis:\n  \\<not> notriv.redundant g\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary minimal: \"old.reducible g \\<Longrightarrow> notriv.cytronMinimal g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. old.reducible g \\<Longrightarrow> notriv.cytronMinimal g", "by (erule notriv.reducible_nonredundant_imp_minimal, rule not_redundant)"], ["", "theorem pruned_invariant:\n    assumes \"pruned g\"\n    shows \"notriv.pruned g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. notriv.pruned g", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. notriv.pruned g", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. notriv.pruned g", "fix u p"], ["proof (state)\ngoal (1 subgoal):\n 1. notriv.pruned g", "assume \"inst g u p\""], ["proof (state)\nthis:\n  inst g u p\n\ngoal (1 subgoal):\n 1. notriv.pruned g", "then"], ["proof (chain)\npicking this:\n  inst g u p", "interpret i: CFG_SSA_Transformed_notriv \\<alpha>e \\<alpha>n invar inEdges' Entry oldDefs oldUses \"defs\" \"uses(g:=u)\" \"phis(g:=p)\" var chooseNext_all"], ["proof (prove)\nusing this:\n  inst g u p\n\ngoal (1 subgoal):\n 1. inst g u p", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. notriv.pruned g", "assume \"i.redundant g\""], ["proof (state)\nthis:\n  i.redundant g\n\ngoal (1 subgoal):\n 1. notriv.pruned g", "then"], ["proof (chain)\npicking this:\n  i.redundant g", "interpret i: CFG_SSA_step \\<alpha>e \\<alpha>n invar inEdges' Entry oldDefs oldUses \"defs\" \"uses(g:=u)\" \"phis(g:=p)\" var chooseNext_all g"], ["proof (prove)\nusing this:\n  i.redundant g\n\ngoal (1 subgoal):\n 1. CFG_SSA_step \\<alpha>e \\<alpha>n invar inEdges' Entry oldDefs oldUses\n     defs (uses(g := u)) (phis(g := p)) var chooseNext_all g", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. notriv.pruned g", "interpret uninst: CFG_SSA_Transformed_notriv_base \\<alpha>e \\<alpha>n invar inEdges' Entry oldDefs oldUses \"defs\" u p var chooseNext_all\n      for u and p"], ["proof (prove)\ngoal:\nNo subgoals!", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. notriv.pruned g", "assume \"i.pruned g\""], ["proof (state)\nthis:\n  i.pruned g\n\ngoal (1 subgoal):\n 1. notriv.pruned g", "hence \"uninst.pruned (uses(g:=i.uses' g)) (phis(g:=i.phis' g)) g\""], ["proof (prove)\nusing this:\n  i.pruned g\n\ngoal (1 subgoal):\n 1. uninst.pruned\n     (uses(g := uninst.uses' (uses(g := u__)) (phis(g := p__)) g))\n     (phis(g := uninst.phis' (uses(g := u__)) (phis(g := p__)) g)) g", "by (rule i.pruned_inv[simplified])"], ["proof (state)\nthis:\n  uninst.pruned\n   (uses(g := uninst.uses' (uses(g := u__)) (phis(g := p__)) g))\n   (phis(g := uninst.phis' (uses(g := u__)) (phis(g := p__)) g)) g\n\ngoal (1 subgoal):\n 1. notriv.pruned g", "}"], ["proof (state)\nthis:\n  \\<lbrakk>inst g ?u3 ?p3;\n   CFG_SSA_wf_base.redundant \\<alpha>n inEdges' defs (uses(g := ?u3))\n    (phis(g := ?p3)) g;\n   CFG_SSA_wf_base.pruned \\<alpha>n defs (uses(g := ?u3)) (phis(g := ?p3))\n    g\\<rbrakk>\n  \\<Longrightarrow> CFG_SSA_wf_base.pruned \\<alpha>n defs\n                     (uses\n                      (g := CFG_SSA_Transformed_notriv_base.uses' \\<alpha>n\n                             defs (uses(g := ?u3)) (phis(g := ?p3))\n                             chooseNext_all g))\n                     (phis\n                      (g := CFG_SSA_Transformed_notriv_base.phis' \\<alpha>n\n                             defs (uses(g := ?u3)) (phis(g := ?p3))\n                             chooseNext_all g))\n                     g\n\ngoal (1 subgoal):\n 1. notriv.pruned g", "note 1 = this"], ["proof (state)\nthis:\n  \\<lbrakk>inst g ?u3 ?p3;\n   CFG_SSA_wf_base.redundant \\<alpha>n inEdges' defs (uses(g := ?u3))\n    (phis(g := ?p3)) g;\n   CFG_SSA_wf_base.pruned \\<alpha>n defs (uses(g := ?u3)) (phis(g := ?p3))\n    g\\<rbrakk>\n  \\<Longrightarrow> CFG_SSA_wf_base.pruned \\<alpha>n defs\n                     (uses\n                      (g := CFG_SSA_Transformed_notriv_base.uses' \\<alpha>n\n                             defs (uses(g := ?u3)) (phis(g := ?p3))\n                             chooseNext_all g))\n                     (phis\n                      (g := CFG_SSA_Transformed_notriv_base.phis' \\<alpha>n\n                             defs (uses(g := ?u3)) (phis(g := ?p3))\n                             chooseNext_all g))\n                     g\n\ngoal (1 subgoal):\n 1. notriv.pruned g", "interpret uninst: CFG_SSA_Transformed_notriv_base \\<alpha>e \\<alpha>n invar inEdges' Entry oldDefs oldUses \"defs\" u p var chooseNext_all\n    for u and p"], ["proof (prove)\ngoal:\nNo subgoals!", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. notriv.pruned g", "have 2: \"\\<And>u u' p p' g. uninst.pruned (u'(g:=u g)) (p'(g:=p g)) g \\<longleftrightarrow> uninst.pruned u p g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u u' p p' g.\n       uninst.pruned (u'(g := u g)) (p'(g := p g)) g = uninst.pruned u p g", "by (clarsimp simp: uninst.CFG_SSA_wf_defs)"], ["proof (state)\nthis:\n  uninst.pruned (?u'1(?g1 := ?u1 ?g1)) (?p'1(?g1 := ?p1 ?g1)) ?g1 =\n  uninst.pruned ?u1 ?p1 ?g1\n\ngoal (1 subgoal):\n 1. notriv.pruned g", "from 1 assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>uninst.inst uses phis g ?u3 ?p3;\n   uninst.redundant (uses(g := ?u3)) (phis(g := ?p3)) g;\n   uninst.pruned (uses(g := ?u3)) (phis(g := ?p3)) g\\<rbrakk>\n  \\<Longrightarrow> uninst.pruned\n                     (uses\n                      (g := uninst.uses' (uses(g := ?u3)) (phis(g := ?p3))\n                             g))\n                     (phis\n                      (g := uninst.phis' (uses(g := ?u3)) (phis(g := ?p3))\n                             g))\n                     g\n  pruned g", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>uninst.inst uses phis g ?u3 ?p3;\n   uninst.redundant (uses(g := ?u3)) (phis(g := ?p3)) g;\n   uninst.pruned (uses(g := ?u3)) (phis(g := ?p3)) g\\<rbrakk>\n  \\<Longrightarrow> uninst.pruned\n                     (uses\n                      (g := uninst.uses' (uses(g := ?u3)) (phis(g := ?p3))\n                             g))\n                     (phis\n                      (g := uninst.phis' (uses(g := ?u3)) (phis(g := ?p3))\n                             g))\n                     g\n  pruned g\n\ngoal (1 subgoal):\n 1. notriv.pruned g", "by - (rule substAll(2)[where P=\"\\<lambda>(u,p). uninst.pruned (uses(g:=u)) (phis(g:=p)) g\" and Q=\"\\<lambda>u p. uninst.pruned (uses(g:=u)) (phis(g:=p)) g\" and g=g, simplified 2],\n          auto simp: cond_def step_def)"], ["proof (state)\nthis:\n  notriv.pruned g\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}