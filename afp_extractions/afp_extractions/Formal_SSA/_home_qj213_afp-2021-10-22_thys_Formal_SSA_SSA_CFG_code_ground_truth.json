{"file_name": "/home/qj213/afp-2021-10-22/thys/Formal_SSA/SSA_CFG_code.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Formal_SSA", "problem_names": ["lemma Union_of_alt_def: \"Union_of f A = (\\<Union>x \\<in> A. f x)\"", "lemma addN_transfer [transfer_rule]:\n    \"rel_fun (=) (rel_fun (=) (rel_fun (pcr_mapping (=) (=)) (pcr_mapping (=) (=)))) addN' addN\"", "lemmas useNodes_of_code = useNodes_of_def [unfolded addN_def [abs_def]]", "lemma lookup_useNodes_of':\n    assumes [simp]: \"\\<And>n. finite (uses g n)\"\n    shows \"Mapping.lookup (useNodes_of g) v =\n    (if (\\<exists>n \\<in> set (\\<alpha>n g). v \\<in> uses g n) then Some {n \\<in> set (\\<alpha>n g). v \\<in> uses g n} else None)\"", "lemma useNodes_of': \"useNodes_of' = useNodes_of\"", "lemma lookup_useNodes_of: \"Mapping.lookup (useNodes_of g) v =\n    (if (\\<exists>n \\<in> set (\\<alpha>n g). v \\<in> uses g n) then Some {n \\<in> set (\\<alpha>n g). v \\<in> uses g n} else None)\"", "lemma keys_phidefNodes:\n    assumes \"finite (dom (phis g))\"\n    shows \"Mapping.keys (phidefNodes g) = snd ` dom (phis g)\"", "lemma lookup_phiNodes_of:\n  assumes [simp]: \"finite (dom (phis g))\"\n  shows \"Mapping.lookup (phiNodes_of g) v =\n    (if (\\<exists>n \\<in> dom (phis g). v \\<in> set (the (phis g n))) then Some {n \\<in> dom (phis g). v \\<in> set (the (phis g n))} else None)\"", "lemmas phiNodes_of_code = phiNodes_of_def [unfolded phis_addN_def [abs_def]]", "lemma phis_transfer [transfer_rule]:\n  includes lifting_syntax\n  shows \"((=) ===> pcr_mapping (=) (=)) phis (\\<lambda>g. Mapping.Mapping (phis g))\"", "lemma lookup_cache[simp]: \"n \\<in> set (\\<alpha>n g) \\<Longrightarrow> Mapping.lookup (cache g f) n = Some (f n)\"", "lemma lookup_cacheD [dest]: \"Mapping.lookup (cache g f) x = Some y \\<Longrightarrow> y = f x\"", "lemma lookup_cache_usesD: \"Mapping.lookup (cache g (uses g)) n = Some vs \\<Longrightarrow> vs = uses g n\"", "lemma usesOf_cache[abs_def, simp]: \"usesOf (cache g (uses g)) n = uses g n\"", "lemma phiDefs_code [code]:\n  \"phiDefs g n = snd ` Set.filter (\\<lambda>(n',v). n' = n) (Mapping.keys (phis g))\"", "lemmas phiUses_code [code] = phiUses_def [folded Union_of_alt_def]", "lemmas allVars_code [code] = allVars_def [folded Union_of_alt_def]", "lemma the_trivial_Nil [simp]: \"the_trivial x [] = None\"", "lemma the_trivialI:\n  assumes \"set vs \\<subseteq> {v, v'}\"\n    and \"v' \\<noteq> v\"\n  shows \"the_trivial v vs = (if set vs \\<subseteq> {v} then None else Some v')\"", "lemma the_trivial_conv:\n  shows \"the_trivial v vs = (if \\<exists>v' \\<in> set vs. v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v} then Some (THE v'. v' \\<in> set vs \\<and> v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v}) else None)\"", "lemma the_trivial_SomeE:\n  assumes \"the_trivial v vs = Some v'\"\n  obtains \"v \\<noteq> v'\" and \"set vs = {v'}\" | \"v \\<noteq> v'\" and \"set vs = {v,v'}\"", "lemma trivial_code:\n    \"phi g v = Some vs \\<Longrightarrow> trivial g v = trivial_code v vs\"", "lemma trivial_phis:\n    \"trivial_phis g = {(n,v). Mapping.lookup (phis g) (n,v) \\<noteq> None \\<and> trivial g v}\"", "lemma redundant_code:\n    \"redundant g = redundant_code g\"", "lemma trivial_code_mapI:\n  \"\\<lbrakk> trivial_code v vs; f ` (set vs - {v}) \\<noteq> {v} ; f v = v \\<rbrakk> \\<Longrightarrow> trivial_code v (map f vs)\"", "lemma trivial_code_map_conv:\n    \"f v = v \\<Longrightarrow> trivial_code v (map f vs) \\<longleftrightarrow> (\\<exists>v'\\<in>set vs. f v' \\<noteq> v \\<and> (f ` set vs) - {f v'} \\<subseteq> {v})\""], "translations": [["", "lemma Union_of_alt_def: \"Union_of f A = (\\<Union>x \\<in> A. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Union_of f A = \\<Union> (f ` A)", "unfolding Union_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (f ` A) = \\<Union> (f ` A)", "by simp"], ["", "type_synonym ('node, 'val) phis_code = \"('node \\<times> 'val, 'val list) mapping\""], ["", "context CFG_base begin"], ["", "definition addN :: \"'g \\<Rightarrow> 'node \\<Rightarrow> ('var, 'node set) mapping \\<Rightarrow> ('var, 'node set) mapping\"\n    where \"addN g n \\<equiv> fold (\\<lambda>v. Mapping.map_default v {} (insert n)) (sorted_list_of_set (uses g n))\""], ["", "definition \"addN' g n = fold (\\<lambda>v m. m(v \\<mapsto> case_option {n} (insert n) (m v))) (sorted_list_of_set (uses g n))\""], ["", "lemma addN_transfer [transfer_rule]:\n    \"rel_fun (=) (rel_fun (=) (rel_fun (pcr_mapping (=) (=)) (pcr_mapping (=) (=)))) addN' addN\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (=)\n     (rel_fun (=) (rel_fun (pcr_mapping (=) (=)) (pcr_mapping (=) (=))))\n     addN' addN", "unfolding addN_def [abs_def] addN'_def [abs_def]\n      Mapping.map_default_def [abs_def] Mapping.default_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun (=)\n     (rel_fun (=) (rel_fun (pcr_mapping (=) (=)) (pcr_mapping (=) (=))))\n     (\\<lambda>g n.\n         fold\n          (\\<lambda>v m. m(v \\<mapsto>\n              case m v of None \\<Rightarrow> {n}\n              | Some x \\<Rightarrow> insert n x))\n          (sorted_list_of_set (uses g n)))\n     (\\<lambda>g n.\n         fold\n          (\\<lambda>v m.\n              Mapping.map_entry v (insert n)\n               (if v \\<in> Mapping.keys m then m\n                else Mapping.update v {} m))\n          (sorted_list_of_set (uses g n)))", "apply (auto simp: mapping.pcr_cr_eq rel_fun_def cr_mapping_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa y.\n       fold\n        (\\<lambda>v m. m(v \\<mapsto>\n            case m v of None \\<Rightarrow> {xa}\n            | Some x \\<Rightarrow> insert xa x))\n        (sorted_list_of_set (uses x xa)) (mapping.rep y) =\n       mapping.rep\n        (fold\n          (\\<lambda>v m.\n              Mapping.map_entry v (insert xa)\n               (if v \\<in> Mapping.keys m then m\n                else Mapping.update v {} m))\n          (sorted_list_of_set (uses x xa)) y)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa y uses.\n       fold\n        (\\<lambda>v m. m(v \\<mapsto>\n            case m v of None \\<Rightarrow> {xa}\n            | Some x \\<Rightarrow> insert xa x))\n        (sorted_list_of_set (uses x xa)) y =\n       fold\n        (\\<lambda>v m.\n            case (if v \\<in> dom m then m else m(v \\<mapsto> {})) v of\n            None \\<Rightarrow>\n              if v \\<in> dom m then m else m(v \\<mapsto> {})\n            | Some va \\<Rightarrow>\n                (if v \\<in> dom m then m else m(v \\<mapsto> {}))(v \\<mapsto>\n                insert xa va))\n        (sorted_list_of_set (uses x xa)) y", "apply (rule fold_cong)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa y uses. y = y\n 2. \\<And>x xa y uses.\n       sorted_list_of_set (uses x xa) = sorted_list_of_set (uses x xa)\n 3. \\<And>x xa y uses xb.\n       xb \\<in> set (sorted_list_of_set (uses x xa)) \\<Longrightarrow>\n       (\\<lambda>m. m(xb \\<mapsto>\n           case m xb of None \\<Rightarrow> {xa}\n           | Some x \\<Rightarrow> insert xa x)) =\n       (\\<lambda>m.\n           case (if xb \\<in> dom m then m else m(xb \\<mapsto> {})) xb of\n           None \\<Rightarrow>\n             if xb \\<in> dom m then m else m(xb \\<mapsto> {})\n           | Some v \\<Rightarrow>\n               (if xb \\<in> dom m then m else m(xb \\<mapsto> {}))(xb \n               \\<mapsto> insert xa v))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa y uses.\n       sorted_list_of_set (uses x xa) = sorted_list_of_set (uses x xa)\n 2. \\<And>x xa y uses xb.\n       xb \\<in> set (sorted_list_of_set (uses x xa)) \\<Longrightarrow>\n       (\\<lambda>m. m(xb \\<mapsto>\n           case m xb of None \\<Rightarrow> {xa}\n           | Some x \\<Rightarrow> insert xa x)) =\n       (\\<lambda>m.\n           case (if xb \\<in> dom m then m else m(xb \\<mapsto> {})) xb of\n           None \\<Rightarrow>\n             if xb \\<in> dom m then m else m(xb \\<mapsto> {})\n           | Some v \\<Rightarrow>\n               (if xb \\<in> dom m then m else m(xb \\<mapsto> {}))(xb \n               \\<mapsto> insert xa v))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa y uses xb.\n       xb \\<in> set (sorted_list_of_set (uses x xa)) \\<Longrightarrow>\n       (\\<lambda>m. m(xb \\<mapsto>\n           case m xb of None \\<Rightarrow> {xa}\n           | Some x \\<Rightarrow> insert xa x)) =\n       (\\<lambda>m.\n           case (if xb \\<in> dom m then m else m(xb \\<mapsto> {})) xb of\n           None \\<Rightarrow>\n             if xb \\<in> dom m then m else m(xb \\<mapsto> {})\n           | Some v \\<Rightarrow>\n               (if xb \\<in> dom m then m else m(xb \\<mapsto> {}))(xb \n               \\<mapsto> insert xa v))", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa y uses xb m xc.\n       xb \\<in> set (sorted_list_of_set (uses x xa)) \\<Longrightarrow>\n       (m(xb \\<mapsto>\n        case m xb of None \\<Rightarrow> {xa}\n        | Some x \\<Rightarrow> insert xa x))\n        xc =\n       (case (if xb \\<in> dom m then m else m(xb \\<mapsto> {})) xb of\n        None \\<Rightarrow> if xb \\<in> dom m then m else m(xb \\<mapsto> {})\n        | Some v \\<Rightarrow>\n            (if xb \\<in> dom m then m else m(xb \\<mapsto> {}))(xb \\<mapsto>\n            insert xa v))\n        xc", "by auto"], ["", "definition \"useNodes_of g = fold (addN g) (\\<alpha>n g) Mapping.empty\""], ["", "lemmas useNodes_of_code = useNodes_of_def [unfolded addN_def [abs_def]]"], ["", "declare useNodes_of_code [code]"], ["", "lemma lookup_useNodes_of':\n    assumes [simp]: \"\\<And>n. finite (uses g n)\"\n    shows \"Mapping.lookup (useNodes_of g) v =\n    (if (\\<exists>n \\<in> set (\\<alpha>n g). v \\<in> uses g n) then Some {n \\<in> set (\\<alpha>n g). v \\<in> uses g n} else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup (useNodes_of g) v =\n    (if \\<exists>n\\<in>set (\\<alpha>n g). v \\<in> uses g n\n     then Some {n \\<in> set (\\<alpha>n g). v \\<in> uses g n} else None)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Mapping.lookup (useNodes_of g) v =\n    (if \\<exists>n\\<in>set (\\<alpha>n g). v \\<in> uses g n\n     then Some {n \\<in> set (\\<alpha>n g). v \\<in> uses g n} else None)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. Mapping.lookup (useNodes_of g) v =\n    (if \\<exists>n\\<in>set (\\<alpha>n g). v \\<in> uses g n\n     then Some {n \\<in> set (\\<alpha>n g). v \\<in> uses g n} else None)", "fix m n xs v"], ["proof (state)\ngoal (1 subgoal):\n 1. Mapping.lookup (useNodes_of g) v =\n    (if \\<exists>n\\<in>set (\\<alpha>n g). v \\<in> uses g n\n     then Some {n \\<in> set (\\<alpha>n g). v \\<in> uses g n} else None)", "have \"Mapping.lookup (fold (\\<lambda>v. Mapping.map_default (v::'var) {} (insert (n::'node))) xs m) v=\n        (case Mapping.lookup m v of None \\<Rightarrow> (if v \\<in> set xs then Some {n} else None)\n          | Some N \\<Rightarrow> (if v \\<in> set xs then Some (insert n N) else Some N))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup\n     (fold (\\<lambda>v. Mapping.map_default v {} (insert n)) xs m) v =\n    (case Mapping.lookup m v of\n     None \\<Rightarrow> if v \\<in> set xs then Some {n} else None\n     | Some N \\<Rightarrow>\n         if v \\<in> set xs then Some (insert n N) else Some N)", "by (induction xs arbitrary: m) (auto simp: Mapping_lookup_map_default split: option.splits)"], ["proof (state)\nthis:\n  Mapping.lookup\n   (fold (\\<lambda>v. Mapping.map_default v {} (insert n)) xs m) v =\n  (case Mapping.lookup m v of\n   None \\<Rightarrow> if v \\<in> set xs then Some {n} else None\n   | Some N \\<Rightarrow>\n       if v \\<in> set xs then Some (insert n N) else Some N)\n\ngoal (1 subgoal):\n 1. Mapping.lookup (useNodes_of g) v =\n    (if \\<exists>n\\<in>set (\\<alpha>n g). v \\<in> uses g n\n     then Some {n \\<in> set (\\<alpha>n g). v \\<in> uses g n} else None)", "}"], ["proof (state)\nthis:\n  Mapping.lookup\n   (fold (\\<lambda>v. Mapping.map_default v {} (insert ?n3)) ?xs3 ?m3)\n   ?va3 =\n  (case Mapping.lookup ?m3 ?va3 of\n   None \\<Rightarrow> if ?va3 \\<in> set ?xs3 then Some {?n3} else None\n   | Some N \\<Rightarrow>\n       if ?va3 \\<in> set ?xs3 then Some (insert ?n3 N) else Some N)\n\ngoal (1 subgoal):\n 1. Mapping.lookup (useNodes_of g) v =\n    (if \\<exists>n\\<in>set (\\<alpha>n g). v \\<in> uses g n\n     then Some {n \\<in> set (\\<alpha>n g). v \\<in> uses g n} else None)", "note addN_conv = this [of n \"sorted_list_of_set (uses g n)\" for g n, folded addN_def, simplified]"], ["proof (state)\nthis:\n  Mapping.lookup (addN ?ga6 ?n6 ?m3) ?va3 =\n  (case Mapping.lookup ?m3 ?va3 of\n   None \\<Rightarrow>\n     if ?va3 \\<in> set (sorted_list_of_set (uses ?ga6 ?n6)) then Some {?n6}\n     else None\n   | Some N \\<Rightarrow>\n       if ?va3 \\<in> set (sorted_list_of_set (uses ?ga6 ?n6))\n       then Some (insert ?n6 N) else Some N)\n\ngoal (1 subgoal):\n 1. Mapping.lookup (useNodes_of g) v =\n    (if \\<exists>n\\<in>set (\\<alpha>n g). v \\<in> uses g n\n     then Some {n \\<in> set (\\<alpha>n g). v \\<in> uses g n} else None)", "{"], ["proof (state)\nthis:\n  Mapping.lookup (addN ?ga6 ?n6 ?m3) ?va3 =\n  (case Mapping.lookup ?m3 ?va3 of\n   None \\<Rightarrow>\n     if ?va3 \\<in> set (sorted_list_of_set (uses ?ga6 ?n6)) then Some {?n6}\n     else None\n   | Some N \\<Rightarrow>\n       if ?va3 \\<in> set (sorted_list_of_set (uses ?ga6 ?n6))\n       then Some (insert ?n6 N) else Some N)\n\ngoal (1 subgoal):\n 1. Mapping.lookup (useNodes_of g) v =\n    (if \\<exists>n\\<in>set (\\<alpha>n g). v \\<in> uses g n\n     then Some {n \\<in> set (\\<alpha>n g). v \\<in> uses g n} else None)", "fix xs m v"], ["proof (state)\ngoal (1 subgoal):\n 1. Mapping.lookup (useNodes_of g) v =\n    (if \\<exists>n\\<in>set (\\<alpha>n g). v \\<in> uses g n\n     then Some {n \\<in> set (\\<alpha>n g). v \\<in> uses g n} else None)", "have \"Mapping.lookup (fold (addN g) xs m) v = (case Mapping.lookup m v of None \\<Rightarrow> if (\\<exists>n\\<in>set xs. v \\<in> uses g n) then Some {n\\<in>set xs. v \\<in> uses g n} else None\n        | Some N \\<Rightarrow> Some ({n\\<in>set xs. v \\<in> uses g n} \\<union> N))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup (fold (addN g) xs m) v =\n    (case Mapping.lookup m v of\n     None \\<Rightarrow>\n       if \\<exists>n\\<in>set xs. v \\<in> uses g n\n       then Some {n \\<in> set xs. v \\<in> uses g n} else None\n     | Some N \\<Rightarrow>\n         Some ({n \\<in> set xs. v \\<in> uses g n} \\<union> N))", "by (induction xs arbitrary: m) (auto split: option.splits simp: addN_conv)"], ["proof (state)\nthis:\n  Mapping.lookup (fold (addN g) xs m) v =\n  (case Mapping.lookup m v of\n   None \\<Rightarrow>\n     if \\<exists>n\\<in>set xs. v \\<in> uses g n\n     then Some {n \\<in> set xs. v \\<in> uses g n} else None\n   | Some N \\<Rightarrow>\n       Some ({n \\<in> set xs. v \\<in> uses g n} \\<union> N))\n\ngoal (1 subgoal):\n 1. Mapping.lookup (useNodes_of g) v =\n    (if \\<exists>n\\<in>set (\\<alpha>n g). v \\<in> uses g n\n     then Some {n \\<in> set (\\<alpha>n g). v \\<in> uses g n} else None)", "}"], ["proof (state)\nthis:\n  Mapping.lookup (fold (addN g) ?xs3 ?m3) ?va3 =\n  (case Mapping.lookup ?m3 ?va3 of\n   None \\<Rightarrow>\n     if \\<exists>n\\<in>set ?xs3. ?va3 \\<in> uses g n\n     then Some {n \\<in> set ?xs3. ?va3 \\<in> uses g n} else None\n   | Some N \\<Rightarrow>\n       Some ({n \\<in> set ?xs3. ?va3 \\<in> uses g n} \\<union> N))\n\ngoal (1 subgoal):\n 1. Mapping.lookup (useNodes_of g) v =\n    (if \\<exists>n\\<in>set (\\<alpha>n g). v \\<in> uses g n\n     then Some {n \\<in> set (\\<alpha>n g). v \\<in> uses g n} else None)", "note this [of \"\\<alpha>n g\" Mapping.empty, simp]"], ["proof (state)\nthis:\n  Mapping.lookup (fold (addN g) (\\<alpha>n g) Mapping.empty) ?va3 =\n  (case Mapping.lookup Mapping.empty ?va3 of\n   None \\<Rightarrow>\n     if \\<exists>n\\<in>set (\\<alpha>n g). ?va3 \\<in> uses g n\n     then Some {n \\<in> set (\\<alpha>n g). ?va3 \\<in> uses g n} else None\n   | Some N \\<Rightarrow>\n       Some ({n \\<in> set (\\<alpha>n g). ?va3 \\<in> uses g n} \\<union> N))\n\ngoal (1 subgoal):\n 1. Mapping.lookup (useNodes_of g) v =\n    (if \\<exists>n\\<in>set (\\<alpha>n g). v \\<in> uses g n\n     then Some {n \\<in> set (\\<alpha>n g). v \\<in> uses g n} else None)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup (useNodes_of g) v =\n    (if \\<exists>n\\<in>set (\\<alpha>n g). v \\<in> uses g n\n     then Some {n \\<in> set (\\<alpha>n g). v \\<in> uses g n} else None)", "unfolding useNodes_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup (fold (addN g) (\\<alpha>n g) Mapping.empty) v =\n    (if \\<exists>n\\<in>set (\\<alpha>n g). v \\<in> uses g n\n     then Some {n \\<in> set (\\<alpha>n g). v \\<in> uses g n} else None)", "by (auto split: option.splits simp: lookup_empty)"], ["proof (state)\nthis:\n  Mapping.lookup (useNodes_of g) v =\n  (if \\<exists>n\\<in>set (\\<alpha>n g). v \\<in> uses g n\n   then Some {n \\<in> set (\\<alpha>n g). v \\<in> uses g n} else None)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context CFG begin"], ["", "lift_definition useNodes_of' :: \"'g \\<Rightarrow> ('var, 'node set) mapping\"\n  is \"\\<lambda>g v. if (\\<exists>n \\<in> set (\\<alpha>n g). v \\<in> uses g n) then Some {n \\<in> set (\\<alpha>n g). v \\<in> uses g n} else None\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma useNodes_of': \"useNodes_of' = useNodes_of\""], ["proof (prove)\ngoal (1 subgoal):\n 1. useNodes_of' = useNodes_of", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. useNodes_of' x = useNodes_of x", "fix g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. useNodes_of' x = useNodes_of x", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. useNodes_of' x = useNodes_of x", "fix m n xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. useNodes_of' x = useNodes_of x", "have \"fold (\\<lambda>v m. m(v::'var \\<mapsto> case m v of None \\<Rightarrow> {n::'node} | Some x \\<Rightarrow> insert n x)) xs m =\n        (\\<lambda>v. case m v of None \\<Rightarrow> (if v \\<in> set xs then Some {n} else None)\n          | Some N \\<Rightarrow> (if v \\<in> set xs then Some (insert n N) else Some N))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold\n     (\\<lambda>v m. m(v \\<mapsto>\n         case m v of None \\<Rightarrow> {n}\n         | Some x \\<Rightarrow> insert n x))\n     xs m =\n    (\\<lambda>v.\n        case m v of\n        None \\<Rightarrow> if v \\<in> set xs then Some {n} else None\n        | Some N \\<Rightarrow>\n            if v \\<in> set xs then Some (insert n N) else Some N)", "by (induction xs arbitrary: m)(auto split: option.splits)"], ["proof (state)\nthis:\n  fold\n   (\\<lambda>v m. m(v \\<mapsto>\n       case m v of None \\<Rightarrow> {n}\n       | Some x \\<Rightarrow> insert n x))\n   xs m =\n  (\\<lambda>v.\n      case m v of\n      None \\<Rightarrow> if v \\<in> set xs then Some {n} else None\n      | Some N \\<Rightarrow>\n          if v \\<in> set xs then Some (insert n N) else Some N)\n\ngoal (1 subgoal):\n 1. \\<And>x. useNodes_of' x = useNodes_of x", "}"], ["proof (state)\nthis:\n  fold\n   (\\<lambda>v m. m(v \\<mapsto>\n       case m v of None \\<Rightarrow> {?n3}\n       | Some x \\<Rightarrow> insert ?n3 x))\n   ?xs3 ?m3 =\n  (\\<lambda>v.\n      case ?m3 v of\n      None \\<Rightarrow> if v \\<in> set ?xs3 then Some {?n3} else None\n      | Some N \\<Rightarrow>\n          if v \\<in> set ?xs3 then Some (insert ?n3 N) else Some N)\n\ngoal (1 subgoal):\n 1. \\<And>x. useNodes_of' x = useNodes_of x", "note addN'_conv = this [of n \"sorted_list_of_set (uses g n)\" for g n, folded addN'_def, simplified]"], ["proof (state)\nthis:\n  addN' ?ga6 ?n6 ?m3 =\n  (\\<lambda>v.\n      case ?m3 v of\n      None \\<Rightarrow>\n        if v \\<in> set (sorted_list_of_set (uses ?ga6 ?n6)) then Some {?n6}\n        else None\n      | Some N \\<Rightarrow>\n          if v \\<in> set (sorted_list_of_set (uses ?ga6 ?n6))\n          then Some (insert ?n6 N) else Some N)\n\ngoal (1 subgoal):\n 1. \\<And>x. useNodes_of' x = useNodes_of x", "{"], ["proof (state)\nthis:\n  addN' ?ga6 ?n6 ?m3 =\n  (\\<lambda>v.\n      case ?m3 v of\n      None \\<Rightarrow>\n        if v \\<in> set (sorted_list_of_set (uses ?ga6 ?n6)) then Some {?n6}\n        else None\n      | Some N \\<Rightarrow>\n          if v \\<in> set (sorted_list_of_set (uses ?ga6 ?n6))\n          then Some (insert ?n6 N) else Some N)\n\ngoal (1 subgoal):\n 1. \\<And>x. useNodes_of' x = useNodes_of x", "fix xs m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. useNodes_of' x = useNodes_of x", "have \"fold (addN' g) xs m = (\\<lambda>v. case m v of None \\<Rightarrow> if (\\<exists>n\\<in>set xs. v \\<in> uses g n) then Some {n\\<in>set xs. v \\<in> uses g n} else None\n        | Some N \\<Rightarrow> Some ({n\\<in>set xs. v \\<in> uses g n} \\<union> N))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (addN' g) xs m =\n    (\\<lambda>v.\n        case m v of\n        None \\<Rightarrow>\n          if \\<exists>n\\<in>set xs. v \\<in> uses g n\n          then Some {n \\<in> set xs. v \\<in> uses g n} else None\n        | Some N \\<Rightarrow>\n            Some ({n \\<in> set xs. v \\<in> uses g n} \\<union> N))", "by (induction xs arbitrary: m) (auto 4 4 split: option.splits if_splits simp: addN'_conv intro!: ext)"], ["proof (state)\nthis:\n  fold (addN' g) xs m =\n  (\\<lambda>v.\n      case m v of\n      None \\<Rightarrow>\n        if \\<exists>n\\<in>set xs. v \\<in> uses g n\n        then Some {n \\<in> set xs. v \\<in> uses g n} else None\n      | Some N \\<Rightarrow>\n          Some ({n \\<in> set xs. v \\<in> uses g n} \\<union> N))\n\ngoal (1 subgoal):\n 1. \\<And>x. useNodes_of' x = useNodes_of x", "}"], ["proof (state)\nthis:\n  fold (addN' g) ?xs3 ?m3 =\n  (\\<lambda>v.\n      case ?m3 v of\n      None \\<Rightarrow>\n        if \\<exists>n\\<in>set ?xs3. v \\<in> uses g n\n        then Some {n \\<in> set ?xs3. v \\<in> uses g n} else None\n      | Some N \\<Rightarrow>\n          Some ({n \\<in> set ?xs3. v \\<in> uses g n} \\<union> N))\n\ngoal (1 subgoal):\n 1. \\<And>x. useNodes_of' x = useNodes_of x", "note this [of \"\\<alpha>n g\" Map.empty, simp]"], ["proof (state)\nthis:\n  fold (addN' g) (\\<alpha>n g) Map.empty =\n  (\\<lambda>v.\n      case None of\n      None \\<Rightarrow>\n        if \\<exists>n\\<in>set (\\<alpha>n g). v \\<in> uses g n\n        then Some {n \\<in> set (\\<alpha>n g). v \\<in> uses g n} else None\n      | Some N \\<Rightarrow>\n          Some ({n \\<in> set (\\<alpha>n g). v \\<in> uses g n} \\<union> N))\n\ngoal (1 subgoal):\n 1. \\<And>x. useNodes_of' x = useNodes_of x", "show \"useNodes_of' g = useNodes_of g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. useNodes_of' g = useNodes_of g", "unfolding mmap_def useNodes_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. useNodes_of' g = fold (addN g) (\\<alpha>n g) Mapping.empty", "by (transfer fixing: g) auto"], ["proof (state)\nthis:\n  useNodes_of' g = useNodes_of g\n\ngoal:\nNo subgoals!", "qed"], ["", "declare useNodes_of'.transfer [unfolded useNodes_of', transfer_rule]"], ["", "lemma lookup_useNodes_of: \"Mapping.lookup (useNodes_of g) v =\n    (if (\\<exists>n \\<in> set (\\<alpha>n g). v \\<in> uses g n) then Some {n \\<in> set (\\<alpha>n g). v \\<in> uses g n} else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup (useNodes_of g) v =\n    (if \\<exists>n\\<in>set (\\<alpha>n g). v \\<in> uses g n\n     then Some {n \\<in> set (\\<alpha>n g). v \\<in> uses g n} else None)", "by clarsimp (transfer'; auto)"], ["", "end"], ["", "context CFG_SSA_base begin"], ["", "definition phis_addN\n  where \"phis_addN g n = fold (\\<lambda>v. Mapping.map_default v {} (insert n)) (case_option [] id (phis g n))\""], ["", "definition phidefNodes where [code]:\n    \"phidefNodes g = fold (\\<lambda>(n,v). Mapping.update v n) (sorted_list_of_set (dom (phis g))) Mapping.empty\""], ["", "lemma keys_phidefNodes:\n    assumes \"finite (dom (phis g))\"\n    shows \"Mapping.keys (phidefNodes g) = snd ` dom (phis g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.keys (phidefNodes g) = snd ` dom (phis g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Mapping.keys (phidefNodes g) = snd ` dom (phis g)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. Mapping.keys (phidefNodes g) = snd ` dom (phis g)", "fix xs m x"], ["proof (state)\ngoal (1 subgoal):\n 1. Mapping.keys (phidefNodes g) = snd ` dom (phis g)", "have \"fold (\\<lambda>(a,b) m. m(b \\<mapsto> a)) (xs::('node \\<times> 'val) list) m x = (if x \\<in> snd ` set xs then (Some \\<circ> fst) (last [(b,a)\\<leftarrow>xs. a = x]) else m x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>(a, b) m. m(b \\<mapsto> a)) xs m x =\n    (if x \\<in> snd ` set xs\n     then (Some \\<circ> fst) (last (filter (\\<lambda>(b, a). a = x) xs))\n     else m x)", "by (induction xs arbitrary: m) (auto split: if_splits simp: filter_empty_conv intro: rev_image_eqI)"], ["proof (state)\nthis:\n  fold (\\<lambda>(a, b) m. m(b \\<mapsto> a)) xs m x =\n  (if x \\<in> snd ` set xs\n   then (Some \\<circ> fst) (last (filter (\\<lambda>(b, a). a = x) xs))\n   else m x)\n\ngoal (1 subgoal):\n 1. Mapping.keys (phidefNodes g) = snd ` dom (phis g)", "}"], ["proof (state)\nthis:\n  fold (\\<lambda>(a, b) m. m(b \\<mapsto> a)) ?xs3 ?m3 ?x3 =\n  (if ?x3 \\<in> snd ` set ?xs3\n   then (Some \\<circ> fst) (last (filter (\\<lambda>(b, a). a = ?x3) ?xs3))\n   else ?m3 ?x3)\n\ngoal (1 subgoal):\n 1. Mapping.keys (phidefNodes g) = snd ` dom (phis g)", "from this [of \"sorted_list_of_set (dom (phis g))\" Map.empty] assms"], ["proof (chain)\npicking this:\n  fold (\\<lambda>(a, b) m. m(b \\<mapsto> a))\n   (sorted_list_of_set (dom (phis g))) Map.empty ?x3 =\n  (if ?x3 \\<in> snd ` set (sorted_list_of_set (dom (phis g)))\n   then (Some \\<circ> fst)\n         (last\n           (filter (\\<lambda>(b, a). a = ?x3)\n             (sorted_list_of_set (dom (phis g)))))\n   else None)\n  finite (dom (phis g))", "show ?thesis"], ["proof (prove)\nusing this:\n  fold (\\<lambda>(a, b) m. m(b \\<mapsto> a))\n   (sorted_list_of_set (dom (phis g))) Map.empty ?x3 =\n  (if ?x3 \\<in> snd ` set (sorted_list_of_set (dom (phis g)))\n   then (Some \\<circ> fst)\n         (last\n           (filter (\\<lambda>(b, a). a = ?x3)\n             (sorted_list_of_set (dom (phis g)))))\n   else None)\n  finite (dom (phis g))\n\ngoal (1 subgoal):\n 1. Mapping.keys (phidefNodes g) = snd ` dom (phis g)", "unfolding phidefNodes_def keys_dom_lookup"], ["proof (prove)\nusing this:\n  fold (\\<lambda>(a, b) m. m(b \\<mapsto> a))\n   (sorted_list_of_set (dom (phis g))) Map.empty ?x3 =\n  (if ?x3 \\<in> snd ` set (sorted_list_of_set (dom (phis g)))\n   then (Some \\<circ> fst)\n         (last\n           (filter (\\<lambda>(b, a). a = ?x3)\n             (sorted_list_of_set (dom (phis g)))))\n   else None)\n  finite (dom (phis g))\n\ngoal (1 subgoal):\n 1. dom (Mapping.lookup\n          (fold (\\<lambda>(n, v). Mapping.update v n)\n            (sorted_list_of_set (dom (phis g))) Mapping.empty)) =\n    snd ` dom (phis g)", "by (transfer fixing: g phis) (auto simp: dom_def intro: rev_image_eqI)"], ["proof (state)\nthis:\n  Mapping.keys (phidefNodes g) = snd ` dom (phis g)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition phiNodes_of :: \"'g \\<Rightarrow> ('val, ('node \\<times> 'val) set) mapping\"\n  where \"phiNodes_of g = fold (phis_addN g) (sorted_list_of_set (dom (phis g))) Mapping.empty\""], ["", "lemma lookup_phiNodes_of:\n  assumes [simp]: \"finite (dom (phis g))\"\n  shows \"Mapping.lookup (phiNodes_of g) v =\n    (if (\\<exists>n \\<in> dom (phis g). v \\<in> set (the (phis g n))) then Some {n \\<in> dom (phis g). v \\<in> set (the (phis g n))} else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup (phiNodes_of g) v =\n    (if \\<exists>n\\<in>dom (phis g). v \\<in> set (the (phis g n))\n     then Some {n \\<in> dom (phis g). v \\<in> set (the (phis g n))}\n     else None)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Mapping.lookup (phiNodes_of g) v =\n    (if \\<exists>n\\<in>dom (phis g). v \\<in> set (the (phis g n))\n     then Some {n \\<in> dom (phis g). v \\<in> set (the (phis g n))}\n     else None)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. Mapping.lookup (phiNodes_of g) v =\n    (if \\<exists>n\\<in>dom (phis g). v \\<in> set (the (phis g n))\n     then Some {n \\<in> dom (phis g). v \\<in> set (the (phis g n))}\n     else None)", "fix m n xs v"], ["proof (state)\ngoal (1 subgoal):\n 1. Mapping.lookup (phiNodes_of g) v =\n    (if \\<exists>n\\<in>dom (phis g). v \\<in> set (the (phis g n))\n     then Some {n \\<in> dom (phis g). v \\<in> set (the (phis g n))}\n     else None)", "have \"Mapping.lookup (fold (\\<lambda>v. Mapping.map_default v {} (insert (n::'node \\<times> 'val))) xs (m::('val, ('node \\<times> 'val) set) mapping)) v =\n      (case Mapping.lookup m v of None \\<Rightarrow> (if v \\<in> set xs then Some {n} else None)\n        | Some N \\<Rightarrow> (if v \\<in> set xs then Some (insert n N) else Some N))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup\n     (fold (\\<lambda>v. Mapping.map_default v {} (insert n)) xs m) v =\n    (case Mapping.lookup m v of\n     None \\<Rightarrow> if v \\<in> set xs then Some {n} else None\n     | Some N \\<Rightarrow>\n         if v \\<in> set xs then Some (insert n N) else Some N)", "by (induction xs arbitrary: m) (auto simp: Mapping_lookup_map_default split: option.splits)"], ["proof (state)\nthis:\n  Mapping.lookup\n   (fold (\\<lambda>v. Mapping.map_default v {} (insert n)) xs m) v =\n  (case Mapping.lookup m v of\n   None \\<Rightarrow> if v \\<in> set xs then Some {n} else None\n   | Some N \\<Rightarrow>\n       if v \\<in> set xs then Some (insert n N) else Some N)\n\ngoal (1 subgoal):\n 1. Mapping.lookup (phiNodes_of g) v =\n    (if \\<exists>n\\<in>dom (phis g). v \\<in> set (the (phis g n))\n     then Some {n \\<in> dom (phis g). v \\<in> set (the (phis g n))}\n     else None)", "}"], ["proof (state)\nthis:\n  Mapping.lookup\n   (fold (\\<lambda>v. Mapping.map_default v {} (insert ?n3)) ?xs3 ?m3)\n   ?va3 =\n  (case Mapping.lookup ?m3 ?va3 of\n   None \\<Rightarrow> if ?va3 \\<in> set ?xs3 then Some {?n3} else None\n   | Some N \\<Rightarrow>\n       if ?va3 \\<in> set ?xs3 then Some (insert ?n3 N) else Some N)\n\ngoal (1 subgoal):\n 1. Mapping.lookup (phiNodes_of g) v =\n    (if \\<exists>n\\<in>dom (phis g). v \\<in> set (the (phis g n))\n     then Some {n \\<in> dom (phis g). v \\<in> set (the (phis g n))}\n     else None)", "note phis_addN_conv = this [of n \"case_option [] id (phis g n)\" for n, folded phis_addN_def]"], ["proof (state)\nthis:\n  Mapping.lookup (phis_addN g ?n6 ?m3) ?va3 =\n  (case Mapping.lookup ?m3 ?va3 of\n   None \\<Rightarrow>\n     if ?va3\n        \\<in> set (case phis g ?n6 of None \\<Rightarrow> []\n                   | Some x \\<Rightarrow> id x)\n     then Some {?n6} else None\n   | Some N \\<Rightarrow>\n       if ?va3\n          \\<in> set (case phis g ?n6 of None \\<Rightarrow> []\n                     | Some x \\<Rightarrow> id x)\n       then Some (insert ?n6 N) else Some N)\n\ngoal (1 subgoal):\n 1. Mapping.lookup (phiNodes_of g) v =\n    (if \\<exists>n\\<in>dom (phis g). v \\<in> set (the (phis g n))\n     then Some {n \\<in> dom (phis g). v \\<in> set (the (phis g n))}\n     else None)", "{"], ["proof (state)\nthis:\n  Mapping.lookup (phis_addN g ?n6 ?m3) ?va3 =\n  (case Mapping.lookup ?m3 ?va3 of\n   None \\<Rightarrow>\n     if ?va3\n        \\<in> set (case phis g ?n6 of None \\<Rightarrow> []\n                   | Some x \\<Rightarrow> id x)\n     then Some {?n6} else None\n   | Some N \\<Rightarrow>\n       if ?va3\n          \\<in> set (case phis g ?n6 of None \\<Rightarrow> []\n                     | Some x \\<Rightarrow> id x)\n       then Some (insert ?n6 N) else Some N)\n\ngoal (1 subgoal):\n 1. Mapping.lookup (phiNodes_of g) v =\n    (if \\<exists>n\\<in>dom (phis g). v \\<in> set (the (phis g n))\n     then Some {n \\<in> dom (phis g). v \\<in> set (the (phis g n))}\n     else None)", "fix xs m v"], ["proof (state)\ngoal (1 subgoal):\n 1. Mapping.lookup (phiNodes_of g) v =\n    (if \\<exists>n\\<in>dom (phis g). v \\<in> set (the (phis g n))\n     then Some {n \\<in> dom (phis g). v \\<in> set (the (phis g n))}\n     else None)", "have \"Mapping.lookup (fold (phis_addN g) xs m) v =\n      (case Mapping.lookup m v of None \\<Rightarrow> if (\\<exists>n \\<in> set xs. v \\<in> set (case_option [] id (phis g n))) then Some {n \\<in> set xs. v \\<in> set (case_option [] id (phis g n))} else None\n        | Some N \\<Rightarrow> Some ({n \\<in> set xs. v \\<in> set (case_option [] id (phis g n))} \\<union> N))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup (fold (phis_addN g) xs m) v =\n    (case Mapping.lookup m v of\n     None \\<Rightarrow>\n       if \\<exists>n\\<in>set xs.\n             v \\<in> set (case phis g n of None \\<Rightarrow> []\n                          | Some x \\<Rightarrow> id x)\n       then Some\n             {n \\<in> set xs.\n              v \\<in> set (case phis g n of None \\<Rightarrow> []\n                           | Some x \\<Rightarrow> id x)}\n       else None\n     | Some N \\<Rightarrow>\n         Some\n          ({n \\<in> set xs.\n            v \\<in> set (case phis g n of None \\<Rightarrow> []\n                         | Some x \\<Rightarrow> id x)} \\<union>\n           N))", "by (induction xs arbitrary: m) (auto simp: phis_addN_conv split: option.splits if_splits)+"], ["proof (state)\nthis:\n  Mapping.lookup (fold (phis_addN g) xs m) v =\n  (case Mapping.lookup m v of\n   None \\<Rightarrow>\n     if \\<exists>n\\<in>set xs.\n           v \\<in> set (case phis g n of None \\<Rightarrow> []\n                        | Some x \\<Rightarrow> id x)\n     then Some\n           {n \\<in> set xs.\n            v \\<in> set (case phis g n of None \\<Rightarrow> []\n                         | Some x \\<Rightarrow> id x)}\n     else None\n   | Some N \\<Rightarrow>\n       Some\n        ({n \\<in> set xs.\n          v \\<in> set (case phis g n of None \\<Rightarrow> []\n                       | Some x \\<Rightarrow> id x)} \\<union>\n         N))\n\ngoal (1 subgoal):\n 1. Mapping.lookup (phiNodes_of g) v =\n    (if \\<exists>n\\<in>dom (phis g). v \\<in> set (the (phis g n))\n     then Some {n \\<in> dom (phis g). v \\<in> set (the (phis g n))}\n     else None)", "}"], ["proof (state)\nthis:\n  Mapping.lookup (fold (phis_addN g) ?xs3 ?m3) ?va3 =\n  (case Mapping.lookup ?m3 ?va3 of\n   None \\<Rightarrow>\n     if \\<exists>n\\<in>set ?xs3.\n           ?va3\n           \\<in> set (case phis g n of None \\<Rightarrow> []\n                      | Some x \\<Rightarrow> id x)\n     then Some\n           {n \\<in> set ?xs3.\n            ?va3\n            \\<in> set (case phis g n of None \\<Rightarrow> []\n                       | Some x \\<Rightarrow> id x)}\n     else None\n   | Some N \\<Rightarrow>\n       Some\n        ({n \\<in> set ?xs3.\n          ?va3\n          \\<in> set (case phis g n of None \\<Rightarrow> []\n                     | Some x \\<Rightarrow> id x)} \\<union>\n         N))\n\ngoal (1 subgoal):\n 1. Mapping.lookup (phiNodes_of g) v =\n    (if \\<exists>n\\<in>dom (phis g). v \\<in> set (the (phis g n))\n     then Some {n \\<in> dom (phis g). v \\<in> set (the (phis g n))}\n     else None)", "note this [of \"sorted_list_of_set (dom (phis g))\", simp]"], ["proof (state)\nthis:\n  Mapping.lookup\n   (fold (phis_addN g) (sorted_list_of_set (dom (phis g))) ?m3) ?va3 =\n  (case Mapping.lookup ?m3 ?va3 of\n   None \\<Rightarrow>\n     if \\<exists>n\\<in>set (sorted_list_of_set (dom (phis g))).\n           ?va3\n           \\<in> set (case phis g n of None \\<Rightarrow> []\n                      | Some x \\<Rightarrow> id x)\n     then Some\n           {n \\<in> set (sorted_list_of_set (dom (phis g))).\n            ?va3\n            \\<in> set (case phis g n of None \\<Rightarrow> []\n                       | Some x \\<Rightarrow> id x)}\n     else None\n   | Some N \\<Rightarrow>\n       Some\n        ({n \\<in> set (sorted_list_of_set (dom (phis g))).\n          ?va3\n          \\<in> set (case phis g n of None \\<Rightarrow> []\n                     | Some x \\<Rightarrow> id x)} \\<union>\n         N))\n\ngoal (1 subgoal):\n 1. Mapping.lookup (phiNodes_of g) v =\n    (if \\<exists>n\\<in>dom (phis g). v \\<in> set (the (phis g n))\n     then Some {n \\<in> dom (phis g). v \\<in> set (the (phis g n))}\n     else None)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup (phiNodes_of g) v =\n    (if \\<exists>n\\<in>dom (phis g). v \\<in> set (the (phis g n))\n     then Some {n \\<in> dom (phis g). v \\<in> set (the (phis g n))}\n     else None)", "unfolding phiNodes_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup\n     (fold (phis_addN g) (sorted_list_of_set (dom (phis g))) Mapping.empty)\n     v =\n    (if \\<exists>n\\<in>dom (phis g). v \\<in> set (the (phis g n))\n     then Some {n \\<in> dom (phis g). v \\<in> set (the (phis g n))}\n     else None)", "by (force split: option.splits simp: lookup_empty)"], ["proof (state)\nthis:\n  Mapping.lookup (phiNodes_of g) v =\n  (if \\<exists>n\\<in>dom (phis g). v \\<in> set (the (phis g n))\n   then Some {n \\<in> dom (phis g). v \\<in> set (the (phis g n))} else None)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas phiNodes_of_code = phiNodes_of_def [unfolded phis_addN_def [abs_def]]"], ["", "declare phiNodes_of_code [code]"], ["", "lemma phis_transfer [transfer_rule]:\n  includes lifting_syntax\n  shows \"((=) ===> pcr_mapping (=) (=)) phis (\\<lambda>g. Mapping.Mapping (phis g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> pcr_mapping (=) (=)) phis (\\<lambda>g. Mapping (phis g))", "by (auto simp: mapping.pcr_cr_eq rel_fun_def cr_mapping_def Mapping.Mapping_inverse)"], ["", "end"], ["", "context CFG_SSA begin"], ["", "declare lookup_phiNodes_of [OF phis_finite, simp]"], ["", "declare keys_phidefNodes [OF phis_finite, simp]"], ["", "end"], ["", "locale CFG_SSA_ext_base = CFG_SSA_base \\<alpha>e \\<alpha>n invar inEdges' Entry \"defs\" \"uses\" phis\n  for \\<alpha>e :: \"'g \\<Rightarrow> ('node::linorder \\<times> 'edgeD \\<times> 'node) set\"\n    and \\<alpha>n :: \"'g \\<Rightarrow> 'node list\"\n    and invar :: \"'g \\<Rightarrow> bool\"\n    and inEdges' :: \"'g \\<Rightarrow> 'node \\<Rightarrow> ('node \\<times> 'edgeD) list\"\n    and Entry :: \"'g \\<Rightarrow> 'node\"\n    and \"defs\" :: \"'g \\<Rightarrow> 'node \\<Rightarrow> 'val::linorder set\"\n    and \"uses\" :: \"'g \\<Rightarrow> 'node \\<Rightarrow> 'val set\"\n    and phis :: \"'g \\<Rightarrow> ('node, 'val) phis\"\nbegin"], ["", "abbreviation \"cache g f \\<equiv> Mapping.tabulate (\\<alpha>n g) f\""], ["", "lemma lookup_cache[simp]: \"n \\<in> set (\\<alpha>n g) \\<Longrightarrow> Mapping.lookup (cache g f) n = Some (f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n    Mapping.lookup (cache g f) n = Some (f n)", "by transfer (auto simp: Map.map_of_map_restrict)"], ["", "lemma lookup_cacheD [dest]: \"Mapping.lookup (cache g f) x = Some y \\<Longrightarrow> y = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup (cache g f) x = Some y \\<Longrightarrow> y = f x", "by transfer (auto simp: Map.map_of_map_restrict restrict_map_def split: if_splits)"], ["", "lemma lookup_cache_usesD: \"Mapping.lookup (cache g (uses g)) n = Some vs \\<Longrightarrow> vs = uses g n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup (cache g (uses g)) n = Some vs \\<Longrightarrow>\n    vs = uses g n", "by blast"], ["", "end"], ["", "definition[simp]: \"usesOf m n \\<equiv> case_option {} id (Mapping.lookup m n)\""], ["", "locale CFG_SSA_ext = CFG_SSA_ext_base  \\<alpha>e \\<alpha>n invar inEdges' Entry \"defs\" \"uses\" phis\n  + CFG_SSA \\<alpha>e \\<alpha>n invar inEdges' Entry \"defs\" \"uses\" phis\n  for \\<alpha>e :: \"'g \\<Rightarrow> ('node::linorder \\<times> 'edgeD \\<times> 'node) set\"\n    and \\<alpha>n :: \"'g \\<Rightarrow> 'node list\"\n    and invar :: \"'g \\<Rightarrow> bool\"\n    and inEdges' :: \"'g \\<Rightarrow> 'node \\<Rightarrow> ('node \\<times> 'edgeD) list\"\n    and Entry :: \"'g \\<Rightarrow> 'node\"\n    and \"defs\" :: \"'g \\<Rightarrow> 'node \\<Rightarrow> 'val::linorder set\"\n    and \"uses\" :: \"'g \\<Rightarrow> 'node \\<Rightarrow> 'val set\"\n    and phis :: \"'g \\<Rightarrow> ('node, 'val) phis\"\nbegin"], ["", "lemma usesOf_cache[abs_def, simp]: \"usesOf (cache g (uses g)) n = uses g n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. usesOf (cache g (uses g)) n = uses g n", "by (auto simp: uses_in_\\<alpha>n dest: lookup_cache_usesD split: option.split)"], ["", "end"], ["", "locale CFG_SSA_base_code = CFG_SSA_ext_base \\<alpha>e \\<alpha>n invar inEdges' Entry \"defs\" \"usesOf \\<circ> uses\" \"\\<lambda>g. Mapping.lookup (phis g)\"\n  for \\<alpha>e :: \"'g \\<Rightarrow> ('node::linorder \\<times> 'edgeD \\<times> 'node) set\"\n    and \\<alpha>n :: \"'g \\<Rightarrow> 'node list\"\n    and invar :: \"'g \\<Rightarrow> bool\"\n    and inEdges' :: \"'g \\<Rightarrow> 'node \\<Rightarrow> ('node \\<times> 'edgeD) list\"\n    and Entry :: \"'g \\<Rightarrow> 'node\"\n    and \"defs\" :: \"'g \\<Rightarrow> 'node \\<Rightarrow> 'val::linorder set\"\n    and \"uses\" :: \"'g \\<Rightarrow> ('node, 'val set) mapping\"\n    and phis :: \"'g \\<Rightarrow> ('node, 'val) phis_code\"\nbegin"], ["", "declare phis_transfer [simplified, transfer_rule]"], ["", "lemma phiDefs_code [code]:\n  \"phiDefs g n = snd ` Set.filter (\\<lambda>(n',v). n' = n) (Mapping.keys (phis g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phiDefs g n =\n    snd ` Set.filter (\\<lambda>(n', v). n' = n) (Mapping.keys (phis g))", "unfolding phiDefs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {v. (n, v) \\<in> dom (Mapping.lookup (phis g))} =\n    snd ` Set.filter (\\<lambda>(n', v). n' = n) (Mapping.keys (phis g))", "by transfer (auto 4 3 intro: rev_image_eqI simp: Set.filter_def)"], ["", "lemmas phiUses_code [code] = phiUses_def [folded Union_of_alt_def]"], ["", "declare allUses_def [code]"], ["", "lemmas allVars_code [code] = allVars_def [folded Union_of_alt_def]"], ["", "end"], ["", "locale CFG_SSA_code = CFG_SSA_base_code  \\<alpha>e \\<alpha>n invar inEdges' Entry \"defs\" \"uses\" phis\n  + CFG_SSA_ext \\<alpha>e \\<alpha>n invar inEdges' Entry \"defs\" \"usesOf \\<circ> uses\" \"\\<lambda>g. Mapping.lookup (phis g)\"\n  for \\<alpha>e :: \"'g \\<Rightarrow> ('node::linorder \\<times> 'edgeD \\<times> 'node) set\"\n    and \\<alpha>n :: \"'g \\<Rightarrow> 'node list\"\n    and invar :: \"'g \\<Rightarrow> bool\"\n    and inEdges' :: \"'g \\<Rightarrow> 'node \\<Rightarrow> ('node \\<times> 'edgeD) list\"\n    and Entry :: \"'g \\<Rightarrow> 'node\"\n    and \"defs\" :: \"'g \\<Rightarrow> 'node \\<Rightarrow> 'val::linorder set\"\n    and \"uses\" :: \"'g \\<Rightarrow> ('node, 'val set) mapping\"\n    and phis :: \"'g \\<Rightarrow> ('node, 'val) phis_code\""], ["", "definition \"the_trivial v vs = (case (foldl (\\<lambda>(good,v') w. if w = v then (good,v')\n      else case v' of Some v' \\<Rightarrow> (good \\<and> w = v', Some v')\n        | None \\<Rightarrow> (good, Some w))\n    (True, None) vs)\n  of (False, _) \\<Rightarrow> None | (True,v) \\<Rightarrow> v)\""], ["", "lemma the_trivial_Nil [simp]: \"the_trivial x [] = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_trivial x [] = None", "unfolding the_trivial_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case foldl\n           (\\<lambda>(good, v') w.\n               if w = x then (good, v')\n               else case v' of None \\<Rightarrow> (good, Some w)\n                    | Some v' \\<Rightarrow> (good \\<and> w = v', Some v'))\n           (True, None) [] of\n     (True, x) \\<Rightarrow> x | (False, x) \\<Rightarrow> None) =\n    None", "by simp"], ["", "lemma the_trivialI:\n  assumes \"set vs \\<subseteq> {v, v'}\"\n    and \"v' \\<noteq> v\"\n  shows \"the_trivial v vs = (if set vs \\<subseteq> {v} then None else Some v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_trivial v vs = (if set vs \\<subseteq> {v} then None else Some v')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. the_trivial v vs = (if set vs \\<subseteq> {v} then None else Some v')", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. the_trivial v vs = (if set vs \\<subseteq> {v} then None else Some v')", "fix vx"], ["proof (state)\ngoal (1 subgoal):\n 1. the_trivial v vs = (if set vs \\<subseteq> {v} then None else Some v')", "have \"\\<lbrakk> set vs \\<subseteq> {v, v'}; v' \\<noteq> v; vx \\<in> {None, Some v'} \\<rbrakk>\n    \\<Longrightarrow> (case foldl (\\<lambda>(good, v') w.\n                    if w = v then (good, v')\n                    else case v' of None \\<Rightarrow> (good, Some w) | Some v' \\<Rightarrow> (good \\<and> w = v', Some v'))\n           (True, vx) vs of\n     (True, x) \\<Rightarrow> x | (False, x) \\<Rightarrow> None) = (if set vs \\<subseteq> {v} then vx else Some v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set vs \\<subseteq> {v, v'}; v' \\<noteq> v;\n     vx \\<in> {None, Some v'}\\<rbrakk>\n    \\<Longrightarrow> (case foldl\n                             (\\<lambda>(good, v') w.\n                                 if w = v then (good, v')\n                                 else case v' of\nNone \\<Rightarrow> (good, Some w)\n| Some v' \\<Rightarrow> (good \\<and> w = v', Some v'))\n                             (True, vx) vs of\n                       (True, x) \\<Rightarrow> x\n                       | (False, x) \\<Rightarrow> None) =\n                      (if set vs \\<subseteq> {v} then vx else Some v')", "by (induction vs arbitrary: vx; case_tac vx; auto)"], ["proof (state)\nthis:\n  \\<lbrakk>set vs \\<subseteq> {v, v'}; v' \\<noteq> v;\n   vx \\<in> {None, Some v'}\\<rbrakk>\n  \\<Longrightarrow> (case foldl\n                           (\\<lambda>(good, v') w.\n                               if w = v then (good, v')\n                               else case v' of\n                                    None \\<Rightarrow> (good, Some w)\n                                    | Some v' \\<Rightarrow>\n  (good \\<and> w = v', Some v'))\n                           (True, vx) vs of\n                     (True, x) \\<Rightarrow> x\n                     | (False, x) \\<Rightarrow> None) =\n                    (if set vs \\<subseteq> {v} then vx else Some v')\n\ngoal (1 subgoal):\n 1. the_trivial v vs = (if set vs \\<subseteq> {v} then None else Some v')", "}"], ["proof (state)\nthis:\n  \\<lbrakk>set vs \\<subseteq> {v, v'}; v' \\<noteq> v;\n   ?vx2 \\<in> {None, Some v'}\\<rbrakk>\n  \\<Longrightarrow> (case foldl\n                           (\\<lambda>(good, v') w.\n                               if w = v then (good, v')\n                               else case v' of\n                                    None \\<Rightarrow> (good, Some w)\n                                    | Some v' \\<Rightarrow>\n  (good \\<and> w = v', Some v'))\n                           (True, ?vx2) vs of\n                     (True, x) \\<Rightarrow> x\n                     | (False, x) \\<Rightarrow> None) =\n                    (if set vs \\<subseteq> {v} then ?vx2 else Some v')\n\ngoal (1 subgoal):\n 1. the_trivial v vs = (if set vs \\<subseteq> {v} then None else Some v')", "with assms"], ["proof (chain)\npicking this:\n  set vs \\<subseteq> {v, v'}\n  v' \\<noteq> v\n  \\<lbrakk>set vs \\<subseteq> {v, v'}; v' \\<noteq> v;\n   ?vx2 \\<in> {None, Some v'}\\<rbrakk>\n  \\<Longrightarrow> (case foldl\n                           (\\<lambda>(good, v') w.\n                               if w = v then (good, v')\n                               else case v' of\n                                    None \\<Rightarrow> (good, Some w)\n                                    | Some v' \\<Rightarrow>\n  (good \\<and> w = v', Some v'))\n                           (True, ?vx2) vs of\n                     (True, x) \\<Rightarrow> x\n                     | (False, x) \\<Rightarrow> None) =\n                    (if set vs \\<subseteq> {v} then ?vx2 else Some v')", "show ?thesis"], ["proof (prove)\nusing this:\n  set vs \\<subseteq> {v, v'}\n  v' \\<noteq> v\n  \\<lbrakk>set vs \\<subseteq> {v, v'}; v' \\<noteq> v;\n   ?vx2 \\<in> {None, Some v'}\\<rbrakk>\n  \\<Longrightarrow> (case foldl\n                           (\\<lambda>(good, v') w.\n                               if w = v then (good, v')\n                               else case v' of\n                                    None \\<Rightarrow> (good, Some w)\n                                    | Some v' \\<Rightarrow>\n  (good \\<and> w = v', Some v'))\n                           (True, ?vx2) vs of\n                     (True, x) \\<Rightarrow> x\n                     | (False, x) \\<Rightarrow> None) =\n                    (if set vs \\<subseteq> {v} then ?vx2 else Some v')\n\ngoal (1 subgoal):\n 1. the_trivial v vs = (if set vs \\<subseteq> {v} then None else Some v')", "unfolding the_trivial_def"], ["proof (prove)\nusing this:\n  set vs \\<subseteq> {v, v'}\n  v' \\<noteq> v\n  \\<lbrakk>set vs \\<subseteq> {v, v'}; v' \\<noteq> v;\n   ?vx2 \\<in> {None, Some v'}\\<rbrakk>\n  \\<Longrightarrow> (case foldl\n                           (\\<lambda>(good, v') w.\n                               if w = v then (good, v')\n                               else case v' of\n                                    None \\<Rightarrow> (good, Some w)\n                                    | Some v' \\<Rightarrow>\n  (good \\<and> w = v', Some v'))\n                           (True, ?vx2) vs of\n                     (True, x) \\<Rightarrow> x\n                     | (False, x) \\<Rightarrow> None) =\n                    (if set vs \\<subseteq> {v} then ?vx2 else Some v')\n\ngoal (1 subgoal):\n 1. (case foldl\n           (\\<lambda>(good, v') w.\n               if w = v then (good, v')\n               else case v' of None \\<Rightarrow> (good, Some w)\n                    | Some v' \\<Rightarrow> (good \\<and> w = v', Some v'))\n           (True, None) vs of\n     (True, x) \\<Rightarrow> x | (False, x) \\<Rightarrow> None) =\n    (if set vs \\<subseteq> {v} then None else Some v')", "by simp"], ["proof (state)\nthis:\n  the_trivial v vs = (if set vs \\<subseteq> {v} then None else Some v')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma the_trivial_conv:\n  shows \"the_trivial v vs = (if \\<exists>v' \\<in> set vs. v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v} then Some (THE v'. v' \\<in> set vs \\<and> v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v}) else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the_trivial v vs =\n    (if \\<exists>v'\\<in>set vs.\n           v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v}\n     then Some\n           (THE v'.\n               v' \\<in> set vs \\<and>\n               v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v})\n     else None)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. the_trivial v vs =\n    (if \\<exists>v'\\<in>set vs.\n           v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v}\n     then Some\n           (THE v'.\n               v' \\<in> set vs \\<and>\n               v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v})\n     else None)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. the_trivial v vs =\n    (if \\<exists>v'\\<in>set vs.\n           v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v}\n     then Some\n           (THE v'.\n               v' \\<in> set vs \\<and>\n               v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v})\n     else None)", "fix b a vs"], ["proof (state)\ngoal (1 subgoal):\n 1. the_trivial v vs =\n    (if \\<exists>v'\\<in>set vs.\n           v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v}\n     then Some\n           (THE v'.\n               v' \\<in> set vs \\<and>\n               v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v})\n     else None)", "have \"a \\<noteq> v\n       \\<Longrightarrow> foldl (\\<lambda>(good, v') w.\n                     if w = v then (good, v')\n                     else case v' of None \\<Rightarrow> (good, Some w) | Some v' \\<Rightarrow> (good \\<and> w = v', Some v'))\n            (b, Some a) vs =\n           (b \\<and> set vs \\<subseteq> {v, a}, Some a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> v \\<Longrightarrow>\n    foldl\n     (\\<lambda>(good, v') w.\n         if w = v then (good, v')\n         else case v' of None \\<Rightarrow> (good, Some w)\n              | Some v' \\<Rightarrow> (good \\<and> w = v', Some v'))\n     (b, Some a) vs =\n    (b \\<and> set vs \\<subseteq> {v, a}, Some a)", "by (induction vs arbitrary: b; clarsimp)"], ["proof (state)\nthis:\n  a \\<noteq> v \\<Longrightarrow>\n  foldl\n   (\\<lambda>(good, v') w.\n       if w = v then (good, v')\n       else case v' of None \\<Rightarrow> (good, Some w)\n            | Some v' \\<Rightarrow> (good \\<and> w = v', Some v'))\n   (b, Some a) vs =\n  (b \\<and> set vs \\<subseteq> {v, a}, Some a)\n\ngoal (1 subgoal):\n 1. the_trivial v vs =\n    (if \\<exists>v'\\<in>set vs.\n           v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v}\n     then Some\n           (THE v'.\n               v' \\<in> set vs \\<and>\n               v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v})\n     else None)", "}"], ["proof (state)\nthis:\n  ?a2 \\<noteq> v \\<Longrightarrow>\n  foldl\n   (\\<lambda>(good, v') w.\n       if w = v then (good, v')\n       else case v' of None \\<Rightarrow> (good, Some w)\n            | Some v' \\<Rightarrow> (good \\<and> w = v', Some v'))\n   (?b2, Some ?a2) ?vsa2 =\n  (?b2 \\<and> set ?vsa2 \\<subseteq> {v, ?a2}, Some ?a2)\n\ngoal (1 subgoal):\n 1. the_trivial v vs =\n    (if \\<exists>v'\\<in>set vs.\n           v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v}\n     then Some\n           (THE v'.\n               v' \\<in> set vs \\<and>\n               v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v})\n     else None)", "note this[simp]"], ["proof (state)\nthis:\n  ?a2 \\<noteq> v \\<Longrightarrow>\n  foldl\n   (\\<lambda>(good, v') w.\n       if w = v then (good, v')\n       else case v' of None \\<Rightarrow> (good, Some w)\n            | Some v' \\<Rightarrow> (good \\<and> w = v', Some v'))\n   (?b2, Some ?a2) ?vsa2 =\n  (?b2 \\<and> set ?vsa2 \\<subseteq> {v, ?a2}, Some ?a2)\n\ngoal (1 subgoal):\n 1. the_trivial v vs =\n    (if \\<exists>v'\\<in>set vs.\n           v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v}\n     then Some\n           (THE v'.\n               v' \\<in> set vs \\<and>\n               v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v})\n     else None)", "{"], ["proof (state)\nthis:\n  ?a2 \\<noteq> v \\<Longrightarrow>\n  foldl\n   (\\<lambda>(good, v') w.\n       if w = v then (good, v')\n       else case v' of None \\<Rightarrow> (good, Some w)\n            | Some v' \\<Rightarrow> (good \\<and> w = v', Some v'))\n   (?b2, Some ?a2) ?vsa2 =\n  (?b2 \\<and> set ?vsa2 \\<subseteq> {v, ?a2}, Some ?a2)\n\ngoal (1 subgoal):\n 1. the_trivial v vs =\n    (if \\<exists>v'\\<in>set vs.\n           v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v}\n     then Some\n           (THE v'.\n               v' \\<in> set vs \\<and>\n               v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v})\n     else None)", "fix b vx"], ["proof (state)\ngoal (1 subgoal):\n 1. the_trivial v vs =\n    (if \\<exists>v'\\<in>set vs.\n           v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v}\n     then Some\n           (THE v'.\n               v' \\<in> set vs \\<and>\n               v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v})\n     else None)", "have \"\\<lbrakk> vx \\<in> insert None (Some ` set vs); case_option True (\\<lambda>vx. vx \\<noteq> v) vx \\<rbrakk>\n    \\<Longrightarrow> foldl (\\<lambda>(good, v') w.\n                    if w = v then (good, v')\n                    else case v' of None \\<Rightarrow> (good, Some w) | Some v' \\<Rightarrow> (good \\<and> w = v', Some v'))\n        (b, vx) vs = (b \\<and> (case vx of Some w \\<Rightarrow> set vs \\<subseteq> {v, w} | None \\<Rightarrow> \\<exists>w. set vs \\<subseteq> {v, w}),\n        (case vx of Some w \\<Rightarrow> Some w | None \\<Rightarrow> if (\\<exists>v'\\<in>set vs. v' \\<noteq> v) then Some (hd (filter (\\<lambda>v'. v' \\<noteq> v) vs)) else None))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vx \\<in> insert None (Some ` set vs);\n     case vx of None \\<Rightarrow> True\n     | Some vx \\<Rightarrow> vx \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> foldl\n                       (\\<lambda>(good, v') w.\n                           if w = v then (good, v')\n                           else case v' of None \\<Rightarrow> (good, Some w)\n                                | Some v' \\<Rightarrow>\n                                    (good \\<and> w = v', Some v'))\n                       (b, vx) vs =\n                      (b \\<and>\n                       (case vx of\n                        None \\<Rightarrow>\n                          \\<exists>w. set vs \\<subseteq> {v, w}\n                        | Some w \\<Rightarrow> set vs \\<subseteq> {v, w}),\n                       case vx of\n                       None \\<Rightarrow>\n                         if \\<exists>v'\\<in>set vs. v' \\<noteq> v\n                         then Some\n                               (hd (filter (\\<lambda>v'. v' \\<noteq> v) vs))\n                         else None\n                       | Some w \\<Rightarrow> Some w)", "by (induction vs arbitrary: b vx; auto)"], ["proof (state)\nthis:\n  \\<lbrakk>vx \\<in> insert None (Some ` set vs);\n   case vx of None \\<Rightarrow> True\n   | Some vx \\<Rightarrow> vx \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> foldl\n                     (\\<lambda>(good, v') w.\n                         if w = v then (good, v')\n                         else case v' of None \\<Rightarrow> (good, Some w)\n                              | Some v' \\<Rightarrow>\n                                  (good \\<and> w = v', Some v'))\n                     (b, vx) vs =\n                    (b \\<and>\n                     (case vx of\n                      None \\<Rightarrow>\n                        \\<exists>w. set vs \\<subseteq> {v, w}\n                      | Some w \\<Rightarrow> set vs \\<subseteq> {v, w}),\n                     case vx of\n                     None \\<Rightarrow>\n                       if \\<exists>v'\\<in>set vs. v' \\<noteq> v\n                       then Some\n                             (hd (filter (\\<lambda>v'. v' \\<noteq> v) vs))\n                       else None\n                     | Some w \\<Rightarrow> Some w)\n\ngoal (1 subgoal):\n 1. the_trivial v vs =\n    (if \\<exists>v'\\<in>set vs.\n           v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v}\n     then Some\n           (THE v'.\n               v' \\<in> set vs \\<and>\n               v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v})\n     else None)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?vx2 \\<in> insert None (Some ` set vs);\n   case ?vx2 of None \\<Rightarrow> True\n   | Some vx \\<Rightarrow> vx \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> foldl\n                     (\\<lambda>(good, v') w.\n                         if w = v then (good, v')\n                         else case v' of None \\<Rightarrow> (good, Some w)\n                              | Some v' \\<Rightarrow>\n                                  (good \\<and> w = v', Some v'))\n                     (?b2, ?vx2) vs =\n                    (?b2 \\<and>\n                     (case ?vx2 of\n                      None \\<Rightarrow>\n                        \\<exists>w. set vs \\<subseteq> {v, w}\n                      | Some w \\<Rightarrow> set vs \\<subseteq> {v, w}),\n                     case ?vx2 of\n                     None \\<Rightarrow>\n                       if \\<exists>v'\\<in>set vs. v' \\<noteq> v\n                       then Some\n                             (hd (filter (\\<lambda>v'. v' \\<noteq> v) vs))\n                       else None\n                     | Some w \\<Rightarrow> Some w)\n\ngoal (1 subgoal):\n 1. the_trivial v vs =\n    (if \\<exists>v'\\<in>set vs.\n           v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v}\n     then Some\n           (THE v'.\n               v' \\<in> set vs \\<and>\n               v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v})\n     else None)", "hence \"the_trivial v vs = (if \\<exists>v' \\<in> set vs. v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v} then Some (hd (filter (\\<lambda>v'. v' \\<noteq> v) vs)) else None)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?vx2 \\<in> insert None (Some ` set vs);\n   case ?vx2 of None \\<Rightarrow> True\n   | Some vx \\<Rightarrow> vx \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> foldl\n                     (\\<lambda>(good, v') w.\n                         if w = v then (good, v')\n                         else case v' of None \\<Rightarrow> (good, Some w)\n                              | Some v' \\<Rightarrow>\n                                  (good \\<and> w = v', Some v'))\n                     (?b2, ?vx2) vs =\n                    (?b2 \\<and>\n                     (case ?vx2 of\n                      None \\<Rightarrow>\n                        \\<exists>w. set vs \\<subseteq> {v, w}\n                      | Some w \\<Rightarrow> set vs \\<subseteq> {v, w}),\n                     case ?vx2 of\n                     None \\<Rightarrow>\n                       if \\<exists>v'\\<in>set vs. v' \\<noteq> v\n                       then Some\n                             (hd (filter (\\<lambda>v'. v' \\<noteq> v) vs))\n                       else None\n                     | Some w \\<Rightarrow> Some w)\n\ngoal (1 subgoal):\n 1. the_trivial v vs =\n    (if \\<exists>v'\\<in>set vs.\n           v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v}\n     then Some (hd (filter (\\<lambda>v'. v' \\<noteq> v) vs)) else None)", "unfolding the_trivial_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?vx2 \\<in> insert None (Some ` set vs);\n   case ?vx2 of None \\<Rightarrow> True\n   | Some vx \\<Rightarrow> vx \\<noteq> v\\<rbrakk>\n  \\<Longrightarrow> foldl\n                     (\\<lambda>(good, v') w.\n                         if w = v then (good, v')\n                         else case v' of None \\<Rightarrow> (good, Some w)\n                              | Some v' \\<Rightarrow>\n                                  (good \\<and> w = v', Some v'))\n                     (?b2, ?vx2) vs =\n                    (?b2 \\<and>\n                     (case ?vx2 of\n                      None \\<Rightarrow>\n                        \\<exists>w. set vs \\<subseteq> {v, w}\n                      | Some w \\<Rightarrow> set vs \\<subseteq> {v, w}),\n                     case ?vx2 of\n                     None \\<Rightarrow>\n                       if \\<exists>v'\\<in>set vs. v' \\<noteq> v\n                       then Some\n                             (hd (filter (\\<lambda>v'. v' \\<noteq> v) vs))\n                       else None\n                     | Some w \\<Rightarrow> Some w)\n\ngoal (1 subgoal):\n 1. (case foldl\n           (\\<lambda>(good, v') w.\n               if w = v then (good, v')\n               else case v' of None \\<Rightarrow> (good, Some w)\n                    | Some v' \\<Rightarrow> (good \\<and> w = v', Some v'))\n           (True, None) vs of\n     (True, x) \\<Rightarrow> x | (False, x) \\<Rightarrow> None) =\n    (if \\<exists>v'\\<in>set vs.\n           v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v}\n     then Some (hd (filter (\\<lambda>v'. v' \\<noteq> v) vs)) else None)", "by (auto split: bool.splits)"], ["proof (state)\nthis:\n  the_trivial v vs =\n  (if \\<exists>v'\\<in>set vs.\n         v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v}\n   then Some (hd (filter (\\<lambda>v'. v' \\<noteq> v) vs)) else None)\n\ngoal (1 subgoal):\n 1. the_trivial v vs =\n    (if \\<exists>v'\\<in>set vs.\n           v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v}\n     then Some\n           (THE v'.\n               v' \\<in> set vs \\<and>\n               v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v})\n     else None)", "thus ?thesis"], ["proof (prove)\nusing this:\n  the_trivial v vs =\n  (if \\<exists>v'\\<in>set vs.\n         v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v}\n   then Some (hd (filter (\\<lambda>v'. v' \\<noteq> v) vs)) else None)\n\ngoal (1 subgoal):\n 1. the_trivial v vs =\n    (if \\<exists>v'\\<in>set vs.\n           v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v}\n     then Some\n           (THE v'.\n               v' \\<in> set vs \\<and>\n               v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v})\n     else None)", "apply (auto split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v'.\n       \\<lbrakk>the_trivial v vs =\n                Some (hd (filter (\\<lambda>v'. v' \\<noteq> v) vs));\n        v' \\<in> set vs; v' \\<noteq> v;\n        set vs - {v'} \\<subseteq> {v}\\<rbrakk>\n       \\<Longrightarrow> hd (filter (\\<lambda>v'. v' \\<noteq> v) vs) =\n                         (THE v'.\n                             v' \\<in> set vs \\<and>\n                             v' \\<noteq> v \\<and>\n                             set vs - {v'} \\<subseteq> {v})", "apply (rule the_equality [THEN sym])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v'.\n       \\<lbrakk>the_trivial v vs =\n                Some (hd (filter (\\<lambda>v'. v' \\<noteq> v) vs));\n        v' \\<in> set vs; v' \\<noteq> v;\n        set vs - {v'} \\<subseteq> {v}\\<rbrakk>\n       \\<Longrightarrow> hd (filter (\\<lambda>v'. v' \\<noteq> v) vs)\n                         \\<in> set vs \\<and>\n                         hd (filter (\\<lambda>v'. v' \\<noteq> v)\n                              vs) \\<noteq>\n                         v \\<and>\n                         set vs -\n                         {hd (filter (\\<lambda>v'. v' \\<noteq> v) vs)}\n                         \\<subseteq> {v}\n 2. \\<And>v' v'a.\n       \\<lbrakk>the_trivial v vs =\n                Some (hd (filter (\\<lambda>v'. v' \\<noteq> v) vs));\n        v' \\<in> set vs; v' \\<noteq> v; set vs - {v'} \\<subseteq> {v};\n        v'a \\<in> set vs \\<and>\n        v'a \\<noteq> v \\<and> set vs - {v'a} \\<subseteq> {v}\\<rbrakk>\n       \\<Longrightarrow> v'a = hd (filter (\\<lambda>v'. v' \\<noteq> v) vs)", "by (thin_tac \"P\" for P, (induction vs; auto))+"], ["proof (state)\nthis:\n  the_trivial v vs =\n  (if \\<exists>v'\\<in>set vs.\n         v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v}\n   then Some\n         (THE v'.\n             v' \\<in> set vs \\<and>\n             v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v})\n   else None)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma the_trivial_SomeE:\n  assumes \"the_trivial v vs = Some v'\"\n  obtains \"v \\<noteq> v'\" and \"set vs = {v'}\" | \"v \\<noteq> v'\" and \"set vs = {v,v'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>v \\<noteq> v'; set vs = {v'}\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>v \\<noteq> v'; set vs = {v, v'}\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  the_trivial v vs = Some v'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>v \\<noteq> v'; set vs = {v'}\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>v \\<noteq> v'; set vs = {v, v'}\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply atomize_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. the_trivial v vs = Some v' \\<Longrightarrow>\n    v \\<noteq> v' \\<and> set vs = {v'} \\<or>\n    v \\<noteq> v' \\<and> set vs = {v, v'}", "apply (subst(asm) the_trivial_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<exists>v'\\<in>set vs.\n           v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v}\n     then Some\n           (THE v'.\n               v' \\<in> set vs \\<and>\n               v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v})\n     else None) =\n    Some v' \\<Longrightarrow>\n    v \\<noteq> v' \\<and> set vs = {v'} \\<or>\n    v \\<noteq> v' \\<and> set vs = {v, v'}", "apply (split if_splits; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>v'\\<in>set vs.\n                v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v};\n     (THE v'.\n         v' \\<in> set vs \\<and>\n         v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v}) =\n     v'\\<rbrakk>\n    \\<Longrightarrow> v \\<noteq> v' \\<and> set vs = {v'} \\<or>\n                      v \\<noteq> v' \\<and> set vs = {v, v'}", "by (subgoal_tac \"(THE v'. v' \\<in> set vs \\<and> v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v}) = hd (filter (\\<lambda>v'. v' \\<noteq> v) vs)\")\n  (fastforce simp: set_double_filter_hd set_single_hd set_minus_one)+"], ["", "locale CFG_SSA_wf_base_code = CFG_SSA_base_code \\<alpha>e \\<alpha>n invar inEdges' Entry \"defs\" \"uses\" phis\n  + CFG_SSA_wf_base \\<alpha>e \\<alpha>n invar inEdges' Entry \"defs\" \"usesOf \\<circ> uses\" \"\\<lambda>g. Mapping.lookup (phis g)\"\n  for \\<alpha>e :: \"'g \\<Rightarrow> ('node::linorder \\<times> 'edgeD \\<times> 'node) set\"\n    and \\<alpha>n :: \"'g \\<Rightarrow> 'node list\"\n    and invar :: \"'g \\<Rightarrow> bool\"\n    and inEdges' :: \"'g \\<Rightarrow> 'node \\<Rightarrow> ('node \\<times> 'edgeD) list\"\n    and Entry :: \"'g \\<Rightarrow> 'node\"\n    and \"defs\" :: \"'g \\<Rightarrow> 'node \\<Rightarrow> 'val::linorder set\"\n    and \"uses\" :: \"'g \\<Rightarrow> ('node, 'val set) mapping\"\n    and phis :: \"'g \\<Rightarrow> ('node, 'val) phis_code\"\nbegin"], ["", "definition [code]:\n    \"trivial_code (v::'val) vs = (the_trivial v vs \\<noteq> None)\""], ["", "definition[code]: \"trivial_phis g = Set.filter (\\<lambda>(n,v). trivial_code v (the (Mapping.lookup (phis g) (n,v)))) (Mapping.keys (phis g))\""], ["", "definition [code]: \"redundant_code g = (trivial_phis g \\<noteq> {})\""], ["", "end"], ["", "locale CFG_SSA_wf_code = CFG_SSA_code \\<alpha>e \\<alpha>n invar inEdges' Entry \"defs\" \"uses\" phis\n  + CFG_SSA_wf_base_code \\<alpha>e \\<alpha>n invar inEdges' Entry \"defs\" \"uses\" phis\n  + CFG_SSA_wf \\<alpha>e \\<alpha>n invar inEdges' Entry \"defs\" \"usesOf \\<circ> uses\" \"\\<lambda>g. Mapping.lookup (phis g)\"\n  for \\<alpha>e :: \"'g \\<Rightarrow> ('node::linorder \\<times> 'edgeD \\<times> 'node) set\"\n    and \\<alpha>n :: \"'g \\<Rightarrow> 'node list\"\n    and invar :: \"'g \\<Rightarrow> bool\"\n    and inEdges' :: \"'g \\<Rightarrow> 'node \\<Rightarrow> ('node \\<times> 'edgeD) list\"\n    and Entry :: \"'g \\<Rightarrow> 'node\"\n    and \"defs\" :: \"'g \\<Rightarrow> 'node \\<Rightarrow> 'val::linorder set\"\n    and \"uses\" :: \"'g \\<Rightarrow> ('node, 'val set) mapping\"\n    and phis :: \"'g \\<Rightarrow> ('node, 'val) phis_code\"\nbegin"], ["", "lemma trivial_code:\n    \"phi g v = Some vs \\<Longrightarrow> trivial g v = trivial_code v vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phi g v = Some vs \\<Longrightarrow> trivial g v = trivial_code v vs", "unfolding trivial_def trivial_code_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. phi g v = Some vs \\<Longrightarrow>\n    (\\<exists>v'\\<in>allVars g. isTrivialPhi g v v') =\n    (the_trivial v vs \\<noteq> None)", "apply (auto split: option.splits simp: isTrivialPhi_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v'.\n       \\<lbrakk>phi g v = Some vs; v' \\<in> allVars g; v' \\<noteq> v;\n        set vs = {v, v'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. the_trivial v vs = Some y\n 2. \\<And>v'.\n       \\<lbrakk>phi g v = Some vs; v' \\<in> allVars g; v' \\<noteq> v;\n        set vs = {v'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. the_trivial v vs = Some y\n 3. \\<And>y.\n       \\<lbrakk>phi g v = Some vs; the_trivial v vs = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'\\<in>allVars g.\n                            v' \\<noteq> v \\<and>\n                            (set vs = {v, v'} \\<or> set vs = {v'})", "apply (clarsimp simp: the_trivial_conv split: if_splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v'.\n       \\<lbrakk>phi g v = Some vs; v' \\<in> allVars g; v' \\<noteq> v;\n        set vs = {v'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. the_trivial v vs = Some y\n 2. \\<And>y.\n       \\<lbrakk>phi g v = Some vs; the_trivial v vs = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'\\<in>allVars g.\n                            v' \\<noteq> v \\<and>\n                            (set vs = {v, v'} \\<or> set vs = {v'})", "apply (clarsimp simp: the_trivial_conv split: if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>phi g v = Some vs; the_trivial v vs = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'\\<in>allVars g.\n                            v' \\<noteq> v \\<and>\n                            (set vs = {v, v'} \\<or> set vs = {v'})", "apply (erule the_trivial_SomeE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>phi g v = Some vs; v \\<noteq> y; set vs = {y}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'\\<in>allVars g.\n                            v' \\<noteq> v \\<and>\n                            (set vs = {v, v'} \\<or> set vs = {v'})\n 2. \\<And>y.\n       \\<lbrakk>phi g v = Some vs; v \\<noteq> y; set vs = {v, y}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'\\<in>allVars g.\n                            v' \\<noteq> v \\<and>\n                            (set vs = {v, v'} \\<or> set vs = {v'})", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>phi g v = Some vs; v \\<noteq> y; set vs = {y}\\<rbrakk>\n       \\<Longrightarrow> y \\<in> allVars g\n 2. \\<And>y.\n       \\<lbrakk>phi g v = Some vs; v \\<noteq> y; set vs = {v, y}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'\\<in>allVars g.\n                            v' \\<noteq> v \\<and>\n                            (set vs = {v, v'} \\<or> set vs = {v'})", "apply (rule phiArg_in_allVars; auto simp: phiArg_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>phi g v = Some vs; v \\<noteq> y; set vs = {v, y}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'\\<in>allVars g.\n                            v' \\<noteq> v \\<and>\n                            (set vs = {v, v'} \\<or> set vs = {v'})", "apply (rename_tac v')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v'.\n       \\<lbrakk>phi g v = Some vs; v \\<noteq> v'; set vs = {v, v'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'\\<in>allVars g.\n                            v' \\<noteq> v \\<and>\n                            (set vs = {v, v'} \\<or> set vs = {v'})", "apply (rule_tac x=v' in bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v'.\n       \\<lbrakk>phi g v = Some vs; v \\<noteq> v'; set vs = {v, v'}\\<rbrakk>\n       \\<Longrightarrow> v' \\<noteq> v \\<and>\n                         (set vs = {v, v'} \\<or> set vs = {v'})\n 2. \\<And>v'.\n       \\<lbrakk>phi g v = Some vs; v \\<noteq> v'; set vs = {v, v'}\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> allVars g", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v'.\n       \\<lbrakk>phi g v = Some vs; v \\<noteq> v'; set vs = {v, v'}\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> allVars g", "apply (rule phiArg_in_allVars; auto simp: phiArg_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma trivial_phis:\n    \"trivial_phis g = {(n,v). Mapping.lookup (phis g) (n,v) \\<noteq> None \\<and> trivial g v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trivial_phis g =\n    {(n, v).\n     Mapping.lookup (phis g) (n, v) \\<noteq> None \\<and> trivial g v}", "unfolding trivial_phis_def Set.filter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a \\<in> Mapping.keys (phis g).\n     case a of\n     (n, v) \\<Rightarrow>\n       trivial_code v (the (Mapping.lookup (phis g) (n, v)))} =\n    {(n, v).\n     Mapping.lookup (phis g) (n, v) \\<noteq> None \\<and> trivial g v}", "apply (auto simp add: phi_def keys_dom_lookup)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b y.\n       \\<lbrakk>trivial_code b y;\n        Mapping.lookup (phis g) (a, b) = Some y\\<rbrakk>\n       \\<Longrightarrow> trivial g b\n 2. \\<And>a b y.\n       \\<lbrakk>trivial g b;\n        Mapping.lookup (phis g) (a, b) = Some y\\<rbrakk>\n       \\<Longrightarrow> trivial_code b y", "apply (subst trivial_code)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b y.\n       \\<lbrakk>trivial_code b y;\n        Mapping.lookup (phis g) (a, b) = Some y\\<rbrakk>\n       \\<Longrightarrow> phi g b = Some (?vs30 a b y)\n 2. \\<And>a b y.\n       \\<lbrakk>trivial_code b y;\n        Mapping.lookup (phis g) (a, b) = Some y\\<rbrakk>\n       \\<Longrightarrow> trivial_code b (?vs30 a b y)\n 3. \\<And>a b y.\n       \\<lbrakk>trivial g b;\n        Mapping.lookup (phis g) (a, b) = Some y\\<rbrakk>\n       \\<Longrightarrow> trivial_code b y", "apply (auto simp: image_def trivial_in_allVars phis_phi)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>trivial g b;\n        Mapping.lookup (phis g) (a, b) = Some y\\<rbrakk>\n       \\<Longrightarrow> trivial_code b y", "apply (frule trivial_phi)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>trivial g b; Mapping.lookup (phis g) (a, b) = Some y;\n        phi g b \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> trivial_code b y", "apply (auto simp add: trivial_code phi_def[symmetric] phis_phi)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma redundant_code:\n    \"redundant g = redundant_code g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redundant g = redundant_code g", "unfolding redundant_def redundant_code_def trivial_phis[of g]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>v\\<in>allVars g. trivial g v) =\n    ({(n, v).\n      Mapping.lookup (phis g) (n, v) \\<noteq> None \\<and>\n      trivial g v} \\<noteq>\n     {})", "apply (auto simp: image_def trivial_in_allVars)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       trivial g v \\<Longrightarrow>\n       \\<exists>a b.\n          (\\<exists>y. Mapping.lookup (phis g) (a, b) = Some y) \\<and>\n          trivial g b", "apply (frule trivial_phi)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>trivial g v; phi g v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            (\\<exists>y.\n                                Mapping.lookup (phis g) (a, b) =\n                                Some y) \\<and>\n                            trivial g b", "apply (auto simp: phi_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma trivial_code_mapI:\n  \"\\<lbrakk> trivial_code v vs; f ` (set vs - {v}) \\<noteq> {v} ; f v = v \\<rbrakk> \\<Longrightarrow> trivial_code v (map f vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trivial_code v vs; f ` (set vs - {v}) \\<noteq> {v};\n     f v = v\\<rbrakk>\n    \\<Longrightarrow> trivial_code v (map f vs)", "unfolding trivial_code_def the_trivial_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(if \\<exists>v'\\<in>set vs.\n                    v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v}\n              then Some\n                    (THE v'.\n                        v' \\<in> set vs \\<and>\n                        v' \\<noteq> v \\<and> set vs - {v'} \\<subseteq> {v})\n              else None) \\<noteq>\n             None;\n     f ` (set vs - {v}) \\<noteq> {v}; f v = v\\<rbrakk>\n    \\<Longrightarrow> (if \\<exists>v'\\<in>set (map f vs).\n                             v' \\<noteq> v \\<and>\n                             set (map f vs) - {v'} \\<subseteq> {v}\n                       then Some\n                             (THE v'.\n                                 v' \\<in> set (map f vs) \\<and>\n                                 v' \\<noteq> v \\<and>\n                                 set (map f vs) - {v'} \\<subseteq> {v})\n                       else None) \\<noteq>\n                      None", "by (auto split: if_splits)"], ["", "lemma trivial_code_map_conv:\n    \"f v = v \\<Longrightarrow> trivial_code v (map f vs) \\<longleftrightarrow> (\\<exists>v'\\<in>set vs. f v' \\<noteq> v \\<and> (f ` set vs) - {f v'} \\<subseteq> {v})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f v = v \\<Longrightarrow>\n    trivial_code v (map f vs) =\n    (\\<exists>v'\\<in>set vs.\n        f v' \\<noteq> v \\<and> f ` set vs - {f v'} \\<subseteq> {v})", "unfolding trivial_code_def the_trivial_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. f v = v \\<Longrightarrow>\n    ((if \\<exists>v'\\<in>set (map f vs).\n            v' \\<noteq> v \\<and> set (map f vs) - {v'} \\<subseteq> {v}\n      then Some\n            (THE v'.\n                v' \\<in> set (map f vs) \\<and>\n                v' \\<noteq> v \\<and> set (map f vs) - {v'} \\<subseteq> {v})\n      else None) \\<noteq>\n     None) =\n    (\\<exists>v'\\<in>set vs.\n        f v' \\<noteq> v \\<and> f ` set vs - {f v'} \\<subseteq> {v})", "by auto"], ["", "end"], ["", "locale CFG_SSA_Transformed_code = ssa: CFG_SSA_wf_code \\<alpha>e \\<alpha>n invar inEdges' Entry \"defs\" \"uses\" phis\n   +\n   CFG_SSA_Transformed \\<alpha>e \\<alpha>n invar inEdges' Entry oldDefs oldUses \"defs\" \"usesOf \\<circ> uses\" \"\\<lambda>g. Mapping.lookup (phis g)\" var\nfor\n  \\<alpha>e :: \"'g \\<Rightarrow> ('node::linorder \\<times> 'edgeD \\<times> 'node) set\" and\n  \\<alpha>n :: \"'g \\<Rightarrow> 'node list\" and\n  invar :: \"'g \\<Rightarrow> bool\" and\n  inEdges' :: \"'g \\<Rightarrow> 'node \\<Rightarrow> ('node \\<times> 'edgeD) list\" and\n  Entry::\"'g \\<Rightarrow> 'node\" and\n  oldDefs :: \"'g \\<Rightarrow> 'node \\<Rightarrow> 'var::linorder set\" and\n  oldUses :: \"'g \\<Rightarrow> 'node \\<Rightarrow> 'var set\" and\n  \"defs\" :: \"'g \\<Rightarrow> 'node \\<Rightarrow> 'val::linorder set\" and\n  \"uses\" :: \"'g \\<Rightarrow> ('node, 'val set) mapping\" and\n  phis :: \"'g \\<Rightarrow> ('node, 'val) phis_code\" and\n  var :: \"'g \\<Rightarrow> 'val \\<Rightarrow> 'var\"\n+\nassumes dom_uses_in_graph: \"Mapping.keys (uses g) \\<subseteq> set (\\<alpha>n g)\""], ["", "end"]]}