{"file_name": "/home/qj213/afp-2021-10-22/thys/Formal_SSA/SSA_Transfer_Rules.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Formal_SSA", "problem_names": ["lemmas weak_All_transfer1 [transfer_rule] = iffD1 [OF right_total_alt_def2]", "lemma weak_All_transfer2 [transfer_rule]: \"right_total R \\<Longrightarrow> ((R ===> (=)) ===> (\\<longrightarrow>)) All All\"", "lemma weak_imp_transfer [transfer_rule]:\n  \"((=) ===> (=) ===> (\\<longrightarrow>)) (\\<longrightarrow>) (\\<longrightarrow>)\"", "lemma weak_conj_transfer [transfer_rule]:\n  \"((\\<longrightarrow>) ===> (\\<longrightarrow>) ===> (\\<longrightarrow>)) (\\<and>) (\\<and>)\"", "lemma graph_path_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges inEdges2\"\n  shows \"(\\<longrightarrow>) (graph_path \\<alpha>e \\<alpha>n invar inEdges) (graph_path \\<alpha>e2 \\<alpha>n2 invar2 inEdges2)\"", "lemma inEdges_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total A\"\n    and [transfer_rule]: \"(A ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(A ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(A ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(A ===> (=)) inEdges' inEdges2\"\n  shows \"(A ===> (=)) inEdges (graph_path_base.inEdges inEdges2)\"", "lemma predecessors_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total A\"\n    and [transfer_rule]: \"(A ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(A ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(A ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(A ===> (=)) inEdges' inEdges2\"\n  shows \"(A ===> (=)) predecessors (graph_path_base.predecessors inEdges2)\"", "lemma successors_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total A\"\n    and [transfer_rule]: \"(A ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(A ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(A ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(A ===> (=)) inEdges' inEdges2\"\n  shows \"(A ===> (=)) successors (graph_path_base.successors \\<alpha>n2 inEdges2)\"", "lemma path_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total A\"\n    and [transfer_rule]: \"(A ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(A ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(A ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(A ===> (=)) inEdges' inEdges2\"\n  shows \"(A ===> (=)) path (graph_path_base.path \\<alpha>n2 invar2 inEdges2)\"", "lemma path2_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total A\"\n    and [transfer_rule]: \"(A ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(A ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(A ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(A ===> (=)) inEdges' inEdges2\"\n  shows \"(A ===> (=)) path2 (graph_path_base.path2 \\<alpha>n2 invar2 inEdges2)\"", "lemma weak_Ex_transfer [transfer_rule]: \"(((=) ===> (\\<longrightarrow>)) ===> (\\<longrightarrow>)) Ex Ex\"", "lemmas transfer_rules = inEdges_transfer predecessors_transfer successors_transfer path_transfer path2_transfer", "lemma graph_Entry_transfer [transfer_rule]:\n  includes lifting_syntax\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e1 \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n1 \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar1 invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges1 inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry1 Entry2\"\n  shows \"(\\<longrightarrow>) (graph_Entry \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1) (graph_Entry \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2)\"", "lemma dominates_transfer [transfer_rule]:\n  includes lifting_syntax\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n  shows \"(G ===> (=)) dominates (graph_Entry_base.dominates \\<alpha>n2 invar2 inEdges2 Entry2)\"", "lemma shortestPath_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n  shows \"(G ===> (=)) shortestPath (graph_Entry.shortestPath \\<alpha>n2 invar2 inEdges2 Entry2)\"", "lemma dominators_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n  shows \"(G ===> (=)) dominators (graph_Entry.dominators \\<alpha>n2 invar2 inEdges2 Entry2)\"", "lemma isIdom_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n  shows \"(G ===> (=)) isIdom (graph_Entry.isIdom \\<alpha>n2 invar2 inEdges2 Entry2)\"", "lemma idom_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n  shows \"(G ===> (=)) idom (graph_Entry.idom \\<alpha>n2 invar2 inEdges2 Entry2)\"", "lemmas graph_Entry_transfer =\n  dominates_transfer\n  shortestPath_transfer\n  dominators_transfer\n  isIdom_transfer\n  idom_transfer", "lemma CFG_transfer [transfer_rule]:\n  includes lifting_syntax\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e1 \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n1 \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar1 invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges1 inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry1 Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs1 defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses1 uses2\"\n  shows \"SSA_CFG.CFG \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1\n    \\<longrightarrow> SSA_CFG.CFG \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2\"", "lemma vars_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses uses2\"\n  shows \"(G ===> (=)) vars (CFG_base.vars \\<alpha>n2 uses2)\"", "lemma defAss'_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses uses2\"\n  shows \"(G ===> (=)) defAss' (CFG_base.defAss' \\<alpha>n2 invar2 inEdges2 Entry2 defs2)\"", "lemma defAss'Uses_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses uses2\"\n  shows \"(G ===> (=)) defAss'Uses (CFG_base.defAss'Uses \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2)\"", "lemmas CFG_transfers =\n  vars_transfer\n  defAss'_transfer\n  defAss'Uses_transfer", "lemma CFG_Construct_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e1 \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n1 \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar1 invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges1 inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry1 Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs1 defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses1 uses2\"\n  shows \"CFG_Construct \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1\n    \\<longrightarrow> CFG_Construct \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2\"", "lemma CFG_Construct_linorder_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e1 \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n1 \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar1 invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges1 inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry1 Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs1 defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses1 uses2\"\n  shows \"CFG_Construct_linorder \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1\n    \\<longrightarrow> CFG_Construct_linorder \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2\"", "lemma phiDefNodes_aux_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses uses2\"\n  shows \"(G ===> (=)) phiDefNodes_aux (CFG_Construct.phiDefNodes_aux inEdges2 defs2)\"", "lemma phiDefNodes_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses uses2\"\n  shows \"(G ===> (=)) phiDefNodes (CFG_Construct.phiDefNodes \\<alpha>n2 inEdges2 defs2 uses2)\"", "lemma lookupDef_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses uses2\"\n  shows \"(G ===> (=)) lookupDef (CFG_Construct.lookupDef \\<alpha>n2 inEdges2 defs2)\"", "lemma defs'_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses uses2\"\n  shows \"(G ===> (=)) defs' (CFG_Construct.defs' defs2)\"", "lemma uses'_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses uses2\"\n  shows \"(G ===> (=)) uses' (CFG_Construct.uses' \\<alpha>n2 inEdges2 defs2 uses2)\"", "lemma phis'_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses uses2\"\n  shows \"(G ===> (=)) phis' (CFG_Construct.phis' \\<alpha>n2 inEdges2 defs2 uses2)\"", "lemmas CFG_Construct_transfer_rules =\n  phiDefNodes_aux_transfer\n  phiDefNodes_transfer\n  lookupDef_transfer\n  defs'_transfer\n  uses'_transfer\n  phis'_transfer", "lemma phiDefs_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses uses2\"\n    and [transfer_rule]: \"(G ===> (=)) phis phis2\"\n  shows \"(G ===> (=)) phiDefs (CFG_SSA_base.phiDefs phis2)\"", "lemma allDefs_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs (defs2::'a \\<Rightarrow> 'node \\<Rightarrow> 'val set)\"\n    and [transfer_rule]: \"(G ===> (=)) uses (uses2::'a \\<Rightarrow> 'node \\<Rightarrow> 'val set)\"\n    and [transfer_rule]: \"(G ===> (=)) phis phis2\"\n  shows \"(G ===> (=)) allDefs (CFG_SSA_base.allDefs defs2 phis2)\"", "lemma phiUses_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses uses2\"\n    and [transfer_rule]: \"(G ===> (=)) phis phis2\"\n  shows \"(G ===> (=)) phiUses (CFG_SSA_base.phiUses \\<alpha>n2 inEdges2 phis2)\"", "lemma allUses_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses uses2\"\n    and [transfer_rule]: \"(G ===> (=)) phis phis2\"\n  shows \"(G ===> (=)) allUses (CFG_SSA_base.allUses \\<alpha>n2 inEdges2 uses2 phis2)\"", "lemma allVars_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses uses2\"\n    and [transfer_rule]: \"(G ===> (=)) phis phis2\"\n  shows \"(G ===> (=)) allVars (CFG_SSA_base.allVars \\<alpha>n2 inEdges2 defs2 uses2 phis2)\"", "lemma defAss_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses uses2\"\n    and [transfer_rule]: \"(G ===> (=)) phis phis2\"\n  shows \"(G ===> (=)) defAss (CFG_SSA_base.defAss \\<alpha>n2 invar2 inEdges2 Entry2 defs2 phis2)\"", "lemmas CFG_SSA_base_transfer_rules =\n  phiDefs_transfer\n  allDefs_transfer\n  phiUses_transfer\n  allUses_transfer\n  allVars_transfer\n  defAss_transfer", "lemma CFG_SSA_base_code_transfer_rules [transfer_rule]:\n  includes lifting_syntax\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses uses2\"\n    and [transfer_rule]: \"(G ===> (=)) phis phis2\"\n  shows \"(G ===> (=)) phiDefs (CFG_SSA_base.phiDefs (\\<lambda>g. Mapping.lookup (phis2 g)))\"\n        \"(G ===> (=)) allDefs (CFG_SSA_base.allDefs defs2 (\\<lambda>g. Mapping.lookup (phis2 g)))\"\n        \"(G ===> (=)) phiUses (CFG_SSA_base.phiUses \\<alpha>n2 inEdges2 (\\<lambda>g. Mapping.lookup (phis2 g)))\"\n        \"(G ===> (=)) allUses (CFG_SSA_base.allUses \\<alpha>n2 inEdges2 (usesOf \\<circ> uses2) (\\<lambda>g. Mapping.lookup (phis2 g)))\"\n        \"(G ===> (=)) defAss (CFG_SSA_base.defAss \\<alpha>n2 invar2 inEdges2 Entry2 defs2 (\\<lambda>g. Mapping.lookup (phis2 g)))\"", "lemma CFG_SSA_transfer [transfer_rule]:\n  includes lifting_syntax\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e1 \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n1 \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar1 invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges1 inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry1 Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs1 defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses1 uses2\"\n    and [transfer_rule]: \"(G ===> (=)) phis1 phis2\"\n  shows \"CFG_SSA  \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1 phis1\n    \\<longrightarrow> CFG_SSA  \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2 phis2\""], "translations": [["", "lemmas weak_All_transfer1 [transfer_rule] = iffD1 [OF right_total_alt_def2]"], ["", "lemma weak_All_transfer2 [transfer_rule]: \"right_total R \\<Longrightarrow> ((R ===> (=)) ===> (\\<longrightarrow>)) All All\""], ["proof (prove)\ngoal (1 subgoal):\n 1. right_total R \\<Longrightarrow>\n    ((R ===> (=)) ===> (\\<longrightarrow>)) All All", "by (auto 4 4 elim: right_totalE rel_funE)"], ["", "lemma weak_imp_transfer [transfer_rule]:\n  \"((=) ===> (=) ===> (\\<longrightarrow>)) (\\<longrightarrow>) (\\<longrightarrow>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> (=) ===> (\\<longrightarrow>)) (\\<longrightarrow>)\n     (\\<longrightarrow>)", "by auto"], ["", "lemma weak_conj_transfer [transfer_rule]:\n  \"((\\<longrightarrow>) ===> (\\<longrightarrow>) ===> (\\<longrightarrow>)) (\\<and>) (\\<and>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<longrightarrow>) ===> (\\<longrightarrow>) ===> (\\<longrightarrow>))\n     (\\<and>) (\\<and>)", "by auto"], ["", "lemma graph_path_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges inEdges2\"\n  shows \"(\\<longrightarrow>) (graph_path \\<alpha>e \\<alpha>n invar inEdges) (graph_path \\<alpha>e2 \\<alpha>n2 invar2 inEdges2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_path \\<alpha>e \\<alpha>n invar inEdges \\<longrightarrow>\n    graph_path \\<alpha>e2 \\<alpha>n2 invar2 inEdges2", "unfolding graph_path_def [abs_def] graph_def valid_graph_def graph_nodes_it_def graph_pred_it_def\n  graph_nodes_it_axioms_def graph_pred_it_axioms_def set_iterator_def set_iterator_genord_def \n  foldri_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>g.\n         invar g \\<longrightarrow>\n         finite\n          (nodes\n            \\<lparr>nodes = set (\\<alpha>n g),\n               edges = \\<alpha>e g\\<rparr>)) \\<and>\n     (\\<forall>g.\n         invar g \\<longrightarrow>\n         finite\n          (edges\n            \\<lparr>nodes = set (\\<alpha>n g),\n               edges = \\<alpha>e g\\<rparr>)) \\<and>\n     (\\<forall>g.\n         invar g \\<longrightarrow>\n         fst `\n         edges\n          \\<lparr>nodes = set (\\<alpha>n g), edges = \\<alpha>e g\\<rparr>\n         \\<subseteq> nodes\n                      \\<lparr>nodes = set (\\<alpha>n g),\n                         edges = \\<alpha>e g\\<rparr> \\<and>\n         snd `\n         snd `\n         edges\n          \\<lparr>nodes = set (\\<alpha>n g), edges = \\<alpha>e g\\<rparr>\n         \\<subseteq> nodes\n                      \\<lparr>nodes = set (\\<alpha>n g),\n                         edges = \\<alpha>e g\\<rparr>)) \\<and>\n    (((\\<forall>g.\n          invar g \\<longrightarrow>\n          finite\n           (nodes\n             \\<lparr>nodes = set (\\<alpha>n g),\n                edges = \\<alpha>e g\\<rparr>)) \\<and>\n      (\\<forall>g.\n          invar g \\<longrightarrow>\n          finite\n           (edges\n             \\<lparr>nodes = set (\\<alpha>n g),\n                edges = \\<alpha>e g\\<rparr>)) \\<and>\n      (\\<forall>g.\n          invar g \\<longrightarrow>\n          fst `\n          edges\n           \\<lparr>nodes = set (\\<alpha>n g), edges = \\<alpha>e g\\<rparr>\n          \\<subseteq> nodes\n                       \\<lparr>nodes = set (\\<alpha>n g),\n                          edges = \\<alpha>e g\\<rparr> \\<and>\n          snd `\n          snd `\n          edges\n           \\<lparr>nodes = set (\\<alpha>n g), edges = \\<alpha>e g\\<rparr>\n          \\<subseteq> nodes\n                       \\<lparr>nodes = set (\\<alpha>n g),\n                          edges = \\<alpha>e g\\<rparr>)) \\<and>\n     (\\<forall>g.\n         invar g \\<longrightarrow>\n         (\\<exists>l0.\n             distinct l0 \\<and>\n             nodes\n              \\<lparr>nodes = set (\\<alpha>n g),\n                 edges = \\<alpha>e g\\<rparr> =\n             set l0 \\<and>\n             sorted_wrt (\\<lambda>_ _. True) l0 \\<and>\n             foldli (rev (\\<alpha>n g)) = foldli l0))) \\<and>\n    ((\\<forall>g.\n         invar g \\<longrightarrow>\n         finite\n          (nodes\n            \\<lparr>nodes = set (\\<alpha>n g),\n               edges = \\<alpha>e g\\<rparr>)) \\<and>\n     (\\<forall>g.\n         invar g \\<longrightarrow>\n         finite\n          (edges\n            \\<lparr>nodes = set (\\<alpha>n g),\n               edges = \\<alpha>e g\\<rparr>)) \\<and>\n     (\\<forall>g.\n         invar g \\<longrightarrow>\n         fst `\n         edges\n          \\<lparr>nodes = set (\\<alpha>n g), edges = \\<alpha>e g\\<rparr>\n         \\<subseteq> nodes\n                      \\<lparr>nodes = set (\\<alpha>n g),\n                         edges = \\<alpha>e g\\<rparr> \\<and>\n         snd `\n         snd `\n         edges\n          \\<lparr>nodes = set (\\<alpha>n g), edges = \\<alpha>e g\\<rparr>\n         \\<subseteq> nodes\n                      \\<lparr>nodes = set (\\<alpha>n g),\n                         edges = \\<alpha>e g\\<rparr>)) \\<and>\n    (\\<forall>g v.\n        invar g \\<longrightarrow>\n        (\\<exists>l0.\n            distinct l0 \\<and>\n            pred\n             \\<lparr>nodes = set (\\<alpha>n g), edges = \\<alpha>e g\\<rparr>\n             v =\n            set l0 \\<and>\n            sorted_wrt (\\<lambda>_ _. True) l0 \\<and>\n            foldli (rev (inEdges g v)) = foldli l0)) \\<longrightarrow>\n    ((\\<forall>g.\n         invar2 g \\<longrightarrow>\n         finite\n          (nodes\n            \\<lparr>nodes = set (\\<alpha>n2 g),\n               edges = \\<alpha>e2 g\\<rparr>)) \\<and>\n     (\\<forall>g.\n         invar2 g \\<longrightarrow>\n         finite\n          (edges\n            \\<lparr>nodes = set (\\<alpha>n2 g),\n               edges = \\<alpha>e2 g\\<rparr>)) \\<and>\n     (\\<forall>g.\n         invar2 g \\<longrightarrow>\n         fst `\n         edges\n          \\<lparr>nodes = set (\\<alpha>n2 g), edges = \\<alpha>e2 g\\<rparr>\n         \\<subseteq> nodes\n                      \\<lparr>nodes = set (\\<alpha>n2 g),\n                         edges = \\<alpha>e2 g\\<rparr> \\<and>\n         snd `\n         snd `\n         edges\n          \\<lparr>nodes = set (\\<alpha>n2 g), edges = \\<alpha>e2 g\\<rparr>\n         \\<subseteq> nodes\n                      \\<lparr>nodes = set (\\<alpha>n2 g),\n                         edges = \\<alpha>e2 g\\<rparr>)) \\<and>\n    (((\\<forall>g.\n          invar2 g \\<longrightarrow>\n          finite\n           (nodes\n             \\<lparr>nodes = set (\\<alpha>n2 g),\n                edges = \\<alpha>e2 g\\<rparr>)) \\<and>\n      (\\<forall>g.\n          invar2 g \\<longrightarrow>\n          finite\n           (edges\n             \\<lparr>nodes = set (\\<alpha>n2 g),\n                edges = \\<alpha>e2 g\\<rparr>)) \\<and>\n      (\\<forall>g.\n          invar2 g \\<longrightarrow>\n          fst `\n          edges\n           \\<lparr>nodes = set (\\<alpha>n2 g), edges = \\<alpha>e2 g\\<rparr>\n          \\<subseteq> nodes\n                       \\<lparr>nodes = set (\\<alpha>n2 g),\n                          edges = \\<alpha>e2 g\\<rparr> \\<and>\n          snd `\n          snd `\n          edges\n           \\<lparr>nodes = set (\\<alpha>n2 g), edges = \\<alpha>e2 g\\<rparr>\n          \\<subseteq> nodes\n                       \\<lparr>nodes = set (\\<alpha>n2 g),\n                          edges = \\<alpha>e2 g\\<rparr>)) \\<and>\n     (\\<forall>g.\n         invar2 g \\<longrightarrow>\n         (\\<exists>l0.\n             distinct l0 \\<and>\n             nodes\n              \\<lparr>nodes = set (\\<alpha>n2 g),\n                 edges = \\<alpha>e2 g\\<rparr> =\n             set l0 \\<and>\n             sorted_wrt (\\<lambda>_ _. True) l0 \\<and>\n             foldli (rev (\\<alpha>n2 g)) = foldli l0))) \\<and>\n    ((\\<forall>g.\n         invar2 g \\<longrightarrow>\n         finite\n          (nodes\n            \\<lparr>nodes = set (\\<alpha>n2 g),\n               edges = \\<alpha>e2 g\\<rparr>)) \\<and>\n     (\\<forall>g.\n         invar2 g \\<longrightarrow>\n         finite\n          (edges\n            \\<lparr>nodes = set (\\<alpha>n2 g),\n               edges = \\<alpha>e2 g\\<rparr>)) \\<and>\n     (\\<forall>g.\n         invar2 g \\<longrightarrow>\n         fst `\n         edges\n          \\<lparr>nodes = set (\\<alpha>n2 g), edges = \\<alpha>e2 g\\<rparr>\n         \\<subseteq> nodes\n                      \\<lparr>nodes = set (\\<alpha>n2 g),\n                         edges = \\<alpha>e2 g\\<rparr> \\<and>\n         snd `\n         snd `\n         edges\n          \\<lparr>nodes = set (\\<alpha>n2 g), edges = \\<alpha>e2 g\\<rparr>\n         \\<subseteq> nodes\n                      \\<lparr>nodes = set (\\<alpha>n2 g),\n                         edges = \\<alpha>e2 g\\<rparr>)) \\<and>\n    (\\<forall>g v.\n        invar2 g \\<longrightarrow>\n        (\\<exists>l0.\n            distinct l0 \\<and>\n            pred\n             \\<lparr>nodes = set (\\<alpha>n2 g),\n                edges = \\<alpha>e2 g\\<rparr>\n             v =\n            set l0 \\<and>\n            sorted_wrt (\\<lambda>_ _. True) l0 \\<and>\n            foldli (rev (inEdges2 g v)) = foldli l0))", "using assms(2-5)"], ["proof (prove)\nusing this:\n  (G ===> (=)) \\<alpha>e \\<alpha>e2\n  (G ===> (=)) \\<alpha>n \\<alpha>n2\n  (G ===> (=)) invar invar2\n  (G ===> (=)) inEdges inEdges2\n\ngoal (1 subgoal):\n 1. ((\\<forall>g.\n         invar g \\<longrightarrow>\n         finite\n          (nodes\n            \\<lparr>nodes = set (\\<alpha>n g),\n               edges = \\<alpha>e g\\<rparr>)) \\<and>\n     (\\<forall>g.\n         invar g \\<longrightarrow>\n         finite\n          (edges\n            \\<lparr>nodes = set (\\<alpha>n g),\n               edges = \\<alpha>e g\\<rparr>)) \\<and>\n     (\\<forall>g.\n         invar g \\<longrightarrow>\n         fst `\n         edges\n          \\<lparr>nodes = set (\\<alpha>n g), edges = \\<alpha>e g\\<rparr>\n         \\<subseteq> nodes\n                      \\<lparr>nodes = set (\\<alpha>n g),\n                         edges = \\<alpha>e g\\<rparr> \\<and>\n         snd `\n         snd `\n         edges\n          \\<lparr>nodes = set (\\<alpha>n g), edges = \\<alpha>e g\\<rparr>\n         \\<subseteq> nodes\n                      \\<lparr>nodes = set (\\<alpha>n g),\n                         edges = \\<alpha>e g\\<rparr>)) \\<and>\n    (((\\<forall>g.\n          invar g \\<longrightarrow>\n          finite\n           (nodes\n             \\<lparr>nodes = set (\\<alpha>n g),\n                edges = \\<alpha>e g\\<rparr>)) \\<and>\n      (\\<forall>g.\n          invar g \\<longrightarrow>\n          finite\n           (edges\n             \\<lparr>nodes = set (\\<alpha>n g),\n                edges = \\<alpha>e g\\<rparr>)) \\<and>\n      (\\<forall>g.\n          invar g \\<longrightarrow>\n          fst `\n          edges\n           \\<lparr>nodes = set (\\<alpha>n g), edges = \\<alpha>e g\\<rparr>\n          \\<subseteq> nodes\n                       \\<lparr>nodes = set (\\<alpha>n g),\n                          edges = \\<alpha>e g\\<rparr> \\<and>\n          snd `\n          snd `\n          edges\n           \\<lparr>nodes = set (\\<alpha>n g), edges = \\<alpha>e g\\<rparr>\n          \\<subseteq> nodes\n                       \\<lparr>nodes = set (\\<alpha>n g),\n                          edges = \\<alpha>e g\\<rparr>)) \\<and>\n     (\\<forall>g.\n         invar g \\<longrightarrow>\n         (\\<exists>l0.\n             distinct l0 \\<and>\n             nodes\n              \\<lparr>nodes = set (\\<alpha>n g),\n                 edges = \\<alpha>e g\\<rparr> =\n             set l0 \\<and>\n             sorted_wrt (\\<lambda>_ _. True) l0 \\<and>\n             foldli (rev (\\<alpha>n g)) = foldli l0))) \\<and>\n    ((\\<forall>g.\n         invar g \\<longrightarrow>\n         finite\n          (nodes\n            \\<lparr>nodes = set (\\<alpha>n g),\n               edges = \\<alpha>e g\\<rparr>)) \\<and>\n     (\\<forall>g.\n         invar g \\<longrightarrow>\n         finite\n          (edges\n            \\<lparr>nodes = set (\\<alpha>n g),\n               edges = \\<alpha>e g\\<rparr>)) \\<and>\n     (\\<forall>g.\n         invar g \\<longrightarrow>\n         fst `\n         edges\n          \\<lparr>nodes = set (\\<alpha>n g), edges = \\<alpha>e g\\<rparr>\n         \\<subseteq> nodes\n                      \\<lparr>nodes = set (\\<alpha>n g),\n                         edges = \\<alpha>e g\\<rparr> \\<and>\n         snd `\n         snd `\n         edges\n          \\<lparr>nodes = set (\\<alpha>n g), edges = \\<alpha>e g\\<rparr>\n         \\<subseteq> nodes\n                      \\<lparr>nodes = set (\\<alpha>n g),\n                         edges = \\<alpha>e g\\<rparr>)) \\<and>\n    (\\<forall>g v.\n        invar g \\<longrightarrow>\n        (\\<exists>l0.\n            distinct l0 \\<and>\n            pred\n             \\<lparr>nodes = set (\\<alpha>n g), edges = \\<alpha>e g\\<rparr>\n             v =\n            set l0 \\<and>\n            sorted_wrt (\\<lambda>_ _. True) l0 \\<and>\n            foldli (rev (inEdges g v)) = foldli l0)) \\<longrightarrow>\n    ((\\<forall>g.\n         invar2 g \\<longrightarrow>\n         finite\n          (nodes\n            \\<lparr>nodes = set (\\<alpha>n2 g),\n               edges = \\<alpha>e2 g\\<rparr>)) \\<and>\n     (\\<forall>g.\n         invar2 g \\<longrightarrow>\n         finite\n          (edges\n            \\<lparr>nodes = set (\\<alpha>n2 g),\n               edges = \\<alpha>e2 g\\<rparr>)) \\<and>\n     (\\<forall>g.\n         invar2 g \\<longrightarrow>\n         fst `\n         edges\n          \\<lparr>nodes = set (\\<alpha>n2 g), edges = \\<alpha>e2 g\\<rparr>\n         \\<subseteq> nodes\n                      \\<lparr>nodes = set (\\<alpha>n2 g),\n                         edges = \\<alpha>e2 g\\<rparr> \\<and>\n         snd `\n         snd `\n         edges\n          \\<lparr>nodes = set (\\<alpha>n2 g), edges = \\<alpha>e2 g\\<rparr>\n         \\<subseteq> nodes\n                      \\<lparr>nodes = set (\\<alpha>n2 g),\n                         edges = \\<alpha>e2 g\\<rparr>)) \\<and>\n    (((\\<forall>g.\n          invar2 g \\<longrightarrow>\n          finite\n           (nodes\n             \\<lparr>nodes = set (\\<alpha>n2 g),\n                edges = \\<alpha>e2 g\\<rparr>)) \\<and>\n      (\\<forall>g.\n          invar2 g \\<longrightarrow>\n          finite\n           (edges\n             \\<lparr>nodes = set (\\<alpha>n2 g),\n                edges = \\<alpha>e2 g\\<rparr>)) \\<and>\n      (\\<forall>g.\n          invar2 g \\<longrightarrow>\n          fst `\n          edges\n           \\<lparr>nodes = set (\\<alpha>n2 g), edges = \\<alpha>e2 g\\<rparr>\n          \\<subseteq> nodes\n                       \\<lparr>nodes = set (\\<alpha>n2 g),\n                          edges = \\<alpha>e2 g\\<rparr> \\<and>\n          snd `\n          snd `\n          edges\n           \\<lparr>nodes = set (\\<alpha>n2 g), edges = \\<alpha>e2 g\\<rparr>\n          \\<subseteq> nodes\n                       \\<lparr>nodes = set (\\<alpha>n2 g),\n                          edges = \\<alpha>e2 g\\<rparr>)) \\<and>\n     (\\<forall>g.\n         invar2 g \\<longrightarrow>\n         (\\<exists>l0.\n             distinct l0 \\<and>\n             nodes\n              \\<lparr>nodes = set (\\<alpha>n2 g),\n                 edges = \\<alpha>e2 g\\<rparr> =\n             set l0 \\<and>\n             sorted_wrt (\\<lambda>_ _. True) l0 \\<and>\n             foldli (rev (\\<alpha>n2 g)) = foldli l0))) \\<and>\n    ((\\<forall>g.\n         invar2 g \\<longrightarrow>\n         finite\n          (nodes\n            \\<lparr>nodes = set (\\<alpha>n2 g),\n               edges = \\<alpha>e2 g\\<rparr>)) \\<and>\n     (\\<forall>g.\n         invar2 g \\<longrightarrow>\n         finite\n          (edges\n            \\<lparr>nodes = set (\\<alpha>n2 g),\n               edges = \\<alpha>e2 g\\<rparr>)) \\<and>\n     (\\<forall>g.\n         invar2 g \\<longrightarrow>\n         fst `\n         edges\n          \\<lparr>nodes = set (\\<alpha>n2 g), edges = \\<alpha>e2 g\\<rparr>\n         \\<subseteq> nodes\n                      \\<lparr>nodes = set (\\<alpha>n2 g),\n                         edges = \\<alpha>e2 g\\<rparr> \\<and>\n         snd `\n         snd `\n         edges\n          \\<lparr>nodes = set (\\<alpha>n2 g), edges = \\<alpha>e2 g\\<rparr>\n         \\<subseteq> nodes\n                      \\<lparr>nodes = set (\\<alpha>n2 g),\n                         edges = \\<alpha>e2 g\\<rparr>)) \\<and>\n    (\\<forall>g v.\n        invar2 g \\<longrightarrow>\n        (\\<exists>l0.\n            distinct l0 \\<and>\n            pred\n             \\<lparr>nodes = set (\\<alpha>n2 g),\n                edges = \\<alpha>e2 g\\<rparr>\n             v =\n            set l0 \\<and>\n            sorted_wrt (\\<lambda>_ _. True) l0 \\<and>\n            foldli (rev (inEdges2 g v)) = foldli l0))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n     (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n     (G ===> (=)) inEdges inEdges2;\n     \\<forall>g.\n        invar g \\<longrightarrow>\n        (\\<exists>l0.\n            distinct l0 \\<and>\n            set (\\<alpha>n g) = set l0 \\<and>\n            foldli (rev (\\<alpha>n g)) = foldli l0);\n     \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n     \\<forall>g.\n        invar g \\<longrightarrow>\n        fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n        snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n     \\<forall>g.\n        invar g \\<longrightarrow>\n        (\\<forall>v.\n            \\<exists>l0.\n               distinct l0 \\<and>\n               pred\n                \\<lparr>nodes = set (\\<alpha>n g),\n                   edges = \\<alpha>e g\\<rparr>\n                v =\n               set l0 \\<and>\n               foldli (rev (inEdges g v)) = foldli l0)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>g.\n                          invar2 g \\<longrightarrow>\n                          finite (\\<alpha>e2 g)) \\<and>\n                      (\\<forall>g.\n                          invar2 g \\<longrightarrow>\n                          fst ` \\<alpha>e2 g\n                          \\<subseteq> set (\\<alpha>n2 g) \\<and>\n                          snd ` snd ` \\<alpha>e2 g\n                          \\<subseteq> set (\\<alpha>n2 g)) \\<and>\n                      (\\<forall>g.\n                          invar2 g \\<longrightarrow>\n                          finite (\\<alpha>e2 g)) \\<and>\n                      (\\<forall>g.\n                          invar2 g \\<longrightarrow>\n                          fst ` \\<alpha>e2 g\n                          \\<subseteq> set (\\<alpha>n2 g) \\<and>\n                          snd ` snd ` \\<alpha>e2 g\n                          \\<subseteq> set (\\<alpha>n2 g)) \\<and>\n                      (\\<forall>g.\n                          invar2 g \\<longrightarrow>\n                          (\\<exists>l0.\n                              distinct l0 \\<and>\n                              set (\\<alpha>n2 g) = set l0 \\<and>\n                              foldli (rev (\\<alpha>n2 g)) =\n                              foldli l0)) \\<and>\n                      (\\<forall>g.\n                          invar2 g \\<longrightarrow>\n                          finite (\\<alpha>e2 g)) \\<and>\n                      (\\<forall>g.\n                          invar2 g \\<longrightarrow>\n                          fst ` \\<alpha>e2 g\n                          \\<subseteq> set (\\<alpha>n2 g) \\<and>\n                          snd ` snd ` \\<alpha>e2 g\n                          \\<subseteq> set (\\<alpha>n2 g)) \\<and>\n                      (\\<forall>g.\n                          invar2 g \\<longrightarrow>\n                          (\\<forall>v.\n                              \\<exists>l0.\n                                 distinct l0 \\<and>\n                                 pred\n                                  \\<lparr>nodes = set (\\<alpha>n2 g),\n                                     edges = \\<alpha>e2 g\\<rparr>\n                                  v =\n                                 set l0 \\<and>\n                                 foldli (rev (inEdges2 g v)) = foldli l0))", "apply safe"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>g.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> finite (\\<alpha>e2 g)\n 2. \\<And>g x a aa b.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, aa, b) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> fst (a, aa, b) \\<in> set (\\<alpha>n2 g)\n 3. \\<And>g x a b aa ab ba.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, b) = snd (aa, ab, ba);\n        (aa, ab, ba) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> snd (a, b) \\<in> set (\\<alpha>n2 g)\n 4. \\<And>g.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> finite (\\<alpha>e2 g)\n 5. \\<And>g x a aa b.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, aa, b) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> fst (a, aa, b) \\<in> set (\\<alpha>n2 g)\n 6. \\<And>g x a b aa ab ba.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, b) = snd (aa, ab, ba);\n        (aa, ab, ba) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> snd (a, b) \\<in> set (\\<alpha>n2 g)\n 7. \\<And>g.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l0.\n                            distinct l0 \\<and>\n                            set (\\<alpha>n2 g) = set l0 \\<and>\n                            foldli (rev (\\<alpha>n2 g)) = foldli l0\n 8. \\<And>g.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> finite (\\<alpha>e2 g)\n 9. \\<And>g x a aa b.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, aa, b) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> fst (a, aa, b) \\<in> set (\\<alpha>n2 g)\n 10. \\<And>g x a b aa ab ba.\n        \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n         (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n         (G ===> (=)) inEdges inEdges2;\n         \\<forall>g.\n            invar g \\<longrightarrow>\n            (\\<exists>l0.\n                distinct l0 \\<and>\n                set (\\<alpha>n g) = set l0 \\<and>\n                foldli (rev (\\<alpha>n g)) = foldli l0);\n         \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n         \\<forall>g.\n            invar g \\<longrightarrow>\n            fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n            snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n         \\<forall>g.\n            invar g \\<longrightarrow>\n            (\\<forall>v.\n                \\<exists>l0.\n                   distinct l0 \\<and>\n                   pred\n                    \\<lparr>nodes = set (\\<alpha>n g),\n                       edges = \\<alpha>e g\\<rparr>\n                    v =\n                   set l0 \\<and>\n                   foldli (rev (inEdges g v)) = foldli l0);\n         invar2 g; (a, b) = snd (aa, ab, ba);\n         (aa, ab, ba) \\<in> \\<alpha>e2 g\\<rbrakk>\n        \\<Longrightarrow> snd (a, b) \\<in> set (\\<alpha>n2 g)\nA total of 11 subgoals...", "apply (rule_tac y=g in right_totalE [OF assms(1)]; (erule(1) rel_funE)+; auto)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>g x a aa b.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, aa, b) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> fst (a, aa, b) \\<in> set (\\<alpha>n2 g)\n 2. \\<And>g x a b aa ab ba.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, b) = snd (aa, ab, ba);\n        (aa, ab, ba) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> snd (a, b) \\<in> set (\\<alpha>n2 g)\n 3. \\<And>g.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> finite (\\<alpha>e2 g)\n 4. \\<And>g x a aa b.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, aa, b) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> fst (a, aa, b) \\<in> set (\\<alpha>n2 g)\n 5. \\<And>g x a b aa ab ba.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, b) = snd (aa, ab, ba);\n        (aa, ab, ba) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> snd (a, b) \\<in> set (\\<alpha>n2 g)\n 6. \\<And>g.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l0.\n                            distinct l0 \\<and>\n                            set (\\<alpha>n2 g) = set l0 \\<and>\n                            foldli (rev (\\<alpha>n2 g)) = foldli l0\n 7. \\<And>g.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> finite (\\<alpha>e2 g)\n 8. \\<And>g x a aa b.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, aa, b) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> fst (a, aa, b) \\<in> set (\\<alpha>n2 g)\n 9. \\<And>g x a b aa ab ba.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, b) = snd (aa, ab, ba);\n        (aa, ab, ba) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> snd (a, b) \\<in> set (\\<alpha>n2 g)\n 10. \\<And>g v.\n        \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n         (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n         (G ===> (=)) inEdges inEdges2;\n         \\<forall>g.\n            invar g \\<longrightarrow>\n            (\\<exists>l0.\n                distinct l0 \\<and>\n                set (\\<alpha>n g) = set l0 \\<and>\n                foldli (rev (\\<alpha>n g)) = foldli l0);\n         \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n         \\<forall>g.\n            invar g \\<longrightarrow>\n            fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n            snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n         \\<forall>g.\n            invar g \\<longrightarrow>\n            (\\<forall>v.\n                \\<exists>l0.\n                   distinct l0 \\<and>\n                   pred\n                    \\<lparr>nodes = set (\\<alpha>n g),\n                       edges = \\<alpha>e g\\<rparr>\n                    v =\n                   set l0 \\<and>\n                   foldli (rev (inEdges g v)) = foldli l0);\n         invar2 g\\<rbrakk>\n        \\<Longrightarrow> \\<exists>l0.\n                             distinct l0 \\<and>\n                             pred\n                              \\<lparr>nodes = set (\\<alpha>n2 g),\n                                 edges = \\<alpha>e2 g\\<rparr>\n                              v =\n                             set l0 \\<and>\n                             foldli (rev (inEdges2 g v)) = foldli l0", "apply (rule_tac y=g in right_totalE [OF assms(1)]; (erule(1) rel_funE)+; force)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>g x a b aa ab ba.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, b) = snd (aa, ab, ba);\n        (aa, ab, ba) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> snd (a, b) \\<in> set (\\<alpha>n2 g)\n 2. \\<And>g.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> finite (\\<alpha>e2 g)\n 3. \\<And>g x a aa b.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, aa, b) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> fst (a, aa, b) \\<in> set (\\<alpha>n2 g)\n 4. \\<And>g x a b aa ab ba.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, b) = snd (aa, ab, ba);\n        (aa, ab, ba) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> snd (a, b) \\<in> set (\\<alpha>n2 g)\n 5. \\<And>g.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l0.\n                            distinct l0 \\<and>\n                            set (\\<alpha>n2 g) = set l0 \\<and>\n                            foldli (rev (\\<alpha>n2 g)) = foldli l0\n 6. \\<And>g.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> finite (\\<alpha>e2 g)\n 7. \\<And>g x a aa b.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, aa, b) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> fst (a, aa, b) \\<in> set (\\<alpha>n2 g)\n 8. \\<And>g x a b aa ab ba.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, b) = snd (aa, ab, ba);\n        (aa, ab, ba) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> snd (a, b) \\<in> set (\\<alpha>n2 g)\n 9. \\<And>g v.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l0.\n                            distinct l0 \\<and>\n                            pred\n                             \\<lparr>nodes = set (\\<alpha>n2 g),\n                                edges = \\<alpha>e2 g\\<rparr>\n                             v =\n                            set l0 \\<and>\n                            foldli (rev (inEdges2 g v)) = foldli l0", "apply (rule_tac y=g in right_totalE [OF assms(1)]; (erule(1) rel_funE)+; force)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>g.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> finite (\\<alpha>e2 g)\n 2. \\<And>g x a aa b.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, aa, b) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> fst (a, aa, b) \\<in> set (\\<alpha>n2 g)\n 3. \\<And>g x a b aa ab ba.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, b) = snd (aa, ab, ba);\n        (aa, ab, ba) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> snd (a, b) \\<in> set (\\<alpha>n2 g)\n 4. \\<And>g.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l0.\n                            distinct l0 \\<and>\n                            set (\\<alpha>n2 g) = set l0 \\<and>\n                            foldli (rev (\\<alpha>n2 g)) = foldli l0\n 5. \\<And>g.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> finite (\\<alpha>e2 g)\n 6. \\<And>g x a aa b.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, aa, b) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> fst (a, aa, b) \\<in> set (\\<alpha>n2 g)\n 7. \\<And>g x a b aa ab ba.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, b) = snd (aa, ab, ba);\n        (aa, ab, ba) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> snd (a, b) \\<in> set (\\<alpha>n2 g)\n 8. \\<And>g v.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l0.\n                            distinct l0 \\<and>\n                            pred\n                             \\<lparr>nodes = set (\\<alpha>n2 g),\n                                edges = \\<alpha>e2 g\\<rparr>\n                             v =\n                            set l0 \\<and>\n                            foldli (rev (inEdges2 g v)) = foldli l0", "apply (rule_tac y=g in right_totalE [OF assms(1)]; (erule(1) rel_funE)+; force)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>g x a aa b.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, aa, b) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> fst (a, aa, b) \\<in> set (\\<alpha>n2 g)\n 2. \\<And>g x a b aa ab ba.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, b) = snd (aa, ab, ba);\n        (aa, ab, ba) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> snd (a, b) \\<in> set (\\<alpha>n2 g)\n 3. \\<And>g.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l0.\n                            distinct l0 \\<and>\n                            set (\\<alpha>n2 g) = set l0 \\<and>\n                            foldli (rev (\\<alpha>n2 g)) = foldli l0\n 4. \\<And>g.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> finite (\\<alpha>e2 g)\n 5. \\<And>g x a aa b.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, aa, b) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> fst (a, aa, b) \\<in> set (\\<alpha>n2 g)\n 6. \\<And>g x a b aa ab ba.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, b) = snd (aa, ab, ba);\n        (aa, ab, ba) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> snd (a, b) \\<in> set (\\<alpha>n2 g)\n 7. \\<And>g v.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l0.\n                            distinct l0 \\<and>\n                            pred\n                             \\<lparr>nodes = set (\\<alpha>n2 g),\n                                edges = \\<alpha>e2 g\\<rparr>\n                             v =\n                            set l0 \\<and>\n                            foldli (rev (inEdges2 g v)) = foldli l0", "apply (rule_tac y=g in right_totalE [OF assms(1)]; (erule(1) rel_funE)+; force)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>g x a b aa ab ba.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, b) = snd (aa, ab, ba);\n        (aa, ab, ba) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> snd (a, b) \\<in> set (\\<alpha>n2 g)\n 2. \\<And>g.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l0.\n                            distinct l0 \\<and>\n                            set (\\<alpha>n2 g) = set l0 \\<and>\n                            foldli (rev (\\<alpha>n2 g)) = foldli l0\n 3. \\<And>g.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> finite (\\<alpha>e2 g)\n 4. \\<And>g x a aa b.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, aa, b) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> fst (a, aa, b) \\<in> set (\\<alpha>n2 g)\n 5. \\<And>g x a b aa ab ba.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, b) = snd (aa, ab, ba);\n        (aa, ab, ba) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> snd (a, b) \\<in> set (\\<alpha>n2 g)\n 6. \\<And>g v.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l0.\n                            distinct l0 \\<and>\n                            pred\n                             \\<lparr>nodes = set (\\<alpha>n2 g),\n                                edges = \\<alpha>e2 g\\<rparr>\n                             v =\n                            set l0 \\<and>\n                            foldli (rev (inEdges2 g v)) = foldli l0", "apply (rule_tac y=g in right_totalE [OF assms(1)]; (erule(1) rel_funE)+; force)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>g.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l0.\n                            distinct l0 \\<and>\n                            set (\\<alpha>n2 g) = set l0 \\<and>\n                            foldli (rev (\\<alpha>n2 g)) = foldli l0\n 2. \\<And>g.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> finite (\\<alpha>e2 g)\n 3. \\<And>g x a aa b.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, aa, b) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> fst (a, aa, b) \\<in> set (\\<alpha>n2 g)\n 4. \\<And>g x a b aa ab ba.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, b) = snd (aa, ab, ba);\n        (aa, ab, ba) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> snd (a, b) \\<in> set (\\<alpha>n2 g)\n 5. \\<And>g v.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l0.\n                            distinct l0 \\<and>\n                            pred\n                             \\<lparr>nodes = set (\\<alpha>n2 g),\n                                edges = \\<alpha>e2 g\\<rparr>\n                             v =\n                            set l0 \\<and>\n                            foldli (rev (inEdges2 g v)) = foldli l0", "apply (rule_tac y=g in right_totalE [OF assms(1)]; (erule(1) rel_funE)+)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>g x.\n       \\<lbrakk>\\<forall>g.\n                   invar g \\<longrightarrow>\n                   (\\<exists>l0.\n                       distinct l0 \\<and>\n                       set (\\<alpha>n g) = set l0 \\<and>\n                       foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; G x g; \\<alpha>e x = \\<alpha>e2 g;\n        \\<alpha>n x = \\<alpha>n2 g; invar x = invar2 g;\n        inEdges x = inEdges2 g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l0.\n                            distinct l0 \\<and>\n                            set (\\<alpha>n2 g) = set l0 \\<and>\n                            foldli (rev (\\<alpha>n2 g)) = foldli l0\n 2. \\<And>g.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> finite (\\<alpha>e2 g)\n 3. \\<And>g x a aa b.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, aa, b) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> fst (a, aa, b) \\<in> set (\\<alpha>n2 g)\n 4. \\<And>g x a b aa ab ba.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, b) = snd (aa, ab, ba);\n        (aa, ab, ba) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> snd (a, b) \\<in> set (\\<alpha>n2 g)\n 5. \\<And>g v.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l0.\n                            distinct l0 \\<and>\n                            pred\n                             \\<lparr>nodes = set (\\<alpha>n2 g),\n                                edges = \\<alpha>e2 g\\<rparr>\n                             v =\n                            set l0 \\<and>\n                            foldli (rev (inEdges2 g v)) = foldli l0", "apply (erule_tac x=x in allE)+"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>g x.\n       \\<lbrakk>invar2 g; G x g; \\<alpha>e x = \\<alpha>e2 g;\n        \\<alpha>n x = \\<alpha>n2 g; invar x = invar2 g;\n        inEdges x = inEdges2 g;\n        invar x \\<longrightarrow>\n        (\\<exists>l0.\n            distinct l0 \\<and>\n            set (\\<alpha>n x) = set l0 \\<and>\n            foldli (rev (\\<alpha>n x)) = foldli l0);\n        invar x \\<longrightarrow> finite (\\<alpha>e x);\n        invar x \\<longrightarrow>\n        fst ` \\<alpha>e x \\<subseteq> set (\\<alpha>n x) \\<and>\n        snd ` snd ` \\<alpha>e x \\<subseteq> set (\\<alpha>n x);\n        invar x \\<longrightarrow>\n        (\\<forall>v.\n            \\<exists>l0.\n               distinct l0 \\<and>\n               pred\n                \\<lparr>nodes = set (\\<alpha>n x),\n                   edges = \\<alpha>e x\\<rparr>\n                v =\n               set l0 \\<and>\n               foldli (rev (inEdges x v)) = foldli l0)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l0.\n                            distinct l0 \\<and>\n                            set (\\<alpha>n2 g) = set l0 \\<and>\n                            foldli (rev (\\<alpha>n2 g)) = foldli l0\n 2. \\<And>g.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> finite (\\<alpha>e2 g)\n 3. \\<And>g x a aa b.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, aa, b) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> fst (a, aa, b) \\<in> set (\\<alpha>n2 g)\n 4. \\<And>g x a b aa ab ba.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, b) = snd (aa, ab, ba);\n        (aa, ab, ba) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> snd (a, b) \\<in> set (\\<alpha>n2 g)\n 5. \\<And>g v.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l0.\n                            distinct l0 \\<and>\n                            pred\n                             \\<lparr>nodes = set (\\<alpha>n2 g),\n                                edges = \\<alpha>e2 g\\<rparr>\n                             v =\n                            set l0 \\<and>\n                            foldli (rev (inEdges2 g v)) = foldli l0", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>g.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> finite (\\<alpha>e2 g)\n 2. \\<And>g x a aa b.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, aa, b) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> fst (a, aa, b) \\<in> set (\\<alpha>n2 g)\n 3. \\<And>g x a b aa ab ba.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, b) = snd (aa, ab, ba);\n        (aa, ab, ba) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> snd (a, b) \\<in> set (\\<alpha>n2 g)\n 4. \\<And>g v.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l0.\n                            distinct l0 \\<and>\n                            pred\n                             \\<lparr>nodes = set (\\<alpha>n2 g),\n                                edges = \\<alpha>e2 g\\<rparr>\n                             v =\n                            set l0 \\<and>\n                            foldli (rev (inEdges2 g v)) = foldli l0", "apply (rule_tac y=g in right_totalE [OF assms(1)]; (erule(1) rel_funE)+; force)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>g x a aa b.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, aa, b) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> fst (a, aa, b) \\<in> set (\\<alpha>n2 g)\n 2. \\<And>g x a b aa ab ba.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, b) = snd (aa, ab, ba);\n        (aa, ab, ba) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> snd (a, b) \\<in> set (\\<alpha>n2 g)\n 3. \\<And>g v.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l0.\n                            distinct l0 \\<and>\n                            pred\n                             \\<lparr>nodes = set (\\<alpha>n2 g),\n                                edges = \\<alpha>e2 g\\<rparr>\n                             v =\n                            set l0 \\<and>\n                            foldli (rev (inEdges2 g v)) = foldli l0", "apply (rule_tac y=g in right_totalE [OF assms(1)]; (erule(1) rel_funE)+; force)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>g x a b aa ab ba.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g; (a, b) = snd (aa, ab, ba);\n        (aa, ab, ba) \\<in> \\<alpha>e2 g\\<rbrakk>\n       \\<Longrightarrow> snd (a, b) \\<in> set (\\<alpha>n2 g)\n 2. \\<And>g v.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l0.\n                            distinct l0 \\<and>\n                            pred\n                             \\<lparr>nodes = set (\\<alpha>n2 g),\n                                edges = \\<alpha>e2 g\\<rparr>\n                             v =\n                            set l0 \\<and>\n                            foldli (rev (inEdges2 g v)) = foldli l0", "apply (rule_tac y=g in right_totalE [OF assms(1)]; (erule(1) rel_funE)+; force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g v.\n       \\<lbrakk>(G ===> (=)) \\<alpha>e \\<alpha>e2;\n        (G ===> (=)) \\<alpha>n \\<alpha>n2; (G ===> (=)) invar invar2;\n        (G ===> (=)) inEdges inEdges2;\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<exists>l0.\n               distinct l0 \\<and>\n               set (\\<alpha>n g) = set l0 \\<and>\n               foldli (rev (\\<alpha>n g)) = foldli l0);\n        \\<forall>g. invar g \\<longrightarrow> finite (\\<alpha>e g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           fst ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g) \\<and>\n           snd ` snd ` \\<alpha>e g \\<subseteq> set (\\<alpha>n g);\n        \\<forall>g.\n           invar g \\<longrightarrow>\n           (\\<forall>v.\n               \\<exists>l0.\n                  distinct l0 \\<and>\n                  pred\n                   \\<lparr>nodes = set (\\<alpha>n g),\n                      edges = \\<alpha>e g\\<rparr>\n                   v =\n                  set l0 \\<and>\n                  foldli (rev (inEdges g v)) = foldli l0);\n        invar2 g\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l0.\n                            distinct l0 \\<and>\n                            pred\n                             \\<lparr>nodes = set (\\<alpha>n2 g),\n                                edges = \\<alpha>e2 g\\<rparr>\n                             v =\n                            set l0 \\<and>\n                            foldli (rev (inEdges2 g v)) = foldli l0", "apply (rule_tac y=g in right_totalE [OF assms(1)]; (erule(1) rel_funE)+; force)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "context graph_path_base begin"], ["", "context includes lifting_syntax\nbegin"], ["", "lemma inEdges_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total A\"\n    and [transfer_rule]: \"(A ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(A ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(A ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(A ===> (=)) inEdges' inEdges2\"\n  shows \"(A ===> (=)) inEdges (graph_path_base.inEdges inEdges2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> (=)) inEdges (graph_path_base.inEdges inEdges2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (A ===> (=)) inEdges (graph_path_base.inEdges inEdges2)", "interpret gp2: graph_path_base \\<alpha>e2 \\<alpha>n2 invar2 inEdges2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. (A ===> (=)) inEdges gp2.inEdges", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> (=)) inEdges gp2.inEdges", "unfolding gp2.inEdges_def [abs_def] inEdges_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> (=))\n     (\\<lambda>g n. map (\\<lambda>(f, d). (f, d, n)) (inEdges' g n))\n     (\\<lambda>g n. map (\\<lambda>(f, d). (f, d, n)) (inEdges2 g n))", "by transfer_prover"], ["proof (state)\nthis:\n  (A ===> (=)) inEdges gp2.inEdges\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma predecessors_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total A\"\n    and [transfer_rule]: \"(A ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(A ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(A ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(A ===> (=)) inEdges' inEdges2\"\n  shows \"(A ===> (=)) predecessors (graph_path_base.predecessors inEdges2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> (=)) predecessors (graph_path_base.predecessors inEdges2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (A ===> (=)) predecessors (graph_path_base.predecessors inEdges2)", "interpret gp2: graph_path_base \\<alpha>e2 \\<alpha>n2 invar2 inEdges2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. (A ===> (=)) predecessors gp2.predecessors", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> (=)) predecessors gp2.predecessors", "unfolding gp2.predecessors_def [abs_def] predecessors_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> (=)) (\\<lambda>g n. map getFrom (inEdges g n))\n     (\\<lambda>g n. map getFrom (gp2.inEdges g n))", "by transfer_prover"], ["proof (state)\nthis:\n  (A ===> (=)) predecessors gp2.predecessors\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma successors_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total A\"\n    and [transfer_rule]: \"(A ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(A ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(A ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(A ===> (=)) inEdges' inEdges2\"\n  shows \"(A ===> (=)) successors (graph_path_base.successors \\<alpha>n2 inEdges2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> (=)) successors (graph_path_base.successors \\<alpha>n2 inEdges2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (A ===> (=)) successors (graph_path_base.successors \\<alpha>n2 inEdges2)", "interpret gp2: graph_path_base \\<alpha>e2 \\<alpha>n2 invar2 inEdges2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. (A ===> (=)) successors gp2.successors", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> (=)) successors gp2.successors", "unfolding gp2.successors_def [abs_def] successors_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> (=))\n     (\\<lambda>g m.\n         concat\n          (map (\\<lambda>n.\n                   if m \\<in> set (predecessors g n) then [n] else [])\n            (\\<alpha>n g)))\n     (\\<lambda>g m.\n         concat\n          (map (\\<lambda>n.\n                   if m \\<in> set (gp2.predecessors g n) then [n] else [])\n            (\\<alpha>n2 g)))", "by transfer_prover"], ["proof (state)\nthis:\n  (A ===> (=)) successors gp2.successors\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total A\"\n    and [transfer_rule]: \"(A ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(A ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(A ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(A ===> (=)) inEdges' inEdges2\"\n  shows \"(A ===> (=)) path (graph_path_base.path \\<alpha>n2 invar2 inEdges2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> (=)) local.path\n     (graph_path_base.path \\<alpha>n2 invar2 inEdges2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (A ===> (=)) local.path\n     (graph_path_base.path \\<alpha>n2 invar2 inEdges2)", "interpret gp2: graph_path_base \\<alpha>e2 \\<alpha>n2 invar2 inEdges2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. (A ===> (=)) local.path gp2.path", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> (=)) local.path gp2.path", "unfolding gp2.path_def path_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> (=))\n     (\\<lambda>g.\n         lfp (\\<lambda>p x.\n                 (\\<exists>n.\n                     x = [n] \\<and>\n                     n \\<in> set (\\<alpha>n g) \\<and> invar g) \\<or>\n                 (\\<exists>ns n'.\n                     x = n' # ns \\<and>\n                     p ns \\<and> n' \\<in> set (predecessors g (hd ns)))))\n     (\\<lambda>g.\n         lfp (\\<lambda>p x.\n                 (\\<exists>n.\n                     x = [n] \\<and>\n                     n \\<in> set (\\<alpha>n2 g) \\<and> invar2 g) \\<or>\n                 (\\<exists>ns n'.\n                     x = n' # ns \\<and>\n                     p ns \\<and>\n                     n' \\<in> set (gp2.predecessors g (hd ns)))))", "by transfer_prover"], ["proof (state)\nthis:\n  (A ===> (=)) local.path gp2.path\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path2_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total A\"\n    and [transfer_rule]: \"(A ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(A ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(A ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(A ===> (=)) inEdges' inEdges2\"\n  shows \"(A ===> (=)) path2 (graph_path_base.path2 \\<alpha>n2 invar2 inEdges2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> (=)) path2 (graph_path_base.path2 \\<alpha>n2 invar2 inEdges2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (A ===> (=)) path2 (graph_path_base.path2 \\<alpha>n2 invar2 inEdges2)", "interpret gp2: graph_path_base \\<alpha>e2 \\<alpha>n2 invar2 inEdges2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. (A ===> (=)) path2 gp2.path2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> (=)) path2 gp2.path2", "unfolding gp2.path2_def [abs_def] path2_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> (=))\n     (\\<lambda>g n ns m.\n         local.path g ns \\<and> n = hd ns \\<and> m = last ns)\n     (\\<lambda>g n ns m. gp2.path g ns \\<and> n = hd ns \\<and> m = last ns)", "by transfer_prover"], ["proof (state)\nthis:\n  (A ===> (=)) path2 gp2.path2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma weak_Ex_transfer [transfer_rule]: \"(((=) ===> (\\<longrightarrow>)) ===> (\\<longrightarrow>)) Ex Ex\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((=) ===> (\\<longrightarrow>)) ===> (\\<longrightarrow>)) Ex Ex", "by (auto elim: rel_funE)"], ["", "lemmas transfer_rules = inEdges_transfer predecessors_transfer successors_transfer path_transfer path2_transfer"], ["", "end"], ["", "end"], ["", "lemma graph_Entry_transfer [transfer_rule]:\n  includes lifting_syntax\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e1 \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n1 \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar1 invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges1 inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry1 Entry2\"\n  shows \"(\\<longrightarrow>) (graph_Entry \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1) (graph_Entry \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_Entry \\<alpha>e1 \\<alpha>n1 invar1 inEdges1\n     Entry1 \\<longrightarrow>\n    graph_Entry \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. graph_Entry \\<alpha>e1 \\<alpha>n1 invar1 inEdges1\n     Entry1 \\<longrightarrow>\n    graph_Entry \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. graph_Entry \\<alpha>e1 \\<alpha>n1 invar1 inEdges1\n     Entry1 \\<longrightarrow>\n    graph_Entry \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2", "assume a: \"graph_path \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 \\<and> graph_Entry_axioms \\<alpha>n1 invar1 inEdges1 Entry1\""], ["proof (state)\nthis:\n  graph_path \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 \\<and>\n  graph_Entry_axioms \\<alpha>n1 invar1 inEdges1 Entry1\n\ngoal (1 subgoal):\n 1. graph_Entry \\<alpha>e1 \\<alpha>n1 invar1 inEdges1\n     Entry1 \\<longrightarrow>\n    graph_Entry \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2", "then"], ["proof (chain)\npicking this:\n  graph_path \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 \\<and>\n  graph_Entry_axioms \\<alpha>n1 invar1 inEdges1 Entry1", "interpret graph_path \\<alpha>e1 \\<alpha>n1 invar1 inEdges1"], ["proof (prove)\nusing this:\n  graph_path \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 \\<and>\n  graph_Entry_axioms \\<alpha>n1 invar1 inEdges1 Entry1\n\ngoal (1 subgoal):\n 1. graph_path \\<alpha>e1 \\<alpha>n1 invar1 inEdges1", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. graph_Entry \\<alpha>e1 \\<alpha>n1 invar1 inEdges1\n     Entry1 \\<longrightarrow>\n    graph_Entry \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2", "have ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_Entry \\<alpha>e1 \\<alpha>n1 invar1 inEdges1\n     Entry1 \\<longrightarrow>\n    graph_Entry \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2", "unfolding graph_Entry_def [abs_def] graph_Entry_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_path \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 \\<and>\n    (\\<forall>g. Entry1 g \\<in> set (\\<alpha>n1 g)) \\<and>\n    (\\<forall>g.\n        invar1 g \\<longrightarrow> inEdges g (Entry1 g) = []) \\<and>\n    (\\<forall>n g.\n        n \\<in> set (\\<alpha>n1 g) \\<longrightarrow>\n        invar1 g \\<longrightarrow>\n        (\\<exists>ns. path2 g (Entry1 g) ns n)) \\<longrightarrow>\n    graph_path \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 \\<and>\n    (\\<forall>g. Entry2 g \\<in> set (\\<alpha>n2 g)) \\<and>\n    (\\<forall>g.\n        invar2 g \\<longrightarrow>\n        graph_path_base.inEdges inEdges2 g (Entry2 g) = []) \\<and>\n    (\\<forall>n g.\n        n \\<in> set (\\<alpha>n2 g) \\<longrightarrow>\n        invar2 g \\<longrightarrow>\n        (\\<exists>ns.\n            graph_path_base.path2 \\<alpha>n2 invar2 inEdges2 g (Entry2 g) ns\n             n))", "by transfer_prover"], ["proof (state)\nthis:\n  graph_Entry \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 \\<longrightarrow>\n  graph_Entry \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2\n\ngoal (1 subgoal):\n 1. graph_Entry \\<alpha>e1 \\<alpha>n1 invar1 inEdges1\n     Entry1 \\<longrightarrow>\n    graph_Entry \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2", "}"], ["proof (state)\nthis:\n  graph_path \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 \\<and>\n  graph_Entry_axioms \\<alpha>n1 invar1 inEdges1 Entry1 \\<Longrightarrow>\n  graph_Entry \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 \\<longrightarrow>\n  graph_Entry \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2\n\ngoal (1 subgoal):\n 1. graph_Entry \\<alpha>e1 \\<alpha>n1 invar1 inEdges1\n     Entry1 \\<longrightarrow>\n    graph_Entry \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2", "thus ?thesis"], ["proof (prove)\nusing this:\n  graph_path \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 \\<and>\n  graph_Entry_axioms \\<alpha>n1 invar1 inEdges1 Entry1 \\<Longrightarrow>\n  graph_Entry \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 \\<longrightarrow>\n  graph_Entry \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2\n\ngoal (1 subgoal):\n 1. graph_Entry \\<alpha>e1 \\<alpha>n1 invar1 inEdges1\n     Entry1 \\<longrightarrow>\n    graph_Entry \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2", "unfolding graph_Entry_def [abs_def]"], ["proof (prove)\nusing this:\n  graph_path \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 \\<and>\n  graph_Entry_axioms \\<alpha>n1 invar1 inEdges1 Entry1 \\<Longrightarrow>\n  graph_path \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 \\<and>\n  graph_Entry_axioms \\<alpha>n1 invar1 inEdges1 Entry1 \\<longrightarrow>\n  graph_path \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 \\<and>\n  graph_Entry_axioms \\<alpha>n2 invar2 inEdges2 Entry2\n\ngoal (1 subgoal):\n 1. graph_path \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 \\<and>\n    graph_Entry_axioms \\<alpha>n1 invar1 inEdges1 Entry1 \\<longrightarrow>\n    graph_path \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 \\<and>\n    graph_Entry_axioms \\<alpha>n2 invar2 inEdges2 Entry2", "by simp"], ["proof (state)\nthis:\n  graph_Entry \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 \\<longrightarrow>\n  graph_Entry \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2\n\ngoal:\nNo subgoals!", "qed"], ["", "context graph_Entry_base begin"], ["", "lemma dominates_transfer [transfer_rule]:\n  includes lifting_syntax\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n  shows \"(G ===> (=)) dominates (graph_Entry_base.dominates \\<alpha>n2 invar2 inEdges2 Entry2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) dominates\n     (graph_Entry_base.dominates \\<alpha>n2 invar2 inEdges2 Entry2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) dominates\n     (graph_Entry_base.dominates \\<alpha>n2 invar2 inEdges2 Entry2)", "interpret gE2: graph_Entry_base \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) dominates gE2.dominates", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) dominates gE2.dominates", "unfolding dominates_def [abs_def] gE2.dominates_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=))\n     (\\<lambda>g n m.\n         m \\<in> set (\\<alpha>n g) \\<and>\n         (\\<forall>ns.\n             g \\<turnstile> Entry g-ns\\<rightarrow>m \\<longrightarrow>\n             n \\<in> set ns))\n     (\\<lambda>g n m.\n         m \\<in> set (\\<alpha>n2 g) \\<and>\n         (\\<forall>ns.\n             gE2.path2 g (Entry2 g) ns m \\<longrightarrow> n \\<in> set ns))", "by transfer_prover"], ["proof (state)\nthis:\n  (G ===> (=)) dominates gE2.dominates\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context graph_Entry begin"], ["", "context includes lifting_syntax\nbegin"], ["", "lemma shortestPath_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n  shows \"(G ===> (=)) shortestPath (graph_Entry.shortestPath \\<alpha>n2 invar2 inEdges2 Entry2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) shortestPath\n     (graph_Entry.shortestPath \\<alpha>n2 invar2 inEdges2 Entry2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) shortestPath\n     (graph_Entry.shortestPath \\<alpha>n2 invar2 inEdges2 Entry2)", "interpret gE2: graph_Entry \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2"], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_Entry \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2", "by transfer' unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) shortestPath gE2.shortestPath", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) shortestPath gE2.shortestPath", "unfolding shortestPath_def [abs_def] gE2.shortestPath_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=))\n     (\\<lambda>g n.\n         LEAST l.\n            \\<exists>ns.\n               length ns = l \\<and> g \\<turnstile> Entry g-ns\\<rightarrow>n)\n     (\\<lambda>g n.\n         LEAST l.\n            \\<exists>ns. length ns = l \\<and> gE2.path2 g (Entry2 g) ns n)", "by transfer_prover"], ["proof (state)\nthis:\n  (G ===> (=)) shortestPath gE2.shortestPath\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dominators_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n  shows \"(G ===> (=)) dominators (graph_Entry.dominators \\<alpha>n2 invar2 inEdges2 Entry2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) dominators\n     (graph_Entry.dominators \\<alpha>n2 invar2 inEdges2 Entry2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) dominators\n     (graph_Entry.dominators \\<alpha>n2 invar2 inEdges2 Entry2)", "interpret gE2: graph_Entry \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2"], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_Entry \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2", "by transfer' unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) dominators gE2.dominators", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) dominators gE2.dominators", "unfolding dominators_def [abs_def] gE2.dominators_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=))\n     (\\<lambda>g n. {m \\<in> set (\\<alpha>n g). dominates g m n})\n     (\\<lambda>g n. {m \\<in> set (\\<alpha>n2 g). gE2.dominates g m n})", "by transfer_prover"], ["proof (state)\nthis:\n  (G ===> (=)) dominators gE2.dominators\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isIdom_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n  shows \"(G ===> (=)) isIdom (graph_Entry.isIdom \\<alpha>n2 invar2 inEdges2 Entry2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) isIdom\n     (graph_Entry.isIdom \\<alpha>n2 invar2 inEdges2 Entry2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) isIdom\n     (graph_Entry.isIdom \\<alpha>n2 invar2 inEdges2 Entry2)", "interpret gE2: graph_Entry \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2"], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_Entry \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2", "by transfer' unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) isIdom gE2.isIdom", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) isIdom gE2.isIdom", "unfolding isIdom_def [abs_def] gE2.isIdom_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=))\n     (\\<lambda>g n m.\n         (m \\<noteq> n \\<and> dominates g m n) \\<and>\n         (\\<forall>m'\\<in>set (\\<alpha>n g).\n             m' \\<noteq> n \\<and> dominates g m' n \\<longrightarrow>\n             dominates g m' m))\n     (\\<lambda>g n m.\n         (m \\<noteq> n \\<and> gE2.dominates g m n) \\<and>\n         (\\<forall>m'\\<in>set (\\<alpha>n2 g).\n             m' \\<noteq> n \\<and> gE2.dominates g m' n \\<longrightarrow>\n             gE2.dominates g m' m))", "by transfer_prover"], ["proof (state)\nthis:\n  (G ===> (=)) isIdom gE2.isIdom\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma idom_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n  shows \"(G ===> (=)) idom (graph_Entry.idom \\<alpha>n2 invar2 inEdges2 Entry2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) idom (graph_Entry.idom \\<alpha>n2 invar2 inEdges2 Entry2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) idom (graph_Entry.idom \\<alpha>n2 invar2 inEdges2 Entry2)", "interpret gE2: graph_Entry \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2"], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_Entry \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2", "by transfer' unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) idom gE2.idom", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) idom gE2.idom", "unfolding idom_def [abs_def] gE2.idom_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) (\\<lambda>g n. THE m. isIdom g n m)\n     (\\<lambda>g n. THE m. gE2.isIdom g n m)", "by transfer_prover"], ["proof (state)\nthis:\n  (G ===> (=)) idom gE2.idom\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas graph_Entry_transfer =\n  dominates_transfer\n  shortestPath_transfer\n  dominators_transfer\n  isIdom_transfer\n  idom_transfer"], ["", "end"], ["", "end"], ["", "lemma CFG_transfer [transfer_rule]:\n  includes lifting_syntax\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e1 \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n1 \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar1 invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges1 inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry1 Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs1 defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses1 uses2\"\n  shows \"SSA_CFG.CFG \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1\n    \\<longrightarrow> SSA_CFG.CFG \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1\n     uses1 \\<longrightarrow>\n    CFG \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2", "unfolding SSA_CFG.CFG_def [abs_def] CFG_axioms_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_Entry \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 \\<and>\n    ((\\<forall>n g.\n         n \\<in> set (\\<alpha>n1 g) \\<longrightarrow>\n         defs1 g n \\<inter> uses1 g n = {}) \\<and>\n     (\\<forall>g n. finite (defs1 g n))) \\<and>\n    (\\<forall>v g n.\n        v \\<in> uses1 g n \\<longrightarrow>\n        n \\<in> set (\\<alpha>n1 g)) \\<and>\n    (\\<forall>g n. finite (uses1 g n)) \\<and> All invar1 \\<longrightarrow>\n    graph_Entry \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 \\<and>\n    ((\\<forall>n g.\n         n \\<in> set (\\<alpha>n2 g) \\<longrightarrow>\n         defs2 g n \\<inter> uses2 g n = {}) \\<and>\n     (\\<forall>g n. finite (defs2 g n))) \\<and>\n    (\\<forall>v g n.\n        v \\<in> uses2 g n \\<longrightarrow>\n        n \\<in> set (\\<alpha>n2 g)) \\<and>\n    (\\<forall>g n. finite (uses2 g n)) \\<and> All invar2", "by transfer_prover"], ["", "context CFG_base begin"], ["", "context includes lifting_syntax\nbegin"], ["", "lemma vars_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses uses2\"\n  shows \"(G ===> (=)) vars (CFG_base.vars \\<alpha>n2 uses2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) vars (CFG_base.vars \\<alpha>n2 uses2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) vars (CFG_base.vars \\<alpha>n2 uses2)", "interpret CFG_base2: CFG_base \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) vars CFG_base2.vars", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) vars CFG_base2.vars", "unfolding vars_def [abs_def] CFG_base2.vars_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=))\n     (\\<lambda>g. fold (\\<union>) (map (uses g) (\\<alpha>n g)) {})\n     (\\<lambda>g. fold (\\<union>) (map (uses2 g) (\\<alpha>n2 g)) {})", "by transfer_prover"], ["proof (state)\nthis:\n  (G ===> (=)) vars CFG_base2.vars\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma defAss'_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses uses2\"\n  shows \"(G ===> (=)) defAss' (CFG_base.defAss' \\<alpha>n2 invar2 inEdges2 Entry2 defs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) defAss'\n     (CFG_base.defAss' \\<alpha>n2 invar2 inEdges2 Entry2 defs2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) defAss'\n     (CFG_base.defAss' \\<alpha>n2 invar2 inEdges2 Entry2 defs2)", "interpret CFG2: CFG_base \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) defAss' CFG2.defAss'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) defAss' CFG2.defAss'", "unfolding defAss'_def [abs_def] CFG2.defAss'_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=))\n     (\\<lambda>g m v.\n         \\<forall>ns.\n            g \\<turnstile> Entry g-ns\\<rightarrow>m \\<longrightarrow>\n            (\\<exists>n\\<in>set ns. v \\<in> defs g n))\n     (\\<lambda>g m v.\n         \\<forall>ns.\n            CFG2.path2 g (Entry2 g) ns m \\<longrightarrow>\n            (\\<exists>n\\<in>set ns. v \\<in> defs2 g n))", "by transfer_prover"], ["proof (state)\nthis:\n  (G ===> (=)) defAss' CFG2.defAss'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma defAss'Uses_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses uses2\"\n  shows \"(G ===> (=)) defAss'Uses (CFG_base.defAss'Uses \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) defAss'Uses\n     (CFG_base.defAss'Uses \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) defAss'Uses\n     (CFG_base.defAss'Uses \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2)", "interpret CFG2: CFG_base \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) defAss'Uses CFG2.defAss'Uses", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) defAss'Uses CFG2.defAss'Uses", "unfolding defAss'Uses_def [abs_def] CFG2.defAss'Uses_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=))\n     (\\<lambda>g.\n         \\<forall>m\\<in>set (\\<alpha>n g).\n            \\<forall>v\\<in>uses g m. defAss' g m v)\n     (\\<lambda>g.\n         \\<forall>m\\<in>set (\\<alpha>n2 g).\n            \\<forall>v\\<in>uses2 g m. CFG2.defAss' g m v)", "by transfer_prover"], ["proof (state)\nthis:\n  (G ===> (=)) defAss'Uses CFG2.defAss'Uses\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas CFG_transfers =\n  vars_transfer\n  defAss'_transfer\n  defAss'Uses_transfer"], ["", "end"], ["", "end"], ["", "context includes lifting_syntax\nbegin"], ["", "lemma CFG_Construct_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e1 \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n1 \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar1 invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges1 inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry1 Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs1 defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses1 uses2\"\n  shows \"CFG_Construct \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1\n    \\<longrightarrow> CFG_Construct \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_Construct \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1\n     uses1 \\<longrightarrow>\n    CFG_Construct \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2", "unfolding CFG_Construct_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1\n     uses1 \\<longrightarrow>\n    CFG \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2", "by transfer_prover"], ["", "lemma CFG_Construct_linorder_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e1 \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n1 \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar1 invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges1 inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry1 Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs1 defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses1 uses2\"\n  shows \"CFG_Construct_linorder \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1\n    \\<longrightarrow> CFG_Construct_linorder \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_Construct_linorder \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1\n     defs1 uses1 \\<longrightarrow>\n    CFG_Construct_linorder \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2\n     defs2 uses2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG_Construct_linorder \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1\n     defs1 uses1 \\<longrightarrow>\n    CFG_Construct_linorder \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2\n     defs2 uses2", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG_Construct_linorder \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1\n     defs1 uses1 \\<longrightarrow>\n    CFG_Construct_linorder \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2\n     defs2 uses2", "assume \"CFG_Construct_linorder \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1\""], ["proof (state)\nthis:\n  CFG_Construct_linorder \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1\n   uses1\n\ngoal (1 subgoal):\n 1. CFG_Construct_linorder \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1\n     defs1 uses1 \\<longrightarrow>\n    CFG_Construct_linorder \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2\n     defs2 uses2", "then"], ["proof (chain)\npicking this:\n  CFG_Construct_linorder \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1\n   uses1", "interpret CFG_Construct_linorder \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1"], ["proof (prove)\nusing this:\n  CFG_Construct_linorder \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1\n   uses1\n\ngoal (1 subgoal):\n 1. CFG_Construct_linorder \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1\n     defs1 uses1", "."], ["proof (state)\ngoal (1 subgoal):\n 1. CFG_Construct_linorder \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1\n     defs1 uses1 \\<longrightarrow>\n    CFG_Construct_linorder \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2\n     defs2 uses2", "have ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_Construct_linorder \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1\n     defs1 uses1 \\<longrightarrow>\n    CFG_Construct_linorder \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2\n     defs2 uses2", "unfolding CFG_Construct_linorder_def CFG_Construct_wf_def CFG_wf_def CFG_wf_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_Construct \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1\n     uses1 \\<and>\n    CFG \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1 \\<and>\n    (\\<forall>g.\n        \\<forall>m\\<in>set (\\<alpha>n1 g).\n           \\<forall>v\\<in>uses1 g m. defAss' g m v) \\<longrightarrow>\n    CFG_Construct \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2\n     uses2 \\<and>\n    CFG \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2 \\<and>\n    (\\<forall>g.\n        \\<forall>m\\<in>set (\\<alpha>n2 g).\n           \\<forall>v\\<in>uses2 g m.\n              CFG_base.defAss' \\<alpha>n2 invar2 inEdges2 Entry2 defs2 g m\n               v)", "by transfer_prover"], ["proof (state)\nthis:\n  CFG_Construct_linorder \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1\n   uses1 \\<longrightarrow>\n  CFG_Construct_linorder \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2\n   uses2\n\ngoal (1 subgoal):\n 1. CFG_Construct_linorder \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1\n     defs1 uses1 \\<longrightarrow>\n    CFG_Construct_linorder \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2\n     defs2 uses2", "}"], ["proof (state)\nthis:\n  CFG_Construct_linorder \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1\n   uses1 \\<Longrightarrow>\n  CFG_Construct_linorder \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1\n   uses1 \\<longrightarrow>\n  CFG_Construct_linorder \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2\n   uses2\n\ngoal (1 subgoal):\n 1. CFG_Construct_linorder \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1\n     defs1 uses1 \\<longrightarrow>\n    CFG_Construct_linorder \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2\n     defs2 uses2", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFG_Construct_linorder \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1\n   uses1 \\<Longrightarrow>\n  CFG_Construct_linorder \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1\n   uses1 \\<longrightarrow>\n  CFG_Construct_linorder \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2\n   uses2\n\ngoal (1 subgoal):\n 1. CFG_Construct_linorder \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1\n     defs1 uses1 \\<longrightarrow>\n    CFG_Construct_linorder \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2\n     defs2 uses2", "by simp"], ["proof (state)\nthis:\n  CFG_Construct_linorder \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1\n   uses1 \\<longrightarrow>\n  CFG_Construct_linorder \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2\n   uses2\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context CFG_Construct begin"], ["", "context includes lifting_syntax\nbegin"], ["", "lemma phiDefNodes_aux_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses uses2\"\n  shows \"(G ===> (=)) phiDefNodes_aux (CFG_Construct.phiDefNodes_aux inEdges2 defs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) phiDefNodes_aux\n     (CFG_Construct.phiDefNodes_aux inEdges2 defs2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) phiDefNodes_aux\n     (CFG_Construct.phiDefNodes_aux inEdges2 defs2)", "interpret i: CFG_Construct \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_Construct \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2", "by transfer' unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) phiDefNodes_aux i.phiDefNodes_aux", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) phiDefNodes_aux i.phiDefNodes_aux", "fix g1 g2 v unvisited n"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) phiDefNodes_aux i.phiDefNodes_aux", "assume \"G g1 g2\""], ["proof (state)\nthis:\n  G g1 g2\n\ngoal (1 subgoal):\n 1. (G ===> (=)) phiDefNodes_aux i.phiDefNodes_aux", "with assms"], ["proof (chain)\npicking this:\n  right_total G\n  (G ===> (=)) \\<alpha>e \\<alpha>e2\n  (G ===> (=)) \\<alpha>n \\<alpha>n2\n  (G ===> (=)) invar invar2\n  (G ===> (=)) inEdges' inEdges2\n  (G ===> (=)) Entry Entry2\n  (G ===> (=)) defs defs2\n  (G ===> (=)) uses uses2\n  G g1 g2", "have \"inEdges2 g2 = inEdges' g1\" and \"defs2 g2 = defs g1\""], ["proof (prove)\nusing this:\n  right_total G\n  (G ===> (=)) \\<alpha>e \\<alpha>e2\n  (G ===> (=)) \\<alpha>n \\<alpha>n2\n  (G ===> (=)) invar invar2\n  (G ===> (=)) inEdges' inEdges2\n  (G ===> (=)) Entry Entry2\n  (G ===> (=)) defs defs2\n  (G ===> (=)) uses uses2\n  G g1 g2\n\ngoal (1 subgoal):\n 1. inEdges2 g2 = inEdges' g1 &&& defs2 g2 = defs g1", "by (auto elim: rel_funE)"], ["proof (state)\nthis:\n  inEdges2 g2 = inEdges' g1\n  defs2 g2 = defs g1\n\ngoal (1 subgoal):\n 1. (G ===> (=)) phiDefNodes_aux i.phiDefNodes_aux", "hence \"phiDefNodes_aux g1 v unvisited n = CFG_Construct.phiDefNodes_aux inEdges2 defs2 g2 v unvisited n\""], ["proof (prove)\nusing this:\n  inEdges2 g2 = inEdges' g1\n  defs2 g2 = defs g1\n\ngoal (1 subgoal):\n 1. phiDefNodes_aux g1 v unvisited n = i.phiDefNodes_aux g2 v unvisited n", "apply (induction g1 v unvisited n rule: phiDefNodes_aux.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g v unvisited n.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> (n \\<notin> set unvisited \\<or>\n                                    v \\<in> defs g n);\n                    x \\<in> set (predecessors g n);\n                    inEdges2 g2 = inEdges' g; defs2 g2 = defs g\\<rbrakk>\n                   \\<Longrightarrow> phiDefNodes_aux g v\n(removeAll n unvisited) x =\n                                     i.phiDefNodes_aux g2 v\n(removeAll n unvisited) x;\n        inEdges2 g2 = inEdges' g; defs2 g2 = defs g\\<rbrakk>\n       \\<Longrightarrow> phiDefNodes_aux g v unvisited n =\n                         i.phiDefNodes_aux g2 v unvisited n", "apply (subst phiDefNodes_aux.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g v unvisited n.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> (n \\<notin> set unvisited \\<or>\n                                    v \\<in> defs g n);\n                    x \\<in> set (predecessors g n);\n                    inEdges2 g2 = inEdges' g; defs2 g2 = defs g\\<rbrakk>\n                   \\<Longrightarrow> phiDefNodes_aux g v\n(removeAll n unvisited) x =\n                                     i.phiDefNodes_aux g2 v\n(removeAll n unvisited) x;\n        inEdges2 g2 = inEdges' g; defs2 g2 = defs g\\<rbrakk>\n       \\<Longrightarrow> (if n \\<notin> set unvisited \\<or> v \\<in> defs g n\n                          then {}\n                          else fold (\\<union>)\n                                (map (phiDefNodes_aux g v\n (removeAll n unvisited))\n                                  (predecessors g n))\n                                (if length (predecessors g n) \\<noteq> 1\n                                 then {n} else {})) =\n                         i.phiDefNodes_aux g2 v unvisited n", "apply (subst i.phiDefNodes_aux.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g v unvisited n.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> (n \\<notin> set unvisited \\<or>\n                                    v \\<in> defs g n);\n                    x \\<in> set (predecessors g n);\n                    inEdges2 g2 = inEdges' g; defs2 g2 = defs g\\<rbrakk>\n                   \\<Longrightarrow> phiDefNodes_aux g v\n(removeAll n unvisited) x =\n                                     i.phiDefNodes_aux g2 v\n(removeAll n unvisited) x;\n        inEdges2 g2 = inEdges' g; defs2 g2 = defs g\\<rbrakk>\n       \\<Longrightarrow> (if n \\<notin> set unvisited \\<or> v \\<in> defs g n\n                          then {}\n                          else fold (\\<union>)\n                                (map (phiDefNodes_aux g v\n (removeAll n unvisited))\n                                  (predecessors g n))\n                                (if length (predecessors g n) \\<noteq> 1\n                                 then {n} else {})) =\n                         (if n \\<notin> set unvisited \\<or>\n                             v \\<in> defs2 g2 n\n                          then {}\n                          else fold (\\<union>)\n                                (map (i.phiDefNodes_aux g2 v\n (removeAll n unvisited))\n                                  (i.predecessors g2 n))\n                                (if length (i.predecessors g2 n) \\<noteq> 1\n                                 then {n} else {}))", "apply (subgoal_tac \"i.predecessors g2 n = predecessors g n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>g v unvisited n.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> (n \\<notin> set unvisited \\<or>\n                                    v \\<in> defs g n);\n                    x \\<in> set (predecessors g n);\n                    inEdges2 g2 = inEdges' g; defs2 g2 = defs g\\<rbrakk>\n                   \\<Longrightarrow> phiDefNodes_aux g v\n(removeAll n unvisited) x =\n                                     i.phiDefNodes_aux g2 v\n(removeAll n unvisited) x;\n        inEdges2 g2 = inEdges' g; defs2 g2 = defs g;\n        i.predecessors g2 n = predecessors g n\\<rbrakk>\n       \\<Longrightarrow> (if n \\<notin> set unvisited \\<or> v \\<in> defs g n\n                          then {}\n                          else fold (\\<union>)\n                                (map (phiDefNodes_aux g v\n (removeAll n unvisited))\n                                  (predecessors g n))\n                                (if length (predecessors g n) \\<noteq> 1\n                                 then {n} else {})) =\n                         (if n \\<notin> set unvisited \\<or>\n                             v \\<in> defs2 g2 n\n                          then {}\n                          else fold (\\<union>)\n                                (map (i.phiDefNodes_aux g2 v\n (removeAll n unvisited))\n                                  (i.predecessors g2 n))\n                                (if length (i.predecessors g2 n) \\<noteq> 1\n                                 then {n} else {}))\n 2. \\<And>g v unvisited n.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> (n \\<notin> set unvisited \\<or>\n                                    v \\<in> defs g n);\n                    x \\<in> set (predecessors g n);\n                    inEdges2 g2 = inEdges' g; defs2 g2 = defs g\\<rbrakk>\n                   \\<Longrightarrow> phiDefNodes_aux g v\n(removeAll n unvisited) x =\n                                     i.phiDefNodes_aux g2 v\n(removeAll n unvisited) x;\n        inEdges2 g2 = inEdges' g; defs2 g2 = defs g\\<rbrakk>\n       \\<Longrightarrow> i.predecessors g2 n = predecessors g n", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>g v unvisited n.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> (n \\<notin> set unvisited \\<or>\n                                    v \\<in> defs g n);\n                    x \\<in> set (predecessors g n);\n                    inEdges2 g2 = inEdges' g; defs2 g2 = defs g\\<rbrakk>\n                   \\<Longrightarrow> phiDefNodes_aux g v\n(removeAll n unvisited) x =\n                                     i.phiDefNodes_aux g2 v\n(removeAll n unvisited) x;\n        inEdges2 g2 = inEdges' g; defs2 g2 = defs g\\<rbrakk>\n       \\<Longrightarrow> i.predecessors g2 n = predecessors g n\n 2. \\<And>g v unvisited n.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> (n \\<notin> set unvisited \\<or>\n                                    v \\<in> defs g n);\n                    x \\<in> set (predecessors g n);\n                    inEdges2 g2 = inEdges' g; defs2 g2 = defs g\\<rbrakk>\n                   \\<Longrightarrow> phiDefNodes_aux g v\n(removeAll n unvisited) x =\n                                     i.phiDefNodes_aux g2 v\n(removeAll n unvisited) x;\n        inEdges2 g2 = inEdges' g; defs2 g2 = defs g;\n        i.predecessors g2 n = predecessors g n\\<rbrakk>\n       \\<Longrightarrow> (if n \\<notin> set unvisited \\<or> v \\<in> defs g n\n                          then {}\n                          else fold (\\<union>)\n                                (map (phiDefNodes_aux g v\n (removeAll n unvisited))\n                                  (predecessors g n))\n                                (if length (predecessors g n) \\<noteq> 1\n                                 then {n} else {})) =\n                         (if n \\<notin> set unvisited \\<or>\n                             v \\<in> defs2 g2 n\n                          then {}\n                          else fold (\\<union>)\n                                (map (i.phiDefNodes_aux g2 v\n (removeAll n unvisited))\n                                  (i.predecessors g2 n))\n                                (if length (i.predecessors g2 n) \\<noteq> 1\n                                 then {n} else {}))", "apply (clarsimp simp: i.predecessors_def predecessors_def i.inEdges_def inEdges_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g v unvisited n.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>\\<not> (n \\<notin> set unvisited \\<or>\n                                    v \\<in> defs g n);\n                    x \\<in> set (predecessors g n);\n                    inEdges2 g2 = inEdges' g; defs2 g2 = defs g\\<rbrakk>\n                   \\<Longrightarrow> phiDefNodes_aux g v\n(removeAll n unvisited) x =\n                                     i.phiDefNodes_aux g2 v\n(removeAll n unvisited) x;\n        inEdges2 g2 = inEdges' g; defs2 g2 = defs g;\n        i.predecessors g2 n = predecessors g n\\<rbrakk>\n       \\<Longrightarrow> (if n \\<notin> set unvisited \\<or> v \\<in> defs g n\n                          then {}\n                          else fold (\\<union>)\n                                (map (phiDefNodes_aux g v\n (removeAll n unvisited))\n                                  (predecessors g n))\n                                (if length (predecessors g n) \\<noteq> 1\n                                 then {n} else {})) =\n                         (if n \\<notin> set unvisited \\<or>\n                             v \\<in> defs2 g2 n\n                          then {}\n                          else fold (\\<union>)\n                                (map (i.phiDefNodes_aux g2 v\n (removeAll n unvisited))\n                                  (i.predecessors g2 n))\n                                (if length (i.predecessors g2 n) \\<noteq> 1\n                                 then {n} else {}))", "by (simp cong: if_cong arg_cong2 [where f=\"fold (\\<union>)\"] map_cong)"], ["proof (state)\nthis:\n  phiDefNodes_aux g1 v unvisited n = i.phiDefNodes_aux g2 v unvisited n\n\ngoal (1 subgoal):\n 1. (G ===> (=)) phiDefNodes_aux i.phiDefNodes_aux", "}"], ["proof (state)\nthis:\n  G ?g1.3 ?g2.3 \\<Longrightarrow>\n  phiDefNodes_aux ?g1.3 ?v3 ?unvisited3 ?n3 =\n  i.phiDefNodes_aux ?g2.3 ?v3 ?unvisited3 ?n3\n\ngoal (1 subgoal):\n 1. (G ===> (=)) phiDefNodes_aux i.phiDefNodes_aux", "thus ?thesis"], ["proof (prove)\nusing this:\n  G ?g1.3 ?g2.3 \\<Longrightarrow>\n  phiDefNodes_aux ?g1.3 ?v3 ?unvisited3 ?n3 =\n  i.phiDefNodes_aux ?g2.3 ?v3 ?unvisited3 ?n3\n\ngoal (1 subgoal):\n 1. (G ===> (=)) phiDefNodes_aux i.phiDefNodes_aux", "by blast"], ["proof (state)\nthis:\n  (G ===> (=)) phiDefNodes_aux i.phiDefNodes_aux\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma phiDefNodes_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses uses2\"\n  shows \"(G ===> (=)) phiDefNodes (CFG_Construct.phiDefNodes \\<alpha>n2 inEdges2 defs2 uses2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) phiDefNodes\n     (CFG_Construct.phiDefNodes \\<alpha>n2 inEdges2 defs2 uses2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) phiDefNodes\n     (CFG_Construct.phiDefNodes \\<alpha>n2 inEdges2 defs2 uses2)", "interpret i: CFG_Construct \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_Construct \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2", "by transfer' unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) phiDefNodes i.phiDefNodes", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) phiDefNodes i.phiDefNodes", "unfolding phiDefNodes_def [abs_def] i.phiDefNodes_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=))\n     (\\<lambda>g v.\n         fold (\\<union>)\n          (concat\n            (map (\\<lambda>n.\n                     if v \\<in> uses g n\n                     then [phiDefNodes_aux g v (\\<alpha>n g) n] else [])\n              (\\<alpha>n g)))\n          {})\n     (\\<lambda>g v.\n         fold (\\<union>)\n          (concat\n            (map (\\<lambda>n.\n                     if v \\<in> uses2 g n\n                     then [i.phiDefNodes_aux g v (\\<alpha>n2 g) n] else [])\n              (\\<alpha>n2 g)))\n          {})", "by transfer_prover"], ["proof (state)\nthis:\n  (G ===> (=)) phiDefNodes i.phiDefNodes\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookupDef_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses uses2\"\n  shows \"(G ===> (=)) lookupDef (CFG_Construct.lookupDef \\<alpha>n2 inEdges2 defs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) lookupDef\n     (CFG_Construct.lookupDef \\<alpha>n2 inEdges2 defs2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) lookupDef\n     (CFG_Construct.lookupDef \\<alpha>n2 inEdges2 defs2)", "interpret i: CFG_Construct \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_Construct \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2", "by transfer' unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) lookupDef i.lookupDef", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) lookupDef i.lookupDef", "fix g g2 n v"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) lookupDef i.lookupDef", "assume \"G g g2\""], ["proof (state)\nthis:\n  G g g2\n\ngoal (1 subgoal):\n 1. (G ===> (=)) lookupDef i.lookupDef", "with assms"], ["proof (chain)\npicking this:\n  right_total G\n  (G ===> (=)) \\<alpha>e \\<alpha>e2\n  (G ===> (=)) \\<alpha>n \\<alpha>n2\n  (G ===> (=)) invar invar2\n  (G ===> (=)) inEdges' inEdges2\n  (G ===> (=)) Entry Entry2\n  (G ===> (=)) defs defs2\n  (G ===> (=)) uses uses2\n  G g g2", "have \"\\<alpha>n2 g2 = \\<alpha>n g\" and \"inEdges2 g2 = inEdges' g\" and \"defs2 g2 = defs g\""], ["proof (prove)\nusing this:\n  right_total G\n  (G ===> (=)) \\<alpha>e \\<alpha>e2\n  (G ===> (=)) \\<alpha>n \\<alpha>n2\n  (G ===> (=)) invar invar2\n  (G ===> (=)) inEdges' inEdges2\n  (G ===> (=)) Entry Entry2\n  (G ===> (=)) defs defs2\n  (G ===> (=)) uses uses2\n  G g g2\n\ngoal (1 subgoal):\n 1. \\<alpha>n2 g2 = \\<alpha>n g &&&\n    inEdges2 g2 = inEdges' g &&& defs2 g2 = defs g", "by (auto elim: rel_funE)"], ["proof (state)\nthis:\n  \\<alpha>n2 g2 = \\<alpha>n g\n  inEdges2 g2 = inEdges' g\n  defs2 g2 = defs g\n\ngoal (1 subgoal):\n 1. (G ===> (=)) lookupDef i.lookupDef", "hence \"lookupDef g n v = i.lookupDef g2 n v\""], ["proof (prove)\nusing this:\n  \\<alpha>n2 g2 = \\<alpha>n g\n  inEdges2 g2 = inEdges' g\n  defs2 g2 = defs g\n\ngoal (1 subgoal):\n 1. lookupDef g n v = i.lookupDef g2 n v", "apply (induction g n v rule: lookupDef.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g n v.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>\\<not> n \\<notin> set (\\<alpha>n g);\n                    v \\<notin> defs g n; predecessors g n = x21 # x22;\n                    x22 = []; \\<alpha>n2 g2 = \\<alpha>n g;\n                    inEdges2 g2 = inEdges' g; defs2 g2 = defs g\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g x21 v =\n                                     i.lookupDef g2 x21 v;\n        \\<alpha>n2 g2 = \\<alpha>n g; inEdges2 g2 = inEdges' g;\n        defs2 g2 = defs g\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n v = i.lookupDef g2 n v", "apply (subst lookupDef.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g n v.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>\\<not> n \\<notin> set (\\<alpha>n g);\n                    v \\<notin> defs g n; predecessors g n = x21 # x22;\n                    x22 = []; \\<alpha>n2 g2 = \\<alpha>n g;\n                    inEdges2 g2 = inEdges' g; defs2 g2 = defs g\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g x21 v =\n                                     i.lookupDef g2 x21 v;\n        \\<alpha>n2 g2 = \\<alpha>n g; inEdges2 g2 = inEdges' g;\n        defs2 g2 = defs g\\<rbrakk>\n       \\<Longrightarrow> (if n \\<notin> set (\\<alpha>n g) then undefined\n                          else if v \\<in> defs g n then (v, n, SimpleDef)\n                               else case predecessors g n of\n                                    [] \\<Rightarrow> (v, n, PhiDef)\n                                    | [m] \\<Rightarrow> lookupDef g m v\n                                    | m # aa # lista \\<Rightarrow>\n  (v, n, PhiDef)) =\n                         i.lookupDef g2 n v", "apply (subst i.lookupDef.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g n v.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>\\<not> n \\<notin> set (\\<alpha>n g);\n                    v \\<notin> defs g n; predecessors g n = x21 # x22;\n                    x22 = []; \\<alpha>n2 g2 = \\<alpha>n g;\n                    inEdges2 g2 = inEdges' g; defs2 g2 = defs g\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g x21 v =\n                                     i.lookupDef g2 x21 v;\n        \\<alpha>n2 g2 = \\<alpha>n g; inEdges2 g2 = inEdges' g;\n        defs2 g2 = defs g\\<rbrakk>\n       \\<Longrightarrow> (if n \\<notin> set (\\<alpha>n g) then undefined\n                          else if v \\<in> defs g n then (v, n, SimpleDef)\n                               else case predecessors g n of\n                                    [] \\<Rightarrow> (v, n, PhiDef)\n                                    | [m] \\<Rightarrow> lookupDef g m v\n                                    | m # aa # lista \\<Rightarrow>\n  (v, n, PhiDef)) =\n                         (if n \\<notin> set (\\<alpha>n2 g2) then undefined\n                          else if v \\<in> defs2 g2 n then (v, n, SimpleDef)\n                               else case i.predecessors g2 n of\n                                    [] \\<Rightarrow> (v, n, PhiDef)\n                                    | [m] \\<Rightarrow> i.lookupDef g2 m v\n                                    | m # aa # lista \\<Rightarrow>\n  (v, n, PhiDef))", "apply (subgoal_tac \"i.predecessors g2 n = predecessors g n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>g n v.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>\\<not> n \\<notin> set (\\<alpha>n g);\n                    v \\<notin> defs g n; predecessors g n = x21 # x22;\n                    x22 = []; \\<alpha>n2 g2 = \\<alpha>n g;\n                    inEdges2 g2 = inEdges' g; defs2 g2 = defs g\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g x21 v =\n                                     i.lookupDef g2 x21 v;\n        \\<alpha>n2 g2 = \\<alpha>n g; inEdges2 g2 = inEdges' g;\n        defs2 g2 = defs g; i.predecessors g2 n = predecessors g n\\<rbrakk>\n       \\<Longrightarrow> (if n \\<notin> set (\\<alpha>n g) then undefined\n                          else if v \\<in> defs g n then (v, n, SimpleDef)\n                               else case predecessors g n of\n                                    [] \\<Rightarrow> (v, n, PhiDef)\n                                    | [m] \\<Rightarrow> lookupDef g m v\n                                    | m # aa # lista \\<Rightarrow>\n  (v, n, PhiDef)) =\n                         (if n \\<notin> set (\\<alpha>n2 g2) then undefined\n                          else if v \\<in> defs2 g2 n then (v, n, SimpleDef)\n                               else case i.predecessors g2 n of\n                                    [] \\<Rightarrow> (v, n, PhiDef)\n                                    | [m] \\<Rightarrow> i.lookupDef g2 m v\n                                    | m # aa # lista \\<Rightarrow>\n  (v, n, PhiDef))\n 2. \\<And>g n v.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>\\<not> n \\<notin> set (\\<alpha>n g);\n                    v \\<notin> defs g n; predecessors g n = x21 # x22;\n                    x22 = []; \\<alpha>n2 g2 = \\<alpha>n g;\n                    inEdges2 g2 = inEdges' g; defs2 g2 = defs g\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g x21 v =\n                                     i.lookupDef g2 x21 v;\n        \\<alpha>n2 g2 = \\<alpha>n g; inEdges2 g2 = inEdges' g;\n        defs2 g2 = defs g\\<rbrakk>\n       \\<Longrightarrow> i.predecessors g2 n = predecessors g n", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>g n v.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>\\<not> n \\<notin> set (\\<alpha>n g);\n                    v \\<notin> defs g n; predecessors g n = x21 # x22;\n                    x22 = []; \\<alpha>n2 g2 = \\<alpha>n g;\n                    inEdges2 g2 = inEdges' g; defs2 g2 = defs g\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g x21 v =\n                                     i.lookupDef g2 x21 v;\n        \\<alpha>n2 g2 = \\<alpha>n g; inEdges2 g2 = inEdges' g;\n        defs2 g2 = defs g\\<rbrakk>\n       \\<Longrightarrow> i.predecessors g2 n = predecessors g n\n 2. \\<And>g n v.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>\\<not> n \\<notin> set (\\<alpha>n g);\n                    v \\<notin> defs g n; predecessors g n = x21 # x22;\n                    x22 = []; \\<alpha>n2 g2 = \\<alpha>n g;\n                    inEdges2 g2 = inEdges' g; defs2 g2 = defs g\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g x21 v =\n                                     i.lookupDef g2 x21 v;\n        \\<alpha>n2 g2 = \\<alpha>n g; inEdges2 g2 = inEdges' g;\n        defs2 g2 = defs g; i.predecessors g2 n = predecessors g n\\<rbrakk>\n       \\<Longrightarrow> (if n \\<notin> set (\\<alpha>n g) then undefined\n                          else if v \\<in> defs g n then (v, n, SimpleDef)\n                               else case predecessors g n of\n                                    [] \\<Rightarrow> (v, n, PhiDef)\n                                    | [m] \\<Rightarrow> lookupDef g m v\n                                    | m # aa # lista \\<Rightarrow>\n  (v, n, PhiDef)) =\n                         (if n \\<notin> set (\\<alpha>n2 g2) then undefined\n                          else if v \\<in> defs2 g2 n then (v, n, SimpleDef)\n                               else case i.predecessors g2 n of\n                                    [] \\<Rightarrow> (v, n, PhiDef)\n                                    | [m] \\<Rightarrow> i.lookupDef g2 m v\n                                    | m # aa # lista \\<Rightarrow>\n  (v, n, PhiDef))", "apply (clarsimp simp: i.predecessors_def predecessors_def i.inEdges_def inEdges_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g n v.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>\\<not> n \\<notin> set (\\<alpha>n g);\n                    v \\<notin> defs g n; predecessors g n = x21 # x22;\n                    x22 = []; \\<alpha>n2 g2 = \\<alpha>n g;\n                    inEdges2 g2 = inEdges' g; defs2 g2 = defs g\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g x21 v =\n                                     i.lookupDef g2 x21 v;\n        \\<alpha>n2 g2 = \\<alpha>n g; inEdges2 g2 = inEdges' g;\n        defs2 g2 = defs g; i.predecessors g2 n = predecessors g n\\<rbrakk>\n       \\<Longrightarrow> (if n \\<notin> set (\\<alpha>n g) then undefined\n                          else if v \\<in> defs g n then (v, n, SimpleDef)\n                               else case predecessors g n of\n                                    [] \\<Rightarrow> (v, n, PhiDef)\n                                    | [m] \\<Rightarrow> lookupDef g m v\n                                    | m # aa # lista \\<Rightarrow>\n  (v, n, PhiDef)) =\n                         (if n \\<notin> set (\\<alpha>n2 g2) then undefined\n                          else if v \\<in> defs2 g2 n then (v, n, SimpleDef)\n                               else case i.predecessors g2 n of\n                                    [] \\<Rightarrow> (v, n, PhiDef)\n                                    | [m] \\<Rightarrow> i.lookupDef g2 m v\n                                    | m # aa # lista \\<Rightarrow>\n  (v, n, PhiDef))", "by (simp cong: if_cong list.case_cong)"], ["proof (state)\nthis:\n  lookupDef g n v = i.lookupDef g2 n v\n\ngoal (1 subgoal):\n 1. (G ===> (=)) lookupDef i.lookupDef", "}"], ["proof (state)\nthis:\n  G ?g3 ?g2.3 \\<Longrightarrow>\n  lookupDef ?g3 ?n3 ?v3 = i.lookupDef ?g2.3 ?n3 ?v3\n\ngoal (1 subgoal):\n 1. (G ===> (=)) lookupDef i.lookupDef", "thus ?thesis"], ["proof (prove)\nusing this:\n  G ?g3 ?g2.3 \\<Longrightarrow>\n  lookupDef ?g3 ?n3 ?v3 = i.lookupDef ?g2.3 ?n3 ?v3\n\ngoal (1 subgoal):\n 1. (G ===> (=)) lookupDef i.lookupDef", "by blast"], ["proof (state)\nthis:\n  (G ===> (=)) lookupDef i.lookupDef\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma defs'_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses uses2\"\n  shows \"(G ===> (=)) defs' (CFG_Construct.defs' defs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) defs' (CFG_Construct.defs' defs2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) defs' (CFG_Construct.defs' defs2)", "interpret i: CFG_Construct \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_Construct \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2", "by transfer' unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) defs' i.defs'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) defs' i.defs'", "unfolding defs'_def [abs_def] i.defs'_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) (\\<lambda>g n. (\\<lambda>v. (v, n, SimpleDef)) ` defs g n)\n     (\\<lambda>g n. (\\<lambda>v. (v, n, SimpleDef)) ` defs2 g n)", "by transfer_prover"], ["proof (state)\nthis:\n  (G ===> (=)) defs' i.defs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma uses'_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses uses2\"\n  shows \"(G ===> (=)) uses' (CFG_Construct.uses' \\<alpha>n2 inEdges2 defs2 uses2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) uses' (CFG_Construct.uses' \\<alpha>n2 inEdges2 defs2 uses2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) uses' (CFG_Construct.uses' \\<alpha>n2 inEdges2 defs2 uses2)", "interpret i: CFG_Construct \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_Construct \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2", "by transfer' unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) uses' i.uses'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) uses' i.uses'", "unfolding uses'_def [abs_def] i.uses'_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) (\\<lambda>g n. lookupDef g n ` uses g n)\n     (\\<lambda>g n. i.lookupDef g n ` uses2 g n)", "by transfer_prover"], ["proof (state)\nthis:\n  (G ===> (=)) uses' i.uses'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma phis'_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses uses2\"\n  shows \"(G ===> (=)) phis' (CFG_Construct.phis' \\<alpha>n2 inEdges2 defs2 uses2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) phis' (CFG_Construct.phis' \\<alpha>n2 inEdges2 defs2 uses2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) phis' (CFG_Construct.phis' \\<alpha>n2 inEdges2 defs2 uses2)", "interpret i: CFG_Construct \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_Construct \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2", "by transfer' unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) phis' i.phis'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) phis' i.phis'", "unfolding phis'_def [abs_def] i.phis'_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=))\n     (\\<lambda>g (n, v, m, def).\n         if m = n \\<and>\n            n \\<in> phiDefNodes g v \\<and>\n            v \\<in> vars g \\<and> def = PhiDef\n         then Some (map (\\<lambda>m. lookupDef g m v) (predecessors g n))\n         else None)\n     (\\<lambda>g (n, v, m, def).\n         if m = n \\<and>\n            n \\<in> i.phiDefNodes g v \\<and>\n            v \\<in> i.vars g \\<and> def = PhiDef\n         then Some\n               (map (\\<lambda>m. i.lookupDef g m v) (i.predecessors g n))\n         else None)", "by transfer_prover"], ["proof (state)\nthis:\n  (G ===> (=)) phis' i.phis'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas CFG_Construct_transfer_rules =\n  phiDefNodes_aux_transfer\n  phiDefNodes_transfer\n  lookupDef_transfer\n  defs'_transfer\n  uses'_transfer\n  phis'_transfer"], ["", "end"], ["", "end"], ["", "context CFG_SSA_base begin"], ["", "context includes lifting_syntax\nbegin"], ["", "lemma phiDefs_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses uses2\"\n    and [transfer_rule]: \"(G ===> (=)) phis phis2\"\n  shows \"(G ===> (=)) phiDefs (CFG_SSA_base.phiDefs phis2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) phiDefs (CFG_SSA_base.phiDefs phis2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) phiDefs (CFG_SSA_base.phiDefs phis2)", "interpret i: CFG_SSA_base \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2 phis2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) phiDefs i.phiDefs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) phiDefs i.phiDefs", "unfolding phiDefs_def [abs_def] i.phiDefs_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) (\\<lambda>g n. {v. (n, v) \\<in> dom (phis g)})\n     (\\<lambda>g n. {v. (n, v) \\<in> dom (phis2 g)})", "by transfer_prover"], ["proof (state)\nthis:\n  (G ===> (=)) phiDefs i.phiDefs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma allDefs_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs (defs2::'a \\<Rightarrow> 'node \\<Rightarrow> 'val set)\"\n    and [transfer_rule]: \"(G ===> (=)) uses (uses2::'a \\<Rightarrow> 'node \\<Rightarrow> 'val set)\"\n    and [transfer_rule]: \"(G ===> (=)) phis phis2\"\n  shows \"(G ===> (=)) allDefs (CFG_SSA_base.allDefs defs2 phis2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) allDefs (CFG_SSA_base.allDefs defs2 phis2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) allDefs (CFG_SSA_base.allDefs defs2 phis2)", "interpret i: CFG_SSA_base \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2 phis2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) allDefs i.allDefs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) allDefs i.allDefs", "unfolding allDefs_def [abs_def] i.allDefs_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) (\\<lambda>g n. defs g n \\<union> phiDefs g n)\n     (\\<lambda>g n. defs2 g n \\<union> i.phiDefs g n)", "by transfer_prover"], ["proof (state)\nthis:\n  (G ===> (=)) allDefs i.allDefs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma phiUses_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses uses2\"\n    and [transfer_rule]: \"(G ===> (=)) phis phis2\"\n  shows \"(G ===> (=)) phiUses (CFG_SSA_base.phiUses \\<alpha>n2 inEdges2 phis2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) phiUses (CFG_SSA_base.phiUses \\<alpha>n2 inEdges2 phis2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) phiUses (CFG_SSA_base.phiUses \\<alpha>n2 inEdges2 phis2)", "interpret i: CFG_SSA_base \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2 phis2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) phiUses i.phiUses", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) phiUses i.phiUses", "unfolding phiUses_def [abs_def] i.phiUses_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=))\n     (\\<lambda>g n.\n         \\<Union>n'\\<in>set (successors g n).\n            \\<Union>v'\\<in>phiDefs g n'.\n               snd `\n               Set.filter (\\<lambda>(n'', v). n'' = n)\n                (set (zip (predecessors g n') (the (phis g (n', v'))))))\n     (\\<lambda>g n.\n         \\<Union>n'\\<in>set (i.successors g n).\n            \\<Union>v'\\<in>i.phiDefs g n'.\n               snd `\n               Set.filter (\\<lambda>(n'', v). n'' = n)\n                (set (zip (i.predecessors g n') (the (phis2 g (n', v'))))))", "by transfer_prover"], ["proof (state)\nthis:\n  (G ===> (=)) phiUses i.phiUses\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma allUses_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses uses2\"\n    and [transfer_rule]: \"(G ===> (=)) phis phis2\"\n  shows \"(G ===> (=)) allUses (CFG_SSA_base.allUses \\<alpha>n2 inEdges2 uses2 phis2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) allUses\n     (CFG_SSA_base.allUses \\<alpha>n2 inEdges2 uses2 phis2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) allUses\n     (CFG_SSA_base.allUses \\<alpha>n2 inEdges2 uses2 phis2)", "interpret i: CFG_SSA_base \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2 phis2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) allUses i.allUses", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) allUses i.allUses", "unfolding allUses_def [abs_def] i.allUses_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) (\\<lambda>g n. uses g n \\<union> phiUses g n)\n     (\\<lambda>g n. uses2 g n \\<union> i.phiUses g n)", "by transfer_prover"], ["proof (state)\nthis:\n  (G ===> (=)) allUses i.allUses\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma allVars_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses uses2\"\n    and [transfer_rule]: \"(G ===> (=)) phis phis2\"\n  shows \"(G ===> (=)) allVars (CFG_SSA_base.allVars \\<alpha>n2 inEdges2 defs2 uses2 phis2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) allVars\n     (CFG_SSA_base.allVars \\<alpha>n2 inEdges2 defs2 uses2 phis2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) allVars\n     (CFG_SSA_base.allVars \\<alpha>n2 inEdges2 defs2 uses2 phis2)", "interpret i: CFG_SSA_base \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2 phis2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) allVars i.allVars", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) allVars i.allVars", "unfolding allVars_def [abs_def] i.allVars_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=))\n     (\\<lambda>g.\n         \\<Union>n\\<in>set (\\<alpha>n g). allDefs g n \\<union> allUses g n)\n     (\\<lambda>g.\n         \\<Union>n\\<in>set (\\<alpha>n2 g).\n            i.allDefs g n \\<union> i.allUses g n)", "by transfer_prover"], ["proof (state)\nthis:\n  (G ===> (=)) allVars i.allVars\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma defAss_transfer [transfer_rule]:\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses uses2\"\n    and [transfer_rule]: \"(G ===> (=)) phis phis2\"\n  shows \"(G ===> (=)) defAss (CFG_SSA_base.defAss \\<alpha>n2 invar2 inEdges2 Entry2 defs2 phis2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) defAss\n     (CFG_SSA_base.defAss \\<alpha>n2 invar2 inEdges2 Entry2 defs2 phis2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) defAss\n     (CFG_SSA_base.defAss \\<alpha>n2 invar2 inEdges2 Entry2 defs2 phis2)", "interpret i: CFG_SSA_base \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2 phis2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. (G ===> (=)) defAss i.defAss", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) defAss i.defAss", "unfolding defAss_def [abs_def] i.defAss_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=))\n     (\\<lambda>g m v.\n         \\<forall>ns.\n            g \\<turnstile> Entry g-ns\\<rightarrow>m \\<longrightarrow>\n            (\\<exists>n\\<in>set ns. v \\<in> allDefs g n))\n     (\\<lambda>g m v.\n         \\<forall>ns.\n            i.path2 g (Entry2 g) ns m \\<longrightarrow>\n            (\\<exists>n\\<in>set ns. v \\<in> i.allDefs g n))", "by transfer_prover"], ["proof (state)\nthis:\n  (G ===> (=)) defAss i.defAss\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas CFG_SSA_base_transfer_rules =\n  phiDefs_transfer\n  allDefs_transfer\n  phiUses_transfer\n  allUses_transfer\n  allVars_transfer\n  defAss_transfer"], ["", "end"], ["", "end"], ["", "context CFG_SSA_base_code begin"], ["", "lemma CFG_SSA_base_code_transfer_rules [transfer_rule]:\n  includes lifting_syntax\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges' inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses uses2\"\n    and [transfer_rule]: \"(G ===> (=)) phis phis2\"\n  shows \"(G ===> (=)) phiDefs (CFG_SSA_base.phiDefs (\\<lambda>g. Mapping.lookup (phis2 g)))\"\n        \"(G ===> (=)) allDefs (CFG_SSA_base.allDefs defs2 (\\<lambda>g. Mapping.lookup (phis2 g)))\"\n        \"(G ===> (=)) phiUses (CFG_SSA_base.phiUses \\<alpha>n2 inEdges2 (\\<lambda>g. Mapping.lookup (phis2 g)))\"\n        \"(G ===> (=)) allUses (CFG_SSA_base.allUses \\<alpha>n2 inEdges2 (usesOf \\<circ> uses2) (\\<lambda>g. Mapping.lookup (phis2 g)))\"\n        \"(G ===> (=)) defAss (CFG_SSA_base.defAss \\<alpha>n2 invar2 inEdges2 Entry2 defs2 (\\<lambda>g. Mapping.lookup (phis2 g)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((G ===> (=)) phiDefs\n      (CFG_SSA_base.phiDefs (\\<lambda>g. Mapping.lookup (phis2 g))) &&&\n     (G ===> (=)) allDefs\n      (CFG_SSA_base.allDefs defs2\n        (\\<lambda>g. Mapping.lookup (phis2 g)))) &&&\n    (G ===> (=)) phiUses\n     (CFG_SSA_base.phiUses \\<alpha>n2 inEdges2\n       (\\<lambda>g. Mapping.lookup (phis2 g))) &&&\n    (G ===> (=)) allUses\n     (CFG_SSA_base.allUses \\<alpha>n2 inEdges2 (usesOf \\<circ> uses2)\n       (\\<lambda>g. Mapping.lookup (phis2 g))) &&&\n    (G ===> (=)) defAss\n     (CFG_SSA_base.defAss \\<alpha>n2 invar2 inEdges2 Entry2 defs2\n       (\\<lambda>g. Mapping.lookup (phis2 g)))", "apply (simp add: CFG_SSA_base.CFG_SSA_defs[abs_def], transfer_prover)"], ["proof (prove)\ngoal (4 subgoals):\n 1. (G ===> (=)) allDefs\n     (CFG_SSA_base.allDefs defs2 (\\<lambda>g. Mapping.lookup (phis2 g)))\n 2. (G ===> (=)) phiUses\n     (CFG_SSA_base.phiUses \\<alpha>n2 inEdges2\n       (\\<lambda>g. Mapping.lookup (phis2 g)))\n 3. (G ===> (=)) allUses\n     (CFG_SSA_base.allUses \\<alpha>n2 inEdges2 (usesOf \\<circ> uses2)\n       (\\<lambda>g. Mapping.lookup (phis2 g)))\n 4. (G ===> (=)) defAss\n     (CFG_SSA_base.defAss \\<alpha>n2 invar2 inEdges2 Entry2 defs2\n       (\\<lambda>g. Mapping.lookup (phis2 g)))", "apply (simp add: CFG_SSA_base.CFG_SSA_defs[abs_def], transfer_prover)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (G ===> (=)) phiUses\n     (CFG_SSA_base.phiUses \\<alpha>n2 inEdges2\n       (\\<lambda>g. Mapping.lookup (phis2 g)))\n 2. (G ===> (=)) allUses\n     (CFG_SSA_base.allUses \\<alpha>n2 inEdges2 (usesOf \\<circ> uses2)\n       (\\<lambda>g. Mapping.lookup (phis2 g)))\n 3. (G ===> (=)) defAss\n     (CFG_SSA_base.defAss \\<alpha>n2 invar2 inEdges2 Entry2 defs2\n       (\\<lambda>g. Mapping.lookup (phis2 g)))", "apply (simp add: CFG_SSA_base.CFG_SSA_defs[abs_def], transfer_prover)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (G ===> (=)) allUses\n     (CFG_SSA_base.allUses \\<alpha>n2 inEdges2 (usesOf \\<circ> uses2)\n       (\\<lambda>g. Mapping.lookup (phis2 g)))\n 2. (G ===> (=)) defAss\n     (CFG_SSA_base.defAss \\<alpha>n2 invar2 inEdges2 Entry2 defs2\n       (\\<lambda>g. Mapping.lookup (phis2 g)))", "apply (simp add: CFG_SSA_base.CFG_SSA_defs[abs_def], transfer_prover)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (G ===> (=)) defAss\n     (CFG_SSA_base.defAss \\<alpha>n2 invar2 inEdges2 Entry2 defs2\n       (\\<lambda>g. Mapping.lookup (phis2 g)))", "apply (simp add: CFG_SSA_base.CFG_SSA_defs[abs_def], transfer_prover)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma CFG_SSA_transfer [transfer_rule]:\n  includes lifting_syntax\n  assumes [transfer_rule]: \"right_total G\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>e1 \\<alpha>e2\"\n    and [transfer_rule]: \"(G ===> (=)) \\<alpha>n1 \\<alpha>n2\"\n    and [transfer_rule]: \"(G ===> (=)) invar1 invar2\"\n    and [transfer_rule]: \"(G ===> (=)) inEdges1 inEdges2\"\n    and [transfer_rule]: \"(G ===> (=)) Entry1 Entry2\"\n    and [transfer_rule]: \"(G ===> (=)) defs1 defs2\"\n    and [transfer_rule]: \"(G ===> (=)) uses1 uses2\"\n    and [transfer_rule]: \"(G ===> (=)) phis1 phis2\"\n  shows \"CFG_SSA  \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1 phis1\n    \\<longrightarrow> CFG_SSA  \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2 phis2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_SSA \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1\n     phis1 \\<longrightarrow>\n    CFG_SSA \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2 phis2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG_SSA \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1\n     phis1 \\<longrightarrow>\n    CFG_SSA \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2 phis2", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG_SSA \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1\n     phis1 \\<longrightarrow>\n    CFG_SSA \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2 phis2", "assume \"CFG_SSA \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1 phis1\""], ["proof (state)\nthis:\n  CFG_SSA \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1 phis1\n\ngoal (1 subgoal):\n 1. CFG_SSA \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1\n     phis1 \\<longrightarrow>\n    CFG_SSA \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2 phis2", "then"], ["proof (chain)\npicking this:\n  CFG_SSA \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1 phis1", "interpret CFG_SSA \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1 phis1"], ["proof (prove)\nusing this:\n  CFG_SSA \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1 phis1\n\ngoal (1 subgoal):\n 1. CFG_SSA \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1 phis1", "."], ["proof (state)\ngoal (1 subgoal):\n 1. CFG_SSA \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1\n     phis1 \\<longrightarrow>\n    CFG_SSA \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2 phis2", "have ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_SSA \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1\n     phis1 \\<longrightarrow>\n    CFG_SSA \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2 phis2", "unfolding CFG_SSA_def [abs_def] CFG_SSA_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1 \\<and>\n    ((\\<forall>g. finite (dom (phis1 g))) \\<and>\n     (\\<forall>g n v vs.\n         phis1 g (n, v) = Some vs \\<longrightarrow>\n         n \\<in> set (\\<alpha>n1 g))) \\<and>\n    (\\<forall>g n v args.\n        phis1 g (n, v) = Some args \\<longrightarrow>\n        length (predecessors g n) = length args) \\<and>\n    (\\<forall>n g.\n        n \\<in> set (\\<alpha>n1 g) \\<longrightarrow>\n        defs1 g n \\<inter> phiDefs g n = {}) \\<and>\n    (\\<forall>n g m.\n        n \\<in> set (\\<alpha>n1 g) \\<longrightarrow>\n        m \\<in> set (\\<alpha>n1 g) \\<longrightarrow>\n        n \\<noteq> m \\<longrightarrow>\n        allDefs g n \\<inter> allDefs g m = {}) \\<longrightarrow>\n    CFG \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2 \\<and>\n    ((\\<forall>g. finite (dom (phis2 g))) \\<and>\n     (\\<forall>g n v vs.\n         phis2 g (n, v) = Some vs \\<longrightarrow>\n         n \\<in> set (\\<alpha>n2 g))) \\<and>\n    (\\<forall>g n v args.\n        phis2 g (n, v) = Some args \\<longrightarrow>\n        length (graph_path_base.predecessors inEdges2 g n) =\n        length args) \\<and>\n    (\\<forall>n g.\n        n \\<in> set (\\<alpha>n2 g) \\<longrightarrow>\n        defs2 g n \\<inter> CFG_SSA_base.phiDefs phis2 g n = {}) \\<and>\n    (\\<forall>n g m.\n        n \\<in> set (\\<alpha>n2 g) \\<longrightarrow>\n        m \\<in> set (\\<alpha>n2 g) \\<longrightarrow>\n        n \\<noteq> m \\<longrightarrow>\n        CFG_SSA_base.allDefs defs2 phis2 g n \\<inter>\n        CFG_SSA_base.allDefs defs2 phis2 g m =\n        {})", "by transfer_prover"], ["proof (state)\nthis:\n  CFG_SSA \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1\n   phis1 \\<longrightarrow>\n  CFG_SSA \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2 phis2\n\ngoal (1 subgoal):\n 1. CFG_SSA \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1\n     phis1 \\<longrightarrow>\n    CFG_SSA \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2 phis2", "}"], ["proof (state)\nthis:\n  CFG_SSA \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1\n   phis1 \\<Longrightarrow>\n  CFG_SSA \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1\n   phis1 \\<longrightarrow>\n  CFG_SSA \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2 phis2\n\ngoal (1 subgoal):\n 1. CFG_SSA \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1\n     phis1 \\<longrightarrow>\n    CFG_SSA \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2 phis2", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFG_SSA \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1\n   phis1 \\<Longrightarrow>\n  CFG_SSA \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1\n   phis1 \\<longrightarrow>\n  CFG_SSA \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2 phis2\n\ngoal (1 subgoal):\n 1. CFG_SSA \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1\n     phis1 \\<longrightarrow>\n    CFG_SSA \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2 phis2", "by simp"], ["proof (state)\nthis:\n  CFG_SSA \\<alpha>e1 \\<alpha>n1 invar1 inEdges1 Entry1 defs1 uses1\n   phis1 \\<longrightarrow>\n  CFG_SSA \\<alpha>e2 \\<alpha>n2 invar2 inEdges2 Entry2 defs2 uses2 phis2\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}